/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - logging support
=============================================================================*/

#ifndef VCOS_LOGGING_H
#define VCOS_LOGGING_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"
#include "vcos_logging_control.h"

/**
 * \file
 *
 * Logging support
 *
 * This provides categorised logging. Clients register
 * a category, and then get a number of logging levels for
 * that category.
 *
 * The logging level flag is tested using a flag *before* the
 * function call, which makes logging very fast when disabled - there
 * is no function call overhead just to find out that this log
 * message is disabled.
 *
 * \section VCOS_LOG_CATEGORY
 *
 * As a convenience, clients define VCOS_LOG_CATEGORY to point to
 * their category; the various vcos_log_xxx() macros then expand to
 * use this.
 *
 * e.g.
 *
 *     #define VCOS_LOG_CATEGORY (&my_category)
 *
 *     #include <interface/vcos/vcos.h>
 *
 *     VCOS_LOG_CAT_T my_category;
 *
 *     ....
 *
 *     vcos_log_trace("Stuff happened: %d", n_stuff);
 *
 */

/** Logging levels */
typedef enum VCOS_LOG_LEVEL_T
{
   VCOS_LOG_UNINITIALIZED   = 0,
   VCOS_LOG_NEVER,
   VCOS_LOG_ERROR,
   VCOS_LOG_WARN,
   VCOS_LOG_INFO,
   VCOS_LOG_TRACE,
} VCOS_LOG_LEVEL_T;


/** Initialize a logging category without going through vcos_log_register().
 *
 * This is useful for the case where there is no obvious point to do the
 * registration (no initialization function for the module). However, it
 * means that your logging category is not registered, so cannot be easily
 * changed at run-time.
 */
#define VCOS_LOG_INIT(n,l) { l, n, 0, {0}, 0, 0 }

/** A registered logging category.
  */
typedef struct VCOS_LOG_CAT_T
{
   VCOS_LOG_LEVEL_T level;      /**< Which levels are enabled for this category */
   const char *name;            /**< Name for this category. */
   struct VCOS_LOG_CAT_T *next;
   struct {
      unsigned int want_prefix:1;
   } flags;
   unsigned int refcount;
   void *platform_data;         /**< platform specific data */
} VCOS_LOG_CAT_T;

typedef void (*VCOS_VLOG_IMPL_FUNC_T)(const VCOS_LOG_CAT_T *cat, VCOS_LOG_LEVEL_T _level, const char *fmt, va_list args);

/** Convert a VCOS_LOG_LEVEL_T into a printable string.
  * The platform needs to implement this function.
  */
VCOSPRE_ const char * VCOSPOST_ vcos_log_level_to_string( VCOS_LOG_LEVEL_T level );

/** Convert a string into a VCOS_LOG_LEVEL_T
  * The platform needs to implement this function.
  */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_string_to_log_level( const char *str, VCOS_LOG_LEVEL_T *level );

/** Log a message. Basic API. Normal code should not use this.
  * The platform needs to implement this function.
  */
VCOSPRE_ void VCOSPOST_ vcos_log_impl(const VCOS_LOG_CAT_T *cat, VCOS_LOG_LEVEL_T _level, const char *fmt, ...) VCOS_FORMAT_ATTR_(printf, 3, 4);

/** Log a message using a varargs parameter list. Normal code should
  * not use this.
  */
VCOSPRE_ void VCOSPOST_ vcos_vlog_impl(const VCOS_LOG_CAT_T *cat, VCOS_LOG_LEVEL_T _level, const char *fmt, va_list args) VCOS_FORMAT_ATTR_(printf, 3, 0);

/** Set the function which does the actual logging output.
 *  Passing in NULL causes the default logging function to be
 *  used.
  */
VCOSPRE_ void VCOSPOST_ vcos_set_vlog_impl( VCOS_VLOG_IMPL_FUNC_T vlog_impl_func );

/** The default logging function, which is provided by each
  * platform.
  */

VCOSPRE_ void VCOSPOST_ vcos_vlog_default_impl(const VCOS_LOG_CAT_T *cat, VCOS_LOG_LEVEL_T _level, const char *fmt, va_list args) VCOS_FORMAT_ATTR_(printf, 3, 0);

/*
 * Initialise the logging subsystem. This is called from
 * vcos_init() so you don't normally need to call it.
 */
VCOSPRE_ void VCOSPOST_ vcos_logging_init(void);

/** Register a logging category.
  *
  * @param name the name of this category.
  * @param category the category to register.
  */
VCOSPRE_ void VCOSPOST_ vcos_log_register(const char *name, VCOS_LOG_CAT_T *category);

/** Unregister a logging category.
  */
VCOSPRE_ void VCOSPOST_ vcos_log_unregister(VCOS_LOG_CAT_T *category);

/** Return a default logging category, for people too lazy to create their own.
  *
  * Using the default category will be slow (there's an extra function
  * call overhead). Don't do this in normal code.
  */
VCOSPRE_ const VCOS_LOG_CAT_T * VCOSPOST_ vcos_log_get_default_category(void);

VCOSPRE_ void VCOSPOST_ vcos_set_log_options(const char *opt);

/** Set the logging level for a category at run time. Without this, the level
  * will be that set by vcos_log_register from a platform-specific source.
  *
  * @param category the category to modify.
  * @param level the new logging level for this category.
  */
VCOS_STATIC_INLINE void vcos_log_set_level(VCOS_LOG_CAT_T *category, VCOS_LOG_LEVEL_T level)
{
   category->level = level;
}

#define vcos_log_dump_mem(cat,label,addr,voidMem,numBytes)  do { if (vcos_is_log_enabled(cat,VCOS_LOG_TRACE)) vcos_log_dump_mem_impl(cat,label,addr,voidMem,numBytes); } while (0)

void vcos_log_dump_mem_impl( const VCOS_LOG_CAT_T *cat,
                             const char           *label,
                             uint32_t              addr,
                             const void           *voidMem,
                             size_t                numBytes );

/*
 * Platform specific hooks (optional).
 */
#ifndef vcos_log_platform_init
#define vcos_log_platform_init()                (void)0
#endif

#ifndef vcos_log_platform_register
#define vcos_log_platform_register(category)    (void)0
#endif

#ifndef vcos_log_platform_unregister
#define vcos_log_platform_unregister(category)  (void)0
#endif

/* VCOS_TRACE() - deprecated macro which just outputs in a debug build and
 * is a no-op in a release build.
 *
 * _VCOS_LOG_X() - internal macro which outputs if the current level for the
 * particular category is higher than the supplied message level.
 */

#define VCOS_LOG_DFLT_CATEGORY vcos_log_get_default_category()

#define _VCOS_LEVEL(x) (x)

#define vcos_is_log_enabled(cat,_level)  (_VCOS_LEVEL((cat)->level) >= _VCOS_LEVEL(_level))

#if defined(_VCOS_METAWARE) || defined(__GNUC__)

# if !defined(AMPUTATE_ALL_VCOS_LOGGING) && (!defined(NDEBUG) || defined(VCOS_ALWAYS_WANT_LOGGING))
#  define VCOS_LOGGING_ENABLED
#  define _VCOS_LOG_X(cat, _level, fmt...)   do { if (vcos_is_log_enabled(cat,_level)) vcos_log_impl(cat,_level,fmt); } while (0)
#  define _VCOS_VLOG_X(cat, _level, fmt, ap) do { if (vcos_is_log_enabled(cat,_level)) vcos_vlog_impl(cat,_level,fmt,ap); } while (0)
# else
#  define _VCOS_LOG_X(cat, _level, fmt...) (void)0
#  define _VCOS_VLOG_X(cat, _level, fmt, ap) (void)0
# endif



# define vcos_log_error(...)   _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_ERROR, __VA_ARGS__)
# define vcos_log_warn(...)    _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_WARN, __VA_ARGS__)
# define vcos_log_info(...)    _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_INFO, __VA_ARGS__)
# define vcos_log_trace(...)   _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_TRACE, __VA_ARGS__)

# define vcos_vlog_error(fmt,ap)  _VCOS_VLOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_ERROR, fmt, ap)
# define vcos_vlog_warn(fmt,ap)   _VCOS_VLOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_WARN, fmt, ap)
# define vcos_vlog_info(fmt,ap)   _VCOS_VLOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_INFO, fmt, ap)
# define vcos_vlog_trace(fmt,ap)  _VCOS_VLOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_TRACE, fmt, ap)

# define vcos_logc_error(cat,...)   _VCOS_LOG_X(cat, VCOS_LOG_ERROR, __VA_ARGS__)
# define vcos_logc_warn(cat,...)    _VCOS_LOG_X(cat, VCOS_LOG_WARN, __VA_ARGS__)
# define vcos_logc_info(cat,...)    _VCOS_LOG_X(cat, VCOS_LOG_INFO, __VA_ARGS__)
# define vcos_logc_trace(cat,...)   _VCOS_LOG_X(cat, VCOS_LOG_TRACE, __VA_ARGS__)

# define vcos_vlogc_error(cat,fmt,ap)  _VCOS_VLOG_X(cat, VCOS_LOG_ERROR, fmt, ap)
# define vcos_vlogc_warn(cat,fmt,ap)   _VCOS_VLOG_X(cat, VCOS_LOG_WARN, fmt, ap)
# define vcos_vlogc_info(cat,fmt,ap)   _VCOS_VLOG_X(cat, VCOS_LOG_INFO, fmt, ap)
# define vcos_vlogc_trace(cat,fmt,ap)  _VCOS_VLOG_X(cat, VCOS_LOG_TRACE, fmt, ap)

# define vcos_log(...)   _VCOS_LOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_INFO, __VA_ARGS__)
# define vcos_vlog(fmt,ap)  _VCOS_VLOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_INFO, fmt, ap)
# define VCOS_ALERT(...) _VCOS_LOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_ERROR, __VA_ARGS__)
# define VCOS_TRACE(...) _VCOS_LOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_INFO, __VA_ARGS__)

/*
 * MS Visual Studio - pre 2005 does not grok variadic macros
 */
#elif defined(_MSC_VER)

# if _MSC_VER >= 1400

#  if !defined(AMPUTATE_ALL_VCOS_LOGGING) && (!defined(NDEBUG) || defined(VCOS_ALWAYS_WANT_LOGGING))
#   define VCOS_LOGGING_ENABLED
#   define _VCOS_LOG_X(cat, _level, fmt,...) do { if (vcos_is_log_enabled(cat,_level)) vcos_log_impl(cat, _level, fmt, __VA_ARGS__); } while (0)
#  else
#   define _VCOS_LOG_X(cat, _level, fmt,...) (void)0
#  endif

# define vcos_log_error(fmt,...)   _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_ERROR, fmt, __VA_ARGS__)
# define vcos_log_warn(fmt,...)    _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_WARN, fmt, __VA_ARGS__)
# define vcos_log_info(fmt,...)    _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_INFO, fmt, __VA_ARGS__)
# define vcos_log_trace(fmt,...)   _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_TRACE, fmt, __VA_ARGS__)

# define vcos_logc_error(cat,fmt,...)   _VCOS_LOG_X(cat, VCOS_LOG_ERROR, fmt, __VA_ARGS__)
# define vcos_logc_warn(cat,fmt,...)    _VCOS_LOG_X(cat, VCOS_LOG_WARN, fmt, __VA_ARGS__)
# define vcos_logc_info(cat,fmt,...)    _VCOS_LOG_X(cat, VCOS_LOG_INFO, fmt, __VA_ARGS__)
# define vcos_logc_trace(cat,fmt,...)   _VCOS_LOG_X(cat, VCOS_LOG_TRACE, fmt, __VA_ARGS__)

# define vcos_log(fmt,...)   _VCOS_LOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_INFO, fmt, __VA_ARGS__)
# define VCOS_ALERT(fmt,...) _VCOS_LOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_ERROR, fmt, __VA_ARGS__)
# define VCOS_TRACE(fmt,...) _VCOS_LOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_INFO, fmt, __VA_ARGS__)

# else /* _MSC_VER >= 1400 */

/* do not define these */

# endif /* _MSC_VER >= 1400 */

#endif

#if VCOS_HAVE_CMD

#include "interface/vcos/vcos_cmd.h"

/*
 * These are the log sub-commands. They're exported here for user-mode apps which 
 * may want to call these, since the "log" command isn't registered for user-mode 
 * apps (vcdbg for example, has its own log command). 
 */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_log_assert_cmd( VCOS_CMD_PARAM_T *param );
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_log_set_cmd( VCOS_CMD_PARAM_T *param );
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_log_status_cmd( VCOS_CMD_PARAM_T *param );
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_log_test_cmd( VCOS_CMD_PARAM_T *param );
#endif

#ifdef __cplusplus
}
#endif
#endif /* VCOS_LOGGING_H */


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - memory support
=============================================================================*/

#ifndef VCOS_MEM_H
#define VCOS_MEM_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

/** \file
  *
  * Memory allocation api (malloc/free equivalents) is for benefit of host
  * applications. VideoCore code should use rtos_XXX functions.
  *
  */


/** Allocate memory
  *
  * @param size Size of memory to allocate
  * @param description Description, to aid in debugging. May be ignored internally on some platforms.
  */
VCOS_INLINE_DECL
void *vcos_malloc(VCOS_UNSIGNED size, const char *description);

void *vcos_kmalloc(VCOS_UNSIGNED size, const char *description);
void *vcos_kcalloc(VCOS_UNSIGNED num, VCOS_UNSIGNED size, const char *description);

/** Allocate cleared memory
  *
  * @param num Number of items to allocate.
  * @param size Size of each item in bytes.
  * @param description Description, to aid in debugging. May be ignored internally on some platforms.
  */
VCOS_INLINE_DECL
void *vcos_calloc(VCOS_UNSIGNED num, VCOS_UNSIGNED size, const char *description);

/** Free memory
  *
  * Free memory that has been allocated.
  */
VCOS_INLINE_DECL
void vcos_free(void *ptr);

void vcos_kfree(void *ptr);

/** Allocate aligned memory
  *
  * Allocate memory aligned on the specified boundary.
  *
  * @param size Size of memory to allocate
  * @param description Description, to aid in debugging. May be ignored internally on some platforms.
  */
VCOS_INLINE_DECL
void *vcos_malloc_aligned(VCOS_UNSIGNED size, VCOS_UNSIGNED align, const char *description);

/** Return the amount of free heap memory
  *
  */
VCOS_INLINE_DECL
unsigned long vcos_get_free_mem(void);

#ifdef __cplusplus
}
#endif

#endif


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - memory pool support
=============================================================================*/

#ifndef VCOS_MEMPOOL_H
#define VCOS_MEMPOOL_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

/** \file
  *
  * Memory pools - variable sized allocator.
  *
  * A very basic memory pool API.
  *
  * This interface is deliberately not thread safe - clients should add
  * their own locking, if required.
  *
  *
  * \fixme: Add fixed-size allocator.
  *
  */


/** Initialize a memory pool. The control data is taken from the memory
  * supplied itself.
  *
  * Note: the dmalloc pool uses the memory supplied for its control
  * area. This is probably a bit broken, as it stops you creating
  * a pool in some "special" area of memory, while leaving the control
  * information in normal memory.
  *
  * @param pool  Pointer to pool object.
  *
  * @param name  Name for the pool. Used for diagnostics.
  *
  * @param start Starting address. Must be at least 8byte aligned.
  *
  * @param size  Size of pool in bytes.
  *
  * @return VCOS_SUCCESS if pool was created.
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_mempool_create(VCOS_MEMPOOL_T *pool, const char *name, void *start, VCOS_UNSIGNED size);

/** Allocate some memory from a pool. If no memory is available, it
  * returns NULL.
  *
  * @param pool Pool to allocate from
  * @param len  Length of memory to allocate
  *
  */
VCOS_INLINE_DECL
void *vcos_mempool_alloc(VCOS_MEMPOOL_T *pool, VCOS_UNSIGNED len);

/** Free some memory back to a pool.
  *
  * @param pool Pool to return to
  * @param mem Memory to return
  */
VCOS_INLINE_DECL
void vcos_mempool_free(VCOS_MEMPOOL_T *pool, void *mem);

/** Deinitialize a memory pool.
  *
  * @param pool Pool to return to
  */
VCOS_INLINE_DECL
void vcos_mempool_delete(VCOS_MEMPOOL_T *pool);

#ifdef __cplusplus
}
#endif
#endif



                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VCOS - packet-like messages, based loosely on those found in TRIPOS.

In the simple case, only the server thread creates a message queue, and
clients wait for replies on a semaphore. In more complex cases, clients can
also create message queues (not yet implemented).

Although it's possible for a thread to create multiple queues and listen
on them in turn, if you find yourself doing this it's probably a bug.
=============================================================================*/

#ifndef VCOS_MSGQUEUE_H
#define VCOS_MSGQUEUE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "vcos_types.h"
#include "vcos_platform.h"
#include "vcos_blockpool.h"

/**
 * \file
 *
 * Packet-like messages, based loosely on those found in TRIPOS and
 * derivatives thereof.
 *
 * A task can send a message *pointer* to another task, where it is
 * queued on a linked list and the task woken up. The receiving task
 * consumes all of the messages on its input queue, and optionally
 * sends back replies using the original message memory.
 *
 * A caller can wait for the reply to a specific message - any other
 * messages that arrive in the meantime are queued separately.
 *
 *
 * All messages have a standard common layout, but the payload area can
 * be used freely to extend this.
 */

#define VCOS_MSGQ_MAGIC 0x5147534d

/** Map the payload portion of a message to a structure pointer.
  */
#define VCOS_MSG_DATA(_msg) (void*)((_msg)->data)

/** Standard message ids - FIXME - these need to be done properly! */
#define VCOS_MSG_N_QUIT            1
#define VCOS_MSG_N_OPEN            2
#define VCOS_MSG_N_CLOSE           3
#define VCOS_MSG_N_PRIVATE         (1<<20)

#define VCOS_MSG_REPLY_BIT         (1<<31)

/** Make gnuc compiler be happy about pointer punning */
#ifdef __GNUC__
#define __VCOS_MAY_ALIAS __attribute__((__may_alias__))
#else
#define __VCOS_MAY_ALIAS
#endif

struct VCOS_MSG_T;

/* Replies go to one of these objects.
 */
typedef struct VCOS_MSG_WAITER_T
{
   /* When the reply is sent, this function gets called with the
    * address of the waiter.
    */
   void (*on_reply)(struct VCOS_MSG_WAITER_T *waiter,
                    struct VCOS_MSG_T *msg);
} VCOS_MSG_WAITER_T;

/** A single message queue.
  */
typedef struct VCOS_MSGQUEUE_T
{
   VCOS_MSG_WAITER_T waiter;           /**< So we can wait on a queue */
   struct VCOS_MSG_T *head;            /**< head of linked list of messages waiting on this queue */
   struct VCOS_MSG_T *tail;            /**< tail of message queue */
   VCOS_SEMAPHORE_T sem;               /**< thread waits on this for new messages */
   VCOS_MUTEX_T lock;                  /**< locks the messages list */
   int attached;                       /**< Is this attached to a thread? */
} VCOS_MSGQUEUE_T;

/** A single message
  */
typedef struct VCOS_MSG_T
{
   uint32_t magic;                     /**< Sanity checking */
   uint32_t code;                      /**< message code */
   struct VCOS_MSG_T *next;            /**< next in queue */
   VCOS_THREAD_T *src_thread;          /**< for debug */
   struct VCOS_MSG_WAITER_T *waiter;   /**< client waiter structure */
   struct VCOS_MSGQ_POOL_T *pool;      /**< Pool allocated from, or NULL */
} VCOS_MSG_T;

#define MSG_REPLY_BIT (1<<31)

/** Initialize a VCOS_MSG_T. Can also use vcos_msg_init().
 */
#define VCOS_MSG_INITIALIZER {VCOS_MSGQ_MAGIC, 0, NULL, NULL, NULL, 0}

/** A pool of messages. This contains its own waiter and
 * semaphore, as well as a blockpool for the actual memory
 * management.
 *
 * When messages are returned to the waiter, it posts the
 * semaphore.
 *
 * When waiting for a message, we just wait on the semaphore.
 * When allocating without waiting, we just try-wait on the
 * semaphore.
 *
 * If we managed to claim the semaphore, then by definition
 * there must be at least that many free messages in the
 * blockpool.
 */
typedef struct VCOS_MSGQ_POOL_T
{
   VCOS_MSG_WAITER_T waiter;
   VCOS_BLOCKPOOL_T blockpool;
   VCOS_SEMAPHORE_T sem;
   uint32_t magic;
} VCOS_MSGQ_POOL_T;

/** Initialise the library. Normally called from vcos_init().
  */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_msgq_init(void);

/** De-initialise the library. Normally called from vcos_deinit().
 */
VCOSPRE_ void VCOSPOST_ vcos_msgq_deinit(void);

/** Send a message.
 *
 * @param dest    Destination message queue
 * @param code    Message code.
 * @param msg     Pointer to message to send. Must not go out of scope before
 *                message is received (do not declare on the stack).
 */
VCOSPRE_ void VCOSPOST_ vcos_msg_send(VCOS_MSGQUEUE_T *dest, uint32_t code, VCOS_MSG_T *msg);

/** Send a message and wait for a reply.
 *
 * @param dest    Destination message queue
 * @param code    Message code.
 * @param msg     Pointer to message to send. May be declared on the stack.
 */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_msg_sendwait(VCOS_MSGQUEUE_T *queue, uint32_t code, VCOS_MSG_T *msg);

/** Wait for a message on a queue.
  */
VCOSPRE_ VCOS_MSG_T * VCOSPOST_ vcos_msg_wait(VCOS_MSGQUEUE_T *queue);

/** Peek for a message on this thread's endpoint. If a message is not
 * available, NULL is returned. If a message is available it will be
 * removed from the endpoint and returned.
 */
VCOSPRE_ VCOS_MSG_T * VCOSPOST_ vcos_msg_peek(VCOS_MSGQUEUE_T *queue);

/** Send a reply to a message
  */
VCOSPRE_ void VCOSPOST_ vcos_msg_reply(VCOS_MSG_T *msg);

/** Set the reply queue for a message. When the message is replied-to, it
 * will return to the given queue.
 *
 * @param msg      Message
 * @param queue    Message queue the message should return to
 */
VCOSPRE_ void VCOSPOST_ vcos_msg_set_source(VCOS_MSG_T *msg, VCOS_MSGQUEUE_T *queue);

/** Initialise a newly allocated message. This only needs to be called
 * for messages allocated on the stack, heap or statically. It is not
 * needed for messages allocated from a pool.
 */
VCOSPRE_ void VCOSPOST_ vcos_msg_init(VCOS_MSG_T *msg);

/** Create a message queue to wait on.
  */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_msgq_create(VCOS_MSGQUEUE_T *queue, const char *name);

/** Destroy a queue
  */
VCOSPRE_ void  VCOSPOST_ vcos_msgq_delete(VCOS_MSGQUEUE_T *queue);

/*
 * Message pools
 */

/** Create a pool of messages. Messages can be allocated from the pool and
 * sent to a message queue. Replying to the message will automatically
 * free it back to the pool.
 *
 * The pool is threadsafe.
 *
 * @param count          number of messages in the pool
 * @param payload_size   maximum message payload size, not including MSG_T.
 */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_msgq_pool_create(
   VCOS_MSGQ_POOL_T *pool,
   size_t count,
   size_t payload_size,
   const char *name);

/** Destroy a message pool.
 */
VCOSPRE_ void VCOSPOST_ vcos_msgq_pool_delete(VCOS_MSGQ_POOL_T *pool);

/** Allocate a message from a message pool.
 *
 * Note:
 *
 * If the alloc fails (returns NULL) then your worker thread has stopped
 * servicing requests or your pool is too small for the latency in
 * the system. Your best bet to handle this is to fail the call that
 * needs to send the message.
 *
 * The returned message payload area is initialised to zero.
 *
 * @param  pool  Pool to allocate from.
 * @return Message or NULL if pool exhausted.
 */
VCOSPRE_ VCOS_MSG_T *VCOSPOST_ vcos_msgq_pool_alloc(VCOS_MSGQ_POOL_T *pool);

/** Wait for a message from a message pool. Waits until a
 * message is available in the pool and then allocates it. If
 * one is already available, returns immediately.
 *
 * This call can never fail.
 *
 * The returned message payload area is initialised to zero.
 *
 * @param  pool  Pool to allocate from.
 * @return Message
 */
VCOSPRE_ VCOS_MSG_T *VCOSPOST_ vcos_msgq_pool_wait(VCOS_MSGQ_POOL_T *pool);

/** Explicitly free a message and return it to its pool.
 *
 * @param  msg  Message to free. No-op if NULL.
 */
VCOSPRE_ void VCOSPOST_ vcos_msgq_pool_free(VCOS_MSG_T *msg);

#ifdef __cplusplus
}
#endif
#endif


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - mutex public header file
=============================================================================*/

#ifndef VCOS_MUTEX_H
#define VCOS_MUTEX_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

/**
 * \file vcos_mutex.h
 *
 * Mutex API. Mutexes are not re-entrant, as supporting this adds extra code
 * that slows down clients which have been written sensibly.
 *
 * \sa vcos_reentrant_mutex.h
 *
 */

/** Create a mutex.
  *
  * @param m      Filled in with mutex on return
  * @param name   A non-null name for the mutex, used for diagnostics.
  *
  * @return VCOS_SUCCESS if mutex was created, or error code.
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_mutex_create(VCOS_MUTEX_T *m, const char *name);

/** Delete the mutex.
  */
VCOS_INLINE_DECL
void vcos_mutex_delete(VCOS_MUTEX_T *m);

/**
  * \brief Wait to claim the mutex.
  *
  * On most platforms this always returns VCOS_SUCCESS, and so would ideally be
  * a void function, however some platforms allow a wait to be interrupted so
  * it remains non-void.
  *
  * Try to obtain the mutex.
  * @param m   Mutex to wait on
  * @return VCOS_SUCCESS - mutex was taken.
  *         VCOS_EAGAIN  - could not take mutex.
  */
#ifndef vcos_mutex_lock
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_mutex_lock(VCOS_MUTEX_T *m);

/** Release the mutex.
  */
VCOS_INLINE_DECL
void vcos_mutex_unlock(VCOS_MUTEX_T *m);
#endif

/** Test if the mutex is already locked.
  *
  * @return 1 if mutex is locked, 0 if it is unlocked.
  */
VCOS_INLINE_DECL
int vcos_mutex_is_locked(VCOS_MUTEX_T *m);

/** Obtain the mutex if possible.
  *
  * @param m  the mutex to try to obtain
  *
  * @return VCOS_SUCCESS if mutex is successfully obtained, or VCOS_EAGAIN
  * if it is already in use by another thread.
  */
#ifndef vcos_mutex_trylock
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_mutex_trylock(VCOS_MUTEX_T *m);
#endif


#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - named semaphores
=============================================================================*/

#ifndef VCOS_NAMED_SEMAPHORE_H
#define VCOS_NAMED_SEMAPHORE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

/**
 * \file
 *
 * Create a named semaphore, or open an existing one by name.
 *
 */

/** 
  * \brief Create a named semaphore.
  *
  * Semaphores are not re-entrant.
  *
  * @param sem   Pointer to memory to be initialized
  * @param name  A name for this semaphore.
  * @param count The initial count for the semaphore.
  *
  * @return VCOS_SUCCESS if the semaphore was created.
  * 
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_named_semaphore_create(VCOS_NAMED_SEMAPHORE_T *sem, const char *name, VCOS_UNSIGNED count);

/**
  * \brief Wait on a named semaphore.
  *
  * There is no timeout option on a semaphore, as adding this will slow down
  * implementations on some platforms. If you need that kind of behaviour, use
  * an event group.
  *
  * This always returns VCOS_SUCCESS and so should really be a void function. However
  * too many lines of code would need to be changed in non-trivial ways, so for now
  * it is non-void.
  *
  * @param sem Semaphore to wait on
  * @return VCOS_SUCCESS - semaphore was taken.
  *
  */
VCOS_INLINE_DECL
void vcos_named_semaphore_wait(VCOS_NAMED_SEMAPHORE_T *sem);

/**
  * \brief Try to wait for a semaphore.
  *
  * Try to obtain the semaphore. If it is already taken, return VCOS_TIMEOUT.
  * @param sem Semaphore to wait on
  * @return VCOS_SUCCESS - semaphore was taken.
  *         VCOS_EAGAIN - could not take semaphore
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_named_semaphore_trywait(VCOS_NAMED_SEMAPHORE_T *sem);

/**
  * \brief Post a semaphore.
  *
  * @param sem Semaphore to wait on
  */
VCOS_INLINE_DECL
void vcos_named_semaphore_post(VCOS_NAMED_SEMAPHORE_T *sem);

/**
  * \brief Delete a semaphore, releasing any resources consumed by it.
  *
  * @param sem Semaphore to wait on
  */
void vcos_named_semaphore_delete(VCOS_NAMED_SEMAPHORE_T *sem);


#ifdef __cplusplus
}
#endif
#endif

                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - 'once'
=============================================================================*/

#ifndef VCOS_ONCE_H
#define VCOS_ONCE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

/**
 * \file vcos_once.h
 *
 * Ensure something is called only once.
 *
 * Initialize once_control to VCOS_ONCE_INIT. The first
 * time this is called, the init_routine will be called. Thereafter
 * it won't.
 *
 * \sa pthread_once()
 *
 */

VCOS_STATUS_T vcos_once(VCOS_ONCE_T *once_control,
                        void (*init_routine)(void));

#ifdef __cplusplus
}
#endif
#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - Queue public header file
=============================================================================*/

#ifndef VCOS_QUEUE_H
#define VCOS_QUEUE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

/** \file vcos_queue.h
  *
  * API for accessing a fixed length queue.
  *
  * Nucleus offers variable length items, but this feature is not used
  * in the current code base, so is withdrawn to simplify the API.
  */

/** Create a fixed length queue.
  *
  * @param queue        Pointer to queue control block
  * @param name         Name of queue
  * @param message_size Size of each queue message item in words (words are sizeof VCOS_UNSIGNED).
  * @param queue_start  Start address of queue area
  * @param queue_size   Size in words (words are sizeof VCOS_UNSIGNED) of queue
  *
  */

VCOS_INLINE_DECL
VCOS_STATUS_T vcos_queue_create(VCOS_QUEUE_T *queue,
                                const char *name,
                                VCOS_UNSIGNED message_size,
                                void *queue_start,
                                VCOS_UNSIGNED queue_size);

/** Delete a queue.
  * @param queue The queue to delete
  */
VCOS_INLINE_DECL
void vcos_queue_delete(VCOS_QUEUE_T *queue);

/** Send an item to a queue. If there is no space, the call with
  * either block waiting for space, or return an error, depending
  * on the value of the wait parameter.
  *
  * @param queue The queue to send to
  * @param src   The data to send (length set when queue was created)
  * @param wait  Whether to wait for space (VCOS_SUSPEND) or fail if
  *              no space (VCOS_NO_SUSPEND).
  *
  * @return If space available, returns VCOS_SUCCESS. Otherwise returns
  * VCOS_EAGAIN if no space available before timeout expires.
  *
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_queue_send(VCOS_QUEUE_T *queue, const void *src, VCOS_UNSIGNED wait);

/** Receive an item from a queue.
  * @param queue The queue to receive from
  * @param dst   Where to write the data to
  * @param wait  Whether to wait (VCOS_SUSPEND) or fail if
  *              empty (VCOS_NO_SUSPEND).
  *
  * @return If an item is available, returns VCOS_SUCCESS. Otherwise returns
  * VCOS_EAGAIN if no item available before timeout expires.
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_queue_receive(VCOS_QUEUE_T *queue, void *dst, VCOS_UNSIGNED wait);

#ifdef __cplusplus
}
#endif
#endif

                            /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - mutex public header file
=============================================================================*/

#ifndef VCOS_QUICKSLOW_MUTEX_H
#define VCOS_QUICKSLOW_MUTEX_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

/**
 * \file vcos_quickslow_mutex.h
 *
 * "Quick/Slow" Mutex API. This is a mutex which supports an additional "quick"
 * (spinlock-based) locking mechanism. While in this quick locked state, other
 * operating system commands will be unavailable and the caller should complete
 * whatever it has to do in a short, bounded length of time (as the spinlock
 * completely locks out other system activity).
 *
 * \sa vcos_mutex.h
 *
 */

/** Create a mutex.
  *
  * @param m      Filled in with mutex on return
  * @param name   A non-null name for the mutex, used for diagnostics.
  *
  * @return VCOS_SUCCESS if mutex was created, or error code.
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_quickslow_mutex_create(VCOS_QUICKSLOW_MUTEX_T *m, const char *name);

/** Delete the mutex.
  */
VCOS_INLINE_DECL
void vcos_quickslow_mutex_delete(VCOS_QUICKSLOW_MUTEX_T *m);

/**
  * \brief Wait to claim the mutex ("slow" mode).
  *
  * Obtain the mutex.
  */
VCOS_INLINE_DECL
void vcos_quickslow_mutex_lock(VCOS_QUICKSLOW_MUTEX_T *m);

/** Release the mutex ("slow" mode).
  */
VCOS_INLINE_DECL
void vcos_quickslow_mutex_unlock(VCOS_QUICKSLOW_MUTEX_T *m);

/**
  * \brief Wait to claim the mutex ("quick" mode).
  *
  * Obtain the mutex. The caller must not call any OS functions or do anything
  * "slow" before the corresponding call to vcos_mutex_quickslow_unlock_quick.
  */
VCOS_INLINE_DECL
void vcos_quickslow_mutex_lock_quick(VCOS_QUICKSLOW_MUTEX_T *m);

/** Release the mutex ("quick" mode).
  */
VCOS_INLINE_DECL
void vcos_quickslow_mutex_unlock_quick(VCOS_QUICKSLOW_MUTEX_T *m);


#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - reentrant mutex public header file
=============================================================================*/

#ifndef VCOS_REENTRANT_MUTEX_H
#define VCOS_REENTRANT_MUTEX_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

/**
 * \file
 *
 * Reentrant Mutex API. You can take one of these mutexes even if you've already
 * taken it. Just to make sure.
 *
 * A re-entrant mutex may be slower on some platforms than a regular one.
 *
 * \sa vcos_mutex.h
 *
 */

/** Create a mutex.
  *
  * @param m      Filled in with mutex on return
  * @param name   A non-null name for the mutex, used for diagnostics.
  *
  * @return VCOS_SUCCESS if mutex was created, or error code.
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_reentrant_mutex_create(VCOS_REENTRANT_MUTEX_T *m, const char *name);

/** Delete the mutex.
  */
VCOS_INLINE_DECL
void vcos_reentrant_mutex_delete(VCOS_REENTRANT_MUTEX_T *m);

/** Wait to claim the mutex. Must not have already been claimed by the current thread.
  */
#ifndef vcos_reentrant_mutexlock
VCOS_INLINE_DECL
void vcos_reentrant_mutex_lock(VCOS_REENTRANT_MUTEX_T *m);

/** Release the mutex.
  */
VCOS_INLINE_DECL
void vcos_reentrant_mutex_unlock(VCOS_REENTRANT_MUTEX_T *m);
#endif


#ifdef __cplusplus
}
#endif
#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef VCOS_STDBOOL_H
#define VCOS_STDBOOL_H

#ifndef __cplusplus

#if defined(__STDC__) && (__STDC_VERSION__ >= 199901L)
#include <stdbool.h>
#else
/* sizeof(bool) == 1. hopefully this matches up with c++ (so structures and
 * such containing bool are binary compatible), but the c++ standard doesn't
 * require sizeof(bool) == 1, so there's no guarantee */
typedef unsigned char bool;
enum {
   false,
   true
};
#endif

#endif /* __cplusplus */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

#ifndef VCOS_SEMAPHORE_H
#define VCOS_SEMAPHORE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#ifndef VCOS_PLATFORM_H
#include "vcos_platform.h"
#endif

/**
 * \file vcos_semaphore.h
 *
 * \section sem Semaphores
 *
 * This provides counting semaphores. Semaphores are not re-entrant. On sensible
 * operating systems a semaphore can always be posted but can only be taken in 
 * thread (not interrupt) context. Under Nucleus, a LISR cannot post a semaphore,
 * although it would not be hard to lift this restriction.
 *
 * \subsection timeout Timeout
 *
 * On both Nucleus and ThreadX a semaphore can be taken with a timeout. This is
 * not supported by VCOS because it makes the non-timeout code considerably more
 * complicated (and hence slower). In the unlikely event that you need a timeout
 * with a semaphore, and you cannot simply redesign your code to avoid it, use
 * an event flag (vcos_event_flags.h).
 *
 * \subsection sem_nucleus Changes from Nucleus:
 *
 *  Semaphores are always "FIFO" - i.e. sleeping threads are woken in FIFO order. That's
 *  because:
 *  \arg there's no support for NU_PRIORITY in threadx (though it can be emulated, slowly)
 *  \arg we don't appear to actually consciously use it - for example, Dispmanx uses
 *  it, but all threads waiting are the same priority.
 *         
 */

/** 
  * \brief Create a semaphore.
  *
  * Create a semaphore.
  *
  * @param sem   Pointer to memory to be initialized
  * @param name  A name for this semaphore. The name may be truncated internally.
  * @param count The initial count for the semaphore.
  *
  * @return VCOS_SUCCESS if the semaphore was created.
  * 
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_semaphore_create(VCOS_SEMAPHORE_T *sem, const char *name, VCOS_UNSIGNED count);

/**
  * \brief Wait on a semaphore.
  *
  * There is no timeout option on a semaphore, as adding this will slow down
  * implementations on some platforms. If you need that kind of behaviour, use
  * an event group.
  *
  * On most platforms this always returns VCOS_SUCCESS, and so would ideally be
  * a void function, however some platforms allow a wait to be interrupted so
  * it remains non-void.
  *
  * @param sem Semaphore to wait on
  * @return VCOS_SUCCESS - semaphore was taken.
  *         VCOS_EAGAIN  - could not take semaphore
  *
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_semaphore_wait(VCOS_SEMAPHORE_T *sem);

/**
  * \brief Wait on a semaphore with a timeout.
  *
  * Note that this function may not be implemented on all
  * platforms, and may not be efficient on all platforms
  * (see comment in vcos_semaphore_wait)
  *
  * Try to obtain the semaphore. If it is already taken, return
  * VCOS_EAGAIN.
  * @param sem Semaphore to wait on
  * @param timeout Number of milliseconds to wait before
  *                returning if the semaphore can't be acquired.
  * @return VCOS_SUCCESS - semaphore was taken.
  *         VCOS_EAGAIN - could not take semaphore (i.e. timeout
  *         expired)
  *         VCOS_EINVAL - Some other error (most likely bad
  *         parameters).
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_semaphore_wait_timeout(VCOS_SEMAPHORE_T *sem, VCOS_UNSIGNED timeout);

/**
  * \brief Try to wait for a semaphore.
  *
  * Try to obtain the semaphore. If it is already taken, return VCOS_TIMEOUT.
  * @param sem Semaphore to wait on
  * @return VCOS_SUCCESS - semaphore was taken.
  *         VCOS_EAGAIN - could not take semaphore
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_semaphore_trywait(VCOS_SEMAPHORE_T *sem);

/**
  * \brief Post a semaphore.
  *
  * @param sem Semaphore to wait on
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_semaphore_post(VCOS_SEMAPHORE_T *sem);

/**
  * \brief Delete a semaphore, releasing any resources consumed by it.
  *
  * @param sem Semaphore to wait on
  */
VCOS_INLINE_DECL
void vcos_semaphore_delete(VCOS_SEMAPHORE_T *sem);

#ifdef __cplusplus
}
#endif
#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VCOS_STDINT_H
#define VCOS_STDINT_H

/** \file
 * Attempt to provide the types defined in stdint.h.
 *
 * Except for use with lcc, this simply includes stdint.h, which should find
 * the system/toolchain version if present, otherwise falling back to the
 * version in interface/vcos/<platform>.
 */

#ifdef __cplusplus
extern "C" {
#endif

#if defined (VCMODS_LCC)

#include <limits.h>

typedef signed   char      int8_t;
typedef unsigned char      uint8_t;

typedef signed   short     int16_t;
typedef unsigned short     uint16_t;

typedef signed   long      int32_t;
typedef unsigned long      uint32_t;

typedef int32_t            intptr_t;
typedef uint32_t           uintptr_t;

typedef int32_t            intmax_t;
typedef uint32_t           uintmax_t;

typedef int8_t             int_least8_t;
typedef int16_t            int_least16_t;
typedef int32_t            int_least32_t;
typedef uint8_t            uint_least8_t;
typedef uint16_t           uint_least16_t;
typedef uint32_t           uint_least32_t;

#define INT8_MIN SCHAR_MIN
#define INT8_MAX SCHAR_MAX
#define UINT8_MAX UCHAR_MAX

#define INT16_MIN SHRT_MIN
#define INT16_MAX SHRT_MAX
#define UINT16_MAX USHRT_MAX

#define INT32_MIN LONG_MIN
#define INT32_MAX LONG_MAX
#define UINT32_MAX ULONG_MAX

#define INTPTR_MIN INT32_MIN
#define INTPTR_MAX INT32_MAX
#define UINTPTR_MAX UINT32_MAX

#define INTMAX_MIN INT32_MIN
#define INTMAX_MAX INT32_MAX
#define UINTMAX_MAX UINT32_MAX

/* N.B. 64-bit integer types are not currently supported by lcc.
 * However, these symbols are referenced in header files included by files
 * compiled by lcc for VCE, so removing them would break the build.
 * The solution here then is to define them, as the correct size, but in a
 * way that should make them unusable in normal arithmetic operations.
 */
typedef struct { uint32_t a; uint32_t b; }  int64_t;
typedef struct { uint32_t a; uint32_t b; } uint64_t;

#else

#include <stdint.h>

#endif

#ifdef __cplusplus
}
#endif
#endif /* VCOS_STDINT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - thread attributes
=============================================================================*/

#ifndef VCOS_THREAD_ATTR_H
#define VCOS_THREAD_ATTR_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * \file
 *
 * Attributes for thread creation.
 *
 */

/** Initialize thread attribute struct. This call does not allocate memory,
  * and so cannot fail.
  *
  */
VCOSPRE_ void VCOSPOST_ vcos_thread_attr_init(VCOS_THREAD_ATTR_T *attrs);

/** Set the stack address and size. If not set, a stack will be allocated automatically.
  *
  * This can only be set on some platforms. It will always be possible to set the stack
  * address on VideoCore, but on host platforms, support may well not be available.
  */
#if VCOS_CAN_SET_STACK_ADDR
VCOS_INLINE_DECL
void vcos_thread_attr_setstack(VCOS_THREAD_ATTR_T *attrs, void *addr, VCOS_UNSIGNED sz);
#endif

/** Set the stack size. If not set, a default size will be used. Attempting to call this after having
  * set the stack location with vcos_thread_attr_setstack() will result in undefined behaviour.
  */
VCOS_INLINE_DECL
void vcos_thread_attr_setstacksize(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED sz);

/** Set the task priority. If not set, a default value will be used.
  */
VCOS_INLINE_DECL
void vcos_thread_attr_setpriority(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED pri);

/** Set the task cpu affinity. If not set, the default will be used.
  */
VCOS_INLINE_DECL
void vcos_thread_attr_setaffinity(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED aff);

/** Set the timeslice. If not set the default will be used.
  */
VCOS_INLINE_DECL
void vcos_thread_attr_settimeslice(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED ts);

/** The thread entry function takes (argc,argv), as per Nucleus, with
  * argc being 0. This may be withdrawn in a future release and should not
  * be used in new code.
  */
VCOS_INLINE_DECL
void _vcos_thread_attr_setlegacyapi(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED legacy);

VCOS_INLINE_DECL
void vcos_thread_attr_setautostart(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED autostart);

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                 /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

#ifndef VCOS_STRING_H
#define VCOS_STRING_H

/**
  * \file
  *
  * String functions.
  *
  */

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

#ifdef __KERNEL__
#include <linux/string.h>
#else
#include <string.h>
#endif

/** Case insensitive string comparison.
  *
  */

VCOS_INLINE_DECL
int vcos_strcasecmp(const char *s1, const char *s2);

VCOS_INLINE_DECL
int vcos_strncasecmp(const char *s1, const char *s2, size_t n);

VCOSPRE_ int VCOSPOST_ vcos_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap);

VCOSPRE_ int VCOSPOST_ vcos_snprintf(char *buf, size_t buflen, const char *fmt, ...);

/** Like vsnprintf, except it places the output at the specified offset.
  * Output is truncated to fit in buflen bytes, and is guaranteed to be NUL-terminated.
  * Returns the string length before/without truncation.
  */
VCOSPRE_ size_t VCOSPOST_ vcos_safe_vsprintf(char *buf, size_t buflen, size_t offset, const char *fmt, va_list ap);

#define VCOS_SAFE_VSPRINTF(buf, offset, fmt, ap) \
   vcos_safe_vsprintf(buf, sizeof(buf) + ((char (*)[sizeof(buf)])buf - &(buf)), offset, fmt, ap)

/** Like snprintf, except it places the output at the specified offset.
  * Output is truncated to fit in buflen bytes, and is guaranteed to be NUL-terminated.
  * Returns the string length before/without truncation.
  */
VCOSPRE_ size_t VCOSPOST_ vcos_safe_sprintf(char *buf, size_t buflen, size_t offset, const char *fmt, ...);

/* The Metaware compiler currently has a bug in its variadic macro handling which
   causes it to append a spurious command to the end of its __VA_ARGS__ data.
   Do not use until this has been fixed (and this comment has been deleted). */

#define VCOS_SAFE_SPRINTF(buf, offset, ...) \
   vcos_safe_sprintf(buf, sizeof(buf) + ((char (*)[sizeof(buf)])buf - &(buf)), offset, __VA_ARGS__)

/** Copies string src to dst at the specified offset.
  * Output is truncated to fit in dstlen bytes, i.e. the string is at most
  * (buflen - 1) characters long. Unlike strncpy, exactly one NUL is written
  * to dst, which is always NUL-terminated.
  * Returns the string length before/without truncation.
  */
VCOSPRE_ size_t VCOSPOST_ vcos_safe_strcpy(char *dst, const char *src, size_t dstlen, size_t offset);

#define VCOS_SAFE_STRCPY(dst, src, offset) \
   vcos_safe_strcpy(dst, src, sizeof(dst) + ((char (*)[sizeof(dst)])dst - &(dst)), offset)

VCOS_STATIC_INLINE
int vcos_strlen(const char *s) { return (int)strlen(s); }

VCOS_STATIC_INLINE
int vcos_strcmp(const char *s1, const char *s2) { return strcmp(s1,s2); }

VCOS_STATIC_INLINE
int vcos_strncmp(const char *cs, const char *ct, size_t count) { return strncmp(cs, ct, count); }

VCOS_STATIC_INLINE
char *vcos_strcpy(char *dst, const char *src) { return strcpy(dst, src); }

VCOS_STATIC_INLINE
char *vcos_strncpy(char *dst, const char *src, size_t count) { return strncpy(dst, src, count); }

VCOS_STATIC_INLINE
void *vcos_memcpy(void *dst, const void *src, size_t n) {  memcpy(dst, src, n);  return dst;  }

VCOS_STATIC_INLINE
void *vcos_memset(void *p, int c, size_t n) { return memset(p, c, n); }

VCOS_STATIC_INLINE
int vcos_memcmp(const void *ptr1, const void *ptr2, size_t count) { return memcmp(ptr1, ptr2, count); }

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

#ifndef VCOS_THREAD_H
#define VCOS_THREAD_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

/**
 * \file vcos_thread.h
 *
 * \section thread Threads
 *
 * Under Nucleus, a thread is created by NU_Create_Task, passing in the stack
 * and various other parameters. To stop the thread, NU_Terminate_Thread() and
 * NU_Delete_Thread() are called.
 *
 * Unfortunately it's not possible to emulate this API under some fairly common
 * operating systems. Under Windows you can't pass in the stack, and you can't
 * safely terminate a thread.
 *
 * Therefore, an API which is similar to the pthreads API is used instead. This
 * API can (mostly) be emulated under all interesting operating systems.
 *
 * Obviously this makes the code somewhat more complicated on VideoCore than it
 * would otherwise be - we end up with an extra mutex per thread, and some code
 * that waits for it. The benefit is that we have a single way of creating
 * threads that works consistently on all platforms (apart from stack supplying).
 *
 * \subsection stack Stack
 *
 * It's still not possible to pass in the stack address, but this can be made
 * much more obvious in the API: the relevant function is missing and the
 * CPP symbol VCOS_CAN_SET_STACK_ADDR is zero rather than one.
 *
 * \subsection thr_create Creating a thread
 *
 * The simplest way to create a thread is with vcos_thread_create() passing in a
 * NULL thread parameter argument. To wait for the thread to exit, call
 * vcos_thread_join().
 *
 * \subsection back Backward compatibility
 *
 * To ease migration, a "classic" thread creation API is provided for code
 * that used to make use of Nucleus, vcos_thread_create_classic(). The
 * arguments are not exactly the same, as the PREEMPT parameter is dropped.
 *
 */

#define VCOS_AFFINITY_CPU0    _VCOS_AFFINITY_CPU0
#define VCOS_AFFINITY_CPU1    _VCOS_AFFINITY_CPU1
#define VCOS_AFFINITY_MASK    _VCOS_AFFINITY_MASK
#define VCOS_AFFINITY_DEFAULT _VCOS_AFFINITY_DEFAULT
#define VCOS_AFFINITY_THISCPU _VCOS_AFFINITY_THISCPU

/** Report whether or not we have an RTOS at all, and hence the ability to
  * create threads.
  */
VCOSPRE_ int VCOSPOST_ vcos_have_rtos(void);

/** Create a thread. It must be cleaned up by calling vcos_thread_join().
  *
  * @param thread   Filled in on return with thread
  * @param name     A name for the thread. May be the empty string.
  * @param attrs    Attributes; default attributes will be used if this is NULL.
  * @param entry    Entry point.
  * @param arg      Argument passed to the entry point.
  */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_thread_create(VCOS_THREAD_T *thread,
                                                    const char *name,
                                                    VCOS_THREAD_ATTR_T *attrs,
                                                    VCOS_THREAD_ENTRY_FN_T entry,
                                                    void *arg);

/** Exit the thread from within the thread function itself.
  * Resources must still be cleaned up via a call to thread_join().
  *
  * The thread can also be terminated by simply exiting the thread function.
  *
  * @param data Data passed to thread_join. May be NULL.
  */
VCOSPRE_ void VCOSPOST_ vcos_thread_exit(void *data);

/** Wait for a thread to terminate and then clean up its resources.
  *
  * @param thread Thread to wait for
  * @param pData  Updated to point at data provided in vcos_thread_exit or exit
  * code of thread function.
  */
VCOSPRE_ void VCOSPOST_ vcos_thread_join(VCOS_THREAD_T *thread,
                             void **pData);


/**
  * \brief Create a thread using an API similar to the one "traditionally"
  * used under Nucleus.
  *
  * This creates a thread which must be cleaned up by calling vcos_thread_join().
  * The thread cannot be simply terminated (as in Nucleus and ThreadX) as thread
  * termination is not universally supported.
  *
  * @param thread       Filled in with thread instance
  * @param name         An optional name for the thread. NULL or "" may be used (but
  *                     a name will aid in debugging).
  * @param entry        Entry point
  * @param arg          A single argument passed to the entry point function
  * @param stack        Pointer to stack address
  * @param stacksz      Size of stack in bytes
  * @param priaff       Priority of task, between VCOS_PRI_LOW and VCOS_PRI_HIGH, ORed with the CPU affinity
  * @param autostart    If non-zero the thread will start immediately.
  * @param timeslice    Timeslice (system ticks) for this thread.
  *
  * @sa vcos_thread_terminate vcos_thread_delete
  */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_thread_create_classic(VCOS_THREAD_T *thread,
                                                            const char *name,
                                                            void *(*entry)(void *arg),
                                                            void *arg,
                                                            void *stack,
                                                            VCOS_UNSIGNED stacksz,
                                                            VCOS_UNSIGNED priaff,
                                                            VCOS_UNSIGNED timeslice,
                                                            VCOS_UNSIGNED autostart);

/**
  * \brief Set a thread's priority
  *
  * Set the priority for a thread.
  *
  * @param thread  The thread
  * @param pri     Thread priority in VCOS_PRI_MASK bits; affinity in VCOS_AFFINITY_MASK bits.
  */
VCOS_INLINE_DECL
void vcos_thread_set_priority(VCOS_THREAD_T *thread, VCOS_UNSIGNED pri);

/**
  * \brief Return the currently executing thread.
  *
  */
VCOS_INLINE_DECL
VCOS_THREAD_T *vcos_thread_current(void);

/**
  * \brief Return the thread's priority.
  */
VCOS_INLINE_DECL
VCOS_UNSIGNED vcos_thread_get_priority(VCOS_THREAD_T *thread);

/**
  * \brief Return the thread's cpu affinity.
  */
VCOS_INLINE_DECL
VCOS_UNSIGNED vcos_thread_get_affinity(VCOS_THREAD_T *thread);

/**
  * \brief Set the thread's cpu affinity.
  */

VCOS_INLINE_DECL
void vcos_thread_set_affinity(VCOS_THREAD_T *thread, VCOS_UNSIGNED affinity);

/**
  * \brief Query whether we are in an interrupt.
  *
  * @return 1 if in interrupt context.
  */
VCOS_INLINE_DECL
int vcos_in_interrupt(void);

/**
  * \brief Sleep a while.
  *
  * @param ms Number of milliseconds to sleep for
  *
  * This may actually sleep a whole number of ticks.
  */
VCOS_INLINE_DECL
void vcos_sleep(uint32_t ms);

/**
  * \brief Return the value of the hardware microsecond counter.
  *
  */
VCOS_INLINE_DECL
uint32_t vcos_getmicrosecs(void);

VCOS_INLINE_DECL
uint64_t vcos_getmicrosecs64(void);

#define vcos_get_ms() (vcos_getmicrosecs()/1000)

/**
  * \brief Return a unique identifier for the current process
  *
  */
VCOS_INLINE_DECL
VCOS_UNSIGNED vcos_process_id_current(void);

/** Relinquish this time slice. */
VCOS_INLINE_DECL
void vcos_thread_relinquish(void);

/** Return the name of the given thread.
  */
VCOSPRE_ const char * VCOSPOST_ vcos_thread_get_name(const VCOS_THREAD_T *thread);

/** Change preemption. This is almost certainly not what you want, as it won't
  * work reliably in a multicore system: although you can affect the preemption
  * on *this* core, you won't affect what's happening on the other core(s).
  *
  * It's mainly here to ease migration. If you're using it in new code, you
  * probably need to think again.
  *
  * @param pe New preemption, VCOS_PREEMPT or VCOS_NO_PREEMPT
  * @return Old value of preemption.
  */
VCOS_INLINE_DECL
VCOS_UNSIGNED vcos_change_preemption(VCOS_UNSIGNED pe);

/** Is a thread still running, or has it exited?
  *
  * Note: this exists for some fairly scary code in the video codec tests. Don't
  * try to use it for anything else, as it may well not do what you expect.
  *
  * @param thread   thread to query
  * @return non-zero if thread is running, or zero if it has exited.
  */
VCOS_INLINE_DECL
int vcos_thread_running(VCOS_THREAD_T *thread);

/** Resume a thread.
  *
  * @param thread thread to resume
  */
VCOS_INLINE_DECL
void vcos_thread_resume(VCOS_THREAD_T *thread);

/*
 * Internal APIs - may not always be present and should not be used in
 * client code.
 */

extern void _vcos_task_timer_set(void (*pfn)(void*), void *, VCOS_UNSIGNED ms);
extern void _vcos_task_timer_cancel(void);

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - timer support
=============================================================================*/

#ifndef VCOS_TIMER_H
#define VCOS_TIMER_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#ifndef VCOS_PLATFORM_H
#include "vcos_platform.h"
#endif

/** \file vcos_timer.h
  *
  * Timers are single shot.
  *
  * Timer times are in milliseconds.
  *
  * \note that timer callback functions are called from an arbitrary thread
  * context. The expiration function should do its work as quickly as possible;
  * blocking should be avoided.
  *
  * \note On Windows, the separate function vcos_timer_init() must be called
  * as timer initialization from DllMain is not possible.
  */

/** Perform timer subsystem initialization. This function is not needed
  * on non-Windows platforms but is still present so that it can be
  * called. On Windows it is needed because vcos_init() gets called
  * from DLL initialization where it is not possible to create a
  * time queue (deadlock occurs if you try).
  *
  * @return VCOS_SUCCESS on success. VCOS_EEXIST if this has already been called
  * once. VCOS_ENOMEM if resource allocation failed.
  */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_timer_init(void);

/** Create a timer in a disabled state.
  *
  * The timer is initially disabled.
  *
  * @param timer     timer handle
  * @param name      name for timer
  * @param expiration_routine function to call when timer expires
  * @param context   context passed to expiration routine
  *
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_timer_create(VCOS_TIMER_T *timer,
                                const char *name,
                                void (*expiration_routine)(void *context),
                                void *context);



/** Start a timer running.
  *
  * Timer must be stopped.
  *
  * @param timer     timer handle
  * @param delay     Delay to wait for, in ms
  */
VCOS_INLINE_DECL
void vcos_timer_set(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay);

/** Stop an already running timer.
  *
  * @param timer     timer handle
  */
VCOS_INLINE_DECL
void vcos_timer_cancel(VCOS_TIMER_T *timer);

/** Stop a timer and restart it.
  * @param timer     timer handle
  * @param delay     delay in ms
  */
VCOS_INLINE_DECL
void vcos_timer_reset(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay);

VCOS_INLINE_DECL
void vcos_timer_delete(VCOS_TIMER_T *timer);

#ifdef __cplusplus
}
#endif
#endif
                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - thread local storage
=============================================================================*/

#ifndef VCOS_TLS_H
#define VCOS_TLS_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"


/** Create a new thread local storage data key visible to all threads in
  * the current process.
  *
  * @param key    The key to create
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_tls_create(VCOS_TLS_KEY_T *key);

/** Delete an existing TLS data key.
  */
VCOS_INLINE_DECL
void vcos_tls_delete(VCOS_TLS_KEY_T tls);

/** Set the value seen by the current thread.
  *
  * @param key    The key to update
  * @param v      The value to set for the current thread.
  *
  * @return VCOS_SUCCESS, or VCOS_ENOMEM if memory for this slot
  * could not be allocated.
  *
  * If TLS is being emulated via VCOS then the memory required
  * can be preallocated at thread creation time
  */
VCOS_INLINE_DECL
VCOS_STATUS_T vcos_tls_set(VCOS_TLS_KEY_T tls, void *v);

/** Get the value for the current thread.
  *
  * @param key    The key to update
  *
  * @return The current value for this thread.
  */
VCOS_INLINE_DECL
void *vcos_tls_get(VCOS_TLS_KEY_T tls);

#ifdef __cplusplus
}
#endif

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/

#ifndef VCOS_TYPES_H
#define VCOS_TYPES_H

#define VCOS_VERSION   1

#include <stddef.h>
#include "vcos_platform_types.h"
#include "interface/vcos/vcos_attr.h"

#if !defined(VCOSPRE_) || !defined(VCOSPOST_)
#error VCOSPRE_ and VCOSPOST_ not defined!
#endif

/* Redefine these here; this means that existing header files can carry on
 * using the VCHPOST/VCHPRE macros rather than having huge changes, which
 * could cause nasty merge problems.
 */
#ifndef VCHPOST_
#define VCHPOST_ VCOSPOST_
#endif
#ifndef VCHPRE_
#define VCHPRE_  VCOSPRE_
#endif

/** Entry function for a lowlevel thread.
  *
  * Returns void for consistency with Nucleus/ThreadX.
  */
typedef void (*VCOS_LLTHREAD_ENTRY_FN_T)(void *);

/** Thread entry point. Returns a void* for consistency
  * with pthreads.
  */
typedef void *(*VCOS_THREAD_ENTRY_FN_T)(void*);


/* Error return codes - chosen to be similar to errno values */
typedef enum
{
   VCOS_SUCCESS,
   VCOS_EAGAIN,
   VCOS_ENOENT,
   VCOS_ENOSPC,
   VCOS_EINVAL,
   VCOS_EACCESS,
   VCOS_ENOMEM,
   VCOS_ENOSYS,
   VCOS_EEXIST,
   VCOS_ENXIO,
   VCOS_EINTR
} VCOS_STATUS_T;

/* Some compilers (MetaWare) won't inline with -g turned on, which then results
 * in a lot of code bloat. To overcome this, inline functions are forward declared
 * with the prefix VCOS_INLINE_DECL, and implemented with the prefix VCOS_INLINE_IMPL.
 *
 * That then means that in a release build, "static inline" can be used in the obvious
 * way, but in a debug build the implementations can be skipped in all but one file,
 * by using VCOS_INLINE_BODIES.
 *
 * VCOS_INLINE_DECL - put this at the start of an inline forward declaration of a VCOS
 * function.
 *
 * VCOS_INLINE_IMPL - put this at the start of an inlined implementation of a VCOS
 * function.
 *
 */

/* VCOS_EXPORT - it turns out that in some circumstances we need the implementation of
 * a function even if it is usually inlined.
 *
 * In particular, if we have a codec that is usually provided in object form, if it
 * was built for a debug build it will be full of calls to vcos_XXX(). If this is used
 * in a *release* build, then there won't be any of these calls around in the main image
 * as they will all have been inlined. The problem also exists for vcos functions called
 * from assembler.
 *
 * VCOS_EXPORT ensures that the named function will be emitted as a regular (not static-inline)
 * function inside vcos_<platform>.c so that it can be linked against. Doing this for every
 * VCOS function would be a bit code-bloat-tastic, so it is only done for those that need it.
 *
 */

#ifdef __cplusplus
#define _VCOS_INLINE inline
#else
#define _VCOS_INLINE __inline
#endif

#if defined(NDEBUG)

#ifdef __GNUC__
# define VCOS_INLINE_DECL extern __inline__
# define VCOS_INLINE_IMPL static __inline__
#else
# define VCOS_INLINE_DECL static _VCOS_INLINE   /* declare a func */
# define VCOS_INLINE_IMPL static _VCOS_INLINE   /* implement a func inline */
#endif

# if defined(VCOS_WANT_IMPL)
#  define VCOS_EXPORT
# else
#  define VCOS_EXPORT VCOS_INLINE_IMPL
# endif /* VCOS_WANT_IMPL */

#define VCOS_INLINE_BODIES

#else /* NDEBUG */

#if !defined(VCOS_INLINE_DECL)
   #define VCOS_INLINE_DECL extern
#endif
#if !defined(VCOS_INLINE_IMPL)
   #define VCOS_INLINE_IMPL
#endif
#define VCOS_EXPORT VCOS_INLINE_IMPL
#endif

#define VCOS_STATIC_INLINE static _VCOS_INLINE

#if defined(__HIGHC__) || defined(__HIGHC_ANSI__)
#define _VCOS_METAWARE
#endif

/** It seems that __FUNCTION__ isn't standard!
  */
#if __STDC_VERSION__ < 199901L
# if __GNUC__ >= 2 || defined(__VIDEOCORE__)
#  define VCOS_FUNCTION __FUNCTION__
# else
#  define VCOS_FUNCTION "<unknown>"
# endif
#else
# define VCOS_FUNCTION __func__
#endif

#define _VCOS_MS_PER_TICK (1000/VCOS_TICKS_PER_SECOND)

/* Convert a number of milliseconds to a tick count. Internal use only - fails to
 * convert VCOS_SUSPEND correctly.
 */
#define _VCOS_MS_TO_TICKS(ms) (((ms)+_VCOS_MS_PER_TICK-1)/_VCOS_MS_PER_TICK)

#define VCOS_TICKS_TO_MS(ticks) ((ticks) * _VCOS_MS_PER_TICK)

/** VCOS version of DATESTR, from pcdisk.h. Used by the hostreq service.
 */
typedef struct vcos_datestr
{
   uint8_t       cmsec;              /**< Centesimal mili second */
   uint16_t      date;               /**< Date */
   uint16_t      time;               /**< Time */

} VCOS_DATESTR;

/* Compile-time assert - declares invalid array length if condition
 * not met, or array of length one if OK.
 */
#define VCOS_CASSERT(e) extern char vcos_compile_time_check[1/(e)]

#define vcos_min(x,y) ((x) < (y) ? (x) : (y))
#define vcos_max(x,y) ((x) > (y) ? (x) : (y))

/** Return the count of an array. FIXME: under gcc we could make
 * this report an error for pointers using __builtin_types_compatible().
 */
#define vcos_countof(x) (sizeof((x)) / sizeof((x)[0]))

/* for backward compatibility */
#define countof(x) (sizeof((x)) / sizeof((x)[0]))

#define VCOS_ALIGN_DOWN(p,n) (((ptrdiff_t)(p)) & ~((n)-1))
#define VCOS_ALIGN_UP(p,n) VCOS_ALIGN_DOWN((ptrdiff_t)(p)+(n)-1,(n))

#ifdef _MSC_VER
   #define vcos_alignof(T) __alignof(T)
#elif defined(__GNUC__)
   #define vcos_alignof(T) __alignof__(T)
#else
   #define vcos_alignof(T) (sizeof(struct { T t; char ch; }) - sizeof(T))
#endif

/** bool_t is not a POSIX type so cannot rely on it. Define it here.
  * It's not even defined in stdbool.h.
  */
typedef int32_t vcos_bool_t;
typedef int32_t vcos_fourcc_t;

#define VCOS_FALSE   0
#define VCOS_TRUE    (!VCOS_FALSE)

/** Mark unused arguments to keep compilers quiet */
#define vcos_unused(x) (void)(x)

/** For backward compatibility */
typedef vcos_fourcc_t fourcc_t;
typedef vcos_fourcc_t FOURCC_T;

#ifdef __cplusplus
#define VCOS_EXTERN_C_BEGIN extern "C" {
#define VCOS_EXTERN_C_END }
#else
#define VCOS_EXTERN_C_BEGIN
#define VCOS_EXTERN_C_END
#endif

/** Variable attribute indicating the variable must be emitted even if it appears unused. */
#if defined(__GNUC__) || defined(_VCOS_METAWARE)
# define VCOS_ATTR_USED  __attribute__ ((used))
#else
# define VCOS_ATTR_USED
#endif

/** Variable attribute requiring specific alignment. */
#if defined(__GNUC__) || defined(_VCOS_METAWARE)
# define VCOS_ATTR_ALIGNED(n)  __attribute__ ((aligned(n)))
#else
# define VCOS_ATTR_ALIGNED(n)
#endif

/** Define a function as a weak alias to another function.
 * @param ret_type     Function return type.
 * @param alias_name   Name of the alias.
 * @param param_list   Function parameter list, including the parentheses.
 * @param target_name  Target function (bare function name, not a string).
 */
#if defined(__GNUC__) || defined(_VCOS_METAWARE)
  /* N.B. gcc allows __attribute__ after parameter list, but hcvc seems to silently ignore it. */
# define VCOS_WEAK_ALIAS(ret_type, alias_name, param_list, target_name) \
   __attribute__ ((weak, alias(#target_name))) ret_type alias_name param_list
#else
# define VCOS_WEAK_ALIAS(ret_type, alias, params, target)  VCOS_CASSERT(0)
#endif

/** Define a function as a weak alias to another function, specified as a string.
 * @param ret_type     Function return type.
 * @param alias_name   Name of the alias.
 * @param param_list   Function parameter list, including the parentheses.
 * @param target_name  Target function name as a string.
 * @note Prefer the use of VCOS_WEAK_ALIAS - it is likely to be more portable.
 *       Only use VCOS_WEAK_ALIAS_STR if you need to do pre-processor mangling of the target
 *       symbol.
 */
#if defined(__GNUC__) || defined(_VCOS_METAWARE)
  /* N.B. gcc allows __attribute__ after parameter list, but hcvc seems to silently ignore it. */
# define VCOS_WEAK_ALIAS_STR(ret_type, alias_name, param_list, target_name) \
   __attribute__ ((weak, alias(target_name))) ret_type alias_name param_list
#else
# define VCOS_WEAK_ALIAS_STR(ret_type, alias, params, target)  VCOS_CASSERT(0)
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - common postamble code
=============================================================================*/

/** \file
  *
  * Postamble code included by the platform-specific header files
  */

#define VCOS_THREAD_PRI_DEFAULT VCOS_THREAD_PRI_NORMAL

#if !defined(VCOS_THREAD_PRI_INCREASE)
#error Which way to thread priorities go?
#endif

#if VCOS_THREAD_PRI_INCREASE < 0
/* smaller numbers are higher priority */
#define VCOS_THREAD_PRI_LESS(x) ((x)<VCOS_THREAD_PRI_MAX?(x)+1:VCOS_THREAD_PRI_MAX)
#define VCOS_THREAD_PRI_MORE(x) ((x)>VCOS_THREAD_PRI_MIN?(x)-1:VCOS_THREAD_PRI_MIN)
#else
/* bigger numbers are lower priority */
#define VCOS_THREAD_PRI_MORE(x) ((x)<VCOS_THREAD_PRI_MAX?(x)+1:VCOS_THREAD_PRI_MAX)
#define VCOS_THREAD_PRI_LESS(x) ((x)>VCOS_THREAD_PRI_MIN?(x)-1:VCOS_THREAD_PRI_MIN)
#endif

/* Convenience for Brits: */
#define VCOS_APPLICATION_INITIALISE VCOS_APPLICATION_INITIALIZE

/*
 * Check for constant definitions
 */
#ifndef VCOS_TICKS_PER_SECOND
#error VCOS_TICKS_PER_SECOND not defined
#endif

#if !defined(VCOS_THREAD_PRI_MIN) || !defined(VCOS_THREAD_PRI_MAX)
#error Priority range not defined
#endif

#if !defined(VCOS_THREAD_PRI_HIGHEST) || !defined(VCOS_THREAD_PRI_LOWEST) || !defined(VCOS_THREAD_PRI_NORMAL)
#error Priority ordering not defined
#endif

#if !defined(VCOS_CAN_SET_STACK_ADDR)
#error Can stack addresses be set on this platform? Please set this macro to either 0 or 1.
#endif

#if (_VCOS_AFFINITY_CPU0|_VCOS_AFFINITY_CPU1) & (~_VCOS_AFFINITY_MASK) 
#error _VCOS_AFFINITY_CPUxxx values are not consistent with _VCOS_AFFINITY_MASK
#endif

/** Append to the end of a singly-linked queue, O(1). Works with
  * any structure where list has members 'head' and 'tail' and
  * item has a 'next' pointer.
  */
#define VCOS_QUEUE_APPEND_TAIL(list, item) {\
   (item)->next = NULL;\
   if (!(list)->head) {\
      (list)->head = (list)->tail = (item); \
   } else {\
      (list)->tail->next = (item); \
      (list)->tail = (item); \
   } \
}

#ifndef VCOS_HAVE_TIMER
VCOSPRE_ void VCOSPOST_ vcos_timer_init(void);
#endif

                                                                                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
The symbol vcos_deprecated_code may be defined at most once, by the inclusion of "vcos_deprecated.h" in vcos_init.c.
Any other inclusions of this header will cause the linker to warn about multiple definitions of vcos_deprecated_code, for example:
   [ldvc] (Warning) "vcos_deprecated_code" is multiply defined in libs/vcos_threadx/vcos_init.c.o and libs/xxxxx/xxxxx.c.o
If you see a build message like this then the configuration you are building is using deprecated code.
Contact the person named in the accompanying comment for advice - do not remove the inclusion.
*/

int vcos_deprecated_code;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - event flags implemented via a semaphore
=============================================================================*/

#ifndef VCOS_GENERIC_BLOCKPOOL_H
#define VCOS_GENERIC_BLOCKPOOL_H

/**
  * \file
  *
  * This provides a generic, thread safe implementation of a VCOS block pool
  * fixed size memory allocator.
  */

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"

/** Bits 0 to (VCOS_BLOCKPOOL_SUBPOOL_BITS - 1) are used to store the
 * subpool id. */
#define VCOS_BLOCKPOOL_SUBPOOL_BITS 3
#define VCOS_BLOCKPOOL_MAX_SUBPOOLS (1 << VCOS_BLOCKPOOL_SUBPOOL_BITS)

/* Make zero an invalid handle at the cost of decreasing the maximum
 * number of blocks (2^28) by 1. Alternatively, a spare bit could be
 * used to indicated valid blocks but there are likely to be better
 * uses for spare bits. e.g. allowing more subpools
 */
#define INDEX_OFFSET 1

#define VCOS_BLOCKPOOL_HANDLE_GET_INDEX(h) \
   (((h) >> VCOS_BLOCKPOOL_SUBPOOL_BITS) - INDEX_OFFSET)

#define VCOS_BLOCKPOOL_HANDLE_GET_SUBPOOL(h) \
   ((h) & ((1 << VCOS_BLOCKPOOL_SUBPOOL_BITS) - 1))

#define VCOS_BLOCKPOOL_HANDLE_CREATE(i,s) \
   ((((i) + INDEX_OFFSET) << VCOS_BLOCKPOOL_SUBPOOL_BITS) | (s))

#define VCOS_BLOCKPOOL_INVALID_HANDLE 0
#define VCOS_BLOCKPOOL_ALIGN_DEFAULT sizeof(unsigned long)
#define VCOS_BLOCKPOOL_FLAG_NONE 0

typedef struct VCOS_BLOCKPOOL_HEADER_TAG
{
   /* Blocks either refer to to the pool if they are allocated
    * or the free list if they are available.
    */
   union {
   struct VCOS_BLOCKPOOL_HEADER_TAG *next;
   struct VCOS_BLOCKPOOL_SUBPOOL_TAG* subpool;
   } owner;
} VCOS_BLOCKPOOL_HEADER_T;

typedef struct VCOS_BLOCKPOOL_SUBPOOL_TAG
{
   /** VCOS_BLOCKPOOL_SUBPOOL_MAGIC */
   uint32_t magic;
   VCOS_BLOCKPOOL_HEADER_T* free_list;
   /* The start of the pool memory */
   void *mem;
   /* Address of the first block header */
   void *start;
   /* The end of the subpool */
   void *end;
   /** The number of blocks in this sub-pool */
   VCOS_UNSIGNED num_blocks;
   /** Current number of available blocks in this sub-pool */
   VCOS_UNSIGNED available_blocks;
   /** Pointers to the pool that owns this sub-pool */
   struct VCOS_BLOCKPOOL_TAG* owner;
   /** Define properties such as memory ownership */
   uint32_t flags;
} VCOS_BLOCKPOOL_SUBPOOL_T;

typedef struct VCOS_BLOCKPOOL_TAG
{
   /** VCOS_BLOCKPOOL_MAGIC */
   uint32_t magic;
   /** Thread safety for Alloc, Free, Delete, Stats */
   VCOS_MUTEX_T mutex;
   /** Alignment of block data pointers */
   VCOS_UNSIGNED align;
   /** Flags for future use e.g. cache options */
   VCOS_UNSIGNED flags;
   /** The size of the block data */
   size_t block_data_size;
   /** Block size inc overheads */
   size_t block_size;
   /** Name for debugging */
   const char *name;
   /* The number of subpools that may be used */
   VCOS_UNSIGNED num_subpools;
   /** Number of blocks in each dynamically allocated subpool */
   VCOS_UNSIGNED num_extension_blocks;
   /** Array of subpools. Subpool zero is is not deleted until the pool is
    * destroed. If the index of the pool is < num_subpools and
    * subpool[index.mem] is null then the subpool entry is valid but
    * "not currently allocated" */
   VCOS_BLOCKPOOL_SUBPOOL_T subpools[VCOS_BLOCKPOOL_MAX_SUBPOOLS];
} VCOS_BLOCKPOOL_T;

#define VCOS_BLOCKPOOL_ROUND_UP(x,s)   (((x) + ((s) - 1)) & ~((s) - 1))
/**
 * Calculates the size in bytes required for a block pool containing
 * num_blocks of size block_size plus any overheads.
 *
 * The block pool header (VCOS_BLOCKPOOL_T) is allocated separately
 *
 * Overheads:
 * block_size + header must be rounded up to meet the required alignment
 * The start of the first block may need to be up to align bytes
 * into the given buffer because statically allocated buffers within structures
 * are not guaranteed to be aligned as required.
 */
#define VCOS_BLOCKPOOL_SIZE(num_blocks, block_size, align) \
   ((VCOS_BLOCKPOOL_ROUND_UP((block_size) + (align >= 4096 ? 32 : 0) + sizeof(VCOS_BLOCKPOOL_HEADER_T), \
                             (align)) * (num_blocks)) + (align))

/**
 * Sanity check to verify whether a handle is potentially a blockpool handle
 * when the pool pointer is not available.
 *
 * If the pool pointer is available use vcos_blockpool_elem_to_handle instead.
 *
 * @param handle       the handle to verify
 * @param max_blocks   the expected maximum number of block in the pool
 *                     that the handle belongs to.
 */
#define VCOS_BLOCKPOOL_IS_VALID_HANDLE_FORMAT(handle, max_blocks) \
    ((handle) != VCOS_BLOCKPOOL_INVALID_HANDLE \
     && VCOS_BLOCKPOOL_HANDLE_GET_INDEX((handle)) < (max_blocks))

VCOSPRE_
   VCOS_STATUS_T VCOSPOST_ vcos_generic_blockpool_init(VCOS_BLOCKPOOL_T *pool,
      VCOS_UNSIGNED num_blocks, VCOS_UNSIGNED block_size,
      void *start, VCOS_UNSIGNED pool_size,
      VCOS_UNSIGNED align, VCOS_UNSIGNED flags,
      const char *name);

VCOSPRE_
   VCOS_STATUS_T VCOSPOST_ vcos_generic_blockpool_create_on_heap(
         VCOS_BLOCKPOOL_T *pool, VCOS_UNSIGNED num_blocks,
         VCOS_UNSIGNED block_size,
         VCOS_UNSIGNED align, VCOS_UNSIGNED flags,
         const char *name);

VCOSPRE_
   VCOS_STATUS_T VCOSPOST_ vcos_generic_blockpool_extend(VCOS_BLOCKPOOL_T *pool,
         VCOS_UNSIGNED num_extensions, VCOS_UNSIGNED num_blocks);

VCOSPRE_ void VCOSPOST_ *vcos_generic_blockpool_alloc(VCOS_BLOCKPOOL_T *pool);

VCOSPRE_ void VCOSPOST_ *vcos_generic_blockpool_calloc(VCOS_BLOCKPOOL_T *pool);

VCOSPRE_ void VCOSPOST_ vcos_generic_blockpool_free(void *block);

VCOSPRE_
   VCOS_UNSIGNED VCOSPOST_ vcos_generic_blockpool_available_count(
         VCOS_BLOCKPOOL_T *pool);

VCOSPRE_
   VCOS_UNSIGNED VCOSPOST_ vcos_generic_blockpool_used_count(
         VCOS_BLOCKPOOL_T *pool);

VCOSPRE_ void VCOSPOST_ vcos_generic_blockpool_delete(VCOS_BLOCKPOOL_T *pool);

VCOSPRE_ uint32_t VCOSPOST_ vcos_generic_blockpool_elem_to_handle(void *block);

VCOSPRE_ void VCOSPOST_
   *vcos_generic_blockpool_elem_from_handle(
         VCOS_BLOCKPOOL_T *pool, uint32_t handle);

VCOSPRE_ uint32_t VCOSPOST_
   vcos_generic_blockpool_is_valid_elem(
         VCOS_BLOCKPOOL_T *pool, const void *block);
#if defined(VCOS_INLINE_BODIES)

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_blockpool_init(VCOS_BLOCKPOOL_T *pool,
      VCOS_UNSIGNED num_blocks, VCOS_UNSIGNED block_size,
      void *start, VCOS_UNSIGNED pool_size,
      VCOS_UNSIGNED align, VCOS_UNSIGNED flags, const char *name)
{
   return vcos_generic_blockpool_init(pool, num_blocks, block_size,
         start, pool_size, align, flags, name);
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_blockpool_create_on_heap(VCOS_BLOCKPOOL_T *pool,
      VCOS_UNSIGNED num_blocks, VCOS_UNSIGNED block_size,
      VCOS_UNSIGNED align, VCOS_UNSIGNED flags, const char *name)
{
   return vcos_generic_blockpool_create_on_heap(
         pool, num_blocks, block_size, align, flags, name);
}

VCOS_INLINE_IMPL
   VCOS_STATUS_T VCOSPOST_ vcos_blockpool_extend(VCOS_BLOCKPOOL_T *pool,
         VCOS_UNSIGNED num_extensions, VCOS_UNSIGNED num_blocks)
{
    return vcos_generic_blockpool_extend(pool, num_extensions, num_blocks);
}

VCOS_INLINE_IMPL
void *vcos_blockpool_alloc(VCOS_BLOCKPOOL_T *pool)
{
   return vcos_generic_blockpool_alloc(pool);
}

VCOS_INLINE_IMPL
void *vcos_blockpool_calloc(VCOS_BLOCKPOOL_T *pool)
{
   return vcos_generic_blockpool_calloc(pool);
}

VCOS_INLINE_IMPL
void vcos_blockpool_free(void *block)
{
   vcos_generic_blockpool_free(block);
}

VCOS_INLINE_IMPL
VCOS_UNSIGNED vcos_blockpool_available_count(VCOS_BLOCKPOOL_T *pool)
{
   return vcos_generic_blockpool_available_count(pool);
}

VCOS_INLINE_IMPL
VCOS_UNSIGNED vcos_blockpool_used_count(VCOS_BLOCKPOOL_T *pool)
{
   return vcos_generic_blockpool_used_count(pool);
}

VCOS_INLINE_IMPL
void vcos_blockpool_delete(VCOS_BLOCKPOOL_T *pool)
{
   vcos_generic_blockpool_delete(pool);
}

VCOS_INLINE_IMPL
uint32_t vcos_blockpool_elem_to_handle(void *block)
{
   return vcos_generic_blockpool_elem_to_handle(block);
}

VCOS_INLINE_IMPL
void *vcos_blockpool_elem_from_handle(VCOS_BLOCKPOOL_T *pool, uint32_t handle)
{
   return vcos_generic_blockpool_elem_from_handle(pool, handle);
}

VCOS_INLINE_IMPL
uint32_t vcos_blockpool_is_valid_elem(VCOS_BLOCKPOOL_T *pool, const void *block)
{
   return vcos_generic_blockpool_is_valid_elem(pool, block);
}
#endif /* VCOS_INLINE_BODIES */


#ifdef __cplusplus
}
#endif
#endif /* VCOS_GENERIC_BLOCKPOOL_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - named semaphores
=============================================================================*/

#ifndef VCOS_GENERIC_NAMED_SEM_H
#define VCOS_GENERIC_NAMED_SEM_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"

/**
 * \file
 *
 * Generic support for named semaphores, using regular ones. This is only
 * suitable for emulating them on an embedded MMUless system, since there is
 * no support for opening semaphores across process boundaries.
 *
 */

#define VCOS_NAMED_SEMAPHORE_NAMELEN   64

/* In theory we could use the name facility provided within Nucleus. However, this
 * is hard to do as semaphores are constantly being created and destroyed; we
 * would need to stop everything while allocating the memory for the semaphore
 * list and then walking it. So keep our own list.
 */
typedef struct VCOS_NAMED_SEMAPHORE_T
{
   struct VCOS_NAMED_SEMAPHORE_IMPL_T *actual; /**< There are 'n' named semaphores per 1 actual semaphore  */
   VCOS_SEMAPHORE_T *sem;                      /**< Pointer to actual underlying semaphore */
} VCOS_NAMED_SEMAPHORE_T;

VCOSPRE_ VCOS_STATUS_T VCOSPOST_
vcos_generic_named_semaphore_create(VCOS_NAMED_SEMAPHORE_T *sem, const char *name, VCOS_UNSIGNED count);

VCOSPRE_ void VCOSPOST_ vcos_named_semaphore_delete(VCOS_NAMED_SEMAPHORE_T *sem);

VCOSPRE_ VCOS_STATUS_T VCOSPOST_ _vcos_named_semaphore_init(void);
VCOSPRE_ void VCOSPOST_ _vcos_named_semaphore_deinit(void);

#if defined(VCOS_INLINE_BODIES)

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_named_semaphore_create(VCOS_NAMED_SEMAPHORE_T *sem, const char *name, VCOS_UNSIGNED count) {
   return vcos_generic_named_semaphore_create(sem, name, count);
}

VCOS_INLINE_IMPL
void vcos_named_semaphore_wait(VCOS_NAMED_SEMAPHORE_T *sem) {
   vcos_semaphore_wait(sem->sem);
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_named_semaphore_trywait(VCOS_NAMED_SEMAPHORE_T *sem) {
   return vcos_semaphore_trywait(sem->sem);
}

VCOS_INLINE_IMPL
void vcos_named_semaphore_post(VCOS_NAMED_SEMAPHORE_T *sem) {
   vcos_semaphore_post(sem->sem);
}


#endif

#ifdef __cplusplus
}
#endif
#endif


                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - event flags implemented via a semaphore
=============================================================================*/

#ifndef VCOS_GENERIC_EVENT_FLAGS_H
#define VCOS_GENERIC_EVENT_FLAGS_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"

/**
  * \file
  *
  * This provides event flags (as per Nucleus Event Groups) based on a
  * mutex, a semaphore (per waiting thread) and a timer (per waiting
  * thread).
  * 
  * The data structure is a 32 bit unsigned int (the current set of
  * flags) and a linked list of clients waiting to be 'satisfied'.
  *
  * The mutex merely locks access to the data structure. If a client
  * calls vcos_event_flags_get() and the requested bits are not already
  * present, it then sleeps on its per-thread semaphore after adding
  * this semaphore to the queue waiting. It also sets up a timer.
  *
  * The per-thread semaphore and timer are actually stored in the
  * thread context (joinable thread). In future it may become necessary
  * to support non-VCOS threads by using thread local storage to
  * create these objects and associate them with the thread.
  */

struct VCOS_EVENT_WAITER_T;

typedef struct VCOS_EVENT_FLAGS_T
{
   VCOS_UNSIGNED events;      /**< Events currently set */
   VCOS_MUTEX_T lock;         /**< Serialize access */
   struct
   {
      struct VCOS_EVENT_WAITER_T *head;   /**< List of threads waiting */
      struct VCOS_EVENT_WAITER_T *tail;   /**< List of threads waiting */
   } waiters;
} VCOS_EVENT_FLAGS_T;

#define VCOS_OR      1
#define VCOS_AND     2
#define VCOS_CONSUME 4
#define VCOS_OR_CONSUME (VCOS_OR | VCOS_CONSUME)
#define VCOS_AND_CONSUME (VCOS_AND | VCOS_CONSUME)
#define VCOS_EVENT_FLAG_OP_MASK (VCOS_OR|VCOS_AND)

VCOSPRE_  VCOS_STATUS_T VCOSPOST_ vcos_generic_event_flags_create(VCOS_EVENT_FLAGS_T *flags, const char *name);
VCOSPRE_  void VCOSPOST_ vcos_generic_event_flags_set(VCOS_EVENT_FLAGS_T *flags,
                                                      VCOS_UNSIGNED events,
                                                      VCOS_OPTION op);
VCOSPRE_  void VCOSPOST_ vcos_generic_event_flags_delete(VCOS_EVENT_FLAGS_T *);
VCOSPRE_  VCOS_STATUS_T VCOSPOST_ vcos_generic_event_flags_get(VCOS_EVENT_FLAGS_T *flags,
                                                               VCOS_UNSIGNED requested_events,
                                                               VCOS_OPTION op,
                                                               VCOS_UNSIGNED suspend,
                                                               VCOS_UNSIGNED *retrieved_events);

#ifdef VCOS_INLINE_BODIES

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_event_flags_create(VCOS_EVENT_FLAGS_T *flags, const char *name) {
   return vcos_generic_event_flags_create(flags, name);
}

VCOS_INLINE_IMPL
void vcos_event_flags_set(VCOS_EVENT_FLAGS_T *flags,
                          VCOS_UNSIGNED events,
                          VCOS_OPTION op) {
   vcos_generic_event_flags_set(flags, events, op);
}

VCOS_INLINE_IMPL
void vcos_event_flags_delete(VCOS_EVENT_FLAGS_T *f) {
   vcos_generic_event_flags_delete(f);
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_event_flags_get(VCOS_EVENT_FLAGS_T *flags,
                                   VCOS_UNSIGNED requested_events,
                                   VCOS_OPTION op,
                                   VCOS_UNSIGNED suspend,
                                   VCOS_UNSIGNED *retrieved_events) {
   return vcos_generic_event_flags_get(flags, requested_events, op, suspend, retrieved_events);
}

#endif /* VCOS_INLINE_BODIES */

#ifdef __cplusplus
}
#endif
#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - reentrant mutexes created from regular ones.
=============================================================================*/

#ifndef VCOS_GENERIC_QUICKSLOW_MUTEX_H
#define VCOS_GENERIC_QUICKSLOW_MUTEX_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"

/**
 * \file
 *
 * Quickslow Mutexes implemented as regular ones (i.e. quick and slow modes are the same).
 *
 */

typedef VCOS_MUTEX_T VCOS_QUICKSLOW_MUTEX_T;

#if defined(VCOS_INLINE_BODIES)
VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_quickslow_mutex_create(VCOS_QUICKSLOW_MUTEX_T *m, const char *name)
{
   return vcos_mutex_create(m, name);
}

VCOS_INLINE_IMPL
void vcos_quickslow_mutex_delete(VCOS_QUICKSLOW_MUTEX_T *m)
{
   vcos_mutex_delete(m);
}

VCOS_INLINE_IMPL
void vcos_quickslow_mutex_lock(VCOS_QUICKSLOW_MUTEX_T *m)
{
   while (vcos_mutex_lock(m) == VCOS_EAGAIN);
}

VCOS_INLINE_IMPL
void vcos_quickslow_mutex_unlock(VCOS_QUICKSLOW_MUTEX_T *m)
{
   vcos_mutex_unlock(m);
}

VCOS_INLINE_IMPL
void vcos_quickslow_mutex_lock_quick(VCOS_QUICKSLOW_MUTEX_T *m)
{
   while (vcos_mutex_lock(m) == VCOS_EAGAIN);
}

VCOS_INLINE_IMPL
void vcos_quickslow_mutex_unlock_quick(VCOS_QUICKSLOW_MUTEX_T *m)
{
   vcos_mutex_unlock(m);
}

#endif


#ifdef __cplusplus
}
#endif
#endif


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - reentrant mutexes created from regular ones.
=============================================================================*/

#ifndef VCOS_GENERIC_REENTRANT_MUTEX_H
#define VCOS_GENERIC_REENTRANT_MUTEX_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"

/**
 * \file
 *
 * Reentrant Mutexes from regular ones.
 *
 */

typedef struct VCOS_REENTRANT_MUTEX_T
{
   VCOS_MUTEX_T mutex;
   VCOS_THREAD_T *owner;
   unsigned count;
} VCOS_REENTRANT_MUTEX_T;

/* Extern definitions of functions that do the actual work */

VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_generic_reentrant_mutex_create(VCOS_REENTRANT_MUTEX_T *m, const char *name);

VCOSPRE_ void VCOSPOST_ vcos_generic_reentrant_mutex_delete(VCOS_REENTRANT_MUTEX_T *m);

VCOSPRE_ void VCOSPOST_ vcos_generic_reentrant_mutex_lock(VCOS_REENTRANT_MUTEX_T *m);

VCOSPRE_ void VCOSPOST_ vcos_generic_reentrant_mutex_unlock(VCOS_REENTRANT_MUTEX_T *m);

/* Inline forwarding functions */

#if defined(VCOS_INLINE_BODIES)

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_reentrant_mutex_create(VCOS_REENTRANT_MUTEX_T *m, const char *name) {
   return vcos_generic_reentrant_mutex_create(m,name);
}

VCOS_INLINE_IMPL
void vcos_reentrant_mutex_delete(VCOS_REENTRANT_MUTEX_T *m) {
   vcos_generic_reentrant_mutex_delete(m);
}

VCOS_INLINE_IMPL
void vcos_reentrant_mutex_lock(VCOS_REENTRANT_MUTEX_T *m) {
   vcos_generic_reentrant_mutex_lock(m);
}

VCOS_INLINE_IMPL
void vcos_reentrant_mutex_unlock(VCOS_REENTRANT_MUTEX_T *m) {
   vcos_generic_reentrant_mutex_unlock(m);
}
#endif

#ifdef __cplusplus
}
#endif
#endif


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - generic thread local storage
=============================================================================*/

#ifndef VCOS_GENERIC_TLS_H
#define VCOS_GENERIC_TLS_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"

/**
  * \file
  *
  * Do an emulation of Thread Local Storage. The platform needs to
  * provide a way to set and get a per-thread pointer which is
  * where the TLS data itself is stored.
  *
  *
  * Each thread that wants to join in this scheme needs to call
  * vcos_tls_thread_register().
  *
  * The platform needs to support the macros/functions
  * _vcos_tls_thread_ptr_set() and _vcos_tls_thread_ptr_get().
  */

#ifndef VCOS_WANT_TLS_EMULATION
#error Should not be included unless TLS emulation is defined
#endif

/** Number of slots to reserve per thread. This results in an overhead
  * of this many words per thread.
  */
#define VCOS_TLS_MAX_SLOTS 4

/** TLS key. Allocating one of these reserves the client one of the 
  * available slots.
  */
typedef VCOS_UNSIGNED VCOS_TLS_KEY_T;

/** TLS per-thread structure. Each thread gets one of these
  * if TLS emulation (rather than native TLS support) is
  * being used.
  */
typedef struct VCOS_TLS_THREAD_T
{
   void *slots[VCOS_TLS_MAX_SLOTS];
} VCOS_TLS_THREAD_T;

/*
 * Internal APIs 
 */

/** Register this thread's TLS storage area. */
VCOSPRE_ void VCOSPOST_ vcos_tls_thread_register(VCOS_TLS_THREAD_T *);

/** Create a new TLS key */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_generic_tls_create(VCOS_TLS_KEY_T *key);

/** Delete a TLS key */
VCOSPRE_ void VCOSPOST_ vcos_generic_tls_delete(VCOS_TLS_KEY_T tls);

/** Initialise the TLS library */
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_tls_init(void);

/** Deinitialise the TLS library */
VCOSPRE_ void VCOSPOST_ vcos_tls_deinit(void);

#if defined(VCOS_INLINE_BODIES)

#undef VCOS_ASSERT_LOGGING_DISABLE
#define VCOS_ASSERT_LOGGING_DISABLE 1

/*
 * Implementations of public API functions
 */

/** Set the given value. Since everything is per-thread, there is no need
  * for any locking.
  */
VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_tls_set(VCOS_TLS_KEY_T tls, void *v) {
   VCOS_TLS_THREAD_T *tlsdata = _vcos_tls_thread_ptr_get();
   vcos_assert(tlsdata); /* Fires if this thread has not been registered */
   if (tls<VCOS_TLS_MAX_SLOTS)
   {
      tlsdata->slots[tls] = v;
      return VCOS_SUCCESS;
   }
   else
   {
      vcos_assert(0);
      return VCOS_EINVAL;
   }
}

/** Get the given value. No locking required.
  */
VCOS_INLINE_IMPL
void *vcos_tls_get(VCOS_TLS_KEY_T tls) {
   VCOS_TLS_THREAD_T *tlsdata = _vcos_tls_thread_ptr_get();
   vcos_assert(tlsdata); /* Fires if this thread has not been registered */
   if (tls<VCOS_TLS_MAX_SLOTS)
   {
      return tlsdata->slots[tls];
   }
   else
   {
      vcos_assert(0);
      return NULL;
   }
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_tls_create(VCOS_TLS_KEY_T *key) {
   return vcos_generic_tls_create(key);
}

VCOS_INLINE_IMPL
void vcos_tls_delete(VCOS_TLS_KEY_T tls) {
   vcos_generic_tls_delete(tls);
}

#undef VCOS_ASSERT_LOGGING_DISABLE
#define VCOS_ASSERT_LOGGING_DISABLE 0

#endif /* VCOS_INLINE_BODIES */

#ifdef __cplusplus
}
#endif

#endif


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - implementation: joinable thread from plain
=============================================================================*/

/** \file
  *
  * Header file for platforms creating the joinable thread from a lowlevel
  * thread.
  *
  * In addition to the actual thread, the following are also created:
  *
  * - a semaphore to wait on when joining the thread
  * - a semaphore to support counted suspend/resume (used by event group)
  * - a per-thread timer (used by event group, but could be removed)
  */

#ifndef VCOS_JOINABLE_THREAD_FROM_PLAIN_H
#define VCOS_JOINABLE_THREAD_FROM_PLAIN_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef VCOS_SEMAPHORE_H
#include "interface/vcos/vcos_semaphore.h"
#endif
#ifndef VCOS_LOWLEVEL_THREAD_H
#include "interface/vcos/vcos_lowlevel_thread.h"
#endif
#ifndef VCOS_TIMER_H
#include "interface/vcos/vcos_timer.h"
#endif

#ifdef VCOS_WANT_TLS_EMULATION
#include "interface/vcos/generic/vcos_generic_tls.h"
#endif

#define VCOS_THREAD_MAGIC 0x56436a74

#define VCOS_THREAD_VALID(t) (t->magic == VCOS_THREAD_MAGIC)
#define VCOS_HAVE_THREAD_AT_EXIT        1

/** Thread attribute structure. Clients should not manipulate this directly, but
  * should instead use the provided functions.
  */
typedef struct VCOS_THREAD_ATTR_T
{
   void *ta_stackaddr;
   VCOS_UNSIGNED ta_stacksz;
   VCOS_UNSIGNED ta_priority;
   VCOS_UNSIGNED ta_affinity;
   VCOS_UNSIGNED ta_timeslice;
   VCOS_UNSIGNED legacy;
   VCOS_UNSIGNED ta_autostart;
} VCOS_THREAD_ATTR_T;

/** Each thread gets a timer, which is for internal VCOS use.
  */
typedef struct _VCOS_THREAD_TIMER_T
{
   VCOS_TIMER_T timer;
   void (*pfn)(void *);
   void *cxt;
} _VCOS_THREAD_TIMER_T;

typedef void (*VCOS_THREAD_EXIT_HANDLER_T)(void *);
/** Called at thread exit.
  */
typedef struct VCOS_THREAD_EXIT_T
{
   VCOS_THREAD_EXIT_HANDLER_T pfn;
   void *cxt;
} VCOS_THREAD_EXIT_T;
#define VCOS_MAX_EXIT_HANDLERS  8

/* The name field isn't used for anything, so we can just copy the
 * the pointer. Nucleus makes its own copy.
 */
typedef const char *          VCOS_LLTHREAD_T_NAME;
#define _VCOS_LLTHREAD_NAME(dst,src) (dst)=(src)

/*
 * Simulated TLS support
 */


/** Thread structure.
  *
  * \warning Do not access the members of this structure directly!
  */
typedef struct VCOS_THREAD_T
{
   VCOS_LLTHREAD_T  thread;      /**< The underlying thread */
   char name[16];                /**< The name */
   unsigned int     magic;       /**< For debug */
   void            *exit_data;   /**< Exit data passed out in vcos_joinable_thread_exit() */
   void            *stack;       /**< Stack, if not supplied by caller */
   VCOS_SEMAPHORE_T wait;        /**< Semaphore to wait on at join */
   VCOS_SEMAPHORE_T suspend;     /**< Semaphore to wait on for counted suspend */
   int16_t          joined;      /**< Joined yet? For debug. */
   VCOS_UNSIGNED    legacy;      /**< Use (argc,argv) for entry point arguments */
   void *(*entry)(void*);        /**< Entry point */
   void             *arg;        /**< Argument passed to entry point */
   void *(*term)(void*);         /**< Termination function, used by reaper */
   void             *term_arg;   /**< Argument passed to termination function */
   _VCOS_THREAD_TIMER_T _timer;  /**< Internal timer, mainly for event groups */
#ifdef VCOS_WANT_TLS_EMULATION
   VCOS_TLS_THREAD_T   _tls;     /**< TLS data when native TLS not available, or NULL */
#endif
   /** Array of functions to call at thread exit */
   VCOS_THREAD_EXIT_T at_exit[VCOS_MAX_EXIT_HANDLERS];

   struct VCOS_THREAD_T *next;   /**< For linked lists of threads */
} VCOS_THREAD_T;

#if defined(VCOS_INLINE_BODIES)

VCOS_INLINE_IMPL
void vcos_thread_attr_setstack(VCOS_THREAD_ATTR_T *attrs, void *addr, VCOS_UNSIGNED stacksz) {
   attrs->ta_stackaddr = addr;
   attrs->ta_stacksz = stacksz;
}

VCOS_INLINE_IMPL
void vcos_thread_attr_setstacksize(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED stacksz) {
   attrs->ta_stacksz = stacksz;
}

VCOS_INLINE_IMPL
void vcos_thread_attr_setpriority(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED pri) {
   attrs->ta_priority = pri;
}

VCOS_INLINE_IMPL
void vcos_thread_attr_setaffinity(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED affinity) {
   attrs->ta_affinity = affinity;
}

VCOS_INLINE_IMPL
void vcos_thread_attr_settimeslice(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED ts) {
   attrs->ta_timeslice = ts;
}

VCOS_INLINE_IMPL
void _vcos_thread_attr_setlegacyapi(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED legacy) {
   attrs->legacy = legacy;
}

VCOS_INLINE_IMPL
void vcos_thread_attr_setautostart(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED autostart) {
   attrs->ta_autostart = autostart;
}

VCOS_INLINE_IMPL
VCOS_THREAD_T *vcos_thread_current(void) {
   VCOS_THREAD_T *ret =  (VCOS_THREAD_T*)vcos_llthread_current();
   /*If we're called from a non-vcos thread, this assert will fail.
    *XXX FIXME why is this commented out?
    *vcos_assert(ret->magic == VCOS_THREAD_MAGIC);
    */
   return ret;
}

VCOS_INLINE_IMPL
int vcos_thread_running(VCOS_THREAD_T *thread) {
   return vcos_llthread_running(&thread->thread);
}

VCOS_INLINE_IMPL
void vcos_thread_resume(VCOS_THREAD_T *thread) {
   vcos_llthread_resume(&thread->thread);
}

#endif /* VCOS_INLINE_BODIES */

/**
  * \brief Create a VCOS_THREAD_T for the current thread. This is so we can have
  * VCOS_THREAD_Ts even for threads not originally created by VCOS (eg the
  * thread that calls vcos_init)
  */
extern VCOS_STATUS_T _vcos_thread_create_attach(VCOS_THREAD_T *thread,
                                                const char *name);

/**
  * \brief Deletes the VCOS_THREAD_T, but does not wait for the underlying
  * thread to exit. This will cleanup everything created by
  * _vcos_thread_create_attach
  */
extern void _vcos_thread_delete(VCOS_THREAD_T *thread);

/** Register a function to be called when the current thread exits.
  */
extern VCOS_STATUS_T vcos_thread_at_exit(void (*pfn)(void*), void *cxt);

/** Deregister a previously registered at-exit function.
  */
extern void vcos_thread_deregister_at_exit(void (*pfn)(void*), void *cxt);

#ifdef __cplusplus
}
#endif
#endif /* VCOS_JOINABLE_THREAD_FROM_PLAIN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - Construct a latch from a semaphore
=============================================================================*/

/** FIXME: rename to vcos_mutex_from_sem.c
  */

typedef struct VCOS_MUTEX_T {
   VCOS_SEMAPHORE_T sem;
   struct VCOS_THREAD_T *owner;
} VCOS_MUTEX_T;

extern VCOS_STATUS_T vcos_generic_mutex_create(VCOS_MUTEX_T *latch, const char *name);
extern void vcos_generic_mutex_delete(VCOS_MUTEX_T *latch);
extern VCOS_STATUS_T vcos_generic_mutex_lock(VCOS_MUTEX_T *latch);
extern void vcos_generic_mutex_unlock(VCOS_MUTEX_T *latch);

#if defined(VCOS_INLINE_BODIES)

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_mutex_create(VCOS_MUTEX_T *latch, const char *name) {
   return vcos_generic_mutex_create(latch,name);
}

VCOS_INLINE_IMPL
void vcos_mutex_delete(VCOS_MUTEX_T *latch) {
   vcos_generic_mutex_delete(latch);
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_mutex_lock(VCOS_MUTEX_T *latch) {
   return vcos_generic_mutex_lock(latch);
}

VCOS_INLINE_IMPL
void vcos_mutex_unlock(VCOS_MUTEX_T *latch) {
   vcos_generic_mutex_unlock(latch);
}

#endif /* VCOS_INLINE_BODIES */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
Create the vcos_malloc API from the regular system malloc/free
=============================================================================*/

/**
  * \file
  *
  * Create the vcos malloc API from a regular system malloc/free library.
  *
  * The API lets callers specify an alignment.
  *
  * Under VideoCore this is not needed, as we can simply use the rtos_malloc routines.
  * But on host platforms that won't be the case.
  *
  */

VCOSPRE_ void * VCOSPOST_  vcos_generic_mem_alloc(VCOS_UNSIGNED sz, const char *desc);
VCOSPRE_  void * VCOSPOST_ vcos_generic_mem_calloc(VCOS_UNSIGNED count, VCOS_UNSIGNED sz, const char *descr);
VCOSPRE_  void VCOSPOST_   vcos_generic_mem_free(void *ptr);
VCOSPRE_  void * VCOSPOST_ vcos_generic_mem_alloc_aligned(VCOS_UNSIGNED sz, VCOS_UNSIGNED align, const char *desc);

#ifdef VCOS_INLINE_BODIES

VCOS_INLINE_IMPL
void *vcos_malloc(VCOS_UNSIGNED size, const char *description) {
   return vcos_generic_mem_alloc(size, description);
}

VCOS_INLINE_IMPL
void *vcos_calloc(VCOS_UNSIGNED num, VCOS_UNSIGNED size, const char *description) {
   return vcos_generic_mem_calloc(num, size, description);
}

VCOS_INLINE_IMPL
void vcos_free(void *ptr) {
   vcos_generic_mem_free(ptr);
}

VCOS_INLINE_IMPL
void * vcos_malloc_aligned(VCOS_UNSIGNED size, VCOS_UNSIGNED align, const char *description) {
   return vcos_generic_mem_alloc_aligned(size, align, description);
}


#endif /* VCOS_INLINE_BODIES */


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - reentrant mutexes mapped directly to regular ones
=============================================================================*/

#ifndef VCOS_GENERIC_REENTRANT_MUTEX_H
#define VCOS_GENERIC_REENTRANT_MUTEX_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "interface/vcos/vcos_mutex.h"

/**
 * \file
 *
 * Reentrant Mutexes directly using the native re-entrant mutex.
 *
 */

typedef VCOS_MUTEX_T VCOS_REENTRANT_MUTEX_T;

/* Inline forwarding functions */

#if defined(VCOS_INLINE_BODIES)

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_reentrant_mutex_create(VCOS_REENTRANT_MUTEX_T *m, const char *name) {
   return vcos_mutex_create(m,name);
}

VCOS_INLINE_IMPL
void vcos_reentrant_mutex_delete(VCOS_REENTRANT_MUTEX_T *m) {
   vcos_mutex_delete(m);
}

VCOS_INLINE_IMPL
void vcos_reentrant_mutex_lock(VCOS_REENTRANT_MUTEX_T *m) {
   vcos_mutex_lock(m);
}

VCOS_INLINE_IMPL
void vcos_reentrant_mutex_unlock(VCOS_REENTRANT_MUTEX_T *m) {
   vcos_mutex_unlock(m);
}

VCOS_INLINE_IMPL
int vcos_reentrant_mutex_is_locked(VCOS_REENTRANT_MUTEX_T *m) {
   return vcos_mutex_is_locked(m);
}

#endif

#ifdef __cplusplus
}
#endif
#endif



                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - thread reaping
=============================================================================*/

#ifndef VCOS_THREAD_REAPER_H
#define VCOS_THREAD_REAPER_H

#define VCOS_HAVE_THREAD_REAPER

/** Initialise the thread reaper.
  */
VCOS_STATUS_T vcos_thread_reaper_init(void);

/** Reap a thread. Arranges for the thread to be automatically
  * joined.
  *
  * @sa vcos_thread_join().
  *
  * @param thread           the thread to terminate
  * @param on_terminated    called after the thread has exited
  * @param cxt              pass back to the callback
  *
  */
void vcos_thread_reap(VCOS_THREAD_T *thread, void (*on_terminated)(void*), void *cxt);

#endif


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
FIXME: This code should be moved to 'linux', it is linux-specific and not generic
on 'pthreads'.
============================================================================*/

#ifndef VCOS_MUTEX_FROM_FUTEX_H
#define VCOS_MUTEX_FROM_FUTEX_H

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vcos/vcos_types.h"
#include "vcos_platform.h"

typedef struct VCOS_FUTEX_T
{
   volatile int value;
} VCOS_FUTEX_T;

typedef VCOS_FUTEX_T VCOS_MUTEX_T;

VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_futex_init(VCOS_FUTEX_T *futex);
VCOSPRE_ void VCOSPOST_ vcos_futex_delete(VCOS_FUTEX_T *futex);
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_futex_lock(VCOS_FUTEX_T *futex);
VCOSPRE_ void VCOSPOST_ vcos_futex_unlock(VCOS_FUTEX_T *futex);
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_futex_trylock(VCOS_FUTEX_T *futex);

#if defined(VCOS_INLINE_BODIES)

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_mutex_create(VCOS_MUTEX_T *latch, const char *name) {
   vcos_unused(name);
   return vcos_futex_init(latch);
}

VCOS_INLINE_IMPL
void vcos_mutex_delete(VCOS_MUTEX_T *latch) {
   vcos_futex_delete(latch);
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_mutex_lock(VCOS_MUTEX_T *latch) {
   return vcos_futex_lock(latch);
}

VCOS_INLINE_IMPL
void vcos_mutex_unlock(VCOS_MUTEX_T *latch) {
   vcos_futex_unlock(latch);
}

VCOS_INLINE_IMPL
int vcos_mutex_is_locked(VCOS_MUTEX_T *latch) {
   int rc = latch->value;
   if (!rc) {
      /* it wasn't locked */
      return 0;
   }
   else {
      return 1; /* it was locked */
   }
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_mutex_trylock(VCOS_MUTEX_T *m) {
   return vcos_futex_trylock(m);
}

#endif /* VCOS_INLINE_BODIES */

#ifdef __cplusplus
}
#endif
#endif /* VCOS_MUTEX_FROM_FUTEX_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - pthreads types
=============================================================================*/

/* Do not include this file directly - instead include it via vcos.h */

/** @file
  *
  * Pthreads implementation of VCOS.
  *
  */

#ifndef VCOS_PLATFORM_H
#define VCOS_PLATFORM_H

#ifdef __cplusplus
extern "C" {
#endif

#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <sys/types.h>
#include <sched.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <time.h>
#include <signal.h>
#include <stddef.h>
#include <stdlib.h>
#include <dlfcn.h>


#define VCOS_HAVE_RTOS         1
#define VCOS_HAVE_SEMAPHORE    1
#define VCOS_HAVE_EVENT        1
#define VCOS_HAVE_QUEUE        0
#define VCOS_HAVE_LEGACY_ISR   0
#define VCOS_HAVE_TIMER        1
#define VCOS_HAVE_CANCELLATION_SAFE_TIMER 1
#define VCOS_HAVE_MEMPOOL      0
#define VCOS_HAVE_ISR          0
#define VCOS_HAVE_ATOMIC_FLAGS 1
#define VCOS_HAVE_THREAD_AT_EXIT        1
#define VCOS_HAVE_ONCE         1
#define VCOS_HAVE_BLOCK_POOL   1
#define VCOS_HAVE_FILE         0
#define VCOS_HAVE_PROC         0
#define VCOS_HAVE_CFG          0
#define VCOS_HAVE_ALIEN_THREADS  1
#define VCOS_HAVE_CMD          1
#define VCOS_HAVE_EVENT_FLAGS  1
#define VCOS_WANT_LOG_CMD      0    /* User apps should do their own thing */

#define VCOS_ALWAYS_WANT_LOGGING

#ifdef __linux__
#define VCOS_HAVE_BACKTRACE    1
#endif

#define VCOS_SO_EXT  ".so"

/* Linux/pthreads seems to have different timer characteristics */
#define VCOS_TIMER_MARGIN_EARLY 0
#define VCOS_TIMER_MARGIN_LATE 15

typedef sem_t                 VCOS_SEMAPHORE_T;
typedef uint32_t              VCOS_UNSIGNED;
typedef uint32_t              VCOS_OPTION;
typedef pthread_key_t         VCOS_TLS_KEY_T;
typedef pthread_once_t        VCOS_ONCE_T;

typedef struct VCOS_LLTHREAD_T
{
   pthread_t thread; // Must be first field.
} VCOS_LLTHREAD_T;

/* VCOS_CASSERT(offsetof(VCOS_LLTHREAD_T, thread) == 0); */

#ifndef VCOS_USE_VCOS_FUTEX
typedef pthread_mutex_t       VCOS_MUTEX_T;
#else
#include "vcos_futex_mutex.h"
#endif /* VCOS_USE_VCOS_FUTEX */

typedef struct
{
   VCOS_MUTEX_T   mutex;
   sem_t          sem;
} VCOS_EVENT_T;

#define VCOS_ONCE_INIT        PTHREAD_ONCE_INIT

typedef struct VCOS_TIMER_T
{
   pthread_t thread;                      /**< id of the timer thread */

   pthread_mutex_t lock;                  /**< lock protecting all other members of the struct */
   pthread_cond_t settings_changed;       /**< cond. var. for informing the timer thread about changes*/
   int quit;                              /**< non-zero if the timer thread is requested to quit*/

   struct timespec expires;               /**< absolute time of next expiration, or 0 if disarmed*/

   void (*orig_expiration_routine)(void*);/**< the expiration routine provided by the user of the timer*/
   void *orig_context;                    /**< the context for exp. routine provided by the user*/

} VCOS_TIMER_T;

/** Thread attribute structure. Don't use pthread_attr directly, as
  * the calls can fail, and inits must match deletes.
  */
typedef struct VCOS_THREAD_ATTR_T
{
   void *ta_stackaddr;
   VCOS_UNSIGNED ta_stacksz;
   VCOS_UNSIGNED ta_priority;
   VCOS_UNSIGNED ta_affinity;
   VCOS_UNSIGNED ta_timeslice;
   VCOS_UNSIGNED legacy;
} VCOS_THREAD_ATTR_T;

/** Called at thread exit.
  */
typedef struct VCOS_THREAD_EXIT_T
{
   void (*pfn)(void *);
   void *cxt;
} VCOS_THREAD_EXIT_T;
#define VCOS_MAX_EXIT_HANDLERS  4

typedef struct VCOS_THREAD_T
{
   pthread_t thread;             /**< The thread itself */
   VCOS_THREAD_ENTRY_FN_T entry; /**< The thread entry point */
   void *arg;                    /**< The argument to be passed to entry */
   VCOS_SEMAPHORE_T suspend;     /**< For support event groups and similar - a per thread semaphore */

   VCOS_TIMER_T task_timer;
   int task_timer_created;       /**< non-zero if the task timer has already been created*/
   void (*orig_task_timer_expiration_routine)(void*);
   void *orig_task_timer_context;

   VCOS_UNSIGNED legacy;
   char name[16];                /**< Record the name of this thread, for diagnostics */
   VCOS_UNSIGNED dummy;          /**< Dummy thread created for non-vcos created threads */

   /** Callback invoked at thread exit time */
   VCOS_THREAD_EXIT_T at_exit[VCOS_MAX_EXIT_HANDLERS];
} VCOS_THREAD_T;

#ifdef VCOS_PTHREADS_WANT_HISR_EMULATION

typedef struct
{
   VCOS_THREAD_T thread;
   char stack[1024];
   VCOS_SEMAPHORE_T waitsem;
} VCOS_HISR_T;

#endif

#define VCOS_SUSPEND          -1
#define VCOS_NO_SUSPEND       0

#define VCOS_START 1
#define VCOS_NO_START 0

#define VCOS_THREAD_PRI_MIN   (sched_get_priority_min(SCHED_OTHER))
#define VCOS_THREAD_PRI_MAX   (sched_get_priority_max(SCHED_OTHER))

#define VCOS_THREAD_PRI_INCREASE (1)
#define VCOS_THREAD_PRI_HIGHEST  VCOS_THREAD_PRI_MAX
#define VCOS_THREAD_PRI_LOWEST   VCOS_THREAD_PRI_MIN
#define VCOS_THREAD_PRI_NORMAL ((VCOS_THREAD_PRI_MAX+VCOS_THREAD_PRI_MIN)/2)
#define VCOS_THREAD_PRI_BELOW_NORMAL (VCOS_THREAD_PRI_NORMAL-VCOS_THREAD_PRI_INCREASE)
#define VCOS_THREAD_PRI_ABOVE_NORMAL (VCOS_THREAD_PRI_NORMAL+VCOS_THREAD_PRI_INCREASE)
#define VCOS_THREAD_PRI_REALTIME VCOS_THREAD_PRI_MAX

#define _VCOS_AFFINITY_DEFAULT 0
#define _VCOS_AFFINITY_CPU0    0x100
#define _VCOS_AFFINITY_CPU1    0x200
#define _VCOS_AFFINITY_MASK    0x300
#define VCOS_CAN_SET_STACK_ADDR  0

#define VCOS_TICKS_PER_SECOND _vcos_get_ticks_per_second()

#include "interface/vcos/generic/vcos_generic_event_flags.h"
#include "interface/vcos/generic/vcos_generic_blockpool.h"
#include "interface/vcos/generic/vcos_mem_from_malloc.h"

/** Convert errno values into the values recognized by vcos */
VCOSPRE_ VCOS_STATUS_T vcos_pthreads_map_error(int error);
VCOSPRE_ VCOS_STATUS_T VCOSPOST_ vcos_pthreads_map_errno(void);

/** Register a function to be called when the current thread exits.
  */
extern VCOS_STATUS_T vcos_thread_at_exit(void (*pfn)(void*), void *cxt);

extern uint32_t _vcos_get_ticks_per_second(void);

/**
 * Set to 1 by default when ANDROID is defined. Allows runtime
 * switching for console apps.
 */
extern int vcos_use_android_log;

typedef struct {
   VCOS_MUTEX_T mutex;
   uint32_t flags;
} VCOS_ATOMIC_FLAGS_T;

#if defined(VCOS_INLINE_BODIES)

#undef VCOS_ASSERT_LOGGING_DISABLE
#define VCOS_ASSERT_LOGGING_DISABLE 1


/*
 * Counted Semaphores
 */
VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_semaphore_wait(VCOS_SEMAPHORE_T *sem) {
   int ret;
   /* gdb causes sem_wait() to EINTR when a breakpoint is hit, retry here */
   while ((ret = sem_wait(sem)) == -1 && errno == EINTR)
      continue;
   vcos_assert(ret==0);
   return VCOS_SUCCESS;
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_semaphore_trywait(VCOS_SEMAPHORE_T *sem) {
   int ret;
   while ((ret = sem_trywait(sem)) == -1 && errno == EINTR)
      continue;
   if (ret == 0)
      return VCOS_SUCCESS;
   else if (errno == EAGAIN)
      return VCOS_EAGAIN;
   else {
      vcos_assert(0);
      return VCOS_EINVAL;
   }
}

/**
  * \brief Wait on a semaphore with a timeout.
  *
  * Note that this function may not be implemented on all
  * platforms, and may not be efficient on all platforms
  * (see comment in vcos_semaphore_wait)
  *
  * Try to obtain the semaphore. If it is already taken, return
  * VCOS_EAGAIN.
  * @param sem Semaphore to wait on
  * @param timeout Number of milliseconds to wait before
  *                returning if the semaphore can't be acquired.
  * @return VCOS_SUCCESS - semaphore was taken.
  *         VCOS_EAGAIN - could not take semaphore (i.e. timeout
  *         expired)
  *         VCOS_EINVAL - Some other error (most likely bad
  *         parameters).
  */
VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_semaphore_wait_timeout(VCOS_SEMAPHORE_T *sem, VCOS_UNSIGNED timeout) {
   struct timespec ts;
   int ret;
   if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
      return VCOS_EINVAL;
   ts.tv_sec  += timeout/1000;
   ts.tv_nsec += (timeout%1000)*1000*1000;
   if (ts.tv_nsec > 1000000000) {
      ts.tv_sec++;
      ts.tv_nsec -= 1000000000;
   }

   while (1) {
      ret = sem_timedwait( sem, &ts );
      if (ret == 0) {
         return VCOS_SUCCESS;
      } else {
         if (errno == EINTR) {
            continue;
         } else if (errno == ETIMEDOUT) {
            return VCOS_EAGAIN;
         } else {
            vcos_assert(0);
            return VCOS_EINVAL;
         }
      }
   }
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_semaphore_create(VCOS_SEMAPHORE_T *sem,
                                    const char *name,
                                    VCOS_UNSIGNED initial_count) {
   int rc = sem_init(sem, 0, initial_count);
   (void)name;
   if (rc != -1) return VCOS_SUCCESS;
   else return vcos_pthreads_map_errno();
}

VCOS_INLINE_IMPL
void vcos_semaphore_delete(VCOS_SEMAPHORE_T *sem) {
   int rc = sem_destroy(sem);
   vcos_assert(rc != -1);
   (void)rc;
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_semaphore_post(VCOS_SEMAPHORE_T *sem) {
   int rc = sem_post(sem);
   vcos_assert(rc == 0);
   (void)rc;
   return VCOS_SUCCESS;
}

/***********************************************************
 *
 * Threads
 *
 ***********************************************************/


extern VCOS_THREAD_T *vcos_dummy_thread_create(void);
extern pthread_key_t _vcos_thread_current_key;
extern uint64_t vcos_getmicrosecs64_internal(void);

VCOS_INLINE_IMPL
uint32_t vcos_getmicrosecs(void) { return (uint32_t)vcos_getmicrosecs64_internal(); }

VCOS_INLINE_IMPL
uint64_t vcos_getmicrosecs64(void) { return vcos_getmicrosecs64_internal(); }

VCOS_INLINE_IMPL
VCOS_THREAD_T *vcos_thread_current(void) {
   void *ret = pthread_getspecific(_vcos_thread_current_key);
   if (ret == NULL)
   {
      ret = vcos_dummy_thread_create();
   }

#ifdef __cplusplus
   return static_cast<VCOS_THREAD_T*>(ret);
#else
   return (VCOS_THREAD_T *)ret;
#endif
}

VCOS_INLINE_IMPL
void vcos_sleep(uint32_t ms) {
   struct timespec ts;
   ts.tv_sec = ms/1000;
   ts.tv_nsec = ms % 1000 * (1000000);
   nanosleep(&ts, NULL);
}

VCOS_INLINE_IMPL
void vcos_thread_attr_setstack(VCOS_THREAD_ATTR_T *attr, void *addr, VCOS_UNSIGNED sz) {
   attr->ta_stackaddr = addr;
   attr->ta_stacksz = sz;
}

VCOS_INLINE_IMPL
void vcos_thread_attr_setstacksize(VCOS_THREAD_ATTR_T *attr, VCOS_UNSIGNED sz) {
   attr->ta_stacksz = sz;
}

VCOS_INLINE_IMPL
void vcos_thread_attr_setpriority(VCOS_THREAD_ATTR_T *attr, VCOS_UNSIGNED pri) {
   (void)attr;
   (void)pri;
}

VCOS_INLINE_IMPL
void vcos_thread_set_priority(VCOS_THREAD_T *thread, VCOS_UNSIGNED p) {
   /* not implemented */
   (void)thread;
   (void)p;
}

VCOS_INLINE_IMPL
VCOS_UNSIGNED vcos_thread_get_priority(VCOS_THREAD_T *thread) {
   /* not implemented */
   (void)thread;
   return 0;
}

VCOS_INLINE_IMPL
void vcos_thread_set_affinity(VCOS_THREAD_T *thread, VCOS_UNSIGNED affinity) {
   /* not implemented */
   vcos_unused(thread);
   vcos_unused(affinity);
}


VCOS_INLINE_IMPL
void vcos_thread_attr_setaffinity(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED affinity) {
   attrs->ta_affinity = affinity;
}

VCOS_INLINE_IMPL
void vcos_thread_attr_settimeslice(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED ts) {
   attrs->ta_timeslice = ts;
}

VCOS_INLINE_IMPL
void _vcos_thread_attr_setlegacyapi(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED legacy) {
   attrs->legacy = legacy;
}

VCOS_INLINE_IMPL
void vcos_thread_attr_setautostart(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED autostart) {
   (void)attrs;
   (void)autostart;
}

VCOS_INLINE_IMPL
VCOS_LLTHREAD_T *vcos_llthread_current(void) {
   return (VCOS_LLTHREAD_T *)pthread_self();
}

VCOS_INLINE_IMPL
VCOS_UNSIGNED vcos_thread_get_affinity(VCOS_THREAD_T *thread) {
   vcos_unused(thread);
   return _VCOS_AFFINITY_CPU0;
}

VCOS_INLINE_IMPL
int vcos_thread_running(VCOS_THREAD_T *thread) {
   vcos_unused(thread);
   /* Not applicable to pthreads */
   return 0;
}

VCOS_INLINE_IMPL
VCOS_UNSIGNED vcos_change_preemption(VCOS_UNSIGNED pe) {
   vcos_unused(pe);
   /* Nothing to do */
   return 0;
}

VCOS_INLINE_IMPL
void vcos_thread_relinquish(void) {
   /* Nothing to do */
}

VCOS_INLINE_IMPL
void vcos_thread_resume(VCOS_THREAD_T *thread) {
   vcos_unused(thread);
   /* Nothing to do */
}


/*
 * Mutexes
 */

#ifndef VCOS_USE_VCOS_FUTEX

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_mutex_create(VCOS_MUTEX_T *latch, const char *name) {
   int rc = pthread_mutex_init(latch, NULL);
   (void)name;
   if (rc == 0) return VCOS_SUCCESS;
   else return vcos_pthreads_map_errno();
}

VCOS_INLINE_IMPL
void vcos_mutex_delete(VCOS_MUTEX_T *latch) {
   int rc = pthread_mutex_destroy(latch);
   (void)rc;
   vcos_assert(rc==0);
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_mutex_lock(VCOS_MUTEX_T *latch) {
   int rc = pthread_mutex_lock(latch);
   vcos_assert(rc==0);
   (void)rc;
   return VCOS_SUCCESS;
}

VCOS_INLINE_IMPL
void vcos_mutex_unlock(VCOS_MUTEX_T *latch) {
   int rc = pthread_mutex_unlock(latch);
   (void)rc;
   vcos_assert(rc==0);
}

VCOS_INLINE_IMPL
int vcos_mutex_is_locked(VCOS_MUTEX_T *m) {
   int rc = pthread_mutex_trylock(m);
   if (rc == 0) {
      pthread_mutex_unlock(m);
      /* it wasn't locked */
      return 0;
   }
   else {
      return 1; /* it was locked */
   }
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_mutex_trylock(VCOS_MUTEX_T *m) {
   int rc = pthread_mutex_trylock(m);
   (void)rc;
   return (rc == 0) ? VCOS_SUCCESS : VCOS_EAGAIN;
}

#endif /* VCOS_USE_VCOS_FUTEX */

/*
 * Events
 */

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_event_create(VCOS_EVENT_T *event, const char *debug_name)
{
   VCOS_STATUS_T status;

   int rc = sem_init(&event->sem, 0, 0);
   if (rc != 0) return vcos_pthreads_map_errno();

   status = vcos_mutex_create(&event->mutex, debug_name);
   if (status != VCOS_SUCCESS) {
      sem_destroy(&event->sem);
      return status;
   }

   return VCOS_SUCCESS;
}

VCOS_INLINE_IMPL
void vcos_event_signal(VCOS_EVENT_T *event)
{
   int ok = 0;
   int value;

   if (vcos_mutex_lock(&event->mutex) != VCOS_SUCCESS)
      goto fail_mtx;

   if (sem_getvalue(&event->sem, &value) != 0)
      goto fail_sem;

   if (value == 0)
      if (sem_post(&event->sem) != 0)
         goto fail_sem;

   ok = 1;
fail_sem:
   vcos_mutex_unlock(&event->mutex);
fail_mtx:
   vcos_assert(ok);
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_event_wait(VCOS_EVENT_T *event)
{
   int ret;
   /* gdb causes sem_wait() to EINTR when a breakpoint is hit, retry here */
   while ((ret = sem_wait(&event->sem)) == -1 && errno == EINTR)
      continue;
   vcos_assert(ret==0);
   return ret == 0 ? VCOS_SUCCESS : (VCOS_STATUS_T)errno;
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_event_try(VCOS_EVENT_T *event)
{
   int ret;
   while ((ret = sem_trywait(&event->sem)) == -1 && errno == EINTR)
      continue;

   if (ret == -1 && errno == EAGAIN)
      return VCOS_EAGAIN;
   else
      return VCOS_SUCCESS;
}

VCOS_INLINE_IMPL
void vcos_event_delete(VCOS_EVENT_T *event)
{
   int rc = sem_destroy(&event->sem);
   vcos_assert(rc != -1);
   (void)rc;

   vcos_mutex_delete(&event->mutex);
}

VCOS_INLINE_IMPL
VCOS_UNSIGNED vcos_process_id_current(void) {
   return (VCOS_UNSIGNED) getpid();
}

VCOS_INLINE_IMPL
int vcos_strcasecmp(const char *s1, const char *s2) {
   return strcasecmp(s1,s2);
}

VCOS_INLINE_IMPL
int vcos_strncasecmp(const char *s1, const char *s2, size_t n) {
   return strncasecmp(s1,s2,n);
}

VCOS_INLINE_IMPL
int vcos_in_interrupt(void) {
   return 0;
}

/* For support event groups - per thread semaphore */
VCOS_INLINE_IMPL
void _vcos_thread_sem_wait(void) {
   VCOS_THREAD_T *t = vcos_thread_current();
   vcos_semaphore_wait(&t->suspend);
}

VCOS_INLINE_IMPL
void _vcos_thread_sem_post(VCOS_THREAD_T *target) {
   vcos_semaphore_post(&target->suspend);
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_tls_create(VCOS_TLS_KEY_T *key) {
   int st = pthread_key_create(key, NULL);
   return st == 0 ? VCOS_SUCCESS: VCOS_ENOMEM;
}

VCOS_INLINE_IMPL
void vcos_tls_delete(VCOS_TLS_KEY_T tls) {
   pthread_key_delete(tls);
}

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_tls_set(VCOS_TLS_KEY_T tls, void *v) {
   pthread_setspecific(tls, v);
   return VCOS_SUCCESS;
}

VCOS_INLINE_IMPL
void *vcos_tls_get(VCOS_TLS_KEY_T tls) {
   return pthread_getspecific(tls);
}

/***********************************************************
 *
 * Timers
 *
 ***********************************************************/

//Other platforms can call compatible OS implementations directly
//from inline functions with minimal overhead.
//Pthreads needs a little bit more, so call functions
//in vcos_pthreads.c from the inline functions.
VCOS_STATUS_T vcos_pthreads_timer_create(VCOS_TIMER_T *timer,
                                const char *name,
                                void (*expiration_routine)(void *context),
                                void *context);
void vcos_pthreads_timer_set(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay_ms);
void vcos_pthreads_timer_cancel(VCOS_TIMER_T *timer);
void vcos_pthreads_timer_reset(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay_ms);
void vcos_pthreads_timer_delete(VCOS_TIMER_T *timer);

/** Create a timer.
  *
  * Note that we just cast the expiry function - this assumes that UNSIGNED
  * and VOID* are the same size.
  */


VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_timer_create(VCOS_TIMER_T *timer,
                                const char *name,
                                void (*expiration_routine)(void *context),
                                void *context) {
   return vcos_pthreads_timer_create(timer, name, expiration_routine, context);
}

VCOS_INLINE_IMPL
void vcos_timer_set(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay_ms) {
   return vcos_pthreads_timer_set(timer, delay_ms);
}

VCOS_INLINE_IMPL
void vcos_timer_cancel(VCOS_TIMER_T *timer) {
   return vcos_pthreads_timer_cancel(timer);
}

VCOS_INLINE_IMPL
void vcos_timer_reset(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay) {
   vcos_timer_set(timer, delay);
}

VCOS_INLINE_IMPL
void vcos_timer_delete(VCOS_TIMER_T *timer) {
   vcos_pthreads_timer_delete(timer);
}

#if VCOS_HAVE_ATOMIC_FLAGS

/*
 * Atomic flags
 */

/* TODO implement properly... */

VCOS_INLINE_IMPL
VCOS_STATUS_T vcos_atomic_flags_create(VCOS_ATOMIC_FLAGS_T *atomic_flags)
{
   atomic_flags->flags = 0;
   return vcos_mutex_create(&atomic_flags->mutex, "VCOS_ATOMIC_FLAGS_T");
}

VCOS_INLINE_IMPL
void vcos_atomic_flags_or(VCOS_ATOMIC_FLAGS_T *atomic_flags, uint32_t flags)
{
   vcos_mutex_lock(&atomic_flags->mutex);
   atomic_flags->flags |= flags;
   vcos_mutex_unlock(&atomic_flags->mutex);
}

VCOS_INLINE_IMPL
uint32_t vcos_atomic_flags_get_and_clear(VCOS_ATOMIC_FLAGS_T *atomic_flags)
{
   uint32_t flags;
   vcos_mutex_lock(&atomic_flags->mutex);
   flags = atomic_flags->flags;
   atomic_flags->flags = 0;
   vcos_mutex_unlock(&atomic_flags->mutex);
   return flags;
}

VCOS_INLINE_IMPL
void vcos_atomic_flags_delete(VCOS_ATOMIC_FLAGS_T *atomic_flags)
{
   vcos_mutex_delete(&atomic_flags->mutex);
}

#endif

#if defined(linux) || defined(_HAVE_SBRK)

/* not exactly the free memory, but a measure of it */

VCOS_INLINE_IMPL
unsigned long vcos_get_free_mem(void) {
   return (unsigned long)sbrk(0);
}

#endif

#ifdef VCOS_PTHREADS_WANT_HISR_EMULATION
VCOS_STATUS_T vcos_legacy_hisr_create(VCOS_HISR_T *hisr, const char *name,
                                      void (*entry)(void),
                                      VCOS_UNSIGNED pri,
                                      void *stack, VCOS_UNSIGNED stack_size);

void vcos_legacy_hisr_activate(VCOS_HISR_T *hisr);

void vcos_legacy_hisr_delete(VCOS_HISR_T *hisr);

#endif

#undef VCOS_ASSERT_LOGGING_DISABLE
#define VCOS_ASSERT_LOGGING_DISABLE 0

#endif /* VCOS_INLINE_BODIES */

#define  vcos_log_platform_init()               _vcos_log_platform_init()
VCOSPRE_ void VCOSPOST_             _vcos_log_platform_init(void);

VCOS_INLINE_DECL void _vcos_thread_sem_wait(void);
VCOS_INLINE_DECL void _vcos_thread_sem_post(VCOS_THREAD_T *);

#define VCOS_APPLICATION_ARGC          vcos_get_argc()
#define VCOS_APPLICATION_ARGV          vcos_get_argv()

#include "interface/vcos/generic/vcos_generic_reentrant_mtx.h"
#include "interface/vcos/generic/vcos_generic_named_sem.h"
#include "interface/vcos/generic/vcos_generic_quickslow_mutex.h"
#include "interface/vcos/generic/vcos_common.h"

#define _VCOS_LOG_LEVEL() getenv("VC_LOGLEVEL")

VCOS_STATIC_INLINE
char *vcos_strdup(const char *str)
{
   return strdup(str);
}

typedef void (*VCOS_ISR_HANDLER_T)(VCOS_UNSIGNED vecnum);

#define VCOS_DL_LAZY RTLD_LAZY
#define VCOS_DL_NOW  RTLD_NOW
#define VCOS_DL_LOCAL  RTLD_LOCAL
#define VCOS_DL_GLOBAL  RTLD_GLOBAL

#ifdef __cplusplus
}
#endif
#endif /* VCOS_PLATFORM_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - platform-specific types and defines
=============================================================================*/

#ifndef VCOS_PLATFORM_TYPES_H
#define VCOS_PLATFORM_TYPES_H

#include "interface/vcos/vcos_inttypes.h"

#ifdef __cplusplus
extern "C" {
#endif

#define VCOSPRE_ extern
#define VCOSPOST_

#if defined(__GNUC__) && (( __GNUC__ > 2 ) || (( __GNUC__ == 2 ) && ( __GNUC_MINOR__ >= 3 )))
#define VCOS_FORMAT_ATTR_(ARCHETYPE, STRING_INDEX, FIRST_TO_CHECK)  __attribute__ ((format (ARCHETYPE, STRING_INDEX, FIRST_TO_CHECK)))
#else
#define VCOS_FORMAT_ATTR_(ARCHETYPE, STRING_INDEX, FIRST_TO_CHECK)
#endif

#if defined(__linux__) && !defined(NDEBUG) && defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
   #define VCOS_BKPT ({ __asm volatile ("int3":::"memory"); })
#endif
/*#define VCOS_BKPT vcos_abort() */

#define VCOS_ASSERT_LOGGING         1
#define VCOS_ASSERT_LOGGING_DISABLE 0

extern void
vcos_pthreads_logging_assert(const char *file, const char *func, unsigned int line, const char *fmt, ...);

#define VCOS_ASSERT_MSG(...) ((VCOS_ASSERT_LOGGING && !VCOS_ASSERT_LOGGING_DISABLE) ? vcos_pthreads_logging_assert(__FILE__, __func__, __LINE__, __VA_ARGS__) : (void)0)

#define VCOS_INLINE_BODIES
#define VCOS_INLINE_DECL extern __inline__
#define VCOS_INLINE_IMPL static __inline__

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
Common image types used by the vc_image library.
=============================================================================*/

#ifndef INTERFACE_VC_DISPLAY_TYPES_H
#define INTERFACE_VC_DISPLAY_TYPES_H

//enums of display input format
typedef enum
{
   VCOS_DISPLAY_INPUT_FORMAT_INVALID = 0,
   VCOS_DISPLAY_INPUT_FORMAT_RGB888,
   VCOS_DISPLAY_INPUT_FORMAT_RGB565
}
VCOS_DISPLAY_INPUT_FORMAT_T;

/** For backward compatibility */
#define DISPLAY_INPUT_FORMAT_INVALID VCOS_DISPLAY_INPUT_FORMAT_INVALID
#define DISPLAY_INPUT_FORMAT_RGB888  VCOS_DISPLAY_INPUT_FORMAT_RGB888
#define DISPLAY_INPUT_FORMAT_RGB565  VCOS_DISPLAY_INPUT_FORMAT_RGB565
typedef VCOS_DISPLAY_INPUT_FORMAT_T DISPLAY_INPUT_FORMAT_T;

// Enum determining how image data for 3D displays has to be supplied
typedef enum
{
   DISPLAY_3D_UNSUPPORTED = 0,   // default
   DISPLAY_3D_INTERLEAVED,       // For autosteroscopic displays
   DISPLAY_3D_SBS_FULL_AUTO,     // Side-By-Side, Full Width (also used by some autostereoscopic displays)
   DISPLAY_3D_SBS_HALF_HORIZ,    // Side-By-Side, Half Width, Horizontal Subsampling (see HDMI spec)
   DISPLAY_3D_TB_HALF,           // Top-bottom 3D
   DISPLAY_3D_FRAME_PACKING,     // Frame Packed 3D
   DISPLAY_3D_FRAME_SEQUENTIAL,  // Output left on even frames and right on odd frames (typically 120Hz)
   DISPLAY_3D_FORMAT_MAX
} DISPLAY_3D_FORMAT_T;

//enums of display types
typedef enum
{
   DISPLAY_INTERFACE_MIN,
   DISPLAY_INTERFACE_SMI,
   DISPLAY_INTERFACE_DPI,
   DISPLAY_INTERFACE_DSI,
   DISPLAY_INTERFACE_LVDS,
   DISPLAY_INTERFACE_MAX

} DISPLAY_INTERFACE_T;

/* display dither setting, used on B0 */
typedef enum {
   DISPLAY_DITHER_NONE   = 0,   /* default if not set */
   DISPLAY_DITHER_RGB666 = 1,
   DISPLAY_DITHER_RGB565 = 2,
   DISPLAY_DITHER_RGB555 = 3,
   DISPLAY_DITHER_MAX
} DISPLAY_DITHER_T;

//info struct
typedef struct
{
   //type
   DISPLAY_INTERFACE_T type;
   //width / height
   uint32_t width;
   uint32_t height;
   //output format
   DISPLAY_INPUT_FORMAT_T input_format;
   //interlaced?
   uint32_t interlaced;
   /* output dither setting (if required) */
   DISPLAY_DITHER_T output_dither;
   /* Pixel frequency */
   uint32_t pixel_freq;
   /* Line rate in lines per second */
   uint32_t line_rate;
   // Format required for image data for 3D displays
   DISPLAY_3D_FORMAT_T format_3d;
   // If display requires PV1 (e.g. DSI1), special config is required in HVS
   uint32_t use_pixelvalve_1;
   // Set for DSI displays which use video mode.
   uint32_t dsi_video_mode;
   // Select HVS channel (usually 0).
   uint32_t hvs_channel;
} DISPLAY_INFO_T;

#endif /* __VC_INCLUDE_IMAGE_TYPES_H__ */


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Common image types used by the vc_image library

#ifndef INTERFACE_VC_IMAGE_TYPES_H
#define INTERFACE_VC_IMAGE_TYPES_H

/* This file gets included by the VCE compiler, which gets confused
 * easily by the VCOS headers. So cannot include vcos.h here.
 */
#include "interface/vcos/vcos_stdint.h"

/* We have so many rectangle types; let's try to introduce a common one. */
typedef struct tag_VC_RECT_T {
   int32_t x;
   int32_t y;
   int32_t width;
   int32_t height;
} VC_RECT_T;

struct VC_IMAGE_T;
typedef struct VC_IMAGE_T VC_IMAGE_T;

/* Types of image supported. */
/* Please add any new types to the *end* of this list.  Also update
 * case_VC_IMAGE_ANY_xxx macros (below), and the vc_image_type_info table in
 * vc_image/vc_image_helper.c.
 */
typedef enum
{
   VC_IMAGE_MIN = 0, //bounds for error checking

   VC_IMAGE_RGB565 = 1,
   VC_IMAGE_1BPP,
   VC_IMAGE_YUV420,
   VC_IMAGE_48BPP,
   VC_IMAGE_RGB888,
   VC_IMAGE_8BPP,
   VC_IMAGE_4BPP,    // 4bpp palettised image
   VC_IMAGE_3D32,    /* A separated format of 16 colour/light shorts followed by 16 z values */
   VC_IMAGE_3D32B,   /* 16 colours followed by 16 z values */
   VC_IMAGE_3D32MAT, /* A separated format of 16 material/colour/light shorts followed by 16 z values */
   VC_IMAGE_RGB2X9,   /* 32 bit format containing 18 bits of 6.6.6 RGB, 9 bits per short */
   VC_IMAGE_RGB666,   /* 32-bit format holding 18 bits of 6.6.6 RGB */
   VC_IMAGE_PAL4_OBSOLETE,     // 4bpp palettised image with embedded palette
   VC_IMAGE_PAL8_OBSOLETE,     // 8bpp palettised image with embedded palette
   VC_IMAGE_RGBA32,   /* RGB888 with an alpha byte after each pixel */ /* xxx: isn't it BEFORE each pixel? */
   VC_IMAGE_YUV422,   /* a line of Y (32-byte padded), a line of U (16-byte padded), and a line of V (16-byte padded) */
   VC_IMAGE_RGBA565,  /* RGB565 with a transparent patch */
   VC_IMAGE_RGBA16,   /* Compressed (4444) version of RGBA32 */
   VC_IMAGE_YUV_UV,   /* VCIII codec format */
   VC_IMAGE_TF_RGBA32, /* VCIII T-format RGBA8888 */
   VC_IMAGE_TF_RGBX32,  /* VCIII T-format RGBx8888 */
   VC_IMAGE_TF_FLOAT, /* VCIII T-format float */
   VC_IMAGE_TF_RGBA16, /* VCIII T-format RGBA4444 */
   VC_IMAGE_TF_RGBA5551, /* VCIII T-format RGB5551 */
   VC_IMAGE_TF_RGB565, /* VCIII T-format RGB565 */
   VC_IMAGE_TF_YA88, /* VCIII T-format 8-bit luma and 8-bit alpha */
   VC_IMAGE_TF_BYTE, /* VCIII T-format 8 bit generic sample */
   VC_IMAGE_TF_PAL8, /* VCIII T-format 8-bit palette */
   VC_IMAGE_TF_PAL4, /* VCIII T-format 4-bit palette */
   VC_IMAGE_TF_ETC1, /* VCIII T-format Ericsson Texture Compressed */
   VC_IMAGE_BGR888,  /* RGB888 with R & B swapped */
   VC_IMAGE_BGR888_NP,  /* RGB888 with R & B swapped, but with no pitch, i.e. no padding after each row of pixels */
   VC_IMAGE_BAYER,  /* Bayer image, extra defines which variant is being used */
   VC_IMAGE_CODEC,  /* General wrapper for codec images e.g. JPEG from camera */
   VC_IMAGE_YUV_UV32,   /* VCIII codec format */
   VC_IMAGE_TF_Y8,   /* VCIII T-format 8-bit luma */
   VC_IMAGE_TF_A8,   /* VCIII T-format 8-bit alpha */
   VC_IMAGE_TF_SHORT,/* VCIII T-format 16-bit generic sample */
   VC_IMAGE_TF_1BPP, /* VCIII T-format 1bpp black/white */
   VC_IMAGE_OPENGL,
   VC_IMAGE_YUV444I, /* VCIII-B0 HVS YUV 4:4:4 interleaved samples */
   VC_IMAGE_YUV422PLANAR,  /* Y, U, & V planes separately (VC_IMAGE_YUV422 has them interleaved on a per line basis) */
   VC_IMAGE_ARGB8888,   /* 32bpp with 8bit alpha at MS byte, with R, G, B (LS byte) */
   VC_IMAGE_XRGB8888,   /* 32bpp with 8bit unused at MS byte, with R, G, B (LS byte) */

   VC_IMAGE_YUV422YUYV,  /* interleaved 8 bit samples of Y, U, Y, V */
   VC_IMAGE_YUV422YVYU,  /* interleaved 8 bit samples of Y, V, Y, U */
   VC_IMAGE_YUV422UYVY,  /* interleaved 8 bit samples of U, Y, V, Y */
   VC_IMAGE_YUV422VYUY,  /* interleaved 8 bit samples of V, Y, U, Y */

   VC_IMAGE_RGBX32,      /* 32bpp like RGBA32 but with unused alpha */
   VC_IMAGE_RGBX8888,    /* 32bpp, corresponding to RGBA with unused alpha */
   VC_IMAGE_BGRX8888,    /* 32bpp, corresponding to BGRA with unused alpha */

   VC_IMAGE_YUV420SP,    /* Y as a plane, then UV byte interleaved in plane with with same pitch, half height */
   
   VC_IMAGE_YUV444PLANAR,  /* Y, U, & V planes separately 4:4:4 */

   VC_IMAGE_TF_U8,   /* T-format 8-bit U - same as TF_Y8 buf from U plane */
   VC_IMAGE_TF_V8,   /* T-format 8-bit U - same as TF_Y8 buf from V plane */
   
   VC_IMAGE_MAX,     //bounds for error checking
   VC_IMAGE_FORCE_ENUM_16BIT = 0xffff,
} VC_IMAGE_TYPE_T;

/* Image transformations (flips and 90 degree rotations).
   These are made out of 3 primitives (transpose is done first).
   These must match the DISPMAN and Media Player definitions. */

#define TRANSFORM_HFLIP     (1<<0)
#define TRANSFORM_VFLIP     (1<<1)
#define TRANSFORM_TRANSPOSE (1<<2)

typedef enum {
   VC_IMAGE_ROT0           = 0,
   VC_IMAGE_MIRROR_ROT0    = TRANSFORM_HFLIP,
   VC_IMAGE_MIRROR_ROT180  = TRANSFORM_VFLIP,
   VC_IMAGE_ROT180         = TRANSFORM_HFLIP|TRANSFORM_VFLIP,
   VC_IMAGE_MIRROR_ROT90   = TRANSFORM_TRANSPOSE,
   VC_IMAGE_ROT270         = TRANSFORM_TRANSPOSE|TRANSFORM_HFLIP,
   VC_IMAGE_ROT90          = TRANSFORM_TRANSPOSE|TRANSFORM_VFLIP,
   VC_IMAGE_MIRROR_ROT270  = TRANSFORM_TRANSPOSE|TRANSFORM_HFLIP|TRANSFORM_VFLIP,
} VC_IMAGE_TRANSFORM_T;

typedef enum
{ //defined to be identical to register bits
   VC_IMAGE_BAYER_RGGB     = 0,
   VC_IMAGE_BAYER_GBRG     = 1,
   VC_IMAGE_BAYER_BGGR     = 2,
   VC_IMAGE_BAYER_GRBG     = 3
} VC_IMAGE_BAYER_ORDER_T;

typedef enum
{ //defined to be identical to register bits
   VC_IMAGE_BAYER_RAW6     = 0,
   VC_IMAGE_BAYER_RAW7     = 1,
   VC_IMAGE_BAYER_RAW8     = 2,
   VC_IMAGE_BAYER_RAW10    = 3,
   VC_IMAGE_BAYER_RAW12    = 4,
   VC_IMAGE_BAYER_RAW14    = 5,
   VC_IMAGE_BAYER_RAW16    = 6,
   VC_IMAGE_BAYER_RAW10_8  = 7,
   VC_IMAGE_BAYER_RAW12_8  = 8,
   VC_IMAGE_BAYER_RAW14_8  = 9,
   VC_IMAGE_BAYER_RAW10L   = 11,
   VC_IMAGE_BAYER_RAW12L   = 12,
   VC_IMAGE_BAYER_RAW14L   = 13,
   VC_IMAGE_BAYER_RAW16_BIG_ENDIAN = 14, 
   VC_IMAGE_BAYER_RAW4    = 15,
} VC_IMAGE_BAYER_FORMAT_T;

#endif /* __VC_INCLUDE_IMAGE_TYPES_H__ */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * CEC related constants - shared by both host and vc.
 */

#ifndef _VC_CEC_H_
#define _VC_CEC_H_

#ifndef STRINGIFY
#define STRINGIFY(x) #x
#define TOSTRING(x)  STRINGIFY(x)
#endif

//Broadcast address and TV logical address
#define CEC_BROADCAST_ADDR       0x0F
#define CEC_TV_ADDRESS           0x00

//Maximum transmit length excluding the header byte */
#define CEC_MAX_XMIT_LENGTH      15  /* +1 for CEC Header Length */
//Invalid physical address
#define CEC_CLEAR_ADDR           0xFFFF  /* packed 16 bits of F.F.F.F */

/* ----------------------------------------------------------------------
 * general CEC defines
 * -------------------------------------------------------------------- */
//Maximum transmission length and invalid physical address are now in vc_cec.h
#define CEC_VERSION              0x04    /* HDMI 1.3a */
//This OUI ID is registered at the current HQ address in Irvine
#define CEC_VENDOR_ID_BROADCOM   (0x18C086L) // 24 bit OUI company id from IEEE. = Broadcom
//These three OUI IDs are registered with the old address of Irvine office in case you need them
//#define CEC_VENDOR_ID_BROADCOM   (0x000AF7L)
//#define CEC_VENDOR_ID_BROADCOM   (0x001018L)
//#define CEC_VENDOR_ID_BROADCOM   (0x001BE9L)
#define CEC_VENDOR_ID_ONKYO            (0x0009B0L)
#define CEC_VENDOR_ID_PANASONIC_EUROPE (0x000F12L)

//If we want to "pretend" to be somebody else use a different company id
#define CEC_VENDOR_ID  (0x000000L) //We should set the vendor id

#define CEC_BLOCKING             1
#define CEC_NONBLOCKING          0

/**
 * These are the logical addresses for all possible attached devices
 */
typedef enum CEC_AllDevices {
   CEC_AllDevices_eTV = 0,            /**<TV only */
   CEC_AllDevices_eRec1,              /**<Address for 1st Recording Device */
   CEC_AllDevices_eRec2,              /**<Address for 2nd Recording Device */
   CEC_AllDevices_eSTB1,              /**<Address for 1st SetTop Box Device */
   CEC_AllDevices_eDVD1,              /**<Address for 1st DVD Device */
   CEC_AllDevices_eAudioSystem,       /**<Address for Audio Device */
   CEC_AllDevices_eSTB2,              /**<Address for 2nd SetTop Box Device */
   CEC_AllDevices_eSTB3,              /**<Address for 3rd SetTop Box Device */
   CEC_AllDevices_eDVD2,              /**<Address for 2nd DVD Device */
   CEC_AllDevices_eRec3,              /**<Address for 3rd Recording Device */
   CEC_AllDevices_eSTB4,              /**<10 Address for 4th Tuner Device */
   CEC_AllDevices_eDVD3,              /**<11 Address for 3rd DVD Device */
   CEC_AllDevices_eRsvd3,             /**<Reserved and cannot be used */
   CEC_AllDevices_eRsvd4,             /**<Reserved and cannot be used */
   CEC_AllDevices_eFreeUse,           /**<Free Address, use for any device */
   CEC_AllDevices_eUnRegistered = 15  /**<UnRegistered Devices */
} CEC_AllDevices_T;

/**
 * define device types for <Report Physical Address>
 */
typedef enum CEC_DeviceTypes{
   CEC_DeviceType_TV           = 0, /**<TV only */
   CEC_DeviceType_Rec          = 1, /**<Recoding device */
   CEC_DeviceType_Reserved     = 2, /**<Reserved */
   CEC_DeviceType_Tuner        = 3, /**<STB */
   CEC_DeviceType_Playback     = 4, /**<DVD player */
   CEC_DeviceType_Audio        = 5, /**<AV receiver */
   CEC_DeviceType_Switch       = 6, /**<CEC switch */
   CEC_DeviceType_VidProc      = 7, /**<Video processor */

   CEC_DeviceType_Invalid      = 0xF, //RESERVED - DO NOT USE
} CEC_DEVICE_TYPE_T;

/**
 * Generic CEC opcode
 */
typedef enum {
   CEC_Opcode_FeatureAbort 	            = 0x00,
   CEC_Opcode_ImageViewOn 	            = 0x04,
   CEC_Opcode_TunerStepIncrement    	    = 0x05,
   CEC_Opcode_TunerStepDecrement    	    = 0x06,
   CEC_Opcode_TunerDeviceStatus 	    = 0x07,
   CEC_Opcode_GiveTunerDeviceStatus 	    = 0x08,
   CEC_Opcode_RecordOn 	                    = 0x09,
   CEC_Opcode_RecordStatus 	            = 0x0A,
   CEC_Opcode_RecordOff 	            = 0x0B,
   CEC_Opcode_TextViewOn 	            = 0x0D,
   CEC_Opcode_RecordTVScreen                = 0x0F,
   CEC_Opcode_GiveDeckStatus        	    = 0x1A,
   CEC_Opcode_DeckStatus 	            = 0x1B,
   CEC_Opcode_SetMenuLanguage               = 0x32,
   CEC_Opcode_ClearAnalogTimer              = 0x33,
   CEC_Opcode_SetAnalogTimer                = 0x34,
   CEC_Opcode_TimerStatus                   = 0x35,
   CEC_Opcode_Standby 	                    = 0x36,
   CEC_Opcode_Play                  	    = 0x41,
   CEC_Opcode_DeckControl 	            = 0x42,
   CEC_Opcode_TimerClearedStatus            = 0x43,
   CEC_Opcode_UserControlPressed 	    = 0x44,
   CEC_Opcode_UserControlReleased 	    = 0x45,
   CEC_Opcode_GiveOSDName           	    = 0x46,
   CEC_Opcode_SetOSDName 	            = 0x47,
   CEC_Opcode_SetOSDString 	            = 0x64,
   CEC_Opcode_SetTimerProgramTitle          = 0x67,
   CEC_Opcode_SystemAudioModeRequest        = 0x70,
   CEC_Opcode_GiveAudioStatus               = 0x71,
   CEC_Opcode_SetSystemAudioMode            = 0x72,
   CEC_Opcode_ReportAudioStatus             = 0x7A,
   CEC_Opcode_GiveSystemAudioModeStatus     = 0x7D,
   CEC_Opcode_SystemAudioModeStatus         = 0x7E,
   CEC_Opcode_RoutingChange 	            = 0x80,
   CEC_Opcode_RoutingInformation 	    = 0x81,
   CEC_Opcode_ActiveSource 	            = 0x82,
   CEC_Opcode_GivePhysicalAddress           = 0x83,
   CEC_Opcode_ReportPhysicalAddress         = 0x84,
   CEC_Opcode_RequestActiveSource 	    = 0x85,
   CEC_Opcode_SetStreamPath 	            = 0x86,
   CEC_Opcode_DeviceVendorID 	            = 0x87,
   CEC_Opcode_VendorCommand         	    = 0x89,
   CEC_Opcode_VendorRemoteButtonDown 	    = 0x8A,
   CEC_Opcode_VendorRemoteButtonUp    	    = 0x8B,
   CEC_Opcode_GiveDeviceVendorID    	    = 0x8C,
   CEC_Opcode_MenuRequest 	            = 0x8D,
   CEC_Opcode_MenuStatus 	            = 0x8E,
   CEC_Opcode_GiveDevicePowerStatus 	    = 0x8F,
   CEC_Opcode_ReportPowerStatus 	    = 0x90,
   CEC_Opcode_GetMenuLanguage               = 0x91,
   CEC_Opcode_SelectAnalogService           = 0x92,
   CEC_Opcode_SelectDigitalService   	    = 0x93,
   CEC_Opcode_SetDigitalTimer               = 0x97,
   CEC_Opcode_ClearDigitalTimer             = 0x99,
   CEC_Opcode_SetAudioRate                  = 0x9A,
   CEC_Opcode_InactiveSource        	    = 0x9D,
   CEC_Opcode_CECVersion                    = 0x9E,
   CEC_Opcode_GetCECVersion                 = 0x9F,
   CEC_Opcode_VendorCommandWithID           = 0xA0,
   CEC_Opcode_ClearExternalTimer            = 0xA1,
   CEC_Opcode_SetExternalTimer              = 0xA2,
   CEC_Opcode_ReportShortAudioDescriptor    = 0xA3,
   CEC_Opcode_RequestShortAudioDescriptor   = 0xA4,
   CEC_Opcode_InitARC                       = 0xC0,
   CEC_Opcode_ReportARCInited               = 0xC1,
   CEC_Opcode_ReportARCTerminated           = 0xC2,
   CEC_Opcode_RequestARCInit                = 0xC3,
   CEC_Opcode_RequestARCTermination         = 0xC4,
   CEC_Opcode_TerminateARC                  = 0xC5,
   CEC_Opcode_CDC                           = 0xF8,
   CEC_Opcode_Abort        	            = 0xFF
} CEC_OPCODE_T;

/**
 * Reason parameter for <Feature Abort>
 */
typedef enum {
   CEC_Abort_Reason_Unrecognised_Opcode   = 0,
   CEC_Abort_Reason_Wrong_Mode            = 1,
   CEC_Abort_Reason_Cannot_Provide_Source = 2,
   CEC_Abort_Reason_Invalid_Operand       = 3,
   CEC_Abort_Reason_Refused               = 4,
   CEC_Abort_Reason_Undetermined          = 5
} CEC_ABORT_REASON_T;

/**
 * Display control parameter for <Set OSD string>
 */
typedef enum {
   CEC_DISPLAY_CONTROL_DEFAULT_TIME       = 0,
   CEC_DISPLAY_CONTROL_UNTIL_CLEARED      = (1<<6),
   CEC_DISPLAY_CONTROL_CLEAR_PREV_MSG     = (1<<7)
} CEC_DISPLAY_CONTROL_T;

/**
 * Power status parameter for <Report Power Status>
 */
typedef enum {
   CEC_POWER_STATUS_ON                    = 0,
   CEC_POWER_STATUS_STANDBY               = 1,
   CEC_POWER_STATUS_ON_PENDING            = 2,
   CEC_POWER_STATUS_STANDBY_PENDING       = 3
} CEC_POWER_STATUS_T;

/**
 * Menu state parameter for <Menu Status>
 */
typedef enum {
   CEC_MENU_STATE_ACTIVATED               = 0,
   CEC_MENU_STATE_DEACTIVATED             = 1,
   CEC_MENU_STATE_QUERY                   = 2
} CEC_MENU_STATE_T;

/**
 * Deck status parameter for <Deck Status>
 */
typedef enum {
   CEC_DECK_INFO_PLAY                     = 0x11,
   CEC_DECK_INFO_RECORD                   = 0x12,
   CEC_DECK_INFO_PLAY_REVERSE             = 0x13,
   CEC_DECK_INFO_STILL                    = 0x14,
   CEC_DECK_INFO_SLOW                     = 0x15,
   CEC_DECK_INFO_SLOW_REVERSE             = 0x16,
   CEC_DECK_INFO_SEARCH_FORWARD           = 0x17,
   CEC_DECK_INFO_SEARCH_REVERSE           = 0x18,
   CEC_DECK_INFO_NO_MEDIA                 = 0x19,
   CEC_DECK_INFO_STOP                     = 0x1A,
   CEC_DECK_INFO_WIND                     = 0x1B,
   CEC_DECK_INFO_REWIND                   = 0x1C,
   CEC_DECK_IDX_SEARCH_FORWARD            = 0x1D,
   CEC_DECK_IDX_SEARCH_REVERSE            = 0x1E,
   CEC_DECK_OTHER_STATUS                  = 0x1F
} CEC_DECK_INFO_T;

/**
 * Deck control mode for <Deck Control>
 */
typedef enum {
   CEC_DECK_CTRL_FORWARD                  = 1,
   CEC_DECK_CTRL_BACKWARD                 = 2,
   CEC_DECK_CTRL_STOP                     = 3,
   CEC_DECK_CTRL_EJECT                    = 4
} CEC_DECK_CTRL_MODE_T;

/**
 * Play mode for <Play>
 */
typedef enum {
   CEC_PLAY_FORWARD                       = 0x24,
   CEC_PLAY_REVERSE                       = 0x20,
   CEC_PLAY_STILL                         = 0x25,
   CEC_PLAY_SCAN_FORWARD_MIN_SPEED        = 0x05,
   CEC_PLAY_SCAN_FORWARD_MED_SPEED        = 0x06,
   CEC_PLAY_SCAN_FORWARD_MAX_SPEED        = 0x07,
   CEC_PLAY_SCAN_REVERSE_MIN_SPEED        = 0x09,
   CEC_PLAY_SCAN_REVERSE_MED_SPEED        = 0x0A,
   CEC_PLAY_SCAN_REVERSE_MAX_SPEED        = 0x0B,
   CEC_PLAY_SLOW_FORWARD_MIN_SPEED        = 0x15,
   CEC_PLAY_SLOW_FORWARD_MED_SPEED        = 0x16,
   CEC_PLAY_SLOW_FORWARD_MAX_SPEED        = 0x17,
   CEC_PLAY_SLOW_REVERSE_MIN_SPEED        = 0x19,
   CEC_PLAY_SLOW_REVERSE_MED_SPEED        = 0x1A,
   CEC_PLAY_SLOW_REVERSE_MAX_SPEED        = 0x1B
} CEC_PLAY_MODE_T;

/**
 * Status request for <Give Deck Status>
 */
typedef enum {
   CEC_DECK_STATUS_ON                     = 1,
   CEC_DECK_STATUS_OFF                    = 2,
   CEC_DECK_STATUS_ONCE                   = 3
} CEC_DECK_STATUS_REQUEST_T;

/**
 * Button code for <User Control Pressed>
 */
typedef enum {
   CEC_User_Control_Select                      = 0x00,
   CEC_User_Control_Up                          = 0x01,
   CEC_User_Control_Down                        = 0x02,
   CEC_User_Control_Left                        = 0x03,
   CEC_User_Control_Right                       = 0x04,
   CEC_User_Control_RightUp                     = 0x05,
   CEC_User_Control_RightDown                   = 0x06,
   CEC_User_Control_LeftUp                      = 0x07,
   CEC_User_Control_LeftDown                    = 0x08,
   CEC_User_Control_RootMenu                    = 0x09,
   CEC_User_Control_SetupMenu                   = 0x0A,
   CEC_User_Control_ContentsMenu                = 0x0B,
   CEC_User_Control_FavoriteMenu                = 0x0C,
   CEC_User_Control_Exit                        = 0x0D,
   CEC_User_Control_Number0                     = 0x20,
   CEC_User_Control_Number1                     = 0x21,
   CEC_User_Control_Number2                     = 0x22,
   CEC_User_Control_Number3                     = 0x23,
   CEC_User_Control_Number4                     = 0x24,
   CEC_User_Control_Number5                     = 0x25,
   CEC_User_Control_Number6                     = 0x26,
   CEC_User_Control_Number7                     = 0x27,
   CEC_User_Control_Number8                     = 0x28,
   CEC_User_Control_Number9                     = 0x29,
   CEC_User_Control_Dot                         = 0x2A,
   CEC_User_Control_Enter                       = 0x2B,
   CEC_User_Control_Clear                       = 0x2C,
   CEC_User_Control_ChannelUp                   = 0x30,
   CEC_User_Control_ChannelDown                 = 0x31,
   CEC_User_Control_PreviousChannel             = 0x32,
   CEC_User_Control_SoundSelect                 = 0x33,
   CEC_User_Control_InputSelect                 = 0x34,
   CEC_User_Control_DisplayInformation          = 0x35,
   CEC_User_Control_Help                        = 0x36,
   CEC_User_Control_PageUp                      = 0x37,
   CEC_User_Control_PageDown                    = 0x38,
   CEC_User_Control_Power                       = 0x40,
   CEC_User_Control_VolumeUp                    = 0x41,
   CEC_User_Control_VolumeDown                  = 0x42,
   CEC_User_Control_Mute                        = 0x43,
   CEC_User_Control_Play                        = 0x44,
   CEC_User_Control_Stop                        = 0x45,
   CEC_User_Control_Pause                       = 0x46,
   CEC_User_Control_Record                      = 0x47,
   CEC_User_Control_Rewind                      = 0x48,
   CEC_User_Control_FastForward                 = 0x49,
   CEC_User_Control_Eject                       = 0x4A,
   CEC_User_Control_Forward                     = 0x4B,
   CEC_User_Control_Backward                    = 0x4C,
   CEC_User_Control_Angle                       = 0x50,
   CEC_User_Control_Subpicture                  = 0x51,
   CEC_User_Control_VideoOnDemand               = 0x52,
   CEC_User_Control_EPG                         = 0x53,
   CEC_User_Control_TimerProgramming            = 0x54,
   CEC_User_Control_InitialConfig               = 0x55,
   CEC_User_Control_PlayFunction                = 0x60,
   CEC_User_Control_PausePlayFunction           = 0x61,
   CEC_User_Control_RecordFunction              = 0x62,
   CEC_User_Control_PauseRecordFunction         = 0x63,
   CEC_User_Control_StopFunction                = 0x64,
   CEC_User_Control_MuteFunction                = 0x65,
   CEC_User_Control_RestoreVolumeFunction       = 0x66,
   CEC_User_Control_TuneFunction                = 0x67,
   CEC_User_Control_SelectDiskFunction          = 0x68,
   CEC_User_Control_SelectAVInputFunction       = 0x69,
   CEC_User_Control_SelectAudioInputFunction    = 0x6A,
   CEC_User_Control_F1Blue                      = 0x71,
   CEC_User_Control_F2Red                       = 0x72,
   CEC_User_Control_F3Green                     = 0x73,
   CEC_User_Control_F4Yellow                    = 0x74,
   CEC_User_Control_F5                          = 0x75
} CEC_USER_CONTROL_T;

/**
 *CEC topology struct
 *
 * Meaning of device_attr is as follows (one per active logical device)
 * bit 3-0 logical address (see CEC_AllDevices_T above)
 * bit 7-4 device type (see CEC_DEVICE_TYPE_T above)
 * bit 11-8 index to upstream device
 * bit 15-12 number of downstream device
 * bit 31-16 index of first 4 downstream devices
 * 
 * To keep life simple we only show the first 4 connected downstream devices
 *
 */
typedef struct {
   uint16_t active_mask;       /**<bit n is set if logical device n is active */
   uint16_t num_devices;       /**<no. of bits set above, save us from counting */
   uint32_t device_attr[16];   /**<Device attribute, see above for explanation */
} VC_CEC_TOPOLOGY_T;

/**
 * CEC message format (provided for host application's convenience
 * for encapsulating a CEC message
 */
typedef struct {
   uint32_t length; //Length of CEC message without the header, so zero indicates a poll message
   CEC_AllDevices_T initiator;
   CEC_AllDevices_T follower;
   uint8_t payload[CEC_MAX_XMIT_LENGTH+1]; //We actually only need 15 bytes, this payload does not include header
} VC_CEC_MESSAGE_T;

/**
 * CEC related notification
 */
typedef enum {
   VC_CEC_NOTIFY_NONE     = 0,        //Reserved - NOT TO BE USED
   VC_CEC_TX              = (1 << 0), /**<A message has been transmitted */
   VC_CEC_RX              = (1 << 1), /**<A message has arrived (only for registered commands) */
   VC_CEC_BUTTON_PRESSED  = (1 << 2), /**<<User Control Pressed> */
   VC_CEC_BUTTON_RELEASE  = (1 << 3), /**<<User Control Release> */
   VC_CEC_REMOTE_PRESSED  = (1 << 4), /**<<Vendor Remote Button Down> */
   VC_CEC_REMOTE_RELEASE  = (1 << 5), /**<<Vendor Remote Button Up> */
   VC_CEC_LOGICAL_ADDR    = (1 << 6), /**<New logical address allocated or released */
   VC_CEC_TOPOLOGY        = (1 << 7), /**<Topology is available */
   VC_CEC_LOGICAL_ADDR_LOST = (1 << 15) /**<Only for passive mode, if the logical address is lost for whatever reason, this will be triggered */
} VC_CEC_NOTIFY_T;


/**
 * Callback reason and arguments (for sending back to host) All parameters are uint32_t
 * For the reason parameter
 * Bit 15-0 of reason is the reason code, 
 * Bit 23-16 is length of valid bytes which follows in the 4 32-bit parameters (0 < length <= 16)
 * Bit 31-24 is any return code (if required for this callback)
 *
 * Length of valid bytes for TX/RX/button press/release callbacks will be the length
 * of the actual CEC message
 *
 * Length of valid bytes for logical address will always be 6 (first parameter + 16-bit physical address)
 *
 * Length of valid bytes for topology callback will always be 2 (16-bit mask)
 * 
 * Many CEC callback messages are of variable length so not all bytes 0-15 are available 
 *
 * Reason                  param1          param2       param3      param4           remark
 * VC_CEC_TX               bytes 0-3       bytes 4-7    bytes 8-11  bytes 12-15      A message has been transmitted 
 *                                                                                   Only a message sent from the host will 
                                                                                     generate this callback
                                                                                     (non-zero return code means failure)
                                                     
 * VC_CEC_RX               bytes 0-3       bytes 4-7    bytes 8-11  bytes 12-15      By definition only successful message will be forwarded
 *
 * VC_CEC_BUTTON_PRESSED   bytes 0-3       bytes 4-7     -           -               User Control pressed (byte 2 will be actual user control code)
 * VC_CEC_BUTTON_RELEASE   bytes 0-3          -          -           -               User Control release (byte 2 will be actual user control code)

 * VC_CEC_REMOTE_PRESSED   bytes 0-3       bytes 4-7    bytes 8-11  bytes 12-15      Vendor remote button down
 * VC_CEC_REMOTE_RELEASE   bytes 0-3       bytes 4-7    bytes 8-11  bytes 12-15      Vendor remote button up

 * VC_CEC_LOGICAL_ADDR     Log addr        Phy addr      -           -               Logical address allocated or failure
 * VC_CEC_TOPOLOGY         topology bit 
 *                         mask                                                      New topology is avaiable
 *
 *VC_CEC_LOGICAL_ADDR_LOST Last log addr   Phy addr                                  "Last log addr" is no longer available
 *
 * Notes: 
 * VC_CEC_BUTTON_RELEASE and VC_CEC_REMOTE_RELEASE (<User Control Release> and <Vendor Remote Button Up> messages respectively)
 * returns the code from the most recent <User Control pressed> <Vendor Remote button up> respectively.
 * The host application will need to find out the vendor ID of the initiator
 * separately in the case if <Vendor Remote Button Up>/<Vendor Remote Button Down> commands were received.
 * <User Control Pressed> will not be longer than 6 bytes (including header)
 *
 * VC_CEC_LOGICAL_ADDR returns 0xF in param1 whenever no logical address is in used. If physical address is 0xFFFF, 
 * this means CEC is being disabled. Otherwise physical address is the one read from EDID (and no suitable logical address 
 * is avaiable to be allocated). Host application should only attempt to send message if both param1 is not 0xF AND param2
 * is not 0xFFFF.
 *
 * VC_CEC_TOPOLOGY returns a 16-bit mask in param1 where bit n is set if logical address n is present. Host application
 * must explicitly retrieve the entire topology if it wants to know how devices are connected. The bit mask includes our
 * own logical address.
 *
 * If CEC is running in passive mode, the host will get a VC_CEC_LOGICAL_ADDR_LOST callback if the logical address is
 * lost (e.g. HDMI mode change). In this case the host should try a new logical address. The physical address returned may 
 * also change, so the host should check this.
 */

/**
 * General callback function for notifications from CEC middleware (and CEC service)
 *
 * @param client_p is the callback context passed in by user
 *
 * @param reason is the notification nature (plus message lengths, return code, etc.)
 *
 * @param param1 is the first parameter of notification (see above)
 *
 * @param param2 is the second parameter of notification (see above)
 *
 * @param param3 is the third parameter of notification (see above)
 *
 * @param param4 is the fourth parameter of notification (see above)
 *
 * @return void
 */
typedef void (*CEC_CALLBACK_T)(void *client_p, uint32_t reason, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4);

/**
 * Some macros to get some fields from the callback parameters in CEC callback 
 */
//Marcos operating on reason
#define CEC_CB_REASON(x) ((x) & 0xFFFF) /** Get callback reason */
#define CEC_CB_MSG_LENGTH(x) (((x) >> 16) & 0xFF) /** Get callback parameter length (this includes the header byte) */
#define CEC_CB_RC(x) (((x) >> 24) & 0xFF) /** Get return value (only for TX callbacks for the moment) */

//Macros operating on param1
#define CEC_CB_INITIATOR(x) (((x) >> 4) & 0xF) /** Get the initiator from first parameter */
#define CEC_CB_FOLLOWER(x) ((x) & 0xF) /** Get the follower from first parameter */
#define CEC_CB_OPCODE(x) (((x) >> 8) & 0xFF) /** Get the opcode from first parameter */
#define CEC_CB_OPERAND1(x) (((x) >> 16) & 0xFF) /** Get the button code from <User Control Pressed> or the first operand of the opcode */
#define CEC_CB_OPERAND2(x) (((x) >> 24) & 0xFF) /** Get the second operand of opcode */

//CEC service return code
typedef enum {
   VC_CEC_SUCCESS                = 0, /** OK */
   VC_CEC_ERROR_NO_ACK           = 1, /** No acknowledgement */
   VC_CEC_ERROR_SHUTDOWN         = 2, /** In the process of shutting down */
   VC_CEC_ERROR_BUSY             = 3, /** block is busy */
   VC_CEC_ERROR_NO_LA            = 4, /** No logical address */
   VC_CEC_ERROR_NO_PA            = 5, /** No physical address */
   VC_CEC_ERROR_NO_TOPO          = 6, /** No topology */
   VC_CEC_ERROR_INVALID_FOLLOWER = 7, /** Invalid follower */
   VC_CEC_ERROR_INVALID_ARGUMENT = 8  /** Invalid arguments */
} VC_CEC_ERROR_T;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * CEC service host API, 
 * See vc_cec.h and vc_cecservice_defs.h for related constants
 */

#ifndef _VC_CECSERVICE_H_
#define _VC_CECSERVICE_H_

#include "vcinclude/common.h"
#include "interface/vcos/vcos.h"
#include "interface/vchi/vchi.h"
#include "interface/vmcs_host/vc_cecservice_defs.h"
#include "interface/vmcs_host/vc_cec.h"

/**
 * \file
 * This API defines the controls for CEC. HDMI must be powered on before
 * CEC is available (subject to CEC support in TV). 
 *
 * In general, a zero return value indicates success; a negative return
 * value indicates error in VCHI layer; a positive return value indicates
 * alternative return value from the server
 */

/**
 * Callback function for host side notification 
 * This is the SAME as the callback function type defined in vc_cec.h
 * Host applications register a single callback for all CEC related notifications.
 * See vc_cec.h for meanings of all parameters
 *
 * @param callback_data is the context passed in by user in <DFN>vc_cec_register_callback</DFN>
 *
 * @param reason bits 15-0 is VC_CEC_NOTIFY_T in vc_cec.h;
 *               bits 23-16 is the valid length of message in param1 to param4 (LSB of param1 is the byte0, MSB of param4 is byte15), little endian
 *               bits 31-24 is the return code (if any)
 *
 * @param param1 is the first parameter
 * 
 * @param param2 is the second parameter
 *
 * @param param3 is the third parameter
 *
 * @param param4 is the fourth parameter
 * 
 * @return void
 */
typedef void (*CECSERVICE_CALLBACK_T)(void *callback_data, uint32_t reason, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4);

//API at application start time
/**
 * Call <DFN>vc_vchi_cec_init</DFN> to initialise the CEC service for use.
 *
 * @param initialise_instance is the VCHI instance
 * @param connections are array of pointers to VCHI connections
 * @param num_connections is the number of connections in array
 * @return void
 **********************************************************/
VCHPRE_ void vc_vchi_cec_init(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );

/**
 * Call <DFN>vc_vchi_cec_stop</DFN> to stop host side CEC service.
 *
 * @param none
 * @return void
 **********************************************************/
VCHPRE_ void vc_vchi_cec_stop( void );

/**
 * Host applications use <DFN>vc_cec_register_callaback</DFN> to register
 * callback to handle all CEC notifications. If more than one applications 
 * need to use CEC, there should be ONE central application which acts on
 * behalf of all clients and handles all communications with CEC services.
 *
 * @param callback function 
 * @param context to be passed when function is called
 * @return void
 ***********************************************************/
VCHPRE_ void vc_cec_register_callback(CECSERVICE_CALLBACK_T callback, void *callback_data);

//Service API
/**
 * Use <DFN>vc_cec_register_command</DFN> to register an opcode to
 * to forwarded to the host application. By default <Feature Abort> 
 * is always forwarded. Once an opcode is registered, it is left to
 * the host application to reply to a CEC message (where appropriate).
 * It is recommended NOT to register the following commands as they 
 * are replied to automatically by CEC middleware:
 * <Give Physical Address>, <Give Device Vendor ID>, <Give OSD Name>,
 * <Get CEC Version>, <Give Device Power Status>, <Menu Request>,
 * and <Get Menu Language>
 * In addition, the following opcodes cannot be registered:
 * <User Control Pressed>, <User Control Released>, 
 * <Vendor Remote Button Down>, <Vendor Remote Button Up>,
 * and <Abort>.
 * <Feature Abort> is always forwarded if it is the reply
 * of a command the host sent.
 *
 * @param opcode to be registered.
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_register_command(CEC_OPCODE_T opcode);

/**
 * <DFN>vc_cec_register_all</DFN> registers all opcodes except <Abort>
 *  to be forwarded as CEC_RX notification.
 * Button presses <User Control Pressed>, etc. will still be forwarded 
 * separately as VC_CEC_BUTTON_PRESSED etc. notification.
 *
 * @param None
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_register_all( void );

/**
 * Use <DFN>vc_cec_deregister_command</DFN> to remove an opcode from
 * the filter for forwarding. By default <Feature Abort> is always forwarded.
 * The following opcode cannot be deregistered:
 * <User Control Pressed>, <User Control Released>, 
 * <Vendor Remote Button Down>, <Vendor Remote Button Up>,
 * and <Abort>.
 *
 * @param opcode to be deregistered
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_deregister_command(CEC_OPCODE_T opcode);

/**
 * <DFN>vc_cec_deregister_all</DFN> removes all registered opcodes,
 * except the ones (e.g. button presses) which are always forwarded.
 *
 * @param None
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_deregister_all( void );

/**
 * <DFN>vc_cec_send_message</DFN> allows a host application to 
 * send a CEC message to another device. There are several 
 * built-in functions for sending command messages. The host
 * application MUST have a valid logical address (between 1 and
 * 14 inclusive) before it can send a message.
 * (For poll message set payload to NULL and length to zero).
 *
 * @param Follower's logical address
 *
 * @param Message payload WITHOUT the header byte (can be NULL)
 *
 * @param Payload length WITHOUT the header byte (can be zero)
 *
 * @param VC_TRUE if the message is a reply to an incoming message
 *
 * @return zero if the command is successful, non-zero otherwise
 *         If the command is successful, there will be a Tx callback
 *         in due course to indicate whether the message has been
 *         acknowledged by the recipient or not
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_send_message(const uint32_t follower,
                                         const uint8_t *payload,
                                         uint32_t length,
                                         vcos_bool_t is_reply);
/**
 * <DFN>vc_cec_get_logical_address</DFN> gets the logical address, 
 * If one is being allocated 0xF (unregistered) will be set.
 * A address value of 0xF also means CEC system is not yet ready
 * to send or receive any messages.
 *
 * @param pointer to logical address (set to allocated address)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         logical_address is not modified if command failed
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_get_logical_address(CEC_AllDevices_T *logical_address);

/**
 * <DFN>vc_cec_alloc_logical_address</DFN> starts the allocation 
 * of a logical address. Logical address is automatically allocated
 * after HDMI power on is complete and AV mute is deassert.
 * The host only needs to call this if the 
 * initial allocation failed (logical address being 0xF and 
 * physical address is NOT 0xFFFF from <DFN>VC_CEC_LOGICAL_ADDR</DFN>
 * notification), or if the host explicitly released its logical 
 * address.
 *
 * @param none
 *
 * @return zero if the command is successful, non-zero otherwise
 *         If successful, there will be a callback notification
 *         <DFN>VC_CEC_LOGICAL_ADDR</DFN>. 
 *         The host should wait for this before calling this 
 *         function again.
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_alloc_logical_address( void );

/**
 * Normally <DFN>vc_cec_release_logical_address</DFN> will not 
 * be called by the host application. It is used to release 
 * our logical address. This effectively disables CEC.
 * The host will need to allocate a new logical address before
 * doing any CEC calls (send/receive message, get topology, etc.). 
 *
 * @param none
 *
 * @return zero if the command is successful, non-zero otherwise
 *         The host should get a callback <DFN>VC_CEC_LOGICAL_ADDR</DFN>
 *         with 0xF being the logical address and 0xFFFF 
 *         being the physical address.
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_release_logical_address( void );

/**
 * Use <DFN>vc_cec_get_topology</DFN> to get the topology.
 *
 * @param pointer to <DFN>VC_CEC_TOPOLOGY_T</DFN>
 *
 * @return zero if the command is successful, non-zero otherwise
 *         If successful, the topology will be set, otherwise it is unchanged
 *         A topology with only 1 device (us) means CEC is not supported.
 *         If there is no topology available, this also returns a failure.
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_get_topology( VC_CEC_TOPOLOGY_T* topology);

/**
 * Use <DFN>vc_cec_set_vendor_id</DFN> to 
 * set the response to <Give Device Vendor ID>
 *
 * @param 24-bit IEEE vendor id
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_set_vendor_id( const uint32_t id );

/**
 * Use <DFN>vc_cec_set_osd_name</DFN> to
 * set the response to <Give OSD Name>
 * 
 * @param OSD name (14 byte char array)
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_set_osd_name( const char* name );

/**
 * <DFN>vc_cec_get_physical_address</DFN> gets our physical address
 *
 * @param pointer to physical address (returned as 16-bit packed value)
 *
 * @return zero if the command is successful, non-zero otherwise
 *          If failed, physical address argument will not be changed
 *          A physical address of 0xFFFF means CEC is not supported
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_get_physical_address(uint16_t *physical_address);

/**
 * <DFN>vc_cec_get_vendor_id(</DFN> gets the vendor id of a particular logical address
 *
 * @param logical_address is the logical address of the device [in]
 *
 * @param vendorid is the pointer to vendor ID (24-bit IEEE OUI value) [out]
 *
 * @return zero if the command is successful, non-zero otherwise
 *         If failed, vendor id argument will not be changed
 *         A vendor ID of 0xFFFFFF means the device does not exist
 *         A vendor ID of 0x0 means vendor ID is not known and
 *         the application can send <Give Device Vendor ID> to that device
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_get_vendor_id(const CEC_AllDevices_T logical_address, uint32_t *vendor_id);

/**
 * <DFN>vc_cec_device_type(</DFN> returns the default device type of a particular
 * logical address, which can be used as the argument to vc_cec_send_ReportPhysicalAddress.
 *
 * @param logical address
 *
 * @return the default device type, if there is any error, the return device
 *         type will be CEC_DeviceType_Invalid
 *
 ************************************************************/
VCHPRE_ CEC_DEVICE_TYPE_T VCHPOST_ vc_cec_device_type(const CEC_AllDevices_T logical_address);

/**
 * These couple of functions are provided for host application's convenience:
 * If the xmit message is encapsulate in a VC_CEC_MESSAGE_T
 * then it can be sent as a normal message (not as a reply)
 * and the initiator field is ignored with vc_cec_send_message2
 * and return zero for success
 * 
 * Applications can call vc_cec_param2message to turn the callback parameters
 * into a VC_CEC_MESSAGE_T (not for LOGICAL_ADDR and TOPOLOGY callbacks). 
 * It also returns zero for success.
 */
VCHPRE_ int VCHPOST_ vc_cec_send_message2(const VC_CEC_MESSAGE_T *message);

VCHPRE_ int VCHPOST_ vc_cec_param2message( const uint32_t reason, const uint32_t param1, 
                                           const uint32_t param2, const uint32_t param3,
                                           const uint32_t param4, VC_CEC_MESSAGE_T *message);

//Extra API if CEC is running in passive mode
//If CEC is not in passive mode the following 3 functions always
//return failure
/**
 * <DFN> vc_cec_poll_address </DFN> sets and polls a particular address to find out
 * its availability in the CEC network. Only available when CEC is running in passive
 * mode. The host can only call this function during logical address allocation stage.
 *
 * @param logical address to try
 *
 * @return 0 if poll is successful (address is occupied)
 *        >0 if poll is unsuccessful (Error code is in VC_CEC_ERROR_T in vc_cec.h)
 *        <0 VCHI errors
 */
VCHPRE_ int VCHPOST_ vc_cec_poll_address(const CEC_AllDevices_T logical_address);

/**
 * <DFN> vc_cec_set_logical_address </DFN> sets the logical address, device type
 * and vendor ID to be in use. Only available when CEC is running in passive
 * mode. It is the responsibility of the host to make sure the logical address
 * is actually free to be used. Physical address will be what is read from EDID.
 *
 * @param logical address
 *
 * @param device type
 *
 * @param vendor ID
 *
 * @return 0 if successful, non-zero otherwise
 */
VCHPRE_ int VCHPOST_ vc_cec_set_logical_address(const CEC_AllDevices_T logical_address,
                                                const CEC_DEVICE_TYPE_T device_type,
                                                const uint32_t vendor_id);

/**
 * <DFN> vc_cec_add_device </DFN> adds a new device to topology. 
 * Only available when CEC is running in passive mode. Device will be
 * automatically removed from topology if a failed xmit is detected.
 * If last_device is true, it will trigger a topology computation
 * (and may trigger a topology callback).
 *
 * @param logical address
 * 
 * @param physical address
 *
 * @param device type
 *
 * @param true if this is the last device, false otherwise
 *
 * @return 0 if successful, non-zero otherwise
 */
VCHPRE_ int VCHPOST_ vc_cec_add_device(const CEC_AllDevices_T logical_address,
                                       const uint16_t physical_address,
                                       const CEC_DEVICE_TYPE_T device_type,
                                       vcos_bool_t last_device);

/**
 * <DFN> vc_cec_set_passive </DFN> enables and disables passive mode.
 * Call this function first (with VC_TRUE as the argument) to enable
 * passive mode before calling any of the above passive API functions
 *
 * @param TRUE to enable passive mode, FALSE to disable
 * 
 * @return 0 if successful, non-zero otherwise
 */
VCHPRE_ int VCHPOST_ vc_cec_set_passive(vcos_bool_t enabled);


//API for some common CEC messages
/** 
 * Functions beginning with vc_cec_send_xxx make it easier for the 
 * host application to send CEC message xxx to other devices
 */
/**
 * <DFN>vc_cec_send_FeatureAbort</DFN> sends <Feature Abort> 
 * for a received command.
 *
 * @param follower (cannot be 0xF)
 *
 * @param rejected opcode
 *
 * @param reject reason <DFN>CEC_ABORT_REASON_T</DFN>
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_send_FeatureAbort(uint32_t follower, 
                                              CEC_OPCODE_T opcode, 
                                              CEC_ABORT_REASON_T reason);

/**
 * <DFN>vc_cec_send_ActiveSource</DFN> broadcasts
 * <Active Source> to all devices
 *
 * @param physical address (16-bit packed)
 *
 * @param reply or not (normally not)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_send_ActiveSource(uint16_t physical_address, vcos_bool_t is_reply);

/**
 * <DFN>vc_cec_send_ImageViewOn</DFN> sends <Image View On>
 * 
 * @param follower
 *
 * @param reply or not (normally not)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_send_ImageViewOn(uint32_t follower, vcos_bool_t is_reply);

/**
 * <DFN>vc_cec_send_SetOSDString</DFN> sends <Set OSD String>
 *
 * @param follower 
 *
 * @param string (char[13]) 
 *
 * @param display control <DFN>CEC_DISPLAY_CONTROL_T</DFN>
 *
 * @param reply or not (normally not)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_send_SetOSDString(uint32_t follower, 
                                              CEC_DISPLAY_CONTROL_T disp_ctrl, 
                                              const char* string,
                                              vcos_bool_t is_reply);

/**
 * <DFN>vc_cec_send_Standby</DFN> sends <Standby>.
 * This will put any/all devices to standby if they support
 * this CEC message.
 *
 * @param follower (can be 0xF)
 *
 * @param reply or not (normally not)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_send_Standby(uint32_t follower, vcos_bool_t is_reply);

/**
 * <DFN>vc_cec_send_MenuStatus</DFN> sends <Menu Status> 
 * (response to <Menu Request>)
 *
 * @param follower
 * 
 * @param menu state <DFN>CEC_MENU_STATE_T</DFN> but NOT CEC_MENU_STATE_QUERY
 *
 * @param reply or not (should always be yes)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_send_MenuStatus(uint32_t follower, 
                                            CEC_MENU_STATE_T menu_state, 
                                            vcos_bool_t is_reply);

/**
 * <DFN>vc_cec_send_ReportPhysicalAddress</DFN> broadcasts
 * <Report Physical Address> to all devices. Note although
 * the passed in device type can be override the default one 
 * associated the allocated logical address, it is not 
 * recommended to do so. One can use <DFN>vc_cec_device_type</DFN>
 * to get the default device type associated with the logical 
 * address returned via VC_CEC_LOGICAL_ADDR callback.
 *
 * @param physical address (16-bit packed)
 *
 * @param device type to be broadcasted
 *
 * @param reply or not (normally not)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
VCHPRE_ int VCHPOST_ vc_cec_send_ReportPhysicalAddress(uint16_t physical_address, 
                                                       CEC_DEVICE_TYPE_T device_type,
                                                       vcos_bool_t is_reply);

#endif //_VC_CECSERVICE_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * CEC service command enumeration and parameter types.
 */

/**
 * \file
 * This file contains definition shared by host side and
 * Videocore side CEC service:
 *
 * In general, a zero return value indicates success of the function
 * A non-zero value indicates VCHI error
 * A positive value indicates alternative return value (for some functions).
 *
 */


#ifndef _VC_CECSERVICE_DEFS_H_
#define _VC_CECSERVICE_DEFS_H_
#include "vcinclude/common.h"
#include "interface/vcos/vcos.h"
#include "interface/vcos/vcos_logging.h"
#include "interface/vchi/message_drivers/message.h"

//CEC VCOS logging stuff
#define CECHOST_LOG_CATEGORY (&cechost_log_category)
#define vc_cec_log_trace(...) _VCOS_LOG_X(CECHOST_LOG_CATEGORY, VCOS_LOG_TRACE, __VA_ARGS__)
#define vc_cec_log_warn(...)  _VCOS_LOG_X(CECHOST_LOG_CATEGORY, VCOS_LOG_WARN, __VA_ARGS__)
#define vc_cec_log_error(...) _VCOS_LOG_X(CECHOST_LOG_CATEGORY, VCOS_LOG_ERROR, __VA_ARGS__)
#define vc_cec_log_info(...)  _VCOS_LOG_X(CECHOST_LOG_CATEGORY, VCOS_LOG_INFO, __VA_ARGS__)
extern VCOS_LOG_CAT_T cechost_log_category; //The actual object lives in CEC host side service code

#define VC_CECSERVICE_VER 1
#define CECSERVICE_MSGFIFO_SIZE 1024
#define CECSERVICE_CLIENT_NAME MAKE_FOURCC("CECS")
#define CECSERVICE_NOTIFY_NAME MAKE_FOURCC("CECN")

//CEC service commands
typedef enum {
   VC_CEC_REGISTER_CMD = 0,
   VC_CEC_REGISTER_ALL,
   VC_CEC_DEREGISTER_CMD,
   VC_CEC_DEREGISTER_ALL,
   VC_CEC_SEND_MSG,
   VC_CEC_GET_LOGICAL_ADDR,
   VC_CEC_ALLOC_LOGICAL_ADDR,
   VC_CEC_RELEASE_LOGICAL_ADDR,
   VC_CEC_GET_TOPOLOGY,
   VC_CEC_SET_VENDOR_ID,
   VC_CEC_SET_OSD_NAME,
   VC_CEC_GET_PHYSICAL_ADDR,
   VC_CEC_GET_VENDOR_ID,

   //The following 3 commands are used when CEC middleware is 
   //running in passive mode (i.e. it does not allocate 
   //logical address automatically)
   VC_CEC_POLL_ADDR,
   VC_CEC_SET_LOGICAL_ADDR,
   VC_CEC_ADD_DEVICE,
   VC_CEC_SET_PASSIVE,
   //Add more commands here
   VC_CEC_END_OF_LIST
} VC_CEC_CMD_CODE_T;

//See vc_cec.h for details
//REGISTER_CMD
//Parameters: opcode to register (CEC_OPCODE_T sent as uint32)
//Reply: none

//REGISTER_ALL
//Parameters: none
//Reply: none

//DEREGISTER_CMD
//Parameters: opcode to deregister (CEC_OPCODE_T sent as uint32)
//Reply: none

//DEREGISTER_ALL
//Parameters: none
//Reply: none

//SEND_MSG
//Parameters: destination, length, 16 bytes buffer (message can only be at most 15 bytes however)
//Reply: none (callback)
typedef struct {
   uint32_t follower;
   uint32_t length;
   uint8_t payload[16]; //max. 15 bytes padded to 16
   uint32_t is_reply;   //non-zero if this is a reply, zero otherwise
} CEC_SEND_MSG_PARAM_T;

//GET_LOGICAL_ADDR
//Parameters: none
//Reply: logical address (uint8 returned as uint32)

//ALLOC_LOGICAL_ADDR
//Parameters: none
//Reply: none (callback)

//GET_TOPOLOGY
//Parameters: none
//Reply: topology (see VC_TOPOLOGY_T)

//SET_VENDOR_ID
//Parameters: vendor id (uint32)
//Reply: none

//Set OSD name
//Parameters: 14 byte char
//Reply: none
#define OSD_NAME_LENGTH 14

//GET_PHYSICAL_ADDR
//Parameter: none
//Reply: packed physical address returned as uint16

//GET_VENDOR_ID
//Parameter: logical address (CEC_AllDevices_T sent as uint32_t)
//Reply: (uint32_t vendor id)

//POLL_LOGICAL_ADDR (only for passive mode)
//Used by host to test a logical address to see if it is available for use
//Only available if CEC is compiled in passive mode and while the host
//is testing the availability of a logical address
//Parameter: logical address
//Reply: 

//SET_LOGICAL_ADDR [(only for passive mode) This will be changed when we support multiple logical addresses]
//Set the logical address used 
//Only available if CEC is compiled in passive mode
//Parameter: logical address, device type, vendor ID
//Reply: (int32_t - zero means success, non-zero otherwise)
//This function will result in a VC_CEC_LOGICAL_ADDR callback
typedef struct {
   uint32_t logical_address;
   uint32_t device_type;
   uint32_t vendor_id;
} CEC_SET_LOGICAL_ADDR_PARAM_T;
   
//ADD_DEVICE (only for passive mode)
//Only available if CEC is compiled in passive mode
//Parameter: logical address, physical address, device type, last device?
//Reply: (int32_t - zero means success, non-zero otherwise)
typedef struct {
   uint32_t logical_address;  /**<logical address */
   uint32_t physical_address; /**<16-bit packed physical address in big endian */
   uint32_t device_type;      /**<CEC_DEVICE_TYPE_T */
   uint32_t last_device;      /**<True (non-zero) or false (zero) */
} CEC_ADD_DEVICE_PARAM_T;

//SET PASSIVE (only for passive mode)
//Enable/disable passive mode
//Parameter: non-zero to enable passive mode, zero to disable
//Reply: (int32_t - zero means success, non-zero otherwise, non zero will be VCHI errors)

#endif //#ifndef _VC_CECSERVICE_DEFS_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef _VC_CMA_H_
#define _VC_CMA_H_

#include "interface/vcos/vcos.h"
#include "interface/vchiq_arm/vchiq.h"

#ifdef __linux__

#include <linux/ioctl.h>

#define VC_CMA_IOC_MAGIC 0xc5

#define VC_CMA_IOC_RESERVE _IO(VC_CMA_IOC_MAGIC, 0)

#endif

#define VC_CMA_FOURCC VCHIQ_MAKE_FOURCC('C','M','A',' ')
#define VC_CMA_VERSION 2

#define VC_CMA_CHUNK_ORDER 6  /* 256K */
#define VC_CMA_CHUNK_SIZE (4096 << VC_CMA_CHUNK_ORDER)
#define VC_CMA_MAX_PARAMS_PER_MSG ((VCHIQ_MAX_MSG_SIZE - sizeof(unsigned short)) / sizeof(unsigned short))

enum
{
   VC_CMA_MSG_QUIT,
   VC_CMA_MSG_OPEN,
   VC_CMA_MSG_TICK,
   VC_CMA_MSG_ALLOC,     /* chunk count */
   VC_CMA_MSG_FREE,      /* chunk, chunk, ... */
   VC_CMA_MSG_ALLOCATED, /* chunk, chunk, ... */
   VC_CMA_MSG_REQUEST_ALLOC, /* chunk count */
   VC_CMA_MSG_REQUEST_FREE,  /* chunk count */
   VC_CMA_MSG_RESERVE,   /* bytes lo, bytes hi */
   VC_CMA_MSG_MAX
};

typedef struct vc_cma_msg_struct
{
    unsigned short type;
    unsigned short params[VC_CMA_MAX_PARAMS_PER_MSG];
} VC_CMA_MSG_T;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Display manager service API

#ifndef _VC_DISPMANX_H_
#define _VC_DISPMANX_H_

#include "interface/vcos/vcos.h"
#include "interface/vctypes/vc_image_types.h"
#include "vc_dispservice_x_defs.h"
#include "interface/vmcs_host/vc_dispmanx_types.h"
#include "interface/vchi/vchi.h"

#ifdef __cplusplus
extern "C" {
#endif
// Same function as above, to aid migration of code.
VCHPRE_ int VCHPOST_ vc_dispman_init( void );
// Stop the service from being used
VCHPRE_ void VCHPOST_ vc_dispmanx_stop( void );
// Set the entries in the rect structure
VCHPRE_ int VCHPOST_ vc_dispmanx_rect_set( VC_RECT_T *rect, uint32_t x_offset, uint32_t y_offset, uint32_t width, uint32_t height );
// Resources
// Create a new resource
VCHPRE_ DISPMANX_RESOURCE_HANDLE_T VCHPOST_ vc_dispmanx_resource_create( VC_IMAGE_TYPE_T type, uint32_t width, uint32_t height, uint32_t *native_image_handle );
// Write the bitmap data to VideoCore memory
VCHPRE_ int VCHPOST_ vc_dispmanx_resource_write_data( DISPMANX_RESOURCE_HANDLE_T res, VC_IMAGE_TYPE_T src_type, int src_pitch, void * src_address, const VC_RECT_T * rect );
VCHPRE_ int VCHPOST_ vc_dispmanx_resource_write_data_handle( DISPMANX_RESOURCE_HANDLE_T res, VC_IMAGE_TYPE_T src_type, int src_pitch, VCHI_MEM_HANDLE_T handle, uint32_t offset, const VC_RECT_T * rect );
VCHPRE_ int VCHPOST_ vc_dispmanx_resource_read_data(
                              DISPMANX_RESOURCE_HANDLE_T handle,
                              const VC_RECT_T* p_rect,
                              void *   dst_address,
                              uint32_t dst_pitch );
// Delete a resource
VCHPRE_ int VCHPOST_ vc_dispmanx_resource_delete( DISPMANX_RESOURCE_HANDLE_T res );

// Displays
// Opens a display on the given device
VCHPRE_ DISPMANX_DISPLAY_HANDLE_T VCHPOST_ vc_dispmanx_display_open( uint32_t device );
// Opens a display on the given device in the request mode
VCHPRE_ DISPMANX_DISPLAY_HANDLE_T VCHPOST_ vc_dispmanx_display_open_mode( uint32_t device, uint32_t mode );
// Open an offscreen display
VCHPRE_ DISPMANX_DISPLAY_HANDLE_T VCHPOST_ vc_dispmanx_display_open_offscreen( DISPMANX_RESOURCE_HANDLE_T dest, DISPMANX_TRANSFORM_T orientation );
// Change the mode of a display
VCHPRE_ int VCHPOST_ vc_dispmanx_display_reconfigure( DISPMANX_DISPLAY_HANDLE_T display, uint32_t mode );
// Sets the desstination of the display to be the given resource
VCHPRE_ int VCHPOST_ vc_dispmanx_display_set_destination( DISPMANX_DISPLAY_HANDLE_T display, DISPMANX_RESOURCE_HANDLE_T dest );
// Set the background colour of the display
VCHPRE_ int VCHPOST_ vc_dispmanx_display_set_background( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_DISPLAY_HANDLE_T display,
                                                                       uint8_t red, uint8_t green, uint8_t blue );
// get the width, height, frame rate and aspect ratio of the display
VCHPRE_ int VCHPOST_ vc_dispmanx_display_get_info( DISPMANX_DISPLAY_HANDLE_T display, DISPMANX_MODEINFO_T * pinfo );
// Closes a display
VCHPRE_ int VCHPOST_ vc_dispmanx_display_close( DISPMANX_DISPLAY_HANDLE_T display );

// Updates
// Start a new update, DISPMANX_NO_HANDLE on error
VCHPRE_ DISPMANX_UPDATE_HANDLE_T VCHPOST_ vc_dispmanx_update_start( int32_t priority );
// Add an elment to a display as part of an update
VCHPRE_ DISPMANX_ELEMENT_HANDLE_T VCHPOST_ vc_dispmanx_element_add ( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_DISPLAY_HANDLE_T display,
                                                                     int32_t layer, const VC_RECT_T *dest_rect, DISPMANX_RESOURCE_HANDLE_T src,
                                                                     const VC_RECT_T *src_rect, DISPMANX_PROTECTION_T protection, 
                                                                     VC_DISPMANX_ALPHA_T *alpha,
                                                                     DISPMANX_CLAMP_T *clamp, DISPMANX_TRANSFORM_T transform );
// Change the source image of a display element
VCHPRE_ int VCHPOST_ vc_dispmanx_element_change_source( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_ELEMENT_HANDLE_T element,
                                                        DISPMANX_RESOURCE_HANDLE_T src );
// Change the layer number of a display element
VCHPRE_ int VCHPOST_ vc_dispmanx_element_change_layer ( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_ELEMENT_HANDLE_T element,
                                                        int32_t layer );
// Signal that a region of the bitmap has been modified
VCHPRE_ int VCHPOST_ vc_dispmanx_element_modified( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_ELEMENT_HANDLE_T element, const VC_RECT_T * rect );
// Remove a display element from its display
VCHPRE_ int VCHPOST_ vc_dispmanx_element_remove( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_ELEMENT_HANDLE_T element );
// Ends an update
VCHPRE_ int VCHPOST_ vc_dispmanx_update_submit( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_CALLBACK_FUNC_T cb_func, void *cb_arg );
// End an update and wait for it to complete
VCHPRE_ int VCHPOST_ vc_dispmanx_update_submit_sync( DISPMANX_UPDATE_HANDLE_T update );
// Query the image formats supported in the VMCS build
VCHPRE_ int VCHPOST_ vc_dispmanx_query_image_formats( uint32_t *supported_formats );

//New function added to VCHI to change attributes, set_opacity does not work there.
VCHPRE_ int VCHPOST_ vc_dispmanx_element_change_attributes( DISPMANX_UPDATE_HANDLE_T update, 
                                                            DISPMANX_ELEMENT_HANDLE_T element,
                                                            uint32_t change_flags,
                                                            int32_t layer,
                                                            uint8_t opacity,
                                                            const VC_RECT_T *dest_rect,
                                                            const VC_RECT_T *src_rect,
                                                            DISPMANX_RESOURCE_HANDLE_T mask,
                                                            DISPMANX_TRANSFORM_T transform );

//xxx hack to get the image pointer from a resource handle, will be obsolete real soon
VCHPRE_ uint32_t VCHPOST_ vc_dispmanx_resource_get_image_handle( DISPMANX_RESOURCE_HANDLE_T res);

//Call this instead of vc_dispman_init
VCHPRE_ void VCHPOST_ vc_vchi_dispmanx_init (VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );

// Take a snapshot of a display in its current state.
// This call may block for a time; when it completes, the snapshot is ready.
// only transform=0 is supported
VCHPRE_ int VCHPOST_ vc_dispmanx_snapshot( DISPMANX_DISPLAY_HANDLE_T display, 
                                           DISPMANX_RESOURCE_HANDLE_T snapshot_resource, 
                                           DISPMANX_TRANSFORM_T transform );

// Set the resource palette (for VC_IMAGE_4BPP and VC_IMAGE_8BPP)
VCHPRE_ int VCHPOST_ vc_dispmanx_resource_set_palette( DISPMANX_RESOURCE_HANDLE_T handle, 
                                                      void * src_address, int offset, int size);

// Start triggering callbacks synced to vsync
VCHPRE_ int VCHPOST_ vc_dispmanx_vsync_callback( DISPMANX_DISPLAY_HANDLE_T display, DISPMANX_CALLBACK_FUNC_T cb_func, void *cb_arg );

#ifdef __cplusplus
}
#endif

#endif // _VC_DISPMANX_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Typedefs and enums for the VideoCore III Display Manager

#ifndef _DISPMANX_TYPES_H
#define _DISPMANX_TYPES_H

#include "interface/vctypes/vc_image_types.h"
#include "interface/vctypes/vc_display_types.h"

#define VC_DISPMANX_VERSION   1

/* Opaque handles */
typedef uint32_t DISPMANX_DISPLAY_HANDLE_T;
typedef uint32_t DISPMANX_UPDATE_HANDLE_T;
typedef uint32_t DISPMANX_ELEMENT_HANDLE_T;
typedef uint32_t DISPMANX_RESOURCE_HANDLE_T;

typedef uint32_t DISPMANX_PROTECTION_T;

#define DISPMANX_NO_HANDLE 0

#define DISPMANX_PROTECTION_MAX   0x0f
#define DISPMANX_PROTECTION_NONE  0
#define DISPMANX_PROTECTION_HDCP  11   // Derived from the WM DRM levels, 101-300



/* Default display IDs.
   Note: if you overwrite with your own dispmanx_platform_init function, you
   should use IDs you provided during dispmanx_display_attach.
*/
#define DISPMANX_ID_MAIN_LCD  0
#define DISPMANX_ID_AUX_LCD   1
#define DISPMANX_ID_HDMI      2
#define DISPMANX_ID_SDTV      3
#define DISPMANX_ID_FORCE_LCD 4
#define DISPMANX_ID_FORCE_TV  5
#define DISPMANX_ID_FORCE_OTHER 6 /* non-default display */

/* Return codes. Nonzero ones indicate failure. */
typedef enum {
  DISPMANX_SUCCESS      = 0,
  DISPMANX_INVALID      = -1
  /* XXX others TBA */
} DISPMANX_STATUS_T;

typedef enum {
  /* Bottom 2 bits sets the orientation */
  DISPMANX_NO_ROTATE = 0,
  DISPMANX_ROTATE_90 = 1,
  DISPMANX_ROTATE_180 = 2,
  DISPMANX_ROTATE_270 = 3,

  DISPMANX_FLIP_HRIZ = 1 << 16,
  DISPMANX_FLIP_VERT = 1 << 17,

  /* invert left/right images */
  DISPMANX_STEREOSCOPIC_INVERT =  1 << 19,
  /* extra flags for controlling 3d duplication behaviour */
  DISPMANX_STEREOSCOPIC_NONE   =  0 << 20,
  DISPMANX_STEREOSCOPIC_MONO   =  1 << 20,
  DISPMANX_STEREOSCOPIC_SBS    =  2 << 20,
  DISPMANX_STEREOSCOPIC_TB     =  3 << 20,
  DISPMANX_STEREOSCOPIC_MASK   = 15 << 20,

  /* extra flags for controlling snapshot behaviour */
  DISPMANX_SNAPSHOT_NO_YUV = 1 << 24,
  DISPMANX_SNAPSHOT_NO_RGB = 1 << 25,
  DISPMANX_SNAPSHOT_FILL = 1 << 26,
  DISPMANX_SNAPSHOT_SWAP_RED_BLUE = 1 << 27,
  DISPMANX_SNAPSHOT_PACK = 1 << 28
} DISPMANX_TRANSFORM_T;

typedef enum {
  /* Bottom 2 bits sets the alpha mode */
  DISPMANX_FLAGS_ALPHA_FROM_SOURCE = 0,
  DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS = 1,
  DISPMANX_FLAGS_ALPHA_FIXED_NON_ZERO = 2,
  DISPMANX_FLAGS_ALPHA_FIXED_EXCEED_0X07 = 3,

  DISPMANX_FLAGS_ALPHA_PREMULT = 1 << 16,
  DISPMANX_FLAGS_ALPHA_MIX = 1 << 17
} DISPMANX_FLAGS_ALPHA_T;

typedef struct {
  DISPMANX_FLAGS_ALPHA_T flags;
  uint32_t opacity;
  VC_IMAGE_T *mask;
} DISPMANX_ALPHA_T;

typedef struct {
  DISPMANX_FLAGS_ALPHA_T flags;
  uint32_t opacity;
  DISPMANX_RESOURCE_HANDLE_T mask;
} VC_DISPMANX_ALPHA_T;  /* for use with vmcs_host */

typedef enum {
  DISPMANX_FLAGS_CLAMP_NONE = 0,
  DISPMANX_FLAGS_CLAMP_LUMA_TRANSPARENT = 1,
#if __VCCOREVER__ >= 0x04000000
  DISPMANX_FLAGS_CLAMP_TRANSPARENT = 2,
  DISPMANX_FLAGS_CLAMP_REPLACE = 3
#else
  DISPMANX_FLAGS_CLAMP_CHROMA_TRANSPARENT = 2,
  DISPMANX_FLAGS_CLAMP_TRANSPARENT = 3
#endif
} DISPMANX_FLAGS_CLAMP_T;

typedef enum {
  DISPMANX_FLAGS_KEYMASK_OVERRIDE = 1,
  DISPMANX_FLAGS_KEYMASK_SMOOTH = 1 << 1,
  DISPMANX_FLAGS_KEYMASK_CR_INV = 1 << 2,
  DISPMANX_FLAGS_KEYMASK_CB_INV = 1 << 3,
  DISPMANX_FLAGS_KEYMASK_YY_INV = 1 << 4
} DISPMANX_FLAGS_KEYMASK_T;

typedef union {
  struct {
    uint8_t yy_upper;
    uint8_t yy_lower;
    uint8_t cr_upper;
    uint8_t cr_lower;
    uint8_t cb_upper;
    uint8_t cb_lower;
  } yuv;
  struct {
    uint8_t red_upper;
    uint8_t red_lower;
    uint8_t blue_upper;
    uint8_t blue_lower;
    uint8_t green_upper;
    uint8_t green_lower;
  } rgb;
} DISPMANX_CLAMP_KEYS_T;

typedef struct {
  DISPMANX_FLAGS_CLAMP_T mode;
  DISPMANX_FLAGS_KEYMASK_T key_mask;
  DISPMANX_CLAMP_KEYS_T key_value;
  uint32_t replace_value;
} DISPMANX_CLAMP_T;

typedef struct {
  int32_t width;
  int32_t height;
  DISPMANX_TRANSFORM_T transform;
  DISPLAY_INPUT_FORMAT_T input_format;
  uint32_t display_num;
} DISPMANX_MODEINFO_T;

/* Update callback. */
typedef void (*DISPMANX_CALLBACK_FUNC_T)(DISPMANX_UPDATE_HANDLE_T u, void * arg);

/* Progress callback */
typedef void (*DISPMANX_PROGRESS_CALLBACK_FUNC_T)(DISPMANX_UPDATE_HANDLE_T u,
                                                  uint32_t line,
                                                  void * arg);

/* Pluggable display interface */

typedef struct tag_DISPMANX_DISPLAY_FUNCS_T {
   // Get essential HVS configuration to be passed to the HVS driver. Options
   // is any combination of the following flags: HVS_ONESHOT, HVS_FIFOREG,
   // HVS_FIFO32, HVS_AUTOHSTART, HVS_INTLACE; and if HVS_FIFOREG, one of;
   // { HVS_FMT_RGB888, HVS_FMT_RGB565, HVS_FMT_RGB666, HVS_FMT_YUV }.
   int32_t (*get_hvs_config)(void *instance, uint32_t *pchan,
                             uint32_t *poptions, DISPLAY_INFO_T *info,
                             uint32_t *bg_colour, uint32_t *test_mode);
   
   // Get optional HVS configuration for gamma tables, OLED matrix and dither controls.
   // Set these function pointers to NULL if the relevant features are not required.
   int32_t (*get_gamma_params)(void * instance,
                               int32_t gain[3], int32_t offset[3], int32_t gamma[3]);
   int32_t (*get_oled_params)(void * instance, uint32_t * poffsets,
                              uint32_t coeffs[3]);
   int32_t (*get_dither)(void * instance, uint32_t * dither_depth, uint32_t * dither_type);
   
   // Get mode information, which may be returned to the applications as a courtesy.
   // Transform should be set to 0, and {width,height} should be final dimensions.
   int32_t (*get_info)(void * instance, DISPMANX_MODEINFO_T * info);
   
   // Inform driver that the application refcount has become nonzero / zero
   // These callbacks might perhaps be used for backlight and power management.
   int32_t (*open)(void * instance);
   int32_t (*close)(void * instance);
   
   // Display list updated callback. Primarily of use to a "one-shot" display.
   // For convenience of the driver, we pass the register address of the HVS FIFO.
   void (*dlist_updated)(void * instance, volatile uint32_t * fifo_reg);
   
   // End-of-field callback. This may occur in an interrupt context.
   void (*eof_callback)(void * instance);

   // Return screen resolution format
   DISPLAY_INPUT_FORMAT_T (*get_input_format)(void * instance);

   int32_t (*suspend_resume)(void *instance, int up);

   DISPLAY_3D_FORMAT_T (*get_3d_format)(void * instance);
} DISPMANX_DISPLAY_FUNCS_T;

#endif /* ifndef _DISPMANX_TYPES_H */
                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VC_DISPSERVICE_DEFS_H
#define VC_DISPSERVICE_DEFS_H

#define  HOST_PITCH_ALIGNMENT    4

//Round up to the nearest multiple of 16
#define  PAD16(x) (((x) + (VC_INTERFACE_BLOCK_SIZE-1)) & ~(VC_INTERFACE_BLOCK_SIZE-1))

//The max length for an effect name
#define DISPMAN_MAX_EFFECT_NAME  (28)

typedef enum {
   // Values initially chosen to match VC_IMAGE_TYPE_T to aid debugging
   // This is now a mandatory constraint
   VC_FORMAT_RGB565    = 1,
   VC_FORMAT_YUV420    = 3,
   VC_FORMAT_RGB888    = 5,
   VC_FORMAT_RGBA32    = 15,
   VC_FORMAT_RGBA565   = 17,
   VC_FORMAT_RGBA16    = 18,
   VC_FORMAT_TF_RGBA32 = 20,
   VC_FORMAT_TF_RGBA16 = 23,
   VC_FORMAT_TF_RGB565 = 25,
   VC_FORMAT_BGR888    = 31,
   VC_FORMAT_BGR888_NP = 32,
   
   VC_FORMAT_ARGB8888  = 43,
   VC_FORMAT_XRGB8888  = 44,

   /* To force 32-bit storage, enabling use in structures over-the-wire */
   VC_FORMAT_RANGE_MAX = 0x7FFFFFFF
} VC_IMAGE_FORMAT_T;

// Transforms.
/* Image transformations. These must match the DISPMAN and Media Player versions */
#define TRANSFORM_HFLIP     (1<<0)
#define TRANSFORM_VFLIP     (1<<1)
#define TRANSFORM_TRANSPOSE (1<<2)

typedef enum {
   VC_DISPMAN_ROT0           = 0,
   VC_DISPMAN_MIRROR_ROT0    = TRANSFORM_HFLIP,
   VC_DISPMAN_MIRROR_ROT180  = TRANSFORM_VFLIP,
   VC_DISPMAN_ROT180         = TRANSFORM_HFLIP|TRANSFORM_VFLIP,
   VC_DISPMAN_MIRROR_ROT90   = TRANSFORM_TRANSPOSE,
   VC_DISPMAN_ROT270         = TRANSFORM_TRANSPOSE|TRANSFORM_HFLIP,
   VC_DISPMAN_ROT90          = TRANSFORM_TRANSPOSE|TRANSFORM_VFLIP,
   VC_DISPMAN_MIRROR_ROT270  = TRANSFORM_TRANSPOSE|TRANSFORM_HFLIP|TRANSFORM_VFLIP,
} VC_DISPMAN_TRANSFORM_T;

typedef enum {
   VC_RESOURCE_TYPE_HOST,
   VC_RESOURCE_TYPE_VIDEOCORE,
   VC_RESOURCE_TYPE_VIDEOCORE_UNCACHED,
} VC_RESOURCE_TYPE_T;

typedef struct {
   uint8_t  type;            // VC_IMAGE_FORMAT_T
   uint32_t width;           // width in pixels
   uint32_t height;          // height in pixels
   uint32_t pitch;           // pitch of image_data array in *bytes*
   uint32_t size;            // number of *bytes* available in the image_data arry
   uint32_t pointer;         // pointer for image_data - this allows the object to be cast to a VC_IMAGE_T on the VIDEOCORE side
} VC_IMAGE_PARAM_T;

typedef enum {
   VC_DISPMAN_DISPLAY_SET_DESTINATION = 0,
   VC_DISPMAN_DISPLAY_UPDATE_START,
   VC_DISPMAN_DISPLAY_UPDATE_END,
   VC_DISPMAN_DISPLAY_OBJECT_ADD,
   VC_DISPMAN_DISPLAY_OBJECT_REMOVE,
   VC_DISPMAN_DISPLAY_OBJECT_MODIFY,
   VC_DISPMAN_DISPLAY_LOCK,
   VC_DISPMAN_DISPLAY_UNLOCK,
   VC_DISPMAN_DISPLAY_RESOURCE_CREATE,
   VC_DISPMAN_DISPLAY_RESOURCE_DELETE,
   VC_DISPMAN_DISPLAY_GET_COMPOSITE,
   VC_DISPMAN_DISPLAY_APPLY_EFFECT_INSTANCE,
   VC_DISPMAN_DISPLAY_RECONFIGURE,
   VC_DISPMAN_DISPLAY_CREATE_EFFECTS_INSTANCE,
   VC_DISPMAN_DISPLAY_DELETE_EFFECTS_INSTANCE,
   VC_DISPMAN_DISPLAY_SET_EFFECT,
   VC_DISPMAN_DISPLAY_RESOURCE_SET_ALPHA,
   VC_DISPMAN_DISPLAY_SNAPSHOT,
   VC_DISPMAN_DISPLAY_QUERY_IMAGE_FORMATS,
   VC_DISPMAN_DISPLAY_GET_DISPLAY_DETAILS,
   // new features - add to end of list
   VC_DISPMAN_DISPLAY_RESOURCE_CREATE_FROM_IMAGE,
   VC_CMD_END_OF_LIST
} VC_CMD_CODE_T;

/* The table of functions executed for each command. */

typedef void (*INTERFACE_EXECUTE_FN_T)(int, int);

extern INTERFACE_EXECUTE_FN_T interface_execute_fn[];

//Parameter sets for dispservice commands
typedef struct {
   uint32_t state;
   uint32_t dummy[3];   //Pad to multiple of 16 bytes
} DISPMAN_LOCK_PARAM_T;

typedef struct {
   uint32_t display;
   uint32_t dummy[3];   //Pad to multiple of 16 bytes
} DISPMAN_GET_DISPLAY_DETAILS_PARAM_T;

typedef struct {
   uint32_t display;
   uint32_t resource;
   uint32_t dummy[2];   //Pad to multiple of 16 bytes
} DISPMAN_SET_DEST_PARAM_T;

typedef struct {
   uint32_t display;
   uint32_t dummy[3];   //Pad to multiple of 16 bytes
} DISPMAN_GET_COMPOSITE_PARAM_T;

typedef struct
{
   uint32_t display;
   uint32_t effects_instance;

   uint32_t dummy[2];   //Pad to multiple of 16 bytes
} DISPMAN_APPLY_EFFECTS_INSTANCE_PARAM_T;

typedef struct
{
   uint32_t read_response;
   uint32_t effects_instance;
} DISPMAN_CREATE_EFFECTS_INSTANCE_RESPONSE_T;

typedef struct
{
   uint32_t effects_instance;
   uint32_t dummy[3];   //Pad to multiple of 16 bytes
} DISPMAN_DELETE_EFFECTS_INSTANCE_PARAM_T;

typedef struct
{
   uint32_t effects_instance;
   char effect_name[ DISPMAN_MAX_EFFECT_NAME ];
   //no need to pad as long as DISPMAN_MAX_EFFECT_NAME +sizeof(uint32) = 32
} DISPMAN_SET_EFFECT_PARAM_T;

typedef struct {
   uint32_t display;
   uint16_t width;
   uint16_t height;
   uint32_t dummy[2];   //Pad to multiple of 16 bytes
} DISPMAN_RECONFIGURE_PARAM_T;

typedef struct {
   uint32_t display;
   uint32_t transparent_colour;
   uint32_t dummy[2];   //Pad to multiple of 16 bytes
} DISPMAN_SET_TRANSPARENT_COLOUR_PARAM_T;

typedef struct {
   //uint32_t object;
   uint32_t display;
   int32_t layer;
   uint32_t transform;
   uint32_t resource;
   uint16_t dest_x;
   uint16_t dest_y;
   uint16_t dest_width;
   uint16_t dest_height;
   uint16_t src_x;
   uint16_t src_y;
   uint16_t src_width;
   uint16_t src_height;
} DISPMAN_OBJECT_ADD_PARAM_T;

typedef struct {
   uint32_t object;
   uint32_t dummy[3];   //Pad to multiple of 16 bytes
} DISPMAN_OBJECT_REMOVE_PARAM_T;

typedef struct {
   uint32_t object;
   uint16_t src_x;
   uint16_t src_y;
   uint16_t width;
   uint16_t height;
   uint32_t dummy[1];   // Pad to multiple of 16 bytes
} DISPMAN_OBJECT_MODIFY_PARAM_T;

typedef struct
{
   uint32_t *resource;
   VC_IMAGE_PARAM_T image;
   uint8_t  type;   // VC_RESOURCE_TYPE_T
   //Removed padding.  VC_IMAGE_T may change in size, so handle the size in the code that sends and receives the commands
   //uint32_t dummy[3];   //Pad to multiple of 16 bytes
} DISPMAN_RESOURCE_CREATE_PARAM_T;

typedef struct
{
   uint32_t native_image_ptr;
   uint32_t type;   // VC_RESOURCE_TYPE_T
   uint32_t dummy[2];  // Pad to multiple of 16 bytes
} DISPMAN_RESOURCE_CREATE_FROM_IMAGE_PARAM_T;

typedef struct {
   uint32_t resource;
   uint32_t dummy[3];   //Pad to multiple of 16 bytes
} DISPMAN_RESOURCE_DELETE_PARAM_T;

typedef struct {
   uint32_t resource;
   uint32_t alpha;
   uint32_t dummy[2];   //Pad to multiple of 16 bytes
} DISPMAN_RESOURCE_SET_ALPHA_PARAM_T;

typedef struct {
   uint32_t display;
   uint32_t resource;
   uint32_t dummy[2];   //Pad to multiple of 16 bytes
} DISPMAN_DISPLAY_SNAPSHOT_PARAM_T;

#endif   //VC_DISPSERVICE_DEFS_H
                                                                                                                                                                                   /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Display service command enumeration.

#ifndef VC_DISPSERVICEX_DEFS_H
#define VC_DISPSERVICEX_DEFS_H

#include "interface/vctypes/vc_image_types.h"

#define  HOST_PITCH_ALIGNMENT    4

//Round up to the nearest multiple of 16
#define  PAD16(x) (((x) + (VC_INTERFACE_BLOCK_SIZE-1)) & ~(VC_INTERFACE_BLOCK_SIZE-1))

//The max length for an effect name
#define DISPMANX_MAX_EFFECT_NAME  (28)

// Should really use the VC_IMAGE_TYPE_T, but this one has been extended
// to force it up to 32-bits...
typedef enum {
   // Values initially chosen to match VC_IMAGE_TYPE_T to aid debugging
   // This is now a mandatory constraint
   VC_FORMAT_RGB565    = VC_IMAGE_RGB565,
   VC_FORMAT_YUV420    = VC_IMAGE_YUV420,
   VC_FORMAT_RGB888    = VC_IMAGE_RGB888,
   VC_FORMAT_RGBA32    = VC_IMAGE_RGBA32,
   VC_FORMAT_RGBA565   = VC_IMAGE_RGBA565,
   VC_FORMAT_RGBA16    = VC_IMAGE_RGBA16,
   VC_FORMAT_TF_RGBA32 = VC_IMAGE_TF_RGBA32,
   VC_FORMAT_TF_RGBA16 = VC_IMAGE_TF_RGBA16,
   VC_FORMAT_TF_RGB565 = VC_IMAGE_TF_RGB565,
   VC_FORMAT_BGR888    = VC_IMAGE_BGR888,
   VC_FORMAT_BGR888_NP = VC_IMAGE_BGR888_NP,

   VC_FORMAT_ARGB8888  = VC_IMAGE_ARGB8888,
   VC_FORMAT_XRGB8888  = VC_IMAGE_XRGB8888,

   /* To force 32-bit storage, enabling use in structures over-the-wire */
   VC_FORMAT_RANGE_MAX = 0x7FFFFFFF
} VC_IMAGE_FORMAT_T;

// Transforms.
/* Image transformations. These must match the DISPMAN and Media Player versions */
#define TRANSFORM_HFLIP     (1<<0)
#define TRANSFORM_VFLIP     (1<<1)
#define TRANSFORM_TRANSPOSE (1<<2)

#define VC_DISPMAN_ROT0 VC_IMAGE_ROT0
#define VC_DISPMAN_ROT90 VC_IMAGE_ROT90
#define VC_DISPMAN_ROT180 VC_IMAGE_ROT180
#define VC_DISPMAN_ROT270 VC_IMAGE_ROT270
#define VC_DISPMAN_MIRROR_ROT0 VC_IMAGE_MIRROR_ROT0
#define VC_DISPMAN_MIRROR_ROT90 VC_IMAGE_MIRROR_ROT90
#define VC_DISPMAN_MIRROR_ROT180 VC_IMAGE_MIRROR_ROT180
#define VC_DISPMAN_MIRROR_ROT270 VC_IMAGE_MIRROR_ROT270
#define VC_DISPMAN_TRANSFORM_T VC_IMAGE_TRANSFORM_T

typedef enum {
   VC_RESOURCE_TYPE_HOST,
   VC_RESOURCE_TYPE_VIDEOCORE,
   VC_RESOURCE_TYPE_VIDEOCORE_UNCACHED,
} VC_RESOURCE_TYPE_T;

typedef struct {
   uint8_t  type;            // VC_IMAGE_FORMAT_T
   uint32_t width;           // width in pixels
   uint32_t height;          // height in pixels
   uint32_t pitch;           // pitch of image_data array in *bytes*
   uint32_t size;            // number of *bytes* available in the image_data arry
   uint32_t pointer;         // pointer for image_data - this allows the object to be cast to a VC_IMAGE_T on the VIDEOCORE side
} VC_IMAGE_PARAM_T;

typedef enum {
   VC_DISPMANX_GET_DEVICES = 0,
   VC_DISPMANX_GET_DEVICE_NAME,
   VC_DISPMANX_GET_MODES,
   VC_DISPMANX_GET_MODE_INFO,
   VC_DISPMANX_DISPLAY_QUERY_IMAGE_FORMATS,
   // Resources
   VC_DISPMANX_RESOURCE_CREATE,
   VC_DISPMANX_RESOURCE_WRITE_DATA,
   VC_DISPMANX_RESOURCE_DELETE,
   // Displays
   VC_DISPMANX_DISPLAY_OPEN,
   VC_DISPMANX_DISPLAY_OPEN_MODE,
   VC_DISPMANX_DISPLAY_OPEN_OFFSCREEN,
   VC_DISPMANX_DISPLAY_RECONFIGURE,
   VC_DISPMANX_DISPLAY_SET_DESTINATION,
   VC_DISPMANX_DISPLAY_SET_BACKGROUND,
   VC_DISPMANX_DISPLAY_GET_INFO,
   VC_DISPMANX_DISPLAY_CLOSE,
   // Updates
   VC_DISPMANX_UPDATE_START,
   VC_DISPMANX_ELEMENT_ADD,
   VC_DISPMANX_ELEMENT_CHANGE_SOURCE,
   VC_DISPMANX_ELEMENT_MODIFIED,
   VC_DISPMANX_ELEMENT_REMOVE,
   VC_DISPMANX_UPDATE_SUBMIT,
   VC_DISPMANX_UPDATE_SUBMIT_SYNC,
   // Miscellaneous
   VC_DISPMANX_SNAPSHOT,
   // new features - add to end of list
   VC_CMD_END_OF_LIST
} VC_CMD_CODE_T;

/* The table of functions executed for each command. */

typedef void (*INTERFACE_EXECUTE_FN_T)(int, int);

extern INTERFACE_EXECUTE_FN_T interface_execute_fn[];

#define DISPMANX_MAX_HOST_DEVICES 8
#define DISPMANX_MAX_DEVICE_NAME_LEN 16

//Parameter sets for dispservice commands

typedef struct {
   int32_t response;
   uint32_t ndevices;
   uint32_t dummy[2];
   uint8_t names[DISPMANX_MAX_HOST_DEVICES][DISPMANX_MAX_DEVICE_NAME_LEN];
} DISPMANX_GET_DEVICES_RESP_T;
typedef struct {
   uint32_t device;
   uint32_t dummy[3];   //Pad to multiple of 16 bytes
} DISPMANX_GET_MODES_PARAM_T;
typedef struct {
   uint32_t display;
   uint32_t mode;
   uint32_t dummy[2];   //Pad to multiple of 16 bytes
} DISPMANX_GET_MODE_INFO_PARAM_T;
typedef struct {
   uint32_t type;
   uint32_t width;
   uint32_t height;
   uint32_t dummy[1];   // Pad to multiple of 16 bytes
} DISPMANX_RESOURCE_CREATE_PARAM_T;
typedef struct {
   // This will be needed when we change to vchi.
   int junk; // empty structure not allowed
} DISPMANX_RESOURCE_WRITE_DATA_PARAM_T;
typedef struct {
   uint32_t handle;
   uint32_t dummy[3];   //Pad to multiple of 16 bytes
} DISPMANX_RESOURCE_DELETE_PARAM_T;
typedef struct {
   uint32_t device;
   uint32_t dummy[3];
} DISPMANX_DISPLAY_OPEN_PARAM_T;
typedef struct {
   uint32_t device;
   uint32_t mode;
   uint32_t dummy[2];
} DISPMANX_DISPLAY_OPEN_MODE_PARAM_T;
typedef struct {
   uint32_t dest;
   uint32_t orientation;
   uint32_t dummy[2];
} DISPMANX_DISPLAY_OPEN_OFFSCREEN_PARAM_T;
typedef struct {
   uint32_t display;
   uint32_t dest;
   uint32_t dummy[2];
} DISPMANX_DISPLAY_SET_DESTINATION_PARAM_T;
typedef struct {
   uint32_t display;
   uint32_t update;
   uint32_t colour;
   uint32_t dummy;
} DISPMANX_DISPLAY_SET_BACKGROUND_PARAM_T;
typedef struct {
   uint32_t display;
   uint32_t dummy[3];
} DISPMANX_DISPLAY_GET_INFO_PARAM_T;
typedef struct {
   uint32_t read_response;
   int32_t      width;
   int32_t      height;
   int32_t      aspect_pixwidth;
   int32_t      aspect_pixheight;
   int32_t      fieldrate_num;
   int32_t      fieldrate_denom;
   int32_t      fields_per_frame;
   uint32_t transform;
   uint32_t dummy[3];
} DISPMANX_DISPLAY_GET_INFO_RESP_T;
typedef struct {
   int32_t priority;
   uint32_t dummy[3];
} DISPMANX_UPDATE_START_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t display;
   int32_t layer;
   uint32_t transform;
   uint32_t src_resource;
   uint16_t dest_x;
   uint16_t dest_y;
   uint16_t dest_width;
   uint16_t dest_height;
   uint16_t src_x;
   uint16_t src_y;
   uint16_t src_width;
   uint16_t src_height;
   uint32_t flags;
   uint32_t opacity;
   uint32_t mask_resource;
   // already 16 byte aligned
} DISPMANX_ELEMENT_ADD_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t element;
   uint32_t src_resource;
   uint32_t dummy; // pad to 16 bytes
} DISPMANX_ELEMENT_CHANGE_SOURCE_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t element;
   uint16_t x;
   uint16_t y;
   uint16_t width;
   uint16_t height;
} DISPMANX_ELEMENT_MODIFIED_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t element;
   uint32_t dummy[2];
} DISPMANX_ELEMENT_REMOVE_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t dummy[3];
} DISPMANX_UPDATE_SUBMIT_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t dummy[3];
} DISPMANX_UPDATE_SUBMIT_SYNC_PARAM_T;
typedef struct {
   uint32_t display;
   uint32_t snapshot_resource;
   uint32_t transform;
   uint32_t dummy[1];
} DISPMANX_DISPLAY_SNAPSHOT_PARAM_T;

// for dispmanx

#define TRANSFORM_HFLIP     (1<<0)
#define TRANSFORM_VFLIP     (1<<1)
#define TRANSFORM_TRANSPOSE (1<<2)


#endif   //VC_DISPSERVICEX_DEFS_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VC_GENCMD_DEFS_H
#define VC_GENCMD_DEFS_H

//Format of reply message is error code followed by a string
#define GENCMDSERVICE_MSGFIFO_SIZE 1024

#define VC_GENCMD_VER   1

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// File service command enumeration.

#ifndef VC_FILESERVICE_DEFS_H
#define VC_FILESERVICE_DEFS_H

#define VC_FILESERV_VER   1
/* Definitions (not used by API) */
#define FS_MAX_DATA 8192 //4096

/* Protocol (not used by API) version 1.2 */

enum {
   /* Over-the-wire file open flags */
   VC_O_RDONLY     = 0x01,
   VC_O_WRONLY     = 0x02,
   VC_O_RDWR            = 0x04,
   VC_O_APPEND     = 0x08,
   VC_O_CREAT           = 0x10,
   VC_O_TRUNC           = 0x20,
   VC_O_EXCL            = 0x40,

   /* Request Commands (VC->Host->VC) */

   /* These commands don't require a pathname */
   VC_FILESYS_RESET      = 64,
   VC_FILESYS_CLOSE      = 65,
   VC_FILESYS_CLOSEDIR   = 66,
   VC_FILESYS_LSEEK      = 67,
   VC_FILESYS_READ       = 68,
   VC_FILESYS_READDIR    = 69,
   VC_FILESYS_SETEND     = 70,
   VC_FILESYS_WRITE      = 71,

   /* These commands require a pathname */
   VC_FILESYS_FORMAT     = 72,
   VC_FILESYS_FREESPACE  = 73,
   VC_FILESYS_GET_ATTR   = 74,
   VC_FILESYS_MKDIR      = 75,
   VC_FILESYS_OPEN       = 76,
   VC_FILESYS_OPENDIR    = 77,
   VC_FILESYS_REMOVE     = 78,
   VC_FILESYS_RENAME     = 79,
   VC_FILESYS_SET_ATTR   = 80,
   VC_FILESYS_SCANDISK   = 81,
   VC_FILESYS_TOTALSPACE = 82,
   VC_FILESYS_DISKWRITABLE=83,
   VC_FILESYS_OPEN_DISK_RAW  = 84,
   VC_FILESYS_CLOSE_DISK_RAW = 85,
   VC_FILESYS_NUMSECTORS     = 86,
   VC_FILESYS_READ_SECTORS   = 87,
   VC_FILESYS_WRITE_SECTORS  = 88,

   VC_FILESYS_MOUNT      = 89,
   VC_FILESYS_UMOUNT     = 90,
   VC_FILESYS_FSTYPE     = 91,

   VC_FILESYS_READ_DIRECT = 92,

   VC_FILESYS_LSEEK64     = 93,
   VC_FILESYS_FREESPACE64 = 94,
   VC_FILESYS_TOTALSPACE64= 95,
   VC_FILESYS_OPEN_DISK   = 96,
   VC_FILESYS_CLOSE_DISK  = 97,
   
   /* extra simple functions for mass storage testing */
   VC_FILESYS_READ_SECTOR = 98, //1sect
   VC_FILESYS_STREAM_SECTOR_BEGIN = 99,
   VC_FILESYS_STREAM_SECTOR_END = 100,
   VC_FILESYS_WRITE_SECTOR = 101,
   VC_FILESYS_FSTAT      = 102,
   VC_FILESYS_DIRSIZE     = 103,
   VC_FILESYS_LIST_DIRS   = 104,
   VC_FILESYS_LIST_FILES  = 105,
   VC_FILESYS_NUM_DIRS    = 106,
   VC_FILESYS_NUM_FILES   = 107,
   VC_FILESYS_MAX_FILESIZE = 108,
   VC_FILESYS_CHKDSK       = 109,
};

/* Parameters for lseek */

#define  VC_FILESYS_SEEK_SET  0    /* Set file pointer to "offset" */
#define  VC_FILESYS_SEEK_CUR  1    /* Set file pointer to current plus "offset" */
#define  VC_FILESYS_SEEK_END  2    /* Set file pointer to EOF plus "offset" */

/* Return values of vc_filesys_type */
#define VC_FILESYS_FS_UNKNOWN 0
#define VC_FILESYS_FS_FAT12 1
#define VC_FILESYS_FS_FAT16 2
#define VC_FILESYS_FS_FAT32 3

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * HDMI common host header for TV service, defines resolution code which host applications should
 * use for power up command for HDMI
 */

#ifndef _VC_HDMI_H_
#define _VC_HDMI_H_

#include "vc_hdmi_property.h" /**< All HDMI related properties have been moved to here */

typedef int VC_HDMI_BOOL_T;

/**
 * HDMI resolution groups. There are two main groups: 
 * CEA - the conventional HDMI ones like 720p
 * DMT - computer monitor resolutions like XGA
 */
typedef enum {
   HDMI_RES_GROUP_INVALID = 0, /**< Initialised value */
   HDMI_RES_GROUP_CEA     = 1, /**< CEA - HDMI device */
   HDMI_RES_GROUP_DMT     = 2, /**< DMT - computer monitors */
   HDMI_RES_GROUP_CEA_3D  = 3, /* deprecated */

} HDMI_RES_GROUP_T;

#define HDMI_RES_GROUP_NAME(g) \
   (((g) == HDMI_RES_GROUP_INVALID) ? "Invalid" : \
   (((g) == HDMI_RES_GROUP_CEA) ? "CEA" : \
   (((g) == HDMI_RES_GROUP_DMT) ? "DMT" : \
    "Unknown")))

/**
 *  CEA 861 defined video code and aspect ratios for various HDMI modes
 *  Not all values are valid for AVI infoframe
 */
typedef enum {
   HDMI_ASPECT_UNKNOWN  = 0, /**< Unknown aspect ratio, or not one of the values below */
   HDMI_ASPECT_4_3      = 1, /**< 4:3  */
   HDMI_ASPECT_14_9     = 2, /**< 14:9 */
   HDMI_ASPECT_16_9     = 3, /**< 16:9 */
   HDMI_ASPECT_5_4      = 4, /**< 5:4  */
   HDMI_ASPECT_16_10    = 5, /**< 16:10*/
   HDMI_ASPECT_15_9     = 6, /**< 15:9 */
   HDMI_ASPECT_64_27    = 7, /**< 64:27 */
   HDMI_ASPECT_21_9     = HDMI_ASPECT_64_27 /**< 21:9 is jargon, 64:27 is the actual aspect ratio */
   /* More aspect ratio values may be added here if defined by CEA in future */
} HDMI_ASPECT_T;

/**
 * Display options set the bounding box (only used in CEA mode)
 */
typedef struct {
   uint16_t aspect; /**<HDMI_ASPECT_T */
   /** Active area information - meanings as in CEA-861. */
   uint16_t vertical_bar_present; /**<VC_HDMI_BOOL_T */
   uint16_t left_bar_width;
   uint16_t right_bar_width;
   uint16_t horizontal_bar_present; /**<VC_HDMI_BOOL_T */
   uint16_t top_bar_height;
   uint16_t bottom_bar_height;
   /** S0/S1 flags as defined in CEA-861. */
   uint8_t         overscan_flags;
} HDMI_DISPLAY_OPTIONS_T;

/**
 * HDMI internal state (with some of the properties related to current display signal)
 * Also see SDTV_DISPLAY_STATE_T in vc_sdtv.h, members up to scan_mode will be in the
 * same position as the equivalent state in SDTV_DISPLAY_STATE_T;
 */
typedef struct {
   uint32_t state;
   uint32_t width;
   uint32_t height;
   uint16_t frame_rate;
   uint16_t scan_mode;
   uint32_t group; /**<HDMI_RES_GROUP_T */
   uint32_t mode; /* This is the mode number of the format */
   uint16_t pixel_rep;   /* Pixel repetition factor, only relevant for CEA formats */
   uint16_t aspect_ratio; /* This is the format's native aspect ratio */
   HDMI_DISPLAY_OPTIONS_T display_options; /* This has the aspect ratio sent in AVI infoframe */
   uint16_t pixel_encoding;
   uint16_t format_3d; /* 3D format, only relevant for CEA formats */
} HDMI_DISPLAY_STATE_T;

/**
 * Copy protection for HDMI, only HDCP is available
 * This enum is to make it consistent with the enums
 * SDTV_CP_MODE_T in vc_sdtv.h
 */
typedef enum {
   HDMI_CP_NONE         = 0, /**< No copyprotection */
   HDMI_CP_HDCP         = 1  /**< HDCP 1.x */
} HDMI_CP_MODE_T;

/**
 *  HDMI operation modes
 */
typedef enum {
   HDMI_MODE_OFF,  /**< Off! */
   HDMI_MODE_DVI,  /**< DVI */
   HDMI_MODE_HDMI, /**< HDMI */
   HDMI_MODE_3D    /**< HDMI 1.4a 3D */
} HDMI_MODE_T;

/**
 * Possible values for the Source Product Description type code (in SPD infoframe).
 * Taken from the CEA-861 spec.
 */
typedef enum {
   HDMI_SPD_TYPE_UNKNOWN,
   HDMI_SPD_TYPE_STB,           /**<Digital STB */
   HDMI_SPD_TYPE_DVD,           /**<DVD player */
   HDMI_SPD_TYPE_DVHS,          /**<D-VHS */
   HDMI_SPD_TYPE_HDD_RECORDER,  /**<HDD video recoder */
   HDMI_SPD_TYPE_DVC,           /**<DVC */
   HDMI_SPD_TYPE_DSC,           /**<DSC */
   HDMI_SPD_TYPE_VCD,           /**<Video CD */
   HDMI_SPD_TYPE_GAME,          /**<Game */
   HDMI_SPD_TYPE_PC,            /**<PC general */
   HDMI_SPD_TYPE_BD,            /**<Blu-Ray Disc */
   HDMI_SPD_TYPE_SACD,          /**<Super Audio CD */
   HDMI_SPD_TYPE_HDDVD,         /**<HD DVD */
   HDMI_SPD_TYPE_PMP            /**<Personal media player */
} HDMI_SPD_TYPE_CODE_T;

/**
 * Structure for SPD infoframe
 */
typedef struct {
   char  *manufacturer;        /**< Manufacture name (up to 8 characters) */
   char  *description;         /**< Product name (up to 16 characters) */
   HDMI_SPD_TYPE_CODE_T type;  /**< Product type */
} HDMI_SPD_DATA_T;

/**
 * These are CEA mode numbers (sent in AVI infoframe) for different resolutions as define in CEA-861
 * 1080i at 100/120Hz (40,46) are supported by HDMI H/W but note we cannot
 * display the debug overlay under these modes.
 * Some modes have two codes, the first one has aspect ratio 4:3 and
 * the second one (with "H" suffix") 16:9.
 * The modes with "4x", etc. are the same the corresponding "non-multiplied" modes
 * but clocked at a higher pixel clock.
 */
typedef enum {
   HDMI_CEA_VGA             =  1,
   HDMI_CEA_480p60          =  2,
   HDMI_CEA_480p60H         =  3,
   HDMI_CEA_720p60          =  4,
   HDMI_CEA_1080i60         =  5,
   HDMI_CEA_480i60          =  6,
   HDMI_CEA_480i60H         =  7,
   HDMI_CEA_240p60          =  8,
   HDMI_CEA_240p60H         =  9,
   HDMI_CEA_480i60_4x       = 10,
   HDMI_CEA_480i60_4xH      = 11,
   HDMI_CEA_240p60_4x       = 12,
   HDMI_CEA_240p60_4xH      = 13,
   HDMI_CEA_480p60_2x       = 14,
   HDMI_CEA_480p60_2xH      = 15,
   HDMI_CEA_1080p60         = 16,
   HDMI_CEA_576p50          = 17,
   HDMI_CEA_576p50H         = 18,
   HDMI_CEA_720p50          = 19,
   HDMI_CEA_1080i50         = 20,
   HDMI_CEA_576i50          = 21,
   HDMI_CEA_576i50H         = 22,
   HDMI_CEA_288p50          = 23,
   HDMI_CEA_288p50H         = 24,
   HDMI_CEA_576i50_4x       = 25,
   HDMI_CEA_576i50_4xH      = 26,
   HDMI_CEA_288p50_4x       = 27,
   HDMI_CEA_288p50_4xH      = 28,
   HDMI_CEA_576p50_2x       = 29,
   HDMI_CEA_576p50_2xH      = 30,
   HDMI_CEA_1080p50         = 31,
   HDMI_CEA_1080p24         = 32,
   HDMI_CEA_1080p25         = 33,
   HDMI_CEA_1080p30         = 34,
   HDMI_CEA_480p60_4x       = 35,
   HDMI_CEA_480p60_4xH      = 36,
   HDMI_CEA_576p50_4x       = 37,
   HDMI_CEA_576p50_4xH      = 38,
   HDMI_CEA_1080i50_rb      = 39,
   HDMI_CEA_1080i100        = 40,
   HDMI_CEA_720p100         = 41,
   HDMI_CEA_576p100         = 42,
   HDMI_CEA_576p100H        = 43,
   HDMI_CEA_576i100         = 44,
   HDMI_CEA_576i100H        = 45,
   HDMI_CEA_1080i120        = 46,
   HDMI_CEA_720p120         = 47,
   HDMI_CEA_480p120         = 48,
   HDMI_CEA_480p120H        = 49,
   HDMI_CEA_480i120         = 50,
   HDMI_CEA_480i120H        = 51,
   HDMI_CEA_576p200         = 52,
   HDMI_CEA_576p200H        = 53,
   HDMI_CEA_576i200         = 54,
   HDMI_CEA_576i200H        = 55,
   HDMI_CEA_480p240         = 56,
   HDMI_CEA_480p240H        = 57,
   HDMI_CEA_480i240         = 58,
   HDMI_CEA_480i240H        = 59,
   HDMI_CEA_720p24          = 60,
   HDMI_CEA_720p25          = 61,
   HDMI_CEA_720p30          = 62,
   HDMI_CEA_1080p120        = 63,
   HDMI_CEA_1080p100        = 64,

   /* Up-to-date as of CEA 861-E */

   HDMI_CEA_OFF = 0xff /**<Special code to shutdown HDMI */

} HDMI_CEA_RES_CODE_T;

/**
 * These are the DMT modes from VESA. They are used for powering up
 * HDMI in DMT resolutions and are not sent in AVI infoframes.
 * Enum is ordered as ascending order of DMT id.
 * All reduced blanking formats are 60Hz unless stated otherwise.
 */
typedef enum {
   HDMI_DMT_640x350_85      = 0x1,  /**<640x350 */
   HDMI_DMT_640x400_85      = 0x2,  /**<640x400 */
   HDMI_DMT_IBM_VGA_85      = 0x3,  /**<720x400 */
   HDMI_DMT_VGA_60          = 0x4,  /**<640x480 (60Hz is same as VGA above) */
   HDMI_DMT_VGA_72          = 0x5,
   HDMI_DMT_VGA_75          = 0x6,
   HDMI_DMT_VGA_85          = 0x7,
   HDMI_DMT_SVGA_56         = 0x8,  /**<800x600 */
   HDMI_DMT_SVGA_60         = 0x9,
   HDMI_DMT_SVGA_72         = 0xA,
   HDMI_DMT_SVGA_75         = 0xB,
   HDMI_DMT_SVGA_85         = 0xC,
   HDMI_DMT_SVGA_120        = 0xD,
   HDMI_DMT_848x480_60      = 0xE,  /**<848x480 */
   HDMI_DMT_XGA_43          = 0xF,  /**<1024x768 - interlaced, DO NOT USE */
   HDMI_DMT_XGA_60          = 0x10, /**<1024x768 */
   HDMI_DMT_XGA_70          = 0x11,
   HDMI_DMT_XGA_75          = 0x12,
   HDMI_DMT_XGA_85          = 0x13,
   HDMI_DMT_XGA_120         = 0x14,
   HDMI_DMT_XGAP_75         = 0x15, /**<1152x864 */
   HDMI_DMT_WXGA_RB         = 0x16, /**<1280x768 reduced blanking */
   HDMI_DMT_WXGA_60         = 0x17,
   HDMI_DMT_WXGA_75         = 0x18,
   HDMI_DMT_WXGA_85         = 0x19,
   HDMI_DMT_WXGA_120        = 0x1A, /**<120Hz with reduced blanking */
   HDMI_DMT_1280x800_RB     = 0x1B, /**<1280x800 reduced blanking */
   HDMI_DMT_1280x800_60     = 0x1C,
   HDMI_DMT_1280x800_75     = 0x1D,
   HDMI_DMT_1280x800_85     = 0x1E,
   HDMI_DMT_1280x800_120    = 0x1F, /** reduced blanking */
   HDMI_DMT_1280x960_60     = 0x20, /**<1280x960 */
   HDMI_DMT_1280x960_85     = 0x21,
   HDMI_DMT_1280x960_120    = 0x22, /** reduced blanking */
   HDMI_DMT_SXGA_60         = 0x23, /**<1280x1024 */
   HDMI_DMT_SXGA_75         = 0x24,
   HDMI_DMT_SXGA_85         = 0x25,
   HDMI_DMT_SXGA_120        = 0x26, /** reduced blanking */
   HDMI_DMT_1360x768_60     = 0x27, /**<1360x768 */
   HDMI_DMT_1360x768_120    = 0x28, /**<120 Hz with reduced blanking */
   HDMI_DMT_SXGAP_RB        = 0x29, /**<1400x1050 reduced blanking */
   HDMI_DMT_SXGAP_60        = 0x2A,
   HDMI_DMT_SXGAP_75        = 0x2B,
   HDMI_DMT_SXGAP_85        = 0x2C,
   HDMI_DMT_SXGAP_120       = 0x2D, /** reduced blanking */
   HDMI_DMT_1440x900_RB     = 0x2E, /**<1440x900 reduced blanking */
   HDMI_DMT_1440x900_60     = 0x2F,
   HDMI_DMT_1440x900_75     = 0x30,
   HDMI_DMT_1440x900_85     = 0x31,
   HDMI_DMT_1440x900_120    = 0x32, /** reduced blanking */
   HDMI_DMT_UXGA_60         = 0x33, /**<1600x1200 60Hz */
   HDMI_DMT_UXGA_65         = 0x34, 
   HDMI_DMT_UXGA_70         = 0x35, 
   HDMI_DMT_UXGA_75         = 0x36, 
   HDMI_DMT_UXGA_85         = 0x37, 
   HDMI_DMT_UXGA_120        = 0x38, /** reduced blanking */
   HDMI_DMT_SWXGAP_RB       = 0x39, /**<1680x1050 reduced blanking */
   HDMI_DMT_SWXGAP_60       = 0x3A, /**<1680x1050 60Hz */
   HDMI_DMT_SWXGAP_75       = 0x3B, 
   HDMI_DMT_SWXGAP_85       = 0x3C, 
   HDMI_DMT_SWXGAP_120      = 0x3D, /** reduced blanking */ 
   HDMI_DMT_1792x1344_60    = 0x3E, /**<1792x1344 60Hz */
   HDMI_DMT_1792x1344_75    = 0x3F, /**<1792x1344 75Hz */
   HDMI_DMT_1792x1344_120   = 0x40, /** reduced blanking */
   HDMI_DMT_1856x1392_60    = 0x41, /**<1856x1392 60Hz */
   HDMI_DMT_1856x1392_75    = 0x42, /**<1856x1392 75Hz */
   HDMI_DMT_1856x1392_120   = 0x43, /** reduced blanking */
   HDMI_DMT_WUXGA_RB        = 0x44, /**<1920x1200 reduced blanking */
   HDMI_DMT_WUXGA_60        = 0x45, /**<1920x1200 60Hz */
   HDMI_DMT_WUXGA_75        = 0x46, /**<1920x1200 75Hz */
   HDMI_DMT_WUXGA_85        = 0x47, /**<1920x1200 85Hz */
   HDMI_DMT_WUXGA_120       = 0x48, /** reduced blanking */
   HDMI_DMT_1920x1440_60    = 0x49, /**<1920x1440 60Hz */
   HDMI_DMT_1920x1440_75    = 0x4A, /**<1920x1440 75Hz */
   HDMI_DMT_1920x1440_120   = 0x4B, /** reduced blanking */
   HDMI_DMT_2560x1600_RB    = 0x4C, /**<2560x1600 reduced blanking */
   HDMI_DMT_2560x1600_60    = 0x4D, /**<2560x1600 60 Hz */
   HDMI_DMT_2560x1600_75    = 0x4E, /**<2560x1600 75 Hz */
   HDMI_DMT_2560x1600_85    = 0x4E, /**<2560x1600 85 Hz */
   HDMI_DMT_2560x1600_120   = 0x50, /** reduced blanking */
   HDMI_DMT_1366x768_60     = 0x51, /**<1366x768 60Hz */
   HDMI_DMT_1080p_60        = 0x52, /**<Same as 1080p60 above */
   HDMI_DMT_1600x900_RB     = 0x53, /**<1600x900 reduced blanking */
   HDMI_DMT_2048x1152_RB    = 0x54, /**<2048x1152 reduced blanking */
   HDMI_DMT_720p_60         = 0x55, /**<Same as 720p60 above */
   HDMI_DMT_1366x768_RB     = 0x56, /**<1366x768 reduced blanking */
   /* Up-to-date as of VESA DMT v1 r12 */

   HDMI_DMT_OFF = 0xff
} HDMI_DMT_RES_CODE_T;

/**
 * HDMI scanmode
 */
typedef enum {
   HDMI_NONINTERLACED,
   HDMI_INTERLACED
} HDMI_INTERLACED_T;

/**
 * Preference for powering up HDMI using best mode
 * Note we will only use CEA modes for matching
 */
typedef enum {
   HDMI_MODE_MATCH_NONE          = 0x0, /**<No mode*/
   HDMI_MODE_MATCH_FRAMERATE     = 0x1, /**<Match based on frame rate */
   HDMI_MODE_MATCH_RESOLUTION    = 0x2, /**<Match based on resolution */
   HDMI_MODE_MATCH_SCANMODE      = 0x4  /**<Match based on scan mode */
} EDID_MODE_MATCH_FLAG_T;

/**
 * Audio support flags
 */
typedef enum {
   EDID_AUDIO_NO_SUPPORT         = (1 << 0), /**<No support for that format */
   EDID_AUDIO_CHAN_UNSUPPORTED   = (1 << 1), /**<max. no. of channels exceeded */
   EDID_AUDIO_FS_UNSUPPORTED     = (1 << 2), /**<no support for that sampling frequency */
   EDID_AUDIO_BR_UNSUPPORTED     = (1 << 3), /**<max. bitrate exceeded */
   EDID_AUDIO_SAMP_UNSUPPORTED   = (1 << 4), /**sample size unsupported (pcm only) */
} EDID_AUDIO_SUPPORT_FLAG_T;

/**
 * Enums for audio support in audio descriptor block (CEA only)
 * audio formats as specified in CEA Short Audio Descriptors
 */
typedef enum {
   EDID_AudioFormat_eReserved,      /**<Refer to header when set in audio info frame */
   EDID_AudioFormat_ePCM,           /**<Plain old PCM, mandatory for any audio support */
   EDID_AudioFormat_eAC3,           /**<AC3 */
   EDID_AudioFormat_eMPEG1,         /**<Mpeg layer 1 and 2 */
   EDID_AudioFormat_eMP3,           /**<Mpeg layer 3 */
   EDID_AudioFormat_eMPEG2,         /**<Mpeg 2 audio */
   EDID_AudioFormat_eAAC,           /**<AAC */
   EDID_AudioFormat_eDTS,           /**<DTS */
   EDID_AudioFormat_eATRAC,         /**<Sony proprietary */
   EDID_AudioFormat_eDSD,           /**<Super Audio CD 1-bit audio */
   EDID_AudioFormat_eEAC3,          /**<Dolby Digital + */
   EDID_AudioFormat_eDTS_HD,        /**<DTS-HD */
   EDID_AudioFormat_eMLP,           /**<Meridian Lossless Packing - for DVD audio */
   EDID_AudioFormat_eDST,           /**<Direct stream transfer - compressed super audio CD */
   EDID_AudioFormat_eWMAPRO,        /**<WMA Pro */
   EDID_AudioFormat_eExtended,      /**<Refer to byte 3 of audio db for coding extension type */

   EDID_AudioFormat_eMaxCount
} EDID_AudioFormat;

/**
 * If audio format is set to EDID_AudioFormat_eExtended,
 * this gives the extended audio type (see CEA-861E section 6.6.1)
 */
typedef enum {
   EDID_AudioCodingExtension_NONE    = 0x0, /** no extension, for audio format != Extended */
   EDID_AudioCodingExtension_HEAAC   = 0x1, /**<HE-AAC */
   EDID_AudioCodingExtension_HEAAC2  = 0x2, /**<HE-AAC v2 */
   EDID_AudioCodingExtension_MPEGSUR = 0x3, /**<MPEG Surround */

   EDID_AudioCodingExtension_max
} EDID_AudioCodingExtension;

/**
 * Audio sample rates as specified in CEA Short Audio Descriptors
 */
typedef enum {
   EDID_AudioSampleRate_eReferToHeader = 0x0,      /**<Only used in audio infoframe */
   EDID_AudioSampleRate_e32KHz         = (1 << 0), /**<32 kHz (mandatory) */
   EDID_AudioSampleRate_e44KHz         = (1 << 1), /**<44.1 kHz (mandatory) */
   EDID_AudioSampleRate_e48KHz         = (1 << 2), /**<48kHz (mandatory) */
   EDID_AudioSampleRate_e88KHz         = (1 << 3), /**<88.2 kHz */
   EDID_AudioSampleRate_e96KHz         = (1 << 4), /**<96kHz */
   EDID_AudioSampleRate_e176KHz        = (1 << 5), /**<176.4 kHz */
   EDID_AudioSampleRate_e192KHz        = (1 << 6)  /**<192 kHz */
} EDID_AudioSampleRate;

/**
 * Audio sample sizes (L-PCM) as specified in CEA Short Audio Descriptors
 */
typedef enum {
   EDID_AudioSampleSize_refertoheader = 0x0, /**<Only used in audio infoframe */
   EDID_AudioSampleSize_16bit         = 0x1, /**<16-bit samples (mandatory) */
   EDID_AudioSampleSize_20bit         = 0x2, /**<20-bit samples */
   EDID_AudioSampleSize_24bit         = 0x4  /**<24-bit samples */
} EDID_AudioSampleSize;

/**
 *  LFE feedback level as described in audio db
 */
typedef enum {
   EDID_AudioLFEFB_UNKNOWN = 0x0, /**<Refer to other information */
   EDID_AudioLFEFB_0dB     = 0x1, /**<0dB - same level as other channels */
   EDID_AudioLFEFB_10dB    = 0x2  /**<+10dB relative to other channels */
} EDID_AudioLFEFB;

/**
 * All possible 3D structures
 * to be used in decoded 3D modes (e.g. HDMI_3D_SUPPORTED_MODE)
 */
typedef enum {
   HDMI_3D_STRUCT_NONE                                   = 0,
   HDMI_3D_STRUCT_FRAME_PACKING                          = (1<<0),
   HDMI_3D_STRUCT_FIELD_ALTERNATIVE                      = (1<<1),
   HDMI_3D_STRUCT_LINE_ALTERNATIVE                       = (1<<2),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_FULL                      = (1<<3),
   HDMI_3D_STRUCT_L_DEPTH                                = (1<<4),
   HDMI_3D_STRUCT_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH        = (1<<5),
   HDMI_3D_STRUCT_TOP_AND_BOTTOM                         = (1<<6),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_HORIZONTAL           = (1<<7),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_ODD_LEFT_ODD_RIGHT   = (1<<8),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_ODD_LEFT_EVEN_RIGHT  = (1<<9),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_EVEN_LEFT_ODD_RIGHT  = (1<<10),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_EVEN_LEFT_EVEN_RIGHT = (1<<11),
   HDMI_3D_STRUCT_FRAME_SEQUENTIAL                       = (1<<12),
} HDMI_3D_STRUCT_T;

/**
 * HDMI notifications (defined as a bit mask to be conveniently returned as a state),
 * make sure this does not clash with the values in vc_sdtv.h
 * SDTV notifications start at bit 16.
 * These values are returned by the TV service in a callback.
 */
typedef enum {
   VC_HDMI_UNPLUGGED          = (1 << 0),  /**<HDMI cable is detached */
   VC_HDMI_ATTACHED           = (1 << 1),  /**<HDMI cable is attached but not powered on */
   VC_HDMI_DVI                = (1 << 2),  /**<HDMI is on but in DVI mode (no audio) */
   VC_HDMI_HDMI               = (1 << 3),  /**<HDMI is on and HDMI mode is active */
   VC_HDMI_HDCP_UNAUTH        = (1 << 4),  /**<HDCP authentication is broken (e.g. Ri mismatched) or not active */
   VC_HDMI_HDCP_AUTH          = (1 << 5),  /**<HDCP is active */
   VC_HDMI_HDCP_KEY_DOWNLOAD  = (1 << 6),  /**<HDCP key download successful/fail */
   VC_HDMI_HDCP_SRM_DOWNLOAD  = (1 << 7),  /**<HDCP revocation list download successful/fail */
   VC_HDMI_CHANGING_MODE      = (1 << 8),  /**<HDMI is starting to change mode, clock has not yet been set */

} VC_HDMI_NOTIFY_T;
#define VC_HDMI_STANDBY (VC_HDMI_ATTACHED) /* For backward code compatibility */

/**
 * Callback reason and arguments from HDMI middleware
 * Each callback comes with two optional uint32_t parameters.
 * Reason                     param1       param2      remark
 * VC_HDMI_UNPLUGGED            -            -         cable is unplugged
 * VC_HDMI_STANDBY            CEA/DMT      mode code   cable is plugged in and peripheral powered off (preferred mode sent back if available)
 * VC_HDMI_DVI                CEA/DMT      mode code   DVI mode is active at said resolution
 * VC_HDMI_HDMI               CEA(3D)/DMT  mode code   HDMI mode is active at said resolution (in 3D mode if CEA3D)
 * VC_HDMI_HDCP_UNAUTH        HDCP_ERROR_T  retry?     HDCP is inactive, the error can be none if we actively disable HDCP, if retry is non-zero, HDCP will attempt to reauthenticate
 * VC_HDMI_HDCP_AUTH            -            -         HDCP is active
 * VC_HDMI_HDCP_KEY_DOWNLOAD  success?       -         HDCP key download success (zero) or not (non zero)
 * VC_HDMI_HDCP_SRM_DOWNLOAD  no. of keys    -         HDCP revocation list download set no. of keys (zero means failure)
 * VC_HDMI_CHANGING_MODE        0            0         No information is supplied in this callback
 */

/* Some constants which are required on host side */
#define HDCP_KEY_BLOCK_SIZE 328 /* KSV, padding, device keys and hash. */
#define HDCP_KSV_LENGTH   5
#define HDCP_MAX_DEVICE 127 /* Max. number of HDCP downstream device supported */
#define HDCP_MAX_DEPTH 7 /* Max. number of levels HDCP 1.x can have */
#define EDID_BLOCKSIZE 128
#define HDMI_NUM_PACKET_BYTES 28 /* Size of HDMI infoframes minus the header */
#define HDMI_MAX_EXPLICIT_3D_MODES 31 /* The number of explicit 3D modes is stored in 5 bits */
#define EDID_MONITOR_DESC_SIZE  18 /* Size of detailed timing descriptor in EDID */
#define EDID_DESC_HEADER_LEN     5 /* Size of detailed timing descriptor header in EDID */
#define EDID_DESC_ASCII_STRING_LEN (EDID_MONITOR_DESC_SIZE - EDID_DESC_HEADER_LEN)
#define EDID_DEVICE_VENDOR_ID_LENGTH 3 /* Expanded Device Vendor ID length in EDID */

/* All CEC related constants now reside in vc_cec.h */

/**
 * General callback function for both HDMI and HDCP middleware
 * reason is the notification nature
 * param1 and param2 have different meanings depending on the notification (see above)
 *
 * @param client_p is the callback context
 *
 * @param reason is the callback reason
 *
 * @param param1 is the first callback argument (meaning as above)
 *
 * @param param2 is the second callback argument (meaning as above)
 *
 * @return void
 */
typedef void (*HDMI_CALLBACK_T)(void *client_p, VC_HDMI_NOTIFY_T reason, uint32_t param1, uint32_t param2);

/* TV service error return code */
typedef enum {
   VC_HDMI_SUCCESS                  = 0, /** OK */
   VC_HDMI_ERROR_FORMAT_UNSUPPORTED = 1, /** format not supported */
   VC_HDMI_ERROR_INVALID_FORMAT     = 2, /** invalid format */
   VC_HDMI_ERROR_INVALID_PROPERTY   = 3, /** invalid property */
   VC_HDMI_ERROR_OUT_OF_RANGE       = 4, /** invalid values passed to set property */
   VC_HDMI_ERROR_INVALID_INFOFRAME  = 5, /** invalid infoframe */
} VC_HDMI_ERROR_T;

/* Defines for backward code compatibility (these were originally in hdmi.h) */
typedef VC_HDMI_ERROR_T HDMI_RESULT_T;
#define HDMI_RESULT_SUCCESS (VC_HDMI_SUCCESS)
#define HDMI_RESULT_FAILED  (VC_HDMI_ERROR_FORMAT_UNSUPPORTED)

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012 Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
      ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
      WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
      DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
      SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * This file contains all the properties one can set in HDMI
 * Each property has up to two parameters corresponding to list of enums one can set via
 * the set/get property function from TV service (HOST) or HDMI middleware API (Videocore)
 * Each property also has a default value for these parameters. Please refer to 
 * individual properties for details.
 */

#ifndef _VC_HDMI_PROPERTY_H_
#define _VC_HDMI_PROPERTY_H_
#include "vcinclude/common.h"

/**
 * Property type
 */
typedef enum {
   HDMI_PROPERTY_PIXEL_ENCODING   = 0, /**< Set pixel encoding, value of property is HDMI_PIXEL_ENCODING_T, default is RGB full range (unless it is not supported) */
   HDMI_PROPERTY_PIXEL_CLOCK_TYPE = 1, /**< See HDMI_PIXEL_CLOCK_TYPE_T, default is HDMI_PIXEL_CLOCK_TYPE_PAL */
   HDMI_PROPERTY_CONTENT_TYPE     = 2, /**< Set content type flag EDID_ContentType_T */
   HDMI_PROPERTY_FUZZY_MATCH      = 3, /**< disable (0 - default) or enable (1) fuzzy format match */
   HDMI_PROPERTY_3D_STRUCTURE     = 4, /**< Set the 3D structure of the next HDMI power on (only for CEA mode) */

   //More properties to be added here
   HDMI_PROPERTY_MAX                   /**< place holder */
} HDMI_PROPERTY_T;

/**
 * Setting/getting a property
 */
typedef struct {
   HDMI_PROPERTY_T property;
   uint32_t param1;
   uint32_t param2;
   //More fields may be added here if required in future
} HDMI_PROPERTY_PARAM_T;

/**
 * PIXEL_ENCODING: param1: encoding type, param2: n/a
 * Setting encoding type is subjected to support in EDID
 */
typedef enum {
   HDMI_PIXEL_ENCODING_DEFAULT = 0,  /**<Default, note that CEA modes (except VGA) default to RGB limited but DMT modes default to RGB full */
   HDMI_PIXEL_ENCODING_RGB_LIMITED,
   HDMI_PIXEL_ENCODING_RGB_FULL,
   HDMI_PIXEL_ENCODING_YCbCr444_LIMITED,
   HDMI_PIXEL_ENCODING_YCbCr444_FULL,
   /** YCbCr 422 are not used at the moment */
   HDMI_PIXEL_ENCODING_YCbCr422_LIMITED,
   HDMI_PIXEL_ENCODING_YCbCr422_FULL,
   HDMI_PIXEL_ENCODING_MAX /**<place holder */
} HDMI_PIXEL_ENCODING_T;

/**
 * PIXEL_CLOCK_TYPE: param1: pixel clock type, param2: n/a
 * Pixel clock nudge factor (set pixel clock type)
 */
typedef enum {
   HDMI_PIXEL_CLOCK_TYPE_PAL  = 0, /**< Use norminal pixel clock (default) */
   HDMI_PIXEL_CLOCK_TYPE_NTSC = 1, /**< Multiply norminal pixel clock by 1000/1001 to get the alternative frame rate e.g. 59.94Hz rather than 60, not applicable to all formats */
   HDMI_PIXEL_CLOCK_TYPE_MAX       /**< place holder */
} HDMI_PIXEL_CLOCK_TYPE_T;

/**
 * Content type: param1: EDID content type, param2: n/a
 */
/**
 * Content type: the enum is the actual value in AVI infoframe + 1
 * because NODATA and Graphics both have value zero
 */
typedef enum {
   EDID_ContentType_NODATA   = 0x0, /**<Content type none */
   EDID_ContentType_Graphics = 0x1, /**<Graphics, ITC must be set to 1 */
   EDID_ContentType_Photo    = 0x2, /**<Photo */
   EDID_ContentType_Cinema   = 0x3, /**<Cinema */
   EDID_ContentType_Game     = 0x4, /**<Game */
   EDID_ContentType_MAX             /**<place holder */
} EDID_ContentType_T;

/**
 * Fuzzy match: param1 zero (disabled) or non-zero (enabled), param2: n/a
 * If enabled, match format in EDID based on resolutions and formats only
 * Default is zero (disabled, so match on blanking periods and pixel clock)
 * Set to non-zero to enable fuzzy match
 */
typedef enum {
   EDID_FUZZY_MATCH_DISABLED = 0x0,
   EDID_FUZZY_MATCH_ENABLED  = 0x1,
   EDID_FUZZY_MATCH_MAX
} EDID_FuzzyMatch_T;

/**
 * 3D structure: param1 - 3D structure (e.g. top/bottom side by side) (default value is none, i.e. 2D)
 *               param2 - n/a at the moment, may be used in the future
 *
 * 3D structure is auto reset to "2D" every time HDMI is power on. Only affect CEA formats.
 */
/*
 * Matched to the 3d struct bit fields stored internally to represent 3D support in EDID
 */
typedef enum {
   HDMI_3D_FORMAT_NONE = 0,           /**<plain and simple 2D! */
   HDMI_3D_FORMAT_SBS_HALF = (1<<7),  /**<side by side half horizontal */
   HDMI_3D_FORMAT_TB_HALF  = (1<<6),  /**<top and bottom half vertical */
   HDMI_3D_FORMAT_FRAME_PACKING = (1<<8),  /**<frame packed */
   HDMI_3D_FORMAT_FRAME_SEQUENTIAL = (1<<9),  /**<Output left on even frames and right on odd frames (typically 120Hz)*/
   /* More 3D structs, e.g. full frame packing, may be added here */
   HDMI_3D_FORMAT_INVALID = 0xFFFF
} HDMI_3D_FORMAT_T;

#endif //_VC_HDMI_PROPERTY_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VC_HOSTREQ_DEFS_H
#define VC_HOSTREQ_DEFS_H

#include "vcinclude/common.h"

#define VC_HOSTREQ_VER 1

/* Types and constants common across the both ends of the interface */
#define VC_HRMAX_CMD_DATA        512
#define VC_HRMAX_VIBRATOR_SEQ    (VC_HRMAX_CMD_DATA/4)

typedef unsigned int keys_t;
typedef unsigned int led_t;

/* Error codes used in responses and in the API */
enum
{
   VC_HRERR_OK          =  0,    /* Success */
   VC_HRERR_NOTREADY    =  1,
   VC_HRERR_UNSUPPORTED =  10,   /* Unsupported or inappropriate request */
   VC_HRERR_MEMADDR     =  20,   /* Trying to read protected host memory */
};

/* Key bit enumerations */
typedef enum
{
   // ENTRIES MUST ONLY BE ADDED TO THE END OF THIS ENUM LIST

   VC_KEY_0 =        (1<<0),
   VC_KEY_1 =        (1<<1),
   VC_KEY_2 =        (1<<2),
   VC_KEY_3 =        (1<<3),
   VC_KEY_4 =        (1<<4),
   VC_KEY_5 =        (1<<5),
   VC_KEY_6 =        (1<<6),
   VC_KEY_7 =        (1<<7),
   VC_KEY_8 =        (1<<8),
   VC_KEY_9 =        (1<<9),
   VC_KEY_UP =       (1<<10),
   VC_KEY_DOWN =     (1<<11),
   VC_KEY_LEFT =     (1<<12),
   VC_KEY_RIGHT =    (1<<13),
   VC_KEY_ENTER =    (1<<14),
   VC_KEY_SEND =     (1<<15),
   VC_KEY_END =      (1<<16),
   VC_KEY_MENU =     (1<<17),
   VC_KEY_VOLUP =    (1<<18),
   VC_KEY_VOLDOWN =  (1<<19),
   VC_KEY_STAR =     (1<<20),
   VC_KEY_HASH =     (1<<21),
   VC_KEY_CANCEL =   (1<<22),
   VC_KEY_CAMERA =   (1<<23),
   VC_KEY_RECORD =   (1<<24),
   VC_KEY_INFO =     (1<<25),
   VC_KEY_DVB =      (1<<26),
   VC_KEY_ANY =      (1<<27)-1  // change this if any more keys are added
} VC_HOSTKEYS_T;

/* Add notify events here */
typedef enum
{
   // ENTRIES MUST ONLY BE ADDED TO THE END OF THIS ENUM LIST

   VC_HRNOTIFY_START = 0,
   VC_HRNOTIFY_GAME_ACCEPT,
   VC_HRNOTIFY_GAME_REJECT,
   VC_HRNOTIFY_GAME_SAVE,
   VC_HRNOTIFY_GAME_LOAD,
   VC_HRNOTIFY_GAME_EXIT,
   VC_HRNOTIFY_MELODY_END,
   VC_HRNOTIFY_DISK_INSERTED,
   VC_HRNOTIFY_DISK_REMOVED,
   VC_HRNOTIFY_RINGTONE_END,
   VC_HRNOTIFY_KEYTONE_END,
   VC_HRNOTIFY_GAME_ABORT,
   VC_HRNOTIFY_PCM_END,
   VC_HRNOTIFY_FS_INUSE,
   VC_HRNOTIFY_FS_NOT_INUSE,
   VC_HRNOTIFY_APP_STATUS,    /* app's status has changed (excluding things like elapsed times) - mainly errors or status changed */
   VC_HRNOTIFY_CAMERA_EVENT,
   VC_HRNOTIFY_END

} VC_HRNOTIFY_T;

//typedef of the callback from a HRNOTIFY function
typedef void (* VC_HRNOTIFY_CALLBACK_T)( const VC_HRNOTIFY_T notify_event, const uint32_t param );

//typedef of the callback from a RENDERTEXT/CONGIFTEXT/LINKDATA/DMB* function
typedef void (* VC_HRDATA_CALLBACK_T)( int cmd, void *userdata, uint8_t *data, int len );

/* Enum host request commands here rather than in vcinterface */
/*
   NB There is overlap of command enumerations with other services
   - but this does not matter
*/
enum
{
   // ENTRIES MUST ONLY BE ADDED TO THE END OF THIS ENUM LIST

   /* Host request service commands, vc->host */
   VC_HOSTREQ_RESET = 64,
   VC_HOSTREQ_CAPTUREKEYS,
   VC_HOSTREQ_VIBRATORPLAY,
   VC_HOSTREQ_VIBRATORSTOP,
   VC_HOSTREQ_KEYLIGHT,
   VC_HOSTREQ_SETLEDS,
   VC_HOSTREQ_TIME,
   VC_HOSTREQ_NOTIFY,
   VC_HOSTREQ_READMEM,
   VC_HOSTREQ_CONFIGTEXT,
   VC_HOSTREQ_RENDERTEXT,
   VC_HOSTREQ_LINKDATA,
   VC_HOSTREQ_MALLOC,
   VC_HOSTREQ_FREE,
   VC_HOSTREQ_MEMMOVE,
   VC_HOSTREQ_WRITEMEM,
   VC_HOSTREQ_KEYIN,
   VC_HOSTREQ_DISPLAYDEV,
   VC_HOSTREQ_ACCESSURL,
   VC_HOSTREQ_DMB_FIC,
   VC_HOSTREQ_DMB_PAD,
   VC_HOSTREQ_DMB_DATA,
   VC_HOSTREQ_READMEM_3D,
   VC_HOSTREQ_SEND_PCM,
   VC_HOSTREQ_AUDIODEVREQUEST,
   VC_HOSTREQ_AUDIODEVCONFIG,
   VC_HOSTREQ_AUDIODEVRELEASE,
   VC_HOSTREQ_PHOTOROW,
   VC_HOSTREQ_COPYCONTROL,
   VC_HOSTREQ_READPIXELS,   /* Batch read of photo data from host */
   VC_HOSTREQ_REPORT_AV_STATS,
   VC_HOSTREQ_GPIO,

   /* Host request service key messages */
   VC_HOSTREQ_KEYEVENT = 96,
   VC_HOSTREQ_KEYACK
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// OpenMAX IL Component Service definitions

#ifndef VC_ILCS_DEFS_H
#define VC_ILCS_DEFS_H

#define VC_ILCS_VERSION 1

#ifdef USE_VCHIQ_ARM
#include "interface/vchiq_arm/vchiq.h"
#else
#include "interface/vchiq/vchiq.h"
#endif

typedef enum {
   IL_RESPONSE,
   IL_CREATE_COMPONENT,

   IL_GET_COMPONENT_VERSION,
   IL_SEND_COMMAND,
   IL_GET_PARAMETER,
   IL_SET_PARAMETER,
   IL_GET_CONFIG,
   IL_SET_CONFIG,
   IL_GET_EXTENSION_INDEX,
   IL_GET_STATE,
   IL_COMPONENT_TUNNEL_REQUEST,
   IL_USE_BUFFER,
   IL_USE_EGL_IMAGE,
   IL_ALLOCATE_BUFFER,
   IL_FREE_BUFFER,
   IL_EMPTY_THIS_BUFFER,
   IL_FILL_THIS_BUFFER,
   IL_SET_CALLBACKS,
   IL_COMPONENT_ROLE_ENUM,

   IL_COMPONENT_DEINIT,

   IL_EVENT_HANDLER,
   IL_EMPTY_BUFFER_DONE,
   IL_FILL_BUFFER_DONE,

   IL_COMPONENT_NAME_ENUM,
   IL_GET_DEBUG_INFORMATION,

   IL_SERVICE_QUIT,
   IL_FUNCTION_MAX_NUM,
   IL_FUNCTION_MAX = 0x7fffffff
} IL_FUNCTION_T;


// size of the largest structure passed by get/set
// parameter/config
// this should be calculated at compile time from IL headers
// must be a multiple of VC_INTERFACE_BLOCK_SIZE
#define VC_ILCS_MAX_PARAM_SIZE 288

// size of the largest structure below
#define VC_ILCS_MAX_CMD_LENGTH (sizeof(IL_GET_EXECUTE_T))

#define VC_ILCS_MAX_INLINE (VCHIQ_SLOT_SIZE-8-16)

// all structures should be padded to be multiples of
// VC_INTERFACE_BLOCK_SIZE in length (currently 16)
typedef struct {
   void *reference;
} IL_EXECUTE_HEADER_T;

typedef struct {
   IL_FUNCTION_T func;
   OMX_ERRORTYPE err;
} IL_RESPONSE_HEADER_T;

// create instance
typedef struct {
   OMX_PTR mark;
   char name[256];
} IL_CREATE_COMPONENT_EXECUTE_T;

typedef struct {
   IL_FUNCTION_T func;
   OMX_ERRORTYPE err;
   void *reference;
   OMX_U32 numPorts;
   OMX_U32 portDir;
   OMX_U32 portIndex[32];
} IL_CREATE_COMPONENT_RESPONSE_T;

// set callbacks
typedef struct {
   void *reference;
   void *pAppData;
} IL_SET_CALLBACKS_EXECUTE_T;

// get state
typedef struct {
   IL_FUNCTION_T func;
   OMX_ERRORTYPE err;
   OMX_STATETYPE state;
} IL_GET_STATE_RESPONSE_T;

// get parameter & get config
#define IL_GET_EXECUTE_HEADER_SIZE 8
typedef struct {
   void *reference;
   OMX_INDEXTYPE index;
   unsigned char param[VC_ILCS_MAX_PARAM_SIZE];
} IL_GET_EXECUTE_T;

#define IL_GET_RESPONSE_HEADER_SIZE 8
typedef struct {
   IL_FUNCTION_T func;
   OMX_ERRORTYPE err;
   unsigned char param[VC_ILCS_MAX_PARAM_SIZE];
} IL_GET_RESPONSE_T;

// set parameter & set config
#define IL_SET_EXECUTE_HEADER_SIZE 8
typedef struct {
   void *reference;
   OMX_INDEXTYPE index;
   unsigned char param[VC_ILCS_MAX_PARAM_SIZE];
} IL_SET_EXECUTE_T;

// send command
typedef struct {
   void *reference;
   OMX_COMMANDTYPE cmd;
   OMX_U32 param;
   OMX_MARKTYPE mark;
} IL_SEND_COMMAND_EXECUTE_T;

// event handler callback
typedef struct {
   void *reference;
   OMX_EVENTTYPE event;
   OMX_U32 data1;
   OMX_U32 data2;
   OMX_PTR eventdata;
} IL_EVENT_HANDLER_EXECUTE_T;

// use/allocate buffer
typedef struct {
   void *reference;
   OMX_PTR bufferReference;
   OMX_U32 port;
   OMX_U32 size;
   void *eglImage;
} IL_ADD_BUFFER_EXECUTE_T;

typedef struct {
   IL_FUNCTION_T func;
   OMX_ERRORTYPE err;
   OMX_PTR reference;
   OMX_BUFFERHEADERTYPE bufferHeader;
} IL_ADD_BUFFER_RESPONSE_T;

// free buffer
typedef struct {
   void *reference;
   OMX_U32 port;
   OMX_PTR bufferReference;
   IL_FUNCTION_T func;
   OMX_PTR inputPrivate;
   OMX_PTR outputPrivate;
} IL_FREE_BUFFER_EXECUTE_T;

// empty/fill this buffer
typedef enum {
   IL_BUFFER_NONE,
   IL_BUFFER_BULK,
   IL_BUFFER_INLINE,
   IL_BUFFER_MAX = 0x7fffffff
} IL_BUFFER_METHOD_T;

#define IL_BUFFER_BULK_UNALIGNED_MAX (32) // This value needs to be the same on voth VC and HOST.
                                          // Here, we just manually set it to the max of VCHI_BULK_ALIGN on VC and HOST. 
#if ( VCHI_BULK_ALIGN > IL_BUFFER_BULK_UNALIGNED_MAX )
   #error "VCHI_BULK_ALIGN > IL_BUFFER_BULK_UNALIGNED_MAX. Just set max higher on both VC and HOST so there's space to put the unaligned bytes."
#endif
typedef struct {
   OMX_U8 header[IL_BUFFER_BULK_UNALIGNED_MAX-1];
   OMX_U8 headerlen;
   OMX_U8 trailer[IL_BUFFER_BULK_UNALIGNED_MAX-1];
   OMX_U8 trailerlen;
} IL_BUFFER_BULK_T;

typedef struct {
   OMX_U8 buffer[1];
} IL_BUFFER_INLINE_T;

typedef struct {
   void *reference;
   OMX_BUFFERHEADERTYPE bufferHeader;
   IL_BUFFER_METHOD_T method;
   OMX_U32 bufferLen;
} IL_PASS_BUFFER_EXECUTE_T;

// get component version
typedef struct {
   IL_FUNCTION_T func;
   OMX_ERRORTYPE err;
   char name[128];
   OMX_VERSIONTYPE component_version;
   OMX_VERSIONTYPE spec_version;
   OMX_UUIDTYPE uuid;
} IL_GET_VERSION_RESPONSE_T;

// get extension index
typedef struct {
   void *reference;
   char name[128];
} IL_GET_EXTENSION_EXECUTE_T;

typedef struct {
   IL_FUNCTION_T func;
   OMX_ERRORTYPE err;
   OMX_INDEXTYPE index;
} IL_GET_EXTENSION_RESPONSE_T;

// component role enum
typedef struct {
   void *reference;
   OMX_U32 index;
} IL_COMPONENT_ROLE_ENUM_EXECUTE_T;

typedef struct {
   IL_FUNCTION_T func;
   OMX_ERRORTYPE err;
   OMX_U8 role[128];
} IL_COMPONENT_ROLE_ENUM_RESPONSE_T;

typedef struct {
   void *reference;
   OMX_U32 port;
   OMX_PTR tunnel_ref;       // reference to use in requests - address of host/vc component
   OMX_BOOL tunnel_host;     // whether tunnel_ref is a host component
   OMX_U32 tunnel_port;
   OMX_TUNNELSETUPTYPE setup;
} IL_TUNNEL_REQUEST_EXECUTE_T;

typedef struct {
   IL_FUNCTION_T func;
   OMX_ERRORTYPE err;
   OMX_TUNNELSETUPTYPE setup;
} IL_TUNNEL_REQUEST_RESPONSE_T;

typedef struct {
   int index;
} IL_COMPONENT_NAME_ENUM_EXECUTE_T;

typedef struct {
   IL_FUNCTION_T func;
   OMX_ERRORTYPE err;
   OMX_U8 name[128];
} IL_COMPONENT_NAME_ENUM_RESPONSE_T;

typedef struct {
   OMX_S32 len;
} IL_GET_DEBUG_INFORMATION_EXECUTE_T;

#endif // VC_ILCS_DEFS_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef IMAGECONV_DEFS_H
#define IMAGECONV_DEFS_H

/** Statistics for image conversion to foreign image types
 */
typedef struct
{
   uint32_t magic;
   uint32_t size;                   /**< Size of this structure, in bytes */
   uint32_t conversions;            /**< Total conversions so far */
   uint32_t duplicate_conversions;  /**< Duplicate conversions (same image twice) */
   uint32_t size_requests;          /**< Num calls to get_converted_size */
   uint32_t consumed_count;         /**< How many converted images were consumed */
   uint32_t failures;               /**< Failed conversions */
   uint32_t time_spent;             /**< Time spent converting, us */
   uint32_t max_vrf_delay;          /**< The max time waiting for the VRF */
   uint32_t vrf_wait_time;          /**< Total time waiting for the VRF */
   uint32_t last_mem_handle;        /**< Last mem handle converted */
   uint32_t first_image_ts;         /**< Timestamp of first image */
   uint32_t last_image_ts;          /**< Timestamp of first image */
   uint32_t max_delay;              /**< Jitter */
} IMAGECONV_STATS_T;

#define IMAGECONV_STATS_MAGIC 0x494D454C
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
* Copyright (c) 2012 Broadcom Europe Ltd
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * Common definitions for services
 */

#ifndef _VC_SERVICE_COMMON_DEFS_H_
#define _VC_SERVICE_COMMON_DEFS_H_
#include "vcinclude/common.h"
//Map VCHI return value to internal error code
//VCHI return +1 for retry so we will map it to -2 to allow
//servers to use positive values to indicate alternative return values
typedef enum {
   VC_SERVICE_VCHI_SUCCESS = 0,
   VC_SERVICE_VCHI_VCHIQ_ERROR = -1,
   VC_SERVUCE_VCHI_RETRY = -2,
   VC_SERVICE_VCHI_UNKNOWN_ERROR
} VC_SERVICE_VCHI_STATUS_T;

extern VC_SERVICE_VCHI_STATUS_T vchi2service_status(int32_t x);
extern const char* vchi2service_status_string(VC_SERVICE_VCHI_STATUS_T status);

#endif //#ifndef _VC_SERVICE_COMMON_DEFS_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * SDTV common host header for TV service
 */
 
#ifndef _VC_SDTV_H_
#define _VC_SDTV_H_

/** Different SDTV modes */
/** colour */
typedef enum SDTV_COLOUR_
{
   SDTV_COLOUR_UNKNOWN = 0x0,
   SDTV_COLOUR_RGB     = 0x4,
   SDTV_COLOUR_YPRPB   = 0x8,
   SDTV_COLOUR_FORCE_32BIT    = 0x80000000
} SDTV_COLOUR_T;
/** operation mode */
typedef enum SDTV_MODE_T_
{
   SDTV_MODE_NTSC       = 0, /**<Normal NTSC */
   SDTV_MODE_NTSC_J     = 1, /**<Japanese version of NTSC - no pedestal.*/
   SDTV_MODE_PAL        = 2, /**<Normal PAL */
   SDTV_MODE_PAL_M      = 3, /**<Brazilian version of PAL - 525/60 rather than 625/50, different subcarrier */
   SDTV_MODE_FORMAT_MASK = 0x3,
   
   SDTV_MODE_OUTPUT_MASK = 0xc,

   SDTV_MODE_YPRPB_480i = (SDTV_MODE_NTSC | SDTV_COLOUR_YPRPB),
   SDTV_MODE_RGB_480i   = (SDTV_MODE_NTSC | SDTV_COLOUR_RGB),
   SDTV_MODE_YPRPB_576i = (SDTV_MODE_PAL  | SDTV_COLOUR_YPRPB),
   SDTV_MODE_RGB_576i   = (SDTV_MODE_PAL  | SDTV_COLOUR_RGB),

   SDTV_MODE_OFF        = 0xf0,
   SDTV_MODE_FORCE_32BIT = 0x80000000
} SDTV_MODE_T;

/** Different aspect ratios */
typedef enum SDTV_ASPECT_T_
{
   // TODO: extend this to allow picture placement/size to be communicated.
   SDTV_ASPECT_UNKNOWN  = 0, /**<Unknown */
   SDTV_ASPECT_4_3      = 1, /**<4:3 */
   SDTV_ASPECT_14_9     = 2, /**<14:9 */
   SDTV_ASPECT_16_9     = 3, /**<16:9 */
   SDTV_ASPECTFORCE_32BIT = 0x80000000
} SDTV_ASPECT_T;

/** SDTV power on option */
typedef struct SDTV_OPTIONS_T_
{
   SDTV_ASPECT_T   aspect;
} SDTV_OPTIONS_T;

/**
 * Different copy protection modes
 * At the moment we have only implemented Macrovision
 */
typedef enum
{
   SDTV_CP_NONE              = 0, /**<No copy protection */
   SDTV_CP_MACROVISION_TYPE1 = 1, /**<Macrovision Type 1 */
   SDTV_CP_MACROVISION_TYPE2 = 2, /**<Macrovision Type 2 */
   SDTV_CP_MACROVISION_TYPE3 = 3, /**<Macrovision Type 3 */
   SDTV_CP_MACROVISION_TEST1 = 4, /**<Macrovision Test 1 */
   SDTV_CP_MACROVISION_TEST2 = 5, /**<Macrovision Test 2 */
   SDTV_CP_CGMS_COPYFREE     = 6, /**<CGMS copy freely */
   SDTV_CP_CGMS_COPYNOMORE   = 7, /**<CGMS copy no more */
   SDTV_CP_CGMS_COPYONCE     = 8, /**<CGMS copy once */
   SDTV_CP_CGMS_COPYNEVER    = 9, /**<CGMS copy never */
   SDTV_CP_WSS_COPYFREE      = 10, /**<WSS no restriction */
   SDTV_CP_WSS_COPYRIGHT_COPYFREE = 11, /**<WSS copyright asserted */
   SDTV_CP_WSS_NOCOPY        = 12, /**<WSS copying restricted */
   SDTV_CP_WSS_COPYRIGHT_NOCOPY = 13, /**<WSS copying restriced, copyright asserted */
   SDTV_CP_FORCE_32BIT = 0x80000000
} SDTV_CP_MODE_T;

/**
 * SDTV internal state
 */
typedef struct {
   uint32_t state;
   uint32_t width;
   uint32_t height;
   uint16_t frame_rate;
   uint16_t scan_mode;
   SDTV_MODE_T mode;
   SDTV_OPTIONS_T display_options;
   SDTV_COLOUR_T colour;
   SDTV_CP_MODE_T cp_mode;
} SDTV_DISPLAY_STATE_T;

/**
 * SDTV notifications
 */
typedef enum 
{
   VC_SDTV_UNPLUGGED          = 1 << 16, /**<SDTV cable unplugged, subject to platform support */
   VC_SDTV_ATTACHED           = 1 << 17, /**<SDTV cable is plugged in */
   VC_SDTV_NTSC               = 1 << 18, /**<SDTV is in NTSC mode */
   VC_SDTV_PAL                = 1 << 19, /**<SDTV is in PAL mode */
   VC_SDTV_CP_INACTIVE        = 1 << 20, /**<Copy protection disabled */
   VC_SDTV_CP_ACTIVE          = 1 << 21  /**<Copy protection enabled */
} VC_SDTV_NOTIFY_T;
#define VC_SDTV_STANDBY (VC_SDTV_ATTACHED) /* For backward code compatibility, to be consistent with HDMI */

/**
 * Callback reason and arguments from vec middleware
 * Each callback comes with two optional uint32_t parameters.
 * Reason                     param1       param2      remark
 * VC_SDTV_UNPLUGGED            -            -         cable is unplugged
 * VC_SDTV_STANDBY              -            -         cable is plugged in
 * VC_SDTV_NTSC              SDTV_MODE_T SDTV_ASPECT_T NTSC mode active with said aspect ratio
 * VC_SDTV_PAL               SDTV_MODE_T SDTV_ASPECT_T PAL  mode active with said aspect ratio
 * VC_SDTV_CP_INACTIVE          -            -         copy protection is inactive
 * VC_SDTV_CP_ACTIVE         SDTV_CP_MODE_T  -         copy protection is active
 */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * TV service host API,
 * See vc_hdmi.h for HDMI related constants
 * See vc_sdtv.h for SDTV related constants
 */

#ifndef _VC_TVSERVICE_H_
#define _VC_TVSERVICE_H_

#include "vcinclude/common.h"
#include "interface/vcos/vcos.h"
#include "interface/vchi/vchi.h"
#include "interface/vmcs_host/vc_tvservice_defs.h"
#include "interface/vmcs_host/vc_hdmi.h"
#include "interface/vmcs_host/vc_sdtv.h"

/**
 * \file
 *
 * This API defines the controls for both HDMI and analogue TVs. It allows
 * the user to dynamically switch between HDMI and SDTV without having
 * to worry about switch one off before turning the other on. It also
 * allows the user to query the supported HDMI resolutions and audio
 * formats and turn on/off copy protection.
 *
 * There are three ways to turn on HDMI: preferred mode; best matched mode
 * and explicit mode. See the three power on functions for details.
 */

/**
 * TVSERVICE_CALLBACK_T is the callback function for host side notification.
 * Host applications register a single callback for all TV related notifications.
 * See <DFN>VC_HDMI_NOTIFY_T</DFN> and <DFN>VC_SDTV_NOTIFY_T</DFN> in vc_hdmi.h and vc_sdtv.h
 * respectively for list of reasons and respective param1 and param2
 *
 * @param callback_data is the context passed in during the call to vc_tv_register_callback
 *
 * @param reason is the notification reason
 *
 * @param param1 is the first optional parameter
 *
 * @param param2 is the second optional parameter
 *
 * @return void
 */
typedef void (*TVSERVICE_CALLBACK_T)(void *callback_data, uint32_t reason, uint32_t param1, uint32_t param2);

/* API at application start time */
/**
 * <DFN>vc_vchi_tv_init</DFN> is called at the beginning of the application
 * to initialise the client to TV service
 *
 * @param initialise_instance is the VCHI instance
 *
 * @param array of pointers of connections
 *
 * @param number of connections (currently this is always <DFN>1</DFN>
 *
 * @return Zero is successful A negative return value indicates failure (which may mean it has not been started on VideoCore).
 */
VCHPRE_ int vc_vchi_tv_init(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );

/**
 * <DFN>vc_vchi_tv_stop</DFN> is called to stop the host side of TV service.
 *
 * @param none
 *
 * @return void
 */
VCHPRE_ void vc_vchi_tv_stop( void );

/**
 * Host applications should call <DFN>vc_tv_register_callback</DFN> at
 * the beginning to register a callback function to handle all notifications.
 * See <DFN>TVSERVICE_CALLBACK_T </DFN>
 *
 * @param callback function
 *
 * @param callback_data is the context to be passed when function is called
 *
 * @return void
 */
VCHPRE_ void vc_tv_register_callback(TVSERVICE_CALLBACK_T callback, void *callback_data);

/**
 * <DFN>vc_tv_unregister_callback</DFN> removes a function registered with
 * <DFN>vc_tv_register_callback</DFN> from the list of callbacks.
 *
 * @param callback function
 *
 * @return void
 */
VCHPRE_ void vc_tv_unregister_callback(TVSERVICE_CALLBACK_T callback);

/**
 * <DFN>vc_tv_unregister_callback</DFN> removes a function registered with
 * <DFN>vc_tv_register_callback</DFN> from the list of callbacks.
 * In contrast to vc_tv_unregister_callback this one matches not only the
 * function pointer but also the data pointer before removal.
 *
 * @param callback function
 *
 * @return void
 */
VCHPRE_ void vc_tv_unregister_callback_full(TVSERVICE_CALLBACK_T callback, void *callback_data);

/**
 * In the following API any functions applying to HDMI only will have hdmi_
 * in the name, ditto for SDTV only will have sdtv_ in the name,
 * Otherwise the function applies to both SDTV and HDMI (e.g. power off)
 */

/**
 * <DFN>vc_tv_get_state</DFN> is used to obtain the current TV state.
 * Host applications should call this function right after registering
 * a callback in case any notifications are missed.
 *
 * Now deprecated - use vc_tv_get_display_state instead
 *
 * @param pointer to TV_GET_STATE_RESP_T
 *
 * @return zero if the command is sent successfully, non zero otherwise
 * If the command fails to be sent, passed in state is unchanged
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_get_state(TV_GET_STATE_RESP_T *tvstate);

/**
 * <DFN>vc_tv_get_display_state</DFN> is used to obtain the current TV display
 * state. This function supersedes vc_tv_get_state (which is only kept for
 * backward compatibility.
 * Host applications should call this function right after registering
 * a callback in case any notifications are missed.
 *
 * @param pointer to TV_DISPLAY_STATE_T
 *
 * @return zero if the command is sent successfully, non zero otherwise
 * If the command fails to be sent, passed in state is unchanged
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_get_display_state(TV_DISPLAY_STATE_T *tvstate);

/**
 * Use <DFN>vc_tv_hdmi_power_on_preferred</DFN> if you don't care what resolutions
 * a TV supports and just want to turn on its native resolution. Analogue TV will
 * be powered down if on (same for the following two HDMI power on functions.)
 * If power on is successful, a host application must wait for the power on complete
 * callback before attempting to open the display.
 *
 * @param none
 *
 * @return single value interpreted as HDMI_RESULT_T (zero means success)
 *         if successful, there will be a callback when the power on is complete
 *
 **/
VCHPRE_ int VCHPOST_ vc_tv_hdmi_power_on_preferred( void );

/**
 * Same as above, but tell the TV to enter 3D mode. The TV will go to 2D mode
 * if the preferred mode doesn't support 3D.
 **/
VCHPRE_ int VCHPOST_ vc_tv_hdmi_power_on_preferred_3d( void );

/**
 * Use <DFN>vc_tv_hdmi_power_on_best</DFN> to power on HDMI at best matched resolution
 * based on passed in parameters. Use HDMI_MODE_MATCH_FRAMERATE if you want to
 * match the frame rate; use HDMI_MODE_MATCH_RESOLUTION if you want to match on
 * screen size; add HDMI_MODE_MATCH_SCANMODE if you want to force
 * interlaced/progressive mode. If no matching mode is found, the native resolution
 * will be used instead.
 *
 * @param width is the desired minimum screen width
 *
 * @param height is the desired minimum screen height
 *
 * @param rate is the desired frame rate
 *
 * @param scan_mode (HDMI_NONINTERLACED / HDMI_INTERLACED) is the desired scan mode
 *
 * @param match flags is the matching flag <DFN>EDID_MODE_MATCH_FLAG_T</DFN>
 *
 * @return same as <DFN>vc_tv_hdmi_power_on_preferred</DFN>
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                              HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags);

/**
 * Same as above, but tell the TV to enter 3D mode. The TV will go to 2D mode
 * if no suitable 3D mode can be found.
 **/
VCHPRE_ int VCHPOST_ vc_tv_hdmi_power_on_best_3d(uint32_t width, uint32_t height, uint32_t frame_rate,
                                              HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags);

/**
 * Use <DFN>vc_tv_hdmi_power_on_explicit</DFN> if you want full control over what mode
 * the TV is driven. This function is used, for example, when the host has the EDID
 * and HDMI middleware does not know. If HDMI middleware has knowledge of EDID, the
 * passed in mode is still subject to TV's supported modes
 *
 * @param mode (HDMI_MODE_HDMI/HDMI_MODE_DVI/HDMI_MODE_3D)
 *
 * @param group (HDMI_RES_GROUP_CEA/HDMI_RES_GROUP_DMT)
 *
 * @param code either <DFN>HDMI_CEA_RES_CODE_T</DFN> or <DFN>HDMI_DMT_RES_CODE_T</DFN>
 *
 * @return same as <DFN>vc_tv_hdmi_power_on_preferred</DFN>
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_power_on_explicit_new(HDMI_MODE_T mode, HDMI_RES_GROUP_T group, uint32_t code);

/**
 * <DFN>vc_tv_sdtv_power_on</DFN> is used to turn on analogue TV. HDMI will
 * automatically be powered off if on.
 *
 * @param SDTV mode <DFN>SDTV_MODE_T</DFN>
 *
 * @param options <DFN>SDTV_OPTIONS_T</DFN>
 *
 * @return single value (zero means success) if successful, there will be a callback when the power on is complete
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options);

/**
 * <DFN>vc_tv_power_off</DFN> is used to turn off either analogue or HDMI output.
 * If HDMI is powered down, there will be a callback with reason UNPLUGGED (if no
 * cable is attached) or STANDBY (if a cable is attached)
 *
 * @param none
 *
 * @return whether command is succcessfully sent
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_power_off( void );

/**
 * <DFN>vc_tv_hdmi_get_supported_modes</DFN> is used to get a list of supported
 * modes for a particular standard (CEA/DMT/CEA3D). Prefer resolution (group and mode)
 * is also returned, if needed. If there are more modes supported than the size of the array
 * supply, only the array will be filled.
 *
 * @param group(HDMI_RES_GROUP_CEA/HDMI_RES_GROUP_DMT)
 *
 * @param array of <DFN>TV_SUPPORT_MODE_T</DFN> struct
 *
 * @param length of array above (in elements, not bytes)
 *
 * @pointer to preferred group (can be NULL)
 *
 * @pointer to prefer mode code (can be NULL)
 *
 * @return the number of modes actually written in the array,
 *         zero means no modes (no EDID or cable unplugged)
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_get_supported_modes_new(HDMI_RES_GROUP_T group,
                                                    TV_SUPPORTED_MODE_NEW_T *supported_modes,
                                                    uint32_t max_supported_modes,
                                                    HDMI_RES_GROUP_T *preferred_group,
                                                    uint32_t *preferred_mode);
/**
 * <DFN>vc_tv_hdmi_mode_supported</DFN> is used to query whether a particular mode
 * is supported or not.
 *
 * @param resolution standard (HDMI_RES_GROUP_CEA/HDMI_RES_GROUP_DMT)
 *
 * @param mode code
 *
 * @return > 0 means supported, 0 means unsupported, < 0 means error
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_mode_supported(HDMI_RES_GROUP_T group,
                                               uint32_t mode);

/**
 * <DFN>vc_tv_hdmi_audio_supported</DFN> is used to query whether a
 * particular audio format is supported. By default a device has to support
 * 16-bit stereo PCM at 32/44.1/48 kHz if audio is supported at all.
 * Support of other audio formats allow SPDIF to be used.
 * A return value of zero means the audio format is completely supported.
 * Any non-zero values are interpreted as bit mask (EDID_AUDIO_SUPPORT_FLAG_T).
 * For example, if EDID_AUDIO_NO_SUPPORT is set, the audio format is not supported.
 * If EDID_AUDIO_CHAN_UNSUPPORTED is set, the max no. of channels has exceeded.
 *
 * @param audio format supplied as (<DFN>EDID_AudioFormat</DFN> + <DFN>EDID_AudioCodingExtension</DFN>)
 *
 * @param no. of channels (1-8)
 *
 * @param sample rate <DFN>EDID_AudioSampleRate</DFN> but NOT "refer to header"
 *
 * @param bit rate (or sample size if pcm) use <DFN>EDID_AudioSampleSize</DFN> as sample size argument
 *
 * @return: single value return interpreted as flags in <DFN>EDID_AUDIO_SUPPORT_FLAG_T</DFN>
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_audio_supported(uint32_t audio_format, uint32_t num_channels,
                                                EDID_AudioSampleRate fs, uint32_t bitrate);

/**
 * Use <DFN>vc_tv_enable_copyprotect</DFN> to turn on copy protection.
 * For HDMI, only HDMI_CP_HDCP is recognised.
 * For SDTV, use one of the values in SDTV_CP_MODE_T
 *
 * @param copy protect mode
 *
 * @param time out in milliseconds (only applicable to HDMI)
 *
 * @return 0 means success, additional result via callback
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_enable_copyprotect(uint32_t cp_mode, uint32_t timeout);

/**
 * Use <DFN>vc_tv_disable_copyprotect</DFN> to turn off copy protection
 *
 * @param none
 *
 * @rturn 0 means success, additional result via callback
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_disable_copyprotect( void );

/**
 * Use <DFN>vc_tv_show_info</DFN> to show or hide info screen.
 * Only usable in HDMI at the moment.
 *
 * @param show (1) or hide (0) info screen
 *
 * @return zero if command is successfully sent
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_show_info(uint32_t show);

/**
 * <DFN>vc_tv_hdmi_get_av_latency</DFN> is used to get the AV latency
 * (in ms) for HDMI (lipsync), only valid if HDMI is currently powered on,
 * otherwise you get zero. The latency is defined as the relative delay
 * of the video stream to the audio stream
 *
 * @param none
 *
 * @return latency (zero if error or latency is not defined),
 *         < 0 if failed to send command)
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_get_av_latency( void );

/**
 * Use <DFN>vc_tv_hdmi_set_hdcp_key</DFN> to download HDCP key to HDCP middleware
 *
 * @param AES encrypted key block (328 bytes)
 *
 * @return single value return indicating queued status
 *         Callback indicates the validity of key
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_set_hdcp_key(const uint8_t *key);

/**
 * Use <DFN>vc_tv_hdmi_set_hdcp_revoked_list</DFN> to download SRM
 * revoked list
 *
 * @param list
 *
 * @param size of list (no. of keys)
 *
 * @return single value return indicating queued status
 *         Callback indicates the number of keys set (zero if failed, unless you are clearing the list)
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_set_hdcp_revoked_list(const uint8_t *list, uint32_t num_keys);

/**
 * <DFN>vc_tv_hdmi_set_spd</DFN> is used to set the SPD infoframe.
 *
 * @param manufacturer (max. 8 characters)
 *
 * @param description (max. 16 characters)
 *
 * @param product type <DFN>HDMI_SPD_TYPE_CODE_T</DFN>
 *
 * @return whether command was sent successfully (zero means success)
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_set_spd(const char *manufacturer, const char *description, HDMI_SPD_TYPE_CODE_T type);

/**
 * <DFN>vc_tv_hdmi_set_display_options</DFN> is used to set the
 * active area for HDMI (bar width/height should be set to zero if absent)
 * This information is conveyed in AVI infoframe.
 *
 * @param aspect ratio <DFN>HDMI_ASPECT_T</DFN>
 *
 * @param left bar width
 *
 * @param right bar width
 *
 * @param top bar height
 *
 * @param bottom bar height
 *
 * @return whether command was sent successfully (zero means success)
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_set_display_options(HDMI_ASPECT_T aspect, uint32_t left_bar_width, uint32_t right_bar_width, uint32_t top_bar_height, uint32_t bottom_bar_height, uint32_t overscan_flags);

/**
 * Use <DFN>vc_tv_test_mode_start</DFN> to generate test signal.
 * At the moment only DVI test signal is supported.
 * HDMI must be powered off before this function is called.
 *
 * @param 24-bit background colour (if applicable)
 *
 * @param test mode <DFN>TV_TEST_MODE_T</DFN>
 *
 * @return whether command was sent successfully (zero means success)
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_test_mode_start(uint32_t colour, TV_TEST_MODE_T test_mode);

/**
 * Use <DFN>vc_tv_test_mode_stop</DFN> to stop the test signal and power down
 * HDMI.
 *
 * @param none
 *
 * @return whether command was sent successfully (zero means success)
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_test_mode_stop( void );

/**
 * <DFN>vc_tv_hdmi_ddc_read</DFN> allows an host application to read EDID
 * with DDC protocol.
 *
 * @param offset
 *
 * @param length to read (this is typically 128 bytes to coincide with EDID block size)
 *
 * @param pointer to buffer, must be 16 byte aligned
 *
 * @returns length of data read (so zero means error) and the buffer will be filled
 *          only if there is no error
 *
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_ddc_read(uint32_t offset, uint32_t length, uint8_t *buffer);

/**
 * Sets the TV state to attached.
 * Required when hotplug interrupt is not handled by VideoCore.
 *
 * @param attached  non-zero if the TV is attached or zero for unplugged.
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_set_attached(uint32_t attached);

/**
 * Sets one of the HDMI properties. HDMI properties persist
 * between HDMI power on/off
 *
 * @param property [in]
 *
 * @return zero if successful, non-zero otherwise
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_set_property(const HDMI_PROPERTY_PARAM_T *property);

/**
 * Gets the current value of an HDMI property.
 *
 * @param property [in/out]
 *
 * @return zero if success (param1/param2 will be set), non-zero otherwise (param1/param2 will not be set)
 */
VCHPRE_ int VCHPOST_ vc_tv_hdmi_get_property(HDMI_PROPERTY_PARAM_T *property);

/**
 * Converts the notification reason to a string.
 *
 * @param reason is the notification reason
 * @return  The notification reason as a string.
 */
VCHPRE_ const char* vc_tv_notification_name(VC_HDMI_NOTIFY_T reason);

/**
 * Get the unique device ID from the EDID
 * @param pointer to device ID struct
 * @return zero if successful, non-zero if failed.
 */
VCHPRE_ int VCHPOST_  vc_tv_get_device_id(TV_DEVICE_ID_T *id);

// temporary: maintain backwards compatibility
VCHPRE_ int VCHPOST_ vc_tv_hdmi_get_supported_modes(HDMI_RES_GROUP_T group,
                                                    TV_SUPPORTED_MODE_T *supported_modes,
                                                    uint32_t max_supported_modes,
                                                    HDMI_RES_GROUP_T *preferred_group,
                                                    uint32_t *preferred_mode);
// temporary: maintain backwards compatibility
VCHPRE_ int VCHPOST_ vc_tv_hdmi_power_on_explicit(HDMI_MODE_T mode, HDMI_RES_GROUP_T group, uint32_t code);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * TV service command enumeration and parameter types.
 */

#ifndef _VC_TVSERVICE_DEFS_H_
#define _VC_TVSERVICE_DEFS_H_
#include "vcinclude/common.h"
#include "interface/vchi/message_drivers/message.h"
#include "vc_hdmi.h"
#include "vc_sdtv.h"

#define VC_TVSERVICE_VER   1

#define TVSERVICE_MSGFIFO_SIZE 1024
#define TVSERVICE_CLIENT_NAME MAKE_FOURCC("TVSV")
#define TVSERVICE_NOTIFY_NAME MAKE_FOURCC("TVNT")

#define TVSERVICE_MAX_CALLBACKS  5

//TV service commands
typedef enum {
   VC_TV_GET_STATE = 0,
   VC_TV_HDMI_ON_PREFERRED,
   VC_TV_HDMI_ON_BEST,
   VC_TV_HDMI_ON_EXPLICIT,
   VC_TV_SDTV_ON,
   VC_TV_OFF,
   VC_TV_QUERY_SUPPORTED_MODES,
   VC_TV_QUERY_MODE_SUPPORT,
   VC_TV_QUERY_AUDIO_SUPPORT,
   VC_TV_ENABLE_COPY_PROTECT,
   VC_TV_DISABLE_COPY_PROTECT,
   VC_TV_SHOW_INFO,
   VC_TV_GET_AV_LATENCY,
   VC_TV_HDCP_SET_KEY,
   VC_TV_HDCP_SET_SRM,
   VC_TV_SET_SPD,
   VC_TV_SET_DISPLAY_OPTIONS,
   VC_TV_TEST_MODE_START,
   VC_TV_TEST_MODE_STOP,
   VC_TV_DDC_READ,
   VC_TV_SET_ATTACHED,
   VC_TV_SET_PROP,
   VC_TV_GET_PROP,
   VC_TV_GET_DISPLAY_STATE,
   VC_TV_QUERY_SUPPORTED_MODES_ACTUAL,
   VC_TV_GET_DEVICE_ID,
   //Add more commands here
   VC_TV_END_OF_LIST
} VC_TV_CMD_CODE_T;

//Parameters for each command (padded to multiple of 16 bytes)
//See vc_hdmi.h and vc_sdtv.h for details

//GET_STATE
//Parameters: none
//Reply: state (flags of VC_HDMI_NOTIFY_T and VC_SDTV_NOTIFY_T)
//       current width
//       current height
//       current refresh rate
//       current scan mode

typedef struct {
   uint32_t state;     /**<TV state is a union of bitmask of VC_HDMI_NOTIFY_T and VC_SDTV_NOTIFY_T */
   uint32_t width;     /**<Current display width if TV is on */
   uint32_t height;    /**<Current display height if TV is on */
   uint16_t frame_rate;/**<Current refresh rate is TV is on */
   uint16_t scan_mode; /**<Current scanmode 0 for progressive, 1 for interlaced */
} TV_GET_STATE_RESP_T;

//Generic single returned interpreted based on the command
typedef struct {
   int32_t ret; //Single return value
} TV_GENERAL_RESP_T;

//HDMI_ON_PREFERRED
//Parameters: 3d mode (on/off)
//Reply: single return value interpreted as HDMI_RESULT_T or SDTV equivalent (all single reply value will be of this form)
typedef struct {
   uint32_t in_3d;
} TV_HDMI_ON_PREFERRED_PARAM_T;

//HDMI_ON_BEST
//Parameters: width, height, frame rate, scan mode, matching flag (EDID_MODE_MATCH_FLAG_T), 3d mode (on/off)
//Reply: single return value interpreted as HDMI_RESULT_T or SDTV equivalent
typedef struct {
   uint32_t width;
   uint32_t height;
   uint32_t frame_rate;
   uint32_t scan_mode;
   uint32_t match_flags;
   uint32_t in_3d;
} TV_HDMI_ON_BEST_PARAM_T;

//HDMI_ON_EXPLICIT
//Parameters: hdmi_mode, standard, mode
//Reply: same as above
typedef struct {
   uint32_t hdmi_mode; //DVI or HDMI
   uint32_t group;
   uint32_t mode;
} TV_HDMI_ON_EXPLICIT_PARAM_T;

//SDTV_ON
//Parameters: SDTV mode, aspect ratio
//Reply: Same as above
typedef struct {
   uint32_t mode;
   uint32_t aspect;
} TV_SDTV_ON_PARAM_T;

//TV_OFF
//Parameters: none
//Reply: none

//TV_QUERY_SUPPORTED_MODES
//Parameters: standard (CEA/DMT) sent as uint32_t
//Reply: how many modes there are in this group,
//       preferred resolution

//TV_QUERY_SUPPORTED_MODES_ACTUAL (This  downloads the array of supported modes)
//Parameters: standard (CEA/DMT) sent as uint32_t,
//            table size supplied
//Reply: how many modes which will be returned,
//       prefer resolution,
//       the actual array of modes (via bulk transfer)

typedef struct {
   uint32_t scan_mode    : 1; /**<1 is interlaced, 0 for progressive */
   uint32_t native       : 1; /**<1 means native mode, 0 otherwise */
   uint32_t group        : 3; /**<group */
   uint32_t code         : 7; /**<mode code */
   uint32_t pixel_rep    : 3; /**<pixel repetition (zero means no repetition)*/
   uint32_t aspect_ratio : 5; /**<aspect ratio of the format */
   uint16_t frame_rate;    /**<frame rate */
   uint16_t width;         /**<frame width */
   uint16_t height;        /**<frame height */
   uint32_t pixel_freq;    /**<pixel clock in Hz */
   uint32_t struct_3d_mask;/**<3D structure supported for this mode, only valid if group == CEA. This is a bitmask of HDMI_3D_STRUCT_T */
} TV_SUPPORTED_MODE_NEW_T;

typedef struct {
   uint16_t scan_mode : 1; /**<1 is interlaced, 0 for progressive */
   uint16_t native    : 1; /**<1 means native mode, 0 otherwise */
   uint16_t code      : 7; /**<mode code */
   uint16_t frame_rate;    /**<frame rate */
   uint16_t width;         /**<frame width */
   uint16_t height;        /**<frame height */
} TV_SUPPORTED_MODE_T;

typedef struct {
   uint32_t num_supported_modes;
   uint32_t preferred_group;
   uint32_t preferred_mode;
} TV_QUERY_SUPPORTED_MODES_RESP_T;

//num_supported_modes is the no. of modes available in that group for TV_QUERY_SUPPORTED_MODES
//and no. of modes which will be bulk sent across in TV_QUERY_SUPPORTED_MODES_ACTUAL

//For TV_QUERY_SUPPORTED_MODES_ACTUAL, there will be a separate bulk receive
//containing the supported modes array

//TV_QUERY_MODE_SUPPORT
//Parameters: stardard, mode
//Reply: yes/no
//but the return value meaning is reversed (zero is unsupported, non-zero is supported)
typedef struct {
   uint32_t group;
   uint32_t mode;
} TV_QUERY_MODE_SUPPORT_PARAM_T;

//TV_QUERY_AUDIO_SUPPORT
//Parameters: audio format, no. of channels, sampling frequency, bitrate/sample size
//Reply: single value interpreted as flags EDID_AUDIO_SUPPORT_FLAG_T
typedef struct {
   uint32_t audio_format; //EDID_AudioFormat (if format is eExtended, add EDID_AudioCodingExtension to the audio format)
   uint32_t num_channels; // 1-8
   uint32_t fs;           // EDID_AudioSampleRate
   uint32_t bitrate;      // EDID_AudioSampleSize if format == PCM, bitrate otherwise
} TV_QUERY_AUDIO_SUPPORT_PARAM_T;

//TV_ENABLE_COPY_PROTECT
//Parameters: copy protect mode (for HDMI it will always be HDCP), timeout
//Reply: single return value - cp result arrive via callback
typedef struct {
   uint32_t cp_mode;
   uint32_t timeout;
} TV_ENABLE_COPY_PROTECT_PARAM_T;

//TV_DISABLE_COPY_PROTECT
//Parameters: none
//Reply: single value return - results arrive via callback

//TV_SHOW_INFO
//Parameters: visible
//Reply: none
typedef struct {
   uint32_t visible; //0 to hide the screen
} TV_SHOW_INFO_PARAM_T;

//TV_GET_AV_LATENCY
//Parameters: none
//Reply: single value interpreted as latency in ms


//TV_HDCP_SET_KEY
//Parameters: key block buffer (fixed size HDCP_KEY_BLOCK_SIZE)
//Reply: none, key validity result arrives via callback
typedef struct {
   uint8_t key[HDCP_KEY_BLOCK_SIZE];
} TV_HDCP_SET_KEY_PARAM_T;

//TV_HDCP_SET_SRM
//Parameters: num of keys, pointer to revocation list (transferred as buffer)
//Reply: none, callback indicates no. of keys set
typedef struct {
   uint32_t num_keys;
} TV_HDCP_SET_SRM_PARAM_T;

//TV_SET_SPD
//Parameters: name [8], description [16], type
//Reply: none
#define TV_SPD_NAME_LEN 8
#define TV_SPD_DESC_LEN 16
typedef struct {
   char manufacturer[TV_SPD_NAME_LEN];
   char description[TV_SPD_DESC_LEN];
   uint32_t type;
} TV_SET_SPD_PARAM_T;

//TV_SET_DISPLAY_OPTIONS
//Parameters: aspect ratio (HDMI_ASPECT_T), vert bar present (bool),
//            left bar width, right bar width, horiz bar present (bool)
//            top bar height, bottom bar height
//Reply: none
typedef struct {
   uint32_t aspect;
   uint32_t vertical_bar_present;
   uint32_t left_bar_width;
   uint32_t right_bar_width;
   uint32_t horizontal_bar_present;
   uint32_t top_bar_height;
   uint32_t bottom_bar_height;
   uint32_t overscan_flags;
} TV_SET_DISPLAY_OPTIONS_PARAM_T;

//TV_TEST_MODE_START
//Parameters: rgb colour, test mode
//Reply: none

//Actual enums used for test mode
typedef enum {
   TV_TEST_MODE_DISABLED        = 0, //Test mode disabled
   TV_TEST_MODE_SOLID_BACKGND   = 1, //Solid background colur
   TV_TEST_MODE_SOLID_VERTICAL  = 2, //Vertical bars
   TV_TEST_MODE_SHADED_VERTICAL = 3, //Shaded vertical bars
   TV_TEST_MODE_SHADED_WHITE_V  = 4, //White vertical bars
   TV_TEST_MODE_SHADED_WHITE_H  = 5, //White horizontal bars
   TV_TEST_MODE_SHADED_RGB      = 6, //Shaded RGB + white bars
   TV_TEST_MODE_WALKING         = 7, //Walking one across 24-bit RGB
   TV_TEST_MODE_DELAYED         = 8, //Delayed shaded RGB bars
   TV_TEST_MODE_HVD             = 9, //Horizontal G, Vert. B, Diag. R bars
   TV_TEST_MODE_ODD_CH          =10, //Odd field crosshairs
   TV_TEST_MODE_EVEN_CH         =11, //Even field crosshairs
   TV_TEST_MODE_32x32           =12, //32x32 white grid
   TV_TEST_MODE_WYCGMRBK_SOLID  =13, //Solid blah blah
   TV_TEST_MODE_WYCGMRBK_SHADED =14, //Shaded blah blah
   TV_TEST_MODE_32x32_DIAGONAL  =15  //32x32 white diagonal grid
} TV_TEST_MODE_T;

typedef struct {
   uint32_t colour; //RGB colour
   uint32_t test_mode; //one of the TV_TEST_MODE_T enums above
} TV_TEST_MODE_START_PARAM_T;

//TV_TEST_MODE_STOP
//Parameters: none
//Reply: none

//TV_DDC_READ
//Parameters: offset, length
//Reply: length of data actually read (so zero means error),
//and fills in the passed in buffer if no error
typedef struct {
   uint32_t offset;
   uint32_t length;
} TV_DDC_READ_PARAM_T;

//TV_SET_ATTACHED
//Parameters: uint32_t attached or not (0 = hotplug low, 1 = hotplug high)

//TV_SET_PROP
//Parameters: HDMI_PROPERTY_PARAM_T
//Reply: 0 = set successful, non-zero if error (int32_t) 
#define HDMI_PROPERTY_SIZE_IN_WORDS (sizeof(HDMI_PROPERTY_T)/sizeof(uint32_t))

//TV_GET_PROP
//Parameters: parameter type (sent as uint32_t)
//Reply param1/param2 of the passed in property and return code
typedef struct {
   int32_t  ret; /**<Return code */
   HDMI_PROPERTY_PARAM_T property; /**<HDMI_PROPERTY_PARAM_T */
} TV_GET_PROP_PARAM_T;

//TV_GET_DISPLAY_STATE
//Parameters: none
//Return TV display state
typedef struct {
   uint32_t state;               /** This will be the state of HDMI | SDTV */
   union {
      SDTV_DISPLAY_STATE_T sdtv; /** If SDTV is active, this is the state of SDTV */
      HDMI_DISPLAY_STATE_T hdmi; /** If HDMI is active, this is the state of HDMI */
   } display;
} TV_DISPLAY_STATE_T;

//TV_GET_DEVICE_ID
//Parameter: none
//Return device ID information from EDID
typedef struct {
   char vendor[EDID_DEVICE_VENDOR_ID_LENGTH+1];
   char monitor_name[EDID_DESC_ASCII_STRING_LEN+1];
   uint32_t serial_num;
} TV_DEVICE_ID_T;

// state flag for LCD attached
enum {
   VC_LCD_ATTACHED_DEFAULT    = (1 <<22),  /**<LCD display is attached and default */
};

#endif
                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _VC_AUDIO_DEFS_H_
#define _VC_AUDIO_DEFS_H_

#define VC_AUDIOSERV_MIN_VER 1
#define VC_AUDIOSERV_VER 3

// FourCC code used for VCHI connection
#define VC_AUDIO_SERVER_NAME  MAKE_FOURCC("AUDS")

// Maximum message length
#define VC_AUDIO_MAX_MSG_LEN  (sizeof( VC_AUDIO_MSG_T ))

// List of screens that are currently supported
// All message types supported for HOST->VC direction
typedef enum
{
   VC_AUDIO_MSG_TYPE_RESULT,              // Generic result
   VC_AUDIO_MSG_TYPE_COMPLETE,              // playback of samples complete
   VC_AUDIO_MSG_TYPE_CONFIG,                 // Configure
   VC_AUDIO_MSG_TYPE_CONTROL,                 // control 
   VC_AUDIO_MSG_TYPE_OPEN,                 //  open
   VC_AUDIO_MSG_TYPE_CLOSE,                 // close/shutdown
   VC_AUDIO_MSG_TYPE_START,                 // start output (i.e. resume)
   VC_AUDIO_MSG_TYPE_STOP,                 // stop output (i.e. pause)
   VC_AUDIO_MSG_TYPE_WRITE,                 // write samples
   VC_AUDIO_MSG_TYPE_LATENCY,               // request latency in cycles
   VC_AUDIO_MSG_TYPE_MAX

} VC_AUDIO_MSG_TYPE;

static const char *vc_audio_msg_type_names[] = {
   "VC_AUDIO_MSG_TYPE_RESULT",
   "VC_AUDIO_MSG_TYPE_COMPLETE",
   "VC_AUDIO_MSG_TYPE_CONFIG",
   "VC_AUDIO_MSG_TYPE_CONTROL",
   "VC_AUDIO_MSG_TYPE_OPEN",
   "VC_AUDIO_MSG_TYPE_CLOSE",
   "VC_AUDIO_MSG_TYPE_START",
   "VC_AUDIO_MSG_TYPE_STOP",
   "VC_AUDIO_MSG_TYPE_WRITE",
   "VC_AUDIO_MSG_TYPE_MAX"
};

// configure the audio
typedef struct
{
   uint32_t channels;
   uint32_t samplerate;
   uint32_t bps;
   uint32_t channelmap;

} VC_AUDIO_CONFIG_T;

typedef struct
{
   uint32_t volume;
   uint32_t dest;

} VC_AUDIO_CONTROL_T;

// audio
typedef struct
{
   uint32_t dummy;

} VC_AUDIO_OPEN_T;

// audio
typedef struct
{
   uint32_t dummy;

} VC_AUDIO_CLOSE_T;
// audio
typedef struct
{
   uint32_t dummy;

} VC_AUDIO_START_T;
// audio
typedef struct
{
   uint32_t draining;

} VC_AUDIO_STOP_T;
// audio
typedef struct
{
   uint32_t dummy;

} VC_AUDIO_LATENCY_T;

// configure the write audio samples
typedef struct
{
   uint32_t count; // in bytes
   void *callback;
   void *cookie;
   uint16_t silence;
   uint16_t max_packet;
} VC_AUDIO_WRITE_T;

// Generic result for a request (VC->HOST)
typedef struct
{
   int32_t success;  // Success value

} VC_AUDIO_RESULT_T;

// Generic result for a request (VC->HOST)
typedef struct
{
   int32_t count;  // Success value
   void *callback;
   void *cookie;
} VC_AUDIO_COMPLETE_T;

// Message header for all messages in HOST->VC direction
typedef struct
{
   int32_t type;     // Message type (VC_AUDIO_MSG_TYPE)
   union
   {
	VC_AUDIO_CONFIG_T    config;
   VC_AUDIO_CONTROL_T   control;
	VC_AUDIO_OPEN_T  open;
	VC_AUDIO_CLOSE_T  close;
	VC_AUDIO_START_T  start;
	VC_AUDIO_STOP_T  stop;
	VC_AUDIO_WRITE_T  write;
	VC_AUDIO_LATENCY_T  latency;
	VC_AUDIO_RESULT_T result;
	VC_AUDIO_COMPLETE_T complete;
   } u;
} VC_AUDIO_MSG_T;


#endif // _VC_AUDIO_DEFS_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VC_VCHI_BUFMAN_H
#define VC_VCHI_BUFMAN_H

#include "interface/vctypes/vc_image_types.h"
#include "interface/vchi/vchi.h"
#ifdef __SYMBIAN32__
#include "interface/vmcs_host/vc_vchi_bufman_defs.h"
typedef uint32_t DISPMANX_RESOURCE_HANDLE_T;
namespace BufManX {
#else
#include "interface/vmcs_host/vc_dispmanx.h"
#include "interface/vmcs_host/vc_vchi_bufman_defs.h"
#endif

typedef void (*vc_bufman_callback_t) (void *next_cookie, void *next_cookie2, int32_t success);

VCHPRE_ void VCHPOST_ vc_vchi_bufman_init(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections);

typedef struct
{
   buf_frame_type_t type;
   int width, height, pitch;
   int bpp; // bits per pixel
   int size;
   void *pixels;
} BUFMANX_IMAGE_T;

#define BUFMAN_TRANSFORM_HFLIP     (1<<0)
#define BUFMAN_TRANSFORM_VFLIP     (1<<1)
#define BUFMAN_TRANSFORM_TRANSPOSE (1<<2)

typedef enum {
   BUFMAN_TRANSFORM_ROT0           = 0,
   BUFMAN_TRANSFORM_MIRROR_ROT0    = BUFMAN_TRANSFORM_HFLIP,
   BUFMAN_TRANSFORM_MIRROR_ROT180  = BUFMAN_TRANSFORM_VFLIP,
   BUFMAN_TRANSFORM_ROT180         = BUFMAN_TRANSFORM_HFLIP|BUFMAN_TRANSFORM_VFLIP,
   BUFMAN_TRANSFORM_MIRROR_ROT90   = BUFMAN_TRANSFORM_TRANSPOSE,
   BUFMAN_TRANSFORM_ROT270         = BUFMAN_TRANSFORM_TRANSPOSE|BUFMAN_TRANSFORM_HFLIP,
   BUFMAN_TRANSFORM_ROT90          = BUFMAN_TRANSFORM_TRANSPOSE|BUFMAN_TRANSFORM_VFLIP,
   BUFMAN_TRANSFORM_MIRROR_ROT270  = BUFMAN_TRANSFORM_TRANSPOSE|BUFMAN_TRANSFORM_HFLIP|BUFMAN_TRANSFORM_VFLIP,
} BUFMAN_TRANSFORM_T;


// we use an opaque type here as the internals shouldn't be used externally, but allocation of the size of the block is required by the caller.
#define BUFMANX_HANDLE_T_SIZE 1024
typedef struct {
   char opaque[BUFMANX_HANDLE_T_SIZE];
} BUFMANX_HANDLE_T;

VCHPRE_ int32_t VCHPOST_ vc_bufmanx_convert_init(void);
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_set_transform_buffer(void *pixels, int size);
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_allocate_image(BUFMANX_IMAGE_T *image);
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_release_image(BUFMANX_IMAGE_T *image);
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_get_default_pitch( BUFMANX_IMAGE_T *src );
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_get_default_size(BUFMANX_IMAGE_T *src);
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_push ( BUFMANX_HANDLE_T *h, const BUFMANX_IMAGE_T *src, DISPMANX_RESOURCE_HANDLE_T dst, const VC_RECT_T *src_rect, const VC_RECT_T *dest_rect, BUFMAN_TRANSFORM_T transform, vc_bufman_callback_t callback, void *cookie, void *cookie2 );
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_pull ( BUFMANX_HANDLE_T *h, BUFMANX_IMAGE_T *dst, const DISPMANX_RESOURCE_HANDLE_T src, const VC_RECT_T *src_rect, const VC_RECT_T *dest_rect, BUFMAN_TRANSFORM_T transform, vc_bufman_callback_t callback, void *cookie, void *cookie2 );
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_pull_blocking ( BUFMANX_HANDLE_T *h, BUFMANX_IMAGE_T *dst, const DISPMANX_RESOURCE_HANDLE_T src, const VC_RECT_T *src_rect, const VC_RECT_T *dest_rect, BUFMAN_TRANSFORM_T transform );
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_push_blocking ( BUFMANX_HANDLE_T *h, const BUFMANX_IMAGE_T *src, DISPMANX_RESOURCE_HANDLE_T dst, const VC_RECT_T *src_rect, const VC_RECT_T *dest_rect, BUFMAN_TRANSFORM_T transform );
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_pull_striped ( BUFMANX_HANDLE_T *xh, BUFMANX_IMAGE_T *dst, const DISPMANX_RESOURCE_HANDLE_T src, const VC_RECT_T *src_rect, const VC_RECT_T *dest_rect, BUFMAN_TRANSFORM_T transform, vc_bufman_callback_t callback, void *cookie, void *cookie2 );
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_pull_striped_blocking ( BUFMANX_HANDLE_T *xh, BUFMANX_IMAGE_T *dst, const DISPMANX_RESOURCE_HANDLE_T src, const VC_RECT_T *src_rect, const VC_RECT_T *dest_rect, BUFMAN_TRANSFORM_T transform );
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_push_striped ( BUFMANX_HANDLE_T *xh, const BUFMANX_IMAGE_T *src, DISPMANX_RESOURCE_HANDLE_T dst, const VC_RECT_T *src_rect, const VC_RECT_T *dest_rect, BUFMAN_TRANSFORM_T transform, vc_bufman_callback_t callback, void *cookie, void *cookie2 );
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_push_striped_blocking ( BUFMANX_HANDLE_T *xh, const BUFMANX_IMAGE_T *src, DISPMANX_RESOURCE_HANDLE_T dst, const VC_RECT_T *src_rect, const VC_RECT_T *dest_rect, BUFMAN_TRANSFORM_T transform );

VCHPRE_ void VCHPOST_ vc_bufmanx_push_multi ( BUFMANX_HANDLE_T *h, const BUFMANX_IMAGE_T *src, DISPMANX_RESOURCE_HANDLE_T dst, BUFMAN_TRANSFORM_T transform, vc_bufman_callback_t callback, void *cookie, void *cookie2 );
VCHPRE_ void VCHPOST_ vc_bufmanx_pull_multi ( BUFMANX_HANDLE_T *h, BUFMANX_IMAGE_T *dst, const DISPMANX_RESOURCE_HANDLE_T src, BUFMAN_TRANSFORM_T transform, vc_bufman_callback_t callback, void *cookie, void *cookie2 );
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_push_multi_blocking ( BUFMANX_HANDLE_T *h, const BUFMANX_IMAGE_T *src, DISPMANX_RESOURCE_HANDLE_T dst, BUFMAN_TRANSFORM_T transform );
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_pull_multi_blocking ( BUFMANX_HANDLE_T *h, BUFMANX_IMAGE_T *dst, const DISPMANX_RESOURCE_HANDLE_T src, BUFMAN_TRANSFORM_T transform );

// Allocate the specified number and type of buffers on the server side, for use with streams
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_allocate_buffers
   (uint32_t stream, uint32_t num_of_buffers,
      buf_frame_type_t type, uint32_t width, uint32_t height);

// Free buffers on the server which are associated with the specified stream
#define VC_BUFMANX_FREE_BUFFERS_ALL    0
VCHPRE_ int32_t VCHPOST_ vc_bufmanx_free_buffers(uint32_t stream, uint32_t num_of_buffers);

// Like vc_bufmanx_push_multi(), but specifies a stream, rather than a dispmanx resource handle,
// to push the data to.
VCHPRE_ void VCHPOST_ vc_bufmanx_push_multi_stream ( BUFMANX_HANDLE_T *xh, const BUFMANX_IMAGE_T *src, uint32_t stream, BUFMAN_TRANSFORM_T transform, vc_bufman_callback_t callback, void *cookie, void *cookie2 );

VCHPRE_ VC_IMAGE_TYPE_T VCHPOST_ vc_bufmanx_get_vc_image_type(buf_frame_type_t bm_type);

#ifdef __SYMBIAN32__
} // namespace BufManX
#endif

#endif /* VC_VCHI_BUFMAN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VC_VCHI_BUFMAN_DEFS_H
#define VC_VCHI_BUFMAN_DEFS_H

#ifdef __SYMBIAN32__
typedef uint32_t DISPMANX_RESOURCE_HANDLE_T;
namespace BufManX {
#else
#include "interface/vmcs_host/vc_dispmanx.h"
#endif

typedef enum {
   // Insert extra frame types here
   FRAME_HOST_IMAGE_BASE = 0x20000, // Base for host format images
   FRAME_HOST_IMAGE_EFormatYuv420P,
   FRAME_HOST_IMAGE_EFormatYuv422P,
   FRAME_HOST_IMAGE_EFormatYuv422LE,
   FRAME_HOST_IMAGE_EFormatRgb565,
   FRAME_HOST_IMAGE_EFormatRgb888,
   FRAME_HOST_IMAGE_EFormatRgbU32,
   FRAME_HOST_IMAGE_EFormatRgbA32,
   FRAME_HOST_IMAGE_EFormatRgbA32LE,
   FRAME_HOST_IMAGE_EFormatRgbU32LE,

   FRAME_FORCE_FIELD_WIDTH = 0xFFFFFFFF
} buf_frame_type_t;

typedef enum {
    //host to videocore
    VC_BUFMAN_CONVERT_UNUSED = 0,
    VC_BUFMAN_PULL_FRAME,
    VC_BUFMAN_PUSH_FRAME,
    VC_BUFMAN_MESSAGE_RESPONSE,
    VC_BUFMAN_SYNC,
    VC_BUFMAN_ALLOC_BUF,
    VC_BUFMAN_FREE_BUF,
    VC_BUFMAN_PULL_MULTI,
    VC_BUFMAN_PUSH_MULTI,
    VC_BUFMAN_PUSH_MULTI_STREAM,
    //vc to host
    VC_BUFMAN_FRAME_SENT_CALLBACK,
    VC_BUFMAN_FORCE_WIDTH = 0x7fffffff,
} buf_command_t;

/* A header used for all messages sent and received by bufman.
 */
typedef struct {
   buf_command_t command;
} BUF_MSG_HDR_T;

/* General remotely call this bufman operation commands */
typedef struct {
   uint32_t resource_handle;
   buf_frame_type_t type;
   int32_t size, width, height, pitch;
   VC_RECT_T src_rect;  // in 16.16 units
   VC_RECT_T dest_rect; // in 32.0 units
} BUF_MSG_REMOTE_FUNCTION_FRAME_T;

typedef struct {
   int32_t status;
   int32_t total_stripes;
   // normal stipe height and size
   int32_t stripe_height, stripe_size;
   // last stripe size (if height not a mulitple of stripe height, last stripe nay be smaller)
   int32_t last_stripe_height, last_stripe_size;
} BUF_MSG_RESPONSE_T;

typedef struct
{
   uint32_t stream;
   uint32_t num_of_buffers;
   buf_frame_type_t type;
   uint32_t width;
   uint32_t height;
} BUF_MSG_ALLOC_BUF_FRAME_T;

typedef struct
{
   uint32_t stream;
   uint32_t num_of_buffers;
} BUF_MSG_FREE_BUF_FRAME_T;

typedef struct {
   BUF_MSG_HDR_T hdr;
   union {
      BUF_MSG_REMOTE_FUNCTION_FRAME_T frame;
      BUF_MSG_RESPONSE_T message_response;
      BUF_MSG_ALLOC_BUF_FRAME_T alloc_buf_frame;
      BUF_MSG_FREE_BUF_FRAME_T free_buf_frame;
   } u;
} BUF_MSG_T;

enum {
   //host to videocore
   VC_BUFMAN_ERROR_NONE = 0,
   VC_BUFMAN_ERROR_BAD_GENERALLY = -1,
   VC_BUFMAN_ERROR_BAD_RESOURCE = -2,
   VC_BUFMAN_ERROR_BAD_TRANSFORM = -3,
   VC_BUFMAN_ERROR_BAD_RESIZE = -4,
   VC_BUFMAN_ERROR_BAD_HOST_FORMAT = -5,
   VC_BUFMAN_ERROR_BAD_VC_FORMAT = -6,
   VC_BUFMAN_ERROR_BAD_SIZE = -7,
};

#ifdef __SYMBIAN32__
} // namespace BufManX
#endif

#endif /* VC_VCHI_BUFMAN_DEFS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VC_VCHI_DISPMANX_H
#define VC_VCHI_DISPMANX_H

#include "interface/peer/vc_vchi_dispmanx_common.h"

#define VC_NUM_HOST_RESOURCES 64
#define DISPMANX_MSGFIFO_SIZE 1024
#define DISPMANX_CLIENT_NAME MAKE_FOURCC("DISP")
#define DISPMANX_NOTIFY_NAME MAKE_FOURCC("UPDH")

//Or with command to indicate we don't need a response
#define DISPMANX_NO_REPLY_MASK (1<<31)

typedef struct {
   char     description[32];
   uint32_t width;
   uint32_t height;
   uint32_t aspect_pixwidth;
   uint32_t aspect_pixheight;
   uint32_t fieldrate_num;
   uint32_t fieldrate_denom;
   uint32_t fields_per_frame;
   uint32_t transform;        
} GET_MODES_DATA_T;

typedef struct {
   int32_t  response;
   uint32_t width;
   uint32_t height;
   uint32_t transform;
   uint32_t input_format;
} GET_INFO_DATA_T;

//Attributes changes flag mask
#define ELEMENT_CHANGE_LAYER          (1<<0)
#define ELEMENT_CHANGE_OPACITY        (1<<1)
#define ELEMENT_CHANGE_DEST_RECT      (1<<2)
#define ELEMENT_CHANGE_SRC_RECT       (1<<3)
#define ELEMENT_CHANGE_MASK_RESOURCE  (1<<4)
#define ELEMENT_CHANGE_TRANSFORM      (1<<5)

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VC_VCHI_FILESERVICE_DEFS_H
#define VC_VCHI_FILESERVICE_DEFS_H

#include "interface/vchi/vchi.h"

/* Definitions (not used by API) */

/* structure used by both side to communicate */
#define FILESERV_MAX_BULK_SECTOR  128   //must be power of two

#define FILESERV_SECTOR_LENGTH  512

#define FILESERV_MAX_BULK (FILESERV_MAX_BULK_SECTOR*FILESERV_SECTOR_LENGTH)

#define FILESERV_4CC  MAKE_FOURCC("FSRV")

typedef enum FILESERV_EVENT_T
{
   FILESERV_BULK_RX = 0,
   FILESERV_BULK_TX,
   FILESERV_BULK_RX_0,
   FILESERV_BULK_RX_1
}FILESERV_EVENT_T;
//this following structure has to equal VCHI_MAX_MSG_SIZE
#define FILESERV_MAX_DATA	(VCHI_MAX_MSG_SIZE - 40) //(VCHI_MAX_MSG_SIZE - 24)

typedef struct{
	uint32_t xid;		    //4 // transaction's ID, used to match cmds with response
   uint32_t cmd_code;    //4
   uint32_t params[4];   //16
   char  data[FILESERV_MAX_DATA];
}FILESERV_MSG_T;

typedef enum
{
   FILESERV_RESP_OK,
   FILESERV_RESP_ERROR,
   FILESERV_BULK_READ,
   FILESERV_BULK_WRITE,

} FILESERV_RESP_CODE_T;


/* Protocol (not used by API) version 1.2 */



#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VC_VCHI_VCFILESYS_H_
#define VC_VCHI_VCFILESYS_H_

#include "vchost_config.h"
#include "vcfilesys_defs.h"
#include "vc_fileservice_defs.h"
#include "interface/vchi/vchi.h"

#ifndef _DIRENT_H  // This should really be in a dirent.h header to avoid conflicts
typedef struct DIR_tag DIR;
#endif // ifndef _DIRENT_H

typedef struct {   
   int64_t  st_size;    /* total size, in bytes  (off_t)*/      
   uint32_t st_modtime;   /* time of last modification (time_t)*/   
} FSTAT_T;


VCHPRE_ int VCHPOST_  vc_vchi_filesys_init (VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );

// Stop it to prevent the functions from trying to use it.
VCHPRE_ void VCHPOST_ vc_filesys_stop(void);

// Return the service number (-1 if not running).
VCHPRE_ int VCHPOST_ vc_filesys_inum(void);

// Low level file system functions equivalent to close(), lseek(), open(), read() and write()
VCHPRE_ int VCHPOST_ vc_filesys_close(int fildes);

VCHPRE_ long VCHPOST_ vc_filesys_lseek(int fildes, long offset, int whence);

VCHPRE_ int64_t VCHPOST_ vc_filesys_lseek64(int fildes, int64_t offset, int whence);

VCHPRE_ int VCHPOST_ vc_filesys_open(const char *path, int vc_oflag);

VCHPRE_ int VCHPOST_ vc_filesys_read(int fildes, void *buf, unsigned int nbyte);

VCHPRE_ int VCHPOST_ vc_filesys_write(int fildes, const void *buf, unsigned int nbyte);

VCHPRE_ int VCHPOST_ vc_filesys_mount(const char *device, const char *mountpoint, const char *options);
VCHPRE_ int VCHPOST_ vc_filesys_umount(const char *mountpoint);


// Ends a directory listing iteration
VCHPRE_ int VCHPOST_ vc_filesys_closedir(void *dhandle);

// Formats the drive that contains the given path
VCHPRE_ int VCHPOST_ vc_filesys_format(const char *path);

// Returns the amount of free space on the drive that contains the given path
VCHPRE_ int VCHPOST_ vc_filesys_freespace(const char *path);
VCHPRE_ int64_t VCHPOST_ vc_filesys_freespace64(const char *path);

// Gets the attributes of the named file
VCHPRE_ int VCHPOST_ vc_filesys_get_attr(const char *path, fattributes_t *attr);

// Get the file stat info struct for the specified file.
VCHPRE_ int VCHPOST_ vc_filesys_fstat(int filedes, FSTAT_T *buf);

// Creates a new directory
VCHPRE_ int VCHPOST_ vc_filesys_mkdir(const char *path);

// Starts a directory listing iteration
VCHPRE_ void * VCHPOST_ vc_filesys_opendir(const char *dirname);

// Directory listing iterator
VCHPRE_ struct dirent * VCHPOST_ vc_filesys_readdir_r(void *dhandle, struct dirent *result);

// Get the sum of the filesizes, and the number of files under the specified directory path.
VCHPRE_ int64_t VCHPOST_ vc_filesys_dirsize(const char *path, uint32_t *num_files, uint32_t *num_dirs);

// Deletes a file or (empty) directory
VCHPRE_ int VCHPOST_ vc_filesys_remove(const char *path);

// Renames a file, provided the new name is on the same file system as the old
VCHPRE_ int VCHPOST_ vc_filesys_rename(const char *oldfile, const char *newfile);

// Resets the co-processor side file system
VCHPRE_ int VCHPOST_ vc_filesys_reset(void);

// Sets the attributes of the named file
VCHPRE_ int VCHPOST_ vc_filesys_set_attr(const char *path, fattributes_t attr);

// Truncates a file at its current position
VCHPRE_ int VCHPOST_ vc_filesys_setend(int fildes);

// Returns the size of a file in bytes.
VCHPRE_ int VCHPOST_ vc_filesys_size(const char *path);

// Checks whether there are any messages in the incoming message fifo and responds to any such messages
VCHPRE_ int VCHPOST_ vc_filesys_poll_message_fifo(void);

// Return the event used to wait for reads.
VCHPRE_ void * VCHPOST_ vc_filesys_read_event(void);

// Sends a command for VC01 to reset the file system
VCHPRE_ void VCHPOST_ vc_filesys_sendreset(void);

// Return the error code of the last file system error
VCHPRE_ int VCHPOST_ vc_filesys_errno(void);

// Invalidates any cluster chains in the FAT that are not referenced in any directory structures
VCHPRE_ void VCHPOST_ vc_filesys_scandisk(const char *path);

// Checks whether or not a FAT filesystem is corrupt or not. If fix_errors is TRUE behaves exactly as vc_filesys_scandisk.
VCHPRE_ int VCHPOST_ vc_filesys_chkdsk(const char *path, int fix_errors);

// Return whether a disk is writeable or not.
VCHPRE_ int VCHPOST_ vc_filesys_diskwritable(const char *path);

// Return file system type of a disk.
VCHPRE_ int VCHPOST_ vc_filesys_fstype(const char *path);

// Returns the toatl amount of space on the drive that contains the given path
VCHPRE_ int VCHPOST_ vc_filesys_totalspace(const char *path);
VCHPRE_ int64_t VCHPOST_ vc_filesys_totalspace64(const char *path);

// Open disk for block level access
VCHPRE_ int VCHPOST_ vc_filesys_open_disk_raw(const char *path);

// Close disk from block level access mode
VCHPRE_ int VCHPOST_ vc_filesys_close_disk_raw(const char *path);

// Open disk for normal access
VCHPRE_ int VCHPOST_ vc_filesys_open_disk(const char *path);

// Close disk for normal access
VCHPRE_ int VCHPOST_ vc_filesys_close_disk(const char *path);

// Return number of sectors.
VCHPRE_ int VCHPOST_ vc_filesys_numsectors(const char *path);
VCHPRE_ int64_t VCHPOST_ vc_filesys_numsectors64(const char *path);

// Read/Write sectors
VCHPRE_ int VCHPOST_ vc_filesys_read_sectors(const char *path, uint32_t sector_num, char *sectors, uint32_t num_sectors, uint32_t *sectors_read);
VCHPRE_ int VCHPOST_ vc_filesys_write_sectors(const char *path, uint32_t sector_num, char *sectors, uint32_t num_sectors, uint32_t *sectors_written);

// Begin reading sectors from VideoCore.
VCHPRE_ int VCHPOST_ vc_filesys_read_sectors_begin(const char *path, uint32_t sector, uint32_t count);

// Read the next sector.
VCHPRE_ int VCHPOST_ vc_filesys_read_sector(char *buf);

// End streaming sectors.
VCHPRE_ int VCHPOST_ vc_filesys_read_sectors_end(uint32_t *sectors_read);

// Begin writing sectors from VideoCore.
VCHPRE_ int VCHPOST_ vc_filesys_write_sectors_begin(const char *path, uint32_t sector, uint32_t count);

// Write the next sector.
VCHPRE_ int VCHPOST_ vc_filesys_write_sector(const char *buf);

// End streaming sectors.
VCHPRE_ int VCHPOST_ vc_filesys_write_sectors_end(uint32_t *sectors_written);

#endif //VCFILESYS_H_

                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VC_VCHI_GENCMD_H
#define VC_VCHI_GENCMD_H
#include "vchost_config.h"
#include "interface/vchi/vchi.h"
#include "interface/vcos/vcos.h" //for VCHPRE_ abd VCHPOST_ macro's for func declaration

/* Initialise general command service. Returns it's interface number. This initialises
   the host side of the interface, it does not send anything to VideoCore. */

VCHPRE_ int VCHPOST_ vc_gencmd_init(void);

VCHPRE_ void VCHPOST_ vc_vchi_gencmd_init(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );


/* Stop the service from being used. */

VCHPRE_ void VCHPOST_ vc_gencmd_stop(void);

/* Functions to support videocore suspend/resume for cases where vc_gencmd_send expects a response to
 * ensure videocore is not shut down (done internally in vc_gencmd / vc_gencmd_until) */

VCHPRE_ int VCHPOST_ use_gencmd_service(void);
VCHPRE_ int VCHPOST_ release_gencmd_service(void);

/******************************************************************************
Send commands to VideoCore.
These all return 0 for success. They return VC_MSGFIFO_FIFO_FULL if there is
insufficient space for the whole message in the fifo, and none of the message is
sent.
******************************************************************************/

/*  send command to general command serivce */
VCHPRE_ int VCHPOST_ vc_gencmd_send( const char *format, ... );

/*  get resonse from general command serivce */
VCHPRE_ int VCHPOST_ vc_gencmd_read_response(char *response, int maxlen);

/* convenience function to send command and receive the response */
VCHPRE_ int VCHPOST_ vc_gencmd(char *response, int maxlen, const char *format, ...);

/******************************************************************************
Utilities to help interpret the responses.
******************************************************************************/

/* Read the value of a property=value type pair from a string (typically VideoCore's
   response to a general command). Return non-zero if found. */
VCHPRE_ int VCHPOST_ vc_gencmd_string_property(char *text, const char *property, char **value, int *length);

/* Read the numeric value of a property=number field from a response string. Return
   non-zero if found. */
VCHPRE_ int VCHPOST_ vc_gencmd_number_property(char *text, const char *property, int *number);

/* Send a command until the desired response is received, the error message is detected, or the timeout */
VCHPRE_ int VCHPOST_ vc_gencmd_until( char        *cmd,
                                      const char  *property,
                                      char        *value,
                                      const char  *error_string,
                                      int         timeout);


#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "vchost_config.h"
#include "vcfilesys_defs.h"
#include "vc_fileservice_defs.h"

#ifndef VCFILESYS_H_
#define VCFILESYS_H_

#ifndef FILESYS_DIR_DEFINED
#define  FILESYS_DIR_DEFINED
typedef struct DIR_tag DIR;
#endif

// Initialises the file system for use
VCHPRE_ int VCHPOST_ vc_filesys_init (void);

// Stop it to prevent the functions from trying to use it.
VCHPRE_ void VCHPOST_ vc_filesys_stop(void);

// Return the service number (-1 if not running).
VCHPRE_ int VCHPOST_ vc_filesys_inum(void);

// Low level file system functions equivalent to close(), lseek(), open(), read() and write()
VCHPRE_ int VCHPOST_ vc_filesys_close(int fildes);

VCHPRE_ long VCHPOST_ vc_filesys_lseek(int fildes, long offset, int whence);

VCHPRE_ int64_t VCHPOST_ vc_filesys_lseek64(int fildes, int64_t offset, int whence);

VCHPRE_ int VCHPOST_ vc_filesys_open(const char *path, int vc_oflag);

VCHPRE_ int VCHPOST_ vc_filesys_read(int fildes, void *buf, unsigned int nbyte);

VCHPRE_ int VCHPOST_ vc_filesys_write(int fildes, const void *buf, unsigned int nbyte);

VCHPRE_ int VCHPOST_ vc_filesys_mount(const char *device, const char *mountpoint, const char *options);
VCHPRE_ int VCHPOST_ vc_filesys_umount(const char *mountpoint);


// Ends a directory listing iteration
VCHPRE_ int VCHPOST_ vc_filesys_closedir(void *dhandle);

// Formats the drive that contains the given path
VCHPRE_ int VCHPOST_ vc_filesys_format(const char *path);

// Returns the amount of free space on the drive that contains the given path
VCHPRE_ int VCHPOST_ vc_filesys_freespace(const char *path);
VCHPRE_ int64_t VCHPOST_ vc_filesys_freespace64(const char *path);

// Gets the attributes of the named file
VCHPRE_ int VCHPOST_ vc_filesys_get_attr(const char *path, fattributes_t *attr);

// Creates a new directory
VCHPRE_ int VCHPOST_ vc_filesys_mkdir(const char *path);

// Starts a directory listing iteration
VCHPRE_ void * VCHPOST_ vc_filesys_opendir(const char *dirname);

// Directory listing iterator
VCHPRE_ struct dirent * VCHPOST_ vc_filesys_readdir_r(void *dhandle, struct dirent *result);

// Deletes a file or (empty) directory
VCHPRE_ int VCHPOST_ vc_filesys_remove(const char *path);

// Renames a file, provided the new name is on the same file system as the old
VCHPRE_ int VCHPOST_ vc_filesys_rename(const char *oldfile, const char *newfile);

// Resets the co-processor side file system
VCHPRE_ int VCHPOST_ vc_filesys_reset(void);

// Sets the attributes of the named file
VCHPRE_ int VCHPOST_ vc_filesys_set_attr(const char *path, fattributes_t attr);

// Truncates a file at its current position
VCHPRE_ int VCHPOST_ vc_filesys_setend(int fildes);

// Checks whether there are any messages in the incoming message fifo and responds to any such messages
VCHPRE_ int VCHPOST_ vc_filesys_poll_message_fifo(void);

// Return the event used to wait for reads.
VCHPRE_ void * VCHPOST_ vc_filesys_read_event(void);

// Sends a command for VC01 to reset the file system
VCHPRE_ void VCHPOST_ vc_filesys_sendreset(void);

// Return the error code of the last file system error
VCHPRE_ int VCHPOST_ vc_filesys_errno(void);

// Invalidates any cluster chains in the FAT that are not referenced in any directory structures
VCHPRE_ void VCHPOST_ vc_filesys_scandisk(const char *path);

// Checks whether or not a FAT filesystem is corrupt or not. If fix_errors is TRUE behaves exactly as vc_filesys_scandisk.
VCHPRE_ int VCHPOST_ vc_filesys_chkdsk(const char *path, int fix_errors);

// Return whether a disk is writeable or not.
VCHPRE_ int VCHPOST_ vc_filesys_diskwritable(const char *path);

// Return file system type of a disk.
VCHPRE_ int VCHPOST_ vc_filesys_fstype(const char *path);

// Returns the toatl amount of space on the drive that contains the given path
VCHPRE_ int VCHPOST_ vc_filesys_totalspace(const char *path);
VCHPRE_ int64_t VCHPOST_ vc_filesys_totalspace64(const char *path);

// Open disk for block level access
VCHPRE_ int VCHPOST_ vc_filesys_open_disk_raw(const char *path);

// Close disk from block level access mode
VCHPRE_ int VCHPOST_ vc_filesys_close_disk_raw(const char *path);

// Open disk for normal access
VCHPRE_ int VCHPOST_ vc_filesys_open_disk(const char *path);

// Close disk for normal access
VCHPRE_ int VCHPOST_ vc_filesys_close_disk(const char *path);

// Return number of sectors.
VCHPRE_ int VCHPOST_ vc_filesys_numsectors(const char *path);
VCHPRE_ int64_t VCHPOST_ vc_filesys_numsectors64(const char *path);

// Begin reading sectors from VideoCore.
VCHPRE_ int VCHPOST_ vc_filesys_read_sectors_begin(const char *path, uint32_t sector, uint32_t count);

// Read the next sector.
VCHPRE_ int VCHPOST_ vc_filesys_read_sector(char *buf);

// End streaming sectors.
VCHPRE_ int VCHPOST_ vc_filesys_read_sectors_end(uint32_t *sectors_read);

// Begin writing sectors from VideoCore.
VCHPRE_ int VCHPOST_ vc_filesys_write_sectors_begin(const char *path, uint32_t sector, uint32_t count);

// Write the next sector.
VCHPRE_ int VCHPOST_ vc_filesys_write_sector(const char *buf);

// End streaming sectors.
VCHPRE_ int VCHPOST_ vc_filesys_write_sectors_end(uint32_t *sectors_written);

#endif //VCFILESYS_H_

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// File service required types

#ifndef VCFILESYS_DEFS_H
#define VCFILESYS_DEFS_H

#include <time.h>  // for time_t

/* Define type fattributes_t and struct dirent for use in file system functions */

typedef int fattributes_t;
//enum {ATTR_RDONLY=1, ATTR_DIRENT=2};
#define ATTR_RDONLY     0x01        /* Read only file attributes */
#define ATTR_HIDDEN     0x02        /* Hidden file attributes */
#define ATTR_SYSTEM     0x04        /* System file attributes */
#define ATTR_VOLUME     0x08        /* Volume Label file attributes */
#define ATTR_DIRENT     0x10        /* Dirrectory file attributes */
#define ATTR_ARCHIVE     0x20        /* Archives file attributes */
#define ATTR_NORMAL     0x00        /* Normal file attributes */

#define D_NAME_MAX_SIZE 256

#ifndef _DIRENT_H  // This should really be in a dirent.h header to avoid conflicts
struct dirent
{
   char d_name[D_NAME_MAX_SIZE];
   unsigned int d_size;
   fattributes_t d_attrib;
   time_t d_creatime;
   time_t d_modtime;
};
#endif // ifndef _DIRENT_H

#define FS_MAX_PATH 256   // The maximum length of a pathname
/* Although not used in the API, this value is required on the host and
VC01 sides of the file system, even if there is no host side. Putting it in
vc_fileservice_defs.h is not appropriate as it would only be included if there
was a host side. */

/* File system error codes */
#define FS_BAD_USER  -7000     // The task isn't registered as a file system user

#define FS_BAD_FILE  -7001     // The path or filename or file descriptor is invalid
#define FS_BAD_PARM  -7002     // Invalid parameter given
#define FS_ACCESS    -7003     // File access conflict
#define FS_MAX_FILES -7004     // Maximum number of files already open
#define FS_NOEMPTY   -7005     // Directory isn't empty
#define FS_MAX_SIZE  -7006     // File is over the maximum file size

#define FS_NO_DISK   -7007     // No disk is present, or the disk has not been opened
#define FS_DISK_ERR  -7008     // There is a problem with the disk

#define FS_IO_ERROR  -7009     // Driver level error

#define FS_FMT_ERR   -7010     // Format error

#define FS_NO_BUFFER -7011     // Internal Nucleus File buffer not available
#define FS_NUF_INT   -7012     // Internal Nucleus File error

#define FS_UNSPEC_ERR -7013    // Unspecified error

#endif
                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// OpenMAX IL - ILCS specific types

#ifndef OMX_ILCS_h
#define OMX_ILCS_h

typedef struct OMX_PARAM_PORTSUMMARYTYPE {
   OMX_U32 nSize;            /**< Size of the structure in bytes */
   OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
   OMX_U32 nNumPorts;        /**< Total number of ports */
   OMX_U32 reqSet;           /**< Which set of ports is details below, portIndex[0] is port reqSet*32 */
   OMX_U32 portDir;          /**< Bitfield, 1 if output port, 0 if input port, max 256 ports */
   OMX_U32 portIndex[32];    /**< Port Indexes */
} OMX_PARAM_PORTSUMMARYTYPE;

typedef struct OMX_PARAM_MARKCOMPARISONTYPE {
   OMX_U32 nSize;            /**< Size of the structure in bytes */
   OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
   OMX_PTR mark;             /**< Pointer to be used for mark comparisons */
} OMX_PARAM_MARKCOMPARISONTYPE;

typedef struct OMX_PARAM_BRCMRECURSIONUNSAFETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_S32 (*pRecursionUnsafe)(OMX_PTR param);
   OMX_PTR param;
} OMX_PARAM_BRCMRECURSIONUNSAFETYPE;

typedef struct OMX_PARAM_TUNNELSTATUSTYPE {
   OMX_U32 nSize;            /**< Size of the structure in bytes */
   OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
   OMX_U32 nPortIndex;       /**< Port being queried */
   OMX_U32 nIndex;           /**< Query the nIndex'th port and fill in nPortIndex */
   OMX_BOOL bUseIndex;       /**< If OMX_TRUE read nIndex, otherwise read nPortIndex */
   OMX_PTR hTunneledComponent; /**< Component currently tunnelling with */
   OMX_U32 nTunneledPort;    /**< Port on tunnelled component */
} OMX_PARAM_TUNNELSTATUSTYPE;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// General command service API

#ifndef GENCMD_H
#define GENCMD_H

#include "vchost_config.h"
#include "interface/vchi/vchi.h"

VCHPRE_ void VCHPOST_ vc_vchi_gencmd_init(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );


/* Initialise general command service. Returns it's interface number. This initialises
   the host side of the interface, it does not send anything to VideoCore. */

VCHPRE_ int VCHPOST_ vc_gencmd_init(void);

/* Stop the service from being used. */

VCHPRE_ void VCHPOST_ vc_gencmd_stop(void);

/* Return the service number (-1 if not running). */
VCHPRE_ int VCHPOST_ vc_gencmd_inum(void);

/******************************************************************************
Send commands to VideoCore.
These all return 0 for success. They return VC_MSGFIFO_FIFO_FULL if there is
insufficient space for the whole message in the fifo, and none of the message is
sent.
******************************************************************************/

/*  send command to general command serivce */
VCHPRE_ int VCHPOST_ vc_gencmd_send( const char *format, ... );

/*  get resonse from general command serivce */
VCHPRE_ int VCHPOST_ vc_gencmd_read_response(char *response, int maxlen);

/* convenience function to send command and receive the response */
VCHPRE_ int VCHPOST_ vc_gencmd(char *response, int maxlen, const char *format, ...);

/* read part of a response from the general command service */
VCHPRE_ int VCHPOST_ vc_gencmd_read_response_partial(char *response, int nbytes);

/* if reading with vc_gencmd_read_response_partial end response reads with this */
VCHPRE_ int VCHPOST_ vc_gencmd_close_response_partial(void);

/* get state of reading of response */
VCHPRE_ int VCHPOST_ vc_gencmd_read_partial_state(void);

/******************************************************************************
Utilities to help interpret the responses.
******************************************************************************/

/* Read the value of a property=value type pair from a string (typically VideoCore's
   response to a general command). Return non-zero if found. */
VCHPRE_ int VCHPOST_ vc_gencmd_string_property(char *text, const char *property, char **value, int *length);

/* Read the numeric value of a property=number field from a response string. Return
   non-zero if found. */
VCHPRE_ int VCHPOST_ vc_gencmd_number_property(char *text, const char *property, int *number);

/* Send a command until the desired response is received, the error message is detected, or the timeout */
VCHPRE_ int VCHPOST_ vc_gencmd_until( char        *cmd,
                                      const char  *property,
                                      char        *value,
                                      const char  *error_string,
                                      int         timeout);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VCHOST_H
#define VCHOST_H

#include "vchost_config.h"
#include "vcfilesys_defs.h"
#include "interface/vcos/vcos.h" //for VCHPRE_ abd VCHPOST_ macro's for func declaration
#include "interface/vmcs_host/vc_fileservice_defs.h" // for VC_O_XXX file definitions
#include "interface/vchi/vchi.h"

#define UNUSED_PARAMETER(x) ((void)(x))/* macro to suppress not use warning */

/*---------------------------------------------------------------------------*/
/* Byte-swapping, dependent on host's orientation */
/*---------------------------------------------------------------------------*/

#ifndef VC_HOST_IS_BIG_ENDIAN
#define VC_HTOV32(val) (val)
#define VC_HTOV16(val) (val)
#define VC_VTOH32(val) (val)
#define VC_VTOH16(val) (val)
#else
static unsigned long  VC_HTOV32(unsigned long val)  {
   return ((val<<24) | ((val&0xff00)<<8) | ((val>>8)&0xff00) | ((val>>24)&0xff)); }
static unsigned short VC_HTOV16(unsigned short val) {
   return ((val<<8)|(val>>8)); }
static unsigned long  VC_VTOH32(unsigned long val)  {
   return ((val<<24) | ((val&0xff00)<<8) | ((val>>8)&0xff00) | ((val>>24)&0xff)); }
static unsigned short VC_VTOH16(unsigned short val) {
   return ((val<<8)|(val>>8)); }
#endif

/*---------------------------------------------------------------------------*/
/* Host port related functions */
/*---------------------------------------------------------------------------*/

/* Boot a bin file from flash into RAM. Returns the id of the application running */

VCHPRE_ int VCHPOST_ vc_host_boot(char *cmd_line, void *binimg, int nbytes, int bootloader);

/* Perform any platform specific initialisations. */

VCHPRE_ int VCHPOST_ vc_host_init(void);

/* Read a multiple of 16 bytes from VideoCore. host_addr has no particular alignment,
   but it is important that it transfers the data in 16-bit chunks if this is possible. */

VCHPRE_ int VCHPOST_ vc_host_read_consecutive(void *host_addr, uint32_t vc_addr, int nbytes, int channel);

#ifdef VC_HOST_IS_BIG_ENDIAN
// Reads from VideoCore with an implicit swap of each pair of bytes.
VCHPRE_ int VCHPOST_ vc_host_read_byteswapped(void *host_addr, uint32_t vc_addr, int nbytes, int channel);
#endif

/* Write a multiple of 16 bytes to VideoCore. host_addr has no particular alignment,
   but it is important that it transfers the data in 16-bit chunks if this is possible. */

VCHPRE_ int VCHPOST_ vc_host_write_consecutive(uint32_t vc_addr, void *host_addr, int nbytes, int channel);

#ifdef VC_HOST_IS_BIG_ENDIAN
// Write to VideoCore with an implicit swap of each pair of bytes.
VCHPRE_ int VCHPOST_ vc_host_write_byteswapped(uint32_t vc_addr, void *host_addr, int nbytes, int channel);
#endif

/* Send an interrupt to VideoCore. */

VCHPRE_ int VCHPOST_ vc_host_send_interrupt(int channel);

/* Wait for an interrupt from VideoCore. This can return immediately if applications
   are happy to busy-wait. */

VCHPRE_ int VCHPOST_ vc_host_wait_interrupt(void);

/* Tell the host to act on or ignore interrupts. */

VCHPRE_ void VCHPOST_ vc_host_interrupts(int on);

/* Function called when there is some kind of internal error. Breakpoints can be set on
   this for debugging. */

VCHPRE_ void VCHPOST_ vc_error(void);


/*---------------------------------------------------------------------------*/
/* Event (interrupt) related functions */
/*---------------------------------------------------------------------------*/

// Minimum number of event objects an implementation should support.
// Sufficient for 2 per 8 interfaces/services + 4 others
#define VC_EVENT_MAX_NUM  20

/* Create (and clear) an event.  Returns a pointer to the event object. */
VCHPRE_ void * VCHPOST_ vc_event_create(void);

/* Wait for an event to be set, blocking until it is set.
   Only one thread may be waiting at any one time.
   The event is automatically cleared on leaving this function. */
VCHPRE_ void VCHPOST_ vc_event_wait(void *sig);

/* Reads the state of an event (for polling systems) */
VCHPRE_ int VCHPOST_ vc_event_status(void *sig);

/* Forcibly clears any pending event */
VCHPRE_ void VCHPOST_ vc_event_clear(void *sig);

/* Sets an event - can be called from any thread */
VCHPRE_ void VCHPOST_ vc_event_set(void *sig);

/* Register the calling task to be notified of an event. */
VCHPRE_ void VCHPOST_ vc_event_register(void *ievent);

/* Set events to block, stopping polling mode. */
VCHPRE_ void VCHPOST_ vc_event_blocking(void);

/*---------------------------------------------------------------------------*/
/* Semaphore related functions */
/*---------------------------------------------------------------------------*/

// Minimum number of locks an implementation should support.

#define VC_LOCK_MAX_NUM 32

// Create a lock. Returns a pointer to the lock object. A lock is initially available
// just once.

VCHPRE_ void * VCHPOST_ vc_lock_create(void);

// Obtain a lock. Block until we have it. Locks are not re-entrant for the same thread.

VCHPRE_ void VCHPOST_ vc_lock_obtain(void *lock);

// Release a lock. Anyone can call this, even if they didn't obtain the lock first.

VCHPRE_ void VCHPOST_ vc_lock_release(void *lock);

/*---------------------------------------------------------------------------*/
/* File system related functions */
/*---------------------------------------------------------------------------*/

// Initialises the host dependent file system functions for use
VCHPRE_ void VCHPOST_ vc_hostfs_init(void);
VCHPRE_ void VCHPOST_ vc_hostfs_exit(void);

// Low level file system functions equivalent to close(), lseek(), open(), read() and write()
VCHPRE_ int VCHPOST_ vc_hostfs_close(int fildes);

VCHPRE_ long VCHPOST_ vc_hostfs_lseek(int fildes, long offset, int whence);

VCHPRE_ int64_t VCHPOST_ vc_hostfs_lseek64(int fildes, int64_t offset, int whence);

VCHPRE_ int VCHPOST_ vc_hostfs_open(const char *path, int vc_oflag);

VCHPRE_ int VCHPOST_ vc_hostfs_read(int fildes, void *buf, unsigned int nbyte);

VCHPRE_ int VCHPOST_ vc_hostfs_write(int fildes, const void *buf, unsigned int nbyte);

// Ends a directory listing iteration
VCHPRE_ int VCHPOST_ vc_hostfs_closedir(void *dhandle);

// Formats the drive that contains the given path
VCHPRE_ int VCHPOST_ vc_hostfs_format(const char *path);

// Returns the amount of free space on the drive that contains the given path
VCHPRE_ int VCHPOST_ vc_hostfs_freespace(const char *path);
VCHPRE_ int64_t VCHPOST_ vc_hostfs_freespace64(const char *path);

// Gets the attributes of the named file
VCHPRE_ int VCHPOST_ vc_hostfs_get_attr(const char *path, fattributes_t *attr);

// Creates a new directory
VCHPRE_ int VCHPOST_ vc_hostfs_mkdir(const char *path);

// Starts a directory listing iteration
VCHPRE_ void * VCHPOST_ vc_hostfs_opendir(const char *dirname);

// Directory listing iterator
VCHPRE_ struct dirent * VCHPOST_ vc_hostfs_readdir_r(void *dhandle, struct dirent *result);

// Deletes a file or (empty) directory
VCHPRE_ int VCHPOST_ vc_hostfs_remove(const char *path);

// Renames a file, provided the new name is on the same file system as the old
VCHPRE_ int VCHPOST_ vc_hostfs_rename(const char *oldfile, const char *newfile);

// Sets the attributes of the named file
VCHPRE_ int VCHPOST_ vc_hostfs_set_attr(const char *path, fattributes_t attr);

// Truncates a file at its current position
VCHPRE_ int VCHPOST_ vc_hostfs_setend(int fildes);

// Returns the total amount of space on the drive that contains the given path
VCHPRE_ int VCHPOST_ vc_hostfs_totalspace(const char *path);
VCHPRE_ int64_t VCHPOST_ vc_hostfs_totalspace64(const char *path);

// Return millisecond resolution system time, only used for differences
VCHPRE_ int VCHPOST_ vc_millitime(void);

// Invalidates any cluster chains in the FAT that are not referenced in any directory structures
VCHPRE_ void VCHPOST_ vc_hostfs_scandisk(const char *path);

// Checks whether or not a FAT filesystem is corrupt or not. If fix_errors is TRUE behaves exactly as vc_filesys_scandisk.
VCHPRE_ int VCHPOST_ vc_hostfs_chkdsk(const char *path, int fix_errors);

/*---------------------------------------------------------------------------*/
/* These functions only need to be implemented for the test system. */
/*---------------------------------------------------------------------------*/

// Open a log file.
VCHPRE_ void VCHPOST_ vc_log_open(const char *fname);

// Flush any pending data to the log file.
VCHPRE_ void VCHPOST_ vc_log_flush(void);

// Close the log file.
VCHPRE_ void VCHPOST_ vc_log_close(void);

// Log an error.
VCHPRE_ void VCHPOST_ vc_log_error(const char *format, ...);

// Log a warning.
VCHPRE_ void VCHPOST_ vc_log_warning(const char *format, ...);

// Write a message to the log.
VCHPRE_ void VCHPOST_ vc_log_msg(const char *format, ...);

// Flush the log.
VCHPRE_ void VCHPOST_ vc_log_flush(void);

// Return the total number of warnings and errors logged.
VCHPRE_ void VCHPOST_ vc_log_counts(int *warnings, int *errors);

// Wait for the specified number of microseconds. Used in test system only.
VCHPRE_ void VCHPOST_ vc_sleep(int ms);

// Get a time value in milliseconds. Used for measuring time differences
VCHPRE_ uint32_t VCHPOST_ vc_time(void);

// Check timing functions are available. Use in calibrating tests.
VCHPRE_ int VCHPOST_ calibrate_sleep (const char *data_dir);

/*---------------------------------------------------------------------------*/
/* Functions to allow dynamic service creation */
/*---------------------------------------------------------------------------*/

VCHPRE_ void VCHPOST_ vc_host_get_vchi_state(VCHI_INSTANCE_T *initialise_instance, VCHI_CONNECTION_T **connection);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VCHOST_CONFIG_H
#define VCHOST_CONFIG_H

#include "interface/vcos/vcos.h"

#if 0
/* Types that map onto VideoCore's types of the same name. */
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef short int16_t;
typedef long int32_t;
typedef unsigned long uint32_t;
typedef long long int64_t;
typedef unsigned long long uint64_t;

#ifndef vc_assert
#define vc_assert(cond) vcos_assert(cond)
#endif
#endif

/* On this platform we need to be able to release the host-side software resources. */
extern void vc_os_close(void);

#ifndef VCHPRE_
#define VCHPRE_     extern
#endif
#ifndef VCHPOST_
#define VCHPOST_
#endif
#ifndef VCCPRE_
#define VCCPRE_     
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VCHOSTREQ_H
#define VCHOSTREQ_H

#include "vc_hostreq_defs.h"
#include "vchost_config.h"
#include <time.h>

#include "interface/vchi/vchi.h"

VCHPRE_ void VCHPOST_ vc_vchi_hostreq_init(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );
//These are originally in vchostmem.c, we only provide them here for backward compatibility
//Host apps should be using bufman service to read/write host memory
VCHPRE_ int VCHPOST_ vchostreq_readmem( void* host_addr, void *vc_addr, int len );
VCHPRE_ int VCHPOST_ vchostreq_writemem( void* host_addr, void *vc_addr, int len, int channel );


VCHPRE_ int VCHPOST_ vc_hostreq_init (void);

VCHPRE_ void VCHPOST_ vc_hostreq_stop (void);

/* Supplies current key settings (preferably when there is a change) */
VCHPRE_ void VCHPOST_ vc_hostreq_keychange(keys_t keys);

/* Sets a user notify function to be called for the given notify event */
VCHPRE_ int32_t VCHPOST_ vc_hostreq_set_notify( const VC_HRNOTIFY_T notify_event, VC_HRNOTIFY_CALLBACK_T notifyfunc );

/* Sets a user callback to be called for the given hostreq event */
VCHPRE_ int32_t VCHPOST_ vc_hostreq_set_data_callback( const int cmd, VC_HRDATA_CALLBACK_T callback, void *userdata );

/*---------------------------------------------------------------------------*/
/*** The following require a host/application specific implementation ***/

/* Change key capture settings (might be ignored) */
VCHPRE_ void VCHPOST_ vc_hostreq_capturekeys(keys_t keymask);


/* Play a zero terminated sequence on the vibrator */
VCHPRE_ void VCHPOST_ vc_hostreq_vibratorplay(const int *sequence);


/* Stop the vibrator sequence immediately */
VCHPRE_ void VCHPOST_ vc_hostreq_vibratorstop(void);


/* Switch backlight on or off. */
VCHPRE_ void VCHPOST_ vc_hostreq_keylight(int state);


/* Set LEDs to specific brightness and colour levels. */
VCHPRE_ void VCHPOST_ vc_hostreq_setleds(led_t ledvalues);


/* Returns seconds since midnight (00:00.00) Jan 1 1970, local time. */
VCHPRE_ time_t VCHPOST_ vc_hostreq_time(void);


/* Send an event with the given eventcode to the host. */
VCHPRE_ void VCHPOST_ vc_hostreq_notify(int eventcode, int param);

/* Receive config data for subsequent hostreq_rendertext events. */
VCHPRE_ void VCHPOST_ vc_hostreq_configtext(char *config_data, int len);

/* Render a text string as a bitmap and then return it to VideoCore. */
VCHPRE_ void VCHPOST_ vc_hostreq_rendertext(char *text, int len);

/* Receive link information from a media file. */
VCHPRE_ void VCHPOST_ vc_hostreq_linkdata(char *link_data, int len);

/* Receive DMB FIC data */
VCHPRE_ void VCHPOST_ vc_hostreq_dmb_fic(char *data, int len);

/* Receive DMB PAD data */
VCHPRE_ void VCHPOST_ vc_hostreq_dmb_pad(char *data, int len);

/* Receive DMB DATA data */
VCHPRE_ void VCHPOST_ vc_hostreq_dmb_data(char *data, int len);

/* Request keypress info (from RTSP server). */
VCHPRE_ void VCHPOST_ vc_hostreq_keyin(void);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// OpenMAX IL Component Service definitions

#ifndef ILCS_H
#define ILCS_H

#include "interface/vmcs_host/khronos/IL/OMX_Component.h"
#include "interface/vmcs_host/vc_ilcs_defs.h"

struct ILCS_SERVICE_T;
typedef struct ILCS_SERVICE_T ILCS_SERVICE_T;

struct ILCS_COMMON_T;
typedef struct ILCS_COMMON_T ILCS_COMMON_T;

typedef void (*IL_FN_T)(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);

typedef struct {
   IL_FN_T *fns;
   ILCS_COMMON_T *(*ilcs_common_init)(ILCS_SERVICE_T *);
   void (*ilcs_common_deinit)(ILCS_COMMON_T *st);
   void (*ilcs_thread_init)(ILCS_COMMON_T *st);
   unsigned char *(*ilcs_mem_lock)(OMX_BUFFERHEADERTYPE *buffer);
   void (*ilcs_mem_unlock)(OMX_BUFFERHEADERTYPE *buffer);
} ILCS_CONFIG_T;

// initialise the VideoCore IL Component service
// returns pointer to state on success, NULL on failure
#ifdef USE_VCHIQ_ARM
VCHPRE_ ILCS_SERVICE_T VCHPOST_ *ilcs_init(VCHIQ_INSTANCE_T state, void **connection, ILCS_CONFIG_T *config, int use_memmgr);
#else
VCHPRE_ ILCS_SERVICE_T VCHPOST_ *ilcs_init(VCHIQ_STATE_T *state, void **connection, ILCS_CONFIG_T *config, int use_memmgr);
#endif

// deinitialises the IL Component service
VCHPRE_ void VCHPOST_ ilcs_deinit(ILCS_SERVICE_T *ilcs);

// returns 1 if the current thread is the ilcs thread, 0 otherwise
VCHPRE_ int VCHPOST_ ilcs_thread_current(void *param);

// returns pointer to shared state
VCHPRE_ ILCS_COMMON_T *ilcs_get_common(ILCS_SERVICE_T *ilcs);

VCHPRE_ int VCHPOST_ ilcs_execute_function(ILCS_SERVICE_T *ilcs, IL_FUNCTION_T func, void *data, int len, void *resp, int *rlen);
VCHPRE_ OMX_ERRORTYPE VCHPOST_ ilcs_pass_buffer(ILCS_SERVICE_T *ilcs, IL_FUNCTION_T func, void *reference, OMX_BUFFERHEADERTYPE *pBuffer);
VCHPRE_ OMX_BUFFERHEADERTYPE * VCHPOST_ ilcs_receive_buffer(ILCS_SERVICE_T *ilcs, void *call, int clen, OMX_COMPONENTTYPE **pComp);

// bulks are 16 bytes aligned, implicit in use of vchiq
#define ILCS_ALIGN   16

#define ILCS_ROUND_UP(x) ((((unsigned long)(x))+ILCS_ALIGN-1) & ~(ILCS_ALIGN-1))
#define ILCS_ROUND_DOWN(x) (((unsigned long)(x)) & ~(ILCS_ALIGN-1))
#define ILCS_ALIGNED(x) (((unsigned long)(x) & (ILCS_ALIGN-1)) == 0)


#ifdef _VIDEOCORE
#include "vcfw/logging/logging.h"

#ifdef ILCS_LOGGING

#define LOG_MSG ILCS_LOGGING
extern void ilcs_log_event_handler(OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_EVENTTYPE eEvent,
                                   OMX_U32 nData1,OMX_U32 nData2,OMX_PTR pEventData);

#else

#define LOG_MSG LOGGING_GENERAL
#define ilcs_log_event_handler(...)
extern void dummy_logging_message(int level, const char *format, ...);
#undef logging_message
#define logging_message if (1) {} else dummy_logging_message

#endif // ILCS_LOGGING
#endif // _VIDEOCORE

#endif // ILCS_H

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// OpenMAX IL Component Service common - Host side header

typedef struct {
   OMX_U32 port;
   IL_FUNCTION_T func;
   OMX_BOOL bEGL;
   OMX_U32 numBuffers;
   OMX_DIRTYPE dir;
} VC_PRIVATE_PORT_T;

struct _VC_PRIVATE_COMPONENT_T {
   OMX_COMPONENTTYPE *comp;
   void *reference;
   OMX_U32 numPorts;
   OMX_CALLBACKTYPE callbacks;
   OMX_PTR callback_state;
   VC_PRIVATE_PORT_T *port;
   struct _VC_PRIVATE_COMPONENT_T *next;
};
typedef struct _VC_PRIVATE_COMPONENT_T  VC_PRIVATE_COMPONENT_T;

struct ILCS_COMMON_T {
   VCOS_SEMAPHORE_T component_lock;
   VC_PRIVATE_COMPONENT_T *component_list;
   ILCS_SERVICE_T *ilcs;
};
   
VCHPRE_ void VCHPOST_ vcilcs_config(ILCS_CONFIG_T *config);

// functions that implement incoming functions calls
// from VideoCore components to host based components
VCHPRE_ void VCHPOST_ vcil_in_get_state(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_get_parameter(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_set_parameter(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_get_config(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_set_config(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_use_buffer(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_free_buffer(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_empty_this_buffer(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_fill_this_buffer(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_get_component_version(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_get_extension_index(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_in_component_role_enum(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);

// functions that implement callbacks from VideoCore
// components to the host core.
// The prefix is vcil_out since they implement part
// of the API that the host uses out to VideoCore
VCHPRE_ void VCHPOST_ vcil_out_event_handler(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_out_empty_buffer_done(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);
VCHPRE_ void VCHPOST_ vcil_out_fill_buffer_done(ILCS_COMMON_T *st, void *call, int clen, void *resp, int *rlen);

// functions used by the host IL core
VCHPRE_ OMX_ERRORTYPE VCHPOST_ vcil_out_get_debug_information(ILCS_COMMON_T *st, OMX_STRING debugInfo, OMX_S32 *pLen);
VCHPRE_ OMX_ERRORTYPE VCHPOST_ vcil_out_create_component(ILCS_COMMON_T *st, OMX_HANDLETYPE hComponent, OMX_STRING component_name);
VCHPRE_ OMX_ERRORTYPE VCHPOST_ vcil_out_component_name_enum(ILCS_COMMON_T *st, OMX_STRING cComponentName, OMX_U32 nNameLength, OMX_U32 nIndex);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** @file OMX_Audio.h - OpenMax IL version 1.1.2
 *  The structures needed by Audio components to exchange
 *  parameters and configuration data with the componenmilts.
 */

#ifndef OMX_Audio_h
#define OMX_Audio_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


/* Each OMX header must include all required header files to allow the
 *  header to compile without errors.  The includes below are required
 *  for this header file to compile successfully 
 */

#include "OMX_Core.h"

/** @defgroup midi MIDI
 * @ingroup audio
 */
 
/** @defgroup effects Audio effects
 * @ingroup audio
 */

/** @defgroup audio OpenMAX IL Audio Domain
 * Structures for OpenMAX IL Audio domain
 * @{
 */

/** Enumeration used to define the possible audio codings.  
 *  If "OMX_AUDIO_CodingUnused" is selected, the coding selection must 
 *  be done in a vendor specific way.  Since this is for an audio 
 *  processing element this enum is relevant.  However, for another 
 *  type of component other enums would be in this area.
 */
typedef enum OMX_AUDIO_CODINGTYPE {
    OMX_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
    OMX_AUDIO_CodingAutoDetect,  /**< auto detection of audio format */
    OMX_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
    OMX_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
    OMX_AUDIO_CodingAMR,         /**< Any variant of AMR encoded data */
    OMX_AUDIO_CodingGSMFR,       /**< Any variant of GSM fullrate (i.e. GSM610) */
    OMX_AUDIO_CodingGSMEFR,      /**< Any variant of GSM Enhanced Fullrate encoded data*/
    OMX_AUDIO_CodingGSMHR,       /**< Any variant of GSM Halfrate encoded data */
    OMX_AUDIO_CodingPDCFR,       /**< Any variant of PDC Fullrate encoded data */
    OMX_AUDIO_CodingPDCEFR,      /**< Any variant of PDC Enhanced Fullrate encoded data */
    OMX_AUDIO_CodingPDCHR,       /**< Any variant of PDC Halfrate encoded data */
    OMX_AUDIO_CodingTDMAFR,      /**< Any variant of TDMA Fullrate encoded data (TIA/EIA-136-420) */
    OMX_AUDIO_CodingTDMAEFR,     /**< Any variant of TDMA Enhanced Fullrate encoded data (TIA/EIA-136-410) */
    OMX_AUDIO_CodingQCELP8,      /**< Any variant of QCELP 8kbps encoded data */
    OMX_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
    OMX_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
    OMX_AUDIO_CodingSMV,         /**< Any variant of SMV encoded data */
    OMX_AUDIO_CodingG711,        /**< Any variant of G.711 encoded data */
    OMX_AUDIO_CodingG723,        /**< Any variant of G.723 dot 1 encoded data */
    OMX_AUDIO_CodingG726,        /**< Any variant of G.726 encoded data */
    OMX_AUDIO_CodingG729,        /**< Any variant of G.729 encoded data */
    OMX_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data */
    OMX_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
    OMX_AUDIO_CodingSBC,         /**< Any variant of SBC encoded data */
    OMX_AUDIO_CodingVORBIS,      /**< Any variant of VORBIS encoded data */
    OMX_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
    OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
    OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
    OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

#define OMX_AUDIO_CodingFLAC_Supported 1
    OMX_AUDIO_CodingFLAC,        /**< Any variant of FLAC */
#define OMX_AUDIO_CodingDDP_Supported 1
    OMX_AUDIO_CodingDDP,         /**< Any variant of Dolby Digital Plus */
#define OMX_AUDIO_CodingDTS_Supported 1
    OMX_AUDIO_CodingDTS,         /**< Any variant of DTS */
#define OMX_AUDIO_CodingWMAPRO_Supported 1
    OMX_AUDIO_CodingWMAPRO,      /**< Any variant of WMA Professional */
#define OMX_AUDIO_CodingATRAC3_Supported 1
    OMX_AUDIO_CodingATRAC3,      /**< Sony ATRAC-3 variants */
#define OMX_AUDIO_CodingATRACX_Supported 1
    OMX_AUDIO_CodingATRACX,      /**< Sony ATRAC-X variants */
#define OMX_AUDIO_CodingATRACAAL_Supported 1
    OMX_AUDIO_CodingATRACAAL,    /**< Sony ATRAC advanced-lossless variants  */

    OMX_AUDIO_CodingMax = 0x7FFFFFFF
} OMX_AUDIO_CODINGTYPE;


/** The PortDefinition structure is used to define all of the parameters 
 *  necessary for the compliant component to setup an input or an output audio 
 *  path.  If additional information is needed to define the parameters of the
 *  port (such as frequency), additional structures must be sent such as the
 *  OMX_AUDIO_PARAM_PCMMODETYPE structure to supply the extra parameters for the port.
 */
typedef struct OMX_AUDIO_PORTDEFINITIONTYPE {
    OMX_STRING cMIMEType;            /**< MIME type of data for the port */
    OMX_NATIVE_DEVICETYPE pNativeRender; /** < platform specific reference
                                               for an output device, 
                                               otherwise this field is 0 */
    OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is 
                                          supported by the OMX component */
    OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this 
                                          port (e.g. PCM, AMR, MP3, etc) */
} OMX_AUDIO_PORTDEFINITIONTYPE;


/**  Port format parameter.  This structure is used to enumerate
  *  the various data input/output format supported by the port.
  */
typedef struct OMX_AUDIO_PARAM_PORTFORMATTYPE {
    OMX_U32 nSize;                  /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
    OMX_U32 nPortIndex;             /**< Indicates which port to set */
    OMX_U32 nIndex;                 /**< Indicates the enumeration index for the format from 0x0 to N-1 */
    OMX_AUDIO_CODINGTYPE eEncoding; /**< Type of data expected for this port (e.g. PCM, AMR, MP3, etc) */
} OMX_AUDIO_PARAM_PORTFORMATTYPE;


/** PCM mode type  */ 
typedef enum OMX_AUDIO_PCMMODETYPE { 
    OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */ 
    OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */ 
    OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */ 
    OMX_AUDIO_PCMModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_PCMModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_PCMModeMax = 0x7FFFFFFF 
} OMX_AUDIO_PCMMODETYPE; 


typedef enum OMX_AUDIO_CHANNELTYPE {
    OMX_AUDIO_ChannelNone = 0x0,    /**< Unused or empty */
    OMX_AUDIO_ChannelLF   = 0x1,    /**< Left front */
    OMX_AUDIO_ChannelRF   = 0x2,    /**< Right front */
    OMX_AUDIO_ChannelCF   = 0x3,    /**< Center front */
    OMX_AUDIO_ChannelLS   = 0x4,    /**< Left surround */
    OMX_AUDIO_ChannelRS   = 0x5,    /**< Right surround */
    OMX_AUDIO_ChannelLFE  = 0x6,    /**< Low frequency effects */
    OMX_AUDIO_ChannelCS   = 0x7,    /**< Back surround */
    OMX_AUDIO_ChannelLR   = 0x8,    /**< Left rear. */
    OMX_AUDIO_ChannelRR   = 0x9,    /**< Right rear. */
    OMX_AUDIO_ChannelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_ChannelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_ChannelMax  = 0x7FFFFFFF 
} OMX_AUDIO_CHANNELTYPE;

#define OMX_AUDIO_MAXCHANNELS 16  /**< maximum number distinct audio channels that a buffer may contain */
#define OMX_MIN_PCMPAYLOAD_MSEC 5 /**< Minimum audio buffer payload size for uncompressed (PCM) audio */

/** PCM format description */ 
typedef struct OMX_AUDIO_PARAM_PCMMODETYPE { 
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
    OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */ 
    OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed or unsigned */ 
    OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */ 
    OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for 
                                           non-interleaved data (e.g. block data) */ 
    OMX_U32 nBitPerSample;            /**< Bit per sample */ 
    OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for 
                                           variable or unknown sampling rate. */ 
    OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */ 
    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMap[i] */

} OMX_AUDIO_PARAM_PCMMODETYPE; 


/** Audio channel mode.  This is used by both AAC and MP3, although the names are more appropriate
 * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC. 
 */
typedef enum OMX_AUDIO_CHANNELMODETYPE {
    OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those 
                                          two channels changes accordingly to each channel information */
    OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between 
                                           2 channels for higher compression gain */
    OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half 
                                           the bitrate of the overall bitrate */
    OMX_AUDIO_ChannelModeMono,        /**< Mono channel mode */
    OMX_AUDIO_ChannelModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_ChannelModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_ChannelModeMax = 0x7FFFFFFF
} OMX_AUDIO_CHANNELMODETYPE;


typedef enum OMX_AUDIO_MP3STREAMFORMATTYPE {
    OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0, /**< MP3 Audio MPEG 1 Layer 3 Stream format */
    OMX_AUDIO_MP3StreamFormatMP2Layer3,     /**< MP3 Audio MPEG 2 Layer 3 Stream format */
    OMX_AUDIO_MP3StreamFormatMP2_5Layer3,   /**< MP3 Audio MPEG2.5 Layer 3 Stream format */
    OMX_AUDIO_MP3StreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_MP3StreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_MP3StreamFormatMax = 0x7FFFFFFF
} OMX_AUDIO_MP3STREAMFORMATTYPE;

/** MP3 params */
typedef struct OMX_AUDIO_PARAM_MP3TYPE {
    OMX_U32 nSize;                 /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
    OMX_U32 nPortIndex;            /**< port that this structure applies to */
    OMX_U32 nChannels;             /**< Number of channels */
    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
                                        rate or unknown bit rates */
    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
                                        variable or unknown sampling rate. */
    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
                                        limit the audio signal. Use 0 to let encoder decide */
    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
    OMX_AUDIO_MP3STREAMFORMATTYPE eFormat;  /**< MP3 stream format */
} OMX_AUDIO_PARAM_MP3TYPE;

typedef enum OMX_AUDIO_DDPBITSTREAMID {
   OMX_AUDIO_DDPBitStreamIdAC3 = 8,
   OMX_AUDIO_DDPBitStreamIdEAC3 = 16,
   OMX_AUDIO_DDPBitStreamIdKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_AUDIO_DDPBitStreamIdVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_AUDIO_DDPBitStreamIdMax = 0x7FFFFFFF
} OMX_AUDIO_DDPBITSTREAMID;

typedef enum OMX_AUDIO_DDPBITSTREAMMODE {
   OMX_AUDIO_DDPBitStreamModeCM = 0,   /**< DDP any main audio service: complete main (CM) */
   OMX_AUDIO_DDPBitStreamModeME,       /**< DDP any main audio service: music and effects (ME) */
   OMX_AUDIO_DDPBitStreamModeVI,       /**< DDP any associated service: visually impaired (VI) */
   OMX_AUDIO_DDPBitStreamModeHI,       /**< DDP any associated service: hearing impaired (HI)  */
   OMX_AUDIO_DDPBitStreamModeD,        /**< DDP any associated service: dialogue (D)           */
   OMX_AUDIO_DDPBitStreamModeC,        /**< DDP any associated service: commentary (C)         */
   OMX_AUDIO_DDPBitStreamModeE,        /**< DDP any associated service: emergency (E)          */
   OMX_AUDIO_DDPBitStreamModeVO,       /**< DDP associated service: voice over (VO)            */
   OMX_AUDIO_DDPBitStreamModeK,        /**< DDP main audio service: karaoke                    */
   OMX_AUDIO_DDPBitStreamModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_AUDIO_DDPBitStreamModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_AUDIO_DDPBitStreamModeMax = 0x7FFFFFFF
} OMX_AUDIO_DDPBITSTREAMMODE;

typedef enum OMX_AUDIO_DDPDOLBYSURROUNDMODE {
   OMX_AUDIO_DDPDolbySurroundModeNotIndicated = 0,               /**< Not indicated */
   OMX_AUDIO_DDPDolbySurroundModeNotDolbySurround,               /**< Not Dolby Surround */
   OMX_AUDIO_DDPDolbySurroundModeDolbySurroundEncoded,           /**< Dolby Surround encoded */
   OMX_AUDIO_DDPDolbySurroundModeReserverd,                      /**< Reserved */
   OMX_AUDIO_DDPDolbySurroundModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_AUDIO_DDPDolbySurroundModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_AUDIO_DDPDolbySurroundModeMax = 0x7FFFFFFF
} OMX_AUDIO_DDPDOLBYSURROUNDMODE;

/** DDP params */
typedef struct OMX_AUDIO_PARAM_DDPTYPE {
    OMX_U32 nSize;                 /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
    OMX_U32 nPortIndex;            /**< port that this structure applies to */
    OMX_U32 nChannels;             /**< Number of channels */
    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
                                        rate or unknown bit rates */
    OMX_U32 nSampleRate;           /**< Sampling rate of the source data. Use 0 for
                                        variable or unknown sampling rate. */
    OMX_AUDIO_DDPBITSTREAMID eBitStreamId;
    OMX_AUDIO_DDPBITSTREAMMODE eBitStreamMode;
    OMX_AUDIO_DDPDOLBYSURROUNDMODE eDolbySurroundMode;
    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMapping[i] */    
} OMX_AUDIO_PARAM_DDPTYPE;

/** DTS params */
typedef struct OMX_AUDIO_PARAM_DTSTYPE {
    OMX_U32 nSize;                 /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
    OMX_U32 nPortIndex;            /**< port that this structure applies to */
    OMX_U32 nChannels;             /**< Number of channels */
    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
                                        rate or unknown bit rates */
    OMX_U32 nSampleRate;           /**< Sampling rate of the source data. Use 0 for
                                        variable or unknown sampling rate. */
    OMX_U32 nDtsType;              /** DTS type 1, 2, or 3. */
    OMX_U32 nFormat;               /** DTS stream is either big/little endian and 16/14 bit packing */
    OMX_U32 nDtsFrameSizeBytes;    /** DTS frame size in bytes */
    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMapping[i] */
} OMX_AUDIO_PARAM_DTSTYPE;

typedef enum OMX_AUDIO_AACSTREAMFORMATTYPE {
    OMX_AUDIO_AACStreamFormatMP2ADTS = 0, /**< AAC Audio Data Transport Stream 2 format */
    OMX_AUDIO_AACStreamFormatMP4ADTS,     /**< AAC Audio Data Transport Stream 4 format */
    OMX_AUDIO_AACStreamFormatMP4LOAS,     /**< AAC Low Overhead Audio Stream format */
    OMX_AUDIO_AACStreamFormatMP4LATM,     /**< AAC Low overhead Audio Transport Multiplex */
    OMX_AUDIO_AACStreamFormatADIF,        /**< AAC Audio Data Interchange Format */
    OMX_AUDIO_AACStreamFormatMP4FF,       /**< AAC inside MPEG-4/ISO File Format */
    OMX_AUDIO_AACStreamFormatRAW,         /**< AAC Raw Format */
    OMX_AUDIO_AACStreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_AACStreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_AACStreamFormatMax = 0x7FFFFFFF
} OMX_AUDIO_AACSTREAMFORMATTYPE;


/** AAC mode type.  Note that the term profile is used with the MPEG-2
 * standard and the term object type and profile is used with MPEG-4 */
typedef enum OMX_AUDIO_AACPROFILETYPE{
  OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
  OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
  OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
  OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
  OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
  OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
  OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
  OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
  OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
  OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
  OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
  OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
  OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
} OMX_AUDIO_AACPROFILETYPE;


/** AAC tool usage (for nAACtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
 * Required for encoder configuration and optional as decoder info output.
 * For MP3, OMX_AUDIO_CHANNELMODETYPE is sufficient. */
#define OMX_AUDIO_AACToolNone 0x00000000 /**< no AAC tools allowed (encoder config) or active (decoder info output) */
#define OMX_AUDIO_AACToolMS   0x00000001 /**< MS: Mid/side joint coding tool allowed or active */
#define OMX_AUDIO_AACToolIS   0x00000002 /**< IS: Intensity stereo tool allowed or active */
#define OMX_AUDIO_AACToolTNS  0x00000004 /**< TNS: Temporal Noise Shaping tool allowed or active */
#define OMX_AUDIO_AACToolPNS  0x00000008 /**< PNS: MPEG-4 Perceptual Noise substitution tool allowed or active */
#define OMX_AUDIO_AACToolLTP  0x00000010 /**< LTP: MPEG-4 Long Term Prediction tool allowed or active */
#define OMX_AUDIO_AACToolAll  0x7FFFFFFF /**< all AAC tools allowed or active (*/

/** MPEG-4 AAC error resilience (ER) tool usage (for nAACERtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
 * Required for ER encoder configuration and optional as decoder info output */
#define OMX_AUDIO_AACERNone  0x00000000  /**< no AAC ER tools allowed/used */
#define OMX_AUDIO_AACERVCB11 0x00000001  /**< VCB11: Virtual Code Books for AAC section data */
#define OMX_AUDIO_AACERRVLC  0x00000002  /**< RVLC: Reversible Variable Length Coding */
#define OMX_AUDIO_AACERHCR   0x00000004  /**< HCR: Huffman Codeword Reordering */
#define OMX_AUDIO_AACERAll   0x7FFFFFFF  /**< all AAC ER tools allowed/used */


/** AAC params */
typedef struct OMX_AUDIO_PARAM_AACPROFILETYPE {
    OMX_U32 nSize;                 /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
    OMX_U32 nPortIndex;            /**< Port that this structure applies to */
    OMX_U32 nChannels;             /**< Number of channels */
    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
                                        variable or unknown sampling rate. */
    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
                                        rate or unknown bit rates */
    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
                                        limit the audio signal. Use 0 to let encoder decide */
    OMX_U32 nFrameLength;          /**< Frame length (in audio samples per channel) of the codec.
                                        Can be 1024 or 960 (AAC-LC), 2048 (HE-AAC), 480 or 512 (AAC-LD).
                                        Use 0 to let encoder decide */
    OMX_U32 nAACtools;             /**< AAC tool usage */
    OMX_U32 nAACERtools;           /**< MPEG-4 AAC error resilience tool usage */
    OMX_AUDIO_AACPROFILETYPE eAACProfile;   /**< AAC profile enumeration */
    OMX_AUDIO_AACSTREAMFORMATTYPE eAACStreamFormat; /**< AAC stream format enumeration */
    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
} OMX_AUDIO_PARAM_AACPROFILETYPE;


/** VORBIS params */
typedef struct OMX_AUDIO_PARAM_VORBISTYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex;       /**< port that this structure applies to */
    OMX_U32 nChannels;        /**< Number of channels */
    OMX_U32 nBitRate;         /**< Bit rate of the encoded data data.  Use 0 for variable
                                   rate or unknown bit rates. Encoding is set to the
                                   bitrate closest to specified  value (in bps) */
    OMX_U32 nMinBitRate;      /**< Sets minimum bitrate (in bps). */
    OMX_U32 nMaxBitRate;      /**< Sets maximum bitrate (in bps). */

    OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
                                   variable or unknown sampling rate. */
    OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
                                   limit the audio signal. Use 0 to let encoder decide */
    OMX_S32 nQuality;		  /**< Sets encoding quality to n, between -1 (low) and 10 (high).
                                   In the default mode of operation, the quality level is 3.
                                   Normal quality range is 0 - 10. */
    OMX_BOOL bManaged;		  /**< Set  bitrate  management  mode. This turns off the
                                   normal VBR encoding, but allows hard or soft bitrate
                                   constraints to be enforced by the encoder. This mode can
                                   be slower, and may also be lower quality. It is
                                   primarily useful for streaming. */
    OMX_BOOL bDownmix;		  /**< Downmix input from stereo to mono (has no effect on 
                                   non-stereo streams). Useful for lower-bitrate encoding. */     
} OMX_AUDIO_PARAM_VORBISTYPE;


/** WMA Version */
typedef enum OMX_AUDIO_WMAFORMATTYPE {
  OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
  OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
  OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
  OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
  OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
  OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
  OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
} OMX_AUDIO_WMAFORMATTYPE;


/** WMA Profile */
typedef enum OMX_AUDIO_WMAPROFILETYPE {
  OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
  OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
  OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
  OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
  OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
  OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
  OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
} OMX_AUDIO_WMAPROFILETYPE;


/** WMA params */
typedef struct OMX_AUDIO_PARAM_WMATYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex;       /**< port that this structure applies to */
    OMX_U16 nChannels;        /**< Number of channels */
    OMX_U32 nBitRate;         /**< Bit rate of the input data.  Use 0 for variable
                                   rate or unknown bit rates */
    OMX_AUDIO_WMAFORMATTYPE eFormat; /**< Version of WMA stream / data */
	OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
    OMX_U32 nSamplingRate;    /**< Sampling rate of the source data */
    OMX_U16 nBlockAlign;      /**< is the block alignment, or block size, in bytes of the audio codec */
    OMX_U16 nEncodeOptions;   /**< WMA Type-specific data */
    OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
} OMX_AUDIO_PARAM_WMATYPE;

/** 
 * RealAudio format
 */
typedef enum OMX_AUDIO_RAFORMATTYPE {
    OMX_AUDIO_RAFormatUnused = 0, /**< Format unused or unknown */
    OMX_AUDIO_RA8,                /**< RealAudio 8 codec */
    OMX_AUDIO_RA9,                /**< RealAudio 9 codec */
    OMX_AUDIO_RA10_AAC,           /**< MPEG-4 AAC codec for bitrates of more than 128kbps */
    OMX_AUDIO_RA10_CODEC,         /**< RealAudio codec for bitrates less than 128 kbps */
    OMX_AUDIO_RA10_LOSSLESS,      /**< RealAudio Lossless */
    OMX_AUDIO_RA10_MULTICHANNEL,  /**< RealAudio Multichannel */
    OMX_AUDIO_RA10_VOICE,         /**< RealAudio Voice for bitrates below 15 kbps */
    OMX_AUDIO_RAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_RAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_VIDEO_RAFormatMax = 0x7FFFFFFF
} OMX_AUDIO_RAFORMATTYPE;

/** RA (Real Audio) params */ 
typedef struct OMX_AUDIO_PARAM_RATYPE { 
    OMX_U32 nSize;              /**< Size of this structure, in Bytes */ 
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
    OMX_U32 nPortIndex;         /**< Port that this structure applies to */ 
    OMX_U32 nChannels;          /**< Number of channels */ 
    OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */ 
    OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */ 
    OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */ 
    OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */ 
    OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */ 
    OMX_U32 nNumRegions;        /**< is the number of regions value */ 
    OMX_AUDIO_RAFORMATTYPE eFormat; /**< is the RealAudio audio format */
} OMX_AUDIO_PARAM_RATYPE; 


/** SBC Allocation Method Type */
typedef enum OMX_AUDIO_SBCALLOCMETHODTYPE {
  OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
  OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
  OMX_AUDIO_SBCAllocMethodKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
  OMX_AUDIO_SBCAllocMethodVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
  OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
} OMX_AUDIO_SBCALLOCMETHODTYPE;


/** SBC params */
typedef struct OMX_AUDIO_PARAM_SBCTYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_U32 nPortIndex;        /**< port that this structure applies to */
    OMX_U32 nChannels;         /**< Number of channels */
    OMX_U32 nBitRate;          /**< Bit rate of the input data.  Use 0 for variable
                                    rate or unknown bit rates */
    OMX_U32 nSampleRate;       /**< Sampling rate of the source data.  Use 0 for
                                    variable or unknown sampling rate. */
    OMX_U32 nBlocks;           /**< Number of blocks */
    OMX_U32 nSubbands;         /**< Number of subbands */
    OMX_U32 nBitPool;          /**< Bitpool value */
    OMX_BOOL bEnableBitrate;   /**< Use bitrate value instead of bitpool */
    OMX_AUDIO_CHANNELMODETYPE eChannelMode; /**< Channel mode enumeration */
    OMX_AUDIO_SBCALLOCMETHODTYPE eSBCAllocType;   /**< SBC Allocation method type */
} OMX_AUDIO_PARAM_SBCTYPE;


/** ADPCM stream format parameters */ 
typedef struct OMX_AUDIO_PARAM_ADPCMTYPE { 
    OMX_U32 nSize;              /**< size of the structure in bytes */ 
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
                                     necessarily the same as the number of channels 
                                     to be rendered. */ 
    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */ 
    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for 
                                    variable or unknown sampling rate. */ 
} OMX_AUDIO_PARAM_ADPCMTYPE; 


/** G723 rate */
typedef enum OMX_AUDIO_G723RATE {
    OMX_AUDIO_G723ModeUnused = 0,  /**< AMRNB Mode unused / unknown */
    OMX_AUDIO_G723ModeLow,         /**< 5300 bps */
    OMX_AUDIO_G723ModeHigh,        /**< 6300 bps */
    OMX_AUDIO_G723ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_G723ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_G723ModeMax = 0x7FFFFFFF
} OMX_AUDIO_G723RATE;


/** G723 - Sample rate must be 8 KHz */
typedef struct OMX_AUDIO_PARAM_G723TYPE { 
    OMX_U32 nSize;                /**< size of the structure in bytes */ 
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */ 
    OMX_U32 nPortIndex;           /**< port that this structure applies to */ 
    OMX_U32 nChannels;            /**< Number of channels in the data stream (not 
                                       necessarily the same as the number of channels 
                                       to be rendered. */ 
    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */ 
    OMX_AUDIO_G723RATE eBitRate;  /**< todo: Should this be moved to a config? */
    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */ 
    OMX_BOOL bPostFilter;         /**< Enable Post Filter */ 
} OMX_AUDIO_PARAM_G723TYPE; 


/** ITU G726 (ADPCM) rate */
typedef enum OMX_AUDIO_G726MODE {
    OMX_AUDIO_G726ModeUnused = 0,  /**< G726 Mode unused / unknown */
    OMX_AUDIO_G726Mode16,          /**< 16 kbps */
    OMX_AUDIO_G726Mode24,          /**< 24 kbps */
    OMX_AUDIO_G726Mode32,          /**< 32 kbps, most common rate, also G721 */
    OMX_AUDIO_G726Mode40,          /**< 40 kbps */
    OMX_AUDIO_G726ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_G726ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_G726ModeMax = 0x7FFFFFFF
} OMX_AUDIO_G726MODE;


/** G.726 stream format parameters - must be at 8KHz */ 
typedef struct OMX_AUDIO_PARAM_G726TYPE { 
    OMX_U32 nSize;              /**< size of the structure in bytes */ 
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
                                     necessarily the same as the number of channels 
                                     to be rendered. */ 
     OMX_AUDIO_G726MODE eG726Mode;
} OMX_AUDIO_PARAM_G726TYPE; 


/** G729 coder type */
typedef enum OMX_AUDIO_G729TYPE {
    OMX_AUDIO_G729 = 0,           /**< ITU G.729  encoded data */
    OMX_AUDIO_G729A,              /**< ITU G.729 annex A  encoded data */
    OMX_AUDIO_G729B,              /**< ITU G.729 with annex B encoded data */
    OMX_AUDIO_G729AB,             /**< ITU G.729 annexes A and B encoded data */
    OMX_AUDIO_G729KhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_G729VendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_G729Max = 0x7FFFFFFF
} OMX_AUDIO_G729TYPE;


/** G729 stream format parameters - fixed 6KHz sample rate */
typedef struct OMX_AUDIO_PARAM_G729TYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex;       /**< port that this structure applies to */
    OMX_U32 nChannels;        /**< Number of channels in the data stream (not
                                   necessarily the same as the number of channels
                                   to be rendered. */
    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
    OMX_AUDIO_G729TYPE eBitType;
} OMX_AUDIO_PARAM_G729TYPE;


/** AMR Frame format */ 
typedef enum OMX_AUDIO_AMRFRAMEFORMATTYPE { 
    OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance 
                                                   (Standard) Format */ 
    OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface 
                                                   Format 1 */ 
    OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface 
                                                   Format 2*/ 
    OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage 
                                                   Format */ 
    OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time 
                                                   Transport Protocol Payload Format */ 
    OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */ 
    OMX_AUDIO_AMRFrameFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_AMRFrameFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF 
} OMX_AUDIO_AMRFRAMEFORMATTYPE; 


/** AMR band mode */
typedef enum OMX_AUDIO_AMRBANDMODETYPE {
    OMX_AUDIO_AMRBandModeUnused = 0,          /**< AMRNB Mode unused / unknown */
    OMX_AUDIO_AMRBandModeNB0,                 /**< AMRNB Mode 0 =  4750 bps */
    OMX_AUDIO_AMRBandModeNB1,                 /**< AMRNB Mode 1 =  5150 bps */
    OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */ 
    OMX_AUDIO_AMRBandModeNB3,                 /**< AMRNB Mode 3 =  6700 bps */
    OMX_AUDIO_AMRBandModeNB4,                 /**< AMRNB Mode 4 =  7400 bps */
    OMX_AUDIO_AMRBandModeNB5,                 /**< AMRNB Mode 5 =  7950 bps */
    OMX_AUDIO_AMRBandModeNB6,                 /**< AMRNB Mode 6 = 10200 bps */
    OMX_AUDIO_AMRBandModeNB7,                 /**< AMRNB Mode 7 = 12200 bps */
    OMX_AUDIO_AMRBandModeWB0,                 /**< AMRWB Mode 0 =  6600 bps */
    OMX_AUDIO_AMRBandModeWB1,                 /**< AMRWB Mode 1 =  8850 bps */
    OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */ 
    OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */ 
    OMX_AUDIO_AMRBandModeWB4,                 /**< AMRWB Mode 4 = 15850 bps */
    OMX_AUDIO_AMRBandModeWB5,                 /**< AMRWB Mode 5 = 18250 bps */
    OMX_AUDIO_AMRBandModeWB6,                 /**< AMRWB Mode 6 = 19850 bps */
    OMX_AUDIO_AMRBandModeWB7,                 /**< AMRWB Mode 7 = 23050 bps */
    OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */      
    OMX_AUDIO_AMRBandModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_AMRBandModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_AMRBandModeMax = 0x7FFFFFFF
} OMX_AUDIO_AMRBANDMODETYPE;
     

/** AMR Discontinuous Transmission mode */ 
typedef enum OMX_AUDIO_AMRDTXMODETYPE { 
    OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */ 
    OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using 
                                             Voice Activity Detector 1 (VAD1) is enabled */ 
    OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using 
                                             Voice Activity Detector 2 (VAD2) is enabled */       
    OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between 
                                             Off, VAD1 or VAD2 modes */ 

    OMX_AUDIO_AMRDTXasEFR,             /**< DTX as EFR instead of AMR standard (3GPP 26.101, frame type =8,9,10) */

    OMX_AUDIO_AMRDTXModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_AMRDTXModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF 
} OMX_AUDIO_AMRDTXMODETYPE; 
 

/** AMR params */
typedef struct OMX_AUDIO_PARAM_AMRTYPE {
    OMX_U32 nSize;                          /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;               /**< OMX specification version information */
    OMX_U32 nPortIndex;                     /**< port that this structure applies to */
    OMX_U32 nChannels;                      /**< Number of channels */
    OMX_U32 nBitRate;                       /**< Bit rate read only field */
    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */ 
    OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;  /**< AMR DTX Mode enumeration */
    OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat; /**< AMR frame format enumeration */
} OMX_AUDIO_PARAM_AMRTYPE;


/** GSM_FR (ETSI 06.10, 3GPP 46.010) stream format parameters */
typedef struct OMX_AUDIO_PARAM_GSMFRTYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex;       /**< port that this structure applies to */
    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
} OMX_AUDIO_PARAM_GSMFRTYPE;


/** GSM-HR (ETSI 06.20, 3GPP 46.020) stream format parameters */
typedef struct OMX_AUDIO_PARAM_GSMHRTYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex;       /**< port that this structure applies to */
    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
} OMX_AUDIO_PARAM_GSMHRTYPE;


/** GSM-EFR (ETSI 06.60, 3GPP 46.060) stream format parameters */
typedef struct OMX_AUDIO_PARAM_GSMEFRTYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex;       /**< port that this structure applies to */
    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
} OMX_AUDIO_PARAM_GSMEFRTYPE;


/** TDMA FR (TIA/EIA-136-420, VSELP 7.95kbps coder) stream format parameters */
typedef struct OMX_AUDIO_PARAM_TDMAFRTYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
                                       necessarily the same as the number of channels
                                       to be rendered. */
    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
} OMX_AUDIO_PARAM_TDMAFRTYPE;


/** TDMA EFR (TIA/EIA-136-410, ACELP 7.4kbps coder) stream format parameters */
typedef struct OMX_AUDIO_PARAM_TDMAEFRTYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
                                       necessarily the same as the number of channels
                                       to be rendered. */
    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
} OMX_AUDIO_PARAM_TDMAEFRTYPE;


/** PDC FR ( RCR-27, VSELP 6.7kbps coder) stream format parameters */
typedef struct OMX_AUDIO_PARAM_PDCFRTYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
                                       necessarily the same as the number of channels
                                       to be rendered. */
    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
} OMX_AUDIO_PARAM_PDCFRTYPE;


/** PDC EFR ( RCR-27, ACELP 6.7kbps coder) stream format parameters */
typedef struct OMX_AUDIO_PARAM_PDCEFRTYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
                                       necessarily the same as the number of channels
                                       to be rendered. */
    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
} OMX_AUDIO_PARAM_PDCEFRTYPE;

/** PDC HR ( RCR-27, PSI-CELP 3.45kbps coder) stream format parameters */
typedef struct OMX_AUDIO_PARAM_PDCHRTYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
                                       necessarily the same as the number of channels
                                       to be rendered. */
    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
} OMX_AUDIO_PARAM_PDCHRTYPE;


/** CDMA Rate types */
typedef enum OMX_AUDIO_CDMARATETYPE {
    OMX_AUDIO_CDMARateBlank = 0,          /**< CDMA encoded frame is blank */
    OMX_AUDIO_CDMARateFull,               /**< CDMA encoded frame in full rate */
    OMX_AUDIO_CDMARateHalf,               /**< CDMA encoded frame in half rate */
    OMX_AUDIO_CDMARateQuarter,            /**< CDMA encoded frame in quarter rate */
    OMX_AUDIO_CDMARateEighth,             /**< CDMA encoded frame in eighth rate (DTX)*/
    OMX_AUDIO_CDMARateErasure,            /**< CDMA erasure frame */
    OMX_AUDIO_CDMARateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_CDMARateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_CDMARateMax = 0x7FFFFFFF
} OMX_AUDIO_CDMARATETYPE;


/** QCELP8 (TIA/EIA-96, up to 8kbps coder) stream format parameters */
typedef struct OMX_AUDIO_PARAM_QCELP8TYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
                                       necessarily the same as the number of channels
                                       to be rendered. */
    OMX_U32 nBitRate;             /**< Bit rate of the input data.  Use 0 for variable
                                       rate or unknown bit rates */
    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
} OMX_AUDIO_PARAM_QCELP8TYPE;


/** QCELP13 ( CDMA, EIA/TIA-733, 13.3kbps coder) stream format parameters */
typedef struct OMX_AUDIO_PARAM_QCELP13TYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
                                       necessarily the same as the number of channels
                                       to be rendered. */
    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
} OMX_AUDIO_PARAM_QCELP13TYPE;


/** EVRC ( CDMA, EIA/TIA-127, RCELP up to 8.55kbps coder) stream format parameters */
typedef struct OMX_AUDIO_PARAM_EVRCTYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
                                       necessarily the same as the number of channels
                                       to be rendered. */
    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< actual Frame rate */
    OMX_BOOL bRATE_REDUCon;       /**< RATE_REDUCtion is requested for this frame */
    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter */
    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter */
} OMX_AUDIO_PARAM_EVRCTYPE;


/** SMV ( up to 8.55kbps coder) stream format parameters */
typedef struct OMX_AUDIO_PARAM_SMVTYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
                                       necessarily the same as the number of channels
                                       to be rendered. */
    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
    OMX_BOOL bRATE_REDUCon;           /**< RATE_REDUCtion is requested for this frame */
    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 ??*/
    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 ??*/
    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter ??*/
    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter ??*/
} OMX_AUDIO_PARAM_SMVTYPE;


/** MIDI Format 
 * @ingroup midi
 */
typedef enum OMX_AUDIO_MIDIFORMATTYPE
{
    OMX_AUDIO_MIDIFormatUnknown = 0, /**< MIDI Format unknown or don't care */
    OMX_AUDIO_MIDIFormatSMF0,        /**< Standard MIDI File Type 0 */
    OMX_AUDIO_MIDIFormatSMF1,        /**< Standard MIDI File Type 1 */
    OMX_AUDIO_MIDIFormatSMF2,        /**< Standard MIDI File Type 2 */
    OMX_AUDIO_MIDIFormatSPMIDI,      /**< SP-MIDI */
    OMX_AUDIO_MIDIFormatXMF0,        /**< eXtensible Music Format type 0 */
    OMX_AUDIO_MIDIFormatXMF1,        /**< eXtensible Music Format type 1 */
    OMX_AUDIO_MIDIFormatMobileXMF,   /**< Mobile XMF (eXtensible Music Format type 2) */
    OMX_AUDIO_MIDIFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_MIDIFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_MIDIFormatMax = 0x7FFFFFFF
} OMX_AUDIO_MIDIFORMATTYPE;


/** MIDI params 
 * @ingroup midi
 */
typedef struct OMX_AUDIO_PARAM_MIDITYPE {
    OMX_U32 nSize;                 /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
    OMX_U32 nPortIndex;            /**< port that this structure applies to */
    OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire 
                                        MIDI file passed in, otherwise if 0x0, the MIDI data 
                                        is merged and streamed (instead of passed as an 
                                        entire MIDI file) */
    OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
                                        voices. A value of zero indicates that the default 
                                        polyphony of the device is used  */                                    
    OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound 
                                        bank at initialization */
    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */                                                                           
} OMX_AUDIO_PARAM_MIDITYPE;


/** Type of the MIDI sound bank 
 * @ingroup midi
 */
typedef enum OMX_AUDIO_MIDISOUNDBANKTYPE {
    OMX_AUDIO_MIDISoundBankUnused = 0,           /**< unused/unknown soundbank type */
    OMX_AUDIO_MIDISoundBankDLS1,                 /**< DLS version 1 */
    OMX_AUDIO_MIDISoundBankDLS2,                 /**< DLS version 2 */
    OMX_AUDIO_MIDISoundBankMobileDLSBase,        /**< Mobile DLS, using the base functionality */
    OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions, /**< Mobile DLS, using the specification-defined optional feature set */
    OMX_AUDIO_MIDISoundBankKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_MIDISoundBankVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_MIDISoundBankMax = 0x7FFFFFFF
} OMX_AUDIO_MIDISOUNDBANKTYPE;


/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank 
 * @ingroup midi
 */
typedef enum OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE {
   OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
   OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
   OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
   OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
   OMX_AUDIO_MIDISoundBankLayoutKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_AUDIO_MIDISoundBankLayoutVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
} OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE;


/** MIDI params to load/unload user soundbank 
 * @ingroup midi
 */
typedef struct OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex;       /**< port that this structure applies to */
    OMX_U32 nDLSIndex;        /**< DLS file index to be loaded */
    OMX_U32 nDLSSize;         /**< Size in bytes */
    OMX_PTR pDLSData;         /**< Pointer to DLS file data */
    OMX_AUDIO_MIDISOUNDBANKTYPE eMidiSoundBank;   /**< Midi sound bank type enumeration */
    OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE eMidiSoundBankLayout; /**< Midi sound bank layout enumeration */
} OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE;


/** Structure for Live MIDI events and MIP messages. 
 * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.) 
 * @ingroup midi
 */
typedef struct OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
    OMX_U32 nMidiEventSize;   /**< Size of immediate MIDI events or MIP message in bytes  */
    OMX_U8 nMidiEvents[1];    /**< MIDI event array to be rendered immediately, or an
                                   array for the MIP message buffer, where the size is 
                                   indicated by nMidiEventSize */
} OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE;


/** MIDI sound bank/ program pair in a given channel 
 * @ingroup midi
 */
typedef struct OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
    OMX_U32 nChannel;           /**< Valid channel values range from 1 to 16 */
    OMX_U16 nIDProgram;         /**< Valid program ID range is 1 to 128 */
    OMX_U16 nIDSoundBank;       /**< Sound bank ID */
    OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks 
                                     by index if multiple banks are present */
} OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE;


/** MIDI control 
 * @ingroup midi
 */
typedef struct OMX_AUDIO_CONFIG_MIDICONTROLTYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10 
                                       format based on JAVA MMAPI (JSR-135) requirement */
    OMX_BU32 sPlayBackRate;       /**< Relative playback rate, stored as Q14.17 fixed-point
                                       number based on JSR-135 requirement */
    OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10 
                                       fixed-point number based on JSR-135 requirement */
    OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
                                       voices. A value of zero indicates that the default 
                                       polyphony of the device is used  */
    OMX_U32 nNumRepeat;           /**< Number of times to repeat playback */
    OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback 
                                       will stop automatically.  Set to zero if not used */
    OMX_U16 nChannelMuteMask;     /**< 16 bit mask for channel mute status */
    OMX_U16 nChannelSoloMask;     /**< 16 bit mask for channel solo status */
    OMX_U32 nTrack0031MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 0-31 */
    OMX_U32 nTrack3263MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 32-63 */
    OMX_U32 nTrack0031SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 0-31 */
    OMX_U32 nTrack3263SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 32-63 */

} OMX_AUDIO_CONFIG_MIDICONTROLTYPE;


/** MIDI Playback States 
 * @ingroup midi
 */
typedef enum OMX_AUDIO_MIDIPLAYBACKSTATETYPE {
  OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to 
  													other defined states */
  OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open. 
                                                    The MIDI engine is currently processing 
                                                    MIDI events. */
  OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being 
                                                    primed. The MIDI engine is currently 
                                                    processing MIDI events. */
  OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but 
                                                    not playing. The MIDI engine is currently
                                                    processing MIDI events. The transition to
                                                    this state is only possible from the 
                                                    OMX_AUDIO_MIDIPlayBackStatePlaying state,
                                                    when the 'playback head' reaches the end
                                                    of media data or the playback stops due
                                                    to stop time set.*/
  OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
                                                    playing. The MIDI engine is currently
                                                    processing MIDI events.*/
  OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
                                                    resource constraints */
  OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
                                                    SP-MIDI content constraints, there is
                                                    no audible MIDI content during playback
                                                    currently. The situation may change if
                                                    resources are freed later.*/
  OMX_AUDIO_MIDIPlayBackStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
  OMX_AUDIO_MIDIPlayBackStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
  OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
} OMX_AUDIO_MIDIPLAYBACKSTATETYPE;


/** MIDI status 
 * @ingroup midi
 */
typedef struct OMX_AUDIO_CONFIG_MIDISTATUSTYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPortIndex;         /**< port that this structure applies to */
    OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field. 
                                     NOTE: May not return a meaningful value until the entire 
                                     file is parsed and buffered.  */
    OMX_U32 nDuration;          /**< The length of the currently open MIDI resource 
                                     in milliseconds. NOTE: May not return a meaningful value 
                                     until the entire file is parsed and buffered.  */  
    OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played 
                                     in milliseconds */
    OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful 
                                     value until the entire file is parsed and buffered. */
    OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently 
                                     open MIDI resource. NOTE: May not return a meaningful value 
                                     until the entire file is parsed and buffered.  */
    OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing 
                                     MIDI resource. NOTE: May not return a meaningful value until 
                                     the entire file is parsed and buffered. */
    OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;  /**< MIDI playback state enumeration, read only field */
} OMX_AUDIO_CONFIG_MIDISTATUSTYPE;


/** MIDI Meta Event structure one per Meta Event.
 *  MIDI Meta Events are like audio metadata, except that they are interspersed 
 *  with the MIDI content throughout the file and are not localized in the header. 
 *  As such, it is necessary to retrieve information about these Meta Events from 
 *  the engine, as it encounters these Meta Events within the MIDI content. 
 *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright, 
 *  author, default tempo, etc.) scattered throughout the file. 
 *  @ingroup midi
 */
typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE{ 
    OMX_U32 nSize;            /**< size of the structure in bytes */ 
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
    OMX_U32 nIndex;           /**< Index of Meta Event */ 
    OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */ 
    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
    OMX_U32 nTrack;           /**< track number for the meta event */
    OMX_U32 nPosition;        /**< Position of the meta-event in milliseconds */
} OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE; 


/** MIDI Meta Event Data structure - one per Meta Event. 
 * @ingroup midi
 */ 
typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE{ 
    OMX_U32 nSize;            /**< size of the structure in bytes */ 
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
    OMX_U32 nIndex;           /**< Index of Meta Event */ 
    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
    OMX_U8 nData[1];          /**< array of one or more bytes of meta data 
                                   as indicated by the nMetaEventSize field */ 
} OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE; 


/** Audio Volume adjustment for a port */
typedef struct OMX_AUDIO_CONFIG_VOLUMETYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
                                     set.  Select the input port to set 
                                     just that port's volume.  Select the 
                                     output port to adjust the master 
                                     volume. */
    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) 
                                     or logarithmic scale (mB) */
    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
                                     Volume logarithmic setting for this port.  The values
                                     for volume are in mB (millibels = 1/100 dB) relative
                                     to a gain of 1 (e.g. the output is the same as the 
                                     input level).  Values are in mB from nMax 
                                     (maximum volume) to nMin mB (typically negative).
                                     Since the volume is "voltage"
                                     and not a "power", it takes a setting of
                                     -600 mB to decrease the volume by 1/2.  If
                                     a component cannot accurately set the 
                                     volume to the requested value, it must
                                     set the volume to the closest value BELOW
                                     the requested value.  When getting the
                                     volume setting, the current actual volume
                                     must be returned. */
} OMX_AUDIO_CONFIG_VOLUMETYPE;


/** Audio Volume adjustment for a channel */
typedef struct OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
                                     set.  Select the input port to set 
                                     just that port's volume.  Select the 
                                     output port to adjust the master 
                                     volume. */
    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
                                     using OMX_ALL to apply volume settings
                                     to all channels */
    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or 
                                     logarithmic scale (mB) */
    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
                                     Volume logarithmic setting for this port.  
                                     The values for volume are in mB 
                                     (millibels = 1/100 dB) relative to a gain
                                     of 1 (e.g. the output is the same as the 
                                     input level).  Values are in mB from nMax 
                                     (maximum volume) to nMin mB (typically negative).  
                                     Since the volume is "voltage"
                                     and not a "power", it takes a setting of
                                     -600 mB to decrease the volume by 1/2.  If
                                     a component cannot accurately set the 
                                     volume to the requested value, it must
                                     set the volume to the closest value BELOW
                                     the requested value.  When getting the
                                     volume setting, the current actual volume
                                     must be returned. */
    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
                                     FALSE otherwise */
} OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE;


/** Audio balance setting */
typedef struct OMX_AUDIO_CONFIG_BALANCETYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
                                     set.  Select the input port to set 
                                     just that port's balance.  Select the 
                                     output port to adjust the master 
                                     balance. */
    OMX_S32 nBalance;           /**< balance setting for this port 
                                     (-100 to 100, where -100 indicates
                                     all left, and no right */
} OMX_AUDIO_CONFIG_BALANCETYPE;


/** Audio Port mute */
typedef struct OMX_AUDIO_CONFIG_MUTETYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
                                     set.  Select the input port to set 
                                     just that port's mute.  Select the 
                                     output port to adjust the master 
                                     mute. */
    OMX_BOOL bMute;             /**< Mute setting for this port */
} OMX_AUDIO_CONFIG_MUTETYPE;


/** Audio Channel mute */
typedef struct OMX_AUDIO_CONFIG_CHANNELMUTETYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPortIndex;         /**< port that this structure applies to */
    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
                                     using OMX_ALL to apply mute settings
                                     to all channels */
    OMX_BOOL bMute;             /**< Mute setting for this channel */
    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
                                     FALSE otherwise */ 
} OMX_AUDIO_CONFIG_CHANNELMUTETYPE;



/** Enable / Disable for loudness control, which boosts bass and to a 
 *  smaller extent high end frequencies to compensate for hearing
 *  ability at the extreme ends of the audio spectrum
 */ 
typedef struct OMX_AUDIO_CONFIG_LOUDNESSTYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_U32 nPortIndex;        /**< port that this structure applies to */
    OMX_BOOL bLoudness;        /**< Enable/disable for loudness */
} OMX_AUDIO_CONFIG_LOUDNESSTYPE;


/** Enable / Disable for bass, which controls low frequencies
 */ 
typedef struct OMX_AUDIO_CONFIG_BASSTYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_U32 nPortIndex;        /**< port that this structure applies to */
    OMX_BOOL bEnable;          /**< Enable/disable for bass control */
    OMX_S32 nBass;             /**< bass setting for the port, as a 
                                    continuous value from -100 to 100  
                                    (0 means no change in bass level)*/
} OMX_AUDIO_CONFIG_BASSTYPE;


/** Enable / Disable for treble, which controls high frequencies tones
 */ 
typedef struct OMX_AUDIO_CONFIG_TREBLETYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_U32 nPortIndex;        /**< port that this structure applies to */
    OMX_BOOL bEnable;          /**< Enable/disable for treble control */
    OMX_S32  nTreble;          /**< treble setting for the port, as a
                                    continuous value from -100 to 100  
                                    (0 means no change in treble level) */
} OMX_AUDIO_CONFIG_TREBLETYPE;


/** An equalizer is typically used for two reasons: to compensate for an 
 *  sub-optimal frequency response of a system to make it sound more natural 
 *  or to create intentionally some unnatural coloring to the sound to create
 *  an effect.
 *  @ingroup effects
 */
typedef struct OMX_AUDIO_CONFIG_EQUALIZERTYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_U32 nPortIndex;        /**< port that this structure applies to */
    OMX_BOOL bEnable;          /**< Enable/disable for equalizer */
    OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is 
                                    N-1, where N is the number of bands, lower limit is 0 */
    OMX_BU32 sCenterFreq;      /**< Center frequecies in Hz.  This is a
                                    read only element and is used to determine 
                                    the lower, center and upper frequency of 
                                    this band.  */
    OMX_BS32 sBandLevel;       /**< band level in millibels */
} OMX_AUDIO_CONFIG_EQUALIZERTYPE;


/** Stereo widening mode type 
 * @ingroup effects
 */ 
typedef enum OMX_AUDIO_STEREOWIDENINGTYPE {
    OMX_AUDIO_StereoWideningHeadphones,    /**< Stereo widening for loudspeakers */
    OMX_AUDIO_StereoWideningLoudspeakers,  /**< Stereo widening for closely spaced loudspeakers */
    OMX_AUDIO_StereoWideningKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_AUDIO_StereoWideningVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_AUDIO_StereoWideningMax = 0x7FFFFFFF
} OMX_AUDIO_STEREOWIDENINGTYPE;


/** Control for stereo widening, which is a special 2-channel
 *  case of the audio virtualizer effect. For example, for 5.1-channel 
 *  output, it translates to virtual surround sound. 
 * @ingroup effects
 */ 
typedef struct OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_U32 nPortIndex;        /**< port that this structure applies to */
    OMX_BOOL bEnable;          /**< Enable/disable for stereo widening control */
    OMX_AUDIO_STEREOWIDENINGTYPE eWideningType; /**< Stereo widening algorithm type */
    OMX_U32  nStereoWidening;  /**< stereo widening setting for the port,
                                    as a continuous value from 0 to 100  */
} OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE;


/** The chorus effect (or ``choralizer'') is any signal processor which makes
 *  one sound source (such as a voice) sound like many such sources singing 
 *  (or playing) in unison. Since performance in unison is never exact, chorus 
 *  effects simulate this by making independently modified copies of the input 
 *  signal. Modifications may include (1) delay, (2) frequency shift, and 
 *  (3) amplitude modulation.
 * @ingroup effects
 */
typedef struct OMX_AUDIO_CONFIG_CHORUSTYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_U32 nPortIndex;        /**< port that this structure applies to */
    OMX_BOOL bEnable;          /**< Enable/disable for chorus */
    OMX_BU32 sDelay;           /**< average delay in milliseconds */
    OMX_BU32 sModulationRate;  /**< rate of modulation in millihertz */
    OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of 
                                    delay (i.e. 0 to 100) */
    OMX_BU32 nFeedback;        /**< Feedback from chorus output to input in percentage */
} OMX_AUDIO_CONFIG_CHORUSTYPE;


/** Reverberation is part of the reflected sound that follows the early 
 *  reflections. In a typical room, this consists of a dense succession of 
 *  echoes whose energy decays exponentially. The reverberation effect structure 
 *  as defined here includes both (early) reflections as well as (late) reverberations. 
 * @ingroup effects
 */
typedef struct OMX_AUDIO_CONFIG_REVERBERATIONTYPE {
    OMX_U32 nSize;                /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
    OMX_U32 nPortIndex;           /**< port that this structure applies to */
    OMX_BOOL bEnable;             /**< Enable/disable for reverberation control */
    OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect 
                                       (i.e. both early reflections and late 
                                       reverberation) in millibels */
    OMX_BS32 sRoomHighFreqLevel;  /**< Attenuation at high frequencies
                                       relative to the intensity at low
                                       frequencies in millibels */
    OMX_BS32 sReflectionsLevel;   /**< Intensity level of early reflections
                                       (relative to room value), in millibels */
    OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative 
                                       to the direct path, in milliseconds */
    OMX_BS32 sReverbLevel;        /**< Intensity level of late reverberation
                                       relative to room level, in millibels */
    OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection 
                                       to the beginning of the late reverberation 
                                       section, in milliseconds */
    OMX_BU32 sDecayTime;          /**< Late reverberation decay time at low
                                       frequencies, in milliseconds */
    OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative 
                                       to low frequency decay time in percent  */
    OMX_U32 nDensity;             /**< Modal density in the late reverberation decay,
                                       in percent (i.e. 0 - 100) */
    OMX_U32 nDiffusion;           /**< Echo density in the late reverberation decay,
                                       in percent (i.e. 0 - 100) */
    OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is 
                                       the frequency used as the reference for all 
                                       the high-frequency settings above */

} OMX_AUDIO_CONFIG_REVERBERATIONTYPE;


/** Possible settings for the Echo Cancelation structure to use 
 * @ingroup effects
 */
typedef enum OMX_AUDIO_ECHOCANTYPE {
   OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
   OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation - 
                                     echo from plastics and face */
   OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for 
                                     Hands Free operation */
   OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for 
                                     Car Kit (longer echo) */
   OMX_AUDIO_EchoCanKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_AUDIO_EchoCanVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
} OMX_AUDIO_ECHOCANTYPE;


/** Enable / Disable for echo cancelation, which removes undesired echo's
 *  from the audio
 * @ingroup effects
 */ 
typedef struct OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_U32 nPortIndex;        /**< port that this structure applies to */
    OMX_AUDIO_ECHOCANTYPE eEchoCancelation; /**< Echo cancelation settings */
} OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE;


/** Enable / Disable for noise reduction, which undesired noise from
 * the audio
 * @ingroup effects
 */ 
typedef struct OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_U32 nPortIndex;        /**< port that this structure applies to */
    OMX_BOOL bNoiseReduction;  /**< Enable/disable for noise reduction */
} OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE;

/** @} */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// OpenMAX IL - Broadcom specific types

#ifndef OMX_Broadcom_h
#define OMX_Broadcom_h

#include "OMX_Component.h"

// for use in buffer headers - marks the contained data
// as being a codec header
#define OMX_BUFFERFLAG_TIME_UNKNOWN 0x00000100

//for use in buffer headers - marks the buffer as being the
//snapshot preview image from a still capture.
//Mainly to be used with the DisplayFunction callback from camera.
#define OMX_BUFFERFLAG_CAPTURE_PREVIEW 0x00000200

/* Mark the end of a NAL unit produced by a video encoder.
 */
#define OMX_BUFFERFLAG_ENDOFNAL    0x00000400

/* Marks pBuffer in OMX_BUFFERHEADERTYPE as containing a fragment list instead of the actual buffer
 */
#define OMX_BUFFERFLAG_FRAGMENTLIST 0x00000800

/* Marks the start of a new sequence of data following any kind of seek operation.
 */
#define OMX_BUFFERFLAG_DISCONTINUITY 0x00001000

/** Codec side information Flag:
* OMX_BUFFERFLAG_CODECSIDEINFO is an optional flag that is set by an
* output port when all bytes in the buffer form part or all of a set of
* codec specific side information. For example, distortion information
* estimated by H.264 encoder can be sent using this flag to signal
* the decoder quality
*/
#define OMX_BUFFERFLAG_CODECSIDEINFO 0x00002000

// for use in buffer headers - indicated the timestamp is a DTS rather than PTS
#define OMX_BUFFERFLAG_TIME_IS_DTS 0x000004000

/**
 * Macros to convert to <code>OMX_TICKS</code> from a signed 64 bit value and
 * vice-versa. These macros don't actually do anything unless <code>OMX_TICKS</code>
 * is defined as a two-part structure (instead of a native signed 64-bit type).
 **/
#ifndef OMX_SKIP64BIT
   #define omx_ticks_from_s64(s) (s)
   #define omx_ticks_to_s64(t) (t)
#else
   static inline OMX_TICKS omx_ticks_from_s64(signed long long s) { OMX_TICKS t; t.nLowPart = (OMX_U32)s; t.nHighPart = (OMX_U32)(s>>32); return t; }
   #define omx_ticks_to_s64(t) ((t).nLowPart | ((uint64_t)((t).nHighPart) << 32))
#endif /* OMX_SKIP64BIT */

/* Buffer fragment descriptor */
typedef struct OMX_BUFFERFRAGMENTTYPE {
   OMX_PTR pBuffer; /**< Pointer to actual block of memory that is acting as the fragment buffer */
   OMX_U32 nLen;    /**< number of bytes in the buffer */
} OMX_BUFFERFRAGMENTTYPE;

/* OMX_IndexParamBrcmEnableIJGTableScaling: JPEG Quality Table Setting. */
typedef struct OMX_PARAM_IJGSCALINGTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bEnabled;
} OMX_PARAM_IJGSCALINGTYPE;
/*
The boolean \code{bEnabled} value determines whether the component uses
the standard IJG quality tables when encoding images.
*/


/* OMX_IndexConfigTimeInvalidStartTime: Invalid Start Times */
/*
This allows clock clients to supply a start time notification to the
clock whilst indicating that this time is invalid.
*/

/* OMX_IndexParamBrcmMaxFrameSkips: Frame timestamp jumps */
/*
This number represents the number of times a jump in frame timestamps
has been observed that is greater than expected.
*/

/* OMX_IndexConfigAsynchronousFailureURI: Asynchronous Failure Filename */
/*
This allows the client to query for the filename that cause an asynchronous
output error.
*/

/* OMX_IndexParamAsynchronousOutput: Asynchronous Output */
/*
The allows the client to specify to a component that is writing files
that this writing may happen asynchronously, including opening and closing
of files.
*/

/* OMX_IndexConfigClockAdjustment: Clock Adjustment */
/*
This allows the client to read from the clock the total time
adjustment made to the clock whilst running by the reference clock.
If the reference clock sends a time that causes the media time to jump
this difference is added to the total, which can be reported via this
index.  When the stream restarts by setting the clock state to
\code{OMX_TIME_ClockStateRunning} or
\code{OMX_TIME_ClockStateWaitingForStartTime} this adjustment total is
set to zero.
*/

/* OMX_IndexParamBrcmDataUnit: Data Unit */
/*
The data unit is an indication to components connected to this
component of the type of data delivery available.
\code{OMX_DataUnitCodedPicture} indicates that we are able to give
framing information, using the \code{OMX_BUFFERFLAG_ENDOFFRAME} flag to
indicate that the data contained finishes a complete
frame. \code{OMX_DataUnitArbitraryStreamSection} indicates that no
end-of-frame markers will be present, and the decoder should perform
the steps necessary to decode the stream. The other enum values are
not used.
*/

/* OMX_IndexConfigPresentationOffset: Presentation Offset */
/*
The value of \code{nTimestamp} is added to the offset requested for
each new input frame. Takes effect for all new input frames, and has
no effect on the offset used for currently-queued frames. A positive
value will make the requested port earlier relative to other streams,
a negative value will make the requested port later relative to other
streams.
*/

/* OMX_IndexConfigSingleStep: Single Step */
/*
When setting this config on a paused clock, where the \code{nU32}
value is non-zero and \code{nPortIndex} is OMX_ALL, the media clock
will advance through the next \code{nU32} next requested media
times. A paused clock is in running state but has a time scale of
0. This will trigger the display of some video frames, so allowing
single-stepping functionality. This config can be set multiple times,
and will buffer up stepping requests until we have media requests to
fulfil, or the clock is stopped or un-paused.

This config can also be used on some video output ports and, if
\code{nU32} is non-zero, requests that the output port forwards the
next \code{nU32} frames appending an EOS marker on the last frame, and
then ceases to forward data on this port.  If \code{nU32} is zero, any
previous request to forward a limited number of frames is cancelled
and the default behaviour of this port will resume.
*/

/* OMX_IndexParamCameraCamplusId: Camera Subsystem Identification */
/*
This parameter allows the configuration of the identifier to be used
to initialise the Broadcom Camplus subsystem that sits beneath the
camera component. If only one instance of the camera component is
used, the default value can be used. If more than one instance is
required, they must each have their own unique values for this
parameter. It is also used to tie the component to the image pool
created with \code{OMX_Set upCamPools}.
*/

/* OMX_IndexConfigAudioRenderingLatency: Audio Rendering Latency */
/*
This config allows the client to query the current latency of audio
rendering.  The latency is returned as the number of samples that
an audio rendering component has received but have not been played.
*/

/* OMX_IndexConfigBrcmPoolMemAllocSize: Pool memory usage values */
/*
This config allows the client to query how much memory is being used by
the component for any image pools. 
*/

/* OMX_IndexConfigDisplayRegion: Display Region */
typedef enum OMX_DISPLAYTRANSFORMTYPE{
   OMX_DISPLAY_ROT0 = 0,
   OMX_DISPLAY_MIRROR_ROT0 = 1,
   OMX_DISPLAY_MIRROR_ROT180 = 2,
   OMX_DISPLAY_ROT180 = 3,
   OMX_DISPLAY_MIRROR_ROT90 = 4,
   OMX_DISPLAY_ROT270 = 5,
   OMX_DISPLAY_ROT90 = 6,
   OMX_DISPLAY_MIRROR_ROT270 = 7,
   OMX_DISPLAY_DUMMY = 0x7FFFFFFF
} OMX_DISPLAYTRANSFORMTYPE;

typedef struct OMX_DISPLAYRECTTYPE {
   OMX_S16 x_offset;
   OMX_S16 y_offset;
   OMX_S16 width;
   OMX_S16 height;
} OMX_DISPLAYRECTTYPE;

typedef enum OMX_DISPLAYMODETYPE {
   OMX_DISPLAY_MODE_FILL = 0,
   OMX_DISPLAY_MODE_LETTERBOX = 1,
   // these allow a left eye source->dest to be specified and the right eye mapping will be inferred by symmetry
   OMX_DISPLAY_MODE_STEREO_LEFT_TO_LEFT = 2,
   OMX_DISPLAY_MODE_STEREO_TOP_TO_TOP = 3,
   OMX_DISPLAY_MODE_STEREO_LEFT_TO_TOP = 4,
   OMX_DISPLAY_MODE_STEREO_TOP_TO_LEFT = 5,
   OMX_DISPLAY_MODE_DUMMY = 0x7FFFFFFF
} OMX_DISPLAYMODETYPE;

typedef enum OMX_DISPLAYSETTYPE {
   OMX_DISPLAY_SET_NONE = 0,
   OMX_DISPLAY_SET_NUM = 1,
   OMX_DISPLAY_SET_FULLSCREEN = 2,
   OMX_DISPLAY_SET_TRANSFORM = 4,
   OMX_DISPLAY_SET_DEST_RECT = 8,
   OMX_DISPLAY_SET_SRC_RECT = 0x10,
   OMX_DISPLAY_SET_MODE = 0x20,
   OMX_DISPLAY_SET_PIXEL = 0x40,
   OMX_DISPLAY_SET_NOASPECT = 0x80,
   OMX_DISPLAY_SET_LAYER = 0x100,
   OMX_DISPLAY_SET_COPYPROTECT = 0x200,
   OMX_DISPLAY_SET_ALPHA = 0x400,
   OMX_DISPLAY_SET_DUMMY = 0x7FFFFFFF
} OMX_DISPLAYSETTYPE;

typedef struct OMX_CONFIG_DISPLAYREGIONTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_DISPLAYSETTYPE set;
   OMX_U32 num;
   OMX_BOOL fullscreen;
   OMX_DISPLAYTRANSFORMTYPE transform;
   OMX_DISPLAYRECTTYPE dest_rect;
   OMX_DISPLAYRECTTYPE src_rect;
   OMX_BOOL noaspect;
   OMX_DISPLAYMODETYPE mode;
   OMX_U32 pixel_x;
   OMX_U32 pixel_y;
   OMX_S32 layer;
   OMX_BOOL copyprotect_required;
   OMX_U32 alpha;
   OMX_U32 wfc_context_width;
   OMX_U32 wfc_context_height;
} OMX_CONFIG_DISPLAYREGIONTYPE;
/*
This config sets the output display device, as well as the region used
on the output display, any display transformation, and some flags to
indicate how to scale the image.

The structure uses a bitfield, \code{set}, to indicate which fields are set
and should be used. All other fields will maintain their current
value.

\code{num} describes the display output device, with 0 typically being
a directly connected LCD display.

\code{fullscreen} indicates that we are using the full device screen
area, rather than a window of the display.  If fullscreen is false,
then dest_rect is used to specify a region of the display to use.

\code{transform} indicates any rotation or flipping used to map frames
onto the natural display orientation.

The \code{src_rect} indicates which area of the frame to display. If
all values are zero, the whole frame will be used.

The \code{noaspect} flag, if set, indicates that any display scaling
should disregard the aspect ratio of the frame region being displayed.

\code{mode} indicates how the image should be scaled to fit the
display. \code{OMX_DISPLAY_MODE_FILL} indicates that the image should
fill the screen by potentially cropping the frames.  Setting
\code{mode} to \code{OMX_DISPLAY_MODE_LETTERBOX} indicates that all
the source region should be displayed and black bars added if
necessary.

The \code{pixel_x} and \code{pixel_y} values, if non-zero, are used to
describe the size of a source pixel. If values are zero, then pixels
default to being square.

Set the \code{layer} that the image will appear on with the
\code{layer} field.
*/



/* OMX_IndexParamSource: Source Image Configuration */
typedef enum OMX_SOURCETYPE {
   OMX_SOURCE_WHITE = 0,    // all white images
   OMX_SOURCE_BLACK = 1,    // all black images
   OMX_SOURCE_DIAGONAL = 2, // greyscale diagonal stripes
   OMX_SOURCE_NOISE = 3,    // random pixel values
   OMX_SOURCE_RANDOM = 4,   // a shaded random pattern of colours
   OMX_SOURCE_COLOUR = 5,   // a solid colour determined by nParam
   OMX_SOURCE_BLOCKS = 6,   // random coloured blocks of 16x16 size
   OMX_SOURCE_SWIRLY,       // a swirly pattern used for encode testing
   OMX_SOURCE_DUMMY = 0x7FFFFFFF
} OMX_SOURCETYPE;

typedef struct OMX_PARAM_SOURCETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_SOURCETYPE eType;
   OMX_U32 nParam;
   OMX_U32 nFrameCount;
   OMX_U32 xFrameRate;
} OMX_PARAM_SOURCETYPE;
/*
The source type determines the kind of image that is produced. Not all
combinations of source type and image type are supported.  The
\code{OMX_SOURCE_SWIRLY} setting can only be used with YUV420 packed
planar image formats.  When producing RGB565 image format, the
\code{OMX_SOURCE_DIAGONAL} and \code{OMX_SOURCE_RANDOM} modes are
treated as \code{OMX_SOURCE_NOISE}.

The \code{nParam} field is used to specify the colour for the source
colour mode, and the offset of the diagonal pattern for diagonal mode.
For the blocks mode, \code{nParam} is used as the seed for the random
colour generator.

The \code{nFrameCount} parameter determines how many frames to send.
If it is zero, then frames are sent continuously. For any other value,
it counts down until it has sent that many frames, and then stops,
sending out an EOS. The \code{xFrameRate} setting is used to determine
the timestamp for each frame produced, or can be set to zero if
timestamps should all remain at zero.
*/

/* OMX_IndexParamSourceSeed: Source Random Seed */
typedef struct OMX_PARAM_SOURCESEEDTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U16 nData[16];
} OMX_PARAM_SOURCESEEDTYPE;
/*
This structure sets the current state of the random number generator
used for \code{OMX_SOURCE_RANDOM} source type, allowing repeatable
random image creation.
*/

/* OMX_IndexParamResize: Resize Control */
typedef enum OMX_RESIZEMODETYPE {
   OMX_RESIZE_NONE,
   OMX_RESIZE_CROP,
   OMX_RESIZE_BOX,
   OMX_RESIZE_BYTES,
   OMX_RESIZE_DUMMY = 0x7FFFFFFF
} OMX_RESIZEMODETYPE;

typedef struct OMX_PARAM_RESIZETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_RESIZEMODETYPE eMode;
   OMX_U32 nMaxWidth;
   OMX_U32 nMaxHeight;
   OMX_U32 nMaxBytes;
   OMX_BOOL bPreserveAspectRatio;
   OMX_BOOL bAllowUpscaling;
} OMX_PARAM_RESIZETYPE;
/*
The mode determines the kind of resize. \code{OMX_RESIZE_BOX} allow
the \code{nMaxWidth} and \code{nMaxHeight} to set a bounding box into
which the output must fit. \code{OMX_RESIZE_BYTES} allows
\code{nMaxBytes} to set the maximum number of bytes into which the
full output frame must fit.  Two flags aid the setting of the output
size. \code{bPreseveAspectRatio} sets whether the resize should
preserve the aspect ratio of the incoming
image. \code{bAllowUpscaling} sets whether the resize is allowed to
increase the size of the output image compared to the size of the
input image.
*/

typedef struct OMX_PARAM_TESTINTERFACETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bTest;
   OMX_BOOL bSetExtra;
   OMX_U32 nExtra;
   OMX_BOOL bSetError;
   OMX_BOOL stateError[2];
} OMX_PARAM_TESTINTERFACETYPE;

/* OMX_IndexConfigVisualisation: Visualisation Mode */
typedef struct OMX_CONFIG_VISUALISATIONTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U8 name[16];
   OMX_U8 property[64];
} OMX_CONFIG_VISUALISATIONTYPE;

/*
\code{name} is a string of characters specifying the type of
visualization. The component appends \code{"_vis.vll"} to the name
provided, and attempts to load a visualisation library contained in
this VLL.  \code{property} contains configuration parameters and
values, which is interpreted by the visualisation library. Typically
all visualisations will accept a property string containing
\code{'mode=<number>'}, where \code{<number>} may be a random 32 bit
integer in decimal format. If provided, this may select a random mode
from that visualisation library.
*/

/*
This parameter is used when creating proprietary communication with
the display component, and provides the display function for passing
images to be displayed, together with a function used to flush all
pending image updates and release all images.
*/

/* OMX_IndexConfigBrcmAudioDestination: Audio Destination */
typedef struct OMX_CONFIG_BRCMAUDIODESTINATIONTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U8 sName[16];
} OMX_CONFIG_BRCMAUDIODESTINATIONTYPE;
/*
This config sets the platform-specific audio destination or output
device for audio sink components (e.g. audio_render).

\code{sName} describes the audio destination, with \code{"local"}
typically being directly connected to headphones.
*/

/* OMX_IndexConfigBrcmAudioSource: Audio Source */
typedef struct OMX_CONFIG_BRCMAUDIOSOURCETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U8 sName[16];
} OMX_CONFIG_BRCMAUDIOSOURCETYPE;
/*
This config sets the platform-specific audio source or input device
for audio source components (e.g. audio_capture).

\code{sName} describes the audio source, with \code{"local"}
typically being directly connected to microphone.
*/

/* OMX_IndexConfigBrcmAudioDownmixCoefficients: Audio Downmix Coefficients */
typedef struct OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 coeff[16];
} OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS;
/*
This config sets the platform-specific audio downmixing coefficients for the 
audio mixer component. The coefficients are 16.16 fixed point.
The even coefficients contribute to the left channel. 
The odd coefficients contribute to the right channel. 
L' = coeff[0] * sample[N] + coeff[2] * sample[N+1] + coeff[4] * sample[N+2] + coeff[6] * sample[N+3] 
   + coeff[8] * sample[N+4] + coeff[10] * sample[N+5] + coeff[12] * sample[N+6] + coeff[14] * sample[N+7]
R' = coeff[1] * sample[N] + coeff[3] * sample[N+1] + coeff[5] * sample[N+2] + coeff[7] * sample[N+3] 
   + coeff[9] * sample[N+4] + coeff[11] * sample[N+5] + coeff[13] * sample[N+6] + coeff[15] * sample[N+7]

\code{coeff} describes the downmixing coefficients
*/

/* OMX_IndexConfigBrcmAudioDownmixCoefficients8x8: Audio Downmix Coefficients */
typedef struct OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8 {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 coeff[64];
} OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8;
/*
This config sets the platform-specific audio downmixing coefficients for the 
audio mixer component. The coefficients are 16.16 fixed point.
The coefficients are a 8*8 mixing matrix from 8 input channels to 8 outputs channels

\code{coeff} describes the downmixing coefficients
*/

/* OMX_IndexConfigBrcmAudioMaxSample: Maximum sample seen */
typedef struct OMX_CONFIG_BRCMAUDIOMAXSAMPLE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nMaxSample;
   OMX_TICKS nTimeStamp;
} OMX_CONFIG_BRCMAUDIOMAXSAMPLE;
/*
This gets the largest sample produced (after downmixing with OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8) 
since this config was last read. The nTimestamp is the earliest timestamp processed. 
This can be used for DRC schemes 

\code{coeff} maximum sample seen in current block
*/

/* OMX_IndexConfigPlayMode: Play Mode */
typedef enum OMX_PLAYMODETYPE {
   OMX_PLAYMODE_NORMAL,
   OMX_PLAYMODE_FF,
   OMX_PLAYMODE_REW,
   OMX_PLAYMODE_DUMMY = 0x7FFFFFFF
} OMX_PLAYMODETYPE;

typedef struct OMX_CONFIG_PLAYMODETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_PLAYMODETYPE eMode;
} OMX_CONFIG_PLAYMODETYPE;
/*
The playmode affects which frames are extracted from the media file
and passed on the output ports. \code{OMX_PLAYMODE_NORMAL} will
extract all frames, \code{OMX_PLAYMODE_FF} extracts only IDR frames
when video is present, or only occasional packets of audio if no video
is present. \code{OMX_PLAYMODE_REW} is similar to
\code{OMX_PLAYMODE_FF} but extracts packets in reverse time
order.
*/

typedef enum OMX_DELIVERYFORMATTYPE {
   OMX_DELIVERYFORMAT_STREAM,         // no framing information is known
   OMX_DELIVERYFORMAT_SINGLE_PACKET,  // packetised, at most one frame per buffer
   OMX_DELIVERYFORMAT_DUMMY = 0x7FFFFFFF
} OMX_DELIVERYFORMATTYPE;

typedef struct OMX_PARAM_DELIVERYFORMATTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_DELIVERYFORMATTYPE eFormat;
} OMX_PARAM_DELIVERYFORMATTYPE;

/* OMX_IndexParamCodecConfig: Codec Configuration */

typedef struct OMX_PARAM_CODECCONFIGTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 bCodecConfigIsComplete;
   OMX_U8 nData[1];
} OMX_PARAM_CODECCONFIGTYPE;

/*
This parameter contains opaque data in a format specified by Broadcom
and allows out-of-band information such as cropping rectangles, aspect
ratio information, codec-specific header bytes, and other essential
information to be passed between connected components.

\code{bCodecConfigIsCompete} specifies if the codec config is fully
contained in here and there is no need to wait for OMX_BUFFERFLAG_CODECCONFIG
buffers
*/

typedef struct OMX_PARAM_STILLSFUNCTIONTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bBuffer;
   OMX_PTR (*pOpenFunc)(void);
   OMX_PTR (*pCloseFunc)(void);
   OMX_PTR (*pReadFunc)(void);
   OMX_PTR (*pSeekFunc)(void);
   OMX_PTR (*pWriteFunc)(void);
} OMX_PARAM_STILLSFUNCTIONTYPE;

typedef void* OMX_BUFFERADDRESSHANDLETYPE;

typedef struct OMX_PARAM_BUFFERADDRESSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nAllocLen;
   OMX_BUFFERADDRESSHANDLETYPE handle;
} OMX_PARAM_BUFFERADDRESSTYPE;

typedef struct OMX_PARAM_TUNNELSETUPTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_TUNNELSETUPTYPE sSetup;
} OMX_PARAM_TUNNELSETUPTYPE;

/* OMX_IndexParamBrcmPortEGL: Used for querying whether a port is an EGL port or not. */
typedef struct OMX_PARAM_BRCMPORTEGLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bPortIsEGL;
} OMX_PARAM_BRCMPORTEGLTYPE;
/*
*/

#define OMX_CONFIG_IMAGEFILTERPARAMS_MAXPARAMS 6
/* OMX_IndexConfigCommonImageFilterParameters: Parameterized Image Filter */
typedef struct OMX_CONFIG_IMAGEFILTERPARAMSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_IMAGEFILTERTYPE eImageFilter;
   OMX_U32 nNumParams;
   OMX_U32 nParams[OMX_CONFIG_IMAGEFILTERPARAMS_MAXPARAMS];
} OMX_CONFIG_IMAGEFILTERPARAMSTYPE;
/*
This structure contains optional parameters for some image
filters. The following table lists all image filters that support
parameters.

<table border="1" cellspacing="0" cellpadding="2">
<tr><td>Filter<td>Parameters<td>Notes

<tr><td>\code{OMX_ImageFilterSolarize}
<td>\code{[x0 y0 y1 y2]}
<td>Linear mapping of \code{[0,x0]} to \code{[0,y0>]}
and \code{[x0,255]} to \code{[y1,y2]}.
Default is \code{"128 128 128 0"}.

<tr><td>\code{OMX_ImageFilterSharpen}
<td>\code{[sz [str [th]]}
<td>\code{sz} size of filter, either 1 or 2.
\code{str} strength of filter.
\code{th} threshold of filter.
Default is \code{"1 40 20"}.

<tr><td>\code{OMX_ImageFilterFilm}
<td>\code{[[str] [u v]]}
<td>\code{str} strength of effect.
\code{u} sets u to constant value.
\code{v} sets v to constant value.
Default is \code{"24"}.

<tr><td>\code{OMX_ImageFilterBlur}
<td>\code{[sz]}
<td>\code{sz} size of filter, either 1 or 2.
Default is \code{"2"}.

<tr><td>\code{OMX_ImageFilterSaturation}
<td>\code{[str]}
<td>\code{str} strength of effect, in 8.8 fixed point format. u/v value
differences from 128 are multiplied by \code{str}.
Default is \code{"272"}.
</table>
*/


/* OMX_IndexConfigTransitionControl: Transition Control */
typedef struct OMX_CONFIG_TRANSITIONCONTROLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nPosStart;
   OMX_U32 nPosEnd;
   OMX_S32 nPosIncrement;
   OMX_TICKS nFrameIncrement;
   OMX_BOOL bSwapInputs;
   OMX_U8 name[16];
   OMX_U8 property[64];
} OMX_CONFIG_TRANSITIONCONTROLTYPE;
/*
This structure represents the internal configuration of the
transition. Transitions are generated by a loadable plug-in described
by the \code{name} field. The component appends \code{"_tran.vll"} to
the name provided, and attempts to load a transition library contained
in this VLL.  The exact type of transition is configured in a
plug-in-dependent manner with the \code{property} field. All plug-ins
should accept a \code{property} field equal to
\code{"flags=<number>"}, where \code{<number>} can be a random 32 bit
number.  If \code{bSwapInputs} is false, then the start image is on
port 210, the stop image on port 211. These are reversed if
\code{bSwapInputs} is true.

Transition frames are generated from the plug-in by referencing a
frame position in [0,65536], where position 0 is the start image,
position 65536 is the stop image. The first frame position generated
is \code{nPosStart}. The last frame position generated is
\code{nPosEnd}. Each frame will increment the position by
\code{nPosIncrement}. The timestamp attached to each frame will
increment by \code{nFrameIncrement}.
*/


/*
This parameter is used to provide a callback function pointer for
release events. It is used for internal clients on VideoCore.
*/


/* OMX_IndexConfigAudioMonoTrackControl: Dual Mono Control */
typedef enum OMX_AUDIOMONOTRACKOPERATIONSTYPE {
   OMX_AUDIOMONOTRACKOPERATIONS_NOP,
   OMX_AUDIOMONOTRACKOPERATIONS_L_TO_R,
   OMX_AUDIOMONOTRACKOPERATIONS_R_TO_L,
   OMX_AUDIOMONOTRACKOPERATIONS_DUMMY = 0x7FFFFFFF
} OMX_AUDIOMONOTRACKOPERATIONSTYPE ;

typedef struct OMX_CONFIG_AUDIOMONOTRACKCONTROLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_AUDIOMONOTRACKOPERATIONSTYPE eMode;
} OMX_CONFIG_AUDIOMONOTRACKCONTROLTYPE;
/*
This config controls the options to support dual mono audio
streams. The output can be unchanged, or the left channel copied over
the right channel, or the right channel copied over the left
channel. This config can be applied at any time with stereo
16-bit-per-sample data. Since audio output is typically buffered, any
change will not be audible until that buffering has been played out.
*/

/* OMX_IndexParamCameraImagePool: Camera Image Pools */
typedef enum OMX_CAMERAIMAGEPOOLINPUTMODETYPE {
   OMX_CAMERAIMAGEPOOLINPUTMODE_ONEPOOL,     /*All input images are allocated from one pool
                                               Works for simple stills capture use cases
                                               Can not be used with parallel stills capture
                                               and video encode, as the pool will be sized for
                                               capture or viewfinder, not both simultaneously.
                                               The pool wouldn't divide sensibly in this mode
                                               anyway.
                                             */
   OMX_CAMERAIMAGEPOOLINPUTMODE_TWOPOOLS,    /*All stills & video input images are allocated
                                               from two separate pools.
                                               This ensures that parallel capture can work, but
                                               would consume more memory if used on a simple
                                               stills capture use case.
                                             */
} OMX_CAMERAIMAGEPOOLINPUTMODETYPE;

typedef struct OMX_PARAM_CAMERAIMAGEPOOLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nNumHiResVideoFrames;
   OMX_U32 nHiResVideoWidth;
   OMX_U32 nHiResVideoHeight;
   OMX_COLOR_FORMATTYPE eHiResVideoType;
   OMX_U32 nNumHiResStillsFrames;
   OMX_U32 nHiResStillsWidth;
   OMX_U32 nHiResStillsHeight;
   OMX_COLOR_FORMATTYPE eHiResStillsType;
   OMX_U32 nNumLoResFrames;
   OMX_U32 nLoResWidth;
   OMX_U32 nLoResHeight;
   OMX_COLOR_FORMATTYPE eLoResType;
   OMX_U32 nNumSnapshotFrames;
   OMX_COLOR_FORMATTYPE eSnapshotType;
   OMX_CAMERAIMAGEPOOLINPUTMODETYPE eInputPoolMode;
   OMX_U32 nNumInputVideoFrames;
   OMX_U32 nInputVideoWidth;
   OMX_U32 nInputVideoHeight;
   OMX_COLOR_FORMATTYPE eInputVideoType;
   OMX_U32 nNumInputStillsFrames;
   OMX_U32 nInputStillsWidth;
   OMX_U32 nInputStillsHeight;
   OMX_COLOR_FORMATTYPE eInputStillsType;
} OMX_PARAM_CAMERAIMAGEPOOLTYPE;
/*
\sloppy This parameter specifies the size, type, and number, of images to
allow in the images pools required by Camplus. Supported types are
\code{OMX_COLOR_FormatYUV420PackedPlanar},
\code{OMX_COLOR_FormatYUV422PackedPlanar},
\code{OMX_COLOR_FormatRawBayer8bit},
\code{OMX_COLOR_FormatRawBayer10bit},
\code{OMX_COLOR_FormatRawBayer8bitcompressed}, and 0 (reserved for the
Broadcom-specific format required by the video encoder). The input
pool width, height, and type can be set as 0 to make the component
query Camplus for the sensor mode that would correspond to the largest
of the viewfinder port definition, the capture port definition, or the
high resolution image pool.
*/

/* OMX_IndexParamImagePoolSize: Specifying Image Pool Properties */
typedef struct OMX_PARAM_IMAGEPOOLSIZETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 width;
   OMX_U32 height;
   OMX_U32 num_pages;
} OMX_PARAM_IMAGEPOOLSIZETYPE;
/*
This parameter is used to control the size of pool that the component
will allocate in the absence of setting an external pool.  The default
can be reset by setting this parameter with all three fields set to
zero.
*/


/* OMX_IndexParamImagePoolExternal: Client Allocated Image Pools */
struct opaque_vc_pool_s;
typedef struct opaque_vc_pool_s OMX_BRCM_POOL_T;

typedef struct OMX_PARAM_IMAGEPOOLEXTERNALTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BRCM_POOL_T *image_pool;
   OMX_BRCM_POOL_T *image_pool2;
   OMX_BRCM_POOL_T *image_pool3;
   OMX_BRCM_POOL_T *image_pool4;
   OMX_BRCM_POOL_T *image_pool5;
} OMX_PARAM_IMAGEPOOLEXTERNALTYPE;
/*
This config allows the client to pass in handles to pre-allocated
image pools for use within the component.
*/


struct _IL_FIFO_T;
typedef struct OMX_PARAM_RUTILFIFOINFOTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   struct _IL_FIFO_T *pILFifo;
} OMX_PARAM_RUTILFIFOINFOTYPE;

/* OMX_IndexParamILFifoConfig: Allows configuration of the FIFO settings. */
typedef struct OMX_PARAM_ILFIFOCONFIG {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nDataSize;         /**< The size of the FIFO's data area */
   OMX_U32 nHeaderCount;      /**< The number of headers allocated */
} OMX_PARAM_ILFIFOCONFIG;
/**
 * Allows configuring the size of the ILFIFO used in a component.
 */

/* OMX_IndexConfigCameraSensorModes: Camera Sensor Mode */
typedef struct OMX_CONFIG_CAMERASENSORMODETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nModeIndex;
   OMX_U32 nNumModes;
   OMX_U32 nWidth;
   OMX_U32 nHeight;
   OMX_U32 nPaddingRight;
   OMX_U32 nPaddingDown;
   OMX_COLOR_FORMATTYPE eColorFormat;
   OMX_U32 nFrameRateMax;
   OMX_U32 nFrameRateMin;
} OMX_CONFIG_CAMERASENSORMODETYPE;
/*
This parameter is used by clients to determine the sensor mode, and
hence the memory usage, of the camera module. This is primarily used
for determining the size of the input image pool.

It can be used in two ways dependent on \code{nPortIndex}. If
\code{nPortIndex} is \code{OMX_ALL}, it returns the sensor mode
corresponding to \code{nModeIndex}, and the number of modes in
\code{nNumModes}. If \code{nModeIndex} is greater than or equal to
\code{nNumModes} only \code{nNumModes} is returned. If
\code{nPortIndex} is equal to a camera video output port index, it
returns the sensor mode that would be selected for the values
currently in \code{OMX_IndexParamPortDefinition} for that port.

The \code{nPaddingRight} and \code{nPaddingDown} values determine the
extra padding the sensor adds to the image. These values must be added
to \code{nWidth} and \code{nHeight} respectively if the client is
specifying the input image pool size.
*/

typedef struct OMX_BRCMBUFFERSTATSTYPE {
   OMX_U32 nOrdinal;
   OMX_TICKS nTimeStamp;
   OMX_U32 nFilledLen;
   OMX_U32 nFlags;
   union
   {
      OMX_U32 nU32;
      struct
      {
         OMX_U32 nYpart;
         OMX_U32 nUVpart;
      } image;
   } crc;
} OMX_BRCMBUFFERSTATSTYPE;

/*
Ports that gather statistics for debugging and diagnostics
might also collect information about buffer header fields
and data.

Note that:

The \code{nOrdinal} field increases monotonically whenever
a new buffer is received or emitted and shall not be reset
upon a port flush.

The \code{nFilledLen} might indicate the size of a data area
larger than the data area that actually contributed to the
checksums (e.g. when image data is provided with cropping
information).
*/

/* OMX_IndexConfigBrcmPortBufferStats: Query port buffer stats history */
typedef struct OMX_CONFIG_BRCMPORTBUFFERSTATSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nCount;
   OMX_BRCMBUFFERSTATSTYPE sData[1];
} OMX_CONFIG_BRCMPORTBUFFERSTATSTYPE;
/*
Ports that gather statistics for debugging and diagnostics
might also collect information about buffer header fields
and data.

The \code{sStatsData} field is a variable length array and
the number of items is denoted by \code{nStatsCount}.
*/

/* OMX_IndexConfigBrcmPortStats: Query port statistics */
typedef struct OMX_CONFIG_BRCMPORTSTATSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nImageCount;
   OMX_U32 nBufferCount;
   OMX_U32 nFrameCount;
   OMX_U32 nFrameSkips;
   OMX_U32 nDiscards;
   OMX_U32 nEOS;
   OMX_U32 nMaxFrameSize;

   OMX_TICKS nByteCount;
   OMX_TICKS nMaxTimeDelta;
   OMX_U32 nCorruptMBs;   /**< Number of corrupt macroblocks in the stream */
} OMX_CONFIG_BRCMPORTSTATSTYPE;
/*
Some ports gather various statistics that can be used by clients for
debugging purposes.  This structure is the set of all statistics that
are gathered.

The \code{nFrameSkips} field indicates the number of frames that did
not have an expected PTS value based on the port frame rate.

The \code{nByteCount} field is a 64 bit value, that will either use a
64 bit type or two 32 bit types, similarly to \code{OMX_TICKS}.
*/

/* OMX_IndexConfigBrcmClockMissCount: Missed clock request accounting */
/*
For each port on the clock component, requests for media times may be
made.  These are typically done one per video frame to allow for
scheduling the display of that frame at the correct time.  If a
request is made after the time has occurred, then that frame will be
displayed late, and the clock component keeps a per-port record of the
number of times this occurs.  This record can be read using this
index.
*/

typedef struct OMX_CONFIG_BRCMCAMERASTATSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nOutFrameCount;
   OMX_U32 nDroppedFrameCount;
} OMX_CONFIG_BRCMCAMERASTATSTYPE;

// for backward compatibility
typedef struct OMX_CONFIG_BRCMCAMERASTATSTYPE OMX_CONFIG_BRCMCAMERASTATS;


#define OMX_BRCM_MAXIOPERFBANDS 10
typedef struct {
   OMX_U32 count[OMX_BRCM_MAXIOPERFBANDS];
   OMX_U32 num[OMX_BRCM_MAXIOPERFBANDS];
} OMX_BRCM_PERFSTATS;

/* OMX_IndexConfigBrcmIOPerfStats: Query I/O performance statistics */
typedef struct OMX_CONFIG_BRCMIOPERFSTATSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bEnabled;                              /**< Enable/disable I/O performance statistics */
   OMX_BRCM_PERFSTATS write; /**< count:bytes     num:microseconds */
   OMX_BRCM_PERFSTATS flush; /**< count:frequency num:microseconds waiting to flush data */
   OMX_BRCM_PERFSTATS wait;  /**< count:frequency num:microseconds waiting in calling function */
} OMX_CONFIG_BRCMIOPERFSTATSTYPE;
/*
A sink component can gather various statistics about I/O (eg. file media) performance that can be used by
clients for debugging purposes.  The \code{bEnabled} field is used to turn the gathering of statistics
on/off.
*/

typedef struct OMX_CONFIG_SHARPNESSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_S32 nSharpness;
} OMX_CONFIG_SHARPNESSTYPE;

/* OMX_IndexConfigCommonFlickerCancellation: Flicker cancellation */
typedef enum OMX_COMMONFLICKERCANCELTYPE {
   OMX_COMMONFLICKERCANCEL_OFF,
   OMX_COMMONFLICKERCANCEL_AUTO,
   OMX_COMMONFLICKERCANCEL_50,
   OMX_COMMONFLICKERCANCEL_60,
   OMX_COMMONFLICKERCANCEL_DUMMY = 0x7FFFFFFF
} OMX_COMMONFLICKERCANCELTYPE;

typedef struct OMX_CONFIG_FLICKERCANCELTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_COMMONFLICKERCANCELTYPE eFlickerCancel;
} OMX_CONFIG_FLICKERCANCELTYPE;
/*
Query / set the flicker cancellation frequency. Values are defined for Off,
50Hz, 60Hz, or auto. The method for auto detecting the flicker frequency is
not defined, and currently results in the feature being turned off.
*/

/* OMX_IndexConfigCommonRedEyeRemoval: Red eye removal/reduction */
typedef enum OMX_REDEYEREMOVALTYPE {
   OMX_RedEyeRemovalNone,                           /**< No red eye removal */
   OMX_RedEyeRemovalOn,                             /**< Red eye removal on */
   OMX_RedEyeRemovalAuto,                           /**< Red eye removal will be done automatically when detected */
   OMX_RedEyeRemovalKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_RedEyeRemovalVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_RedEyeRemovalSimple,                         /**< Use simple red eye reduction mechanism if supported by algorithm */
   OMX_RedEyeRemovalMax = 0x7FFFFFFF
} OMX_REDEYEREMOVALTYPE;

typedef struct OMX_CONFIG_REDEYEREMOVALTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_REDEYEREMOVALTYPE eMode;
} OMX_CONFIG_REDEYEREMOVALTYPE;
/*
   Configures the red eye reduction algorithm in the camera processing
   pipeline. The stage is only enabled if the flash mode is not FlashOff.
   The OMX_RedEyeRemovalSimple mode requests that the algorithm uses a
   reduced complexity algorithm to reduce the processing time.
*/


typedef enum OMX_FACEDETECTIONCONTROLTYPE {
   OMX_FaceDetectionControlNone,                           /**< Disables face detection */
   OMX_FaceDetectionControlOn,                             /**< Enables face detection */
   OMX_FaceDetectionControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_FaceDetectionControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_FaceDetectionControlMax = 0x7FFFFFFF
} OMX_FACEDETECTIONCONTROLTYPE;

typedef struct OMX_CONFIG_FACEDETECTIONCONTROLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_FACEDETECTIONCONTROLTYPE eMode;
   OMX_U32 nFrames;      /**< number of frames to apply this setting for,
                              0 for unlimited */
   OMX_U32 nMaxRegions;  /**< maximum number of regions to detect, 0 for unlimited */
   OMX_U32 nQuality;     /**< hint for algorithmic complexity, range is 0-100.
                              0 for simplest algorithm, 100 for best quality */
} OMX_CONFIG_FACEDETECTIONCONTROLTYPE;

typedef enum OMX_FACEREGIONFLAGSTYPE {
   OMX_FaceRegionFlagsNone    = 0,
   OMX_FaceRegionFlagsBlink   = 1,
   OMX_FaceRegionFlagsSmile   = 2,
   OMX_FaceRegionFlagsKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_FaceRegionFlagsVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_FaceRegionFlagsMax = 0x7FFFFFFF
} OMX_FACEREGIONFLAGSTYPE;

typedef struct OMX_FACEREGIONTYPE {
   OMX_S16 nLeft;              /**< X Coordinate of the top left corner of the rectangle */
   OMX_S16 nTop;               /**< Y Coordinate of the top left corner of the rectangle */
   OMX_U16 nWidth;             /**< Width of the rectangle */
   OMX_U16 nHeight;            /**< Height of the rectangle */
   OMX_FACEREGIONFLAGSTYPE nFlags;  /**< Flags for the region */
#ifndef OMX_SKIP64BIT
   OMX_U64 nFaceRecognitionId; /**< ID returned by face recognition for this face */
#else
   struct
   {
      OMX_U32 nLowPart;   /**< low bits of the signed 64 bit value */
      OMX_U32 nHighPart;  /**< high bits of the signed 64 bit value */
   } nFaceRecognitionId;
#endif
} OMX_FACEREGIONTYPE;

typedef struct OMX_CONFIG_FACEDETECTIONREGIONTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;            /**< index of port with face detection enabled */
   OMX_U32 nIndex;                /**< first requested region number, allowing retrieval of many regions
                                       over several requests */
   OMX_U32 nDetectedRegions;      /**< total number of detected regions */
   OMX_S32 nValidRegions;         /**< number of valid regions in sRegion array
                                       When getting, the client sets this to the number of regions available.
                                       The component writes region data and updates this field with how many
                                       regions have been written to. */
   OMX_U32 nImageWidth;           /**< Width of the image, hence reference for the face coordinates */
   OMX_U32 nImageHeight;          /**< Height of the image, hence reference for the face coordinates */
   OMX_FACEREGIONTYPE sRegion[1]; /**< variable length array of face regions */
} OMX_CONFIG_FACEDETECTIONREGIONTYPE;

typedef enum OMX_INTERLACETYPE {
   OMX_InterlaceProgressive,                    /**< The data is not interlaced, it is progressive scan */
   OMX_InterlaceFieldSingleUpperFirst,          /**< The data is interlaced, fields sent
                                                     separately in temporal order, with upper field first */
   OMX_InterlaceFieldSingleLowerFirst,          /**< The data is interlaced, fields sent
                                                     separately in temporal order, with lower field first */
   OMX_InterlaceFieldsInterleavedUpperFirst,    /**< The data is interlaced, two fields sent together line
                                                     interleaved, with the upper field temporally earlier */
   OMX_InterlaceFieldsInterleavedLowerFirst,    /**< The data is interlaced, two fields sent together line
                                                     interleaved, with the lower field temporally earlier */
   OMX_InterlaceMixed,                          /**< The stream may contain a mixture of progressive
                                                     and interlaced frames */
   OMX_InterlaceKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_InterlaceVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_InterlaceMax = 0x7FFFFFFF
} OMX_INTERLACETYPE;

typedef struct OMX_CONFIG_INTERLACETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;            /**< index of port emitting or accepting the content */
   OMX_INTERLACETYPE eMode;       /**< The interlace type of the content */
   OMX_BOOL bRepeatFirstField;    /**< Whether to repeat the first field */
} OMX_CONFIG_INTERLACETYPE;

/* OMX_IndexParamIspTuner: Custom ISP tuner */
typedef struct OMX_PARAM_CAMERAISPTUNERTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U8 tuner_name[64];
} OMX_PARAM_CAMERAISPTUNERTYPE;
/*
This parameter allows a custom ISP tuner to be loaded instead of
the default one specified for the camera module. Setting an empty
string uses the default value.
*/

/* OMX_IndexConfigCameraInputFrame: Pointer to the raw input image */
typedef struct OMX_CONFIG_IMAGEPTRTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_PTR pImage;
} OMX_CONFIG_IMAGEPTRTYPE;
/*
This parameter parameter allows the return of a pointer to a
VideoCore image resource.
*/

/* OMX_IndexConfigAFAssistLight: Autofocus assist light mode selection */
typedef enum OMX_AFASSISTTYPE {
   OMX_AFAssistAuto,
   OMX_AFAssistOn,
   OMX_AFAssistOff,
   OMX_AFAssistTorch,
   OMX_AFAssistKhronosExtensions = 0x6F000000,
   OMX_AFAssistVendorStartUnused = 0x7F000000,
   OMX_AFAssistMax = 0x7FFFFFFF
} OMX_AFASSISTTYPE;

typedef struct OMX_CONFIG_AFASSISTTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_AFASSISTTYPE eMode;
} OMX_CONFIG_AFASSISTTYPE;
/*
Set the mode to adopt for the autofocus assist light.
\code{OMX_AFAssistTorch} will turn the AF assist light on permanently, allowing
it to be used as a torch.
*/

/* OMX_IndexConfigInputCropPercentage: Specify input crop as a percentage */
typedef struct OMX_CONFIG_INPUTCROPTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 xLeft;     /**< Fraction of the width for the top left corner of the rectangle */
   OMX_U32 xTop;      /**< Fraction of the height for the top left corner of the rectangle */
   OMX_U32 xWidth;    /**< Fraction of the image width desired */
   OMX_U32 xHeight;   /**< Fraction of the image height desired */
} OMX_CONFIG_INPUTCROPTYPE;
/*
This parameter allows the input cropping to be specified as a
percentage of the current width/height.  Required for the camera
component where the output resolution varies dependent on the port.
All percentage values are as 16p16 fixed point numbers (0x10000 =
100\%)
*/

/* OMX_IndexParamCodecRequirements: Advanced codec requirements */
typedef struct OMX_PARAM_CODECREQUIREMENTSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nCallbackID;
   OMX_BOOL bTryHWCodec;
} OMX_PARAM_CODECREQUIREMENTSTYPE;
/*
This parameter allows internal users of RIL components controlling
video codecs to request that the component loads the component and
queries for requirements.  The component will perform a callback with
the given nCallbackID value passing a pointer to the requirements
structure as the data field.
*/

/* OMX_IndexConfigBrcmEGLImageMemHandle: Mapping from an EGLImage to a VideoCore mem handle */
typedef struct OMX_CONFIG_BRCMEGLIMAGEMEMHANDLETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_PTR eglImage;
   OMX_PTR memHandle;
} OMX_CONFIG_BRCMEGLIMAGEMEMHANDLETYPE;
/*
This config allows the EGL server to notify a RIL component that an
EGLImage is available for rendering into and to provide a mapping from
an EGLImage to a mem handle.
*/

/* OMX_IndexConfigPrivacyIndicator: Privacy indicator control */
typedef enum OMX_PRIVACYINDICATORTYPE {
   OMX_PrivacyIndicatorOff,
   OMX_PrivacyIndicatorOn,
   OMX_PrivacyIndicatorForceOn,
   OMX_PrivacyIndicatorKhronosExtensions = 0x6F000000,
   OMX_PrivacyIndicatorVendorStartUnused = 0x7F000000,
   OMX_PrivacyIndicatorMax = 0x7FFFFFFF
} OMX_PRIVACYINDICATORTYPE;

typedef struct OMX_CONFIG_PRIVACYINDICATORTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_PRIVACYINDICATORTYPE ePrivacyIndicatorMode;
} OMX_CONFIG_PRIVACYINDICATORTYPE;
/*
This config allows control over the privacy indicator light.  This
light indicates when a capture is in progress.

\code{OMX_PrivacyIndicatorOff} indicator is disabled.

\code{OMX_PrivacyIndicatorOn} indicator will be
turned on whenever an image is being captured as determined by the
capturing bit. Minimum on duration of approx 200ms.

\code{OMX_PrivacyIndicatorForceOn} results in turning the indicator on
immediately, whether an image is being captured or not. The mode will
automatically revert to \code{OMX_PrivacyIndicatorOff} once the
indicator has been turned on, so \code{OMX_PrivacyIndicatorForceOn}
must be requested at least every 200ms if the indicator is to remain
on.
*/


/* OMX_IndexParamCameraFlashType: Select flash type */
typedef enum OMX_CAMERAFLASHTYPE {
   OMX_CameraFlashDefault,
   OMX_CameraFlashXenon,
   OMX_CameraFlashLED,
   OMX_CameraFlashNone,
   OMX_CameraFlashKhronosExtensions = 0x6F000000,
   OMX_CameraFlashVendorStartUnused = 0x7F000000,
   OMX_CameraFlashMax = 0x7FFFFFFF
} OMX_CAMERAFLASHTYPE;

typedef struct OMX_PARAM_CAMERAFLASHTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_CAMERAFLASHTYPE eFlashType;
   OMX_BOOL bRedEyeUsesTorchMode;
} OMX_PARAM_CAMERAFLASHTYPE;
/*
This parameter allows the selection of xenon or LED flash devices
to be used with the currently selected camera. If that device is not
available, then the component will revert back to whatever flash
device is available for that camera.
\code{bRedEyeUsesTorchMode} allows the blinking for red eye reduction to
be switched between using the indicator mode, and the torch mode for the
flash driver.
*/

/* OMX_IndexConfigCameraFlashConfig: Flash cycle configuration */
typedef enum OMX_CAMERAFLASHCONFIGSYNCTYPE {
   OMX_CameraFlashConfigSyncFrontSlow,
   OMX_CameraFlashConfigSyncRearSlow,
   OMX_CameraFlashConfigSyncFrontFast,
   OMX_CameraFlashConfigSyncKhronosExtensions = 0x6F000000,
   OMX_CameraFlashConfigSyncVendorStartUnused = 0x7F000000,
   OMX_CameraFlashConfigSyncMax = 0x7FFFFFFF
} OMX_CAMERAFLASHCONFIGSYNCTYPE;

typedef struct OMX_CONFIG_CAMERAFLASHCONFIGTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bUsePreFlash;
   OMX_BOOL bUseFocusDistanceInfo;
   OMX_CAMERAFLASHCONFIGSYNCTYPE eFlashSync;
   OMX_BOOL bIgnoreChargeState;
} OMX_CONFIG_CAMERAFLASHCONFIGTYPE;
/*
This parameter allows the configuration of various parameters relating to
the flash cycle. Some of the options are only applicable to xenon flash.

\code{bUsePreFlash} uses a low intensity pre-flash to determine flash intensity. This setting
is recommended for almost all flash situations.

\code{bUseFocusDistanceInfo} uses the distance of the subject, as measured by the AF algorithm
to set the intensity of the flash.

\code{eFlashSync} configures which edge of the shutter is used to synchronise the flash, and
the duration of the exposure.

\code{eIgnoreChargeState} will make the flash fire, even if it is not fully charged.
*/

/* OMX_IndexConfigBrcmAudioTrackGaplessPlayback: Encoder/decoder delay and padding information for gapless playback. */
typedef struct OMX_CONFIG_BRCMAUDIOTRACKGAPLESSPLAYBACKTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nDelay;   /**< number of samples delay added by the codec */
   OMX_U32 nPadding; /**< number of silent samples added to the end */
} OMX_CONFIG_BRCMAUDIOTRACKGAPLESSPLAYBACKTYPE;
/*
This config allows communication between components to facilitate gapless playback.
*/


/* OMX_IndexConfigBrcmAudioTrackChangeControl: Configure gapless/crossfaded audio track change. */
typedef struct OMX_CONFIG_BRCMAUDIOTRACKCHANGECONTROLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nSrcPortIndex;
   OMX_U32 nDstPortIndex;
   OMX_U32 nXFade;
} OMX_CONFIG_BRCMAUDIOTRACKCHANGECONTROLTYPE;
/*
This config allows the client to specify the gapless or crossfade
parameters to be used on a track change.  If \code{nXFade} is 0, then
a normal or gapless track change will result, otherwise a crossfade of
\code{nXFade} ms is used.
*/

/* OMX_IndexParamBrcmPixelValueRange: Describing the pixel value range */
typedef enum OMX_BRCMPIXELVALUERANGETYPE
{
   OMX_PixelValueRangeUnspecified = 0,
   OMX_PixelValueRangeITU_R_BT601,
   OMX_PixelValueRangeFull8Bit,
   OMX_PixelValueRangeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_PixelValueRangeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_PixelValueRangeMax = 0x7FFFFFFF
} OMX_BRCMPIXELVALUERANGETYPE;

typedef struct OMX_PARAM_BRCMPIXELVALUERANGETYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BRCMPIXELVALUERANGETYPE ePixelValueRange;
} OMX_PARAM_BRCMPIXELVALUERANGETYPE;
/*
This structure allows a description of the range that pixel values may
have.  This is typically useful since some standards use the full 8
bit range, whereas others introduce pedastals which reduce the range
at the top and bottom end.
*/

/* OMX_IndexParamCameraDisableAlgorithm: Disabling camera processing stages. */
typedef enum OMX_CAMERADISABLEALGORITHMTYPE {
      OMX_CameraDisableAlgorithmFacetracking,
      OMX_CameraDisableAlgorithmRedEyeReduction,
      OMX_CameraDisableAlgorithmVideoStabilisation,
      OMX_CameraDisableAlgorithmWriteRaw,
      OMX_CameraDisableAlgorithmVideoDenoise,
      OMX_CameraDisableAlgorithmStillsDenoise,
      OMX_CameraDisableAlgorithmAntiShake,
      OMX_CameraDisableAlgorithmImageEffects,
      OMX_CameraDisableAlgorithmDarkSubtract,
      OMX_CameraDisableAlgorithmDynamicRangeExpansion,
      OMX_CameraDisableAlgorithmFaceRecognition,
      OMX_CameraDisableAlgorithmFaceBeautification,
      OMX_CameraDisableAlgorithmSceneDetection,
      OMX_CameraDisableAlgorithmHighDynamicRange,
   OMX_CameraDisableAlgorithmKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_CameraDisableAlgorithmVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_CameraDisableAlgorithmMax = 0x7FFFFFFF
} OMX_CAMERADISABLEALGORITHMTYPE;

typedef struct OMX_PARAM_CAMERADISABLEALGORITHMTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_CAMERADISABLEALGORITHMTYPE eAlgorithm;
   OMX_BOOL bDisabled;
} OMX_PARAM_CAMERADISABLEALGORITHMTYPE;
/*
Allows plugin algorithms to be disabled to save memory
within the camera component
*/

/* OMX_IndexConfigBrcmAudioEffectControl: Audio Effect Control */
typedef struct OMX_CONFIG_BRCMAUDIOEFFECTCONTROLTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bEnable;
   OMX_U8 name[16];
   OMX_U8 property[256];
} OMX_CONFIG_BRCMAUDIOEFFECTCONTROLTYPE;
/*
This structure represents the internal configuration of an audio effect.
The audio effect is provided by a loadable plug-in described
in the \code{name} field and is configured in a plug-in-dependent
manner with the \code{property} field. The \code{bEnable} field is used to
turn the effect on/off.
*/

/* OMX_IndexConfigBrcmMinimumProcessingLatency: Processing Latency Bound */
typedef struct OMX_CONFIG_BRCMMINIMUMPROCESSINGLATENCY {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_TICKS nOffset;
} OMX_CONFIG_BRCMMINIMUMPROCESSINGLATENCY;
/*
Query/set the difference between the actual media time and when the
component receives request fulfillments for media time requests. This
can be used with e.g. splitter/mixer components to control when the
component stops waiting for input or output packets from active
streams and continues with processing (to maintain a constant
processing rate).
*/

/** Enable or disable Supplemental Enhancment Information (SEI) messages to be inserted in
  * the H.264 bitstream.
  */
typedef struct OMX_PARAM_BRCMVIDEOAVCSEIENABLETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bEnable;
} OMX_PARAM_BRCMVIDEOAVCSEIENABLETYPE;

/* OMX_IndexParamBrcmAllowMemChange: Allowing changing memory allocation on state transition */
typedef struct OMX_PARAM_BRCMALLOWMEMCHANGETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bEnable;
} OMX_PARAM_BRCMALLOWMEMCHANGETYPE;
/*
Let the component change the amount of memory it has allocated when
going from LOADED to IDLE. By default this is enabled, but if it is
disabled the component will fail to transition to IDLE if the
component requires more memory than has already been allocated.  This
might occur if (for example) the component was configured, taken to
IDLE, then taken back to LOADED, the profile increased and the
component taken back to IDLE.
*/

typedef enum OMX_CONFIG_CAMERAUSECASE {
   OMX_CameraUseCaseAuto,
   OMX_CameraUseCaseVideo,
   OMX_CameraUseCaseStills,
   OMX_CameraUseCaseKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_CameraUseCaseVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_CameraUseCaseMax = 0x7FFFFFFF
} OMX_CONFIG_CAMERAUSECASE;

typedef struct OMX_CONFIG_CAMERAUSECASETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_CONFIG_CAMERAUSECASE eUseCase;
} OMX_CONFIG_CAMERAUSECASETYPE;

/* OMX_IndexParamBrcmDisableProprietaryTunnels: Disabling proprietary tunnelling */
typedef struct OMX_PARAM_BRCMDISABLEPROPRIETARYTUNNELSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bUseBuffers;
}  OMX_PARAM_BRCMDISABLEPROPRIETARYTUNNELSTYPE;
/*
Tell a source component to refuse to support proprietary tunnelling. Buffers will be used instead.
*/


//
// Control for memory allocation and component-internal buffering
//

/* OMX_IndexParamBrcmRetainMemory: Controlling memory use on state transition */
typedef struct OMX_PARAM_BRCMRETAINMEMORYTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bEnable;
} OMX_PARAM_BRCMRETAINMEMORYTYPE;
/*
Ask a component to retain its memory when going from IDLE to LOADED, if possible.
This has the benefit that you are then guaranteed that the transition to IDLE cannot
fail due to lack of memory, but has the disadvantage that you cannot leave the component
lying around in LOADED, unused, since it is using significant amounts of memory.
*/

/** Tell write media how large the output buffer should be. This is a hint, and
  * may be ignored. A good size is bandwidth*<SDcard-delay>, which works out at
  * around 1Mbyte for up to 16Mbit/s. Sizes may (and probably will) be rounded down
  * to the nearest power of 2.
  */
typedef struct OMX_PARAM_BRCMOUTPUTBUFFERSIZETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nBufferSize;
} OMX_PARAM_BRCMOUTPUTBUFFERSIZETYPE;

/* OMX_IndexConfigCameraInfo: Camera device driver information */
#define OMX_CONFIG_CAMERAINFOTYPE_NAME_LEN 16
typedef struct OMX_CONFIG_LENSCALIBRATIONVALUETYPE
{
   OMX_U16  nShutterDelayTime;
   OMX_U16  nNdTransparency;
   OMX_U16  nPwmPulseNearEnd;  /**< Num pulses to move lens 1um at near end */
   OMX_U16  nPwmPulseFarEnd;   /**< Num pulses to move lens 1um at far end */
   OMX_U16  nVoltagePIOutNearEnd[3];
   OMX_U16  nVoltagePIOut10cm[3];
   OMX_U16  nVoltagePIOutInfinity[3];
   OMX_U16  nVoltagePIOutFarEnd[3];
   OMX_U32  nAdcConversionNearEnd;
   OMX_U32  nAdcConversionFarEnd;
} OMX_CONFIG_LENSCALIBRATIONVALUETYPE;
/*
Ask the camera component for the driver info on the current camera device
*/

#define OMX_CONFIG_CAMERAINFOTYPE_NAME_LEN 16
#define OMX_CONFIG_CAMERAINFOTYPE_SERIALNUM_LEN 20
#define OMX_CONFIG_CAMERAINFOTYPE_EPROMVER_LEN 8
typedef struct OMX_CONFIG_CAMERAINFOTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U8 cameraname[OMX_CONFIG_CAMERAINFOTYPE_NAME_LEN];
   OMX_U8 lensname[OMX_CONFIG_CAMERAINFOTYPE_NAME_LEN];
   OMX_U16 nModelId;
   OMX_U8 nManufacturerId;
   OMX_U8 nRevNum;
   OMX_U8 sSerialNumber[OMX_CONFIG_CAMERAINFOTYPE_SERIALNUM_LEN];
   OMX_U8 sEpromVersion[OMX_CONFIG_CAMERAINFOTYPE_EPROMVER_LEN];
   OMX_CONFIG_LENSCALIBRATIONVALUETYPE sLensCalibration;
   OMX_U32 xFNumber;
   OMX_U32 xFocalLength;
} OMX_CONFIG_CAMERAINFOTYPE;


typedef enum OMX_CONFIG_CAMERAFEATURESSHUTTER {
   OMX_CameraFeaturesShutterUnknown,
   OMX_CameraFeaturesShutterNotPresent,
   OMX_CameraFeaturesShutterPresent,
   OMX_CameraFeaturesShutterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_CameraFeaturesShutterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_CameraFeaturesShutterMax = 0x7FFFFFFF
} OMX_CONFIG_CAMERAFEATURESSHUTTER;

typedef struct OMX_CONFIG_CAMERAFEATURESTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_CONFIG_CAMERAFEATURESSHUTTER eHasMechanicalShutter;
   OMX_BOOL bHasLens;
} OMX_CONFIG_CAMERAFEATURESTYPE;


//Should be added to the spec as part of IL416c
/* OMX_IndexConfigRequestCallback: Enable config change notifications. */
typedef struct OMX_CONFIG_REQUESTCALLBACKTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_INDEXTYPE nIndex;
   OMX_BOOL bEnable;
} OMX_CONFIG_REQUESTCALLBACKTYPE;
/*
This config implements IL416c to allow clients to request notification
of when a config or parameter is changed. When the parameter specified
in \code{nIndex} for port \code{nPortIndex} changes, an
\code{OMX_EventParamOrConfigChanged} event is generated for the client.
*/

/* OMX_IndexConfigCommonFocusRegionXY: Define focus regions */
typedef enum OMX_FOCUSREGIONTYPE {
   OMX_FocusRegionNormal,
   OMX_FocusRegionFace,
   OMX_FocusRegionMax
} OMX_FOCUSREGIONTYPE;

typedef struct OMX_FOCUSREGIONXY {
   OMX_U32 xLeft;
   OMX_U32 xTop;
   OMX_U32 xWidth;
   OMX_U32 xHeight;
   OMX_U32 nWeight;
   OMX_U32 nMask;
   OMX_FOCUSREGIONTYPE eType;
} OMX_FOCUSREGIONXY;

typedef struct OMX_CONFIG_FOCUSREGIONXYTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nIndex;
   OMX_U32 nTotalRegions;
   OMX_S32 nValidRegions;
   OMX_BOOL bLockToFaces;
   OMX_U32 xFaceTolerance;
   OMX_FOCUSREGIONXY sRegion[1];
} OMX_CONFIG_FOCUSREGIONXYTYPE;
/*
Query / set the focus regions to use as a set of x/y/width/height boxes relative
to the overall image.

\code{nIndex} - first region number being set/read, allowing retrieval/setting
of many regions over several requests.

\code{nTotalRegions} - total number of regions currently defined.

\code{nValidRegions} - number of valid regions in the \code{sRegion} array.
When getting, the client sets this to the number of regions available.
The component writes region data and updates this field with how many
regions have been written to.
When setting, this is the number of regions defined with this structure

\code{bLockToFaces} - compare the region(s) given to the latest face tracking results.
If a face is found within xFaceTolerance of the defined region, then amend the
region to correspond to the face.

\code{xFaceTolerance} - 0p16 value to define the max difference between the region centre
and face tracking result centre to take the FT results

\code{sRegions} - variable length array of focus regions.
*/

typedef struct OMX_CONFIG_U8TYPE {
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
    OMX_U32 nPortIndex;               /**< port that this structure applies to */
    OMX_U8  nU8;                     /**< U8 value */
} OMX_PARAM_U8TYPE;

typedef struct OMX_CONFIG_CAMERASETTINGSTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;               /**< port that this structure applies to */
    OMX_U32 nExposure;
    OMX_U32 nAnalogGain;
    OMX_U32 nDigitalGain;
    OMX_U32 nLux;
    OMX_U32 nRedGain;
    OMX_U32 nBlueGain;
    OMX_U32 nFocusPosition;
} OMX_CONFIG_CAMERASETTINGSTYPE;

/* OMX_IndexConfigDrawBoxLineParams: Face box style parameters. */
typedef struct OMX_YUVCOLOUR {
   OMX_U8 nY;
   OMX_U8 nU;
   OMX_U8 nV;
} OMX_YUVCOLOUR;

typedef struct OMX_CONFIG_DRAWBOXLINEPARAMS {
    OMX_U32 nSize;                           /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;                /**< OMX specification version information */
    OMX_U32 nPortIndex;                      /**< Port to which this config applies */
    OMX_U32 xCornerSize;                     /**< Size of the corners as a fraction of the complete side */
    OMX_U32 nPrimaryFaceLineWidth;           /**< Width of the box line for the primary face in pixels */
    OMX_U32 nOtherFaceLineWidth;             /**< Width of the box line for other faces in pixels */
    OMX_U32 nFocusRegionLineWidth;           /**< Width of the box line for focus regions in pixels */
    OMX_YUVCOLOUR sPrimaryFaceColour;        /**< YUV colour for the primary face */
    OMX_YUVCOLOUR sPrimaryFaceSmileColour;   /**< YUV colour for the primary face if smiling */
    OMX_YUVCOLOUR sPrimaryFaceBlinkColour;   /**< YUV colour for the primary face if blinking */
    OMX_YUVCOLOUR sOtherFaceColour;          /**< YUV colour for the all other faces */
    OMX_YUVCOLOUR sOtherFaceSmileColour;     /**< YUV colour for the all other faces if smiling */
    OMX_YUVCOLOUR sOtherFaceBlinkColour;     /**< YUV colour for the all other faces if blinking */
    OMX_BOOL bShowFocusRegionsWhenIdle;      /**< Are focus regions displayed when just in viewfinder/AF idle */
    OMX_YUVCOLOUR sFocusRegionColour;        /**< YUV colour for focus regions */
    OMX_BOOL bShowAfState;                   /**< Change to the colours specified below if AF cycle has run */
    OMX_BOOL bShowOnlyPrimaryAfState;        /**< Only show the primary face when displaying the AF status */
    OMX_BOOL bCombineNonFaceRegions;         /**< Combine all regions not defined as faces into one single box covering them all */
    OMX_YUVCOLOUR sAfLockPrimaryFaceColour;  /**< YUV colour for the primary face */
    OMX_YUVCOLOUR sAfLockOtherFaceColour;    /**< YUV colour for the all other faces */
    OMX_YUVCOLOUR sAfLockFocusRegionColour;  /**< YUV colour for focus regions */
    OMX_YUVCOLOUR sAfFailPrimaryFaceColour;  /**< YUV colour for the primary face */
    OMX_YUVCOLOUR sAfFailOtherFaceColour;    /**< YUV colour for the all other faces */
    OMX_YUVCOLOUR sAfFailFocusRegionColour;  /**< YUV colour for focus regions */
 } OMX_CONFIG_DRAWBOXLINEPARAMS;
/*
Query / set the parameters for the box to be drawn around faces/focus regions.
*/

 #define OMX_PARAM_CAMERARMITYPE_RMINAME_LEN 16
 //OMX_IndexParamCameraRmiControl
 typedef struct OMX_PARAM_CAMERARMITYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_BOOL bEnabled;
    OMX_U8 sRmiName[OMX_PARAM_CAMERARMITYPE_RMINAME_LEN];
    OMX_U32 nInputBufferHeight;
    OMX_U32 nRmiBufferSize;
    OMX_BRCM_POOL_T *pImagePool;
 } OMX_PARAM_CAMERARMITYPE;

/* OMX_IndexConfigBrcmSyncOutput: Forcing a write sync */
typedef struct OMX_CONFIG_BRCMSYNCOUTPUTTYPE {
    OMX_U32 nSize;                           /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;                /**< OMX specification version information */
}  OMX_CONFIG_BRCMSYNCOUTPUTTYPE;
/*
Setting this config forces a sync of data to the filesystem.
*/

/* OMX_IndexConfigDrmView: View information for DRM rental files */
typedef struct OMX_CONFIG_DRMVIEWTYPE {
   OMX_U32 nSize;             /**< Size of this structure, in Bytes */
   OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
   OMX_U32 nCurrentView;      /**< Current view count */
   OMX_U32 nMaxView;          /**< Max. no. of view allowed */
} OMX_CONFIG_DRMVIEWTYPE;
/*
This structure contains information about the number of available
views in the selected DRM rental file, which typically have a given
maximum view count.  It allows the user to explicitly agree to playing
the file, which will increment the number of current views the file
has had.
*/

typedef struct OMX_PARAM_BRCMU64TYPE {
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
    OMX_U32 nPortIndex;               /**< port that this structure applies to */
    OMX_U32 nLowPart;                 /**< low bits of the unsigned 64 bit value */
    OMX_U32 nHighPart;                /**< high bits of the unsigned 64 bit value */
} OMX_PARAM_BRCMU64TYPE;

/* OMX_IndexParamBrcmDisableEXIF: Disable generation of EXIF data */
/*
This parameter is used by clients to control the generation of exif
data in JPEG images.
*/

/* OMX_IndexParamBrcmThumbnail: Control generation of thumbnail */
typedef struct OMX_PARAM_BRCMTHUMBNAILTYPE {
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
    OMX_BOOL bEnable;                 /**< Enable generation of thumbnails during still capture */
    OMX_BOOL bUsePreview;             /**< Use the preview image (as is) as thumbnail */
    OMX_U32 nWidth;                   /**< Desired width of the thumbnail */
    OMX_U32 nHeight;                  /**< Desired height of the thumbnail */
} OMX_PARAM_BRCMTHUMBNAILTYPE;
/*
This parameter is used by clients to control how thumbnails are
generated when creating still images.

Thumbnail generation will be turned on or off depending on the
\code{bEnable} field.

The \code{bUsePreview} field will let the component know whether it
should use the low resolution preview image (if the component has one
available) as is for the thumbnail. When this is set to true, it should
make the generation of thumbnails faster (if a preview image is available)
and should use less memory as well.

The \code{nWidth} and \code{nHeight} fields allow the client to
specify the dimensions of the thumbnail.  If both \code{nWidth} and
\code{nHeight} are 0, we will calculate a sensible size for the
thumbnail.
*/

typedef struct OMX_PARAM_BRCMASPECTRATIOTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nWidth;
    OMX_U32 nHeight;
} OMX_PARAM_BRCMASPECTRATIOTYPE;

/* OMX_IndexParamBrcmVideoDecodeErrorConcealment: Control error concealment for video decode */
typedef struct OMX_PARAM_BRCMVIDEODECODEERRORCONCEALMENTTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bStartWithValidFrame; /**< Decoder will only start emitting frames from a non-corrupted frame */
} OMX_PARAM_BRCMVIDEODECODEERRORCONCEALMENTTYPE;
/*
 This parameter is used by clients to control the type of error concealment
 that will be done by the video decoder.
 */

#define OMX_CONFIG_FLASHINFOTYPE_NAME_LEN 16
typedef struct OMX_CONFIG_FLASHINFOTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U8 sFlashName[OMX_CONFIG_FLASHINFOTYPE_NAME_LEN];
   OMX_CAMERAFLASHTYPE eFlashType;
   OMX_U8 nDeviceId;
   OMX_U8 nDeviceVersion;
} OMX_CONFIG_FLASHINFOTYPE;

/* OMX_IndexParamBrcmInterpolateMissingTimestamps: Configure component to interpolate missing timestamps */
/*
Configures a component so that it tries to timestamp all the buffers it outputs.
If the timestamp information is missing from the original buffer, the
component will try its best to interpolate a value for the missing timestamp.
 */

/* OMX_IndexParamBrcmSetCodecPerformanceMonitoring: Configure component to output performance statistics */
/*
Configures a codec component so that it outputs performance statistics to
the given DECODE_PROGRESS_REPORT_T structure (passed as a pointer).
This structure can then be read by the client to find out where the codec is
at in its processing.
 */

/* OMX_IndexConfigDynamicRangeExpansion: Configure image dynamic range expansion processing */
typedef enum OMX_DYNAMICRANGEEXPANSIONMODETYPE {
   OMX_DynRangeExpOff,
   OMX_DynRangeExpLow,
   OMX_DynRangeExpMedium,
   OMX_DynRangeExpHigh,
   OMX_DynRangeExpKhronosExtensions = 0x6F000000,
   OMX_DynRangeExpVendorStartUnused = 0x7F000000,
   OMX_DynRangeExpMax = 0x7FFFFFFF
} OMX_DYNAMICRANGEEXPANSIONMODETYPE;

typedef struct OMX_CONFIG_DYNAMICRANGEEXPANSIONTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_DYNAMICRANGEEXPANSIONMODETYPE eMode;
} OMX_CONFIG_DYNAMICRANGEEXPANSIONTYPE;
/*
Configures the intensity of an image dynamic range expansion processing stage
*/

/* OMX_IndexParamBrcmTransposeBufferCount: Configure the number of pre-allocated transpose buffers  */
/*
This config allows the client to explicitly set the number of destination buffers pre-allocated for
ports that support 90/270 degree rotation (e.g. in video_render). The buffers will be pre-allocated during
a state transition from LOADED to IDLE (the transition will fail if there is not enough memory available
for the buffers).
.
*/


/* OMX_IndexParamBrcmThreadAffinity: Control the CPU affinity of component thread(s) */
typedef enum OMX_BRCMTHREADAFFINITYTYPE {
   OMX_BrcmThreadAffinityCPU0,
   OMX_BrcmThreadAffinityCPU1,
   OMX_BrcmThreadAffinityMax = 0x7FFFFFFF
} OMX_BRCMTHREADAFFINITYTYPE;

typedef struct OMX_PARAM_BRCMTHREADAFFINITYTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BRCMTHREADAFFINITYTYPE eAffinity;  /**< Thread CPU affinity */
} OMX_PARAM_BRCMTHREADAFFINITYTYPE;
/*
 This parameter is used by clients to hint the CPU that a component thread should run on.
 */

 /* OMX_IndexConfigCommonSceneDetected: Reports the scene type detected by a scene detection algorithm. */
typedef enum OMX_SCENEDETECTTYPE {
   OMX_SceneDetectUnknown,
   OMX_SceneDetectLandscape,
   OMX_SceneDetectPortrait,
   OMX_SceneDetectMacro,
   OMX_SceneDetectNight,
   OMX_SceneDetectPortraitNight,
   OMX_SceneDetectBacklit,
   OMX_SceneDetectPortraitBacklit,
   OMX_SceneDetectSunset,
   OMX_SceneDetectBeach,
   OMX_SceneDetectSnow,
   OMX_SceneDetectFireworks,
   OMX_SceneDetectMax = 0x7FFFFFFF
} OMX_SCENEDETECTTYPE;

/* OMX_IndexConfigCommonSceneDetected: Reports the scene type detected by a scene detection algorithm. */
typedef struct OMX_CONFIG_SCENEDETECTTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_SCENEDETECTTYPE eScene;  /**< Scene type detected */
} OMX_CONFIG_SCENEDETECTTYPE;
/*
 This config is used to report to clients the scene type that has been detected.
 */

/* OMX_IndexParamNalStreamFormat: Control the NAL unit packaging. This is a Khronos extension. */
typedef enum OMX_INDEXEXTTYPE {
    /* Video parameters and configurations */
    OMX_IndexExtVideoStartUnused = OMX_IndexKhronosExtensions + 0x00600000,
    OMX_IndexParamNalStreamFormatSupported,         /**< reference: OMX_NALSTREAMFORMATTYPE */
    OMX_IndexParamNalStreamFormat,                  /**< reference: OMX_NALSTREAMFORMATTYPE */
    OMX_IndexParamNalStreamFormatSelect,            /**< reference: OMX_NALSTREAMFORMATTYPE */

    OMX_IndexExtMax = 0x7FFFFFFF
} OMX_INDEXEXTTYPE;

/* OMX_IndexParamNalStreamFormat: Control the NAL unit packaging. This is a Khronos extension. */
typedef enum OMX_NALUFORMATSTYPE {
    OMX_NaluFormatStartCodes = 1,
    OMX_NaluFormatOneNaluPerBuffer = 2,
    OMX_NaluFormatOneByteInterleaveLength = 4,
    OMX_NaluFormatTwoByteInterleaveLength = 8,
    OMX_NaluFormatFourByteInterleaveLength = 16,
    OMX_NaluFormatCodingMax = 0x7FFFFFFF
} OMX_NALUFORMATSTYPE;

/* OMX_IndexParamNalStreamFormat: Control the NAL unit packaging. This is a Khronos extension. */
typedef struct OMX_NALSTREAMFORMATTYPE{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_NALUFORMATSTYPE eNaluFormat;
} OMX_NALSTREAMFORMATTYPE;
/*
 This parameter is used to control the NAL unit packaging of an H264 video port.
 */

/* OMX_IndexParamVideoMvc: MVC codec parameters */
typedef  struct OMX_VIDEO_PARAM_AVCTYPE  OMX_VIDEO_PARAM_MVCTYPE;
/*
This parameter is currently identical to the AVC parameter type.
*/

 /* OMX_IndexConfigBrcmDrawStaticBox: Define static box to be drawn */
typedef enum OMX_STATICBOXTYPE {
   OMX_StaticBoxNormal,
   OMX_StaticBoxPrimaryFaceAfIdle,
   OMX_StaticBoxNonPrimaryFaceAfIdle,
   OMX_StaticBoxFocusRegionAfIdle,
   OMX_StaticBoxPrimaryFaceAfSuccess,
   OMX_StaticBoxNonPrimaryFaceAfSuccess,
   OMX_StaticBoxFocusRegionAfSuccess,
   OMX_StaticBoxPrimaryFaceAfFail,
   OMX_StaticBoxNonPrimaryFaceAfFail,
   OMX_StaticBoxFocusRegionAfFail,
   OMX_StaticBoxMax
} OMX_STATICBOXTYPE;

typedef struct OMX_STATICBOX {
   OMX_U32 xLeft;
   OMX_U32 xTop;
   OMX_U32 xWidth;
   OMX_U32 xHeight;
   OMX_STATICBOXTYPE eType;
} OMX_STATICBOX;

typedef struct OMX_CONFIG_STATICBOXTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nIndex;
   OMX_U32 nTotalBoxes;
   OMX_S32 nValidBoxes;
   OMX_BOOL bDrawOtherBoxes;
   OMX_STATICBOX sBoxes[1];
} OMX_CONFIG_STATICBOXTYPE;
/*
Query / set the parameters for a box to always be drawn on viewfinder images
The x/y/width/height values for the boxes are relative to the overall image.

\code{nIndex} - first box number being set/read, allowing retrieval/setting
of many boxes over several requests.

\code{nValidBoxes} - total number of boxes currently defined.

\code{nValidBoxes} - number of valid boxes in the \code{sBoxes} array.
When getting, the client sets this to the number of boxes available.
The component writes box data and updates this field with how many
boxes have been written to.
When setting, this is the number of boxes defined with this structure

\code{sBoxes} - variable length array of static boxes.
*/

/* OMX_IndexConfigPortCapturing: Per-port capturing state */
typedef struct OMX_CONFIG_PORTBOOLEANTYPE{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_BOOL bEnabled;
} OMX_CONFIG_PORTBOOLEANTYPE;
/*
This is proposed in IL533f for controlling
which ports of a multi-port camera component are capturing frames.
*/

/* OMX_IndexConfigCaptureMode: Capturing mode type */
typedef enum OMX_CAMERACAPTUREMODETYPE {
   OMX_CameraCaptureModeWaitForCaptureEnd,
   OMX_CameraCaptureModeWaitForCaptureEndAndUsePreviousInputImage,
   OMX_CameraCaptureModeResumeViewfinderImmediately,
   OMX_CameraCaptureModeMax,
} OMX_CAMERACAPTUREMODETYPE;

typedef struct OMX_PARAM_CAMERACAPTUREMODETYPE{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_CAMERACAPTUREMODETYPE eMode;
} OMX_PARAM_CAMERACAPTUREMODETYPE;
/*
This controls the mode of operation for
still image capture in the camera component.
*/

/* OMX_IndexParamBrcmDrmEncryption: Set DRM encryption scheme */
typedef enum OMX_BRCMDRMENCRYPTIONTYPE
{
   OMX_DrmEncryptionNone = 0,
   OMX_DrmEncryptionHdcp2,
   OMX_DrmEncryptionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_DrmEncryptionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_DrmEncryptionRangeMax = 0x7FFFFFFF
} OMX_BRCMDRMENCRYPTIONTYPE;

typedef struct OMX_PARAM_BRCMDRMENCRYPTIONTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BRCMDRMENCRYPTIONTYPE eEncryption;
   OMX_U32 nConfigDataLen;
   OMX_U8 configData[1];
} OMX_PARAM_BRCMDRMENCRYPTIONTYPE;
/*
Query/set the DRM encryption scheme used by a port writing out data.
*/


/* OMX_IndexConfigBufferStall: Advertise buffer stall state */
typedef struct OMX_CONFIG_BUFFERSTALLTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bStalled;      /**< Whether we are stalled */
   OMX_U32 nDelay;         /**< Delay in real time (us) from last buffer to current time */
} OMX_CONFIG_BUFFERSTALLTYPE;
/*
Query/set the buffer stall threashold.  When set the \code{nDelay}
parameter specifies a time to class whether buffer output is stalled.
When get, the \code{nDelay} parameter indicates the current buffer
delay, and the {bStalled} parameter indicates whether this time is
over a previously set threashold.  When
\code{OMX_IndexConfigRequestCallback} is used with this index, a
notification is given when \code{bStalled} changes.
*/

/* OMX_IndexConfigLatencyTarget: Maintain target latency by adjusting clock speed */
typedef struct OMX_CONFIG_LATENCYTARGETTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bEnabled; /**< whether this mode is enabled */
   OMX_U32 nFilter; /**< number of latency samples to filter on, good value: 1 */
   OMX_U32 nTarget; /**< target latency, us */
   OMX_U32 nShift;  /**< shift for storing latency values, good value: 7 */
   OMX_S32 nSpeedFactor; /**< multiplier for speed changes, in 24.8 format, good value: 256-512 */
   OMX_S32 nInterFactor; /**< divider for comparing latency versus gradiant, good value: 300 */
   OMX_S32 nAdjCap; /**< limit for speed change before nSpeedFactor is applied, good value: 100 */
} OMX_CONFIG_LATENCYTARGETTYPE;
/*
Query/set parameters used when adjusting clock speed to match the
measured latency to a specified value.
*/

/* OMX_IndexConfigBrcmUseProprietaryCallback: Force use of proprietary callback */
typedef struct OMX_CONFIG_BRCMUSEPROPRIETARYCALLBACKTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL bEnable;
} OMX_CONFIG_BRCMUSEPROPRIETARYCALLBACKTYPE;
/*
Disable/enable the use of proprietary callbacks rather than OpenMAX IL buffer handling.
*/

/* OMX_IndexParamCommonUseStcTimestamps: Select timestamp mode */
typedef enum OMX_TIMESTAMPMODETYPE
{
   OMX_TimestampModeZero = 0,       /**< Use a timestamp of 0 */
   OMX_TimestampModeRawStc,         /**< Use the raw STC as the timestamp */
   OMX_TimestampModeResetStc,       /**< Store the STC when video capture port goes active, and subtract that from STC for the timestamp */
   OMX_TimestampModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   OMX_TimestampModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_TimestampModeMax = 0x7FFFFFFF
} OMX_TIMESTAMPMODETYPE;

typedef struct OMX_PARAM_TIMESTAMPMODETYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_TIMESTAMPMODETYPE eTimestampMode;
} OMX_PARAM_TIMESTAMPMODETYPE;
/*
 Specifies what to use as timestamps in the absence of a clock component.
*/

/* EGL image buffer for passing to video port.
 * Used when port color format is OMX_COLOR_FormatBRCMEGL.
 */
typedef struct OMX_BRCMVEGLIMAGETYPE
{
   /* Passed between ARM + VC; use fixed width types. */
   OMX_U32 nWidth;
   OMX_U32 nHeight;
   OMX_U32 nStride;
   OMX_U32 nUmemHandle;
   OMX_U32 nUmemOffset;
   OMX_U32 nFlipped;    /* Non-zero -> vertically flipped image */
} OMX_BRCMVEGLIMAGETYPE;

/* Provides field of view 
 */
typedef struct OMX_CONFIG_BRCMFOVTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 xFieldOfViewHorizontal;  /**< Horizontal field of view in degrees. 16p16 value */
   OMX_U32 xFieldOfViewVertical;    /**< Vertical field of view in degrees. 16p16 value */
} OMX_CONFIG_BRCMFOVTYPE;

/* OMX_IndexConfigBrcmDecoderPassThrough: Enabling Audio Passthrough */
/*
This allows an audio decoder to disable decoding the stream and pass through correctly framed
data to enable playback of compressed audio to supported output devices.
*/

/* OMX_IndexConfigBrcmClockReferenceSource: Select Clock Reference Source */
/*
This control allows communicating directly to an audio renderer component whether it should
act as a clock reference source or act as a slave.
*/

/* OMX_IndexConfigEncLevelExtension: AVC Override encode capabilities */
typedef struct OMX_VIDEO_CONFIG_LEVEL_EXTEND {
   OMX_U32 nSize; 
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_U32 nCustomMaxMBPS;     /**< Specifies maximum macro-blocks per second */
   OMX_U32 nCustomMaxFS;       /**< Specifies maximum frame size (macro-blocks per frame) */
   OMX_U32 nCustomMaxBRandCPB; /**< Specifies maximum bitrate in units of 1000 bits/s and Codec Picture Buffer (CPB derived from bitrate) */
} OMX_VIDEO_CONFIG_LEVEL_EXTEND;
/*
This allows finer control of the H264 encode internal parameters.
*/

/* OMX_IndexParamBrcmEEDEEnable: Enable/Disable end to end distortion estimator */
typedef struct OMX_VIDEO_EEDE_ENABLE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 enable;
} OMX_VIDEO_EEDE_ENABLE;
/*
This enables or disables the use of end to end distortion estimation.
*/

/* OMX_IndexParamBrcmEEDELossRate: Loss rate configuration for end to end distortion */
typedef struct OMX_VIDEO_EEDE_LOSSRATE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
   OMX_U32 loss_rate; /**< loss rate, 5 means 5% */
} OMX_VIDEO_EEDE_LOSSRATE;
/*
Set the packet loss rate used by the end to end distortion estimator.
*/

/* OMX_IndexParamColorSpace: Colour space information */
typedef enum OMX_COLORSPACETYPE
{
   OMX_COLORSPACE_UNKNOWN,
   OMX_COLORSPACE_JPEG_JFIF,
   OMX_COLORSPACE_ITU_R_BT601,
   OMX_COLORSPACE_ITU_R_BT709,
   OMX_COLORSPACE_FCC,
   OMX_COLORSPACE_SMPTE240M,
   OMX_COLORSPACE_BT470_2_M,
   OMX_COLORSPACE_BT470_2_BG,
   OMX_COLORSPACE_JFIF_Y16_255,
   OMX_COLORSPACE_MAX = 0x7FFFFFFF
} OMX_COLORSPACETYPE;

typedef struct OMX_PARAM_COLORSPACETYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_COLORSPACETYPE eColorSpace;
} OMX_PARAM_COLORSPACETYPE;

typedef enum OMX_CAPTURESTATETYPE
{
   OMX_NotCapturing,
   OMX_CaptureStarted,
   OMX_CaptureComplete,
   OMX_CaptureMax = 0x7FFFFFFF
} OMX_CAPTURESTATETYPE;

typedef struct OMX_PARAM_CAPTURESTATETYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_CAPTURESTATETYPE eCaptureState;
} OMX_PARAM_CAPTURESTATETYPE;

/*
Provides information on the colour space that's in use during image/video processing.
*/

/* OMX_IndexConfigMinimiseFragmentation: Minimising Fragmentation */
/*
This control can be supported to enable the client to request that the component works
to minimise fragmentation of output buffers.
*/

/* OMX_IndexConfigBrcmBufferFlagFilter: Filters buffers based on flags */
/*
This control can be set to request that buffers are conditionally forwarded on 
output ports based on matching flags set on that buffer.
*/

/* OMX_IndexParamPortMaxFrameSize: Specifying maximum frame size */
/*
This control can be used to control the maximum frame size allowed on an output port.
*/

/* OMX_IndexConfigBrcmCameraRnDPreprocess: Enable use of development ISP software stage */
/*
This control can be used to enable a developmental software stage to be inserted into
the preprocessor stage of the ISP.
*/

/* OMX_IndexConfigBrcmCameraRnDPostprocess: Enable use of development ISP software stage */
/*
This control can be used to enable a developmental software stage to be inserted into
the postprocessor stage of the ISP.
*/

/* OMX_IndexParamDisableVllPool: Controlling use of memory for loadable modules */
/*
This control can be used to control whether loadable modules used a dedicated memory
pool or use heap allocated memory.
*/

typedef struct OMX_PARAM_BRCMCONFIGFILETYPE {
   OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                            actual URI name */
   OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
   OMX_U32 fileSize;                   /**< Size of complete file data */
} OMX_PARAM_BRCMCONFIGFILETYPE;

typedef struct OMX_PARAM_BRCMCONFIGFILECHUNKTYPE {
   OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                            actual chunk data */
   OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
   OMX_U32 size;                       /**< Number of bytes being transferred in this chunk */
   OMX_U32 offset;                     /**< Offset of this chunk in the file */
   OMX_U8 data[1];                     /**< Chunk data */
} OMX_PARAM_BRCMCONFIGFILECHUNKTYPE;

typedef struct OMX_PARAM_BRCMFRAMERATERANGETYPE {
   OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                            actual chunk data */
   OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
   OMX_U32 nPortIndex;
   OMX_U32 xFramerateLow;              /**< Low end of framerate range. Q16 format */
   OMX_U32 xFramerateHigh;             /**< High end of framerate range. Q16 format */
} OMX_PARAM_BRCMFRAMERATERANGETYPE;

typedef struct OMX_PARAM_S32TYPE {
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
    OMX_U32 nPortIndex;               /**< port that this structure applies to */
    OMX_S32 nS32;                     /**< S32 value */
} OMX_PARAM_S32TYPE;

typedef struct OMX_PARAM_BRCMVIDEODRMPROTECTBUFFERTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 size_wanted;     /**< Input. Zero size means internal video decoder buffer,
                                 mem_handle and phys_addr not returned in this case */
   OMX_U32 protect;         /**< Input. 1 = protect, 0 = unprotect */

   OMX_U32 mem_handle;      /**< Output. Handle for protected buffer */
   OMX_PTR phys_addr;       /**< Output. Physical memory address of protected buffer */
} OMX_PARAM_BRCMVIDEODRMPROTECTBUFFERTYPE;

typedef struct OMX_CONFIG_ZEROSHUTTERLAGTYPE
{
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 bZeroShutterMode;        /**< Select ZSL mode from the camera. */
   OMX_U32 bConcurrentCapture;      /**< Perform concurrent captures for full ZSL. */

} OMX_CONFIG_ZEROSHUTTERLAGTYPE;

typedef struct OMX_PARAM_BRCMVIDEODECODECONFIGVD3TYPE {
   OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                            configuration data */
   OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
   OMX_U8 config[1];                   /**< Configuration data (a VD3_CONFIGURE_T) */
} OMX_PARAM_BRCMVIDEODECODECONFIGVD3TYPE;

typedef struct OMX_CONFIG_CUSTOMAWBGAINSTYPE {
   OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                            configuration data */
   OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
   OMX_U32 xGainR;                     /**< Red gain - 16p16 */
   OMX_U32 xGainB;                     /**< Blue gain - 16p16 */
} OMX_CONFIG_CUSTOMAWBGAINSTYPE;

/* OMX_IndexConfigBrcmRenderStats: Query port statistics */
typedef struct OMX_CONFIG_BRCMRENDERSTATSTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_U32 nPortIndex;
   OMX_BOOL nValid;
   OMX_U32 nMatch;
   OMX_U32 nPeriod;
   OMX_U32 nPhase;
   OMX_U32 nPixelClockNominal;
   OMX_U32 nPixelClock;
   OMX_U32 nHvsStatus;
   OMX_U32 dummy0[2];
} OMX_CONFIG_BRCMRENDERSTATSTYPE;

#define OMX_BRCM_MAXANNOTATETEXTLEN 256
typedef struct OMX_CONFIG_BRCMANNOTATETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;
   OMX_BOOL bEnable;
   OMX_BOOL bShowShutter;
   OMX_BOOL bShowAnalogGain;
   OMX_BOOL bShowLens;
   OMX_BOOL bShowCaf;
   OMX_BOOL bShowMotion;
   OMX_BOOL bShowFrameNum;
   OMX_BOOL bEnableBackground;
   OMX_BOOL bCustomBackgroundColour;
   OMX_U8 nBackgroundY;
   OMX_U8 nBackgroundU;
   OMX_U8 nBackgroundV;
   OMX_U8 dummy1;
   OMX_BOOL bCustomTextColour;
   OMX_U8 nTextY;
   OMX_U8 nTextU;
   OMX_U8 nTextV;
   OMX_U8 nTextSize;   /**< Text size: 6-150 pixels */
   OMX_U8 sText[OMX_BRCM_MAXANNOTATETEXTLEN];
} OMX_CONFIG_BRCMANNOTATETYPE;

typedef enum OMX_BRCMSTEREOSCOPICMODETYPE {
   OMX_STEREOSCOPIC_NONE = 0,
   OMX_STEREOSCOPIC_SIDEBYSIDE = 1,
   OMX_STEREOSCOPIC_TOPBOTTOM = 2,
   OMX_STEREOSCOPIC_MAX = 0x7FFFFFFF,
} OMX_BRCMSTEREOSCOPICMODETYPE;

typedef struct OMX_CONFIG_BRCMSTEREOSCOPICMODETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_BRCMSTEREOSCOPICMODETYPE eMode;    /**< Packing mode */
   OMX_BOOL bDecimate;                    /**< Half/half mode
                                          (pixel aspect ratio = 1:2 or 2:1 if set. 1:1 if not set) */
   OMX_BOOL bSwapEyes;                    /**< False = left eye first. True = right eye first. */
} OMX_CONFIG_BRCMSTEREOSCOPICMODETYPE;

typedef enum OMX_CAMERAINTERFACETYPE {
   OMX_CAMERAINTERFACE_CSI = 0,
   OMX_CAMERAINTERFACE_CCP2 = 1,
   OMX_CAMERAINTERFACE_CPI = 2,
   OMX_CAMERAINTERFACE_MAX = 0x7FFFFFFF,
} OMX_CAMERAINTERFACETYPE;

typedef struct OMX_PARAM_CAMERAINTERFACETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_CAMERAINTERFACETYPE eMode;         /**< Interface mode */
} OMX_PARAM_CAMERAINTERFACETYPE;

typedef enum OMX_CAMERACLOCKINGMODETYPE {
   OMX_CAMERACLOCKINGMODE_STROBE = 0,
   OMX_CAMERACLOCKINGMODE_CLOCK = 1,
   OMX_CAMERACLOCKINGMODE_MAX = 0x7FFFFFFF,
} OMX_CAMERACLOCKINGMODETYPE;

typedef struct OMX_PARAM_CAMERACLOCKINGMODETYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_CAMERACLOCKINGMODETYPE eMode;      /**< Clocking mode */
} OMX_PARAM_CAMERACLOCKINGMODETYPE;

typedef enum OMX_CAMERARXDECODETYPE {
   OMX_CAMERARXDECODE_NONE = 0,
   OMX_CAMERARXDECODE_DPCM8TO10 = 1,
   OMX_CAMERARXDECODE_DPCM7TO10 = 2,
   OMX_CAMERARXDECODE_DPCM6TO10 = 3,
   OMX_CAMERARXDECODE_DPCM8TO12 = 4,
   OMX_CAMERARXDECODE_DPCM7TO12 = 5,
   OMX_CAMERARXDECODE_DPCM6TO12 = 6,
   OMX_CAMERARXDECODE_DPCM10TO14 = 7,
   OMX_CAMERARXDECODE_DPCM8TO14 = 8,
   OMX_CAMERARXDECODE_DPCM12TO16 = 9,
   OMX_CAMERARXDECODE_DPCM10TO16 = 10,
   OMX_CAMERARXDECODE_DPCM8TO16 = 11,
   OMX_CAMERARXDECODE_MAX = 0x7FFFFFFF
} OMX_CAMERARXDECODETYPE;

typedef enum OMX_CAMERARXENCODETYPE {
   OMX_CAMERARXENCODE_NONE = 0,
   OMX_CAMERARXENCODE_DPCM10TO8 = 1,
   OMX_CAMERARXENCODE_DPCM12TO8 = 2,
   OMX_CAMERARXENCODE_DPCM14TO8 = 3,
   OMX_CAMERARXENCODE_MAX = 0x7FFFFFFF
} OMX_CAMERARXENCODETYPE;

typedef enum OMX_CAMERARXUNPACKTYPE {
   OMX_CAMERARXUNPACK_NONE = 0,
   OMX_CAMERARXUNPACK_6 = 1,
   OMX_CAMERARXUNPACK_7 = 2,
   OMX_CAMERARXUNPACK_8 = 3,
   OMX_CAMERARXUNPACK_10 = 4,
   OMX_CAMERARXUNPACK_12 = 5,
   OMX_CAMERARXUNPACK_14 = 6,
   OMX_CAMERARXUNPACK_16 = 7,
   OMX_CAMERARXUNPACK_MAX = 0x7FFFFFFF
} OMX_CAMERARXUNPACKYPE;

typedef enum OMX_CAMERARXPACKTYPE {
   OMX_CAMERARXPACK_NONE = 0,
   OMX_CAMERARXPACK_8 = 1,
   OMX_CAMERARXPACK_10 = 2,
   OMX_CAMERARXPACK_12 = 3,
   OMX_CAMERARXPACK_14 = 4,
   OMX_CAMERARXPACK_16 = 5,
   OMX_CAMERARXPACK_RAW10 = 6,
   OMX_CAMERARXPACK_RAW12 = 7,
   OMX_CAMERARXPACK_MAX = 0x7FFFFFFF
} OMX_CAMERARXPACKTYPE;

typedef struct OMX_PARAM_CAMERARXCONFIG_TYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_CAMERARXDECODETYPE eDecode;
   OMX_CAMERARXENCODETYPE eEncode;
   OMX_CAMERARXUNPACKYPE eUnpack;
   OMX_CAMERARXPACKTYPE ePack;
   OMX_U32 nDataLanes;
   OMX_U32 nEncodeBlockLength;
   OMX_U32 nEmbeddedDataLines;
   OMX_U32 nImageId;
} OMX_PARAM_CAMERARXCONFIG_TYPE;

typedef struct OMX_PARAM_CAMERARXTIMING_TYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_U32 nTiming1;
   OMX_U32 nTiming2;
   OMX_U32 nTiming3;
   OMX_U32 nTiming4;
   OMX_U32 nTiming5;
   OMX_U32 nTerm1;
   OMX_U32 nTerm2;
   OMX_U32 nCpiTiming1;
   OMX_U32 nCpiTiming2;
} OMX_PARAM_CAMERARXTIMING_TYPE;

typedef enum OMX_BAYERORDERTYPE {
   OMX_BayerOrderRGGB = 0,
   OMX_BayerOrderGBRG = 1,
   OMX_BayerOrderBGGR = 3,
   OMX_BayerOrderGRBG = 3,

   OMX_BayerOrderMax = 0x7FFFFFFF
} OMX_BAYERORDERTYPE;

typedef struct OMX_PARAM_BAYERORDERTYPE {
   OMX_U32 nSize;
   OMX_VERSIONTYPE nVersion;

   OMX_U32 nPortIndex;                    /**< port that this structure applies to */
   OMX_BAYERORDERTYPE eBayerOrder;
} OMX_PARAM_BAYERORDERTYPE;
#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** OMX_Component.h - OpenMax IL version 1.1.2
 *  The OMX_Component header file contains the definitions used to define
 *  the public interface of a component.  This header file is intended to
 *  be used by both the application and the component.
 */

#ifndef OMX_Component_h
#define OMX_Component_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */



/* Each OMX header must include all required header files to allow the
 *  header to compile without errors.  The includes below are required
 *  for this header file to compile successfully 
 */

#include "OMX_Audio.h"
#include "OMX_Video.h"
#include "OMX_Image.h"
#include "OMX_Other.h"

/** @ingroup comp */
typedef enum OMX_PORTDOMAINTYPE { 
    OMX_PortDomainAudio, 
    OMX_PortDomainVideo, 
    OMX_PortDomainImage, 
    OMX_PortDomainOther,
    OMX_PortDomainKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_PortDomainVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_PortDomainMax = 0x7ffffff
} OMX_PORTDOMAINTYPE;

/** @ingroup comp */
typedef struct OMX_PARAM_PORTDEFINITIONTYPE {
    OMX_U32 nSize;                 /**< Size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
    OMX_U32 nPortIndex;            /**< Port number the structure applies to */
    OMX_DIRTYPE eDir;              /**< Direction (input or output) of this port */
    OMX_U32 nBufferCountActual;    /**< The actual number of buffers allocated on this port */
    OMX_U32 nBufferCountMin;       /**< The minimum number of buffers this port requires */
    OMX_U32 nBufferSize;           /**< Size, in bytes, for buffers to be used for this channel */
    OMX_BOOL bEnabled;             /**< Ports default to enabled and are enabled/disabled by
                                        OMX_CommandPortEnable/OMX_CommandPortDisable.
                                        When disabled a port is unpopulated. A disabled port
                                        is not populated with buffers on a transition to IDLE. */
    OMX_BOOL bPopulated;           /**< Port is populated with all of its buffers as indicated by
                                        nBufferCountActual. A disabled port is always unpopulated. 
                                        An enabled port is populated on a transition to OMX_StateIdle
                                        and unpopulated on a transition to loaded. */
    OMX_PORTDOMAINTYPE eDomain;    /**< Domain of the port. Determines the contents of metadata below. */
    union {
        OMX_AUDIO_PORTDEFINITIONTYPE audio;
        OMX_VIDEO_PORTDEFINITIONTYPE video;
        OMX_IMAGE_PORTDEFINITIONTYPE image;
        OMX_OTHER_PORTDEFINITIONTYPE other;
    } format;
    OMX_BOOL bBuffersContiguous;
    OMX_U32 nBufferAlignment;
} OMX_PARAM_PORTDEFINITIONTYPE;

/** @ingroup comp */
typedef struct OMX_PARAM_U32TYPE { 
    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
    OMX_U32 nU32;                     /**< U32 value */
} OMX_PARAM_U32TYPE;

/** @ingroup rpm */
typedef enum OMX_SUSPENSIONPOLICYTYPE {
    OMX_SuspensionDisabled, /**< No suspension; v1.0 behavior */
    OMX_SuspensionEnabled,  /**< Suspension allowed */   
    OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_SuspensionPolicyStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_SuspensionPolicyMax = 0x7fffffff
} OMX_SUSPENSIONPOLICYTYPE;

/** @ingroup rpm */
typedef struct OMX_PARAM_SUSPENSIONPOLICYTYPE {
    OMX_U32 nSize;                  
    OMX_VERSIONTYPE nVersion;        
    OMX_SUSPENSIONPOLICYTYPE ePolicy;
} OMX_PARAM_SUSPENSIONPOLICYTYPE;

/** @ingroup rpm */
typedef enum OMX_SUSPENSIONTYPE {
    OMX_NotSuspended, /**< component is not suspended */
    OMX_Suspended,    /**< component is suspended */
    OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_SuspensionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_SuspendMax = 0x7FFFFFFF
} OMX_SUSPENSIONTYPE;

/** @ingroup rpm */
typedef struct OMX_PARAM_SUSPENSIONTYPE {
    OMX_U32 nSize;                  
    OMX_VERSIONTYPE nVersion;       
    OMX_SUSPENSIONTYPE eType;             
} OMX_PARAM_SUSPENSIONTYPE ;

typedef struct OMX_CONFIG_BOOLEANTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_BOOL bEnabled;    
} OMX_CONFIG_BOOLEANTYPE;

/* Parameter specifying the content uri to use. */
/** @ingroup cp */
typedef struct OMX_PARAM_CONTENTURITYPE
{
    OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                             actual URI name */
    OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
    OMX_U8 contentURI[1];               /**< The URI name */
} OMX_PARAM_CONTENTURITYPE;

/* Parameter specifying the pipe to use. */
/** @ingroup cp */
typedef struct OMX_PARAM_CONTENTPIPETYPE
{
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_HANDLETYPE hPipe;       /**< The pipe handle*/
} OMX_PARAM_CONTENTPIPETYPE;

/** @ingroup rpm */
typedef struct OMX_RESOURCECONCEALMENTTYPE {
    OMX_U32 nSize;             /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
    OMX_BOOL bResourceConcealmentForbidden; /**< disallow the use of resource concealment 
                                            methods (like degrading algorithm quality to 
                                            lower resource consumption or functional bypass) 
                                            on a component as a resolution to resource conflicts. */
} OMX_RESOURCECONCEALMENTTYPE;


/** @ingroup metadata */
typedef enum OMX_METADATACHARSETTYPE {
    OMX_MetadataCharsetUnknown = 0,
    OMX_MetadataCharsetASCII,
    OMX_MetadataCharsetBinary,
    OMX_MetadataCharsetCodePage1252,
    OMX_MetadataCharsetUTF8,
    OMX_MetadataCharsetJavaConformantUTF8,
    OMX_MetadataCharsetUTF7,
    OMX_MetadataCharsetImapUTF7,
    OMX_MetadataCharsetUTF16LE, 
    OMX_MetadataCharsetUTF16BE,
    OMX_MetadataCharsetGB12345,
    OMX_MetadataCharsetHZGB2312,
    OMX_MetadataCharsetGB2312,
    OMX_MetadataCharsetGB18030,
    OMX_MetadataCharsetGBK,
    OMX_MetadataCharsetBig5,
    OMX_MetadataCharsetISO88591,
    OMX_MetadataCharsetISO88592,
    OMX_MetadataCharsetISO88593,
    OMX_MetadataCharsetISO88594,
    OMX_MetadataCharsetISO88595,
    OMX_MetadataCharsetISO88596,
    OMX_MetadataCharsetISO88597,
    OMX_MetadataCharsetISO88598,
    OMX_MetadataCharsetISO88599,
    OMX_MetadataCharsetISO885910,
    OMX_MetadataCharsetISO885913,
    OMX_MetadataCharsetISO885914,
    OMX_MetadataCharsetISO885915,
    OMX_MetadataCharsetShiftJIS,
    OMX_MetadataCharsetISO2022JP,
    OMX_MetadataCharsetISO2022JP1,
    OMX_MetadataCharsetISOEUCJP,
    OMX_MetadataCharsetSMS7Bit,
    OMX_MetadataCharsetKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_MetadataCharsetVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_MetadataCharsetTypeMax= 0x7FFFFFFF
} OMX_METADATACHARSETTYPE;

/** @ingroup metadata */
typedef enum OMX_METADATASCOPETYPE
{
    OMX_MetadataScopeAllLevels,
    OMX_MetadataScopeTopLevel,
    OMX_MetadataScopePortLevel,
    OMX_MetadataScopeNodeLevel,
    OMX_MetadataScopeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_MetadataScopeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_MetadataScopeTypeMax = 0x7fffffff
} OMX_METADATASCOPETYPE;

/** @ingroup metadata */
typedef enum OMX_METADATASEARCHMODETYPE
{
    OMX_MetadataSearchValueSizeByIndex,
    OMX_MetadataSearchItemByIndex,
    OMX_MetadataSearchNextItemByKey,
    OMX_MetadataSearchKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_MetadataSearchVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_MetadataSearchTypeMax = 0x7fffffff
} OMX_METADATASEARCHMODETYPE;
/** @ingroup metadata */
typedef struct OMX_CONFIG_METADATAITEMCOUNTTYPE
{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_METADATASCOPETYPE eScopeMode;
    OMX_U32 nScopeSpecifier;
    OMX_U32 nMetadataItemCount;
} OMX_CONFIG_METADATAITEMCOUNTTYPE;

/** @ingroup metadata */
typedef struct OMX_CONFIG_METADATAITEMTYPE
{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_METADATASCOPETYPE eScopeMode;
    OMX_U32 nScopeSpecifier;
    OMX_U32 nMetadataItemIndex;  
    OMX_METADATASEARCHMODETYPE eSearchMode;
    OMX_METADATACHARSETTYPE eKeyCharset;
    OMX_U8 nKeySizeUsed;
    OMX_U8 nKey[128];
    OMX_METADATACHARSETTYPE eValueCharset;
    OMX_STRING sLanguageCountry;
    OMX_U32 nValueMaxSize;
    OMX_U32 nValueSizeUsed;
    OMX_U8 nValue[1];
} OMX_CONFIG_METADATAITEMTYPE;

/* @ingroup metadata */
typedef struct OMX_CONFIG_CONTAINERNODECOUNTTYPE
{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_BOOL bAllKeys;
    OMX_U32 nParentNodeID;
    OMX_U32 nNumNodes;
} OMX_CONFIG_CONTAINERNODECOUNTTYPE;

/** @ingroup metadata */
typedef struct OMX_CONFIG_CONTAINERNODEIDTYPE
{
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_BOOL bAllKeys;
    OMX_U32 nParentNodeID;
    OMX_U32 nNodeIndex; 
    OMX_U32 nNodeID; 
    OMX_STRING cNodeName;
    OMX_BOOL bIsLeafType;
} OMX_CONFIG_CONTAINERNODEIDTYPE;

/** @ingroup metadata */
typedef struct OMX_PARAM_METADATAFILTERTYPE 
{ 
    OMX_U32 nSize; 
    OMX_VERSIONTYPE nVersion; 
    OMX_BOOL bAllKeys;	/* if true then this structure refers to all keys and 
                         * the three key fields below are ignored */
    OMX_METADATACHARSETTYPE eKeyCharset;
    OMX_U32 nKeySizeUsed; 
    OMX_U8   nKey [128]; 
    OMX_U32 nLanguageCountrySizeUsed;
    OMX_U8 nLanguageCountry[128];
    OMX_BOOL bEnabled;	/* if true then key is part of filter (e.g. 
                         * retained for query later). If false then
                         * key is not part of filter */
} OMX_PARAM_METADATAFILTERTYPE; 

/** The OMX_HANDLETYPE structure defines the component handle.  The component 
 *  handle is used to access all of the component's public methods and also
 *  contains pointers to the component's private data area.  The component
 *  handle is initialized by the OMX core (with help from the component)
 *  during the process of loading the component.  After the component is
 *  successfully loaded, the application can safely access any of the
 *  component's public functions (although some may return an error because
 *  the state is inappropriate for the access).
 * 
 *  @ingroup comp
 */
typedef struct OMX_COMPONENTTYPE
{
    /** The size of this structure, in bytes.  It is the responsibility
        of the allocator of this structure to fill in this value.  Since
        this structure is allocated by the GetHandle function, this
        function will fill in this value. */
    OMX_U32 nSize;

    /** nVersion is the version of the OMX specification that the structure 
        is built against.  It is the responsibility of the creator of this 
        structure to initialize this value and every user of this structure 
        should verify that it knows how to use the exact version of 
        this structure found herein. */
    OMX_VERSIONTYPE nVersion;

    /** pComponentPrivate is a pointer to the component private data area.  
        This member is allocated and initialized by the component when the 
        component is first loaded.  The application should not access this 
        data area. */
    OMX_PTR pComponentPrivate;

    /** pApplicationPrivate is a pointer that is a parameter to the 
        OMX_GetHandle method, and contains an application private value 
        provided by the IL client.  This application private data is 
        returned to the IL Client by OMX in all callbacks */
    OMX_PTR pApplicationPrivate;

    /** refer to OMX_GetComponentVersion in OMX_core.h or the OMX IL 
        specification for details on the GetComponentVersion method.
     */
    OMX_ERRORTYPE (*GetComponentVersion)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_OUT OMX_STRING pComponentName,
            OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
            OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
            OMX_OUT OMX_UUIDTYPE* pComponentUUID);

    /** refer to OMX_SendCommand in OMX_core.h or the OMX IL 
        specification for details on the SendCommand method.
     */
    OMX_ERRORTYPE (*SendCommand)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_COMMANDTYPE Cmd,
            OMX_IN  OMX_U32 nParam1,
            OMX_IN  OMX_PTR pCmdData);

    /** refer to OMX_GetParameter in OMX_core.h or the OMX IL 
        specification for details on the GetParameter method.
     */
    OMX_ERRORTYPE (*GetParameter)(
            OMX_IN  OMX_HANDLETYPE hComponent, 
            OMX_IN  OMX_INDEXTYPE nParamIndex,  
            OMX_INOUT OMX_PTR pComponentParameterStructure);


    /** refer to OMX_SetParameter in OMX_core.h or the OMX IL 
        specification for details on the SetParameter method.
     */
    OMX_ERRORTYPE (*SetParameter)(
            OMX_IN  OMX_HANDLETYPE hComponent, 
            OMX_IN  OMX_INDEXTYPE nIndex,
            OMX_IN  OMX_PTR pComponentParameterStructure);


    /** refer to OMX_GetConfig in OMX_core.h or the OMX IL 
        specification for details on the GetConfig method.
     */
    OMX_ERRORTYPE (*GetConfig)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_INDEXTYPE nIndex, 
            OMX_INOUT OMX_PTR pComponentConfigStructure);


    /** refer to OMX_SetConfig in OMX_core.h or the OMX IL 
        specification for details on the SetConfig method.
     */
    OMX_ERRORTYPE (*SetConfig)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_INDEXTYPE nIndex, 
            OMX_IN  OMX_PTR pComponentConfigStructure);


    /** refer to OMX_GetExtensionIndex in OMX_core.h or the OMX IL 
        specification for details on the GetExtensionIndex method.
     */
    OMX_ERRORTYPE (*GetExtensionIndex)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_STRING cParameterName,
            OMX_OUT OMX_INDEXTYPE* pIndexType);


    /** refer to OMX_GetState in OMX_core.h or the OMX IL 
        specification for details on the GetState method.
     */
    OMX_ERRORTYPE (*GetState)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_OUT OMX_STATETYPE* pState);

    
    /** The ComponentTunnelRequest method will interact with another OMX
        component to determine if tunneling is possible and to setup the
        tunneling.  The return codes for this method can be used to 
        determine if tunneling is not possible, or if tunneling is not
        supported.  
        
        Base profile components (i.e. non-interop) do not support this
        method and should return OMX_ErrorNotImplemented 

        The interop profile component MUST support tunneling to another 
        interop profile component with a compatible port parameters.  
        A component may also support proprietary communication.
        
        If proprietary communication is supported the negotiation of 
        proprietary communication is done outside of OMX in a vendor 
        specific way. It is only required that the proper result be 
        returned and the details of how the setup is done is left 
        to the component implementation.  
    
        When this method is invoked when nPort in an output port, the
        component will:
        1.  Populate the pTunnelSetup structure with the output port's 
            requirements and constraints for the tunnel.

        When this method is invoked when nPort in an input port, the
        component will:
        1.  Query the necessary parameters from the output port to 
            determine if the ports are compatible for tunneling
        2.  If the ports are compatible, the component should store
            the tunnel step provided by the output port
        3.  Determine which port (either input or output) is the buffer
            supplier, and call OMX_SetParameter on the output port to
            indicate this selection.
        
        The component will return from this call within 5 msec.
    
        @param [in] hComp
            Handle of the component to be accessed.  This is the component
            handle returned by the call to the OMX_GetHandle method.
        @param [in] nPort
            nPort is used to select the port on the component to be used
            for tunneling.
        @param [in] hTunneledComp
            Handle of the component to tunnel with.  This is the component 
            handle returned by the call to the OMX_GetHandle method.  When
            this parameter is 0x0 the component should setup the port for
            communication with the application / IL Client.
        @param [in] nPortOutput
            nPortOutput is used indicate the port the component should
            tunnel with.
        @param [in] pTunnelSetup
            Pointer to the tunnel setup structure.  When nPort is an output port
            the component should populate the fields of this structure.  When
            When nPort is an input port the component should review the setup
            provided by the component with the output port.
        @return OMX_ERRORTYPE
            If the command successfully executes, the return code will be
            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
        @ingroup tun
    */

    OMX_ERRORTYPE (*ComponentTunnelRequest)(
        OMX_IN  OMX_HANDLETYPE hComp,
        OMX_IN  OMX_U32 nPort,
        OMX_IN  OMX_HANDLETYPE hTunneledComp,
        OMX_IN  OMX_U32 nTunneledPort,
        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup); 

    /** refer to OMX_UseBuffer in OMX_core.h or the OMX IL 
        specification for details on the UseBuffer method.
        @ingroup buf
     */
    OMX_ERRORTYPE (*UseBuffer)(
            OMX_IN OMX_HANDLETYPE hComponent,
            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
            OMX_IN OMX_U32 nPortIndex,
            OMX_IN OMX_PTR pAppPrivate,
            OMX_IN OMX_U32 nSizeBytes,
            OMX_IN OMX_U8* pBuffer);

    /** refer to OMX_AllocateBuffer in OMX_core.h or the OMX IL 
        specification for details on the AllocateBuffer method.
        @ingroup buf
     */
    OMX_ERRORTYPE (*AllocateBuffer)(
            OMX_IN OMX_HANDLETYPE hComponent,
            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
            OMX_IN OMX_U32 nPortIndex,
            OMX_IN OMX_PTR pAppPrivate,
            OMX_IN OMX_U32 nSizeBytes);

    /** refer to OMX_FreeBuffer in OMX_core.h or the OMX IL 
        specification for details on the FreeBuffer method.
        @ingroup buf
     */
    OMX_ERRORTYPE (*FreeBuffer)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_U32 nPortIndex,
            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);

    /** refer to OMX_EmptyThisBuffer in OMX_core.h or the OMX IL 
        specification for details on the EmptyThisBuffer method.
        @ingroup buf
     */
    OMX_ERRORTYPE (*EmptyThisBuffer)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);

    /** refer to OMX_FillThisBuffer in OMX_core.h or the OMX IL 
        specification for details on the FillThisBuffer method.
        @ingroup buf
     */
    OMX_ERRORTYPE (*FillThisBuffer)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);

    /** The SetCallbacks method is used by the core to specify the callback
        structure from the application to the component.  This is a blocking
        call.  The component will return from this call within 5 msec.
        @param [in] hComponent
            Handle of the component to be accessed.  This is the component
            handle returned by the call to the GetHandle function.
        @param [in] pCallbacks
            pointer to an OMX_CALLBACKTYPE structure used to provide the 
            callback information to the component
        @param [in] pAppData
            pointer to an application defined value.  It is anticipated that 
            the application will pass a pointer to a data structure or a "this
            pointer" in this area to allow the callback (in the application)
            to determine the context of the call
        @return OMX_ERRORTYPE
            If the command successfully executes, the return code will be
            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
     */
    OMX_ERRORTYPE (*SetCallbacks)(
            OMX_IN  OMX_HANDLETYPE hComponent,
            OMX_IN  OMX_CALLBACKTYPE* pCallbacks, 
            OMX_IN  OMX_PTR pAppData);

    /** ComponentDeInit method is used to deinitialize the component
        providing a means to free any resources allocated at component
        initialization.  NOTE:  After this call the component handle is
        not valid for further use.
        @param [in] hComponent
            Handle of the component to be accessed.  This is the component
            handle returned by the call to the GetHandle function.
        @return OMX_ERRORTYPE
            If the command successfully executes, the return code will be
            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
     */
    OMX_ERRORTYPE (*ComponentDeInit)(
            OMX_IN  OMX_HANDLETYPE hComponent);

    /** @ingroup buf */
    OMX_ERRORTYPE (*UseEGLImage)(
            OMX_IN OMX_HANDLETYPE hComponent,
            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
            OMX_IN OMX_U32 nPortIndex,
            OMX_IN OMX_PTR pAppPrivate,
            OMX_IN void* eglImage);

    OMX_ERRORTYPE (*ComponentRoleEnum)(
        OMX_IN OMX_HANDLETYPE hComponent,
		OMX_OUT OMX_U8 *cRole,
		OMX_IN OMX_U32 nIndex);

} OMX_COMPONENTTYPE;

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** OMX_Core.h - OpenMax IL version 1.1.2
 *  The OMX_Core header file contains the definitions used by both the
 *  application and the component to access common items.
 */

#ifndef OMX_Core_h
#define OMX_Core_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#if !defined(OMX_SKIP64BIT) && !defined(_VIDEOCORE)
  /* The Videocore compiler doesn't enforce 64 bit alignment on 64 bit variables,
   * which is almost equivalent to OMX_SKIP64BIT.
   * Annoyingly struct OMX_BUFFERHEADERTYPE doesn't do the sensible thing
   * and add padding fields or similar to make it the same for all compilers,
   * so all clients need to define this.
   * Warn if this isn't set, as the GPU will not interpret your buffers correctly,
   * or vice versa.
   */
  #warning OMX_SKIP64BIT is not defined - this will be incompatible with the VC GPU code.
#endif

/* Each OMX header shall include all required header files to allow the
 *  header to compile without errors.  The includes below are required
 *  for this header file to compile successfully 
 */

#include "OMX_Index.h"


/** The OMX_COMMANDTYPE enumeration is used to specify the action in the
 *  OMX_SendCommand macro.  
 *  @ingroup core
 */
typedef enum OMX_COMMANDTYPE
{
    OMX_CommandStateSet,    /**< Change the component state */
    OMX_CommandFlush,       /**< Flush the data queue(s) of a component */
    OMX_CommandPortDisable, /**< Disable a port on a component. */
    OMX_CommandPortEnable,  /**< Enable a port on a component. */
    OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
    OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_CommandVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_CommandMax = 0X7FFFFFFF
} OMX_COMMANDTYPE;



/** The OMX_STATETYPE enumeration is used to indicate or change the component
 *  state.  This enumeration reflects the current state of the component when
 *  used with the OMX_GetState macro or becomes the parameter in a state change
 *  command when used with the OMX_SendCommand macro.
 *
 *  The component will be in the Loaded state after the component is initially
 *  loaded into memory.  In the Loaded state, the component is not allowed to
 *  allocate or hold resources other than to build it's internal parameter
 *  and configuration tables.  The application will send one or more
 *  SetParameters/GetParameters and SetConfig/GetConfig commands to the
 *  component and the component will record each of these parameter and
 *  configuration changes for use later.  When the application sends the
 *  Idle command, the component will acquire the resources needed for the
 *  specified configuration and will transition to the idle state if the
 *  allocation is successful.  If the component cannot successfully
 *  transition to the idle state for any reason, the state of the component
 *  shall be fully rolled back to the Loaded state (e.g. all allocated 
 *  resources shall be released).  When the component receives the command
 *  to go to the Executing state, it shall begin processing buffers by
 *  sending all input buffers it holds to the application.  While
 *  the component is in the Idle state, the application may also send the
 *  Pause command.  If the component receives the pause command while in the
 *  Idle state, the component shall send all input buffers it holds to the 
 *  application, but shall not begin processing buffers.  This will allow the
 *  application to prefill buffers.
 * 
 *  @ingroup comp
 */

typedef enum OMX_STATETYPE
{
    OMX_StateInvalid,      /**< component has detected that it's internal data 
                                structures are corrupted to the point that
                                it cannot determine it's state properly */
    OMX_StateLoaded,      /**< component has been loaded but has not completed
                                initialization.  The OMX_SetParameter macro
                                and the OMX_GetParameter macro are the only 
                                valid macros allowed to be sent to the 
                                component in this state. */
    OMX_StateIdle,        /**< component initialization has been completed
                                successfully and the component is ready to
                                to start. */
    OMX_StateExecuting,   /**< component has accepted the start command and
                                is processing data (if data is available) */
    OMX_StatePause,       /**< component has received pause command */
    OMX_StateWaitForResources, /**< component is waiting for resources, either after 
                                preemption or before it gets the resources requested.
                                See specification for complete details. */
    OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_StateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_StateMax = 0X7FFFFFFF
} OMX_STATETYPE;

/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These 
 *  errors should cover most of the common failure cases.  However, 
 *  vendors are free to add additional error messages of their own as 
 *  long as they follow these rules:
 *  1.  Vendor error messages shall be in the range of 0x90000000 to
 *      0x9000FFFF.
 *  2.  Vendor error messages shall be defined in a header file provided
 *      with the component.  No error messages are allowed that are
 *      not defined.
 */
typedef enum OMX_ERRORTYPE
{
  OMX_ErrorNone = 0,

  /** There were insufficient resources to perform the requested operation */
  OMX_ErrorInsufficientResources = (OMX_S32) 0x80001000,

  /** There was an error, but the cause of the error could not be determined */
  OMX_ErrorUndefined = (OMX_S32) 0x80001001,

  /** The component name string was not valid */
  OMX_ErrorInvalidComponentName = (OMX_S32) 0x80001002,

  /** No component with the specified name string was found */
  OMX_ErrorComponentNotFound = (OMX_S32) 0x80001003,

  /** The component specified did not have a "OMX_ComponentInit" or
      "OMX_ComponentDeInit entry point */
  OMX_ErrorInvalidComponent = (OMX_S32) 0x80001004,

  /** One or more parameters were not valid */
  OMX_ErrorBadParameter = (OMX_S32) 0x80001005,

  /** The requested function is not implemented */
  OMX_ErrorNotImplemented = (OMX_S32) 0x80001006,

  /** The buffer was emptied before the next buffer was ready */
  OMX_ErrorUnderflow = (OMX_S32) 0x80001007,

  /** The buffer was not available when it was needed */
  OMX_ErrorOverflow = (OMX_S32) 0x80001008,

  /** The hardware failed to respond as expected */
  OMX_ErrorHardware = (OMX_S32) 0x80001009,

  /** The component is in the state OMX_StateInvalid */
  OMX_ErrorInvalidState = (OMX_S32) 0x8000100A,

  /** Stream is found to be corrupt */
  OMX_ErrorStreamCorrupt = (OMX_S32) 0x8000100B,

  /** Ports being connected are not compatible */
  OMX_ErrorPortsNotCompatible = (OMX_S32) 0x8000100C,

  /** Resources allocated to an idle component have been
      lost resulting in the component returning to the loaded state */
  OMX_ErrorResourcesLost = (OMX_S32) 0x8000100D,

  /** No more indicies can be enumerated */
  OMX_ErrorNoMore = (OMX_S32) 0x8000100E,

  /** The component detected a version mismatch */
  OMX_ErrorVersionMismatch = (OMX_S32) 0x8000100F,

  /** The component is not ready to return data at this time */
  OMX_ErrorNotReady = (OMX_S32) 0x80001010,

  /** There was a timeout that occurred */
  OMX_ErrorTimeout = (OMX_S32) 0x80001011,

  /** This error occurs when trying to transition into the state you are already in */
  OMX_ErrorSameState = (OMX_S32) 0x80001012,

  /** Resources allocated to an executing or paused component have been 
      preempted, causing the component to return to the idle state */
  OMX_ErrorResourcesPreempted = (OMX_S32) 0x80001013, 

  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
      on a port restart) when it deems that it has waited an unusually long time for the supplier 
      to send it an allocated buffer via a UseBuffer call. */
  OMX_ErrorPortUnresponsiveDuringAllocation = (OMX_S32) 0x80001014,

  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
      during the deallocation of buffers (on a transition from the IDLE to LOADED state or 
      on a port stop) when it deems that it has waited an unusually long time for the supplier 
      to request the deallocation of a buffer header via a FreeBuffer call. */
  OMX_ErrorPortUnresponsiveDuringDeallocation = (OMX_S32) 0x80001015,

  /** A supplier port sends this error to the IL client (via the EventHandler callback) 
      during the stopping of a port (either on a transition from the IDLE to LOADED 
      state or a port stop) when it deems that it has waited an unusually long time for 
      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
  OMX_ErrorPortUnresponsiveDuringStop = (OMX_S32) 0x80001016,

  /** Attempting a state transtion that is not allowed */
  OMX_ErrorIncorrectStateTransition = (OMX_S32) 0x80001017,

  /* Attempting a command that is not allowed during the present state. */
  OMX_ErrorIncorrectStateOperation = (OMX_S32) 0x80001018, 

  /** The values encapsulated in the parameter or config structure are not supported. */
  OMX_ErrorUnsupportedSetting = (OMX_S32) 0x80001019,

  /** The parameter or config indicated by the given index is not supported. */
  OMX_ErrorUnsupportedIndex = (OMX_S32) 0x8000101A,

  /** The port index supplied is incorrect. */
  OMX_ErrorBadPortIndex = (OMX_S32) 0x8000101B,

  /** The port has lost one or more of its buffers and it thus unpopulated. */
  OMX_ErrorPortUnpopulated = (OMX_S32) 0x8000101C,

  /** Component suspended due to temporary loss of resources */
  OMX_ErrorComponentSuspended = (OMX_S32) 0x8000101D,

  /** Component suspended due to an inability to acquire dynamic resources */
  OMX_ErrorDynamicResourcesUnavailable = (OMX_S32) 0x8000101E,

  /** When the macroblock error reporting is enabled the component returns new error 
  for every frame that has errors */
  OMX_ErrorMbErrorsInFrame = (OMX_S32) 0x8000101F,

  /** A component reports this error when it cannot parse or determine the format of an input stream. */
  OMX_ErrorFormatNotDetected = (OMX_S32) 0x80001020, 

  /** The content open operation failed. */
  OMX_ErrorContentPipeOpenFailed = (OMX_S32) 0x80001021,

  /** The content creation operation failed. */
  OMX_ErrorContentPipeCreationFailed = (OMX_S32) 0x80001022,

  /** Separate table information is being used */
  OMX_ErrorSeperateTablesUsed = (OMX_S32) 0x80001023,

  /** Tunneling is unsupported by the component*/
  OMX_ErrorTunnelingUnsupported = (OMX_S32) 0x80001024,

  OMX_ErrorKhronosExtensions = (OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
  OMX_ErrorVendorStartUnused = (OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */

  /** Disk Full error */
  OMX_ErrorDiskFull = (OMX_S32) 0x90000001,
 
  /** Max file size is reached */
  OMX_ErrorMaxFileSize = (OMX_S32) 0x90000002,

  /** Unauthorised to play a DRM protected file */
  OMX_ErrorDrmUnauthorised = (OMX_S32) 0x90000003,

  /** The DRM protected file has expired */
  OMX_ErrorDrmExpired = (OMX_S32) 0x90000004,

  /** Some other DRM library error */
  OMX_ErrorDrmGeneral = (OMX_S32) 0x90000005,

  OMX_ErrorMax = 0x7FFFFFFF
} OMX_ERRORTYPE;

/** @ingroup core */
typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN  OMX_HANDLETYPE hComponent);

/** @ingroup core */
typedef struct OMX_COMPONENTREGISTERTYPE
{
  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
  OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
} OMX_COMPONENTREGISTERTYPE;

/** @ingroup core */
extern OMX_COMPONENTREGISTERTYPE OMX_ComponentRegistered[];

/** @ingroup rpm */
typedef struct OMX_PRIORITYMGMTTYPE {
 OMX_U32 nSize;             /**< size of the structure in bytes */
 OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
 OMX_U32 nGroupPriority;            /**< Priority of the component group */
 OMX_U32 nGroupID;                  /**< ID of the component group */
} OMX_PRIORITYMGMTTYPE;

/* Component name and Role names are limited to 128 characters including the terminating '\0'. */
#define OMX_MAX_STRINGNAME_SIZE 128

/** @ingroup comp */
typedef struct OMX_PARAM_COMPONENTROLETYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
} OMX_PARAM_COMPONENTROLETYPE;

/** End of Stream Buffer Flag: 
  *
  * A component sets EOS when it has no more data to emit on a particular 
  * output port. Thus an output port shall set EOS on the last buffer it 
  * emits. A component's determination of when an output port should 
  * cease sending data is implemenation specific.
  * @ingroup buf
  */

#define OMX_BUFFERFLAG_EOS 0x00000001 

/** Start Time Buffer Flag: 
 *
 * The source of a stream (e.g. a demux component) sets the STARTTIME
 * flag on the buffer that contains the starting timestamp for the
 * stream. The starting timestamp corresponds to the first data that
 * should be displayed at startup or after a seek.
 * The first timestamp of the stream is not necessarily the start time.
 * For instance, in the case of a seek to a particular video frame, 
 * the target frame may be an interframe. Thus the first buffer of 
 * the stream will be the intra-frame preceding the target frame and
 * the starttime will occur with the target frame (with any other
 * required frames required to reconstruct the target intervening).
 *
 * The STARTTIME flag is directly associated with the buffer's 
 * timestamp ' thus its association to buffer data and its 
 * propagation is identical to the timestamp's.
 *
 * When a Sync Component client receives a buffer with the 
 * STARTTIME flag it shall perform a SetConfig on its sync port 
 * using OMX_ConfigTimeClientStartTime and passing the buffer's
 * timestamp.
 * 
 * @ingroup buf
 */

#define OMX_BUFFERFLAG_STARTTIME 0x00000002

 

/** Decode Only Buffer Flag: 
 *
 * The source of a stream (e.g. a demux component) sets the DECODEONLY
 * flag on any buffer that should shall be decoded but should not be
 * displayed. This flag is used, for instance, when a source seeks to 
 * a target interframe that requires the decode of frames preceding the 
 * target to facilitate the target's reconstruction. In this case the 
 * source would emit the frames preceding the target downstream 
 * but mark them as decode only.
 *
 * The DECODEONLY is associated with buffer data and propagated in a 
 * manner identical to the buffer timestamp.
 *
 * A component that renders data should ignore all buffers with 
 * the DECODEONLY flag set.
 * 
 * @ingroup buf
 */

#define OMX_BUFFERFLAG_DECODEONLY 0x00000004


/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt 
 * @ingroup buf
 */

#define OMX_BUFFERFLAG_DATACORRUPT 0x00000008

/* End of Frame: The buffer contains exactly one end of frame and no data
 *  occurs after the end of frame. This flag is an optional hint. The absence
 *  of this flag does not imply the absence of an end of frame within the buffer. 
 * @ingroup buf
*/
#define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010

/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame ' 
 *  a frame that has no dependency on any other frame information 
 *  @ingroup buf
 */
#define OMX_BUFFERFLAG_SYNCFRAME 0x00000020

/* Extra data present flag: there is extra data appended to the data stream
 * residing in the buffer 
 * @ingroup buf  
 */
#define OMX_BUFFERFLAG_EXTRADATA 0x00000040

/** Codec Config Buffer Flag: 
* OMX_BUFFERFLAG_CODECCONFIG is an optional flag that is set by an
* output port when all bytes in the buffer form part or all of a set of
* codec specific configuration data.  Examples include SPS/PPS nal units
* for OMX_VIDEO_CodingAVC or AudioSpecificConfig data for
* OMX_AUDIO_CodingAAC.  Any component that for a given stream sets 
* OMX_BUFFERFLAG_CODECCONFIG shall not mix codec configuration bytes
* with frame data in the same buffer, and shall send all buffers
* containing codec configuration bytes before any buffers containing
* frame data that those configurations bytes describe.
* If the stream format for a particular codec has a frame specific
* header at the start of each frame, for example OMX_AUDIO_CodingMP3 or
* OMX_AUDIO_CodingAAC in ADTS mode, then these shall be presented as
* normal without setting OMX_BUFFERFLAG_CODECCONFIG.
 * @ingroup buf
 */
#define OMX_BUFFERFLAG_CODECCONFIG 0x00000080



/** @ingroup buf */
typedef struct OMX_BUFFERHEADERTYPE
{
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U8* pBuffer;            /**< Pointer to actual block of memory 
                                     that is acting as the buffer */
    OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
    OMX_U32 nFilledLen;         /**< number of bytes currently in the 
                                     buffer */
    OMX_U32 nOffset;            /**< start offset of valid data in bytes from
                                     the start of the buffer */
    OMX_PTR pAppPrivate;        /**< pointer to any data the application
                                     wants to associate with this buffer */
    OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
                                     wants to associate with this buffer */ 
    OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
                                     wants to associate with this buffer */
    OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
                                     wants to associate with this buffer */
    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a 
                                              mark event upon processing this buffer. */
    OMX_PTR pMarkData;          /**< Application specific data associated with 
                                     the mark sent on a mark event to disambiguate 
                                     this mark from others. */
    OMX_U32 nTickCount;         /**< Optional entry that the component and
                                     application can update with a tick count
                                     when they access the component.  This
                                     value should be in microseconds.  Since
                                     this is a value relative to an arbitrary
                                     starting point, this value cannot be used 
                                     to determine absolute time.  This is an
                                     optional entry and not all components
                                     will update it.*/
 OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample 
                                     starting at the first logical sample 
                                     boundary in the buffer. Timestamps of 
                                     successive samples within the buffer may
                                     be inferred by adding the duration of the 
                                     of the preceding buffer to the timestamp
                                     of the preceding buffer.*/
  OMX_U32     nFlags;           /**< buffer specific flags */
  OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using 
                                     this buffer */
  OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
                                     this buffer */
} OMX_BUFFERHEADERTYPE;

/** The OMX_EXTRADATATYPE enumeration is used to define the 
 * possible extra data payload types.
 * NB: this enum is binary backwards compatible with the previous
 * OMX_EXTRADATA_QUANT define.  This should be replaced with
 * OMX_ExtraDataQuantization.
 */
typedef enum OMX_EXTRADATATYPE
{
   OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */        
   OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
   OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

   OMX_ExtraDataSequenceGap,                    /**< Indicates a gap in sequence numbers, data is uint32_t 
                                                     saying how many frames were lost */
   OMX_ExtraDataDecodeOnlyUntil,                /**< Indicates a timestamp until which all data should be
                                                     decoded only, and the first packets after should generate
                                                     a client start time flag.  data is int32_t of seek time
                                                     in milliseconds */

   OMX_ExtraDataMax = 0x7FFFFFFF
} OMX_EXTRADATATYPE;


typedef struct OMX_OTHER_EXTRADATATYPE  {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;               
    OMX_U32 nPortIndex;
    OMX_EXTRADATATYPE eType;       /* Extra Data type */
    OMX_U32 nDataSize;   /* Size of the supporting data to follow */
    OMX_U8  data[1];     /* Supporting data hint  */
} OMX_OTHER_EXTRADATATYPE;

/** @ingroup comp */
typedef struct OMX_PORT_PARAM_TYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPorts;             /**< The number of ports for this component */
    OMX_U32 nStartPortNumber;   /** first port number for this type of port */
} OMX_PORT_PARAM_TYPE; 

/** @ingroup comp */
typedef enum OMX_EVENTTYPE
{
    OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
    OMX_EventError,               /**< component has detected an error condition */
    OMX_EventMark,                /**< component has detected a buffer mark */
    OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
    OMX_EventBufferFlag,          /**< component has detected an EOS */ 
    OMX_EventResourcesAcquired,   /**< component has been granted resources and is
                                       automatically starting the state change from
                                       OMX_StateWaitForResources to OMX_StateIdle. */
   OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
   OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
   OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
   OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
   OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   OMX_EventParamOrConfigChanged,   /* Should be added to the main spec as part of IL416c */
   OMX_EventMax = 0x7FFFFFFF
} OMX_EVENTTYPE;

typedef struct OMX_CALLBACKTYPE
{
    /** The EventHandler method is used to notify the application when an
        event of interest occurs.  Events are defined in the OMX_EVENTTYPE
        enumeration.  Please see that enumeration for details of what will
        be returned for each type of event. Callbacks should not return
        an error to the component, so if an error occurs, the application 
        shall handle it internally.  This is a blocking call.

        The application should return from this call within 5 msec to avoid
        blocking the component for an excessively long period of time.

        @param hComponent
            handle of the component to access.  This is the component
            handle returned by the call to the GetHandle function.
        @param pAppData
            pointer to an application defined value that was provided in the 
            pAppData parameter to the OMX_GetHandle method for the component.
            This application defined value is provided so that the application 
            can have a component specific context when receiving the callback.
        @param eEvent
            Event that the component wants to notify the application about.
        @param nData1
            nData will be the OMX_ERRORTYPE for an error event and will be 
            an OMX_COMMANDTYPE for a command complete event and OMX_INDEXTYPE for a OMX_PortSettingsChanged event.
         @param nData2
            nData2 will hold further information related to the event. Can be OMX_STATETYPE for
            a OMX_CommandStateSet command or port index for a OMX_PortSettingsChanged event.
            Default value is 0 if not used. )
        @param pEventData
            Pointer to additional event-specific data (see spec for meaning).
      */

   OMX_ERRORTYPE (*EventHandler)(
        OMX_IN OMX_HANDLETYPE hComponent,
        OMX_IN OMX_PTR pAppData,
        OMX_IN OMX_EVENTTYPE eEvent,
        OMX_IN OMX_U32 nData1,
        OMX_IN OMX_U32 nData2,
        OMX_IN OMX_PTR pEventData);

    /** The EmptyBufferDone method is used to return emptied buffers from an
        input port back to the application for reuse.  This is a blocking call 
        so the application should not attempt to refill the buffers during this
        call, but should queue them and refill them in another thread.  There
        is no error return, so the application shall handle any errors generated
        internally.  
        
        The application should return from this call within 5 msec.
        
        @param hComponent
            handle of the component to access.  This is the component
            handle returned by the call to the GetHandle function.
        @param pAppData
            pointer to an application defined value that was provided in the 
            pAppData parameter to the OMX_GetHandle method for the component.
            This application defined value is provided so that the application 
            can have a component specific context when receiving the callback.
        @param pBuffer
            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
            or AllocateBuffer indicating the buffer that was emptied.
        @ingroup buf
     */
    OMX_ERRORTYPE (*EmptyBufferDone)(
        OMX_IN OMX_HANDLETYPE hComponent,
        OMX_IN OMX_PTR pAppData,
        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);

    /** The FillBufferDone method is used to return filled buffers from an
        output port back to the application for emptying and then reuse.  
        This is a blocking call so the application should not attempt to 
        empty the buffers during this call, but should queue the buffers 
        and empty them in another thread.  There is no error return, so 
        the application shall handle any errors generated internally.  The 
        application shall also update the buffer header to indicate the
        number of bytes placed into the buffer.  

        The application should return from this call within 5 msec.
        
        @param hComponent
            handle of the component to access.  This is the component
            handle returned by the call to the GetHandle function.
        @param pAppData
            pointer to an application defined value that was provided in the 
            pAppData parameter to the OMX_GetHandle method for the component.
            This application defined value is provided so that the application 
            can have a component specific context when receiving the callback.
        @param pBuffer
            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
            or AllocateBuffer indicating the buffer that was filled.
        @ingroup buf
     */
    OMX_ERRORTYPE (*FillBufferDone)(
        OMX_OUT OMX_HANDLETYPE hComponent,
        OMX_OUT OMX_PTR pAppData,
        OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);

} OMX_CALLBACKTYPE;

/** The OMX_BUFFERSUPPLIERTYPE enumeration is used to dictate port supplier
    preference when tunneling between two ports.
    @ingroup tun buf
*/
typedef enum OMX_BUFFERSUPPLIERTYPE
{
    OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
                                              or don't care */
    OMX_BufferSupplyInput,             /**< input port supplies the buffers */
    OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
    OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_BufferSupplyVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_BufferSupplyMax = 0x7FFFFFFF
} OMX_BUFFERSUPPLIERTYPE;


/** buffer supplier parameter 
 * @ingroup tun
 */
typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
    OMX_U32 nSize; /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex; /**< port that this structure applies to */
    OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< buffer supplier */
} OMX_PARAM_BUFFERSUPPLIERTYPE;


/**< indicates that buffers received by an input port of a tunnel 
     may not modify the data in the buffers 
     @ingroup tun
 */
#define OMX_PORTTUNNELFLAG_READONLY 0x00000001 


/** The OMX_TUNNELSETUPTYPE structure is used to pass data from an output
    port to an input port as part the two ComponentTunnelRequest calls
    resulting from a OMX_SetupTunnel call from the IL Client. 
    @ingroup tun
 */   
typedef struct OMX_TUNNELSETUPTYPE
{
    OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
    OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
} OMX_TUNNELSETUPTYPE; 

/* OMX Component headers is included to enable the core to use
   macros for functions into the component for OMX release 1.0.  
   Developers should not access any structures or data from within
   the component header directly */
/* TO BE REMOVED - #include <OMX_Component.h> */

/** GetComponentVersion will return information about the component.  
    This is a blocking call.  This macro will go directly from the
    application to the component (via a core macro).  The
    component will return from this call within 5 msec.
    @param [in] hComponent
        handle of component to execute the command
    @param [out] pComponentName
        pointer to an empty string of length 128 bytes.  The component 
        will write its name into this string.  The name will be 
        terminated by a single zero byte.  The name of a component will 
        be 127 bytes or less to leave room for the trailing zero byte.  
        An example of a valid component name is "OMX.ABC.ChannelMixer\0".
    @param [out] pComponentVersion
        pointer to an OMX Version structure that the component will fill 
        in.  The component will fill in a value that indicates the 
        component version.  NOTE: the component version is NOT the same 
        as the OMX Specification version (found in all structures).  The 
        component version is defined by the vendor of the component and 
        its value is entirely up to the component vendor.
    @param [out] pSpecVersion
        pointer to an OMX Version structure that the component will fill 
        in.  The SpecVersion is the version of the specification that the 
        component was built against.  Please note that this value may or 
        may not match the structure's version.  For example, if the 
        component was built against the 2.0 specification, but the 
        application (which creates the structure is built against the 
        1.0 specification the versions would be different.
    @param [out] pComponentUUID
        pointer to the UUID of the component which will be filled in by 
        the component.  The UUID is a unique identifier that is set at 
        RUN time for the component and is unique to each instantion of 
        the component.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_GetComponentVersion(                            \
        hComponent,                                         \
        pComponentName,                                     \
        pComponentVersion,                                  \
        pSpecVersion,                                       \
        pComponentUUID)                                     \
    ((OMX_COMPONENTTYPE*)hComponent)->GetComponentVersion(  \
        hComponent,                                         \
        pComponentName,                                     \
        pComponentVersion,                                  \
        pSpecVersion,                                       \
        pComponentUUID)                 /* Macro End */


/** Send a command to the component.  This call is a non-blocking call.
    The component should check the parameters and then queue the command
    to the component thread to be executed.  The component thread shall 
    send the EventHandler() callback at the conclusion of the command. 
    This macro will go directly from the application to the component (via
    a core macro).  The component will return from this call within 5 msec.
    
    When the command is "OMX_CommandStateSet" the component will queue a
    state transition to the new state idenfied in nParam.
    
    When the command is "OMX_CommandFlush", to flush a port's buffer queues,
    the command will force the component to return all buffers NOT CURRENTLY 
    BEING PROCESSED to the application, in the order in which the buffers 
    were received.
    
    When the command is "OMX_CommandPortDisable" or 
    "OMX_CommandPortEnable", the component's port (given by the value of
    nParam) will be stopped or restarted. 
    
    When the command "OMX_CommandMarkBuffer" is used to mark a buffer, the
    pCmdData will point to a OMX_MARKTYPE structure containing the component
    handle of the component to examine the buffer chain for the mark.  nParam1
    contains the index of the port on which the buffer mark is applied.

    Specification text for more details. 
    
    @param [in] hComponent
        handle of component to execute the command
    @param [in] Cmd
        Command for the component to execute
    @param [in] nParam
        Parameter for the command to be executed.  When Cmd has the value 
        OMX_CommandStateSet, value is a member of OMX_STATETYPE.  When Cmd has 
        the value OMX_CommandFlush, value of nParam indicates which port(s) 
        to flush. -1 is used to flush all ports a single port index will 
        only flush that port.  When Cmd has the value "OMX_CommandPortDisable"
        or "OMX_CommandPortEnable", the component's port is given by 
        the value of nParam.  When Cmd has the value "OMX_CommandMarkBuffer"
        the components pot is given by the value of nParam.
    @param [in] pCmdData
        Parameter pointing to the OMX_MARKTYPE structure when Cmd has the value
        "OMX_CommandMarkBuffer".     
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_SendCommand(                                    \
         hComponent,                                        \
         Cmd,                                               \
         nParam,                                            \
         pCmdData)                                          \
     ((OMX_COMPONENTTYPE*)hComponent)->SendCommand(         \
         hComponent,                                        \
         Cmd,                                               \
         nParam,                                            \
         pCmdData)                          /* Macro End */


/** The OMX_GetParameter macro will get one of the current parameter 
    settings from the component.  This macro cannot only be invoked when 
    the component is in the OMX_StateInvalid state.  The nParamIndex
    parameter is used to indicate which structure is being requested from
    the component.  The application shall allocate the correct structure 
    and shall fill in the structure size and version information before 
    invoking this macro.  When the parameter applies to a port, the
    caller shall fill in the appropriate nPortIndex value indicating the
    port on which the parameter applies. If the component has not had 
    any settings changed, then the component should return a set of 
    valid DEFAULT  parameters for the component.  This is a blocking 
    call.  
    
    The component should return from this call within 20 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] nParamIndex
        Index of the structure to be filled.  This value is from the
        OMX_INDEXTYPE enumeration.
    @param [in,out] pComponentParameterStructure
        Pointer to application allocated structure to be filled by the 
        component.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_GetParameter(                                   \
        hComponent,                                         \
        nParamIndex,                                        \
        pComponentParameterStructure)                        \
    ((OMX_COMPONENTTYPE*)hComponent)->GetParameter(         \
        hComponent,                                         \
        nParamIndex,                                        \
        pComponentParameterStructure)    /* Macro End */


/** The OMX_SetParameter macro will send an initialization parameter
    structure to a component.  Each structure shall be sent one at a time,
    in a separate invocation of the macro.  This macro can only be
    invoked when the component is in the OMX_StateLoaded state, or the
    port is disabled (when the parameter applies to a port). The 
    nParamIndex parameter is used to indicate which structure is being
    passed to the component.  The application shall allocate the 
    correct structure and shall fill in the structure size and version 
    information (as well as the actual data) before invoking this macro.
    The application is free to dispose of this structure after the call
    as the component is required to copy any data it shall retain.  This 
    is a blocking call.  
    
    The component should return from this call within 20 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] nIndex
        Index of the structure to be sent.  This value is from the
        OMX_INDEXTYPE enumeration.
    @param [in] pComponentParameterStructure
        pointer to application allocated structure to be used for
        initialization by the component.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_SetParameter(                                   \
        hComponent,                                         \
        nParamIndex,                                        \
        pComponentParameterStructure)                        \
    ((OMX_COMPONENTTYPE*)hComponent)->SetParameter(         \
        hComponent,                                         \
        nParamIndex,                                        \
        pComponentParameterStructure)    /* Macro End */


/** The OMX_GetConfig macro will get one of the configuration structures 
    from a component.  This macro can be invoked anytime after the 
    component has been loaded.  The nParamIndex call parameter is used to 
    indicate which structure is being requested from the component.  The 
    application shall allocate the correct structure and shall fill in the 
    structure size and version information before invoking this macro.  
    If the component has not had this configuration parameter sent before, 
    then the component should return a set of valid DEFAULT values for the 
    component.  This is a blocking call.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] nIndex
        Index of the structure to be filled.  This value is from the
        OMX_INDEXTYPE enumeration.
    @param [in,out] pComponentConfigStructure
        pointer to application allocated structure to be filled by the 
        component.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
*/        
#define OMX_GetConfig(                                      \
        hComponent,                                         \
        nConfigIndex,                                       \
        pComponentConfigStructure)                           \
    ((OMX_COMPONENTTYPE*)hComponent)->GetConfig(            \
        hComponent,                                         \
        nConfigIndex,                                       \
        pComponentConfigStructure)       /* Macro End */


/** The OMX_SetConfig macro will send one of the configuration 
    structures to a component.  Each structure shall be sent one at a time,
    each in a separate invocation of the macro.  This macro can be invoked 
    anytime after the component has been loaded.  The application shall 
    allocate the correct structure and shall fill in the structure size 
    and version information (as well as the actual data) before invoking 
    this macro.  The application is free to dispose of this structure after 
    the call as the component is required to copy any data it shall retain.  
    This is a blocking call.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] nConfigIndex
        Index of the structure to be sent.  This value is from the
        OMX_INDEXTYPE enumeration above.
    @param [in] pComponentConfigStructure
        pointer to application allocated structure to be used for
        initialization by the component.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_SetConfig(                                      \
        hComponent,                                         \
        nConfigIndex,                                       \
        pComponentConfigStructure)                           \
    ((OMX_COMPONENTTYPE*)hComponent)->SetConfig(            \
        hComponent,                                         \
        nConfigIndex,                                       \
        pComponentConfigStructure)       /* Macro End */


/** The OMX_GetExtensionIndex macro will invoke a component to translate 
    a vendor specific configuration or parameter string into an OMX 
    structure index.  There is no requirement for the vendor to support 
    this command for the indexes already found in the OMX_INDEXTYPE 
    enumeration (this is done to save space in small components).  The 
    component shall support all vendor supplied extension indexes not found
    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the GetHandle function.
    @param [in] cParameterName
        OMX_STRING that shall be less than 128 characters long including
        the trailing null byte.  This is the string that will get 
        translated by the component into a configuration index.
    @param [out] pIndexType
        a pointer to a OMX_INDEXTYPE to receive the index value.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_GetExtensionIndex(                              \
        hComponent,                                         \
        cParameterName,                                     \
        pIndexType)                                         \
    ((OMX_COMPONENTTYPE*)hComponent)->GetExtensionIndex(    \
        hComponent,                                         \
        cParameterName,                                     \
        pIndexType)                     /* Macro End */


/** The OMX_GetState macro will invoke the component to get the current 
    state of the component and place the state value into the location
    pointed to by pState.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [out] pState
        pointer to the location to receive the state.  The value returned
        is one of the OMX_STATETYPE members 
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp
 */
#define OMX_GetState(                                       \
        hComponent,                                         \
        pState)                                             \
    ((OMX_COMPONENTTYPE*)hComponent)->GetState(             \
        hComponent,                                         \
        pState)                         /* Macro End */


/** The OMX_UseBuffer macro will request that the component use
    a buffer (and allocate its own buffer header) already allocated 
    by another component, or by the IL Client. This is a blocking 
    call.
    
    The component should return from this call within 20 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [out] ppBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
        pointer to the buffer header
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */

#define OMX_UseBuffer(                                      \
           hComponent,                                      \
           ppBufferHdr,                                     \
           nPortIndex,                                      \
           pAppPrivate,                                     \
           nSizeBytes,                                      \
           pBuffer)                                         \
    ((OMX_COMPONENTTYPE*)hComponent)->UseBuffer(            \
           hComponent,                                      \
           ppBufferHdr,                                     \
           nPortIndex,                                      \
           pAppPrivate,                                     \
           nSizeBytes,                                      \
           pBuffer)


/** The OMX_AllocateBuffer macro will request that the component allocate 
    a new buffer and buffer header.  The component will allocate the 
    buffer and the buffer header and return a pointer to the buffer 
    header.  This is a blocking call.
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [out] ppBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure used to receive 
        the pointer to the buffer header
    @param [in] nPortIndex
        nPortIndex is used to select the port on the component the buffer will
        be used with.  The port can be found by using the nPortIndex
        value as an index into the Port Definition array of the component.
    @param [in] pAppPrivate
        pAppPrivate is used to initialize the pAppPrivate member of the 
        buffer header structure.
    @param [in] nSizeBytes
        size of the buffer to allocate.  Used when bAllocateNew is true.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */    
#define OMX_AllocateBuffer(                                 \
        hComponent,                                         \
        ppBuffer,                                           \
        nPortIndex,                                         \
        pAppPrivate,                                        \
        nSizeBytes)                                         \
    ((OMX_COMPONENTTYPE*)hComponent)->AllocateBuffer(       \
        hComponent,                                         \
        ppBuffer,                                           \
        nPortIndex,                                         \
        pAppPrivate,                                        \
        nSizeBytes)                     /* Macro End */


/** The OMX_FreeBuffer macro will release a buffer header from the component
    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If  
    the component allocated the buffer (see the OMX_UseBuffer macro) then 
    the component shall free the buffer and buffer header. This is a 
    blocking call. 
    
    The component should return from this call within 20 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] nPortIndex
        nPortIndex is used to select the port on the component the buffer will
        be used with.
    @param [in] pBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
        or AllocateBuffer.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */
#define OMX_FreeBuffer(                                     \
        hComponent,                                         \
        nPortIndex,                                         \
        pBuffer)                                            \
    ((OMX_COMPONENTTYPE*)hComponent)->FreeBuffer(           \
        hComponent,                                         \
        nPortIndex,                                         \
        pBuffer)                        /* Macro End */


/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an 
    input port of a component.  The buffer will be emptied by the component
    and returned to the application via the EmptyBufferDone call back.
    This is a non-blocking call in that the component will record the buffer
    and return immediately and then empty the buffer, later, at the proper 
    time.  As expected, this macro may be invoked only while the component 
    is in the OMX_StateExecuting.  If nPortIndex does not specify an input
    port, the component shall return an error.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] pBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
        or AllocateBuffer.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */
#define OMX_EmptyThisBuffer(                                \
        hComponent,                                         \
        pBuffer)                                            \
    ((OMX_COMPONENTTYPE*)hComponent)->EmptyThisBuffer(      \
        hComponent,                                         \
        pBuffer)                        /* Macro End */


/** The OMX_FillThisBuffer macro will send an empty buffer to an 
    output port of a component.  The buffer will be filled by the component
    and returned to the application via the FillBufferDone call back.
    This is a non-blocking call in that the component will record the buffer
    and return immediately and then fill the buffer, later, at the proper 
    time.  As expected, this macro may be invoked only while the component 
    is in the OMX_ExecutingState.  If nPortIndex does not specify an output
    port, the component shall return an error.  
    
    The component should return from this call within 5 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [in] pBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
        or AllocateBuffer.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */
#define OMX_FillThisBuffer(                                 \
        hComponent,                                         \
        pBuffer)                                            \
    ((OMX_COMPONENTTYPE*)hComponent)->FillThisBuffer(       \
        hComponent,                                         \
        pBuffer)                        /* Macro End */



/** The OMX_UseEGLImage macro will request that the component use
    a EGLImage provided by EGL (and allocate its own buffer header)
    This is a blocking call.
    
    The component should return from this call within 20 msec.
    
    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the OMX_GetHandle function.
    @param [out] ppBuffer
        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
        pointer to the buffer header.  Note that the memory location used
        for this buffer is NOT visible to the IL Client.
    @param [in] nPortIndex
        nPortIndex is used to select the port on the component the buffer will
        be used with.  The port can be found by using the nPortIndex
        value as an index into the Port Definition array of the component.
    @param [in] pAppPrivate
        pAppPrivate is used to initialize the pAppPrivate member of the 
        buffer header structure.
    @param [in] eglImage
        eglImage contains the handle of the EGLImage to use as a buffer on the
        specified port.  The component is expected to validate properties of 
        the EGLImage against the configuration of the port to ensure the component
        can use the EGLImage as a buffer.          
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup comp buf
 */
#define OMX_UseEGLImage(                                    \
           hComponent,                                      \
           ppBufferHdr,                                     \
           nPortIndex,                                      \
           pAppPrivate,                                     \
           eglImage)                                        \
    ((OMX_COMPONENTTYPE*)hComponent)->UseEGLImage(          \
           hComponent,                                      \
           ppBufferHdr,                                     \
           nPortIndex,                                      \
           pAppPrivate,                                     \
           eglImage)

/** The OMX_Init method is used to initialize the OMX core.  It shall be the
    first call made into OMX and it should only be executed one time without
    an interviening OMX_Deinit call.  
    
    The core should return from this call within 20 msec.

    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);


/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be 
    the last call made into OMX. In the event that the core determines that 
    thare are components loaded when this call is made, the core may return 
    with an error rather than try to unload the components.
        
    The core should return from this call within 20 msec.
    
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void);


/** The OMX_ComponentNameEnum method will enumerate through all the names of
    recognised valid components in the system. This function is provided
    as a means to detect all the components in the system run-time. There is
    no strict ordering to the enumeration order of component names, although
    each name will only be enumerated once.  If the OMX core supports run-time
    installation of new components, it is only requried to detect newly
    installed components when the first call to enumerate component names
    is made (i.e. when nIndex is 0x0).
    
    The core should return from this call in 20 msec.
    
    @param [out] cComponentName
        pointer to a null terminated string with the component name.  The
        names of the components are strings less than 127 bytes in length
        plus the trailing null for a maximum size of 128 bytes.  An example 
        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
        assigned by the vendor, but shall start with "OMX." and then have 
        the Vendor designation next.
    @param [in] nNameLength
        number of characters in the cComponentName string.  With all 
        component name strings restricted to less than 128 characters 
        (including the trailing null) it is recomended that the caller
        provide a input string for the cComponentName of 128 characters.
    @param [in] nIndex
        number containing the enumeration index for the component. 
        Multiple calls to OMX_ComponentNameEnum with increasing values
        of nIndex will enumerate through the component names in the
        system until OMX_ErrorNoMore is returned.  The value of nIndex
        is 0 to (N-1), where N is the number of valid installed components
        in the system.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  When the value of nIndex exceeds the number of 
        components in the system minus 1, OMX_ErrorNoMore will be
        returned. Otherwise the appropriate OMX error will be returned.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
    OMX_OUT OMX_STRING cComponentName,
    OMX_IN  OMX_U32 nNameLength,
    OMX_IN  OMX_U32 nIndex);


/** The OMX_GetHandle method will locate the component specified by the
    component name given, load that component into memory and then invoke
    the component's methods to create an instance of the component.  
    
    The core should return from this call within 20 msec.
    
    @param [out] pHandle
        pointer to an OMX_HANDLETYPE pointer to be filled in by this method.
    @param [in] cComponentName
        pointer to a null terminated string with the component name.  The
        names of the components are strings less than 127 bytes in length
        plus the trailing null for a maximum size of 128 bytes.  An example 
        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
        assigned by the vendor, but shall start with "OMX." and then have 
        the Vendor designation next.
    @param [in] pAppData
        pointer to an application defined value that will be returned
        during callbacks so that the application can identify the source
        of the callback.
    @param [in] pCallBacks
        pointer to a OMX_CALLBACKTYPE structure that will be passed to the
        component to initialize it with.  
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
    OMX_OUT OMX_HANDLETYPE* pHandle, 
    OMX_IN  OMX_STRING cComponentName,
    OMX_IN  OMX_PTR pAppData,
    OMX_IN  OMX_CALLBACKTYPE* pCallBacks);


/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle 
    method.  If the component reference count goes to zero, the component will
    be unloaded from memory.  
    
    The core should return from this call within 20 msec when the component is 
    in the OMX_StateLoaded state.

    @param [in] hComponent
        Handle of the component to be accessed.  This is the component
        handle returned by the call to the GetHandle function.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
    OMX_IN  OMX_HANDLETYPE hComponent);



/** The OMX_SetupTunnel method will handle the necessary calls to the components
    to setup the specified tunnel the two components.  NOTE: This is
    an actual method (not a #define macro).  This method will make calls into
    the component ComponentTunnelRequest method to do the actual tunnel 
    connection.  

    The ComponentTunnelRequest method on both components will be called. 
    This method shall not be called unless the component is in the 
    OMX_StateLoaded state except when the ports used for the tunnel are
    disabled. In this case, the component may be in the OMX_StateExecuting,
    OMX_StatePause, or OMX_StateIdle states. 

    The core should return from this call within 20 msec.
    
    @param [in] hOutput
        Handle of the component to be accessed.  Also this is the handle
        of the component whose port, specified in the nPortOutput parameter
        will be used the source for the tunnel. This is the component handle
        returned by the call to the OMX_GetHandle function.  There is a 
        requirement that hOutput be the source for the data when
        tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
        specified in hInput will have it's port specified in nPortInput
        setup for communication with the application / IL client.
    @param [in] nPortOutput
        nPortOutput is used to select the source port on component to be
        used in the tunnel. 
    @param [in] hInput
        This is the component to setup the tunnel with. This is the handle
        of the component whose port, specified in the nPortInput parameter
        will be used the destination for the tunnel. This is the component handle
        returned by the call to the OMX_GetHandle function.  There is a 
        requirement that hInput be the destination for the data when
        tunelling (i.e. nPortInut is an input port).   If 0x0, the component
        specified in hOutput will have it's port specified in nPortPOutput
        setup for communication with the application / IL client.
    @param [in] nPortInput
        nPortInput is used to select the destination port on component to be
        used in the tunnel.
    @return OMX_ERRORTYPE
        If the command successfully executes, the return code will be
        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
        When OMX_ErrorNotImplemented is returned, one or both components is 
        a non-interop component and does not support tunneling.
        
        On failure, the ports of both components are setup for communication
        with the application / IL Client.
    @ingroup core tun
 */
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
    OMX_IN  OMX_HANDLETYPE hOutput,
    OMX_IN  OMX_U32 nPortOutput,
    OMX_IN  OMX_HANDLETYPE hInput,
    OMX_IN  OMX_U32 nPortInput);
    
/** @ingroup cp */
OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
    OMX_OUT OMX_HANDLETYPE *hPipe,
    OMX_IN OMX_STRING szURI);

/** The OMX_GetComponentsOfRole method will return the number of components that support the given
    role and (if the compNames field is non-NULL) the names of those components. The call will fail if 
    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
    client should:
        * first call this function with the compNames field NULL to determine the number of component names
        * second call this function with the compNames field pointing to an array of names allocated 
          according to the number returned by the first call.

    The core should return from this call within 5 msec.
    
    @param [in] role
        This is generic standard component name consisting only of component class 
        name and the type within that class (e.g. 'audio_decoder.aac').
    @param [inout] pNumComps
        This is used both as input and output. 
 
        If compNames is NULL, the input is ignored and the output specifies how many components support
        the given role.
     
        If compNames is not NULL, on input it bounds the size of the input structure and 
        on output, it specifies the number of components string names listed within the compNames parameter.
    @param [inout] compNames
        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts 
        a list of the names of all physical components that implement the specified standard component name. 
        Each name is NULL terminated. numComps indicates the number of names.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole ( 
	OMX_IN      OMX_STRING role,
    OMX_INOUT   OMX_U32 *pNumComps,
    OMX_INOUT   OMX_U8  **compNames);

/** The OMX_GetRolesOfComponent method will return the number of roles supported by the given
    component and (if the roles field is non-NULL) the names of those roles. The call will fail if 
    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
    client should:
        * first call this function with the roles field NULL to determine the number of role names
        * second call this function with the roles field pointing to an array of names allocated 
          according to the number returned by the first call.

    The core should return from this call within 5 msec.

    @param [in] compName
        This is the name of the component being queried about.
    @param [inout] pNumRoles
        This is used both as input and output. 
 
        If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
     
        If compNames is not NULL, on input it bounds the size of the input structure and 
        on output, it specifies the number of roles string names listed within the roles parameter.
    @param [out] roles
        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings 
        which accepts a list of the names of all standard components roles implemented on the 
        specified component name. numComps indicates the number of names.
    @ingroup core
 */
OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent ( 
	OMX_IN      OMX_STRING compName, 
    OMX_INOUT   OMX_U32 *pNumRoles,
    OMX_OUT     OMX_U8 **roles);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** 
 * @file OMX_IVCommon.h - OpenMax IL version 1.1.2
 *  The structures needed by Video and Image components to exchange
 *  parameters and configuration data with the components.
 */
#ifndef OMX_IVCommon_h
#define OMX_IVCommon_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/**
 * Each OMX header must include all required header files to allow the header
 * to compile without errors.  The includes below are required for this header
 * file to compile successfully 
 */

#include "OMX_Core.h"

/** @defgroup iv OpenMAX IL Imaging and Video Domain
 * Common structures for OpenMAX IL Imaging and Video domains
 * @{
 */


/** 
 * Enumeration defining possible uncompressed image/video formats. 
 *
 * ENUMS:
 *  Unused                 : Placeholder value when format is N/A
 *  Monochrome             : black and white
 *  8bitRGB332             : Red 7:5, Green 4:2, Blue 1:0
 *  12bitRGB444            : Red 11:8, Green 7:4, Blue 3:0
 *  16bitARGB4444          : Alpha 15:12, Red 11:8, Green 7:4, Blue 3:0
 *  16bitARGB1555          : Alpha 15, Red 14:10, Green 9:5, Blue 4:0
 *  16bitRGB565            : Red 15:11, Green 10:5, Blue 4:0
 *  16bitBGR565            : Blue 15:11, Green 10:5, Red 4:0
 *  18bitRGB666            : Red 17:12, Green 11:6, Blue 5:0
 *  18bitARGB1665          : Alpha 17, Red 16:11, Green 10:5, Blue 4:0
 *  19bitARGB1666          : Alpha 18, Red 17:12, Green 11:6, Blue 5:0
 *  24bitRGB888            : Red 24:16, Green 15:8, Blue 7:0
 *  24bitBGR888            : Blue 24:16, Green 15:8, Red 7:0
 *  24bitARGB1887          : Alpha 23, Red 22:15, Green 14:7, Blue 6:0
 *  25bitARGB1888          : Alpha 24, Red 23:16, Green 15:8, Blue 7:0
 *  32bitBGRA8888          : Blue 31:24, Green 23:16, Red 15:8, Alpha 7:0
 *  32bitARGB8888          : Alpha 31:24, Red 23:16, Green 15:8, Blue 7:0
 *  YUV411Planar           : U,Y are subsampled by a factor of 4 horizontally
 *  YUV411PackedPlanar     : packed per payload in planar slices
 *  YUV420Planar           : Three arrays Y,U,V.
 *  YUV420PackedPlanar     : packed per payload in planar slices
 *  YUV420SemiPlanar       : Two arrays, one is all Y, the other is U and V
 *  YUV422Planar           : Three arrays Y,U,V.
 *  YUV422PackedPlanar     : packed per payload in planar slices
 *  YUV422SemiPlanar       : Two arrays, one is all Y, the other is U and V
 *  YCbYCr                 : Organized as 16bit YUYV (i.e. YCbYCr)
 *  YCrYCb                 : Organized as 16bit YVYU (i.e. YCrYCb)
 *  CbYCrY                 : Organized as 16bit UYVY (i.e. CbYCrY)
 *  CrYCbY                 : Organized as 16bit VYUY (i.e. CrYCbY)
 *  YUV444Interleaved      : Each pixel contains equal parts YUV
 *  RawBayer8bit           : SMIA camera output format
 *  RawBayer10bit          : SMIA camera output format
 *  RawBayer8bitcompressed : SMIA camera output format
 Vendor extensions
 *  32bitABGR888           : Alpha 31:24, Blue 23:16, Green 15:8, Red 7:0
 */
typedef enum OMX_COLOR_FORMATTYPE {
    OMX_COLOR_FormatUnused,
    OMX_COLOR_FormatMonochrome,
    OMX_COLOR_Format8bitRGB332,
    OMX_COLOR_Format12bitRGB444,
    OMX_COLOR_Format16bitARGB4444,
    OMX_COLOR_Format16bitARGB1555,
    OMX_COLOR_Format16bitRGB565,
    OMX_COLOR_Format16bitBGR565,
    OMX_COLOR_Format18bitRGB666,
    OMX_COLOR_Format18bitARGB1665,
    OMX_COLOR_Format19bitARGB1666, 
    OMX_COLOR_Format24bitRGB888,
    OMX_COLOR_Format24bitBGR888,
    OMX_COLOR_Format24bitARGB1887,
    OMX_COLOR_Format25bitARGB1888,
    OMX_COLOR_Format32bitBGRA8888,
    OMX_COLOR_Format32bitARGB8888,
    OMX_COLOR_FormatYUV411Planar,
    OMX_COLOR_FormatYUV411PackedPlanar,
    OMX_COLOR_FormatYUV420Planar,
    OMX_COLOR_FormatYUV420PackedPlanar,
    OMX_COLOR_FormatYUV420SemiPlanar,
    OMX_COLOR_FormatYUV422Planar,
    OMX_COLOR_FormatYUV422PackedPlanar,
    OMX_COLOR_FormatYUV422SemiPlanar,
    OMX_COLOR_FormatYCbYCr,
    OMX_COLOR_FormatYCrYCb,
    OMX_COLOR_FormatCbYCrY,
    OMX_COLOR_FormatCrYCbY,
    OMX_COLOR_FormatYUV444Interleaved,
    OMX_COLOR_FormatRawBayer8bit,
    OMX_COLOR_FormatRawBayer10bit,
    OMX_COLOR_FormatRawBayer8bitcompressed,
    OMX_COLOR_FormatL2, 
    OMX_COLOR_FormatL4, 
    OMX_COLOR_FormatL8, 
    OMX_COLOR_FormatL16, 
    OMX_COLOR_FormatL24, 
    OMX_COLOR_FormatL32,
    OMX_COLOR_FormatYUV420PackedSemiPlanar,
    OMX_COLOR_FormatYUV422PackedSemiPlanar,
    OMX_COLOR_Format18BitBGR666,
    OMX_COLOR_Format24BitARGB6666,
    OMX_COLOR_Format24BitABGR6666,
    OMX_COLOR_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_COLOR_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_COLOR_Format32bitABGR8888,
    OMX_COLOR_Format8bitPalette,
    OMX_COLOR_FormatYUVUV128,
    OMX_COLOR_FormatRawBayer12bit,
    OMX_COLOR_FormatBRCMEGL,
    OMX_COLOR_FormatBRCMOpaque,
    OMX_COLOR_FormatYVU420PackedPlanar,
    OMX_COLOR_FormatYVU420PackedSemiPlanar,
    OMX_COLOR_FormatRawBayer16bit,
    OMX_COLOR_FormatMax = 0x7FFFFFFF
} OMX_COLOR_FORMATTYPE;


/** 
 * Defines the matrix for conversion from RGB to YUV or vice versa.
 * iColorMatrix should be initialized with the fixed point values 
 * used in converting between formats.
 */
typedef struct OMX_CONFIG_COLORCONVERSIONTYPE {
    OMX_U32 nSize;              /**< Size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */ 
    OMX_U32 nPortIndex;         /**< Port that this struct applies to */
    OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
    OMX_S32 xColorOffset[4];    /**< Stored in signed Q16 format */
}OMX_CONFIG_COLORCONVERSIONTYPE;


/** 
 * Structure defining percent to scale each frame dimension.  For example:  
 * To make the width 50% larger, use fWidth = 1.5 and to make the width
 * 1/2 the original size, use fWidth = 0.5
 */
typedef struct OMX_CONFIG_SCALEFACTORTYPE {
    OMX_U32 nSize;            /**< Size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version info */ 
    OMX_U32 nPortIndex;       /**< Port that this struct applies to */
    OMX_S32 xWidth;           /**< Fixed point value stored as Q16 */
    OMX_S32 xHeight;          /**< Fixed point value stored as Q16 */
}OMX_CONFIG_SCALEFACTORTYPE;


/** 
 * Enumeration of possible image filter types 
 */
typedef enum OMX_IMAGEFILTERTYPE {
    OMX_ImageFilterNone,
    OMX_ImageFilterNoise,
    OMX_ImageFilterEmboss,
    OMX_ImageFilterNegative,
    OMX_ImageFilterSketch,
    OMX_ImageFilterOilPaint,
    OMX_ImageFilterHatch,
    OMX_ImageFilterGpen,
    OMX_ImageFilterAntialias, 
    OMX_ImageFilterDeRing,       
    OMX_ImageFilterSolarize,
    OMX_ImageFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_ImageFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
      
    /* Broadcom specific image filters */
    OMX_ImageFilterWatercolor,
    OMX_ImageFilterPastel,
    OMX_ImageFilterSharpen,
    OMX_ImageFilterFilm,
    OMX_ImageFilterBlur,
    OMX_ImageFilterSaturation,

    OMX_ImageFilterDeInterlaceLineDouble,
    OMX_ImageFilterDeInterlaceAdvanced,
    
    OMX_ImageFilterColourSwap,
    OMX_ImageFilterWashedOut,
    OMX_ImageFilterColourPoint,
    OMX_ImageFilterPosterise,
    OMX_ImageFilterColourBalance,
    OMX_ImageFilterCartoon,

    OMX_ImageFilterAnaglyph,
    OMX_ImageFilterDeInterlaceFast,
    OMX_ImageFilterMax = 0x7FFFFFFF
} OMX_IMAGEFILTERTYPE;

typedef enum OMX_IMAGEFILTERANAGLYPHTYPE {
    OMX_ImageFilterAnaglyphNone,
    OMX_ImageFilterAnaglyphSBStoRedCyan,
    OMX_ImageFilterAnaglyphSBStoCyanRed,
    OMX_ImageFilterAnaglyphSBStoGreenMagenta,
    OMX_ImageFilterAnaglyphSBStoMagentaGreen,
    OMX_ImageFilterAnaglyphTABtoRedCyan,
    OMX_ImageFilterAnaglyphTABtoCyanRed,
    OMX_ImageFilterAnaglyphTABtoGreenMagenta,
    OMX_ImageFilterAnaglyphTABtoMagentaGreen,
} OMX_IMAGEFILTERANAGLYPHTYPE;

/** 
 * Image filter configuration 
 *
 * STRUCT MEMBERS:
 *  nSize        : Size of the structure in bytes       
 *  nVersion     : OMX specification version information
 *  nPortIndex   : Port that this structure applies to 
 *  eImageFilter : Image filter type enumeration      
 */
typedef struct OMX_CONFIG_IMAGEFILTERTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_IMAGEFILTERTYPE eImageFilter;
} OMX_CONFIG_IMAGEFILTERTYPE;


/** 
 * Customized U and V for color enhancement 
 *
 * STRUCT MEMBERS:
 *  nSize             : Size of the structure in bytes
 *  nVersion          : OMX specification version information 
 *  nPortIndex        : Port that this structure applies to
 *  bColorEnhancement : Enable/disable color enhancement
 *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for 
 *                      U component
 *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for 
 *                      V component
 */
typedef struct OMX_CONFIG_COLORENHANCEMENTTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion; 
    OMX_U32 nPortIndex;
    OMX_BOOL bColorEnhancement;
    OMX_U8 nCustomizedU;
    OMX_U8 nCustomizedV;
} OMX_CONFIG_COLORENHANCEMENTTYPE;


/** 
 * Define color key and color key mask 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version information 
 *  nPortIndex : Port that this structure applies to
 *  nARGBColor : 32bit Alpha, Red, Green, Blue Color
 *  nARGBMask  : 32bit Mask for Alpha, Red, Green, Blue channels
 */
typedef struct OMX_CONFIG_COLORKEYTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nARGBColor;
    OMX_U32 nARGBMask;
} OMX_CONFIG_COLORKEYTYPE;


/** 
 * List of color blend types for pre/post processing 
 *
 * ENUMS:
 *  None          : No color blending present
 *  AlphaConstant : Function is (alpha_constant * src) + 
 *                  (1 - alpha_constant) * dst)
 *  AlphaPerPixel : Function is (alpha * src) + (1 - alpha) * dst)
 *  Alternate     : Function is alternating pixels from src and dst
 *  And           : Function is (src & dst)
 *  Or            : Function is (src | dst)
 *  Invert        : Function is ~src
 */
typedef enum OMX_COLORBLENDTYPE {
    OMX_ColorBlendNone,
    OMX_ColorBlendAlphaConstant,
    OMX_ColorBlendAlphaPerPixel,
    OMX_ColorBlendAlternate,
    OMX_ColorBlendAnd,
    OMX_ColorBlendOr,
    OMX_ColorBlendInvert,
    OMX_ColorBlendKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_ColorBlendVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_ColorBlendMax = 0x7FFFFFFF
} OMX_COLORBLENDTYPE;


/** 
 * Color blend configuration 
 *
 * STRUCT MEMBERS:
 *  nSize             : Size of the structure in bytes                        
 *  nVersion          : OMX specification version information                
 *  nPortIndex        : Port that this structure applies to                   
 *  nRGBAlphaConstant : Constant global alpha values when global alpha is used
 *  eColorBlend       : Color blend type enumeration                         
 */
typedef struct OMX_CONFIG_COLORBLENDTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nRGBAlphaConstant;
    OMX_COLORBLENDTYPE  eColorBlend;
} OMX_CONFIG_COLORBLENDTYPE;


/** 
 * Hold frame dimension
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes      
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to     
 *  nWidth     : Frame width in pixels                 
 *  nHeight    : Frame height in pixels                
 */
typedef struct OMX_FRAMESIZETYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nWidth;
    OMX_U32 nHeight;
} OMX_FRAMESIZETYPE;


/**
 * Rotation configuration 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes             
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to
 *  nRotation  : +/- integer rotation value               
 */
typedef struct OMX_CONFIG_ROTATIONTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_S32 nRotation; 
} OMX_CONFIG_ROTATIONTYPE;


/** 
 * Possible mirroring directions for pre/post processing 
 *
 * ENUMS:
 *  None       : No mirroring                         
 *  Vertical   : Vertical mirroring, flip on X axis   
 *  Horizontal : Horizontal mirroring, flip on Y axis  
 *  Both       : Both vertical and horizontal mirroring
 */
typedef enum OMX_MIRRORTYPE {
    OMX_MirrorNone = 0,
    OMX_MirrorVertical,
    OMX_MirrorHorizontal,
    OMX_MirrorBoth, 
    OMX_MirrorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_MirrorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_MirrorMax = 0x7FFFFFFF   
} OMX_MIRRORTYPE;


/** 
 * Mirroring configuration 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes      
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to  
 *  eMirror    : Mirror type enumeration              
 */
typedef struct OMX_CONFIG_MIRRORTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion; 
    OMX_U32 nPortIndex;
    OMX_MIRRORTYPE  eMirror;
} OMX_CONFIG_MIRRORTYPE;


/** 
 * Position information only 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes               
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to
 *  nX         : X coordinate for the point                     
 *  nY         : Y coordinate for the point 
 */                      
typedef struct OMX_CONFIG_POINTTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_S32 nX;
    OMX_S32 nY;
} OMX_CONFIG_POINTTYPE;


/** 
 * Frame size plus position 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes                    
 *  nVersion   : OMX specification version information      
 *  nPortIndex : Port that this structure applies to    
 *  nLeft      : X Coordinate of the top left corner of the rectangle
 *  nTop       : Y Coordinate of the top left corner of the rectangle
 *  nWidth     : Width of the rectangle                              
 *  nHeight    : Height of the rectangle                             
 */
typedef struct OMX_CONFIG_RECTTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;  
    OMX_U32 nPortIndex; 
    OMX_S32 nLeft; 
    OMX_S32 nTop;
    OMX_U32 nWidth;
    OMX_U32 nHeight;
} OMX_CONFIG_RECTTYPE;


/** 
 * Deblocking state; it is required to be set up before starting the codec 
 *
 * STRUCT MEMBERS:
 *  nSize       : Size of the structure in bytes      
 *  nVersion    : OMX specification version information 
 *  nPortIndex  : Port that this structure applies to
 *  bDeblocking : Enable/disable deblocking mode    
 */
typedef struct OMX_PARAM_DEBLOCKINGTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_BOOL bDeblocking;
} OMX_PARAM_DEBLOCKINGTYPE;


/** 
 * Stabilization state 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes          
 *  nVersion   : OMX specification version information    
 *  nPortIndex : Port that this structure applies to   
 *  bStab      : Enable/disable frame stabilization state
 */
typedef struct OMX_CONFIG_FRAMESTABTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_BOOL bStab;
} OMX_CONFIG_FRAMESTABTYPE;


/** 
 * White Balance control type 
 *
 * STRUCT MEMBERS:
 *  SunLight : Referenced in JSR-234
 *  Flash    : Optimal for device's integrated flash
 */
typedef enum OMX_WHITEBALCONTROLTYPE {
    OMX_WhiteBalControlOff = 0,
    OMX_WhiteBalControlAuto,
    OMX_WhiteBalControlSunLight,
    OMX_WhiteBalControlCloudy,
    OMX_WhiteBalControlShade,
    OMX_WhiteBalControlTungsten,
    OMX_WhiteBalControlFluorescent,
    OMX_WhiteBalControlIncandescent,
    OMX_WhiteBalControlFlash,
    OMX_WhiteBalControlHorizon,
    OMX_WhiteBalControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_WhiteBalControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_WhiteBalControlMax = 0x7FFFFFFF
} OMX_WHITEBALCONTROLTYPE;


/** 
 * White Balance control configuration 
 *
 * STRUCT MEMBERS:
 *  nSize            : Size of the structure in bytes       
 *  nVersion         : OMX specification version information
 *  nPortIndex       : Port that this structure applies to                 
 *  eWhiteBalControl : White balance enumeration            
 */
typedef struct OMX_CONFIG_WHITEBALCONTROLTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_WHITEBALCONTROLTYPE eWhiteBalControl;
} OMX_CONFIG_WHITEBALCONTROLTYPE;


/** 
 * Exposure control type 
 */
typedef enum OMX_EXPOSURECONTROLTYPE {
    OMX_ExposureControlOff = 0,
    OMX_ExposureControlAuto,
    OMX_ExposureControlNight,
    OMX_ExposureControlBackLight,
    OMX_ExposureControlSpotLight,
    OMX_ExposureControlSports,
    OMX_ExposureControlSnow,
    OMX_ExposureControlBeach,
    OMX_ExposureControlLargeAperture,
    OMX_ExposureControlSmallAperture,
    OMX_ExposureControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_ExposureControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_ExposureControlVeryLong,
    OMX_ExposureControlFixedFps,
    OMX_ExposureControlNightWithPreview,
    OMX_ExposureControlAntishake,
    OMX_ExposureControlFireworks,
    OMX_ExposureControlMax = 0x7FFFFFFF
} OMX_EXPOSURECONTROLTYPE;


/** 
 * White Balance control configuration 
 *
 * STRUCT MEMBERS:
 *  nSize            : Size of the structure in bytes      
 *  nVersion         : OMX specification version information
 *  nPortIndex       : Port that this structure applies to                
 *  eExposureControl : Exposure control enumeration         
 */
typedef struct OMX_CONFIG_EXPOSURECONTROLTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_EXPOSURECONTROLTYPE eExposureControl;
} OMX_CONFIG_EXPOSURECONTROLTYPE;


/** 
 * Defines sensor supported mode. 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes           
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to 
 *  nFrameRate : Single shot mode is indicated by a 0     
 *  bOneShot   : Enable for single shot, disable for streaming
 *  sFrameSize : Framesize                                          
 */
typedef struct OMX_PARAM_SENSORMODETYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nFrameRate;
    OMX_BOOL bOneShot;
    OMX_FRAMESIZETYPE sFrameSize;
} OMX_PARAM_SENSORMODETYPE;


/** 
 * Defines contrast level 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes                              
 *  nVersion   : OMX specification version information                
 *  nPortIndex : Port that this structure applies to                 
 *  nContrast  : Values allowed for contrast -100 to 100, zero means no change
 */
typedef struct OMX_CONFIG_CONTRASTTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_S32 nContrast;
} OMX_CONFIG_CONTRASTTYPE;


/** 
 * Defines brightness level 
 *
 * STRUCT MEMBERS:
 *  nSize       : Size of the structure in bytes          
 *  nVersion    : OMX specification version information 
 *  nPortIndex  : Port that this structure applies to 
 *  nBrightness : 0-100%        
 */
typedef struct OMX_CONFIG_BRIGHTNESSTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nBrightness;
} OMX_CONFIG_BRIGHTNESSTYPE;


/** 
 * Defines backlight level configuration for a video sink, e.g. LCD panel 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version information 
 *  nPortIndex : Port that this structure applies to
 *  nBacklight : Values allowed for backlight 0-100%
 *  nTimeout   : Number of milliseconds before backlight automatically turns 
 *               off.  A value of 0x0 disables backight timeout 
 */
typedef struct OMX_CONFIG_BACKLIGHTTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nBacklight;
    OMX_U32 nTimeout;
} OMX_CONFIG_BACKLIGHTTYPE;


/** 
 * Defines setting for Gamma 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version information 
 *  nPortIndex : Port that this structure applies to
 *  nGamma     : Values allowed for gamma -100 to 100, zero means no change
 */
typedef struct OMX_CONFIG_GAMMATYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_S32 nGamma;
} OMX_CONFIG_GAMMATYPE;


/** 
 * Define for setting saturation 
 * 
 * STRUCT MEMBERS:
 *  nSize       : Size of the structure in bytes
 *  nVersion    : OMX specification version information
 *  nPortIndex  : Port that this structure applies to
 *  nSaturation : Values allowed for saturation -100 to 100, zero means 
 *                no change
 */
typedef struct OMX_CONFIG_SATURATIONTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_S32 nSaturation;
} OMX_CONFIG_SATURATIONTYPE;


/** 
 * Define for setting Lightness 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes
 *  nVersion   : OMX specification version information
 *  nPortIndex : Port that this structure applies to
 *  nLightness : Values allowed for lightness -100 to 100, zero means no 
 *               change
 */
typedef struct OMX_CONFIG_LIGHTNESSTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_S32 nLightness;
} OMX_CONFIG_LIGHTNESSTYPE;


/** 
 * Plane blend configuration 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes 
 *  nVersion   : OMX specification version information
 *  nPortIndex : Index of input port associated with the plane.
 *  nDepth     : Depth of the plane in relation to the screen. Higher 
 *               numbered depths are "behind" lower number depths.  
 *               This number defaults to the Port Index number.
 *  nAlpha     : Transparency blending component for the entire plane.  
 *               See blending modes for more detail.
 */
typedef struct OMX_CONFIG_PLANEBLENDTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nDepth;
    OMX_U32 nAlpha;
} OMX_CONFIG_PLANEBLENDTYPE;


/** 
 * Define interlace type
 *
 * STRUCT MEMBERS:
 *  nSize                 : Size of the structure in bytes 
 *  nVersion              : OMX specification version information 
 *  nPortIndex            : Port that this structure applies to
 *  bEnable               : Enable control variable for this functionality 
 *                          (see below)
 *  nInterleavePortIndex  : Index of input or output port associated with  
 *                          the interleaved plane. 
 *  pPlanarPortIndexes[4] : Index of input or output planar ports.
 */
typedef struct OMX_PARAM_INTERLEAVETYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_BOOL bEnable;
    OMX_U32 nInterleavePortIndex;
} OMX_PARAM_INTERLEAVETYPE;


/** 
 * Defines the picture effect used for an input picture 
 */
typedef enum OMX_TRANSITIONEFFECTTYPE {
    OMX_EffectNone,
    OMX_EffectFadeFromBlack,
    OMX_EffectFadeToBlack,
    OMX_EffectUnspecifiedThroughConstantColor,
    OMX_EffectDissolve,
    OMX_EffectWipe,
    OMX_EffectUnspecifiedMixOfTwoScenes,
    OMX_EffectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_EffectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

    OMX_EffectReverseUnspecifiedMixOfTwoScenes,
    
#ifndef __VIDEOCORE4__
    OMX_EffectDiagonalWipe,
    OMX_EffectDiagonalWipeRotate,
    OMX_EffectEllipticalWipe,
    OMX_EffectEllipticalWipeRotate,
    OMX_EffectInverseEllipticalWipe,
    OMX_EffectInverseEllipticalWipeRotate,
    OMX_EffectGlassWipe,
    OMX_EffectGlassWipeRotate,
    OMX_EffectWavyWipe,
    OMX_EffectWavyWipeRotate,
    OMX_EffectMunchingSquares,
    OMX_EffectStripeWipe,
    OMX_EffectStripeWipeRotate,
    
    OMX_EffectRotozoomUnmatched,
    OMX_EffectRotozoomMatched,
    OMX_EffectRotozoomGentle,
#endif

    OMX_EffectMunchRandom,
    OMX_EffectMunchVRandom,
    OMX_EffectMunchHRandom,
    OMX_EffectMunchWipe,
    OMX_EffectMunchMunch,
    OMX_EffectMunchStripe,
    OMX_EffectFadeRandom,
    OMX_EffectFadeVRandom,
    OMX_EffectFadeHRandom,
    OMX_EffectFadeWipe,
    OMX_EffectFadeMunch,
    OMX_EffectFadeStripe,
    OMX_EffectColourBlockRandom,
    OMX_EffectColourBlockVRandom,
    OMX_EffectColourBlockHRandom,
    OMX_EffectColourBlockWipe,
    OMX_EffectColourBlockMunch,
    OMX_EffectColourBlockStripe,
    OMX_EffectColourBlock2Random,
    OMX_EffectColourBlock2VRandom,
    OMX_EffectColourBlock2HRandom,
    OMX_EffectColourBlock2Wipe,
    OMX_EffectColourBlock2Munch,
    OMX_EffectColourBlock2Stripe,
    OMX_EffectShadeRandom,
    OMX_EffectShadeVRandom,
    OMX_EffectShadeHRandom,
    OMX_EffectShadeWipe,
    OMX_EffectShadeMunch,
    OMX_EffectShadeStripe,
    OMX_EffectBitmaskRandom,
    OMX_EffectBitmaskVRandom,
    OMX_EffectBitmaskHRandom,
    OMX_EffectBitmaskWipe,
    OMX_EffectBitmaskMunch,
    OMX_EffectBitmaskStripe,
    OMX_EffectBitmask2Random,
    OMX_EffectBitmask2VRandom,
    OMX_EffectBitmask2HRandom,
    OMX_EffectBitmask2Wipe,
    OMX_EffectBitmask2Munch,
    OMX_EffectBitmask2Stripe,
    OMX_EffectBitmask2ColourRandom,
    OMX_EffectBitmask2ColourVRandom,
    OMX_EffectBitmask2ColourHRandom,
    OMX_EffectBitmask2ColourWipe,
    OMX_EffectBitmask2ColourMunch,
    OMX_EffectBitmask2ColourStripe,

    OMX_EffectPushRight,
    OMX_EffectPushLeft,
    OMX_EffectPushDown,
    OMX_EffectPushUp,
    OMX_EffectCoverRight,
    OMX_EffectCoverLeft,
    OMX_EffectCoverDown,
    OMX_EffectCoverUp,
    OMX_EffectRevealRight,
    OMX_EffectRevealLeft,
    OMX_EffectRevealDown,
    OMX_EffectRevealUp,
    OMX_EffectWipeRight,
    OMX_EffectWipeLeft,
    OMX_EffectWipeDown,
    OMX_EffectWipeUp,
    OMX_EffectSpeckle,
    OMX_EffectCircle,
    OMX_EffectSpiral,
    OMX_EffectDiamond,
    OMX_EffectVert,
    OMX_EffectPlus,
    OMX_EffectClock,
    OMX_EffectPlasma,
    OMX_EffectDisplace,
    OMX_EffectGenie,
    OMX_EffectSide,
    OMX_EffectMaze,
    OMX_EffectRipple,
    OMX_EffectStar,
    OMX_EffectAlpha,
    OMX_EffectIntense,
    OMX_EffectIntenseU,
    OMX_EffectIntenseV,
    OMX_EffectInverseIntense,
    OMX_EffectInverseIntenseU,
    OMX_EffectInverseIntenseV,

    OMX_EffectPageTurn,

    OMX_EffectFlipPlaneDown,
    OMX_EffectFlipPlaneDownMid,
    OMX_EffectFlipPlaneDownHigh,
    OMX_EffectFlipPlaneLeft,
    OMX_EffectFlipPlaneLeftMid,
    OMX_EffectFlipPlaneLeftHigh,
    OMX_EffectFlipCubeDown,
    OMX_EffectFlipCubeDownMid,
    OMX_EffectFlipCubeDownHigh,
    OMX_EffectFlipCubeLeft,
    OMX_EffectFlipCubeLeftMid,
    OMX_EffectFlipCubeLeftHigh,

    OMX_EffectMax = 0x7FFFFFFF
} OMX_TRANSITIONEFFECTTYPE;


/** 
 * Structure used to configure current transition effect 
 *
 * STRUCT MEMBERS:
 * nSize      : Size of the structure in bytes
 * nVersion   : OMX specification version information 
 * nPortIndex : Port that this structure applies to
 * eEffect    : Effect to enable
 */
typedef struct OMX_CONFIG_TRANSITIONEFFECTTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_TRANSITIONEFFECTTYPE eEffect;
} OMX_CONFIG_TRANSITIONEFFECTTYPE;


/** 
 * Defines possible data unit types for encoded video data. The data unit 
 * types are used both for encoded video input for playback as well as
 * encoded video output from recording. 
 */
typedef enum OMX_DATAUNITTYPE {
    OMX_DataUnitCodedPicture,
    OMX_DataUnitVideoSegment,
    OMX_DataUnitSeveralSegments,
    OMX_DataUnitArbitraryStreamSection,
    OMX_DataUnitKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_DataUnitVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_DataUnitMax = 0x7FFFFFFF
} OMX_DATAUNITTYPE;


/** 
 * Defines possible encapsulation types for coded video data unit. The 
 * encapsulation information is used both for encoded video input for 
 * playback as well as encoded video output from recording. 
 */
typedef enum OMX_DATAUNITENCAPSULATIONTYPE {
    OMX_DataEncapsulationElementaryStream,
    OMX_DataEncapsulationGenericPayload,
    OMX_DataEncapsulationRtpPayload,
    OMX_DataEncapsulationKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_DataEncapsulationVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_DataEncapsulationMax = 0x7FFFFFFF
} OMX_DATAUNITENCAPSULATIONTYPE;


/** 
 * Structure used to configure the type of being decoded/encoded 
 */
typedef struct OMX_PARAM_DATAUNITTYPE {
    OMX_U32 nSize;            /**< Size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
    OMX_DATAUNITTYPE eUnitType;
    OMX_DATAUNITENCAPSULATIONTYPE eEncapsulationType;
} OMX_PARAM_DATAUNITTYPE;


/**
 * Defines dither types 
 */
typedef enum OMX_DITHERTYPE {
    OMX_DitherNone,
    OMX_DitherOrdered,
    OMX_DitherErrorDiffusion,
    OMX_DitherOther,
    OMX_DitherKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_DitherVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_DitherMax = 0x7FFFFFFF
} OMX_DITHERTYPE;


/** 
 * Structure used to configure current type of dithering 
 */
typedef struct OMX_CONFIG_DITHERTYPE {
    OMX_U32 nSize;            /**< Size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
    OMX_DITHERTYPE eDither;   /**< Type of dithering to use */
} OMX_CONFIG_DITHERTYPE;

typedef struct OMX_CONFIG_CAPTUREMODETYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;     /**< Port that this structure applies to */
    OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture 
                             *   data as fast as possible (otherwise obey port's frame rate). */
    OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the 
                             *   specified number of frames (otherwise the port does not 
                             *   terminate the capture until instructed to do so by the client). 
                             *   Even if set, the client may manually terminate the capture prior 
                             *   to reaching the limit. */
    OMX_U32 nFrameLimit;      /**< Limit on number of frames emitted during a capture (only
                               *   valid if bFrameLimited is set). */
} OMX_CONFIG_CAPTUREMODETYPE;

typedef enum OMX_METERINGTYPE {
 
    OMX_MeteringModeAverage,     /**< Center-weighted average metering. */
    OMX_MeteringModeSpot,  	      /**< Spot (partial) metering. */
    OMX_MeteringModeMatrix,      /**< Matrix or evaluative metering. */
 
    OMX_MeteringKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_MeteringVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_MeteringModeBacklit,
    OMX_EVModeMax = 0x7fffffff
} OMX_METERINGTYPE;
 
typedef struct OMX_CONFIG_EXPOSUREVALUETYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_METERINGTYPE eMetering;
    OMX_S32 xEVCompensation;      /**< Fixed point value stored as Q16 */
    OMX_U32 nApertureFNumber;     /**< e.g. nApertureFNumber = 2 implies "f/2" - Q16 format */
    OMX_BOOL bAutoAperture;		/**< Whether aperture number is defined automatically */
    OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */ 
    OMX_BOOL bAutoShutterSpeed;	/**< Whether shutter speed is defined automatically */ 
    OMX_U32 nSensitivity;         /**< e.g. nSensitivity = 100 implies "ISO 100" */
    OMX_BOOL bAutoSensitivity;	/**< Whether sensitivity is defined automatically */
} OMX_CONFIG_EXPOSUREVALUETYPE;

/** 
 * Focus region configuration 
 *
 * STRUCT MEMBERS:
 *  nSize           : Size of the structure in bytes
 *  nVersion        : OMX specification version information
 *  nPortIndex      : Port that this structure applies to
 *  bCenter         : Use center region as focus region of interest
 *  bLeft           : Use left region as focus region of interest
 *  bRight          : Use right region as focus region of interest
 *  bTop            : Use top region as focus region of interest
 *  bBottom         : Use bottom region as focus region of interest
 *  bTopLeft        : Use top left region as focus region of interest
 *  bTopRight       : Use top right region as focus region of interest
 *  bBottomLeft     : Use bottom left region as focus region of interest
 *  bBottomRight    : Use bottom right region as focus region of interest
 */
typedef struct OMX_CONFIG_FOCUSREGIONTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_BOOL bCenter;
    OMX_BOOL bLeft;
    OMX_BOOL bRight;
    OMX_BOOL bTop;
    OMX_BOOL bBottom;
    OMX_BOOL bTopLeft;
    OMX_BOOL bTopRight;
    OMX_BOOL bBottomLeft;
    OMX_BOOL bBottomRight;
} OMX_CONFIG_FOCUSREGIONTYPE;

/** 
 * Focus Status type 
 */
typedef enum OMX_FOCUSSTATUSTYPE {
    OMX_FocusStatusOff = 0,
    OMX_FocusStatusRequest,
    OMX_FocusStatusReached,
    OMX_FocusStatusUnableToReach,
    OMX_FocusStatusLost,
    OMX_FocusStatusKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_FocusStatusVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_FocusStatusCafWatching,
    OMX_FocusStatusCafSceneChanged,
    OMX_FocusStatusMax = 0x7FFFFFFF
} OMX_FOCUSSTATUSTYPE;

/** 
 * Focus status configuration 
 *
 * STRUCT MEMBERS:
 *  nSize               : Size of the structure in bytes
 *  nVersion            : OMX specification version information
 *  nPortIndex          : Port that this structure applies to
 *  eFocusStatus        : Specifies the focus status
 *  bCenterStatus       : Use center region as focus region of interest
 *  bLeftStatus         : Use left region as focus region of interest
 *  bRightStatus        : Use right region as focus region of interest
 *  bTopStatus          : Use top region as focus region of interest
 *  bBottomStatus       : Use bottom region as focus region of interest
 *  bTopLeftStatus      : Use top left region as focus region of interest
 *  bTopRightStatus     : Use top right region as focus region of interest
 *  bBottomLeftStatus   : Use bottom left region as focus region of interest
 *  bBottomRightStatus  : Use bottom right region as focus region of interest
 */
typedef struct OMX_PARAM_FOCUSSTATUSTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_FOCUSSTATUSTYPE eFocusStatus;
    OMX_BOOL bCenterStatus;
    OMX_BOOL bLeftStatus;
    OMX_BOOL bRightStatus;
    OMX_BOOL bTopStatus;
    OMX_BOOL bBottomStatus;
    OMX_BOOL bTopLeftStatus;
    OMX_BOOL bTopRightStatus;
    OMX_BOOL bBottomLeftStatus;
    OMX_BOOL bBottomRightStatus;
} OMX_PARAM_FOCUSSTATUSTYPE;

/** @} */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VCFILED_CHECK_H
#define VCFILED_CHECK_H

#ifdef ANDROID
#define VCFILED_LOCKDIR "/tmp/vcfiled/vcfiled.pid"
#define VCFILED_LOCKFILE "/tmp/vcfiled"
#endif

#ifndef VCFILED_LOCKFILE
#define VCFILED_LOCKDIR "/var/run/vcfiled"
#define VCFILED_LOCKFILE VCFILED_LOCKDIR "/vcfiled"
#endif

typedef void (*VCFILED_LOGMSG_T)(int level, const char *fmt, ...);
int vcfiled_lock(const char *filename, VCFILED_LOGMSG_T logmsg);
extern int vcfiled_is_running(const char *lockfile);


#endif


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 */

/** 
 * @file OMX_Image.h - OpenMax IL version 1.1.2
 * The structures needed by Image components to exchange parameters and 
 * configuration data with the components.
 */
#ifndef OMX_Image_h
#define OMX_Image_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


/**
 * Each OMX header must include all required header files to allow the 
 * header to compile without errors.  The includes below are required  
 * for this header file to compile successfully 
 */

#include "OMX_IVCommon.h"

/** @defgroup imaging OpenMAX IL Imaging Domain
 * @ingroup iv
 * Structures for OpenMAX IL Imaging domain
 * @{
 */

/** 
 * Enumeration used to define the possible image compression coding. 
 */
typedef enum OMX_IMAGE_CODINGTYPE {
    OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
    OMX_IMAGE_CodingAutoDetect,  /**< Auto detection of image format */
    OMX_IMAGE_CodingJPEG,        /**< JPEG/JFIF image format */
    OMX_IMAGE_CodingJPEG2K,      /**< JPEG 2000 image format */
    OMX_IMAGE_CodingEXIF,        /**< EXIF image format */
    OMX_IMAGE_CodingTIFF,        /**< TIFF image format */
    OMX_IMAGE_CodingGIF,         /**< Graphics image format */
    OMX_IMAGE_CodingPNG,         /**< PNG image format */
    OMX_IMAGE_CodingLZW,         /**< LZW image format */
    OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
    OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_IMAGE_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

    OMX_IMAGE_CodingTGA,
    OMX_IMAGE_CodingPPM,

    OMX_IMAGE_CodingMax = 0x7FFFFFFF
} OMX_IMAGE_CODINGTYPE;


/**
 * Data structure used to define an image path. The number of image paths 
 * for input and output will vary by type of the image component.  
 * 
 *  Input (aka Source) : Zero Inputs, one Output,
 *  Splitter           : One Input, 2 or more Outputs,
 *  Processing Element : One Input, one output,
 *  Mixer              : 2 or more inputs, one output,
 *  Output (aka Sink)  : One Input, zero outputs.
 * 
 * The PortDefinition structure is used to define all of the parameters 
 * necessary for the compliant component to setup an input or an output  
 * image path.  If additional vendor specific data is required, it should  
 * be transmitted to the component using the CustomCommand function.   
 * Compliant components will prepopulate this structure with optimal  
 * values during the OMX_GetParameter() command.
 *
 * STRUCT MEMBERS:
 *  cMIMEType             : MIME type of data for the port
 *  pNativeRender         : Platform specific reference for a display if a 
 *                          sync, otherwise this field is 0
 *  nFrameWidth           : Width of frame to be used on port if 
 *                          uncompressed format is used.  Use 0 for 
 *                          unknown, don't care or variable
 *  nFrameHeight          : Height of frame to be used on port if 
 *                          uncompressed format is used. Use 0 for 
 *                          unknown, don't care or variable
 *  nStride               : Number of bytes per span of an image (i.e. 
 *                          indicates the number of bytes to get from
 *                          span N to span N+1, where negative stride 
 *                          indicates the image is bottom up
 *  nSliceHeight          : Height used when encoding in slices
 *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
 *                          the OMX component
 *  eCompressionFormat    : Compression format used in this instance of  
 *                          the component. When OMX_IMAGE_CodingUnused is 
 *                          specified, eColorFormat is valid
 *  eColorFormat          : Decompressed format used by this component
 *  pNativeWindow         : Platform specific reference for a window object if a 
 *                          display sink , otherwise this field is 0x0. 
 */
typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
    OMX_STRING cMIMEType;
    OMX_NATIVE_DEVICETYPE pNativeRender;
    OMX_U32 nFrameWidth; 
    OMX_U32 nFrameHeight;
    OMX_S32 nStride;     
    OMX_U32 nSliceHeight;
    OMX_BOOL bFlagErrorConcealment;
    OMX_IMAGE_CODINGTYPE eCompressionFormat;
    OMX_COLOR_FORMATTYPE eColorFormat;
    OMX_NATIVE_WINDOWTYPE pNativeWindow;
} OMX_IMAGE_PORTDEFINITIONTYPE;


/**  
 * Port format parameter.  This structure is used to enumerate the various 
 * data input/output format supported by the port.
 * 
 * STRUCT MEMBERS:
 *  nSize              : Size of the structure in bytes
 *  nVersion           : OMX specification version information
 *  nPortIndex         : Indicates which port to set
 *  nIndex             : Indicates the enumeration index for the format from 
 *                       0x0 to N-1
 *  eCompressionFormat : Compression format used in this instance of the 
 *                       component. When OMX_IMAGE_CodingUnused is specified, 
 *                       eColorFormat is valid
 *  eColorFormat       : Decompressed format used by this component
 */
typedef struct OMX_IMAGE_PARAM_PORTFORMATTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_U32 nIndex;
    OMX_IMAGE_CODINGTYPE eCompressionFormat;
    OMX_COLOR_FORMATTYPE eColorFormat;
} OMX_IMAGE_PARAM_PORTFORMATTYPE;


/** 
 * Flash control type 
 *
 * ENUMS
 *  Torch : Flash forced constantly on
 */
typedef enum OMX_IMAGE_FLASHCONTROLTYPE {
    OMX_IMAGE_FlashControlOn = 0,
    OMX_IMAGE_FlashControlOff,
    OMX_IMAGE_FlashControlAuto,
    OMX_IMAGE_FlashControlRedEyeReduction,
    OMX_IMAGE_FlashControlFillin,
    OMX_IMAGE_FlashControlTorch,
    OMX_IMAGE_FlashControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_IMAGE_FlashControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
} OMX_IMAGE_FLASHCONTROLTYPE;


/** 
 * Flash control configuration 
 *
 * STRUCT MEMBERS:
 *  nSize         : Size of the structure in bytes
 *  nVersion      : OMX specification version information
 *  nPortIndex    : Port that this structure applies to
 *  eFlashControl : Flash control type
 */
typedef struct OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_IMAGE_FLASHCONTROLTYPE eFlashControl;
} OMX_IMAGE_PARAM_FLASHCONTROLTYPE;


/** 
 * Focus control type 
 */
typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
    OMX_IMAGE_FocusControlOn = 0,
    OMX_IMAGE_FocusControlOff,
    OMX_IMAGE_FocusControlAuto,
    OMX_IMAGE_FocusControlAutoLock,
    OMX_IMAGE_FocusControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_IMAGE_FocusControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_IMAGE_FocusControlHyperfocal,         /* Focus at the hyperfocal point of the lens. */
    OMX_IMAGE_FocusControlAutoMacro,          /* CF over a macro range (eg 0-50cm) */
    OMX_IMAGE_FocusControlAutoInfinity,       /* CF over distant range (eg 50cm to infinity) */
    OMX_IMAGE_FocusControlAutoLockMacro,      /* AF over a macro range (eg 0-50cm) */
    OMX_IMAGE_FocusControlAutoLockInfinity,   /* AF over distant range (eg 50cm to infinity) */
    OMX_IMAGE_FocusControlNearFixed,          /* Focus at a fixed near focus point - (50cm-1m) */
    OMX_IMAGE_FocusControlAutoNear,           /* CF over a near range (eg 0-200cm) */
    OMX_IMAGE_FocusControlAutoLockNear,       /* AF over a near range (eg 0-200cm) */
    OMX_IMAGE_FocusControlInfinityFixed,      /* Focus at infinity */
    OMX_IMAGE_FocusControlMacroFixed,         /* Focus at a macro distance */
    OMX_IMAGE_FocusControlAutoFast,           /* CF over a full range with fast response */
    OMX_IMAGE_FocusControlAutoMacroFast,      /* CF over a macro range (eg 0-50cm) with fast response */
    OMX_IMAGE_FocusControlAutoNearFast,       /* CF over a near range (eg 0-200cm) */
    OMX_IMAGE_FocusControlAutoInfinityFast,   /* CF over distant range (eg 50cm to infinity) with fast response */
    OMX_IMAGE_FocusControlCurrentFixed,       /* Stop the lens at the current position */
    OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
} OMX_IMAGE_FOCUSCONTROLTYPE;

 
/** 
 * Focus control configuration 
 *
 * STRUCT MEMBERS:
 *  nSize           : Size of the structure in bytes
 *  nVersion        : OMX specification version information
 *  nPortIndex      : Port that this structure applies to
 *  eFocusControl   : Focus control
 *  nFocusSteps     : Focus can take on values from 0 mm to infinity. 
 *                    Interest is only in number of steps over this range.
 *  nFocusStepIndex : Current focus step index
 */
typedef struct OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_IMAGE_FOCUSCONTROLTYPE eFocusControl;
    OMX_U32 nFocusSteps;
    OMX_U32 nFocusStepIndex;
} OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;


/** 
 * Q Factor for JPEG compression, which controls the tradeoff between image
 * quality and size.  Q Factor provides a more simple means of controlling
 * JPEG compression quality, without directly programming Quantization
 * tables for chroma and luma 
 *
 * STRUCT MEMBERS:
 *  nSize      : Size of the structure in bytes         
 *  nVersion   : OMX specification version information 
 *  nPortIndex : Port that this structure applies to 
 *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1 
 *               produces the smallest, worst quality images, and a factor 
 *               of 100 produces the largest, best quality images.  A 
 *               typical default is 75 for small good quality images               
 */
typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
    OMX_U32 nSize;            
    OMX_VERSIONTYPE nVersion; 
    OMX_U32 nPortIndex;       
    OMX_U32 nQFactor;                                        
} OMX_IMAGE_PARAM_QFACTORTYPE;

/** 
 * Quantization table type 
 */

typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
    OMX_IMAGE_QuantizationTableLuma = 0,
    OMX_IMAGE_QuantizationTableChroma,
    OMX_IMAGE_QuantizationTableChromaCb,
    OMX_IMAGE_QuantizationTableChromaCr,
    OMX_IMAGE_QuantizationTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_IMAGE_QuantizationTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
} OMX_IMAGE_QUANTIZATIONTABLETYPE;

/** 
 * JPEG quantization tables are used to determine DCT compression for
 * YUV data, as an alternative to specifying Q factor, providing exact 
 * control of compression 
 *
 * STRUCT MEMBERS:
 *  nSize                   : Size of the structure in bytes
 *  nVersion                : OMX specification version information 
 *  nPortIndex              : Port that this structure applies to
 *  eQuantizationTable      : Quantization table type
 *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored 
 *                            in increasing columns then by rows of data (i.e. 
 *                            row 1, ... row 8). Quantization values are in 
 *                            the range 0-255 and stored in linear order
 *                            (i.e. the component will zig-zag the 
 *                            quantization table data if required internally) 
 */
typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_IMAGE_QUANTIZATIONTABLETYPE eQuantizationTable;
    OMX_U8 nQuantizationMatrix[64];
} OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;


/** 
 * Huffman table type, the same Huffman table is applied for chroma and 
 * luma component 
 */
typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
    OMX_IMAGE_HuffmanTableAC = 0,
    OMX_IMAGE_HuffmanTableDC,
    OMX_IMAGE_HuffmanTableACLuma,
    OMX_IMAGE_HuffmanTableACChroma,
    OMX_IMAGE_HuffmanTableDCLuma,
    OMX_IMAGE_HuffmanTableDCChroma,
    OMX_IMAGE_HuffmanTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_IMAGE_HuffmanTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
    OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
} OMX_IMAGE_HUFFMANTABLETYPE;

/** 
 * JPEG Huffman table 
 *
 * STRUCT MEMBERS:
 *  nSize                            : Size of the structure in bytes
 *  nVersion                         : OMX specification version information
 *  nPortIndex                       : Port that this structure applies to
 *  eHuffmanTable                    : Huffman table type
 *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each 
 *                                     possible length
 *  nHuffmanTable[256]               : 0-255, the size used for AC and DC 
 *                                     HuffmanTable are 16 and 162 
 */
typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
    OMX_U32 nSize;
    OMX_VERSIONTYPE nVersion;
    OMX_U32 nPortIndex;
    OMX_IMAGE_HUFFMANTABLETYPE eHuffmanTable;
    OMX_U8 nNumberOfHuffmanCodeOfLength[16];
    OMX_U8 nHuffmanTable[256];
}OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;

/** @} */
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * Copyright (c) 2008 The Khronos Group Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/** @file OMX_Index.h - OpenMax IL version 1.1.2
 *  The OMX_Index header file contains the definitions for both applications
 *  and components .
 */


#ifndef OMX_Index_h
#define OMX_Index_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


/* Each OMX header must include all required header files to allow the
 *  header to compile without errors.  The includes below are required
 *  for this header file to compile successfully
 */
#include "OMX_Types.h"


/** The OMX_INDEXTYPE enumeration is used to select a structure when either
 *  getting or setting parameters and/or configuration data.  Each entry in
 *  this enumeration maps to an OMX specified structure.  When the
 *  OMX_GetParameter, OMX_SetParameter, OMX_GetConfig or OMX_SetConfig methods
 *  are used, the second parameter will always be an entry from this enumeration
 *  and the third entry will be the structure shown in the comments for the entry.
 *  For example, if the application is initializing a cropping function, the
 *  OMX_SetConfig command would have OMX_IndexConfigCommonInputCrop as the second parameter
 *  and would send a pointer to an initialized OMX_RECTTYPE structure as the
 *  third parameter.
 *
 *  The enumeration entries named with the OMX_Config prefix are sent using
 *  the OMX_SetConfig command and the enumeration entries named with the
 *  OMX_PARAM_ prefix are sent using the OMX_SetParameter command.
 */
typedef enum OMX_INDEXTYPE {

    OMX_IndexComponentStartUnused = 0x01000000,
    OMX_IndexParamPriorityMgmt,             /**< reference: OMX_PRIORITYMGMTTYPE */
    OMX_IndexParamAudioInit,                /**< reference: OMX_PORT_PARAM_TYPE */
    OMX_IndexParamImageInit,                /**< reference: OMX_PORT_PARAM_TYPE */
    OMX_IndexParamVideoInit,                /**< reference: OMX_PORT_PARAM_TYPE */
    OMX_IndexParamOtherInit,                /**< reference: OMX_PORT_PARAM_TYPE */
    OMX_IndexParamNumAvailableStreams,      /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamActiveStream,             /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamSuspensionPolicy,         /**< reference: OMX_PARAM_SUSPENSIONPOLICYTYPE */
    OMX_IndexParamComponentSuspended,       /**< reference: OMX_PARAM_SUSPENSIONTYPE */
    OMX_IndexConfigCapturing,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigCaptureMode,             /**< reference: OMX_CONFIG_CAPTUREMODETYPE */
    OMX_IndexAutoPauseAfterCapture,         /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamContentURI,               /**< reference: OMX_PARAM_CONTENTURITYPE */
    OMX_IndexParamCustomContentPipe,        /**< reference: OMX_PARAM_CONTENTPIPETYPE */
    OMX_IndexParamDisableResourceConcealment, /**< reference: OMX_RESOURCECONCEALMENTTYPE */
    OMX_IndexConfigMetadataItemCount,       /**< reference: OMX_CONFIG_METADATAITEMCOUNTTYPE */
    OMX_IndexConfigContainerNodeCount,      /**< reference: OMX_CONFIG_CONTAINERNODECOUNTTYPE */
    OMX_IndexConfigMetadataItem,            /**< reference: OMX_CONFIG_METADATAITEMTYPE */
    OMX_IndexConfigCounterNodeID,           /**< reference: OMX_CONFIG_CONTAINERNODEIDTYPE */
    OMX_IndexParamMetadataFilterType,       /**< reference: OMX_PARAM_METADATAFILTERTYPE */
    OMX_IndexParamMetadataKeyFilter,        /**< reference: OMX_PARAM_METADATAFILTERTYPE */
    OMX_IndexConfigPriorityMgmt,            /**< reference: OMX_PRIORITYMGMTTYPE */
    OMX_IndexParamStandardComponentRole,    /**< reference: OMX_PARAM_COMPONENTROLETYPE */

    OMX_IndexPortStartUnused = 0x02000000,
    OMX_IndexParamPortDefinition,           /**< reference: OMX_PARAM_PORTDEFINITIONTYPE */
    OMX_IndexParamCompBufferSupplier,       /**< reference: OMX_PARAM_BUFFERSUPPLIERTYPE */
    OMX_IndexReservedStartUnused = 0x03000000,

    /* Audio parameters and configurations */
    OMX_IndexAudioStartUnused = 0x04000000,
    OMX_IndexParamAudioPortFormat,          /**< reference: OMX_AUDIO_PARAM_PORTFORMATTYPE */
    OMX_IndexParamAudioPcm,                 /**< reference: OMX_AUDIO_PARAM_PCMMODETYPE */
    OMX_IndexParamAudioAac,                 /**< reference: OMX_AUDIO_PARAM_AACPROFILETYPE */
    OMX_IndexParamAudioRa,                  /**< reference: OMX_AUDIO_PARAM_RATYPE */
    OMX_IndexParamAudioMp3,                 /**< reference: OMX_AUDIO_PARAM_MP3TYPE */
    OMX_IndexParamAudioAdpcm,               /**< reference: OMX_AUDIO_PARAM_ADPCMTYPE */
    OMX_IndexParamAudioG723,                /**< reference: OMX_AUDIO_PARAM_G723TYPE */
    OMX_IndexParamAudioG729,                /**< reference: OMX_AUDIO_PARAM_G729TYPE */
    OMX_IndexParamAudioAmr,                 /**< reference: OMX_AUDIO_PARAM_AMRTYPE */
    OMX_IndexParamAudioWma,                 /**< reference: OMX_AUDIO_PARAM_WMATYPE */
    OMX_IndexParamAudioSbc,                 /**< reference: OMX_AUDIO_PARAM_SBCTYPE */
    OMX_IndexParamAudioMidi,                /**< reference: OMX_AUDIO_PARAM_MIDITYPE */
    OMX_IndexParamAudioGsm_FR,              /**< reference: OMX_AUDIO_PARAM_GSMFRTYPE */
    OMX_IndexParamAudioMidiLoadUserSound,   /**< reference: OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE */
    OMX_IndexParamAudioG726,                /**< reference: OMX_AUDIO_PARAM_G726TYPE */
    OMX_IndexParamAudioGsm_EFR,             /**< reference: OMX_AUDIO_PARAM_GSMEFRTYPE */
    OMX_IndexParamAudioGsm_HR,              /**< reference: OMX_AUDIO_PARAM_GSMHRTYPE */
    OMX_IndexParamAudioPdc_FR,              /**< reference: OMX_AUDIO_PARAM_PDCFRTYPE */
    OMX_IndexParamAudioPdc_EFR,             /**< reference: OMX_AUDIO_PARAM_PDCEFRTYPE */
    OMX_IndexParamAudioPdc_HR,              /**< reference: OMX_AUDIO_PARAM_PDCHRTYPE */
    OMX_IndexParamAudioTdma_FR,             /**< reference: OMX_AUDIO_PARAM_TDMAFRTYPE */
    OMX_IndexParamAudioTdma_EFR,            /**< reference: OMX_AUDIO_PARAM_TDMAEFRTYPE */
    OMX_IndexParamAudioQcelp8,              /**< reference: OMX_AUDIO_PARAM_QCELP8TYPE */
    OMX_IndexParamAudioQcelp13,             /**< reference: OMX_AUDIO_PARAM_QCELP13TYPE */
    OMX_IndexParamAudioEvrc,                /**< reference: OMX_AUDIO_PARAM_EVRCTYPE */
    OMX_IndexParamAudioSmv,                 /**< reference: OMX_AUDIO_PARAM_SMVTYPE */
    OMX_IndexParamAudioVorbis,              /**< reference: OMX_AUDIO_PARAM_VORBISTYPE */

    OMX_IndexConfigAudioMidiImmediateEvent, /**< reference: OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE */
    OMX_IndexConfigAudioMidiControl,        /**< reference: OMX_AUDIO_CONFIG_MIDICONTROLTYPE */
    OMX_IndexConfigAudioMidiSoundBankProgram, /**< reference: OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE */
    OMX_IndexConfigAudioMidiStatus,         /**< reference: OMX_AUDIO_CONFIG_MIDISTATUSTYPE */
    OMX_IndexConfigAudioMidiMetaEvent,      /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE */
    OMX_IndexConfigAudioMidiMetaEventData,  /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE */
    OMX_IndexConfigAudioVolume,             /**< reference: OMX_AUDIO_CONFIG_VOLUMETYPE */
    OMX_IndexConfigAudioBalance,            /**< reference: OMX_AUDIO_CONFIG_BALANCETYPE */
    OMX_IndexConfigAudioChannelMute,        /**< reference: OMX_AUDIO_CONFIG_CHANNELMUTETYPE */
    OMX_IndexConfigAudioMute,               /**< reference: OMX_AUDIO_CONFIG_MUTETYPE */
    OMX_IndexConfigAudioLoudness,           /**< reference: OMX_AUDIO_CONFIG_LOUDNESSTYPE */
    OMX_IndexConfigAudioEchoCancelation,    /**< reference: OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE */
    OMX_IndexConfigAudioNoiseReduction,     /**< reference: OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE */
    OMX_IndexConfigAudioBass,               /**< reference: OMX_AUDIO_CONFIG_BASSTYPE */
    OMX_IndexConfigAudioTreble,             /**< reference: OMX_AUDIO_CONFIG_TREBLETYPE */
    OMX_IndexConfigAudioStereoWidening,     /**< reference: OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE */
    OMX_IndexConfigAudioChorus,             /**< reference: OMX_AUDIO_CONFIG_CHORUSTYPE */
    OMX_IndexConfigAudioEqualizer,          /**< reference: OMX_AUDIO_CONFIG_EQUALIZERTYPE */
    OMX_IndexConfigAudioReverberation,      /**< reference: OMX_AUDIO_CONFIG_REVERBERATIONTYPE */
    OMX_IndexConfigAudioChannelVolume,      /**< reference: OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE */

    /* Image specific parameters and configurations */
    OMX_IndexImageStartUnused = 0x05000000,
    OMX_IndexParamImagePortFormat,          /**< reference: OMX_IMAGE_PARAM_PORTFORMATTYPE */
    OMX_IndexParamFlashControl,             /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
    OMX_IndexConfigFocusControl,            /**< reference: OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE */
    OMX_IndexParamQFactor,                  /**< reference: OMX_IMAGE_PARAM_QFACTORTYPE */
    OMX_IndexParamQuantizationTable,        /**< reference: OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE */
    OMX_IndexParamHuffmanTable,             /**< reference: OMX_IMAGE_PARAM_HUFFMANTTABLETYPE */
    OMX_IndexConfigFlashControl,            /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */

    /* Video specific parameters and configurations */
    OMX_IndexVideoStartUnused = 0x06000000,
    OMX_IndexParamVideoPortFormat,          /**< reference: OMX_VIDEO_PARAM_PORTFORMATTYPE */
    OMX_IndexParamVideoQuantization,        /**< reference: OMX_VIDEO_PARAM_QUANTIZATIONTYPE */
    OMX_IndexParamVideoFastUpdate,          /**< reference: OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE */
    OMX_IndexParamVideoBitrate,             /**< reference: OMX_VIDEO_PARAM_BITRATETYPE */
    OMX_IndexParamVideoMotionVector,        /**< reference: OMX_VIDEO_PARAM_MOTIONVECTORTYPE */
    OMX_IndexParamVideoIntraRefresh,        /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
    OMX_IndexParamVideoErrorCorrection,     /**< reference: OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE */
    OMX_IndexParamVideoVBSMC,               /**< reference: OMX_VIDEO_PARAM_VBSMCTYPE */
    OMX_IndexParamVideoMpeg2,               /**< reference: OMX_VIDEO_PARAM_MPEG2TYPE */
    OMX_IndexParamVideoMpeg4,               /**< reference: OMX_VIDEO_PARAM_MPEG4TYPE */
    OMX_IndexParamVideoWmv,                 /**< reference: OMX_VIDEO_PARAM_WMVTYPE */
    OMX_IndexParamVideoRv,                  /**< reference: OMX_VIDEO_PARAM_RVTYPE */
    OMX_IndexParamVideoAvc,                 /**< reference: OMX_VIDEO_PARAM_AVCTYPE */
    OMX_IndexParamVideoH263,                /**< reference: OMX_VIDEO_PARAM_H263TYPE */
    OMX_IndexParamVideoProfileLevelQuerySupported, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
    OMX_IndexParamVideoProfileLevelCurrent, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
    OMX_IndexConfigVideoBitrate,            /**< reference: OMX_VIDEO_CONFIG_BITRATETYPE */
    OMX_IndexConfigVideoFramerate,          /**< reference: OMX_CONFIG_FRAMERATETYPE */
    OMX_IndexConfigVideoIntraVOPRefresh,    /**< reference: OMX_CONFIG_INTRAREFRESHVOPTYPE */
    OMX_IndexConfigVideoIntraMBRefresh,     /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
    OMX_IndexConfigVideoMBErrorReporting,   /**< reference: OMX_CONFIG_MBERRORREPORTINGTYPE */
    OMX_IndexParamVideoMacroblocksPerFrame, /**< reference: OMX_PARAM_MACROBLOCKSTYPE */
    OMX_IndexConfigVideoMacroBlockErrorMap, /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
    OMX_IndexParamVideoSliceFMO,            /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
    OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
    OMX_IndexConfigVideoNalSize,            /**< reference: OMX_VIDEO_CONFIG_NALSIZE */

    /* Image & Video common Configurations */
    OMX_IndexCommonStartUnused = 0x07000000,
    OMX_IndexParamCommonDeblocking,         /**< reference: OMX_PARAM_DEBLOCKINGTYPE */
    OMX_IndexParamCommonSensorMode,         /**< reference: OMX_PARAM_SENSORMODETYPE */
    OMX_IndexParamCommonInterleave,         /**< reference: OMX_PARAM_INTERLEAVETYPE */
    OMX_IndexConfigCommonColorFormatConversion, /**< reference: OMX_CONFIG_COLORCONVERSIONTYPE */
    OMX_IndexConfigCommonScale,             /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
    OMX_IndexConfigCommonImageFilter,       /**< reference: OMX_CONFIG_IMAGEFILTERTYPE */
    OMX_IndexConfigCommonColorEnhancement,  /**< reference: OMX_CONFIG_COLORENHANCEMENTTYPE */
    OMX_IndexConfigCommonColorKey,          /**< reference: OMX_CONFIG_COLORKEYTYPE */
    OMX_IndexConfigCommonColorBlend,        /**< reference: OMX_CONFIG_COLORBLENDTYPE */
    OMX_IndexConfigCommonFrameStabilisation,/**< reference: OMX_CONFIG_FRAMESTABTYPE */
    OMX_IndexConfigCommonRotate,            /**< reference: OMX_CONFIG_ROTATIONTYPE */
    OMX_IndexConfigCommonMirror,            /**< reference: OMX_CONFIG_MIRRORTYPE */
    OMX_IndexConfigCommonOutputPosition,    /**< reference: OMX_CONFIG_POINTTYPE */
    OMX_IndexConfigCommonInputCrop,         /**< reference: OMX_CONFIG_RECTTYPE */
    OMX_IndexConfigCommonOutputCrop,        /**< reference: OMX_CONFIG_RECTTYPE */
    OMX_IndexConfigCommonDigitalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
    OMX_IndexConfigCommonOpticalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE*/
    OMX_IndexConfigCommonWhiteBalance,      /**< reference: OMX_CONFIG_WHITEBALCONTROLTYPE */
    OMX_IndexConfigCommonExposure,          /**< reference: OMX_CONFIG_EXPOSURECONTROLTYPE */
    OMX_IndexConfigCommonContrast,          /**< reference: OMX_CONFIG_CONTRASTTYPE */
    OMX_IndexConfigCommonBrightness,        /**< reference: OMX_CONFIG_BRIGHTNESSTYPE */
    OMX_IndexConfigCommonBacklight,         /**< reference: OMX_CONFIG_BACKLIGHTTYPE */
    OMX_IndexConfigCommonGamma,             /**< reference: OMX_CONFIG_GAMMATYPE */
    OMX_IndexConfigCommonSaturation,        /**< reference: OMX_CONFIG_SATURATIONTYPE */
    OMX_IndexConfigCommonLightness,         /**< reference: OMX_CONFIG_LIGHTNESSTYPE */
    OMX_IndexConfigCommonExclusionRect,     /**< reference: OMX_CONFIG_RECTTYPE */
    OMX_IndexConfigCommonDithering,         /**< reference: OMX_CONFIG_DITHERTYPE */
    OMX_IndexConfigCommonPlaneBlend,        /**< reference: OMX_CONFIG_PLANEBLENDTYPE */
    OMX_IndexConfigCommonExposureValue,     /**< reference: OMX_CONFIG_EXPOSUREVALUETYPE */
    OMX_IndexConfigCommonOutputSize,        /**< reference: OMX_FRAMESIZETYPE */
    OMX_IndexParamCommonExtraQuantData,     /**< reference: OMX_OTHER_EXTRADATATYPE */
    OMX_IndexConfigCommonFocusRegion,       /**< reference: OMX_CONFIG_FOCUSREGIONTYPE */
    OMX_IndexConfigCommonFocusStatus,       /**< reference: OMX_PARAM_FOCUSSTATUSTYPE */
    OMX_IndexConfigCommonTransitionEffect,  /**< reference: OMX_CONFIG_TRANSITIONEFFECTTYPE */

    /* Reserved Configuration range */
    OMX_IndexOtherStartUnused = 0x08000000,
    OMX_IndexParamOtherPortFormat,          /**< reference: OMX_OTHER_PARAM_PORTFORMATTYPE */
    OMX_IndexConfigOtherPower,              /**< reference: OMX_OTHER_CONFIG_POWERTYPE */
    OMX_IndexConfigOtherStats,              /**< reference: OMX_OTHER_CONFIG_STATSTYPE */


    /* Reserved Time range */
    OMX_IndexTimeStartUnused = 0x09000000,
    OMX_IndexConfigTimeScale,               /**< reference: OMX_TIME_CONFIG_SCALETYPE */
    OMX_IndexConfigTimeClockState,          /**< reference: OMX_TIME_CONFIG_CLOCKSTATETYPE */
    OMX_IndexConfigTimeActiveRefClock,      /**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE */
    OMX_IndexConfigTimeCurrentMediaTime,    /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
    OMX_IndexConfigTimeCurrentWallTime,     /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
    OMX_IndexConfigTimeCurrentAudioReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
    OMX_IndexConfigTimeCurrentVideoReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
    OMX_IndexConfigTimeMediaTimeRequest,    /**< reference: OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE (write only) */
    OMX_IndexConfigTimeClientStartTime,     /**<reference:  OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
    OMX_IndexConfigTimePosition,            /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
    OMX_IndexConfigTimeSeekMode,            /**< reference: OMX_TIME_CONFIG_SEEKMODETYPE */


    OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
    /* Vendor specific area */
    OMX_IndexVendorStartUnused = 0x7F000000,
    /* Vendor specific structures should be in the range of 0x7F000000
       to 0x7FFFFFFE.  This range is not broken out by vendor, so
       private indexes are not guaranteed unique and therefore should
       only be sent to the appropriate component. */

    /* used for ilcs-top communication */
    OMX_IndexParamMarkComparison,           /**< reference: OMX_PARAM_MARKCOMPARISONTYPE */
    OMX_IndexParamPortSummary,              /**< reference: OMX_PARAM_PORTSUMMARYTYPE */
    OMX_IndexParamTunnelStatus,             /**< reference : OMX_PARAM_TUNNELSTATUSTYPE */
    OMX_IndexParamBrcmRecursionUnsafe,      /**< reference: OMX_PARAM_BRCMRECURSIONUNSAFETYPE */

    /* used for top-ril communication */
    OMX_IndexParamBufferAddress,            /**< reference : OMX_PARAM_BUFFERADDRESSTYPE */
    OMX_IndexParamTunnelSetup,              /**< reference : OMX_PARAM_TUNNELSETUPTYPE */
    OMX_IndexParamBrcmPortEGL,              /**< reference : OMX_PARAM_BRCMPORTEGLTYPE */
    OMX_IndexParamIdleResourceCount,        /**< reference : OMX_PARAM_U32TYPE */

    /* used for ril-ril communication */
    OMX_IndexParamImagePoolDisplayFunction, /**<reference : OMX_PARAM_IMAGEDISPLAYFUNCTIONTYPE */
    OMX_IndexParamBrcmDataUnit,             /**<reference: OMX_PARAM_DATAUNITTYPE */
    OMX_IndexParamCodecConfig,              /**<reference: OMX_PARAM_CODECCONFIGTYPE */
    OMX_IndexParamCameraPoolToEncoderFunction, /**<reference : OMX_PARAM_CAMERAPOOLTOENCODERFUNCTIONTYPE */
    OMX_IndexParamCameraStripeFunction,     /**<reference : OMX_PARAM_CAMERASTRIPEFUNCTIONTYPE */
    OMX_IndexParamCameraCaptureEventFunction, /**<reference : OMX_PARAM_CAMERACAPTUREEVENTFUNCTIONTYPE */

    /* used for client-ril communication */
    OMX_IndexParamTestInterface,            /**< reference : OMX_PARAM_TESTINTERFACETYPE */

    // 0x7f000010
    OMX_IndexConfigDisplayRegion,           /**< reference : OMX_CONFIG_DISPLAYREGIONTYPE */
    OMX_IndexParamSource,                   /**< reference : OMX_PARAM_SOURCETYPE */
    OMX_IndexParamSourceSeed,               /**< reference : OMX_PARAM_SOURCESEEDTYPE */
    OMX_IndexParamResize,                   /**< reference : OMX_PARAM_RESIZETYPE */
    OMX_IndexConfigVisualisation,           /**< reference : OMX_CONFIG_VISUALISATIONTYPE */
    OMX_IndexConfigSingleStep,              /**<reference : OMX_PARAM_U32TYPE */
    OMX_IndexConfigPlayMode,                /**<reference: OMX_CONFIG_PLAYMODETYPE */
    OMX_IndexParamCameraCamplusId,          /**<reference : OMX_PARAM_U32TYPE */
    OMX_IndexConfigCommonImageFilterParameters,  /**<reference : OMX_CONFIG_IMAGEFILTERPARAMSTYPE */
    OMX_IndexConfigTransitionControl,       /**<reference : OMX_CONFIG_TRANSITIONCONTROLTYPE */
    OMX_IndexConfigPresentationOffset,      /**<reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
    OMX_IndexParamSourceFunctions,          /**<reference: OMX_PARAM_STILLSFUNCTIONTYPE */
    OMX_IndexConfigAudioMonoTrackControl,   /**<reference : OMX_CONFIG_AUDIOMONOTRACKCONTROLTYPE */
    OMX_IndexParamCameraImagePool,          /**<reference : OMX_PARAM_CAMERAIMAGEPOOLTYPE */
    OMX_IndexConfigCameraISPOutputPoolHeight,/**<reference : OMX_PARAM_U32TYPE */
    OMX_IndexParamImagePoolSize,            /**<reference: OMX_PARAM_IMAGEPOOLSIZETYPE */

    // 0x7f000020
    OMX_IndexParamImagePoolExternal,        /**<reference: OMX_PARAM_IMAGEPOOLEXTERNALTYPE */
    OMX_IndexParamRUTILFifoInfo,            /**<reference: OMX_PARAM_RUTILFIFOINFOTYPE*/
    OMX_IndexParamILFifoConfig,             /**<reference: OMX_PARAM_ILFIFOCONFIG */
    OMX_IndexConfigCameraSensorModes,       /**<reference : OMX_CONFIG_CAMERASENSORMODETYPE */
    OMX_IndexConfigBrcmPortStats,           /**<reference : OMX_CONFIG_BRCMPORTSTATSTYPE */
    OMX_IndexConfigBrcmPortBufferStats,     /**<reference : OMX_CONFIG_BRCMPORTBUFFERSTATSTYPE */
    OMX_IndexConfigBrcmCameraStats,         /**<reference : OMX_CONFIG_BRCMCAMERASTATSTYPE */
    OMX_IndexConfigBrcmIOPerfStats,         /**<reference : OMX_CONFIG_BRCMIOPERFSTATSTYPE */
    OMX_IndexConfigCommonSharpness,         /**<reference : OMX_CONFIG_SHARPNESSTYPE */
    OMX_IndexConfigCommonFlickerCancellation,   /**reference : OMX_CONFIG_FLICKERCANCELTYPE */
    OMX_IndexParamCameraSwapImagePools,     /**<reference : OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCameraSingleBufferCaptureInput,  /**<reference : OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigCommonRedEyeRemoval,   /**<reference : OMX_CONFIG_REDEYEREMOVALTYPE  */
    OMX_IndexConfigCommonFaceDetectionControl,  /**<reference : OMX_CONFIG_FACEDETECTIONCONTROLTYPE */
    OMX_IndexConfigCommonFaceDetectionRegion,   /**<reference : OMX_CONFIG_FACEDETECTIONREGIONTYPE */
    OMX_IndexConfigCommonInterlace,         /**<reference: OMX_CONFIG_INTERLACETYPE */

    // 0x7f000030
    OMX_IndexParamISPTunerName,             /**<reference: OMX_PARAM_CAMERAISPTUNERTYPE */
    OMX_IndexParamCameraDeviceNumber,       /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamCameraDevicesPresent,     /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraInputFrame,        /**<reference: OMX_CONFIG_IMAGEPTRTYPE */
    OMX_IndexConfigStillColourDenoiseEnable,    /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigVideoColourDenoiseEnable,    /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigAFAssistLight,           /**<reference: OMX_CONFIG_AFASSISTTYPE */
    OMX_IndexConfigSmartShakeReductionEnable, /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigInputCropPercentages,    /**<reference: OMX_CONFIG_INPUTCROPTYPE */
    OMX_IndexConfigStillsAntiShakeEnable,   /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigWaitForFocusBeforeCapture,/**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigAudioRenderingLatency,   /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigDrawBoxAroundFaces,      /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCodecRequirements,        /**<reference: OMX_PARAM_CODECREQUIREMENTSTYPE */
    OMX_IndexConfigBrcmEGLImageMemHandle,   /**<reference: OMX_CONFIG_BRCMEGLIMAGEMEMHANDLETYPE */
    OMX_IndexConfigPrivacyIndicator,        /**<reference: OMX_CONFIG_PRIVACYINDICATORTYPE */

    // 0x7f000040
    OMX_IndexParamCameraFlashType,          /**<reference: OMX_PARAM_CAMERAFLASHTYPE */
    OMX_IndexConfigCameraEnableStatsPass,   /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigCameraFlashConfig,       /**<reference: OMX_CONFIG_CAMERAFLASHCONFIGTYPE */
    OMX_IndexConfigCaptureRawImageURI,      /**<reference: OMX_PARAM_CONTENTURITYPE */
    OMX_IndexConfigCameraStripeFuncMinLines, /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraAlgorithmVersionDeprecated,   /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraIsoReferenceValue,  /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraCaptureAbortsAutoFocus, /**<reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmClockMissCount,      /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigFlashChargeLevel,         /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmVideoEncodedSliceSize, /**<reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmAudioTrackGaplessPlayback,  /**< reference: OMX_CONFIG_BRCMAUDIOTRACKGAPLESSPLAYBACKTYPE */
    OMX_IndexConfigBrcmAudioTrackChangeControl,    /**< reference: OMX_CONFIG_BRCMAUDIOTRACKCHANGECONTROLTYPE */
    OMX_IndexParamBrcmPixelAspectRatio,     /**< reference: OMX_CONFIG_POINTTYPE */
    OMX_IndexParamBrcmPixelValueRange,      /**< reference: OMX_PARAM_BRCMPIXELVALUERANGETYPE */
    OMX_IndexParamCameraDisableAlgorithm,   /**< reference: OMX_PARAM_CAMERADISABLEALGORITHMTYPE */

    // 0x7f000050
    OMX_IndexConfigBrcmVideoIntraPeriodTime, /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmVideoIntraPeriod,     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmAudioEffectControl, /**< reference: OMX_CONFIG_BRCMAUDIOEFFECTCONTROLTYPE */
    OMX_IndexConfigBrcmMinimumProcessingLatency, /**< reference: OMX_CONFIG_BRCMMINIMUMPROCESSINGLATENCY */
    OMX_IndexParamBrcmVideoAVCSEIEnable,    /**< reference: OMX_PARAM_BRCMVIDEOAVCSEIENABLETYPE */
    OMX_IndexParamBrcmAllowMemChange,   /**< reference: OMX_PARAM_BRCMALLOWMEMCHANGETYPE */
    OMX_IndexConfigBrcmVideoEncoderMBRowsPerSlice, /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamCameraAFAssistDeviceNumber_Deprecated,   /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamCameraPrivacyIndicatorDeviceNumber_Deprecated,   /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraUseCase,               /**< reference: OMX_CONFIG_CAMERAUSECASETYPE */
    OMX_IndexParamBrcmDisableProprietaryTunnels,   /**< reference: OMX_PARAM_BRCMDISABLEPROPRIETARYTUNNELSTYPE */
    OMX_IndexParamBrcmOutputBufferSize,         /**<  reference: OMX_PARAM_BRCMOUTPUTBUFFERSIZETYPE */
    OMX_IndexParamBrcmRetainMemory,             /**< reference: OMX_PARAM_BRCMRETAINMEMORYTYPE */
    OMX_IndexConfigCanFocus_Deprecated,                    /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmImmutableInput,           /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamDynamicParameterFile,        /**< reference: OMX_PARAM_CONTENTURITYPE */

    // 0x7f000060
    OMX_IndexParamUseDynamicParameterFile,     /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigCameraInfo,                 /**< reference: OMX_CONFIG_CAMERAINFOTYPE */
    OMX_IndexConfigCameraFeatures,             /**< reference: OMX_CONFIG_CAMERAFEATURESTYPE */
    OMX_IndexConfigRequestCallback,            /**< reference: OMX_CONFIG_REQUESTCALLBACKTYPE */ //Should be added to the spec as part of IL416c
    OMX_IndexConfigBrcmOutputBufferFullCount,  /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCommonFocusRegionXY,        /**< reference: OMX_CONFIG_FOCUSREGIONXYTYPE */
    OMX_IndexParamBrcmDisableEXIF,             /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigUserSettingsId,             /**< reference: OMX_CONFIG_U8TYPE */
    OMX_IndexConfigCameraSettings,             /**< reference: OMX_CONFIG_CAMERASETTINGSTYPE */
    OMX_IndexConfigDrawBoxLineParams,          /**< reference: OMX_CONFIG_DRAWBOXLINEPARAMS */
    OMX_IndexParamCameraRmiControl_Deprecated,            /**< reference: OMX_PARAM_CAMERARMITYPE */
    OMX_IndexConfigBurstCapture,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmEnableIJGTableScaling,   /**< reference: OMX_PARAM_IJGSCALINGTYPE */
    OMX_IndexConfigPowerDown,                  /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmSyncOutput,             /**< reference: OMX_CONFIG_BRCMSYNCOUTPUTTYPE */
    OMX_IndexParamBrcmFlushCallback,           /**< reference: OMX_PARAM_BRCMFLUSHCALLBACK */

    // 0x7f000070
    OMX_IndexConfigBrcmVideoRequestIFrame,     /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmNALSSeparate,            /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigConfirmView,                /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigDrmView,                    /**< reference: OMX_CONFIG_DRMVIEWTYPE */
    OMX_IndexConfigBrcmVideoIntraRefresh,      /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
    OMX_IndexParamBrcmMaxFileSize,             /**< reference: OMX_PARAM_BRCMU64TYPE */
    OMX_IndexParamBrcmCRCEnable,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmCRC,                     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigCameraRmiInUse_Deprecated,             /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmAudioSource,            /**<reference: OMX_CONFIG_BRCMAUDIOSOURCETYPE */
    OMX_IndexConfigBrcmAudioDestination,       /**< reference: OMX_CONFIG_BRCMAUDIODESTINATIONTYPE */
    OMX_IndexParamAudioDdp,                    /**< reference: OMX_AUDIO_PARAM_DDPTYPE */
    OMX_IndexParamBrcmThumbnail,               /**< reference: OMX_PARAM_BRCMTHUMBNAILTYPE */
    OMX_IndexParamBrcmDisableLegacyBlocks_Deprecated,     /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmCameraInputAspectRatio,  /**< reference: OMX_PARAM_BRCMASPECTRATIOTYPE */
    OMX_IndexParamDynamicParameterFileFailFatal,/**< reference: OMX_CONFIG_BOOLEANTYPE */

    // 0x7f000080
    OMX_IndexParamBrcmVideoDecodeErrorConcealment, /**< reference: OMX_PARAM_BRCMVIDEODECODEERRORCONCEALMENTTYPE */
    OMX_IndexParamBrcmInterpolateMissingTimestamps, /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmSetCodecPerformanceMonitoring, /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigFlashInfo,                  /**< reference: OMX_CONFIG_FLASHINFOTYPE */
    OMX_IndexParamBrcmMaxFrameSkips,           /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigDynamicRangeExpansion,      /**< reference: OMX_CONFIG_DYNAMICRANGEEXPANSIONTYPE */
    OMX_IndexParamBrcmFlushCallbackId,         /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmTransposeBufferCount,    /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigFaceRecognitionControl,     /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigFaceRecognitionSaveFace,    /**< reference: OMX_PARAM_BRCMU64TYPE */
    OMX_IndexConfigFaceRecognitionDatabaseUri, /**< reference: OMX_PARAM_CONTENTURITYPE */
    OMX_IndexConfigClockAdjustment,            /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
    OMX_IndexParamBrcmThreadAffinity,          /**< reference: OMX_PARAM_BRCMTHREADAFFINITYTYPE */
    OMX_IndexParamAsynchronousOutput,          /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigAsynchronousFailureURI,     /**< reference: OMX_PARAM_CONTENTURITYPE */
    OMX_IndexConfigCommonFaceBeautification,   /**< reference: OMX_CONFIG_BOOLEANTYPE */

    // 0x7f000090
    OMX_IndexConfigCommonSceneDetectionControl,/**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigCommonSceneDetected,        /**< reference: OMX_CONFIG_SCENEDETECTTYPE */
    OMX_IndexParamDisableVllPool,              /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamVideoMvc,                    /**< reference: OMX_VIDEO_PARAM_MVCTYPE */
    OMX_IndexConfigBrcmDrawStaticBox,          /**< reference: OMX_CONFIG_STATICBOXTYPE */
    OMX_IndexConfigBrcmClockReferenceSource,   /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamPassBufferMarks,             /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigPortCapturing,              /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexConfigBrcmDecoderPassThrough,     /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmDecoderPassThrough=OMX_IndexConfigBrcmDecoderPassThrough,  /* deprecated */
    OMX_IndexParamBrcmMaxCorruptMBs,           /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmGlobalAudioMute,        /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCameraCaptureMode,           /**< reference: OMX_PARAM_CAMERACAPTUREMODETYPE */
    OMX_IndexParamBrcmDrmEncryption,           /**< reference: OMX_PARAM_BRCMDRMENCRYPTIONTYPE */
    OMX_IndexConfigBrcmCameraRnDPreprocess,    /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmCameraRnDPostprocess,   /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmAudioTrackChangeCount,  /**< reference: OMX_PARAM_U32TYPE */

    // 0x7f0000a0
    OMX_IndexParamCommonUseStcTimestamps,      /**< reference: OMX_PARAM_TIMESTAMPMODETYPE */
    OMX_IndexConfigBufferStall,                /**< reference: OMX_CONFIG_BUFFERSTALLTYPE */
    OMX_IndexConfigRefreshCodec,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCaptureStatus,               /**< reference: OMX_PARAM_CAPTURESTATETYPE */
    OMX_IndexConfigTimeInvalidStartTime,       /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
    OMX_IndexConfigLatencyTarget,              /**< reference: OMX_CONFIG_LATENCYTARGETTYPE */
    OMX_IndexConfigMinimiseFragmentation,      /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmUseProprietaryCallback, /**< reference: OMX_CONFIG_BRCMUSEPROPRIETARYTUNNELTYPE */
    OMX_IndexParamPortMaxFrameSize,            /**< reference: OMX_FRAMESIZETYPE */
    OMX_IndexParamComponentName,               /**< reference: OMX_PARAM_COMPONENTROLETYPE */
    OMX_IndexConfigEncLevelExtension,          /**< reference: OMX_VIDEO_CONFIG_LEVEL_EXTEND */
    OMX_IndexConfigTemporalDenoiseEnable,      /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmLazyImagePoolDestroy,    /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmEEDEEnable,              /**< reference: OMX_VIDEO_EEDE_ENABLE */
    OMX_IndexParamBrcmEEDELossRate,            /**< reference: OMX_VIDEO_EEDE_LOSSRATE */
    OMX_IndexParamAudioDts,                    /**< reference: OMX_AUDIO_PARAM_DTSTYPE */

    // 0x7f0000b0
    OMX_IndexParamNumOutputChannels,           /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmHighDynamicRange,       /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmPoolMemAllocSize,       /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmBufferFlagFilter,       /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoEncodeMinQuant,     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoEncodeMaxQuant,     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamRateControlModel,            /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmExtraBuffers,            /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigFieldOfView,                /**< reference: OMX_CONFIG_BRCMFOVTYPE */
    OMX_IndexParamBrcmAlignHoriz,              /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmAlignVert,               /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamColorSpace,                  /**< reference: OMX_PARAM_COLORSPACETYPE */
    OMX_IndexParamBrcmDroppablePFrames,        /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmVideoInitialQuant,       /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoEncodeQpP,          /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoRCSliceDQuant,      /**< reference: OMX_PARAM_U32TYPE */

    // 0x7f0000c0
    OMX_IndexParamBrcmVideoFrameLimitBits,     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoPeakRate,           /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmVideoH264DisableCABAC,  /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmVideoH264LowLatency,    /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmVideoH264AUDelimiters,  /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmVideoH264DeblockIDC,    /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigBrcmVideoH264IntraMBMode,   /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexConfigContrastEnhance,            /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCameraCustomSensorConfig,    /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmHeaderOnOpen,            /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmUseRegisterFile,        /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmRegisterFileFailFatal,  /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmConfigFileRegisters,     /**< reference: OMX_PARAM_BRCMCONFIGFILETYPE */
    OMX_IndexParamBrcmConfigFileChunkRegisters,/**< reference: OMX_PARAM_BRCMCONFIGFILECHUNKTYPE */
    OMX_IndexParamBrcmAttachLog,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamCameraZeroShutterLag,        /**< reference: OMX_CONFIG_ZEROSHUTTERLAGTYPE */

    // 0x7f0000d0
    OMX_IndexParamBrcmFpsRange,                /**< reference: OMX_PARAM_BRCMFRAMERATERANGETYPE */
    OMX_IndexParamCaptureExposureCompensation, /**< reference: OMX_PARAM_S32TYPE */
    OMX_IndexParamBrcmVideoPrecodeForQP,       /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmVideoTimestampFifo,      /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamSWSharpenDisable,            /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexConfigBrcmFlashRequired,          /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmVideoDrmProtectBuffer,   /**< reference: OMX_PARAM_BRCMVIDEODRMPROTECTBUFFERTYPE */
    OMX_IndexParamSWSaturationDisable,         /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmVideoDecodeConfigVD3,    /**< reference: OMX_PARAM_BRCMVIDEODECODECONFIGVD3TYPE */
    OMX_IndexConfigBrcmPowerMonitor,           /**< reference: OMX_CONFIG_BOOLEANTYPE */
    OMX_IndexParamBrcmZeroCopy,                /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexParamBrcmVideoEGLRenderDiscardMode,   /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexParamBrcmVideoAVC_VCLHRDEnable,    /**< reference: OMX_CONFIG_PORTBOOLEANTYPE*/
    OMX_IndexParamBrcmVideoAVC_LowDelayHRDEnable, /**< reference: OMX_CONFIG_PORTBOOLEANTYPE*/
    OMX_IndexParamBrcmVideoCroppingDisable,    /**< reference: OMX_CONFIG_PORTBOOLEANTYPE*/
    OMX_IndexParamBrcmVideoAVCInlineHeaderEnable, /**< reference: OMX_CONFIG_PORTBOOLEANTYPE*/

    // 0x7f0000f0
    OMX_IndexConfigBrcmAudioDownmixCoefficients = 0x7f0000f0, /**< reference: OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS */
    OMX_IndexConfigBrcmAudioDownmixCoefficients8x8,           /**< reference: OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8 */
    OMX_IndexConfigBrcmAudioMaxSample,                        /**< reference: OMX_CONFIG_BRCMAUDIOMAXSAMPLE */
    OMX_IndexConfigCustomAwbGains,                            /**< reference: OMX_CONFIG_CUSTOMAWBGAINSTYPE */
    OMX_IndexParamRemoveImagePadding,                         /**< reference: OMX_CONFIG_PORTBOOLEANTYPE*/
    OMX_IndexParamBrcmVideoAVCInlineVectorsEnable,            /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexConfigBrcmRenderStats,                           /**< reference: OMX_CONFIG_BRCMRENDERSTATSTYPE */
    OMX_IndexConfigBrcmCameraAnnotate,                        /**< reference: OMX_CONFIG_BRCMANNOTATETYPE */
    OMX_IndexParamBrcmStereoscopicMode,                       /**< reference :OMX_CONFIG_BRCMSTEREOSCOPICMODETYPE */
    OMX_IndexParamBrcmLockStepEnable,                         /**< reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexParamBrcmTimeScale,                              /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamCameraInterface,                            /**< reference: OMX_PARAM_CAMERAINTERFACETYPE */
    OMX_IndexParamCameraClockingMode,                         /**< reference: OMX_PARAM_CAMERACLOCKINGMODETYPE */
    OMX_IndexParamCameraRxConfig,                             /**< reference: OMX_PARAM_CAMERARXCONFIG_TYPE */
    OMX_IndexParamCameraRxTiming,                             /**< reference: OMX_PARAM_CAMERARXTIMING_TYPE */
    OMX_IndexParamDynamicParameterConfig,                     /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexParamBrcmVideoAVCSPSTimingEnable,                /** reference: OMX_CONFIG_PORTBOOLEANTYPE */
    OMX_IndexParamBrcmBayerOrder,                             /** reference: OMX_PARAM_BAYERORDERTYPE */
    OMX_IndexParamBrcmMaxNumCallbacks,                        /**< reference: OMX_PARAM_U32TYPE */
    OMX_IndexMax = 0x7FFFFFFF
} OMX_INDEXTYPE;

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */

                                                                                 /*
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** @file OMX_Other.h - OpenMax IL version 1.1.2
 *  The structures needed by Other components to exchange
 *  parameters and configuration data with the components.
 */

#ifndef OMX_Other_h
#define OMX_Other_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


/* Each OMX header must include all required header files to allow the
 *  header to compile without errors.  The includes below are required
 *  for this header file to compile successfully 
 */

#include "OMX_Core.h"


/** 
 * Enumeration of possible data types which match to multiple domains or no
 * domain at all.  For types which are vendor specific, a value above
 * OMX_OTHER_VENDORTSTART should be used.
 */
typedef enum OMX_OTHER_FORMATTYPE {
    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time, 
                                   time deltas, etc */
    OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power 
                                   management, setting clocks? */
    OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames 
                                   dropped, etc */
    OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
    OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific 
                                                formats */

    OMX_OTHER_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_OTHER_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

    OMX_OTHER_FormatText,
    OMX_OTHER_FormatTextSKM2,
    OMX_OTHER_FormatText3GP5,

    OMX_OTHER_FormatMax = 0x7FFFFFFF
} OMX_OTHER_FORMATTYPE;

/** 
 * Enumeration of seek modes.
 */
typedef enum OMX_TIME_SEEKMODETYPE {
    OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
                                * of the requested seek position over   
                                * the actual seek position if it
                                * results in a faster seek. */
    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek 
                                * position over an approximation
                                * of the requested seek position even
                                * if it results in a slower seek. */
    OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
    OMX_TIME_SeekModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */

    OMX_TIME_SeekModeDirectional, /**< Similar to Fast, but if seeking backwards will
                                   * try and seek to a previous sync position from the
                                   * current media time. */

    OMX_TIME_SeekModeMax = 0x7FFFFFFF
} OMX_TIME_SEEKMODETYPE;

/* Structure representing the seekmode of the component */
typedef struct OMX_TIME_CONFIG_SEEKMODETYPE {
    OMX_U32 nSize;                  /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
    OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
} OMX_TIME_CONFIG_SEEKMODETYPE;

/** Structure representing a time stamp used with the following configs 
 * on the Clock Component (CC):
 * 
 * OMX_IndexConfigTimeCurrentWallTime: query of the CCs current wall  
 *     time
 * OMX_IndexConfigTimeCurrentMediaTime: query of the CCs current media
 *     time
 * OMX_IndexConfigTimeCurrentAudioReference and  
 * OMX_IndexConfigTimeCurrentVideoReference: audio/video reference 
 *     clock sending SC its reference time
 * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends 
 *     this structure to the Clock Component via a SetConfig on its 
 *     client port when it receives a buffer with
 *     OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
 *     specified by that buffer for nStartTimestamp. 
 *
 * Its also used with the following config on components in general:
 *
 * OMX_IndexConfigTimePosition: IL client querying component position 
 * (GetConfig) or commanding a component to seek to the given location
 * (SetConfig)
 */	
typedef struct OMX_TIME_CONFIG_TIMESTAMPTYPE {
    OMX_U32 nSize;               /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;    /**< OMX specification version
                                  *   information */
    OMX_U32 nPortIndex;     /**< port that this structure applies to */
    OMX_TICKS nTimestamp;  	     /**< timestamp .*/ 
} OMX_TIME_CONFIG_TIMESTAMPTYPE;  

/** Enumeration of possible reference clocks to the media time. */
typedef enum OMX_TIME_UPDATETYPE {
      OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
      OMX_TIME_UpdateScaleChanged,	        /**< Update was generated because the scale chagned. */
      OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
      OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
      OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
      OMX_TIME_UpdateMax = 0x7FFFFFFF
} OMX_TIME_UPDATETYPE;

/** Enumeration of possible reference clocks to the media time. */
typedef enum OMX_TIME_REFCLOCKTYPE {
      OMX_TIME_RefClockNone,    /**< Use no references. */
      OMX_TIME_RefClockAudio,	/**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
      OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
      OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
      OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
      OMX_TIME_RefClockMax = 0x7FFFFFFF
} OMX_TIME_REFCLOCKTYPE;

/** Enumeration of clock states. */
typedef enum OMX_TIME_CLOCKSTATE {
      OMX_TIME_ClockStateRunning,             /**< Clock running. */
      OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the 
                                               *   prescribed clients emit their
                                               *   start time. */
      OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
      OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
      OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
      OMX_TIME_ClockStateMax = 0x7FFFFFFF
} OMX_TIME_CLOCKSTATE;

/** Structure representing a media time request to the clock component.
 *
 *  A client component sends this structure to the Clock Component via a SetConfig
 *  on its client port to specify a media timestamp the Clock Component
 *  should emit.  The Clock Component should fulfill the request by sending a
 *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested 
 *  timestamp.
 *
 *  The client may require a media time request be fulfilled slightly
 *  earlier than the media time specified. In this case the client specifies 
 *  an offset which is equal to the difference between wall time corresponding 
 *  to the requested media time and the wall time when it will be 
 *  fulfilled. 
 *
 *  A client component may uses these requests and the OMX_TIME_MEDIATIMETYPE to
 *  time events according to timestamps. If a client must perform an operation O at
 *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a 
 *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
 *  is a little early). When the clock component passes the resulting OMX_TIME_MEDIATIMETYPE
 *  structure back to the client component, the client may perform operation O (perhaps having
 *  to wait a slight amount more time itself as specified by the return values).
 */

typedef struct OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
    OMX_U32 nPortIndex;         /**< port that this structure applies to */
    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time 
                                 *   from others (e.g. the number of the frame to deliver). 
                                 *   Duplicated in the media time structure that fulfills 
                                 *   this request. A value of zero is reserved for time scale 
                                 *   updates. */
    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/ 
    OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
                                 *   request should be fulfilled early */
} OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;

/**< Structure sent from the clock component client either when fulfilling 
 *   a media time request or when the time scale has changed. 
 *
 *   In the former case the Clock Component fills this structure and times its emission 
 *   to a client component (via the client port) according to the corresponding media 
 *   time request sent by the client. The Clock Component should time the emission to occur
 *   when the requested timestamp matches the Clock Component's media time but also the 
 *   prescribed offset early. 
 *
 *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
 *   media time and sets the nScale to the new scale via the client port. It emits a 
 *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to 
 *   alter processing to accomodate scaling. For instance a video component might skip inter-frames 
 *   in the case of extreme fastforward. Likewise an audio component might add or remove samples 
 *   from an audio frame to scale audio data. 
 *
 *   It is expected that some clock components may not be able to fulfill requests
 *   at exactly the prescribed time. This is acceptable so long as the request is 
 *   fulfilled at least as early as described and not later. This structure provides 
 *   fields the client may use to wait for the remaining time.
 *
 *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the 
 *   wall time until the nMediaTimestamp actually occurs. In the latter case the
 *   client can get a more accurate value for offset by getting the current wall
 *   from the cloc component and subtracting it from nWallTimeAtMedia. 
 */

typedef struct OMX_TIME_MEDIATIMETYPE {
    OMX_U32 nSize;                  /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time 
                                     *   from others. Copied from the media time request. 
                                     *   A value of zero is reserved for time scale updates. */
    OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was 
                                     *   requested then this is the current media time. */ 
    OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
                                     *   request was actually fulfilled early */

    OMX_TICKS nWallTimeAtMediaTime; /**< Wall time corresponding to nMediaTimeStamp.
                                     *   A client may compare this value to current
                                     *   media time obtained from the Clock Component to determine
                                     *   the wall time until the media timestamp is really
                                     *   current. */
    OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
    OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
                                    /**< State of the media time. */
} OMX_TIME_MEDIATIMETYPE;  

/** Structure representing the current media time scale factor. Applicable only to clock 
 *  component, other components see scale changes via OMX_TIME_MEDIATIMETYPE buffers sent via
 *  the clock component client ports. Upon recieving this config the clock component changes 
 *  the rate by which the media time increases or decreases effectively implementing trick modes. 
 */ 
typedef struct OMX_TIME_CONFIG_SCALETYPE {
    OMX_U32 nSize;                  /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
    OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
                                     * scaling the media time */
} OMX_TIME_CONFIG_SCALETYPE;
 
/** Bits used to identify a clock port. Used in OMX_TIME_CONFIG_CLOCKSTATETYPEs nWaitMask field */
#define OMX_CLOCKPORT0 0x00000001
#define OMX_CLOCKPORT1 0x00000002
#define OMX_CLOCKPORT2 0x00000004
#define OMX_CLOCKPORT3 0x00000008
#define OMX_CLOCKPORT4 0x00000010
#define OMX_CLOCKPORT5 0x00000020
#define OMX_CLOCKPORT6 0x00000040
#define OMX_CLOCKPORT7 0x00000080

/** Structure representing the current mode of the media clock. 
 *  IL Client uses this config to change or query the mode of the 
 *  media clock of the clock component. Applicable only to clock
 *  component. 
 *  
 *  On a SetConfig if eState is OMX_TIME_ClockStateRunning media time
 *  starts immediately at the prescribed start time. If
 *  OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
 *  the given nStartTime and waits for all clients specified in the 
 *  nWaitMask to send starttimes (via 
 *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts 
 *  the media clock using the earliest start time supplied. */    
typedef struct OMX_TIME_CONFIG_CLOCKSTATETYPE {
    OMX_U32 nSize;              /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;   /**< OMX specification version 
                                 *   information */
    OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
    OMX_TICKS nStartTime;       /**< Start time of the media time. */
    OMX_TICKS nOffset;          /**< Time to offset the media time by 
                                 * (e.g. preroll). Media time will be
                                 * reported to be nOffset ticks earlier.     
                                 */
    OMX_U32 nWaitMask;          /**< Mask of OMX_CLOCKPORT values. */
} OMX_TIME_CONFIG_CLOCKSTATETYPE;

/** Structure representing the reference clock currently being used to
 *  compute media time. IL client uses this config to change or query the 
 *  clock component's active reference clock */
typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
    OMX_U32 nSize;                  /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */                        
} OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;

/** Descriptor for setting specifics of power type.
 *  Note: this structure is listed for backwards compatibility. */
typedef struct OMX_OTHER_CONFIG_POWERTYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_BOOL bEnablePM;       /**< Flag to enable Power Management */
} OMX_OTHER_CONFIG_POWERTYPE;


/** Descriptor for setting specifics of stats type.
 *  Note: this structure is listed for backwards compatibility. */
typedef struct OMX_OTHER_CONFIG_STATSTYPE {
    OMX_U32 nSize;            /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    /* what goes here */
} OMX_OTHER_CONFIG_STATSTYPE;


/**
 * The PortDefinition structure is used to define all of the parameters 
 * necessary for the compliant component to setup an input or an output other 
 * path.
 */
typedef struct OMX_OTHER_PORTDEFINITIONTYPE {
    OMX_OTHER_FORMATTYPE eFormat;  /**< Type of data expected for this channel */
} OMX_OTHER_PORTDEFINITIONTYPE;

/**  Port format parameter.  This structure is used to enumerate
  *  the various data input/output format supported by the port.
  */
typedef struct OMX_OTHER_PARAM_PORTFORMATTYPE {
    OMX_U32 nSize; /**< size of the structure in bytes */
    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
    OMX_U32 nPortIndex; /**< Indicates which port to set */
    OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
    OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
} OMX_OTHER_PARAM_PORTFORMATTYPE; 

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef __VC_INCLUDE_COMMON_H__
#define __VC_INCLUDE_COMMON_H__

#include "interface/vcos/vcos_stdint.h"
#include "interface/vctypes/vc_image_types.h"

#if defined(__HIGHC__) && defined(_VIDEOCORE) && !defined(_I386)
// __HIGHC__ is only available with MW
// The scvc plugins are compiled (bizarrely) on an x86 with _VIDEOCORE set!
#include <vc/intrinsics.h>
#endif

#ifdef __COVERITY__
#ifndef _Rarely
#define _Rarely(x) (x)
#endif
#ifndef _Usually
#define _Usually(x) (x)
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __SYMBIAN32__
# ifndef INLINE
#  define INLINE __inline
# endif

/* Align a pointer/integer by rounding up/down */
#define ALIGN_DOWN(p, n)   ((uint32_t)(p) - ( (uint32_t)(p) % (uint32_t)(n) ))
#define ALIGN_UP(p, n)     ALIGN_DOWN((uint32_t)(p) + (uint32_t)(n) - 1, (n))

#elif defined (VCMODS_LCC)
#include <limits.h>


#elif !defined(__KERNEL__)
#include <limits.h>

#endif


/*}}}*/

/* Fixed-point types */
typedef unsigned short uint8p8_t;
typedef signed short sint8p8_t;
typedef unsigned short uint4p12_t;
typedef signed short sint4p12_t;
typedef signed short sint0p16_t;
typedef signed char sint8p0_t;
typedef unsigned char uint0p8_t;
typedef signed long int24p8_t;

/*{{{ Common typedefs */

typedef enum bool_e
{
   VC_FALSE = 0,
   VC_TRUE = 1,
} VC_BOOL_T;

#ifndef bool_t
#define bool_t VC_BOOL_T
#endif

/*}}}*/

/*{{{ Common macros */


/* Align a pointer/integer by rounding up/down */
#define ALIGN_DOWN(p, n)   ((uintptr_t)(p) - ( (uintptr_t)(p) % (uintptr_t)(n) ))
#define ALIGN_UP(p, n)     ALIGN_DOWN((uintptr_t)(p) + (uintptr_t)(n) - 1, (n))

#define CLIP(lower, n, upper) _min((upper), _max((lower), (n)))

/*}}}*/

/*{{{ Debugging and profiling macros */

#if 0
/* There's already an assert_once in <logging/logging.h> */
#ifdef DEBUG
#define assert_once(x) \
   { \
      static uint8_t ignore = 0; \
      if(!ignore) \
      { \
         assert(x); \
         ignore++; \
      } \
   }
#else
#define assert_once(x) (void)0
#endif
#endif /* 0 */

#if defined(__HIGHC__) && !defined(NDEBUG)
/* HighC lacks a __FUNCTION__ preproc symbol... :( */
#define profile_rename(name) _ASM(".global " name "\n" name ":\n")
#else
#define profile_rename(name) (void)0
#endif

/*}}}*/
#ifdef __cplusplus
 }
#endif
#endif /* __VCINCLUDE_COMMON_H__ */

                                                                                                                                                                                                                                                                        /*
 * Copyright (c) 2008 The Khronos Group Inc. 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions: 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software. 
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 */

/** OMX_Types.h - OpenMax IL version 1.1.2
 *  The OMX_Types header file contains the primitive type definitions used by 
 *  the core, the application and the component.  This file may need to be
 *  modified to be used on systems that do not have "char" set to 8 bits, 
 *  "short" set to 16 bits and "long" set to 32 bits.
 */

#ifndef OMX_Types_h
#define OMX_Types_h

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/** The OMX_API and OMX_APIENTRY are platform specific definitions used
 *  to declare OMX function prototypes.  They are modified to meet the
 *  requirements for a particular platform */
#ifdef __SYMBIAN32__   
#   ifdef __OMX_EXPORTS
#       define OMX_API __declspec(dllexport)
#   else
#       ifdef _WIN32
#           define OMX_API __declspec(dllexport) 
#       else
#           define OMX_API __declspec(dllimport)
#       endif
#   endif
#else
#   if defined(_WIN32) && !defined(__MINGW32__)
#      ifdef __OMX_EXPORTS
#          define OMX_API __declspec(dllexport)
#      else
#          define OMX_API __declspec(dllimport)
#      endif
#   else
#      ifdef __OMX_EXPORTS
#          define OMX_API
#      else
#          define OMX_API extern
#      endif
#   endif
#endif

#ifndef OMX_APIENTRY
#define OMX_APIENTRY 
#endif 

/** OMX_IN is used to identify inputs to an OMX function.  This designation 
    will also be used in the case of a pointer that points to a parameter 
    that is used as an output. */
#ifndef OMX_IN
#define OMX_IN
#endif

/** OMX_OUT is used to identify outputs from an OMX function.  This 
    designation will also be used in the case of a pointer that points 
    to a parameter that is used as an input. */
#ifndef OMX_OUT
#define OMX_OUT
#endif


/** OMX_INOUT is used to identify parameters that may be either inputs or
    outputs from an OMX function at the same time.  This designation will 
    also be used in the case of a pointer that  points to a parameter that 
    is used both as an input and an output. */
#ifndef OMX_INOUT
#define OMX_INOUT
#endif

/** OMX_ALL is used to as a wildcard to select all entities of the same type
 *  when specifying the index, or referring to a object by an index.  (i.e.
 *  use OMX_ALL to indicate all N channels). When used as a port index
 *  for a config or parameter this OMX_ALL denotes that the config or
 *  parameter applies to the entire component not just one port. */
#define OMX_ALL 0xFFFFFFFF

/** In the following we define groups that help building doxygen documentation */

/** @defgroup core OpenMAX IL core
 * Functions and structure related to the OMX IL core
 */
 
 /** @defgroup comp OpenMAX IL component
 * Functions and structure related to the OMX IL component
 */
 
/** @defgroup rpm Resource and Policy Management 
 * Structures for resource and policy management of components
 */

/** @defgroup buf Buffer Management
 * Buffer handling functions and structures
 */
  
/** @defgroup tun Tunneling
 * @ingroup core comp
 * Structures and functions to manage tunnels among component ports
 */
 
/** @defgroup cp Content Pipes
 *  @ingroup core
 */
 
 /** @defgroup metadata Metadata handling
  * 
  */ 

#if defined(__GNUC__)
#include <stdint.h>
#define STDINT_H_AVAILABLE
#endif

/** OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
typedef unsigned char OMX_U8;

/** OMX_S8 is an 8 bit signed quantity that is byte aligned */
typedef signed char OMX_S8;

/** OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
typedef unsigned short OMX_U16;

/** OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
typedef signed short OMX_S16;

/** OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
#ifdef STDINT_H_AVAILABLE
typedef uint32_t OMX_U32;
#else
typedef unsigned long OMX_U32;
#endif

/** OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
#ifdef STDINT_H_AVAILABLE
typedef int32_t OMX_S32;
#else
typedef signed long OMX_S32;
#endif


/* Users with compilers that cannot accept the "long long" designation should
   define the OMX_SKIP64BIT macro.  It should be noted that this may cause 
   some components to fail to compile if the component was written to require
   64 bit integral types.  However, these components would NOT compile anyway
   since the compiler does not support the way the component was written.
*/
#ifndef OMX_SKIP64BIT
#ifdef __SYMBIAN32__
/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
typedef unsigned long long OMX_U64;

/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
typedef signed long long OMX_S64;

#elif defined(WIN32)

/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */   
typedef unsigned __int64  OMX_U64;

/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
typedef signed   __int64  OMX_S64;

#else /* WIN32 */

/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
typedef unsigned long long OMX_U64;

/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
typedef signed long long OMX_S64;

#endif /* WIN32 */
#endif


/** The OMX_BOOL type is intended to be used to represent a true or a false 
    value when passing parameters to and from the OMX core and components.  The
    OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
 */
typedef enum OMX_BOOL {
    OMX_FALSE = 0,
    OMX_TRUE = !OMX_FALSE,
    OMX_BOOL_MAX = 0x7FFFFFFF
} OMX_BOOL; 
 
/** The OMX_PTR type is intended to be used to pass pointers between the OMX
    applications and the OMX Core and components.  This is a 32 bit pointer and
    is aligned on a 32 bit boundary.
 */
typedef void* OMX_PTR;

/** The OMX_STRING type is intended to be used to pass "C" type strings between
    the application and the core and component.  The OMX_STRING type is a 32 
    bit pointer to a zero terminated string.  The  pointer is word aligned and 
    the string is byte aligned.  
 */
typedef char* OMX_STRING;

/** The OMX_BYTE type is intended to be used to pass arrays of bytes such as
    buffers between the application and the component and core.  The OMX_BYTE 
    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
    aligned and the string is byte aligned.
 */
typedef unsigned char* OMX_BYTE;

/** OMX_UUIDTYPE is a very long unique identifier to uniquely identify
    at runtime.  This identifier should be generated by a component in a way
    that guarantees that every instance of the identifier running on the system
    is unique. */
typedef unsigned char OMX_UUIDTYPE[128];

/** The OMX_DIRTYPE enumeration is used to indicate if a port is an input or
    an output port.  This enumeration is common across all component types.    
 */
typedef enum OMX_DIRTYPE
{
    OMX_DirInput,              /**< Port is an input port */
    OMX_DirOutput,             /**< Port is an output port */
    OMX_DirMax = 0x7FFFFFFF
} OMX_DIRTYPE;

/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering 
    for numerical data (i.e. big endian, or little endian).    
 */
typedef enum OMX_ENDIANTYPE
{
    OMX_EndianBig, /**< big endian */
    OMX_EndianLittle, /**< little endian */
    OMX_EndianMax = 0x7FFFFFFF
} OMX_ENDIANTYPE;


/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data 
    is signed or unsigned
 */
typedef enum OMX_NUMERICALDATATYPE
{
    OMX_NumericalDataSigned, /**< signed data */
    OMX_NumericalDataUnsigned, /**< unsigned data */
    OMX_NumercialDataMax = 0x7FFFFFFF
} OMX_NUMERICALDATATYPE;


/** Unsigned bounded value type */
typedef struct OMX_BU32 {
    OMX_U32 nValue; /**< actual value */
    OMX_U32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
    OMX_U32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
} OMX_BU32;


/** Signed bounded value type */
typedef struct OMX_BS32 {
    OMX_S32 nValue; /**< actual value */
    OMX_S32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
    OMX_S32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
} OMX_BS32;


/** Structure representing some time or duration in microseconds. This structure
  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate 
  *  negative deltas and preroll scenarios. The quantity is represented in microseconds 
  *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g. 
  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to 
  *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
  *  or minus 35 minutes).
  *
  *  Implementations with limited precision may convert the signed 64 bit value to 
  *  a signed 32 bit value internally but risk loss of precision.  
  */
#ifndef OMX_SKIP64BIT
typedef OMX_S64 OMX_TICKS;
#else
typedef struct OMX_TICKS
{
    OMX_U32 nLowPart;    /** low bits of the signed 64 bit tick value */
    OMX_U32 nHighPart;   /** high bits of the signed 64 bit tick value */
} OMX_TICKS;
#endif
#define OMX_TICKS_PER_SECOND 1000000

/** Define the public interface for the OMX Handle.  The core will not use
    this value internally, but the application should only use this value.
 */
typedef void* OMX_HANDLETYPE;

typedef struct OMX_MARKTYPE
{
    OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will 
                                                generate a mark event upon 
                                                processing the mark. */
    OMX_PTR pMarkData;   /**< Application specific data associated with 
                              the mark sent on a mark event to disambiguate 
                              this mark from others. */
} OMX_MARKTYPE;


/** OMX_NATIVE_DEVICETYPE is used to map a OMX video port to the
 *  platform & operating specific object used to reference the display 
 *  or can be used by a audio port for native audio rendering */
typedef void* OMX_NATIVE_DEVICETYPE;

/** OMX_NATIVE_WINDOWTYPE is used to map a OMX video port to the
 *  platform & operating specific object used to reference the window */
typedef void* OMX_NATIVE_WINDOWTYPE;


/** Define the OMX IL version that corresponds to this set of header files.
 *  We also define a combined version that can be used to write or compare
 *  values of the 32bit nVersion field, assuming a little endian architecture */
#define OMX_VERSION_MAJOR 1
#define OMX_VERSION_MINOR 1
#define OMX_VERSION_REVISION 2
#define OMX_VERSION_STEP 0

#define OMX_VERSION ((OMX_VERSION_STEP<<24) | (OMX_VERSION_REVISION<<16) | (OMX_VERSION_MINOR<<8) | OMX_VERSION_MAJOR)


/** The OMX_VERSIONTYPE union is used to specify the version for
    a structure or component.  For a component, the version is entirely
    specified by the component vendor.  Components doing the same function
    from different vendors may or may not have the same version.  For 
    structures, the version shall be set by the entity that allocates the
    structure.  For structures specified in the OMX 1.1 specification, the
    value of the version shall be set to 1.1.0.0 in all cases.  Access to the
    OMX_VERSIONTYPE can be by a single 32 bit access (e.g. by nVersion) or
    by accessing one of the structure elements to, for example, check only
    the Major revision.
 */
typedef union OMX_VERSIONTYPE
{
    struct
    {
        OMX_U8 nVersionMajor;   /**< Major version accessor element */
        OMX_U8 nVersionMinor;   /**< Minor version accessor element */
        OMX_U8 nRevision;       /**< Revision version accessor element */
        OMX_U8 nStep;           /**< Step version accessor element */
    } s;
    OMX_U32 nVersion;           /**< 32 bit value to make accessing the
                                    version easily done in a single word
                                    size copy/compare operation */
} OMX_VERSIONTYPE;

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/* File EOF */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef __VC_INCLUDE_IMAGE_TYPES_H__
#define __VC_INCLUDE_IMAGE_TYPES_H__

#include "interface/vctypes/vc_image_types.h"

#endif /* __VC_INCLUDE_IMAGE_TYPES_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef VCORE_H
#define VCORE_H

#ifdef __VIDEOCORE__
#include "vc/intrinsics.h"
#undef asm
#define asm(x) _ASM(x)

#undef min
#define min(x,y) _min(x,y)

#undef max
#define max(x,y) _max(x,y)

#ifndef abs
#define abs(x) _abs(x)
#endif
#else
#define _vasm asm
#define _bkpt() do {asm(" bkpt");}while(0)
#define _di() do{asm(" di");}while(0)
#define _ei() do{asm(" ei");}while(0)
#define _nop() do{asm(" nop");}while(0)
#define _sleep() do{asm(" sleep");}while(0)

#undef min
#define min(x,y) ((x)<(y) ? (x):(y))

#undef max
#define max(x,y) ((x)>(y) ? (x):(y))

#ifndef abs
#define abs(x) ((x)>=0 ? (x):-(x))
#endif
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            !<arch>
/               1463768117  0     0     0       44        `
         vcfiled_lock vcfiled_is_running //                                              20        `
vcfiled_check.c.o/

/0              1463768117  1000  1000  100664  3012      `
ELF          (            	     4     (  	 M-@M `/ P 0P  
     z  P:   . pP&   @0    @@@@@@0 P/  ! ` 0        PT    @ @   P5  
\ 0  8/ @   P
, 0  8/ @  @@   `     P  !   8/  @ 0  8/  @  pP  | 0  8/ @
      <   8/ @     L  $        l   4   @- $M P  P     @0` p  @@@@@@0a P      $    0     $      could not create %s:%s
 could not create lockfile %s:%s
    could not re-open lockfile %s:%s
   already running at pid %d
  could not lock %s:%s
   %d  could not write pid:%s
 %s: Could not access lockfile %s: %s
   vmcs_main    GCC: (crosstool-NG crosstool-ng-1.22.0-88-g8460611) 4.9.3 A=   aeabi 3   ARM1176JZF-S 	
"D .symtab .strtab .shstrtab .rel.text .data .bss .rodata.str1.4 .comment .note.GNU-stack .ARM.attributes                                                                                           p                                   !              &   `          +   |          0   <          5                            8         :             ?                                                                                   D           Q              Z              b              h              o              u              |                                                                                                                                                       vcfiled_check.c $a $d .LC5 .LC1 .LC0 .LC3 .LC4 .LC2 .LC6 .LC8 .LC7 vcfiled_lock __strdup strrchr mkdir open64 fcntl getpid snprintf strlen write free __errno_location strerror read close strtol vcfiled_is_running printf              8     P                                  !     "    #  0  "  @  #  d  "    $    %    #    %        #  ,  &  8  "  @  #  d  !  p    t    x  	  |  
                        "    #  (  (  8    <                                                         4   @                    	   @         8  
            %             t                     +             t                     0      2       t                   ?      0       X  ;                 H                                   X     p          >                                  h                                <                	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
CFLAGS+=-DSTANDALONE -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS -DTARGET_POSIX -D_LINUX -fPIC -DPIC -D_REENTRANT -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -U_FORTIFY_SOURCE -Wall -g -DHAVE_LIBOPENMAX=2 -DOMX -DOMX_SKIP64BIT -ftree-vectorize -pipe -DUSE_EXTERNAL_OMX -DHAVE_LIBBCM_HOST -DUSE_EXTERNAL_LIBBCM_HOST -DUSE_VCHIQ_ARM -Wno-psabi

LDFLAGS+=-L$(SDKSTAGE)/opt/vc/lib/ -lGLESv2 -lEGL -lopenmaxil -lbcm_host -lvcos -lvchiq_arm -lpthread -lrt -lm -L$(SDKSTAGE)/opt/vc/src/hello_pi/libs/ilclient -L$(SDKSTAGE)/opt/vc/src/hello_pi/libs/vgfont

INCLUDES+=-I$(SDKSTAGE)/opt/vc/include/ -I$(SDKSTAGE)/opt/vc/include/interface/vcos/pthreads -I$(SDKSTAGE)/opt/vc/include/interface/vmcs_host/linux -I./ -I$(SDKSTAGE)/opt/vc/src/hello_pi/libs/ilclient -I$(SDKSTAGE)/opt/vc/src/hello_pi/libs/vgfont

all: $(BIN) $(LIB)

%.o: %.c
	@rm -f $@ 
	$(CC) $(CFLAGS) $(INCLUDES) -g -c $< -o $@ -Wno-deprecated-declarations

%.o: %.cpp
	@rm -f $@ 
	$(CXX) $(CFLAGS) $(INCLUDES) -g -c $< -o $@ -Wno-deprecated-declarations

%.bin: $(OBJS)
	$(CC) -o $@ -Wl,--whole-archive $(OBJS) $(LDFLAGS) -Wl,--no-whole-archive -rdynamic

%.a: $(OBJS)
	$(AR) r $@ $^

clean:
	for i in $(OBJS); do (if test -e "$$i"; then ( rm $$i ); fi ); done
	@rm -f $(BIN) $(LIB)


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ELF          (    0
  4   7   4    (                  &  &           &  & & x             &  & &             Qtd                                          ( HX H                !       %   &   *       +       ,   -   /   0       4jvT<qXsy]|XyJBE|`0'0spWI7                                &       b                                         R           "                  ~                                        x             p             i                          %                                         P                                                     a               8                              $(              
 u         
               (                    (           $   
    <     
   $(         $(            h    
         
   (                
          
 '  p       
 >  x       
 .  X  T   
         
   $(              
    X  \   
 U         
  __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses NumVideoCoreSymbols GetVideoCoreSymbol strncpy LookupVideoCoreSymbol strcmp vcos_log_impl LookupVideoCoreUInt32Symbol ReadVideoCoreMemory mmap64 memcpy munmap __errno_location strerror OpenVideoCoreMemoryFileWithOffset vcos_log_register calloc open64 lseek64 ioctl free close malloc __strdup OpenVideoCoreMemoryFile OpenVideoCoreMemory ReadVideoCoreMemoryBySymbol ReadVideoCoreStringBySymbol WriteVideoCoreMemory CloseVideoCoreMemory GetVideoCoreMemoryBase GetVideoCoreMemorySize GetVideoCoreMemoryPhysicalAddress libc.so.6 _edata __bss_start __bss_start__ __bss_end__ __end__ _end libdebug_sym.so GLIBC_2.4                                                              w         ii         &    &    (    '   '   '   '    (   '   '   '   '   '   ' 	  ' 
  '   '   '   '   '   '   ' !  ' /  '   '   '   '   '   ' (  ' ,  ' +  '   @-M  -x  x p h ` X P H @ 8 0 (               0 0   R/D t   H0H 0  00`8  S /,0M00  S  
//   p   L L  `@0A0/, M00  S  
//D @  |   L @- D0  0  R4 0  S  
(0 w0 0   P l     @-8 80    0  R  
$ 00  S   
3/  x     / A- \`P  $@  ps 0@ V0D0 0  U  
0   0  O- @ P  \M Pp@@`     0 S   @0  O   P@  Z0  0  Y0   0 0 S   \  Z 0 0  Y 0t  0   0 S  \ \0 p 0  \ 0 p , ,0 0 \    4       @-M0@  P  
  R   
H    0 S    00 , 0 @0       P  G-   M Pp@  !1   !0@ 40 > S8  
A0H 0 S!   ` 0^@c)P	P 0N^@P 0@` 0 p @*  
	        0 S  0  040 f      0 S0 0 @40 V  x@@ 0 Sw P  h    P0 L 0 40 ?  L          x  t     4      O- `P
SM  S (  @PU 
  V  
 p 3  P  r  )  0 S    W<  ` 0 `  !  P 0  p ppti` 0 S  0 00C0
+ 0  Pn  
  W 
(	   0 S ` 0bS  	   0 S  8 (0 `L0 Pa   00   P  
h` 0 S   P      8 (0 L0    d   P  
Th` 0 S   P     `S$xp 0 S P   `   7 '0 L0 7  '0 `L0   o70 0 SM  
+7  '0L0   sP   w S \  	T'L	0  ` 0 S]0,' 0 	0 U 0 SR0' 0 	0 J 0 SG    &	0 ?>   0 S    6  &0L0 0Pfp`vp 0 SvM P  >    X6 T&0 L0 h 044v4	p
 0L   \   0`  S  
  0"  Po  
  0 S      
 	0  P      5 %0 L0 /  
+,0  PU  H50 0 SO 05  ,%0L0     P  
 e` 0 S         4 $0 L0 00    P
d` 0 S P      x4 t$0 L0 X   0 SVH4H$0 `L0 P
(d8 `0 h0C0 Q 0s#pLp0  f 0 Sr0# 0 0 [ 0 Sl0# 0 0 P 0 S\0x# 0 0 E 0 SV    H#0 :H4   0 S$3$#0 L0 ,PL   0  Sk  a :  P$ b  
 0  ;  PK  
 0  Se  
 p2
0L L0`	0HP     <   P
 0 G1&H2  0   R   0` Sp=    $0 RP `0	 0000 0
0  `P   0!0 0 !   0 S 1  !0L0 PFPD`1`!0 L0  P @       H        v l  x  v |          T                D  t            (    
  8  4 
  l  v ,
     vl 	  d   	     $	             8                 p  T  D         A-M`P 0 pt @P      0 S'  0 0 p0 > 0  S0 PW @P@\    0 S   D0 @ 0p0 !  @     
     	  A-MP` 0 p2 @P      0 S.  0 0 0  0  S0 ` @P  |    0 S   d0 ` 00  @ 0  P0E @  x  	  
     G-   M P`@p  !1   !0p@ 40 > S8  
A0G 0 S!   0^@c)P	P 0N^@P 0@  0 p @*  
 	       0 S  0  0 40 z      0 S0 0 @40 j  x@@ 0 S P  |    P0 L 0 40 S 
 \  \  \  	 p     0  \      p  p@- `$   P  
 0  S	  
 @P A 0P S$ @:    P   o p@3 / / /@-LookupVideoCoreSymbol   LookupVideoCoreUInt32Symbol AccessVideoCoreMemory   OpenVideoCoreMemoryFileWithOffset   ReadVideoCoreMemoryBySymbol ReadVideoCoreStringBySymbol %s: %s found, addr = 0x%08x size = %zu  %s: %s not found    %s: Symbol: '%s' has a size of %zu, expecting %zu   %s: %s %zu bytes @ 0x%08x   Read    %s: Can't access peripheral address 0x%08x  %s: Memory address 0x%08x + numBytes 0x%08zx is > memory end 0x%08x %s: mmap failed: %s(%d) /dev/vc-mem debug_sym   %s: Unable to open '%s': %s(%d)
    %s: Opened %s memFd = %d    %s: Failed to get memory size via ioctl: %s(%d)
    %s: Failed to get memory base via ioctl: %s(%d)
    %s: Failed to get memory load via ioctl: %s(%d)
    %s: Failed to get memory physical address via ioctl: %s(%d)
    %s: Failed to seek to end of file: %s(%d)
  %s: vcMemSize = %08x    %s: vcMemBase = %08x    %s: vcMemLoad = %08x    %s: vcMemPhys = %08x    %s: ReadVideoCoreMemory @VC_SYMBOL_BASE_OFFSET (0x%08x) failed
 %s: Updated from debug header:  %s: vcSymbolTableOffset = 0x%08x    %s: newHandle->vcSymbolTableOffset (0x%x - 0x%x) > %dMB
    %s: ReadVideoCoreMemory @ symAddr(0x%08x) failed
   %s: Symbol %d: label: 0x%p addr: 0x%08x size: %zu   %s: numSymbols (%d) > 1024 - looks wrong
   %s: Detected %d symbols %s: ReadVideoCoreMemory @ newHandle->vcSymbolTableOffset(0x%08x) failed
    %s: ReadVideoCoreMemory @ sym->label(0x%08x) failed
    %s: Symbol %d (@0x%p): label: '%s' addr: 0x%08x size: %zu   %s: Symbol not found: '%s'  %s: Unable to read %zu bytes @ 0x%08x   Write                  w                     &          &       o             
              '                0          @         o  o   on  o                                           &                                                                             ( GCC: (crosstool-NG crosstool-ng-1.22.0-88-g8460611) 4.9.3 A;   aeabi 1   ARM1176JZF-S 	
"D .symtab .strtab .shstrtab .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .comment .ARM.attributes                                                          n                                    0                               	     0
       
                               &            &           &           &           &           '           (           (                                               m   0
        
 p   0
       
 }   L
        
 m            m                         m            m                            &       m   T
        
   T
       
 }   
        
 m   
        
   
       
 }           
 }   (        m           
 ,         
 }   l        
 B  (      }   &        Q  &       m           
 x         
 }           
 }   &          &       }   (                   m           
 }           
 m           
 }   0        
 m   <        
 }   $        
 m   X        
 }   t        
 m           
 }           
 m           
 }           
 m           
 }           
 m            
 }                                                "        !       	  !       }   8!         }   (          (                  }   &         2  &        }   &        @  &                    L  (       Y  &      b  (       n  '      m           	 }   	        	 m   	        	                                                  "                        
   (                    &             8  $(       C             U  (       \        
 p           v  $(                                                                                
                 <     
   X  \   
 +             G             Y             m  $(       r                     
   $(         x       
   (                            
   p       
                   $   
 8       
 M         
 o        
   X  T   
                    h    
                         /home/dc4/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin/../arm-linux-gnueabihf/sysroot/usr/lib/crti.o $a call_weak_fn $d /home/dc4/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin/../arm-linux-gnueabihf/sysroot/usr/lib/crtn.o crtstuff.c __JCR_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.8965 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry debug_sym.c __FUNCTION__.8761 __FUNCTION__.8771 __FUNCTION__.8779 __FUNCTION__.8720 __FUNCTION__.8799 __FUNCTION__.8808 debug_sym_log_category __FRAME_END__ __JCR_END__ __dso_handle _DYNAMIC __TMC_END__ _GLOBAL_OFFSET_TABLE_ calloc@@GLIBC_2.4 vcos_log_impl strcmp@@GLIBC_2.4 __cxa_finalize@@GLIBC_2.4 _ITM_deregisterTMCloneTable ReadVideoCoreMemoryBySymbol __bss_start__ free@@GLIBC_2.4 memcpy@@GLIBC_2.4 _bss_end__ mmap64@@GLIBC_2.4 _edata NumVideoCoreSymbols _fini __bss_end__ ioctl@@GLIBC_2.4 lseek64@@GLIBC_2.4 open64@@GLIBC_2.4 malloc@@GLIBC_2.4 strerror@@GLIBC_2.4 OpenVideoCoreMemory __gmon_start__ ReadVideoCoreMemory LookupVideoCoreSymbol __errno_location@@GLIBC_2.4 vcos_log_register __strdup@@GLIBC_2.4 _end strncpy@@GLIBC_2.4 LookupVideoCoreUInt32Symbol __end__ GetVideoCoreMemorySize __bss_start munmap@@GLIBC_2.4 GetVideoCoreSymbol GetVideoCoreMemoryBase _Jv_RegisterClasses ReadVideoCoreStringBySymbol WriteVideoCoreMemory GetVideoCoreMemoryPhysicalAddress OpenVideoCoreMemoryFile OpenVideoCoreMemoryFileWithOffset _ITM_registerTMCloneTable CloseVideoCoreMemory _init close@@GLIBC_2.4                                             o                         %                           -                              5   o   n  n  b                B   o                        Q   	          @                Z   	   B   0  0        	         c                               ^             4                i         0
  0
  X                 o                                 u                                }         &  &                             & &                             & &                             & &                             & &                           ' '                            ( (                             ( (                          0       (  :                      p        B(  <                                ~(                                  T)       \         	              1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               !<arch>
/               1463768126  0     0     0       430       `
                                 NumVideoCoreSymbols GetVideoCoreSymbol LookupVideoCoreSymbol LookupVideoCoreUInt32Symbol ReadVideoCoreMemory OpenVideoCoreMemoryFileWithOffset OpenVideoCoreMemoryFile OpenVideoCoreMemory ReadVideoCoreMemoryBySymbol ReadVideoCoreStringBySymbol WriteVideoCoreMemory CloseVideoCoreMemory GetVideoCoreMemoryBase GetVideoCoreMemorySize GetVideoCoreMemoryPhysicalAddress  debug_sym.c.o/  1463768126  1000  1000  100664  11868     `
ELF          (            T,     4     (  
   / A- \`P  $@  p 0@ V0D0 0  U  
0   0  O- @ P  \M Pp@@`     0 S   @0     P@  Z0  0  Y0   0 0 S   \  Z 0 0  Y 0t  0   0 S  \ \0 p 0  \ 0 p , ,0 0 \   l   L   L           @-M0@  P  
  R   
H    0 S    00 , 0 @0   D   $      G-   M Pp@  !1   !0@ 40 > S8  
A0H 0 S!   ` 0^@c)P	P 0N^@P 0@` 0 p @*  
	        0 S  0  040       0 S0 0 @40   x@@ 0 S P      P0 L 0 40                            t   D   8   O- `P
SM   ( @PU 
  V  
 p   P  r  )  0 S    W<  ` 0 `    P 0  p ppti` 0 S  0 00C0
+ 0  Pn  
  W 
(	   0 S ` 0bS  	   0 S  8 (0 `L0 Pa   00   P  
h` 0 S   P      8 (0 L0    d   P  
Th` 0 S   P     `S$xp 0 S P   `   7 '0 L0 7  '0 `L0   o70 0 SM  
+7  '0L0   P    S \  	T'L	0   0 S]0,' 0 	0  0 SR0' 0 	0  0 SG    &	0 >   0 S    6  &0L0 Pfp`vp 0 Sv P      X6 T&0 L0 h 044v4	p
 0L   \   0`  S  
  0  Po  
  0 S      
 	0  P      5 %0 L0 /  
+,0  PU  H50 0 SO 05  ,%0L0     P  
 e` 0 S         4 $0 L0 00    P
d` 0 S P      x4 t$0 L0 X   0 SVH4H$0 `L0 P
(d8 `0 h0C0 Q 0s#pLp0   0 Sr0# 0 0  0 Sl0# 0 0  0 S\0x# 0 0  0 SV    H#0 H4   0 S$3$#0 L0 PL   0  Sk  a   P$ b  
 0    PK  
 0  Se  
 p2
0L L0`	0HP     <  P
 0 G1H2  0   R   0` Sp=    $0 RP `0	 0000 0
0  `P   0!0 0 !   0 S 1  !0L0 PFPD`1`!0 L0  P @  	  	    	  p	  $	   	      v  |  p  vP                     T  @                 |  L  @  (  (  (  |  p  D  $    v       v  l  `  T  @  4             d  <  0                @      |  t  X  L       A-M`P 0 p @P      0 S'  0 0 p0  0  S0 P @P@\    0 S   D0 @ 0p0   @          X   8   0   A-MP` 0 p @P      0 S.  0 0 0  0  S0 ` @P  |    0 S   d0 ` 00  @ 0  P0E @          x   X   P   G-   M P`@p  !1   !0p@ 40 > S8  
A0G 0 S!   0^@c)P	P 0N^@P 0@  0 p @*  
 	       0 S  0  0 40       0 S0 0 @40   x@@ 0 S P      P0 L 0 40                            t   D   8   p@- `$   P  
 0  S	  
 @P  0P S$ @    P    p@ / / /LookupVideoCoreSymbol   LookupVideoCoreUInt32Symbol AccessVideoCoreMemory   OpenVideoCoreMemoryFileWithOffset   ReadVideoCoreMemoryBySymbol ReadVideoCoreStringBySymbol %s: %s found, addr = 0x%08x size = %zu  %s: %s not found    %s: Symbol: '%s' has a size of %zu, expecting %zu   %s: %s %zu bytes @ 0x%08x   Read    %s: Can't access peripheral address 0x%08x  %s: Memory address 0x%08x + numBytes 0x%08zx is > memory end 0x%08x %s: mmap failed: %s(%d) /dev/vc-mem debug_sym   %s: Unable to open '%s': %s(%d)
    %s: Opened %s memFd = %d    %s: Failed to get memory size via ioctl: %s(%d)
    %s: Failed to get memory base via ioctl: %s(%d)
    %s: Failed to get memory load via ioctl: %s(%d)
    %s: Failed to get memory physical address via ioctl: %s(%d)
    %s: Failed to seek to end of file: %s(%d)
  %s: vcMemSize = %08x    %s: vcMemBase = %08x    %s: vcMemLoad = %08x    %s: vcMemPhys = %08x    %s: ReadVideoCoreMemory @VC_SYMBOL_BASE_OFFSET (0x%08x) failed
 %s: Updated from debug header:  %s: vcSymbolTableOffset = 0x%08x    %s: newHandle->vcSymbolTableOffset (0x%x - 0x%x) > %dMB
    %s: ReadVideoCoreMemory @ symAddr(0x%08x) failed
   %s: Symbol %d: label: 0x%p addr: 0x%08x size: %zu   %s: numSymbols (%d) > 1024 - looks wrong
   %s: Detected %d symbols %s: ReadVideoCoreMemory @ newHandle->vcSymbolTableOffset(0x%08x) failed
    %s: ReadVideoCoreMemory @ sym->label(0x%08x) failed
    %s: Symbol %d (@0x%p): label: '%s' addr: 0x%08x size: %zu   %s: Symbol not found: '%s'  %s: Unable to read %zu bytes @ 0x%08x   Write    GCC: (crosstool-NG crosstool-ng-1.22.0-88-g8460611) 4.9.3 A=   aeabi 3   ARM1176JZF-S 	
"D .symtab .strtab .shstrtab .rel.text .data .bss .rodata .rodata.str1.4 .comment .note.GNU-stack .ARM.attributes                                                                                                       (                                       `            <             l            T         "             '   p          ,             1             6                                    ;   (         @   `         F   t         L   4         R   X         X            ^   |         d            j            p            v            |               P                                    <                                                                                    H            0                                                $                                                            L            8                                                               4          L   "     #  p        5                                                    G                                                    	 ^           r                            \                                         l                                                                           T    9             K             R             Y             a             g             l             r             y                                           $              8  h              '         >          debug_sym.c $a $d .LC1 .LC0 .LC2 .LC4 .LC3 .LC6 .LC5 .LC7 .LC9 .LC24 .LC12 .LC10 .LC11 .LC21 .LC17 .LC18 .LC19 .LC20 .LC30 .LC8 .LC16 .LC26 .LC13 .LC23 .LC14 .LC15 .LC25 .LC22 .LC27 .LC31 .LC29 .LC28 .LC32 .LC33 .LC34 __FUNCTION__.8761 __FUNCTION__.8771 __FUNCTION__.8779 __FUNCTION__.8720 __FUNCTION__.8799 __FUNCTION__.8808 debug_sym_log_category NumVideoCoreSymbols GetVideoCoreSymbol strncpy LookupVideoCoreSymbol strcmp vcos_log_impl LookupVideoCoreUInt32Symbol ReadVideoCoreMemory mmap64 memcpy munmap __errno_location strerror OpenVideoCoreMemoryFileWithOffset vcos_log_register calloc open64 lseek64 ioctl free close malloc __strdup OpenVideoCoreMemoryFile OpenVideoCoreMemory ReadVideoCoreMemoryBySymbol ReadVideoCoreStringBySymbol WriteVideoCoreMemory CloseVideoCoreMemory GetVideoCoreMemoryBase GetVideoCoreMemorySize GetVideoCoreMemoryPhysicalAddress D   H     G     J    K    K                7        7    I  P  K  `    d  7  h      K  @  N  \  O  h  P    K    K    Q    R  H  K  T    X    \  7  `    d    h  7  l    p    t  7  x    |      7        T    U    V    W  t  M    K    X  (  Q  4  R  `  K  t  X    Q    Y    Q    R    K  0  K  x  K    Z    Y    K    K    K  H  K    K    Q    R    K  L	  M  	  K  	  Q  	  R  	  K  	  M  4
  K  H
  X  h
  Q  t
  R  
  K  
  X  
  Q  
  R    K  H  K    K    K    K  0  K  \  K    K    [    M  T  M  l  \    K    K  X  K    K                            7            7                7        7            7             7                        7       $     ,    0  7  4  !  8  7  <    @  "  D  7  H  #  L    P  7  T  $  \    `  7  d  %  l    p  7  t  &  x    |  7    '        7    (                        7    )        7    7        "        *        7    +    7    ,    S    ]    I  L  K  x  M    K        7    /        7    0    I  T  K    M    K        7    /        7    0  x  K    N    O    P  \  K    K    Q    R    K        5    7            7           $  7  (    ,    0  7  4    d  Y    Y    Z    Y                                                       4                       	   @       %                %                                  +                                 0                                 8      2         T                G      0         ;                 P              #                     `     p        #  >                                a  p                                  `     F         	              4"  `                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       