, // and r0, r0, r2
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0f0f0f0f, 0xe00208a7, // mov r2, mask
0x149e7080, 0x10020867, // and r1, r0, r2
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x149e7080, 0x10020827, // and r0, r0, r2
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x00ff00ff, 0xe00208a7, // mov r2, mask
0x149e7080, 0x10020867, // and r1, r0, r2
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149e7080, 0x10020827, // and r0, r0, r2
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0000ffff, 0xe00208a7, // mov r2, mask
0x149e7080, 0x10020867, // and r1, r0, r2
0x0e9c81c0, 0x10020827, // shr r0, r0, shift
0x149e7080, 0x10020827, // and r0, r0, r2
0x119c83c0, 0x10020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffff8c0, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
0x2225b19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
0x206e701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
0x00000000, 0xf0f549e7, // bra -, ra_save_64
0x209db017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
0x216c97d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff7e0, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff790, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
0x8c167d76, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff700, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff6b0, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
0x2225b19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
0x206e701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
0x00000000, 0xf0f549e7, // bra -, ra_save_64
0x209db017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
0x216c97d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
0x8c14cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff5d0, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff580, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x00000000, 0xf0f489e7, // bra -, ra_save_32
0x952c2ff6, 0x100242c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
0x95307ff6, 0x10024307, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
0x9538eff6, 0x1002438e, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
0x119c51c0, 0xd0020827, // shl r0, r0, 5
0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
0x159cafc0, 0x100602a7, // mov.ifnz ra_save_64, rx_save_slave_64
0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
0x000016b8, 0xf00809e7, // brr.allz -, r:end
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000003, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000002, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100206e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100216e7, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c61c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x55555555, 0xe00208a7, // mov r2, mask
0x149e7080, 0x10020867, // and r1, r0, r2
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x149e7080, 0x10020827, // and r0, r0, r2
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x33333333, 0xe00208a7, // mov r2, mask
0x149e7080, 0x10020867, // and r1, r0, r2
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x149e7080, 0x10020827, // and r0, r0, r2
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0f0f0f0f, 0xe00208a7, // mov r2, mask
0x149e7080, 0x10020867, // and r1, r0, r2
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x149e7080, 0x10020827, // and r0, r0, r2
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x00ff00ff, 0xe00208a7, // mov r2, mask
0x149e7080, 0x10020867, // and r1, r0, r2
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149e7080, 0x10020827, // and r0, r0, r2
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0000ffff, 0xe00208a7, // mov r2, mask
0x149e7080, 0x10020867, // and r1, r0, r2
0x0e9c81c0, 0x10020827, // shr r0, r0, shift
0x149e7080, 0x10020827, // and r0, r0, r2
0x119c83c0, 0x10020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff2e8, 0xf0f80227, // brr ra_link_1, r:pass_1
0x009e7000, 0x100009e7, // nop
0x00000200, 0xe0020827, // mov r0, 0x200
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x00000016, 0xe0020867, // mov r1, STAGES
0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
0xfffff2b8, 0xf00809e7, // brr.allz -, r:pass_1
0x009e7000, 0x100009e7, // nop
0x00000200, 0xe0020827, // mov r0, 0x200
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000003, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000002, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100206e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100216e7, // mov rb_tw_im+dst, r4
0x00000000, 0xe002469a, // mov ra_tw_re+TW48+1, 0; mov rb_tw_im+TW48+1, 0
0x00000000, 0xe002471c, // mov ra_tw_re+TW64+1, 0; mov rb_tw_im+TW64+1, 0
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000007, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000006, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000004, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020767, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021767, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000005, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100207a7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100217a7, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c61c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff568, 0xf0f80227, // brr ra_link_1, r:pass_2
0x009e7000, 0x100009e7, // nop
0x00000200, 0xe0020827, // mov r0, 0x200
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x0000ffff, 0xe0020827, // mov r0, 0xFFFF
0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
0xfffff538, 0xf01809e7, // brr.allnz -, r:pass_2
0x009e7000, 0x100009e7, // nop
0x00000200, 0xe0020827, // mov r0, 0x200
0x0c1e7c00, 0x100601e7, // add.ifnz ra_points, ra_points, r0
0x956dbdbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x207a7016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209de017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209de01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x217a709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x026e7c80, 0x10020827, // fsub r0,  a, b
0x026e7180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x026e7c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x01727380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x1002589b, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x026e7c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10020727, // fadd a+1, r0, r1
0x029dbec0, 0x10020827, // fsub r0,  a, b
0x029db1c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029dbe40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019dc3c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x1002489b, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029dbe80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10021727, // fadd a+1, r0, r1
0x95659dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20767016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209dd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209dd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2176709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02667c80, 0x10020827, // fsub r0,  a, b
0x02667180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02667c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x016a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025899, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02667c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100206a7, // fadd a+1, r0, r1
0x029d9ec0, 0x10020827, // fsub r0,  a, b
0x029d91c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d9e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019da3c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024899, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d9e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100216a7, // fadd a+1, r0, r1
0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x025e7c80, 0x10020827, // fsub r0,  a, b
0x025e7180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x025e7c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x01627380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x025e7c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10020627, // fadd a+1, r0, r1
0x029d7ec0, 0x10020827, // fsub r0,  a, b
0x029d71c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d7e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d83c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d7e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10021627, // fadd a+1, r0, r1
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02567c80, 0x10020827, // fsub r0,  a, b
0x02567180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02567c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x015a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02567c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100205a7, // fadd a+1, r0, r1
0x029d5ec0, 0x10020827, // fsub r0,  a, b
0x029d51c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d5e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d63c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d5e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100215a7, // fadd a+1, r0, r1
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x00000016, 0xe0020867, // mov r1, STAGES
0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
0xfffff0a0, 0xf00809e7, // brr.allz -, r:pass_2
0x009e7000, 0x100009e7, // nop
0x00000200, 0xe0020827, // mov r0, 0x200
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x159c0fc0, 0x100202e7, // mov ra_vpm_lo, rb_vpm
0x159c1fc0, 0x10020327, // mov ra_vpm_hi, rb_vpm_16
0x80904000, 0xe00203a7, // mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
0x80905000, 0xe00213a7, // mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))
0x00000016, 0xe00212e7, // mov rb_STAGES, STAGES
0x000000f0, 0xe0021327, // mov rb_0xF0, 0xF0
0x00000040, 0xe0021367, // mov rb_0x40, 0x40
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000003, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000002, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000009, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000008, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c51c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff008, 0xf0f80227, // brr ra_link_1, r:pass_3
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x000003ff, 0xe0020827, // mov r0, 0x3FF
0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
0xffffefd8, 0xf01809e7, // brr.allnz -, r:pass_3
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100601e7, // add.ifnz ra_points, ra_points, r0
0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x025e7c80, 0x10020827, // fsub r0,  a, b
0x025e7180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x025e7c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x01627380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x025e7c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10020627, // fadd a+1, r0, r1
0x029d7ec0, 0x10020827, // fsub r0,  a, b
0x029d71c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d7e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d83c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d7e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10021627, // fadd a+1, r0, r1
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02567c80, 0x10020827, // fsub r0,  a, b
0x02567180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02567c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x015a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02567c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100205a7, // fadd a+1, r0, r1
0x029d5ec0, 0x10020827, // fsub r0,  a, b
0x029d51c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d5e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d63c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d5e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100215a7, // fadd a+1, r0, r1
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
0xffffed48, 0xf00809e7, // brr.allz -, r:pass_3
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x0000000b, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x0000000a, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c51c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xffffead8, 0xf0f80227, // brr ra_link_1, r:pass_4
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x025e7c80, 0x10020827, // fsub r0,  a, b
0x025e7180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x025e7c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x01627380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x025e7c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10020627, // fadd a+1, r0, r1
0x029d7ec0, 0x10020827, // fsub r0,  a, b
0x029d71c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d7e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d83c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d7e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10021627, // fadd a+1, r0, r1
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02567c80, 0x10020827, // fsub r0,  a, b
0x02567180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02567c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x015a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02567c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100205a7, // fadd a+1, r0, r1
0x029d5ec0, 0x10020827, // fsub r0,  a, b
0x029d51c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d5e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d63c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d5e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100215a7, // fadd a+1, r0, r1
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
0xffffe848, 0xf00809e7, // brr.allz -, r:pass_4
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0xffffe918, 0xf0f809e7, // brr -, r:loop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159c3fc0, 0x100209a7, // mov interrupt, flag
0x009e7000, 0x300009e7, // nop; nop; thrend
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                0x00000020, 0xe0021767, // mov rb_0x20,    0x20
0x00000040, 0xe00217a7, // mov rb_0x40,    0x40
0x00000080, 0xe00217e7, // mov rb_0x80,    0x80
0x00005555, 0xe0020727, // mov rx_0x5555,  0x5555
0x00003333, 0xe0020767, // mov rx_0x3333,  0x3333
0x00000f0f, 0xe00207a7, // mov rx_0x0F0F,  0x0F0F
0x000000ff, 0xe00207e7, // mov rx_0x00FF,  0x00FF
0x88104000, 0xe00206e7, // mov ra_vdw, vdw_setup_0(16, 16, dma_h32( 0,0))
0x88104800, 0xe00216e7, // mov rb_vdw, vdw_setup_0(16, 16, dma_h32(16,0))
0x15827d80, 0x10020227, // mov rx_tw_shared, unif
0x15827d80, 0x10021227, // mov rx_tw_unique, unif
0x15827d80, 0x10021167, // mov rb_inst, unif
0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
0xcc9e7081, 0x100246a0, // add out_0, r0, r2; v8adds r0, r0, r1
0xcc9e7081, 0x100256a0, // add out_1, r0, r2; v8adds r0, r0, r1
0xcc9e7081, 0x100049e0, // add out_2, r0, r2; v8adds r0, r0, r1
0x0c9e7080, 0x100009e7, // add out_3, r0, r2
0x000000b0, 0xf0f80127, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x156a7d80, 0x10021c67, // mov vw_setup, arg
0x159e7000, 0x10020c27, // mov vpm, r0
0x159e7240, 0x10020c27, // mov vpm, r1
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x00000000, 0xf0f409e7, // bra -, ra_link_1
0x156e7d80, 0x10021c67, // mov vw_setup, arg_vdw
0xc00007c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
0x8c05edf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
0x00000038, 0xf0f81127, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x156a7d80, 0x10021c67, // mov vw_setup, arg
0x159e7000, 0x10020c27, // mov vpm, r0
0x159e7240, 0x10020c27, // mov vpm, r1
0x00000000, 0xf0f4c9e7, // bra -, ra_sync
0x009e7000, 0x100009e7, // nop
0x156a7d80, 0x10020c67, // mov vr_setup, arg_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x00000080, 0xf0f801a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000000, 0xf0f409e7, // bra -, ra_link_1
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x000003e8, 0xf0f811a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f409e7, // bra -, ra_link_1
0x00000009, 0xe80009e7, // mov -, srel(i+9)
0x00000011, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f409e7, // bra -, ra_link_1
0x0000000a, 0xe80009e7, // mov -, srel(i+9)
0x00000012, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f409e7, // bra -, ra_link_1
0x0000000b, 0xe80009e7, // mov -, srel(i+9)
0x00000013, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f409e7, // bra -, ra_link_1
0x0000000c, 0xe80009e7, // mov -, srel(i+9)
0x00000014, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f409e7, // bra -, ra_link_1
0x0000000d, 0xe80009e7, // mov -, srel(i+9)
0x00000015, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f409e7, // bra -, ra_link_1
0x0000000e, 0xe80009e7, // mov -, srel(i+9)
0x00000016, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f409e7, // bra -, ra_link_1
0x0000000f, 0xe80009e7, // mov -, srel(i+9)
0x00000017, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x202a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209ca039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x2208acb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x202a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x202e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209cb039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x2208bcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x202e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x20327030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209cc039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x2208ccb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x20327031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x20367030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209cd039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x2208dcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x20367031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x00000000, 0xf0f489e7, // bra -, ra_link_0
0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14727180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14727180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0e9c11c0, 0xd0020827, // shr r0, r0, 13-STAGES
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x000000cc, 0xe20229e7, // mov.setf  -, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
0x959fa000, 0xd002c8a0, // mov r2, r0; mov.ifnz r0, r0 << 6
0x959fa249, 0xd002c8e1, // mov r3, r1; mov.ifnz r1, r1 << 6
0x00003300, 0xe20229e7, // mov.setf  -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
0x809f6012, 0xd000c9e0, // nop; mov.ifnz r0, r2 >> 6
0x809f601b, 0xd000c9e1, // nop; mov.ifnz r1, r3 >> 6
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x000000cc, 0xe20229e7, // mov.setf  -, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
0x959fa000, 0xd002c8a0, // mov r2, r0; mov.ifnz r0, r0 << 6
0x959fa249, 0xd002c8e1, // mov r3, r1; mov.ifnz r1, r1 << 6
0x00003300, 0xe20229e7, // mov.setf  -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
0x809f6012, 0xd000c9e0, // nop; mov.ifnz r0, r2 >> 6
0x809f601b, 0xd000c9e1, // nop; mov.ifnz r1, r3 >> 6
0xfffffd40, 0xf0f809e7, // brr -, r:fft_16
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffcf8, 0xf0f809e7, // brr -, r:fft_16
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
0x119c51c0, 0xd0020827, // shl r0, r0, 5
0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
0x00000928, 0xf00809e7, // brr.allz -, r:end
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c227c00, 0x10020e27, // add t0s, ptr, r0
0x0c227c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c41c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14727180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14727180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0e9c11c0, 0xd0020827, // shr r0, r0, 13-STAGES
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x000000cc, 0xe20229e7, // mov.setf  -, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
0x959fa000, 0xd002c8a0, // mov r2, r0; mov.ifnz r0, r0 << 6
0x959fa249, 0xd002c8e1, // mov r3, r1; mov.ifnz r1, r1 << 6
0x00003300, 0xe20229e7, // mov.setf  -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
0x809f6012, 0xd000c9e0, // nop; mov.ifnz r0, r2 >> 6
0x809f601b, 0xd000c9e1, // nop; mov.ifnz r1, r3 >> 6
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffbe0, 0xf0f80027, // brr ra_link_1, r:pass_1
0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x0e1ccdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
0xfffffbb8, 0xf00809e7, // brr.allz -, r:pass_1
0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c227c00, 0x10020e27, // add t0s, ptr, r0
0x0c227c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c227c00, 0x10020e27, // add t0s, ptr, r0
0x0c227c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020267, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021267, // mov rb_tw_im+dst, r4
0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c41c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffb78, 0xf0f80027, // brr ra_link_1, r:pass_2
0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0xfffffb58, 0xf0f80027, // brr ra_link_1, r:pass_2
0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x0d01ddc0, 0x10020027, // sub ra_link_1, ra_link_1, rb_0x20
0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20267016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209c9017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209c901f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2126709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02367c80, 0x10020827, // fsub r0,  a, b
0x02367180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02367c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x013a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x1002588d, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02367c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100203a7, // fadd a+1, r0, r1
0x029cdec0, 0x10020827, // fsub r0,  a, b
0x029cd1c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029cde40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019ce3c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x1002488d, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029cde80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100213a7, // fadd a+1, r0, r1
0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1ccdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
0xfffff9c0, 0xf00809e7, // brr.allz -, r:pass_2
0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c9c8e00, 0x10020e27, // add t0s, ptr, r0
0x0c9c8e40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000002, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c227c00, 0x10020e27, // add t0s, ptr, r0
0x0c227c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020267, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021267, // mov rb_tw_im+dst, r4
0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c41c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff808, 0xf0f80027, // brr ra_link_1, r:pass_3
0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20267016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209c9017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209c901f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2126709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02367c80, 0x10020827, // fsub r0,  a, b
0x02367180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02367c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x013a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x1002588d, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02367c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100203a7, // fadd a+1, r0, r1
0x029cdec0, 0x10020827, // fsub r0,  a, b
0x029cd1c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029cde40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019ce3c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x1002488d, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029cde80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100213a7, // fadd a+1, r0, r1
0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1ccdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
0xfffff678, 0xf00809e7, // brr.allz -, r:pass_3
0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0xfffff6a8, 0xf0f809e7, // brr -, r:loop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159c3fc0, 0x100209a7, // mov interrupt, flag
0x009e7000, 0x300009e7, // nop; nop; thrend
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               0x00000010, 0xe0021727, // mov rb_0x10,    0x10
0x00000040, 0xe0021767, // mov rb_0x40,    0x40
0x00000080, 0xe00217a7, // mov rb_0x80,    0x80
0x000000f0, 0xe00217e7, // mov rb_0xF0,    0xF0
0x00005555, 0xe0020727, // mov rx_0x5555,  0x5555
0x00003333, 0xe0020767, // mov rx_0x3333,  0x3333
0x00000f0f, 0xe00207a7, // mov rx_0x0F0F,  0x0F0F
0x000000ff, 0xe00207e7, // mov rx_0x00FF,  0x00FF
0x88104000, 0xe00206a7, // mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
0x88105000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
0x90104000, 0xe00206e7, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
0x15827d80, 0x10021167, // mov rb_inst, unif
0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
0xcc9e7081, 0x10024620, // add out_0, r0, r2; v8adds r0, r0, r1
0xcc9e7081, 0x10024660, // add out_1, r0, r2; v8adds r0, r0, r1
0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
0x0c9e7080, 0x100211e7, // add out_3, r0, r2
0x000000b0, 0xf0f80127, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15627d80, 0x10021c67, // mov vw_setup, arg
0x159e7000, 0x10020c27, // mov vpm, r0
0x159e7240, 0x10020c27, // mov vpm, r1
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x156a7d80, 0x10021c67, // mov vw_setup, arg_vdw
0xc00000c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
0x8c05ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
0x00000038, 0xf0f81127, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15627d80, 0x10021c67, // mov vw_setup, arg
0x159e7000, 0x10020c27, // mov vpm, r0
0x159e7240, 0x10020c27, // mov vpm, r1
0x00000000, 0xf0f4c9e7, // bra -, ra_sync
0x009e7000, 0x100009e7, // nop
0x15627d80, 0x10020c67, // mov vr_setup, arg_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x000000c8, 0xf0f802a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15627d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x156e7d80, 0x10021c67, // mov vw_setup, ra_vdw_32
0xc0000040, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
0x8c05ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
0x00000050, 0xf0f812a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15627d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
0x00000000, 0xf0f4c9e7, // bra -, ra_sync
0x009e7000, 0x100009e7, // nop
0x15627d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
0x15c27d80, 0x100009e7, // mov -, vpm
0x00000080, 0xf0f801a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x00000510, 0xf0f811a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x00000009, 0xe80009e7, // mov -, srel(i+9)
0x00000011, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000a, 0xe80009e7, // mov -, srel(i+9)
0x00000012, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000b, 0xe80009e7, // mov -, srel(i+9)
0x00000013, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000c, 0xe80009e7, // mov -, srel(i+9)
0x00000014, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000d, 0xe80009e7, // mov -, srel(i+9)
0x00000015, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000e, 0xe80009e7, // mov -, srel(i+9)
0x00000016, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000f, 0xe80009e7, // mov -, srel(i+9)
0x00000017, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x00000000, 0xf0f409e7, // bra -, ra_link_0
0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14727180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14727180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0e9c41c0, 0xd0020827, // shr r0, r0, 13-STAGES
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffffda0, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14727180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14727180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0e9c41c0, 0xd0020827, // shr r0, r0, 13-STAGES
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffffc80, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x00000000, 0xf0f549e7, // bra -, ra_save_32
0x95602ff6, 0x10024602, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
0x95647ff6, 0x10024647, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
0x956c1ff6, 0x100246c1, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffbf0, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x00000000, 0xf0f489e7, // bra -, ra_save_16
0x009e7000, 0x100009e7, // nop
0x95602ff6, 0x10024602, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
0x95680ff6, 0x10024680, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
0x119c51c0, 0xd0020827, // shl r0, r0, 5
0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
0x000005e8, 0xf00809e7, // brr.allz -, r:end
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c51c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14727180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14727180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0e9c41c0, 0xd0020827, // shr r0, r0, 13-STAGES
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffa80, 0xf0f80227, // brr ra_link_1, r:pass_1
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0xfffffa60, 0xf0f80227, // brr ra_link_1, r:pass_1
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000002, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c41c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffb20, 0xf0f80227, // brr ra_link_1, r:pass_2
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02467c80, 0x10020827, // fsub r0,  a, b
0x02467180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02467c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x014a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02467c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100204a7, // fadd a+1, r0, r1
0x029d1ec0, 0x10020827, // fsub r0,  a, b
0x029d11c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d1e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d23c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d1e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100214a7, // fadd a+1, r0, r1
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1c9dc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
0xfffff990, 0xf00809e7, // brr.allz -, r:pass_2
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0xfffff9e8, 0xf0f809e7, // brr -, r:loop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159c3fc0, 0x100209a7, // mov interrupt, flag
0x009e7000, 0x300009e7, // nop; nop; thrend
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   0x00000013, 0xe0021227, // mov rb_STAGES,  STAGES
0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
0x00000040, 0xe0021727, // mov rb_0x40,    0x40
0x00000080, 0xe0021767, // mov rb_0x80,    0x80
0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
0x55555555, 0xe0020767, // mov rx_0x55555555, 0x55555555
0x33333333, 0xe00207a7, // mov rx_0x33333333, 0x33333333
0x0f0f0f0f, 0xe00207e7, // mov rx_0x0F0F0F0F, 0x0F0F0F0F
0x00ff00ff, 0xe0021667, // mov rx_0x00FF00FF, 0x00FF00FF
0x0000ffff, 0xe00216a7, // mov rx_0x0000FFFF, 0x0000FFFF
0x80904000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0(1, 16, dma_h32( 0,0))
0x80905000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(1, 16, dma_h32(32,0))
0x80904000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
0x80905000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))
0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
0x15827d80, 0x10021167, // mov rb_inst, unif
0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
0x0c9e7080, 0x100211e7, // add out_3, r0, r2
0x000001d0, 0xf0f80127, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10021c67, // mov vw_setup, arg
0x159e7000, 0x10020c27, // mov vpm, r0
0x159e7240, 0x10020c27, // mov vpm, r1
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x156e7d80, 0x10020827, // mov r0, arg_vdw
0x8c05cdf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
0x00040000, 0xe00208e7, // mov r3, PASS16_STRIDE
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000038, 0xf0f81127, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10021c67, // mov vw_setup, arg
0x159e7000, 0x10020c27, // mov vpm, r0
0x159e7240, 0x10020c27, // mov vpm, r1
0x00000000, 0xf0f4c9e7, // bra -, ra_sync
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x000002e8, 0xf0f802a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x15727d80, 0x10020827, // mov r0, ra_vdw_32
0x8c05cdf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
0x00020000, 0xe00208e7, // mov r3, PASS32_STRIDE
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000050, 0xf0f812a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
0x00000000, 0xf0f4c9e7, // bra -, ra_sync
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
0x15c27d80, 0x100009e7, // mov -, vpm
0x00000080, 0xf0f801a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x00000640, 0xf0f811a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x00000009, 0xe80009e7, // mov -, srel(i+9)
0x00000011, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000a, 0xe80009e7, // mov -, srel(i+9)
0x00000012, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000b, 0xe80009e7, // mov -, srel(i+9)
0x00000013, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000c, 0xe80009e7, // mov -, srel(i+9)
0x00000014, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000d, 0xe80009e7, // mov -, srel(i+9)
0x00000015, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000e, 0xe80009e7, // mov -, srel(i+9)
0x00000016, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000f, 0xe80009e7, // mov -, srel(i+9)
0x00000017, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x00000000, 0xf0f409e7, // bra -, ra_link_0
0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149d91c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149d91c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149da1c0, 0x10020867, // and r1, r0, mask
0x0e9db1c0, 0x10020827, // shr r0, r0, shift
0x149da1c0, 0x10020827, // and r0, r0, mask
0x119db3c0, 0x10020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0e9ca1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffffd78, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149d91c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149d91c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149da1c0, 0x10020867, // and r1, r0, mask
0x0e9db1c0, 0x10020827, // shr r0, r0, shift
0x149da1c0, 0x10020827, // and r0, r0, mask
0x119db3c0, 0x10020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0e9ca1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffffc30, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x00000000, 0xf0f549e7, // bra -, ra_save_32
0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffba0, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x00000000, 0xf0f489e7, // bra -, ra_save_16
0x009e7000, 0x100009e7, // nop
0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffb38, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffae8, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x00000000, 0xf0f549e7, // bra -, ra_save_32
0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
0x119c51c0, 0xd0020827, // shl r0, r0, 5
0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
0x000010a8, 0xf00809e7, // brr.allz -, r:end
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c51c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149d91c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149d91c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149da1c0, 0x10020867, // and r1, r0, mask
0x0e9db1c0, 0x10020827, // shr r0, r0, shift
0x149da1c0, 0x10020827, // and r0, r0, mask
0x119db3c0, 0x10020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0e9ca1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff928, 0xf0f80227, // brr ra_link_1, r:pass_1
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
0xfffff900, 0xf00809e7, // brr.allz -, r:pass_1
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000002, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c41c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffa10, 0xf0f80227, // brr ra_link_1, r:pass_2
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x00003fff, 0xe0020827, // mov r0, 0x3FFF
0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
0xfffff9e0, 0xf01809e7, // brr.allnz -, r:pass_2
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dddc0, 0x100601e7, // add.ifnz ra_points, ra_points, rb_0x80
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02467c80, 0x10020827, // fsub r0,  a, b
0x02467180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02467c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x014a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02467c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100204a7, // fadd a+1, r0, r1
0x029d1ec0, 0x10020827, // fsub r0,  a, b
0x029d11c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d1e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d23c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d1e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100214a7, // fadd a+1, r0, r1
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
0xfffff850, 0xf00809e7, // brr.allz -, r:pass_2
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000004, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000003, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c51c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff648, 0xf0f80227, // brr ra_link_1, r:pass_3
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0xfffff628, 0xf0f80227, // brr ra_link_1, r:pass_3
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0xfffff608, 0xf0f80227, // brr ra_link_1, r:pass_3
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0xfffff5e8, 0xf0f80227, // brr ra_link_1, r:pass_3
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x024e7c80, 0x10020827, // fsub r0,  a, b
0x024e7180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x024e7c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x01527380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x024e7c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10020527, // fadd a+1, r0, r1
0x029d3ec0, 0x10020827, // fsub r0,  a, b
0x029d31c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d3e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d43c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d3e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10021527, // fadd a+1, r0, r1
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02467c80, 0x10020827, // fsub r0,  a, b
0x02467180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02467c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x014a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02467c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100204a7, // fadd a+1, r0, r1
0x029d1ec0, 0x10020827, // fsub r0,  a, b
0x029d11c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d1e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d23c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d1e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100214a7, // fadd a+1, r0, r1
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
0xfffff358, 0xf00809e7, // brr.allz -, r:pass_3
0x00000060, 0xe0020827, // mov r0, 3*4*8
0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000006, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000005, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c51c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff0e8, 0xf0f80227, // brr ra_link_1, r:pass_4
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x024e7c80, 0x10020827, // fsub r0,  a, b
0x024e7180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x024e7c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x01527380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x024e7c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10020527, // fadd a+1, r0, r1
0x029d3ec0, 0x10020827, // fsub r0,  a, b
0x029d31c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d3e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d43c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d3e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10021527, // fadd a+1, r0, r1
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02467c80, 0x10020827, // fsub r0,  a, b
0x02467180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02467c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x014a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02467c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100204a7, // fadd a+1, r0, r1
0x029d1ec0, 0x10020827, // fsub r0,  a, b
0x029d11c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d1e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d23c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d1e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100214a7, // fadd a+1, r0, r1
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
0xffffee58, 0xf00809e7, // brr.allz -, r:pass_4
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0xffffef28, 0xf0f809e7, // brr -, r:loop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159c3fc0, 0x100209a7, // mov interrupt, flag
0x009e7000, 0x300009e7, // nop; nop; thrend
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            0x00000010, 0xe0021227, // mov rb_0x10,    0x10
0x000001d0, 0xe0021967, // mov r5rep,      0x1D0
0x00005555, 0xe00207a7, // mov rx_0x5555,  0x5555
0x00003333, 0xe00217a7, // mov rx_0x3333,  0x3333
0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
0x000000ff, 0xe00217e7, // mov rx_0x00FF,  0x00FF
0x15827d80, 0x100203e7, // mov rx_tw_shared, unif
0x15827d80, 0x100213e7, // mov rx_tw_unique, unif
0x15827d80, 0x10021167, // mov rb_inst, unif
0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
0xcc9e7081, 0x10025020, // add out_0, r0, r2; v8adds r0, r0, r1
0xcc9e7081, 0x10025060, // add out_1, r0, r2; v8adds r0, r0, r1
0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
0x0c9e7080, 0x100211e7, // add out_3, r0, r2
0x000000c8, 0xf0f80127, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x153a7d80, 0x10021c67, // mov vw_setup, ra_vdw_32
0xc0003fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
0x8c04ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
0x00000050, 0xf0f81127, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
0x00000000, 0xf0f4c9e7, // bra -, ra_sync
0x009e7000, 0x100009e7, // nop
0x152e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
0x15c27d80, 0x100009e7, // mov -, vpm
0x00000100, 0xf0f802a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000040, 0xe0020827, // mov r0, 0x40
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0xa0104000, 0xe0021c67, // mov vw_setup, vdw_setup_0(64, 16, dma_h32(0,0))
0xc0001fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(PASS64_STRIDE-16*4)
0x8c067c36, 0x10024072, // add ra_save_ptr, ra_save_ptr, step; mov vw_addr, ra_save_ptr
0x000002b8, 0xf0f812a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c51c0, 0xd00200a7, // shl ra_temp, r0, 5
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0fc49e7, // brr -, ra_temp
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x000000e0, 0xf0f809e7, // brr -, r:2f
0x00000010, 0xe80009e7, // mov -, sacq(i)
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x000000c0, 0xf0f809e7, // brr -, r:2f
0x00000011, 0xe80009e7, // mov -, sacq(i)
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x000000a0, 0xf0f809e7, // brr -, r:2f
0x00000012, 0xe80009e7, // mov -, sacq(i)
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000080, 0xf0f809e7, // brr -, r:2f
0x00000013, 0xe80009e7, // mov -, sacq(i)
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000060, 0xf0f809e7, // brr -, r:2f
0x00000014, 0xe80009e7, // mov -, sacq(i)
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000040, 0xf0f809e7, // brr -, r:2f
0x00000015, 0xe80009e7, // mov -, sacq(i)
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000020, 0xf0f809e7, // brr -, r:2f
0x00000016, 0xe80009e7, // mov -, sacq(i)
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f809e7, // brr -, r:2f
0x00000017, 0xe80009e7, // mov -, sacq(i)
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
0x00000000, 0xf0fc49e7, // brr -, ra_temp
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x00000008, 0xe80009e7, // mov -, srel(i+8)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x00000009, 0xe80009e7, // mov -, srel(i+8)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x0000000a, 0xe80009e7, // mov -, srel(i+8)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x0000000b, 0xe80009e7, // mov -, srel(i+8)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x0000000c, 0xe80009e7, // mov -, srel(i+8)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x0000000d, 0xe80009e7, // mov -, srel(i+8)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x0000000e, 0xe80009e7, // mov -, srel(i+8)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x0000000f, 0xe80009e7, // mov -, srel(i+8)
0x00000080, 0xf0f801a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x00000858, 0xf0f811a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x00000009, 0xe80009e7, // mov -, srel(i+9)
0x00000011, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000a, 0xe80009e7, // mov -, srel(i+9)
0x00000012, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000b, 0xe80009e7, // mov -, srel(i+9)
0x00000013, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000c, 0xe80009e7, // mov -, srel(i+9)
0x00000014, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000d, 0xe80009e7, // mov -, srel(i+9)
0x00000015, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000e, 0xe80009e7, // mov -, srel(i+9)
0x00000016, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000f, 0xe80009e7, // mov -, srel(i+9)
0x00000017, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x204a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209d2039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x22092cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x204a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x204e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209d3039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x22093cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x204e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x20527030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209d4039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x22094cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x20527031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x20567030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209d5039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x22095cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x20567031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x00000000, 0xf0f409e7, // bra -, ra_link_0
0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149de1c0, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x149de1c0, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149df1c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149df1c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffffda0, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149de1c0, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x149de1c0, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149df1c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149df1c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffffc80, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
0x8c167d76, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149de1c0, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x149de1c0, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149df1c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149df1c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffffb20, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149de1c0, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x149de1c0, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149df1c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149df1c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffffa00, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
0x2225a19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
0x206a701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
0x00000000, 0xf0f549e7, // bra -, ra_save_64
0x209da017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
0x216897d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
0x8c14cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff920, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff8d0, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x00000000, 0xf0f489e7, // bra -, ra_save_32
0x952c2ff6, 0x100242c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
0x95307ff6, 0x10024307, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
0x9538eff6, 0x1002438e, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
0x119c51c0, 0xd0020827, // shl r0, r0, 5
0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
0x159cafc0, 0x100602a7, // mov.ifnz ra_save_64, rx_save_slave_64
0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
0x00000df0, 0xf00809e7, // brr.allz -, r:end
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000003, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000002, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100206a7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100216a7, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c61c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149de1c0, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x149de1c0, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149df1c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149df1c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff688, 0xf0f80227, // brr ra_link_1, r:pass_1
0x009e7000, 0x100009e7, // nop
0x00000200, 0xe0020827, // mov r0, 0x200
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x00000010, 0xe0020867, // mov r1, STAGES
0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
0xfffff658, 0xf00809e7, // brr.allz -, r:pass_1
0x009e7000, 0x100009e7, // nop
0x00000200, 0xe0020827, // mov r0, 0x200
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x159c0fc0, 0x100202e7, // mov ra_vpm_lo, rb_vpm
0x159c1fc0, 0x10020327, // mov ra_vpm_hi, rb_vpm_16
0x90104000, 0xe00203a7, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
0x90105000, 0xe00213a7, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
0x00000060, 0xe00212e7, // mov rb_3x4x8, 3*4*8
0x000000f0, 0xe0021327, // mov rb_0xF0, 0xF0
0x00000040, 0xe0021367, // mov rb_0x40, 0x40
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000003, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000002, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000005, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000004, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c51c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff900, 0xf0f80227, // brr ra_link_1, r:pass_2
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0xfffff8e0, 0xf0f80227, // brr ra_link_1, r:pass_2
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0xfffff8c0, 0xf0f80227, // brr ra_link_1, r:pass_2
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0xfffff8a0, 0xf0f80227, // brr ra_link_1, r:pass_2
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x025e7c80, 0x10020827, // fsub r0,  a, b
0x025e7180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x025e7c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x01627380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x025e7c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10020627, // fadd a+1, r0, r1
0x029d7ec0, 0x10020827, // fsub r0,  a, b
0x029d71c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d7e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d83c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d7e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10021627, // fadd a+1, r0, r1
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02567c80, 0x10020827, // fsub r0,  a, b
0x02567180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02567c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x015a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02567c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100205a7, // fadd a+1, r0, r1
0x029d5ec0, 0x10020827, // fsub r0,  a, b
0x029d51c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d5e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d63c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d5e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100215a7, // fadd a+1, r0, r1
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
0xfffff610, 0xf00809e7, // brr.allz -, r:pass_2
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x0d20bdc0, 0x10020227, // sub ra_link_1, ra_link_1, rb_3x4x8
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000007, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000006, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c51c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff3a0, 0xf0f80227, // brr ra_link_1, r:pass_3
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x025e7c80, 0x10020827, // fsub r0,  a, b
0x025e7180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x025e7c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x01627380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x025e7c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10020627, // fadd a+1, r0, r1
0x029d7ec0, 0x10020827, // fsub r0,  a, b
0x029d71c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d7e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d83c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d7e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x10021627, // fadd a+1, r0, r1
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02567c80, 0x10020827, // fsub r0,  a, b
0x02567180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02567c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x015a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02567c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100205a7, // fadd a+1, r0, r1
0x029d5ec0, 0x10020827, // fsub r0,  a, b
0x029d51c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d5e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d63c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d5e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100215a7, // fadd a+1, r0, r1
0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
0xfffff110, 0xf00809e7, // brr.allz -, r:pass_3
0x009e7000, 0x100009e7, // nop
0x00000100, 0xe0020827, // mov r0, 0x100
0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0xfffff1e0, 0xf0f809e7, // brr -, r:loop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159c3fc0, 0x100209a7, // mov interrupt, flag
0x009e7000, 0x300009e7, // nop; nop; thrend
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

##############################################################################
# Macro baseline

.include "gpu_fft_ex.qinc"

##############################################################################
# Redefining some macros

.macro body_ra_save_64
    mov -, vw_wait

    .rep i, 7
        mov -, srel(i+1) # Master releases slaves
    .endr

    write_vpm_64

    .rep i, 7
        mov -, sacq(i+9) # Master waits for slaves
    .endr

    mov r0, vdw_setup_0(1, 16, dma_h32(0,0))
    mov r1, 0x40
    add ra_save_ptr, ra_save_ptr, r1; mov r1, ra_save_ptr
    mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
    mov r3, PASS64_STRIDE

    .rep i, 64
        add r0, r0, r2; mov vw_setup, r0
        add r1, r1, r3; mov vw_addr,  r1
    .endr

    bra -, ra_link_1
    nop
    nop
    nop
.endm

.macro bit_rev, shift, mask
    mov r2, mask
    and r1, r0, r2
    shr r0, r0, shift
    and r0, r0, r2
    shl r1, r1, shift
    or  r0, r0, r1
.endm

.macro read_rev, stride
    add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx

    bit_rev 1,       0x55555555  # 16 SIMD
    bit_rev 2,       0x33333333
    bit_rev 4,       0x0F0F0F0F
    bit_rev 8,       0x00FF00FF
    bit_rev rb_0x10, 0x0000FFFF

    shr r0, r0, 32-STAGES-3 # r0 = re = {idx[0:STAGES-1], 1'b0, 2'b0}
    add r1, r0, 4           # r1 = im = {idx[0:STAGES-1], 1'b1, 2'b0}

    interleave

    add t0s, ra_addr_x, r0
    add t0s, ra_addr_x, r1
.endm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             0x15827d80, 0x10020e27, // mov t0s, unif
0x009e7000, 0xa00009e7, // ldtmu0
0x0c9cc9c0, 0xd0020e27, // add t0s, r4, 3*4
0x009e7000, 0xa00009e7, // ldtmu0
0x0c827980, 0x100200a7, // add ra_src_base, r4, unif
0x15827d80, 0x10020e27, // mov t0s, unif
0x009e7000, 0xa00009e7, // ldtmu0
0x0c9cc9c0, 0xd0020e27, // add t0s, r4, 3*4
0x009e7000, 0xa00009e7, // ldtmu0
0x0c827980, 0x100200e7, // add ra_dst_base, r4, unif
0x15827d80, 0x100214a7, // mov rb_Y_STRIDE_SRC, unif
0x15827d80, 0x100214e7, // mov rb_Y_STRIDE_DST, unif
0x15827d80, 0x10021527, // mov rb_NX,           unif
0x15827d80, 0x10021567, // mov rb_NY,           unif
0x00000008, 0xe0021467, // mov rb_X_STRIDE, 2*4
0x00000010, 0xe0021427, // mov rb_0x10, 0x10
0xc0000000, 0xe0020827, // mov r0, vdw_setup_1(0)
0x0c9d31c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_DST
0x00000040, 0xe0020867, // mov r1, 16*4
0x0d9e7040, 0x100201a7, // sub ra_vdw_stride, r0, r1
0x40991037, 0x100049e0, // nop; mul24 r0, elem_num, rb_X_STRIDE
0x159e7000, 0x10021027, // mov rb_offsets_re+i, r0
0x0c9c41c0, 0xd0021227, // add rb_offsets_im+i, r0, 4
0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
0x159e7000, 0x10021067, // mov rb_offsets_re+i, r0
0x0c9c41c0, 0xd0021267, // add rb_offsets_im+i, r0, 4
0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
0x159e7000, 0x100210a7, // mov rb_offsets_re+i, r0
0x0c9c41c0, 0xd00212a7, // add rb_offsets_im+i, r0, 4
0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
0x159e7000, 0x100210e7, // mov rb_offsets_re+i, r0
0x0c9c41c0, 0xd00212e7, // add rb_offsets_im+i, r0, 4
0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
0x159e7000, 0x10021127, // mov rb_offsets_re+i, r0
0x0c9c41c0, 0xd0021327, // add rb_offsets_im+i, r0, 4
0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
0x159e7000, 0x10021167, // mov rb_offsets_re+i, r0
0x0c9c41c0, 0xd0021367, // add rb_offsets_im+i, r0, 4
0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
0x159e7000, 0x100211a7, // mov rb_offsets_re+i, r0
0x0c9c41c0, 0xd00213a7, // add rb_offsets_im+i, r0, 4
0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
0x159e7000, 0x100211e7, // mov rb_offsets_re+i, r0
0x0c9c41c0, 0xd00213e7, // add rb_offsets_im+i, r0, 4
0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
0x00000000, 0xe0020067, // mov ra_y, 0
0x00000000, 0xe0020027, // mov ra_x, 0
0x40052037, 0x100049e1, // nop; mul24 r1, ra_y, rb_Y_STRIDE_SRC
0x40011037, 0x100049e0, // nop; mul24 r0, ra_x, rb_X_STRIDE
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c0a7c00, 0x10020127, // add ra_src_cell, ra_src_base, r0
0x40013037, 0x100049e1, // nop; mul24 r1, ra_x, rb_Y_STRIDE_DST
0x40051037, 0x100049e0, // nop; mul24 r0, ra_y, rb_X_STRIDE
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c0e7c00, 0x10020167, // add ra_dst_cell, ra_dst_base, r0
0x00001200, 0xe0021c67, // mov vw_setup, vpm_setup(16, 1, v32(0,0))
0x0c100dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re
0x0c108dc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im
0x0c101dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
0x0c109dc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020c27, // mov vpm, r4
0x009e7000, 0xb00009e7, // ldtmu1
0x159e7900, 0x10020c27, // mov vpm, r4
0x0c102dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
0x0c10adc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020c27, // mov vpm, r4
0x009e7000, 0xb00009e7, // ldtmu1
0x159e7900, 0x10020c27, // mov vpm, r4
0x0c103dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
0x0c10bdc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020c27, // mov vpm, r4
0x009e7000, 0xb00009e7, // ldtmu1
0x159e7900, 0x10020c27, // mov vpm, r4
0x0c104dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
0x0c10cdc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020c27, // mov vpm, r4
0x009e7000, 0xb00009e7, // ldtmu1
0x159e7900, 0x10020c27, // mov vpm, r4
0x0c105dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
0x0c10ddc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020c27, // mov vpm, r4
0x009e7000, 0xb00009e7, // ldtmu1
0x159e7900, 0x10020c27, // mov vpm, r4
0x0c106dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
0x0c10edc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020c27, // mov vpm, r4
0x009e7000, 0xb00009e7, // ldtmu1
0x159e7900, 0x10020c27, // mov vpm, r4
0x0c107dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
0x0c10fdc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020c27, // mov vpm, r4
0x009e7000, 0xb00009e7, // ldtmu1
0x159e7900, 0x10020c27, // mov vpm, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020c27, // mov vpm, r4
0x009e7000, 0xb00009e7, // ldtmu1
0x159e7900, 0x10020c27, // mov vpm, r4
0x88104000, 0xe0021c67, // mov vw_setup, vdw_setup_0(16, 16, dma_h32(0,0))
0x151a7d80, 0x10021c67, // mov vw_setup, ra_vdw_stride
0x15167d80, 0x10021ca7, // mov vw_addr, ra_dst_cell
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x0c010dc0, 0x10020027, // add ra_x, ra_x, rb_0x10
0x009e7000, 0x100009e7, // nop
0x0d014dc0, 0x100229e7, // sub.setf -, ra_x, rb_NX
0xfffffde0, 0xf01809e7, // brr.allnz -, r:inner
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c048dc0, 0xd0020067, // add ra_y, ra_y, 8
0x009e7000, 0x100009e7, // nop
0x0d055dc0, 0x100229e7, // sub.setf -, ra_y, rb_NY
0xfffffda0, 0xf01809e7, // brr.allnz -, r:outer
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000001, 0xe00209a7, // mov interrupt, 1
0x009e7000, 0x300009e7, // nop; nop; thrend
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 20

.include "gpu_fft_ex.qinc"

##############################################################################
# Twiddles: src

.set TW32_BASE,     0   # rx_tw_shared
.set TW16_BASE,     1
.set TW32_P2_STEP,  2
.set TW16_P2_STEP,  3
.set TW32_P3_STEP,  4
.set TW16_P3_STEP,  5
.set TW32_P4_STEP,  6
.set TW16_P4_STEP,  7

.set TW32_P4_BASE,  0   # rx_tw_unique
.set TW16_P4_BASE,  1

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2

##############################################################################
# Registers

.set ra_link_0,         ra0
#    rx_0x00FF00FF      rb0
.set ra_save_ptr,       ra1
.set rb_vdw_32,         rb1
.set ra_temp,           ra2
.set rb_vpm_lo,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
# spare                 ra4
# spare                 rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_hi,         rb7
.set ra_link_1,         ra8
.set rb_STAGES,         rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_32,        ra10
.set rx_save_slave_32,  rb10

.set rx_tw_shared,      ra11
.set rx_tw_unique,      rb11

.set ra_tw_re,          ra12 # 9
.set rb_tw_im,          rb12 # 9

.set ra_vpm_lo,         ra26
.set ra_vpm_hi,         ra27
.set ra_vdw_32,         ra28

.set rx_0x55555555,     ra29
.set rx_0x33333333,     ra30
.set rx_0x0F0F0F0F,     ra31
.set rx_0x00FF00FF,     rb0
.set rx_0x0000FFFF,     rb26

.set rb_0x10,           rb27
.set rb_0x40,           rb28
.set rb_0x80,           rb29
.set rb_0xF0,           rb30
.set rb_0x100,          rb31

##############################################################################
# Constants

mov rb_STAGES,  STAGES

mov rb_0x10,    0x10
mov rb_0x40,    0x40
mov rb_0x80,    0x80
mov rb_0xF0,    0xF0
mov rb_0x100,   0x100

mov rx_0x55555555, 0x55555555
mov rx_0x33333333, 0x33333333
mov rx_0x0F0F0F0F, 0x0F0F0F0F
mov rx_0x00FF00FF, 0x00FF00FF
mov rx_0x0000FFFF, 0x0000FFFF

mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm_lo, ra_vpm_hi, rb_vpm_lo, rb_vpm_hi

##############################################################################
# Master/slave procedures

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_32 LOAD_REVERSED

:pass_2
:pass_3
:pass_4
    body_pass_32 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_32, rx_save_slave_32

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    init_stage 5
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P2_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x100

        mov r0, 0x7FFF
        and.setf -, ra_points, r0

        brr.allnz -, r:pass_2
        nop
        nop
        add.ifnz ra_points, ra_points, rb_0x100

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P3_STEP
    init_stage 5
    read_lin rb_0x10

    .rep i, 4
        brr ra_link_1, r:pass_3
        nop
        nop
        add ra_points, ra_points, rb_0x100
    .endr

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_3
        mov r0, 3*4*8
        sub ra_link_1, ra_link_1, r0
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 4

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P4_BASE
    load_tw rx_tw_unique, TW32+0, TW32_P4_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P4_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P4_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_4
        nop
        nop
        add ra_points, ra_points, rb_0x100

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_4
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                 0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
0x00000040, 0xe0021727, // mov rb_0x40,    0x40
0x00000080, 0xe0021767, // mov rb_0x80,    0x80
0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
0x00005555, 0xe0020767, // mov rx_0x5555,  0x5555
0x00003333, 0xe00207a7, // mov rx_0x3333,  0x3333
0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
0x000000ff, 0xe00216a7, // mov rx_0x00FF,  0x00FF
0x88104000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
0x88105000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
0x15827d80, 0x10021167, // mov rb_inst, unif
0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
0x0c9e7080, 0x100211e7, // add out_3, r0, r2
0x000000b0, 0xf0f80127, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10021c67, // mov vw_setup, arg
0x159e7000, 0x10020c27, // mov vpm, r0
0x159e7240, 0x10020c27, // mov vpm, r1
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x156e7d80, 0x10021c67, // mov vw_setup, arg_vdw
0xc0000fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
0x00000038, 0xf0f81127, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10021c67, // mov vw_setup, arg
0x159e7000, 0x10020c27, // mov vpm, r0
0x159e7240, 0x10020c27, // mov vpm, r1
0x00000000, 0xf0f4c9e7, // bra -, ra_sync
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
0x15c27d80, 0x100009e7, // mov -, vpm
0x000000c8, 0xf0f802a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
0xc00007c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
0x00000050, 0xf0f812a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
0x00000000, 0xf0f4c9e7, // bra -, ra_sync
0x009e7000, 0x100009e7, // nop
0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
0x15c27d80, 0x100009e7, // mov -, vpm
0x00000080, 0xf0f801a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159f2fc0, 0x100009e7, // mov -, vw_wait
0x00000019, 0xe80009e7, // mov -, sacq(i+9)
0x00000001, 0xe80009e7, // mov -, srel(i+1)
0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
0x00000002, 0xe80009e7, // mov -, srel(i+1)
0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
0x00000003, 0xe80009e7, // mov -, srel(i+1)
0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
0x00000004, 0xe80009e7, // mov -, srel(i+1)
0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
0x00000005, 0xe80009e7, // mov -, srel(i+1)
0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x00000006, 0xe80009e7, // mov -, srel(i+1)
0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
0x00000007, 0xe80009e7, // mov -, srel(i+1)
0x00000500, 0xf0f811a7, // brr rx_ptr, label
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x00000009, 0xe80009e7, // mov -, srel(i+9)
0x00000011, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000a, 0xe80009e7, // mov -, srel(i+9)
0x00000012, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000b, 0xe80009e7, // mov -, srel(i+9)
0x00000013, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000c, 0xe80009e7, // mov -, srel(i+9)
0x00000014, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000d, 0xe80009e7, // mov -, srel(i+9)
0x00000015, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000e, 0xe80009e7, // mov -, srel(i+9)
0x00000016, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x00000000, 0xf0f509e7, // bra -, ra_link_1
0x0000000f, 0xe80009e7, // mov -, srel(i+9)
0x00000017, 0xe80009e7, // mov -, sacq(i+1)
0x009e7000, 0x100009e7, // nop
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
0x00000000, 0xf0f409e7, // bra -, ra_link_0
0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149da1c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149da1c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffffda8, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149da1c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149da1c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0xfffffc90, 0xf0f80027, // brr ra_link_0, call
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
0x019e72c0, 0x10020867, // fadd r1, r1,      r3
0x00000000, 0xf0f549e7, // bra -, ra_save_32
0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffc00, 0xf0f80027, // brr ra_link_0, call
0x009e7000, 0xa00009e7, // nop;        ldtmu0
0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
0x159e7900, 0x10020867, // mov r1, r4
0x00000000, 0xf0f489e7, // bra -, ra_save_16
0x009e7000, 0x100009e7, // nop
0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
0x119c51c0, 0xd0020827, // shl r0, r0, 5
0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
0x00000958, 0xf00809e7, // brr.allz -, r:end
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c51c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x14767180, 0x10020867, // and r1, r0, mask
0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
0x14767180, 0x10020827, // and r0, r0, mask
0x119c13c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147a7180, 0x10020867, // and r1, r0, mask
0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
0x147a7180, 0x10020827, // and r0, r0, mask
0x119c23c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x147e7180, 0x10020867, // and r1, r0, mask
0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
0x147e7180, 0x10020827, // and r0, r0, mask
0x119c43c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x149da1c0, 0x10020867, // and r1, r0, mask
0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
0x149da1c0, 0x10020827, // and r0, r0, mask
0x119c83c0, 0xd0020867, // shl r1, r1, shift
0x159e7040, 0x10020827, // or  r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffa98, 0xf0f80227, // brr ra_link_1, r:pass_1
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0x0e1cddc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
0xfffffa70, 0xf00809e7, // brr.allz -, r:pass_1
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000001, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000002, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c41c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffffb20, 0xf0f80227, // brr ra_link_1, r:pass_2
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0xfffffb00, 0xf0f80227, // brr ra_link_1, r:pass_2
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02467c80, 0x10020827, // fsub r0,  a, b
0x02467180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02467c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x014a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02467c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100204a7, // fadd a+1, r0, r1
0x029d1ec0, 0x10020827, // fsub r0,  a, b
0x029d11c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d1e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d23c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d1e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100214a7, // fadd a+1, r0, r1
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1cddc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
0xfffff970, 0xf00809e7, // brr.allz -, r:pass_2
0x00000020, 0xe0020827, // mov r0, 4*8
0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000000, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
0x00000003, 0xe0020867, // mov r1, src
0x119c73c0, 0xd0020867, // shl r1, r1, 7
0x0c9e7040, 0x10020827, // add r0, r0, r1
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
0x009e7000, 0xa00009e7, // ldtmu0
0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x159c5fc0, 0x10020827, // mov r0, rb_inst
0x119c41c0, 0xd0020827, // shl r0, r0, m
0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
0x00000000, 0xe00201e7, // mov ra_points, 0
0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
0x119c31c0, 0xd0020827, // shl r0, r0, 3
0x0c9c41c0, 0xd0020867, // add r1, r0, 4
0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
0xfffff7b0, 0xf0f80227, // brr ra_link_1, r:pass_3
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
0x029e7640, 0x100208e7, // fsub r3, r3, r1
0x02467c80, 0x10020827, // fsub r0,  a, b
0x02467180, 0x10020867, // fsub r1, r0, a
0x019e7280, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x02467c40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x014a7380, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x02467c80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100204a7, // fadd a+1, r0, r1
0x029d1ec0, 0x10020827, // fsub r0,  a, b
0x029d11c0, 0x10020867, // fsub r1, r0, a
0x019e72c0, 0x100208a7, // fadd r2, r1, b
0x029e7040, 0x10020867, // fsub r1, r0, r1
0x029d1e40, 0x10020867, // fsub r1,  a, r1
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x019d23c0, 0x10020867, // fadd r1, r1, a+1
0x019e7040, 0x100208a7, // fadd r2, r0, r1
0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
0x029e7280, 0x10020867, // fsub r1, r1, r2
0x029d1e80, 0x100208a7, // fsub r2,  a, r2
0x029e7080, 0x10020827, // fsub r0, r0, r2
0x019e7040, 0x100214a7, // fadd a+1, r0, r1
0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
0x0e1cddc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
0xfffff620, 0xf00809e7, // brr.allz -, r:pass_3
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
0x009e7000, 0x100009e7, // nop
0x009e7000, 0xa00009e7, // ldtmu0
0x009e7000, 0xa00009e7, // ldtmu0
0xfffff678, 0xf0f809e7, // brr -, r:loop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
0x159c3fc0, 0x100209a7, // mov interrupt, flag
0x009e7000, 0x300009e7, // nop; nop; thrend
0x009e7000, 0x100009e7, // nop
0x009e7000, 0x100009e7, // nop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

##############################################################################
# Bit-rotated write

.set PASS16_STRIDE, ((1<<STAGES)/16*8)
.set PASS32_STRIDE, ((1<<STAGES)/32*8)
.set PASS64_STRIDE, ((1<<STAGES)/64*8)

##############################################################################
# Load twiddle factors

.macro load_tw, ptr, dst, src
    shl r0, elem_num, 3
    mov r1, src
    shl r1, r1, 7
    add r0, r0, r1
    add r1, r0, 4
    add t0s, ptr, r0
    add t0s, ptr, r1
    ldtmu0
    mov ra_tw_re+dst, r4
    ldtmu0
    mov rb_tw_im+dst, r4
.endm

##############################################################################
# VPM pointers

.macro inst_vpm, in_inst, out_0, out_1, out_2, out_3
    mov r0, vpm_setup(1, 1, v32( 0,0))
    mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
    mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))

    nop; mul24 r2, r2, in_inst

    add out_0, r0, r2; v8adds r0, r0, r1
    add out_1, r0, r2; v8adds r0, r0, r1
    add out_2, r0, r2; v8adds r0, r0, r1
    add out_3, r0, r2
.endm

##############################################################################

.macro proc, rx_ptr, label
    brr rx_ptr, label
    nop
    nop
    nop
.endm

##############################################################################

.macro write_vpm_16, arg
    mov vw_setup, arg
    mov vpm, r0
    mov vpm, r1
.endm

.macro write_vpm_32
    mov vw_setup, ra_vpm_lo
    fadd vpm, ra_32_re, r0
    fadd vpm, rb_32_im, r1
    mov vw_setup, ra_vpm_hi
    fsub vpm, ra_32_re, r0
    fsub vpm, rb_32_im, r1
.endm

.macro write_vpm_64
    mov vw_setup, rb_vpm
    fadd vpm, ra_64+0, rb_64+0
    fadd vpm, ra_64+1, rb_64+1
    mov vw_setup, rb_vpm_16
    fadd vpm, ra_64+2, rb_64+2
    fadd vpm, ra_64+3, rb_64+3
    mov vw_setup, rb_vpm_32
    fsub vpm, ra_64+0, rb_64+0
    fsub vpm, ra_64+1, rb_64+1
    mov vw_setup, rb_vpm_48
    fsub vpm, ra_64+2, rb_64+2
    fsub vpm, ra_64+3, rb_64+3
.endm

##############################################################################

.macro body_ra_save_16, arg_vpm, arg_vdw
    write_vpm_16 arg_vpm

    mov -, vw_wait

    .rep i, 7
        mov -, sacq(i+9) # Master waits for slave
        mov -, srel(i+1) # Master releases slave
    .endr

    bra -, ra_link_1

    mov vw_setup, arg_vdw
    mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
    add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
.endm

##############################################################################

.macro body_rx_save_slave_16, arg_vpm
    write_vpm_16 arg_vpm

    bra -, ra_sync

    nop
    mov vr_setup, arg_vpm
    mov -, vpm
.endm

##############################################################################

.macro body_ra_save_32
    write_vpm_32

    mov -, vw_wait

    .rep i, 7
        mov -, sacq(i+9) # Master waits for slave
        mov -, srel(i+1) # Master releases slave
    .endr

    bra -, ra_link_1

    mov vw_setup, ra_vdw_32
    mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
    add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
.endm

##############################################################################

.macro body_rx_save_slave_32
    write_vpm_32

    bra -, ra_sync

    nop
    mov vr_setup, ra_vpm_lo
    mov -, vpm
.endm

##############################################################################

.macro body_ra_save_64, step
    mov -, vw_wait

    .rep i, 7
        mov -, srel(i+1) # Master releases slaves
    .endr

    write_vpm_64

    .rep i, 7
        mov -, sacq(i+9) # Master waits for slaves
    .endr

    bra -, ra_link_1

    mov vw_setup, vdw_setup_0(64, 16, dma_h32(0,0))
    mov vw_setup, vdw_setup_1(PASS64_STRIDE-16*4)
    add ra_save_ptr, ra_save_ptr, step; mov vw_addr, ra_save_ptr
.endm

##############################################################################

.macro body_rx_save_slave_64
    mov r0, rb_inst
    shl ra_temp, r0, 5
    nop
    brr -, ra_temp
    nop
    nop
    nop

    .rep i, 8
        brr -, r:2f
        mov -, sacq(i) # Slave waits for master
        nop
        nop
    .endr
:2
    write_vpm_64

    brr -, ra_temp
    nop
    nop
    nop

    .rep i, 8
        bra -, ra_link_1
        mov vr_setup, rb_vpm
        mov -, vpm
        mov -, srel(i+8) # Slave releases master
    .endr
.endm

##############################################################################

.macro body_ra_sync
    mov -, vw_wait

    .rep i, 7
        mov -, sacq(i+9) # Master waits for slave
    .if i==5
        bra -, ra_link_1
    .endif
        mov -, srel(i+1) # Master releases slave
    .endr
.endm

##############################################################################

.macro body_rx_sync_slave
    .rep i, 7
        bra -, ra_link_1
        mov -, srel(i+9) # Slave releases master
        mov -, sacq(i+1) # Slave waits for master
        nop
    .endr
.endm

##############################################################################

.macro fft_twiddles_32
    nop;                  fmul ra_temp, r0, ra_tw_re+TW32 # rr
    nop;                  fmul r2,      r1, rb_tw_im+TW32 # ii
    nop;                  fmul r3,      r1, ra_tw_re+TW32 # ir
    fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32 # ri
    fadd r1, r1,      r3
.endm

##############################################################################
# FFT-16 codelet

.macro body_fft_16
.rep i, 4
    and.setf -, elem_num, (1<<i)
    nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
    nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
    fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
    nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
    fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
    fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
.if i==3
    bra -, ra_link_0
.endif
    fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
    fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
    fsub.ifnz r1, r3, r1
.endr
.endm

##############################################################################

.macro bit_rev, shift, mask
    and r1, r0, mask
    shr r0, r0, shift
    and r0, r0, mask
    shl r1, r1, shift
    or  r0, r0, r1
.endm

##############################################################################

.macro swizzle
.endm

.macro interleave
    and.setf -, elem_num, 1; mov r2, r0
    mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
    mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
.endm

##############################################################################

.macro read_rev, stride
    add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx

    bit_rev 1, rx_0x5555    # 16 SIMD
    bit_rev 2, rx_0x3333
    bit_rev 4, rx_0x0F0F
    bit_rev 8, rx_0x00FF    # reversal creates left shift by 16-STAGES
.if STAGES>13
    shl r0, r0, STAGES-13
.endif
.if STAGES<13
    shr r0, r0, 13-STAGES
.endif                      # r0 = re = {idx[0:STAGES-1], 1'b0, 2'b0}
    add r1, r0, 4           # r1 = im = {idx[0:STAGES-1], 1'b1, 2'b0}

    interleave
    swizzle

    add t0s, ra_addr_x, r0
    add t0s, ra_addr_x, r1
.endm

.macro load_rev, stride, call
    read_rev stride
    nop;        ldtmu0
    mov r0, r4; ldtmu0
    mov r1, r4
    brr ra_link_0, call
    interleave
.endm

##############################################################################

.macro read_lin, stride
    add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx

    shl r0, r0, 3
    add r1, r0, 4

    add t0s, ra_addr_x, r0
    add t0s, ra_addr_x, r1
.endm

.macro load_lin, stride, call
    read_lin stride
    brr ra_link_0, call
    nop;        ldtmu0
    mov r0, r4; ldtmu0
    mov r1, r4
.endm

##############################################################################
# Unpack twiddles

.macro unpack_twiddles
    mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
.rep i, 4
    and.setf -, elem_num, (8>>i)
    mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
    mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
.endr
.endm

##############################################################################
# float-float enhanced-precision subtract (corrects rounding errors)

.macro df64_sub32, a, b     # df64_sub32(float2 &a, float b)
    fsub r0,  a, b              # float2 s = twoSub(a.x, b);
    fsub r1, r0, a
    fadd r2, r1, b
    fsub r1, r0, r1
    fsub r1,  a, r1
    fsub r1, r1, r2

    fadd r1, r1, a+1            # s.y += a.y;

    fadd r2, r0, r1             # a = twoSum(s.x, s,y);
    fsub r2, r2, r0; mov a, r2
    fsub r1, r1, r2
    fsub r2,  a, r2
    fsub r0, r0, r2
    fadd a+1, r0, r1
.endm

##############################################################################
# Rotate twiddles using enhanced-precision trig recurrence

.macro rotate, base, step
    mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
    nop;             fmul r0, r2, ra_tw_re+step # a.cos
    nop;             fmul r1, r2, rb_tw_im+step # b.cos
    nop;             fmul r2, r3, rb_tw_im+step # b.sin
    fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step # a.sin
    fsub r3, r3, r1
    df64_sub32 ra_tw_re+base, r2
    df64_sub32 rb_tw_im+base, r3
.endm

.macro next_twiddles_32
    rotate TW32, TW32_STEP
.endm

.macro next_twiddles_16
    rotate TW16+3, TW16_STEP
    unpack_twiddles
.endm

##############################################################################
# Alternate input/output buffers between stages

.macro swap_buffers
    mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
.endm

##############################################################################
# Reset counters and twiddles

.macro init_stage, m
    mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
.ifset TW32
    mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
.endif
    unpack_twiddles
    mov r0, rb_inst
    shl r0, r0, m
    add ra_load_idx, r0, elem_num
    mov ra_points, 0
    mov ra_save_ptr, rb_addr_y
.endm

##############################################################################

.set LOAD_STRAIGHT, 0
.set LOAD_REVERSED, 1

.macro loader_16, stride, mode
    .if mode==LOAD_REVERSED
        load_rev stride, r:fft_16
    .else
        load_lin stride, r:fft_16
    .endif
.endm

.macro body_pass_16, mode
    loader_16 rb_0x80, mode
    bra -, ra_save_16
    nop
    mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
    mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
.endm

.macro body_pass_32, mode
    loader_16 rb_0xF0, mode
    mov ra_32_re, r0; mov rb_32_im, r1
    loader_16 rb_0x10, mode
    fft_twiddles_32
    bra -, ra_save_32
    mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
    mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
    mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
.endm

.macro body_pass_64, mode, step
    loader_16 rb_0x10, mode
    mov ra_32_re, r0; mov rb_32_im, r1
    loader_16 rb_0x10, mode
    fft_twiddles_32

    fadd ra_64+0, ra_32_re, r0
    fadd ra_64+1, rb_32_im, r1
    fsub ra_64+2, ra_32_re, r0
    fsub ra_64+3, rb_32_im, r1

    loader_16 step, mode
    mov ra_32_re, r0; mov rb_32_im, r1
    loader_16 rb_0x10, mode
    fft_twiddles_32

    fsub r3, rb_32_im, r1
    fsub r2, ra_32_re, r0
    fadd r1, rb_32_im, r1
    fadd r0, ra_32_re, r0

    nop;                        fmul rb_32_im, r1, ra_tw_re+TW48 # ir
    nop;                        fmul ra_32_re, r1, rb_tw_im+TW48 # ii
    nop;                        fmul r1,       r0, rb_tw_im+TW48 # ri
    fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48 # rr
    fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64 # ii
    nop;                        fmul rb_32_im, r3, ra_tw_re+TW64 # ir
    bra -, ra_save_64
    nop;                        fmul r3,       r2, rb_tw_im+TW64 # ri
    fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64 # rr
    fsub rb_64+2, r2, ra_32_re
.endm

##############################################################################

.macro exit, flag
    mov interrupt, flag
    nop; nop; thrend
    nop
    nop
.endm

##############################################################################
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 17

.include "gpu_fft_ex.qinc"

##############################################################################
# Twiddles: src

.set TW32_BASE,     0   # rx_tw_shared
.set TW16_BASE,     1
.set TW16_P2_STEP,  2
.set TW16_P3_STEP,  3
.set TW16_P4_STEP,  4

.set TW16_P4_BASE,  0   # rx_tw_unique

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2

##############################################################################
# Registers

.set ra_link_0,         ra0
.set rb_vdw_16,         rb0
.set ra_save_ptr,       ra1
.set rb_vdw_32,         rb1
.set ra_temp,           ra2
.set rb_vpm_lo,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_16,        ra4
.set rx_save_slave_16,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_hi,         rb7
.set ra_link_1,         ra8
.set rb_STAGES,         rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_32,        ra10
.set rx_save_slave_32,  rb10

.set rx_tw_shared,      ra11
.set rx_tw_unique,      rb11

.set ra_tw_re,          ra12 # 9
.set rb_tw_im,          rb12 # 9

.set ra_vpm_lo,         ra25
.set ra_vpm_hi,         ra26
.set ra_vdw_16,         ra27
.set ra_vdw_32,         ra28

.set rx_0x55555555,     ra29
.set rx_0x33333333,     ra30
.set rx_0x0F0F0F0F,     ra31
.set rx_0x00FF00FF,     rb24
.set rx_0x0000FFFF,     rb25

.set rb_0x10,           rb26
.set rb_0x40,           rb27
.set rb_0x80,           rb28
.set rb_0xF0,           rb29
.set rb_0x100,          rb30
.set rb_0xFFF,          rb31

##############################################################################
# Constants

mov rb_STAGES,  STAGES

mov rb_0x10,    0x10
mov rb_0x40,    0x40
mov rb_0x80,    0x80
mov rb_0xF0,    0xF0
mov rb_0x100,   0x100
mov rb_0xFFF,   0xFFF

mov rx_0x55555555, 0x55555555
mov rx_0x33333333, 0x33333333
mov rx_0x0F0F0F0F, 0x0F0F0F0F
mov rx_0x00FF00FF, 0x00FF00FF
mov rx_0x0000FFFF, 0x0000FFFF

mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm_lo, ra_vpm_hi, rb_vpm_lo, rb_vpm_hi

##############################################################################
# Master/slave procedures

proc ra_save_16, r:1f
body_ra_save_16 ra_vpm_lo, ra_vdw_16
:1

proc rx_save_slave_16, r:1f
body_rx_save_slave_16 ra_vpm_lo
:1

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_32 LOAD_REVERSED

:pass_2
:pass_3
:pass_4
    body_pass_16 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_16, rx_save_slave_16
    mov.ifnz ra_save_32, rx_save_slave_32

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    init_stage 5
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    init_stage 4
    read_lin rb_0x80

        brr ra_link_1, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x80

        and.setf -, ra_points, rb_0xFFF

        brr.allnz -, r:pass_2
        nop
        nop
        add.ifnz ra_points, ra_points, rb_0x80

        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    init_stage 4
    read_lin rb_0x80

    .rep i, 2
        brr ra_link_1, r:pass_3
        nop
        nop
        add ra_points, ra_points, rb_0x80
    .endr

        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_3
        mov r0, 4*8
        sub ra_link_1, ra_link_1, r0
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 4

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P4_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P4_STEP
    init_stage 4
    read_lin rb_0x80

        brr ra_link_1, r:pass_4
        nop
        nop
        add ra_points, ra_points, rb_0x80

        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_4
        nop
        nop
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                           # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 14

.include "gpu_fft.qinc"

##############################################################################
# Twiddles: src

.set TW32_BASE,     0   # rx_tw_shared
.set TW16_BASE,     1
.set TW32_P2_STEP,  2
.set TW16_P2_STEP,  3
.set TW16_P3_STEP,  4

.set TW16_P3_BASE,  0   # rx_tw_unique

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2

##############################################################################
# Registers

.set ra_link_0,         ra0
.set rb_vdw_16,         rb0
.set ra_save_ptr,       ra1
.set rb_vdw_32,         rb1
.set ra_temp,           ra2
.set rb_vpm_lo,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_16,        ra4
.set rx_save_slave_16,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_hi,         rb7
.set ra_link_1,         ra8
#                       rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_32,        ra10
.set rx_save_slave_32,  rb10

.set rx_tw_shared,      ra11
.set rx_tw_unique,      rb11

.set ra_tw_re,          ra12 # 9
.set rb_tw_im,          rb12 # 9

.set ra_vpm_lo,         ra25
.set ra_vpm_hi,         ra26
.set ra_vdw_16,         ra27
.set ra_vdw_32,         ra28

.set rx_0x5555,         ra29
.set rx_0x3333,         ra30
.set rx_0x0F0F,         ra31

.set rx_0x00FF,         rb26
.set rb_0x10,           rb27
.set rb_0x40,           rb28
.set rb_0x80,           rb29
.set rb_0xF0,           rb30
.set rb_0x100,          rb31

##############################################################################
# Constants

mov rb_0x10,    0x10
mov rb_0x40,    0x40
mov rb_0x80,    0x80
mov rb_0xF0,    0xF0
mov rb_0x100,   0x100

mov rx_0x5555,  0x5555
mov rx_0x3333,  0x3333
mov rx_0x0F0F,  0x0F0F
mov rx_0x00FF,  0x00FF

mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm_lo, ra_vpm_hi, rb_vpm_lo, rb_vpm_hi

##############################################################################
# Master/slave procedures

proc ra_save_16, r:1f
body_ra_save_16 ra_vpm_lo, ra_vdw_16
:1

proc rx_save_slave_16, r:1f
body_rx_save_slave_16 ra_vpm_lo
:1

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_32 LOAD_REVERSED

:pass_2
    body_pass_32 LOAD_STRAIGHT

:pass_3
    body_pass_16 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_16, rx_save_slave_16
    mov.ifnz ra_save_32, rx_save_slave_32

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    init_stage 5
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P2_STEP
    init_stage 5
    read_lin rb_0x10

    .rep i, 2
        brr ra_link_1, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x100
    .endr

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_2
        mov r0, 4*8
        sub ra_link_1, ra_link_1, r0
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P3_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    init_stage 4
    read_lin rb_0x80

        brr ra_link_1, r:pass_3
        nop
        nop
        add ra_points, ra_points, rb_0x80

        next_twiddles_16

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_3
        nop
        nop
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 10

.include "gpu_fft.qinc"

##############################################################################
# Twiddles: src

.set TW32_P1_BASE,  0   # rx_tw_shared
.set TW16_P1_BASE,  1
.set TW32_P2_STEP,  2
.set TW16_P2_STEP,  3

.set TW32_P2_BASE,  0   # rx_tw_unique
.set TW16_P2_BASE,  1

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2

##############################################################################
# Registers

.set ra_link_0,         ra0
#                       rb0
.set ra_save_ptr,       ra1
.set rb_vdw_32,         rb1
.set ra_temp,           ra2
.set rb_vpm_lo,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_32,        ra4
.set rx_save_slave_32,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_hi,         rb7
.set ra_link_1,         ra8
#                       rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9

.set rx_tw_shared,      ra10
.set rx_tw_unique,      rb10

.set ra_tw_re,          ra11 # 9
.set rb_tw_im,          rb11 # 9

.set ra_vpm_lo,         ra27
.set ra_vpm_hi,         ra28
.set ra_vdw_32,         ra29

.set rb_0x10,           rb27
.set rb_0x40,           rb28
.set rb_0xF0,           rb29

.set rx_0x5555,         ra30
.set rx_0x3333,         rb30
.set rx_0x0F0F,         ra31
.set rx_0x00FF,         rb31

##############################################################################
# Constants

mov rb_0x10,    0x10
mov rb_0x40,    0x40
mov rb_0xF0,    0xF0

mov rx_0x5555,  0x5555
mov rx_0x3333,  0x3333
mov rx_0x0F0F,  0x0F0F
mov rx_0x00FF,  0x00FF

mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm_lo, ra_vpm_hi, rb_vpm_lo, rb_vpm_hi

##############################################################################
# Master/slave procedures

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_32 LOAD_REVERSED

:pass_2
    body_pass_32 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_32, rx_save_slave_32

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_P1_BASE
    load_tw rx_tw_shared, TW32+0, TW32_P1_BASE
    init_stage 5
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_1
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P2_BASE
    load_tw rx_tw_unique, TW32+0, TW32_P2_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P2_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_2
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_2
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 21

.include "gpu_fft_2048k.qinc"

##############################################################################
# Twiddles: src

.set TW64_BASE0,    0   # rx_tw_shared
.set TW64_BASE1,    1
.set TW32_BASE,     2
.set TW16_BASE,     3
.set TW32_P2_STEP,  4
.set TW16_P2_STEP,  5
.set TW32_P3_STEP,  6
.set TW16_P3_STEP,  7
.set TW32_P4_STEP,  8
.set TW16_P4_STEP,  9

.set TW32_P4_BASE,  0   # rx_tw_unique
.set TW16_P4_BASE,  1

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2
.set TW48,      9  # 1
.set TW64,      10 # 1

##############################################################################
# Registers

.set ra_link_0,         ra0
.set rb_vpm,            rb0
.set ra_save_ptr,       ra1
.set rb_vpm_16,         rb1
.set ra_temp,           ra2
.set rb_vpm_32,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_32,        ra4
.set rx_save_slave_32,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_48,         rb7
.set ra_link_1,         ra8
.set rb_0x10,           rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_64,        ra10
.set rx_save_slave_64,  rb10

.set ra_64,             ra11 # 4
.set rb_64,             rb11 # 4

.set rx_tw_shared,      ra15
.set rx_tw_unique,      rb15

.set ra_tw_re,          ra16 # 11
.set rb_tw_im,          rb16 # 11

##############################################################################
# Dual-use registers

.set rb_STAGES,         rb_64+0
.set rb_0xF0,           rb_64+1
.set rb_0x40,           rb_64+2

.set ra_vpm_lo,         ra_64+0
.set ra_vpm_hi,         ra_64+1
.set rb_vpm_lo,         rb_vpm_32
.set rb_vpm_hi,         rb_vpm_48
.set ra_vdw_32,         ra_64+3
.set rb_vdw_32,         rb_64+3

##############################################################################
# Constants

mov rb_0x10,    0x10
mov r5rep,      0x1D0

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, rb_vpm, rb_vpm_16, rb_vpm_32, rb_vpm_48

##############################################################################
# Master/slave procedures

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_save_64, r:1f
body_ra_save_64
:1

proc rx_save_slave_64, r:1f
body_rx_save_slave_64
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_64 LOAD_REVERSED, r5

:pass_2
:pass_3
:pass_4
    body_pass_32 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_32, rx_save_slave_32
    mov.ifnz ra_save_64, rx_save_slave_64

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW48, TW64_BASE0
    load_tw rx_tw_shared, TW64, TW64_BASE1
    init_stage 6
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        mov r0, 0x200
        add ra_points, ra_points, r0

        mov r1, STAGES
        shr.setf -, ra_points, r1

        brr.allz -, r:pass_1
        nop
        mov r0, 0x200
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Dual-use registers

    mov ra_vpm_lo, rb_vpm
    mov ra_vpm_hi, rb_vpm_16

    mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
    mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))

    mov rb_STAGES, STAGES
    mov rb_0xF0, 0xF0
    mov rb_0x40, 0x40

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P2_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_2
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

        mov r0, 0x7FFF
        and.setf -, ra_points, r0

        brr.allnz -, r:pass_2
        nop
        mov r0, 0x100
        add.ifnz ra_points, ra_points, r0

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_2
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P3_STEP
    init_stage 5
    read_lin rb_0x10

    .rep i, 4
        brr ra_link_1, r:pass_3
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0
    .endr

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        mov r0, 0x100
        brr.allz -, r:pass_3
        add ra_points, ra_points, r0
        mov r0, (4-1)*4*8
        sub ra_link_1, ra_link_1, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 4

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P4_BASE
    load_tw rx_tw_unique, TW32+0, TW32_P4_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P4_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P4_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_4
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_4
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

##############################################################################
# Macro baseline

.include "gpu_fft.qinc"

##############################################################################
# Redefining some macros

.if STAGES>16
.macro read_rev, stride
    add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx

    bit_rev 1,       rx_0x55555555  # 16 SIMD
    bit_rev 2,       rx_0x33333333
    bit_rev 4,       rx_0x0F0F0F0F
    bit_rev 8,       rx_0x00FF00FF
    bit_rev rb_0x10, rx_0x0000FFFF

    shr r0, r0, 32-STAGES-3 # r0 = re = {idx[0:STAGES-1], 1'b0, 2'b0}
    add r1, r0, 4           # r1 = im = {idx[0:STAGES-1], 1'b1, 2'b0}

    interleave

    add t0s, ra_addr_x, r0
    add t0s, ra_addr_x, r1
.endm
.endif

.if STAGES>17
.macro body_ra_save_16, arg_vpm, arg_vdw
    write_vpm_16 arg_vpm

    mov -, vw_wait

    .rep i, 7
        mov -, sacq(i+9) # Master waits for slave
        mov -, srel(i+1) # Master releases slave
    .endr

    mov r0, arg_vdw
    add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr

    mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
    mov r3, PASS16_STRIDE

    .rep i, 16
        add r0, r0, r2; mov vw_setup, r0
        add r1, r1, r3; mov vw_addr,  r1
    .endr

    bra -, ra_link_1
    nop
    nop
    nop
.endm
.endif

.if STAGES>18
.macro body_ra_save_32
    write_vpm_32

    mov -, vw_wait

    .rep i, 7
        mov -, sacq(i+9) # Master waits for slave
        mov -, srel(i+1) # Master releases slave
    .endr

    mov r0, ra_vdw_32
    add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr

    mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
    mov r3, PASS32_STRIDE

    .rep i, 32
        add r0, r0, r2; mov vw_setup, r0
        add r1, r1, r3; mov vw_addr,  r1
    .endr

    bra -, ra_link_1
    nop
    nop
    nop
.endm
.endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 8

.include "gpu_fft.qinc"

##############################################################################
# Twiddles: src

.set TW16_P1_BASE,  0   # rx_tw_shared
.set TW16_P2_STEP,  1

.set TW16_P2_BASE,  0   # rx_tw_unique

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW16,      1  # 5

##############################################################################
# Registers

.set ra_link_1,         ra0
#                       rb0
.set ra_save_ptr,       ra1
#                       rb1
.set ra_temp,           ra2
#                       rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_16,        ra4
.set rx_save_slave_16,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
#                       rb7

.set rx_tw_shared,      ra8
.set rx_tw_unique,      rb8

.set ra_tw_re,          ra9 # 6
.set rb_tw_im,          rb9 # 6

.set ra_vpm,            ra27
.set rb_vpm,            rb27
.set ra_vdw,            ra28
.set rb_vdw,            rb28

.set rx_0x5555,         ra29
.set rx_0x3333,         ra30
.set rx_0x0F0F,         ra31

.set rb_0x40,           rb30
.set rb_0x80,           rb31

##############################################################################
# Register alias

.set ra_link_0, ra_save_16

##############################################################################
# Constants

mov rb_0x40,    0x40
mov rb_0x80,    0x80

mov rx_0x5555,  0x5555
mov rx_0x3333,  0x3333
mov rx_0x0F0F,  0x0F0F

mov ra_vdw, vdw_setup_0(16, 16, dma_h32( 0,0))
mov rb_vdw, vdw_setup_0(16, 16, dma_h32(16,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm, rb_vpm, -, -

##############################################################################
# Master/slave procedures

proc ra_save_16, r:1f
body_ra_save_16 ra_vpm, ra_vdw
:1

proc rx_save_slave_16, r:1f
body_rx_save_slave_16 ra_vpm
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Redefining this macro

.macro read_rev, stride
    add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx

    bit_rev 1, rx_0x5555    # 16 SIMD
    bit_rev 2, rx_0x3333
    bit_rev 4, rx_0x0F0F

    shl r0, r0, 3           # {idx[0:7], 1'b0, 2'b0}
    add r1, r0, 4           # {idx[0:7], 1'b1, 2'b0}

    add t0s, ra_addr_x, r0
    add t0s, ra_addr_x, r1
.endm

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
:pass_2
    brr -, r:fft_16
    nop;        ldtmu0
    mov r0, r4; ldtmu0
    mov r1, r4

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_16, rx_save_slave_16

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_P1_BASE
    init_stage 4
    read_rev rb_0x80
    read_rev rb_0x80

.rep i, 2
    brr ra_link_1, r:pass_1
    nop
    mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
    mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
.endr

    bra ra_link_1, ra_sync
    nop
    nop
    nop

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P2_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    init_stage 4
    read_lin rb_0x80
    read_lin rb_0x80

    brr ra_link_1, r:pass_2
    nop
    mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
    mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw

    next_twiddles_16

    brr ra_link_1, r:pass_2
    nop
    mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
    mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw

    bra ra_link_1, ra_sync
    nop
    nop
    nop

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 18

.include "gpu_fft_ex.qinc"

##############################################################################
# Twiddles: src

.set TW32_BASE,     0   # rx_tw_shared
.set TW16_BASE,     1
.set TW16_P2_STEP,  2
.set TW16_P3_STEP,  3
.set TW32_P4_STEP,  4
.set TW16_P4_STEP,  5

.set TW32_P4_BASE,  0   # rx_tw_unique
.set TW16_P4_BASE,  1

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2

##############################################################################
# Registers

.set ra_link_0,         ra0
.set rb_vdw_16,         rb0
.set ra_save_ptr,       ra1
.set rb_vdw_32,         rb1
.set ra_temp,           ra2
.set rb_vpm_lo,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_16,        ra4
.set rx_save_slave_16,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_hi,         rb7
.set ra_link_1,         ra8
.set rb_STAGES,         rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_32,        ra10
.set rx_save_slave_32,  rb10

.set rx_tw_shared,      ra11
.set rx_tw_unique,      rb11

.set ra_tw_re,          ra12 # 9
.set rb_tw_im,          rb12 # 9

.set ra_vpm_lo,         ra25
.set ra_vpm_hi,         ra26
.set ra_vdw_16,         ra27
.set ra_vdw_32,         ra28

.set rx_0x55555555,     ra29
.set rx_0x33333333,     ra30
.set rx_0x0F0F0F0F,     ra31
.set rx_0x00FF00FF,     rb24
.set rx_0x0000FFFF,     rb25

.set rb_0x10,           rb26
.set rb_0x40,           rb27
.set rb_0x80,           rb28
.set rb_0xF0,           rb29
.set rb_0x100,          rb30
.set rb_0x1FFF,         rb31

##############################################################################
# Constants

mov rb_STAGES,  STAGES

mov rb_0x10,    0x10
mov rb_0x40,    0x40
mov rb_0x80,    0x80
mov rb_0xF0,    0xF0
mov rb_0x100,   0x100
mov rb_0x1FFF,  0x1FFF

mov rx_0x55555555, 0x55555555
mov rx_0x33333333, 0x33333333
mov rx_0x0F0F0F0F, 0x0F0F0F0F
mov rx_0x00FF00FF, 0x00FF00FF
mov rx_0x0000FFFF, 0x0000FFFF

mov ra_vdw_16, vdw_setup_0( 1, 16, dma_h32( 0,0))
mov rb_vdw_16, vdw_setup_0( 1, 16, dma_h32(32,0))
mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm_lo, ra_vpm_hi, rb_vpm_lo, rb_vpm_hi

##############################################################################
# Master/slave procedures

proc ra_save_16, r:1f
body_ra_save_16 ra_vpm_lo, ra_vdw_16
:1

proc rx_save_slave_16, r:1f
body_rx_save_slave_16 ra_vpm_lo
:1

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_32 LOAD_REVERSED

:pass_2
:pass_3
    body_pass_16 LOAD_STRAIGHT

:pass_4
    body_pass_32 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_16, rx_save_slave_16
    mov.ifnz ra_save_32, rx_save_slave_32

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    init_stage 5
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    init_stage 4
    read_lin rb_0x80

        brr ra_link_1, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x80

        and.setf -, ra_points, rb_0x1FFF

        brr.allnz -, r:pass_2
        nop
        nop
        add.ifnz ra_points, ra_points, rb_0x80

        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    init_stage 4
    read_lin rb_0x80

    .rep i, 4
        brr ra_link_1, r:pass_3
        nop
        nop
        add ra_points, ra_points, rb_0x80
    .endr

        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_3
        mov r0, 3*4*8
        sub ra_link_1, ra_link_1, r0
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 4

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P4_BASE
    load_tw rx_tw_unique, TW32+0, TW32_P4_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P4_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P4_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_4
        nop
        nop
        add ra_points, ra_points, rb_0x100

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_4
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                               # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 11

.include "gpu_fft.qinc"

##############################################################################
# Twiddles: src

.set TW64_P1_BASE0, 0   # rx_tw_shared
.set TW64_P1_BASE1, 1
.set TW32_P1_BASE,  2
.set TW16_P1_BASE,  3
.set TW32_P2_STEP,  4
.set TW16_P2_STEP,  5

.set TW32_P2_BASE,  0   # rx_tw_unique
.set TW16_P2_BASE,  1

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2
.set TW48,      9  # 1
.set TW64,      10 # 1

##############################################################################
# Registers

.set ra_link_0,         ra0
.set rb_vpm,            rb0
.set ra_save_ptr,       ra1
.set rb_vpm_16,         rb1
.set ra_temp,           ra2
.set rb_vpm_32,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_32,        ra4
.set rx_save_slave_32,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_48,         rb7
.set ra_link_1,         ra8
#                       rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_64,        ra10
.set rx_save_slave_64,  rb10

.set ra_64,             ra11 # 4
.set rb_64,             rb11 # 4

.set rx_tw_shared,      ra15
.set rx_tw_unique,      rb15

.set ra_tw_re,          ra16 # 11
.set rb_tw_im,          rb16 # 11

.set rx_0x5555,         ra28
.set rx_0x3333,         ra29
.set rx_0x0F0F,         ra30
.set rx_0x00FF,         ra31

.set rb_0x10,           rb28
.set rb_0x40,           rb29
.set rb_0xF0,           rb30
.set rb_0x1D0,          rb31

##############################################################################
# Dual-use registers

.set ra_vpm_lo,         ra_64+0
.set ra_vpm_hi,         ra_64+1
.set rb_vpm_lo,         rb_vpm_32
.set rb_vpm_hi,         rb_vpm_48
.set ra_vdw_32,         ra_64+2
.set rb_vdw_32,         rb_64+2

##############################################################################
# Constants

mov rb_0x10,    0x10
mov rb_0x40,    0x40
mov rb_0xF0,    0xF0
mov rb_0x1D0,   0x1D0

mov rx_0x5555,  0x5555
mov rx_0x3333,  0x3333
mov rx_0x0F0F,  0x0F0F
mov rx_0x00FF,  0x00FF

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, rb_vpm, rb_vpm_16, rb_vpm_32, rb_vpm_48

##############################################################################
# Master/slave procedures

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_save_64, r:1f
body_ra_save_64 rb_0x40
:1

proc rx_save_slave_64, r:1f
body_rx_save_slave_64
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_64 LOAD_REVERSED, rb_0x1D0

:pass_2
    body_pass_32 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_32, rx_save_slave_32
    mov.ifnz ra_save_64, rx_save_slave_64

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_P1_BASE
    load_tw rx_tw_shared, TW32+0, TW32_P1_BASE
    load_tw rx_tw_shared, TW48,   TW64_P1_BASE0
    load_tw rx_tw_shared, TW64,   TW64_P1_BASE1
    init_stage 6
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        mov r0, 0x200
        add ra_points, ra_points, r0

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_1
        nop
        mov r0, 0x200
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Dual-use registers

    mov ra_vpm_lo, rb_vpm
    mov ra_vpm_hi, rb_vpm_16

    mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
    mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P2_BASE
    load_tw rx_tw_unique, TW32+0, TW32_P2_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P2_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_2
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_2
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 15

.include "gpu_fft.qinc"

##############################################################################
# Twiddles: src

.set TW32_BASE,     0   # rx_tw_shared
.set TW16_BASE,     1
.set TW32_P2_STEP,  2
.set TW16_P2_STEP,  3
.set TW32_P3_STEP,  4
.set TW16_P3_STEP,  5

.set TW32_P3_BASE,  0   # rx_tw_unique
.set TW16_P3_BASE,  1

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2

##############################################################################
# Registers

.set ra_link_0,         ra0
#                       rb0
.set ra_save_ptr,       ra1
.set rb_vdw_32,         rb1
.set ra_temp,           ra2
.set rb_vpm_lo,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_32,        ra4
.set rx_save_slave_32,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_hi,         rb7
.set ra_link_1,         ra8
#                       rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9

.set rx_tw_shared,      ra10
.set rx_tw_unique,      rb10

.set ra_tw_re,          ra11 # 9
.set rb_tw_im,          rb11 # 9

.set ra_vpm_lo,         ra26
.set ra_vpm_hi,         ra27
.set ra_vdw_32,         ra28

.set rx_0x5555,         ra29
.set rx_0x3333,         ra30
.set rx_0x0F0F,         ra31

.set rx_0x00FF,         rb26
.set rb_0x10,           rb27
.set rb_0x40,           rb28
.set rb_0x80,           rb29
.set rb_0xF0,           rb30
.set rb_0x100,          rb31

##############################################################################
# Constants

mov rb_0x10,    0x10
mov rb_0x40,    0x40
mov rb_0x80,    0x80
mov rb_0xF0,    0xF0
mov rb_0x100,   0x100

mov rx_0x5555,  0x5555
mov rx_0x3333,  0x3333
mov rx_0x0F0F,  0x0F0F
mov rx_0x00FF,  0x00FF

mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm_lo, ra_vpm_hi, rb_vpm_lo, rb_vpm_hi

##############################################################################
# Master/slave procedures

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_32 LOAD_REVERSED

:pass_2
:pass_3
    body_pass_32 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_32, rx_save_slave_32

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    init_stage 5
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P2_STEP
    init_stage 5
    read_lin rb_0x10

    .rep i, 4
        brr ra_link_1, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x100
    .endr

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_2
        mov r0, 3*4*8
        sub ra_link_1, ra_link_1, r0
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P3_BASE
    load_tw rx_tw_unique, TW32+0, TW32_P3_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P3_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_3
        nop
        nop
        add ra_points, ra_points, rb_0x100

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_3
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 22

.include "gpu_fft_2048k.qinc"

##############################################################################
# Twiddles: src

.set TW64_BASE0,    0   # rx_tw_shared
.set TW64_BASE1,    1
.set TW32_BASE,     2
.set TW16_BASE,     3

.set TW48_P2_STEP,  4
.set TW64_P2_STEP,  5

.set TW32_P2_STEP,  6
.set TW16_P2_STEP,  7
.set TW32_P3_STEP,  8
.set TW16_P3_STEP,  9
.set TW32_P4_STEP, 10
.set TW16_P4_STEP, 11

.set TW32_P4_BASE,  0   # rx_tw_unique
.set TW16_P4_BASE,  1

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2
.set TW48,      9  # 2
.set TW64,      11 # 2
.set TW48_STEP, 13 # 1
.set TW64_STEP, 14 # 1

##############################################################################
# Registers

.set ra_link_0,         ra0
.set rb_vpm,            rb0
.set ra_save_ptr,       ra1
.set rb_vpm_16,         rb1
.set ra_temp,           ra2
.set rb_vpm_32,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_32,        ra4
.set rx_save_slave_32,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_48,         rb7
.set ra_link_1,         ra8
.set rb_0x10,           rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_64,        ra10
.set rx_save_slave_64,  rb10

.set ra_64,             ra11 # 4
.set rb_64,             rb11 # 4

.set rx_tw_shared,      ra15
.set rx_tw_unique,      rb15

.set ra_tw_re,          ra16 # 15
.set rb_tw_im,          rb16 # 15

##############################################################################
# Dual-use registers

.set rb_STAGES,         rb_64+0
.set rb_0xF0,           rb_64+1
.set rb_0x40,           rb_64+2

.set ra_vpm_lo,         ra_64+0
.set ra_vpm_hi,         ra_64+1
.set rb_vpm_lo,         rb_vpm_32
.set rb_vpm_hi,         rb_vpm_48
.set ra_vdw_32,         ra_64+3
.set rb_vdw_32,         rb_64+3

##############################################################################
# Constants

mov rb_0x10,    0x10
mov r5rep,      0x1D0

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, rb_vpm, rb_vpm_16, rb_vpm_32, rb_vpm_48

##############################################################################
# Master/slave procedures

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_save_64, r:1f
body_ra_save_64
:1

proc rx_save_slave_64, r:1f
body_rx_save_slave_64
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_64 LOAD_REVERSED, r5
:pass_2
    body_pass_64 LOAD_STRAIGHT, r5
:pass_3
:pass_4
    body_pass_32 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_32, rx_save_slave_32
    mov.ifnz ra_save_64, rx_save_slave_64

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW48+0, TW64_BASE0
    load_tw rx_tw_shared, TW64+0, TW64_BASE1
    init_stage 6
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        mov r0, 0x200
        add ra_points, ra_points, r0

        mov r1, STAGES
        shr.setf -, ra_points, r1

        brr.allz -, r:pass_1
        nop
        mov r0, 0x200
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW48+0, TW64_BASE0
    load_tw rx_tw_shared, TW64+0, TW64_BASE1
    mov ra_tw_re+TW48+1, 0; mov rb_tw_im+TW48+1, 0
    mov ra_tw_re+TW64+1, 0; mov rb_tw_im+TW64+1, 0
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P2_STEP
    load_tw rx_tw_shared, TW48_STEP, TW48_P2_STEP
    load_tw rx_tw_shared, TW64_STEP, TW64_P2_STEP
    init_stage 6
    read_lin rb_0x10

        brr ra_link_1, r:pass_2
        nop
        mov r0, 0x200
        add ra_points, ra_points, r0

        mov r0, 0xFFFF
        and.setf -, ra_points, r0

        brr.allnz -, r:pass_2
        nop
        mov r0, 0x200
        add.ifnz ra_points, ra_points, r0

        rotate TW64, TW64_STEP
        rotate TW48, TW48_STEP
        next_twiddles_32
        next_twiddles_16

        mov r1, STAGES
        shr.setf -, ra_points, r1

        brr.allz -, r:pass_2
        nop
        mov r0, 0x200
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Dual-use registers

    mov ra_vpm_lo, rb_vpm
    mov ra_vpm_hi, rb_vpm_16

    mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
    mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))

    mov rb_STAGES, STAGES
    mov rb_0xF0, 0xF0
    mov rb_0x40, 0x40

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P3_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_3
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

        mov r0, 0x3FF
        and.setf -, ra_points, r0

        brr.allnz -, r:pass_3
        nop
        mov r0, 0x100
        add.ifnz ra_points, ra_points, r0

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_3
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 4

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P4_BASE
    load_tw rx_tw_unique, TW32+0, TW32_P4_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P4_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P4_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_4
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_4
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # BCM2835 "GPU_FFT" release 2.0
#
# Copyright (c) 2014, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set rb_offsets_re,     rb0 # 8
.set rb_offsets_im,     rb8 # 8
.set rb_0x10,           rb16
.set rb_X_STRIDE,       rb17
.set rb_Y_STRIDE_SRC,   rb18
.set rb_Y_STRIDE_DST,   rb19
.set rb_NX,             rb20
.set rb_NY,             rb21

.set ra_x,              ra0
.set ra_y,              ra1
.set ra_src_base,       ra2
.set ra_dst_base,       ra3
.set ra_src_cell,       ra4
.set ra_dst_cell,       ra5
.set ra_vdw_stride,     ra6

    mov t0s, unif               # src->vc_msg
    ldtmu0                      # r4 = vc_unifs
    add t0s, r4, 3*4            # 3rd unif
    ldtmu0                      # r4 = src->in
    add ra_src_base, r4, unif   # optional offset

    mov t0s, unif               # dst->vc_msg
    ldtmu0                      # r4 = vc_unifs
    add t0s, r4, 3*4            # 3rd unif
    ldtmu0                      # r4 = src->in
    add ra_dst_base, r4, unif   # optional offset

    mov rb_Y_STRIDE_SRC, unif
    mov rb_Y_STRIDE_DST, unif
    mov rb_NX,           unif
    mov rb_NY,           unif

    mov rb_X_STRIDE, 2*4        # sizeof complex
    mov rb_0x10, 0x10

    mov r0, vdw_setup_1(0)
    add r0, r0, rb_Y_STRIDE_DST
    mov r1, 16*4
    sub ra_vdw_stride, r0, r1

    nop; mul24 r0, elem_num, rb_X_STRIDE
.rep i, 8
    mov rb_offsets_re+i, r0
    add rb_offsets_im+i, r0, 4
    add r0, r0, rb_Y_STRIDE_SRC
.endr

    mov ra_y, 0
:outer
    mov ra_x, 0
:inner

    nop; mul24 r1, ra_y, rb_Y_STRIDE_SRC
    nop; mul24 r0, ra_x, rb_X_STRIDE
    add r0, r0, r1
    add ra_src_cell, ra_src_base, r0

    nop; mul24 r1, ra_x, rb_Y_STRIDE_DST
    nop; mul24 r0, ra_y, rb_X_STRIDE
    add r0, r0, r1
    add ra_dst_cell, ra_dst_base, r0

    mov vw_setup, vpm_setup(16, 1, v32(0,0))

        add t0s, ra_src_cell, rb_offsets_re
        add t1s, ra_src_cell, rb_offsets_im
    .rep i, 7
        add t0s, ra_src_cell, rb_offsets_re+1+i
        add t1s, ra_src_cell, rb_offsets_im+1+i
        ldtmu0
        mov vpm, r4
        ldtmu1
        mov vpm, r4
    .endr
        ldtmu0
        mov vpm, r4
        ldtmu1
        mov vpm, r4

    mov vw_setup, vdw_setup_0(16, 16, dma_h32(0,0))
    mov vw_setup, ra_vdw_stride
    mov vw_addr, ra_dst_cell
    mov -, vw_wait

    add ra_x, ra_x, rb_0x10
    nop
    sub.setf -, ra_x, rb_NX
    brr.allnz -, r:inner
    nop
    nop
    nop

    add ra_y, ra_y, 8
    nop
    sub.setf -, ra_y, rb_NY
    brr.allnz -, r:outer
    nop
    nop
    nop

    mov interrupt, 1
    nop; nop; thrend
    nop
    nop
               # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 12

.include "gpu_fft.qinc"

##############################################################################
# Twiddles: src

.set TW16_BASE,     0   # rx_tw_shared
.set TW16_P2_STEP,  1
.set TW16_P3_STEP,  2

.set TW16_P3_BASE,  0   # rx_tw_unique

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW16,      1  # 5

##############################################################################
# Registers

.set ra_link_1,         ra0
#                       rb0
.set ra_save_ptr,       ra1
#                       rb1
.set ra_temp,           ra2
#                       rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_16,        ra4
.set rx_save_slave_16,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
#                       rb7

.set rx_tw_shared,      ra8
.set rx_tw_unique,      rb8

.set ra_tw_re,          ra9 # 6
.set rb_tw_im,          rb9 # 6

.set ra_vpm,            ra26
.set rb_vpm,            rb26
.set ra_vdw,            ra27
.set rb_vdw,            rb27

.set rx_0x5555,         ra28
.set rx_0x3333,         ra29
.set rx_0x0F0F,         ra30
.set rx_0x00FF,         ra31

.set rb_0x20,           rb29
.set rb_0x40,           rb30
.set rb_0x80,           rb31

##############################################################################
# Register alias

.set ra_link_0, ra_save_16

##############################################################################
# Constants

mov rb_0x20,    0x20
mov rb_0x40,    0x40
mov rb_0x80,    0x80

mov rx_0x5555,  0x5555
mov rx_0x3333,  0x3333
mov rx_0x0F0F,  0x0F0F
mov rx_0x00FF,  0x00FF

mov ra_vdw, vdw_setup_0(16, 16, dma_h32( 0,0))
mov rb_vdw, vdw_setup_0(16, 16, dma_h32(16,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm, rb_vpm, -, -

##############################################################################
# Macros

.macro swap_vpm_vdw
    mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
    mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
.endm

.macro swizzle
    mov.setf  -, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
    mov r2, r0; mov.ifnz r0, r0 << 6
    mov r3, r1; mov.ifnz r1, r1 << 6
    mov.setf  -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
    nop; mov.ifnz r0, r2 >> 6
    nop; mov.ifnz r1, r3 >> 6
.endm

##############################################################################
# Master/slave procedures

proc ra_save_16, r:1f
body_ra_save_16 ra_vpm, ra_vdw
:1

proc rx_save_slave_16, r:1f
body_rx_save_slave_16 ra_vpm
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    read_rev rb_0x80
    nop;        ldtmu0
    mov r0, r4; ldtmu0
    mov r1, r4
    swizzle
    brr -, r:fft_16
    interleave

:pass_2
:pass_3
    read_lin rb_0x80
    brr -, r:fft_16
    nop;        ldtmu0
    mov r0, r4; ldtmu0
    mov r1, r4

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_16, rx_save_slave_16

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    init_stage 4
    read_rev rb_0x80

        brr ra_link_1, r:pass_1
        swap_vpm_vdw
        add ra_points, ra_points, rb_0x80

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_1
        swap_vpm_vdw
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    init_stage 4
    read_lin rb_0x80

    .rep i, 2
        brr ra_link_1, r:pass_2
        swap_vpm_vdw
        add ra_points, ra_points, rb_0x80
    .endr

        sub ra_link_1, ra_link_1, rb_0x20
        next_twiddles_16
        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_2
        swap_vpm_vdw
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P3_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    init_stage 4
    read_lin rb_0x80

        brr ra_link_1, r:pass_3
        swap_vpm_vdw
        add ra_points, ra_points, rb_0x80

        next_twiddles_16
        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_3
        swap_vpm_vdw
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 9

.include "gpu_fft.qinc"

##############################################################################
# Twiddles: src

.set TW32_P1_BASE,  0   # rx_tw_shared
.set TW16_P1_BASE,  1
.set TW16_P2_STEP,  2

.set TW16_P2_BASE,  0   # rx_tw_unique

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2

##############################################################################
# Registers

.set ra_link_0,         ra0
.set rb_vdw_16,         rb0
.set ra_save_ptr,       ra1
.set rb_vdw_32,         rb1
.set ra_temp,           ra2
.set rb_vpm_lo,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_16,        ra4
.set rx_save_slave_16,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_hi,         rb7
.set ra_link_1,         ra8
#                       rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_32,        ra10
.set rx_save_slave_32,  rb10

.set rx_tw_shared,      ra11
.set rx_tw_unique,      rb11

.set ra_tw_re,          ra12 # 9
.set rb_tw_im,          rb12 # 9

.set ra_vpm_lo,         ra24
.set ra_vpm_hi,         ra25
.set ra_vdw_16,         ra26
.set ra_vdw_32,         ra27

.set rx_0x5555,         ra28
.set rx_0x3333,         ra29
.set rx_0x0F0F,         ra30
.set rx_0x00FF,         ra31

.set rb_0x10,           rb28
.set rb_0x40,           rb29
.set rb_0x80,           rb30
.set rb_0xF0,           rb31

##############################################################################
# Constants

mov rb_0x10,    0x10
mov rb_0x40,    0x40
mov rb_0x80,    0x80
mov rb_0xF0,    0xF0

mov rx_0x5555,  0x5555
mov rx_0x3333,  0x3333
mov rx_0x0F0F,  0x0F0F
mov rx_0x00FF,  0x00FF

mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm_lo, ra_vpm_hi, rb_vpm_lo, rb_vpm_hi

##############################################################################
# Master/slave procedures

proc ra_save_16, r:1f
body_ra_save_16 ra_vpm_lo, ra_vdw_16
:1

proc rx_save_slave_16, r:1f
body_rx_save_slave_16 ra_vpm_lo
:1

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_32 LOAD_REVERSED

:pass_2
    body_pass_16 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_16, rx_save_slave_16
    mov.ifnz ra_save_32, rx_save_slave_32

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_P1_BASE
    load_tw rx_tw_shared, TW32+0, TW32_P1_BASE
    init_stage 5
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        nop
        nop

        brr ra_link_1, r:pass_1
        nop
        nop
        nop

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P2_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    init_stage 4
    read_lin rb_0x80

        brr ra_link_1, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x80

        next_twiddles_16

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 19

.include "gpu_fft_ex.qinc"

##############################################################################
# Twiddles: src

.set TW32_BASE,     0   # rx_tw_shared
.set TW16_BASE,     1
.set TW16_P2_STEP,  2
.set TW32_P3_STEP,  3
.set TW16_P3_STEP,  4
.set TW32_P4_STEP,  5
.set TW16_P4_STEP,  6

.set TW32_P4_BASE,  0   # rx_tw_unique
.set TW16_P4_BASE,  1

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2

##############################################################################
# Registers

.set ra_link_0,         ra0
.set rb_vdw_16,         rb0
.set ra_save_ptr,       ra1
.set rb_vdw_32,         rb1
.set ra_temp,           ra2
.set rb_vpm_lo,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_16,        ra4
.set rx_save_slave_16,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_hi,         rb7
.set ra_link_1,         ra8
.set rb_STAGES,         rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_32,        ra10
.set rx_save_slave_32,  rb10

.set rx_tw_shared,      ra11
.set rx_tw_unique,      rb11

.set ra_tw_re,          ra12 # 9
.set rb_tw_im,          rb12 # 9

.set ra_vpm_lo,         ra25
.set ra_vpm_hi,         ra26
.set ra_vdw_16,         ra27
.set ra_vdw_32,         ra28

.set rx_0x55555555,     ra29
.set rx_0x33333333,     ra30
.set rx_0x0F0F0F0F,     ra31
.set rx_0x00FF00FF,     rb25
.set rx_0x0000FFFF,     rb26

.set rb_0x10,           rb27
.set rb_0x40,           rb28
.set rb_0x80,           rb29
.set rb_0xF0,           rb30
.set rb_0x100,          rb31

##############################################################################
# Constants

mov rb_STAGES,  STAGES

mov rb_0x10,    0x10
mov rb_0x40,    0x40
mov rb_0x80,    0x80
mov rb_0xF0,    0xF0
mov rb_0x100,   0x100

mov rx_0x55555555, 0x55555555
mov rx_0x33333333, 0x33333333
mov rx_0x0F0F0F0F, 0x0F0F0F0F
mov rx_0x00FF00FF, 0x00FF00FF
mov rx_0x0000FFFF, 0x0000FFFF

mov ra_vdw_16, vdw_setup_0(1, 16, dma_h32( 0,0))
mov rb_vdw_16, vdw_setup_0(1, 16, dma_h32(32,0))
mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm_lo, ra_vpm_hi, rb_vpm_lo, rb_vpm_hi

##############################################################################
# Master/slave procedures

proc ra_save_16, r:1f
body_ra_save_16 ra_vpm_lo, ra_vdw_16
:1

proc rx_save_slave_16, r:1f
body_rx_save_slave_16 ra_vpm_lo
:1

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_32 LOAD_REVERSED

:pass_2
    body_pass_16 LOAD_STRAIGHT

:pass_3
:pass_4
    body_pass_32 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_16, rx_save_slave_16
    mov.ifnz ra_save_32, rx_save_slave_32

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    init_stage 5
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    init_stage 4
    read_lin rb_0x80

        brr ra_link_1, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x80

        mov r0, 0x3FFF
        and.setf -, ra_points, r0

        brr.allnz -, r:pass_2
        nop
        nop
        add.ifnz ra_points, ra_points, rb_0x80

        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P3_STEP
    init_stage 5
    read_lin rb_0x10

    .rep i, 4
        brr ra_link_1, r:pass_3
        nop
        nop
        add ra_points, ra_points, rb_0x100
    .endr

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_3
        mov r0, 3*4*8
        sub ra_link_1, ra_link_1, r0
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 4

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P4_BASE
    load_tw rx_tw_unique, TW32+0, TW32_P4_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P4_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P4_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_4
        nop
        nop
        add ra_points, ra_points, rb_0x100

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_4
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
        # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 16

.include "gpu_fft.qinc"

##############################################################################
# Twiddles: src

.set TW64_BASE0,    0 # rx_tw_shared
.set TW64_BASE1,    1
.set TW32_BASE,     2
.set TW16_BASE,     3
.set TW32_P2_STEP,  4
.set TW16_P2_STEP,  5
.set TW32_P3_STEP,  6
.set TW16_P3_STEP,  7

.set TW32_P3_BASE,  0 # rx_tw_unique
.set TW16_P3_BASE,  1

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2
.set TW48,      9  # 1
.set TW64,      10 # 1

##############################################################################
# Registers

.set ra_link_0,         ra0
.set rb_vpm,            rb0
.set ra_save_ptr,       ra1
.set rb_vpm_16,         rb1
.set ra_temp,           ra2
.set rb_vpm_32,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_32,        ra4
.set rx_save_slave_32,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_48,         rb7
.set ra_link_1,         ra8
.set rb_0x10,           rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_64,        ra10
.set rx_save_slave_64,  rb10

.set ra_64,             ra11 # 4
.set rb_64,             rb11 # 4

.set rx_tw_shared,      ra15
.set rx_tw_unique,      rb15

.set ra_tw_re,          ra16 # 11
.set rb_tw_im,          rb16 # 11

.set rx_0x5555,         ra30
.set rx_0x3333,         rb30
.set rx_0x0F0F,         ra31
.set rx_0x00FF,         rb31

##############################################################################
# Dual-use registers

.set rb_STAGES,         rb_0x10

.set rb_3x4x8,          rb_64+0
.set rb_0xF0,           rb_64+1
.set rb_0x40,           rb_64+2

.set ra_vpm_lo,         ra_64+0
.set ra_vpm_hi,         ra_64+1
.set rb_vpm_lo,         rb_vpm_32
.set rb_vpm_hi,         rb_vpm_48
.set ra_vdw_32,         ra_64+3
.set rb_vdw_32,         rb_64+3

##############################################################################
# Constants

mov rb_0x10,    0x10
mov r5rep,      0x1D0

mov rx_0x5555,  0x5555
mov rx_0x3333,  0x3333
mov rx_0x0F0F,  0x0F0F
mov rx_0x00FF,  0x00FF

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, rb_vpm, rb_vpm_16, rb_vpm_32, rb_vpm_48

##############################################################################
# Master/slave procedures

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_save_64, r:1f
    mov r0, 0x40
body_ra_save_64 r0
:1

proc rx_save_slave_64, r:1f
body_rx_save_slave_64
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_64 LOAD_REVERSED, r5

:pass_2
:pass_3
    body_pass_32 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_32, rx_save_slave_32
    mov.ifnz ra_save_64, rx_save_slave_64

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW48, TW64_BASE0
    load_tw rx_tw_shared, TW64, TW64_BASE1
    init_stage 6
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        mov r0, 0x200
        add ra_points, ra_points, r0

        mov r1, STAGES
        shr.setf -, ra_points, r1

        brr.allz -, r:pass_1
        nop
        mov r0, 0x200
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Dual-use registers

    mov ra_vpm_lo, rb_vpm
    mov ra_vpm_hi, rb_vpm_16

    mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
    mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))

    mov rb_3x4x8, 3*4*8
    mov rb_0xF0, 0xF0
    mov rb_0x40, 0x40

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P2_STEP
    init_stage 5
    read_lin rb_0x10

    .rep i, 4
        brr ra_link_1, r:pass_2
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0
    .endr

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_2
        mov r0, 0x100
        add ra_points, ra_points, r0
        sub ra_link_1, ra_link_1, rb_3x4x8

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P3_BASE
    load_tw rx_tw_unique, TW32+0, TW32_P3_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    load_tw rx_tw_shared, TW32_STEP, TW32_P3_STEP
    init_stage 5
    read_lin rb_0x10

        brr ra_link_1, r:pass_3
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

        next_twiddles_32
        next_twiddles_16

        shr.setf -, ra_points, rb_STAGES

        brr.allz -, r:pass_3
        nop
        mov r0, 0x100
        add ra_points, ra_points, r0

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                             # BCM2835 "GPU_FFT" release 3.0
#
# Copyright (c) 2015, Andrew Holme.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.set STAGES, 13

.include "gpu_fft.qinc"

##############################################################################
# Twiddles: src

.set TW32_BASE,     0   # rx_tw_shared
.set TW16_BASE,     1
.set TW16_P2_STEP,  2
.set TW16_P3_STEP,  3

.set TW16_P3_BASE,  0   # rx_tw_unique

##############################################################################
# Twiddles: dst

.set TW16_STEP, 0  # 1
.set TW32_STEP, 1  # 1
.set TW16,      2  # 5
.set TW32,      7  # 2

##############################################################################
# Registers

.set ra_link_0,         ra0
.set rb_vdw_16,         rb0
.set ra_save_ptr,       ra1
.set rb_vdw_32,         rb1
.set ra_temp,           ra2
.set rb_vpm_lo,         rb2
.set ra_addr_x,         ra3
.set rb_addr_y,         rb3
.set ra_save_16,        ra4
.set rx_save_slave_16,  rb4
.set ra_load_idx,       ra5
.set rb_inst,           rb5
.set ra_sync,           ra6
.set rx_sync_slave,     rb6
.set ra_points,         ra7
.set rb_vpm_hi,         rb7
.set ra_link_1,         ra8
#                       rb8
.set ra_32_re,          ra9
.set rb_32_im,          rb9
.set ra_save_32,        ra10
.set rx_save_slave_32,  rb10

.set rx_tw_shared,      ra11
.set rx_tw_unique,      rb11

.set ra_tw_re,          ra12 # 9
.set rb_tw_im,          rb12 # 9

.set ra_vpm_lo,         ra25
.set ra_vpm_hi,         ra26
.set ra_vdw_16,         ra27
.set ra_vdw_32,         ra28

.set rx_0x5555,         ra29
.set rx_0x3333,         ra30
.set rx_0x0F0F,         ra31

.set rx_0x00FF,         rb26
.set rb_0x10,           rb27
.set rb_0x40,           rb28
.set rb_0x80,           rb29
.set rb_0xF0,           rb30
.set rb_0x100,          rb31

##############################################################################
# Constants

mov rb_0x10,    0x10
mov rb_0x40,    0x40
mov rb_0x80,    0x80
mov rb_0xF0,    0xF0
mov rb_0x100,   0x100

mov rx_0x5555,  0x5555
mov rx_0x3333,  0x3333
mov rx_0x0F0F,  0x0F0F
mov rx_0x00FF,  0x00FF

mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))

##############################################################################
# Twiddles: ptr

mov rx_tw_shared, unif
mov rx_tw_unique, unif

##############################################################################
# Instance

mov rb_inst, unif
inst_vpm rb_inst, ra_vpm_lo, ra_vpm_hi, rb_vpm_lo, rb_vpm_hi

##############################################################################
# Master/slave procedures

proc ra_save_16, r:1f
body_ra_save_16 ra_vpm_lo, ra_vdw_16
:1

proc rx_save_slave_16, r:1f
body_rx_save_slave_16 ra_vpm_lo
:1

proc ra_save_32, r:1f
body_ra_save_32
:1

proc rx_save_slave_32, r:1f
body_rx_save_slave_32
:1

proc ra_sync, r:1f
body_ra_sync
:1

proc rx_sync_slave, r:main
body_rx_sync_slave

##############################################################################
# Subroutines

:fft_16
    body_fft_16

:pass_1
    body_pass_32 LOAD_REVERSED

:pass_2
:pass_3
    body_pass_16 LOAD_STRAIGHT

##############################################################################
# Top level

:main
    mov.setf r0, rb_inst
    sub r0, r0, 1
    shl r0, r0, 5
    add.ifnz ra_sync, rx_sync_slave, r0
    mov.ifnz ra_save_16, rx_save_slave_16
    mov.ifnz ra_save_32, rx_save_slave_32

:loop
    mov.setf ra_addr_x, unif # Ping buffer or null
    mov      rb_addr_y, unif # Pong buffer or IRQ enable

    brr.allz -, r:end

##############################################################################
# Pass 1

    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW32+0, TW32_BASE
    init_stage 5
    read_rev rb_0x10

        brr ra_link_1, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_1
        nop
        nop
        add ra_points, ra_points, rb_0x100

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 2

    swap_buffers
    load_tw rx_tw_shared, TW16+3, TW16_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P2_STEP
    init_stage 4
    read_lin rb_0x80

    .rep i, 2
        brr ra_link_1, r:pass_2
        nop
        nop
        add ra_points, ra_points, rb_0x80
    .endr

        next_twiddles_16

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_2
        mov r0, 4*8
        sub ra_link_1, ra_link_1, r0
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################
# Pass 3

    swap_buffers
    load_tw rx_tw_unique, TW16+3, TW16_P3_BASE
    load_tw rx_tw_shared, TW16_STEP, TW16_P3_STEP
    init_stage 4
    read_lin rb_0x80

        brr ra_link_1, r:pass_3
        nop
        nop
        add ra_points, ra_points, rb_0x80

        next_twiddles_16

        shr.setf -, ra_points, STAGES

        brr.allz -, r:pass_3
        nop
        nop
        add ra_points, ra_points, rb_0x80

    bra ra_link_1, ra_sync
    nop
    ldtmu0
    ldtmu0

##############################################################################

    brr -, r:loop
    nop
    nop
    nop

:end
    exit rb_addr_y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      OBJS=main.o
BIN=hello_font.bin

LDFLAGS+=-lvgfont -lfreetype -lz

include ../Makefile.include

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        OS/2_c  p   VPCLT^     6cmap  l  Xcvt 9    fpgm  &`   gasp   H   glyftA  &  ~hdmx4!     Hhead T   6hheaEo  L   $hmtx	    0kernR    -loca=    maxpG:  ,    name    postZ/    prep;      h           :          :        _        :        :        d        M       0        l       	      	 p  	   t	  	  &
  	  

Y  	  &
  	  &
  	  
c  	  .
5  	  `
  	  s  	  0  	 &
{Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.Bitstream Vera SansBitstreamVeraSans-RomanRelease 1.10Copyright (c) 2003 by Bitstream, Inc.
All Rights Reserved.
Bitstream Vera is a trademark of Bitstream, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license ("Fonts") and associated documentation files (the "Font Software"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions:

The above copyright and trademark notices and this permission notice shall be included in all copies of one or more of the Font Software typefaces.

The Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing either the words "Bitstream" or the word "Vera".

This License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the "Bitstream Vera" names.

The Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself.

THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL BITSTREAM OR THE GNOME FOUNDATION BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.

Except as contained in this notice, the names of Gnome, the Gnome Foundation, and Bitstream Inc., shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Font Software without prior written authorization from the Gnome Foundation or Bitstream Inc., respectively. For further information, contact: fonts at gnome dot org.http://www.bitstream.com C o p y r i g h t   ( c )   2 0 0 3   b y   B i t s t r e a m ,   I n c .   A l l   R i g h t s   R e s e r v e d . B i t s t r e a m   V e r a   S a n s B i t s t r e a m V e r a S a n s - R o m a n R e l e a s e   1 . 1 0 C o p y r i g h t   ( c )   2 0 0 3   b y   B i t s t r e a m ,   I n c .  
 A l l   R i g h t s   R e s e r v e d .  
 B i t s t r e a m   V e r a   i s   a   t r a d e m a r k   o f   B i t s t r e a m ,   I n c .  
  
 P e r m i s s i o n   i s   h e r e b y   g r a n t e d ,   f r e e   o f   c h a r g e ,   t o   a n y   p e r s o n   o b t a i n i n g   a   c o p y   o f   t h e   f o n t s   a c c o m p a n y i n g   t h i s   l i c e n s e   ( " F o n t s " )   a n d   a s s o c i a t e d   d o c u m e n t a t i o n   f i l e s   ( t h e   " F o n t   S o f t w a r e " ) ,   t o   r e p r o d u c e   a n d   d i s t r i b u t e   t h e   F o n t   S o f t w a r e ,   i n c l u d i n g   w i t h o u t   l i m i t a t i o n   t h e   r i g h t s   t o   u s e ,   c o p y ,   m e r g e ,   p u b l i s h ,   d i s t r i b u t e ,   a n d / o r   s e l l   c o p i e s   o f   t h e   F o n t   S o f t w a r e ,   a n d   t o   p e r m i t   p e r s o n s   t o   w h o m   t h e   F o n t   S o f t w a r e   i s   f u r n i s h e d   t o   d o   s o ,   s u b j e c t   t o   t h e   f o l l o w i n g   c o n d i t i o n s :  
  
 T h e   a b o v e   c o p y r i g h t   a n d   t r a d e m a r k   n o t i c e s   a n d   t h i s   p e r m i s s i o n   n o t i c e   s h a l l   b e   i n c l u d e d   i n   a l l   c o p i e s   o f   o n e   o r   m o r e   o f   t h e   F o n t   S o f t w a r e   t y p e f a c e s .  
  
 T h e   F o n t   S o f t w a r e   m a y   b e   m o d i f i e d ,   a l t e r e d ,   o r   a d d e d   t o ,   a n d   i n   p a r t i c u l a r   t h e   d e s i g n s   o f   g l y p h s   o r   c h a r a c t e r s   i n   t h e   F o n t s   m a y   b e   m o d i f i e d   a n d   a d d i t i o n a l   g l y p h s   o r   c h a r a c t e r s   m a y   b e   a d d e d   t o   t h e   F o n t s ,   o n l y   i f   t h e   f o n t s   a r e   r e n a m e d   t o   n a m e s   n o t   c o n t a i n i n g   e i t h e r   t h e   w o r d s   " B i t s t r e a m "   o r   t h e   w o r d   " V e r a " .  
  
 T h i s   L i c e n s e   b e c o m e s   n u l l   a n d   v o i d   t o   t h e   e x t e n t   a p p l i c a b l e   t o   F o n t s   o r   F o n t   S o f t w a r e   t h a t   h a s   b e e n   m o d i f i e d   a n d   i s   d i s t r i b u t e d   u n d e r   t h e   " B i t s t r e a m   V e r a "   n a m e s .  
  
 T h e   F o n t   S o f t w a r e   m a y   b e   s o l d   a s   p a r t   o f   a   l a r g e r   s o f t w a r e   p a c k a g e   b u t   n o   c o p y   o f   o n e   o r   m o r e   o f   t h e   F o n t   S o f t w a r e   t y p e f a c e s   m a y   b e   s o l d   b y   i t s e l f .  
  
 T H E   F O N T   S O F T W A R E   I S   P R O V I D E D   " A S   I S " ,   W I T H O U T   W A R R A N T Y   O F   A N Y   K I N D ,   E X P R E S S   O R   I M P L I E D ,   I N C L U D I N G   B U T   N O T   L I M I T E D   T O   A N Y   W A R R A N T I E S   O F   M E R C H A N T A B I L I T Y ,   F I T N E S S   F O R   A   P A R T I C U L A R   P U R P O S E   A N D   N O N I N F R I N G E M E N T   O F   C O P Y R I G H T ,   P A T E N T ,   T R A D E M A R K ,   O R   O T H E R   R I G H T .   I N   N O   E V E N T   S H A L L   B I T S T R E A M   O R   T H E   G N O M E   F O U N D A T I O N   B E   L I A B L E   F O R   A N Y   C L A I M ,   D A M A G E S   O R   O T H E R   L I A B I L I T Y ,   I N C L U D I N G   A N Y   G E N E R A L ,   S P E C I A L ,   I N D I R E C T ,   I N C I D E N T A L ,   O R   C O N S E Q U E N T I A L   D A M A G E S ,   W H E T H E R   I N   A N   A C T I O N   O F   C O N T R A C T ,   T O R T   O R   O T H E R W I S E ,   A R I S I N G   F R O M ,   O U T   O F   T H E   U S E   O R   I N A B I L I T Y   T O   U S E   T H E   F O N T   S O F T W A R E   O R   F R O M   O T H E R   D E A L I N G S   I N   T H E   F O N T   S O F T W A R E .  
  
 E x c e p t   a s   c o n t a i n e d   i n   t h i s   n o t i c e ,   t h e   n a m e s   o f   G n o m e ,   t h e   G n o m e   F o u n d a t i o n ,   a n d   B i t s t r e a m   I n c . ,   s h a l l   n o t   b e   u s e d   i n   a d v e r t i s i n g   o r   o t h e r w i s e   t o   p r o m o t e   t h e   s a l e ,   u s e   o r   o t h e r   d e a l i n g s   i n   t h i s   F o n t   S o f t w a r e   w i t h o u t   p r i o r   w r i t t e n   a u t h o r i z a t i o n   f r o m   t h e   G n o m e   F o u n d a t i o n   o r   B i t s t r e a m   I n c . ,   r e s p e c t i v e l y .   F o r   f u r t h e r   i n f o r m a t i o n ,   c o n t a c t :   f o n t s   a t   g n o m e   d o t   o r g . h t t p : / / w w w . b i t s t r e a m . c o m 5        f   q    u  -        J 3     T  99 NR 7s`s3VV9    s 3D        {  o {R     o      H     T  3f       s 
 +      b    -  { T #     \q#H 99` #fy```{   w` `b {  {   R f  f w ;  {    J/    } o   o5 j o {   - {  T7  f  D ) f s   @%2%%A:B2SAS//2}A}G}G2%]%]@@%d%d%A2dAd
A(]%]@%..%A%d%@~}}~}}|d{T{%zyxwv
utsrqponl!kjBjSih}gBfedcba:`^][ZYX
YX
WW2VUTUBTSSRQJQPONMNMLKJKJIJIIHGFEDC-CBAK@?>=>=<=<;<@;:987876765654321210/0/.-	.-	,2+*%+d*)*%)('%(A'%&%&%$#"!! ddBBBdB-B}d
	-d@-- d+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ , %Id@QX Y!-,%Id@QX Y!-,   Py PXY%%#  Py PXY%-,KPX EDY!-,%E`D-,KSX%%EDY!!-,ED-   ff   @  /1 0!%!!f sr) 5     	 @@   
<2991 /0KTX 
 @  
 
878Y  P]%3#3#5qe     M@  1 <20KTKT[X  @   878Y@0	@	P	`	p			]#!#o$++        `@1 		 
 91 /<<<<<<<2220@]!!!3!!!!#!#!5!!5!T%Dh$ig8R>hggh`TifaabbN   m ! ( / @U"

'&(
/)/))/B"
)	*!# *-
) 	"	&0<<<1 /299990KSX99Y"K	TX 0 @  0 0878YKTKT[KT[X 0  0 0 @878Y#.'5.546753.'>54&dijfod]SS\dtzq{---@A$*.U# jXV`OnZXh   q)   # ' 3 @6$%&%&'$'B .$&($4'!%		!+14991 2<0KSXY"K	TKT[KT[KT[KT[KT[X 4 @  4 4878Y"32654&'2#"&546"32654&%3#2#"&546WccWUccUVcbWWcd1Za    	 0@
	 	 	  !


	
 



B	 
(('+'$
.	 .'.'!!199999991 /9990KSX99999999Y"2]@"	) * *&: 4D^ YZ
UZZY0g{  "-		'(	2' ')	#**(/2;	49?2J	LKFO2VZ	YUY\_2ji`2uyz 	2229] ]3267	>73#'#" 5467.54632.#"[U_I{;Bh]h02SUWDi;#QX?@Yr~YWc?}<$$/1oX3g  o  B@
  1 0KTKT[X  @   878Y@@P`p]#o+   {  O@   
2991 0KTX  @   878YKTX     @878Y#&547{>;  o  @   <991 03#654<:  =J  N@, 	

	 	<2<2991 <22990%#'%%73%g:r:g:PrPbybcy      #@ 	 
<<1 /<<0!!#!5!----     @  1 073#R@  d    1 0!!d          1 /073#   B  -@  B  /991 0KSXY"3#m      #@ 	1 0"32'2  #"  		P3343ssyz     Z 
 K@B 	 1 /20KSXY"KTX     @878Y]7!5%3!!JeJsHH     J  @' B  

91 /20KSX9Y"KTKT[KT[X  @   878Y@2UVVzzv t vust  ] ]%!!56 7>54&#"5>32 Ls3aM_xzXE[w:mIwBC12\p   s ( {@. 
	 	 #) & 	)991 90KTKT[X ) @  ) )878Y@	daa d! ]!"&'532654&+532654&#"5>32?^jTmSrsY%%%12wps{$&  |  d     @ B 	
 <291 /<290KSXY"KTKT[X  @   878Y@* * H Y i w  + &+6NOOVfuz] ]	!33##!55^%3`   d  u@# 
 
1 90KTKT[X  @   878YKTX     @878Y!!>32  !"&'532654&#",X,$^hZkQT  10$&     $ X@$  "%"	!%1 90@ ]]"32654&.#">32  #   !2	LL;kPL;y$&W]yb     h  c@B  991 /0KSXY"KTX  @   878Y@X9Hg ] ]!#!3V+     # / C@% '-'0$*$	!0991 990"32654&%&&54632#"$54632654&#"HV  "attt     $ X@# 
 %! ""%1 90@]]7532#" 54 3   !"&2654&#"LK:lL>$&V\s[     #   @  <21 /073#3##  #  	 %@  
 
<21 03#3#R#@   ^  M@*  B  $#291 90KSXY"	5   `   @  #<21 0!!!!   ^  O@+  B $ #<91 90KSXY"55//m      $ p@+$	
  	
 &%99991 /9990KTX % @  % %878Yy	z
z ]%3##546?>54&#"5>328ZZ93lOa^gHZX/'eVY5^1YnFC98LVV/5<4   q  L @2	L4307$7CM34 ((+(I+*(I,=M<991 2990 K	TKT[KT[KT[KT[X M  M M @878Y@	NN/N?N]32654&#"#"&5463253>54&'&$#"3267#"$'&5476$32 |{zy!<gg;?@h{`smihZ}~Rk{KOHMIKL kPA@fjhmWQoag}}IJ}b{     h  
 @A  

  
	


B 		 	
91 /<90KSXY" ]@: X v p  	VXPghxv|rwx] ]	!3#!#%{9_+         C@# 
	
 .	 !29991 /90"]!2654&#!2654&#%!2#!D+|f>orqp   s'  6@
  021 0].#   !267#   !2'f  fjzSb_^^_HHghG       .@ 	
 2 	99991 /0`]3   !%!   )5BhPa/w.,~      .@ 
	 21 /0]!!!!!!9>F    # 	 )@  
21 /0]!!!!#ZpPH7   s  9@   431 990%!5!#   !2&&#   !26uu^opkSUmnHF_`%    ;  ,@ 
8	 221 /<20P]3!3#!#"d+9       9  1 /0KTX     @878Y@0@P`]3#+ f  M@  9 991 990KTX     @878Y@0@P`]3+53265M?n     j 
 @(B 	 291 /<290KSXY"]@	((764GFCUgvw		

(+*66650A@E@@@b`hgwp,]q ]q3!	!#3wH1     j  %@ : 1 /0@	0P]3!!_      @4	
	

	B
 	
>
 91 /<290KSXY"p]@V	

&& &
 
45
i|{y

#,'(	4<VY	ej	vy	] ]!	!###-}-+      3 	 y@B 6 
991 /<2990KSXY"]@068HGif	FIWXeiy] ]!3!#j+  s   #@ 	31 0"  32  '   !   ':xyLHH[[bb       :@ 	
 ? 	291 /0@?_]32654&#%!2+#8/  s   R@*B 	39991 990KSX9Y""  32  #'#   !  '?
!#y;:xLHHab[     T   @5	
B 		 
?
299991 /<9990KSX9Y"@]@Bz  % %%&'&&&	 66FFhuuw] ]#.+#! 32654&#A{>Jx ~hbO    ' ~@<	
B
  %(
 "-"(99991 90KSX99Y")])/)O)].#"!"&'532654&/.54$32Hs_wzj{r{i76vce+0/EF~n|-&      J@ @ @1 /20K
TX  @   878Y@ 	 	@	p			]!!#!+   )  K@ 	 
8 A1 299990KTX  @   878Y]332653 !  u\*$    h  @'   B  91 /290KSXY"P]@b *GGZ} 	* &&))% 8 33<<7H EEIIGY Vfiiz vvyyu )] ]!3	3J+  D   {@I	
	
	


   B
 
	 91 /<2290KSXY" ]@
 
 

($
 
>>4
0
LMB
@
Yjkg
`
{|
 	    	 	

  !   #	$
%  <:5306	9?0F FJ@E@BBB@@	D
M@@XVYPfgab```d	d
dw v{xwtyywpx	[] ]3	3	3#	#D:9:9+  =  ; ]@F	


	   B 	  
91 /<290KSXY"KTKT[KT[X     @878Y@''486KX[fkww			&()&('	) 5 4<;:;4	4
8?H	OX_e ejjhiil	l
xyyx}	
x  @] ]3	3	#	#su  \Y+3{     @(   B @ @	91 /290KSXY" 
]@<5000F@@@QQQe
&)78@
ghxp

] ]3	3#f9   \   	 @B  B 
991 /0KSXY"K	TK
T[X 
 @  
 
878Y@@
)&8HGH	 /59?GJOUYfiowx] ]!!!5!sP=go   X  S@ C 21 0KTX     @878YKTKT[X  @   878Y!#3!X   B  -@  B  /991 0KSXY"#m   o  <@  C<1 0KTKT[X     @878Y!53#5oX    @
 91 290##HHu-      1 0!5   f  1@	 D1 0 K	TKT[X     @878Y	#ofv  {-{ 
 % @'	  # 	E&22991 /9990@n0000 0!0"?'@@@@ @!@"PPPP P!P"P'p' !"'''000 0!@@@ @!PPP P!``` `!ppp p! !]]"326=7#5#"&5463!54&#"5>32o?`TeZ3f{bs)Lfa..''      8@	 GF221 /0`]4&#"326>32#"&'#3:{{:/Rdaad   q{  ?@ 
 HE21 0@].#"3267#"  !2NPPNM]-U5++++$$>:#  qZ   8@  GE221 /0`]3#5#"3232654&#":||^daDDa   q{   p@$ 	 KE91 90@)?p? ????,//	,
o oooo	]q]!3267#   32 .#"jbck)^Z44*,8
C   /    p@ 
 	L<<991 /22990K
TX     @878YKTX  @   878Y@P]#"!!##535463cM/Phc/N   qVZ{  ( J@#	&#'	& G E)221 /990`***]4&#"326!"&'5326=#"3253aQQR9||9=,*[cb::bc     d  4@	 
 N	F21 /<90`]#4&#"#3>32d||Bu\ed     y   +@  F<21 /0@	@	P	`	p	]3#3#`  Vy   D@  O F<2991 990@@P`p]3+532653#F1iL`a(     
 @)B 	 F291 /<90KSXY"]@_
')+Vfgsw		
('(++@h`]q ]33	##%ki#    y  "  F1 /0@@P`p]3#     { " Z@&	   PPF#291 /<<<290@0$P$p$$$$$$$	]>32#4&#"#4&#"#3>32)Erurw?yz|v\`gb|     d{  6@	 
 N	F21 /<90`]#4&#"#3>32d||Bu\`ed  qu{   J@ 	QE1 0@#?{ {	
{{]"32654&'2  #"  s98  V{   >@ G F221 0@	`]%#3>32#"&4&#"326s:{{8
daa  qVZ{   >@	G E221 0@	`]32654&#"#"3253#/s:||:/daDDad     J{  0@ 	
 F21 /90P].#"#3>32JI,:.`fc  o{ ' @<S	
SB
 %(
 R"E(99991 90KSX99Y" ']@m
.	,
,,;	;
;;   $(
(*//*(() )!$'
   
	'/)?)_))))))] ]q.#"#"&'532654&/.54632NZb?Zlfae@f?((TT@I!*##55YQKP%$   7    8@ 
	 F<<2991 /<2990]!!;#"&5#53w{KsN`>   X`  6@	 
	N F21 /290`]332653#5#"&||Cua{fc   =  ` @'   B  91 /290KSXY"K
TX     @878YKTKT[X  @   878Y@Hj{ 		 & &)) 5 5::0F FIIFH@V VYYPf fiigh`u t{{uz  >] ]3	3#=^^\`T   V  5` @IU	
	U
	U

U
   B
 
	 91 /<2290KSXY"K
TKT[KT[KT[KT[X     @878YKTKT[KT[X  @   878Y@"
5
IIF
@
[[U
P
nnf
yy
	
		% %#'!%""%'	$
!#96690FHF@B@@@D	D
D@@V VVPQRRPS	T
Uc dejejjjn	agou uy}x}zzxy		{
v} @/ 	y] ]333##V`jjj  ;  y` Z@F  
	
 

	B
 
 91 /<290KSXY"K
TKT[KT[KT[X     @878YKTX  @   878Y@


&
=1
UWX
f
vzvt






	
	)&%	* :9746	90IFE	J@Y VYYWVYVV	YPox/] ]	#	#	3	dkr))`HJq  =V` @C	 

     


B	 
	 91 29990KSX2Y"K
TKT[X     @878YKTX  @   878Y@ 	
#5I
O
NZ	Z
j

 
	
' $$  )(	%
$$'** 7 55008
668990A @@@@@@@@B	E
GII@T QQUPPVUVW	W
UUYYPffh
ii`{xx 		e] ]+5326?3	3N|lLT3!;^^hzHTNl  X  ` 	 @B  
2991 /0KSXY"KTKT[X 
 @  
 
878YKTX 
  
 
 @878Y@B&GI+ 690@@E@@CWY_``f``b] ]!!!5!qjL}e`%   $ @4%	 ! 	 	%	
$ 
  C
%<<299999991 99999990KTX %  % % @878Y &]#"&=4&+5326=46;#"3>l==k>DV[noZVtsXX     1 0#      $ @6%   #% # C %<2<99999991 99999990K
TX % @  % %878YKTX %  % % @878Y &]326=467.=4&+532;#"+ FUZooZUF?l>>l?VWst  1  #@  1 990#"'&'&'&#"56632326ian^Xbian
^V1OD;>MSOE<>L    hN' $      u    hm   ! @T!!! !!!B			  ! VV!"2299999991 /<9990KSXY" #]@ sP#fiu{yyv v!#] ]4&#"326!.54632#!#TY?@WX??Y!X=>sr?<_Z?YWA?XXN)sIsrFv)  su'' &      -     k' (      u   3^' 1      u sN' 2     'u )N' 8      u {-f' D       R   {-f' D      C R   {-f' D       R   {-' D       R   {-7' D       R   {-' D       R   qu{' F          qf' H          qf' H      C    qf' H          q' H            of'           f'       C    \f'           F'            d7' Q          quf' R       s   quf' R      C s   quf' R       s   qu' R       s   qu7' R       s   Xf' X       {   Xf' X      C {   Xf' X       {   X' X       {    9;  '@
 YW	Y <<1 <203!!#!5!oo\]   u=    @ 	Z[Z1 0"32654&'2#"&546 PnnPPnoO@v+..ooPOmmOOp1.-rB   #  ! Q@+ " 	"<<<221 <9990%&&'667#&  73JDFHAMf	fIX)**'# 32!    b  `@! 
  	<<1 /2<2990KTX     @878Y66 ].#"!!!!53#535632NL=ty-=))/   \=  > @</0* 06'&*&#<#?/ 0-	6W9-W 	W"9&"W3?99991 99990K
TKT[KT[KT[X ? @  ? ?878Y>54&.#"#"&'532654/.5467.54632{?>?>S8al\]>9IXW:fq][;;I.Z.L-[.K''PGZsweZ54m@''TLf{xf[1,pE  3!  	\ 1 04632#"&3~|}}||}   ;9  %@  ]]91 290!###&&54$yfN    / @0-'!  **.	 !'	$'$- F099991 /990@@'(





 
!"& : :!MM I!I"jj  ]]4632#"&'532654&/.5467.#"#:A9`@IPAtx;e\`Wqqs`/Q*%jd_[?T>7;[gp      / 8 L `@6EBC?2H09JC9 $HE301B<?96I1`K6`C<^	K^	_*M299991 /29990"32676654&'&&'2#"$'&5476$#32654&'2#'&&### ^^``^^^]]^\^mmllmmmmllmm}{{nWXfi`C.;I6Bf^^^^^__^]]^^gnmmmmnnmmmmnb>KL?gwyVpMI`3D     / I C@&=>:A$104G $7aD=0^*	D^	J21 /02#"$'&5476$"32676654&'&&&&#"3267#"&54632 mmllmmmmllmm^^``^^^]]^\^BB@zBCFInmmmmnnmmmmng^^^^^__^]]^^! "  'F   >@!
	 	b	bcbc91 <<2<<903#######5Jq7rqr  /B^^  sRf  1@	 D1 0 K	TKT[X     @878Y3#f   F)   @ d d1 <20 K
TKT[X  @   878YKTKT[KT[KT[X     @878YKTKT[X  @   878Y@````pppp]3#%3#^y    '  >@"
 
	 <291 <2<<990!!!!!'7!5!7! }/H{};ff    H   @9B 	
 
<291 /<0KSXY"]@gww	]!!!!!!#!59=qF  f 	  + @<+,
 )& *&&&,+,* #
 )#3,999999991 99999990@*W ZWU!je!{vu!	FY Vj ddj(| svz(]]	32 4&'.#" &5 !27 !"&''3>_'y=_''NOy;WfNP[gX@CHp@CpDfbMKYg[KKX      / @-	! $'!!0 $*099991 9990@   	


	
$$$   $$	$
***///***55500055	5
:::???:::EEE@@@EE	E
JJJOOOJJJV !"&'()]]32654&#".#"326#"&54632>32#"&1TevYR1UfvYRF^_HDa^/XZie7XXje~w        .@ 	 
<2<21 /<<0!!#!5!!!--}}      
 T@.  B 	 $#<2291 /90KSXY"	5!!@po       
 V@/  B $	 #<<291 /90KSXY"55!5A   R    @FB	 		 f ef
e<2299991 /2<2<290KSXY"KTX     @878Y@(''')((79] ]!#!5!5'!5!3	3!!!c`T{yT9{3{JD{3   V`   M@%	
 !		N F!291 2<990"`""]3326533267#"&'#"&'#%	 )I#ER2bf*V
H<9NPOONN   h-  ) b@ '!	'!*$ $*9991 990KTKT[KT[KT[KT[X * @  * *878Y>54&#"#"&54632 #"&54324&#"32IH7$$0eeWOmVPmmWKt,>bF[t}t{   w;  ]@
 
 91 990@0QVPZ
spvupz
Z	pp{	t]]!!	!!5	7AJI3!   wq  @ gg 1 20!#!#
}  / # @1  "$ #"#h#$9999991 /<229990K
TX $  $ $ @878Y@V	 		
		# #(] ]#3267#"&5467!##"#>3!i/7.%7vy"P)6<	yJ\:1fd.xo@E}   / % &@  &
iji&1 026732#"&'&&#"#"&546327jPd@7*8	kOeD=!0

l9TA6?&#Hn!bSA8?S   s;   ) _@3(%  %

* "(kl"k*229991 99990!!#5#"&5463354&#"56632"32655P,]uu>DIE~bRhP{@p?Dq[[""CO@Mr  `d    .@ 
 klk991 0!!2#"&546"32654&PXi~hi}|P{s  N    @@"	   mm 9991 /<20%!5654 #" !5!&5 !  ?1/aL"a*>w   {o{  3 >@C'-%= 4% :.-*1
%?47& %7& =&-7"E?<999991 2<<29990@0+0,0-0.0/00@+@,@-@.@/@0P+P,P-P.P/P0+0@@@@@@@@@? ????0,0-0.0/@,@-@.@/P,P-P.P/o oooo`,`-`.`/p,p-p.p/,-./]q].#">32 !3267#"&'#"&5463!54&#"5>32"326=DJhddjMI`TeZo0Z^Z55*,ywxx..''`f{bs)  H 	  + @<+,&
 )& *&&&,+,* #
 #Q)E,229999991 99999990@p(?-YVUV jf! {	
{z{ {!"#$%{&%--&Y VUZ(i fej(z tvz($$]]	32654&'.#".5 327 #"&'')gA\*g>}66]C_56`?`!*(Ou))Hn.Mw834OMx43N     $ @/   !##%"	 "	 "!&	%99991 9990KTKT[KT[X %  % % @878Y@ttttv]33267#"&546?>7>5#537ZZ:3mN`^gIYX0&DeWX5^1YnFC98LVV/5<6 5     	 b@   
<2991 /0KTX 
 @  
 
878YKTKT[KT[X 
  
 
 @878Y  P]#53#3 +e   ^  @
  1 0!#!^   =} 
 *@
	 
	 91 903##'%\sB} }`s-Pb;  V # @@
	B

 !$	
 $91 2299990KSX29Y"KTX $  $ $ @878Y.#"!!#"&'53267#5!>32&P,`r<::d/4a/am"?$5dz!!J    ; ?@.9* -"*19"< -<<21 9999990#"'&'&'&#"56632326#"'&'&'&#"56632326ian
^Xbian^Vgian
^Xbian
^VoNE;=LTNE;=KOE;=LSNE;=K   `   8@  91 /90@cmpxyvn  ]]	!3!^DC?   %#   @I   
			
	B	 	 o
on<2991 <2990KSXY"55%-+#-+#RR    H#   @I	
	

	   B
  o
o p<<991 <2990KSXY"5%5+-+-#^R^^R^         #@ 
 	1 /<<220%3#%3#%3#    hk' $      u   h^' $      u s^' 2     'u  s     ;@ 	
 299991 /220!!!!!   !#   !39OAg@AF|pm|  q{  ' 3 @1  .("%4 "1	 K1	Q+E49991 2<2290@%?5_5p55555? ????	o oooo	]q].#"!3267#"&'#"  32>32 %"32654&
HjbdjQGBN5Z44*,nmnm98olkp     y    /1 0!!  y     y    /1 0!!  y  m   '@ 		
 1 <20#53#53RR??  m   '@	 	
 1 <203#%3# RR@@    @  1 0#53R?     @ q 1 03#R?    o    )@ 
	r <<1 03#3#!!oA  #u   "@  91 990	9%- =V' \       ^    N' <      su   +@  B 1 0KSXY"3#-\   ^ R # / @I	- '!-
-'!0 *$0*	$
$(st*(s09999999991 9999999907'#"&''7&&5467'766324&#"326{r%$&(r;t=:x=q%%&&s7t@<u\rpqqs;w>?s9q(&%%s>v:@t8s'%$|ppr    s#  G@%  B  on291 90KSXY"5s-+#R    #  I@&   B o p<91 90KSXY"5+-#^R^   /  J   @( 	   
L<2<2991 /<22990K
TX     @878YKTX  @   878Y@0P] ]#!##53546;#"3#JcM`/NPhc  /  J  @!	 	 

L<<991 /<22990K
TX     @878YKTX  @   878Y@0P
]!#!"!!##53546J cM/{Phc/N   9;  >@  
 
 YW	Y<<2<<21 22220%!#!5!!5!3!!!oooo\\  HF    1 03#F     @  1 0%3# R@  m    '@	  	
1 <20%3#%3#RfR@@   q
L   # ' 3 ? K @D$%&%&'$'B@ .(F4:&$L%IC'1+C=	1=I7+!L991 2<<2220KSXY"KTK	T[KT[KT[KT[KT[X L @  L L878Y"32654&'2#"&5462#"&546!3#"32654&2#"&546"32654&WddWUccUt%ZVcbWWcdWccWUcc    hm' $      u   m' (      u   hk' $      u   N' (      u   k' (      u   k' ,     /u  `m' ,     /u   XN' ,     /u ;  k' ,     /u sk' 2     'u sm' 2     'u sk' 2     'u )k' 8      u )m' 8      u )k' 8      u    y`     F1 /0@@P`p]3#`   ?f  7@ u91 290 K	TKT[X     @878Y3#'#f  J7  c@$  VwVv99991 <<99990 K	TKT[X     @878Y'.#"#>3232673#"&9!&$}f[&@%9!&$}f[&@Z7IR!7IR   b+  /  1 0 K	TKT[X     @878Y!!V   )9H  W@ VV 1 <0 K	TX     @878Y KTKT[KT[X  @   878Y332673#"&vaWV`v
HKKJL Df  ,@	 d 1 0 K	TX     @878Y3#      _@	 VxV1 0 K	TKT[X     @878YK
TKT[KT[X     @878Y4&#"3267#"&54632X@AWWA@Xzssss?XW@AWX@sss  #u    @	
  '	1 /90!#"&'532654&'T76xv.W+"J/;<+->i0Y[0.W=  f   B@  991 <20 K	TKT[X     @878Y3#3#fx  Lu     @
  
'1 /90!33267#"&546w-+76 >&Dzs5=X..

W]0i  ?f  7@ u91 <90 K	TKT[X     @878Y373x   u  ?@
   :	 y<<991 /900P]3%!!'79Pw^Mo;jn     H  ^@
	 	
 z
z <<991 /90KTX  @   878Y@@P`sz
p	]37#'7}L{JZjXj  m' 6      u of' V          \  m' =      u X  f' ]             @  <21 0##
 
   
     g@ 	 2
 y<291 /220@( 	
	
]]!   )#53!!3   !iP`P5~.,  qu  ('@^%{&%#${##{#({'(#&'('%$%(('"#" !  B('&%"! ##	#)&'! (%#"QE)99999991 9990KSXY"?*]@v%+("/#/$)%-&-'*(6%F%X X!` `!f"u u!u"%#%$&&&''(6$6%F$E%Z Z!b b! z{	
{zzv v!x"**'] ].#"32654& #" 54 32''%'3%F2X)6	~r4*!M!z&77kc\oab   k' <      su =Vf' \       ^         =@	 	?
 2291 /0@	?_]332+#32654&#'  V   >@ G F221 0@	`]%#3>32#"&4&#"326s:{{8daa   -    1 0!!   ?  @M

	  
	
 B
 	
	 <291 <290KSXY"	'77w55v8vL57y5yy5   
 ,@ 		|]|| 1 2035733!
c)t'+n   ^  J@$ } }B   ~91 90KSX2Y"!!567 54&#"56632"?XhU4zHM98rn81^BQ##{l0  b ( H@' 
	 	 #) ~&~	)9991 90#"&'532654&##532654&#"56632\e9}F4wCmxolV^^ad_(fQI7Z`mR|yOFJLl?<:=svcE`  '      ' 5   	d ? '      ' 5    d b '      ' 5   	d sm' *     
u qVZH' J            P' ,     /u u' 6          ou{' V          s'k' &     -u qf' F          s'm' &     -u qf' F           q  $ J@$	"  
GE%<<1 /<20`&&&]!5!533##5#"3232654&#"F:||N}}daDDa   d    1 0!!d   HF    1 03#F    1@: "+	 /)	2+"!)#&
	, & &*!/<299999999991 22<20K	TKT[KT[KT[KT[KT[X 2  2 2 @878Y@z 1Tilnooooiko o!o"o#n$l%i'i-	
 !"#$%&'()*+,-2  		  	USjg
] ].#"!!!!3267#" #734&5465#73 32[f A78 f[Y`(77(6bbiZ{.# .{ZiHH"{/ #/{"G  )   @ d d1 <20 KTKT[X  @   878YKTKT[KT[X     @878YKTKT[X  @   878Y KTX     @878Y@````pppp]3#%3#^y s  @   B 1 0KSXY" KTX     @878Y KTX  @   878Y@ %%6FVjg	  / /]]3#7  J  u@!  VV	99991 <2990 KTX     @878Y KTX  @   878Y]'.#"#4632326=3#"&9$(}gV$=09" (}gT";9!2-ev3)dw   @ B 1 0KSXY" KTX     @878Y KTX  @   878Y@*  $ $5CU U    / /]]#  1  w@
 91 <90 KTX     @878Y KTX  @   878YKTX     @878Y@  / /-	 ]3#'#  1  @
 91 290 KTK	T[K
T[KT[X     @878Y KTX  @   878YKTX     @878Y@      " 	 ]373
   ?   @ 	
 ]<291 <290KTKT[KT[KT[KT[K
T[X  @   878Y KTKT[X     @878Y@T/9IFYi  " 5 G KS [e    ]]	!33##5!55bf]my   9  j@ VV 1 20 KTX     @878Y KTX  @   878YKTKT[X     @878Y332673#"&vcSRav
6978w{z  f    1 03#                                              	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`a bcdefghijklmnopqrstuvwxyz{|}~  >   :     ~ 1BSax~ & 0 : !""""+"H"e%     0AR^x}  0 9 !""""+"H"`%      ^  Ch      Vj    q_      8                                (    B                                           b c  d  e        f     g      h    j i k m l n  o q p r s u t v w  x z y { } |    ~                                                                                                  f        55    q= 3     =   d        d          ?   y }  s)   3 s \ \? u   L s L s   y  D{ ={ \         { f q q q / q 9 9 9    q  qJ + o# 7  = V ; =3 X   y y  s  L s  { { { { { {f q q q q q9 999  q q q q q      9      \3 
    ' s    L f     R # hd  + / s ` N { H? 55  =  Z      y y L s s/ q      % %      =V ^3 3 
 /
 /  9  % 
 qy  y   \ \\ \ ;L sL sL s   9             #   L  F  + o{ \3 X3 
 q =   5 5 ^5 b   b3 s q\  + o sf q sf q q d      s       5 ?          +                                	 
                        ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~                                                                                                                                	
	sfthyphenperiodcenteredEuroc6459c6460c6461c6462c6463c6466c6467c6468c6469     " " " " X  O!nE~Le		R	s	

X:i=z/ Eu)pP@"m#{CwR w [ r !5!B!!!"	""#"0"="J"W"d"q"~"""""""""# ###'#4#A#N#[#h##$4$%3%S%&&'K''((X()_*%*\**+z+,D,,-P-..R./0A011!1P12H2z23F3p3p3}3334z44445595g55556[667C778 88J999)969C9P9]9j9w99999999::{::;;^;;;<"<_<<<<<<=c>;>H>U>>>?a??@:@K@\@m@z@@@@@@@@A@AVAkBEBBC_CCDUDE*E?       -   
x  $  %  &    '    )    * K  +    - r  .    /    2 9  3    4 K  5    7D  9  :  ;  <  =    I    Q    R &  U    Y  Z    \  b  d    g 9  x    y &  z &  { &  | &  } &               9           9   9   9                   K         $  $  $  $ $ 9 $ & $ * $ 2 $ 4 $ 6   $ 7a $ 8   $ 9} $ : $ ;   $ <a $ F $ G $ H $ I $ R $ T $ W $ X   $ Y $ Z $ \u $ b 9 $ d $ g $ h   $ o $ p $ q $ r $ s $ y $ z $ { $ | $ } $ ~   $    $    $    $  $    $  9 $  9 $  $  $  $ u $ a $  / $  9 $  9 $  $  $  $    $    $    $    $ a $ u $  $    $  $  $  $  %    % & % * % 2 % 6 % 9 % : % < % d % g %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  &    & $   & 6   & < & b   &  &  &    &    &    &  & &  &    &    &    &    &  &    '    ' $ ' 9 ' :   ' < ' b '  '  '  '  '  '  '  ' D '  '  '  )    )  ) a ) $D ) 6 ) 7 ) DD ) H ) Lk ) R ) Uk ) X ) \D ) bD ) iD ) jD ) kD ) lD ) mD ) nD ) p ) q ) r ) s ) y ) z ) { ) | ) } ) ~ )  )  )  )    )    ) D ) D )  )    ) D )  ) D ) D )  ) D )  *    * $   * 7 * :   * < * b   *  *  *    *    *  *  *  *  *    *    *  +    +  +    +    +    +  +  +  -  - $ - b -  -  -  -  -  -  -  -  -  . ) . $ . & . 2 . 7a . 8 . : . < . D . H . R . X . \k . b . d . g . h . i . j . k . l . m . n . p . q . r . s . y . z . { . | . } . ~ .  .  .  . } .    .  .  .  .  .  . k .  .    .  .  .  .  .  .  .  .  .  . k .  .  /  / $ / / 2 / 7 / 8 / 9 / :D / < / D   / H / R / X / \D / b / / g / h / i   / j   / k   / l   / m   / n   / p / q / r / s / y / z / { / | / } / ~ /  /  /  /    /    /  / /  / /  / a /  / D /  /    /  / /  / /  /  /  /  /  /  /  / D 2  9 2  2  2 $ 2 9 2 ;} 2 < 2 b 2  2    2  2  2  2  2  2 D 2  2  2  3  3  3    3 $} 3 8   3 :   3 < 3 D 3 H 3 L 3 Q 3 R 3 U 3 V 3 X 3 \   3 b} 3 h   3 i 3 j 3 k 3 l 3 m 3 n 3 p 3 q 3 r 3 s 3 x 3 y 3 z 3 { 3 | 3 } 3 ~ 3  3  3  3  3    3 } 3 } 3  & 3  & 3    3  3  3 } 3 } 3    3    3    3  3  3    3  4  9 4    4    4  4  4 } 5  5  5  5 $ 5 & 5 7k 5 9 5 : 5 <} 5 D 5 H 5 R 5 X 5 \ 5 b 5 d 5 i 5 j 5 k 5 l 5 m 5 n 5 p 5 q 5 r 5 s 5 y 5 z 5 { 5 | 5 } 5 ~ 5  5  5  5  5  5  5  5 k 5 } 5  5 } 5  5  5  5 } 5  5  5  6 $ & 6 &   6 *   6 2   6 4   6 6   6 b & 6 d   6 g   6  & 6  & 6    6  & 6  & 6    6    6    6    6    6    6    6    7 D 7  7  7 $a 7 & 7 7 7 D 7 F 7 H 7 L 7 R 7 U 7 V 7 X 7 Z 7 \ 7 ba 7 d 7 i 7 j 7 k 7 l 7 m 7 n 7 o 7 p 7 q 7 r 7 s 7 y 7 z 7 { 7 | 7 } 7 ~ 7  7  7  7 D 7  7 a 7 a 7    7  7  7  7 a 7 a 7  7  7  7  7  7  7  8 $   8 -   8 = 8 b   8    8    8    8    8  9  9  9 Y 9 $} 9 2 9 Da 9 Ha 9 L 9 Ra 9 Xu 9 \ 9 b} 9 g 9 ia 9 ja 9 ka 9 la 9 ma 9 na 9 pa 9 qa 9 ra 9 sa 9 ya 9 za 9 {a 9 |a 9 }a 9 ~u 9 u 9 u 9 u 9 N 9  9 } 9 } 9  9    9    9  9  9 } 9 } 9  9  9  9  :  :  :  : $ : D} : H : L : R : U : X : \ : b : i} : j} : k} : l} : m} : n} : p : q : r : s : y : z : { : | : } : ~ :  :  :  :  :  :  :  :  :    :  :  :  :  :  ;  ; $   ; &k ; 2} ; 7 ; H ; b   ; dk ; g} ; p ; q ; r ; s ;  ;    ;    ;    ; } ; a ;  ;  ;    ;    ; } ; } ; } ; k ; k <  < a <  < $a < & < 2 < D < H < L < R < X < ba < d < g < i < j < k < l < m < n < p < q < r < s < y < z < { < | < } < ~ <  <  <  <  < k < a < a <  <  <  <  < a < a <  <  <  <  <  =  =    =    =  =  =  H [ I  I k I  I W I Z I \ I  I  I  A I    I  I  I  N D N H N R N X N \ N i N j N k N l N m N n N p N q N r N s N y N z N { N | N } N ~ N  N  N  N  N  Q    Q    Q    Q    Q    Q k Q  Q  R  & R  R    R [ R    R    R k R  R } U } U D U  U F U G U H U I   U J U K U P U Q U R U T U U U X   U Y   U Z   U [ U \   U ]   U o U p U q U r U s U x U y U z U { U | U } U ~   U    U    U    U  U    U    U  V U    U  U    U    U  U  U  Y  Y a Y  Y  Y  Y    Y  Y  Z    Z D Z  Z  Z  Z    Z    Z ) [ F [ H [ R [ o [ p [ q [ r [ s [ y [ z [ { [ | [ } [  [  \  \  \ k \  \  \    \    \  b  b  b  b $ 9 b & b * b 2 b 4 b 6   b 7a b 8   b 9} b : b ;   b <a b F b G b H b I b R b T b W b X   b Y b Z b \u b b 9 b d b g b h   b o b p b q b r b s b y b z b { b | b } b ~   b    b    b    b  b    b  9 b  9 b  b  b  b u b a b  / b  9 b  9 b  b  b  b    b    b    b    b a b u b  b    b  b  b  b  d    d $   d 6   d < d b   d  d  d    d    d    d  & d  d    d    d    d    d  d    g  9 g  g  g $ g 9 g ;} g < g b g  g    g  g  g  g  g  g D g  g  g  h $   h -   h = h b   h    h    h    h    h  p [ q [ r [ s [ x    x    x    x    x    x k x  x  y  & y  y    y [ y    y    y k y  y } z  & z  z    z [ z    z    z k z  z } {  & {  {    { [ {    {    { k {  { } |  & |  |    | [ |    |    | k |  | } }  & }  }    } [ }    }    } k }  } }   &                                  $    %  &  '  )    *  +    -  .    /    2    3    4    5    7  9  :  ;    <k  =    I    Q    R    U    Y  Z  \  b    d  g    x    y    z    {    |    }                         k                              k              $  %  &  '  )    *    +    -  .    /    2  3    4    5    7D  9N  :  ;  <  =    I    Q    R    U    Y  Z  \  b  d  g  x    y    z    {    |    }                                                              $ 9  &  *  2  4  6    7a  8    9}  :  ;    <a  F  G  H  I  R  T  W  X    Y  Z  \u  b 9  d  g  h    o  p  q  r  s  y  z  {  |  }  ~                       9   9        u  a   /   9   9                        a  u                      $ 9  &  *  2  4  6    7a  8    9}  :  ;    <a  F  G  H  I  R  T  W  X    Y  Z  \u  b 9  d  g  h    o  p  q  r  s  y  z  {  |  }  ~                       9   9        u  a   /   9   9                        a  u                 9      $  9  ;}  <  b                  D        $  %  &  '  )  *  +  -  .  /  2  3  4  5  7    9    :    ;  <    =  I  Q  Rk  U  Y  Z  \  b  d  g  x  yk  zk  {k  |k  }k    }                                              k                  a    $a  &  2  D  H  L  R  X  ba  d  g  i  j  k  l  m  n  p  q  r  s  y  z  {  |  }  ~          k  a  a          a  a            $ &  %  &  '  )  *  +  - /  .  /  2  3  4  5  7  9  :  ;  <  =    I  Q  R  U  Y  Z<  \  b &  d  g  x  y  z  {  |  }     &   &   &         &   &                                $ 9  &  *  2  4  6    7a  8    9}  :  ;    <a  F  G  H  I  R  T  W  X    Y  Z  \u  b 9  d  g  h    o  p  q  r  s  y  z  {  |  }  ~                       9   9        u  a   /   9   9                        a  u                      $ 9  &  *  2  4  6    7a  8    9}  :  ;    <a  F  G  H  I  R  T  W  X    Y  Z  \u  b 9  d  g  h    o  p  q  r  s  y  z  {  |  }  ~                       9   9        u  a   /   9   9                        a  u                 9      $  9  ;}  <  b                  D         9      $  9  ;}  <  b                  D         9      $  9  ;}  <  b                  D        $    -    =  b                      $    -    =  b                      $    -    =  b                      $ &  &    *    2    4    6    b &  d    g     &   &       &   &                                                                      a    $a  &  2  D  H  L  R  X  ba  d  g  i  j  k  l  m  n  p  q  r  s  y  z  {  |  }  ~          k  a  a          a  a                k                    k                  D      $    7  :    <  b                                  $ &  &    *    2    4    6    b &  d    g     &   &       &   &                                      $    6    <  b                     &                              $    6    <  b                     &                              M  B    @   h     m  

L                  G  BG  S f    J        Bits @  m            B `  #c  VeraSans        6628R00  @        	 	
							
					  
 
			











   	

																															   





			
						
	
			
	



		

	
								

	   			





	
	

				



	

			
		





	


			   												

	
	
	
		
		
														
	

																																					


	
						

		  	 













		
	

	

												





																					

	
	
	
		


		


	
		
	
		
					


	
  
 










	
	
	

			
	
	

	



	
	
		


											











	



	
	




		





	
		
		



			

  
 		
	


		


























			
			
	
	

			



												







								   	


		
	
	





								
																
											   



			






		



	











				







   











		

























   
	


   	
						

							   														    
					
	


 


	
  " 


	

	




"


	
  # 


				
	
	
	


#	


	
  $ 			
					
					$	
	  & 			
					
					&	
	              P
_<          g
Lm                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Test app for VG font library.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>

#include "bcm_host.h"
#include "vgfont.h"

static const char *strnchr(const char *str, size_t len, char c)
{
   const char *e = str + len;
   do {
      if (*str == c) {
         return str;
      }
   } while (++str < e);
   return NULL;
}

int32_t render_subtitle(GRAPHICS_RESOURCE_HANDLE img, const char *text, const int skip, const uint32_t text_size, const uint32_t y_offset)
{
   uint32_t text_length = strlen(text)-skip;
   uint32_t width=0, height=0;
   const char *split = text;
   int32_t s=0;
   int len = 0; // length of pre-subtitle
   uint32_t img_w, img_h;

   graphics_get_resource_size(img, &img_w, &img_h);

   if (text_length==0)
      return 0;
   while (split[0]) {
      s = graphics_resource_text_dimensions_ext(img, split, text_length-(split-text), &width, &height, text_size);
      if (s != 0) return s;
      if (width > img_w) {
         const char *space = strnchr(split, text_length-(split-text), ' ');
         if (!space) {
            len = split+1-text;
            split = split+1;
         } else {
            len = space-text;
            split = space+1;
         }
      } else {
         break;
      }
   }
   // split now points to last line of text. split-text = length of initial text. text_length-(split-text) is length of last line
   if (width) {
      s = graphics_resource_render_text_ext(img, (img_w - width)>>1, y_offset-height,
                                     GRAPHICS_RESOURCE_WIDTH,
                                     GRAPHICS_RESOURCE_HEIGHT,
                                     GRAPHICS_RGBA32(0xff,0xff,0xff,0xff), /* fg */
                                     GRAPHICS_RGBA32(0,0,0,0x80), /* bg */
                                     split, text_length-(split-text), text_size);
      if (s!=0) return s;
   }
   return render_subtitle(img, text, skip+text_length-len, text_size, y_offset - height);
}

int main(void)
{
   GRAPHICS_RESOURCE_HANDLE img;
   uint32_t width, height;
   int LAYER=1;
   bcm_host_init();
   int s;

   s = gx_graphics_init(".");
   assert(s == 0);

   s = graphics_get_display_size(0, &width, &height);
   assert(s == 0);

   s = gx_create_window(0, width, height, GRAPHICS_RESOURCE_RGBA32, &img);
   assert(s == 0);

   // transparent before display to avoid screen flash
   graphics_resource_fill(img, 0, 0, width, height, GRAPHICS_RGBA32(0,0,0,0x00));

   graphics_display_resource(img, 0, LAYER, 0, 0, GRAPHICS_RESOURCE_WIDTH, GRAPHICS_RESOURCE_HEIGHT, VC_DISPMAN_ROT0, 1);

   uint32_t text_size = 10;
   while (1) {
      const char *text = "The quick brown fox jumps over the lazy dog";
      uint32_t y_offset = height-60+text_size/2;
      graphics_resource_fill(img, 0, 0, width, height, GRAPHICS_RGBA32(0,0,0,0x00));
      // blue, at the top (y=40)
      graphics_resource_fill(img, 0, 40, width, 1, GRAPHICS_RGBA32(0,0,0xff,0xff));

      // green, at the bottom (y=height-40)
      graphics_resource_fill(img, 0, height-40, width, 1, GRAPHICS_RGBA32(0,0xff,0,0xff));

      // draw the subtitle text
      render_subtitle(img, text, 0, text_size,  y_offset);
      graphics_update_displayed_resource(img, 0, 0, 0, 0);
      text_size += 1;
      if (text_size > 50)
         text_size = 10;
   }

   graphics_display_resource(img, 0, LAYER, 0, 0, GRAPHICS_RESOURCE_WIDTH, GRAPHICS_RESOURCE_HEIGHT, VC_DISPMAN_ROT0, 0);
   graphics_delete_resource(img);

   return 0;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         OBJS=jpeg.o
BIN=hello_jpeg.bin
LDFLAGS+=-lilclient

include ../Makefile.include

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
Copyright (c) 2012, Matt Ownby
                    Anthong Sale

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <stdio.h>
#include <assert.h>
#include "jpeg.h"

#define TIMEOUT_MS 2000

typedef struct _COMPONENT_DETAILS {
    COMPONENT_T    *component;
    OMX_HANDLETYPE  handle;
    int             inPort;
    int             outPort;
} COMPONENT_DETAILS;

struct _OPENMAX_JPEG_DECODER {
    ILCLIENT_T     *client;
    COMPONENT_DETAILS *imageDecoder;
    COMPONENT_DETAILS *imageResizer;
    OMX_BUFFERHEADERTYPE **ppInputBufferHeader;
    int             inputBufferHeaderCount;
    OMX_BUFFERHEADERTYPE *pOutputBufferHeader;
};

int             bufferIndex = 0;	// index to buffer array

int
portSettingsChanged(OPENMAX_JPEG_DECODER * decoder)
{
    OMX_PARAM_PORTDEFINITIONTYPE portdef;

    // need to setup the input for the resizer with the output of the
    // decoder
    portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
    portdef.nVersion.nVersion = OMX_VERSION;
    portdef.nPortIndex = decoder->imageDecoder->outPort;
    OMX_GetParameter(decoder->imageDecoder->handle,
		     OMX_IndexParamPortDefinition, &portdef);

    unsigned int    uWidth =
	(unsigned int) portdef.format.image.nFrameWidth;
    unsigned int    uHeight =
	(unsigned int) portdef.format.image.nFrameHeight;

    // tell resizer input what the decoder output will be providing
    portdef.nPortIndex = decoder->imageResizer->inPort;
    OMX_SetParameter(decoder->imageResizer->handle,
		     OMX_IndexParamPortDefinition, &portdef);

    // establish tunnel between decoder output and resizer input
    OMX_SetupTunnel(decoder->imageDecoder->handle,
		    decoder->imageDecoder->outPort,
		    decoder->imageResizer->handle,
		    decoder->imageResizer->inPort);

    // enable ports
    OMX_SendCommand(decoder->imageDecoder->handle,
		    OMX_CommandPortEnable,
		    decoder->imageDecoder->outPort, NULL);
    OMX_SendCommand(decoder->imageResizer->handle,
		    OMX_CommandPortEnable,
		    decoder->imageResizer->inPort, NULL);

    // put resizer in idle state (this allows the outport of the decoder
    // to become enabled)
    OMX_SendCommand(decoder->imageResizer->handle,
		    OMX_CommandStateSet, OMX_StateIdle, NULL);

    // wait for state change complete
    ilclient_wait_for_event(decoder->imageResizer->component,
			    OMX_EventCmdComplete,
			    OMX_CommandStateSet, 1,
			    OMX_StateIdle, 1, 0, TIMEOUT_MS);

    // once the state changes, both ports should become enabled and the
    // resizer
    // output should generate a settings changed event
    ilclient_wait_for_event(decoder->imageDecoder->component,
			    OMX_EventCmdComplete,
			    OMX_CommandPortEnable, 1,
			    decoder->imageDecoder->outPort, 1, 0,
			    TIMEOUT_MS);
    ilclient_wait_for_event(decoder->imageResizer->component,
			    OMX_EventCmdComplete, OMX_CommandPortEnable, 1,
			    decoder->imageResizer->inPort, 1, 0,
			    TIMEOUT_MS);
    ilclient_wait_for_event(decoder->imageResizer->component,
			    OMX_EventPortSettingsChanged,
			    decoder->imageResizer->outPort, 1, 0, 1, 0,
			    TIMEOUT_MS);

    ilclient_disable_port(decoder->imageResizer->component,
			  decoder->imageResizer->outPort);

    // query output buffer requirements for resizer
    portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
    portdef.nVersion.nVersion = OMX_VERSION;
    portdef.nPortIndex = decoder->imageResizer->outPort;
    OMX_GetParameter(decoder->imageResizer->handle,
		     OMX_IndexParamPortDefinition, &portdef);

    // change output color format and dimensions to match input
    portdef.format.image.eCompressionFormat = OMX_IMAGE_CodingUnused;
    portdef.format.image.eColorFormat = OMX_COLOR_Format32bitABGR8888;
    portdef.format.image.nFrameWidth = uWidth;
    portdef.format.image.nFrameHeight = uHeight;
    portdef.format.image.nStride = 0;
    portdef.format.image.nSliceHeight = 0;
    portdef.format.image.bFlagErrorConcealment = OMX_FALSE;

    OMX_SetParameter(decoder->imageResizer->handle,
		     OMX_IndexParamPortDefinition, &portdef);

    // grab output requirements again to get actual buffer size
    // requirement (and buffer count requirement!)
    OMX_GetParameter(decoder->imageResizer->handle,
		     OMX_IndexParamPortDefinition, &portdef);

    // move resizer into executing state
    ilclient_change_component_state(decoder->imageResizer->component,
				    OMX_StateExecuting);

    // show some logging so user knows it's working
    printf
	("Width: %u Height: %u Output Color Format: 0x%x Buffer Size: %u\n",
	 (unsigned int) portdef.format.image.nFrameWidth,
	 (unsigned int) portdef.format.image.nFrameHeight,
	 (unsigned int) portdef.format.image.eColorFormat,
	 (unsigned int) portdef.nBufferSize);
    fflush(stdout);

    // enable output port of resizer
    OMX_SendCommand(decoder->imageResizer->handle,
		    OMX_CommandPortEnable,
		    decoder->imageResizer->outPort, NULL);

    // allocate the buffer
    // void* outputBuffer = 0; 
    // if (posix_memalign(&outputBuffer, portdef.nBufferAlignment,
    // portdef.nBufferSize) != 0)
    // {
    // perror("Allocating output buffer");
    // return OMXJPEG_ERROR_MEMORY;
    // }

    // set the buffer
    // int ret = OMX_UseBuffer(decoder->imageResizer->handle,
    // &decoder->pOutputBufferHeader,
    // decoder->imageResizer->outPort, NULL,
    // portdef.nBufferSize,
    // (OMX_U8 *) outputBuffer);
    int             ret = OMX_AllocateBuffer(decoder->imageResizer->handle,
					     &decoder->pOutputBufferHeader,
					     decoder->imageResizer->
					     outPort,
					     NULL,
					     portdef.nBufferSize);
    if (ret != OMX_ErrorNone) {
	perror("Eror allocating buffer");
	fprintf(stderr, "OMX_AllocateBuffer returned 0x%x allocating buffer size 0x%x\n", ret, portdef.nBufferSize);
	return OMXJPEG_ERROR_MEMORY;
    }

    ilclient_wait_for_event(decoder->imageResizer->component,
			    OMX_EventCmdComplete,
			    OMX_CommandPortEnable, 1,
			    decoder->imageResizer->outPort, 1, 0,
			    TIMEOUT_MS);

    return OMXJPEG_OK;
}

int
portSettingsChangedAgain(OPENMAX_JPEG_DECODER * decoder)
{
    ilclient_disable_port(decoder->imageDecoder->component,
			  decoder->imageDecoder->outPort);
    ilclient_disable_port(decoder->imageResizer->component,
			  decoder->imageResizer->inPort);

    OMX_PARAM_PORTDEFINITIONTYPE portdef;

    // need to setup the input for the resizer with the output of the
    // decoder
    portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
    portdef.nVersion.nVersion = OMX_VERSION;
    portdef.nPortIndex = decoder->imageDecoder->outPort;
    OMX_GetParameter(decoder->imageDecoder->handle,
		     OMX_IndexParamPortDefinition, &portdef);

    // tell resizer input what the decoder output will be providing
    portdef.nPortIndex = decoder->imageResizer->inPort;
    OMX_SetParameter(decoder->imageResizer->handle,
		     OMX_IndexParamPortDefinition, &portdef);

    // enable output of decoder and input of resizer (ie enable tunnel)
    ilclient_enable_port(decoder->imageDecoder->component,
			 decoder->imageDecoder->outPort);
    ilclient_enable_port(decoder->imageResizer->component,
			 decoder->imageResizer->inPort);

    // need to wait for this event
    ilclient_wait_for_event(decoder->imageResizer->component,
			    OMX_EventPortSettingsChanged,
			    decoder->imageResizer->outPort, 1,
			    0, 0, 0, TIMEOUT_MS);

    return OMXJPEG_OK;
}

int
prepareResizer(OPENMAX_JPEG_DECODER * decoder)
{
    decoder->imageResizer = malloc(sizeof(COMPONENT_DETAILS));
    if (decoder->imageResizer == NULL) {
	perror("malloc image resizer");
	return OMXJPEG_ERROR_MEMORY;
    }

    int             ret = ilclient_create_component(decoder->client,
						    &decoder->
						    imageResizer->
						    component,
						    "resize",
						    ILCLIENT_DISABLE_ALL_PORTS
						    |
						    ILCLIENT_ENABLE_INPUT_BUFFERS
						    |
						    ILCLIENT_ENABLE_OUTPUT_BUFFERS);
    if (ret != 0) {
	perror("image resizer");
	return OMXJPEG_ERROR_CREATING_COMP;
    }
    // grab the handle for later use
    decoder->imageResizer->handle =
	ILC_GET_HANDLE(decoder->imageResizer->component);

    // get and store the ports
    OMX_PORT_PARAM_TYPE port;
    port.nSize = sizeof(OMX_PORT_PARAM_TYPE);
    port.nVersion.nVersion = OMX_VERSION;

    OMX_GetParameter(ILC_GET_HANDLE(decoder->imageResizer->component),
		     OMX_IndexParamImageInit, &port);
    if (port.nPorts != 2) {
	return OMXJPEG_ERROR_WRONG_NO_PORTS;
    }
    decoder->imageResizer->inPort = port.nStartPortNumber;
    decoder->imageResizer->outPort = port.nStartPortNumber + 1;

    decoder->pOutputBufferHeader = NULL;

    return OMXJPEG_OK;
}

int
prepareImageDecoder(OPENMAX_JPEG_DECODER * decoder)
{
    decoder->imageDecoder = malloc(sizeof(COMPONENT_DETAILS));
    if (decoder->imageDecoder == NULL) {
	perror("malloc image decoder");
	return OMXJPEG_ERROR_MEMORY;
    }

    int             ret = ilclient_create_component(decoder->client,
						    &decoder->
						    imageDecoder->
						    component,
						    "image_decode",
						    ILCLIENT_DISABLE_ALL_PORTS
						    |
						    ILCLIENT_ENABLE_INPUT_BUFFERS);

    if (ret != 0) {
	perror("image decode");
	return OMXJPEG_ERROR_CREATING_COMP;
    }
    // grab the handle for later use in OMX calls directly
    decoder->imageDecoder->handle =
	ILC_GET_HANDLE(decoder->imageDecoder->component);

    // get and store the ports
    OMX_PORT_PARAM_TYPE port;
    port.nSize = sizeof(OMX_PORT_PARAM_TYPE);
    port.nVersion.nVersion = OMX_VERSION;

    OMX_GetParameter(decoder->imageDecoder->handle,
		     OMX_IndexParamImageInit, &port);
    if (port.nPorts != 2) {
	return OMXJPEG_ERROR_WRONG_NO_PORTS;
    }
    decoder->imageDecoder->inPort = port.nStartPortNumber;
    decoder->imageDecoder->outPort = port.nStartPortNumber + 1;

    return OMXJPEG_OK;
}

int
startupImageDecoder(OPENMAX_JPEG_DECODER * decoder)
{
    // move to idle
    ilclient_change_component_state(decoder->imageDecoder->component,
				    OMX_StateIdle);

    // set input image format
    OMX_IMAGE_PARAM_PORTFORMATTYPE imagePortFormat;
    memset(&imagePortFormat, 0, sizeof(OMX_IMAGE_PARAM_PORTFORMATTYPE));
    imagePortFormat.nSize = sizeof(OMX_IMAGE_PARAM_PORTFORMATTYPE);
    imagePortFormat.nVersion.nVersion = OMX_VERSION;
    imagePortFormat.nPortIndex = decoder->imageDecoder->inPort;
    imagePortFormat.eCompressionFormat = OMX_IMAGE_CodingJPEG;
    OMX_SetParameter(decoder->imageDecoder->handle,
		     OMX_IndexParamImagePortFormat, &imagePortFormat);

    // get buffer requirements
    OMX_PARAM_PORTDEFINITIONTYPE portdef;
    portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
    portdef.nVersion.nVersion = OMX_VERSION;
    portdef.nPortIndex = decoder->imageDecoder->inPort;
    OMX_GetParameter(decoder->imageDecoder->handle,
		     OMX_IndexParamPortDefinition, &portdef);

    // enable the port and setup the buffers
    OMX_SendCommand(decoder->imageDecoder->handle,
		    OMX_CommandPortEnable,
		    decoder->imageDecoder->inPort, NULL);
    decoder->inputBufferHeaderCount = portdef.nBufferCountActual;
    // allocate pointer array
    decoder->ppInputBufferHeader =
	(OMX_BUFFERHEADERTYPE **) malloc(sizeof(void) *
					 decoder->inputBufferHeaderCount);
    // allocate each buffer
    int             i;
    for (i = 0; i < decoder->inputBufferHeaderCount; i++) {
	if (OMX_AllocateBuffer(decoder->imageDecoder->handle,
			       &decoder->ppInputBufferHeader[i],
			       decoder->imageDecoder->inPort,
			       (void *) i,
			       portdef.nBufferSize) != OMX_ErrorNone) {
	    perror("Allocate decode buffer");
	    return OMXJPEG_ERROR_MEMORY;
	}
    }
    // wait for port enable to complete - which it should once buffers are 
    // assigned
    int             ret =
	ilclient_wait_for_event(decoder->imageDecoder->component,
				OMX_EventCmdComplete,
				OMX_CommandPortEnable, 0,
				decoder->imageDecoder->inPort, 0,
				0, TIMEOUT_MS);
    if (ret != 0) {
	fprintf(stderr, "Did not get port enable %d\n", ret);
	return OMXJPEG_ERROR_EXECUTING;
    }
    // start executing the decoder 
    ret = OMX_SendCommand(decoder->imageDecoder->handle,
			  OMX_CommandStateSet, OMX_StateExecuting, NULL);
    if (ret != 0) {
	fprintf(stderr, "Error starting image decoder %x\n", ret);
	return OMXJPEG_ERROR_EXECUTING;
    }
    ret = ilclient_wait_for_event(decoder->imageDecoder->component,
				  OMX_EventCmdComplete,
				  OMX_StateExecuting, 0, 0, 1, 0,
				  TIMEOUT_MS);
    if (ret != 0) {
	fprintf(stderr, "Did not receive executing stat %d\n", ret);
	// return OMXJPEG_ERROR_EXECUTING;
    }

    return OMXJPEG_OK;
}

// this function run the boilerplate to setup the openmax components;
int
setupOpenMaxJpegDecoder(OPENMAX_JPEG_DECODER ** pDecoder)
{
    *pDecoder = malloc(sizeof(OPENMAX_JPEG_DECODER));
    if (pDecoder[0] == NULL) {
	perror("malloc decoder");
	return OMXJPEG_ERROR_MEMORY;
    }
    memset(*pDecoder, 0, sizeof(OPENMAX_JPEG_DECODER));

    if ((pDecoder[0]->client = ilclient_init()) == NULL) {
	perror("ilclient_init");
	return OMXJPEG_ERROR_ILCLIENT_INIT;
    }

    if (OMX_Init() != OMX_ErrorNone) {
	ilclient_destroy(pDecoder[0]->client);
	perror("OMX_Init");
	return OMXJPEG_ERROR_OMX_INIT;
    }
    // prepare the image decoder
    int             ret = prepareImageDecoder(pDecoder[0]);
    if (ret != OMXJPEG_OK)
	return ret;

    ret = prepareResizer(pDecoder[0]);
    if (ret != OMXJPEG_OK)
	return ret;

    ret = startupImageDecoder(pDecoder[0]);
    if (ret != OMXJPEG_OK)
	return ret;

    return OMXJPEG_OK;
}

// this function passed the jpeg image buffer in, and returns the decoded
// image
int
decodeImage(OPENMAX_JPEG_DECODER * decoder, char *sourceImage,
	    size_t imageSize)
{
    char           *sourceOffset = sourceImage;	// we store a separate
						// buffer ot image so we
						// can offset it
    size_t          toread = 0;	// bytes left to read from buffer
    toread += imageSize;
    int             bFilled = 0;	// have we filled our output
					// buffer
    bufferIndex = 0;

    while (toread > 0) {
	// get next buffer from array
	OMX_BUFFERHEADERTYPE *pBufHeader =
	    decoder->ppInputBufferHeader[bufferIndex];

	// step index and reset to 0 if required
	bufferIndex++;
	if (bufferIndex >= decoder->inputBufferHeaderCount)
	    bufferIndex = 0;

	// work out the next chunk to load into the decoder
	if (toread > pBufHeader->nAllocLen)
	    pBufHeader->nFilledLen = pBufHeader->nAllocLen;
	else
	    pBufHeader->nFilledLen = toread;

	toread = toread - pBufHeader->nFilledLen;

	// pass the bytes to the buffer
	memcpy(pBufHeader->pBuffer, sourceOffset, pBufHeader->nFilledLen);

	// update the buffer pointer and set the input flags

	sourceOffset = sourceOffset + pBufHeader->nFilledLen;
	pBufHeader->nOffset = 0;
	pBufHeader->nFlags = 0;
	if (toread <= 0) {
	    pBufHeader->nFlags = OMX_BUFFERFLAG_EOS;
	}
	// empty the current buffer
	int             ret =
	    OMX_EmptyThisBuffer(decoder->imageDecoder->handle,
				pBufHeader);

	if (ret != OMX_ErrorNone) {
	    perror("Empty input buffer");
	    fprintf(stderr, "return code %x\n", ret);
	    return OMXJPEG_ERROR_MEMORY;
	}
	// wait for buffer to empty or port changed event
	int             done = 0;
	while ((done == 0) && (decoder->pOutputBufferHeader == NULL)) {
	    if (decoder->pOutputBufferHeader == NULL) {
		ret =
		    ilclient_wait_for_event
		    (decoder->imageDecoder->component,
		     OMX_EventPortSettingsChanged,
		     decoder->imageDecoder->outPort, 0, 0, 1, 0, 5);

		if (ret == 0) {
		    ret = portSettingsChanged(decoder);
		    if (ret != OMXJPEG_OK)
			return ret;
		}
	    } else {
		ret =
		    ilclient_remove_event(decoder->imageDecoder->component,
					  OMX_EventPortSettingsChanged,
					  decoder->imageDecoder->outPort,
					  0, 0, 1);
		if (ret == 0)
		    portSettingsChangedAgain(decoder);

	    }

	    // check to see if buffer is now empty
	    if (pBufHeader->nFilledLen == 0)
		done = 1;

	    if ((done == 0)
		|| (decoder->pOutputBufferHeader == NULL))
		sleep(1);
	}

	// fill the buffer if we have created the buffer
	if ((bFilled == 0) && (decoder->pOutputBufferHeader != NULL)) {
	    ret = OMX_FillThisBuffer(decoder->imageResizer->handle,
				     decoder->pOutputBufferHeader);
	    if (ret != OMX_ErrorNone) {
		perror("Filling output buffer");
		fprintf(stderr, "Error code %x\n", ret);
		return OMXJPEG_ERROR_MEMORY;
	    }

	    bFilled = 1;
	}
    }

    // wait for buffer to fill
    /*
     * while(pBufHeader->nFilledLen == 0) { sleep(5); } 
     */

    // wait for end of stream events
    int             ret =
	ilclient_wait_for_event(decoder->imageDecoder->component,
				OMX_EventBufferFlag,
				decoder->imageDecoder->outPort, 1,
				OMX_BUFFERFLAG_EOS, 1,
				0, 2);
    if (ret != 0) {
	fprintf(stderr, "No EOS event on image decoder %d\n", ret);
    }
    ret = ilclient_wait_for_event(decoder->imageResizer->component,
				  OMX_EventBufferFlag,
				  decoder->imageResizer->outPort, 1,
				  OMX_BUFFERFLAG_EOS, 1, 0, 2);
    if (ret != 0) {
	fprintf(stderr, "No EOS event on image resizer %d\n", ret);
    }
    return OMXJPEG_OK;
}

// this function cleans up the decoder.
void
cleanup(OPENMAX_JPEG_DECODER * decoder)
{
    // flush everything through
    OMX_SendCommand(decoder->imageDecoder->handle,
		    OMX_CommandFlush, decoder->imageDecoder->outPort,
		    NULL);
    ilclient_wait_for_event(decoder->imageDecoder->component,
			    OMX_EventCmdComplete, OMX_CommandFlush, 0,
			    decoder->imageDecoder->outPort, 0, 0,
			    TIMEOUT_MS);
    OMX_SendCommand(decoder->imageResizer->handle, OMX_CommandFlush,
		    decoder->imageResizer->inPort, NULL);
    ilclient_wait_for_event(decoder->imageResizer->component,
			    OMX_EventCmdComplete, OMX_CommandFlush, 0,
			    decoder->imageResizer->inPort, 1, 0,
			    TIMEOUT_MS);

    OMX_SendCommand(decoder->imageDecoder->handle, OMX_CommandPortDisable,
		    decoder->imageDecoder->inPort, NULL);

    int             i = 0;
    for (i = 0; i < decoder->inputBufferHeaderCount; i++) {
	OMX_BUFFERHEADERTYPE *vpBufHeader =
	    decoder->ppInputBufferHeader[i];

	OMX_FreeBuffer(decoder->imageDecoder->handle,
		       decoder->imageDecoder->inPort, vpBufHeader);
    }

    ilclient_wait_for_event(decoder->imageDecoder->component,
			    OMX_EventCmdComplete, OMX_CommandPortDisable,
			    0, decoder->imageDecoder->inPort, 0, 0,
			    TIMEOUT_MS);

    OMX_SendCommand(decoder->imageResizer->handle, OMX_CommandPortDisable,
		    decoder->imageResizer->outPort, NULL);

    OMX_FreeBuffer(decoder->imageResizer->handle,
		   decoder->imageResizer->outPort,
		   decoder->pOutputBufferHeader);

    ilclient_wait_for_event(decoder->imageResizer->component,
			    OMX_EventCmdComplete, OMX_CommandPortDisable,
			    0, decoder->imageResizer->outPort, 0, 0,
			    TIMEOUT_MS);

    OMX_SendCommand(decoder->imageDecoder->handle, OMX_CommandPortDisable,
		    decoder->imageDecoder->outPort, NULL);
    ilclient_wait_for_event(decoder->imageDecoder->component,
			    OMX_EventCmdComplete, OMX_CommandPortDisable,
			    0, decoder->imageDecoder->outPort, 0, 0,
			    TIMEOUT_MS);

    OMX_SendCommand(decoder->imageResizer->handle, OMX_CommandPortDisable,
		    decoder->imageResizer->inPort, NULL);
    ilclient_wait_for_event(decoder->imageResizer->component,
			    OMX_EventCmdComplete, OMX_CommandPortDisable,
			    0, decoder->imageResizer->inPort, 0, 0,
			    TIMEOUT_MS);

    OMX_SetupTunnel(decoder->imageDecoder->handle,
		    decoder->imageDecoder->outPort, NULL, 0);
    OMX_SetupTunnel(decoder->imageResizer->handle,
		    decoder->imageResizer->inPort, NULL, 0);

    ilclient_change_component_state(decoder->imageDecoder->component,
				    OMX_StateIdle);
    ilclient_change_component_state(decoder->imageResizer->component,
				    OMX_StateIdle);

    ilclient_wait_for_event(decoder->imageDecoder->component,
			    OMX_EventCmdComplete, OMX_CommandStateSet, 0,
			    OMX_StateIdle, 0, 0, TIMEOUT_MS);
    ilclient_wait_for_event(decoder->imageResizer->component,
			    OMX_EventCmdComplete, OMX_CommandStateSet, 0,
			    OMX_StateIdle, 0, 0, TIMEOUT_MS);

    ilclient_change_component_state(decoder->imageDecoder->component,
				    OMX_StateLoaded);
    ilclient_change_component_state(decoder->imageResizer->component,
				    OMX_StateLoaded);

    ilclient_wait_for_event(decoder->imageDecoder->component,
			    OMX_EventCmdComplete, OMX_CommandStateSet, 0,
			    OMX_StateLoaded, 0, 0, TIMEOUT_MS);
    ilclient_wait_for_event(decoder->imageResizer->component,
			    OMX_EventCmdComplete, OMX_CommandStateSet, 0,
			    OMX_StateLoaded, 0, 0, TIMEOUT_MS);

    OMX_Deinit();

    if (decoder->client != NULL) {
	ilclient_destroy(decoder->client);
    }
}

int
main(int argc, char *argv[])
{
    OPENMAX_JPEG_DECODER *pDecoder;
    char           *sourceImage;
    size_t          imageSize;
    int             s;
    if (argc < 2) {
	printf("Usage: %s <filename>\n", argv[0]);
	return -1;
    }
    FILE           *fp = fopen(argv[1], "rb");
    if (!fp) {
	printf("File %s not found.\n", argv[1]);
    }
    fseek(fp, 0L, SEEK_END);
    imageSize = ftell(fp);
    fseek(fp, 0L, SEEK_SET);
    sourceImage = malloc(imageSize);
    assert(sourceImage != NULL);
    s = fread(sourceImage, 1, imageSize, fp);
    assert(s == imageSize);
    fclose(fp);
    bcm_host_init();
    s = setupOpenMaxJpegDecoder(&pDecoder);
    assert(s == 0);
    s = decodeImage(pDecoder, sourceImage, imageSize);
    assert(s == 0);
    cleanup(pDecoder);
    free(sourceImage);
    return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Matt Ownby
                    Anthong Sale

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _OPTION_H_
#define _OPTION_H_

/*
Defines the methods for interacting with openmax il and ilclient to decode
jpeg images from the camera
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include "bcm_host.h"
#include "ilclient.h"

#define OMXJPEG_OK                  0
#define OMXJPEG_ERROR_ILCLIENT_INIT    -1024
#define OMXJPEG_ERROR_OMX_INIT         -1025
#define OMXJPEG_ERROR_MEMORY         -1026
#define OMXJPEG_ERROR_CREATING_COMP    -1027
#define OMXJPEG_ERROR_WRONG_NO_PORTS   -1028
#define OMXJPEG_ERROR_EXECUTING         -1029
#define OMXJPEG_ERROR_NOSETTINGS   -1030

typedef struct _OPENMAX_JPEG_DECODER OPENMAX_JPEG_DECODER;

//this function run the boilerplate to setup the openmax components;
int setupOpenMaxJpegDecoder(OPENMAX_JPEG_DECODER** decoder);

//this function passed the jpeg image buffer in, and returns the decoded image
int decodeImage(OPENMAX_JPEG_DECODER* decoder,
              char* sourceImage, size_t imageSize);

//this function cleans up the decoder.
void cleanup(OPENMAX_JPEG_DECODER* decoder);

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             OBJS=triangle.o video.o models.o
BIN=hello_teapot.bin
LDFLAGS+=-lilclient

include ../Makefile.include


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       hello_videocube
===============

Sample for Raspberry Pi that uses egl_render to display video on an animated cube.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Spatial coordinates for the cube

static const GLbyte quadx[6*4*3] = {
   /* FRONT */
   -10, -10,  10,
   10, -10,  10,
   -10,  10,  10,
   10,  10,  10,

   /* BACK */
   -10, -10, -10,
   -10,  10, -10,
   10, -10, -10,
   10,  10, -10,

   /* LEFT */
   -10, -10,  10,
   -10,  10,  10,
   -10, -10, -10,
   -10,  10, -10,

   /* RIGHT */
   10, -10, -10,
   10,  10, -10,
   10, -10,  10,
   10,  10,  10,

   /* TOP */
   -10,  10,  10,
   10,  10,  10,
   -10,  10, -10,
   10,  10, -10,

   /* BOTTOM */
   -10, -10,  10,
   -10, -10, -10,
   10, -10,  10,
   10, -10, -10,
};

/** Texture coordinates for the quad. */
static const GLfloat texCoords[6 * 4 * 2] = {
   0.f,  0.f,
   0.f,  1.f,
   1.f,  0.f,
   1.f,  1.f,

   0.f,  0.f,
   0.f,  1.f,
   1.f,  0.f,
   1.f,  1.f,

   0.f,  0.f,
   0.f,  1.f,
   1.f,  0.f,
   1.f,  1.f,

   0.f,  0.f,
   0.f,  1.f,
   1.f,  0.f,
   1.f,  1.f,

   0.f,  0.f,
   0.f,  1.f,
   1.f,  0.f,
   1.f,  1.f,

   0.f,  0.f,
   0.f,  1.f,
   1.f,  0.f,
   1.f,  1.f
};

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <math.h>
#include <stdio.h>
#include <stdint.h>

#include "GLES/gl.h"
#include "EGL/egl.h"
#include "EGL/eglext.h"
#include "models.h"

#define VMCS_RESOURCE(a,b) (b)

/******************************************************************************
Private typedefs, macros and constants
******************************************************************************/

enum {VBO_VERTEX, VBO_NORMAL, VBO_TEXTURE, VBO_MAX};
#define MAX_MATERIALS 4
#define MAX_MATERIAL_NAME 32

typedef struct wavefront_material_s {
   GLuint vbo[VBO_MAX];
   int numverts;
   char name[MAX_MATERIAL_NAME];
   GLuint texture;
} WAVEFRONT_MATERIAL_T;

typedef struct wavefront_model_s {
   WAVEFRONT_MATERIAL_T material[MAX_MATERIALS];
   int num_materials;
   GLuint texture;
} WAVEFRONT_MODEL_T;


/******************************************************************************
Static Data
******************************************************************************/

/******************************************************************************
Static Function Declarations
******************************************************************************/

/******************************************************************************
Static Function Definitions
******************************************************************************/

static void create_vbo(GLenum type, GLuint *vbo, int size, void *data)
{
   glGenBuffers(1, vbo);
   vc_assert(*vbo);
   glBindBuffer(type, *vbo);
   glBufferData(type, size, data, GL_STATIC_DRAW);
   glBindBuffer(type, 0);     
}


static void destroy_vbo(GLuint *vbo)
{
   glDeleteBuffers(1, vbo);
   *vbo = 0;
}

#define MAX_VERTICES 100000
static void *allocbuffer(int size)
{
   return malloc(size);
}

static void freebuffer(void *p)
{
   free (p);
}

static void centre_and_rescale(float *verts, int numvertices)
{
   float cx=0.0f, cy=0.0f, cz=0.0f, scale=0.0f;
   float minx=0.0f, miny=0.0f, minz=0.0f;
   float maxx=0.0f, maxy=0.0f, maxz=0.0f;
   int i;
   float *v = verts;
   minx = maxx = verts[0];
   miny = maxy = verts[1];
   minz = maxz = verts[2];
   for (i=0; i<numvertices; i++) {
      float x = *v++;
      float y = *v++;
      float z = *v++;
      minx = vcos_min(minx, x);
      miny = vcos_min(miny, y);
      minz = vcos_min(minz, z);
      maxx = vcos_max(maxx, x);
      maxy = vcos_max(maxy, y);
      maxz = vcos_max(maxz, z);
      cx += x;
      cy += y;
      cz += z;
   }
   cx /= (float)numvertices;
   cy /= (float)numvertices;
   cz /= (float)numvertices;
   scale = 3.0f / (maxx-minx + maxy-miny + maxz-minz);
   v = verts;
   for (i=0; i<numvertices; i++) {
      *v = (*v-cx) * scale; v++;
      *v = (*v-cy) * scale; v++;
      *v = (*v-cz) * scale; v++;
   }
}

static void renormalise(float *verts, int numvertices)
{
   int i;
   float *v = verts;
   for (i=0;i<numvertices; i++) {
      float x = v[0];
      float y = v[1];
      float z = v[2];
      float scale = 1.0f/sqrtf(x*x + y*y + z*z);
      *v++ = x * scale;
      *v++ = y * scale;
      *v++ = z * scale;
   }
}

static void deindex(float *dst, const float *src, const unsigned short *indexes, GLsizei size, GLsizei count)
{
   int i;
   for (i=0; i<count; i++) {
      int ind = size * (indexes[0]-1);
      *dst++ = src[ind + 0];
      *dst++ = src[ind + 1];
      // todo: optimise - move out of loop
      if (size >= 3) *dst++ = src[ind + 2];
      indexes += 3;
   }
}

int draw_wavefront(MODEL_T m, GLuint texture)
{
   int i;
   WAVEFRONT_MODEL_T *model = (WAVEFRONT_MODEL_T *)m;

   for (i=0; i<model->num_materials; i++) {
      WAVEFRONT_MATERIAL_T *mat = model->material + i;
      if (mat->texture == -1) continue;
      glBindTexture(GL_TEXTURE_2D, mat->texture ? mat->texture:texture);
      if (mat->vbo[VBO_VERTEX]) {
         glBindBuffer(GL_ARRAY_BUFFER, mat->vbo[VBO_VERTEX]);
         glVertexPointer(3, GL_FLOAT, 0, NULL);
      }
      if (mat->vbo[VBO_NORMAL]) {   
         glEnableClientState(GL_NORMAL_ARRAY);
         glBindBuffer(GL_ARRAY_BUFFER, mat->vbo[VBO_NORMAL]);
         glNormalPointer(GL_FLOAT, 0, NULL);
      } else {
         glDisableClientState(GL_NORMAL_ARRAY);
      }
      if (mat->vbo[VBO_TEXTURE]) {   
         glEnableClientState(GL_TEXTURE_COORD_ARRAY);
         glBindBuffer(GL_ARRAY_BUFFER, mat->vbo[VBO_TEXTURE]);
         glTexCoordPointer(2, GL_FLOAT, 0, NULL);
      } else {
         glDisableClientState(GL_TEXTURE_COORD_ARRAY);
      }
      glDrawArrays(GL_TRIANGLES, 0, mat->numverts);
   }
   glBindBuffer(GL_ARRAY_BUFFER, 0);
   return 0;
}

struct wavefront_model_loading_s {
   unsigned short material_index[MAX_MATERIALS];
   int num_materials;
   int numv, numt, numn, numf;
   unsigned int data[0];
};

static int load_wavefront_obj(const char *modelname, WAVEFRONT_MODEL_T *model, struct wavefront_model_loading_s *m)
{
   char line[256+1];
   unsigned short pp[54+1];
   FILE *fp;
   int i, valid;
   float *qv = (float *)m->data;
   float *qt = (float *)m->data + 3 * MAX_VERTICES;
   float *qn = (float *)m->data + (3+2) * MAX_VERTICES;
   unsigned short *qf = (unsigned short *)((float *)m->data + (3+2+3) * MAX_VERTICES);
   float *pv = qv, *pt = qt, *pn = qn;
   unsigned short *pf = qf;
   fp = fopen(modelname, "r");
   if (!fp) return -1;

   m->num_materials = 0;
   m->material_index[0] = 0;

   valid = fread(line, 1, sizeof(line)-1, fp);

   while (valid > 0) {
      char *s, *end = line;
      
      while((end-line < valid) && *end != '\n' && *end != '\r')
         end++;
      *end++ = 0;

      if((end-line < valid) && *end != '\n' && *end != '\r')
         *end++ = 0;

      s = line;

      if (s[strlen(s)-1] == 10) s[strlen(s)-1]=0;
      switch (s[0]) {
      case '#': break; // comment
      case '\r': case '\n': case '\0': break; // blank line
      case 'm': vc_assert(strncmp(s, "mtllib", sizeof "mtllib"-1)==0); break;
      case 'o': break;
      case 'u': 
         if (sscanf(s, "usemtl %s", /*MAX_MATERIAL_NAME-1, */model->material[m->num_materials].name) == 1) {
            if (m->num_materials < MAX_MATERIALS) {
               if (m->num_materials > 0 && ((pf-qf)/3 == m->material_index[m->num_materials-1] || strcmp(model->material[m->num_materials-1].name, model->material[m->num_materials].name)==0)) {
                  strcpy(model->material[m->num_materials-1].name, model->material[m->num_materials].name);
                  m->num_materials--;
               } else
               m->material_index[m->num_materials] = (pf-qf)/3;
               m->num_materials++;
            }
         } else { printf(s); vc_assert(0); }
         break;
      case 'g': vc_assert(strncmp(s, "g ", sizeof "g "-1)==0); break;
      case 's': vc_assert(strncmp(s, "s ", sizeof "s "-1)==0); break;
      case 'v': case 'f':
         if (sscanf(s, "v %f %f %f", pv+0, pv+1, pv+2) == 3) {
            pv += 3;
         } else if (sscanf(s, "vt %f %f", pt+0, pt+1) == 2) {
            pt += 2;
         } else if (sscanf(s, "vn %f %f %f", pn+0, pn+1, pn+2) == 3) {
            pn += 3;
         } else if (i = sscanf(s, "f"" %hu//%hu %hu//%hu %hu//%hu %hu//%hu %hu//%hu %hu//%hu"
                                     " %hu//%hu %hu//%hu %hu//%hu %hu//%hu %hu//%hu %hu//%hu"
                                     " %hu//%hu %hu//%hu %hu//%hu %hu//%hu %hu//%hu %hu//%hu %hu",
               pp+ 0, pp+ 1, pp+ 2, pp+ 3, pp+ 4, pp+ 5, pp+ 6, pp+ 7, pp+ 8, pp+ 9, pp+10, pp+11, 
               pp+12, pp+13, pp+14, pp+15, pp+16, pp+17, pp+18, pp+19, pp+20, pp+21, pp+22, pp+23, 
               pp+24, pp+25, pp+26, pp+27, pp+28, pp+29, pp+30, pp+32, pp+32, pp+33, pp+34, pp+35, pp+36), i >= 6) {
            int poly = i/2;
            //vc_assert(i < countof(pp)); // may need to increment poly count and pp array
            for (i=1; i<poly-1; i++) {
               *pf++ = pp[0]; *pf++ = 0; *pf++ = pp[1];
               *pf++ = pp[2*i+0]; *pf++ = 0; *pf++ = pp[2*i+1];
               *pf++ = pp[2*(i+1)+0]; *pf++ = 0; *pf++ = pp[2*(i+1)+1];
            }
         } else if (i = sscanf(s, "f"" %hu/%hu %hu/%hu %hu/%hu %hu/%hu %hu/%hu %hu/%hu"
                                     " %hu/%hu %hu/%hu %hu/%hu %hu/%hu %hu/%hu %hu/%hu"
                                     " %hu/%hu %hu/%hu %hu/%hu %hu/%hu %hu/%hu %hu/%hu %hu",
               pp+ 0, pp+ 1, pp+ 2, pp+ 3, pp+ 4, pp+ 5, pp+ 6, pp+ 7, pp+ 8, pp+ 9, pp+10, pp+11, 
               pp+12, pp+13, pp+14, pp+15, pp+16, pp+17, pp+18, pp+19, pp+20, pp+21, pp+22, pp+23, 
               pp+24, pp+25, pp+26, pp+27, pp+28, pp+29, pp+30, pp+32, pp+32, pp+33, pp+34, pp+35, pp+36), i >= 6) {
            int poly = i/2;
            //vc_assert(i < countof(pp); // may need to increment poly count and pp array
            for (i=1; i<poly-1; i++) {
               *pf++ = pp[0]; *pf++ = pp[1]; *pf++ = 0;
               *pf++ = pp[2*i+0]; *pf++ = pp[2*i+1]; *pf++ = 0;
               *pf++ = pp[2*(i+1)+0]; *pf++ = pp[2*(i+1)+1]; *pf++ = 0;
            }
         } else if (i = sscanf(s, "f"" %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu"
                                     " %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu"
                                     " %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu %hu/%hu/%hu %hu",
               pp+ 0, pp+ 1, pp+ 2, pp+ 3, pp+ 4, pp+ 5, pp+ 6, pp+ 7, pp+ 8, pp+ 9, pp+10, pp+11, pp+12, pp+13, pp+14, pp+15, pp+16, pp+17, 
               pp+18, pp+19, pp+20, pp+21, pp+22, pp+23, pp+24, pp+25, pp+26, pp+27, pp+28, pp+29, pp+30, pp+32, pp+32, pp+33, pp+34, pp+35, 
               pp+36, pp+37, pp+38, pp+39, pp+40, pp+41, pp+42, pp+43, pp+44, pp+45, pp+46, pp+47, pp+48, pp+49, pp+50, pp+51, pp+52, pp+53, pp+54), i >= 9) {
            int poly = i/3;
            //vc_assert(i < countof(pp); // may need to increment poly count and pp array
            for (i=1; i<poly-1; i++) {
               *pf++ = pp[0]; *pf++ = pp[1]; *pf++ = pp[2];
               *pf++ = pp[3*i+0]; *pf++ = pp[3*i+1]; *pf++ = pp[3*i+2];
               *pf++ = pp[3*(i+1)+0]; *pf++ = pp[3*(i+1)+1]; *pf++ = pp[3*(i+1)+2];
            }
         } else { printf(s); vc_assert(0); }
         break;
      default: 
         printf("%02x %02x %s", s[0], s[1], s); vc_assert(0); break;
      }

      // shift down read characters and read some more into the end
      // if we didn't find a newline, then end is one off the end of our
      // line, so end-line will be valid+1
      i = end-line > valid ? valid : end-line;
      memmove(line, end, valid - i);
      valid -= i;
      valid += fread(line+valid, 1, sizeof(line)-1-valid, fp);
   }
   fclose(fp);

   if (m->num_materials==0) m->material_index[m->num_materials++] = 0;

   centre_and_rescale(qv, (pv-qv)/3);
   renormalise(qn, (pn-qn)/3);
   //centre_and_rescale2(qt, (pt-qt)/2);

   m->numv = pv-qv;
   m->numt = pt-qt;
   m->numn = pn-qn;
   m->numf = pf-qf;

   // compress array
   //memcpy((float *)m->data, (float *)m->data, m->numv * sizeof *qv); - nop
   memcpy((float *)m->data + m->numv, (float *)m->data + 3 * MAX_VERTICES, m->numt * sizeof *qt);
   memcpy((float *)m->data + m->numv + m->numt,(float *) m->data + (3 + 2) * MAX_VERTICES, m->numn * sizeof *qn);
   memcpy((float *)m->data + m->numv + m->numt + m->numn, (float *)m->data + (3 + 2 + 3) * MAX_VERTICES, m->numf * sizeof *qf);

   return 0;
}

static int load_wavefront_dat(const char *modelname, WAVEFRONT_MODEL_T *model, struct wavefront_model_loading_s *m)
{
   FILE *fp;
   int s;
   const int size = sizeof *m + 
      sizeof(float)*(3+2+3)*MAX_VERTICES +   // 3 vertices + 2 textures + 3 normals
      sizeof(unsigned short)*3*MAX_VERTICES; //each face has 9 vertices

   fp = fopen(modelname, "r");
   if (!fp) return -1;
   s = fread(m, 1, size, fp);
   if (s < 0) return -1;
   fclose(fp);
   return 0;
}

MODEL_T load_wavefront(const char *modelname, const char *texturename)
{
   WAVEFRONT_MODEL_T *model;
   float *temp, *qv, *qt, *qn;
   unsigned short *qf;
   int i;
   int numverts = 0, offset = 0;
   struct wavefront_model_loading_s *m;
   int s=-1;
   char modelname_obj[128];
   model = malloc(sizeof *model);
   if (!model || !modelname) return NULL;
   memset (model, 0, sizeof *model);
   model->texture = 0; //load_texture(texturename);
   m = allocbuffer(sizeof *m + 
      sizeof(float)*(3+2+3)*MAX_VERTICES +    // 3 vertices + 2 textures + 3 normals
      sizeof(unsigned short)*3*MAX_VERTICES); //each face has 9 vertices
   if (!m) return 0;

   if (strlen(modelname) + 5 <= sizeof modelname_obj) {
      strcpy(modelname_obj, modelname);
      strcat(modelname_obj, ".dat");
      s = load_wavefront_dat(modelname_obj, model, m);
   }
   if (s==0) {}
   else if (strncmp(modelname + strlen(modelname) - 4, ".obj", 4) == 0) {
      #ifdef DUMP_OBJ_DAT
      int size;
      FILE *fp;
      #endif
      s = load_wavefront_obj(modelname, model, m);
      #ifdef DUMP_OBJ_DAT
      strcpy(modelname_obj, modelname);
      strcat(modelname_obj, ".dat");
      size = sizeof *m + 
         sizeof(float)*(3*m->numv+2*m->numt+3*m->numn) +  // 3 vertices + 2 textures + 3 normals
         sizeof(unsigned short)*3*m->numf;                //each face has 9 vertices
      fp = host_file_open(modelname_obj, "w");
      fwrite(m, 1, size, fp);
      fclose(fp);
      #endif
   } else if (strncmp(modelname + strlen(modelname) - 4, ".dat", 4) == 0) {
      s = load_wavefront_dat(modelname, model, m);
   }
   if (s != 0) return 0;

   qv = (float *)(m->data);
   qt = (float *)(m->data + m->numv);
   qn = (float *)(m->data + m->numv + m->numt);
   qf = (unsigned short *)(m->data + m->numv + m->numt + m->numn);

   numverts = m->numf/3;
   vc_assert(numverts <= MAX_VERTICES);

   temp = allocbuffer(3*numverts*sizeof *temp);
   for (i=0; i<m->num_materials; i++) {
      WAVEFRONT_MATERIAL_T *mat = model->material + i;
      mat->numverts = i < m->num_materials-1 ? m->material_index[i+1]-m->material_index[i] : numverts - m->material_index[i];
      // vertex, texture, normal
      deindex(temp, qv, qf+3*offset+0, 3, mat->numverts);
      create_vbo(GL_ARRAY_BUFFER, mat->vbo+VBO_VERTEX, 3 * mat->numverts * sizeof *qv, temp); // 3
   
      deindex(temp, qt, qf+3*offset+1, 2, mat->numverts);
      create_vbo(GL_ARRAY_BUFFER, mat->vbo+VBO_TEXTURE, 2 * mat->numverts * sizeof *qt, temp); // 2
   
      deindex(temp, qn, qf+3*offset+2, 3, mat->numverts);
      create_vbo(GL_ARRAY_BUFFER, mat->vbo+VBO_NORMAL, 3 * mat->numverts * sizeof *qn, temp); // 3
      offset += mat->numverts;
      mat->texture = model->texture;
   }
   model->num_materials = m->num_materials;
   vc_assert(offset == numverts);
   freebuffer(temp);
   freebuffer(m);
   return (MODEL_T)model;
}

void unload_wavefront(MODEL_T m)
{
   WAVEFRONT_MODEL_T *model = (WAVEFRONT_MODEL_T *)m;
   int i;
   for (i=0; i<model->num_materials; i++) {
      WAVEFRONT_MATERIAL_T *mat = model->material + i;
      if (mat->vbo[VBO_VERTEX])
         destroy_vbo(mat->vbo+VBO_VERTEX);
      if (mat->vbo[VBO_TEXTURE])
         destroy_vbo(mat->vbo+VBO_TEXTURE);
      if (mat->vbo[VBO_NORMAL])
         destroy_vbo(mat->vbo+VBO_NORMAL);
   }
}

// create a cube model that looks like a wavefront model, 
MODEL_T cube_wavefront(void)
{
   static const float qv[] = {
    -0.5f, -0.5f,  0.5f,
    -0.5f, -0.5f, -0.5f,
     0.5f, -0.5f, -0.5f,
     0.5f, -0.5f,  0.5f,
    -0.5f,  0.5f,  0.5f,
     0.5f,  0.5f,  0.5f,
     0.5f,  0.5f, -0.5f,
    -0.5f,  0.5f, -0.5f,
   };
   
   static const float qn[] = {
     0.0f, -1.0f, -0.0f,
     0.0f,  1.0f, -0.0f,
     0.0f,  0.0f,  1.0f,
     1.0f,  0.0f, -0.0f,
     0.0f,  0.0f, -1.0f,
    -1.0f,  0.0f, -0.0f,
   };
   
   static const float qt[] = {
    1.0f, 0.0f,
    1.0f, 1.0f,
    0.0f, 1.0f,
    0.0f, 0.0f,
   };
   
   static const unsigned short qf[] = {
    1,1,1, 2,2,1, 3,3,1,
    3,3,1, 4,4,1, 1,1,1,
    5,4,2, 6,1,2, 7,2,2,
    7,2,2, 8,3,2, 5,4,2,
    1,4,3, 4,1,3, 6,2,3,
    6,2,3, 5,3,3, 1,4,3,
    4,4,4, 3,1,4, 7,2,4,
    7,2,4, 6,3,4, 4,4,4,
    3,4,5, 2,1,5, 8,2,5,
    8,2,5, 7,3,5, 3,4,5,
    2,4,6, 1,1,6, 5,2,6,
    5,2,6, 8,3,6, 2,4,6,
   };
   WAVEFRONT_MODEL_T *model = malloc(sizeof *model);
   if (model) {
      WAVEFRONT_MATERIAL_T *mat = model->material;
      float *temp;
      const int offset = 0;
      memset(model, 0, sizeof *model);

      temp = allocbuffer(3*MAX_VERTICES*sizeof *temp);
      mat->numverts = countof(qf)/3;
      // vertex, texture, normal
      deindex(temp, qv, qf+3*offset+0, 3, mat->numverts);
      create_vbo(GL_ARRAY_BUFFER, mat->vbo+VBO_VERTEX, 3 * mat->numverts * sizeof *qv, temp); // 3

      deindex(temp, qt, qf+3*offset+1, 2, mat->numverts);
      create_vbo(GL_ARRAY_BUFFER, mat->vbo+VBO_TEXTURE, 2 * mat->numverts * sizeof *qt, temp); // 2

      deindex(temp, qn, qf+3*offset+2, 3, mat->numverts);
      create_vbo(GL_ARRAY_BUFFER, mat->vbo+VBO_NORMAL, 3 * mat->numverts * sizeof *qn, temp); // 3

      freebuffer(temp);
      model->num_materials = 1;
   }
   return (MODEL_T)model;
}


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MODELS_T
#define MODELS_T
typedef struct opqaue_model_s * MODEL_T;

MODEL_T load_wavefront(const char *modelname, const char *texturename);
MODEL_T cube_wavefront(void);
void unload_wavefront(MODEL_T m);
int draw_wavefront(MODEL_T m, GLuint texture);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#pragma once


void* video_decode_test(void* arg);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 OpenVG 1.1 Reference Implementation
-----------------------------------

Copyright (c) 2007 The Khronos Group Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and /or associated documentation files
(the "Materials "), to deal in the Materials without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Materials,
and to permit persons to whom the Materials are furnished to do so,
subject to the following conditions: 

The above copyright notice and this permission notice shall be included 
in all copies or substantial portions of the Materials. 

THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR
THE USE OR OTHER DEALINGS IN THE MATERIALS.


Path data for the Tiger sample program has been extracted from Ghostscript's
tiger.eps example file distributed under GNU General Public License.

Ghostscript's License document:
" The files in the src, lib, toolbin, examples, doc and man
  directories (folders) and any subdirectories (sub-folders)
  thereof are part of GPL Ghostscript.

  The files in the Resource directory and any subdirectories thereof
  are also part of GPL Ghostscript, with the explicit exception of
  the files in the CMap subdirectory. The CMap files are copyright
  Adobe Systems Incorporated and covered by a separate license
  which permits only verbatim distribution.

  GPL Ghostscript is free software; you can redistribute it and/or
  modify it under the terms of version 2 of the GNU General Public
  License as published by the Free Software Foundation.

  GPL Ghostscript is distributed in the hope that it will be
  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program so you can know your rights and responsibilities.
  It should be in a file named doc/COPYING. If not, write to the
  Free Software Foundation, Inc., 59 Temple Place Suite 330, Boston, MA
  02111-1307, USA."
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #ifndef __TIGER_H
#define __TIGER_H

/*------------------------------------------------------------------------
 *
 * OpenVG 1.0.1 Reference Implementation sample code
 * -------------------------------------------------
 *
 * Copyright (c) 2007 The Khronos Group Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and /or associated documentation files
 * (the "Materials "), to deal in the Materials without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Materials,
 * and to permit persons to whom the Materials are furnished to do so,
 * subject to the following conditions: 
 *
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Materials. 
 *
 * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR
 * THE USE OR OTHER DEALINGS IN THE MATERIALS.
 *
 *//**
 * \file
 * \brief	Header for including the Tiger image data.
 * \note	
 *//*-------------------------------------------------------------------*/

extern const int tigerCommandCount;
extern const char tigerCommands[];
extern const float tigerMinX;
extern const float tigerMaxX;
extern const float tigerMinY;
extern const float tigerMaxY;
extern const int tigerPointCount;
extern const float tigerPoints[];

#endif /* __TIGER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
Copyright (c) 2012, OtherCrashOverride
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// A rotating cube rendered with OpenGL|ES. Three images used as textures on the cube faces.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>
#include <unistd.h>

#include "bcm_host.h"

#include "GLES/gl.h"
#include "EGL/egl.h"
#include "EGL/eglext.h"

#include "cube_texture_and_coords.h"
#include "models.h"
#include "triangle.h"
#include <pthread.h>


#define PATH "./"

#define IMAGE_SIZE_WIDTH 1920
#define IMAGE_SIZE_HEIGHT 1080

#ifndef M_PI
   #define M_PI 3.141592654
#endif
  

typedef struct
{
   uint32_t screen_width;
   uint32_t screen_height;
// OpenGL|ES objects
   EGLDisplay display;
   EGLSurface surface;
   EGLContext context;
   GLuint tex;
// model rotation vector and direction
   GLfloat rot_angle_x_inc;
   GLfloat rot_angle_y_inc;
   GLfloat rot_angle_z_inc;
// current model rotation angles
   GLfloat rot_angle_x;
   GLfloat rot_angle_y;
   GLfloat rot_angle_z;
// current distance from camera
   GLfloat distance;
   GLfloat distance_inc;
   MODEL_T model;
} CUBE_STATE_T;

static void init_ogl(CUBE_STATE_T *state);
static void init_model_proj(CUBE_STATE_T *state);
static void reset_model(CUBE_STATE_T *state);
static GLfloat inc_and_wrap_angle(GLfloat angle, GLfloat angle_inc);
static GLfloat inc_and_clip_distance(GLfloat distance, GLfloat distance_inc);
static void redraw_scene(CUBE_STATE_T *state);
static void update_model(CUBE_STATE_T *state);
static void init_textures(CUBE_STATE_T *state);
static void exit_func(void);
static volatile int terminate;
static CUBE_STATE_T _state, *state=&_state;

static void* eglImage = 0;
static pthread_t thread1;


/***********************************************************
 * Name: init_ogl
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description: Sets the display, OpenGL|ES context and screen stuff
 *
 * Returns: void
 *
 ***********************************************************/
static void init_ogl(CUBE_STATE_T *state)
{
   int32_t success = 0;
   EGLBoolean result;
   EGLint num_config;

   static EGL_DISPMANX_WINDOW_T nativewindow;

   DISPMANX_ELEMENT_HANDLE_T dispman_element;
   DISPMANX_DISPLAY_HANDLE_T dispman_display;
   DISPMANX_UPDATE_HANDLE_T dispman_update;
   VC_RECT_T dst_rect;
   VC_RECT_T src_rect;

   static const EGLint attribute_list[] =
   {
      EGL_RED_SIZE, 8,
      EGL_GREEN_SIZE, 8,
      EGL_BLUE_SIZE, 8,
      EGL_ALPHA_SIZE, 8,
      EGL_DEPTH_SIZE, 16,
      EGL_SAMPLES, 4,
      EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
      EGL_NONE
   };
   
   EGLConfig config;

   // get an EGL display connection
   state->display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
   assert(state->display!=EGL_NO_DISPLAY);

   // initialize the EGL display connection
   result = eglInitialize(state->display, NULL, NULL);
   assert(EGL_FALSE != result);

   // get an appropriate EGL frame buffer configuration
   // this uses a BRCM extension that gets the closest match, rather than standard which returns anything that matches
   result = eglSaneChooseConfigBRCM(state->display, attribute_list, &config, 1, &num_config);
   assert(EGL_FALSE != result);

   // create an EGL rendering context
   state->context = eglCreateContext(state->display, config, EGL_NO_CONTEXT, NULL);
   assert(state->context!=EGL_NO_CONTEXT);

   // create an EGL window surface
   success = graphics_get_display_size(0 /* LCD */, &state->screen_width, &state->screen_height);
   assert( success >= 0 );

   dst_rect.x = 0;
   dst_rect.y = 0;
   dst_rect.width = state->screen_width;
   dst_rect.height = state->screen_height;
      
   src_rect.x = 0;
   src_rect.y = 0;
   src_rect.width = state->screen_width << 16;
   src_rect.height = state->screen_height << 16;        

   dispman_display = vc_dispmanx_display_open( 0 /* LCD */);
   dispman_update = vc_dispmanx_update_start( 0 );
         
   dispman_element = vc_dispmanx_element_add ( dispman_update, dispman_display,
      0/*layer*/, &dst_rect, 0/*src*/,
      &src_rect, DISPMANX_PROTECTION_NONE, 0 /*alpha*/, 0/*clamp*/, 0/*transform*/);
      
   nativewindow.element = dispman_element;
   nativewindow.width = state->screen_width;
   nativewindow.height = state->screen_height;
   vc_dispmanx_update_submit_sync( dispman_update );
      
   state->surface = eglCreateWindowSurface( state->display, config, &nativewindow, NULL );
   assert(state->surface != EGL_NO_SURFACE);

   // connect the context to the surface
   result = eglMakeCurrent(state->display, state->surface, state->surface, state->context);
   assert(EGL_FALSE != result);

   // Set background color and clear buffers
   glClearColor((0.3922f+7*0.5f)/8, (0.1176f+7*0.5f)/8, (0.5882f+7*0.5f)/8, 1.0f);

   // Enable back face culling.
   glEnable(GL_CULL_FACE);

   glEnable(GL_DEPTH_TEST);
   glClearDepthf(1.0);
   glDepthFunc(GL_LEQUAL);

   float noAmbient[] = {1.0f, 1.0f, 1.0f, 1.0f};
   glLightfv(GL_LIGHT0, GL_AMBIENT, noAmbient);
   glEnable(GL_LIGHT0);
   glEnable(GL_LIGHTING);
}

/***********************************************************
 * Name: init_model_proj
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description: Sets the OpenGL|ES model to default values
 *
 * Returns: void
 *
 ***********************************************************/
static void init_model_proj(CUBE_STATE_T *state)
{
   float nearp = 0.1f;
   float farp = 500.0f;
   float hht;
   float hwd;

   glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );

   glViewport(0, 0, (GLsizei)state->screen_width, (GLsizei)state->screen_height);
      
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();

   hht = nearp * (float)tan(45.0 / 2.0 / 180.0 * M_PI);
   hwd = hht * (float)state->screen_width / (float)state->screen_height;

   glFrustumf(-hwd, hwd, -hht, hht, nearp, farp);
   
   glEnableClientState( GL_VERTEX_ARRAY );

   reset_model(state);
}

/***********************************************************
 * Name: reset_model
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description: Resets the Model projection and rotation direction
 *
 * Returns: void
 *
 ***********************************************************/
static void reset_model(CUBE_STATE_T *state)
{
   // reset model position
   glMatrixMode(GL_MODELVIEW);

   // reset model rotation
   state->rot_angle_x = 45.f; state->rot_angle_y = 30.f; state->rot_angle_z = 0.f;
   state->rot_angle_x_inc = 0.5f; state->rot_angle_y_inc = 0.5f; state->rot_angle_z_inc = 0.f;
   state->distance = 1.2f*1.5f;
}

/***********************************************************
 * Name: update_model
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description: Updates model projection to current position/rotation
 *
 * Returns: void
 *
 ***********************************************************/
static void update_model(CUBE_STATE_T *state)
{
   // update position
   state->rot_angle_x = inc_and_wrap_angle(state->rot_angle_x, state->rot_angle_x_inc);
   state->rot_angle_y = inc_and_wrap_angle(state->rot_angle_y, state->rot_angle_y_inc);
   state->rot_angle_z = inc_and_wrap_angle(state->rot_angle_z, state->rot_angle_z_inc);
   state->distance    = inc_and_clip_distance(state->distance, state->distance_inc);

   glLoadIdentity();
   // move camera back to see the cube
   glTranslatef(0.f, 0.f, -state->distance);

   // Rotate model to new position
   glRotatef(state->rot_angle_x, 1.f, 0.f, 0.f);
   glRotatef(state->rot_angle_y, 0.f, 1.f, 0.f);
   glRotatef(state->rot_angle_z, 0.f, 0.f, 1.f);
}

/***********************************************************
 * Name: inc_and_wrap_angle
 *
 * Arguments:
 *       GLfloat angle     current angle
 *       GLfloat angle_inc angle increment
 *
 * Description:   Increments or decrements angle by angle_inc degrees
 *                Wraps to 0 at 360 deg.
 *
 * Returns: new value of angle
 *
 ***********************************************************/
static GLfloat inc_and_wrap_angle(GLfloat angle, GLfloat angle_inc)
{
   angle += angle_inc;

   if (angle >= 360.0)
      angle -= 360.f;
   else if (angle <=0)
      angle += 360.f;

   return angle;
}

/***********************************************************
 * Name: inc_and_clip_distance
 *
 * Arguments:
 *       GLfloat distance     current distance
 *       GLfloat distance_inc distance increment
 *
 * Description:   Increments or decrements distance by distance_inc units
 *                Clips to range
 *
 * Returns: new value of angle
 *
 ***********************************************************/
static GLfloat inc_and_clip_distance(GLfloat distance, GLfloat distance_inc)
{
   distance += distance_inc;

   if (distance >= 10.0f)
      distance = 10.f;
   else if (distance <= 1.0f)
      distance = 1.0f;

   return distance;
}

/***********************************************************
 * Name: redraw_scene
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description:   Draws the model and calls eglSwapBuffers
 *                to render to screen
 *
 * Returns: void
 *
 ***********************************************************/
static void redraw_scene(CUBE_STATE_T *state)
{
   // Start with a clear screen
   glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

   draw_wavefront(state->model, state->tex);

   eglSwapBuffers(state->display, state->surface);
}

/***********************************************************
 * Name: init_textures
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description:   Initialise OGL|ES texture surfaces to use image
 *                buffers
 *
 * Returns: void
 *
 ***********************************************************/
static void init_textures(CUBE_STATE_T *state)
{
   // the texture containing the video
   glGenTextures(1, &state->tex);

   glBindTexture(GL_TEXTURE_2D, state->tex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, IMAGE_SIZE_WIDTH, IMAGE_SIZE_HEIGHT, 0,
                GL_RGBA, GL_UNSIGNED_BYTE, NULL);

   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

   /* Create EGL Image */
   eglImage = eglCreateImageKHR(
                state->display,
                state->context,
                EGL_GL_TEXTURE_2D_KHR,
                (EGLClientBuffer)state->tex,
                0);
    
   if (eglImage == EGL_NO_IMAGE_KHR)
   {
      printf("eglCreateImageKHR failed.\n");
      exit(1);
   }

   // Start rendering
   pthread_create(&thread1, NULL, video_decode_test, eglImage);

   // setup overall texture environment
   glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
   glEnableClientState(GL_TEXTURE_COORD_ARRAY);

   glEnable(GL_TEXTURE_2D);

   // Bind texture surface to current vertices
   glBindTexture(GL_TEXTURE_2D, state->tex);
}
//------------------------------------------------------------------------------

static void exit_func(void)
// Function to be passed to atexit().
{
   if (eglImage != 0)
   {
      if (!eglDestroyImageKHR(state->display, (EGLImageKHR) eglImage))
         printf("eglDestroyImageKHR failed.");
   }

   // clear screen
   glClear( GL_COLOR_BUFFER_BIT );
   eglSwapBuffers(state->display, state->surface);

   // Release OpenGL resources
   eglMakeCurrent( state->display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT );
   eglDestroySurface( state->display, state->surface );
   eglDestroyContext( state->display, state->context );
   eglTerminate( state->display );

   printf("\ncube closed\n");
} // exit_func()

//==============================================================================

int main ()
{
   bcm_host_init();
   printf("Note: ensure you have sufficient gpu_mem configured\n");

   // Clear application state
   memset( state, 0, sizeof( *state ) );
      
   // Start OGLES
   init_ogl(state);

   // Setup the model world
   init_model_proj(state);

   // initialise the OGLES texture(s)
   init_textures(state);

   //state->model = cube_wavefront();
   state->model = load_wavefront("/opt/vc/src/hello_pi/hello_teapot/teapot.obj.dat", NULL);

   while (!terminate)
   {
      update_model(state);
      redraw_scene(state);
   }
   exit_func();
   return 0;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*------------------------------------------------------------------------
 *
 * OpenVG 1.0.1 Reference Implementation sample code
 * -------------------------------------------------
 *
 * Copyright (c) 2007 The Khronos Group Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and /or associated documentation files
 * (the "Materials "), to deal in the Materials without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Materials,
 * and to permit persons to whom the Materials are furnished to do so,
 * subject to the following conditions: 
 *
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Materials. 
 *
 * THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR
 * THE USE OR OTHER DEALINGS IN THE MATERIALS.
 *
 *//**
 * \file
 * \brief	Tiger sample application. Resizing the application window
 *			rerenders the tiger in the new resolution. Pressing 1,2,3
 *			or 4 sets pixel zoom factor, mouse moves inside the zoomed
 *			image (mouse move works on OpenGL >= 1.2).
 * \note	
 *//*-------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <assert.h>
#include <string.h>
#define UNREF(X) ((void)(X))

#ifdef HG_FLAT_INCLUDES
#	include "openvg.h"
#	include "vgu.h"
#	include "egl.h"
#else
#	include "VG/openvg.h"
#	include "VG/vgu.h"
#	include "EGL/egl.h"
#endif

#include "tiger.h"

/*--------------------------------------------------------------*/

#ifdef __RASPBERRYPI__
static float rotateN = 0.0f;
#endif
const float			aspectRatio = 612.0f / 792.0f;
int					renderWidth = 0;
int					renderHeight = 0;
EGLDisplay			egldisplay;
EGLConfig			eglconfig;
EGLSurface			eglsurface;
EGLContext			eglcontext;

/*--------------------------------------------------------------*/

typedef struct
{
	VGFillRule		m_fillRule;
	VGPaintMode		m_paintMode;
	VGCapStyle		m_capStyle;
	VGJoinStyle		m_joinStyle;
	float			m_miterLimit;
	float			m_strokeWidth;
	VGPaint			m_fillPaint;
	VGPaint			m_strokePaint;
	VGPath			m_path;
} PathData;

typedef struct
{
	PathData*			m_paths;
	int					m_numPaths;
} PS;

PS* PS_construct(const char* commands, int commandCount, const float* points, int pointCount)
{
	PS* ps = (PS*)malloc(sizeof(PS));
	int p = 0;
	int c = 0;
	int i = 0;
	int paths = 0;
	int maxElements = 0;
	unsigned char* cmd;
	UNREF(pointCount);

	while(c < commandCount)
	{
		int elements, e;
		c += 4;
		p += 8;
		elements = (int)points[p++];
		assert(elements > 0);
		if(elements > maxElements)
			maxElements = elements;
		for(e=0;e<elements;e++)
		{
			switch(commands[c])
			{
			case 'M': p += 2; break;
			case 'L': p += 2; break;
			case 'C': p += 6; break;
			case 'E': break;
			default:
				assert(0);		//unknown command
			}
			c++;
		}
		paths++;
	}

	ps->m_numPaths = paths;
	ps->m_paths = (PathData*)malloc(paths * sizeof(PathData));
	cmd = (unsigned char*)malloc(maxElements);

	i = 0;
	p = 0;
	c = 0;
	while(c < commandCount)
	{
		int elements, startp, e;
		float color[4];

		//fill type
		int paintMode = 0;
		ps->m_paths[i].m_fillRule = VG_NON_ZERO;
		switch( commands[c] )
		{
		case 'N':
			break;
		case 'F':
			ps->m_paths[i].m_fillRule = VG_NON_ZERO;
			paintMode |= VG_FILL_PATH;
			break;
		case 'E':
			ps->m_paths[i].m_fillRule = VG_EVEN_ODD;
			paintMode |= VG_FILL_PATH;
			break;
		default:
			assert(0);		//unknown command
		}
		c++;

		//stroke
		switch( commands[c] )
		{
		case 'N':
			break;
		case 'S':
			paintMode |= VG_STROKE_PATH;
			break;
		default:
			assert(0);		//unknown command
		}
		ps->m_paths[i].m_paintMode = (VGPaintMode)paintMode;
		c++;

		//line cap
		switch( commands[c] )
		{
		case 'B':
			ps->m_paths[i].m_capStyle = VG_CAP_BUTT;
			break;
		case 'R':
			ps->m_paths[i].m_capStyle = VG_CAP_ROUND;
			break;
		case 'S':
			ps->m_paths[i].m_capStyle = VG_CAP_SQUARE;
			break;
		default:
			assert(0);		//unknown command
		}
		c++;

		//line join
		switch( commands[c] )
		{
		case 'M':
			ps->m_paths[i].m_joinStyle = VG_JOIN_MITER;
			break;
		case 'R':
			ps->m_paths[i].m_joinStyle = VG_JOIN_ROUND;
			break;
		case 'B':
			ps->m_paths[i].m_joinStyle = VG_JOIN_BEVEL;
			break;
		default:
			assert(0);		//unknown command
		}
		c++;

		//the rest of stroke attributes
		ps->m_paths[i].m_miterLimit = points[p++];
		ps->m_paths[i].m_strokeWidth = points[p++];

		//paints
		color[0] = points[p++];
		color[1] = points[p++];
		color[2] = points[p++];
		color[3] = 1.0f;
		ps->m_paths[i].m_strokePaint = vgCreatePaint();
		vgSetParameteri(ps->m_paths[i].m_strokePaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
		vgSetParameterfv(ps->m_paths[i].m_strokePaint, VG_PAINT_COLOR, 4, color);

		color[0] = points[p++];
		color[1] = points[p++];
		color[2] = points[p++];
		color[3] = 1.0f;
		ps->m_paths[i].m_fillPaint = vgCreatePaint();
		vgSetParameteri(ps->m_paths[i].m_fillPaint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
		vgSetParameterfv(ps->m_paths[i].m_fillPaint, VG_PAINT_COLOR, 4, color);

		//read number of elements

		elements = (int)points[p++];
		assert(elements > 0);
		startp = p;
		for(e=0;e<elements;e++)
		{
			switch( commands[c] )
			{
			case 'M':
				cmd[e] = VG_MOVE_TO | VG_ABSOLUTE;
				p += 2;
				break;
			case 'L':
				cmd[e] = VG_LINE_TO | VG_ABSOLUTE;
				p += 2;
				break;
			case 'C':
				cmd[e] = VG_CUBIC_TO | VG_ABSOLUTE;
				p += 6;
				break;
			case 'E':
				cmd[e] = VG_CLOSE_PATH;
				break;
			default:
				assert(0);		//unknown command
			}
			c++;
		}

		ps->m_paths[i].m_path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F, 1.0f, 0.0f, 0, 0, (unsigned int)VG_PATH_CAPABILITY_ALL);
		vgAppendPathData(ps->m_paths[i].m_path, elements, cmd, points + startp);
		i++;
	}
	free(cmd);
	return ps;
}

void PS_destruct(PS* ps)
{
	int i;
	assert(ps);
	for(i=0;i<ps->m_numPaths;i++)
	{
		vgDestroyPaint(ps->m_paths[i].m_fillPaint);
		vgDestroyPaint(ps->m_paths[i].m_strokePaint);
		vgDestroyPath(ps->m_paths[i].m_path);
	}
	free(ps->m_paths);
	free(ps);
}

void PS_render(PS* ps)
{
	int i;
	assert(ps);
	vgSeti(VG_BLEND_MODE, VG_BLEND_SRC_OVER);

	for(i=0;i<ps->m_numPaths;i++)
	{
		vgSeti(VG_FILL_RULE, ps->m_paths[i].m_fillRule);
		vgSetPaint(ps->m_paths[i].m_fillPaint, VG_FILL_PATH);

		if(ps->m_paths[i].m_paintMode & VG_STROKE_PATH)
		{
			vgSetf(VG_STROKE_LINE_WIDTH, ps->m_paths[i].m_strokeWidth);
			vgSeti(VG_STROKE_CAP_STYLE, ps->m_paths[i].m_capStyle);
			vgSeti(VG_STROKE_JOIN_STYLE, ps->m_paths[i].m_joinStyle);
			vgSetf(VG_STROKE_MITER_LIMIT, ps->m_paths[i].m_miterLimit);
			vgSetPaint(ps->m_paths[i].m_strokePaint, VG_STROKE_PATH);
		}

		vgDrawPath(ps->m_paths[i].m_path, ps->m_paths[i].m_paintMode);
	}
	assert(vgGetError() == VG_NO_ERROR);
}

PS* tiger = NULL;

/*--------------------------------------------------------------*/

void render(int w, int h)
{
#ifndef __RASPBERRYPI__
	if(renderWidth != w || renderHeight != h)
#endif
	{
		float clearColor[4] = {1,1,1,1};
		float scale = w / (tigerMaxX - tigerMinX);

		eglSwapBuffers(egldisplay, eglsurface);	//force EGL to recognize resize

		vgSetfv(VG_CLEAR_COLOR, 4, clearColor);
		vgClear(0, 0, w, h);

		vgLoadIdentity();
#ifdef __RASPBERRYPI__
                vgTranslate(w * 0.5f, h * 0.5f);
                vgRotate(rotateN);
                vgTranslate(-w * 0.5f, -h * 0.5f);
#endif
		vgScale(scale, scale);
		vgTranslate(-tigerMinX, -tigerMinY + 0.5f * (h / scale - (tigerMaxY - tigerMinY)));

		PS_render(tiger);
		assert(vgGetError() == VG_NO_ERROR);

		renderWidth = w;
		renderHeight = h;
	}
#ifndef __RASPBERRYPI__
	eglSwapBuffers(egldisplay, eglsurface);
	assert(eglGetError() == EGL_SUCCESS);
#endif
}

/*--------------------------------------------------------------*/

void init(NativeWindowType window)
{
	static const EGLint s_configAttribs[] =
	{
		EGL_RED_SIZE,		8,
		EGL_GREEN_SIZE, 	8,
		EGL_BLUE_SIZE,		8,
		EGL_ALPHA_SIZE, 	8,
		EGL_LUMINANCE_SIZE, EGL_DONT_CARE,			//EGL_DONT_CARE
		EGL_SURFACE_TYPE,	EGL_WINDOW_BIT,
		EGL_SAMPLES,		1,
		EGL_NONE
	};
	EGLint numconfigs;

	egldisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
	eglInitialize(egldisplay, NULL, NULL);
	assert(eglGetError() == EGL_SUCCESS);
	eglBindAPI(EGL_OPENVG_API);

	eglChooseConfig(egldisplay, s_configAttribs, &eglconfig, 1, &numconfigs);
	assert(eglGetError() == EGL_SUCCESS);
	assert(numconfigs == 1);

	eglsurface = eglCreateWindowSurface(egldisplay, eglconfig, window, NULL);
	assert(eglGetError() == EGL_SUCCESS);
	eglcontext = eglCreateContext(egldisplay, eglconfig, NULL, NULL);
	assert(eglGetError() == EGL_SUCCESS);
	eglMakeCurrent(egldisplay, eglsurface, eglsurface, eglcontext);
	assert(eglGetError() == EGL_SUCCESS);

	tiger = PS_construct(tigerCommands, tigerCommandCount, tigerPoints, tigerPointCount);
}

/*--------------------------------------------------------------*/

void deinit(void)
{
	PS_destruct(tiger);
	eglMakeCurrent(egldisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
	assert(eglGetError() == EGL_SUCCESS);
	eglTerminate(egldisplay);
	assert(eglGetError() == EGL_SUCCESS);
	eglReleaseThread();
}

/*--------------------------------------------------------------*/

#ifdef WIN32
#pragma warning(disable:4115)	/* named type definition in parentheses (this comes from a visual studio include file) */
#include <windows.h>

static LONG WINAPI windowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_CLOSE:
	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	case WM_PAINT:
		{
			RECT rect;
			InvalidateRect(hWnd, NULL, 0);
			GetClientRect(hWnd, &rect);
			render(rect.right - rect.left, rect.bottom - rect.top);
			return 0;
		}
	default:
		break;
	}
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

/*--------------------------------------------------------------*/

int main(void)
{
	HWND window;
	{
		WNDCLASS wndclass;
		wndclass.style		   = 0;
		wndclass.lpfnWndProc   = windowProc;
		wndclass.cbClsExtra    = 0;
		wndclass.cbWndExtra    = 0;
		wndclass.hInstance	   = (HINSTANCE)GetModuleHandle(NULL);
		wndclass.hIcon		   = LoadIcon(wndclass.hInstance, MAKEINTRESOURCE(101));
		wndclass.hCursor	   = LoadCursor(NULL, IDC_ARROW);
		wndclass.hbrBackground = CreateSolidBrush(RGB(0, 0, 0));
		wndclass.lpszMenuName  = NULL;
		wndclass.lpszClassName = "MainWndClass";
		if (!wndclass.hIcon)
			wndclass.hIcon = LoadIcon(NULL, IDI_EXCLAMATION);
		RegisterClass(&wndclass);
	}

	window = CreateWindow(
		"MainWndClass",
		"OpenVG Tiger sample (rendering, please wait)",
		WS_OVERLAPPEDWINDOW,
		200, 200, 400, (int)(400.0f / aspectRatio),
		NULL,
		NULL,
		(HINSTANCE)GetModuleHandle(NULL),
		NULL);
	if (!window)
		return -1;

	init((NativeWindowType)window);

	{
		MSG msg;
		ShowWindow(window, SW_SHOW);
		while (GetMessage(&msg, NULL, 0, 0))
		{
			DispatchMessage(&msg);
			if (msg.message == WM_QUIT)
				break;
		}
	}

	deinit();

	DestroyWindow(window);
	return 0;
}

/*--------------------------------------------------------------*/

#elif defined __APPLE__

/*--------------------------------------------------------------*/

#include <OpenGL/gl.h>

//TODO

#elif defined __RASPBERRYPI__
#include "bcm_host.h"
int main(void)
{
   uint32_t width, height;
   bcm_host_init();
   int s;

   static EGL_DISPMANX_WINDOW_T nativewindow;

   DISPMANX_ELEMENT_HANDLE_T dispman_element;
   DISPMANX_DISPLAY_HANDLE_T dispman_display;
   DISPMANX_UPDATE_HANDLE_T dispman_update;
   VC_RECT_T dst_rect;
   VC_RECT_T src_rect;

   s = graphics_get_display_size(0 /* LCD */, &width, &height);
   assert( s >= 0 );

   dst_rect.x = 0;
   dst_rect.y = 0;
   dst_rect.width = width;
   dst_rect.height = height;
      
   src_rect.x = 0;
   src_rect.y = 0;
   src_rect.width = width << 16;
   src_rect.height = height << 16;        

   dispman_display = vc_dispmanx_display_open( 0 /* LCD */);
   dispman_update = vc_dispmanx_update_start( 0 );
         
   dispman_element = vc_dispmanx_element_add ( dispman_update, dispman_display,
      1/*layer*/, &dst_rect, 0/*src*/,
      &src_rect, DISPMANX_PROTECTION_NONE, 0 /*alpha*/, 0/*clamp*/, 0/*transform*/);
      
   nativewindow.element = dispman_element;
   nativewindow.width = width;
   nativewindow.height = height;
   vc_dispmanx_update_submit_sync( dispman_update );

   init(&nativewindow);

   while (1) {
      render(width, height);
      rotateN += 1.0f;
   }
   deinit();

   return 0;
}
#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     OpenVG 1.1 Reference Implementation
-----------------------------------

Copyright (c) 2007 The Khronos Group Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and /or associated documentation files
(the "Materials "), to deal in the Materials without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Materials,
and to permit persons to whom the Materials are furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Materials.

THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR
THE USE OR OTHER DEALINGS IN THE MATERIALS.


Version
-------
Official RI for OpenVG 1.1
Released: May 13, 2008


Release Notes
-------------

This release is based on OpenVG 1.1 and EGL 1.3 specifications.
This release is Windows-only, although the source code
compiles at least on Mac OS X 10.5 and Cygwin. Project files are
provided for MSVC 6.

This archive contains sources for OpenVG RI, VGU and EGL. There's
also a precompiled libOpenVG.dll that contains OpenVG and EGL implementations.


Package Structure
-----------------

bin
  win32
    libOpenVG.dll         OpenVG Windows .dll
    tiger.exe             Windows executable of the Tiger sample
lib
  libOpenVG.lib           MSVC 6 dll import library
ri
  openvg_ri.dsp           MSVC 6 project file for libOpenVG.dll
  src                     .cpp and .h -files of the reference implementation
    win32                 Windows backend for EGL
    macosx                Mac OS X backend for EGL
    null                  null backend for EGL
  include                 Public OpenVG and EGL headers
    EGL
      egl.h
    VG
      openvg.h
      vgu.h
samples
  samples.dsw             MSVC 6 workspace file for tiger sample and libOpenVG.dll
  samples.dsp             MSVC 6 project file for tiger.exe
  tiger
    main.c
    tiger.c
    tiger.h
readme.txt
license.txt


Samples
-------

Tiger

The release contains a sample application that renders an image of a
tiger. Note that the sample doesn't start immediately, since it takes
a few seconds to render the image. Resizing the window rerenders the
image in the new resolution.


Known Issues
------------

-EGL functionality is incomplete (some functions lack proper error checking, some
 attribs may not be processed, etc.)
-When opening samples.dsw, MSVC may complain about missing Perforce connection. Just
 ignore that.


Changes
-------

Nov 25, 2008
-Clamp color transform scale to [-127, 127] and bias to [-1, 1]

May 13, 2008
- Changed 8 sample MSAA configs into 32 sample configs
- Changed max gaussian std deviation to 16 (was 128)
- VG_DRAW_IMAGE_MULTIPLY converts luminance to RGB if either paint or image color is RGB
- Fixes A40102 by storing input floats as is

February 12, 2008
- fixed arc transformation.
- fixed point along path corner cases.
- partially fixed A40102 by not filtering invalid float input.

December 12, 2007
- fixed an overflow bug in vgFillMaskLayer error handling.
- increased accuracy for Gaussian blur. The new code avoids an infinite loop with a very small std dev.
- fixed a bug in Font::find that caused deleted fonts to be returned.

November 20, 2007
- reimplemented 1,2 & 4 bits per pixel images
- fixed vgGetParameter for paint
- fixed https://cvs.khronos.org/bugzilla/show_bug.cgi?id=1095 RI handling of child images with shared storage
  -vgGetParent: return closest valid ancestor, or image itself if no ancestor was found.
- EGL refactoring & clean up
- divided OS native parts of EGL into separate files that should be included in that platform's build
- added a generic OS backend for EGL (not thread safe, no window rendering)
- fixed https://cvs.khronos.org/bugzilla/show_bug.cgi?id=1943 RI does not handle channel mask correctly for lL/sL/BW1
- removed EGL_IMAGE_IN_USE_ERROR from vgDrawGlyph(s)
- added configs without an alpha mask to facilitate CTS reference image creation
- implemented more accurate stroking by rendering each stroke part into a coverage buffer and compositing from there
  -fixes https://cvs.khronos.org/bugzilla/show_bug.cgi?id=2221 RI errors at end of curved strokes.
- bugfix: joins used path midpoints, interpolateStroke and caps didn't => seams (visible in some G60101 cases)
- vgCreateMaskLayer returns VG_INVALID_HANDLE if the current surface doesn't have a mask layer
- vgRenderToMask bugfix: temp buffer is now cleared between fill and stroke
- bugfix: vgCreateImage returns an error if allowedQuality is zero
- bugfix: vgSetPaint returns an error if paintModes is zero
- bugfix: vgCreateFont doesn't return an error if capacityHint is zero
- bugfix: writeFilteredPixel writes also into luminance formats

October 12, 2007
-Upgrade to OpenVG 1.1, including
  -Implemented MSAA, added 4 and 8 sample EGLConfigs
  -Implemented VG_A_4 and VG_A_1 image formats and EGLConfigs
  -Implemented Glyph API
  -Implemented new masking functions
  -Implemented color transform
-Implemented native EGL backends for Windows & Mac OS X => Fix for bugzilla 1376 RI uses non-standard EGL implementation
  *RI now works with CTS generation's native_w32.c (native_ri.c can be removed).
  *dependency on GLUT has been removed. GLUT code is still included and can be compiled in instead of native by defining RI_USE_GLUT.
-16 bit EGLConfigs now expose 4 mask bits, 8 bit configs 8, 4 bit configs 4, and 1 bit configs 1. MSAA configs expose one bit per sample.
-EGL now works with any display, not just EGL_DEFAULT_DISPLAY
-Simplification: removed code to handle less than 8 bits per pixel. Smaller bit depths always allocate 8 bits per pixel.
-Changed rasterizer data types to RScalar and RVector2 so that it's possible to alter RIfloat precision without affecting rasterization.
-Accuracy: increased circularLerp precision
-Bugfix: matrix inversion now checks if the input matrix is affine and forces the inverted matrix to be affine as well
-Bugfix: fixed eglCopyBuffers (copied from dst to dst)
-Bugfix: fixed eglCreatePixmapSurface (allowed only VG_sRGBA_8888, didn't give an error if config had more than one sample per pixel)
-Bugfix: bugzilla 2465: RI asserts when setting maximum amount of gradient stops

February 27, 2007
-changed to MIT open source license.
-bugfix, bugzilla 820: RGB and luminance are now treated as different color spaces.
-bugfix, bugzilla 1094/1095: vgGetParent now returns the input image in case its parent is already destroyed.

December 1, 2006
-bugfix, bugzilla 649: allowed image quality is now taken into account when deciding resampling filter.
-bugfix, bugzilla 650, bad stroking accuracy reported by TK Chan and Mika Tuomi: curve tessellation is now increased from 64 to 256. RI_MAX_EDGES has been increased from 100000 to 262144 to facilitate the increased number of edges.
-bugfix, reported by Chris Wynn, affects I30206: degenerate gradients in repeat mode now render the first stop color instead of the last one.
-changed float to RIfloat, added an option to compile RIfloat into a class to test reduced precision float ops

September 6, 2006
-bugfix, bugzilla 591: CLOSE_PATH followed by a MOVE_TO doesn't produce an extra end cap anymore
-abs values of arc axis lengths are taken only just before rendering
-undefined bits of bitfields are now ignored in the API

September 1, 2006
-changed colorToInt to use mathematical round-to-nearest as recommended by new language in section 3.4.4.
-implemented VG_PAINT_COLOR_RAMP_PREMULTIPLIED
-implemented VG_STROKE_DASH_PHASE_RESET
-implemented new language for filter channelMasks (section 11.2)
-tangents returned by vgPointAlongPath are now normalized
-implemented VG_MAX_GAUSSIAN_STD_DEVIATION, rewrote Gaussian blur code
-vgGetString: if no context, return NULL. VG_VERSION returns the spec version (1.0).
-bugfix, bugzilla 542: vgSeparableConvolve now convolves the edge color with the horizontal kernel and uses that as the edge color for the vertical pass
-ellipse rh and rv are replaced by their absolute values whenever read for processing, the absolute values are not written into the path data

August 18, 2006
-bugfix, M30301: the arguments for vguComputeWarpQuadToQuad were the wrong way around, destination should come before source.
-bugfix, M10102: check for degeneracy in vguComputeWarpSquareToQuad is done before the affinity check so that degenerate affine matrices also produce the bad warp error
-bugfix, bugzilla 491: Chris Wynn's vgComputeWarpSquareToQuad -case. There was a wrong mapping between vertices, (1,1) was mapped to (dx2,dy2)
-bugfix, bugzilla 519: vguPolygon wrong error check. vguPolygon didn't have an error check for the count argument
-bugfix, bugzilla 518: vgGetParameterfv/iv wrong errors. vgGetParametrtfv/iv error checking was for count < 0 instead of count <= 0.
-bugfix, bugzilla 517: wrong cap flag checked in vgPathTransformedBounds
-bugfix, bugzilla 494: egl.h has wrong values for OPENVG_BIT and OPENGL_ES_BIT. Copied the enumerations from the 1.3 egl.h on the Khronos site (OpenKode/egl/egl.h)
-bugfix, bugzilla 492: gradient filter window was biased
-bugfix: when appending paths, there was a loop over coordinates to replace arc axis lengths by their absolute values. However, if the path wasn't empty, the loop accessed wrong coordinates. Fixes: Qingping Zhang's cases 2&3.
-bugfix: image filter write mask was ignored when writing to VG_A_8 images. Fixes: Qingping Zhang's case 13.
-bugfix: if image filter processing format is premultiplied, color channels are clamped to alpha before conversion to destination format
-bugfix: in eglReleaseThread the EGL instance was freed when its reference count reached zero, but the pointer wasn't made NULL, causing the use of uninitialized instance.
-bugfix: vgClearImage didn't clamp the clear color to [0,1] range
-bugfix: a zero-length dash at a path vertex produces a join
-bugfix: vgSetParameter now checks paramType for all object types
-bugfix: convolution filters incorrectly restricted the area read from the source image to the intersection of source and destination image sizes
-bugfix: EGL surface creation now defaults correctly to EGL_COLOR_SPACE_sRGB
-antialiasing is done in the linear color space as the spec recommends.
-image filters clamp the result to [0,1] range.
-Color::pack and Color::convert assert that their input is in [0,1] range
-in case a projective transform is used, VGImageMode is always VG_DRAW_IMAGE_NORMAL
-the default value for VG_FILTER_FORMAT_LINEAR is now VG_FALSE
-added Matrix::isAffine for easy affinity check
-Color::clamp clamps color channels to alpha for premultiplied colors
-VG_BLEND_LIGHTEN: color channels cannot exceed alpha anymore
-RI now supports flexible pixel formats. Any bit depth for RGBA is now supported.
-eglGetProcAddress is now properly implemented, it returns a function pointer for eglSetConfigPreferenceHG extension
-eglQueryString now returns "eglSetConfigPreferenceHG" for EGL_EXTENSIONS
-location of egl.h in RI. use EGL/egl.h, VG/openvg.h, VG/vgu.h
-OpenVG 1.0.1 spec changes
 +use the latest openvg.h
 +2.8: AA happens in linear space
 +3.4: alpha channel depth of zero results in alpha=1 when read
 +4.1: return VG_NO_CONTEXT_ERROR from vgGetError in case no context is current
 +5.1: VG_SCREEN_LAYOUT (default = screen layout of the display)
 +5.2, 5.3: vgSet, vgGet, vgSetParameter, vgGetParameter: handling of invalid values of count
 +5.2.1: new default for VG_FILTER_FORMAT_LINEAR is VG_FALSE
 +8.5.3: get rid of VG_PATH_DATATYPE_INVALID and VG_IMAGE_FORMAT_INVALID enums
 +10.2: get rid of old extension image formats, add the official ones
 +10.5: when reading/writing pixels, clamp color channels to [0, alpha]
 +10.8: when a projective transform is used, always use VG_DRAW_IMAGE_NORMAL mode
 +10.8: VG_DRAW_IMAGE_MULTIPLY: if color spaces of paint and image don't match, no conversion takes place, result is in image color space
 +12.4: clamp the result of additive blend to [0,1]

October 20, 2005
-Gradients are filtered to avoid aliasing
-Subpaths that ended with a close path segment were capped and joined incorrectly. Fixed.
-Alpha mask was allocated per context, not per EGL surface. Fixed.

August 22, 2005
-Updated to spec amendment
-Fixed bugs
-Implemented eglChooseConfig and eglReleaseThread

July 22, 2005
-Updated to 18th July 2005 version of the OpenVG 1.0 spec.
-Updated to 20th July 2005 version of the EGL 1.2 spec.
-Fixed bugs.
-openvg.h, vgu.h and egl.h are now contained in include/vg directory.

May 4, 2005
-Updated to April 26th 2005 version of the OpenVG 1.0 spec.
-Can share images, paths, and paint between contexts.
-Fixed path tangent computation.
-Implemented image filters.
-Fixed bugs.
-Changed directory structure a bit.

March 29, 2005
-Updated to March 28th 2005 version of the OpenVG 1.0 spec.
-Changed rasterizer to use 32 samples per pixel in the high quality
 mode (renders faster at the expense of some aliasing).
-EGL allocates sRGB rendering surfaces.
-Includes GLUT dll against which tiger.exe was linked.

March 24, 2005
-Initial release.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {                              ,F5N |J*-8)0 "	1E w                                                                            	Q0O_% w*,Oc c                                                       +h(k# K  Zabs ) My-                                                   Wwf(-X  $8 h\nxS)|                                                  WKeCL N`XGhnh^)I066l%){u 
                              CAmWLf4E6 VO;FU^hWO?.)i!N+{	
	                              f$dpr1mw.KF e +O`:\RjF(_ 4J%=5[	                           	
x255LE?%bYj#^,ns-':z4t]G3}Cc
\G"8Q

	 						
	                     
			&#!)bo ( e.qKz<\\x8.0" & *(<K)-n
     
	  
  
  
	  			             
5Gi,kBC|zEpmBY<$F j	c4a; .  DY 
		
  
  	
  
  	            5&d~>dxz{{k=Z*wtOFyxDE!^>  n
		
						
		    	    							Lg4nl\uxtHhW2,pr/	    	  
	
 	 _7] {LGy|auir<d78:,
	 


	
		
  		 On )'src[r{>lWrLrKUDC=#|									
	"r
tnorwysiXnf]g_ZL%6).* c(&%%
					 
		
		 	&$B>@]ZkU9wGtJrsp6k*W6u(lJ7###




		%#$"d|T QY?WrgY-c1(X$k@OL9/,'1M&K>(  ###

##)PPaKeLm}BWz _hebgGKpz9ty:%VA$&###)&% /kAIu}m]Ob=i6D-Y?oVcFM30 Y? ;z$ "#"+++	%#)8HW"\hzqG{Eh ]OiGu=#=% -A6DC)2l ""$)))+&&&&&&%##+/M eWHxhtYIRpXP_F\^5rOQFBFR.2+CEj?#'%%%%%%$+&'!" ####+-/"###"+,,-+,,,)))

%########$,2Bvd=ekXxVs}_uGh:cx(\Z6;rS.VC[n@%Jn!%+,")++.'*,"!""#!"#!!"#!!"#!$"""))+!!!!!$))))))))))%%######$*854&4j\OQvqk(uKJXlTtdXHLB<)J%=uW.S"-))+*))))))+++++++++++++++++++++)))+++++(+)))))/)) #####",+*(4213wrz}Y{Ts2t\iBYfsawpp]wNnEeLYW?f^?^1 )()))))))))))))))))))))))))))))))))))))).,))/00.//
%%%%%%%$#++)$+)+45'E9oc}xpY~i216RHbOstEJ\Ngeq^<;1>$w_ ;f9ZK8;.(0*-00*.1(.*)))))(/01(/*)(/*'00*'00..00...999######-+*)))*))*20L'ZSEidd@4&T`Er9wWhh3M*m7f8|KUaJ14.g[$_?AlB;?<4310./.../..0./000000.)&0./00./0../0........-777'%%%%%%%#+++++))))744445=C2jN]hVF.FVoG@`zj]aIBr a:5EiJob_\ ea <o7\ObT9vP=Il069:0................/0..................899?77$####,!$+))))))))(422199B9wc^jeAja`J4]A0E]WNegVn7)-PB Y5T-\7Q+A*XX K]@o&4rhpW$5680..................................-5>??=?? '%%%%%###%%$**,,,)+*)))))))*44989BAD|fnUgsASjby^:>/YuGgFyuy.-w&_V`5 |M{e	Xc3 wV	hx:N*omD<dI4iJF369;-.........................?@@@@@@?======%####*******))))))))())))(0/88778?H@sb~jR-PDescLy#3>iP]|HmC[PH |(lS8.a s,cr-D4xlV]R:$CT7XH4:875/-------44444444444444444<=======<<<C=<###*))))))))))))))*94&)*;9977779>3N\Y]Xke8BKPU@F9xYROI-j?;`Zq578<P peGi_xxoVH,MF85@@@@@@@C44=???????????????=====;D=MNNMNN***))))))))))(()/.078,./87776@=?F~lb|TKkb[\ZIU-BBeLpy_qKo.a_1lcD/5C U^!EH0:5HWC?=>=======?33;=====<<CE<C>;DDDDDDDDCCKKKKKK$$,)))33333()*33;::88877988777>>DM,rQR}ngih\u]7FUtl|Ilj|]uFfEM0[dn*8(.1#*s_sHLTwXS\L7JJ( [@FdZID>====<CDF=FDDDDDANNLLNLNNLLLLLLLLLLKJQQKK##))()22988../88777777777776@>=;\1]9Mig\]qWKeAfhW\[cU;>]HAYdJSP;2.'03.*\QKXS[[wmJDZ% YN,IES@`?#>BCCDCCBD>CCCCB@KKKKKKKKKKKKKKKIPPPPPPPP**)3::887778887777777777@>>>=>FG5~ro`jl^q>}7KFWITGLLRSy]^kVT+/30'OI0.5
DoF`Wn[NfG0HzUB=vUpygj<GMLLLLLLMLLLLQTKKPQQQQQQQQQQQQOZZZZZZZZ)))87777777777777777777><=====FJz|z?w4LV\WUPbwfh8?7B>`A=0/_Z9u%{2_*RMF]Z]F_zIh`(S2 iVxWJLKKKKKKPQQQPPQQPPPPPPPPPPPPPNYYYYYYYY*)/7767777777777777>>>>=HFFFFH>vEiN@P8@SynF_aXZil=EhGcEb:G?Y96P\.:/q dzaf"q<L5 TNXuoF|rcn?x+QIMMPQQQPPPPPPPPPPPPPPPPPPPPPNYYYX``YYe q!r.-E677767@=7>>>>=====FEEMKGtyztZ~pIJKqTOHbZseOH:fA`A)
bZ2(uzex Yo	S].y8LhgDB=a9 _cTGYw{4vK%rbX\OQPPPPPPPPOOPOOOPOOOOOOOOOOMX```__``6`5^4^!C i S#6x";@=7>=>========<PLK;XcRQzopCBIhX@jY?YV5l5XEWs.Jwq5m89@y1bV Ve?s|`A@MN\rwhN3 ~IzvUjz0efSPPPPPPOYZZYa[ZYa[ZZZ`abZaa`_______2Y2Y5\= t` vX`/ e$r";>=========<DMLIMtsl|Lvms|SmbhZR[L\UJ;aGGU6Z!$e8 ]K-O,]-
H' B8 yl8nd`URW* [D*KODqnf`?VwJ aq<QQOPPOMV_```_```_````___`____^^^^__8z8z8{(Cf O S tI cS bO XD >7p4==<==<FDMLM/[hGz`KZk@[_nGyRQegOdV YRdM0^9 ?,4# of0oQLY*W?I$ K*W:pJqYkf\D\0x? 3Kh<BBQ]WZ`a`_____________________mnnnhh1p1p3q<u \]qJ `O cO cN [6I30<<ECCCBCJK^SxITvn=<;\]aT]fox<HXjIf}yf6J <gYT;!jF 4$H `> lF$}Tzn^]fM'S5kM'oZ9zP], sbVzV4wW,te^____________]ddddddddddllllmm3t3t3t(1kaY Z rF Z5Y;iQe//MMLLLLLJ]LhR;`edNVD?5^9{BkXugUFaYApTB1Af`=+^U' WY7y\TJZ2
p?(aTyxjb9mO_RUn, YI8UhyK{_]_^deeeeeeeeecmmmmmmmmmmllllll$J$JC"PHE E e@ _= S9t2O*1KKKKKKKLJl|}xh9j=/V9e>JXiRflqB{|i;21FRKI0p`4mN*[etS=_ oKN. bJ!pdcihdFM9 ~R)`$Z5 d^bfdddccdddddblllmmlllllllllll''-7H!/yYJxL e(hk`*3KKJKKNNM}rN HoFKeK/6Ip:*rtdsxrVZ*IZOMBJ/eQXB,7q}9i(U7	mO0Zanh*bF ['C 6% fHs^7WV:bM@i;jHuyTc7 Tcdbmmeddddbllcbbkllllrsssll**,=K"9+|$wdr:f  eO;KKRPPc[kyynSyK=w261G=ysrkNcb\jc>ORQG5p8c'e,C/VqOfJ?9fEvb`vP6\1 X5[I7_MI`]fS`z`^[jUF\w]>$ iQ*bmy[b/e2 Vxt`db_lldcbjd_sskjjsssssrrrrss|%QL*=(%hE9 d v)u9J;RQQ\ZZNw[ie}>3lcBVD1.d};]g[nZ_mzI<t@U[brZ>x/fICAr4UbSTB51 U2fSWKi? v@)jJCTLGV^eZ_a^einUvtY^gW R- hT u|^0pC }uojrstttsturrsssrrrrrrrrrrr*z(y%y2X4~`T_M^9L#"{: e%F6OOO\Y^L_lbXyb52hSj{tzaR;PM^,x2gI6Fv"]9s`?^H	M6 8 iM~dkTB"^9 mR'ne:t_TxdWmhfigh\\]y`wK&t0s]pZus\ssrrrrrrrrrrrrrrrrrrrqqq se N'  , 0U3]?oXF j( X+ g0CZZKa\VEOyFBfJ/'UJr_pj94R|7g"dd@u .oIh>tWY|@	S5 2 kK#\\fTSaN@C#@2 hX*zrX{u_|w\mYoJL]nHtTt[u]trrrrrrrrrrrrrrrrqq|||w| "}E'V89 u2;vb*E GR9i_`UmsJKm\C
A{[y?lfi0~t5+2HQhg|?s%\WS?s Y]	ui>r`s3qW5oB N'0 T>a.pWCP`djKTG2A' cHw]eV@VVbHX]Vn}g@=$ pW@}xrO^qrrqqqqqqqqqqqqqxyyLzT&qt7BSi=}w@UJfZYh%_i,@ G
oGNbhx|e5v.WpT_}TIg\A4rqD'-+1? m ,^GoLd[h qba_@U.ppkO1O; ZAa;<[CI_XbUYrcgb]`e]bHPI!I, _Y3nfZt^gMZ|Qa}Ktsr;v8dI2Syvvyyyyyyyyyyyyyxxx]nXzuemG04J'_Csu[;P3]dBKlbp_no@?^E R. D R# c0Q A=* VYUU sbgnqRYLH-tcH)J-dG Q:xUKwabjkllklb^ZrbVqM.eE'R6iJfe7qhfzn{bzi=yxxxxxxxxxxwwwww{~>jmcxT\JD`gn[yUoDed%vpB_-r"t\N <5YQ$ZAdMbPwrcR0U5b^jI;M.=1 [MuZCjrgincik{iosSbFkZRw``u`phJX8|iWx|wxxxxxxxxxuVecqbZ[~`8QxeOSwIq}eRwI`5 F ^qN> a:97	@9gM
mWEcB*JlmjP<\=eEgD<X@)O?1$ >,[I,q`BxfWzdnu^_qYW|]LV'\"xQb"g^Jz^i>zwvxxxxxw|}haw<+gptTHAin[ VsK|XazfMKc}[WL|I *C0iQRi\a|kX`/|p@r_H;"t;q_;bPO`H8YD%Q6 : H\0|P}[;zY=kJ% YG*UV4~~~~}ez\vgznQ\K1r?wPI~ERlSAvR4r^YH#W >*E5yc`iVqdpZ`I9mXb]K^@RYNX^oZZZIS=iF-fIO) jAmDkI/tT:yYkiCbGj~{}|||u{sj}sG=oN|J+DgdkOmq_VIbmXYV=s)tmzJyX+vlPzsgpyliSP7h|hV7jS1ibmaj[fkOPcN4zT!oDzNeGbM}TapZX.],rdz9uyud]kE;yBTjRVQNG(%'1 $6ko	[2oNExl`d{oquXPY@*l{iW7L' eF%vfEck[__hq[\t[Wzd`mO4M2 ZA oZRr]SyL+L }h#}vghqakt=fiX\w{K6RbmW^KaD.&$|x zi*wnDrUi</ {vXel|hg`M)N>pixS3jFO^:"gWL`jjppwrXkwXB_GxWD_AO5 T3qxl\VJsb}qrLzwIXriJ2]zkJ|q5NDM=0(*0	
}Ikxx$l,|f_xi=mhCkW9L# rtkfup^YV?)YMt^QBe tA D& E<hT*U.ZW}ZZ}ZY`TnP-P6@% \B}Y<xdTrE"? shWxnux}unM{Ix:nznhxFyUO0<=Pi:(
}ib2f ^SdNs_Ymc\`gJi8 n;gqnhsa+sRwXDs`-Px@
As?pR;|\J}X[{RsbS`VgEz\6Y:W>~^;wH=yYMW1X/k}L}yxu}f}sstTLn{zvxcjTcD@=C^[  {pxj<Yq)}`UjB~^Ao\Zl]omZh\*\8g`oklk_JxUla8vTOz`#yCc<}_G{`5dI`Z_Rm`fXfX\R\L^bHbErw^lpw{xpttuoli}hnSAsqyK]H[_LXJ;FU[& 
v|_d pgq]%{a4xVzXLr_`l`bma_f]ZjT+Q.sV?unqqpAnT^f^euO"U+j8)sP=nVw[mcndm}}hWEyfRs_OmhZWomeVFy~snofkrr}o{h{T`zi|\zp{TtmgfKjp?6JF<QUpe5GL/z*m3u
`l \aSU\S qb.rKsU6uSGq_ak`ekabl_tz\NqN8  RO,vpenO 	kTiaoxkc_P*]DK1 V>z\7Y~zeSk[o[KV( \W!P%yf~ok6>pvteQb]bwfyd~bYxNlaggyp6e83XJUtcjL?WNr ~U \* |7`7KbLV W{ LlLYA@<= PI  X7z^-z[?uYPv\Wx]Rk]umebx^QnN2B$ xcClLvae<O#~ZIqgoFsJpDfAe6zUkMgMx; lIve%}iXiK?hqlr2f$5tJ''2;@;<0URKTuTqNhaj0q}_P^vj|G{nCRV=qE}POEJB AXX#QP961.:9qe#y\eD= nVz_[v_]u\]kbRqbqz\U~_@qTb9uK\'T9vN]* n9 IfM{M8|M=uI }Z}8 d' mIy\FaJcK:dEtP[[IbX:}|4biWt*%FioB f2 e2 d2 i/e, u@n,MheMRgaXF{;Zqrf;b[M_U]kOR@[qlgKA	MT NA&  EG gV%TG yn5& >+D1	_H}Pj;TO.C6{QhL\<h`\|swvslx\K+~V$w^jT}b4sPmEtH6vSH|[P\Wv[3W$wGTg5Y!xPgk^.kH<i{p? XHf dBjI <;U]I q?
]) d0 n< r? R.H'%[X?c0le>a`{|bNl\cP]Qv~.d)25f	Bx& P	 s=\L6$ 6$ C3^Gd3T=[OH\G2: dK|g~ez_GsGpFzcghc5Y,]K~[V_XbVyXPs]Vg>tFi}vv14$x~&$k{8Du6 {N	rE{B bdd"y4d-*u8499(TzY&n~Zv|Rdf{ph{sy{ryyKiQ@c Y lu9Y& 0bS:/ /'/" aE
}CM hBRSYJ=UdJE>,THsK\nhyhLrg6J/ tSxxnatY/pKa,kPsXuy~;Gw{{AO whSp}V;D*_8
Fv: s6 7S8N=*%BW9AKVQC*d` vk{yrTGodXs}}}|slhRHg?@^R"^ _.<!!C/WE pJE):4yF&Y[`YK]W6BaIHN<#A[TpVtqgc~dhOD) eL}[iijSe=]7 pQ<qWiK{@8W]0ZbUmB&V&DybTxE	uE X`1B?_7yxs&fafU\2']BCe`hzYRtrZgwIf}z|}yvkcbN4ocx>c!~C\BfFT[5  ^a'\r^?<
V?kTRUT`SCO]CM^BR]J6, hU;p[Lvgisb~ihfBL! c5p_xM(U, N xG;lQi}vDcB	tM{6}\PxwoS t"w:TJ}')l_kx-=; @ V8   y z r `|RLYf&JQpBghG[kPxqmryOZ8Rw~sx}wlbMQe[xrCbEN i/} YJkBb/En\6O0L.aAteFY]L]MPZ>HbGPmOZL5,'Q;+kUGsO~g_}ghfyGg>qGDzHaI~T%f@ kI vQV2iQ{sun9&~d)|zrGQoVkqc$&> ~< *}   VK@ s` f i l:`2OLCVx?8a.buIWQhkJgpS=j^W05axnnkocWQe|^cpVFCf~n[	k*zF~?|H |UvT_}Za^<}_Hi]TXOQNCG[NKRTtYIBC/$ C2pA95|e{c[~tai)~V#dEaScLg=_3zQ${IyQuMn\b>aQeJ$XovML`|}  4 vQ&|aXHRODkedmlE ~5 U^[<?c(Fi:_qIjqvEdaOl.uotuQ#lri7(ow_bUI{Lbr{Udwf1llTPU/2Ecx_eVW8+hFeMlc\\UZUINWGEQMlaOG^M.P@6&
rI#vUDnbNs[[t]Y|roU+noWamfWrF[+]4X;qU0aC~Xtg6X^J#cnVyqymPe@4BA//+,+)LhCln?TJ^'Q+MN^;Fv1Zp7hh.Vi0KFe$zl`qCrr]^lWp P@#ykWq\iOa;wH?f@WlNp`&f	S [nD(K2BG!A4 El>^B$sZgLeN[PEPSSFUm^V_rQOyVG]><  |^5tKhL_Z}sh1B%gG;zN{RsqR{Q#e;M w>pbM3 hP-hW~cuQ`X.m;e{JzPfivfXKLF<?=>4622+$!&-;Jc~QW	t:Nb<_j4rg;xc7._;el#xotkcuO$`m`Ap0mDFu
>p7|P#b65\99M3ka$O [:}:o:'jL:vE$E"88L U*A&9{\ChDhKr_NcSXKThA]`doeG]>I,S4x9zWaU~`9\D 6 P4i|T)SR8G1 T)pI\`AxsjM"dJf.~Ycq7UNFMHSS?DFFFEQI/2+-,,:6-+(`zm]HMZ#QW$]g3IQJZR17PCc7g{AoQchKw8 P$ t-pW<@%^#H4`*C\`o"3b&l>j4\ zL(N/GoY[e+[JeC#O/3 N/gNaIaFi[`UQgR`yRUi?2a>5W5.D#aA)v\~gy[Lk9h>X& k8RsJO[-rLi1BEZ^0S8noW-[G)}}S.~etoRY_aVSGHCEEEF@033,.-%%'4A-!OpY4DCNGS:MK.)G4]1Pc+Q_)rpP*e  D 3 -y` A+ (HCO.?Q']Y SL+,aA \V7^>#>RLNLb(DZ]!gUzX6dD+M-9 ;pK,`T[lQMsnZZ{`VpxSKhD9iE=Y6?;osVthPz$i9 OW1c]TbQb<X}Y*qFYQyAwUxY3vU<{p>\VW`qn{DdkHwS^ba_YRTTTEEE<6%**+""$ u|}KGZ7+@9(>DS1Kb']V0gn.LZ( 6 1) ZS @*83INLFWS%3& W&[0pQ>qKVX8A P3H#n5n@kBiIfNrR:^>%H2-+!s:yStyiZlXGaJ6ZSOU;%A9 m6yN_VhW`h<_5bQa_xsc2nQqK~{vog0Q glxjwX]c``_XYRSSEEE<6,###&%$"&"\0~ t7o`]2 ?$(>DW6Ie(Q7n`+>q$ K
=  ]VC-/) =CHGMKi_/f6V3r^jBRyH;c7,# OCt`gX,oQgPbImM4[E(C20)! Llpzxs_QwaNXNHlQ9b<-J)
H- U1]\Xvsqep;hk&yJuczN~vtOj^3qylIJeAp2YujhghhgabNRSKDDFF;22$V eg;)A76J.HPDIK_O
SJXR	nRX: *=MA\<
tT"}Y([.]+tPEeO\bQeZDBG3 @*rTr[5hBlNmS}]D}\CfE,P0=: _:~qNnF\Fe_WrSRYW([N@oT{UwQ\ {NdQk5eh#nD bgiZ/_4Sf0TyJc3{1rdfeeeehaVYTIKJEE594$ 4- vD~ _kx87
<J$HPDQtV.N?|N=yRP;=x#4&,
~rj,u7{AM$S(d6c6g6bRD]I`fH`\BAS1)4N<xY4z\6lOqZw`oWqXeKdB+O2yUb: wNy\#kEhXjFqalbaLsah{Y?jJ_CWHiT
h8jGezl_e UK k@ |FS0B5uGNvopqqwvvuihpbLLLKEEK3(!$    } tkSy\7feG7 ?@dP'\-V8uAAd;Vl1;o)$i5 jP o~G!r=|GwGX*g7Y=`NhQTbUe_RerRR}WT"vY3vX2b;pH~VtWt[iPuXb@G& k?wGmQb=~^HlajXXZ^h]RxmYf<yRjDf:{Q#hG*olo+K Bs&fa*|hfTmLh(Qc)WJleqqppns}vyiU__FFK2'$#!"	  x o ^ehww t)N9cL$zQ+L=w<?m1Bc$.y$!|v@D7"P1nCR<~H{HY+}T%`._HuK:]ILXL]`UcnKY`4n=4z^3z\4pT-tX1iBmQv]hL~]sR!N#a8Y2Xz]9|`K^PxhjIP^tk|hRqHoIwUd-uDSjKe0;F UW$eWgseZHzboffqox~]pIC<<:2-#$"!#rj^z Rr_zud.ix?1,v3{7&w4!t2y=k<
fJ"a@*lL2jK4_AxQ%R0O-]<]@abGgBAeJRlNmrOkmO/A!;}]DcET2}P/^7bGnkmh`g[-m?ij/V&T/\VXyW`mW~|lHpJ~MkqmZd=ah0N#d'vyq}NwDx3w(v>h|gkh&S&WDTM?fbS}ggxtvdU>=><24#!		  k]sa|c@brzJXosQ.g2Z6P, {T'|YrQsChnIK[<V6gG0cQ!WG:V^nE
{Q,e@Z;]6pN`M@dKOqN[mM/hG:V61 \2V3U3}[3aI]]njmoX)^.Zw\h5JG%s\|}lP~a;gAuTilkIbd{~TLf^ttD_ l?lL|suKq5 B	Q0qfJgmhegfq||vyNQE>66+ %"~ r \ _ Sy`{}ffZ@`CZ?sS?|^omddbNzTHqOG]="qP?oQ*fKsT4eB>rQ(Z-xK*b?IxWI`Di5iSB`PndT8nL-rU,fI!6 )]L-kQ0pR.iBhZ{~\=]<tT^TzRYYea@tuqkzuZAeG~'~gqgztW/<~FkzwPj6](C(	dZgfhhnxtsvMIG;/14& x qii Y3y|tpoj_4L%(V<X8 bGMpcz[Qd?#oLKiJ*vObtSEiK(c@>g>[oEJqIR$X<dB<o=N}T3}lA\P`dFwpJ)pU0tX2O;5%  T5']72\7-rQElBeQcA_>Y^MmY]!S*md<W6pPoO}~cbyYDhO*V_{aUr5VM8 cP?|]3Shav_W^eco~}wl\\>?5'!
 qv je\r"fw|[~_Q1V4,U2(T2#mGIkey^"\<`=%Z9(kDZlJ@hCDgCBfBGbA6mRD&C#b@9`;LrQ:o-jKieOI~P-{P.P+Z26  4 >,\79oN;lI[9a@g<bamBd;h-Z37 nEtEqAwwbIoYwViO s^7{znx^, |M
a+W-qN)Mq^dCTzd]a\P[mjhZ\TM7"'    | v i^]q [f?Z4Nc8GKzkJeA'S2(a?3Z9*R.2nJE\6E1{>	WA\;3O0d@AgCBf=Ph@JL-\?<;P+$b;@n^MS{Q,{O/zH&pG*E1"5"" (A M4vQ(V6aAd9\^Tk?u\pD#KlCT+ wIYoVdhOs?_qc/pVhLXmLZ+q}^nXR]POSBNcUPI7Dlkej{w:pqSD 
}~ Wzb WybneY[["PW>AIlV5T/ww_L7)fC6Y7+cA5Z8+];/^4.x?4t:a:	e5*rM%lJ;c>EeLWcJkV0+B% P2	+ 4"3"eG|_sUtM~U'|^'sX(Y8F.7$5"7%9 e:tK`2\.f8`crUgqwN \ZQg?D j}^Bka|So;tG X#f@p}aE`g#uJTOQOPPPBNVQGlhu]_DdV.Vb<R\6X_9`O&`P&::yLNZ@\jh`v^cycQlmK (c|C^~Xld_OU,S^%@W9bZT<u`!glBX;VjF.iF7\9+b@4fE9S8+^0 /eKj92mIw\3fH4`JIcIooF<J-A% M7% )> n2r4|T e4a'sV%lL2S<!N<dO6,  nO}U}T&wO!}Q%X+YftVjwyR#oA_U_s.\hrdTwxHFzc5rX<{uqrvoX|<n;u% AGFPQQPEP\~^wnAZFMR2mCeDlL~?j.[ K!HMEK C-H<NK@J7,lEjS%t[(waWxlrYfVppYBaP"P[>F@H!FEjlOq_6eO9^FB]DOZAKT8<\9-Q/#jH<R0%R6.v<pH&jF#nAzM6lH7eNDfL\O1Z*X*	Z8V7 Q4V9`DlM7nO7fNgOuU<^D5Z?Nj[,rR-@" P-	}X,g;c5sX(z_/~[sqTbCkO)][]WU|8u6bz}b=]<nm2Mu9g?~vi{aV* z' d& yI&\HPGKIIZlOzceOcU4l>@_'_%	L : 47CA *% 0!* .GS@W91
:PMXy0Zhfjb[|o@wbUd
<F	:D1\aZ[=wKO9#aJL\EH]CJ]?AZ7'U4'U6*Z8,W3'UD1l<^(uFhS~]PaMG]CNkFO](&a#u5H}S%pQ,pR'kK4mM4mM4gNfKvYekJtjR>a;a?D1,=0iK7lI7yOEtq8ZtsSpW0|Sad`Vf[uR,~Y'uAkKgWxnb~ZfU!R r4{]RX_-Dhyj;HO9B9^tFvn?hCPJ*= ]+ R O	MF %$ '# )" . 3"/ / . 2 0 1 8 0R4 %0
*BNIG[R\K:T9KO8-A65TN__CTX?QT:YI*hD(sF`]BUMBRV@Nf>;_1&Y7+T2&V3+S4vMoEnCc8xS@dLZZECeB5`2oE#_(G) wZ/_KrR9tT;tT;pP7qYyNeX\OYiyW4j2m6YC3(K9^P*hAFgF4m}eH\2bhaehjsX9O15y\2tMkzzRe^U bF`:I/V|{^,ik{QE}OF=BD~0w|DbNiK: B(X! S+ 2 0 N A :  MK 
,4
- ! ) !  $ ) 7 7
 d\	{z fwYfd8XX>HUEOT:>C*OL2|N:F>H/ Q<6LIq?DdV@L_=:R/!W3&]:4\=e>uFlBjCdW]L]nRu{LZs7Ea,.xK2mKU8? yY@}^C^B[@{V<ub}JW[yO>}[G_7ZBk229	 %W7e?BzC.zf]RgZbfnsog?hvLO26 |itd~d`m,tN
J|IlK#yX]ahJXIH6Otb]P\R%m7 PVKL.N+N 6*
	 yXTlD(+   + :#'E9 }Y`
54kf:FP5[Q<VN9\M8zZAoQ7uT=R19~gNRK=D9KN/WM73V2&Q/$hK>%	 T-V%Q"b@x^ZaTda^EZG"pG%cJ)G0e20 E%\HHSGO`Scv\]l`qmKt~eN&dAgAtW/K66#- ! >+T3 hpKqQuX2wejQzoywwN,i@!cmOjoo[.zMY3W!pO'kogiUW^YuKJ=c2z>p>QPD.Sx   
    ~n hLE.-) 4"9&8?d{^f2TN@2RXTO@(D?+|vbv[~]EtV4zZ?B&!"	 h,)V5SF)I,`_> ];-UB=MGG l=%\8S\?g@cH{wZf|T-WKANMLM55oW_F  @?QEN;JlxrSjlM+y[5~`9hU6C2:*8'5$2I6wUnP+lJ<xvtsS<lm{gLe
xK1yZBcDQYT\#R4_f|D:?nPqXhY3p2 c0 I OZ
u vk m cT We; 72 0&{8_ bfOX"(<F@1@+%^0~L9w\bi}\PuY>ZH' @"e8#`B&X8R/-Y:=\H+Q=$  K(
Q*|GR(gEnQ[zNNqGxYTb[FG5/T6qX- 7#]D7I@IK`njkI#{]7gA`:iJ$S5
T6jOT6>  ,W8}_=gB{jCh}my^w^tbL{Tj@oIi>pP+rwupO_xWjHzd;M8W*H)\DbPh[7?X) Z% JE4 
(	 |ww	m `G ? z2RD 	b-X vIO%&$)$<3F$91}k?dZuVZm]:jZ7    EE$#R4Q8N7=\FGM@>4o4u>ajI\QFvR/V{QMGZbC@!F: UI5$ "  N3,s+Ni]IiC)vS-vX/}_6e?c=kM"Z<g+P2eGY<3
0
D|\BbkM#w~hjzanttVrK}WxL)nQ+`puiyW|ZnO~_\=c?7:EO\d2q`+f4 e# c" j'E*LWK?	 ~ |nb f \ IEh4=   tx+0,1lT0vU>S((<d8S?UM]R_TjL>"59D$X6*_9CW6@`GC  'W-i8WBYCWEyM/a*`JBbJHH5=*4!8!, ' L+^AfF'qR9rR:xZ7`dzTqLP1T4Z:"iI/F&=  }uW1Zje^uSwTi`4_1X)U*dxzvyh|Z[d[8' _[woT(zG;] g& g$ fVBL9  |nf \ ] Jw? c1J*	 G1J-M[%ZCB~`FTLC_   I T&vNHpUHyXJ{kq_L6" 2$H'C-R2AZDBbIF
 Db2oB*aL[;|P!f[+bIXM<#C2D5\6b1 ~IeOnO5nK9nL4lI2tS.oGfp}W_?$V6Z:!iJ3dF/Y:"A&7I	u}fAvX2at^guS~\tI*d6p@u2\c|}nhHb_Xuai6qDec$Ck+] n* k/2>3 0 ~wl m a T K8 g' a2	 
$&$ +$gPZ+~G uK)~dPYI84  
 "Ol7nD?tRQnbyUKF1 	2<:H&nKCP.
 *Q) c4&jKvMa8\DfB7U2'O,"R3cFA#e>e?r\<mZ<mZ<fT6jW9xitnRK+eF-~Q1[:hJe:lBpBc0wO!_3p>d8nHc=tsghvTrE'g9]7b:c:a:n.a7f[j5
T1wn|i{Yujvk~^ {<n,d# r/ r^][%  uul o [ I Bq4P(	  
("o3zU#{FzS1p^Nni`QD+D  # 9+ f.z=5rTH[TyT(%
  %;E xW+'   0 
O'rG+eKPV.QIqNA`:)\8pQ,K17 C%fR2ueIveJtbEr_?zjElsqhG4D(fQePaO{M|On@sFe;3 fQp^&}`3qS+oomj^}_Z2yTmEnDmEy6_2X.t9{@qJ*q@!x|bl+bwB {> T f! &HZye4$	  y qsf [ U
G }27  $ 2rOQ4C*|E'Q3U:hdRXG).	)"%K	c*p@(pQ4[7zY./ M4!cJ9/% ,
H)P2
." =)]+ f9m?c(iICUEYUG<lN-o@bC,B"	< /[@lX6p[JaIQhL3z^Hz`eG*zV4cFjTz\x[UxJ{Q!jqdO S8q`oipsoe6i;|QyOxN|NXM! s8P6 c)HWov5gx
qT@U r%8EH[W:  
u
o ZTO z9 E! .	 EbK7zD(zB'xG(m`AUib\?/4
	$ ;$K, t0AzCX0 vF~L,oM3]L8YF-pR N1S.!P(iLwE w;W kBd9l3hHKYCZ\DJxKEm;1dD.lL695$+-%L4!b?GQWWMIAxYOrXt`jDcD`H|]aZRZ*gM	}[s{pLT;vfo\~T'T[TNQpE~ayZa7bM.o#zw^uI }2
jKM\j[<>w wn6l \ R4AO,<<"`CQ1+  6 \-N$]3P(oD0e`\H1_M%F/ pC!b6`9>- V# ^-g7xM*{U^*qK@aJaf@CdB3X9!gH+=! K&Z%OqKX f/oBdaNOQPDNiq7;dI jL&rN-_B+E92+$bA"^LMgXRpXEU4U6T(renTw]m~`wYQ0jQt]qOdC}ff1qx|k]0iF!tmfgjI`Zb@oMeD_,iZz*qh4m yJsF n!<& PNdX>:  } 
s h [ ] ] c M3y5EN94L-hB<H) )9  : K&b7Z1L&|I0naMAoW3S'`6lD$`@'\;!G-L2T2xJ%k1i'zZ7QEIm@JlG9aA*]B$^FI44D1}N3`D_9zNk2q3CZOeQAhFjN$xT4lP<B<<?:(,%  3E2'T;-b3[< W(=4sYsX}^iz\xYBbB)kqLiEw`Js\v~_glJ?_;V6|elk_[AhzY_>nM`o,y: kt"gi@F g>4@XXP9 ?IG9&!:,vzp^~jD< {Nm,t<$cF%S$@) <!
uH$tKW6{O,YM[K{T@_4F\=mM4]=$^>%[;"L,Q0Q5
r@o@d9qe^F.e?:k>)sF2iC,F%I(' B'	nQ2tV6~aA]4rWOJBZBKoL%tT&qS,kL$L>/;1(=439) jJpQ<  T9^>"W7R8 kMqZzdsj[W9!vqXsZ]DfT~|yhOKwHi:\1a6nloryW];\ZZz]X,Sb| ^ l=Vqyk NR =R7KW>S`4 	81 p2+o(n7&E,*
 Y8yX^CP-E"M,lB e;0 zYBrXBlK-eF)Y6-X2=V4%D {P~TiF^+xK&e8(f9%kF-`@'Z52<!" N%!`>:^D-cE^@zmInG7mJ,wX3~_8[QEB=8C@;I51\KnAxFuBX8F&X;&\#pdLior|^H1'%}dtZjSjZz{}lgJ'EK9 a2xF&zrom~hdZlrcg.,T>ef2 "8vtm}kxzprotS~9p %% y e\A$$x0<  $U&d.sUa@zO-zO-e;vU1 ^;qQCcQeD0]=#T4W7 <W8!kAwN#Z*yP$sF/mF2fF-gG.[:!R2'  >!G/cLFY;\o^:iHoM(nO*rKmQvV<dD*tT<z^0xEuC~KWb:z^6C I V ^&zjt`^<nQt^iCiK|kwjgH~aoYg@ua7}i@qvt]_uJ'o^loh
,"v 'k YrqHF#+#$-F(,{'}(}x 
1mkh- B*  !` jJ&~[oM}R0W5lF.jeY  X,nO"{^9pP7`@'W7]=$2Ya.#xM&qKoH4mK;cG0dG0jJ-Q2\+ H  8! D3M1\_MgDaBxZ3x^]H|]G]FX:GyD~H~VzTa>d^.,!PX	]"(p[y58+v`{U}`|zmJgY:kV^?]>aDw.XUnm`8c:w[{szrphq] s s1)UH]YD#!!"-9g^WO`~dpQwl@qnEj]*jqs x!WLm  
Y!e3_DhFgE{O,pJ.u_O   ,^A~^EuU<yY@]=$\9!0+% R3]4x=L%V4wK&lKAjH<U=&K8<)&  ! 5<*X=eG!bDd>wQjCxfGmWOhIa;rL\_[iC}_9lN. 4? L'\5P0O/hfcuN.pWeDiG`=ZCuJ_&F{?i:qBSjkagJ ~ 8y X4J0+-,	##$+././7@?a?xAnk:gX6]N$Ze(hc,
     4	X1#T.\2kM}\?xaLLr|   * O']9nM-zX8eD,l>":0 1S2S& i;`6pRNnMGfQ8PA?0?2 NA	  I2)C0fI tS+eEdE qMpK}mNua\tX4y[1kFnH\tNrLoIj0iSoX?9?8
?:O,N,jpimiI1zYlJe@dl|nwR?)tRC+/tys|(vf })w=wRW="#$#!! wgrSh'QeF5(?  C;%TK>mY7`HdXx[Bre[,	K0+S<;eR@zT[cB2L8&,0 ;U$X4uI'vQ<kI=Z7+Q/%mM6U5
UE% Q?fS6tbDsW7pQ0tV4fNkRbZkJ:sMqJ|V|VtNrLZ8Y7_?oBaDPC+XE'M:qxp]?tQqOlJeFpRcE|Q0oG|g>|g@mIREY?fau[W<(39"& %#"!y q |mj `1PW7!  62VCTtH9BpAgIUP;"+"2 C'E+Ja87]NZ9V3
8 QR&i;{TDlJBiG:N,$P0iI`T$B4=-% 4"a=4g>;f<>qO/yX9d\oasR/qGwNsI^ZrPbAnOt?F,
LG0N< XG*gL nlkT*mKwUgLjNeLiH}j[x\pQcAubQgGqEm kLPF1*!""(&&''&"wret Qi(?;	 	 	3*C;&WU@t6%|O:fStM>3"
 7B,&K6#c>({Q<H2,  #@  nP*b4x[3pO<jJ5fF-^>%eE,kK2?)6#8%!<8R97V>:XA<bL<zjCsU:dKkV}W|V`xRqKeCc8\/O,T1+
Y9'rlJ= xVmCnDuJ]U3YsOgJ_AaCpR%2sP_^T<&--,!!(&','4.  pjy"fd4L6  	 ,$=6^J'h5#|2 f?xV,=6
 +
 1" :#R''j>)XF)S;d@hBoU3mIu4~d!|`7`GmM4tU8iI0jJ1dP2H89)	+$" #>""?#;P6DcM@eF3gRjTlBsJ`b_dBiGV0
`"`"M2U>E- p{Z^0{ZTU\liGfO&xSpOkQnQrS hL?;;.0, 	#% (&'0./)4)6ELB)ki.g9T\622	  !;)N-c1c)^6vK* ! & 3 E%_>&dE(S5R5oKmIpP$uX+e8sV+gLlHDgG,Y9 kK2cC*T4>'5 / 
 $1<)`Gf@_MiPdKpK{U]~\sQZ7X![$[$[$[$OJKVQiG Z<U9jdnzn|Tul{^tWv{}a>EK),+*!  	&,!$'%')10/,C+
HvJno	o6[oDUb/QK   % AP`%j3|Jd?A.O=!WF+I1fG/tU=rPCb<8\42,!5(jQ:|\GhH4pS-{\Bdc}]BkK2dD+_?&nN4G1 5"8"'&,)/%/$ /% m5mIf[hNnUqJrIqG~]fbj0\"X#n3S@V+\0]1xa0A  lS,gO*oY3rls|~ZtvN847=1/0*+"&())-",""$ +%)!*))'&($z6jyI2{~2pdcnNYM>@35% 4@K' j>j<> 
V8\>ZK7MKHUSQbUJkVEaL=N;O< 3P4&bC-hH/bB)}]DeLnN5_?&bB)_?&V6M-D$J)Z3	zQ#Z1pGA a6 eNdKcJ`GnVuVhHpR];]2MpUvL5T*T*U'R3oDZdQJ9 X}``V>k{Y6TS777/)-.45,./+'/!*!+-'0)%*)) y j_yswsQtny~vX[PDLDg9 LF!!!&K,i9P3\>G) >tL*cAkTeRBiUHiV4gU5<6$ U1^:!cA&xV<nM5dKR2iI2`?(dC,N.J*c8^.{Q$lEnFP& O07F(qT9y]AwUM{XQjmV/\]7.l0c6`4g4H3\9|xa]d!joLDtHj==7777//767677<07761);06%)#!!#(!/$&! vlTu{wq^~c~vae[JFEm='P9bA(Q1]<(T2&[9/U5\<#@"'9iK7\<#lRnZJ_J9fQ@]H73' ?)I4#cE3sR?hG5aB lN(mP'`@(Y9 SB*V?zS#Q&xC{Gh6R6: BJ#W6#rR?qQ=[L_@b"v2o *y:"E1]@\,~~~~eM#\6a-{]+t]4tu==7777/0>=B<ABHD=2>:88;1'+-	+%)+ tl~"p}rnqsua}fwfQ4rj"  qP3cJ\<#Y8%W5+];3aB!Z:!H:"LN6 +?Y9q_OtaOvaThRFYC2?5"%"
 /A #M(3\6DpP5dF }_6gF1aA*TF-XC"jAU(xBtD:$o9A4F;#7 B#G. p2.w$i(\=$g<,_1"\0)c1|=yZ$~~~sn~T9>9 Q gIu==777726YUNNG@?DDFJ@;<;14&#0, %!!%
 q fh;a_]bXsslloRQf[PR7" I)jJ1wW>wW>`A%^;8cB4V5%V4(^;06  -=K)X?'wcJu`QlX?n[<*  ( 7 D#U6iK%cErT-wY3eF+fF-gH/e;U3wO,r:m6w?!f8W@P9[CH8m7n:4v7&^?9{C3m4#n2#j=)lL?zC8S=n}|d9^ivL~J<<=777QQgeeSTINP^QZXJK8@V;(!#3."!('#
	 p ej\t8_slkchkM;NDZ[@ZH', 1B!hJ/nO8hK$nKE_<?[9.[9.`5,I0! %  5@ 3C';L8"aN,o\=kV9&">8# ]<!^<%bD gK$gJ#fH"nQ*jN_FhI0{Q0b5|T/J-w?"1|6j=sC#j9j;Q'~H}B>/'t8(l2"m3%b5[asZSt<%T(qG}fEvyWl?JJEBOMZYiggryxtld[\V]OC<OJ?=/'+) (&&' v ]gb1a`Ec^jvd;^FKXG^V@C0?++ >R.c5 e8#tN7xX?Z:!X7%^<0W0% (69"!M3:V@2_Q#lJ3E%P:?+&B!\6W2aB)gG.gG.pP7wW>kR|\C^A*\:zO-q<r;s<o8w@"=$]X&?9= V'tCmbAka@YY5p?+p>*uRQrLCk9 R.W1^8eEjYe[JJJWS`YYigtflg\TJKCGEA[53=9$10.&&  ysa cf,\[A_[JUCAdLN\KbXQR;0Q@J<)' HT'P*Y9 eE,kJ8X6*Z8,_>1,,,3?*H2.kJ0Z:!E.WD&<)5'3& 8 R2^>%_?&mM4mM4`@'{]FoC!yN,M.P2q:r;q:yBPFH=dPjO:\C-A
N}=/nT9bH-3^YXgcc?7oS?x]Hw^I[J}VEZ=fH}Wd~~xx}rqv}{}MLLA41jif>44]RT.-+834		 IF@ZTUidd675MGLK=4YQPMHG[OE;7.~}r}.)!.!"x]ZFPRyxz~SMO988`_a532YRPeccWGC864HICNCHVWSRGDH>:VNK\WVZOTPN@C;<izyuwt$;UUeZTC6%-& POOA89qkk_WN|wu2/10<:KIEmghUURD5-ECFG<;B==OKAFBBOKK6<;NBA<44hxY($@B=E4+-%1(#_]]LIGFA@UKDlmj ggi)#(630=>>YNLC??VLOHC8K8@\XQ@B:TI@745D=<|~wm~qZ5FH*1$~|aZ_xqtPNLA<@F@;XUT.(* SPU/5254/bhhRKP[NEUTNM>7_TQUKE@7=K@@VURG<<0+0zn^\M,j[NKiqw;<$%||~ibb}~VXZ320NFDx{~>:;  ./4:82{wwlljC<5\SJWLDMHETOLWF=PB5B@9SNJTU[B>@*&"64,,0+,PQohY}HQI$~{`\e?:7 TPJb_[901 &!
" MMKUJEMB9OC:MK@^SHPNKB;7MICMFDC>9@9?GHE+& ,*-}pezkh|j~F6A046#&416\=*ipt|}{}~~XUV?:7FA<\SO/+)+$$ 11.CEDQHGNBDLGCWRP450RJCMIBIB>A;7KIHGGE.)"AB8xqezkh\=/k@2<91/!#6+!}}GDB2-)SJG74.YOL932" !9;6@C>_TSFE=LFF{}|EB;@;@QJEVMACE=K@F,./0+(<<5746zvyuf|]`C?~{~ZZgJGF?;;41-PKHSOPOCB$#%*&"KKMf]aYWX??7{uqyx|VIGODCIIDJA9GA,PII84-.-':7/;=3D>;8+!{|~~=86EABA>@7.-_^[\M=2-/8:8>?>IIDSFD?<78-+>;5&C>>493VTP=4.QK?1-,&)$FAAH<A?86@63|$ojhbXRha`}z~}~~=:<GCA0+,@:<SPPKFA621+'&RRNJE;J@;:3+^gf#665@C<OJKIB;ZWY/.,787JBD@<-AB?xprhj~q'1.g9F?FA~kgw::9NC8343H?<}%"!445vim^RMMEA<85?@9MADKG>I@=! 6.3212`MH736F:>5%|y`WMt~[W}||biEB?OKJ302JF<_WV(*":97x~QF?UROWOOz|3*0533BB@egb& $41251/x^a^4/.ACB858|}}}ud|z~B;?LGG423I@@(# :=9ihdDBFHD;RNGzyxC6;&
C?>THH!j]dKF8>>8:64C=.HBB,20u~{xvdin}{~~hgoD==IDE672-)&;<<dZVFF@\SJ_ZTzyx1($:;6++*zz~A@<smr$! &.(3..D=;A<=Q?/ke[wgSwny~z`]yFACC;=;:9(%#IHDXNE<63MC:fkd)+&,&(/1.%!cbd61/slo8,!?:4:71<<):71JD>CD>|aih_N{|~{@76A<;%%#,&&MKGSRQOLFMG<# 2//&! ),*.*&2/*56/tss.+(<3.H===96<12IIEIB:yrs}{_]fSKB40.A??vxzGC=VKCKA9'!$+$&21+"!!#&$73330-z|I>D?9/=9<?99A>4G?@MH,i~|p~p8-(j~~dd|IFI1,+;<92-)RE:742L>430- +.% 8866.&]VP<5+OJI;=7LHF:66<>1OLJB75uuzwot{ 643ghgWUO;0'RKB<72wst$!"$##.*'*&&21/0,)hji%($<66A?:=7+NL<==9:2.OL9B<3fzpom~}~~>:BSSOghg432[RHLICFA8KGH*%'./+&&!$%%<;811)d[\E@:2..K><A;8LE3A=3=9+<?6B8.LC?KEBuzi}~}}4*5=;=jjh<;<KB5UODLCDAA?D:5# !/,, 0*'0/+srtLG>:70EGAOC=>9671/:70B:.9/.?>:LC7drkU;x|||}~766D<>>=<?77TKFKHG:93TO?''%11,')#`acVIODBBWRMNGA>:/=<3>92LMKJC1?=>5/&@@<YOK{|}}g #{+-2NGGWVW1/'QA?LF?PJG<:3;/2" #$$0.,]YX(&%;50?44F><WXXA@<D;1F@%YPN>=640'<1)2.+C??yk|~}~}|rkeaXQMGBBQID1/([[XOP\TKGQPR731H<1UPO>:;C?<JC9&&&&##++*1,)^[UMB=GA>JC=WVS;/4=;2<5*==782.BA9@@;96(<76NE7x|z}eqx}ynkd_;85~~vfd_}~|||[OK;64LFA'*+}A>9HED865CA7KECC?:IIFFC@'%%1//=;8c[[;30IB8MJDGDG[YYA?8G:+:94@<7=6(75*3,.A5*@:2G>4||z}~~ e\TIS]\]\<7:elfmjcFB=xtm~}x}WUT~|tssid_;-/JFAMI@MY`?=ASOJ@<>?<9PKHVRK@??I:;502542BB>lkjHE@VUTMFAE?ATNC=87B;*D@DECA<325-0;96,)$=2+F@5G<0}|}|J@<_TM|}|VX[tuuqsy\]a7<:HHK\^ZgffZXMec_xed_y}{vsusred<83MG@<82i|yXZg^_\IC;;:>20,FC>?:7JH@%";8<@@@^_^KIHGA6haUNOD662GCF8:5SLFC@2<7-36,F=1782>7-H@4=;4||~<40bYVyxw|Z`allrIIJWZWjjba_^omfwupx}|{pqnzlm=54F?8*&&_xoHDE\XY3.0IFAD@>B@<FB=,-)kjg*"G?44*(WKJMKF<3261.C>>ED@334==9@;:KCD51!HC<GC;0,-NHDE@;{{||<.&}tq}{DLPOSSGEI7<<da`^\WedYYWPeeZ}{{v|xqpF;;753F?:%33z504OKLGB>C=@<;+A901..352aca+(%7/.F=1=<6?><4-*LQHLFC57-PB4JF6WYRNJALHB75)4,)93-HA2}|~~~}f~TKBoheC@7~q?E=onkgcartxginloo]bg798_c^_ZVRRFPLGyvpZXRkmktqnK@@53/D<8+.}~`blDA>PG:443GC=PMG"<6731-fehC@9EAC,.$;9<TMP{zVWM661G?/;4%OOR][YQMJ860=54ND9A4,F<9}~|~|}s}tlicbqomupe5*$2+%TLGu2<7d_Plig]]Zwy{dno]hj<9<;E@RTQSPKGD?gedzysgfcikhpomtom\KH6.,lmqDC=ZVRA=<965;62210{mjmC<;EBCC@>hffu~mpsk_`HEEF;?KH>>@8^ZY@6/IAKD9.<71JD=MG;B;3}~~}~kqpoTWUtsry;.(<10?1(F33LF@faY?;2id[]XMtgcaa^YJSXJMOFHJ574RRRRRJVWT[WWkifME@112LEGMHG;86.)*3.,<>=<54<<6OOG;/HE:ckk-((9.-9-+:73NC:RK@LF>@;5MDA,()641+))F;4H==|x~}}xod_]v|x%<-)<.+?1)<*&}|b\V{v:)!E8/E4-F4*OGB_YWGB:xncVRKpxxnjgPMJad\z{|[Zd>BCGHIP^gYY`E?9DDA;89%#%>:9ppq-*%20-/,-E976;8~~%" #! ""E51D=>YJJUTO`^[3.(31-554<<5FC<?75}~~~|~CCFshd-"#96*90,B4+3)%H@:~zs7+N?5@3(B3-<.)[ZW,F61>/(A/'y`d\@71mgYOGESQCtkgw}x}`cxDEDVQM&('-*,CA@RQS0/,B<:5.*?;<omkMJF?=9JC;SURQICKC</'&7769:3?=:B44H@4}z||}|rtG=6QHANF>ME@6*!yqk1%!D4*<1-C4*9,(WNGjge5*';.*B1*?-)-]^\%@.)>/'PD<&/*QJ=oeY'%xyz{xaih_^Y@><GEF321GDCpv{1.196,A@<D=7nnmtmr<=7OJH797QHCONI;13/0(43/<=5743=74H@?z|~kgazsmlc__YJQ@=zJ:.LB8F>5F;-;.*dWSkh]</+</)A0)A719*&SPFysowsp5%!:*%;*&6(WQN2#<, 4%wppwp1+%g]MKH5hcdKLRNJL$$#2/+mefa_cPPMB=3>::72.ccceag#  TLILIEPKHJB?9453.1GFC9:0E=2>84@;6~}}}lgf445555@AEWWVNJHpqkae`]pg_d\OZJH?5'|sD<:LD7JB9G80,d]W3$8,"6*!4&#!|xzuw+;+$0#!+ lol<+,8-)3'$pi\wXWm/,.?:35;5H@>$&%:2/>74<82TLGOaaXVX576"

@C@TTQQQN50.1,,92"C;*==8;56==4G@:z}{{}~|ymdaDC@xh,-/066?CC_^\A?9{qojrlhl`ZZSK:( }q{ytI>3I=6I;59,'+#{wj+6)%1"."!mig~yx|wQBA5%&2("B8.iid$!#>=<4;;F=>3/)B<67))@78@540/,:4..)*!!9:=Z]bD8<:72">76812GC<A?:974?;-||{~}pfZzr~a]]t>>7T[\dfdecWyfa`UnlgmdZaUGQD>SLI{l~C;5F<44&%"gb\c[Oojd/&@0-MF<iki}snC?;E==69:RRS40.=52<;6?>>C:/2;6F;;>9; #
[[d<73550KF===/77484/B<4?><|~{{}}oon?C@zsqmfzzz~~~th_xn|zw^XRwftnd!!595W[\UPFnj]rjf^[SKYQB}vl|p7-$83,1'"PH>`^Zilh[_oQLL772?>B0,+;95363IC>QHF0*'FB>876330&:0'('"51370$/+2.)B>88<1;:7@=)D65}||}lAIWFT^tuyfa`v}wxy988~vRKFFGAzzzxqLI8~wkMKIyivZZS096dffOMMaaX{iwl[_ZPXPJG>8OI?onfmlh@<=>?<?<<3/.97424.)* FD;>=534.;;9888-"!;NJU@9 <:886,6+)63/;9;985HG8EB6SNF~~z|~g{""%?<={{~UQOifbqopHHGxxvKHAtqivocHE5zvnuwxuus585ySQHptvf_RreUYZYoli_XNyfuiGEE\_]XYOVVSKE<^XLFEJA@>102;;;=4*<77763:61ME;B=:GGB=951-*p\'(!//-400<:6>94BA7666GI?C>;EB?~{~~~|k001_XX``arrtSTSLMDyo--.~sgMOMW[S:><XXWjrqNQOwiJE=|pcd`FJItpglbOjgfRMKOIAea]NS`954877/..F??400C80PIEVE>JHGXYTTN=46/&&$l]K&&+*(20)@<8C=9:82<?;@A9EFBC>=}~~}~qy}TZ^BA=>72MGCd[[YWQLE>HFBIDByyzqomsm`[[XOPLxbbaB@<v&)$}adYyzz|x|y{xj+/+ygC>8mqohjgw{~oopXSLD@7,,,723@BC=76?<152/WRR_Y^;76RJ7504%&$)'(&'$1+(544;>8892C?4@<?DA?MFE{}}~qtwxQPOA=;C?<YYZ```a\]}xw}xw{{}^\[ccb~|ceYtoq^^_gfb~|jnpPKA`ZQ{OSN!%!}~qsraabJPFVRB+,#shYHEEmkk{wtrqtkgbNMK944@><('%3.,C>;MIJWZZID==50?53D?B##%71--+(,(%5426385-,><:A>5;74531FD@|}|}}oo~wmx}567:41B=4SPL`^[YVWpqrlkhhgffec}{zyxoifdlhfAA;JGBlgajf\~yvlgdqomroltqqohspjjpp~vtuZVN__S{q65-|wZbdnsx]`_^``ST[;:<8331,'.' D=<894IDIHGF<4-C@=100%$#60//.,)(&1/-56.5+(<>8JGDB;;:5.DCB~{~~zVjgwbk89:2,&HD@XSPTWRXSS}ywqplxssXVP~}{zyyqqt~psoomipnlrphsplif_trhZVR~xqpjZUSsrm{xpojpol}~~d\_nokx150hpk_^aa]_U\\}vo787@=7:8732,>:8GFLD;0E69<41@;?0,'-*)//*)'%))%64*6011/->:4=:6HB;=:8HB:Zl^n\jdsarxKNM,&%3,)67/^^[RPJkhd}}bb_|uwvwtRQPsigprkvus[ZQsnn[YWxxty{x~~}}lqqlpredejkmffhplhpmjpkdqofiaZu~zu.)!~wJG@ligcd`ddeLMJoleA=>967)))-**/+*B<=860B<6GA5@=>)&)0++'&'1-+,)).).0.-1./:65C?;C=4B>8FB9KHGJFHSQSXOO\SUmccojk{|wvjm{orqkge~yrZXUzusr{{~|~}oottu{}|RRMqqknidtvwNOOgb_UQKmg`NHDpniwzrge]wtoKG?b^XihfbbYrplxncZ\f521722+)%DFC0/0:95?=8FB?40,&%$210(!"-+& "*)'.)+@=>><><<6RJD>8070)rooYWZg_^nhc|}}~z`ifMKMnf]pkgyvsspsorrurv[bi~~sng}|@@Ewtlzyofe\__dTVVe`dYVSSLEb`aLH9`XSz~xthh^fbY"/-)POLURQiyqfwsu8033+)NFK?:<13,0)*HBDF=5('(433)''0..+''10-./(2/-74->96A>;NJCYRK43/{zxut]ZUd_[cYYtph|xzfdekhgy][jzywssqkhhIKETOL~<;:PTVx{|dc^]\X|wo|{{cadJMR@B?MNMpmc`[PJID=8-c_Rid[xtqa]YxtoXVNooo_]\kg_VPOIHE?6+ n322983;<9*+(52'885-)&()),)*)('667.,*0,,<27571430@<9A=4:<:!FC?d`^dhjcbgtszonqhsv]WbAFHec_zyu~||\ZW\_`smfrrostuBDB_UNXIAM>4[MJqso10+k" uvr[^_{wzv[XS{vu|ijlMOL__^`[V]YW1*+::363,MIDC@=lfb`\U~}`_YD94 )]sHEQLLL--,200>3)764**, '&'..,++**& %##CDD880E;;1/.7:4D86KD;LE:kfoqlu~{xvoqplmRRSv~y|zB<=ukeke]dc`nno>3.QGDSE?VI@RA>UF>_UFG5-7+(C5(xoxwy~ULEzrb&~}w}xrv{ztphOIHog_B=.kmnlmm;>@OPMUPLMMH]^T^Y[GJ>wroD@?K@<(#$,-*C@>10.31/.**)%&)((''%367.' ,,*%$!41.9<:668++'@?9794>77D?;VaXfgdqkiYWRy@?;=63SDBPE<MB?REDmifF<9H=9M?8K>3K?8A7/JD>|>62I?4D5-L;0B3%hc\D7/@2*E4,L:0umzxp51*^QM>5-KB9vtr=?5[Z\y\XRid\JF;~yzzwsw}lmnknrRRMVOJSPE^\]VXPnlfspj643## ,*(%#"212.--)*(+$$,0,*'&**'.-/401<75565A<7;95==<PKIURLzxsljhyuyEPM{weia650YUTOC?H:<PA>ypnHMIG@=J>>MA>NB<K?>GA<B=8UMHQHFHB:J=8K;3YTRtqm`\O:/$=/(;.+B3):3-NF@1$<-*C:/A1%+!YTMVQG3&#;-$:+&=1'peWOPL@7/ZPFNJ>wxzNMGEDC~u=:4nnhzumgghjvV[]nuyNLMIKBWN?A;79;3cbaF@=764$"(%&+))% $"!,+)334++&DD9MNG52.=9-:86FDCOKHmihPMQoqlhzs}cc\]VPsqk{u3,'F>:NA<NC<MA;E<;pjl>74SGDJE>KD?OD@QEB>88IC=`ZWUTNOLCOJFG@>VIFE=5J@7K>2?5)>0# &:,!G<5:-&6("6/*4$!4% 2'"  8)%6'.!iaUPQMUH=4/'SM=YYR;5)plfJHEjc_pmg>=:fsvabhkkpUSNC<4F77NJJEHE#"",,*!!!--.+,,.+,752' #02/964++*@>;HFG___@;8xqvwr~::::/$I=5J;9P@?N;BD>:J>AF<9K>=F=8@97662NHFRMK^TU[VRYWNRDBxtulhdrqqnjfolijbW_VPdXS~~y}rXUJWQBQLFRI=LD7%:0&GB7E<1?1)1'!(g`_{(5.,."," $DA;%7& 'MF5++ *!5,(%%70&MD<<82^TD[UP:9*E>8iwu{snzqww[ZbSTROPH;91B<>PTIGDF>:5)***+++*(11-/*%46-*-*LF>B>;CA=_W[L;2E0'A/%YKGld^4+&G=3K<7J@4G91LD7iPUD;<I?>MHDPILNGDE=:xqr=A?\ZY[\UWUSJHEFDGB<9{uqrnsrsssruut}|xtooxoqmjpmhtrksmihd]WPFmf[zsljec]XQb\UVOISK@=4*?56qi`.*&?5,=.(TMI}wrgd]xu) -#"+! ~}}t, *%N;30","!@<0?41) +$#h^SHKJ=>;PIAZYSw|}-;@fkpYX[EC:?:8:7./3*+(*//+*))))*HID4)%(%&962953FC?;901(!8.*B1.G9.H93?532+1@3-C<4H?@G=AA;8QNG\TJ`VXYTRYSTVOPfecomlussvuuzwxvqqtpo~}xxywwxjjk\\_zHHHssuwxvyxvlkgjfepicv_\X{wuzwrtqlie`bYSSICncZtsphTKGZWNOG;GA=&VVQznlge:4-6-'6.)qh_midmieRKE+$ 0!#ppme^Wp;,,/$" EC;<<2H45,$873URShnsmop55:bg_rppvs~lglkpx^ddPLK62+(#,(%10/<8263.20)A83200;=7A>3)?+*?1&>.+?2&>1.EA?HDCQJGMJCLFH~a_]njfqkimjkjgfjdd}~zxxx~|}{{zvyzvu}|}{|z{z{ppmztgoQPO^`]kjjiggYVTxrgugrqnyurkih\YO9/+}smfUQHAXSKNHFJB4/(#*'$qj]|{b[UKA9?80=3.ohfmjaa`]e^X*!*mmkK??mjg1'&-'(61-&'"nnhOURSVY[^ejor;F>FMR*8;jkqCFH)()300..//.+DD61/(763310;<;9*#4*$5*.8.1?//lqsD@CRONOPIQRPRNPSOM]UQvssyvx}|}}{|ttwz|||zyzvm~wo`zqfopqplnrdqauznCDC545?>=HGGX\Ypcxoc}xxssqrqlha`]VPGEArgQ~yuoke\YN_ZOE@:D;2/-$sh_TJ@_TNOI?>51A3&qj\wUPL(())	YRL3@<RWPs{~\[`0?EJGCURQQRV427.21'%#10../*?88/.*10.42/<<1>78HA?HG8FA;HCBWWU__\eddbb_TSRQOPibbnlotuuyz{zyz||}{~w|ys{vnfi_R`TBwxg`_uiXqcQc`\SQR;<;230zqfrie[QQQggdXVRYWSJJBueY^UA_YV\YXKFA0'%STT[QGlk_>83:3/! bb`OKJqpq!"QPU24NMJ_feC9<4,.54271/"! ('#><7\^_TQL__]cb`b^]\ZWvka{soqqr{{}~|w{~{|tuotuy~}twx}}||{~~???zywroo{tp~}~kg`l`NrgQvulik}q^ykXM<TTVmnjebcRPRjbU}r\eXLb^_de_VRO;42leZuiSi`[[XVUSR53,!+)cZTzvnzk*.*Xgk{~_Ya/*(EHIJLM^ls%&"++*432 -+,BE>ZXXihjpppstuttrkkmk\`yzx}{}zkhbrqqWUNwlmi^HJIpokec`RNL[b]e`Uk_Ronklmm]P<dW>|zmmm[YRldSmfYZWP|x:==&')`]Xo_KooccZV,%&"]a`~H<D'%&MPSMNO610335826*'(]ZWcbc}|}|||ywwpnjzxwznqquuv~}y($!d]UmgX{umwvyuuwwfgeDEF}kZVPlg[a^Wpqovttnlh}}|365]YVpl`vts}~gcc[R<[O=vuxhif-0)qieROAREC01//.*SRP{}lqxC6;		JHGjjkJII,**23/*' \YZfdev|~~wxruml{znRXY~|uTSQoeWzHJKdcby}|BC@}wnRPDRJ<wlipqlg\T(+*tocB@7lgS@51cffYXYuuunliqmjy~|nprgd`QL>]TI/,&VVT?@>)$ PVS@@7LKM337
NJK"-.=97%''2-*1.%"$PWP_ZZ~}rrvnmsjhlj\Srlgwuy~YSTZWV^^[wuv[XQpkclh`~IIDNPNRSSvwv<=:lgb12-a\Vyrj]_`]^_fiklnlrsz~>@9dYR0+"meZ41-geUXUVyuq~zyxxz|\RKZMESNAolkosmspoWWXGBAYSMIIAYYW+%"!!

CLMOOS(&!4/'+,,OSX("!ttzopnnrl{|}vih}|zy~QSRXXWkjd20._a`>=6vqj{uh'$>A<bef|xzMNK}qvse}yomncegYZ_`^a}}~oqvlmolmtqpuTPAVSPorr||xmlmhhfRQQTTO6:/RQRpqs<<<120ISO0%(QRQ3)263LNN457)((}zVWYD=B~efcigf}\]\}@?<hcQtmcLKE_RHcd`ph^(''fc`x}~z~ybce&()577><;JLL@@@LOP?ACVRN?432/+ddePNUHGG<>?')(1/.0/*=9>++*V\\UST-.-63/yLKJldhiceWRSii__\X`\JaXSjea]OFrrp{o_|wulh{~uwytuvusuvwrqnIOPzoa/,* nonghjmopqstRPMcdbNPP5/,**#04.;C>}|.0/**+>C?22/566OLL('$RY\SUV/.*((&150}uxd]WRQNsms@78\OO}}}ghkTNT~z|uot=:<ZY[nmk@AFvmevmedbb]Ntof:."S>2uok{qxzk}niuvuXWRnjbkoqvzzxx|w}LJI}}}kjmBC;4/,:=9HNN`^`[^`TSS:;9$" #"#CCG(*'Y]dPJJ<;9kwp}zyv|}~gpurutosndgh{zukhdpprebe}~|xx~}zkkjwutxuunli{yxMFG~yuwsr||zsrtRKGtrt;=@c[WppqYZXw@CG<83'),645i`Ljnn=3#eYX`UCa_[rdbuwx{{pqtLKImqr,**983=:9TUWuz\^`XZ^525!"#66>&&%W`c?@<>83}{{}vy~suw|yzvx{rrsyxzz||~|khf}z\YUyvtmee}|xb_\nkilljgde}|vijhSROqtlMLJ~|wppkz|yebcsrnfb_wvt--2979>1(79B^YU00*ttx//4gd_XZW(,.}wnXNK?PLN~}USRVYYV`\Y]`SUU!!& +,.46;C@<.1'++* EA?|v|~}~|{ysuxxvxxvsUTRomj|]WVokgvomrmh##jedurdqkgxxtonmfhgbidbfb\yuq]YW^][USEIDEmgZa^cSN=QOO-,6C?+9:4~yuxz|utxssvrtyrptb]dcaa'*)*)'WY\^``||cff\^`?@A*.1*((300EEF++'/+)AD;;>,y||}z~ggdqpnhfbqpkpnpwvqmmffdXok`>94[UOtohf`X`]Tc_[]ZRVSNLKHmlewws~|USPrmkiif``Y~zuZWUsus[[UJ?:tswdhl`lsdcU%"*)++EHK??EtuwQRU?EL77=!! ('#&((OX^58;+($%$#D<7PH@]Z^mln~rtw~{{|^^Ya]^|xw_\Wvusca_C@<SOJ]XPNHDje\i_Xa[Ob\U{fb[gc]KIAzxr]YUggc.,.rslXWZ@;>dddNNMmlldc`KGHpifb``}@>Bz]baV\_bhemqtZ\aMT]/1,+)*-.-,50MTRIKO:E;D=?C@/vrzm~~oqsopn}xqnmxzuchhswx_`a[abZ^`dhiinmXWUrqrosnDFAurmWXSTURa`X42/:84OLG^YOC=5dcXXXOVRKmjc<;:iha>;9LMHSQH@DBpoppqnHGJ@@=EJE6:8,..POSQQQ<581/3$#%!%!IGK78:243163?@C8<;ED:==4M@D<9;ytm|}zbaa}hol_fc}{s~zzlpveklotwtx~_imuw~TY]SUV]aaSUV<<>TSPC==456;3+CGD:=9CA@=<5A=5.'':4/WUS<79,+'585661//,#!!1,0'# (*&*%%,.-@:3DA:>2-xrpuyvGC<SLI^XLF@B9:5wskw@C>gdU{zsY]\~yQTW]ZWyuq~vqm|wno~yopst_jlVZbRKS).1DPXJFMBJKLHJ#%598556-.+(,'0-3//-('&##./+;83A1,G0-KIK>.(@7-C83F:4E;8|powzz~wwG;5H;7H90M=4yvztxlie?:5bWSbTLVUQ[XLxpnd}}{NOGYUM{}tx{y{ac`ZWNsokdZSpiayunS\`XdoX[gUV]ENX68=]gk,2;TPXL[cHJN!:<6,.&72*7.-ncey2)&=0/7-+>1*B24K=5;53DD?3.+D71G99H>8I:2L;7Zb[bgcMB?B70D5/J:2D:-rgbX][SF8J;0J8,O>2k]T7,'aVHl]KVOE\ZPsy10'heaXTP~~lsjvwvXVOC@@]b`xxvZ\Y{wqh]_YXFTSI}xu~qnkTabSdf^epEJQc`d66;!14beidoriktEZ^Ncd6/1:2-NC?RHH-?F+#%:/-FA?GE@JE<JB5MC=1*&91*B65F<<FA>H=7E6.E87/'$;1,>2,>2)A4,J;3@3,\YW72+G8*E6.D7*J8,H6.j]WE6.A1%B/)F6'D-$}qdz|@-G3'C/!I;/]_\;4(O=3@84MK=}feQujY&$gdaorqE@@dc_uvv~xZ^[xsoB95P[ViomKHFw~uSCF751HDA481wTirfjo431636I[^b_gT`e7.,:84WLIUNI-'";21MDFSNFXOLRNGTOEf^Z%!BA7LICTHCQG?NGCPEAk[P5(%B;6LE=NDBPG=J?7@1(J?<;*"E:/E;4C6.I=1C1%5*"?3#;.$B5$>-"@/$7&G@8#B3(:*!?.";+"G7/stm+=("=) 9&:(#{skqqr4#0 . ,!kdXVWSODI<4+H=356,ypwxy6-.7-"D>;45'a`\}wi*53{~xwy/99SOZQMTnmp@>:gvzjnu8;9bv}st{ &$2;6U\_.*-33+`_^pY_SPLWXVc_^ccXa_\a\XaZ[=;7ROMWTQ[VTURG[RK^VVYOOI?6PGEQKDVNISMISMFOE@I<3.'NE?JC6PF:IF9MA8?,#pijI=/@;,PE:HA.B2)>,#92+F;/D9/A4*<2#B/%3'#OGA 	5(46#5# :/)@>;ukc5"5%/."0& $!&(&$]ZRjb`>A@shg'&* 3+(c^X_NW7*(']UFzntH>D##!"SKHmsuD>Dxv"++_\bFJJONT($#b\]a^\xyzFTUZ[Zdeekkjmklmmijf`eeX|qrUUSfdcffakiijd_gc`b\^a]V^VPa\W^\Ue^^daY^XLPND`WS{||yupPF?ZTMe[Q^UKYLHUJ>JC3RQGpngYO>ZPFXM>VL?PG8=1('LH=LB8KD6E=6I>43&#F=3?6+>1).&FF?@6.=0)1 +(2/%mih#+ $ -+)hZ\%#&$-*$%'%TKEtj_HONmmm<;58662@<ZZdaeh%&!165-02TU\*'&_]^WXW}dwy]\]`]^hffgegkhifefcb]z|x{|ffb\[\a_anmnnmpsmozuvnkemhbnjfecenokpnpsqnpmmojf_^XZUQYVTrojnleqliiaYXSLVPBZKJ~|e]Vh`[ol^d_UWPISKD*\SI[VGZPHZQFSF@F>2	zusaXQMC;IA8F>/C3. LFD>4/I@5J@66*"bY\50!<2.5 NA=5-')!"\WWtto96/!#NSO   qw}U]d<45	)4612/!!"}z~~lnosqsx}znll~z|t|xhgjSVWaccbbbplmjjjcbcb^_]ZYrolWZ[gggonnpppjjkhhhba_a^]_^[}KEFghhpmmz{zwvutrob^Zxywl|wq|xtvrnskbb]Ud`X|d_]tokmh`daZbZSOI99-$GFE]YS^XNSOHKD;,$ GA8mmf}zpZSGOH@H@5.%kli~y|GC7?;3A8/mnnpon92-=52&! jfhkcclfc1!hll2*'WVSnu|XV[RKN	EGI]]cCOV~~|yz}qqslp}||x~}{||zyyzqplzql|{}qqrfgd~~ourecdba`__\pkj^bbfgfbaeXXXhfdccb_]\yuomllkkhcbbjgg_YY_\W`ZPnklad_bc``\[a^\QLGNIC^YVwpmfbZUHvsttpmifefa\\XTLF@^YRicYnj^YVUomm[UPVQLNG?
zz|ZXTWRKFD;,""wrurlhTRLLG>B:3\]^WRS;71  
{xy3/.ePM582PNQjih:8:6/7

		;;>IFF9;=yz}tupphdwuqxl}{z}}}uvuqsqlyzqvuldgcv{}ycc^ihejhgba_RPKMNIwug}pmnmfec\\Y_^]^]ZPKF-,(xowfcc`cd`dc`\[X]WUAD@WSNa]YVQHmkjcc_hca_]ZRLAIHCsmjtof}sefc``\MJD"mpcZTSLF>\TUGKA>;7cecnjbz~kghA@>312iml0+(8;;DEF%($	
COR6/6" ||{wts}}wl^|~it||}vfycxxs||}srrgeavn\zm\bc`jihccbWVTHB@wtlxjyzohllfecbbaSOP<:9ba\weUNBeb_loqRRPGEG>??@E>xrm`ZRbf^dedWVVIFH784>A>urqNHEZ\[okh???432&UZUCB@DDD?78T^`213*('#''NQW"#"?:<ca]sqs}}}}wuk}~~ojZg^Nyxxe\G_S@z|}}}rnjq^r_qtsrl\|m_nfR{wv~XXTg\S~vh}vz~zx}zpsq`]^``[qiTwlZ^[Xe^ehjkPPP`a][QBRM@RTMghjFDF499062RKJ.-(1-Saf:8:%#%!!"=@>EEF.46j|}WSWpm_h`Rimb<HDxvvsnri^wvu>6+pne|{|dZPQH1wvsmlkVN;LC2qut~uvuWPBQE?;3+wwyltt{z~___WQKUH>GD8^dglkkhfjIIH-. -*&44>FGEklrDIKJOS)+%##$%{~{EK?nf_tokyt350[PO}}|yvpvxy zysLD5*)*vugyyvnkc~}|~gddff`~rrt`ZLjjbwy}{wy}a`a=9-IKDbeiknljqx]da-3+##784ACH`mpSQYPSZ)(("!{wx}t}ttp$& NJH]YW}w)) |~nmo542d`X,/+t~zv{zxuttvuvggennluw_ddx}kkpUTPFEEd`ffeh88<KML!!"$"JLTpmrLORRT]HFN''& # "RYO>=<sskefaFGC~||y100^XWFTN||}eb_PRKPOF[WJ64.PNB}xpqro`Q|qsquyw}www{|~hhfbbdllqjklL]YTRS;@<363[dePPSO\gIPY786"$ %"NWS}urplkmz|x=;7?D?W\V||zOSR|vx54-a`WPQLcb\li_aZQxwu/+"PH>qvx`bbsrtljnsty|z!'("&#KLM]TYDUYMX_EIN$#"DQR353{|z{qsrDID|}QUPyuqfdX}yssrl=5'gaWCGCDGGsuxoruw{~xy{srsfij30(=6+pszhmmqorMMK`^aYW[[]_]\]szx::9873)))750mpw:AF>>I;8?/.1&#!z}nwxJO7xrsTTTkihrtr_ggWUSID8EE>qnrw}zv||oqsuuyihfppmHNG/-.0*,)7612- !^`c(5;S[cOU[9==+&$wxrPBDzquwwxwyzuqjmk{{xx{{}qchaaZwvzz|ux~(!DDB*&'RSW]XeWagX`gLRUtyupnieggvww//0KEH--1lhd{trxspk\G}wtpmf\[Sb`Z|{~}wzz#$#&! 132TZ_ejmPZaZYdNV];9:QKM@@ITMNIHL~pjmhftqt^XP`YM\WViopFA;V\fOONypd^Rjkj|{w`]Yld[pxz{}>88yup6DB_dl2)*Ycd@?A1CIVWeBDJ%"!CCJ`Z[BAH8--}y|ska]epWVVjy\URrsk_YVrlevz~ou}vus626+()!%(&NQUFMTWYeWZfQV_@9=HDHMLOPOPvxx@=A9>Aopx:@Fwum{yyltvpuvz~}oqvdciSWVZekZ_bT;<#! :<:EED]ce5:@<?E479]ciLHIYWZRQSVVUw! !s{^[O[gowtwlmolon}smld^gfa|yvwfnnXeg`\[\^fQ_asqr>>>@BE,+/cah@BDEKV@JVPMStx\X\STXacdZWP~svu|qswnrwt~x,,+" &=CFGRZDJMOOVUUaRS`zC<@VQSeacrqw{rsxpox|w%""02698=366PPVQT[EL\{stD@;~y{_TVw~ogomfghokBAIP9AN28bff?AB9FG''#=98&,.svH@>404XabRQJJ\X]ce}UFLvwuzNRPRTWRNJjpn|uvl.)(~uv~ibgxuo{yx\YWKMLPHEztvzyWVLzrr|d[_mea}>77hcb.+*~YXQWMQ_`X/&!"FHL~~vtsE>:hkgmac_ZW/0*YPM0+(WROv{}rrs_\ZUHHYSK>>?%)&?=:9<;541&$%--!f_cgikhtshmh<RQDLFKKHSVSgZYudb|ttynoke}wxoletqoh[YAEDvymf^^{vr@57SNOrml}~v~upib\omd]_[gTWyxs&& UWN}tqk~jeetqqni`dZ\PRMd]V|xyu|w{vo|tqtidgeZwogi}{xJLEhc_}{xgcagh`dbakjg@B>~yuca_\YVjeezpPMQQBDwqowuq2,'YXRqogmlhcbbljjmusg\U]XRD>=hbU+)(YXVURA^]RWUOULH:94]WR]UMKKDUH;F>6C=8XMFCGF21.10,&$ &!$#"# #"~~~heknntuox{|z~}q~xrtzqyzhihonrlplptufcespoipkedadhhhojVWVljh^_[b`_rvrehesppxvqnml^^Wffc}~wmmknsousnfg`stovsknoiqmhc`Z[UPng`kc[vlge\URLG_WR_UNYON@5-lc]ogbykdg`^[VPjd`ZPQYRP^WTVOG^XTXPR_ZTfY[`ZNZRO=7980/>5;^_ThdasnmXWPPM<JD@MG;OH@MICMHBFHEBC@886]]W_`^VVPUXVQXTNUQfhh^_]^^\\YUONNZRIhggTTR/80w]iusqRVZejj]_aJQMEKNVZ`BNNDLLPNRPT\WYfOMTFHTEOZEFNIJT<;@ABI?KSgjiqoqvtv{ou~y{{z{u~sszw|yzortz|~~~}z|jhhvxzsst|vy{lpvsru~|hms~}}~~tx}aekvuvsvztuxvz~gfdffdrptmptlpsbbkkkreim_dkilsJOSqqwilqelmdnrqvnhpoqwrzvqrzjkuels`m}op[bm{va]ZB88gec|{lp|nw~emuTW]Z`koqfpvyyvzlq{benxmo{xRFB}umokmj'.'ozxoxnktgo{fn{gks{z{{22-oibvsljf[tjoi`WNH]UNpjbnlZd^][VTvvy_\]v0..^ifw~kmzfit_bjgoztkmc`_}sp}spj}{~~twSWL}|{}z|XLGoaIupytidVSInmkzzwmoplnqorpuxv``ZggZ`XQmhbtkhsrocR[noq\YXvxTOK}uwwxps~kr|jqms{qux{w[SNy}zuvrec_reftlq|wotqptljnh`ys`fy}whmflmfrdm\WSNMEbbX_^VXOK^XVyz{|~omn@=6feYkkew||uvwzujma]``^ZM?9..iswgmynthr|smmIDF}~zdfgng^cbaw}z\^^xvzttstvo|ppha[zxtyxt8=3yha[XSzrumUPKllphigee_lgamieJHEvpestxRL6[MB90+>4(.:(QBCv}iisacmYckrmhipm}jfb{vzxTKJ984ghgxthIH=jkcROPlb^jcYmmk~}~gh`jcbeebx||z|z6+*21"/) )!:5*xyzK]X/65\gqYNUXJFrpp{i`a~b[Xtkm}szucg_zssKKMhhhUTNzqpjf[jmoz{|hgefe_rni}~x||{nifVNKNFF:7/./&KLCVKERHDOKHEDH;83;6:823.)*eefvjhhifooqw{x{y|stty}|XPL^]Vpkjwsrqmh^Z~zeb^bwvgbl^Wd^Yi][qcghxhnq`_]jddrxsw||Z]^~lnlcbdNMK<9/8SKsmfJKHF7532,6==QUYMKPQPR221843{cfsossw{}{|}x}~ooirrlikkKFBvtvigciaZ`\Zrbb,***&!,-*54+8GBB<6OLC-.()%"9&'UPHzqg{~yz~uvxha[]XTqpsmvw=99zpXXYIMN>=;021';:^>KYOQW@D<99575TRVV\eeeqehngfk@JOT[]rqs|{zNOP}spfvvy}mkwumd[Qmli]XQca\wwv,&&-.%RTNtro685[WUnih@F?IHGbb_AC?rroTVN880%"!bWR`QUqrumgcuin~~^\__FRkELJyvt\geewypquyyGUSbafSTWb`j}nxjmqbiqhpx>IQ[bjfuvfde`ab|~umvpl[YMe\U\PPYNKcKIcVOOG=~pg~zwsodbauqxwno640prwkhnjfissn|~~2,,EF@INJab`feeSKEPNESIA=64@@3H@7==8P>9XXHjhffd`jjiegeIJG)(&YLBrtwjjeihfIJL70-=?9T[_NLN44*5-+#KIO]^byhfqfktCJS_dhbY]zzzbjl}z{a``<,/51,;<7GJJRVT`_YYZSdcaffeeha`faUQL<=66/0M?@wllkfcunrohimlrrqvtuva`^X_a]\_KOKspnpolXDM,.(LOHgghRIIZLD*+'[]Ynpntwuyyyt{y|x}uvxcddehbTSDXPJ]XKnjfegcGIF/)%^]Uq~nmtorlmd__Z]ge[NIK547:53IE@NMI?2.mst<9<acnefkhjoFFPdmvhikrxt{zWKKTMJ554[]]onqrsuy~z~|zyyrurxxsxsrzzuzuqqqo}~pqoovrWYO66+F77sstx|zz~c_\~C88KKG`[ZTNNUH=ZZPx{|hglx~}xz}sxz~z|iji>:5VRK[\XJUU./-UOH{X]\khfy{fcc[aVZ_Z731W[^A@<ECBXPOUZUOLLDKLz;K0$) $   &%*/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// OpenGL|ES 2 demo using shader to compute mandelbrot/julia sets
// Thanks to Peter de Rivas for original Python code

#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>
#include <unistd.h>

#include "bcm_host.h"

#include "GLES2/gl2.h"
#include "EGL/egl.h"
#include "EGL/eglext.h"

typedef struct
{
   uint32_t screen_width;
   uint32_t screen_height;
// OpenGL|ES objects
   EGLDisplay display;
   EGLSurface surface;
   EGLContext context;

   GLuint verbose;
   GLuint vshader;
   GLuint fshader;
   GLuint mshader;
   GLuint program;
   GLuint program2;
   GLuint tex_fb;
   GLuint tex;
   GLuint buf;
// julia attribs
   GLuint unif_color, attr_vertex, unif_scale, unif_offset, unif_tex, unif_centre; 
// mandelbrot attribs
   GLuint attr_vertex2, unif_scale2, unif_offset2, unif_centre2;
} CUBE_STATE_T;

static CUBE_STATE_T _state, *state=&_state;

#define check() assert(glGetError() == 0)

static void showlog(GLint shader)
{
   // Prints the compile log for a shader
   char log[1024];
   glGetShaderInfoLog(shader,sizeof log,NULL,log);
   printf("%d:shader:\n%s\n", shader, log);
}

static void showprogramlog(GLint shader)
{
   // Prints the information log for a program object
   char log[1024];
   glGetProgramInfoLog(shader,sizeof log,NULL,log);
   printf("%d:program:\n%s\n", shader, log);
}
    
/***********************************************************
 * Name: init_ogl
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description: Sets the display, OpenGL|ES context and screen stuff
 *
 * Returns: void
 *
 ***********************************************************/
static void init_ogl(CUBE_STATE_T *state)
{
   int32_t success = 0;
   EGLBoolean result;
   EGLint num_config;

   static EGL_DISPMANX_WINDOW_T nativewindow;

   DISPMANX_ELEMENT_HANDLE_T dispman_element;
   DISPMANX_DISPLAY_HANDLE_T dispman_display;
   DISPMANX_UPDATE_HANDLE_T dispman_update;
   VC_RECT_T dst_rect;
   VC_RECT_T src_rect;

   static const EGLint attribute_list[] =
   {
      EGL_RED_SIZE, 8,
      EGL_GREEN_SIZE, 8,
      EGL_BLUE_SIZE, 8,
      EGL_ALPHA_SIZE, 8,
      EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
      EGL_NONE
   };
   
   static const EGLint context_attributes[] = 
   {
      EGL_CONTEXT_CLIENT_VERSION, 2,
      EGL_NONE
   };
   EGLConfig config;

   // get an EGL display connection
   state->display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
   assert(state->display!=EGL_NO_DISPLAY);
   check();

   // initialize the EGL display connection
   result = eglInitialize(state->display, NULL, NULL);
   assert(EGL_FALSE != result);
   check();

   // get an appropriate EGL frame buffer configuration
   result = eglChooseConfig(state->display, attribute_list, &config, 1, &num_config);
   assert(EGL_FALSE != result);
   check();

   // get an appropriate EGL frame buffer configuration
   result = eglBindAPI(EGL_OPENGL_ES_API);
   assert(EGL_FALSE != result);
   check();

   // create an EGL rendering context
   state->context = eglCreateContext(state->display, config, EGL_NO_CONTEXT, context_attributes);
   assert(state->context!=EGL_NO_CONTEXT);
   check();

   // create an EGL window surface
   success = graphics_get_display_size(0 /* LCD */, &state->screen_width, &state->screen_height);
   assert( success >= 0 );

   dst_rect.x = 0;
   dst_rect.y = 0;
   dst_rect.width = state->screen_width;
   dst_rect.height = state->screen_height;
      
   src_rect.x = 0;
   src_rect.y = 0;
   src_rect.width = state->screen_width << 16;
   src_rect.height = state->screen_height << 16;        

   dispman_display = vc_dispmanx_display_open( 0 /* LCD */);
   dispman_update = vc_dispmanx_update_start( 0 );
         
   dispman_element = vc_dispmanx_element_add ( dispman_update, dispman_display,
      0/*layer*/, &dst_rect, 0/*src*/,
      &src_rect, DISPMANX_PROTECTION_NONE, 0 /*alpha*/, 0/*clamp*/, 0/*transform*/);
      
   nativewindow.element = dispman_element;
   nativewindow.width = state->screen_width;
   nativewindow.height = state->screen_height;
   vc_dispmanx_update_submit_sync( dispman_update );
      
   check();

   state->surface = eglCreateWindowSurface( state->display, config, &nativewindow, NULL );
   assert(state->surface != EGL_NO_SURFACE);
   check();

   // connect the context to the surface
   result = eglMakeCurrent(state->display, state->surface, state->surface, state->context);
   assert(EGL_FALSE != result);
   check();

   // Set background color and clear buffers
   glClearColor(0.15f, 0.25f, 0.35f, 1.0f);
   glClear( GL_COLOR_BUFFER_BIT );

   check();
}


static void init_shaders(CUBE_STATE_T *state)
{
   static const GLfloat vertex_data[] = {
        -1.0,-1.0,1.0,1.0,
        1.0,-1.0,1.0,1.0,
        1.0,1.0,1.0,1.0,
        -1.0,1.0,1.0,1.0
   };
   const GLchar *vshader_source =
              "attribute vec4 vertex;"
              "varying vec2 tcoord;"
              "void main(void) {"
              " vec4 pos = vertex;"
              " gl_Position = pos;"
              " tcoord = vertex.xy*0.5+0.5;"
              "}";
      
   //Mandelbrot
   const GLchar *mandelbrot_fshader_source =
"uniform vec4 color;"
"uniform vec2 scale;"
"uniform vec2 centre;"
"varying vec2 tcoord;"
"void main(void) {"
"  float intensity;"
"  vec4 color2;"
"  float cr=(gl_FragCoord.x-centre.x)*scale.x;"
"  float ci=(gl_FragCoord.y-centre.y)*scale.y;"
"  float ar=cr;"
"  float ai=ci;"
"  float tr,ti;"
"  float col=0.0;"
"  float p=0.0;"
"  int i=0;"
"  for(int i2=1;i2<16;i2++)"
"  {"
"    tr=ar*ar-ai*ai+cr;"
"    ti=2.0*ar*ai+ci;"
"    p=tr*tr+ti*ti;"
"    ar=tr;"
"    ai=ti;"
"    if (p>16.0)"
"    {"
"      i=i2;"
"      break;"
"    }"
"  }"
"  color2 = vec4(float(i)*0.0625,0,0,1);"
"  gl_FragColor = color2;"
"}";

   // Julia
   const GLchar *julia_fshader_source =
"uniform vec4 color;"
"uniform vec2 scale;"
"uniform vec2 centre;"
"uniform vec2 offset;"
"varying vec2 tcoord;"
"uniform sampler2D tex;"
"void main(void) {"
"  float intensity;"
"  vec4 color2;"
"  float ar=(gl_FragCoord.x-centre.x)*scale.x;"
"  float ai=(gl_FragCoord.y-centre.y)*scale.y;"
"  float cr=(offset.x-centre.x)*scale.x;"
"  float ci=(offset.y-centre.y)*scale.y;"
"  float tr,ti;"
"  float col=0.0;"
"  float p=0.0;"
"  int i=0;"
"  vec2 t2;"
"  t2.x=tcoord.x+(offset.x-centre.x)*(0.5/centre.y);"
"  t2.y=tcoord.y+(offset.y-centre.y)*(0.5/centre.x);"
"  for(int i2=1;i2<16;i2++)"
"  {"
"    tr=ar*ar-ai*ai+cr;"
"    ti=2.0*ar*ai+ci;"
"    p=tr*tr+ti*ti;"
"    ar=tr;"
"    ai=ti;"
"    if (p>16.0)"
"    {"
"      i=i2;"
"      break;"
"    }"
"  }"
"  color2 = vec4(0,float(i)*0.0625,0,1);"
"  color2 = color2+texture2D(tex,t2);"
"  gl_FragColor = color2;"
"}";

        state->vshader = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(state->vshader, 1, &vshader_source, 0);
        glCompileShader(state->vshader);
        check();

        if (state->verbose)
            showlog(state->vshader);
            
        state->fshader = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(state->fshader, 1, &julia_fshader_source, 0);
        glCompileShader(state->fshader);
        check();

        if (state->verbose)
            showlog(state->fshader);

        state->mshader = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(state->mshader, 1, &mandelbrot_fshader_source, 0);
        glCompileShader(state->mshader);
        check();

        if (state->verbose)
            showlog(state->mshader);

        // julia 
        state->program = glCreateProgram();
        glAttachShader(state->program, state->vshader);
        glAttachShader(state->program, state->fshader);
        glLinkProgram(state->program);
        check();

        if (state->verbose)
            showprogramlog(state->program);
            
        state->attr_vertex = glGetAttribLocation(state->program, "vertex");
        state->unif_color  = glGetUniformLocation(state->program, "color");
        state->unif_scale  = glGetUniformLocation(state->program, "scale");
        state->unif_offset = glGetUniformLocation(state->program, "offset");
        state->unif_tex    = glGetUniformLocation(state->program, "tex");       
        state->unif_centre = glGetUniformLocation(state->program, "centre");

        // mandelbrot
        state->program2 = glCreateProgram();
        glAttachShader(state->program2, state->vshader);
        glAttachShader(state->program2, state->mshader);
        glLinkProgram(state->program2);
        check();

        if (state->verbose)
            showprogramlog(state->program2);
            
        state->attr_vertex2 = glGetAttribLocation(state->program2, "vertex");
        state->unif_scale2  = glGetUniformLocation(state->program2, "scale");
        state->unif_offset2 = glGetUniformLocation(state->program2, "offset");
        state->unif_centre2 = glGetUniformLocation(state->program2, "centre");
        check();
   
        glClearColor ( 0.0, 1.0, 1.0, 1.0 );
        
        glGenBuffers(1, &state->buf);

        check();

        // Prepare a texture image
        glGenTextures(1, &state->tex);
        check();
        glBindTexture(GL_TEXTURE_2D,state->tex);
        check();
        // glActiveTexture(0)
        glTexImage2D(GL_TEXTURE_2D,0,GL_RGB,state->screen_width,state->screen_height,0,GL_RGB,GL_UNSIGNED_SHORT_5_6_5,0);
        check();
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        check();
        // Prepare a framebuffer for rendering
        glGenFramebuffers(1,&state->tex_fb);
        check();
        glBindFramebuffer(GL_FRAMEBUFFER,state->tex_fb);
        check();
        glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D,state->tex,0);
        check();
        glBindFramebuffer(GL_FRAMEBUFFER,0);
        check();
        // Prepare viewport
        glViewport ( 0, 0, state->screen_width, state->screen_height );
        check();
        
        // Upload vertex data to a buffer
        glBindBuffer(GL_ARRAY_BUFFER, state->buf);
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertex_data),
                             vertex_data, GL_STATIC_DRAW);
        glVertexAttribPointer(state->attr_vertex, 4, GL_FLOAT, 0, 16, 0);
        glEnableVertexAttribArray(state->attr_vertex);
        check();
}


static void draw_mandelbrot_to_texture(CUBE_STATE_T *state, GLfloat cx, GLfloat cy, GLfloat scale)
{
        // Draw the mandelbrot to a texture
        glBindFramebuffer(GL_FRAMEBUFFER,state->tex_fb);
        check();
        glBindBuffer(GL_ARRAY_BUFFER, state->buf);
        
        glUseProgram ( state->program2 );
        check();

        glUniform2f(state->unif_scale2, scale, scale);
        glUniform2f(state->unif_centre2, cx, cy);
        check();
        glDrawArrays ( GL_TRIANGLE_FAN, 0, 4 );
        check();
               
        glFlush();
        glFinish();
        check();
}
        
static void draw_triangles(CUBE_STATE_T *state, GLfloat cx, GLfloat cy, GLfloat scale, GLfloat x, GLfloat y)
{
        // Now render to the main frame buffer
        glBindFramebuffer(GL_FRAMEBUFFER,0);
        // Clear the background (not really necessary I suppose)
        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
        check();
        
        glBindBuffer(GL_ARRAY_BUFFER, state->buf);
        check();
        glUseProgram ( state->program );
        check();
        glBindTexture(GL_TEXTURE_2D,state->tex);
        check();
        glUniform4f(state->unif_color, 0.5, 0.5, 0.8, 1.0);
        glUniform2f(state->unif_scale, scale, scale);
        glUniform2f(state->unif_offset, x, y);
        glUniform2f(state->unif_centre, cx, cy);
        glUniform1i(state->unif_tex, 0); // I don't really understand this part, perhaps it relates to active texture?
        check();
        
        glDrawArrays ( GL_TRIANGLE_FAN, 0, 4 );
        check();

        glBindBuffer(GL_ARRAY_BUFFER, 0);

        glFlush();
        glFinish();
        check();
        
        eglSwapBuffers(state->display, state->surface);
        check();
}

static int get_mouse(CUBE_STATE_T *state, int *outx, int *outy)
{
    static int fd = -1;
    const int width=state->screen_width, height=state->screen_height;
    static int x=800, y=400;
    const int XSIGN = 1<<4, YSIGN = 1<<5;
    if (fd<0) {
       fd = open("/dev/input/mouse0",O_RDONLY|O_NONBLOCK);
    }
    if (fd>=0) {
        struct {char buttons, dx, dy; } m;
        while (1) {
           int bytes = read(fd, &m, sizeof m);
           if (bytes < (int)sizeof m) goto _exit;
           if (m.buttons&8) {
              break; // This bit should always be set
           }
           read(fd, &m, 1); // Try to sync up again
        }
        if (m.buttons&3)
           return m.buttons&3;
        x+=m.dx;
        y+=m.dy;
        if (m.buttons&XSIGN)
           x-=256;
        if (m.buttons&YSIGN)
           y-=256;
        if (x<0) x=0;
        if (y<0) y=0;
        if (x>width) x=width;
        if (y>height) y=height;
   }
_exit:
   if (outx) *outx = x;
   if (outy) *outy = y;
   return 0;
}       
 
//==============================================================================

int main ()
{
   int terminate = 0;
   GLfloat cx, cy;
   bcm_host_init();

   // Clear application state
   memset( state, 0, sizeof( *state ) );
      
   // Start OGLES
   init_ogl(state);
   init_shaders(state);
   cx = state->screen_width/2;
   cy = state->screen_height/2;

   draw_mandelbrot_to_texture(state, cx, cy, 0.003);
   while (!terminate)
   {
      int x, y, b;
      b = get_mouse(state, &x, &y);
      if (b) break;
      draw_triangles(state, cx, cy, 0.003, x, y);
   }
   return 0;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        The video clip test.h264 is (c) copyright 2008, Blender Foundation / www.bigbuckbunny.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      OBJS=triangle.o video.o
BIN=hello_videocube.bin
LDFLAGS+=-lilclient

include ../Makefile.include


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Video deocode demo using OpenMAX IL though the ilcient helper library

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "bcm_host.h"
#include "ilclient.h"

static int video_decode_test(char *filename)
{
   OMX_VIDEO_PARAM_PORTFORMATTYPE format;
   OMX_TIME_CONFIG_CLOCKSTATETYPE cstate;
   COMPONENT_T *video_decode = NULL, *video_scheduler = NULL, *video_render = NULL, *clock = NULL;
   COMPONENT_T *list[5];
   TUNNEL_T tunnel[4];
   ILCLIENT_T *client;
   FILE *in;
   int status = 0;
   unsigned int data_len = 0;

   memset(list, 0, sizeof(list));
   memset(tunnel, 0, sizeof(tunnel));

   if((in = fopen(filename, "rb")) == NULL)
      return -2;

   if((client = ilclient_init()) == NULL)
   {
      fclose(in);
      return -3;
   }

   if(OMX_Init() != OMX_ErrorNone)
   {
      ilclient_destroy(client);
      fclose(in);
      return -4;
   }

   // create video_decode
   if(ilclient_create_component(client, &video_decode, "video_decode", ILCLIENT_DISABLE_ALL_PORTS | ILCLIENT_ENABLE_INPUT_BUFFERS) != 0)
      status = -14;
   list[0] = video_decode;

   // create video_render
   if(status == 0 && ilclient_create_component(client, &video_render, "video_render", ILCLIENT_DISABLE_ALL_PORTS) != 0)
      status = -14;
   list[1] = video_render;

   // create clock
   if(status == 0 && ilclient_create_component(client, &clock, "clock", ILCLIENT_DISABLE_ALL_PORTS) != 0)
      status = -14;
   list[2] = clock;

   memset(&cstate, 0, sizeof(cstate));
   cstate.nSize = sizeof(cstate);
   cstate.nVersion.nVersion = OMX_VERSION;
   cstate.eState = OMX_TIME_ClockStateWaitingForStartTime;
   cstate.nWaitMask = 1;
   if(clock != NULL && OMX_SetParameter(ILC_GET_HANDLE(clock), OMX_IndexConfigTimeClockState, &cstate) != OMX_ErrorNone)
      status = -13;

   // create video_scheduler
   if(status == 0 && ilclient_create_component(client, &video_scheduler, "video_scheduler", ILCLIENT_DISABLE_ALL_PORTS) != 0)
      status = -14;
   list[3] = video_scheduler;

   set_tunnel(tunnel, video_decode, 131, video_scheduler, 10);
   set_tunnel(tunnel+1, video_scheduler, 11, video_render, 90);
   set_tunnel(tunnel+2, clock, 80, video_scheduler, 12);

   // setup clock tunnel first
   if(status == 0 && ilclient_setup_tunnel(tunnel+2, 0, 0) != 0)
      status = -15;
   else
      ilclient_change_component_state(clock, OMX_StateExecuting);

   if(status == 0)
      ilclient_change_component_state(video_decode, OMX_StateIdle);

   memset(&format, 0, sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE));
   format.nSize = sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE);
   format.nVersion.nVersion = OMX_VERSION;
   format.nPortIndex = 130;
   format.eCompressionFormat = OMX_VIDEO_CodingAVC;

   if(status == 0 &&
      OMX_SetParameter(ILC_GET_HANDLE(video_decode), OMX_IndexParamVideoPortFormat, &format) == OMX_ErrorNone &&
      ilclient_enable_port_buffers(video_decode, 130, NULL, NULL, NULL) == 0)
   {
      OMX_BUFFERHEADERTYPE *buf;
      int port_settings_changed = 0;
      int first_packet = 1;

      ilclient_change_component_state(video_decode, OMX_StateExecuting);

      while((buf = ilclient_get_input_buffer(video_decode, 130, 1)) != NULL)
      {
         // feed data and wait until we get port settings changed
         unsigned char *dest = buf->pBuffer;

         data_len += fread(dest, 1, buf->nAllocLen-data_len, in);

         if(port_settings_changed == 0 &&
            ((data_len > 0 && ilclient_remove_event(video_decode, OMX_EventPortSettingsChanged, 131, 0, 0, 1) == 0) ||
             (data_len == 0 && ilclient_wait_for_event(video_decode, OMX_EventPortSettingsChanged, 131, 0, 0, 1,
                                                       ILCLIENT_EVENT_ERROR | ILCLIENT_PARAMETER_CHANGED, 10000) == 0)))
         {
            port_settings_changed = 1;

            if(ilclient_setup_tunnel(tunnel, 0, 0) != 0)
            {
               status = -7;
               break;
            }

            ilclient_change_component_state(video_scheduler, OMX_StateExecuting);

            // now setup tunnel to video_render
            if(ilclient_setup_tunnel(tunnel+1, 0, 1000) != 0)
            {
               status = -12;
               break;
            }

            ilclient_change_component_state(video_render, OMX_StateExecuting);
         }
         if(!data_len)
            break;

         buf->nFilledLen = data_len;
         data_len = 0;

         buf->nOffset = 0;
         if(first_packet)
         {
            buf->nFlags = OMX_BUFFERFLAG_STARTTIME;
            first_packet = 0;
         }
         else
            buf->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN;

         if(OMX_EmptyThisBuffer(ILC_GET_HANDLE(video_decode), buf) != OMX_ErrorNone)
         {
            status = -6;
            break;
         }
      }

      buf->nFilledLen = 0;
      buf->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN | OMX_BUFFERFLAG_EOS;

      if(OMX_EmptyThisBuffer(ILC_GET_HANDLE(video_decode), buf) != OMX_ErrorNone)
         status = -20;

      // wait for EOS from render
      ilclient_wait_for_event(video_render, OMX_EventBufferFlag, 90, 0, OMX_BUFFERFLAG_EOS, 0,
                              ILCLIENT_BUFFER_FLAG_EOS, -1);

      // need to flush the renderer to allow video_decode to disable its input port
      ilclient_flush_tunnels(tunnel, 0);

   }

   fclose(in);

   ilclient_disable_tunnel(tunnel);
   ilclient_disable_tunnel(tunnel+1);
   ilclient_disable_tunnel(tunnel+2);
   ilclient_disable_port_buffers(video_decode, 130, NULL, NULL, NULL);
   ilclient_teardown_tunnels(tunnel);

   ilclient_state_transition(list, OMX_StateIdle);
   ilclient_state_transition(list, OMX_StateLoaded);

   ilclient_cleanup_components(list);

   OMX_Deinit();

   ilclient_destroy(client);
   return status;
}

int main (int argc, char **argv)
{
   if (argc < 2) {
      printf("Usage: %s <filename>\n", argv[0]);
      exit(1);
   }
   bcm_host_init();
   return video_decode_test(argv[1]);
}


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
Copyright (c) 2012, Broadcom Europe Ltd
Copyright (c) 2012, OtherCrashOverride
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// A rotating cube rendered with OpenGL|ES. Three images used as textures on the cube faces.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>
#include <unistd.h>

#include "bcm_host.h"

#include "GLES/gl.h"
#include "EGL/egl.h"
#include "EGL/eglext.h"

#include "cube_texture_and_coords.h"

#include "triangle.h"
#include <pthread.h>


#define PATH "./"

#define IMAGE_SIZE_WIDTH 1920
#define IMAGE_SIZE_HEIGHT 1080

#ifndef M_PI
   #define M_PI 3.141592654
#endif
  

typedef struct
{
   uint32_t screen_width;
   uint32_t screen_height;
// OpenGL|ES objects
   EGLDisplay display;
   EGLSurface surface;
   EGLContext context;
   GLuint tex;
// model rotation vector and direction
   GLfloat rot_angle_x_inc;
   GLfloat rot_angle_y_inc;
   GLfloat rot_angle_z_inc;
// current model rotation angles
   GLfloat rot_angle_x;
   GLfloat rot_angle_y;
   GLfloat rot_angle_z;
// current distance from camera
   GLfloat distance;
   GLfloat distance_inc;
} CUBE_STATE_T;

static void init_ogl(CUBE_STATE_T *state);
static void init_model_proj(CUBE_STATE_T *state);
static void reset_model(CUBE_STATE_T *state);
static GLfloat inc_and_wrap_angle(GLfloat angle, GLfloat angle_inc);
static GLfloat inc_and_clip_distance(GLfloat distance, GLfloat distance_inc);
static void redraw_scene(CUBE_STATE_T *state);
static void update_model(CUBE_STATE_T *state);
static void init_textures(CUBE_STATE_T *state);
static void exit_func(void);
static volatile int terminate;
static CUBE_STATE_T _state, *state=&_state;

static void* eglImage = 0;
static pthread_t thread1;


/***********************************************************
 * Name: init_ogl
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description: Sets the display, OpenGL|ES context and screen stuff
 *
 * Returns: void
 *
 ***********************************************************/
static void init_ogl(CUBE_STATE_T *state)
{
   int32_t success = 0;
   EGLBoolean result;
   EGLint num_config;

   static EGL_DISPMANX_WINDOW_T nativewindow;

   DISPMANX_ELEMENT_HANDLE_T dispman_element;
   DISPMANX_DISPLAY_HANDLE_T dispman_display;
   DISPMANX_UPDATE_HANDLE_T dispman_update;
   VC_RECT_T dst_rect;
   VC_RECT_T src_rect;

   static const EGLint attribute_list[] =
   {
      EGL_RED_SIZE, 8,
      EGL_GREEN_SIZE, 8,
      EGL_BLUE_SIZE, 8,
      EGL_ALPHA_SIZE, 8,
      EGL_DEPTH_SIZE, 16,
      //EGL_SAMPLES, 4,
      EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
      EGL_NONE
   };
   
   EGLConfig config;

   // get an EGL display connection
   state->display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
   assert(state->display!=EGL_NO_DISPLAY);

   // initialize the EGL display connection
   result = eglInitialize(state->display, NULL, NULL);
   assert(EGL_FALSE != result);

   // get an appropriate EGL frame buffer configuration
   // this uses a BRCM extension that gets the closest match, rather than standard which returns anything that matches
   result = eglSaneChooseConfigBRCM(state->display, attribute_list, &config, 1, &num_config);
   assert(EGL_FALSE != result);

   // create an EGL rendering context
   state->context = eglCreateContext(state->display, config, EGL_NO_CONTEXT, NULL);
   assert(state->context!=EGL_NO_CONTEXT);

   // create an EGL window surface
   success = graphics_get_display_size(0 /* LCD */, &state->screen_width, &state->screen_height);
   assert( success >= 0 );

   dst_rect.x = 0;
   dst_rect.y = 0;
   dst_rect.width = state->screen_width;
   dst_rect.height = state->screen_height;
      
   src_rect.x = 0;
   src_rect.y = 0;
   src_rect.width = state->screen_width << 16;
   src_rect.height = state->screen_height << 16;        

   dispman_display = vc_dispmanx_display_open( 0 /* LCD */);
   dispman_update = vc_dispmanx_update_start( 0 );
         
   dispman_element = vc_dispmanx_element_add ( dispman_update, dispman_display,
      0/*layer*/, &dst_rect, 0/*src*/,
      &src_rect, DISPMANX_PROTECTION_NONE, 0 /*alpha*/, 0/*clamp*/, 0/*transform*/);
      
   nativewindow.element = dispman_element;
   nativewindow.width = state->screen_width;
   nativewindow.height = state->screen_height;
   vc_dispmanx_update_submit_sync( dispman_update );
      
   state->surface = eglCreateWindowSurface( state->display, config, &nativewindow, NULL );
   assert(state->surface != EGL_NO_SURFACE);

   // connect the context to the surface
   result = eglMakeCurrent(state->display, state->surface, state->surface, state->context);
   assert(EGL_FALSE != result);

   // Set background color and clear buffers
   glClearColor(0.15f, 0.25f, 0.35f, 1.0f);

   // Enable back face culling.
   glEnable(GL_CULL_FACE);

   glMatrixMode(GL_MODELVIEW);
}

/***********************************************************
 * Name: init_model_proj
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description: Sets the OpenGL|ES model to default values
 *
 * Returns: void
 *
 ***********************************************************/
static void init_model_proj(CUBE_STATE_T *state)
{
   float nearp = 1.0f;
   float farp = 500.0f;
   float hht;
   float hwd;

   glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );

   glViewport(0, 0, (GLsizei)state->screen_width, (GLsizei)state->screen_height);
      
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();

   hht = nearp * (float)tan(45.0 / 2.0 / 180.0 * M_PI);
   hwd = hht * (float)state->screen_width / (float)state->screen_height;

   glFrustumf(-hwd, hwd, -hht, hht, nearp, farp);
   
   glEnableClientState( GL_VERTEX_ARRAY );
   glVertexPointer( 3, GL_BYTE, 0, quadx );

   reset_model(state);
}

/***********************************************************
 * Name: reset_model
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description: Resets the Model projection and rotation direction
 *
 * Returns: void
 *
 ***********************************************************/
static void reset_model(CUBE_STATE_T *state)
{
   // reset model position
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   glTranslatef(0.f, 0.f, -50.f);

   // reset model rotation
   state->rot_angle_x = 45.f; state->rot_angle_y = 30.f; state->rot_angle_z = 0.f;
   state->rot_angle_x_inc = 0.5f; state->rot_angle_y_inc = 0.5f; state->rot_angle_z_inc = 0.f;
   state->distance = 40.f;
}

/***********************************************************
 * Name: update_model
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description: Updates model projection to current position/rotation
 *
 * Returns: void
 *
 ***********************************************************/
static void update_model(CUBE_STATE_T *state)
{
   // update position
   state->rot_angle_x = inc_and_wrap_angle(state->rot_angle_x, state->rot_angle_x_inc);
   state->rot_angle_y = inc_and_wrap_angle(state->rot_angle_y, state->rot_angle_y_inc);
   state->rot_angle_z = inc_and_wrap_angle(state->rot_angle_z, state->rot_angle_z_inc);
   state->distance    = inc_and_clip_distance(state->distance, state->distance_inc);

   glLoadIdentity();
   // move camera back to see the cube
   glTranslatef(0.f, 0.f, -state->distance);

   // Rotate model to new position
   glRotatef(state->rot_angle_x, 1.f, 0.f, 0.f);
   glRotatef(state->rot_angle_y, 0.f, 1.f, 0.f);
   glRotatef(state->rot_angle_z, 0.f, 0.f, 1.f);
}

/***********************************************************
 * Name: inc_and_wrap_angle
 *
 * Arguments:
 *       GLfloat angle     current angle
 *       GLfloat angle_inc angle increment
 *
 * Description:   Increments or decrements angle by angle_inc degrees
 *                Wraps to 0 at 360 deg.
 *
 * Returns: new value of angle
 *
 ***********************************************************/
static GLfloat inc_and_wrap_angle(GLfloat angle, GLfloat angle_inc)
{
   angle += angle_inc;

   if (angle >= 360.0)
      angle -= 360.f;
   else if (angle <=0)
      angle += 360.f;

   return angle;
}

/***********************************************************
 * Name: inc_and_clip_distance
 *
 * Arguments:
 *       GLfloat distance     current distance
 *       GLfloat distance_inc distance increment
 *
 * Description:   Increments or decrements distance by distance_inc units
 *                Clips to range
 *
 * Returns: new value of angle
 *
 ***********************************************************/
static GLfloat inc_and_clip_distance(GLfloat distance, GLfloat distance_inc)
{
   distance += distance_inc;

   if (distance >= 120.0f)
      distance = 120.f;
   else if (distance <= 40.0f)
      distance = 40.0f;

   return distance;
}

/***********************************************************
 * Name: redraw_scene
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description:   Draws the model and calls eglSwapBuffers
 *                to render to screen
 *
 * Returns: void
 *
 ***********************************************************/
static void redraw_scene(CUBE_STATE_T *state)
{
   // Start with a clear screen
   glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

   // Need to rotate textures - do this by rotating each cube face
   glRotatef(270.f, 0.f, 0.f, 1.f ); // front face normal along z axis

   // draw first 4 vertices
   glDrawArrays( GL_TRIANGLE_STRIP, 0, 4);

   // same pattern for other 5 faces - rotation chosen to make image orientation 'nice'
   glRotatef(90.f, 0.f, 0.f, 1.f ); // back face normal along z axis
   glDrawArrays( GL_TRIANGLE_STRIP, 4, 4);

   glRotatef(90.f, 1.f, 0.f, 0.f ); // left face normal along x axis
   glDrawArrays( GL_TRIANGLE_STRIP, 8, 4);

   glRotatef(90.f, 1.f, 0.f, 0.f ); // right face normal along x axis
   glDrawArrays( GL_TRIANGLE_STRIP, 12, 4);

   glRotatef(270.f, 0.f, 1.f, 0.f ); // top face normal along y axis
   glDrawArrays( GL_TRIANGLE_STRIP, 16, 4);

   glRotatef(90.f, 0.f, 1.f, 0.f ); // bottom face normal along y axis
   glDrawArrays( GL_TRIANGLE_STRIP, 20, 4);

   eglSwapBuffers(state->display, state->surface);
}

/***********************************************************
 * Name: init_textures
 *
 * Arguments:
 *       CUBE_STATE_T *state - holds OGLES model info
 *
 * Description:   Initialise OGL|ES texture surfaces to use image
 *                buffers
 *
 * Returns: void
 *
 ***********************************************************/
static void init_textures(CUBE_STATE_T *state)
{
   //// load three texture buffers but use them on six OGL|ES texture surfaces
   glGenTextures(1, &state->tex);

   glBindTexture(GL_TEXTURE_2D, state->tex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, IMAGE_SIZE_WIDTH, IMAGE_SIZE_HEIGHT, 0,
                GL_RGBA, GL_UNSIGNED_BYTE, NULL);

   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);


   /* Create EGL Image */
   eglImage = eglCreateImageKHR(
                state->display,
                state->context,
                EGL_GL_TEXTURE_2D_KHR,
                (EGLClientBuffer)state->tex,
                0);
    
   if (eglImage == EGL_NO_IMAGE_KHR)
   {
      printf("eglCreateImageKHR failed.\n");
      exit(1);
   }

   // Start rendering
   pthread_create(&thread1, NULL, video_decode_test, eglImage);

   // setup overall texture environment
   glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
   glEnableClientState(GL_TEXTURE_COORD_ARRAY);

   glEnable(GL_TEXTURE_2D);

   // Bind texture surface to current vertices
   glBindTexture(GL_TEXTURE_2D, state->tex);
}
//------------------------------------------------------------------------------

static void exit_func(void)
// Function to be passed to atexit().
{
   if (eglImage != 0)
   {
      if (!eglDestroyImageKHR(state->display, (EGLImageKHR) eglImage))
         printf("eglDestroyImageKHR failed.");
   }

   // clear screen
   glClear( GL_COLOR_BUFFER_BIT );
   eglSwapBuffers(state->display, state->surface);

   // Release OpenGL resources
   eglMakeCurrent( state->display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT );
   eglDestroySurface( state->display, state->surface );
   eglDestroyContext( state->display, state->context );
   eglTerminate( state->display );

   printf("\ncube closed\n");
} // exit_func()

//==============================================================================

int main ()
{
   bcm_host_init();
   printf("Note: ensure you have sufficient gpu_mem configured\n");

   // Clear application state
   memset( state, 0, sizeof( *state ) );
      
   // Start OGLES
   init_ogl(state);

   // Setup the model world
   init_model_proj(state);

   // initialise the OGLES texture(s)
   init_textures(state);

   while (!terminate)
   {
      update_model(state);
      redraw_scene(state);
   }
   exit_func();
   return 0;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
Copyright (c) 2012, Broadcom Europe Ltd
Copyright (c) 2012, OtherCrashOverride
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Video decode demo using OpenMAX IL though the ilcient helper library

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "bcm_host.h"
#include "ilclient.h"

static OMX_BUFFERHEADERTYPE* eglBuffer = NULL;
static COMPONENT_T* egl_render = NULL;

static void* eglImage = 0;

void my_fill_buffer_done(void* data, COMPONENT_T* comp)
{
  if (OMX_FillThisBuffer(ilclient_get_handle(egl_render), eglBuffer) != OMX_ErrorNone)
   {
      printf("OMX_FillThisBuffer failed in callback\n");
      exit(1);
   }
}


// Modified function prototype to work with pthreads
void *video_decode_test(void* arg)
{
   const char* filename = "/opt/vc/src/hello_pi/hello_video/test.h264";
   eglImage = arg;

   if (eglImage == 0)
   {
      printf("eglImage is null.\n");
      exit(1);
   }

   OMX_VIDEO_PARAM_PORTFORMATTYPE format;
   OMX_TIME_CONFIG_CLOCKSTATETYPE cstate;
   COMPONENT_T *video_decode = NULL, *video_scheduler = NULL, *clock = NULL;
   COMPONENT_T *list[5];
   TUNNEL_T tunnel[4];
   ILCLIENT_T *client;
   FILE *in;
   int status = 0;
   unsigned int data_len = 0;

   memset(list, 0, sizeof(list));
   memset(tunnel, 0, sizeof(tunnel));

   if((in = fopen(filename, "rb")) == NULL)
      return (void *)-2;

   if((client = ilclient_init()) == NULL)
   {
      fclose(in);
      return (void *)-3;
   }

   if(OMX_Init() != OMX_ErrorNone)
   {
      ilclient_destroy(client);
      fclose(in);
      return (void *)-4;
   }

   // callback
   ilclient_set_fill_buffer_done_callback(client, my_fill_buffer_done, 0);

   // create video_decode
   if(ilclient_create_component(client, &video_decode, "video_decode", ILCLIENT_DISABLE_ALL_PORTS | ILCLIENT_ENABLE_INPUT_BUFFERS) != 0)
      status = -14;
   list[0] = video_decode;

   // create egl_render
   if(status == 0 && ilclient_create_component(client, &egl_render, "egl_render", ILCLIENT_DISABLE_ALL_PORTS | ILCLIENT_ENABLE_OUTPUT_BUFFERS) != 0)
      status = -14;
   list[1] = egl_render;

   // create clock
   if(status == 0 && ilclient_create_component(client, &clock, "clock", ILCLIENT_DISABLE_ALL_PORTS) != 0)
      status = -14;
   list[2] = clock;

   memset(&cstate, 0, sizeof(cstate));
   cstate.nSize = sizeof(cstate);
   cstate.nVersion.nVersion = OMX_VERSION;
   cstate.eState = OMX_TIME_ClockStateWaitingForStartTime;
   cstate.nWaitMask = 1;
   if(clock != NULL && OMX_SetParameter(ILC_GET_HANDLE(clock), OMX_IndexConfigTimeClockState, &cstate) != OMX_ErrorNone)
      status = -13;

   // create video_scheduler
   if(status == 0 && ilclient_create_component(client, &video_scheduler, "video_scheduler", ILCLIENT_DISABLE_ALL_PORTS) != 0)
      status = -14;
   list[3] = video_scheduler;

   set_tunnel(tunnel, video_decode, 131, video_scheduler, 10);
   set_tunnel(tunnel+1, video_scheduler, 11, egl_render, 220);
   set_tunnel(tunnel+2, clock, 80, video_scheduler, 12);

   // setup clock tunnel first
   if(status == 0 && ilclient_setup_tunnel(tunnel+2, 0, 0) != 0)
      status = -15;
   else
      ilclient_change_component_state(clock, OMX_StateExecuting);

   if(status == 0)
      ilclient_change_component_state(video_decode, OMX_StateIdle);

   memset(&format, 0, sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE));
   format.nSize = sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE);
   format.nVersion.nVersion = OMX_VERSION;
   format.nPortIndex = 130;
   format.eCompressionFormat = OMX_VIDEO_CodingAVC;

   if(status == 0 &&
      OMX_SetParameter(ILC_GET_HANDLE(video_decode), OMX_IndexParamVideoPortFormat, &format) == OMX_ErrorNone &&
      ilclient_enable_port_buffers(video_decode, 130, NULL, NULL, NULL) == 0)
   {
      OMX_BUFFERHEADERTYPE *buf;
      int port_settings_changed = 0;
      int first_packet = 1;

      ilclient_change_component_state(video_decode, OMX_StateExecuting);

      while((buf = ilclient_get_input_buffer(video_decode, 130, 1)) != NULL)
      {
         // feed data and wait until we get port settings changed
         unsigned char *dest = buf->pBuffer;

         // loop if at end
         if (feof(in))
            rewind(in);

         data_len += fread(dest, 1, buf->nAllocLen-data_len, in);

         if(port_settings_changed == 0 &&
            ((data_len > 0 && ilclient_remove_event(video_decode, OMX_EventPortSettingsChanged, 131, 0, 0, 1) == 0) ||
             (data_len == 0 && ilclient_wait_for_event(video_decode, OMX_EventPortSettingsChanged, 131, 0, 0, 1,
                                                       ILCLIENT_EVENT_ERROR | ILCLIENT_PARAMETER_CHANGED, 10000) == 0)))
         {
            port_settings_changed = 1;

            if(ilclient_setup_tunnel(tunnel, 0, 0) != 0)
            {
               status = -7;
               break;
            }

            ilclient_change_component_state(video_scheduler, OMX_StateExecuting);

            // now setup tunnel to egl_render
            if(ilclient_setup_tunnel(tunnel+1, 0, 1000) != 0)
            {
               status = -12;
               break;
            }

            // Set egl_render to idle
            ilclient_change_component_state(egl_render, OMX_StateIdle);

            // Enable the output port and tell egl_render to use the texture as a buffer
            //ilclient_enable_port(egl_render, 221); THIS BLOCKS SO CAN'T BE USED
            if (OMX_SendCommand(ILC_GET_HANDLE(egl_render), OMX_CommandPortEnable, 221, NULL) != OMX_ErrorNone)
            {
               printf("OMX_CommandPortEnable failed.\n");
               exit(1);
            }

            if (OMX_UseEGLImage(ILC_GET_HANDLE(egl_render), &eglBuffer, 221, NULL, eglImage) != OMX_ErrorNone)
            {
               printf("OMX_UseEGLImage failed.\n");
               exit(1);
            }

            // Set egl_render to executing
            ilclient_change_component_state(egl_render, OMX_StateExecuting);


            // Request egl_render to write data to the texture buffer
            if(OMX_FillThisBuffer(ILC_GET_HANDLE(egl_render), eglBuffer) != OMX_ErrorNone)
            {
               printf("OMX_FillThisBuffer failed.\n");
               exit(1);
            }
         }
         if(!data_len)
            break;

         buf->nFilledLen = data_len;
         data_len = 0;

         buf->nOffset = 0;
         if(first_packet)
         {
            buf->nFlags = OMX_BUFFERFLAG_STARTTIME;
            first_packet = 0;
         }
         else
            buf->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN;

         if(OMX_EmptyThisBuffer(ILC_GET_HANDLE(video_decode), buf) != OMX_ErrorNone)
         {
            status = -6;
            break;
         }
      }

      buf->nFilledLen = 0;
      buf->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN | OMX_BUFFERFLAG_EOS;

      if(OMX_EmptyThisBuffer(ILC_GET_HANDLE(video_decode), buf) != OMX_ErrorNone)
         status = -20;

      // need to flush the renderer to allow video_decode to disable its input port
      ilclient_flush_tunnels(tunnel, 0);

      ilclient_disable_port_buffers(video_decode, 130, NULL, NULL, NULL);
   }

   fclose(in);

   ilclient_disable_tunnel(tunnel);
   ilclient_disable_tunnel(tunnel+1);
   ilclient_disable_tunnel(tunnel+2);
   ilclient_teardown_tunnels(tunnel);

   ilclient_state_transition(list, OMX_StateIdle);
   ilclient_state_transition(list, OMX_StateLoaded);

   ilclient_cleanup_components(list);

   OMX_Deinit();

   ilclient_destroy(client);
   return (void *)status;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       OBJS=world.o
BIN=hello_world.bin

include ../Makefile.include

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * \file
 *
 * \brief This API defines helper functions for writing IL clients.
 *
 * This file defines an IL client side library.  This is useful when
 * writing IL clients, since there tends to be much repeated and
 * common code across both single and multiple clients.  This library
 * seeks to remove that common code and abstract some of the
 * interactions with components.  There is a wrapper around a
 * component and tunnel, and some operations can be done on lists of
 * these.  The callbacks from components are handled, and specific
 * events can be checked or waited for.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "interface/vcos/vcos.h"
#include "interface/vcos/vcos_logging.h"
#include "interface/vmcs_host/vchost.h"

#include "IL/OMX_Broadcom.h"
#include "ilclient.h"

#define VCOS_LOG_CATEGORY (&ilclient_log_category)

#ifndef ILCLIENT_THREAD_DEFAULT_STACK_SIZE
#define ILCLIENT_THREAD_DEFAULT_STACK_SIZE   (6<<10)
#endif

static VCOS_LOG_CAT_T ilclient_log_category;

/******************************************************************************
Static data and types used only in this file.
******************************************************************************/

struct _ILEVENT_T {
   OMX_EVENTTYPE eEvent;
   OMX_U32 nData1;
   OMX_U32 nData2;
   OMX_PTR pEventData;
   struct _ILEVENT_T *next;
};

#define NUM_EVENTS 100
struct _ILCLIENT_T {
   ILEVENT_T *event_list;
   VCOS_SEMAPHORE_T event_sema;
   ILEVENT_T event_rep[NUM_EVENTS];

   ILCLIENT_CALLBACK_T port_settings_callback;
   void *port_settings_callback_data;
   ILCLIENT_CALLBACK_T eos_callback;
   void *eos_callback_data;
   ILCLIENT_CALLBACK_T error_callback;
   void *error_callback_data;
   ILCLIENT_BUFFER_CALLBACK_T fill_buffer_done_callback;
   void *fill_buffer_done_callback_data;
   ILCLIENT_BUFFER_CALLBACK_T empty_buffer_done_callback;
   void *empty_buffer_done_callback_data;
   ILCLIENT_CALLBACK_T configchanged_callback;
   void *configchanged_callback_data;
};

struct _COMPONENT_T {
   OMX_HANDLETYPE comp;
   ILCLIENT_CREATE_FLAGS_T flags;
   VCOS_SEMAPHORE_T sema;
   VCOS_EVENT_FLAGS_T event;
   struct _COMPONENT_T *related;
   OMX_BUFFERHEADERTYPE *out_list;
   OMX_BUFFERHEADERTYPE *in_list;
   char name[32];
   char bufname[32];
   unsigned int error_mask;
   unsigned int private;
   ILEVENT_T *list;
   ILCLIENT_T *client;
};

#define random_wait()
static char *states[] = {"Invalid", "Loaded", "Idle", "Executing", "Pause", "WaitingForResources"};

typedef enum {
   ILCLIENT_ERROR_UNPOPULATED  = 0x1,
   ILCLIENT_ERROR_SAMESTATE    = 0x2,
   ILCLIENT_ERROR_BADPARAMETER = 0x4
} ILERROR_MASK_T;

/******************************************************************************
Static functions.
******************************************************************************/

static OMX_ERRORTYPE ilclient_empty_buffer_done(OMX_IN OMX_HANDLETYPE hComponent,
      OMX_IN OMX_PTR pAppData,
      OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
static OMX_ERRORTYPE ilclient_empty_buffer_done_error(OMX_IN OMX_HANDLETYPE hComponent,
      OMX_IN OMX_PTR pAppData,
      OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
static OMX_ERRORTYPE ilclient_fill_buffer_done(OMX_OUT OMX_HANDLETYPE hComponent,
      OMX_OUT OMX_PTR pAppData,
      OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
static OMX_ERRORTYPE ilclient_fill_buffer_done_error(OMX_OUT OMX_HANDLETYPE hComponent,
      OMX_OUT OMX_PTR pAppData,
      OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
static OMX_ERRORTYPE ilclient_event_handler(OMX_IN OMX_HANDLETYPE hComponent,
      OMX_IN OMX_PTR pAppData,
      OMX_IN OMX_EVENTTYPE eEvent,
      OMX_IN OMX_U32 nData1,
      OMX_IN OMX_U32 nData2,
      OMX_IN OMX_PTR pEventData);
static void ilclient_lock_events(ILCLIENT_T *st);
static void ilclient_unlock_events(ILCLIENT_T *st);

/******************************************************************************
Global functions
******************************************************************************/

/***********************************************************
 * Name: ilclient_init
 *
 * Description: Creates ilclient pointer
 *
 * Returns: pointer to client structure
 ***********************************************************/
ILCLIENT_T *ilclient_init()
{
   ILCLIENT_T *st = vcos_malloc(sizeof(ILCLIENT_T), "ilclient");
   int i;
   
   if (!st)
      return NULL;
   
   vcos_log_set_level(VCOS_LOG_CATEGORY, VCOS_LOG_WARN);
   vcos_log_register("ilclient", VCOS_LOG_CATEGORY);

   memset(st, 0, sizeof(ILCLIENT_T));

   i = vcos_semaphore_create(&st->event_sema, "il:event", 1);
   vc_assert(i == VCOS_SUCCESS);

   ilclient_lock_events(st);
   st->event_list = NULL;
   for (i=0; i<NUM_EVENTS; i++)
   {
      st->event_rep[i].eEvent = -1; // mark as unused
      st->event_rep[i].next = st->event_list;
      st->event_list = st->event_rep+i;
   }
   ilclient_unlock_events(st);
   return st;
}

/***********************************************************
 * Name: ilclient_destroy
 *
 * Description: frees client state
 *
 * Returns: void
 ***********************************************************/
void ilclient_destroy(ILCLIENT_T *st)
{
   vcos_semaphore_delete(&st->event_sema);
   vcos_free(st);
   vcos_log_unregister(VCOS_LOG_CATEGORY);
}

/***********************************************************
 * Name: ilclient_set_port_settings_callback
 *
 * Description: sets the callback used when receiving port settings
 * changed messages.  The data field in the callback function will be
 * the port index reporting the message.
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_port_settings_callback(ILCLIENT_T *st, ILCLIENT_CALLBACK_T func, void *userdata)
{
   st->port_settings_callback = func;
   st->port_settings_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_set_eos_callback
 *
 * Description: sets the callback used when receiving eos flags.  The
 * data parameter in the callback function will be the port index
 * reporting an eos flag.
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_eos_callback(ILCLIENT_T *st, ILCLIENT_CALLBACK_T func, void *userdata)
{
   st->eos_callback = func;
   st->eos_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_set_error_callback
 *
 * Description: sets the callback used when receiving error events.
 * The data parameter in the callback function will be the error code
 * being reported.
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_error_callback(ILCLIENT_T *st, ILCLIENT_CALLBACK_T func, void *userdata)
{
   st->error_callback = func;
   st->error_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_set_fill_buffer_done_callback
 *
 * Description: sets the callback used when receiving
 * fill_buffer_done event
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_fill_buffer_done_callback(ILCLIENT_T *st, ILCLIENT_BUFFER_CALLBACK_T func, void *userdata)
{
   st->fill_buffer_done_callback = func;
   st->fill_buffer_done_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_set_empty_buffer_done_callback
 *
 * Description: sets the callback used when receiving
 * empty_buffer_done event
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_empty_buffer_done_callback(ILCLIENT_T *st, ILCLIENT_BUFFER_CALLBACK_T func, void *userdata)
{
   st->empty_buffer_done_callback = func;
   st->empty_buffer_done_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_set_configchanged_callback
 *
 * Description: sets the callback used when a config changed
 * event is received
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_configchanged_callback(ILCLIENT_T *st, ILCLIENT_CALLBACK_T func, void *userdata)
{
   st->configchanged_callback = func;
   st->configchanged_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_create_component
 *
 * Description: initialises a component state structure and creates
 * the IL component.
 *
 * Returns: 0 on success, -1 on failure
 ***********************************************************/
int ilclient_create_component(ILCLIENT_T *client, COMPONENT_T **comp, char *name,
                              ILCLIENT_CREATE_FLAGS_T flags)
{
   OMX_CALLBACKTYPE callbacks;
   OMX_ERRORTYPE error;
   char component_name[128];
   int32_t status;

   *comp = vcos_malloc(sizeof(COMPONENT_T), "il:comp");
   if(!*comp)
      return -1;

   memset(*comp, 0, sizeof(COMPONENT_T));

#define COMP_PREFIX "OMX.broadcom."

   status = vcos_event_flags_create(&(*comp)->event,"il:comp");
   vc_assert(status == VCOS_SUCCESS);
   status = vcos_semaphore_create(&(*comp)->sema, "il:comp", 1);
   vc_assert(status == VCOS_SUCCESS);
   (*comp)->client = client;

   vcos_snprintf((*comp)->name, sizeof((*comp)->name), "cl:%s", name);
   vcos_snprintf((*comp)->bufname, sizeof((*comp)->bufname), "cl:%s buffer", name);
   vcos_snprintf(component_name, sizeof(component_name), "%s%s", COMP_PREFIX, name);

   (*comp)->flags = flags;

   callbacks.EventHandler = ilclient_event_handler;
   callbacks.EmptyBufferDone = flags & ILCLIENT_ENABLE_INPUT_BUFFERS ? ilclient_empty_buffer_done : ilclient_empty_buffer_done_error;
   callbacks.FillBufferDone = flags & ILCLIENT_ENABLE_OUTPUT_BUFFERS ? ilclient_fill_buffer_done : ilclient_fill_buffer_done_error;

   error = OMX_GetHandle(&(*comp)->comp, component_name, *comp, &callbacks);

   if (error == OMX_ErrorNone)
   {
      OMX_UUIDTYPE uid;
      char name[128];
      OMX_VERSIONTYPE compVersion, specVersion;

      if(OMX_GetComponentVersion((*comp)->comp, name, &compVersion, &specVersion, &uid) == OMX_ErrorNone)
      {
         char *p = (char *) uid + strlen(COMP_PREFIX);

         vcos_snprintf((*comp)->name, sizeof((*comp)->name), "cl:%s", p);
         (*comp)->name[sizeof((*comp)->name)-1] = 0;
         vcos_snprintf((*comp)->bufname, sizeof((*comp)->bufname), "cl:%s buffer", p);
         (*comp)->bufname[sizeof((*comp)->bufname)-1] = 0;
      }

      if(flags & (ILCLIENT_DISABLE_ALL_PORTS | ILCLIENT_OUTPUT_ZERO_BUFFERS))
      {
         OMX_PORT_PARAM_TYPE ports;
         OMX_INDEXTYPE types[] = {OMX_IndexParamAudioInit, OMX_IndexParamVideoInit, OMX_IndexParamImageInit, OMX_IndexParamOtherInit};
         int i;

         ports.nSize = sizeof(OMX_PORT_PARAM_TYPE);
         ports.nVersion.nVersion = OMX_VERSION;

         for(i=0; i<4; i++)
         {
            OMX_ERRORTYPE error = OMX_GetParameter((*comp)->comp, types[i], &ports);
            if(error == OMX_ErrorNone)
            {
               uint32_t j;
               for(j=0; j<ports.nPorts; j++)
               {
                  if(flags & ILCLIENT_DISABLE_ALL_PORTS)
                     ilclient_disable_port(*comp, ports.nStartPortNumber+j);
                  
                  if(flags & ILCLIENT_OUTPUT_ZERO_BUFFERS)
                  {
                     OMX_PARAM_PORTDEFINITIONTYPE portdef;
                     portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
                     portdef.nVersion.nVersion = OMX_VERSION;
                     portdef.nPortIndex = ports.nStartPortNumber+j;
                     if(OMX_GetParameter((*comp)->comp, OMX_IndexParamPortDefinition, &portdef) == OMX_ErrorNone)
                     {
                        if(portdef.eDir == OMX_DirOutput && portdef.nBufferCountActual > 0)
                        {
                           portdef.nBufferCountActual = 0;
                           OMX_SetParameter((*comp)->comp, OMX_IndexParamPortDefinition, &portdef);
                        }
                     }
                  }
               }
            }
         }
      }
      return 0;
   }
   else
   {
      vcos_event_flags_delete(&(*comp)->event);
      vcos_semaphore_delete(&(*comp)->sema);
      vcos_free(*comp);
      *comp = NULL;
      return -1;
   }
}

/***********************************************************
 * Name: ilclient_remove_event
 *
 * Description: Removes an event from a component event list.  ignore1
 * and ignore2 are flags indicating whether to not match on nData1 and
 * nData2 respectively.
 *
 * Returns: 0 if the event was removed.  -1 if no matching event was
 * found.
 ***********************************************************/
int ilclient_remove_event(COMPONENT_T *st, OMX_EVENTTYPE eEvent,
                          OMX_U32 nData1, int ignore1, OMX_IN OMX_U32 nData2, int ignore2)
{
   ILEVENT_T *cur, *prev;
   uint32_t set;
   ilclient_lock_events(st->client);

   cur = st->list;
   prev = NULL;

   while (cur && !(cur->eEvent == eEvent && (ignore1 || cur->nData1 == nData1) && (ignore2 || cur->nData2 == nData2)))
   {
      prev = cur;
      cur = cur->next;
   }

   if (cur == NULL)
   {
      ilclient_unlock_events(st->client);
      return -1;
   }

   if (prev == NULL)
      st->list = cur->next;
   else
      prev->next = cur->next;

   // add back into spare list
   cur->next = st->client->event_list;
   st->client->event_list = cur;
   cur->eEvent = -1; // mark as unused

   // if we're removing an OMX_EventError or OMX_EventParamOrConfigChanged event, then clear the error bit from the eventgroup,
   // since the user might have been notified through the error callback, and then 
   // can't clear the event bit - this will then cause problems the next time they
   // wait for an error.
   if(eEvent == OMX_EventError)
      vcos_event_flags_get(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR_CONSUME, 0, &set);
   else if(eEvent == OMX_EventParamOrConfigChanged)
      vcos_event_flags_get(&st->event, ILCLIENT_CONFIG_CHANGED, VCOS_OR_CONSUME, 0, &set);

   ilclient_unlock_events(st->client);
   return 0;
}

/***********************************************************
 * Name: ilclient_state_transition
 *
 * Description: Transitions a null terminated list of IL components to
 * a given state.  All components are told to transition in a random
 * order before any are checked for transition completion.
 *
 * Returns: void
 ***********************************************************/
void ilclient_state_transition(COMPONENT_T *list[], OMX_STATETYPE state)
{
   OMX_ERRORTYPE error;
   int i, num;
   uint32_t set;

   num=0;
   while (list[num])
      num++;

   // if we transition the supplier port first, it will call freebuffer on the non
   // supplier, which will correctly signal a port unpopulated error.  We want to
   // ignore these errors.
   if (state == OMX_StateLoaded)
      for (i=0; i<num; i++)
         list[i]->error_mask |= ILCLIENT_ERROR_UNPOPULATED;
   for (i=0; i<num; i++)
      list[i]->private = ((rand() >> 13) & 0xff)+1;

   for (i=0; i<num; i++)
   {
      // transition the components in a random order
      int j, min = -1;
      for (j=0; j<num; j++)
         if (list[j]->private && (min == -1 || list[min]->private > list[j]->private))
            min = j;

      list[min]->private = 0;

      random_wait();
      //Clear error event for this component
      vcos_event_flags_get(&list[min]->event, ILCLIENT_EVENT_ERROR, VCOS_OR_CONSUME, 0, &set);

      error = OMX_SendCommand(list[min]->comp, OMX_CommandStateSet, state, NULL);
      vc_assert(error == OMX_ErrorNone);
   }

   random_wait();

   for (i=0; i<num; i++)
      if(ilclient_wait_for_command_complete(list[i], OMX_CommandStateSet, state) < 0)
         vc_assert(0);

   if (state == OMX_StateLoaded)
      for (i=0; i<num; i++)
         list[i]->error_mask &= ~ILCLIENT_ERROR_UNPOPULATED;
}

/***********************************************************
 * Name: ilclient_teardown_tunnels
 *
 * Description: tears down a null terminated list of tunnels.
 *
 * Returns: void
 ***********************************************************/
void ilclient_teardown_tunnels(TUNNEL_T *tunnel)
{
   int i;
   OMX_ERRORTYPE error;

   i=0;;
   while (tunnel[i].source)
   {
      error = OMX_SetupTunnel(tunnel[i].source->comp, tunnel[i].source_port, NULL, 0);
      vc_assert(error == OMX_ErrorNone);

      error = OMX_SetupTunnel(tunnel[i].sink->comp, tunnel[i].sink_port, NULL, 0);
      vc_assert(error == OMX_ErrorNone);
      i++;
   }
}

/***********************************************************
 * Name: ilclient_disable_tunnel
 *
 * Description: disables a tunnel by disabling the ports.  Allows
 * ports to signal same state error if they were already disabled.
 *
 * Returns: void
 ***********************************************************/
void ilclient_disable_tunnel(TUNNEL_T *tunnel)
{
   OMX_ERRORTYPE error;
   
   if(tunnel->source == 0 || tunnel->sink == 0)
      return;

   tunnel->source->error_mask |= ILCLIENT_ERROR_UNPOPULATED;
   tunnel->sink->error_mask |= ILCLIENT_ERROR_UNPOPULATED;

   error = OMX_SendCommand(tunnel->source->comp, OMX_CommandPortDisable, tunnel->source_port, NULL);
   vc_assert(error == OMX_ErrorNone);

   error = OMX_SendCommand(tunnel->sink->comp, OMX_CommandPortDisable, tunnel->sink_port, NULL);
   vc_assert(error == OMX_ErrorNone);

   if(ilclient_wait_for_command_complete(tunnel->source, OMX_CommandPortDisable, tunnel->source_port) < 0)
      vc_assert(0);

   if(ilclient_wait_for_command_complete(tunnel->sink, OMX_CommandPortDisable, tunnel->sink_port) < 0)
      vc_assert(0);

   tunnel->source->error_mask &= ~ILCLIENT_ERROR_UNPOPULATED;
   tunnel->sink->error_mask &= ~ILCLIENT_ERROR_UNPOPULATED;
}

/***********************************************************
 * Name: ilclient_enable_tunnel
 *
 * Description: enables a tunnel by enabling the ports
 *
 * Returns: 0 on success, -1 on failure
 ***********************************************************/
int ilclient_enable_tunnel(TUNNEL_T *tunnel)
{
   OMX_STATETYPE state;
   OMX_ERRORTYPE error;

   ilclient_debug_output("ilclient: enable tunnel from %x/%d to %x/%d",
                         tunnel->source, tunnel->source_port,
                         tunnel->sink, tunnel->sink_port);

   error = OMX_SendCommand(tunnel->source->comp, OMX_CommandPortEnable, tunnel->source_port, NULL);
   vc_assert(error == OMX_ErrorNone);

   error = OMX_SendCommand(tunnel->sink->comp, OMX_CommandPortEnable, tunnel->sink_port, NULL);
   vc_assert(error == OMX_ErrorNone);

   // to complete, the sink component can't be in loaded state
   error = OMX_GetState(tunnel->sink->comp, &state);
   vc_assert(error == OMX_ErrorNone);
   if (state == OMX_StateLoaded)
   {
      int ret = 0;

      if(ilclient_wait_for_command_complete(tunnel->sink, OMX_CommandPortEnable, tunnel->sink_port) != 0 ||
         OMX_SendCommand(tunnel->sink->comp, OMX_CommandStateSet, OMX_StateIdle, NULL) != OMX_ErrorNone ||
         (ret = ilclient_wait_for_command_complete_dual(tunnel->sink, OMX_CommandStateSet, OMX_StateIdle, tunnel->source)) < 0)
      {
         if(ret == -2)
         {
            // the error was reported fom the source component: clear this error and disable the sink component
            ilclient_wait_for_command_complete(tunnel->source, OMX_CommandPortEnable, tunnel->source_port);
            ilclient_disable_port(tunnel->sink, tunnel->sink_port);
         }

         ilclient_debug_output("ilclient: could not change component state to IDLE");
         ilclient_disable_port(tunnel->source, tunnel->source_port);
         return -1;
      }
   }
   else
   {
      if (ilclient_wait_for_command_complete(tunnel->sink, OMX_CommandPortEnable, tunnel->sink_port) != 0)
      {
         ilclient_debug_output("ilclient: could not change sink port %d to enabled", tunnel->sink_port);

         //Oops failed to enable the sink port
         ilclient_disable_port(tunnel->source, tunnel->source_port);
         //Clean up the port enable event from the source port.
         ilclient_wait_for_event(tunnel->source, OMX_EventCmdComplete,
                                 OMX_CommandPortEnable, 0, tunnel->source_port, 0,
                                 ILCLIENT_PORT_ENABLED | ILCLIENT_EVENT_ERROR, VCOS_EVENT_FLAGS_SUSPEND);
         return -1;
      }
   }

   if(ilclient_wait_for_command_complete(tunnel->source, OMX_CommandPortEnable, tunnel->source_port) != 0)
   {
      ilclient_debug_output("ilclient: could not change source port %d to enabled", tunnel->source_port);

      //Failed to enable the source port
      ilclient_disable_port(tunnel->sink, tunnel->sink_port);
      return -1;
   }

   return 0;
}


/***********************************************************
 * Name: ilclient_flush_tunnels
 *
 * Description: flushes all ports used in a null terminated list of
 * tunnels.  max specifies the maximum number of tunnels to flush from
 * the list, where max=0 means all tunnels.
 *
 * Returns: void
 ***********************************************************/
void ilclient_flush_tunnels(TUNNEL_T *tunnel, int max)
{
   OMX_ERRORTYPE error;
   int i;

   i=0;
   while (tunnel[i].source && (max == 0 || i < max))
   {
      error = OMX_SendCommand(tunnel[i].source->comp, OMX_CommandFlush, tunnel[i].source_port, NULL);
      vc_assert(error == OMX_ErrorNone);

      error = OMX_SendCommand(tunnel[i].sink->comp, OMX_CommandFlush, tunnel[i].sink_port, NULL);
      vc_assert(error == OMX_ErrorNone);

      ilclient_wait_for_event(tunnel[i].source, OMX_EventCmdComplete,
                              OMX_CommandFlush, 0, tunnel[i].source_port, 0,
                              ILCLIENT_PORT_FLUSH, VCOS_EVENT_FLAGS_SUSPEND);
      ilclient_wait_for_event(tunnel[i].sink, OMX_EventCmdComplete,
                              OMX_CommandFlush, 0, tunnel[i].sink_port, 0,
                              ILCLIENT_PORT_FLUSH, VCOS_EVENT_FLAGS_SUSPEND);
      i++;
   }
}


/***********************************************************
 * Name: ilclient_return_events
 *
 * Description: Returns all events from a component event list to the
 * list of unused event structures.
 *
 * Returns: void
 ***********************************************************/
void ilclient_return_events(COMPONENT_T *comp)
{
   ilclient_lock_events(comp->client);
   while (comp->list)
   {
      ILEVENT_T *next = comp->list->next;
      comp->list->next = comp->client->event_list;
      comp->client->event_list = comp->list;
      comp->list = next;
   }
   ilclient_unlock_events(comp->client);
}

/***********************************************************
 * Name: ilclient_cleanup_components
 *
 * Description: frees all components from a null terminated list and
 * deletes resources used in component state structure.
 *
 * Returns: void
 ***********************************************************/
void ilclient_cleanup_components(COMPONENT_T *list[])
{
   int i;
   OMX_ERRORTYPE error;

   i=0;
   while (list[i])
   {
      ilclient_return_events(list[i]);
      if (list[i]->comp)
      {
         error = OMX_FreeHandle(list[i]->comp);

         vc_assert(error == OMX_ErrorNone);
      }
      i++;
   }

   i=0;
   while (list[i])
   {
      vcos_event_flags_delete(&list[i]->event);
      vcos_semaphore_delete(&list[i]->sema);
      vcos_free(list[i]);
      list[i] = NULL;
      i++;
   }
}

/***********************************************************
 * Name: ilclient_change_component_state
 *
 * Description: changes the state of a single component.  Note: this
 * may not be suitable if the component is tunnelled and requires
 * connected components to also change state.
 *
 * Returns: 0 on success, -1 on failure (note - trying to change to
 * the same state which causes a OMX_ErrorSameState is treated as
 * success)
 ***********************************************************/
int ilclient_change_component_state(COMPONENT_T *comp, OMX_STATETYPE state)
{
   OMX_ERRORTYPE error;
   error = OMX_SendCommand(comp->comp, OMX_CommandStateSet, state, NULL);
   vc_assert(error == OMX_ErrorNone);
   if(ilclient_wait_for_command_complete(comp, OMX_CommandStateSet, state) < 0)
   {
      ilclient_debug_output("ilclient: could not change component state to %d", state);
      ilclient_remove_event(comp, OMX_EventError, 0, 1, 0, 1);
      return -1;
   }
   return 0;
}

/***********************************************************
 * Name: ilclient_disable_port
 *
 * Description: disables a port on a given component.
 *
 * Returns: void
 ***********************************************************/
void ilclient_disable_port(COMPONENT_T *comp, int portIndex)
{
   OMX_ERRORTYPE error;
   error = OMX_SendCommand(comp->comp, OMX_CommandPortDisable, portIndex, NULL);
   vc_assert(error == OMX_ErrorNone);
   if(ilclient_wait_for_command_complete(comp, OMX_CommandPortDisable, portIndex) < 0)
      vc_assert(0);
}

/***********************************************************
 * Name: ilclient_enabled_port
 *
 * Description: enables a port on a given component.
 *
 * Returns: void
 ***********************************************************/
void ilclient_enable_port(COMPONENT_T *comp, int portIndex)
{
   OMX_ERRORTYPE error;
   error = OMX_SendCommand(comp->comp, OMX_CommandPortEnable, portIndex, NULL);
   vc_assert(error == OMX_ErrorNone);
   if(ilclient_wait_for_command_complete(comp, OMX_CommandPortEnable, portIndex) < 0)
      vc_assert(0);
}


/***********************************************************
 * Name: ilclient_enable_port_buffers
 *
 * Description: enables a port on a given component which requires
 * buffers to be supplied by the client.
 *
 * Returns: void
 ***********************************************************/
int ilclient_enable_port_buffers(COMPONENT_T *comp, int portIndex,
                                 ILCLIENT_MALLOC_T ilclient_malloc,
                                 ILCLIENT_FREE_T ilclient_free,
                                 void *private)
{
   OMX_ERRORTYPE error;
   OMX_PARAM_PORTDEFINITIONTYPE portdef;
   OMX_BUFFERHEADERTYPE *list = NULL, **end = &list;
   OMX_STATETYPE state;
   int i;

   memset(&portdef, 0, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
   portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
   portdef.nVersion.nVersion = OMX_VERSION;
   portdef.nPortIndex = portIndex;
   
   // work out buffer requirements, check port is in the right state
   error = OMX_GetParameter(comp->comp, OMX_IndexParamPortDefinition, &portdef);
   if(error != OMX_ErrorNone || portdef.bEnabled != OMX_FALSE || portdef.nBufferCountActual == 0 || portdef.nBufferSize == 0)
      return -1;

   // check component is in the right state to accept buffers
   error = OMX_GetState(comp->comp, &state);
   if (error != OMX_ErrorNone || !(state == OMX_StateIdle || state == OMX_StateExecuting || state == OMX_StatePause))
      return -1;

   // send the command
   error = OMX_SendCommand(comp->comp, OMX_CommandPortEnable, portIndex, NULL);
   vc_assert(error == OMX_ErrorNone);

   for (i=0; i != portdef.nBufferCountActual; i++)
   {
      unsigned char *buf;
      if(ilclient_malloc)
         buf = ilclient_malloc(private, portdef.nBufferSize, portdef.nBufferAlignment, comp->bufname);
      else
         buf = vcos_malloc_aligned(portdef.nBufferSize, portdef.nBufferAlignment, comp->bufname);

      if(!buf)
         break;

      error = OMX_UseBuffer(comp->comp, end, portIndex, NULL, portdef.nBufferSize, buf);
      if(error != OMX_ErrorNone)
      {
         if(ilclient_free)
            ilclient_free(private, buf);
         else
            vcos_free(buf);

         break;
      }
      end = (OMX_BUFFERHEADERTYPE **) &((*end)->pAppPrivate);
   }

   // queue these buffers
   vcos_semaphore_wait(&comp->sema);

   if(portdef.eDir == OMX_DirInput)
   {
      *end = comp->in_list;
      comp->in_list = list;
   }
   else
   {
      *end = comp->out_list;
      comp->out_list = list;
   }

   vcos_semaphore_post(&comp->sema);

   if(i != portdef.nBufferCountActual ||
      ilclient_wait_for_command_complete(comp, OMX_CommandPortEnable, portIndex) < 0)
   {
      ilclient_disable_port_buffers(comp, portIndex, NULL, ilclient_free, private);

      // at this point the first command might have terminated with an error, which means that
      // the port is disabled before the disable_port_buffers function is called, so we're left
      // with the error bit set and an error event in the queue.  Clear these now if they exist.
      ilclient_remove_event(comp, OMX_EventError, 0, 1, 1, 0);

      return -1;
   }

   // success
   return 0;
}


/***********************************************************
 * Name: ilclient_disable_port_buffers
 *
 * Description: disables a port on a given component which has
 * buffers supplied by the client.
 *
 * Returns: void
 ***********************************************************/
void ilclient_disable_port_buffers(COMPONENT_T *comp, int portIndex,
                                   OMX_BUFFERHEADERTYPE *bufferList,
                                   ILCLIENT_FREE_T ilclient_free,
                                   void *private)
{
   OMX_ERRORTYPE error;
   OMX_BUFFERHEADERTYPE *list = bufferList;
   OMX_BUFFERHEADERTYPE **head, *clist, *prev;
   OMX_PARAM_PORTDEFINITIONTYPE portdef;
   int num;

   // get the buffers off the relevant queue
   memset(&portdef, 0, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
   portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
   portdef.nVersion.nVersion = OMX_VERSION;
   portdef.nPortIndex = portIndex;
   
   // work out buffer requirements, check port is in the right state
   error = OMX_GetParameter(comp->comp, OMX_IndexParamPortDefinition, &portdef);
   if(error != OMX_ErrorNone || portdef.bEnabled != OMX_TRUE || portdef.nBufferCountActual == 0 || portdef.nBufferSize == 0)
      return;
   
   num = portdef.nBufferCountActual;
   
   error = OMX_SendCommand(comp->comp, OMX_CommandPortDisable, portIndex, NULL);
   vc_assert(error == OMX_ErrorNone);
      
   while(num > 0)
   {
      VCOS_UNSIGNED set;

      if(list == NULL)
      {
         vcos_semaphore_wait(&comp->sema);
         
         // take buffers for this port off the relevant queue
         head = portdef.eDir == OMX_DirInput ? &comp->in_list : &comp->out_list;
         clist = *head;
         prev = NULL;
         
         while(clist)
         {
            if((portdef.eDir == OMX_DirInput ? clist->nInputPortIndex : clist->nOutputPortIndex) == portIndex)
            {
               OMX_BUFFERHEADERTYPE *pBuffer = clist;
               
               if(!prev)
                  clist = *head = (OMX_BUFFERHEADERTYPE *) pBuffer->pAppPrivate;
               else
                  clist = prev->pAppPrivate = (OMX_BUFFERHEADERTYPE *) pBuffer->pAppPrivate;
               
               pBuffer->pAppPrivate = list;
               list = pBuffer;
            }
            else
            {
               prev = clist;
               clist = (OMX_BUFFERHEADERTYPE *) &(clist->pAppPrivate);
            }
         }
         
         vcos_semaphore_post(&comp->sema);
      }

      while(list)
      {
         void *buf = list->pBuffer;
         OMX_BUFFERHEADERTYPE *next = list->pAppPrivate;
         
         error = OMX_FreeBuffer(comp->comp, portIndex, list);
         vc_assert(error == OMX_ErrorNone);
         
         if(ilclient_free)
            ilclient_free(private, buf);
         else
            vcos_free(buf);
         
         num--;
         list = next;
      }

      if(num)
      {
         OMX_U32 mask = ILCLIENT_PORT_DISABLED | ILCLIENT_EVENT_ERROR;
         mask |= (portdef.eDir == OMX_DirInput ? ILCLIENT_EMPTY_BUFFER_DONE : ILCLIENT_FILL_BUFFER_DONE);

         // also wait for command complete/error in case we didn't have all the buffers allocated
         vcos_event_flags_get(&comp->event, mask, VCOS_OR_CONSUME, -1, &set);

         if((set & ILCLIENT_EVENT_ERROR) && ilclient_remove_event(comp, OMX_EventError, 0, 1, 1, 0) >= 0)
            return;

         if((set & ILCLIENT_PORT_DISABLED) && ilclient_remove_event(comp, OMX_EventCmdComplete, OMX_CommandPortDisable, 0, portIndex, 0) >= 0)
            return;
      }            
   }
  
   if(ilclient_wait_for_command_complete(comp, OMX_CommandPortDisable, portIndex) < 0)
      vc_assert(0);
}


/***********************************************************
 * Name: ilclient_setup_tunnel
 *
 * Description: creates a tunnel between components that require that
 * ports be inititially disabled, then enabled after tunnel setup.  If
 * timeout is non-zero, it will initially wait until a port settings
 * changes message has been received by the output port.  If port
 * streams are supported by the output port, the requested port stream
 * will be selected.
 *
 * Returns: 0 indicates success, negative indicates failure.
 * -1: a timeout waiting for the parameter changed
 * -2: an error was returned instead of parameter changed
 * -3: no streams are available from this port
 * -4: requested stream is not available from this port
 * -5: the data format was not acceptable to the sink
 ***********************************************************/
int ilclient_setup_tunnel(TUNNEL_T *tunnel, unsigned int portStream, int timeout)
{
   OMX_ERRORTYPE error;
   OMX_PARAM_U32TYPE param;
   OMX_STATETYPE state;
   int32_t status;
   int enable_error;

   // source component must at least be idle, not loaded
   error = OMX_GetState(tunnel->source->comp, &state);
   vc_assert(error == OMX_ErrorNone);
   if (state == OMX_StateLoaded && ilclient_change_component_state(tunnel->source, OMX_StateIdle) < 0)
      return -2;

   // wait for the port parameter changed from the source port
   if(timeout)
   {
      status = ilclient_wait_for_event(tunnel->source, OMX_EventPortSettingsChanged,
                                       tunnel->source_port, 0, -1, 1,
                                       ILCLIENT_PARAMETER_CHANGED | ILCLIENT_EVENT_ERROR, timeout);
      
      if (status < 0)
      {
         ilclient_debug_output(
            "ilclient: timed out waiting for port settings changed on port %d", tunnel->source_port);
         return status;
      }
   }

   // disable ports
   ilclient_disable_tunnel(tunnel);

   // if this source port uses port streams, we need to select one of them before proceeding
   // if getparameter causes an error that's fine, nothing needs selecting
   param.nSize = sizeof(OMX_PARAM_U32TYPE);
   param.nVersion.nVersion = OMX_VERSION;
   param.nPortIndex = tunnel->source_port;
   if (OMX_GetParameter(tunnel->source->comp, OMX_IndexParamNumAvailableStreams, &param) == OMX_ErrorNone)
   {
      if (param.nU32 == 0)
      {
         // no streams available
         // leave the source port disabled, and return a failure
         return -3;
      }
      if (param.nU32 <= portStream)
      {
         // requested stream not available
         // no streams available
         // leave the source port disabled, and return a failure
         return -4;
      }

      param.nU32 = portStream;
      error = OMX_SetParameter(tunnel->source->comp, OMX_IndexParamActiveStream, &param);
      vc_assert(error == OMX_ErrorNone);
   }

   // now create the tunnel
   error = OMX_SetupTunnel(tunnel->source->comp, tunnel->source_port, tunnel->sink->comp, tunnel->sink_port);

   enable_error = 0;

   if (error != OMX_ErrorNone || (enable_error=ilclient_enable_tunnel(tunnel)) < 0)
   {
      // probably format not compatible
      error = OMX_SetupTunnel(tunnel->source->comp, tunnel->source_port, NULL, 0);
      vc_assert(error == OMX_ErrorNone);
      error = OMX_SetupTunnel(tunnel->sink->comp, tunnel->sink_port, NULL, 0);
      vc_assert(error == OMX_ErrorNone);
      
      if(enable_error)
      {
         //Clean up the errors. This does risk removing an error that was nothing to do with this tunnel :-/
         ilclient_remove_event(tunnel->sink, OMX_EventError, 0, 1, 0, 1);
         ilclient_remove_event(tunnel->source, OMX_EventError, 0, 1, 0, 1);
      }

      ilclient_debug_output("ilclient: could not setup/enable tunnel (setup=0x%x,enable=%d)",
                             error, enable_error);
      return -5;
   }

   return 0;
}

/***********************************************************
 * Name: ilclient_wait_for_event
 *
 * Description: waits for a given event to appear on a component event
 * list.  If not immediately present, will wait on that components
 * event group for the given event flag.
 *
 * Returns: 0 indicates success, negative indicates failure.
 * -1: a timeout was received.
 * -2: an error event was received.
 * -3: a config change event was received.
 ***********************************************************/
int ilclient_wait_for_event(COMPONENT_T *comp, OMX_EVENTTYPE event,
                            OMX_U32 nData1, int ignore1, OMX_IN OMX_U32 nData2, int ignore2,
                            int event_flag, int suspend)
{
   int32_t status;
   uint32_t set;

   while (ilclient_remove_event(comp, event, nData1, ignore1, nData2, ignore2) < 0)
   {
      // if we want to be notified of errors, check the list for an error now
      // before blocking, the event flag may have been cleared already.
      if(event_flag & ILCLIENT_EVENT_ERROR)
      {
         ILEVENT_T *cur;
         ilclient_lock_events(comp->client);
         cur = comp->list;
         while(cur && cur->eEvent != OMX_EventError)            
            cur = cur->next;
         
         if(cur)
         {
            // clear error flag
            vcos_event_flags_get(&comp->event, ILCLIENT_EVENT_ERROR, VCOS_OR_CONSUME, 0, &set);
            ilclient_unlock_events(comp->client);
            return -2;
         }

         ilclient_unlock_events(comp->client);
      }
      // check for config change event if we are asked to be notified of that
      if(event_flag & ILCLIENT_CONFIG_CHANGED)
      {
         ILEVENT_T *cur;
         ilclient_lock_events(comp->client);
         cur = comp->list;
         while(cur && cur->eEvent != OMX_EventParamOrConfigChanged)
            cur = cur->next;
         
         ilclient_unlock_events(comp->client);

         if(cur)
            return ilclient_remove_event(comp, event, nData1, ignore1, nData2, ignore2) == 0 ? 0 : -3;
      }

      status = vcos_event_flags_get(&comp->event, event_flag, VCOS_OR_CONSUME, 
                                    suspend, &set);
      if (status != 0)
         return -1;
      if (set & ILCLIENT_EVENT_ERROR)
         return -2;
      if (set & ILCLIENT_CONFIG_CHANGED)
         return ilclient_remove_event(comp, event, nData1, ignore1, nData2, ignore2) == 0 ? 0 : -3;
   }

   return 0;
}



/***********************************************************
 * Name: ilclient_wait_for_command_complete_dual
 *
 * Description: Waits for an event signalling command completion.  In
 * this version we may also return failure if there is an error event
 * that has terminated a command on a second component.
 *
 * Returns: 0 on success, -1 on failure of comp, -2 on failure of other
 ***********************************************************/
int ilclient_wait_for_command_complete_dual(COMPONENT_T *comp, OMX_COMMANDTYPE command, OMX_U32 nData2, COMPONENT_T *other)
{
   OMX_U32 mask = ILCLIENT_EVENT_ERROR;
   int ret = 0;

   switch(command) {
   case OMX_CommandStateSet:    mask |= ILCLIENT_STATE_CHANGED; break;
   case OMX_CommandPortDisable: mask |= ILCLIENT_PORT_DISABLED; break;
   case OMX_CommandPortEnable:  mask |= ILCLIENT_PORT_ENABLED;  break;
   default: return -1;
   }

   if(other)
      other->related = comp;

   while(1)
   {
      ILEVENT_T *cur, *prev = NULL;
      VCOS_UNSIGNED set;

      ilclient_lock_events(comp->client);

      cur = comp->list;
      while(cur &&
            !(cur->eEvent == OMX_EventCmdComplete && cur->nData1 == command && cur->nData2 == nData2) &&
            !(cur->eEvent == OMX_EventError && cur->nData2 == 1))
      {
         prev = cur;
         cur = cur->next;
      }

      if(cur)
      {
         if(prev == NULL)
            comp->list = cur->next;
         else
            prev->next = cur->next;

         // work out whether this was a success or a fail event
         ret = cur->eEvent == OMX_EventCmdComplete || cur->nData1 == OMX_ErrorSameState ? 0 : -1;

         if(cur->eEvent == OMX_EventError)
            vcos_event_flags_get(&comp->event, ILCLIENT_EVENT_ERROR, VCOS_OR_CONSUME, 0, &set);

         // add back into spare list
         cur->next = comp->client->event_list;
         comp->client->event_list = cur;
         cur->eEvent = -1; // mark as unused
         
         ilclient_unlock_events(comp->client);
         break;
      }
      else if(other != NULL)
      {
         // check the other component for an error event that terminates a command
         cur = other->list;
         while(cur && !(cur->eEvent == OMX_EventError && cur->nData2 == 1))
            cur = cur->next;

         if(cur)
         {
            // we don't remove the event in this case, since the user
            // can confirm that this event errored by calling wait_for_command on the
            // other component

            ret = -2;
            ilclient_unlock_events(comp->client);
            break;
         }
      }

      ilclient_unlock_events(comp->client);

      vcos_event_flags_get(&comp->event, mask, VCOS_OR_CONSUME, VCOS_SUSPEND, &set);
   }

   if(other)
      other->related = NULL;

   return ret;
}


/***********************************************************
 * Name: ilclient_wait_for_command_complete
 *
 * Description: Waits for an event signalling command completion.
 *
 * Returns: 0 on success, -1 on failure.
 ***********************************************************/
int ilclient_wait_for_command_complete(COMPONENT_T *comp, OMX_COMMANDTYPE command, OMX_U32 nData2)
{
   return ilclient_wait_for_command_complete_dual(comp, command, nData2, NULL);
}

/***********************************************************
 * Name: ilclient_get_output_buffer
 *
 * Description: Returns an output buffer returned from a component
 * using the OMX_FillBufferDone callback from the output list for the
 * given component and port index.
 *
 * Returns: pointer to buffer if available, otherwise NULL
 ***********************************************************/
OMX_BUFFERHEADERTYPE *ilclient_get_output_buffer(COMPONENT_T *comp, int portIndex, int block)
{
   OMX_BUFFERHEADERTYPE *ret = NULL, *prev = NULL;
   VCOS_UNSIGNED set;

   do {
      vcos_semaphore_wait(&comp->sema);
      ret = comp->out_list;
      while(ret != NULL && ret->nOutputPortIndex != portIndex)
      {
         prev = ret;
         ret = ret->pAppPrivate;
      }
      
      if(ret)
      {
         if(prev == NULL)
            comp->out_list = ret->pAppPrivate;
         else
            prev->pAppPrivate = ret->pAppPrivate;
         
         ret->pAppPrivate = NULL;
      }
      vcos_semaphore_post(&comp->sema);

      if(block && !ret)
         vcos_event_flags_get(&comp->event, ILCLIENT_FILL_BUFFER_DONE, VCOS_OR_CONSUME, -1, &set);

   } while(block && !ret);

   return ret;
}

/***********************************************************
 * Name: ilclient_get_input_buffer
 *
 * Description: Returns an input buffer return from a component using
 * the OMX_EmptyBufferDone callback from the output list for the given
 * component and port index.
 *
 * Returns: pointer to buffer if available, otherwise NULL
 ***********************************************************/
OMX_BUFFERHEADERTYPE *ilclient_get_input_buffer(COMPONENT_T *comp, int portIndex, int block)
{
   OMX_BUFFERHEADERTYPE *ret = NULL, *prev = NULL;

   do {
      VCOS_UNSIGNED set;

      vcos_semaphore_wait(&comp->sema);
      ret = comp->in_list;
      while(ret != NULL && ret->nInputPortIndex != portIndex)
      {
         prev = ret;
         ret = ret->pAppPrivate;
      }
      
      if(ret)
      {
         if(prev == NULL)
            comp->in_list = ret->pAppPrivate;
         else
            prev->pAppPrivate = ret->pAppPrivate;
         
         ret->pAppPrivate = NULL;
      }
      vcos_semaphore_post(&comp->sema);

      if(block && !ret)
         vcos_event_flags_get(&comp->event, ILCLIENT_EMPTY_BUFFER_DONE, VCOS_OR_CONSUME, -1, &set);

   } while(block && !ret);

   return ret;
}

/***********************************************************
 * Name: ilclient_debug_output
 *
 * Description: prints a varg message to the log or the debug screen
 * under win32
 *
 * Returns: void
 ***********************************************************/
void ilclient_debug_output(char *format, ...)
{
   va_list args;

   va_start(args, format);
   vcos_vlog_info(format, args);
   va_end(args);
}

/******************************************************************************
Static functions
******************************************************************************/

/***********************************************************
 * Name: ilclient_lock_events
 *
 * Description: locks the client event structure
 *
 * Returns: void
 ***********************************************************/
static void ilclient_lock_events(ILCLIENT_T *st)
{
   vcos_semaphore_wait(&st->event_sema);
}

/***********************************************************
 * Name: ilclient_unlock_events
 *
 * Description: unlocks the client event structure
 *
 * Returns: void
 ***********************************************************/
static void ilclient_unlock_events(ILCLIENT_T *st)
{
   vcos_semaphore_post(&st->event_sema);
}

/***********************************************************
 * Name: ilclient_event_handler
 *
 * Description: event handler passed to core to use as component
 * callback
 *
 * Returns: success
 ***********************************************************/
static OMX_ERRORTYPE ilclient_event_handler(OMX_IN OMX_HANDLETYPE hComponent,
                                            OMX_IN OMX_PTR pAppData,
                                            OMX_IN OMX_EVENTTYPE eEvent,
                                            OMX_IN OMX_U32 nData1,
                                            OMX_IN OMX_U32 nData2,
                                            OMX_IN OMX_PTR pEventData)
{
   COMPONENT_T *st = (COMPONENT_T *) pAppData;
   ILEVENT_T *event;
   OMX_ERRORTYPE error = OMX_ErrorNone;

   ilclient_lock_events(st->client);

   // go through the events on this component and remove any duplicates in the
   // existing list, since the client probably doesn't need them.  it's better
   // than asserting when we run out.
   event = st->list;
   while(event != NULL)
   {
      ILEVENT_T **list = &(event->next);
      while(*list != NULL)
      {
         if((*list)->eEvent == event->eEvent &&
            (*list)->nData1 == event->nData1 &&
            (*list)->nData2 == event->nData2)
         {
            // remove this duplicate
            ILEVENT_T *rem = *list;
            ilclient_debug_output("%s: removing %d/%d/%d", st->name, event->eEvent, event->nData1, event->nData2);            
            *list = rem->next;
            rem->eEvent = -1;
            rem->next = st->client->event_list;
            st->client->event_list = rem;
         }
         else
            list = &((*list)->next);
      }

      event = event->next;
   }

   vc_assert(st->client->event_list);
   event = st->client->event_list;

   switch (eEvent) {
   case OMX_EventCmdComplete:
      switch (nData1) {
      case OMX_CommandStateSet:
         ilclient_debug_output("%s: callback state changed (%s)", st->name, states[nData2]);
         vcos_event_flags_set(&st->event, ILCLIENT_STATE_CHANGED, VCOS_OR);
         break;
      case OMX_CommandPortDisable:
         ilclient_debug_output("%s: callback port disable %d", st->name, nData2);
         vcos_event_flags_set(&st->event, ILCLIENT_PORT_DISABLED, VCOS_OR);
         break;
      case OMX_CommandPortEnable:
         ilclient_debug_output("%s: callback port enable %d", st->name, nData2);
         vcos_event_flags_set(&st->event, ILCLIENT_PORT_ENABLED, VCOS_OR);
         break;
      case OMX_CommandFlush:
         ilclient_debug_output("%s: callback port flush %d", st->name, nData2);
         vcos_event_flags_set(&st->event, ILCLIENT_PORT_FLUSH, VCOS_OR);
         break;
      case OMX_CommandMarkBuffer:
         ilclient_debug_output("%s: callback mark buffer %d", st->name, nData2);
         vcos_event_flags_set(&st->event, ILCLIENT_MARKED_BUFFER, VCOS_OR);
         break;
      default:
         vc_assert(0);
      }
      break;
   case OMX_EventError:
      {
         // check if this component failed a command, and we have to notify another command
         // of this failure
         if(nData2 == 1 && st->related != NULL)
            vcos_event_flags_set(&st->related->event, ILCLIENT_EVENT_ERROR, VCOS_OR);

         error = nData1;
         switch (error) {
         case OMX_ErrorPortUnpopulated:
            if (st->error_mask & ILCLIENT_ERROR_UNPOPULATED)
            {
               ilclient_debug_output("%s: ignore error: port unpopulated (%d)", st->name, nData2);
               event = NULL;
               break;
            }
            ilclient_debug_output("%s: port unpopulated %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorSameState:
            if (st->error_mask & ILCLIENT_ERROR_SAMESTATE)
            {
               ilclient_debug_output("%s: ignore error: same state (%d)", st->name, nData2);
               event = NULL;
               break;
            }
            ilclient_debug_output("%s: same state %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorBadParameter:
            if (st->error_mask & ILCLIENT_ERROR_BADPARAMETER)
            {
               ilclient_debug_output("%s: ignore error: bad parameter (%d)", st->name, nData2);
               event = NULL;
               break;
            }
            ilclient_debug_output("%s: bad parameter %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorIncorrectStateTransition:
            ilclient_debug_output("%s: incorrect state transition %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorBadPortIndex:
            ilclient_debug_output("%s: bad port index %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorStreamCorrupt:
            ilclient_debug_output("%s: stream corrupt %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorInsufficientResources:
            ilclient_debug_output("%s: insufficient resources %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorUnsupportedSetting:
            ilclient_debug_output("%s: unsupported setting %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorOverflow:
            ilclient_debug_output("%s: overflow %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorDiskFull:
            ilclient_debug_output("%s: disk full %x (%d)", st->name, error, nData2);
            //we do not set the error
            break;
         case OMX_ErrorMaxFileSize:
            ilclient_debug_output("%s: max file size %x (%d)", st->name, error, nData2);
            //we do not set the error
            break;
         case OMX_ErrorDrmUnauthorised:
            ilclient_debug_output("%s: drm file is unauthorised %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorDrmExpired:
            ilclient_debug_output("%s: drm file has expired %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorDrmGeneral:
            ilclient_debug_output("%s: drm library error %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         default:
            vc_assert(0);
            ilclient_debug_output("%s: unexpected error %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         }
      }
      break;
   case OMX_EventBufferFlag:
      ilclient_debug_output("%s: buffer flag %d/%x", st->name, nData1, nData2);
      if (nData2 & OMX_BUFFERFLAG_EOS)
      {
         vcos_event_flags_set(&st->event, ILCLIENT_BUFFER_FLAG_EOS, VCOS_OR);
         nData2 = OMX_BUFFERFLAG_EOS;
      }
      else
         vc_assert(0);
      break;
   case OMX_EventPortSettingsChanged:
      ilclient_debug_output("%s: port settings changed %d", st->name, nData1);
      vcos_event_flags_set(&st->event, ILCLIENT_PARAMETER_CHANGED, VCOS_OR);
      break;
   case OMX_EventMark:
      ilclient_debug_output("%s: buffer mark %p", st->name, pEventData);
      vcos_event_flags_set(&st->event, ILCLIENT_BUFFER_MARK, VCOS_OR);
      break;
   case OMX_EventParamOrConfigChanged:
      ilclient_debug_output("%s: param/config 0x%X on port %d changed", st->name, nData2, nData1);
      vcos_event_flags_set(&st->event, ILCLIENT_CONFIG_CHANGED, VCOS_OR);
      break;
   default:
      vc_assert(0);
      break;
   }

   if (event)
   {
      // fill in details
      event->eEvent = eEvent;
      event->nData1 = nData1;
      event->nData2 = nData2;
      event->pEventData = pEventData;

      // remove from top of spare list
      st->client->event_list = st->client->event_list->next;

      // put at head of component event queue
      event->next = st->list;
      st->list = event;
   }
   ilclient_unlock_events(st->client);

   // now call any callbacks without the event lock so the client can 
   // remove the event in context
   switch(eEvent) {
   case OMX_EventError:
      if(event && st->client->error_callback)
         st->client->error_callback(st->client->error_callback_data, st, error);
      break;
   case OMX_EventBufferFlag:
      if ((nData2 & OMX_BUFFERFLAG_EOS) && st->client->eos_callback)
         st->client->eos_callback(st->client->eos_callback_data, st, nData1);
      break;
   case OMX_EventPortSettingsChanged:
      if (st->client->port_settings_callback)
         st->client->port_settings_callback(st->client->port_settings_callback_data, st, nData1);
      break;
   case OMX_EventParamOrConfigChanged:
      if (st->client->configchanged_callback)
         st->client->configchanged_callback(st->client->configchanged_callback_data, st, nData2);
      break;
   default:
      // ignore
      break;
   }

   return OMX_ErrorNone;
}

/***********************************************************
 * Name: ilclient_empty_buffer_done
 *
 * Description: passed to core to use as component callback, puts
 * buffer on list
 *
 * Returns:
 ***********************************************************/
static OMX_ERRORTYPE ilclient_empty_buffer_done(OMX_IN OMX_HANDLETYPE hComponent,
      OMX_IN OMX_PTR pAppData,
      OMX_IN OMX_BUFFERHEADERTYPE* pBuffer)
{
   COMPONENT_T *st = (COMPONENT_T *) pAppData;
   OMX_BUFFERHEADERTYPE *list;

   ilclient_debug_output("%s: empty buffer done %p", st->name, pBuffer);

   vcos_semaphore_wait(&st->sema);
   // insert at end of the list, so we process buffers in
   // the same order
   list = st->in_list;
   while(list && list->pAppPrivate)
      list = list->pAppPrivate;

   if(!list)
      st->in_list = pBuffer;
   else
      list->pAppPrivate = pBuffer;

   pBuffer->pAppPrivate = NULL;
   vcos_semaphore_post(&st->sema);

   vcos_event_flags_set(&st->event, ILCLIENT_EMPTY_BUFFER_DONE, VCOS_OR);

   if (st->client->empty_buffer_done_callback)
      st->client->empty_buffer_done_callback(st->client->empty_buffer_done_callback_data, st);

   return OMX_ErrorNone;
}

/***********************************************************
 * Name: ilclient_empty_buffer_done_error
 *
 * Description: passed to core to use as component callback, asserts
 * on use as client not expecting component to use this callback.
 *
 * Returns:
 ***********************************************************/
static OMX_ERRORTYPE ilclient_empty_buffer_done_error(OMX_IN OMX_HANDLETYPE hComponent,
      OMX_IN OMX_PTR pAppData,
      OMX_IN OMX_BUFFERHEADERTYPE* pBuffer)
{
   vc_assert(0);
   return OMX_ErrorNone;
}

/***********************************************************
 * Name: ilclient_fill_buffer_done
 *
 * Description: passed to core to use as component callback, puts
 * buffer on list
 *
 * Returns:
 ***********************************************************/
static OMX_ERRORTYPE ilclient_fill_buffer_done(OMX_OUT OMX_HANDLETYPE hComponent,
      OMX_OUT OMX_PTR pAppData,
      OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer)
{
   COMPONENT_T *st = (COMPONENT_T *) pAppData;
   OMX_BUFFERHEADERTYPE *list;

   ilclient_debug_output("%s: fill buffer done %p", st->name, pBuffer);

   vcos_semaphore_wait(&st->sema);
   // insert at end of the list, so we process buffers in
   // the correct order
   list = st->out_list;
   while(list && list->pAppPrivate)
      list = list->pAppPrivate;

   if(!list)
      st->out_list = pBuffer;
   else
      list->pAppPrivate = pBuffer;
      
   pBuffer->pAppPrivate = NULL;
   vcos_semaphore_post(&st->sema);

   vcos_event_flags_set(&st->event, ILCLIENT_FILL_BUFFER_DONE, VCOS_OR);

   if (st->client->fill_buffer_done_callback)
      st->client->fill_buffer_done_callback(st->client->fill_buffer_done_callback_data, st);

   return OMX_ErrorNone;
}

/***********************************************************
 * Name: ilclient_fill_buffer_done_error
 *
 * Description: passed to core to use as component callback, asserts
 * on use as client not expecting component to use this callback.
 *
 * Returns:
 ***********************************************************/
static OMX_ERRORTYPE ilclient_fill_buffer_done_error(OMX_OUT OMX_HANDLETYPE hComponent,
      OMX_OUT OMX_PTR pAppData,
      OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer)
{
   vc_assert(0);
   return OMX_ErrorNone;
}



OMX_HANDLETYPE ilclient_get_handle(COMPONENT_T *comp)
{
   vcos_assert(comp);
   return comp->comp;
}


static struct {
   OMX_PORTDOMAINTYPE dom;
   int param;
} port_types[] = {
   { OMX_PortDomainVideo, OMX_IndexParamVideoInit },
   { OMX_PortDomainAudio, OMX_IndexParamAudioInit },
   { OMX_PortDomainImage, OMX_IndexParamImageInit },
   { OMX_PortDomainOther, OMX_IndexParamOtherInit },
};

int ilclient_get_port_index(COMPONENT_T *comp, OMX_DIRTYPE dir, OMX_PORTDOMAINTYPE type, int index)
{
   uint32_t i;
   // for each possible port type...
   for (i=0; i<sizeof(port_types)/sizeof(port_types[0]); i++)
   {
      if ((port_types[i].dom == type) || (type == (OMX_PORTDOMAINTYPE) -1))
      {
         OMX_PORT_PARAM_TYPE param;
         OMX_ERRORTYPE error;
         uint32_t j;

         param.nSize = sizeof(param);
         param.nVersion.nVersion = OMX_VERSION;
         error = OMX_GetParameter(ILC_GET_HANDLE(comp), port_types[i].param, &param);
         assert(error == OMX_ErrorNone);

         // for each port of this type...
         for (j=0; j<param.nPorts; j++)
         {
            int port = param.nStartPortNumber+j;

            OMX_PARAM_PORTDEFINITIONTYPE portdef;
            portdef.nSize = sizeof(portdef);
            portdef.nVersion.nVersion = OMX_VERSION;
            portdef.nPortIndex = port;

            error = OMX_GetParameter(ILC_GET_HANDLE(comp), OMX_IndexParamPortDefinition, &portdef);
            assert(error == OMX_ErrorNone);

            if (portdef.eDir == dir)
            {
               if (index-- == 0)
                  return port;
            }
         }
      }
   }
   return -1;
}

int ilclient_suggest_bufsize(COMPONENT_T *comp, OMX_U32 nBufSizeHint)
{
   OMX_PARAM_BRCMOUTPUTBUFFERSIZETYPE param;
   OMX_ERRORTYPE error;

   param.nSize = sizeof(param);
   param.nVersion.nVersion = OMX_VERSION;
   param.nBufferSize = nBufSizeHint;
   error = OMX_SetParameter(ILC_GET_HANDLE(comp), OMX_IndexParamBrcmOutputBufferSize,
                            &param);
   assert(error == OMX_ErrorNone);

   return (error == OMX_ErrorNone) ? 0 : -1;
}

unsigned int ilclient_stack_size(void)
{
   return ILCLIENT_THREAD_DEFAULT_STACK_SIZE;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * \file
 *
 * \brief This API defines helper functions for writing IL clients.
 *
 * This file defines an IL client side library.  This is useful when
 * writing IL clients, since there tends to be much repeated and
 * common code across both single and multiple clients.  This library
 * seeks to remove that common code and abstract some of the
 * interactions with components.  There is a wrapper around a
 * component and tunnel, and some operations can be done on lists of
 * these.  The callbacks from components are handled, and specific
 * events can be checked or waited for.
 */

#ifndef _IL_CLIENT_H
#define _IL_CLIENT_H

#include "IL/OMX_Broadcom.h"
#include "interface/vcos/vcos.h"

/**
 * The <DFN>ILCLIENT_T</DFN> structure encapsulates the state needed for the IL
 * Client API.  It contains a set of callback functions used to
 * communicate with the user.  It also includes a linked list of free
 * event structures.
 ***********************************************************/
typedef struct _ILCLIENT_T ILCLIENT_T;


/**
 * Each <DFN>ILEVENT_T</DFN> structure stores the result of an <DFN>EventHandler</DFN>
 * callback from a component, storing the event message type and any
 * parameters returned.
 ***********************************************************/
typedef struct _ILEVENT_T ILEVENT_T;



struct _COMPONENT_T;

/**
 * The <DFN>COMPONENT_T</DFN> structure represents an IL component,
 * together with the necessary extra information required by the IL
 * Client API.  This structure stores the handle to the OMX component,
 * as well as the event list containing all events sent by this
 * component.  The component state structure also holds a pair of
 * buffer queues, for input and output buffers returned to the client
 * by the <DFN>FillBufferDone</DFN> and <DFN>EmptyBufferDone</DFN>
 * callbacks.  As some operations result in error callbacks that can
 * be ignored, an error mask is maintained to allow some errors to be
 * ignored.  A pointer to the client state structure is also added.
 ***********************************************************/
typedef struct _COMPONENT_T COMPONENT_T;


/**
 * The generic callback function is used for communicating events from
 * a particular component to the user.
 *
 * @param userdata The data returned from when the callback was registered.
 *
 * @param comp The component structure representing the component that
 * originated this event.
 *
 * @param data The relevant data field from the event.
 *
 * @return Void.
 ***********************************************************/
typedef void (*ILCLIENT_CALLBACK_T)(void *userdata, COMPONENT_T *comp, OMX_U32 data);


/**
 * The buffer callback function is used for indicating that a
 * component has returned a buffer on a port using client buffer
 * communication.
 *
 * @param data The data returned from when the callback was registered.
 *
 * @param comp The component from which the buffer originated.
 *
 * @return Void.
 ***********************************************************/
typedef void (*ILCLIENT_BUFFER_CALLBACK_T)(void *data, COMPONENT_T *comp);


/**
 * The malloc function is passed into
 * <DFN>ilclient_enable_port_buffers()</DFN> and used for allocating the
 * buffer payload.
 *
 * @param userdata Private pointer passed into
 * <DFN>ilclient_enable_port_buffers()</DFN> call.
 *
 * @param size Size in bytes of the requested memory region.
 *
 * @param align Alignment requirement in bytes for the base memory address.
 *
 * @param description Text description of the memory being allocated.
 *
 * @return The memory address on success, <DFN>NULL</DFN> on failure.
 ***********************************************************/
typedef void *(*ILCLIENT_MALLOC_T)(void *userdata, VCOS_UNSIGNED size, VCOS_UNSIGNED align, const char *description);


/**
 * The free function is passed into
 * <DFN>ilclient_enable_port_buffers()</DFN> and
 * <DFN>ilclient_disable_port_buffers()</DFN> and used for freeing the
 * buffer payload.
 *
 * @param userdata Private pointer passed into
 * <DFN>ilclient_enable_port_buffers()</DFN> and
 * <DFN>ilclient_disable_port_buffers()</DFN>.
 *
 * @param pointer Memory address to free, that was previously returned
 * from <DFN>ILCLIENT_MALLOC_T</DFN> function.
 *
 * @return Void.
 ***********************************************************/
typedef void (*ILCLIENT_FREE_T)(void *userdata, void *pointer);


/**
 * The event mask enumeration describes the possible events that the
 * user can ask to wait for when waiting for a particular event.
 ***********************************************************/
typedef enum {
   ILCLIENT_EMPTY_BUFFER_DONE  = 0x1,   /**< Set when a buffer is
                                           returned from an input
                                           port */

   ILCLIENT_FILL_BUFFER_DONE   = 0x2,   /**< Set when a buffer is
                                           returned from an output
                                           port */

   ILCLIENT_PORT_DISABLED      = 0x4,   /**< Set when a port indicates
                                           it has completed a disable
                                           command. */

   ILCLIENT_PORT_ENABLED       = 0x8,   /**< Set when a port indicates
                                           is has completed an enable
                                           command. */

   ILCLIENT_STATE_CHANGED      = 0x10,  /**< Set when a component
                                           indicates it has completed
                                           a state change command. */

   ILCLIENT_BUFFER_FLAG_EOS    = 0x20,  /**< Set when a port signals
                                           an EOS event. */

   ILCLIENT_PARAMETER_CHANGED  = 0x40,  /**< Set when a port signals a
                                           port settings changed
                                           event. */

   ILCLIENT_EVENT_ERROR        = 0x80,  /**< Set when a component
                                           indicates an error. */

   ILCLIENT_PORT_FLUSH         = 0x100, /**< Set when a port indicates
                                           is has completed a flush
                                           command. */

   ILCLIENT_MARKED_BUFFER      = 0x200, /**< Set when a port indicates
                                           it has marked a buffer. */

   ILCLIENT_BUFFER_MARK        = 0x400, /**< Set when a port indicates
                                           it has received a buffer
                                           mark. */

   ILCLIENT_CONFIG_CHANGED     = 0x800  /**< Set when a config parameter
                                           changed. */
} ILEVENT_MASK_T;


/**
 * On component creation the user can set flags to control the 
 * creation of that component.
 ***********************************************************/
typedef enum {
   ILCLIENT_FLAGS_NONE            = 0x0, /**< Used if no flags are
                                            set. */

   ILCLIENT_ENABLE_INPUT_BUFFERS  = 0x1, /**< If set we allow the
                                            client to communicate with
                                            input ports via buffer
                                            communication, rather than
                                            tunneling with another
                                            component. */

   ILCLIENT_ENABLE_OUTPUT_BUFFERS = 0x2, /**< If set we allow the
                                            client to communicate with
                                            output ports via buffer
                                            communication, rather than
                                            tunneling with another
                                            component. */

   ILCLIENT_DISABLE_ALL_PORTS     = 0x4, /**< If set we disable all
                                            ports on creation. */

   ILCLIENT_HOST_COMPONENT        = 0x8, /**< Create a host component.
                                            The default host ilcore
                                            only can create host components
                                            by being locally hosted
                                            so should only be used for testing
                                            purposes. */

   ILCLIENT_OUTPUT_ZERO_BUFFERS   = 0x10 /**< All output ports will have
                                            nBufferCountActual set to zero,
                                            if supported by the component. */                                            
} ILCLIENT_CREATE_FLAGS_T;
  

/**
 * \brief This structure represents a tunnel in the OpenMAX IL API.
 *
 * Some operations in this API act on a tunnel, so the tunnel state
 * structure (<DFN>TUNNEL_T</DFN>) is a convenient store of the source and sink
 * of the tunnel.  For each, a pointer to the relevant component state
 * structure and the port index is stored.
 ***********************************************************/
typedef struct {
   COMPONENT_T *source;  /**< The source component */
   int source_port;      /**< The output port index on the source component */
   COMPONENT_T *sink;    /**< The sink component */
   int sink_port;        /**< The input port index on the sink component */
} TUNNEL_T;


/**
 * The <DFN>set_tunnel</DFN> macro is a useful function that initialises a
 * <DFN>TUNNEL_T</DFN> structure.
 ***********************************************************/
#define set_tunnel(t,a,b,c,d)  do {TUNNEL_T *_ilct = (t); \
  _ilct->source = (a); _ilct->source_port = (b); \
  _ilct->sink = (c); _ilct->sink_port = (d);} while(0)

/**
 * For calling OpenMAX IL methods directory, we need to access the
 * <DFN>OMX_HANDLETYPE</DFN> corresponding to the <DFN>COMPONENT_T</DFN> structure.  This
 * macro enables this while keeping the <DFN>COMPONENT_T</DFN> structure opaque.
 * The parameter <DFN>x</DFN> should be of the type <DFN>*COMPONENT_T</DFN>.
 ***********************************************************/
#define ILC_GET_HANDLE(x) ilclient_get_handle(x)

/**
 * An IL Client structure is created by the <DFN>ilclient_init()</DFN>
 * method.  This structure is used when creating components, but
 * otherwise is not needed in other API functions as a pointer to this
 * structure is maintained in the <DFN>COMPONENT_T</DFN> structure.
 *
 * @return pointer to client structure
 ***********************************************************/
VCHPRE_ ILCLIENT_T VCHPOST_ *ilclient_init(void);

/**
 * When all components have been deleted, the IL Client structure can
 * be destroyed by calling the <DFN>ilclient_destroy()</DFN> function.
 *
 * @param handle The client handle.  After calling this function, this
 * handle should not be used.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_destroy(ILCLIENT_T *handle);

/**
 * The <DFN>ilclient_set_port_settings_callback()</DFN> function registers a
 * callback to be used when the <DFN>OMX_EventPortSettingsChanged</DFN> event is
 * received.  When the event is received, a pointer to the component
 * structure and port index is returned by the callback.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_port_settings_callback(ILCLIENT_T *handle,
                                                          ILCLIENT_CALLBACK_T func,
                                                          void *userdata);

/**
 * The <DFN>ilclient_set_eos_callback()</DFN> function registers a callback to be
 * used when the <DFN>OMX_EventBufferFlag</DFN> is received with the
 * <DFN>OMX_BUFFERFLAG_EOS</DFN> flag set. When the event is received, a pointer
 * to the component structure and port index is returned by the
 * callback.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_eos_callback(ILCLIENT_T *handle,
                                                ILCLIENT_CALLBACK_T func,
                                                void *userdata);

/**
 * The <DFN>ilclient_set_error_callback()</DFN> function registers a callback to be
 * used when the <DFN>OMX_EventError</DFN> is received from a component.  When
 * the event is received, a pointer to the component structure and the
 * error code are reported by the callback.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_error_callback(ILCLIENT_T *handle,
                                                  ILCLIENT_CALLBACK_T func,
                                                  void *userdata);

/**
 * The <DFN>ilclient_set_configchanged_callback()</DFN> function
 * registers a callback to be used when an
 * <DFN>OMX_EventParamOrConfigChanged</DFN> event occurs.  When the
 * event is received, a pointer to the component structure and the
 * index value that has changed are reported by the callback.  The
 * user may then use an <DFN>OMX_GetConfig</DFN> call with the index
 * as specified to retrieve the updated information.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_configchanged_callback(ILCLIENT_T *handle, 
                                                          ILCLIENT_CALLBACK_T func, 
                                                          void *userdata);


/**
 * The <DFN>ilclient_set_fill_buffer_done_callback()</DFN> function registers a
 * callback to be used when a buffer passed to an output port using the
 * <DFN>OMX_FillBuffer</DFN> call is returned with the <DFN>OMX_FillBufferDone</DFN>
 * callback.  When the event is received, a pointer to the component
 * structure is returned by the callback.  The user may then use the
 * <DFN>ilclient_get_output_buffer()</DFN> function to retrieve the buffer.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_fill_buffer_done_callback(ILCLIENT_T *handle,
                                                             ILCLIENT_BUFFER_CALLBACK_T func,
                                                             void *userdata);

/**
 * The <DFN>ilclient_set_empty_buffer_done_callback()</DFN> function registers a
 * callback to be used when a buffer passed to an input port using the
 * <DFN>OMX_EmptyBuffer</DFN> call is returned with the <DFN>OMX_EmptyBufferDone</DFN>
 * callback.  When the event is received, a pointer to the component
 * structure is returned by the callback.  The user may then use the
 * <DFN>ilclient_get_input_buffer()</DFN> function to retrieve the buffer.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_empty_buffer_done_callback(ILCLIENT_T *handle,
                                                              ILCLIENT_BUFFER_CALLBACK_T func,
                                                              void *userdata);


/**
 * Components are created using the <DFN>ilclient_create_component()</DFN>
 * function.  
 *
 * @param handle The client handle
 *
 * @param comp On successful creation, the component structure pointer
 * will be written back into <DFN>comp</DFN>.
 *
 * @param name The name of the component to be created.  Component
 * names as provided are automatically prefixed with
 * <DFN>"OMX.broadcom."</DFN> before passing to the IL core.  The name
 * provided will also be used in debugging messages added about this
 * component.
 *
 * @param flags The client can specify some creation behaviour by using
 * the <DFN>flags</DFN> field.  The meaning of each flag is defined 
 * by the <DFN>ILCLIENT_CREATE_FLAGS_T</DFN> type.
 *
 * @return 0 on success, -1 on failure
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_create_component(ILCLIENT_T *handle,
                                               COMPONENT_T **comp,
                                               char *name,
                                               ILCLIENT_CREATE_FLAGS_T flags);

/**
 * The <DFN>ilclient_cleanup_components()</DFN> function deallocates all
 * state associated with components and frees the OpenMAX component
 * handles. All tunnels connecting components should have been torn
 * down explicitly, and all components must be in loaded state.
 *
 * @param list A null-terminated list of component pointers to be
 * deallocated.
 * 
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_cleanup_components(COMPONENT_T *list[]);


/**
 * The <DFN>ilclient_change_component_state()</DFN> function changes the
 * state of an individual component.  This will trigger the state
 * change, and also wait for that state change to be completed.  It
 * should not be called if this state change has dependencies on other
 * components also changing states.  Trying to change a component to
 * its current state is treated as success.
 *
 * @param comp The component to change.
 *
 * @param state The new state to transition to.
 *
 * @return 0 on success, -1 on failure.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_change_component_state(COMPONENT_T *comp,
                                                     OMX_STATETYPE state);


/**
 * The <DFN>ilclient_state_transition()</DFN> function transitions a set of
 * components that need to perform a simultaneous state transition; 
 * for example, when two components are tunnelled and the buffer
 * supplier port needs to allocate and pass buffers to a non-supplier
 * port.  All components are sent a command to change state, then the
 * function will wait for all components to signal that they have
 * changed state.
 *
 * @param list A null-terminated list of component pointers.
 *
 * @param state The new state to which to transition all components.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_  ilclient_state_transition(COMPONENT_T *list[],
                                                 OMX_STATETYPE state);


/**
 * The <DFN>ilclient_disable_port()</DFN> function disables a port on a
 * given component.  This function sends the disable port message to
 * the component and waits for the component to signal that this has
 * taken place.  If the port is already disabled, this is treated as a
 * success.
 *
 * @param comp The component containing the port to disable.
 *
 * @param portIndex The port index of the port to disable.  This must
 * be a named port index, rather than a <DFN>OMX_ALL</DFN> value.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_disable_port(COMPONENT_T *comp,
                                            int portIndex);


/**
 * The <DFN>ilclient_enable_port()</DFN> function enables a port on a
 * given component.  This function sends the enable port message to
 * the component and waits for the component to signal that this has
 * taken place.  If the port is already disabled, this is treated as a
 * success.
 *
 * @param comp The component containing the port to enable.
 *
 * @param portIndex The port index of the port to enable.  This must
 * be a named port index, rather than a <DFN>OMX_ALL</DFN> value.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_enable_port(COMPONENT_T *comp,
                                           int portIndex);



/**
 * The <DFN>ilclient_enable_port_buffers()</DFN> function enables a port
 * in base profile mode on a given component.  The port is not
 * tunneled, so requires buffers to be allocated.
 *
 * @param comp The component containing the port to enable.
 *
 * @param portIndex The port index of the port to enable.  This must
 * be a named port index, rather than a <DFN>OMX_ALL</DFN> value.
 *
 * @param ilclient_malloc This function will be used to allocate
 * buffer payloads.  If <DFN>NULL</DFN> then
 * <DFN>vcos_malloc_aligned</DFN> will be used.
 *
 * @param ilclient_free If an error occurs, this function is used to
 * free previously allocated payloads.  If <DFN>NULL</DFN> then
 * <DFN>vcos_free</DFN> will be used.
 *
 * @param userdata The first argument to calls to
 * <DFN>ilclient_malloc</DFN> and <DFN>ilclient_free</DFN>, if these
 * arguments are not <DFN>NULL</DFN>.
 *
 * @return 0 indicates success. -1 indicates failure.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_enable_port_buffers(COMPONENT_T *comp,
                                                  int portIndex,
                                                  ILCLIENT_MALLOC_T ilclient_malloc,
                                                  ILCLIENT_FREE_T ilclient_free,
                                                  void *userdata);


/**
 * The <DFN>ilclient_disable_port_buffers()</DFN> function disables a
 * port in base profile mode on a given component.  The port is not
 * tunneled, and has been supplied with buffers by the client.
 *
 * @param comp The component containing the port to disable.
 *
 * @param portIndex The port index of the port to disable.  This must
 * be a named port index, rather than a <DFN>OMX_ALL</DFN> value.
 *
 * @param bufferList A list of buffers, using <DFN>pAppPrivate</DFN>
 * as the next pointer that were allocated on this port, and currently
 * held by the application.  If buffers on this port are held by IL
 * client or the component then these are automatically freed.
 *
 * @param ilclient_free This function is used to free the buffer payloads.
 * If <DFN>NULL</DFN> then <DFN>vcos_free</DFN> will be used.
 *
 * @param userdata The first argument to calls to
 * <DFN>ilclient_free</DFN>.
 *
 * @return void
 */
VCHPRE_ void VCHPOST_ ilclient_disable_port_buffers(COMPONENT_T *comp,
                                                    int portIndex,
                                                    OMX_BUFFERHEADERTYPE *bufferList,
                                                    ILCLIENT_FREE_T ilclient_free,
                                                    void *userdata);


/**
 * With a populated tunnel structure, the
 * <DFN>ilclient_setup_tunnel()</DFN> function connects the tunnel.  It
 * first transitions the source component to idle if currently in
 * loaded state, and then optionally checks the source event list for
 * a port settings changed event from the source port.  If this event
 * is not in the event queue then this function optionally waits for
 * it to arrive.  To disable this check for the port settings changed
 * event, set <DFN>timeout</DFN> to zero.
 *
 * Both ports are then disabled, and the source port is inspected for
 * a port streams parameter.  If this is supported, then the
 * <DFN>portStream</DFN> argument is used to select which port stream
 * to use.  The two ports are then tunnelled using the
 * <DFN>OMX_SetupTunnel</DFN> function.  If this is successful, then
 * both ports are enabled.  Note that for disabling and enabling the
 * tunnelled ports, the functions <DFN>ilclient_disable_tunnel()</DFN>
 * and <DFN>ilclient_enable_tunnel()</DFN> are used, so the relevant
 * documentation for those functions applies here.
 *
 * @param tunnel The tunnel structure representing the tunnel to
 * set up.
 *
 * @param portStream If port streams are supported on the output port
 * of the tunnel, then this parameter indicates the port stream to
 * select on this port.
 *
 * @param timeout The time duration in milliseconds to wait for the
 * output port to signal a port settings changed event before
 * returning a timeout failure.  If this is 0, then we do not check
 * for a port settings changed before setting up the tunnel.
 *
 * @return 0 indicates success, negative indicates failure:
 *  - -1: a timeout waiting for the parameter changed
 *  - -2: an error was returned instead of parameter changed
 *  - -3: no streams are available from this port
 *  - -4: requested stream is not available from this port
 *  - -5: the data format was not acceptable to the sink
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_setup_tunnel(TUNNEL_T *tunnel,
                                           unsigned int portStream,
                                           int timeout);


/**
 * The <DFN>ilclient_disable_tunnel()</DFN> function disables both ports listed in
 * the tunnel structure.  It will send a port disable command to each
 * port, then waits for both to indicate they have completed the
 * transition.  The errors <DFN>OMX_ErrorPortUnpopulated</DFN> and
 * <DFN>OMX_ErrorSameState</DFN> are both ignored by this function; the former
 * since the first port to disable may deallocate buffers before the
 * second port has been disabled, leading to the second port reporting
 * the unpopulated error.
 *
 * @param tunnel The tunnel to disable.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_disable_tunnel(TUNNEL_T *tunnel);


/**
 * The <DFN>ilclient_enable_tunnel()</DFN> function enables both ports listed in
 * the tunnel structure.  It will first send a port enable command to
 * each port.  It then checks whether the sink component is not in
 * loaded state - if so, the function waits for both ports to complete
 * the requested port enable.  If the sink component was in loaded
 * state, then this component is transitioned to idle to allow the
 * ports to exchange buffers and enable the ports.  This is since
 * typically this function is used when creating a tunnel between two
 * components, where the source component is processing data to enable
 * it to report the port settings changed event, and the sink port has
 * yet to be used.  Before transitioning the sink component to idle,
 * this function waits for the sink port to be enabled - since the
 * component is in loaded state, this will happen quickly.  If the
 * transition to idle fails, the sink component is transitioned back
 * to loaded and the source port disabled.  If the transition
 * succeeds, the function then waits for the source port to complete
 * the requested port enable.
 *
 * @param tunnel The tunnel to enable.
 *
 * @return 0 on success, -1 on failure.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_enable_tunnel(TUNNEL_T *tunnel);


/**
 * The <DFN>ilclient_flush_tunnels()</DFN> function will flush a number of tunnels
 * from the list of tunnels presented.  For each tunnel that is to be
 * flushed, both source and sink ports are sent a flush command.  The
 * function then waits for both ports to report they have completed
 * the flush operation.
 *
 * @param tunnel List of tunnels.  The list must be terminated with a
 * tunnel structure with <DFN>NULL</DFN> component entries.
 *
 * @param max The maximum number of tunnels to flush from the list.
 * A value of 0 indicates that all tunnels in the list are flushed.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_flush_tunnels(TUNNEL_T *tunnel,
                                             int max);


/**
 * The <DFN>ilclient_teardown_tunnels()</DFN> function tears down all tunnels in
 * the list of tunnels presented.  For each tunnel in the list, the
 * <DFN>OMX_SetupTunnel</DFN> is called on the source port and on the sink port,
 * where for both calls the destination component is <DFN>NULL</DFN> and the
 * destination port is zero.  The VMCSX IL implementation requires
 * that all tunnels are torn down in this manner before components are
 * freed. 
 *
 * @param tunnels List of tunnels to teardown.  The list must be
 * terminated with a tunnel structure with <DFN>NULL</DFN> component entries.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_teardown_tunnels(TUNNEL_T *tunnels);


/**
 * The <DFN>ilclient_get_output_buffer()</DFN> function returns a buffer
 * that was sent to an output port and that has been returned from a
 * component using the <DFN>OMX_FillBufferDone</DFN> callback.
 *
 * @param comp The component that returned the buffer.
 *
 * @param portIndex The port index on the component that the buffer
 * was returned from.
 *
 * @param block If non-zero, the function will block until a buffer is available.
 *
 * @return Pointer to buffer if available, otherwise <DFN>NULL</DFN>.
 ***********************************************************/
VCHPRE_ OMX_BUFFERHEADERTYPE* VCHPOST_ ilclient_get_output_buffer(COMPONENT_T *comp,
                                                                  int portIndex,
                                                                  int block);


/**
 * The <DFN>ilclient_get_input_buffer()</DFN> function returns a buffer
 * that was sent to an input port and that has been returned from a
 * component using the <DFN>OMX_EmptyBufferDone</DFN> callback.
 *
 * @param comp The component that returned the buffer.
 *
 * @param portIndex The port index on the component from which the buffer
 * was returned.
 *
 * @param block If non-zero, the function will block until a buffer is available.
 *
 * @return pointer to buffer if available, otherwise <DFN>NULL</DFN>
 ***********************************************************/
VCHPRE_ OMX_BUFFERHEADERTYPE* VCHPOST_ ilclient_get_input_buffer(COMPONENT_T *comp,
                                                                 int portIndex,
                                                                 int block);


/**
 * The <DFN>ilclient_remove_event()</DFN> function queries the event list for the
 * given component, matching against the given criteria.  If a matching
 * event is found, it is removed and added to the free event list.
 *
 * @param comp The component that returned the matching event.
 *
 * @param event The event type of the matching event.
 *
 * @param nData1 The <DFN>nData1</DFN> field of the matching event.
 *
 * @param ignore1 Whether to ignore the <DFN>nData1</DFN> field when finding a
 * matching event.  A value of 0 indicates that <DFN>nData1</DFN> must match, a
 * value of 1 indicates that <DFN>nData1</DFN> does not have to match.
 *
 * @param nData2 The <DFN>nData2</DFN> field of the matching event.
 *
 * @param ignore2 Whether to ignore the <DFN>nData2</DFN> field when finding a
 * matching event.  A value of 0 indicates that <DFN>nData2</DFN> must match, a
 * value of 1 indicates that <DFN>nData2</DFN> does not have to match.
 *
 * @return 0 if the event was removed.  -1 if no matching event was
 * found.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_remove_event(COMPONENT_T *comp,
                                           OMX_EVENTTYPE event,
                                           OMX_U32 nData1,
                                           int ignore1,
                                           OMX_U32 nData2,
                                           int ignore2);


/**
 * The <DFN>ilclient_return_events()</DFN> function removes all events
 * from a component event list and adds them to the IL client free
 * event list.  This function is automatically called when components
 * are freed.
 *
 * @param comp The component from which all events should be moved to
 * the free list.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_return_events(COMPONENT_T *comp);


/**
 * The <DFN>ilclient_wait_for_event()</DFN> function is similar to
 * <DFN>ilclient_remove_event()</DFN>, but allows the caller to block until that
 * event arrives.
 *
 * @param comp The component that returned the matching event.
 *
 * @param event The event type of the matching event.
 *
 * @param nData1 The <DFN>nData1</DFN> field of the matching event.
 *
 * @param ignore1 Whether to ignore the <DFN>nData1</DFN> field when finding a
 * matching event.  A value of 0 indicates that <DFN>nData1</DFN> must match, a
 * value of 1 indicates that <DFN>nData1</DFN> does not have to match.
 *
 * @param nData2 The <DFN>nData2</DFN> field of the matching event.
 *
 * @param ignore2 Whether to ignore the <DFN>nData2</DFN> field when finding a
 * matching event.  A value of 0 indicates that <DFN>nData2</DFN> must match, a
 * value of 1 indicates that <DFN>nData2</DFN> does not have to match.
 *
 * @param event_flag Specifies a bitfield of IL client events to wait
 * for, given in <DFN>ILEVENT_MASK_T</DFN>.  If any of these events
 * are signalled by the component, the event list is then re-checked
 * for a matching event.  If the <DFN>ILCLIENT_EVENT_ERROR</DFN> bit
 * is included, and an error is signalled by the component, then the
 * function will return an error code.  If the
 * <DFN>ILCLIENT_CONFIG_CHANGED</DFN> bit is included, and this bit is
 * signalled by the component, then the function will return an error
 * code.
 *
 * @param timeout Specifies how long to block for in milliseconds
 * before returning a failure.
 *
 * @return 0 indicates success, a matching event has been removed from
 * the component's event queue.  A negative return indicates failure,
 * in this case no events have been removed from the component's event
 * queue.
 *  - -1: a timeout was received.
 *  - -2: an error event was received.
 *  - -3: a config changed event was received.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_wait_for_event(COMPONENT_T *comp,
                                             OMX_EVENTTYPE event,
                                             OMX_U32 nData1,
                                             int ignore1,
                                             OMX_U32 nData2,
                                             int ignore2,
                                             int event_flag,
                                             int timeout);


/**
 * The <DFN>ilclient_wait_for_command_complete()</DFN> function waits
 * for a message from a component that indicates that the command
 * has completed.  This is either a command success message, or an 
 * error message that signals the completion of an event.
 * 
 * @param comp The component currently processing a command.
 *
 * @param command The command being processed.  This must be either
 * <DFN>OMX_CommandStateSet</DFN>, <DFN>OMX_CommandPortDisable</DFN>
 * or <DFN>OMX_CommandPortEnable</DFN>.
 *
 * @param nData2 The expected value of <DFN>nData2</DFN> in the
 * command complete message.
 *
 * @return 0 indicates success, either the command successfully completed
 * or the <DFN>OMX_ErrorSameState</DFN> was returned.  -1 indicates
 * that the command terminated with a different error message.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_wait_for_command_complete(COMPONENT_T *comp,
                                                        OMX_COMMANDTYPE command,
                                                        OMX_U32 nData2);


/**
 * The <DFN>ilclient_wait_for_command_complete_dual()</DFN> function
 * is similar to <DFN>ilclient_wait_for_command_complete()</DFN>.  The
 * difference is that while waiting for the component to complete the
 * event or raise an error, we can also report if another reports an
 * error that terminates a command.  This is useful if the two
 * components are tunneled, and we need to wait for one component to
 * enable a port, or change state to <DFN>OMX_StateIdle</DFN>.  If the
 * other component is the buffer supplier and reports an error, then
 * it will not allocate buffers, so our first component may stall.
 * 
 * @param comp The component currently processing a command.
 *
 * @param command The command being processed.  This must be either
 * <DFN>OMX_CommandStateSet</DFN>, <DFN>OMX_CommandPortDisable</DFN>
 * or <DFN>OMX_CommandPortEnable</DFN>.
 *
 * @param nData2 The expected value of <DFN>nData2</DFN> in the
 * command complete message.
 *
 * @param related Another component, where we will return if this
 * component raises an error that terminates a command.
 *
 * @return 0 indicates success, either the command successfully
 * completed or the <DFN>OMX_ErrorSameState</DFN> was returned.  -1
 * indicates that the command terminated with a different error
 * message. -2 indicates that the related component raised an error.
 * In this case, the error is not cleared from the related
 * component's event list.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_wait_for_command_complete_dual(COMPONENT_T *comp,
                                                             OMX_COMMANDTYPE command,
                                                             OMX_U32 nData2,
                                                             COMPONENT_T *related);
                                                             

/**
 * The <DFN>ilclient_debug_output()</DFN> function adds a message to a 
 * host-specific debug display.  For a local VideoCore host the message is
 * added to the internal message log.  For a Win32 host the message is
 * printed to the debug display.  This function should be customised
 * when IL client is ported to another platform.
 * 
 * @param format A message to add, together with the variable
 * argument list similar to <DFN>printf</DFN> and other standard C functions.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_debug_output(char *format, ...);

/**
 * The <DFN>ilclient_get_handle()</DFN> function returns the
 * underlying OMX component held by an IL component handle.  This is
 * needed when calling methods such as <DFN>OMX_SetParameter</DFN> on
 * a component created using the IL client library.
 *
 * @param comp  IL component handle
 *
 * @return The <DFN>OMX_HANDLETYPE</DFN> value for the component.
 ***********************************************************/
VCHPRE_ OMX_HANDLETYPE VCHPOST_ ilclient_get_handle(COMPONENT_T *comp);


#ifndef OMX_SKIP64BIT

/**
 * Macro to return <DFN>OMX_TICKS</DFN> from a signed 64 bit value.
 * This is the version where <DFN>OMX_TICKS</DFN> is a signed 64 bit
 * value, an alternative definition is used when <DFN>OMX_TICKS</DFN>
 * is a structure.
 */
#define ilclient_ticks_from_s64(s) (s)

/**
 * Macro to return signed 64 bit value from <DFN>OMX_TICKS</DFN>.
 * This is the version where <DFN>OMX_TICKS</DFN> is a signed 64 bit
 * value, an alternative definition is used when <DFN>OMX_TICKS</DFN>
 * is a structure.
 */
#define ilclient_ticks_to_s64(t)   (t)

#else

/**
 * Inline function to return <DFN>OMX_TICKS</DFN> from a signed 64 bit
 * value.  This is the version where <DFN>OMX_TICKS</DFN> is a
 * structure, an alternative definition is used when
 * <DFN>OMX_TICKS</DFN> is a signed 64 bit value.
 */
static inline OMX_TICKS ilclient_ticks_from_s64(int64_t s) {
   OMX_TICKS ret;
   ret.nLowPart = s;
   ret.nHighPart = s>>32;
   return ret;
}

/**
 * Inline function to return signed 64 bit value from
 * <DFN>OMX_TICKS</DFN>.  This is the version where
 * <DFN>OMX_TICKS</DFN> is a structure, an alternative definition is
 * used when <DFN>OMX_TICKS</DFN> is a signed 64 bit value.
 */
static inline int64_t ilclient_ticks_to_s64(OMX_TICKS t) {
   uint64_t u = t.nLowPart | ((uint64_t)t.nHighPart << 32);
   return u;
}


#endif /* OMX_SKIP64BIT */

/**
 * The <DFN>ilclient_get_port_index()</DFN> function returns the n'th
 * port index of the specified type and direction for the given
 * component.
 *
 * @param comp    The component of interest
 * @param dir     The direction
 * @param type    The type, or -1 for any type.
 * @param index   Which port (counting from 0).
 *
 * @return        The port index, or -1 if not found.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_get_port_index(COMPONENT_T *comp,
                                             OMX_DIRTYPE dir,
                                             OMX_PORTDOMAINTYPE type,
                                             int index);


/**
 * The <DFN>ilclient_suggest_bufsize()</DFN> function gives a
 * component a hint about the size of buffer it should use.  This size
 * is set on the component by setting the
 * <DFN>OMX_IndexParamBrcmOutputBufferSize</DFN> index on the given
 * component.
 *
 * @param comp         IL component handle
 * @param nBufSizeHint Size of buffer in bytes
 *
 * @return             0 indicates success, -1 indicates failure.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_suggest_bufsize(COMPONENT_T *comp,
                                              OMX_U32 nBufSizeHint);


/**
 * The <DFN>ilclient_stack_size()</DFN> function suggests a minimum
 * stack size that tasks calling into with API will require.
 *
 * @return    Suggested stack size in bytes.
 ***********************************************************/
VCHPRE_ unsigned int VCHPOST_ ilclient_stack_size(void);

#endif /* ILCLIENT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * \file
 *
 * \brief Host core implementation.
 */

#include <stdio.h>
#include <stdarg.h>

//includes
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "IL/OMX_Component.h"
#include "interface/vcos/vcos.h"

#include "interface/vmcs_host/vcilcs.h"
#include "interface/vmcs_host/vchost.h"
#include "interface/vmcs_host/vcilcs_common.h"

static int coreInit = 0;
static int nActiveHandles = 0;
static ILCS_SERVICE_T *ilcs_service = NULL;
static VCOS_MUTEX_T lock;
static VCOS_ONCE_T once = VCOS_ONCE_INIT;

/* Atomic creation of lock protecting shared state */
static void initOnce(void)
{
   VCOS_STATUS_T status;
   status = vcos_mutex_create(&lock, VCOS_FUNCTION);
   vcos_demand(status == VCOS_SUCCESS);
}

/* OMX_Init */
OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void)
{
   VCOS_STATUS_T status;
   OMX_ERRORTYPE err = OMX_ErrorNone;

   status = vcos_once(&once, initOnce);
   vcos_demand(status == VCOS_SUCCESS);

   vcos_mutex_lock(&lock);
   
   if(coreInit == 0)
   {
      // we need to connect via an ILCS connection to VideoCore
      VCHI_INSTANCE_T initialise_instance;
      VCHI_CONNECTION_T *connection;
      ILCS_CONFIG_T config;

      vc_host_get_vchi_state(&initialise_instance, &connection);

      vcilcs_config(&config);

      ilcs_service = ilcs_init((VCHIQ_INSTANCE_T) initialise_instance, (void **) &connection, &config, 0);

      if(ilcs_service == NULL)
      {
         err = OMX_ErrorHardware;
         goto end;
      }

      coreInit = 1;
   }
   else
      coreInit++;

end:
   vcos_mutex_unlock(&lock);
   return err;
}

/* OMX_Deinit */
OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void)
{
   if(coreInit == 0) // || (coreInit == 1 && nActiveHandles > 0))
      return OMX_ErrorNotReady;

   vcos_mutex_lock(&lock);

   coreInit--;

   if(coreInit == 0)
   {
      // we need to teardown the ILCS connection to VideoCore
      ilcs_deinit(ilcs_service);
      ilcs_service = NULL;
   }

   vcos_mutex_unlock(&lock);
   
   return OMX_ErrorNone;
}


/* OMX_ComponentNameEnum */
OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
   OMX_OUT OMX_STRING cComponentName,
   OMX_IN  OMX_U32 nNameLength,
   OMX_IN  OMX_U32 nIndex)
{
   if(ilcs_service == NULL)
      return OMX_ErrorBadParameter;

   return vcil_out_component_name_enum(ilcs_get_common(ilcs_service), cComponentName, nNameLength, nIndex);
}


/* OMX_GetHandle */
OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
   OMX_OUT OMX_HANDLETYPE* pHandle,
   OMX_IN  OMX_STRING cComponentName,
   OMX_IN  OMX_PTR pAppData,
   OMX_IN  OMX_CALLBACKTYPE* pCallBacks)
{
   OMX_ERRORTYPE eError;
   OMX_COMPONENTTYPE *pComp;
   OMX_HANDLETYPE hHandle = 0;

   if (pHandle == NULL || cComponentName == NULL || pCallBacks == NULL || ilcs_service == NULL)
   {
      if(pHandle)
         *pHandle = NULL;
      return OMX_ErrorBadParameter;
   }

   {
      pComp = (OMX_COMPONENTTYPE *)malloc(sizeof(OMX_COMPONENTTYPE));
      if (!pComp)
      {
         vcos_assert(0);
         return OMX_ErrorInsufficientResources;
      }
      memset(pComp, 0, sizeof(OMX_COMPONENTTYPE));
      hHandle = (OMX_HANDLETYPE)pComp;
      pComp->nSize = sizeof(OMX_COMPONENTTYPE);
      pComp->nVersion.nVersion = OMX_VERSION;
      eError = vcil_out_create_component(ilcs_get_common(ilcs_service), hHandle, cComponentName);

      if (eError == OMX_ErrorNone) {
         // Check that all function pointers have been filled in.
         // All fields should be non-zero.
         int i;
         uint32_t *p = (uint32_t *) pComp;
         for(i=0; i<sizeof(OMX_COMPONENTTYPE)>>2; i++)
            if(*p++ == 0)
               eError = OMX_ErrorInvalidComponent;

         if(eError != OMX_ErrorNone && pComp->ComponentDeInit)
            pComp->ComponentDeInit(hHandle);
      }      

      if (eError == OMX_ErrorNone) {
         eError = pComp->SetCallbacks(hHandle,pCallBacks,pAppData);
         if (eError != OMX_ErrorNone)
            pComp->ComponentDeInit(hHandle);
      }
      if (eError == OMX_ErrorNone) {
         *pHandle = hHandle;
      }
      else {
         *pHandle = NULL;
         free(pComp);
      }
   } 

   if (eError == OMX_ErrorNone) {
      vcos_mutex_lock(&lock);
      nActiveHandles++;
      vcos_mutex_unlock(&lock);
   }

   return eError;
}

/* OMX_FreeHandle */
OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
   OMX_IN  OMX_HANDLETYPE hComponent)
{
   OMX_ERRORTYPE eError = OMX_ErrorNone;
   OMX_COMPONENTTYPE *pComp;

   if (hComponent == NULL || ilcs_service == NULL)
      return OMX_ErrorBadParameter;

   pComp = (OMX_COMPONENTTYPE*)hComponent;

   if (ilcs_service == NULL)
      return OMX_ErrorBadParameter;

   eError = (pComp->ComponentDeInit)(hComponent);
   if (eError == OMX_ErrorNone) {
      vcos_mutex_lock(&lock);
      --nActiveHandles;
      vcos_mutex_unlock(&lock);
      free(pComp);
   }

   vcos_assert(nActiveHandles >= 0);

   return eError;
}

/* OMX_SetupTunnel */
OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
   OMX_IN  OMX_HANDLETYPE hOutput,
   OMX_IN  OMX_U32 nPortOutput,
   OMX_IN  OMX_HANDLETYPE hInput,
   OMX_IN  OMX_U32 nPortInput)
{
   OMX_ERRORTYPE eError = OMX_ErrorNone;
   OMX_COMPONENTTYPE *pCompIn, *pCompOut;
   OMX_TUNNELSETUPTYPE oTunnelSetup;

   if ((hOutput == NULL && hInput == NULL) || ilcs_service == NULL)
      return OMX_ErrorBadParameter;

   oTunnelSetup.nTunnelFlags = 0;
   oTunnelSetup.eSupplier = OMX_BufferSupplyUnspecified;

   pCompOut = (OMX_COMPONENTTYPE*)hOutput;

   if (hOutput){
      eError = pCompOut->ComponentTunnelRequest(hOutput, nPortOutput, hInput, nPortInput, &oTunnelSetup);
   }

   if (eError == OMX_ErrorNone && hInput) {
      pCompIn = (OMX_COMPONENTTYPE*)hInput;
      eError = pCompIn->ComponentTunnelRequest(hInput, nPortInput, hOutput, nPortOutput, &oTunnelSetup);

      if (eError != OMX_ErrorNone && hOutput) {
         /* cancel tunnel request on output port since input port failed */
         pCompOut->ComponentTunnelRequest(hOutput, nPortOutput, NULL, 0, NULL);
      }
   }
   return eError;
}

/* OMX_GetComponentsOfRole */
OMX_ERRORTYPE OMX_GetComponentsOfRole (
   OMX_IN      OMX_STRING role,
   OMX_INOUT   OMX_U32 *pNumComps,
   OMX_INOUT   OMX_U8  **compNames)
{
   OMX_ERRORTYPE eError = OMX_ErrorNone;

   *pNumComps = 0;
   return eError;
}

/* OMX_GetRolesOfComponent */
OMX_ERRORTYPE OMX_GetRolesOfComponent (
   OMX_IN      OMX_STRING compName,
   OMX_INOUT   OMX_U32 *pNumRoles,
   OMX_OUT     OMX_U8 **roles)
{
   OMX_ERRORTYPE eError = OMX_ErrorNone;

   *pNumRoles = 0;
   return eError;
}

/* OMX_GetDebugInformation */
OMX_ERRORTYPE OMX_GetDebugInformation (
   OMX_OUT    OMX_STRING debugInfo,
   OMX_INOUT  OMX_S32 *pLen)
{
   if(ilcs_service == NULL)
      return OMX_ErrorBadParameter;

   return vcil_out_get_debug_information(ilcs_get_common(ilcs_service), debugInfo, pLen);
}



/* File EOF */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   OBJS=font.o vgft.o graphics.o
LIB=libvgfont.a

INCLUDES+=-I$(SDKSTAGE)/usr/include/freetype2 -I$(SDKSTAGE)/usr/include -I$(SDKSTAGE)/usr/include/arm-linux-gnueabi

include ../../Makefile.include

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Graphics library for VG

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "vgfont.h"
#include "graphics_x_private.h"

/******************************************************************************
Defines.
******************************************************************************/
#define ATEXT_FONT_SIZE 12 /*< Default font size (font size can be set with *_ext functions). */

/******************************************************************************
Local data
******************************************************************************/
static GX_DISPLAY_T display; /*< Our one and only EGL display. */

/**
 * We create one eglContext for each of the possible graphics_x resource types 
 * that are supported.
 ***********************************************************/
static EGLContext gx_contexts[GRAPHICS_RESOURCE_HANDLE_TYPE_MAX]; 

/** Note: we have to share all our contexts, because otherwise it seems
 * to be not valid to blit from one image to another if the images
 * have different contexts.
 *
 * That means we have to use a single global lock to serialise all accesses
 * to any contexts.
 ***********************************************************/
static VCOS_MUTEX_T lock;

static EGLConfig gx_configs[GRAPHICS_RESOURCE_HANDLE_TYPE_MAX];

static int inited;

/******************************************************************************
Local Functions
******************************************************************************/

/** Convert graphics_x colour formats into EGL format. */
static int gx_egl_attrib_colours(EGLint *attribs, GRAPHICS_RESOURCE_TYPE_T res_type)
{
   int i, n;
   static EGLint rgba[] = {EGL_RED_SIZE, EGL_GREEN_SIZE, EGL_BLUE_SIZE, EGL_ALPHA_SIZE};
   static uint8_t rgb565[] = {5,6,5,0};
   static uint8_t rgb888[] = {8,8,8,0};
   static uint8_t rgb32a[] = {8,8,8,8};

   uint8_t *sizes = NULL;

   switch (res_type)
   {
      case GRAPHICS_RESOURCE_RGB565:
         sizes = rgb565;
         break;
      case GRAPHICS_RESOURCE_RGB888:
         sizes = rgb888;
         break;
      case GRAPHICS_RESOURCE_RGBA32:
         sizes = rgb32a;
         break;
      default:
         vcos_assert(0);
         return -1;
   }
   for (n=0, i=0; i<countof(rgba); i++)
   {
      attribs[n++] = rgba[i];
      attribs[n++] = sizes[i];
   }
   return n;
}

/* Create an EGLContext for a given GRAPHICS_RESOURCE_TYPE */
static VCOS_STATUS_T create_context(EGLDisplay disp, 
                                    GRAPHICS_RESOURCE_TYPE_T image_type,
                                    EGLContext *shared_with)
{
   int n;
   EGLConfig configs[1];
   EGLint nconfigs, attribs[32];
   n = gx_egl_attrib_colours(attribs, image_type);

   // we want to be able to do OpenVG on this surface...
   attribs[n++] = EGL_RENDERABLE_TYPE; attribs[n++] = EGL_OPENVG_BIT;
   attribs[n++] = EGL_SURFACE_TYPE;    attribs[n++] = EGL_WINDOW_BIT;

   attribs[n] = EGL_NONE;

   EGLBoolean egl_ret = eglChooseConfig(disp,
                                        attribs, configs,
                                        countof(configs), &nconfigs);

   if (!egl_ret || !nconfigs)
   {
      GX_LOG("%s: no suitable configurations for res type %d",
             __FUNCTION__, image_type);
      return VCOS_EINVAL;
   }

   EGLContext cxt = eglCreateContext(disp, configs[0], *shared_with, 0);
   if (!cxt)
   {
      GX_LOG("Could not create context for image type %d: 0x%x",
             image_type, eglGetError());
      return VCOS_ENOSPC;
   }
   
   gx_contexts[image_type] = cxt;
   gx_configs[image_type] = configs[0];
   *shared_with = cxt;

   return VCOS_SUCCESS;
}

/******************************************************************************
Functions private to code inside GraphicsX
******************************************************************************/

static VCOS_STATUS_T gx_priv_initialise( void )
{
   int i;
   EGLDisplay disp;
   EGLint egl_maj, egl_min;
   int32_t ret = VCOS_EINVAL;
   EGLBoolean result;

   vcos_demand(inited == 0);

   vcos_log_set_level(&gx_log_cat, VCOS_LOG_WARN);
   vcos_log_register("graphics", &gx_log_cat);

   memset(&display,0,sizeof(display));

   gx_priv_init();

   disp = eglGetDisplay(EGL_DEFAULT_DISPLAY);

   if (disp == EGL_NO_DISPLAY)
   {
      GX_LOG("Could not open display: 0x%x", eglGetError());
      vcos_assert(0);
      goto fail_disp;
   }

   result = eglInitialize(disp, &egl_maj, &egl_min);
   if (!result)
   {
      GX_LOG("Could not init display :0x%x", eglGetError());
      vcos_assert(0); // really can't continue
      goto fail_egl_init;
   }

   result = eglBindAPI(EGL_OPENVG_API);
   vcos_assert(result); // really should succeed

   display.disp = disp;

   GX_TRACE("Supported client APIS: %s", eglQueryString(disp, EGL_CLIENT_APIS));

   // create the available contexts
   EGLContext shared_context = EGL_NO_CONTEXT;
   ret =  create_context(disp,GRAPHICS_RESOURCE_RGB565, &shared_context);
   ret |= create_context(disp,GRAPHICS_RESOURCE_RGB888, &shared_context);
   ret |= create_context(disp,GRAPHICS_RESOURCE_RGBA32, &shared_context);

   if (ret != VCOS_SUCCESS)
      goto fail_cxt;

   eglSwapInterval(disp, 1);

   inited = 1;

   return ret;

fail_cxt:
   for (i=0; i<GRAPHICS_RESOURCE_HANDLE_TYPE_MAX; i++)
   {
      if (gx_contexts[i])
      {
         eglDestroyContext(display.disp,gx_contexts[i]);
         vcos_mutex_delete(&lock);
      }
   }
   eglTerminate(display.disp);
fail_egl_init:
fail_disp:
   return ret;
}

/*****************************************************************************/
void gx_priv_save(GX_CLIENT_STATE_T *state, GRAPHICS_RESOURCE_HANDLE res)
{
   EGLBoolean egl_result;
   vcos_assert(res == NULL || (res->magic == RES_MAGIC));
   vcos_assert(res == NULL || !res->context_bound);

   state->context      = eglGetCurrentContext();
   state->api          = eglQueryAPI();
   state->read_surface = eglGetCurrentSurface(EGL_READ);
   state->draw_surface = eglGetCurrentSurface(EGL_DRAW);
   state->res = res;

   vcos_assert(state->api); // should never be anything other than VG or GL
   
   vcos_mutex_lock(&lock);

   egl_result = eglBindAPI(EGL_OPENVG_API);
   vcos_assert(egl_result);
   
   if (res)
   {
      GX_TRACE("gx_priv_save: eglMakeCurrent: %s, res %x surface %x, cxt %x", vcos_thread_get_name(vcos_thread_current()), 
         (uint32_t)res, (uint32_t)res->surface, (uint32_t)res->context);

      egl_result = eglMakeCurrent(display.disp, res->surface, 
                                  res->surface, res->context);
      vcos_assert(egl_result);
      
      res->context_bound = 1;
   }
}

/*****************************************************************************/
void gx_priv_restore(GX_CLIENT_STATE_T *state)
{
   EGLBoolean egl_result;

   GX_TRACE("gx_priv_restore: eglMakeCurrent: %s, res %x draw_surface %x, surface %x, cxt %x", vcos_thread_get_name(vcos_thread_current()),
      (uint32_t)state->res, (uint32_t)state->draw_surface, (uint32_t)state->read_surface, (uint32_t)state->context);

   // disconnect our thread from this context, so we other threads can use it via
   // this API
   egl_result = eglMakeCurrent(display.disp, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
   vcos_assert(egl_result);

   // now return to the client's API binding
   egl_result = eglBindAPI(state->api);
   vcos_assert(egl_result);

   egl_result = eglMakeCurrent(display.disp, state->draw_surface, state->read_surface, state->context);
   vcos_assert(egl_result);

   if (state->res) state->res->context_bound = 0;
   
   vcos_mutex_unlock(&lock);
}

/******************************************************************************
Functions and data exported as part of the public GraphicsX API
******************************************************************************/

VCOS_LOG_CAT_T gx_log_cat; /*< Logging category for GraphicsX. */

int32_t graphics_initialise( void )
{
   // dummy initialisation function. This is typically called
   // early in the day before VLLs are available, and so cannot
   // do anything useful.
   return 0;
}

/*****************************************************************************/
int32_t graphics_uninitialise( void )
{
   int i;
   vcos_assert(inited);

   gx_priv_font_term();

   for (i=0; i<GRAPHICS_RESOURCE_HANDLE_TYPE_MAX; i++)
      if (gx_contexts[i])
         eglDestroyContext(display.disp,gx_contexts[i]);

   eglTerminate(display.disp);
   gx_priv_destroy();
   vcos_log_unregister(&gx_log_cat);
   inited = 0;
   return 0;
}

/*****************************************************************************/
VCOS_STATUS_T gx_create_window( uint32_t screen_id,
                                uint32_t width,
                                uint32_t height,
                                GRAPHICS_RESOURCE_TYPE_T image_type,
                                GRAPHICS_RESOURCE_HANDLE *resource_handle )
{
   int rc;
   VCOS_STATUS_T status = VCOS_SUCCESS;
   GRAPHICS_RESOURCE_HANDLE h;
   EGLBoolean egl_result;
   void *cookie;
   GX_CLIENT_STATE_T save;

   if (!gx_contexts[image_type])
   {
      GX_LOG("Invalid image type %d", image_type);
      return VCOS_EINVAL;
   }

   h = vcos_calloc(1,sizeof(*h), "graphics_x_resource");
   if (!h)
   {
      GX_LOG("%s: no memory for resource", __FUNCTION__);
      return VCOS_ENOMEM;
   }

   // now need to get the native window
   rc = gx_priv_create_native_window(screen_id, 
                                     width, height, image_type,
                                     &h->u.native_window,
                                     &cookie);
   if (rc < 0)
   {
      GX_LOG("%s: could not create native window", __FUNCTION__);
      status = VCOS_ENOMEM;
      goto fail_create_native_win;
   }

   h->magic = RES_MAGIC;
   h->type  = GX_WINDOW;
   h->alpha = 1.0;

   h->surface = eglCreateWindowSurface(display.disp, gx_configs[image_type], &h->u.native_window.egl_win, NULL);
   if (!h->surface)
   {
      GX_LOG("Could not create window surface: 0x%x", eglGetError());
      status = VCOS_ENOMEM;
      goto fail_win;
   }

   egl_result = eglSurfaceAttrib(display.disp, h->surface,
      EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
   vcos_assert(egl_result);

   h->context   = gx_contexts[image_type];
   h->screen_id = screen_id;
   h->width     = width;
   h->height    = height;
   h->restype   = image_type;

   gx_priv_save(&save, h);

   // fill it with black
   status = gx_priv_resource_fill(h, 0, 0, width, height, GRAPHICS_RGBA32(0,0,0,0xff));
   vcos_assert(status == VCOS_SUCCESS);

   gx_priv_finish_native_window(h, cookie);
   gx_priv_flush(h);

   *resource_handle = h;
   gx_priv_restore(&save);
   return status;

fail_win:
   gx_priv_destroy_native_window(h);
fail_create_native_win:
   vcos_free(h);
   gx_priv_restore(&save);
   return status;
}

/*****************************************************************************/
int32_t graphics_delete_resource( GRAPHICS_RESOURCE_HANDLE res )
{
   EGLBoolean result;

   if (!res)
   {
      // let it slide - mimics old behaviour
      return 0;
   }
   GX_TRACE("delete resource @%p", res);

   vcos_assert(res->magic == RES_MAGIC);

   if (res->type == GX_PBUFFER)
   {
      GX_CLIENT_STATE_T save;
      gx_priv_save(&save, res);
      vgDestroyImage(res->u.pixmap);
      vcos_assert(vgGetError() == 0);
      gx_priv_restore(&save);
   }

   GX_TRACE("graphics_delete_resource: calling eglDestroySurface...");
   result = eglDestroySurface(display.disp, res->surface);
   vcos_assert(result);

   GX_TRACE("graphics_delete_resource: calling eglWaitClient...");
   eglWaitClient(); // wait for EGL to finish sorting out its surfaces

   if (res->type == GX_WINDOW)
   {
      GX_TRACE("graphics_delete_resource: calling gx_priv_destroy_native_window...");
      gx_priv_destroy_native_window(res);
   }

   res->magic = ~RES_MAGIC;
   vcos_free(res);
   GX_TRACE("graphics_delete_resource: done");

   return 0;
}

/*****************************************************************************/
int32_t graphics_update_displayed_resource(GRAPHICS_RESOURCE_HANDLE res,
                                           const uint32_t x_offset,
                                           const uint32_t y_offset,
                                           const uint32_t width,
                                           const uint32_t height )
{
   GX_CLIENT_STATE_T save;
   gx_priv_save(&save, res);
      
   gx_priv_flush(res);

   gx_priv_restore(&save);

   return 0;
}

/*****************************************************************************/
int32_t graphics_resource_fill(GRAPHICS_RESOURCE_HANDLE res,
                               uint32_t x,
                               uint32_t y,
                               uint32_t width,
                               uint32_t height,
                               uint32_t fill_colour )
{
   GX_CLIENT_STATE_T save;
   gx_priv_save(&save, res);
   
   VCOS_STATUS_T st = gx_priv_resource_fill(
      res, 
      x, res->height-y-height, 
      width, height, 
      fill_colour);

   gx_priv_restore(&save);
      
   return st == VCOS_SUCCESS ? 0 : -1;
}

/*****************************************************************************/
int32_t graphics_resource_render_text_ext( GRAPHICS_RESOURCE_HANDLE res,
                                           const int32_t x,
                                           const int32_t y,
                                           const uint32_t width,
                                           const uint32_t height,
                                           const uint32_t fg_colour,
                                           const uint32_t bg_colour,
                                           const char *text,
                                           const uint32_t text_length,
                                           const uint32_t text_size )
{

   /*
   * FIXME: Not at all optimal - re-renders each time.
   * FIXME: Not UTF-8 safe
   * FIXME: much better caching (or any caching)
   */
   VCOS_STATUS_T rc = gx_priv_render_text(
      &display, res, 
      x, res->height-y-text_size, width, height, fg_colour, bg_colour,
      text, text_length, text_size);

   return (rc == VCOS_SUCCESS) ? 0 : -1;
}

/*****************************************************************************/
int32_t graphics_resource_render_text(  GRAPHICS_RESOURCE_HANDLE res,
                                        const int32_t x,
                                        const int32_t y,
                                        const uint32_t width, /* this can be GRAPHICS_RESOURCE_WIDTH for no clipping */
                                        const uint32_t height, /* this can be GRAPHICS_RESOURCE_HEIGHT for no clipping */
                                        const uint32_t fg_colour,
                                        const uint32_t bg_colour,
                                        const char *text,
                                        const uint32_t text_length)
{
   return graphics_resource_render_text_ext(res, x, y, width, height,
                                            fg_colour, bg_colour,
                                            text, text_length,
                                            ATEXT_FONT_SIZE);
}

/*****************************************************************************/
int32_t graphics_get_resource_size(
   const GRAPHICS_RESOURCE_HANDLE res,
   uint32_t *w,
   uint32_t *h)
{
   if (w) *w = res->width;
   if (h) *h = res->height;
   return 0;
}

/*****************************************************************************/
int32_t graphics_get_resource_type(const GRAPHICS_RESOURCE_HANDLE res, GRAPHICS_RESOURCE_TYPE_T *type)
{
   if (type) *type = res->restype;
   return 0;
}

/*****************************************************************************/
int32_t graphics_bitblt( const GRAPHICS_RESOURCE_HANDLE src,
                         const uint32_t x, // offset within source
                         const uint32_t y, // offset within source
                         const uint32_t width,
                         const uint32_t height,
                         GRAPHICS_RESOURCE_HANDLE dest,
                         const uint32_t x_pos,
                         const uint32_t y_pos )
{
   int rc = -1;
   VGfloat old[9];
   uint32_t w, h;
   VGPaint paint = VG_INVALID_HANDLE;
   GX_CLIENT_STATE_T save;
   int is_child = 0;
   VGImage img = VG_INVALID_HANDLE;

   gx_priv_save(&save, dest);

   if (src->type != GX_PBUFFER)
   {
      vcos_assert(0);
      goto finish;
   }

   // create a child image that contains just the part wanted
   w = width == GRAPHICS_RESOURCE_WIDTH ? src->width : width;
   h = height == GRAPHICS_RESOURCE_HEIGHT ? src->height : height;

   if (x==0 && y==0 && 
       w == src->width &&
       h == src->height)
   {
      img = src->u.pixmap;
   }
   else
   {
      is_child = 1;
      img = vgChildImage(src->u.pixmap, x, y, w, h);
      if (img == VG_INVALID_HANDLE)
      {
         vcos_assert(0);
         goto finish;
      }
   }

   vcos_assert(vgGetError()==0);

   vgSeti(VG_MATRIX_MODE, VG_MATRIX_IMAGE_USER_TO_SURFACE);
   vgGetMatrix(old);
   vgLoadIdentity();
   vgTranslate((VGfloat)x_pos, (VGfloat)(dest->height-y_pos));
   vgScale(1.0, -1.0);

   // Do we have a translucency going on?
   if (src->alpha != 1.0)
   {
      VGfloat colour[4] = {1.0,1.0,1.0,src->alpha};
      paint = vgCreatePaint();

      vgSetParameterfv(paint, VG_PAINT_COLOR, 4, colour);
      vgSeti(VG_IMAGE_MODE, VG_DRAW_IMAGE_MULTIPLY);
      vgSetPaint(paint, VG_STROKE_PATH | VG_FILL_PATH);
   }
   vcos_assert(vgGetError()==0);

   vgDrawImage(img);
   vcos_assert(vgGetError()==0);
   vgLoadMatrix(old);

   int err = vgGetError();

   if (err)
   {
      GX_LOG("vg error %x blitting area", err);
      vcos_assert(0);
      rc = -1;
   }
   else
   {
      rc = 0;
   }
finish:
   if (paint != VG_INVALID_HANDLE)
      vgDestroyPaint(paint);

   if (is_child)
      vgDestroyImage(img);

   gx_priv_restore(&save);
   return rc;
}

void gx_priv_flush(GRAPHICS_RESOURCE_HANDLE res)
{
   EGLBoolean result;
   result = eglSwapBuffers(display.disp, res->surface);
   vcos_assert(result);
}


/** Map a colour, which the client will have supplied in RGB888.
 */

void gx_priv_colour_to_paint(uint32_t col, VGfloat *rgba)
{
   // with OpenVG we use RGB order.
   rgba[0] = ((VGfloat)((col & R_888_MASK) >> 16 )) / 0xff;
   rgba[1] = ((VGfloat)((col & G_888_MASK) >> 8 )) / 0xff;
   rgba[2] = ((VGfloat)((col & B_888_MASK) >> 0 )) / 0xff;
   rgba[3] = ((VGfloat)((col & ALPHA_888_MASK) >> 24)) / 0xff;
}

/** Fill an area of a surface with a fixed colour.
  */
VCOS_STATUS_T gx_priv_resource_fill(GRAPHICS_RESOURCE_HANDLE res,
                               uint32_t x,
                               uint32_t y,
                               uint32_t width,
                               uint32_t height,
                               uint32_t fill_colour )
{
   VGfloat vg_clear_colour[4];

   gx_priv_colour_to_paint(fill_colour, vg_clear_colour);
   vgSeti(VG_SCISSORING, VG_FALSE);

   vgSetfv(VG_CLEAR_COLOR, 4, vg_clear_colour);
   vgClear(x, y, width, height);

   int err = vgGetError();
   if (err)
   {
      GX_LOG("vg error %x filling area", err);
      vcos_assert(0);
   }

   return VCOS_SUCCESS;
}

VCOS_STATUS_T gx_priv_get_pixels(const GRAPHICS_RESOURCE_HANDLE res, void **p_pixels, GX_RASTER_ORDER_T raster_order)
{
   VCOS_STATUS_T status = VCOS_SUCCESS;
   void *pixels, *dest;
   uint32_t width, height;
   int data_size, pitch;
   VGImageFormat image_format;
 
   if (!p_pixels)
   {
      status = VCOS_EINVAL;
      goto finish;
   }

   GX_TRACE("%s: res %p", __FUNCTION__, res);

   graphics_get_resource_size(res, &width, &height);

   /* FIXME: implement e.g. gx_get_pitch */
   switch (res->restype)
   {
      case GRAPHICS_RESOURCE_RGB565:
         pitch = ((width + 31)&(~31)) << 1;
         break;
      case GRAPHICS_RESOURCE_RGB888:
      case GRAPHICS_RESOURCE_RGBA32:
         pitch = ((width + 31)&(~31)) << 2;
         break;
      default:
      {
         GX_LOG("Unsupported pixel format");
         status = VCOS_EINVAL;
         goto finish;
      }
   }
   
   data_size = pitch * height;

   /* NB: vgReadPixels requires that the data pointer is aligned, but does not 
      require the stride to be aligned. Most implementations probably will 
      require that as well though... */
   pixels = vcos_malloc(data_size, "gx_get_pixels data");
   if (!pixels)
   {
      GX_LOG("Could not allocate %d bytes for vgReadPixels", data_size);
      status = VCOS_ENOMEM;
      goto finish;
   }
   /* FIXME: introduce e.g. GX_COLOR_FORMAT and mapping to VGImageFormat... */

   /* Hand out image data formatted to match OpenGL RGBA format.
    */
   switch (res->restype)
   {
      case GRAPHICS_RESOURCE_RGB565:
         image_format = VG_sBGR_565;
         break;
      case GRAPHICS_RESOURCE_RGB888:
         image_format = VG_sXBGR_8888;
         break;
      case GRAPHICS_RESOURCE_RGBA32:
         image_format = VG_sABGR_8888;
         break;
      default:
      {
         GX_LOG("Unsupported pixel format");
         status = VCOS_EINVAL;
         goto finish;
      }
   }   

   /* VG raster order is bottom-to-top */
   if (raster_order == GX_TOP_BOTTOM)
   {
      dest = ((uint8_t*)pixels)+(pitch*(height-1));
      pitch = -pitch;
   }
   else
   {
      dest = pixels;
   }

   vgReadPixels(dest, pitch, image_format, 0, 0, width, height);

   vcos_assert(vgGetError() == 0);
   
   *p_pixels = pixels;

finish:
   return status;
}

static VCOS_STATUS_T convert_image_type(GRAPHICS_RESOURCE_TYPE_T image_type,
                                        VGImageFormat *vg_image_type,
                                        int *pbytes_per_pixel)
{
   int bytes_per_pixel;

   switch (image_type)
   {
   case GRAPHICS_RESOURCE_RGB565:
      *vg_image_type = VG_sRGB_565;
      bytes_per_pixel = 2;
      break;
   case GRAPHICS_RESOURCE_RGB888:
      *vg_image_type = VG_sRGBX_8888;
      bytes_per_pixel = 3; // 24 bpp
      break;
   case GRAPHICS_RESOURCE_RGBA32:
      *vg_image_type = VG_sARGB_8888;
      bytes_per_pixel = 4;
      break;
   default:
      vcos_assert(0);
      *vg_image_type = 0;
      return VCOS_EINVAL;
   }
   if (pbytes_per_pixel)
      *pbytes_per_pixel = bytes_per_pixel;

   return VCOS_SUCCESS;
}


/*****************************************************************************/
VCOS_STATUS_T gx_create_pbuffer( uint32_t width,
                                uint32_t height,
                                GRAPHICS_RESOURCE_TYPE_T image_type,
                                GRAPHICS_RESOURCE_HANDLE *resource_handle )
{
   VCOS_STATUS_T status = VCOS_SUCCESS;
   GRAPHICS_RESOURCE_HANDLE h;
   VGImage image;
   VGImageFormat vg_image_type;
   GX_CLIENT_STATE_T save;

   h = vcos_calloc(1,sizeof(*h), "graphics_x_resource");
   if (!h)
   {
      GX_LOG("%s: no memory for resource", __FUNCTION__);
      return VCOS_ENOMEM;
   }

   status = convert_image_type(image_type, &vg_image_type, NULL);
   if (status != VCOS_SUCCESS)
   {
      vcos_free(h);
      return status;
   }

   h->magic     = RES_MAGIC;
   h->context   = gx_contexts[image_type];
   h->config    = gx_configs[image_type];
   h->alpha     = 1.0;
   h->type      = GX_PBUFFER;
   h->width     = width;
   h->height    = height;
   h->restype   = image_type;

   GX_TRACE("Creating pbuffer surface");

   EGLint attribs[] = {EGL_WIDTH, width, EGL_HEIGHT, height, EGL_NONE};
   h->surface = eglCreatePbufferSurface(display.disp, h->config, 
                                        attribs);
   if (!h->surface)
   {
      GX_LOG("Could not create EGL pbuffer surface: 0x%x", eglGetError());
      vcos_free(h);
      return VCOS_EINVAL;
   }

   gx_priv_save(&save, h);

   image = vgCreateImage(vg_image_type, width, height, VG_IMAGE_QUALITY_BETTER);
   if (image == VG_INVALID_HANDLE)
   {
      GX_LOG("Could not create vg image type %d: vg error 0x%x",
             vg_image_type, vgGetError());
      eglDestroySurface(display.disp, h->surface);
      vcos_free(h);
      status = VCOS_ENOMEM;
      goto finish;
   }
 
   h->u.pixmap  = image;
 
   // fill it with black
   status = gx_priv_resource_fill(h, 0, 0, width, height, GRAPHICS_RGBA32(0,0,0,0xff));
   vcos_assert(status == VCOS_SUCCESS);

   *resource_handle = h;
finish:
   gx_priv_restore(&save);
   return status;
}

/*****************************************************************************/
GX_PAINT_T *gx_create_gradient(GRAPHICS_RESOURCE_HANDLE res,
                               uint32_t start_colour,
                               uint32_t end_colour)
{
   // holds  the two colour stops (offset,r,g,b,a).
   VGfloat fill_stops[10];
   GX_CLIENT_STATE_T save;
   VGPaint paint = VG_INVALID_HANDLE;

   gx_priv_save(&save, res);

   paint = vgCreatePaint();
   if (!paint)
   {
      gx_priv_restore(&save);
      vcos_log("Could not create paint: vg %d\n", vgGetError());
      vcos_assert(0);
      goto finish;
   }

   fill_stops[0] = 0.0;
   gx_priv_colour_to_paint(start_colour, fill_stops+1);

   fill_stops[5] = 1.0;
   gx_priv_colour_to_paint(end_colour, fill_stops+6);

   vgSetParameteri(paint, VG_PAINT_TYPE, VG_PAINT_TYPE_LINEAR_GRADIENT);
   vgSetParameterfv(paint, VG_PAINT_COLOR_RAMP_STOPS, 5*2, fill_stops);

finish:
   gx_priv_restore(&save);
   return (GX_PAINT_T*)paint;
}

/*****************************************************************************/
void gx_destroy_paint(GRAPHICS_RESOURCE_HANDLE res, GX_PAINT_T *p)
{
   GX_CLIENT_STATE_T save;
   VGPaint paint = (VGPaint)p;
   gx_priv_save(&save, res);
   vgDestroyPaint(paint);
   gx_priv_restore(&save);
}

/*****************************************************************************/
VCOS_STATUS_T gx_fill_gradient(GRAPHICS_RESOURCE_HANDLE dest,
                               uint32_t x, uint32_t y,
                               uint32_t width, uint32_t height,
                               uint32_t radius,
                               GX_PAINT_T *p)
{
   /* Define start and end points of gradient, see OpenVG specification, 
      section 9.3.3. */
   VGfloat gradient[4] = {0.0, 0.0, 0.0, 0.0};
   VGPaint paint = (VGPaint)p;
   VGPath path;
   GX_CLIENT_STATE_T save;
   VCOS_STATUS_T status = VCOS_SUCCESS;

   if (!paint)
      return VCOS_EINVAL;

   gx_priv_save(&save, dest);

   if (width == GRAPHICS_RESOURCE_WIDTH)
      width = dest->width;

   if (height == GRAPHICS_RESOURCE_HEIGHT)
      height = dest->height;

   gradient[2] = width;

   vgSetParameterfv(paint, VG_PAINT_LINEAR_GRADIENT, 4, gradient);
   vgSetPaint(paint, VG_FILL_PATH);

   path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_S_32,
                       1.0, 0.0, 8, 8, VG_PATH_CAPABILITY_ALL);
   if (!path)
   {
      status = VCOS_ENOMEM;
      goto finish;
   }

   vguRoundRect(path, (VGfloat)x, (VGfloat)y, (VGfloat)width, (VGfloat)height,
                (VGfloat)radius, (VGfloat)radius);
   vgDrawPath(path, VG_FILL_PATH);
   vgDestroyPath(path);

   vcos_assert(vgGetError() == 0);
   
finish:
   gx_priv_restore(&save);

   return status;
}

/*****************************************************************************/
VCOS_STATUS_T gx_graphics_init(const char *font_dir)
{
   GX_CLIENT_STATE_T save;
   VCOS_STATUS_T rc;
   
   gx_priv_save(&save, NULL);
   
   rc = gx_priv_initialise();
   if (rc == VCOS_SUCCESS)
      rc = gx_priv_font_init(font_dir);

   gx_priv_restore(&save);
   
   return rc;
}

/*****************************************************************************/
int gx_is_double_buffered(void)
{
   return 1;
}

/*****************************************************************************/
int32_t graphics_userblt(GRAPHICS_RESOURCE_TYPE_T src_type,
                         const void *src_data,
                         const uint32_t src_x,
                         const uint32_t src_y,
                         const uint32_t width,
                         const uint32_t height,
                         const uint32_t pitch,
                         GRAPHICS_RESOURCE_HANDLE dest,
                         const uint32_t x_pos,
                         const uint32_t y_pos )
{
   VCOS_STATUS_T status;
   VGImageFormat vg_src_type;
   int bytes_per_pixel;
   GX_CLIENT_STATE_T save;
   
   status = convert_image_type(src_type, &vg_src_type, &bytes_per_pixel);
   if (status != VCOS_SUCCESS)
      return status;

   gx_priv_save(&save, dest);

   if (dest->type == GX_PBUFFER)
   {
      vgImageSubData(dest->u.pixmap,
                     src_data,
                     pitch,
                     vg_src_type,
                     x_pos, y_pos, width, height);
   }
   else if (dest->type == GX_WINDOW)
   {
      // need to invert this as VG thinks zero is at the bottom
      // while graphics_x thinks it is at the top.
      vgWritePixels((uint8_t*)src_data + pitch*(height-1),
                    -pitch,
                    vg_src_type,
                    x_pos, dest->height-y_pos-height, width, height);
   }
   else
   {
      vcos_assert(0);
   }

   if (vgGetError() == 0)
      status = VCOS_SUCCESS;
   else
   {
      vcos_assert(0);
      status = VCOS_EINVAL;
   }

   gx_priv_restore(&save);
   return status;
}

/*****************************************************************************/
int32_t graphics_resource_text_dimensions( GRAPHICS_RESOURCE_HANDLE resource_handle,
                                           const char *text,
                                           const uint32_t text_length,
                                           uint32_t *width,
                                           uint32_t *height )
{
   return graphics_resource_text_dimensions_ext(resource_handle, text, text_length, width, height, ATEXT_FONT_SIZE);
}

/*****************************************************************************/
VCOS_STATUS_T gx_render_arrowhead(GRAPHICS_RESOURCE_HANDLE res,
                                  uint32_t tip_x, uint32_t tip_y, 
                                  int32_t w, int32_t h,
                                  GX_PAINT_T *p)
{
   VGfloat gradient[4];
   VGPaint paint = (VGPaint)p;
   VGPath path;
   VCOS_STATUS_T status = VCOS_SUCCESS;

   GX_CLIENT_STATE_T save;
   gx_priv_save(&save, res);

   if (!paint)
   {
      vcos_assert(0);
      status = VCOS_EINVAL;
      goto finish;
   }

   gradient[0] = 0.0; gradient[1] = 0.0;
   gradient[2] = w; gradient[2] = 0.0;

   vgSetParameterfv(paint, VG_PAINT_LINEAR_GRADIENT, 4, gradient);
   vgSetPaint(paint, VG_FILL_PATH);

   path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_S_32,
                       1.0, 0.0, 8, 8, VG_PATH_CAPABILITY_ALL);
   if (!path)
   {
      status = VCOS_ENOMEM;
      goto finish;
   }
   VGfloat points[] = {
      (VGfloat)tip_x, (VGfloat)tip_y,
      (VGfloat)tip_x + w, (VGfloat)tip_y + h/2,
      (VGfloat)tip_x + w, (VGfloat)tip_y - h/2,
   };

   vguPolygon(path, points, 3, 1);

   vgDrawPath(path, VG_FILL_PATH);
   vgDestroyPath(path);

   vcos_assert(vgGetError()==0);

finish:
   gx_priv_restore(&save);
   return status;
}

/*****************************************************************************/
int32_t gx_apply_alpha( GRAPHICS_RESOURCE_HANDLE resource_handle,
                        const uint8_t alpha )
{
   vcos_assert(resource_handle);
   if (resource_handle->type != GX_PBUFFER)
   {
      vcos_assert(0);
      return -1;
   }
   resource_handle->alpha = 1.0*alpha/255;
   return 0;
}

/*****************************************************************************/
int32_t graphics_resource_set_alpha_per_colour( GRAPHICS_RESOURCE_HANDLE res,
                                                const uint32_t colour,
                                                const uint8_t alpha )
{
   GX_ERROR("Not implemented yet!");
   return 0;
}

/*****************************************************************************/
VCOS_STATUS_T gx_get_pixels(const GRAPHICS_RESOURCE_HANDLE res, void **pixels)
{
   VCOS_STATUS_T status = VCOS_SUCCESS;
   GX_CLIENT_STATE_T save;
   gx_priv_save(&save, res);
   
   /* Default to top-top-bottom raster scan order */
   status = gx_priv_get_pixels(res, pixels, GX_TOP_BOTTOM);
   
   gx_priv_restore(&save);
   return status;
}

/*****************************************************************************/
VCOS_STATUS_T gx_get_pixels_in_raster_order(const GRAPHICS_RESOURCE_HANDLE res, 
                                            void **pixels, 
                                            GX_RASTER_ORDER_T raster_order)
{
   VCOS_STATUS_T status = VCOS_SUCCESS;
   GX_CLIENT_STATE_T save;
   gx_priv_save(&save, res);
   
   status = gx_priv_get_pixels(res, pixels, raster_order);
   
   gx_priv_restore(&save);
   return status;
}

/*****************************************************************************/
void gx_free_pixels(const GRAPHICS_RESOURCE_HANDLE res, void *pixels)
{
   vcos_free(pixels);
}

VCOS_STATUS_T gx_bind_vg( GX_CLIENT_STATE_T *save, GRAPHICS_RESOURCE_HANDLE res )
{
   gx_priv_save(save, res);
   vcos_assert(vgGetError()==0);
   return VCOS_SUCCESS;
}

/** Unbind VG */
void gx_unbind_vg(GX_CLIENT_STATE_T *restore)
{
   gx_priv_restore(restore);
}


GX_CLIENT_STATE_T *gx_alloc_context(void)
{
   GX_CLIENT_STATE_T *ret = vcos_calloc(1,sizeof(*ret), "gx_client_state");
   return ret;
}

void gx_free_context(GX_CLIENT_STATE_T *state)
{
   vcos_free(state);
}

void gx_convert_colour(uint32_t colour, float *dest)
{
   gx_priv_colour_to_paint(colour, dest);
}


#define MAX_DISPLAY_HANDLES  4

#define CHANGE_LAYER    (1<<0)
#define CHANGE_OPACITY  (1<<1)
#define CHANGE_DEST     (1<<2)
#define CHANGE_SRC      (1<<3)
#define CHANGE_MASK     (1<<4)
#define CHANGE_XFORM    (1<<5)

typedef struct
{
   /** Keep a display handle going for each connected screen (LCD, HDMI). */
   DISPMANX_DISPLAY_HANDLE_T screens[MAX_DISPLAY_HANDLES];
   int refcounts[MAX_DISPLAY_HANDLES];

   //a flag to count the number of dispman starts that have been invoked

   uint32_t dispman_start_count;
   // maintain the single global handle to the update in progress
   DISPMANX_UPDATE_HANDLE_T current_update;

   VCOS_MUTEX_T lock;
} gx_priv_state_t;

static gx_priv_state_t gx;

void gx_priv_init(void)
{
   vcos_mutex_create(&gx.lock,NULL);
}

void gx_priv_destroy(void)
{
   vcos_mutex_delete(&gx.lock);
}


static
int32_t gx_priv_open_screen(uint32_t index, DISPMANX_DISPLAY_HANDLE_T *pscreen)
{
   int ret = -1;
   vcos_mutex_lock(&gx.lock);

   if (gx.refcounts[index] != 0)
   {
      *pscreen = gx.screens[index];
      gx.refcounts[index]++;
      ret = 0;
   }
   else
   {
      DISPMANX_DISPLAY_HANDLE_T h = vc_dispmanx_display_open(index);
      if (h == DISPMANX_NO_HANDLE)
      {
         GX_LOG("Could not open dispmanx display %d", index);
         ret = -1;
         goto finish;
      }
      gx.screens[index] = h;
      gx.refcounts[index] = 1;
      *pscreen = h;
      ret = 0;
   }
finish:
   vcos_mutex_unlock(&gx.lock);
   return ret;
}

static
int32_t gx_priv_release_screen(uint32_t index)
{
   vcos_mutex_lock(&gx.lock);
   gx.refcounts[index]--;
   if (gx.refcounts[index] == 0)
   {
      vc_dispmanx_display_close(gx.screens[index]);
      gx.screens[index] = DISPMANX_NO_HANDLE;
   }
   vcos_mutex_unlock(&gx.lock);
   return 0;
}




int gx_priv_create_native_window(uint32_t screen_id,
                                 uint32_t w, uint32_t h,
                                 GRAPHICS_RESOURCE_TYPE_T type,
                                 GX_NATIVE_WINDOW_T *win,
                                 void **cookie)
{
   int rc;
   DISPMANX_DISPLAY_HANDLE_T dispmanx_display;
   VC_RECT_T dst_rect;
   VC_RECT_T src_rect;
   DISPMANX_UPDATE_HANDLE_T current_update;
   *cookie = NULL;

   rc = gx_priv_open_screen(screen_id, &dispmanx_display);
   if (rc < 0)
   {
      GX_LOG("Could not open display %d", screen_id);
      goto fail_screen;
   }

   current_update = vc_dispmanx_update_start(0);
   if (!current_update)
   {
      GX_LOG("Could not start update on screen %d", screen_id);
      goto fail_update;
   }
   
   src_rect.x = src_rect.y = 0;
   src_rect.width = w << 16;
   src_rect.height = h << 16;

   dst_rect.x = dst_rect.y = 0;
   dst_rect.width = dst_rect.height = 1;
   
   win->egl_win.width = w;
   win->egl_win.height = h;
   VC_DISPMANX_ALPHA_T alpha;
   memset(&alpha, 0x0, sizeof(VC_DISPMANX_ALPHA_T));
   alpha.flags = DISPMANX_FLAGS_ALPHA_FROM_SOURCE;

   DISPMANX_CLAMP_T clamp;
   memset(&clamp, 0x0, sizeof(DISPMANX_CLAMP_T));

   win->egl_win.element = vc_dispmanx_element_add(current_update, dispmanx_display,
      0 /* layer */, &dst_rect, 
      0 /* src */, &src_rect, 
      DISPMANX_PROTECTION_NONE,
      &alpha /* alpha */,
      &clamp /* clamp */,
      0 /* transform */);

   if ( !win->egl_win.element )
   {
      GX_LOG("Could not add element %dx%d",w,h);
      vc_dispmanx_update_submit_sync(current_update);
      rc = -1;
   }

   // have to pass back the update so it can be completed *After* the
   // window has been initialised (filled with background colour).
   *cookie = (void*)current_update;

   return 0;

fail_update:
   gx_priv_release_screen(screen_id);
fail_screen:
   return rc;
}

void gx_priv_finish_native_window(GRAPHICS_RESOURCE_HANDLE_TABLE_T *res,
                                  void *current_update)
{
   vc_dispmanx_update_submit_sync((DISPMANX_UPDATE_HANDLE_T)current_update);
}

void
gx_priv_destroy_native_window(GRAPHICS_RESOURCE_HANDLE_TABLE_T *res)
{
   DISPMANX_UPDATE_HANDLE_T current_update;

   if((current_update = vc_dispmanx_update_start(0)) != 0)
   {
      int ret = vc_dispmanx_element_remove(current_update, res->u.native_window.egl_win.element);
      vcos_assert(ret == 0);
      ret = vc_dispmanx_update_submit_sync(current_update);
      vcos_assert(ret == 0);
   }

   gx_priv_release_screen(res->screen_id);
}


/***********************************************************
 * Name: graphics_get_display_size
 *
 * Arguments:
 *       void
 *
 * Description: Return size of display
 *
 * Returns: int32_t:
 *               >=0 if it succeeded
 *
 ***********************************************************/
int32_t graphics_get_display_size( const uint16_t display_number,
                                   uint32_t *width,
                                   uint32_t *height)
{
   DISPMANX_MODEINFO_T mode_info;
   int32_t success = -1;
   DISPMANX_DISPLAY_HANDLE_T disp;
   vcos_assert(width && height);
   *width = *height = 0;

   if(vcos_verify(display_number < MAX_DISPLAY_HANDLES))
   {
      // TODO Shouldn't this close the display if it wasn't previously open?
      if (gx_priv_open_screen(display_number, &disp) < 0)
      {
         vcos_assert(0);
         return -1;
      }
      success = vc_dispmanx_display_get_info(disp, &mode_info);

      if( success >= 0 )
      {
         *width = mode_info.width;
         *height = mode_info.height;
         vcos_assert(*height > 64);
      }
      else
      {
         vcos_assert(0);
      }
   }

   return success;
}

static inline uint16_t auto_size(uint16_t arg, uint16_t actual_size)
{
   return arg == GRAPHICS_RESOURCE_WIDTH ? actual_size : arg;
}

int32_t graphics_display_resource( GRAPHICS_RESOURCE_HANDLE res,
                                   const uint16_t screen_number,
                                   const int16_t z_order,
                                   const uint16_t offset_x,
                                   const uint16_t offset_y,
                                   const uint16_t dest_width,
                                   const uint16_t dest_height,
                                   const VC_DISPMAN_TRANSFORM_T transform,
                                   const uint8_t display )
{
   DISPMANX_UPDATE_HANDLE_T update;
   int32_t rc;
   int xform_changed;

   if (!res)
   {
      // mimics old behaviour.
      (void)vcos_verify(0);
      return 0;
   }
   vcos_assert(res->magic == RES_MAGIC);

   xform_changed = transform != res->transform;
   res->transform = transform;

   rc = graphics_update_start();
   update = gx.current_update;
   vcos_assert(rc == 0);

   if (display)
   {
      VC_RECT_T src_rect, dest_rect;

      int32_t src_width = res->width;
      int32_t src_height = res->height;

      uint32_t change_flags = CHANGE_LAYER;

      // has the destination position changed?
      uint32_t w = auto_size(dest_width, res->width);
      uint32_t h = auto_size(dest_height, res->height);

      vcos_assert(screen_number == res->screen_id);

      if (gx.screens[screen_number] == 0)
      {
         vcos_assert(0);
         DISPMANX_DISPLAY_HANDLE_T display_handle;
         gx_priv_open_screen(screen_number, &display_handle);
      }

      if ((offset_x != res->dest.x) ||
          (offset_y != res->dest.y) ||
          (h != res->dest.height) ||
          (w != res->dest.width))
      {
         change_flags |= CHANGE_DEST;
         res->dest.x      = offset_x;
         res->dest.y      = offset_y;
         res->dest.height = h;
         res->dest.width  = w;
      }

      if (xform_changed)
         change_flags |= CHANGE_XFORM;

      vc_dispmanx_rect_set( &src_rect, 0, 0, ((uint32_t)src_width)<<16, ((uint32_t)src_height)<<16 );
      vc_dispmanx_rect_set( &dest_rect, offset_x, offset_y, w, h);

      rc = vc_dispmanx_element_change_attributes(update,
         res->u.native_window.egl_win.element,
         change_flags,
         z_order, /* layer */
         0xff, /* opacity */
         &dest_rect,
         &src_rect,
         0, transform);

      vcos_assert(rc==0);
      gx_priv_flush(res);

   }
   else
   {
      vgFinish();
      eglWaitClient();
      rc = vc_dispmanx_element_change_source(update, res->u.native_window.egl_win.element, 0);
      vcos_assert(rc==0);
   }

   rc = graphics_update_end();
   vcos_assert(rc==0);

   return rc;
}

/***********************************************************
 * Name: graphics_update_start
 *
 * Arguments:
 *       void
 *
 * Description: Starts an update UNLESS and update is already in progress
 *
 * Returns: int32_t:
 *               >=0 if it succeeded
 *
 ***********************************************************/
int32_t graphics_update_start(void)
{
   int32_t success = 0;

   //check we are not already in an update
   if ( 0 == gx.dispman_start_count )
   {
      gx.current_update = vc_dispmanx_update_start( 10 );
      if( gx.current_update == DISPMANX_NO_HANDLE )
      {
         //error
         success = -1;
         vc_assert( 0 );
      }
   }

   if( success == 0 )
   {
      //inc the counter
      gx.dispman_start_count++;
   }

   return success;
}


/***********************************************************
 * Name: graphics_update_end
 *
 * Arguments:
 *       void
 *
 * Description: Ends an update UNLESS more than one update is in progress
 *
 * Returns: int32_t:
 *               >=0 if it succeeded
 *
 ***********************************************************/
int32_t graphics_update_end( void )
{
   int32_t success = -1;

   // make sure you are checking the return value of graphics_update_start
   if(vcos_verify(gx.current_update != DISPMANX_NO_HANDLE))
   {
      //check we are in an update
      if(vcos_verify(gx.dispman_start_count > 0))
      {
         //dec the counter
         gx.dispman_start_count--;

         success = 0;

         //is the counter now 0?
         if( 0 == gx.dispman_start_count )
         {
            eglWaitClient();
            if( vc_dispmanx_update_submit_sync( gx.current_update ) != 0 )
            {
               //error
               success = -1;
               vc_assert( 0 );
            }
         }
      }
   }

   return success;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Graphics library for VG

#ifndef GRAPHICS_X_PRIVATE_H
#define GRAPHICS_X_PRIVATE_H

#define VCOS_LOG_CATEGORY (&gx_log_cat)

#include "EGL/egl.h"
#include "EGL/eglext.h"
#include "VG/openvg.h"
#include "VG/vgu.h"

#include "vgfont.h"
#include "bcm_host.h"

extern VCOS_LOG_CAT_T gx_log_cat;

#define LOG_ERR( fmt, arg... )   vcos_log_error( "%s:%d " fmt, __func__, __LINE__, ##arg)

#define GX_ERROR(format, arg...) if (1) {} else printf( format "\n", ##arg)
#define GX_LOG(format, arg...) if (1) {} else printf( format "\n", ##arg)
#define GX_TRACE(format, arg...) if (1) {} else printf( format "\n", ##arg)

typedef struct
{
   EGL_DISPMANX_WINDOW_T egl_win;
} GX_NATIVE_WINDOW_T;

typedef enum
{
   GX_TOP_BOTTOM,
   GX_BOTTOM_TOP,
} GX_RASTER_ORDER_T;

typedef struct {} GX_PAINT_T;

typedef struct GX_CLIENT_STATE_T GX_CLIENT_STATE_T;
typedef struct {
   EGLDisplay disp;
} GX_DISPLAY_T;

struct GX_DISPLAY_T
{
   EGLDisplay disp;
};

typedef enum
{
   GX_WINDOW, GX_PIXMAP, GX_PBUFFER
} GX_RES_TYPE;

#define RES_MAGIC ('G'<<24|'X'<<16|'R'<<8|'S'<<0)
#define GX_PRIV_FLAG_FLIP (1<<0)

/**
 * Structure encapsulating the per-surface state.
 ***********************************************************/
typedef struct GRAPHICS_RESOURCE_HANDLE_TABLE_T
{
   union
   {
      GX_NATIVE_WINDOW_T native_window;
      VGImage pixmap;
   } u;
   GX_RES_TYPE type;

   uint32_t magic;         /** To work around broken create interface */
   int context_bound;
   const char *last_caller;
   EGLSurface surface;
   EGLContext context;
   EGLConfig config;
   uint32_t screen_id;     /** 0-LCD, etc */
   uint16_t width;
   uint16_t height;
   GRAPHICS_RESOURCE_TYPE_T restype;
   VC_DISPMAN_TRANSFORM_T transform;

   VC_RECT_T dest;         /** destination rectangle in use, for book-keeping */

   VGfloat alpha;
} GRAPHICS_RESOURCE_HANDLE_TABLE_T;

/**
 * Structure used to store an EGL client state. 
 ***********************************************************/
struct GX_CLIENT_STATE_T
{
   EGLSurface read_surface;
   EGLSurface draw_surface;
   EGLContext context;
   EGLenum api;
   GRAPHICS_RESOURCE_HANDLE res;
};

/**
 * \fixme add documentation
 *
 ***********************************************************/ 
void gx_priv_init(void);

/**
 * \fixme add documentation
 *
 ***********************************************************/ 
void gx_priv_destroy(void);

/**
 * \fixme add documentation
 *
 * @param col colour
 *
 * @param rgba OpenVG paint colour
 *
 ***********************************************************/ 
void gx_priv_colour_to_paint(uint32_t col, VGfloat *rgba);

/** 
 * Save current EGL client state.
 *
 * @param state upon return, holds the saved EGL client state.
 *
 * @param res handle to the surface the EGL client state belongs to (may be <code>NULL</code>).
 * 
 */
void gx_priv_save(GX_CLIENT_STATE_T *state, GRAPHICS_RESOURCE_HANDLE res);

/** 
 * Restore current EGL client state.
 *
 * @param state the EGL client state to restore.
 * 
 */
void gx_priv_restore(GX_CLIENT_STATE_T *state);

/** 
 * Create a native window for a surface.
 *
 * @param screen_id \fixme
 * 
 * @param w width of the window
 *
 * @param h height of the window
 *
 * @param type color/raster format of the resource
 *
 * @param win upon successful return, holds a handle to the native window
 *
 * @param cookie \fixme
 *
 * @return VCOS_SUCCESS on success, or error code.
 */
int gx_priv_create_native_window(uint32_t screen_id,
                                 uint32_t w, uint32_t h,
                                 GRAPHICS_RESOURCE_TYPE_T type,
                                 GX_NATIVE_WINDOW_T *win,
                                 void **cookie);

/** 
 * Destroy native window bound to surface.
 *
 * @param res Handle to surface.
 * 
 */
void gx_priv_destroy_native_window(GRAPHICS_RESOURCE_HANDLE_TABLE_T *res);

/** 
 * Initialise font from the given directory.
 *
 * @param font_dir path to font
 * 
 * \fixme only supports Vera.tff at the moment?
 *
 * @return VCOS_SUCCESS on success, or error code.
 */
VCOS_STATUS_T gx_priv_font_init(const char *font_dir);

/**
 * \fixme add documentation
 *
 ***********************************************************/ 
void gx_priv_font_term(void);

/**
 * Fill an area of a surface with a single colour.
 *
 * @param res Handle to surface.
 *
 * @param x x-offset of area to fill
 * 
 * @param y y-offset of area to fill
 *
 * @param width width of area to fill
 *
 * @param height height of area to fill
 *
 * @param fill_colour fill colour
 *
 ***********************************************************/
VCOS_STATUS_T gx_priv_resource_fill(GRAPHICS_RESOURCE_HANDLE res,
                               uint32_t x,
                               uint32_t y,
                               uint32_t width,
                               uint32_t height,
                               uint32_t fill_colour );

/**
 * Render text into a surface
 *
 * @param disp Handle to display.
 *
 * @param res Handle to surface.
 *
 * @param x x-offset
 *
 * @param y y-offset
 *
 * @param width bounding rectangle width
 *
 * @param height bounding rectangle height
 *
 * @param fg_colour foreground color
 *
 * @param bg_colour background color
 *
 * @param text text to render
 *
 * @param text_length length of text
 *
 * @param text_size size of text
 *
 ***********************************************************/
VCOS_STATUS_T gx_priv_render_text( GX_DISPLAY_T *disp,
                                   GRAPHICS_RESOURCE_HANDLE res,
                                   int32_t x,
                                   int32_t y,
                                   uint32_t width,
                                   uint32_t height,
                                   uint32_t fg_colour,
                                   uint32_t bg_colour,
                                   const char *text,
                                   uint32_t text_length,
                                   uint32_t text_size );

/**
 * Flush a surface.
 *
 * @param res Handle to surface.
 *
 ***********************************************************/ 
void gx_priv_flush(GRAPHICS_RESOURCE_HANDLE res);

/**
 * Called after the EGL/VG initialisation of a window has completed
 * following its creation.
 *
 * @param res ???
 *
 * @param cookie ???
 *
 ***********************************************************/ 
void gx_priv_finish_native_window(GRAPHICS_RESOURCE_HANDLE_TABLE_T *res,
                                  void *cookie);

/**
 * Flush font cache.
 *
 ***********************************************************/ 
void gx_font_cache_flush(void);

/**
 * Read a bitmap (.BMP) image from the given file. 
 *  
 * @param filename filename (must not be <code>NULL</code>).
 *
 * @param width holds the width of the image upon return.
 *
 * @param height holds the height of the image upon return.
 *
 * @param pitch_bytes holds the pitch of the image data (in bytes) upon return.
 *
 * @param restype holds the type of the image upon return.
 *
 * @param vg_format holds the OpenVG image format upon return.
 *
 * @param flags holds flags describing image properties upon return.
 *
 * @param image_data_size holds size of the image data upon return.
 * 
 * @param pimage_data holds the image data buffer upon return (must not be <code>NULL</code>),
 *                    the caller is responsible for releasing the buffer afterwards.
 *
 * @return 0 if success, non-zero otherwise (in which case the output parameters
 *           may be invalid).
 *
 ***********************************************************/ 
int gx_priv_read_bmp(const char *file_name, 
                     uint32_t *width, uint32_t *height, uint32_t *pitch_bytes,
                     GRAPHICS_RESOURCE_TYPE_T *restype,
                     VGImageFormat *vg_format,
                     uint32_t *flags,
                     uint32_t *image_data_size,
                     void **pimage_data);

/**
 * Read a Targa (.TGA) image from the given file. 
 *  
 * @param filename filename (must not be <code>NULL</code>).
 *
 * @param width holds the width of the image upon return.
 *
 * @param height holds the height of the image upon return.
 *
 * @param pitch_bytes holds the pitch of the image data (in bytes) upon return.
 *
 * @param restype holds the type of the image upon return.
 *
 * @param vg_format holds the OpenVG image format upon return.
 *
 * @param flags holds flags describing image properties upon return.
 *
 * @param image_data_size holds size of the image data upon return.
 * 
 * @param pimage_data holds the image data buffer upon return (must not be <code>NULL</code>),
 *                    the caller is responsible for releasing the memory afterwards.
 *
 * @return 0 if success, non-zero otherwise (in which case the output parameters.
 *           may be invalid).
 *
 ***********************************************************/ 
int gx_priv_read_tga(const char *file_name, 
                     uint32_t *width, uint32_t *height, uint32_t *pitch_bytes,
                     GRAPHICS_RESOURCE_TYPE_T *restype,
                     VGImageFormat *vg_format,
                     uint32_t *flags,
                     uint32_t *image_data_size,
                     void **pimage_data);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Font handling for graphicsx

#ifndef VCFTLIB_H
#define VCFTLIB_H

#include <stdint.h>
#include "interface/vmcs_host/vc_dispservice_x_defs.h"
#include "interface/vctypes/vc_image_types.h"
#include "interface/vcos/vcos.h"

//Definitions which in certain functions can be used to mean the actual width and height of a resource, without
//having to know the data implicitly.
#define GRAPHICS_RESOURCE_WIDTH  0xFFFF
#define GRAPHICS_RESOURCE_HEIGHT 0xFFFF

#define R_888_MASK      (0x00FF0000)
#define G_888_MASK      (0x0000FF00)
#define B_888_MASK      (0x000000FF)
#define ALPHA_888_MASK  (0xFF000000)
#define GRAPHICS_RGBA32( r, g, b, a ) GRAPHICS_RGBA888( r, g, b, a )
#define GRAPHICS_RGBA888( r, g, b, a ) ( (((a) << (8+8+8)) & ALPHA_888_MASK) | (((b) << (8+8)) & R_888_MASK) | (((g) << 8) & G_888_MASK) | ((r) & B_888_MASK) )
#define GRAPHICS_TRANSPARENT_COLOUR 0x00000001UL

//resource defs

typedef enum
{
   GRAPHICS_RESOURCE_HANDLE_TYPE_MIN,

   GRAPHICS_RESOURCE_RGB565,
   GRAPHICS_RESOURCE_RGB888, /*  888 format is ONLY used when loading bitmaps
                                 - you can't create or delete bitmaps with this format */
   GRAPHICS_RESOURCE_RGBA32,
   GRAPHICS_RESOURCE_TF_RGB32A,
   GRAPHICS_RESOURCE_TF_RGB565,
   GRAPHICS_RESOURCE_YUV420,

   GRAPHICS_RESOURCE_HANDLE_TYPE_MAX

} GRAPHICS_RESOURCE_TYPE_T;


typedef struct GRAPHICS_RESOURCE_HANDLE_TABLE_T *GRAPHICS_RESOURCE_HANDLE;

VCOS_STATUS_T gx_graphics_init(const char *font_dir);
int32_t graphics_delete_resource( GRAPHICS_RESOURCE_HANDLE res );
VCOS_STATUS_T gx_create_window( uint32_t screen_id,
                                uint32_t width,
                                uint32_t height,
                                GRAPHICS_RESOURCE_TYPE_T image_type,
                                GRAPHICS_RESOURCE_HANDLE *resource_handle );

int32_t graphics_display_resource( GRAPHICS_RESOURCE_HANDLE res,
                                   const uint16_t screen_number,
                                   const int16_t z_order,
                                   const uint16_t offset_x,
                                   const uint16_t offset_y,
                                   const uint16_t dest_width,
                                   const uint16_t dest_height,
                                   const VC_DISPMAN_TRANSFORM_T transform,
                                   const uint8_t display );

int32_t graphics_resource_fill(GRAPHICS_RESOURCE_HANDLE res,
                               uint32_t x,
                               uint32_t y,
                               uint32_t width,
                               uint32_t height,
                               uint32_t fill_colour );

int32_t graphics_update_displayed_resource(GRAPHICS_RESOURCE_HANDLE res,
                                           const uint32_t x_offset,
                                           const uint32_t y_offset,
                                           const uint32_t width,
                                           const uint32_t height );

int32_t graphics_resource_render_text_ext( GRAPHICS_RESOURCE_HANDLE res,
                                           const int32_t x,
                                           const int32_t y,
                                           const uint32_t width,
                                           const uint32_t height,
                                           const uint32_t fg_colour,
                                           const uint32_t bg_colour,
                                           const char *text,
                                           const uint32_t text_length,
                                           const uint32_t text_size );

int32_t graphics_resource_text_dimensions_ext(GRAPHICS_RESOURCE_HANDLE res,
                                              const char *text,
                                              const uint32_t text_length,
                                              uint32_t *width,
                                              uint32_t *height,
                                              const uint32_t text_size );

int32_t graphics_get_resource_size(
   const GRAPHICS_RESOURCE_HANDLE res,
   uint32_t *w,
   uint32_t *h);

int32_t graphics_update_start(void);

int32_t graphics_update_end( void );

int32_t graphics_resource_text_dimensions( GRAPHICS_RESOURCE_HANDLE resource_handle,
                                           const char *text,
                                           const uint32_t text_length,
                                           uint32_t *width,
                                           uint32_t *height );

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 menu "CPU Frequency scaling"

config CPU_FREQ
	bool "CPU Frequency scaling"
	select SRCU
	help
	  CPU Frequency scaling allows you to change the clock speed of 
	  CPUs on the fly. This is a nice method to save power, because 
	  the lower the CPU clock speed, the less power the CPU consumes.

	  Note that this driver doesn't automatically change the CPU
	  clock speed, you need to either enable a dynamic cpufreq governor
	  (see below) after boot, or use a userspace tool.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If in doubt, say N.

if CPU_FREQ

config CPU_FREQ_GOV_COMMON
	bool

config CPU_FREQ_BOOST_SW
	bool
	depends on THERMAL

config CPU_FREQ_STAT
	tristate "CPU frequency translation statistics"
	default y
	help
	  This driver exports CPU frequency statistics information through sysfs
	  file system.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_stats.

	  If in doubt, say N.

config CPU_FREQ_STAT_DETAILS
	bool "CPU frequency translation statistics details"
	depends on CPU_FREQ_STAT
	help
	  This will show detail CPU frequency translation table in sysfs file
	  system.

	  If in doubt, say N.

choice
	prompt "Default CPUFreq governor"
	default CPU_FREQ_DEFAULT_GOV_USERSPACE if ARM_SA1100_CPUFREQ || ARM_SA1110_CPUFREQ
	default CPU_FREQ_DEFAULT_GOV_PERFORMANCE
	help
	  This option sets which CPUFreq governor shall be loaded at
	  startup. If in doubt, select 'performance'.

config CPU_FREQ_DEFAULT_GOV_PERFORMANCE
	bool "performance"
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'performance' as default. This sets
	  the frequency statically to the highest frequency supported by
	  the CPU.

config CPU_FREQ_DEFAULT_GOV_POWERSAVE
	bool "powersave"
	select CPU_FREQ_GOV_POWERSAVE
	help
	  Use the CPUFreq governor 'powersave' as default. This sets
	  the frequency statically to the lowest frequency supported by
	  the CPU.

config CPU_FREQ_DEFAULT_GOV_USERSPACE
	bool "userspace"
	select CPU_FREQ_GOV_USERSPACE
	help
	  Use the CPUFreq governor 'userspace' as default. This allows
	  you to set the CPU frequency manually or when a userspace 
	  program shall be able to set the CPU dynamically without having
	  to enable the userspace governor manually.

config CPU_FREQ_DEFAULT_GOV_ONDEMAND
	bool "ondemand"
	select CPU_FREQ_GOV_ONDEMAND
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'ondemand' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the ondemand
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_CONSERVATIVE
	bool "conservative"
	select CPU_FREQ_GOV_CONSERVATIVE
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'conservative' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the conservative
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.
endchoice

config CPU_FREQ_GOV_PERFORMANCE
	tristate "'performance' governor"
	help
	  This cpufreq governor sets the frequency statically to the
	  highest available CPU frequency.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_performance.

	  If in doubt, say Y.

config CPU_FREQ_GOV_POWERSAVE
	tristate "'powersave' governor"
	help
	  This cpufreq governor sets the frequency statically to the
	  lowest available CPU frequency.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_powersave.

	  If in doubt, say Y.

config CPU_FREQ_GOV_USERSPACE
	tristate "'userspace' governor for userspace frequency scaling"
	help
	  Enable this cpufreq governor when you either want to set the
	  CPU frequency manually or when a userspace program shall
	  be able to set the CPU dynamically, like on LART 
	  <http://www.lartmaker.nl/>.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_userspace.

	  For details, take a look at <file:Documentation/cpu-freq/>.

	  If in doubt, say Y.

config CPU_FREQ_GOV_ONDEMAND
	tristate "'ondemand' cpufreq policy governor"
	select CPU_FREQ_GOV_COMMON
	help
	  'ondemand' - This driver adds a dynamic cpufreq policy governor.
	  The governor does a periodic polling and 
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions). 

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_ondemand.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_CONSERVATIVE
	tristate "'conservative' cpufreq governor"
	depends on CPU_FREQ
	select CPU_FREQ_GOV_COMMON
	help
	  'conservative' - this driver is rather similar to the 'ondemand'
	  governor both in its source code and its purpose, the difference is
	  its optimisation for better suitability in a battery powered
	  environment.  The frequency is gracefully increased and decreased
	  rather than jumping to 100% when speed is required.

	  If you have a desktop machine then you should really be considering
	  the 'ondemand' governor instead, however if you are using a laptop,
	  PDA or even an AMD64 based computer (due to the unacceptable
	  step-by-step latency issues between the minimum and maximum frequency
	  transitions in the CPU) you will probably want to use this governor.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_conservative.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

comment "CPU frequency scaling drivers"

config CPUFREQ_DT
	tristate "Generic DT based cpufreq driver"
	depends on HAVE_CLK && OF
	# if CPU_THERMAL is on and THERMAL=m, CPUFREQ_DT cannot be =y:
	depends on !CPU_THERMAL || THERMAL
	select PM_OPP
	help
	  This adds a generic DT based cpufreq driver for frequency management.
	  It supports both uniprocessor (UP) and symmetric multiprocessor (SMP)
	  systems which share clock and voltage across all CPUs.

	  If in doubt, say N.

if X86
source "drivers/cpufreq/Kconfig.x86"
endif

if ARM || ARM64
source "drivers/cpufreq/Kconfig.arm"
endif

if PPC32 || PPC64
source "drivers/cpufreq/Kconfig.powerpc"
endif

if AVR32
config AVR32_AT32AP_CPUFREQ
	bool "CPU frequency driver for AT32AP"
	depends on PLATFORM_AT32AP
	default n
	help
	  This enables the CPU frequency driver for AT32AP processors.
	  If in doubt, say N.
endif

if IA64
config IA64_ACPI_CPUFREQ
	tristate "ACPI Processor P-States driver"
	depends on ACPI_PROCESSOR
	help
	This driver adds a CPUFreq driver which utilizes the ACPI
	Processor Performance States.

	For details, take a look at <file:Documentation/cpu-freq/>.

	If in doubt, say N.
endif

if MIPS
config LOONGSON2_CPUFREQ
	tristate "Loongson2 CPUFreq Driver"
	help
	  This option adds a CPUFreq driver for loongson processors which
	  support software configurable cpu frequency.

	  Loongson2F and it's successors support this feature.

	  For details, take a look at <file:Documentation/cpu-freq/>.

	  If in doubt, say N.

config LOONGSON1_CPUFREQ
	tristate "Loongson1 CPUFreq Driver"
	help
	  This option adds a CPUFreq driver for loongson1 processors which
	  support software configurable cpu frequency.

	  For details, take a look at <file:Documentation/cpu-freq/>.

	  If in doubt, say N.
endif

if SPARC64
config SPARC_US3_CPUFREQ
	tristate "UltraSPARC-III CPU Frequency driver"
	help
	  This adds the CPUFreq driver for UltraSPARC-III processors.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If in doubt, say N.

config SPARC_US2E_CPUFREQ
	tristate "UltraSPARC-IIe CPU Frequency driver"
	help
	  This adds the CPUFreq driver for UltraSPARC-IIe processors.

	  For details, take a look at <fi#
# Sample configuration file for the Samba suite for Debian GNU/Linux.
#
#
# This is the main Samba configuration file. You should read the
# smb.conf(5) manual page in order to understand the options listed
# here. Samba has a huge number of configurable options most of which 
# are not shown in this example
#
# Some options that are often worth tuning have been included as
# commented-out examples in this file.
#  - When such options are commented with ";", the proposed setting
#    differs from the default Samba behaviour
#  - When commented with "#", the proposed setting is the default
#    behaviour of Samba but the option is considered important
#    enough to be mentioned here
#
# NOTE: Whenever you modify this file you should run the command
# "testparm" to check that you have not made any basic syntactic 
# errors. 

#======================= Global Settings =======================

[global]

## Browsing/Identification ###

# Change this to the workgroup/NT-domain name your Samba server will part of
   workgroup = WORKGROUP

# Windows Internet Name Serving Support Section:
# WINS Support - Tells the NMBD component of Samba to enable its WINS Server
#   wins support = no

# WINS Server - Tells the NMBD components of Samba to be a WINS Client
# Note: Samba can be either a WINS Server, or a WINS Client, but NOT both
;   wins server = w.x.y.z

# This will prevent nmbd to search for NetBIOS names through DNS.
   dns proxy = no

#### Networking ####

# The specific set of interfaces / networks to bind to
# This can be either the interface name or an IP address/netmask;
# interface names are normally preferred
;   interfaces = 127.0.0.0/8 eth0

# Only bind to the named interfaces and/or networks; you must use the
# 'interfaces' option above to use this.
# It is recommended that you enable this feature if your Samba machine is
# not protected by a firewall or is a firewall itself.  However, this
# option cannot handle dynamic or non-broadcast interfaces correctly.
;   bind interfaces only = yes



#### Debugging/Accounting ####

# This tells Samba to use a separate log file for each machine
# that connects
   log file = /var/log/samba/log.%m

# Cap the size of the individual log files (in KiB).
   max log size = 1000

# If you want Samba to only log through syslog then set the following
# parameter to 'yes'.
#   syslog only = no

# We want Samba to log a minimum amount of information to syslog. Everything
# should go to /var/log/samba/log.{smbd,nmbd} instead. If you want to log
# through syslog you should set the following parameter to something higher.
   syslog = 0

# Do something sensible when Samba crashes: mail the admin a backtrace
   panic action = /usr/share/samba/panic-action %d


####### Authentication #######

# Server role. Defines in which mode Samba will operate. Possible
# values are "standalone server", "member server", "classic primary
# domain controller", "classic backup domain controller", "active
# directory domain controller". 
#
# Most people will want "standalone sever" or "member server".
# Running as "active directory domain controller" will require first
# running "samba-tool domain provision" to wipe databases and create a
# new domain.
   server role = standalone server

# If you are using encrypted passwords, Samba will need to know what
# password database type you are using.  
   passdb backend = tdbsam

   obey pam restrictions = yes

# This boolean parameter controls whether Samba attempts to sync the Unix
# password with the SMB password when the encrypted SMB password in the
# passdb is changed.
   unix password sync = yes

# For Unix password sync to work on a Debian GNU/Linux system, the following
# parameters must be set (thanks to Ian Kahan <<kahan@informatik.tu-muenchen.de> for
# sending the correct chat script for the passwd program in Debian Sarge).
   passwd program = /usr/bin/passwd %u
   passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .

# This boolean controls whether PAM will be used for password changes
# when requested by an SMB client instead of the program listed in
# 'passwd program'. The default is 'no'.
   pam password change = yes

# This option controls how unsuccessful authentication attempts are mapped
# to anonymous connections
   map to guest = bad user

########## Domains ###########

#
# The following settings only takes effect if 'server role = primary
# classic domain controller', 'server role = backup domain controller'
# or 'domain logons' is set 
#

# It specifies the location of the user's
# profile directory from the client point of view) The following
# required a [profiles] share to be setup on the samba server (see
# below)
;   logon path = \\%N\profiles\%U
# Another common choice is storing the profile in the user's home directory
# (this is Samba's default)
#   logon path = \\%N\%U\profile

# The following setting only takes effect if 'domain logons' is set
# It specifies the location of a user's home directory (from the client
# point of view)
;   logon drive = H:
#   logon home = \\%N\%U

# The following setting only takes effect if 'domain logons' is set
# It specifies the script to run during logon. The script must be stored
# in the [netlogon] share
# NOTE: Must be store in 'DOS' file format convention
;   logon script = logon.cmd

# This allows Unix users to be created on the domain controller via the SAMR
# RPC pipe.  The example command creates a user account with a disabled Unix
# password; please adapt to your needs
; add user script = /usr/sbin/adduser --quiet --disabled-password --gecos "" %u

# This allows machine accounts to be created on the domain controller via the 
# SAMR RPC pipe.  
# The following assumes a "machines" group exists on the system
; add machine script  = /usr/sbin/useradd -g machines -c "%u machine account" -d /var/lib/samba -s /bin/false %u

# This allows Unix groups to be created on the domain controller via the SAMR
# RPC pipe.  
; add group script = /usr/sbin/addgroup --force-badname %g

############ Misc ############

# Using the following line enables you to customise your configuration
# on a per machine basis. The %m gets replaced with the netbios name
# of the machine that is connecting
;   include = /home/samba/etc/smb.conf.%m

# Some defaults for winbind (make sure you're not using the ranges
# for something else.)
;   idmap uid = 10000-20000
;   idmap gid = 10000-20000
;   template shell = /bin/bash

# Setup usershare options to enable non-root users to share folders
# with the net usershare command.

# Maximum number of usershare. 0 (default) means that usershare is disabled.
;   usershare max shares = 100

# Allow users who've been granted usershare privileges to create
# public shares, not just authenticated ones
   usershare allow guests = yes

#======================= Share Definitions =======================

[homes]
   comment = Home Directories
   browseable = no

# By default, the home directories are exported read-only. Change the
# next parameter to 'no' if you want to be able to write to them.
   read only = yes

# File creation mask is set to 0700 for security reasons. If you want to
# create files with group=rw permissions, set next parameter to 0775.
   create mask = 0700

# Directory creation mask is set to 0700 for security reasons. If you want to
# create dirs. with group=rw permissions, set next parameter to 0775.
   directory mask = 0700

# By default, \\server\username shares can be connected to by anyone
# with access to the samba server.
# The following parameter makes sure that only "username" can connect
# to \\server\username
# This might need tweaking when using external authentication schemes
   valid users = %S

# Un-comment the following and create the netlogon directory for Domain Logons
# (you need to configure Samba to act as a domain controller too.)
;[netlogon]
;   comment = Network Logon Service
;   path = /home/samba/netlogon
;   guest ok = yes
;   read only = yes

# Un-comment the following and create the profiles directory to store
# users profiles (see the "logon path" option above)
# (you need to configure Samba to act as a domain controller too.)
# The path below should be writable by all users so that their
# profile directory may be created the first time they log on
;[profiles]
;   comment = Users profiles
;   path = /home/samba/profiles
;   guest ok = no
;   browseable = no
;   create mask = 0600
;   directory mask = 0700

[printers]
   comment = All Printers
   browseable = no
   path = /var/spool/samba
   printable = yes
   guest ok = no
   read only = yes
   create mask = 0700

# Windows clients look for this share name as a source of downloadable
# printer drivers
[print$]
   comment = Printer Drivers
   path = /var/lib/samba/printers
   browseable = yes
   read only = yes
   guest ok = no
# Uncomment to allow remote administration of Windows print drivers.
# You may need to replace 'lpadmin' with the name of the group your
# admin users are members of.
# Please note that you also need to set appropriate Unix permissions
# to the drivers directory for these users to have write rights in it
;   write list = root, @lpadmin

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #!/bin/sh
#
# Trivial script to load/save current contents of the kernel clock
# from/to a file. Helpful as a *bootstrap* clock on machines where
# there isn't a useful RTC driver (e.g. on development boards). Using
# NTP is still recommended on these machines to get to real time sync
# once more of the system is up and running.
#
# Copyright 2012 Steve McIntyre <93sam@debian.org>
#
# License: GPLv2, see COPYING

if [ "$FILE"x = ""x ] ; then
    FILE=/etc/fake-hwclock.data
fi

COMMAND=$1
if [ "$COMMAND"x = ""x ] ; then
    COMMAND="save"
fi

FORCE=false
if [ "$2"x = "force"x ] ; then
    FORCE=true
fi

case $COMMAND in
    save)
        if [ -e $FILE ] ; then
            SAVED="$(cat $FILE)"
            SAVED_SEC=$(date -u -d "$SAVED" '+%s')
            NOW_SEC=$(date -u '+%s')
            if $FORCE || [ $NOW_SEC -ge $SAVED_SEC ] ; then
                date -u '+%Y-%m-%d %H:%M:%S' > $FILE
            else
                echo "Current system time: $(date -u '+%Y-%m-%d %H:%M:%S')"
                echo "fake-hwclock saved clock information is in the future: $SAVED"
                echo "To force the saved system clock backwards anyway, use \"force\""
            fi
        else
            date -u '+%Y-%m-%d %H:%M:%S' > $FILE
        fi
        ;;
    load)
        if [ -e $FILE ] ; then
            SAVED="$(cat $FILE)"
            SAVED_SEC=$(date -u -d "$SAVED" '+%s')
            NOW_SEC=$(date -u '+%s')
            if $FORCE || [ $NOW_SEC -le $SAVED_SEC ] ; then
                date -u -s "$SAVED"
            else
                echo "Current system time: $(date -u '+%Y-%m-%d %H:%M:%S')"
                echo "fake-hwclock saved clock information is in the past: $SAVED"
                echo "To set system time to this saved clock anyway, use \"force\""
            fi      
        else
            echo "Unable to read saved clock information: $FILE does not exist"
        fi
        ;;
    *)
        echo $0: Unknown command $COMMAND
        exit 1
        ;;
esac
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ELF          (      4      4    (     p                     4   4  4                 4  4  4                                                                          P  P  P  D   D         Qtd                          /lib/ld-linux-armhf.so.3             GNU                        GNU 3|?|L6%            @ 0  D	=	``&	 T
                  
                                                                  !           %       &   '   (   )       +   -   v|
A:I*I*I4A|~{.N=(]:?}[;YyRke?~|zW
`I*7'X,qX`ON-^|ICEGR)DeWvT<v                                              .               J                            	                                                       d                                     J                                                                                                                                                           U         0             p                           <                          R             /                      e                                                 (                                                 r             I         j           ;                       libreg.so __gmon_start__ _Jv_RegisterClasses _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable _fini _init reglib_get_rd_alpha2 libnl-genl-3.so.200 nl_cache_free nl_cb_put nl_socket_alloc nl_socket_free nl_wait_for_ack nl_send_auto_complete nlmsg_alloc nlmsg_free nl_cb_set genl_ctrl_search_by_name genlmsg_put genl_ctrl_alloc_cache genl_family_get_id genl_connect genl_family_put libnl-3.so.200 nl_cb_alloc nla_nest_start nl_cb_err nla_put nla_nest_end libc.so.6 exit perror abort strlen getenv stderr fwrite close open fprintf __libc_start_main _edata __bss_start __bss_start__ __bss_end__ __end__ /lib/crda GLIBC_2.4                                                                                      ii   g      t   x                 )   '         !      *         $   (   ,   0   4   8   < "  @   D   H   L .  P   T #  X   \   `   d (  h %  l   p 	  @- -              | t l d \ T L D < 4 , $          5O-0 @ <M(P`u  T p `    PH 
  AB Q-   A B R+  0(@  T1  /  @  T,  
  q  P  P 
  P  
  P  
40  &  0 	  <0 R  
40  Q  0 d  h   { PP  
04<0*    0z   Q  P$   
 @P  
$ y   P PP 0 r R0!  #  P  08`  0f0   Pt   "; P~  
 0  SD  
	P   1 0 P m  
  0  P f   0  P ]   0  P T   0  P K   0  P B  P
  P :   0 X:   `PP  
  PPM  2  0  0 01 0 !0  0 S<  
  $    	  < P P 0 R
/@1`0$    0 P1<  0   00    0  g0 0   h PP0 0  x0 0  )  0  P0 0!    0,0h 0  &  0y              h  p    \  @  4    T  h  |  t  D  D  |      - -- 0|      0 0   R/      0 0` S/0  S//      $$ `A/0  S//      @-@ 0  S0 0 @-$  0  S  @0  S
3/      /0 0 /@-@$0$ 0                C- pL`LP`P`eFaPE @@0 	 3/ T    /@-  nl80211 error %d
   Usage: %s
  COUNTRY COUNTRY environment variable not set.
  COUNTRY environment variable must be an ISO ISO 3166-1-alpha-2 (uppercase) or 00
   No country match in regulatory database.
   Failed to allocate netlink sock.
   Failed to connect to generic netlink.
  Failed to allocate generic netlink cache.
  nl80211 nl80211 not found.
 Failed to allocate netlink message.
    Failed to send regulatory request: %d
  Failed to set regulatory domain: %d
    failed to open db file  /usr/local/lib/crda/regulatory.bin  /usr/lib/crda/regulatory.bin             `                               ]                                o            
   q                                                    o  o   o^                                                                                                                                                                                        A0   aeabi &   6 	
" .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.exidx .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes                                                    4  4                             P  P                     !         p  p  $                  4   o       h               >                           F             q                 N   o   ^  ^  ^                [   o                        j   	                          s   	   B                     |           	                    w             
                                                                                            <                      p                                                                                                                                                                                                                  | |                                                       p          1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ELF          (    H; 4   r   4   	 (     pDm  Dm Dm                4   4  4                 T  T T                          Pm  Pm           o  o o    #           o  o o                p  p p D   D         Qtd                          Rtdo  o o             /lib/ld-linux-armhf.so.3             GNU                        GNU ou4^[qeziMa          
    @, DGAXJ   P       I  &) .T, ^(  ep(` H B   @  0	@ 
$` `                          
                                                                                       %       '   (   *   +       ,   .   0       1       4   6   7   9   :   <       >   ?   @   A   B   C   D           F   H       K       M       N   O   Q   S   T   U   V       Y   \           ^       _   b   c   d       f   h   i   k   n   q   r   s       t       ^-|Qw>jNBw)e-2@/t_F\l?Wm	/N=M:}T
_t;fUa9@\?~|$V6d`gII"#x|vbaP}[;AM|]abAqWhA`9FX7?9@&v;]E%o78DW3f8pc$#'6_9@a3fH 89{|c)fRPvw|o9(!	t41#]|H5U $u|W bdE%c>d'di9a|1^|u/^-l<9nZik]x3x;H                                           D                                                                               s                                        R              O             J              	             *             U                          c                          {                q                    {              &                           t             6             t             7              %                                                                                                                      @                q    !  w                                         P  q                   W                                                                                              4             $             +                                                       ?                          I  q                                                            1                            F                                       <             '                             q                                                 q                   Z                           S                          o             a                           ,                                                      q      ~             3             r                          f                          m                           G                          m                          ]             d                                                                  i                                        ]   q                                 libc.so.6 chroot fflush __printf_chk exit execl execv _IO_putc setlocale strncmp dcngettext optind __strdup dcgettext nanosleep inet_ntop strncpy getdomainname mbstowcs fork tcgetsid sigprocmask __stack_chk_fail iswprint abort stdin getpid strspn chmod strtok strtol isatty cfsetispeed fgetc strlen ungetc sigemptyset openlog getaddrinfo memset cfgetospeed setutent warn __errno_location tcsetattr chdir read memcmp __syslog_chk utmpname dup2 __fxstat64 __fprintf_chk sigaddset getgrnam stdout fputs memcpy fclose tcsetpgrp __vsnprintf_chk malloc raise nl_langinfo __ctype_b_loc nice optarg stderr ioctl alarm __snprintf_chk getopt_long freeifaddrs getifaddrs gethostname chown sigaction tcflush waitpid endutent vhangup localtime strchr updwtmp program_invocation_short_name tcgetattr __ctype_tolower_loc freeaddrinfo setvbuf pututline getutent fcntl cfsetospeed cfgetispeed uname fopen64 bindtextdomain access _IO_getc strcmp __libc_start_main setenv write closelog sysconf free __progname ld-linux-armhf.so.3 __stack_chk_guard __gmon_start__ GLIBC_2.4                                                                                                                                     ii                     ii         q   q K  q \  q r  q -  q   q O  q >  p 7  p   p   p :  p ,   p '  $p d  (p 4  ,p 
  0p D  4p b  8p H  <p *  @p T  Dp f  Hp    Lp n  Pp !  Tp Y  Xp   \p ]  `p 0  dp g  hp c  lp 1  pp V  tp i  xp   |p Z  p o  p s  p   p F  p W  p   p 2  p .  p   p /  p [  p "  p +  p   p   p G  p k  p B  p   p @  p h  p 3  p   p _  p   p   p   p   p %  p t  p   p    q `  q X  q   q C  q Q  q   q j  q 6   q S  $q   (q a  ,q E  0q l  4q ;  8q   <q #  @q m  Dq P  Hq R  Lq 9  Pq q  Tq (  Xq ^  \q L  `q 8  dq U  hq   lq N  pq <  tq 	  xq p  |q I  q e  q ?  q   q A  q =  q   q   q $  q &  q   q M  q   q J  q   q 5  @-j	 -Z                     | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $               R  P(  
G- `@p  T  
X @  T  W   
 P  M PP0S     Y@  
 	 	@ 
  0 
0  /  O-&M?$M& 0x  @PU  0L/?p hp!1Tqh.2`P20B0a]?  0?  07>  0".x   .? p' 
80@N S <! `! `! `! `! `! `! `! `! `! `! 0! `!  ! `! `! ! |  l  `!   `!    `!  `!  `! `!  `! `! `! `! `! `! `! `! `! `! `!  `!   `! | `! l \ `! `! P @ 0 $  `!    `! `!  `! `! `! `! `! `! `! `!  p ` P D 8 ,  01 01=   T17T1T17T1T16T1P   D=  @=    tT1 0T1~   
   PXv     T1<T1l 0d1iT19T1e 0l1bT10T1^T10T1Z 0h1WT10T1ST10T1OT1  @0T1!I   
 CT1;T1? 0\1<T1<T18T1:T14   
 .T18T1* a  Y&
	 s  P!
	 n  P01
	 g  PC T18T1 	    P|  '   0  S.  
\ S 0 \ R  
   000Cs0 S  ! Qr    00T16T1 0`1T1;T1H 	 i6 8;   T! 00T1lz ` T P  J  [ 
0 Tp 0  
` `  ` 9  V 
a	01 b>a|pa,    P  ` $    Xta 0 T  1  Sx1h10} @  tqpa Pd	  P 
0 T00C S -B>   ?     Q  
B>( , ?  P  DLU  P pQ@ 0- S `] @  TZ   P  
   P   M 0 0   PO    P  J 7   0C < , B,    P  6 .  P x!T1  R:T17x1 xT   o      |X   P 
hP <     0T1
" 
1   S ,T19T1T18 90  , <k00 !
  :40<kK0!4=0< ;080"(Z<0e<%<( 00 ,0 0C0= 0  @>?@0A 0 EFG0I 0 , B@D@H@M@JKL0^ P  
  %     +  403>0 ST1;T1T1 
T!l50 SG 
T1
  1 S  
   |+ xT1PE@ T 
X  P/ T!50  S  
T1\A`    T5$0 
U,L	   $\1  x0P000X1  Sv T1*: 
        T  
 ** P: D   r0s000
- R. 
lQ  U 
 p   0s r  `jv`  V 
  \db> @ P|E  
 P `  P  
  P   P4 hhd   p i  -  W  
0  S   B>  P@ g00
 S S0w
   1 P
pB>  TAP ,09  S,0T1, 9T1T!0000040  ;K>408 , c1 S 
 S40;40 0  <0B0C_  P  0 S    R  C0 S  RP  C OT1   40140   , I  P  
p        +   `$@hP     Tp@D <     !  Peh0  S  l0  S  p0  S  t0  SY
 T @   PS x! 0 R10x1/q g g g ] g g [ q  4h q h q  h g g g g q th h h h h h DK  i j j WT  j ,j      `j f k T  T  VT  j i h h   "T  	  T  i <k @k Dk $j f k q - @ xj Tj   \h q   Hk pk (i Z $k i i e hk j g h j Pi pi i h  r j j  o0b.B   P @@( 	 0f
P 	     P    T	 A  P  
 0 S  	+ 	 4   pP   w  P 0:
S
  )  P 
 C 0V0?  
  l pF 
  %T1 J     
^    > P@ 	   ^ pP  0V0?  
 8 D p 
    P    TC;h   	   Sk 
Ps0s000
  
 `   r0s000
  R   0    X    R  
  P0 00 X 0  S8
  &< 01=C< .  &< 01=C< |A  T
0  S
 !  v 0  S- 
T!* 
#0   T	
\1  Sb>1##|%b>1|EwMT19T1,H D +,  =  8A  0  U?  8 0,0  Y>@ +  
 Y/  
 Y$  
  V  
, 0  8, 0    40, 1 40  P     f  P    Up! 4 ,4 4 , 0 4 , 4 0   4 40;40
 UW 
P  U 
 U  
  U  P Q2  T1*  E  p 
 	 @b>@, A, @   , NT1
' 
   $  0Tq 0%0{0`P00$ 00  Sn U,d   +   P]    W+@tP  +0@s0tP S  
 0 0S   0000  P3  
C  P/  
 6P1 0   `F V8PP 0@L  P 	 a 0  P   @T  
 S \7  P0  T S S S S  Pg
  Pc
 VP800  
`F 0 S S  
 S  ,(3   R<   pm ,  @,    T@  P PP!	4 d,p ` 0,  ,0CC`b>C ^ 	(0  P  b> 0 P`C Y	`  *@ t0s00  0
   @P  
, , i   , ,pCuE`U `  0 T!0 0p! 	 19   U     U$~t0s00  0	
)0h S  800Y  
 @` 0*  0
4  pd! L    p`!  h        U
 UC
 U 0 0*P!@]  P 	 r 0  P   @T  
 S ;  P0  T& S$ S S  S 0;P+  0  0 M 0  P   PU  
 S  0 0; 0  U S S S ST1+Rd  
<`O  K
0,  0  f    ;   Q\ xZ l   rT  mP 	M    epG    _B    Z<    Tp6   N0  I+  D&    >  (} `@  T*  
t0s00  0    V<s`    x  P/  @c pP
   P@G  #   4  P  
`  V  `M1  V|
@  Ty
_L;  0
O 0D;0G, p  @   p     - -- 0+Z  (Z 0 0   R/,l4   0 0` S/0  S//q q     $$ `A/0  S//q q     @-@ 0  S0 0q @-$  0  S  @0  S
3/o     
 @- d, 2 P      S  
0  S  Z @- @   k   3 0    l  |[ X  vU D  pO 0  jI   dC   ^=   X7   R1   L+   F%   @   : |  4 h  . T  ( @  " ,           
                x   d   P   <   (                  0   J0   `o] ] q <^ H^ x^ ^ ^ 0_ `_ _ _ ` 4` x` ` ` (a `a a a $b `b b b c Hc |c c c (d `d d d e @e xe e e q @-`p P p  
p0{ SpG @    pp0	  
} S  
 T 7@2 0 0    p@-MPM @  0  `0d 0  +P0P   
0<  :0   0 R  p7q q e  - @-M<@0   0  0 R  @/q  - 0 -M0   0
  kq p@-   P @PAP @@B `P	  
5 0P   0p  p e O- Q P
  

 K @ 0  S%  
    P@ < P T p)  
	  P)  
 T`  
 e`  Y  0  S 0  @ 0P  S  X   d B   
	 	` 
  f e @-MP@  0  Q0     0 R   `F pP
  
      P 0 0P  @   ^   0 ) q q f f p@- P t `PpD@ 0D0@  P  
D0  	 S	  0 `Pp  M/ H+,f 0f @f C-M @Q 00  
 ` p P p    P   @T  
   ` R    T    0 R   0 S 0 S S   S  q 3O-M 0 p |0Ph   [ 0 @0  
  P  
 0 
p` S
 S  0`0 \
 \
 p   X  
x; Y# Y0 0
 Y0  S  

 Y Y   L  
 S S
 0`   S    P  

 Y Y:  
   
 S S
 0`   S`  0   S]  

 S SZ  
   
 S S  
0  S pB Y  *0X	 S  SH
  
" S p
 t	  Pn  
`0	 Q 
0Q	 S  S0
i	`	   Zm  
 
 J P 0 S S0 0  Y0  S  
 XS  $  [    [G  
C 0 0 =   P
  I
41|   0 R3  	 p   
  n  P  $ %  R 00   }  P `    
   X  
  +tp %&  0 0 L0  0$   q f f \f lf e A- @PXM 0  p`T  0     @  T!  
   P
P  U
0 S  WG  
  P V?  

 V$  /0$  vT  0 R:  X  W
 V0pp0pppp p` @P  
  0  P      P  
  R  

 R    Q  
$ /0 $  DF  z 0I0A Sq e O-Mj 0 @  "  
   	  t    Q 
t  z Pn  
. 0  7   
  P2 
p  PP  
(       P  PU 
   p R  =  UyP       P  PU 
   p R  #  U   P   
 0  S'  Dy8@  P     P  @T 
   p R     T  - "F PP 
 0
0  S
" 0 R    E8   0s, t PPg  
  
  
Xx  p 0Q  
\ S  
  4p 40KB S< Q hT Q hT hT hT hT hT hT hT hT hT hT hT hT hT hT hT hT hT hT hT hT hT hT hT hT S hT hT hT lR hT  R hT hT hT hT hT hT hT hT hT hT hT hT Q hT S hT hT hT hT hT hT hT S S |S S hT hT S R S  R R 6  p  
  	  9 0vP    $ 0  P   PU  
 S p  Z  U 0 S
 0 S S S P
 0p
G*00	 d 02  4 [
  P\o    Po B @P	 L P5  
   RH
0 Pt @   0 S  P U [   
 , -o @   P8   
 0P0 
    P 0 S
          P A @3 0P 
00  P  u    A  v  q   P
d [r  

    bN/ ] 0 $(,00 P  
 0  PF  
\    P   
x    0 S\T 0 S>6 0 S S9 S#/ 0 S SL SHB 0 Swa 0 S Sr S`Z0 0"0h   ~e 0P00W G P2 ,0  S
   P
.  P
  0   E Qv}    0 N   0 $(,0
  P0  S
p  Wpo, X  P  0P2  
D  R%  
0 S  
0  S
      0"  R     0            0| q f f dK  g q l q f Z f g f f e f f f f f f $g tg Dg dg `g Pg 4g e   Q  
  aB Qp  
 0 0`B So   q  
/oo @ r     S  ?C S  ?C S  >C S  >C S  =C S  =C S  <C S  <C S  ;C S  ;C 
S  :C 
S  :C 	S  9C 	S  9C S  8C S  8C S  7C S  7C S  6C S  6C S  5C S  5C S  4C S  4C S  3C S  3C S  2C S  2C S  1C S  1C  S  0C  S  0C   \  `B/  <  `B/  3 //o b  \3  `B/  P    Q
@-u@ A/@- C- pL`LP`P`eFaPE @@0 	 3/ T  /@-  2      K      n                        ,     X       	     
   `	          %      K                                        @B     	  ` 
     %&   -   g5    	=           k         8   k        a   k         c    l        C   l        d   l         E   l        f   $l         h   4l        H   <l         i   Dl        I   Pl         J   Xl        l   hl        L   tl         m   l         n   l         N   l        o   l         p   l        P   l        r   l         R   l         s   l        t   l         U   l         w   l             m            m            m            $m            ,m           8m                           k k k k 
Usage:
     %1$s [options] <line> [<baud_rate>,...] [<termtype>]
 %1$s [options] <baud_rate>,... <line> [<termtype>]
  
Options:
   -8, --8bits                assume 8-bit tty
    -a, --autologin <user>     login the specified user automatically
  -c, --noreset              do not reset control mode
   -E, --remote               use -r <hostname> for login(1)
  -f, --issue-file <file>    display issue file
  -h, --flow-control         enable hardware flow control
    -H, --host <hostname>      specify login host
  -i, --noissue              do not display issue file
   -I, --init-string <string> set init string
     -J  --noclear              do not clear the screen before prompt
   -l, --login-program <file> specify login program
   -L, --local-line[=<mode>]  control the local line flag
     -m, --extract-baud         extract baud rate during connect
    -n, --skip-login           do not prompt for login
     -N  --nonewline            do not print a newline before issue
     -o, --login-options <opts> options that are passed to login
    -p, --login-pause          wait for any key before the login
   -r, --chroot <dir>         change root to the directory
    -R, --hangup               do virtually hangup on the tty
  -s, --keep-baud            try to keep baud rate after break
   -t, --timeout <number>     login process timeout
   -U, --detect-case          detect uppercase terminal
   -w, --wait-cr              wait carriage-return
        --nohints              do not print hints
      --nohostname           no hostname at all will be shown
        --long-hostname        show full qualified hostname
        --erase-chars <string> additional backspace chars
      --kill-chars <string>  additional kill chars
       --chdir <directory>    chdir before the login
      --delay <number>       sleep seconds before prompt
         --nice <number>        run login with this priority
        --help                 display this help and exit
      --version              output version information and exit
    
For more details see %s.
  agetty(8)   %s  failed to allocate memory: %m   \u  /dev/null   /usr/bin/plymouth   ,   bad speed: %s   too many alternate speeds   /etc/os-release cannot open: %s: %m  	
     	
="  
  unknown_domain      login:  %s %s %d  %d    %02d:%02d:%02d  %ld PRETTY_NAME ANSI_COLOR  [%sm   %d user %d users    %d  [press ENTER to login]  /run/numlock-on Num Lock off    Num Lock on Caps Lock on    ,   Scroll Lock on  Hint: %s

  /bin/login  tty1    /etc/issue  util-linux  /usr/share/locale   =always =never  =auto   invalid argument of --local-line    bad timeout value: %s   %s from %s
 util-linux 2.25.2   8a:cC:d:Ef:hH:iI:Jl:L::mnNo:pP:r:Rst:Uw not enough arguments    0123456789, 9600    tty 0123456789  /var/run/utmp   LOGIN   /var/log/wtmp   /dev/%s /dev/%s: cannot open as standard input: %m  /dev/%s: not a character device /dev/%s: not a tty  /dev/%s: cannot get controlling tty: %m /dev/%s: vhangup() failed: %m   %s: not open for read/write /dev/%s: cannot set process group: %m   %s: dup problem: %m %s: failed to get terminal attributes: %m   linux   vt102   TERM    --ping  quit    C.UTF-8 POSIX   setting terminal attributes failed: %m  [r[H[J   %s%s (automatic login)
 %s: read: %m    %s: input overrun   %s: invalid character conversion for login name %s: invalid character 0x%x in login name    %s: failed to set terminal attributes: %m   checkname failed: %m    -h  -f  --  %s: can't change root directory %s: %m  %s: can't change working directory %s: %m   %s: can't change process priority: %m   %s: can't exec %s: %m      8bits   autologin   noreset chdir   delay   remote  issue-file  flow-control    host    noissue init-string noclear login-program   local-line  extract-baud    skip-login  nonewline   login-options   login-pause nice    chroot  hangup  keep-baud   timeout detect-case wait-cr nohints nohostname  long-hostname   version help    erase-chars kill-chars                                                                                                                                                                                                                                                                                                                                                                                                                                                             8< <                       Z    o          o       o         
                       p    `           p    0    @         o o   o                                                 o                                                                                                                                    A0   aeabi &   6 	
" .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.exidx .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes                                                    T T                             p p                     !            $                  4   o                     >            P              F                              N   o                      [   o      @                j   	      0 0  @                s   	   B   p p  `              |                              w            $                              ?                          Z Z                             Z Z                        p   Dm Dm                            Lm Lm                             o o                             o o                             o o                             o o                            p  p                           q q                             q q  4                       p        q  1                                r                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        