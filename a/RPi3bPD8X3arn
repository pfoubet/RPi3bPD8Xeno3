ented interpreter is never used to load glyphs from     */
  /* TrueType fonts unless one of the following two options is used.       */
  /*                                                                       */
  /*   - The unpatented interpreter is explicitly activated by the user    */
  /*     through the FT_PARAM_TAG_UNPATENTED_HINTING parameter tag         */
  /*     when opening the FT_Face.                                         */
  /*                                                                       */
  /*   - FreeType detects that the FT_Face corresponds to one of the       */
  /*     `trick' fonts (e.g., `Mingliu') it knows about.  The font engine  */
  /*     contains a hard-coded list of font names and other matching       */
  /*     parameters (see function `tt_face_init' in file                   */
  /*     `src/truetype/ttobjs.c').                                         */
  /*                                                                       */
  /* Here a sample code snippet for using FT_PARAM_TAG_UNPATENTED_HINTING. */
  /*                                                                       */
  /*   {                                                                   */
  /*     FT_Parameter  parameter;                                          */
  /*     FT_Open_Args  open_args;                                          */
  /*                                                                       */
  /*                                                                       */
  /*     parameter.tag = FT_PARAM_TAG_UNPATENTED_HINTING;                  */
  /*                                                                       */
  /*     open_args.flags      = FT_OPEN_PATHNAME | FT_OPEN_PARAMS;         */
  /*     open_args.pathname   = my_font_pathname;                          */
  /*     open_args.num_params = 1;                                         */
  /*     open_args.params     = &parameter;                                */
  /*                                                                       */
  /*     error = FT_Open_Face( library, &open_args, index, &face );        */
  /*     ...                                                               */
  /*   }                                                                   */
  /*                                                                       */
/* #define TT_CONFIG_OPTION_UNPATENTED_HINTING */


  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED to compile the        */
  /* TrueType glyph loader to use Apple's definition of how to handle      */
  /* component offsets in composite glyphs.                                */
  /*                                                                       */
  /* Apple and MS disagree on the default behavior of component offsets    */
  /* in composites.  Apple says that they should be scaled by the scaling  */
  /* factors in the transformation matrix (roughly, it's more complex)     */
  /* while MS says they should not.  OpenType defines two bits in the      */
  /* composite flags array which can be used to disambiguate, but old      */
  /* fonts will not have them.                                             */
  /*                                                                       */
  /*   http://www.microsoft.com/typography/otspec/glyf.htm                 */
  /*   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html */
  /*                                                                       */
#undef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED


  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_GX_VAR_SUPPORT if you want to include         */
  /* support for Apple's distortable font technology (fvar, gvar, cvar,    */
  /* and avar tables).  This has many similarities to Type 1 Multiple      */
  /* Masters support.                                                      */
  /*                                                                       */
#define TT_CONFIG_OPTION_GX_VAR_SUPPORT


  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_BDF if you want to include support for        */
  /* an embedded `BDF ' table within SFNT-based bitmap formats.            */
  /*                                                                       */
#define TT_CONFIG_OPTION_BDF


  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****      T Y P E 1   D R I V E R    C O N F I G U R A T I O N       ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* T1_MAX_DICT_DEPTH is the maximum depth of nest dictionaries and       */
  /* arrays in the Type 1 stream (see t1load.c).  A minimum of 4 is        */
  /* required.                                                             */
  /*                                                                       */
#define T1_MAX_DICT_DEPTH  5


  /*************************************************************************/
  /*                                                                       */
  /* T1_MAX_SUBRS_CALLS details the maximum number of nested sub-routine   */
  /* calls during glyph loading.                                           */
  /*                                                                       */
#define T1_MAX_SUBRS_CALLS  16


  /*************************************************************************/
  /*                                                                       */
  /* T1_MAX_CHARSTRING_OPERANDS is the charstring stack's capacity.  A     */
  /* minimum of 16 is required.                                            */
  /*                                                                       */
  /* The Chinese font MingTiEG-Medium (CNS 11643 character set) needs 256. */
  /*                                                                       */
#define T1_MAX_CHARSTRINGS_OPERANDS  256


  /*************************************************************************/
  /*                                                                       */
  /* Define this configuration macro if you want to prevent the            */
  /* compilation of `t1afm', which is in charge of reading Type 1 AFM      */
  /* files into an existing face.  Note that if set, the T1 driver will be */
  /* unable to produce kerning distances.                                  */
  /*                                                                       */
#undef T1_CONFIG_OPTION_NO_AFM


  /*************************************************************************/
  /*                                                                       */
  /* Define this configuration macro if you want to prevent the            */
  /* compilation of the Multiple Masters font support in the Type 1        */
  /* driver.                                                               */
  /*                                                                       */
#undef T1_CONFIG_OPTION_NO_MM_SUPPORT


  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****         C F F   D R I V E R    C O N F I G U R A T I O N        ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* Using CFF_CONFIG_OPTION_DARKENING_PARAMETER_{X,Y}{1,2,3,4} it is      */
  /* possible to set up the default values of the four control points that */
  /* define the stem darkening behaviour of the (new) CFF engine.  For     */
  /* more details please read the documentation of the                     */
  /* `darkening-parameters' property of the cff driver module (file        */
  /* `ftcffdrv.h'), which allows the control at run-time.                  */
  /*                                                                       */
  /* Do *not* undefine these macros!                                       */
  /*                                                                       */
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1   500
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1   400

#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2  1000
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2   275

#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3  1667
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3   275

#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4  2333
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4     0


  /*************************************************************************/
  /*                                                                       */
  /* CFF_CONFIG_OPTION_OLD_ENGINE controls whether the pre-Adobe CFF       */
  /* engine gets compiled into FreeType.  If defined, it is possible to    */
  /* switch between the two engines using the `hinting-engine' property of */
  /* the cff driver module.                                                */
  /*                                                                       */
/* #define CFF_CONFIG_OPTION_OLD_ENGINE */


  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****    A U T O F I T   M O D U L E    C O N F I G U R A T I O N     ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* Compile autofit module with CJK (Chinese, Japanese, Korean) script    */
  /* support.                                                              */
  /*                                                                       */
#define AF_CONFIG_OPTION_CJK

  /*************************************************************************/
  /*                                                                       */
  /* Compile autofit module with Indic script support.                     */
  /*                                                                       */
#define AF_CONFIG_OPTION_INDIC

  /*************************************************************************/
  /*                                                                       */
  /* Compile autofit module with warp hinting.  The idea of the warping    */
  /* code is to slightly scale and shift a glyph within a single dimension */
  /* so that as much of its segments are aligned (more or less) on the     */
  /* grid.  To find out the optimal scaling and shifting value, various    */
  /* parameter combinations are tried and scored.                          */
  /*                                                                       */
  /* This experimental option is active only if the rendering mode is      */
  /* FT_RENDER_MODE_LIGHT; you can switch warping on and off with the      */
  /* `warping' property of the auto-hinter (see file `ftautoh.h' for more  */
  /* information; by default it is switched off).                          */
  /*                                                                       */
#define AF_CONFIG_OPTION_USE_WARPER

  /* */


  /*
   * This macro is obsolete.  Support has been removed in FreeType
   * version 2.5.
   */
/* #define FT_CONFIG_OPTION_OLD_INTERNALS */


  /*
   * This macro is defined if either unpatented or native TrueType
   * hinting is requested by the definitions above.
   */
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
#define  TT_USE_BYTECODE_INTERPRETER
#undef   TT_CONFIG_OPTION_UNPATENTED_HINTING
#elif defined TT_CONFIG_OPTION_UNPATENTED_HINTING
#define  TT_USE_BYTECODE_INTERPRETER
#endif


  /*
   * Check CFF darkening parameters.  The checks are the same as in function
   * `cff_property_set' in file `cffdrivr.c'.
   */
#if CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 < 0   || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 < 0   || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 < 0   || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4 < 0   || \
                                                      \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 < 0   || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 < 0   || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 < 0   || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 < 0   || \
                                                      \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 >        \
      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2     || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 >        \
      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3     || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 >        \
      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4     || \
                                                      \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 > 500 || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 > 500 || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 > 500 || \
    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 > 500
#error "Invalid CFF darkening parameters!"
#endif

FT_END_HEADER


#endif /* __FTOPTION_H__ */


/* END */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /***************************************************************************/
/*                                                                         */
/*  ftstdlib.h                                                             */
/*                                                                         */
/*    ANSI-specific library and header configuration file (specification   */
/*    only).                                                               */
/*                                                                         */
/*  Copyright 2002-2015 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* This file is used to group all #includes to the ANSI C library that   */
  /* FreeType normally requires.  It also defines macros to rename the     */
  /* standard functions within the FreeType source code.                   */
  /*                                                                       */
  /* Load a file which defines __FTSTDLIB_H__ before this one to override  */
  /* it.                                                                   */
  /*                                                                       */
  /*************************************************************************/


#ifndef __FTSTDLIB_H__
#define __FTSTDLIB_H__


#include <stddef.h>

#define ft_ptrdiff_t  ptrdiff_t


  /**********************************************************************/
  /*                                                                    */
  /*                           integer limits                           */
  /*                                                                    */
  /* UINT_MAX and ULONG_MAX are used to automatically compute the size  */
  /* of `int' and `long' in bytes at compile-time.  So far, this works  */
  /* for all platforms the library has been tested on.                  */
  /*                                                                    */
  /* Note that on the extremely rare platforms that do not provide      */
  /* integer types that are _exactly_ 16 and 32 bits wide (e.g. some    */
  /* old Crays where `int' is 36 bits), we do not make any guarantee    */
  /* about the correct behaviour of FT2 with all fonts.                 */
  /*                                                                    */
  /* In these case, `ftconfig.h' will refuse to compile anyway with a   */
  /* message like `couldn't find 32-bit type' or something similar.     */
  /*                                                                    */
  /**********************************************************************/


#include <limits.h>

#define FT_CHAR_BIT    CHAR_BIT
#define FT_USHORT_MAX  USHRT_MAX
#define FT_INT_MAX     INT_MAX
#define FT_INT_MIN     INT_MIN
#define FT_UINT_MAX    UINT_MAX
#define FT_ULONG_MAX   ULONG_MAX


  /**********************************************************************/
  /*                                                                    */
  /*                 character and string processing                    */
  /*                                                                    */
  /**********************************************************************/


#include <string.h>

#define ft_memchr   memchr
#define ft_memcmp   memcmp
#define ft_memcpy   memcpy
#define ft_memmove  memmove
#define ft_memset   memset
#define ft_strcat   strcat
#define ft_strcmp   strcmp
#define ft_strcpy   strcpy
#define ft_strlen   strlen
#define ft_strncmp  strncmp
#define ft_strncpy  strncpy
#define ft_strrchr  strrchr
#define ft_strstr   strstr


  /**********************************************************************/
  /*                                                                    */
  /*                           file handling                            */
  /*                                                                    */
  /**********************************************************************/


#include <stdio.h>

#define FT_FILE     FILE
#define ft_fclose   fclose
#define ft_fopen    fopen
#define ft_fread    fread
#define ft_fseek    fseek
#define ft_ftell    ftell
#define ft_sprintf  sprintf


  /**********************************************************************/
  /*                                                                    */
  /*                             sorting                                */
  /*                                                                    */
  /**********************************************************************/


#include <stdlib.h>

#define ft_qsort  qsort


  /**********************************************************************/
  /*                                                                    */
  /*                        memory allocation                           */
  /*                                                                    */
  /**********************************************************************/


#define ft_scalloc   calloc
#define ft_sfree     free
#define ft_smalloc   malloc
#define ft_srealloc  realloc


  /**********************************************************************/
  /*                                                                    */
  /*                          miscellaneous                             */
  /*                                                                    */
  /**********************************************************************/


#define ft_atol  atol


  /**********************************************************************/
  /*                                                                    */
  /*                         execution control                          */
  /*                                                                    */
  /**********************************************************************/


#include <setjmp.h>

#define ft_jmp_buf     jmp_buf  /* note: this cannot be a typedef since */
                                /*       jmp_buf is defined as a macro  */
                                /*       on certain platforms           */

#define ft_longjmp     longjmp
#define ft_setjmp( b ) setjmp( *(ft_jmp_buf*) &(b) ) /* same thing here */


  /* the following is only used for debugging purposes, i.e., if */
  /* FT_DEBUG_LEVEL_ERROR or FT_DEBUG_LEVEL_TRACE are defined    */

#include <stdarg.h>


#endif /* __FTSTDLIB_H__ */


/* END */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Œ3F`îÜ·ëÌ›÷_ÈåZlÜøÄb¡G×G³î¾ûKÜu×X¼ÿ¾çRQi**¤X·®kÖB¡Ğ1Ko»mô%µç:N:TáğáÔ×·1‰C, #55¹¹©¸ùæaÈÉIİî¼d!/77ÅãâÁw0-ËuLò¡\®eR­äróZ&Óœ#û††s‹Œ¤’­¢£—|l%ô?,Îœ‘wHUTrUe¥55
X­£Ğ½Ç    IDATvF¬<8éé’´*1ÒÒÄ}2aò|ĞçÀjµ‘€>6›­0™¬İşM£1 ­­ı¼iX´()3çÂ®ƒĞóy<.x<®Ûß"#$‹@ \‡Ã‰ââZ¬[WŒß~;»J¯½ûîk0aÂ ~}ÍG¸:l6Ş~{#¾ùf|òz¼öÚ­d{º
<!P€B¡ÃK/­ÁÎexà‰xãüãéıÌ§°eK	ÎmE||8nºi8¦NŠk®I#ç+„+Âl¶aïŞ
ìØQ†ß?¥RÏ¤Íš5êœ>or¹‡ÁáÃ58|¸RØí…ÜÜää¤0iàdEè
¨İA*Áó¼ğÂjÔÖ*ğÛo.´¨z›»îúD">–/¿×Û¥xŒ={NãŞ{¿Âë¯çãñÇ§x»¿£ªJ†©S?ÆóÏOÃ3ÏÜèír®˜ÿûwlÛv»v½ìíRú¾ PÑX,6¬][„/¾Ø††6äçÀ3ÏÜˆÁƒc½Z¡wÑhÈÌ|?şø®»n°·Ëé5'ªªd(*ªe¤*µÚ@„*@ ø‡×`öì¥Ø¼ù9Œ•ì•ÊÊš—÷1öî}ii“í—-ÛU«àğá7<¶@ \:f³”J=ÚÚÚ™ÛJ%õP(¨é¶¶vX,6·÷<DGŠˆˆDE	:¦CÊüşûÅ:M8N´¶ê]¤(=¤R
#Éå”DK
 -E	:äj11Bfı11BDE…2Ë}:1«¾^	©TÃ¤•ĞiYr¹MM*71Œ–Ó’’º—¢ÄbâãÃIÇ•.hµ&””Ô£°°¥¥8z´J¥©©1ÈÊJ@nn*ÓÉÂÓíZ­	Û·ŸÀºuÅØ¿¿
"Ó§gcÎœ1ÈÍMõèºi¬V;xàk?^Ÿéõ˜¶m;G]‰ç›Š…§õÊ:ívşşûÖ®-ÂÖ­¥°Ù˜<9sæŒÁM7¿,I€úK±{w9NœhDS“‹N'Àb±Œ””hdg'bÊ”Á˜4)‹§N5¡´´¥¥(,¬E}½lÃUYY	1"ÉoÓ`=‡ÉdEk«2%SÇIêXŞÚªcD¬–ÚÛ;e+6›…¨¨PDGK	WqqaˆŠ
…D†èhúY€  ²õgl6ššT¨¬”¢²RŠŠ
J®ª¨hÙl‡ÃF||8ÒÓ%q‡\%G:œuÅUÀ¢…«®¢Õù,“ÉÆĞíçOÀâñ¸
âºIX]å¬ˆˆĞ~%Áı­Ö„M›aíÚ"Õ"..³gÆ=÷\Óçİ$x~8ˆ×_ÿ7İ4Ÿ~z'IW¼B<%PÑ¬][„×_ÿññáX²d>†OğÈz j’Í›£  ••R„‡‡à†2‘Ÿ?“'gkYÂa·;päÈY”`Ó¦cP(tŒL5cÆH$>ç=ííf”•51×>\­Ö€‡#’››Â´÷‘ë¨İA*ÁóüôÓ!¼ñÆzTT,¾Ğ½K"Põ6K—îÄ7ßìÃ±co{»ĞĞĞ†iÓşƒ©S‡âÓOïòv9~‡ÃáÄìÙKa2Y±yós~İÀü¯­GII6n|ÆÛ¥ô9|I ¢±Û((8¥Kw¢¢BŠ›nç›ŠaÃâ½]¡—>ü<ûl~x’·KñD¨"‚¯ñÈ#+!•jPPğ¬×jØ¼¹O<ñª«?ôèM¬Ÿ>„7ßÜ€ÊÊ<¶@ t&¹¦E¹¦D/Èµ&-ŞĞ,]“¢D¢`ÄÇ‡#44è’ê±ZíhkÓC­6ºI@]¥ ®©Ut=İÉ@t-ş$™Í6H¥šn“¢è×MM*·Îî®©]ÏB·éËù-ú3ƒ'O62’Jii#ªªdp:;“èQi³²{­EOÊ;W‹ÓéÄÂ…¿`Ó¦ãX³æ	Œ= ×ÖíÊš5ExşùŸñÖ[3ñÈ#“{uİ:	Û¶ÀæÍ%Ø½»¡¡<äçS[NNÊTÜÚªÇæÍ%øë¯
œ:Õ¹\³¹SHDll823cqÍ5©˜:u88–Û¶ZXXÆ .7 ™™qÛ)%V¥§“”	çÇl¶A­n?ïq‡V(tp8ÜÏ	.vü¡Ïı"Vy¥`uo2uJZ­­zØís>óR°ºÎ'iv‚SU%Ãš5EX³¦J¥£GÀÜ¹9¸í¶Ñ&áò8|¸?ü-$V­zqqaŞ.Éïğ´@P}ŸşgÖà±Ç®ÃË/ßìñ¶†º:%vì(CAÁqŸÇÅ„	ƒ0}z6n¾9‹´c®W™jóæãÉ´HO— /o(òò†œwğ!»İ3gäBUªFc£
C†Ä#''¹¹)¸öÚ4DFúşà[„…¨¢¢¢HûA©T"--T‚)/oÁ7|„;^ÄĞ¡çí¿NªŞ¦¸¸3f,Á¯!%%ÚÛåô(‹3g.ÅbÇæÍÏ’Q@®€åË÷àÃ·bûö‘!ñv9WÅÂ…¿ ¥EŸ~ÜÛ¥ô9|Q ¢q:Ø¹ó>ùä?^‰ÓñòË·`ôhï$zY³–"33‹Ïñv)>ƒkc‰«PŠQ£’‘››B„*@ xŒÆF®½ö]|şùİ˜1c¤×êøì³øå—Ã8xp‘G×³}ûI<ğÀ×¨­ı7Ñœ@ .*UB…BÛ‘2ÑÎtxV(¨d&*½Iï&Eñùˆ‰ :ZØ‘0!Dd¤ 11TbÜrÙí„f³--jÈdZ´´¨™¹\¹\ÇÔ×ÖÖîö¾°°`ÄÄP°Åb!“xŠØX:	C€×#ÿv†Ä.Ö9]&Ó2ïárr^9ÌušpùĞ×ú´|RZÚ€ãÇëaµÚ!ò‘MÉRYY‰=z€WÚî**¤X·®kÖB¡Ğ!++sæŒÁí·Fx¸wÚß~{#¾ùfV­zS¦x7½|éÒøàƒ­øä“;qÇ9^©A*Õ`óæ¬^]ˆ²²&$$„cæÌQ˜?ˆºªÏÖéLØµëöí«Ä‰hhPA«52ûï€ 6BCyH„HI‰ÆĞ¡ñHH‡ÃáÀ©S-(-m@II,„B22b‘››ŠÜÜŒ•L:ü.«Õ…‚N€ì|îL‚¤g­­:7#88b±¨ã¼BÄœ_ĞÇy‰D„ØX„B¾¿ÁÓX­v47«Ï«NŸnÅBÄ*oãp8¡Õ¡Ñ™gÎ­Ö•ÊĞ!`u>h9‹~t% €ÍˆUôƒšAXŸ‘²ÂÃ],jš$O¾ƒÕjÇîİåøùçÃØ³§|~ fÏ…yór1bD’·Ë#øgÏ¶â¾ûV@«5áÛo$ÛÏeÒ@õúñGj€»Áƒ%X²d~¯%N75©°gÏiìØQ†={ÊÀÆ¤IÈËŠiÓ†!:ZĞ+uú‡ÅÅµ(((Á–-%J5HJŠD^ŞPäçg_tœ³g[QTTË<*+e €ÔÔhŒ•Œ‘#“1fÌ ëw®«ÕŠ3gÎÀá8wĞ	Bÿ…Åb!99!!¾Õç—@èKØí¤§¿Š÷Ş»ÿøÇØó-FªŞÆjµ#3ó5¼óÎlÜu×8o—Ó£¼ôÒlÜx¿ÿ¾°×.†úÍÍjLš´Ü€ç›êír®šçû	J¥ßÿ¨·Késø²@åÊ¾}•øè£­8r¤99)xé¥›0aBº·Ë"xˆ^X†%9w¸ ]…ª½{+¡Ñœ+T@F!ÂUóÿ·	ë×ÅáÃox5Ùö©§¾‡NgÂwß=âÑõÕbæÌ%8zô-H$¤C8@ Ğ#Éwmº&5uMfà–E'Eu—#¼¢k:Åª»Ä¨º:e·i]krMŠò×´¤ı;ĞÓ*·ÎäçûwpNH'#÷÷ 2™Æ-­çğáhµFbèĞxde%úDZ'…œ«å‹/váı÷·àÓOïÄÜ¹Ş–ºòÿ·	+VìÅ7ß<ˆnâÕZhámíÚBÈåÂÛm·îÑ¶ß#Gê°{÷)”–6âìÙV(Zèõf·}m` áá!ˆ‹!<< &“R©µµŠnSÕ†O ƒézŒ®ÇF×tKú|¦¹Y½şÒ“’"æÕëbBÏcµÚqæŒ¬#¥Š’«NŸnA}½6›\n RS£‘‘‹!Câ‘!ÁàÁ±HJŠ mï>Äå¤_¹Îw<€æB©Wô>¡kâUt´nG xµÚ€Í›K°jÕ”•5aøğÜsÏµ˜={BBüçúà=ôz3zê{ìİ[?‡Ûoãí’ü†Ş¨h*+¥xöÙŸPQ!Å/LÃO\ß«ÇY•ª;wbRšívFJF~şLŸMî®˜Š
)6o>ß~;ŠÚZÂ1mÚğK’© êXXTT‹£GëpäHJJê¡Ó™Àç"++£GÀèÑ0jTğŠ@ „âÆÿë®ËÄë¯O?ß"D òwÜ±b±K—Î÷v)=ÆúõG±`Áøê«ûqË-YŞ.Ç/yôÑ•8y²	{ö¼Ò'FLöÙŸ Rµ{¼£dÄ_*šÂÂ|ñÅnìØQ†œœ,Xpòò†z»,B³lÙn¬X±G¾åíRü"TÁSŒı6zêz<õÔ^­eÚ´ÿ`Â„Axã]Ouµ'.Æ®]/!3“DŞ„¾‹Vk‚Tª†TªéHgê¡Z[õ	MZ˜LVæ=,QQ¡ˆŠ
ELŒÑÑDGSi]ç]M;ƒÅbƒJÕ™Œ¡ÎMLjllƒÁ`aŞs¾NÏII‘ŒîW£qšLÖ&EÕ×+Ï×Hçoß@§3¡¼¼¥¥(*ªÅ¡CÕP(t`càÀF”ÊÊJÀÈ‘É^ÿ=L&+vì(ÃºuÅØ³§!!<äçgcÎœ1—Ô£7øõ×b<óÌOxë­™xä‘ÉŞ.‡ÁétâÅ×`ıú#øùçÇ1vlª·K‚İîÀßŸÁÚµEøı÷°Zí˜<9sæŒÁM7÷ØöÖÜ¬Â¾}U8v¬§OKÑØØ•ª&“]ot$|°`±Xa±ØÁf³‘#“““‚ÜÜ’¶Nğ8jµ¡C¦RC.×¢©I™Œ’®èy
…YÍf!:ZˆØXJ<‹‡XLMSóDˆ‹#¹û ‹gÎÈQU%Ã©SÍ¨¨ Äª††68N„„12õ 33¤ëùf³ju;ÔjZ¬2@¥2 ­­*U;ó¬R RµC­¦şÖuà.7 ááÁAxx0ÂÃC:ÁˆˆADDç4ı·°°`¿º6!|‰#GÎbÕª((8  n¿=÷İw-ÒÓ%Ş.àãØí|ğÁV,[¶O>y=^}õVr½q	ô¶@ 6›ÿûß|ôÑï92Ÿ~z§Wu1-Ø¿¿
Ç±}ûIèt&¤§KŸŸ™3G!-
O¸2h™jÃ†c¨®–#..7ßœ…©S‡âškÒ.ù<±®N‰ÂÂ¦òäÉF8ƒÖde% 7799)$Y—@ „+à±ÇVÁnw`ÅŠÎ·¨¼Á'Ÿü~8ˆ#GŞôv)=Byy¦Oÿ<0‹å{»¿dß¾JÌ›·?üğ(®¿>ÓÛåôÏ<ó#4#V­zØÛ¥ô9üM ¢)*ªÅçŸïÂe6,O?}#¦OÏö‰Î„«ç?Nâ¾AEÅb¿ñÛ—°Û(+kBa!åı×_ĞjˆŠ
ÅÈ‘D¨"Â¥óí·ûñî»(.şÂÃ½w¾èt:‘ş*Şygî¼Ó³	Ìmmí6lÖ¬y&òèºÁ˜Í¶)Jã"G©!—ë˜À--çÊGb±¨Cº¡$¨˜!¢¢B!‘ˆ%@ddèUwòë.-©«$%—ëÜ:Û‹DÁHN<obÒ€Q
ùWUWoâ*ˆu•¢è©T­ÖÄ¼‡Js	î6)*9911BÄÆ†A(äyñ›õOl6ª«©AMègÎÈÎé¬••ˆ±cS}f[u8œ(.®ÅºuÅX¿şh¯I6WÂÎ§ğàƒ_ã©§nÀ+¯ÜâírÎÁnwà‰'¾ÃŞ½øõ×:4ŞÛ%1t'ÇååÁÜ¹9˜0aP¯µ):œ8A¥¯ÕÔÈÑÔ¤Fs³jµíífØlönßÇb±Àá°„ÈÈ…´´$%E"%%
‰‰á8Ğ{‰m„şÕjG[›Şí¸M']^nš•?‹İ
«ÕšJKPY)Ce¥¥¥L’‘HŒôt122$HO— ++C‡Æ©®¡×›»¬¨yî²U[›*u¼ëŠPÈGTT(""BÑ*22´c^HÇ#” "8˜$5®hµ&lÚt_½Rde%âî»¯Áœ9cH'qÂùé§CxõÕu˜6m>ıô.²½Ş¨hÊË›ñôÓ?¢¡¡o¼1wß}M¯×@c6ÛPXXƒ?ş(Ã¦MÇ Pè.A^ŞPäåñ™hş-S” ²RŠˆˆ\}&òóG`Ê”Á—ÕF×ŞnFYY#T<x­­zp8l¤¦Æ0)àYY‰HO'í)@ \Œ?ÜŠíÛOb÷î—Ï·¨¼Á¡CÕ¸í¶ÏqèĞ"$%Ez»œ«B§3á¦›şÄb!Ö¬y’Ü4¸'òò>FBBxŸ’~úGhµD òş*PÑ”•5aÉ’Ø¼¹ƒÇâñÇ§àöÛÇQ‚ü:õaûö0|x‚·Ëé\H¨ºæš4fT_"TÁ§Ó‰É“?Àµ×¦áƒæzµ–ÆFrsßÁ¦MÏ`Ì˜®Ëáp"9ùE|ñÅ=˜1c„G×E —Ë¥ÈG
…‡»|Ôpã:/:ZØ#×ÒJ¥ÍÍj47«ÑØØ†æfuG'yu‡Ä¥u­](äA"	ƒD"‚DB¥8ÄÄ×)sEGüê:ÿJ±ŞúWL¦Aaa-
kQZÚ€ÒÒ˜Í6<‹¬¬Däæ¦`Ü¸ˆx»Üs ;e¬^]ˆÆF²²1gÎÌ=Ê'S3­Ãw,Ã-·dá³ÏîòÙv«Õ{îù
§N5aÃ†gšíí’ÎA*Õ`óæ¬YSˆ“'›Y³Fá®»Æ"%Å»õZ­v”—·àôéÔÕµ¢±Q…êj¤R54#L&+ìvÇyßÏf³€ÀÀ "$$¡¡<ˆD|DD„ :Z€¨¨P&5Q"¡¤–ÈÈPŸİ¦ş‡R©ïH±R3"{s³r¹¦c*U;³<‡ÃFt´qqÔ¹Pl¬‰‰ˆ‹C\\8ââÂ ½ø—ƒFc@E…••2TTPRÕ©SÍŒ4#‘Ş)UedH‘‹  —+'ôÔ 
7áª­­J¥¾C´¢d+…BÇL»¦ Çí"YuŠVQQ¡ˆŒe¤+z>Ğp:Ø·¯«VÀeÆüù×à¾ûÆC"y»<‚RTT‹‡ú11B¬\ù0Â½]’ÏâM
 Ä¥?Ş†ÿşw&OÎÀş3b±wÿoÛí9r%Øºµ--j$$„cÚ´á— D ¸RW§Äe((8¢¢Z„‡‡à†®L¦¢9{¶GÖ1²²&X­vf æ‘#“0bDFL‚HìoE ‚ÿ²fM^~yª«?D@@·çwD ò‹¯âƒæbŞ¼\o—sU,Xğöí«Ä¼Hn\!«WâÅWc×®—úT<ù‚?@¯7cåÊ‡¼]JŸÃß*šòòf,_¾ë×Å Ab<ñÄu¸í¶Ñç;`|«Õ´´WğÙgwaÖ¬QŞ.§OB„*@ \
;wÂ}÷­ÀŸ¾‚AƒÄ^­eÏÓ˜?ÿ(+{·W’°¼}C@ ô?L&«[
ı¨¯W2Ns³ÚM>êíd“ÉŠ††6´´¨;Ä(UŒ0ÕÔ¤rëàÊtşGl,•œKu‹Ÿï?#üÒ¿‘ëoÒU”jjRÁfëìàßõ7êüm„$}ÂOÉ´Œ$UZÚˆââ³P©ÚÁå %%ÚmÔÖAƒÄ>+¹ÉdZÇºuÅ(-m@\\fÏíâÌ…¨¬”bÖ¬¥ÈÉIÁ×_?èóÿWt:æÎ]­ÖˆõëŸöéûR¬[WŒµk!—ë|^¤:GQ.*:‹ƒÏ ¼¼--j @H%M°át:a·;a4Za±Xa³9ÜÄâ®°X ›Í‡Ã—€À@x<.øü@‚ÏDhhBB‚ ñ!ğÀçs-Dhh>ÄbêuTT(„B>iO#œ“ÉÊ$„65©˜¤PJ¶¢Î§\EëÀ@NÇ¹%U%$„3‚U||"Hb‚#“iPZÚˆÊJ)#X>İ‹ÅÆœOPiUbF°"#Áh”J=Z[õn¢5Oç"^µ£µUÎäöş€ ¶K’-SÉÂtê0õšJö§ë3á|H¥üğÃAüğÃßP©¸ùæ,<üğDÊEğOêê”¸ÿşP«øúë1jT²·KòI|å~Iqq-yæ'èt&|øá\ÜrK–Wëq…¬fÓ¦ã¨ª’]U‚@ÓĞĞ†íÛO¢ à8Š‹ÏB(ä#/oòóG`òä^Ù`&“'N42BÕ±cuhlTÅb!%%Š‘©FŒHÂ°a	dĞ@ ôkŠ‹k1cÆşë|ƒ.Ê[Ü~ûçHJŠÄ'ŸÜéíR®˜µk‹ğÜs?cåÊ‡—7ÔÛåø%&“ãÇ¿o‚?ôîèğ=ÍSO}ƒÁ‚o¿%UOÓW*šŠ
)¾øb6l8Š””h,Xp©ü”‰cÖ¬‘xá…›¼]J¿à\¡ê4´Z¢£7n ª¡Ÿòül6?ıô˜·KÁ—_ş…/¾Ø…’’wze}'.Æm·ÆóÏOí•õ„¾ÑhACC#uMgjiQ»‰G<	%ÑÏT2“€‘$x<nÖ©ÑPW§tKKr•…êëÛ˜Î¼İ‰A®‰I©©1êÑú<…ÙlëèÈì.¯¹N77« ×›™÷qÌ$EÑòš«Ìî7ÿ
ZÎ(-md„©ÊJ) *5"77µC–J@vv’Ïw0›møã“X·®{ö”#88S§ÃÜ¹9˜0aÏ_ßK¥Ì˜ñÄb!V¯~Òo¶¶vÌšµ\n ~ûmÏÜëp8Q\\‹uëŠ±~ıQX­vLœéÓ³‘Ÿ?¢Ç5=ÍåHaa|H¥T*PK•¤Tê¡Ó™ Ñ Ñ˜`0˜a0˜a4Za4Z`³9`±Øa·;àp\XÄê
%T²Àf³Àá°Áb±Àå€Í¦ØätH[Œ¼Åårˆ  ¸\6>Øl6ÂÂ¨g‘ˆß!xq!ƒÍf#6–’õx¼@„…ƒË¥ÚÃÈ±È±ZíhkÓC&£R,©ó1-“jyöl+´Z#³<}^æ~>F£$%EYÛ±XlIU-LúŞéÓ-hn¦¤P¡‡ŒŒXdfÆbÈxdfÆbğàX</WNğuèıG§dån%—ëK.×#\vÈTTrcLL÷ÂUt´B!Ù	¾ÕjÇ¶m'ğÕW{Q\\‹áÃpÏ=×bÎœ1>Kè]ôz3,øşyÿş÷˜;7ÇÛ%ù¾"PT;ëûïoÁ7ßìÃôéÙøğÃ¹ó­ën×¡ââ³x˜<97Ş87ßœE®ÑWDS“
¿ÿ~‚Ù®x<.&L„éÓ³qË-Y	¹ºíJ«5¢¤¤……5(-¥ä*¥R‡ÔÔde% ++¹¹)6,Ág‘"¡§ikkÇ°a‹°zõ˜81½»Eˆ@å->şxÖ­+Æ¡C‹¼]ÊQW§ÄÔ©ãÎ;Çâ­·fy»¿eÅŠ½X¼x\„˜·ËéQ|ò{˜LV|óÍƒŞ.¥ÏÑ×*šêj9>ıt6l8ŠÔÔh<÷ÜTÌ˜1‚ˆT~Äı÷>Ÿ‹åËïõv)ıZ¨Ú·¯……µ8|¸šUĞÏ¨¬”âºë>Â÷ß?‚ë¯Ïôv9xùå5¨©Q`İº§ze}3g.Avv"Şygv¯¬@ ø/6›r¹mhjR£¹Y…æfMÇ4•Î¤V˜åƒƒ‘Á¤ÄÆR	D´%‘ˆ<rÓß5=‰¤4nr»&'‰DÁHNt“ƒ\;åÆÄ}şZÀµóqwR”ë´+ôwïšå:íßŸpal6ª«åŒtQTT‹²²&ØíˆÅBde%2ÆŒĞ+	˜=«³aÃQV\{mæÌƒéÓ³ı&U@¥jÇìÙŸƒÅÖ¯Úç:C]Œ–5fÎ\âwò—ÉdÅe.Ò]¦Nê7ÒL¦Aaa-
k¹Êl¶A àağàX¦ÃÏ¸q}ù÷RŒFŒFš›Õò•­­:èõhµ¨ÕFØlv¨ÕX,v˜Lf:‘é¼    IDATX,v68˜ÍT2–İî€ÕJ	ZôÃéDÇ³³ãÑsÿ6®íãl6=Mı®%w±X,°Àf³;YÌ¨ÖN #@`` x¼Îí;(ˆã¶½qÜ:qr òİj
ã#(¨³3ÇEHH ¸\3Íår:ÖÅÇa–çrêóB«'¸Ø¹]×äÒ¾pn×Ğj2•ååÍrU3´ZX,’’"™‡ÌÌXdfÆaèĞ8$'G‘Î‹„+Æl¶A©¤®™èD+©TÃÈWr¹Ö-Ë•  "#C!SÂUDDó:22‰ÑÑH$"ÒQœàu9‹+öbëÖR„…ã{®Å½÷ïsıjWİîÀ»ïàË/ÿÂÓOß€W^¹…œ¹àKÍŸÆÂ…¿Àápàßÿç³ƒµ76ª°mÛ	ìØQ†ƒÏ€Ã	ÀÄ‰éÈËŠ›n¨(ßL€&ø6--jìÚU;Ê°gO9³]MŸİ£’¦Kµ±ÔàäÉ&„„aÈ8·öÓŒI¬“@ _ÃétbÀ€—ğé§waöìQİ-B*oAEEÿB||·ñ`>‹ÍæÀìÙK`0X°uëÂ~y“£'°Xl7î]äçÀÛo÷=	í‰'¾ƒÅbÃ×_ª§é«M}½Ÿ¾¿ürññáxê©ğŒ%£-úï¾[€¿şªÀ/z»¨ãõ©SBÕ¡CÕĞéLˆ‰`ìØ˜8199)¤Q„@ ú/¿¼œÁ¾}¯úDGœÙ³—bğàX,^<§WÖ÷À_#$$Ÿ~w¯¬@ ø.ş"i444¨P_¯DCCêëÛĞĞ ìxnƒÑha–ŒEl¬qqáHHG\\âã©ç„„pÄÄ}~ ÆÀ$1Ğ	Y]§U°Ûİ›IQb±		á>ÿİ	W}Ã¿´´……µ(.>Û§nøWUÉ°iÓ1¬][Œúz%ÒÓ%˜;wæÍëwqL&+æÍ[ÆF

E\\˜·Kº"jk˜9s	†‰Ç÷ß?.7ÀÛ%]2™%X»¶'N4">>³fÂ]wEJJ´·Ë»,¬V;jj(*ªeFR>sF‡Ãé&Lææ¦bôè>)¼Y­vT¢Tª…ÕjƒVk‚Ng‚ÍfGk+Õ©İh´@¯7Ãf³Ãd²Âju@£1  nßj4&æØH-cİNIZV«‹­Cà²Ãáp2r¼eµÚİÎ{¬V;\oÓâÍå$võ$ô¹}ÊÅb±ÀbÑÏÔL*¬óÿ%%Š0 2J,c»Ic®÷29ŒœÈ‹å„PÈG` õÙT’¡¡Aàp8`±œàó!ğÈeÒÂD">³n€Ç\‡…ó…ÂÎù¡¡¼³Øí(:&•ûUÌk•ªY>$$		áHLŒ@bb$’’"”‰ÄÄ$%Eœ#¾z™LÓ‘X%eäïêj9ìv“¸—••€Œ	ÒÓ%92Ùïÿÿ€¾ÓhÌ ®¯Õjärí9§k‚ï…®É¢¢äzŒàQärÖ®-Ä×_ïƒR©ÇÌ™#ñä“×cğàXo—Fğ~ùå0^ye-¦M†Ï>»Ëo!ñ4¾(P”|¾hÑoøõ×#˜?Ş|sæU§ğx’¶¶vìÚu
›7—àÏ?OÃápbÔ¨däç@~~6Äb‘·K$ø!]·+6›…I“¨dñiÓ†÷hj¨ÕjÇéÓ-8v¬ÇÕ¡¤¤UU².RÑm¬	d›&BŸ!+ë<ÿüT<ğÀÄîşL*oa2Y1xğkøÏæáöÛÇx»œËâ½÷6ã›oöaûö–ãírü–•+à­·6àĞ¡EHúŞÉçã›Í+ğv)}¾.PÑ‘ÊÿøùçCxãõ¨ªú€Œîäƒ¡Š@ ú6£G¿E‹fàşû}ã†Ø°a‹ğüóSñĞC“ze}ş™Lƒ|¬WÖG ¼ƒÅbCK‹†‘¢:%)ªóWm­:‰YŞUÀq—¤DHJŠD||¸Ç®3FêëÛP_¯Dccóš–¥´Z# ªc°XLI[®_ãâÂK	R<÷"kó´°v¾¤¨î‚‚8HDÌoA‹k®Ó‰‰>Ù!à´ZNŸnî%jqìXZ[õàpØHMaD©ÜÜ–à²ø• V°y3%¸Õ"66·Ü’…;ï‹!Câ¼]Şa·;ğÈ#+QXXƒñû{Ç×ã;–!/o(–.½Ûo·µŠ
)6o>Õ«ÑØ¨BVV"æÌƒÙ³G!2Ò?;èët&”—73	t‡UC¡Ğ! €;÷YY	92Ùï8_E«5Áét¸ÍkiQ»IYz½ííffÑhİî€ÉD¥vÑé] u.Gc 5¨VkbşN	_vØívX­”Tæt²˜÷šLVf½‹‹ yÌápÂápºIdv»»Dæp8	Íápÿn½E` ‡‘Äø|Øì °XTò)-€…„!0Jxàñ¸Ìw2›m0L°XĞë)1O§3A¯73B\pp¢£C!‘„uˆøaHLŒÀ€Q80A‚ƒƒÈÿ•^„–CKKPY)Ce¥”9ç ±XˆôtJ¨¢åªÁƒc™D9ÁÓt'[u½ÖkiQ»]s—6ğE\\Ùß®
«ÕbÙ²İ¨¨"''Ü€oBîKPTT‹ü‰«V=ì·ƒzô$¾*PÑÇ?ÿ¹Ÿ~z'Æèí’.ŠVkìP¸Û¶€Á`Á°a	ÈË‚Y³Faà@ÿn!xµÚ€;Ê™ŠÅbaìØTäåÅ¬Y£<2ÈB{»¥¥8v¬ì¡®N	§Ó}ĞšáÃ©v–¾Ø¯•@ }ŸI“cæÌQxá…iİı™TŞdæÌ%4HŒ?çíR.™ıû«ğ,ÇGİ»îçírü»İñãßÇu×îµÑØ{›~€^oÆÊ•y»”>G¨h\Eª¸¸p,X@D*_¥¨¨3g.Aaá¿à_éŠı"TBßbéÒøâ‹İ8räMŸ­O¥jÇĞ¡‹ğË/cÒ¤Œ^Yç»ïàÀ*üşûÂ^Y@ğ&“õõ)LJ44¨:FâW1€Çã"11±±aL"ÎDO{R<²ZíhnV£¾^É$(ÕÕ)™¤«††6¦“ë…R®ÒÒÄ>)
Y,6¨Tíİvœ£¥5©TÃˆ` Àå ""ä‚£”Eú9V«ååÍ(,¬enÒWUÉÜnÒçæ¦ ''Ã‡'øıèÑf³{÷V`İºblÛv<Ó¦C~ş\}¦_Øït:ñÂ«±qã1¬^ı8ÆŒIñvI=ÂşıU¸ûî/q×]cñşûşİ~ïp8Q\\‹uëŠ±~ıQX,6L™2Ó§gcúôl¿ÿÿåšTWZÚˆÃ‡k Õˆ¡Cãİ’êÒÓÅ¤s-á¼X,68”Ğ ƒV«v»z=5¯½İÌH^ôy©^oA{;•,f4Za6[a0Xàp8`0PÓ %£ÙíØíVØlvX­668v˜L¶‹ÖÉb±À›Í›M¥s±Ù ÀbÎ;m6G‡$vér‡ .7 ¡¡A¤RgØ
ù`³YLÚ–PÈ‡ÃFH\n BBÁårˆ  x<.ó
ùìHï
ºhW¦kZUe¥§O·Àb±u›V5bD¢£Ş.›ĞÑj×À:Èd(zH¥j´¶êÑÒ¢†B¡ƒL¦u­X,¢£C-ì,D±X„øøpˆÅBÄÆŠ ç}§Ó‰ıû«°bÅ^ìØQ†!CâğØcS0kÖ("éõsÎmÅ½÷~ÎŒU«BVV¢·Kò*¾.P€B¡ÃK/­ÁÎexà‰xã|¿Çé¶Z¦jmÕ#=]‚¼¼¡ÈË‚ÜÜTo—HğC´Z#¶o?‰;Oa×®S0›mLâÙŒ#ã¹k ×Akè6:	\(ä##CâÖÆBúÁ×™1c	FŒHÄ;ïÌîîÏD ò&|°%8pà5o—rIhµ&ÜpÃGÈÎN$©BWÉ–-%xôÑUØ»÷Ÿ}vŠ—^Zƒúz%V¯~ÂÛ¥ô9ú›@EÓĞĞ†¥Kw‘Ê‡Q«2äuüôÓc˜2e°·Ë!\&®BÕŞ½•(*ª…Éd…X,Dnn*ªÁ‡±Ù7îÿ0kÖ(,Z”ïír  ‡×`öì¥8räMÄÆöÎhË–íÆªUpøğ½²>peX­v&‰Jb¢D#zB¡c–ˆaÒ˜èD&×d¦Ş¸&ÖhnR”ëëÆFÓ1•NT¢¥¨ääHæõ€Ñ
}«=²¸\®u“¿\E)…BÇtÄ.<ªxrr$Äb!¢£…~›ÖBğuuJÖ07àKJ`±Ø ò‘‹ÜÜTäæ¦`äÈdŒªê-JK°vm1~ûí4Æ„9sÆàÖ[³}Rš¼Ş}· _}õ¾ıö!\}¦·ËéQ¶m;G]‰ç›Š…»¡Ğï0™¬Ø±£ëÖcÏraêÔ¡˜;7&êr‘İîÀ™3r¦³Oii¯‡Õj‡PÈGv6%hfe%bôèıª}à˜Í6˜LètfX­6èt&˜LV˜Í6hµFX­vèõfFøÒh¨yííæáËµÚ «ÕƒÁ½Ş‹ÅŞ±œ{‚×Å`±XŒXÅá°€€ 68*-‹Nú²Z°Zí0›-°XìüÌÀ@øü@„…uÊU!!A
ùàó¹àó!òØñš€‘ˆ¡ÏL…<¿é\{¥X,6TTHqêT3ÊË›qêTNjB[[; @"!33C†ÄcÈ8dfÆbàÀ"|
£Ñ™Œºî¤Ÿ¥Rê´¹Y©”J´rİ7…„!..‰¨#=¬èv êº“„Š’’,_¾[·– &FˆÇ›‚ùó¯é3×[„ËG£1à‘GVâØ±z|şùİ˜6m˜·Kòş PÑ¬][„×_ÿññáX²d>†OğvI—…İîÀ‘#gQPP‚-[J •j˜©S‡!??cÆ¤öRÂec4Z°

ã÷ßOÀh´`ôèÈÏüülˆÅO…ÒëÍ8uªé’¥*2p@ |‰ûî[¡¥Kçw÷g"Py“¿şªÀwşÇ½Õ+'5WËóÏÿŒ;Oa÷î—I£ÔU2{öRˆDÁ}:éÍ77àèÑ:<ëíRúıU ¢!"•o“•õ,¸>:ÙÛ¥®’®BUaaÌf››P5qb:’“#½]*@ ô{6n<†~À¯!)É7öË?şxo½µ••‹{­±ü§Ÿáw6âôéÅ½²>p~
êêZqö¬uu­Â%LÉdFÊ
yHHˆ`$©¤$ê55/¢Wõh¡«¦FÚÚÖÿÏŞ}Ç5u¯ ÿ°Â&aF„¥@7jÔzAkk{k{;ì­µv·ÚV;µ[{»®ÖöÚ_k«8A« uÖV–ìF€HØ	+õû#ä–¶ZÂ÷ızåbJÏƒmg|?Ï¡°	UUM¨©iXÜ¥R·ÔÒÒŞŞNğövìt®ÙŞŞzÄk½
…rĞ¤(İt¬ÁA)±¸*Õõ‰úğ—n2–İ 	Yú ”»»=YŒIÜ”§Ádf
ÑŞŞ3»#&†mÔ7Õ++qôhÊFuu38’’¢‘”ÄÑ.±tøúëKØ²å>üğn¬^Í§»œqà@&6mÚ­[—ãá‡ëZ—T*CJJ’“³Ÿ/‚»»=îº+
kÖL…ŸŸİå«îî>ÖÚ7œzÇçûÚ7äôJ‚0ºp–\®@ww/:;{ÑÑ¡@gg/êëÛ!éBõMMhmí‚LÖƒ®®^(J±¬`€Á°†.emm	kë	°²2‡¹¹9&L0ƒ¹¹ -LLLab¢…F£E_Ÿ
…==JÈå=èîÖÂ::ƒ&Ødiic"lm­¨g{{ëş××ƒVÆDØÛ[ÃÁÁ“`ooMMØ‹d²îşIUu$ÔÔªŞŞ¡§UM™â''ã	¨Æ©½½‰bq¤R]¨ª¾^©T†úúv44È “uSÿü„	ºsXË®?lÅ ‚Vnnvğôt„«+iî1ˆD­Ø½û¾ÿş7XYYà¡‡fáÁgÂÎÎ0®Õ£K¥ÒàÕWãÿ»‚§Ÿ^ˆgYLwI´K*@÷9Ş´i?22ªğè£sñüówÉk‘……uHO/ÂÑ£×PYÙ''Ì„„„HÌ™4&.‚^
…—.	’’‹Ó§ÑÕÕ‹¨(_,\ÈÃÒ¥ğõuµZH¨Š ‚+zê{´´tâÛoêm ¢SWW/BB6c×®{±|ùdºËùSééEøç?÷`÷î°tiİåŒiEEbÄÅ½ÖcæLİåŒ˜;N"=½gÎ<Gw)Fg¼¨ôHÊ0%&~
6Ûï½·ŠîRˆav3ªY³8³pŸ b<IHøîîøòËÒ]
eëÖ£ÈÈâäÉM£¶Í””\<öØ>ˆD1ÂT*Äâ¶ß…¤ª«uÏ]]½ t‹š¼½áëë<(p¤Ÿ(5Z¡#µZƒºº6…º”.,¥JÕÕµRa"gg°Ù.ğós¯¯s°Ë^^º z{Uhoï‚TúûIQú¯Ú-00ÁÖ¿›50(åîn[[ÃšEŒ7Ş0ÏÈ¢¶¶ff¦ğ÷w¥n”‡‡{"2ÒÛh'EÈdİHIÉÃÁƒ™ÈÊª†«+ññX½šĞPºËGä`Ã†ÿÃ+¯,Ã£Î¡»œõÉ'g°}ûI|ôÑ¬ZCw9#¢¬L‚ÔÔ\8	‘¨áá^HLŒÆŠSŒj*Ü@ryòòDÔt¼œœ´´tÂÜÜ~~ºı—>XÈ$çİ1µD"Cmíõ)²UUM¨¬lDuu3ujnnk0º)Sf011J¥AOO/d²47wR“\õ,-Íaoo=hê©5ìì¬`ggI“,affS ˜˜˜¢³S¹\²’Ë{ “õ@.ï¡^wt( “õ9y‹Á˜GÇIpp°îXM2håà ûg\\lG¥ÁÃß¡TªQ^.EQ‘ÅÅõ(*ªGQ‘mmºiU^^	qçA={{;’…ŒÄ˜ÒÛ«‚D"t|½iˆ®YÈÀ)Ñfptœ&ÓnĞ„hışÅÏÏ66†ù™&ş¾ÖÖ.|ıõ%|õÕ%(•jÜ}÷TüûßóÀb~CkbøíÙs[·ÅêÕS±}{â¸­Œµ  hµZ|÷İoxíµ£
ba×®{áïïJwY·¥¬L‚3gŠ–V„ÌL!ìì¬1k„`É’pƒ=¾$Wo¯
/–!%%ii…ËàpXHHˆÀ]wEÑÒ§««EEƒCU••P«5`0¬Àåº‘PA1ê6o>Œâb1Ù0ÔÛ$@E·øøêíÛ“è.åµµuaîÜ˜=;;wŞCw9cŞæÍ‡páB.]zÉ¨wíÒ[®\ÙLw)F‡¨«®nÆÎé8t(xê©…X¹2Š©hòÒKÉ()iÀÑ£CxF„ª‚ C^wŞù!{11lºË¡Ü{ï—pv¶ÕsHı”çÒÒwÀ`0 AÜ®¾>jjZ¨ÉLCR'31áëë__İ‚$__gøøè^»¹Ùê‚c}7v@Ú?õª55-(/—¢§§ `gg§A¨8&‚‚ÜiÛwÈdİŠÒ¿nlìÔñàÂÒë‹À®¥˜L\]F}í‰]*•••ÈÏ!3SˆŒ!Õ]”Édº	Îç³¾Ów_Ÿ
.”!99§NÀÌÌqq<$&FcîÜ`£¾.uù² ÷Şû_<òÈlŞOw9£â7cÏ‹Ø»÷AÌŸBw9#F£Ñ"+Kˆää,=šƒ%fÌ@bb4âã#0qâºKQú	zBddT¡  
…66–v§ösS§ú‘ë]1ı1íÀãğ²2	ÊÊ —ëÂUfpw·‡——#||œáæf[[KXYYÀÄhiéBk«şÑ‰ææN´´t¢µµëw!(++¸¸Ø‚É´ƒ««-X,;¸¸èmàîngg[8;Û ·W™¬íí=Éº!“õ ½]÷|ãŸë¿ÛÚºÑ×§´Í?
y±Xºco{ûëîìlKû”+©T@JM©¸ÑÆÆ~~®àp˜Ôş-4ÔÖÖÆ½¯'Œ›R©¦¦.‹D­‹ÛQ_ßÖÿºuu­èîî£şy[xx8ô?ìáééOOêÏÈ}ø±«««û÷_ÅgŸıŒ––N,_>›6-›m\“V‰¿öóÏ%X¿~‚ƒİ±wïƒãês=Tz7~²2	yfÖ¯ŸgM-D¢Vœ>]ˆ””\dgWcÂsÄÆrE‹ÂÈ}-â–©ÕdgW#%%Ç_CSS¦Z¶l2™´ÕÖÙ©UéÎC

®Ÿ‹ØÛ[Sç aaõ€³Q|Î	‚ Ã±uëQdg× %eãPo“ İŞ|3ééE¸páEºKùC=ö?\½*ÄùóÏıï‘ÖÛ«BdäkØ°a>|İåŒ¨={.âÓOÏâÚµmt—btH€jh55-TÊËËO?½+VL!'X£lïŞKøàƒÓ(*z“îRˆQv3ªÙ³¹ğòr¤»T‚ £²~ı>TU5áôégè.e©SßÀÚµÓ±aÃ‚QÛfNNâã?Ffæ«ğğpµíÄX§_T7p±cY™„º™:øõhÒ/ÌÔ¥ô‹3+*¤ÔB(}¨ëÆz9Ö¨N’’Éº!‘ÈÑØ(§:bßøz`‡l@·(“Å²ƒ·÷Ğ¡(&ÓFÎ ÃÍ	¦MóWçyùù"<¨—´µu!*ÊII1¸ë®)ã¢kpnn-’’>ÃâÅaØµëqÒÔjµxöÙ8r$û÷?†©Sıè.iÄõöª–Vˆää,œ;Wkë	X¸0II1˜93p\ü·'ÁQ‚>ÃUÁõ†UUèì¼>½Ö××\.kÈsîî>´´èBU­­ºPUc£®áÀÀãl©TN5O t¡-''¸¹ÙÁÅ…‹ÜÜtÇÕú@—••ÅïêîììE{{7Z[;ÑÔÔ––.47w ±Q>àë´´èŞx\onn
''8:Úôªlàæf&S7ÖÕ•ûQZ)•jTU5QóóE(.®GWW/ÌÌLáéé ‡5 ;<kÔÏùb$µ·wC,n²jƒXÜNı™T*§şÙ‰'ÀËËöT¨J Õí›\\liüIˆ›¡Tªqôh>ş8uu­$H5N•”Ôãşû÷ÀÂÂß~ûğ˜Ÿht³Ær€
Ğ}ùå9¼ûîOˆŒôÆÎ÷À××™î²†MkkÎ-FjjÎŸ/…F£Å”)>HHˆDBBä¨^Ã&ŒÃÀ0Ujj.¤R9¦Š‹ã!<Ü‹î©IU›<äæÖB©TÃÂÂl¶uÂå²ê².’ ‚ø{Ş|3W®TàäÉMC½MTt;{¶÷ß¿¹¹ÛòËñã¹X¿~¾ûîÌ™Dw9cŞÑ£9xòÉï•µ®®†÷ß{8}ÿıoxıõc(-}‡îRŒ	Pı¹ºº6ìÚ•~¸
6ÛO<1+WFÑŞéo¼¸tI€Õ«?GAÁpr²¡»‚F
…’Z`BUA#C*•Ï~x7şñhºË¡ôôô!0ğEìÙ³‹‡Úv++ûÎ}ÁÁn£¶]‚ş(tôg“™8&¸\üü\ac3º¡ ¹¼$Ô¬ªª&TW7SõÚØXÂ××~~.`³u??g°Ù.#~.¢P(ÿpR”şk±¸]]½Ô÷èƒQ®®ŒÏŒA¯==ÆE ƒ0<ryòòDÈÈ¨B~~²³«ÑÚÚssSøù¹"<Ü|¾bbØd»f5bqÍÁ÷ß_…PØD->XµŠ?®Îi««›±lÙNDFzcïŞ‡Æ]S­Ö`ıú}¸x±‡=Ïƒî’FT*GJJ.RRr‘™)„»»=îº+
wßÍ7‹õ:;{Q\,¦BBÔÖ¶  ||œÃ¦‚U‘‘Ş˜0ÁœæŠ	Âğ54´£ªªBa„Â&êø¿ºº™š eggMëûùéL¸|êèP@"‘¡©©ƒznhhGss'õ,·šDãè8‰
Tyz:RiÜİàéé WWÛ?jµZ´´tQ!/]ÈJ7AK*•£¹¹õõíhl”£¹¹“ú>33S8;ÛÂÃCªrw·‹e7èáîn?â“¡ôáùü|µ ±¼\
­V;;ëA“ª¸\‚‚ÜÈ>0J}}**L%·£®®uuº×úgıDîI“,‡|úø8ÁËË‘|F=?ËŸ    IDATˆJ¥ÁáÃÙøøã4ˆÅmøÇ?¢±qc	ˆ#R©ëÖ}…êêfìÙ³3fĞ]Òˆë*½’’zlØğD¢V¼òÊ2¬];î’†LÖ‹HO/ÂO? §§QQ¾X¸‡%KÂIè“¸eú	ã))y8q"‰ŞŞNˆ‹ã!!!11lƒiŒscƒ@‚¢"1Z[» `P‡Õÿ`LıA„ázç8w®iiÏõ6	PÑ­£CÍøüóûAw9ƒ´µuaöìíX´(ï½·ŠîrŒÂ|Fƒ}û¦»”§‹ÕÖ~@w)F‡¨nNmmşóŸ³Ø¿ÿ*\ñôÓ‹AN¢F˜D"Ã”)[qèĞ˜>İŸîrrc êêÕ*ôõTÍ™OO21„ âf½óÎ	8ŒŒWaaaFw9”ü|/ş—.½4ª*;ù*İ >ßø§ÄT*Äâ6j‚”@ AY™%%õÙÕËu£¥Ñ‹T*Cy¹åå(/— ¢¢ååRªã³••µH’Ívî¸ÀÏÏuDêU*ÕhmíüÃP”T*GMMd²nê{,,Ìàè8iÈIQ7¾&CĞİİ‡ÂÂ:jl~~µ8V~¦ èº}µ(y<Ë{pú´núÎåËå°··ÆÒ¥áHLŒ—ÇR©Ë–í‚‹‹-x|Äq*¥RûîÛâb1}~~ão“@ AJJ.ÌBmm8’’¢±jß ›†¡ƒüü:df
ÑŞŞ3»Ú§’E>qkd²nª	„~Z®~Š•B¡ [P§Ÿ’Äá°¨pÏÍì“ÚÛ»Q_ßŞŒh¥¦ĞÔ×·C$jESS5UÊÂÂlĞÄ*6Û¾¾Nğõu†¯¯«›ş¹úúTHdHdhhQ¤R9Ú!‘èşL  Ã
ğòr„··Sÿ³#¼¼t_DÓ‹¶¶.‰QTTO=WTH¡Tªaii  7„„x€Çsçà`÷[ú{ ˆ±jàT=ı~Iÿumm+ôK°şlš···#9& F£Å‰yØ±ã$D"2‘j¼éíUaÓ¦ı8q"ï¾»
«Wóé.iDK€
Ğı·{ÿıSøâ‹s˜=›‹>Xm´×Z
%.] %%iiEË{nŠ1¶h4ZÖ!=½‡e£ººX´(ÌàÂTé¯µèïsåç×QSÁmm­ä.—EMÏóÄÄ‰ãóz%A1´÷Şû	§NàìÙç‡z›¨ÁâÅ"*Êo½µ’îRÙ¸ñ{\¼X†óç_€5İåŒy]]½{ï¼“hô'â –Vˆø
55ïÔbNc@T·F à?ÿ9‹Ã‡³Áå²ğÔSIj„½„—_NÀı÷Ï »Â€õôô¡  îw*}·^>ßª‚ ş„B¡DTÔ6üë_³°iÓBºËäÇ3ğÒKÉ(/ß>ªS@
%üüÇ¾}cÁ‚QÛ.AŒ¶îî>TV6Ršô¡#¡°	J¥&&&ğôt@@€+™`Âßßşş#:ú+µµºEååRªŞŠ
)är ÀŞŞLªŞÀ@W0áåå8l“nd²nH$r46Ê!‘ÈúŸu¯kjZ •ê:Ók4×/•ÚÙYÿe(j8k$ˆá¦VkPQÑH-êÏÏ!7·J¥ÆDDDxÏ×MK‰Šò÷×™Ôj®\©ÀÁƒ™8q"†"11sæÛkœr¹+W~•Jƒ£G7ÀŞ~|ß+èèP )é3Èdİ8zôI0™ºK¢…¾›qrrÍAO3f 11K—FŒÛ^MM5Õ/?_„¼<úúT`0¬ÀåºÏ÷ŸÏÆäÉ>pvÙÉ™aŒ”J5ª«›©óıyQE…”š*åâbGw~1ğùVÛ*•j*Ü¤XÕ×·¡¦¦ÕÕÍ‹Û RéVNN6ıaªë||œÀf;ÃÁáïc55u ±Qúúv44ÈPW×ŠÚÚÖşç–A“¬'
Wéú×––Ã3	G¥Ò ²²‘šT%HpíZUËPâ¹\Ö°l› Æ¹\Ñªj¦BUÕÕºçÓ«lltÓ«|}ûƒUº	Ûşş.ps³§ù§0~*•‡eaçÎtj"ÕSOÅÁÛ›L¤2vZ­~x|p=4Û¶­0ÚëzÆ ÒËÊâÉ'¿GG‡;v$aÉ’pºKQjµÙÙÕHIÉCjj¤RÃ"DŒee¤¦æâèÑk¨¬l„»»=î¼3		ˆfô>±³³UUT *?_„¢"1º»û`ff
OO*P¥kbÃ"Ó&	‚ Æ±>8ãÇ¯áÂ…‡z›¨Á¶mÇpñbÙ¥Ühqùr9V¯ş{ö¬Ãw†Ñ]QHIÉÅã‹ÜÜmpr2şb—/°jÕç()y‹ğ†	Pı=¥¥øè£4¤¦æaòdolÜ‡¸8İe¥øø1y²Şxã.ºK!Æ›	TÍ¨"‚ €ÿû¿_±eËadf¾jpŞ·n=ŠŒ!NÜ4êÛöñy}´+WFú¶	b¸õôôA ¢´´ee(+Ó-
¬«kƒV«………Øl—şĞ‘+8\àJ[§=}‡øõ7° ] ‰ÃaRNÂú»
å“¢jk[¨ T}};µH	 ,-ÍÁbÙÁÕ•1à™oo'*åîn?nÃÄØ5p
JF†ÙÙÕèîîƒµõğxÔbV2e°²2	’“³ğãWÑÚÚ…¨(_$%Å`ùòÉ°µßS
%Ö¬ù55-8~|#irÒ¯µµ+Vì‚……~bÜ_ÿîíU!-M7±íüùRLœh…C‘”ƒ™3É¾ºFII=22„CNÿÓïŸù|?DGû’®Éq¤R5±J?™W PSn+øúº€Ãa"<Üë–&VİH©T£®®Ba3ª«›ûŸ› 6C$j¥ÎAìì¬ÁfëÂU®qDP||œanş÷Ïôôô¡¶V¦Ò‡«D"İk‘¨mĞä\Ëşşºi¾~~.Ğ5Ùğòr–æ7bqŠ‹ëQPP‡¢"1
Å‰Z ÎÎ6àñ<ê‰ĞP„†z€Ív1èÅ™1T*êëÛM­Ò?ª«›¨&3“&YöOâ¾şYõóÓMçïç'ÃíÆ‰T«WóñÌ3‹Çm“„ñäØ±kxê©ï1~>ùä^£<ş6Æ  ;şyûíØ»÷âã#°cGÒ¸hô2pŠĞ‘#9¨ªj‚»»=æÍF\o\7ş!ş>}˜êøñ\”—Káè8	óæ#!!sçßÖ¹ÊhQ«5
›Q\¬›š[\,FqqÚèÎEBBtç ÁÁº	º®äóB1ìÚu?ş˜_~yy¨·I€Ê¤¥bİº½((xÃ Â==}˜?ÿ=ğxØ½ûºË1?ş-ššä8xğßt—2*òóEX¼øCüúë’æf$@u{JJêññÇéHIÉEt4Ï?¿3grè.Ë¨lÚ´2üğÃct—BŒa==}ÈÊªFFF22„øí·J(•j¨"‚è7ş{ˆˆğÂ‡ŞMw)¿³jÕçğôt ¥¶ĞĞ-xöÙ;ñÀÆuS0n*•UU(-•Pa©’’ÔÖ¶@£ÑbâÄ	àp˜àpXƒÂRŞŞN´İÀjkëBI‰.Ô¥«Y÷,—÷ Ğ-ÎãrYv—ë†  7¸bÒ$Ë›ŞF_Ÿ
mm]ƒBQúIQú×íèèPPß3a‚9¬MŠòñq”rs³ƒAc_G‡%%õÈÏ×5¢øí·J45uÀÌÌşş®TP*<Ü“'û›Â7hhhÇ‰ùøá‡«(.®G@€+–/ŸŒÄÄr-³ŸZ­Á£ş¿şZ‰#G ‡C¦GÔĞĞåËwÉdàÇ÷—ôÚÚºpâD>ÌDf¦nnöX²$kÖLEHˆ;İå¹\ÒÒzdf
‘‘!¤&¸˜››ÂÏïú~œÏgƒÇóÕé¾aŒZZ:©‰I%%õıç0*dÄdÚ!(hğ9‡ÃüÛªÕjêêÚ¨`UMM3ªªš H µB£Ñ5ÅĞOÆØdâvƒUzryD"]¨ªººUU¨¬Ô=; €jÌ¡Wùû_lüİÉYzWõ6ôùôÛxÌæi”Ø	âfÉdİÂŸR*h%H P(è™>>NÔ~Cß”†ÃaÁÊÊ‚æŸ`ìR©48r$ï¿
ÍÍxğÁX<ñÄ¼qß(ÁØee	ñàƒ{áêÊÀ¾}Ãİİ¸¦¿k€JïüùR<ıôĞh4xï½Õã®y²>ø’^Œü|ìí­±`Aââx˜??„\£ nYY™gÎ!-­™™B88LÂüùº0ÕXèÉå=(-mt.RPP…B	ssSxx\ŸV¥ŸœÈ$M‚ ŒÈG¥áğál\ºôÒPo“ •!Ë{ÀãmÁÿû€AL{Ú¶íöïÿçÏ¿ËîrŒB_Ÿ
aa¯à…–àÁcé.gTˆÅmˆ‰y))O!*Ê‡îrŒ
	PìììÚ•ôô"ÄÄ°ñÂK0cF İe…Ï>û_}u	ÙÙ¯Ñ]
aDº»ûıçªyó‚îâ6AÄP.^,Ãİw3g3ÈEˆáá¯`Ã†xøáÙ£¾í3ŞÂš5S±aÃ‚Qß6AÜ‘¨•
éí•—K¡Tªann
6ÛAAºÅz\.!!îğöv¢í¦Z­Aee#Š‹ëQX(FQ‘%%õÔb;;;ëş†,ªæà`·¿\`"“uC"‘£±ñ÷¡(ı4©ÆÆ¼ligg=(¥Ÿ¥ÿ3&“WW™rA%¥Rªª¦şEöUÈÏ¯CE…™\r+::8uª ÉÉY¸|¹ÆD$$D 11|¾İå­V‹gŸ=€#G²ñãëÃ¦»$ƒ$6aùò]	ñÀ·ß><æ“Œ´òr)¿†ƒ³P[Û‡…¤¤h¬ZÅ7¸)º†âÆI‚YYÕèééÃ¤I–	q4IË%¡F‚í(+“ ¸¸.T¥+˜ššÀÛÛ‰êTêÏã¶'2öôô¡¼\
@:hJÖ«¸\7„…yë$H¹\ªªFTU5¡¢¢±?\Õ„ªª&ôôè&;8L‚ŸŸ51+$D÷÷p;÷&õÇµúi|ùù"×£««—
êÂdº	aS¦øÀÉÉf¸~l‚“T*D¢TV6¡²R÷¹­ªjDEE¤R ]ÒËËşş®T ’ÃÑ}vŒ‰4ÿc‡R©Æ?fàİwOB©Ôà_ÿŠÅ£Î…ÍÍ7"Æ–êêfÜwßntw÷aß¾Çó »¤acì*@·ŞrË–Ã8t(÷Ş;¯½¶ü–x‹ÚÚ¤¥!%%YYÕ°²²ÀÌ™ˆÀ¢Ea¤™qËnüŠÁ˜ˆ¸¸$$Dböl.&L0§»Ä¿E©T£¢BŠ’’†şº{uúÉ¹66–àpXvï¿ç¥ûšœAŒMï½÷N*ÀÙ³Ïõ6	PŠŞÃŒxıõ»h­#/O„øø±}{"î½w:­µ“³g‹qÿı{‘ñÊ¸™”ÑÛ«›ı¾ùæ!,\Jw9F…¨†Wf¦ï½÷._.Gl,/¾¸“'{Ó]Ö˜–^„şsJKß!cˆógªØXbbØ¸ã@¨"Â(İÿn(Jƒ<golì@dä«8pàqÌœ8êÛ_¼øCÄÆr°ysü¨o› Òw$ÔÂ°œœ´´t ˜LÕÕN¿8ŒînÛ½(-­Gaa=ŠŠta©ÒÒ(JXX˜!0	ÏÁÁîThêÆÆ;
…R©µµ-Hdhl”SA)ık±¸*•†úKKs°Xvğö:ÅdÚÁÃÃ¶i[A‡šš*(¥Û‡ˆĞÛ«‚­­‚‚Ü¨‰$Ó¦ù“Â_P«5¸r¥fâäÉ|¨TÌÍEbb4/#—?ğÎ;'ğÙg?c÷î°x1ıMßYnn-V­úqq<|òÉZÒ©vYYB$'gáØ±kèîîÃŒHLŒÆÒ¥¤3öŸP«5¨¨h¤'33…(*C­Ö
Ğ†‡{!:Ú÷¶§Å¡£VkP[Û‚’’”–ê……bÔÔ´@«ÕÂÎÎ¡¡îàñ<¨G` ó¶+ôá"} J°ª¬l„Z­ƒa.×mĞgŸÃak	­V‹úúöşIUº°FEE#JJêÑÔ¤k¤ÁdÚ!$ÄÁÁîıçˆnğ÷w½­Ÿ`€4?¿yyµTãû;ıyôpÿÜ1Võõ© 6C P«ôSÂõ»íì¬©P¢şç1.C7K.Wà‹/Îa÷î°±±Â¦MqÏ=ÓÈµ)#%“uãá‡¿Áµkµøâ‹û1~İ%‹ñ ÒKIÉÅ‹/&ÃÖÖ
¼Ó¦ùÓ]mZZ:ñóÏ%HMÍÃùó¥011ÁÔ©~ˆ‹ãaÙ²Épu%×‰[SW×†S§
¨0•­­fÏæbÁ‚£¹¦ÓÑ¡€PØDMÕß×“Jå ®Ké§‡‡{"$Äƒ¬	‚ Ü[o¥âÒ%Nzz¨·I€ÊP¼òÊüö[%ÒÓŸ¥­µZƒøø1qâ:ôorÑq=ûì(.®ÇÉ“›è.eTq¹/áµ×–ã{¦Ñ]ŠQ!ª‘‘‘Q…;Nâ×_+©E·áá^t—5&UW7cÆŒ·pâÄ&F#FÍÍªfÎ„›	T1¶	…Mˆ}{÷>h
.\(Ãš5_  àZ:r­Zõüü\°}{Ò¨o›¿z{U()ÑMh*,¬Ca¡ÅÅõTğˆËe!4Ôaaº…uAAî´7hmíBnn-5UJ·°ÆD„†z $äú‚@__g´´t9)JÿµXÜ†®®^jú`”«+cÀ3cĞkr“‰÷¤R9’ÊÏ¯CVV5ÚÚº`aa6Û|>11ìY kÌÊÊ$HNÎÂÁƒhlì@x¸£±re¹ö¾ùælŞ|~x7V¯æÓ]Î˜pùr9Ö®ı/î¹g*Ş~;‘îrZo¯
/–!99§NÀÊÊ‹…"!!óæÃÌŒ,Jı+]]½(*
 ºŸï×ÿ{ÃŞ°´›¡	Âuvö¢¸XÜßpBwXVÖ€Ş^,,Ìú§4¹#4Ôaaõ–…7~î)JJê¡Tªìõ¡ªÀ@æˆze²n”•I¨ıNY™uÔ¹/›í2hzTx¸˜LÆßŞT*£Bdúı~
ëa2İ4dw'ˆ~†ôŸÙÂB15en`sıçˆËu#Ç47wbçÎtìÛ÷||œğÊ+ËÇ£»,b¨TlÙrß}÷¶m[Œ¥»¤Û6T ĞÔÔç;€3gŠ°n],^y%aÌNÉ.ííİHO/Â™3Å8{¶
…QQ¾X¸‡¥K#àëëLw‰ÄS_ß“'ó‘^„_­€¹¹bc9ˆÀw†İ½ıùÏÀsıô\`èc)‡++š+'‚  `ëÖ£ÈÎ®FJÊSC½MT†âäÉ|<òÈ7(*zvvÖ´Ôğõ×—ñÚkGpúô3v§¥có:Ö¬™Š§Ÿ^Dw)£jÆŒ·p÷İSñä“è.Å¨ ÕÈ:{¶ï½w
uX²$Ï>»\.‹î²ÆF‹€€°}{V­Š¡»bœÒª.^ #£
¹¹µ$PE„QØ¼ùÎ-Á/¿¼l‹¿øâ<¾üò®]ÛFËözh/,--ğÙg÷Ñ²}ÂøõöªPXX‡k×j‘Ÿ/BQ‘ååR¨TØØX"$ÄƒZ,Çãy€ËeÑ¾€K.WPáŒÜÜZäå‰ µ ¼½àww89ÙÀÚzúúTC†¤ô,,Ìàè8iÈIQ7¾&b°?[ôîããD¥È¢÷¿G"‘!55d °P¬X1÷Ş;,
¹IÇ]Ã¿ÿı-^~9?>îrÆ”S§
ğÈ#ß`ãÆ…xæ™ñuàïjoïFjjÌDf¦nnöX²$wßÍçAwycÊ­„qG*XAã•J¥X<xúpnn-šš:`ff
W*Ø¤uİİ}ıÇ•"Ô!?¿ååÒşIU©Ét|>ÑÑì[Ì¨TªQQ!Eqq=JJPT$FII=5=ŠÅ²Ã”)>Ô#<Üë¶Be
””Ôß¬Q!66ÛeĞß7İ“	ÂĞ¨ÕÔÔ´ ¤¤¥¥º`UII=ª«›¡Ri`aaWp8,„„¸ƒÃa"(È>>Nãº™‡XÜ†;NâĞ¡lL™âƒ­[—#*Ê—î²ˆ°gÏElİzëÖÅbëÖåyæf· •ŞÁƒ™Ø¼ù<<°k×½ó¤»$ƒ P(qé’ ))¹HK+„\® ‡ÃBBB"Áá5QÄ­imíÂÙ³ÅÔ´3SSÌšÅE||/ƒ­-½MGŠV«Emm+JKPV&Aqq=İÔ`¥Rı‡ÇRŞŞNäZAÄ(Û¼ùJJpøğC½MT†¢­­aa¯àë¯¢¥cISSfÍÚµk§cóæøQß¾1««kŸÿ:zÓ§¯1Á		;1eŠ¶m[Aw)F…¨FV«EZZŞ}÷'”•5`åÊ(<óÌbøø8Ñ]Ú˜±`Á{˜;7˜üN!FWW/rrjş4PË‹Eúa¸::ˆŞ†ç»ÿú×,ºËÒSO}©Tıû£eû›6íGss¾ıöZ¶OF‹Š
)®]«Enn-®]«¥º|;8LBD„x<}gqİ”&ºo€tw÷¡°P·x.;[ˆÜÜ:ˆD-Ğh´°µµ„ƒƒ&N´€F£EOOdP«5Ô÷ÛÙYÿe(ÊÓÓaL/ ˆÑ¢RiPYÙH-¤ÍÌ¢°°L&cĞ"Ú˜6ìíéiª5Ö)J¤§!99çÎ•ÀÚÚò”ƒ™3Çõ"¿[¥Ÿ¢tï½ÓñÖ[+é.gL:p ›6íÇÖ­ËñğÃ³é.gL)/—âøñkHNÎBMM8’’¢‘”Ä‡««-İåIR©BddN«áóÙ˜6Í..äï˜ †›T*šÏÎ®FkkÌÍMáç78Té=,zzúP\\ü|òòDÈÌ¬†PØ33S»aêTğùlğù~·5êf47w¢¤¤yy"ääÔàÚµH¥r˜››‚ÃaaÊDEù"2Òû¶ƒJ¥UUMƒÔ¡½½ff¦ğôt ºÂ‡‡{aòd8;şÔt‚0dúÏ‘@ éèBŠú©o66–v•iw†ìÚµZ¼şú1dd-[àååHwYÄ0KMÍÃ“O~‡éÓıñå—ŒÙ‰*ã5@ "Q+6mÚŒŒ*<úè\<ÿü´793$*•99ÕHIÉCjj.¤R9||œ°`		ˆ‰a“ëiÄ-ÑO;Ó‡©LLL0{6qq<ÜygœœŒÿØ[×X¢.TUV&AiiD¢VhµZLœ8Lé¦TëÂUt—Na´{î jk[ğãë‡z›¨ÉÜ¹;0wn^}uù¨o{Ã†ïğë¯¸páELš46OşÕ¡CYxúéPZúö¸ëpµnİW°¶€O?%İß‡	P­V‹ÔÔ<ìØq"Q+V¯æã™g‘Nê7aıú}èéQâ›o¢»‚Ò_ªbc9¸ã@²Ÿ%Â |şù9|ôÑidemƒa˜».|±±¼òÊ2Z¶ÿê«G—'Â±cOÒ²}bl»q[f¦ííİCvîçp˜´İDT(”Ôd¨‚İ4,@‘¨2Y ÀÄxÅoÂs¸¹ÙÁÕ•KÿÌ ^{{;ÁİİÜH&ˆÛ ß‡è«W¡°PŒ>Lšd‰ÁÍÈ¤ëÛ£Ñh‘•%DrrÉA_Ÿ
sæ!>^×5w8¦:Œ7yy"$&~Š…yøä“µãn!äpúä“3Ø¾ı$>üğn¬^Í§»œ1GÿùNIÉÃáÃÙË{0cF £±tiÄmM-ï{33uÁ*ı¢èƒ½S§úÁ˜HwÉaT´Z-„Âfäå]Ÿ\XX‡îî>XYY ,ÌÑÑ¾ˆf#*ÊwØÂ£MMÈÍ­¥Qõ×Á™Lø|?ÄÄ°Áç³æ9âç¸Ï¹32„ÈÊªşİñòp;o<ÇÏÏQÓ•õû=‡‡Iûy>Aª®®^”•I¨Iwùù"(•jØÚZQSØuÇ^ğós1ús	­V‹””<¼óN*¤R9yd66lX@ÖY™ìì¬[·®®|ûíÃps³§»¤[6T€î³úİw¿áµ×"(ˆ…;ïE@€+İeı9xzz1NÌ‡PØÌ„¸8æÎ†¹9i¦FÜ<™¬iiº0Õ…eP«5˜2Å		‘X¶lò¸k’3°Ùƒ@ ¥Âêµµº`•­­Ølp8Lp‘F­†    IDAT¹¬şóiğN1zê{´´tşQóe 2$/¿œŒk×jñÓOOêvû­ÿøÇ§øê«uX¼8lT·=¼øâAÕ#%e#İ¥Œº¿Hp	P>F‹'òğÖ[©hhhÇêÕ|<ÿüÒ¡îO|øái$'gáÊ•Ít—B7…ª‚0tjµwÜñ6-
5Ø	¯*•/àİwW!))†–>øàRSópîÜ´lŸ;4-ÊÊğÛo•¸zU·L"‘ÁÔÔLLìÈHoLìà`÷Q	õõ©ĞÖÖÕ’S!)©TššH$2Ô×·¡««oĞ÷™˜ 'ZÂÅÅ>>NàrYÔİ`queÀÍÍ,€%ˆa&—+PZZO-@ÏÉ©AKKçï&
ğùl„†zı²Ñ"H’’‹2!µ"<Ü‰‰Ñ¸ë®)ã¢“éH©®nÆòå»Àåºá»ï!aÚağæ›)Ø½ûöî}óç‡Ğ]Î˜ÕÛ«ÂÅ‹eHNÎÂ©S033E\‰‰Ñ˜7/˜LÄ
””ÔSÍ®^­DccÌÌLáï?xBÎäÉ>dÿ@ÃL­Ö ¼\JMiÊÊ¢¬LF'*LÅç³Áå²†e¿×ÙÙ‹ììjê3Ÿ“S‹>8;Û`êTÌ™ÃÅÜ¹Ápwù…âjµCOlõñqêwùaÁ‚°XÃÓØP&ëFY™dP°J&e0¬ÀåºQû=.—…  ·a™FÆäÆ©o']Õ@$ ÀÕ(ÛúúTØ»÷2vîLÇÄ‰Ø²%wİ5…1HMMî»ï¿èììÅ¾}#4Ôƒî’nÉxPé	lÜø=ÊÊ$xæ™EX¿~¹N÷'ÊÊ$HMÍEzz1òóEpp˜„ùóƒ‘‰Ù³¹ä¸ˆ¸%==}¸|¹))¹øé§(J*L•1®›—Ëå
TW7¡¬LB«6|°³³ªâruS«È:E‚ ˆ›÷Øcû R©±gÏº¡Ş&*Crüx.şıïoQTôÖ¨uW*Õˆ‹{>>Nøßÿş5*ÛoæÎİùóC°eKİ¥Œº;N"-­gÏ>Gw)F…¨è£TªñãxÿıŸĞÕÕ‡˜‰ì:¥¦æaıú}¨¨ØKKr…{ª.]ºq«TÍœ²&btœ8‘‡Gı._~¾¾Ît—3$@‚9sv =ıYğxôÜLüï/àË/Ï#;û5Z¶O.¥Rİßu»
W¯V!#C¹¼†bbØˆ‰ñÃ”)>ˆˆğ‚­íğßËdİHähl”C"‘¡±QŠ”jjê€Fsı2ƒ1“&YÂÄDw£I&ëF£…ƒÃ$ğxîàóı0{6^äÆ%AŒ ¥R’’zdd©bååRhµ×'vœPG¦/©T””\¤¤ä"3Sww{ÜuWÖ¬™
??ºËó¤R–/ÿ“pğàã¤kú0ÑjµxöÙ8r$û÷?†©Sıè.iÌkoïFjjÌDVV5˜L–.ÀêÕü1·ÑĞİ8±%#C™¬ÖÖÀãyZM¦µÄğëèP ;»ÙÙÕÈÊªFNN::°±±Dd¤bb|ûÏaÙÃò{[©TSá¥+WÊñË/èéé—ËÂÜ¹A˜3'S§úÚ}¹\k×jğë¯øå—
äåÕB­Ö"(ˆ…;îÄÌ™˜6-`XïËuvö¢¸X@Ú®¡  
…’šH=0PêI&"Ä”J5Š‹ëû'Ué!JJê¡Tª1i’%x<DFz!:šèhßaE‚öön|ğÁi|óÍe„…yâÍ7WbÊºË"†‰LÖ‡úyy"|şùıX°`ì4È ªëT*¾üòŞ}÷'DFzcçÎ{ö>›!©©iAzzRRr‘•U++Ìœˆøø,^6"÷Qã¥P(qé’ ))¹8uª İİ}ˆŠòEBB$–.““şF‚¾áƒşÜD  ¸¸-- ®«ÂÃ½úÃULğxäš.AÄî¿7'áãïêm 2$ÍÍˆˆxß~û0æÍ•mîŞ}o¾™‚óç_ ›Mn87™¬<Ş|ıõCˆ‹ãÑ]Î¨Û³ç">ıô,®]ÛFw)F…¨è×İİ‡¯¿¾„O>933S<şø\<ôĞ,²Hj€²2	æÎİ³gŸGp°İåÄmëììÅµk$PE}îºëØÛ[ãë¯¢»”?tìØ5lØğ(/§/@ıÃWñê«G l§eû„áèêê¥&Ãüö[%rsk¡P(Ád20uªø|?Lê‡  ·Ûê‚«P(MŠª­mù]PJ,nƒJ¥¡¾ÇÒÒ,–\]`±ìàíí&“kë	Jeı]|Å(/—ÀÜÜ<GçqDG³áéé0EAáÆ.øùù"äå‰Ğ×§ƒa…ˆoğùº Ô”)>dêÑéíU!-­ÉÉY8¾'Z`áÂP$%Å`æÌ@²X˜tt(°råĞÕÕ‹ãÇ7’¦ÃL­Ö`ıú}¸x±‡=A[ƒcTQÑˆcÇrpèP6ª«›Áá°”¤$>\]mé.Ïèõ»Q?¹Á˜ˆˆ/ò»‘ FXMM22ª¨sÜòr)LMMÀãy 6–>Ÿ©Sı‡%T¤Ri“Sôôb\º$@AA,-ÍÃÆ¬Yºëàáá^ÃğSİœîî>dgWº.ob¢ûÙuªØ˜3'hØğªTTVêö}úğYYÕhkë ª‘‚>Xéò;ˆ R*Õ(-m !²³«QV&Z­»»=¦š2Åaac~Òea¡›7Bvv5V®ŒÂk¯-'ÇEFB©Tã™g~À‘#9xã•xà±H"ªß+)©Ç†ßA$jÅ+¯,ÃÚµÓé.iÌ¨¯oÇÏ?— =½çÏ—ÂÔÔ|¾ââxX¾|29"n‰~âxJJ.ÒÒ
!—+Àá°•+£Èæ!ˆÅm(+“ ´´¥¥ºp•B¡„‰‰	¼½ä†  7»#8Øl¶ÌÍo
(AÄÍúÇ?ş.—…·ßNêm 24±±ï`ñâ0lŞ?âÛjoïÆw¼µk§ã¥—–øöÆ£ôô"<ğÀW(,|c\.¨NIÉÅã‹ªªwÇü/CBT†£½½Ÿ~ú3öî½{{k¬_?÷ß?ƒt‡îB¢¿ÿóøÏÖbÙ²Ét—CÃîfU±±ØÛ[Ó]*AF °PŒ…ßÇÁƒÿÆwĞ]ÎÚ¾ıNŸ.Ä¹s/ĞVÃ‰yxä‘ÿ¡¶öıÛ
ÅcF£Eaa.]àâE®^­B_Ÿ
L&|¾bc9ˆ‰aßt—üŞ^ÚÛ» •ş~R”şëúú6tvöRßcii{{k0™vğñqêH1¨ ”«+îîöÔÂ®¡'n\6{6ÆÄû{#ˆñî¦lXX˜!8Ø½ª™²14-²²„HNÎÂÑ£9èéQbÆŒ $&F#>>'’.ÿÃI©TcíÚÿB âøñ'áååHwIFI©Tãşûw£¨HŒ£GŸ$SÓF@~¾fáğálÈdİ¸ã@$&FcÉ’pÒ}w‘éŒA¯ææNüúk22„ÈÌ¢  ff&	¹¨š6ÍXBEõõí8w®çÏ—áÒ¥2Èå
øú:cîÜ Ì›ŒØXÎ¨ŞkkëÂ•+øå—r\¾\ŠŠFXX˜!*Ê³gs1~x<÷;n¿ñüA  ¦¦€.TÅá°Àá°È9Aü®®^\»V‹¬,!rrj]ƒ¶¶.XYY`òdoLŸ€iÓüå;&ÏµZ-’“³ğöÛ©èíUáùç—à¾û¦“ëÔF@«Õâ³Ï~ÆÛoŸÀƒÆbÛ¶055ìı;	P­·W…÷ß?…/¾8‡Ù³¹øàƒÕ`2g*ŞhhkëÂ™3ÅHMÍÃ…eP«5˜2Å‡L"ş–¾>®^­BZZËAss'¦Z¾|
\é.Ñ`i4ZÔÖ¶ ´´ee””Ô£¤¤BaT*&L0‡ÃDp°;¸\BBtÁ*²Ï#b¼¸óÎqÇØ²%a¨·I€ÊĞ<ÿü””Ô#%å©ßÖ/ÄéÓ¸tée2Vu„¼õV*Îœ)¢u!òòD¸óÎqåÊf2şx‘ •áiiéÄ_œÇîİÀd2°aÃ¬Y3uÜ_}+VLÆ3Ï,¦»‚qC-€€€ &ø|6	Tq[6nüu8{ö9ƒ^tñÏîµõ|şùı´Õpé’ «WÒÒ·Ièd¨­mÁÅ‹\¼X†Ë—ËÑŞŞË³gs1kwÜ8ä™¬ûCQú×xÉÌÎÎ>>ºIQ×vƒ^»º2şô3ªTª‘‘!ì_|VŠ’’ªkøŒşı‹D†g‘A¿×ÙÙ‹âb1µàñêÕ*ˆD­033…¿¿+µÈ1<Ü‘‘Ş¤9Ê(ÑO’INÎBMM5IfÕ*>é^;BNF:|xBBÜé.É¨uvö"1ñSÈdİ8zôI0™ºK2J}}*\¸P†ää,œ:U 33SÄÅñ˜¹sƒIÇİQ —+—W‹ŒŒ*äç×!'§--077…ŸŸî÷,Ÿï‡˜6™¿à” Æ©T†_~©À/¿Tà×_+P]İŒ	Ìåƒ9s‚0wnğ°„ŠT*²³«qî\	Î+Ea¡66–˜??K–„cŞ¼`X[nàA*•áòårüòKÎ+…T*‹e‡B°`AfÎäŒxMMM(*£°PŒÂÂ:ŠQ]İFc"BC=êÏ¡¡d’ßKÑO«Õ¢²²	ÙÙÕøí·J\½Z…êêfXX˜!2ÒÓ¦ùcÚ4ÄÄ°ac3vÂñ½øøã4ìŞ}<vìHBX˜'İeÃàøñ\lÜøæÏÁ'ŸÜkĞA? úsYYB<ùä÷èèP`ûöD,]AwIcROO._.GJJ.NŸ.DGÇõIBË–MF` “î‰1D­Öo¤¤ä!%å;¨ÿŸââx£:	w,S*Õ¨ªj‚@ ›R¥oüP[Û
­VwÂå²Àå^oşâ1¦µ‚ nÆ¬Yï`ÅŠ)xúéEC½MT†æÈ‘lÜøŠ‹ßÑ_JÅÅõX´è|ôÑ$&FØvÆ»{ïıÎÎ¶Ø¹óºK¡E[[x¼-øá‡Ç0k—îrŒ	P.±¸;w¦cÿş«pÅÓO/B||„A/tI>¸&˜á‹/şIw)1êH Š ˆáÒÜÜ‰˜˜mØ¾=	«Wóé.çOñù¯cíÚxòÉ´Õ›[‹%K>BFÆ«ğôt ­bdôôôáâE.\(Å……M°¶€éÓı1kS¦øÀÆÆ
rH$²şgù ×uumP«5Ô¿ÓÎÎúOCQL¦<=şvs}·îŸ.Á¥KtvöÂÏÏ…êÔ=uª	ûÄP©4¨¬lD~¾™™BddQQ!…Fs}2†>0Åç³agGËGS{{7RSópğ`&23…`±ì°tiî¾›ÏƒîòŒŞæÍ‡±ÿoØ¿ÿ1LêGw9ãBkkV¬Ø3>üÙçŒ0™¬))º}LVV5˜L–.ÀªU1dáê(ÓOjÉÈ"#£
uP(”°±±Dp°;õûxêT?x{;Ñ].Aúúv\¹RË—8w®MM`2˜3G75j¸&××·ã§Ÿòqòd>22„°°0Ãœ9AX¶,‹…ú¢r­V‹ÂB1Îœ)Æ™3EÈËÁÂÂ3gbÉ’p,Z6j÷U»ºzQ\\ßª£¨HŒÒÒôõ©`iià`w„†z ,Ì¡¡v#Óú¢_cc®^­4eOß€(6–ƒY³8˜6Íft—ú—„Â&¼ğB2®\)Ç=÷LÃ+¯,#“Œ@V–ëÖí…··#¾ùæ_Ûü…¨şZOOŞ~ûöî½„øøìØ‘Dîİß†Ş^22t“„ôá',XÀCBBbbØãvíqë4-²²„HIÉCjj¤RÙ ÿŸø|rMóVÉå=(-m€@ EY™ùù"””Ô£³³Àï'êr¹,¹‘FsAŒYÑÑÛğğÃ³ñè£s†z›¨T*ÇäÉ¯xà$1ñSôö*qüøFrp:‚¢£·áÁcñøãóè.…6AA/aË–eX»v:İ¥ 2|ååR¼ÿş)¤¦æaòdo¼øâÌœÉ¡»¬Q·}û	¤¥áçŸŸ§»‚ ]KK'rrj‘!¤U&&&ğ÷w¥U³fqÈ"*‚ ~çı÷OáÿûYY¯ÁÒÒp/PÊå
¿Œo¾yqq<Úê¨ªjÂÌ™oãÌ™çÈ4#!“uãìÙœ8‘‡óçKÑÓ£„«+°±™ F‹ÆÆÔÕµ¢»»ú>KKs°Xvpuexfzíåå8ì¨•J5®^­Âùó¥øùç”–6`âÄ	˜93Z¬æãC‡Äp“Jeı‹³…ÈÏ¹@›ÏgcêTÿ!'Ó#ïÏ¦ÃÌ›<î§x–wßı	Ÿ|r_~ùO,YNw9ãJCC;–/ß&“||Ô'tŒW••8z4‡e£ºº™šr—˜C¦Ñ``À9?¿™™BÖp‰a“Å‹1ô¡¢ŸÖ5öÈÉ©‰	å‹¹sƒ1oŞğL§jiéÄ©S8q"—/`iiÅ‹Ã°bÅdÌDËÄ¥ææNœ=[ŒÓ§qş|)”J5¦MóÃ’%á¸óÎp°Xv£ZÏû@@‚ÂB1ÚÚº¨©¸º.ğL„‡{!*Ê—Ü&è¦¼]¹RÑß°°uum°µµÂôé˜5‹ƒ9s‚àççBw™H«Õ"99¯¿~ææ¦xùåx$%ÅĞ]q›ª«›qß}»¡Tª±oß¿Àá°è.éwH€êæ?_Š§Ÿşï½·šÖ{\Æbà$¡“'óÑĞĞOO,Z†…y˜>=€Lä$nš>L•^Œ'òP]İ//G,\JÂyÃ@*•
U	Rªùƒ……Øl—Aç)ŞŞäïœ ƒ¼›7ÇÿQv¨ÑŒoaùòÉxá…%#òïOK+Äºu{‘’²S¦øŒÈ6 £C  úÒmÁ‚÷0o^0^~9îRŒ	P¹¹µøè£4¤§!&†—_W}ÎÆ¦MûQQ±cLt#ˆÑtc JßAª‚¨¯OEMuzöÙÅt—ó§22ª°bÅ'ÈÌ|ôM~jjê@DÄ«8|ø	L›æO[ÄÍéëS¡­­R©|ÀC†šš””4@$j…\Ş3è{,,Láèh3ä¤(ı×¾¾Î£:ÕiàÍÀcÇrĞÜÜ	'ÄÆrÇÃ¬Y\ƒ@ÄX#—÷ /O„ŒŒ*äç×!;»­­]077…ŸŸ+ÂÃ=Áçû!&†À@&LMÉ<:åç‹pğ`ÉF{{7î¸#‰‰ÑX²$“&YÒ]Ş¸²oß¼ôR2ŞÖ¬™Fw9ã’PØ„åËw!$Äß~û0¹^6ÊnÜEEù"))wİ5…ìhÔÕÕ‹¢"1òóë¨É‘55-  'ÄÄ°©`Ud¤7é|L·©««W®T =½gÏ– ¡¡ÿÏŞ]ÇUuÿİ Œ	X 6(ÆÄÆ[™±Pgí«›ÓÓsSgÏšñ››³»ÀÙ‚¢‚I
("·~ W™ (q/ğy>>ğÂ¹ç¾y çó9ï¨\¹,]»ZçZòaTT<‡İdÿ~/<=ŸP¾|)zô°eàÀf4l¨›i£‰‰©œ>}‡#G|9}ú		©ØÛW§wo;zôhL…
¥u¼Ö—^XuófÏÅ¼U\jm]M E^``.páB çÏ“ˆ¹yZ·N[‡kÓ¦^/DEÅóË/‡Ø½û;ÖgîÜ¾T­ª»ut!ç^¾LdØ°¿¸};„µk¿¤}ûzº)Q@õabc“øé§}ìİëÉàÁÍ™5«§¸NÌEşşá¸»ßäĞ¡›Ü¿Aùò¥hß¾..iÛ¶®X>HúïÓşı^<zôŒ*UÊÑ¥K#\\lhÒÄRÜÈ©©J"¸{7ÿpîÜ	ãîİ§DDÄ P¶lI4¨LƒU´ÿj×6Ë‚ è‹X¶l }úØgöeQ@¥&NÜùª+Ş¸\ß·J¥¦cÇEÔ©S‰µk¿Èõı¯yzââò;W¯ş„¹yÑí.=lØ_ÊX»öK]‡Rhˆª‚çòåÌŸ/¯@ºtiÈ”)İô²Qn»s'Œqöì”"ñı
BNdUPÕ Aš6µÄÁÁ’6mêäk2¸ º·s§“'ïâÚµùŞ÷Cıı÷E,8Âİ»suÚq*9YA“Ù´i;Ö×YBÚä¨ğğX"#c	!22–ÀÀ¨…RÏÅ¡V¿^–*^ÜĞœ¬ÄÀ@‚…EEììÌiÙ²6uëšajjDÅŠFzqó#}’Š»»Çß&..[[sºw·¡{wë"½ ¹)11•Û·C2$„iÉ„é…RÖÖU±±1ÅŠz"$$šƒ½Øºõj†‰/ıû;ˆ	`yìĞ!oZ·®óÖÔ–cÇn1bÄF¦LéÆØ±tœ ¤5\0àœœ°rå·Îk.^ NJT¬(şVòÊ»&âµkWOtÁÖÿ-&¸~ı1/_&j;;8Xj«¬¬LE×cAøHéÓ©öÁÍÍ‡ÇÓ’»w·ÆÙÙ;»ê9¾ş
ŠâÀovï¾ÎÃ‡‘4jT•Ï>kFŸ>v:k–’¢äüyôæØ±[¤¦*iÓ¦½{ÛÓ¥K#½˜™~Õ	>„û÷#Ğh4—ÔvO/¬ÇB¡¨JojtòäNòÃß?œ2eŠÓ¦M:vl@§Nôn¢åµk˜2e7ÁÁ/˜0¡cÆ´×‹µNáã¤¦*™0a‡yóë¯}ùâ‹–ºIKP}7·›Lº‡2eŠóûïE£¾<ÅÉ“~¸¹İäÆ'o·ëÓµ«5¥K‹Â5!ûş[œW¡BiÚµ«‹‹Kc±Æ“^¾LäÎ0üıŸâçÆíÛ¡¦UÕ­[‰úõ+Ó°aZQUıúU02*®ë°A(‚RR”XZNâŸ¾Îj ( ÒG{öÜ`âÄÜ»7%rwnëÖ+L›¶—sç¦R½ú'¹ºo!£íÛ¯òÓOû¹ÿ·"½àñóÏ¹víG|¯ëP
Q@Up<éÇo¿!  œøá‡ÎTªTV×aå™ÔT%µjMaÕªÏéÑ£±®Ã„åùóx¼½EA• uNN‹©W¯+VÖu(ïõı÷Û	Öù:‚F£¡Zµ‰¬Yó..âü#/$'+´P±E½U(R©Ö>§X19ffÆ˜˜½ñ1íÿFrñâ}¼¼)W®]º4¢K—†8:Zé]·X•JÍ¿ÿŞãÀ/Nô#!!;»ê8;§Mérúš *•š"µÉÒ¾¾ÁÜ¼„B¡ÂÄ¤66æÚA{ûêbMDÏÄÆ&qüømöì¹ÁÅ‹÷111ÂÙÙ†šÒ¨QU]‡W$xyâìü;5jTd×®o¨\9mÍéÒ¥¼Aƒš1o^?G)@ÚúîçŸ¯gàÀŒ?“Õ«O3oŞaúõ³gùrı¿(bbqsóa÷îëÜ¸ñD»ôX``”vú¤¯o0>>Á¤¦*)S¦8uëVÂÁ¡–ØÚZğÉ'º›$#Ù;a¸»ûàæv“‡#©T©,İºYÓ§=¶¶æ9Ş¿‡Ç#¶o¿†›ÛMT*5İ»Û0th+ìí«ç<ø”˜˜Êñã·Ù¿ß“sçü10Ñ½»ƒ5ÇÁ!çÓ¸rSll2÷î…e(0}ø0•J­=¦UÕ©cF½z•Ex¡È	~Á¹sşœ<éÇ¹sş¨Tjìì,pqiLÏ¶zÓ¤ 5UÉ²e'øã3ØÙY°tégXZVÔuXÂGÒh4,]zœ%K3|xk~ş¹—^äˆ‰ª÷ìY“&íâÔ)?†udÆ½»WQX„†Fsôè-NôãÊ•ÈdRZ·®ƒ“Sºti$®í„’^Luòä|}ƒ)W®:ˆIgyM©Tóğa$á„¿sª®••Ù«¢„ y+**Ff°wïXZ´È´ ^Pé£°°—4iò3»wÿO?­•kûMNVğé§óèÚµ¿şÚ'×ö+dîçŸrõêC ëPtêï¿/°xñqüü~Õu(…†( *ØÔj‡û0şaBC£quu`Ê”nT¨P8/ü[·O¶üğC]‡"Úóçñ\¹ò Ç\¿şXT	Bpùòúõ[Í‘#ßÓ¸qÎ“TòZ‡‹h×®.?ıä¢ëP¨Uk
sçöÅÕÕA×¡())J^¾L "âíIQéÿúô%qqÉÚçÊ)W®$¦¦Æ˜šajj„…E……R•+—¥L™ŒİÅ|}ƒÙ²å
x‘”¤ eËZÒ‚.]éåŒÀÀ(vì¸ÆÎDDÄÒ´©%..6tëf]¨"B^{sº„‡ÇcnÜxBt’    IDATRR*%KÒ A•ÕëÔSõÑ§¸H¥:uj(¦¸èÈØ±[8tÈP®\Ivïş•JMïŞ«h×®.«W®I\BšãÇo3bÄß|÷]'&LèÄ¯¿º±ví¿h4 —Ëğòš-…òYfÓó\\l0ÀjÕÊë:<á?
=ãúõÇÚÂªôé,o&ç88Ô I“ê¹Ş°R
»»wŸ¾šL•ÖÉ½^½JÔœ¾}›äxšK||
‡y³yóe||‚±¶®Æ°aôêe«Óää/8tè&;v\Ã×7˜š5M8°ıû7Õ›¢‹ÿJHHááÃHí”ª´Âª`RR”Ú©}é×Té‹7ĞuØ‚/ââ’9yÒwwşı÷.jµ†–-kÑ£Gcºwo¬ÓîŞcÂ„øû‡3qbgFn‡L&®£ª;=˜<y;7dÅŠÁ:?ŞŠªœÛ½û:Ó§ï¥J•r¬X1X4ÙÈcÑÑ	œ:uwwŸ·Š`m033ÖuˆBÅ‰¯'— cÇú¢˜*EDÄñêZ%­Äƒ¨ÕŒŒŠS§N%í½++S76Åª‚ äš'OÓ²å\Ÿ˜Õ9œ( ÒWÍšıÂ€M™81÷Î—/?ÉªU§¹|yºŞ.ò&ƒ­ÃÄ¤¿ÿ>H×¡èÔ©Swøâ‹ÿÃßş[IsÂÇT…ƒB¡bçN-:JjªŠ±cÛ3|xk/¤å¶‘#7¢VkøóÏ¡ºE
•gÏâ¸zõá{
ªêêÅ A>Î°añâEŒÓu(ï•’¢ÄÊj*+W¦G[]‡C£F3˜8±_}%n¦‹‰IÌ²(*ıqddo.—ÌP•öÿ×…R¦¦F˜˜e»CXddÛ¶]a×®ë<yòœªàêê@Ÿ>özy]“šªäøñÛlÙråÕ$•2ôë×”Áƒ›‹‰Ş‚ğââ’¹{7ìU’ócmB™LJÍš&’úlm-ÄL=çëÌîİ78pÀ‹èèìí«Ó¿Szõ²£tébº¯HŠŠŠÇÖv6J¥
 ¹\J±b†XX”ç“OÊ°yóñw¥‡¶n½ÂäÉ»iÒ¤:OP«ÓÎÅärßß‰ï¿ï¤ã‹®ôãÜşı¼|™(s„8ß„¼ñf”ÔT;7dÈ´jU;Ç]Ã==Ÿ°aÃöÁÈ¨C†´`Ø0Gç2øù…²mÛ5öíó$11'§|õU+Zµª­Ó¸²#½ü›“}ïÜ	#!!¹\J&Ú)UVVf4iRråôo]FrS||
§N¥%QŸ9s‰DB×®0ÀGG+6šP*Õ¬[÷/‹£aÃ*,]úVV¢‰LAuñb _½‘ÚµMøûï¯uÚCPåààL˜°k×1jT;&Oî*®#òARR*/ŞÇÍí&Çİ"11•†«âäTŸ^½ì¨YÓD×!
HHH4ÇİÒS•)Sœ6mêĞ±c}ºw·¡dIÑp%¿ÄÇ§pçNh†Âª[·BHNV¼Õ ¢N36¬"®UAø(~~¡89-æòåéYåvˆ*}5~ü6BB¢Ù³ç¹²¿/hÙòWFj'nºå“&M~fØ0G¾ù¦½®CÑ©û÷#hÓæ7NšDıú•uN¡ 
¨
—„„6n¼Èòå')S¦ßß‰Ï>kVhº4/YrŒıû½¸xqš®C„Bí]UV88XÒ¬YMQP%DpğZ¶œËš5_àìl£ëpŞËË+gçß¹ti––uÍšıÂ—_~Z$®Åbb	%22–ğğ˜W3>	‰F¥RkŸS¬˜33cÌÍ3/Š255¦J•r¹v>zûv(şy¼)]º}û6ÁÕÕAo¯ÃÃcX·î,;wzŸLûöõ<¸¹˜¤"@L„ĞoÇ88X~PÂkXØKöï÷dÛ¶k<~üLLfÑ3Ë–`éÒ¨T*íç¤R	r¹ŒU«†ˆsÊ¢(5UI·nË¸w/µZ¼ş›,_¾ŞŞ?‹Ä,ûï¤=™LŠ“Sƒš´\.ÅÔTtÍÎOYM¼,UªõëW/á$$¤pğ 7Û·_ÅÓ3êÕ?á‹/>åóÏ[PªTÎŠK#"bÙ²å2ÿüs‰øø\]=ºr)ú“’¢äğa6mºŒ‡Ç#êÖ­Ä°aôík_à®cŞ<úú†àíÈóçñ ®Ó¬­«acc‰‰hÈ+N±±I<èÍ®]×ñô|B¥Jeéß¿	ƒ5ÇÜ\wÇÿp&LØŸ_“'weôèvb‚põøñ3†ù?Ôj5›7¤V-İzˆªÜ£ÑhØºõ*³f n]3–/¬³ŸkQ”’¢äüyNôãØ±[<••NNprªOÓ¦¶Æ)maa/9rÄ—“'ı¸|ù††rZµª³³]»Z‹¦9:Ş "  œ€€ğw^«XY™½úg*şîAx§«WÒ§Ï*||ædÕ¤GPé«;=˜:u7÷îÍ§X±œ&œ1c?zqùòOâ>(*,-'±~ıWtëf­ëpt*%EIíÚSXµjˆ^t£/DUáÏÚµgY¿ş,˜4©+ÎÎ6ş„ßİİ‡1c6qÿşo…nº– è³Ì
ªd2	õë¿.¨jŞ¼¦˜)zjöì9âËåË?ˆ‚/1¾;wïÎÓ‹›ºmÛ.ÀÅ¥1'vÖu(-9Y‘å¤¨ôÿ‡†F“¢}Nza”‰‰Ñ2<®Zµ\“š²ëêÕ‡,]z‚‹¨[·_İš¾}›äÊG^
Šbõê3ìÜéA¹r¥6¬8`jj¤ëĞAïFi¥Ò’ñ‚IIQR¦LqêÖ­„ƒC,±µµĞiç]!íıå»ï¶áæv“†Ñµk£wn›Ìñã·Ø³ç/ŞÇØ¸ÎÎ6ôë×‡ùµğ>J¥;»Ù<÷Ö×$		,\8€Aƒšë :!+		)|õÕ®^}˜¡Ø=T*aÅŠÁôéc¯ƒè„ÌÄÆ&qüømí1ÑÄ¤ÎÎqq±ÉÖ1ÑÉi1AA/Ø°ah˜`RX©Tj<È8™åæÍ 
Õ[b*‹ díŞ½§lİz•;®ah(gøpG†wÄØ¸dö›œ¬`ÇÖ®ı—°°hœ3n\GêÕ«”K‘¼Û·CÙ°á<xQ¼¸!ƒ7gøpG*U*«ëĞ>Ú›EUé]àßl~‘ ˜~\‰ŠBaóğa$»v]g÷îëDFÆâäÔ€áÃùôÓœOØû*•šµkÿeáÂ£ØÛWgùòA¢aIÀĞ¡áïÎ†CiÙ²V¾Ç 
¨rßıû|ûíVüıÃ™8±3cÆ´×‹{bE‰J¥ÆÓó	nn>>ìCxxÕª•§S§†¸¸ØĞ¤‰¥ø™ÙöâE§OßÁİİ‡³gï!“Iqt´ÂÙÙ†.]‰\~Á;aÜ¾ŠŸ_Ú¿àà@Zã©ª¼jş¶£ËBxAôÏ©Swøâ‹ÿãÑ£…Yå,‹*}E‹¿²ÿ8š5K»ñ¢P¨xüøµkg½0õòe"¥JËĞ•0((ŠÖ­ã—_zóùç-ó%ş¢.$$‡9¸»ÇÎÎB×áè\›6¿Ñ­›5S¦tÓu(…‚( *Ü=zÆ‚Gpw÷ÁÎÎœiÓ\hÑ¢¦®ÃúhéSèNœø†«è:A(²"#ã¸ví!.àáñ˜€€pär©(¨=ŸB“&³ùî»NŒÓN×ádËÄ‰;	|k”sªk×¥|úim~úÉE×¡¼E¡PñâE|–EQ±F“¨}ŒòåKe:)ê¿õ‡Ç#-:Ê¥KhÑ¢&ãÇw¢U+İ$dÇ“'Ïùã3ìØqJ•Ê2bD†i!Šÿ!ÿíZ~ıúc^¾LÄÀ@†¥eE,iÚÔR$×é¡§O_òùçğµZC‡õùçŸ¯ßÚN¥Rsùòvï¾ÎáÃ¾¨ÕjZ·®C¿~MèÒ¥‘˜†£‡Üİ}5ê2¹Õ£%‘H˜>İ¹HLè,^¾Lä³ÏÖpçNJåÛÅS R©”ºuÍ8ujR>G'dGhh4xe{*_ú©D"A*…ŸîÍ°a:ˆ\ÈLbb*·o‡d8Ç	Ò:;8Ôxu~Ss½m
!º—Ì¦M—X½ú
…ŠÏ>kÆØ±ís¼F¡Tªqs»ÉªU§ñ÷Š‹Kc&MêJºŸ|ÏÖ­WÙ¸ñ"QQñôë×”±cÛëÅTöÜ›Ä½{O3<ˆ@­Ö`dTœ:u*e(6­UË™Lÿ@	Â»(•jõå¯¿.píÚ#êÔ1cØ0G\]04Ìÿ÷ı{÷2nÜV‚‚¢˜1£C†´È÷„œKIQ2~ü6ñeÉ’Ïè×¯I¾¾¾( ÊJ¥šuëÒ
76gùòAT¯ş‰®Ã*²üıÃqw¿ÉÁƒŞ<xIùò¥hß¾..iÛ¶®XÇ²-::S§^SI¥Z·®ƒ“SºvmD…
¢1œ>ˆMÒTİ¾Š¯o0D¢R©)W®Ô«u›jÚÂª*UÊé:dAtäÀ/¾ıv+AAK²ÚDPé³&MæĞ¦Uª”ãâÅûxy’šªäğáï±µ5Ïô9­ZÍ'>>™ï¿ïÄÀÍ04”3fÌ&nİ
áß§ˆÃ|rıúczö\§ç¬İu*·Œ½‰äd7×u(Ò=7ğ÷×>N'ûß¤¾Ö­­pt´ÒEˆB¸y3ˆyóÜ¹xñ>VÌšÕ“úõ+ë:¬¦Tª©Uk
‹»æû¢  YU‚ ¿6l8Ï¼y‡ñôœEÙ²9ëÚ›_œœãèX›™3{ê: úö]Eİº•™;·O¾¾nLL"áá±DFÆóêcÚãÀÀ(""bxö,µúõ2Œ±qÉ÷EU­Z®@$¢<yòœ_uãÈ_>ı´&tÑëF ¡¡ÑÌëÎ¡CŞÔªeÊØ±èÕË®@L}„ü’‚Ÿ_¨6qîúõÇF`aQA[(em]•ÆÍu’T$d§ç¾üòObc“´Å2™Ÿ9Úæ<şşáìÙsƒ]»<ˆŠŠÇŞ¾:..éÛ×^LßĞsiëĞ¨Õ™â ÚbÆ«WÌõÀÿş·™ıû½²µ­›ÛwØÛWÏÛ€„ñõf÷î8àEttööÕéß¿)½zÙQºtÚô×ùó³fÍ¿(•* $èÕË¥K?Å8z*22Ÿ mñ€§ç^¼H@.—R£†	ÖÖUµ…Uµk›Š.çB‘ŸÂ¦M—X·î,qqÉæÈwß9åx}Y£ÑpêÔ,8Â½{OéŞİ†ì®‰Ê
…Š¼X¹ò=£C‡ú|ÿ}'7Î<£ ‹OáÎPí”ª7'§7ÓH/¨Jÿ(Ó•Ÿ_(6\`ÿ~OÊ•+Å¸q<¸E¾¯y¤¤(Y¼økÖœ¡K—F,\8@4×-€4K—géÒ|óM{¦Më'Í†nßåĞ!oŞÌ İ²å
ööÔ«÷:Ç¤bÅ2ŒÑZ4<Êwï†1nÜV‚ƒ_ˆBG=áïÎ©S~œ8áÇO02*AëÖVtìXŸnİ¬)Uª˜®C
ˆ˜˜DNœğÃİİ‡sçüQ©ÔØÙYàâÒ˜=m©X±Œ®CŞYSœ× JP§Y†ë”:uÌt² ù`óæËÌŸ˜;wæfµ‰( Ò'II©xz>áêÕG\¸€—W *•CC9J¥J›duşüÔªeòÖóÕj? RiJ¡|ùÒ¸º:°fÍşïÿ†Òµk£üş–Š¬C‡nò¿ÿmæñãE"ù
X¾ü$Û·_ãêÕŸtJÔºõ|=z†\u¤B¡¤W/;V¯ş<#òÃ…üòË!îÜ	£{w¦Ow.pcg;v\D»võ˜>İY×¡‚…ˆˆX<<eYPÕºµM›ZŠ›‚Ç4­[ÿ†£cmæÍë§ëp²%5UIíÚSY¾|½zÙé: †YOÅŠeX¶l`®ì/9Y‘é¤¨  (m¡TXØK
•ö9ÅŠÉ133ÆÄÄèFÚÇææ¨\¹l¡hr’šªdéÒã¬Yó/––™5«'íÚÕÕuXYJMU²rå)şøã_LM˜>İ™®]­EÂ£Pä)•j>ŒÌ0YêöíÔj¦¦Fn05mjY`Š|Ø¿ß‹ñã·¡VkP©^ØÈdR~ø¡+¥J²cÇ5îÜ	£V-zö´¥_¿¦XX¬µ‡¢êîİ§tè°0Ë¯K¥4õëWföìŞ|úi­|ŒNÈJz!÷ÁƒŞÈdRmQÍÉå2ºvmÄºu_æs„ÂÇHMUrîœ?nn7qw÷A£ÑĞ©SCúöµgêÔ=„‡ÇdØ^.—Ò°aU6nü‘|SDDÄàáñÇŠJ—.F½z•±¶®†ƒƒ%ÍšÕ?S¡ÈJNV°uë–.=”tfÀ€¦9NÔV©ÔìÛçÉÒ¥Ç	{Éˆmr¥@+7¨ÕNŸ¾Ã²e'¸y3¨@7Eü
…ŠGi¯!}}ƒñó%115C±iz’b£FUÅu¤P DDÄ°jÕ¶l¹¬-¤2¤e¾¯ç^¼xŸñã·¡R©Yºt ^¯»
YÛ¾ı*S§î¡k×F,_>8Ó&
şşáT©RNÛ„áC,Yrœ%Kah(2ÏU©ÔÈğ÷Ÿ_(îKèƒôBÇµkÿ¥M›:,Yâšã)œBî	‰æØ±[œ<éÇ•+Ëe8:ZáìlCçÎ12*¡ë…"))•‹ïãæv“#G|IIQj‹©\\cjj¤ë…Lü·9à»Šªjˆ{!‚P­Yó/ÿ}™Ym"
¨ôEll¶¶³HJR`h(C¡P“É€{÷æez"ƒİì7>#A*•`` eâÄÎŞš%óæ2X¿şkÖü‹·÷l]‡¢Nœ¸ÍĞ¡qïŞ<½XÈ.h–,9ÎŠ'P(ŞİEö¯¿†Ñ¹sÃ|ŒLÈ/wwæÏ?Lhh4®®L™Ò­ÀŒşßÿ6—Ì¦M#tŠ Ù$
ªA7Nôã«¯6pöìj×6Õu8Ùrófİº-ãâÅiÔ¨QQ×á 0bÄFd2)k×~ñÎíRS•DG'd(ŠJŸ•ş8<ü%±±ÉÚçÊ)W®d¦“¢,,*`bbD¥Je12*×=^^L˜°ƒ°°h~üÑ™Ï?o©×MD|}ƒùî»m„†F3~|'FŒh#nEVDD¾¾!¯’€qëVÉÉŠ	ÀÖÖUiÖ¬Fkâ!¤Q©ÔüöÛV¯>D"yk­Y"I[7.]º8½zÙÑ·olm_·üÂî‡v±k—G¦8R©„Š˜8±3ƒ5ÅÂz(  œ…räˆ/2™4C‘c:™L‚‡ÇL*U*«ƒ…õòe"z³w¯'7n<2¿ßg` ÃØ¸›6(”K
»7Ğ¯_O+¬JOÈùoºƒƒ%ÆÆ¢p@(:^¾LdÑ¢£lÚtGG+–,qÍ•÷2…BÅ–-—Y´è2¦LéÆgŸ5Ó‹óœôiY¿ıv„€€púöµgâÄ.Ejú§J¥&$$š€€pm¢¢—W QQñ o76ü½÷f!Uµjå™;·/VùCll?ş¸‡¼3¦S¦tkšĞùóşŒ¹+«Jüı÷°¹èßÿœ³zõŞ÷ƒ‘´n=ÿÛÈåRœóÇ¢)sn»qã1ß~»¸¸d~û­İ»Ûdºİ£GÏ¸ví!6Ïç‹¶/8}úîî>œ={µZóFŒ(z²-9YÁ…¸¹İäØ±[$&¦bo_—Æ8;Û`f&~—ôYúTİÌŠªş{bcc.ãB·xñ1õåôéÉYm"
¨ô‰«ë®\y˜e·AHKÖzòdQ¦_»~ı1={®Èôkr¹”R¥Šóõ×ŒÙV±ä±9sríÚ#ş^×¡è…  (š7ÿ7·ï°·¯®ëp
œ'Oóé§ó²,ª(Y²wîüšï£ã…ü¥P¨Ø¹ÓƒE‹’šªbìØöŞZïV¬8ÅÖ­W¸vm†®Cá#½YPuáB QoT98ÔÈ´cš Ù7`ÀŠ“±yóH]‡’m›6]æ—_áï?_/’U ¾ûnÏŸÇ1sfO"#ß.ŠJŸ&—áÛØ¸d¦EQo~®bE#½ù>umË–+LŸ¾{ûê,]úÕ«¢ëŞiıúsÌë†ƒƒ%K—,R	L‚›ŒO2$°ı·+¸ƒƒ%VÇ¹B ..™1c6i“Şåß'S§N¥|ŠLÈM±±IØØÌ$%E™áór¹Œ%øöÛŒÑF¬ Ì™së×#•J2üİH3¦=S§v×a„BNŒ±‘'ng˜Xû&™LŠT*añbWú÷oš¿Á	¹î¿	9×®="8ø2™”š5_ŸwY[WÅÖÖB$?…§çÆßÎ³gq¬\9'§¹²ß—/Y¼ø›6]¢nİJÌŸßOoîA«ÕôfÑ¢£„†Fóùç-ùá‡.EzúRzôDÅ€€p£€×EUVVfXY™¾ú¿i§–	Bn
ŠbÖ¬?~—ÆÌİ3ß›ìŞ}iÓöR«–	kÖ|¡÷ë±ÂÛîİ{Ê_ür¹ŒÍ›GP³¦	=£k×e$$$£Ñ€›ÛwØÙY|ğ¾Û¶]ÀıûïÈ+’°iÓ×tìX?gß„©¤¤TæÍ;Ì_]ÀÙÙ†úgxïW(Ttì¸ˆû÷#X·îK\\ë0Ú¢+&&‘óç8yÒO[ Ó°aUœœêÓ»·½Ş4Šô_JŠ’óçÓ¦Ÿ8q›ØØd¬¬Ìpq±¡O{,-ÅïRA—Ìİ»a®UÒßKEóA(ØfÍ:€·w‡}›Õ&¢€JŸ„†FÓºõ|’’YnS©’1³3ıÚşı^Œ·å½7Å?ı´»wÿ/'¡
ï1zô&
%6Óu(zA£ÑP·î4~úÉ…Ï?o©ëp
¤q÷îÓL;ärıû7aÉ’Ït™ 		)lÜx‘åËORºtq&LèÌgŸ5ÓÛnÿb
 >1xx<æÂ… ÎŸ (HT	BNİ»÷”±mÛ(Ú´©£ëp²mÒ¤]<|É¾}cóåõ’“DDÄExx‘‘±„‡Ç¾ú˜ö88øE†ëâbÅä˜™cbb„™™1ææŞ*”ªR¥œŞKé…BÅÄ‰;Ø¿ß‹I“º2n\½Njy3ŞìÎ˜1íô:^AÈ)…BÅİ»axx<Îò†ƒƒ%M›Zbm]Mïrîñãg¼èw6ê‚´É'cÇv`Ò¤®ù›Ö®=ËÜ¹nÚ©E2$	#F´aÜ¸Ef"faráB 3fìçşıp$’×…T¥KÇÇçgJ”0Ôq„Â‡JIQÒ ÁO$&¦¼gK	 aØ°ÖÌ™ÓK32ÿ-ğğxLLL"2êÕ«üê¼¬ª(
­äd?ş¸‡İ»¯3ujwÆíkûgÆŒı\ºtŸ¡C™:µ¥JËµıç„B¡bÇk,Yr…BÍ¤I]ùüóÈdbı	Ò˜ııÃ3í odTœ:u*eHX¬]ÛT¼?
záâÅ ¦OßGxx gOÛ|}ı‡#5ê‚ƒ_èäõ…œ‹ˆˆå«¯ş$00ŠßÄO?í#<ü%J¥™LJÃ†U8räû>'üã3ÌŸ•*óµ Ò¥‹ãç÷«(àÏcgÏŞcÂ„¨Õj-rÕÏŸ˜?ş8ƒZ­¡D	Îœ™Œ¹yG[´¥O:yÒ£Go¯-€qrj€µu5]‡(©©J®]{Ä‰~<èÅóç¯—zõ²£fM]‡(|€)ª²µµà“OJ¿§‚ ä»‰wş’­[Geµ‰( Ò7ÿ}‘3öeYeccÎÑ£™O5Z¹òK–'5U™é×¥R	2™”M›F¨„¼‚¨W¯•4hP…¹sûè:½Ñ£Ç
5ªÂÜ¹}uJ´n]ZB„R©Îôë»v}C«Vµó9*A×""bYºô8Û·_¥F¦OwÎµî}¹)00Š-~ÅÍm<ööŞ-Iı'
ª!ç&NÜ‰‡Ç#ÎŸŸZ ’¥:w^B‹5™=»Wö“’¢$<<&ÓIQéÿ‹&>şuâa±brÊ–-©•V eÄåËfİº¯¨R¥¥KëGâLa P¨øæ›Íœ={ÿû¿¯hÛ¶®®Cz'…BÅ¨QÿpéÒ}Ö­ûRïã„¥R©yğ R{Ç×7˜›7ƒP(TÇÆÆ‡´B);;*T7r
»ÿ½ÇÈ‘IIQ¾·x*©©^^³Ôù‡6Ù Y³_F.—¡Ñ¨qumÆ¤I]155ÒuxB¨ÕöíódşüÃDDÄhï-YâÊÀÍuğ¡ºÉ7ßlzoãÃt2™”V­j³nİ—•Èãè]ÉìÎÇ'˜ÔT¥8‡
µ¿şºÀÌ™ûùö['&OÎİ~7·›üøãäüö[?:wn˜«ûÏ‰ÄÄTÖ¬9ÃÊ•§17/Ïœ9½ÅúDŞœâ¿¸öøXªT1jMÆŞ    IDATÖ4ÑN©²¶®Š¹¸ç èDJŠ’Ù³ğÏ?—øòËO™=»W¾ş.¦¤(ùõW76l8O¿~MX° ¿h¶PÀ$&¦2zô?\¾ü…B™aZ­D"aõê!ôêe÷Aû{IÓ¦s²lÊ<p`3,èŸãØ…÷‹Mâ§Ÿö±w¯'ƒ7§G[>ûlöºP.—R·n%ş^´é	•J§çÜÜ|pw÷!""só
895ÀÅÅ†¦M-?híT£ÑğÇgèŞİFL,bŞü]rsó&22N[LåâÒ++³Úß–-W(Uª½{Ø{‚»bc“¹w/{EUööÕ)_¾”®C„"oÔ¨H`íÚ/³ÚDPéµZCïŞ+ñö|«PB"®]­ùóÏ¡™>wÊ”İìØq-Ã…U:©T¢ìèh•'±¯µl9—›1n\G]‡¢7¦LÙÍıûùÖ™¾°‰ˆˆÅŞ~v¦7ZË—/…ÏÑ±¬{ôè¿ıv˜Ã‡}iÑ¢&3göĞ«n(jµ+«©üòKo‘è!EÄ›UçÎùü‚âÅhÔ¨*5r\Põûï'¸};”¹sû`jjœËÑBş{ñ"&M~æçŸ{¨‰­
…ŠÚµ§²tégôécŸå6/^ÄgYõæãt2Ê—/…©©ñ[“¢şû83‹åØ±[œ>=9O¾ï¢J£Ñ0nÜVNœ¸Í–-#qp¨¡ëŞkÜ¸­?~‹mÛFÑ¤‰¥®ÃŠÄÄTõ¥GÛ\½	ÓÂÂÂ¸téR®Å$è3gÂ8t(ĞI®Ì;}ûmCj×.K§N(S¦LÄçááA```ì»(òó‹fıú» 4lX=,05-˜ÅåË—§C‡Ü›Dñ&•J…»»;©©©y²ÿ¼¤Ri¸t)œ£GƒILTbjZ’iÓë:¬BÅÚÚš:uò¦Ù`úûíºuw¸{÷å—+V,ÁèÑõøä1I®°‘J¥™¾ßêrŠ¨·w	4nlkû„¬ìÚu	¶3}ºcÆ´ËÕ}?{ÇŒû9tÈ››3gN/½™FiScfÍ:À™3wéÓÇÙ³{‰nåÙ’¢äîİ0nßåÖ­nßáîİ§$'+00Q¿~å	‹uëVÊÕëp/¯@bb’h×N½	osw÷á‡v`iY‘Í›Gæûß´›ÛM&MÚ‰¹yşüs¨˜fS€¨Õ†ÿ‹S§îh§J§“H$T¨Pšk×~úàÂ8gçåÜ¼˜i^Ñ¾}ciŞ¼fâ>Ì¡CŞL™²‰DB\\r†Ÿµ\.eäÈ¶üô“‹#2£Vk¸};„“'ı8pÀ›‡#©P¡4íÚÕÅÅ¥1mÛÖ}ï¹†·wİ»/£dIC–-ˆ‹‹XÏ)Š2+Ì³°¨@Çi…yï»Ïššª¤~ıé$&¦âêÚŒùóûæêZ€3ÏÅi×o||‚ñõ&<<‰D‚¥å'ØÙY`kk­­TÉµk”Ó§ïœ¬ {w›\ÙŸ Vƒ¯ÃÌ¬,K–¸fµ‰( ÒG=£}û¤¦f,„201dH‹,'ø¸º®áÂ…€·>/•J00±yóH1¡&ŸÔ«7iÓº¨äÇ¼ö÷ßY¸ğ(wîü*:Ú~¤Ş½WrıúÔê×Õ2†m•ãÿBáàíÄœ9ñğxŒ³³Ó§;ëÍBi·nËpp°¿«‚PDe§ ªY³f¯ ªI“9<}MÉ’Åùõ×Ş¸º:äñw yë÷ßO°nİ9<=gQ²dÁéyùò}úõûƒeË"•JˆŒŒ%<<öÕÇ"#c		‰ÎpSÈØ¸ä{‹¢ªV-—£æ +Wbûök\¾<=7¾Má•Õ«O³`Á¶lIëÖú?ÕzÍš™?ß½ÀÄ+GŞbÚ´=DDÄ²mÛ¨î,şfçíë×síÚC"#ãÉ¤Ô¬i¢M³¶®Š­­E¶o¾Œ;–Õ«WTL‚>“P±âWH¥%ÿóy%qY£Q Ñ¨ßx¬"&æ_Š§¬_¿#FäI„fffDDDäÉ¾‹¢%êR²dCââ.‘šúT×áäXtt4eË–Íõı?6mÚäú~ó“Db@©Rv/^ƒçÏwê÷>GÈN:qüøñ<Ùwúû­±qG+ ‘ÈHŞ^÷Häh4ÿ}×™„„›yŸ [Ù}¿Mïp|ıúc<<ãåHTT<r¹”5^Ÿ:8XÒ°aU¤Ò»÷æä´˜;wÂ0À3\D§d!Ï­__~9ÄæÍ#òdÓÑ£·˜<yeÊgåÊÁØÛWÏõ×È‰'n3mÚ^’’ÌœÙƒšŠ{çH©TóàA·n…pëV¾¾!øù…’¢m0òæ5s½z•?:a±W¯xx<ÆÉ©óç÷£råÜ?g
¶'O3hĞ: ¶m•ï“F£>ü/>á?>§M±ZÌšu€Îg9©V.—òı÷ùşûN´ß/1cÆ¾·Š²*T(Ïœ>_>ŞøñÛØ»×ó­Ÿ	¤ËmÜ8'§:ˆLÈ.ÿpNòãÄ	?®_LÙ²%éØ±>NNèĞ¡~¦÷uçÍsgİºs(•J4øê«´i…ÙÍ…
µZÃ9yò‡ûğäÉsªU+O§N³œrvêÔ¾øâO@ƒL&¥V-şş{¸˜j¦Ç""bñõÆÛ;oï@¼½‰M¦X19VÕUÙÙY|t>g›6¿qÿ~­[[±`Á ,,ô#/TôM+°³3W®²( ÒWüq†yóÜ3\,Ê?Ş‰ñã3¿@jŞü‚‚^døœL&E.—²uë(Z¶¬•§1i4?°råzö´Õu8zÃË+gçß¹xq5jTÔu8ÒÖ­W˜2e÷[‹(G|/:
œ<éÇ¬Yæ‹/>eÒ¤®é¶[é÷ßoçéÓvì­Ó8AĞQxx<âúõÇœ={hJ”0¤aÃ*ï-¨ŠˆˆÁÖvö«G$hÕª6K—~F•*åòõû„Ü P¨hŞüWúöµgÚ4g]‡@r²â“¢‚‚¢{™aúq±brÌÌŒ111zã£‘ö±¹y*W.›«`³²aÃyV­:·÷ÏyşZEÅÙ³÷øüóÿcÖ¬|ıuk]‡ó^çÎù3dÈzfÌèÁÈ‘;iZ(8<yÎ´i{8w. ‰D‚L&aüøNÙJtP*Õ<|‰¯o°6AöÁƒÔê×Ò“¿š5«‘ÑÇO™3fœ>}ú£÷!NŸ|ò	¿üòcÆŒ)û
¦3gÎĞ¡C={Æ'ŸäşÍÿ¼Ş¿Ppåõû¡x¿²’Ó÷Ãô‰¤ñğxÄ­[!$'+(UªX†),5²•D“šª¤fÍ)¨Tjär%J2s¦6	¶BúöÛ­œ<y‡“' jÕÜ_Ó}ş<‰wğï¿w5ª“'wÍ—5©ìJJJeéÒ¬]û/MšTgáÂÔ®mªë°
4•*ıº:½¨*˜Û·ß.ª²µ5§qc¬¬LßÛÀI©TS»öRR”Èå2är)S§vgØ0Gäòoş$>ÑÑ	|ñÅŸE±yó¬­«åëë§¤(™:u7»v]ç›oÚóãİÅû¸ûë¯Ì˜±ŸLÒ53(^Ü€+W¦cjjœí}¿x‘€ÍÌÅ:2FŒh#&éÀÅ‹¸º®Íòg-•J(S¦8gÏNù Ÿ³ ;AAQœ8á‡›ÛM<=Ÿ`h(ÇÑÑ
gg:wn¤ÍËjŞüW‚‚¢´Ï“É¤Ô®mÊ_Å/V˜çî~“}û¼xüøUª”£K—FŠ©ÆßÎşıÚûñr¹¿ÿ>HL5+@Ò›M§O÷ñ	&5U‰‘QqllÌqpH›4Ş¤IuÊ•{wC›øøêÖıµZƒ\.C"‰»0fL;½ºŞ}Ğ¡Ã"ºtiÈ¤I]³ÚäŠ(kÖS£FµåÀoîİ{ŠR™ö&¨R©111Êò9±K¥RŠ“³sç7ØÛ[äi¼Âk‰‰©(•jÊ”Ñm±‚¾iÔ¨*%JrıúcQ@õ‘œmøñÇ½¨Õ¯U«T)‡Mş.À	úÏÉ©mÛÖeçN,8Â¾}|óM;FŒh£³&uêTâìÙ{:ymAô…E,,*Ğ¿S cAÕÁƒ^¬^}:Ë‚ª‹ï#‘H^-6kĞhàÊ•´ió›öæ¥¸1$$nn7yö,–¯¾j•ç¯•šª$::!Ó¢¨ÀÀ(""b	Ill²ö9††rÊ•+©eaQKLM9yÒˆˆvíú&GÉü¹­D	CSuF¡ñğa$£Go¢OûQ<Àwßm¥GÆ¢xJÈ
…ŠõëÏ²páQ4Íÿ$xz>Éô9ÿ½aâëLJŠ’2eŠS·n%­˜8±3ÍšÕÄÄ¤Lş~C‚ ‚ ‚Ş255ÆÉÉXÛ¥şÍBüôÉ¥ÿ}!ÓBü¦M-)[6ã´Ê[·B´	¶J¥Šøø$¦LÙÍ_]dñbWlmEó>!o,\8€.]–2aÂvvî“ë˜>ù¤47gëÖ«Ì}€K—î³jÕ½¹G]¢„!Ó§;Ó«—-“&í¢cÇEŒÙ–I“ºˆÉI&“bee†••ıú5Ò:ı§#oİ
ÁÇ'˜}û<ILL¥T©bX[W¥qcslmÓ:Áÿ·AÛ½{OIIQiÇH¥RÅœ9Ù²å
Ë–}¦wÓÍİ)W®;waäÈôí»šõë¿¢]»ÜŸ°—•bÅä,[6{ûêLŸ¾—€€pV®¢ó«BæV®Lk² ‘À»j¨T*5sçº³bÅàlï»|ùR´jU›‹ïkÏñ
½zÙå(fáÃÅÆ&3nÜÖwşœÕj‰‰©Œõ{÷}oa¯ {ææøúëÖ|ıukÂÃc8zôGŞbâÄLš´GÇÚØÚZd(‚ôBï:v\ÄÒ¥ŸÑ£‡hÈ_ÔÕ©cF:]˜8±¾¾Á¸»ûpø°/6œ§rå²téÒˆÃ‡}243U*Õ¨TFú‡óç˜7¯¯(š) LMqqi¬-zS(TÜ½¦½?èææÃ’%Ç_mk„ƒCš6µÔ^«¼y}xóf vğBzMÁ¢EGÙºõ*K– U+«|şîA%%¥R¢ÄÛS"ß$V_ô”L&eùòAtê´Xû¹wP=¯]¼´â©âÅØµkvv¢x*?ÅÅ¥%ŠÅˆŒdØØTÃÃã1®®º§@26.IÛ¶u9{ö.J¥4Íõ›
Bá`` cÈ¸¸Ø°jÕ/>Æöí×˜2¥ÎÎ6ùş{S·®±¼x‘@ùòïî˜ BÑóß‚ªGqùò._~À=×Y½ú4%KÒ´©%qq)ÈåÒ·‹”J³fààAoV¬„¥¥~Ü„÷Ù°á<İºÙP¹rÙí'&&‘ğğX"#c	!2òuQTz¡Ô³gq¦™—ÄÔÔHûÏÚº2|®bE£,‹·n½‚ƒCÎ&¡ä…%IJT¹!11•/¿ü“ÚµMY´h€®ÃÉ–éÓ÷!‘H™7¯¯®CŠ€‹ï3iÒNBB¢3tv…´	åOˆˆˆÕIùú†pãÆ¢£Ë¥Ô¨a‚ƒƒ%C†´ÀÚºµk›ŠBpAA!Ûäré«Ä+3íºZBB
~~¡øú†¼•ŒcaQáU"NZa•—Wr¹¥2í\V£I;ÇÙùwúô±cÎœŞïí‚,ªxq–/„‹ËïlÜx‘¡Csı5$	C†´ yóšŒ»…1mš3Ã‡;êÍ½ÕªpèĞwlÜx‘päˆ/ô§U«Úº­PJ%Ô®mJíÚ¦ôí›VT¥R©yğ 2Ã5úŸG¡PadT›jÚ.ğ‘ÈdÒ×ûjµ†'OÑ£Ç
qŒ2(YÒ¿fòä]|õÕŸüşû z÷Îß¢•!CZ`eeÊÈ‘éÖm)6£N³|Ax¿³g'ãææÃÚµgyô(¹\¦M‚~“B¡bï^O†s¤qãìµ÷íÛ„´-,*Ğ°a•\‰]È¾Å‹¾Õ?3
…Š7°jÕi¾ûÎ)"r‹™™1C‡¶bèĞVÄÄ$râ„§Nİaİº³È2ä2 (iù£GoâÂ…û¢øEĞJ»>¯Æ´iÎÜ½†»»»w_'!!å­mÓ'ÚíØq_ß`şüs(Õª•Ïï…00iæé"#ãğöÄÛ;/¯@-:J\\2Å‹`m][Û´¦¾¾Áo_T*5aaÑ¸º®¥wï´ë‘—)”¤ xqƒwn#
¨ôX½z•øî;'–/?©]”ÉªëlHÈíÿe2)%J²k×˜ºˆrGll ¥K‹ªÿjÚÔ’£G}uFÖ·¯=gÎÜÒ.¤EW
á}ŒK2}º3C‡¶â·ß3zô&ììÌ™9³'M›Zæ[uëV   œæÍkæÛë
‚P0Õ¨Q‘5*2dH múIzAÕõëßZpL“6ÊÇ'ˆví2iRÆŒi/’…·<|‰¹y½X”¾qã1ŞŞAÌ™Ó;Ëm’“&EE½U(­Mv‚´“ffÆ˜˜affŒ££U†¢(SScªT)‡\şñİì
÷î=eØ°ÜOpÉ©’%Q*Õ(*½ø9dsæ$::‘½{ÿW : Ÿ9s—¼Ø²e$ÆÆ%ßÿAøH1üò‹ûöy¾•Lõ¦˜˜$lmg!‘H¨Y³"¶¶üğClmÍiĞ Š8F	‚ ‚ ¹®T©b88ÔÀÁ¡†ösáá1Ü¼„·wŞŞ?~›¸¸d,,*dÚ?ıüöàAoNœ¸ÃŒ.Ü\oŠN„ÂÁÆ¦ß|ÓÒ³§]%yÕªe‚›Ûw,Zt”Ÿ>È¥K÷Y¶là[ÙtE.—òõ×­éÔ©?ş¸W×5|ñEK¦Ow¡tébº¯Ğ‘ÉŞ.<MLLåöí·
O³šX–¾{ğàMÎœ¹ËìÙ½è×¯‰8F
ÈåR–,q¥\¹’Œ·…çÏã1¢M¾ÆààPƒ£G'0bÄFzôXÎŠƒéÜ¹a¾Æ ¼›±qI†iÁ!-ğõfÓ¦ËìŞ}&íLóÆÉ™L&åÇ÷räÈølcºu³fÒ¤¤¤(10iuBşêÚÕšˆˆXÎó'66	CC9J¥*C“Ãtjµ†Å‹Ò¢EÍçğBÁal\’şı›Ò¿SÚ¶]Àıûá™n÷fñ‹·w ş9”êÕ?ÉÏP=W¯^eêÕ«LDD»w{d‘“ö~qïŞSœœ³ví´m›“/…ÜgbR†Îf8gŒÂÃã¾¾!xyò×_¨Q£b†œték8nn79qÂ™3{ˆ5¡ÈKNTŞwß9qè7>C£Ñd9*$$H»x*]ºûö¥^½ÊùªğÊë	TúÕ…]4mjÉªU§‰ŠŠ§B…Òº§@êÔ©††r’“XY™‰AB¶U®\–+3l˜#sæ¢W¯•8;Û0mš3òüõÍÌŒ)[¶$÷î‰*A>\Íš&Ô¬iB‡õ9xĞûÛ¦-¨™7ï0‡û²bÅ`jÕ2ÉŸ@½váB Ë–äêÕ,\8@[ §+))JV­:••)aa/ñö>Ÿ¡P*""–°°hâã_w—*VLNÙ²%155ÆÂ¢ÖÖÕ033ÒJ™˜Q¹rYÊ”Éûf·n…’¢ÄŞ¾z¿Ö‡*Q"m!$11EÑäÀùóşlŞ|…5k>ÇÔÔX×á¼—Z­aŞ<wºvmDûöõtPH)*şùçóç»koRdU<iİ®¿ıÖ‰Ñ£Û‰Iå‚ ‚ ‚Î˜™Ó¥K#ºti¤]?=x«ëÚwÏ*•jâã“™2e7;w^cÑ"Wm³4AÈãÆudçÎë,YrŒ¹són’´ŒiÓœéĞ¡>ß|³™N³nİWØÚêO3Zsó
lİ:Š¼øé§}œ9s—%K\iÕÊJ×¡z%K¾UxGçÎKŞsŒTñòeãÇocÛ¶«,Zä*îEH$fÌèAÅŠFÌ}…BÅ7ß´Ï×*U*Ë¾}c™6m/Ã‡ÿÅÌ™=92¹„ì±¶®ÆâÅ®ÌœÙƒC‡n²~ıY<ˆÄÀ@B¡D©Táë„››=z4ÎÖ>K–4ÄÉ©‡û¢P¨èÕ+'¡	iZ´¨I‹iy1Qœ<éÇ±c·´Bå¤¦*µÛk4ğõ×9wnŠ˜lX€¿àşıˆL›T¼I¥RãïNÇ‹X¶l ..ÙûûŠ•JÍáÃ7³,J§P¨P*“<x=ß|Ó©S»!“}|óTA¿XXTÀÂ¢B†iã¶¶³3Zÿ—B¡B¡P3eÊnvíºÎ’%®Ô®mš_!‚^IJJ}o•8bê9Ë—F"I»Ğşä“Ì'P§M *S¦ûöÅS:›V@•I‹MÓ¦Õ‘HÀË+P×¡X%JÒµkÚ®D§áÃ5nlÎ¾}cÙ¸q8·o‡Òºõ|fÌØ¯——¬¬Ìxšç¯#BáuùòƒlwIÑh4ÜºB‡Y·îì;ot
…—Z­Áİİ'§Å¸º®áÆÇÈdRBC£óôucbñõæäI?¶l¹Â’%Ç˜<y_~ù']º,ÅÖv5jLæÄ	?"5ê–,9Î…ÄÄ$aaQfÎìÉ?ÿ|Í±cğöÍ£Gñöş™cÇ&°nİ—üòKoş÷¿ôïßGG+êÔ1Ë·ë/¯@Ê•+…¥¥şuF+QÂHË-|œØØ$&LØA¯^¶fêíÁƒŞøû‡3eJ7]‡"R—/? ]»…üüóA’’ï½yi’“S‹dñÔƒÙ?oûĞç1tèĞ~Ü’Ùë§Ç–‰„ähğñ?ƒ‚LüŞ}<ñ{—3âwïã‰ß½œ¿{¯¨ÿîI¥LMˆŒŒ}ï¶FÃÍ›Á89-æ—_‘òŞç	Bv”*UŒÉ“»°yóemÃØ¼Ô¬YNú++3zö\ÎêÕ§ß™€¦½zÙqöìTllªáêº–É“weh°$ä¹\úÇHğô¤}û,[v"CB¼Ptİ–ú3w®;+WÊ÷×74”³x±+³g÷bÎœƒüğÃÎL'úÁÈ¨C†´àÜ¹©ìÙó?ºwo„\.ÃÀ@†F³g %%ûÇ–>}ìÑh44hP%ËizBş±°¨À×_·fÏÿáï?ŸíÛG3|¸#uêTB"‘ •¦ı{ş<ñã·ëİ¹‰}GŞB*ÍŞõ¡J¥&)IÁèÑ›˜5ë@¶î7EÃÕ«ˆ‰É^ŸF“v>úÇg8p/^$äqt‚®„‡ÇŸœ-Ó×p‚èĞaK–×'B‘£VkHMUj/g¥àL òó;;HMÕu$ùÎmäÈ¾âuÈ2İ&®LK>)Ù½÷7Q»şüüP—¤RØ¿zôĞu$ZqqIH¥J•*¦ëPô±qIjÕ2ÅÃã1NNòìuğôôD­.œ@uëG&“`jšÂÙ³guN000 E‹H¥¢Î7¯895 mÛºìÜéÁÂ…GøöÎ;,Š«ãï.»TT"–¨±$šØclÑ¨1öX5’X°€Xc/)¶$ŠúÙK"JÔDMĞØkÅŠ`AQA¤Iİ=ß„e;»Ì.œßóøÈìÌÜûÎÌ™sî¹gîŞ½—1aBG|üñÛ°´4NóÀÇ§&nßV>U5Ã0ŒE‹€Y³tŞí¬CXØ4DH}|°€D ™¹21æÏ‡ı” zuC_ÅŒ©¢¢?›+Ãşıãë¯"66QÑ¦ÈË“ÁÂBŒøø½ªKIy…øøT<{–Šøø”ÿ/º—\$aÏÁÁÎÎöŠŞŞ5áìlÓ§£qùò}„‡ww'³û"ÔåËĞ¼y]“(fk›Ÿ@õêUÅ{~`(‚ƒ†\NFıú³¡	=Ş½›ÂÛ»t³ô6mÚW¯^5*¦¼`aa5Fı»DÿşÓì·sseX½z'æÎí£S}Ã‡ÇÖ­[uÖYŞ¸wïZ¶l‰ÄÄÄ"¿ïß¿}úèvNË
SÖÆhÛ#l{ŒP°í•/téÏXYÕEÕª}µ,™——‘HŒï¾;/¿\””ı…2åªU«"..666:ïÛ¿ÿëøê«£Ø°áO|ñ…¶6©?UªØaûö±iÓ),Xğ._~€U«ÃŞ^wíÆÂÉ©6lø\ÁÌ™{ñçŸ·±rå@¼õV¡¥•[ŠûO++T­úÖûçææB$cÅŠß0şR¤¤7†L¦Œ‹ÅØ·oz—rÒĞ¡m™™ƒyóÂakk‰Ñ£ß2Bí3æ-¸¹UA@À<~œŒ>âA«À”Æ}ğAtï^'O>Âï¿ßC||
–/ß‰víjkµ¿D"GåÊ–hÑ¢j¹ST³fMøøø¥ìØØXÜ¿ß(e«¢];{´k×©©9¸~ı9"#ŸáÊ•üşûlß~ uêØ—©SÆßßNNÆù˜ã7Ğ¬Y3äh<rµjaié"9òß!äSøU*‘èße±"Y.4ô¾új	ÒÓ/DcŒıŞæòåËHOOÇÖ­× ‰`a!*b;…Ã“\NE’+hÈ®    IDAT-‰§OßÁğák1uj+£i¬¨u«–y—m|!vì¹ï&-@çæ"G$Æ—_Aöü…˜™vÆPŠSÄó(„$++ÿCËšf 2Ÿª„„|'±iPYù,Lå™™Lx•ØuUºşó\9Æåìm:—±2=xüXhEHKËB¥JVZQ ¢ñúë¸tÉ¸ÏœœÈår4hĞ ‰ù¸9mñóŞy§%ªT±ZŠQÈÈÈÀƒ “É8ÊÈH¥:´úöm†ï¿?•+ãÇ/ (¨;zölbğÑÔDxøƒ–É0Œ™øûsæè´Û¹/ş†ìED"Q‘Bbm%¨a/…‹£%ªW¶„³½N•-áTY
g{K4soH¸}Vî(ÖÈÈÈÆÎ°fÍxñ"@ş——
'4Édr<yò²H1YY¹HHHEBBÊ¿ÿ§–X‹K*’ce%AÍš¨QÃ5k: qãÚ¨YÓ^±\£†=jÕª¢ôÃ
™™9øúë£;¶=<=kú¬”	ıõ C†´Z†R¤ÿ~x„¿¦¤gÏÆ`ß¾¿±mÛÇpt4>Ç­[OqåÊCÌ™Sú‡‚qqq3fºvUşü…©¸<|˜gÏ2ñâE6^¼ÈBbb&³‘––£xq%‹ ‘ˆ—GËóÛ*vvnX»v7,,´k‡„††"..ÎX‡aVÈår¼xñ¢ÄïGÅO?ı„Ç&öLøOc¾°İ1BÁ¶ÇÛ^ùB—şÌ‘#ğÛoqŠglb±"‘r¹İ,--àè(…³³-œœ¬Q­šªVµ†»ûë°³kÌCaÌˆë×¯ã‹/¾@FF†^	TR©>şøm¬Xñ¦N}·Lfğ‰D3æ-øù¹áÓO·¡sçX¿ş#¼öZ£×­½z5E›6^˜9óg|øá÷èÕ«)–/ óx^cN÷Ÿ‡=Äï¿Ç(Ğ³Xœ?È¹ ¯ ––b88XÂÉÉNNV¨R%ÿŸ—WØÛêP0zôhƒµ>şømäæÊ0gÎ~T©b‡÷ßonruáİwá§Ÿ>ÅÈ‘›Ğ§Ïlßş1\]Ë\‡©cŠãŒZµzS§®_Šzõœ`gg©õ¾‡y¡reër1víÉ“'ÈÎ6ŞlŒÙÙÙ°³³ƒ»»»ÑêPG›6ÿı˜˜'';At˜"·oß6Xr“2““ƒM›6¡²Æ#GD<FBB&,,ò“_,-óßWÚÚJ R©‰øßuùãáll$‹E¨]»ll”O¬ÀOY¼·ÉÎÎ†‹‹ú÷¯WWg €%$’|[±¶–*Ş[ZJ`m«$E|¨[·*jÖäLCbôq¬ZæEüµû.è\@ùã£Ä" ONŠç7b ª®V¨WÃµªZÁÕÑ®–håÙ°™hxíŒé`‚yB’™™ßv°¶ÖĞv&%Ì˜±‡X§l•pDDäÏ8øü¹ĞJS¢Z5¢o¿ZEBCOPÓ¦s„–a²ìŞ}‘êÖJÙÙ¹F«#))‰?N999F«ƒ1|ı„ãñãdš6m7¹¹M¦=¾¦î´üÓ§£ÉÅeÅÇ§´\†aÌqãˆ:vÔy·ıûÿ¦ĞĞ´oß_tölEE=¥¤¤t#dÌ†û/^¤ÓÊ•¿QıúAT«Örq™L..“TşkÒd½ÿşj×n1yzN/²®nİ©Ô²åÔ»÷*úä“-4{v­[A?ÿ|‰Îœ‰¦èèÊÈÈ.•ì-[N“‡Ç4zñÂ<í7>>…\\&Ñ©SQBKQÊ½{ÏÈÅe]»'´³#/OF:-§aÃ6-E',ø…ŞxcÉåòR—U­Z5úÖÄ30¦MNN=xH§NEÑ?£¥KÑ§Ÿn£wŞù’|}g’‡Ç4zù2CëòÆGõh'«üÜÜ\š3gÕ®]›œœœhØ°a”œœ¬XŸœœL#FŒ jÕª‘››Rff&EGG Ú±cÕ«WœœœhÜ¸q”‘‘.öîİKşşşdmmMµk×¦U«V)ö#Ê¿³³³¢¾çÏŸÓ|Pb[¹\NÔ¤Izşïóãœœ
&777rtt¤O?ı”²²²ûEDDP:uèÔ©S€~şùgjÚ´)ÙÛÛÓüùóuj*G™6"¢°°0òóó#+++òğğ mÛ¶iuNĞúõë©AƒdooOóæÍÓ¨E&“ÑêÕ«ÉÇÇ‡ììì¨U«V´uëVRñø_)Æöº”ÏvWqì.""‚ (ÎŸ¡Ñµ|¶½Šc{oÙö8Şæ÷£êÔ	¤Ö­Ğ AßÑÌ™?Ówß§C‡®Rdä#Ú°LÅÆñ<%%“<<¦ÑÎç¨L;R©ÿµäî>•~øá\™×¯-ááÿ¿ÿ,jÑb>9-´œrGqÿ¹lÙ¯äç7‹ŞyçKúä“­´`Á/´yóI:zô:İ¼ù˜RR2TËcÄë‚¸qÓ åêBll"½õÖjÚt.?;WS1]¢¢¢èÊ•+f[>£?§OŸ¦Ç­|c?—bÊÆ~Dd|{gôÃèí-ó"-:HmÛ.¢¡C7PpğO´víö]¼x?N¦¼<™qô1æ	æQI\\¹¸L¢Ë—¨Ûì,'P1æ	Şøß}wœš7Ÿ§yÃ
ÊıûÏÉÅe;c´:øÁ†yÃ×Ox®\yHï¿¿†\\&Ñğá¡tÿ¾abï‹éäâ2‰Nœ¸mò†1côL b˜âÄ;Õ¢Y½çQİºS©ví)j“¦
ÿóğ˜F3fì¡/¿<L;w§?ş¸A7o>¡ÄÄ4£k–ËåôÖ[KhêÔİF¯ËX:t•ÜÜ&Sjªixô(ÿÈ_©} Â(aÛ¶3T§N ÅÄ$-E':uZNsæì3HYœ@Å©è^±bùûûÓµk×(22’Z¶lIS§NU¬2duêÔ‰îŞ½K‘‘‘äïïOóæÍSvîØ±#İ¹s‡.\¸@õë×§   JII!‰DB£F¢¸¸8Ú±c /^$]|À4ÑæÍ›iûöíEÖËårš6m5mÚ”Û.^¼˜úõëG>¤ÈÈHzíµ×(00P±_·nİh×®]”––F hÀ€”œœL¡¡¡@Q–¦r”iKKK#©TJß}÷=}ú”6mÚD‰„ÒÓÓ5S Ô³gOJKK£½{÷y‰¯JËªU«¨FFO<¡C‡‘›››Ùèf»«8vgj	Tl{Çö8Ş²íq¼eÃa¨x>fÌÿ¨ÿµR¥yy2Z²ä ¹ºN¦Y³Â(7×4Ÿ=F#Gn"7·É´hÑÊÉÉZR¹ı'ScØƒ\.§‰ OÏéùÈ eëÂË—Ô¯ßZjĞ ˆ.^¼'˜S„Ç©˜.œ@Uqá*ÆTàªŠ‹©$P1ŒZL0BH
r4|4‚¨3Çoü5kş V­-Ã¤yãE´pá£•Ï6Ì¾~¦Ão¿EÒ›o.¢ºu§Òüùû)%åU©ËlÜx6­_ÿ§Ô1cÖpc &:÷R$E¹ºªŸuªø¿ÌLaÚÇİ"—Itó¦ù> ıâ‹pêØq¹Ğ2Tÿ’\\&|6ÍòNjj&5i2›æÍÛ/´HJJ'7·Étôèuƒ”Çf¡1µİ4 }ûşKP¼yó&………Qşìtıú÷_XXyyy);GFF*ÖíŞ½›<<<(;;›nİºEééé$—ËéÌ™3€¢££5è~ÿı÷)))©ÈúéÓ§ º}»èÇ:ê×¯OOŸ>U,=z”7n¬T :~ü¸â¸
ôhS2m/_¾$+++Z½zµâ8ÓÒÒH&“©=§Zşü3¿ß,“É´ÒÒ AÚ²eK‘ãß¶m›Ùèf»«8vgj	Tl{Çö8Ş²íq¼eÃa¨x~àÀªUkŠ ³Ÿ8p…êÕ›N~gwbÆbÏ‹äå5ƒºuû’îŞ}&´œrûO¦0Æ²‡Ü\ø5k6âãS^¾¶äääÑ¨Q›ÈÓs::%˜SƒÇ©˜.œ@Uqá*ÆTàªŠ'P1f	æQItt‚6c²ÎŠÁ0ŒAÉË“A"á[K;ûâØ±›BË`Fİº5Âñã30wnoìÙs	o¾¹Û¶…L&×»Ìj"**Ş€*†a˜ŠÌò¼óØ7¢6fÌèvíêÃÖÖ  ‘XÀÂB}›<>>¥,$–`ãÆh×Îº
R¿!¸|ùš7¯+´•H¥ @n®şm–ŠÈºuÈË“còä®BKÑ‰¨¨xÈå„&Mê-…aÊ%±±±ğòòR,7lØ}ûö $$$@&“ÁÓÓS±ŞËËqqqŠåúõë+şöññÁÓ§Oaii‰ØØX¼÷Ş{hÓ¦6mÚ¤•–ôôtäåå¡J•*E~¿téÚ·o%K–ùıÑ£GpqqH$‚H$B×®][DOa\]óc³T*Õ©eÚpúôi\¼xuëÖE·nİpùòeˆÅbµç´¸±¸h{F•–‡¢iÓ¦E¶mÜ¸±’³h°İ±İ	ÛÛP°í±í1¼õ–7 àôéhÁ4ôìÙ¿üò9îŞ}†nİ¾BLÌ3Á´¨cÀ€×qøğÈå„ÎW`ãÆ“BKbF$1BC?BåÊÖ1b#23sÑ!•Z`Ã†Ğ³gŠÃ‡¯	¢ƒa†a†aÆĞŒmÖ4fŒ³<ÆÀÈdrH$BË0i:ujˆ[·"..Yh)Ãh@*µÀÈ‘ípöl>ü°æÌÙ‡–áØ±[z•çãã‚[·X%Ã0SQ±„­êØ`âÄ.Øµk<¢¢–àÈ‘@Ì™Óİºù£J[ ùc©´h=!!µÌõŞ»÷'NDaÌ˜·Ê¼nC‘›+ÃµkqhŞÜ]h)*)èåææ	¬Ä|HKËÂ–-g0vl{ØÛÛ-G'bc_ÀÆÆÕ«WZ
Ã”K\]]ñàÁÅò•+W°hÑ" €³³3,,,pïŞ=Åú»wïÂÍÍM±ıßàÇ;wî nİºÈÎÎFß¾}1iÒ$œ;wëÖ­ÓJËáÃ‡Ñ­[·¿<xë×¯Ç®]»püøñ"Ú£££AD "$''ãüùóŠõÅn<­m9Ê´eff"33Û·oGBB>úè#tíÚ/_¾T{N‰D:iñğğÀÕ«W‹l{ıúu¥e˜lwlwBÁ¶Ç¶'l{l{Ã öö6hÒ¤6Îœ.
 üüÜpğà$T©b‹^½Váôé;‚êQ…§g:4&tÄ¼yû1zôf$'g-‹aT®lÍ›G!6öBBÂÓaa!ÆW_Bÿş-0vìV8pE0-Ã0Ã0Ã0†‚¨ô$&&FåóÒî÷ğáCŒ9Rï:…²ú´•%"‘111eZgY—'ç¨4Ğ¦*U²Ò;ÃĞ¾'Êêş,í=§­NC®e”×{»¢cooƒ8~|:6tÅĞ¡0pàw¸sG·Ù¤üüÜpûöÓRÍbÅ0£-Ü¶/‰qZİ92´15ª…1cŞBhèHÜ¸±§OÏÄŠ OŸfpuıïÚ/^¤¬^m	=ºuĞ©“o™×m(nÜxŒ¬¬\´há.´•XZ$PÉVb>lÛvD„#ŞZŠÎ$$¤¢fMA}±®p|ÒCÅcŸòØ6lBBBpíÚ5Ü¸qŠÁÈR©ÄçŸû÷ïãúõë˜5k†ªØ?00111¸téfÎœ‰aÃ†!##™™™H$ÈÌÌÄÜ¹s iiiJ5ü÷Ş{¯Äz[[[x{{#((ãÆCVV `ğàÁ˜>}:îİ»‡7n GX½zµÎç@›r”iëÒ¥‹b@wbb"Äb1,--ÕS}µ`Ú´iG||<>ŒÙ³gë|¬¦ÛÛP°í±í	ÛÛ9Áıı1ÅşŒ©õaš6­ƒk×â4ohdœí±wo :tğÁàÁë±mÛY¡%)E"#0°víşyˆÎWâòåûBËbTÀş³l05¿¦ŒzõªcÍš!Ø½û"öì¹$˜±X„+>ÀGµÅ§ŸnÇîİÓb˜ã8£â×=qâD8::*]WÌá¾Ô…òpíu¡4ÇXŞ®½¾”EÀ˜B\×MçŠmÑü0TL*o×ŞşÄ±Ë˜ñĞTü±Îay³QS€¨äŞ½{prr*ñûşıûÑ§Oi¦@›*íŒöä'PñTêJ-ğæ›õqSh)%pttÄŒ3Œ^OiıAYéd˜âxxTÇúõ#°gÏx$&¦¡K—•˜={RS³´Úß××YY¹¸?ÑÈJ†a·íÍŸzõªãÃ[aÕªÁ¸|yşùg¶nƒöí}ÊTGJÊ+üôÓ%ŒÓb±ù$zç¯¿ÀÁÁõêUZŠJş›Š¨´!''7ÄğáošİìS kk‰Ğ2ÊsO¦ÇÎ’£k×®èÖ­Ş|óMÔ©SË—/W¬_»v-\]]ñúë¯+¶V¬ÿøãÑ­[7tïŞï¾û.¦NŠªU«bñâÅøğÃáççOOO4¨Älîîîhİº5\\\››‹¤¤$¸ººªÔ Xºt)  $$uêÔÁo¼¶mÛÂËË«ˆvmÑT2m666Ø´iæÌ™|ÿı÷Ø½{7lmm5S}´Œ;³gÏFPP<==1{öllß¾]çc5ØîØî„‚mmO(ØöØö*ÜŸ)Ì±ãççŠ[·B.'¡¥ÀÚZŠuë†bÊ”wü3V®<,´$•´m[Óàïï†~ıÖaóæSBKbŒûÏòCçÎ¾7®=fÎüQQº}°ÔˆD"ÌŸßãÆu@`à.ìÚuA0-æŒ¹Œ3*îC
ëNLLÄš5kYb£SºöÆjû±-˜B´”]{S‰ëæØ×a´‡c’á1•s¨Ï½k*~ÇTÎ!£™¼<í¨@J˜1c°NÙ*áˆˆ ˆ?7j5ÑÑÑ¤â´h½Ÿª2zôèA¯^½Ò»C¡¬~!´ èèèÒR­Ñ·ßF˜7o?õèñµĞ2L;Î’‡Ç4ÊÌÌ1xÙIIItüøqÊÉÑ®l!îÉ‚{ÎØâØt-£´÷¶®×Ü\mß~–5šE¾¾!z‚òòdj÷ÉÎÎ¥Úµ§Pxøße¤’a“dÜ8¢^·íK®3H\GÔ£Rë1Áş€*Ö­‹ oï JMÍZJ©7n+º^hqs›Ìí-Ùºõ¹»O¥øø¡¥èÅ¢E¨K—+¯Zµjô­‘ıJEO¥ÁPqLÕù)íy3„¾qãÆQG#¶“Œ]>c¾Ûÿ•…eÌˆˆ@ÏôŞÇØå3æÇ[F(ÊC¼åşŒş»?£Ïv†ĞdÈx{ñâ=rq™D'—º,CòÓO—¨ví)ôÉdr¡å¨D.—ÓÚµP­ZShüøm”‘‘-´$³ı§a0–ÿÔCøµ²ê¿æääQÏßP×®+)''ÏèõibÙ²_©V­)tèĞU¡¥BEg¤N³1§´÷eTT]¹rÅ€ŠJW¾©^{¡c€2J{íOŸ>M?6 ¢¢”Õs£²h”e]Ÿ*ŠŸMç¸´¶XÏyŒmïæ„!ı™ÉcÕ1/Bˆ±À†,SŸºMÅïÆ”l”ˆÌjÜTYpùò}rq™DO¨}¶t¶ÜÎ@•——‡¹sç¢N:¨^½:†—/_*Ö¿|ù}ôœœœP«V-L:YYÿÍñÃ?ÀÓÓÕ«WÇøñãñêÕ+ @XX5jÔ©S«W¯.QwëÖ­ 5kÖTü–˜˜;;;ØØıš3aêÔ©hÚ´)ógãÈÍÍÅÌ™3Q«V-T©R&L@vv¶bÚ·cÇ¡nİº8}ú4D"öîİ‹×^{øâ‹/e«*§8…µ×®¬Nuåj[gÇƒ0ş|•Û™<•vtîì‹ìì<œ;wWh)E(>½¢ª{¬øv…—ÃÃÃáææ†ääd À?şoooddd (éöíÛX[[£^½zŠ/”yğàAøúú¢zõê˜0a²²²´ÖYU¾O“Ï,@™ÏRFy¼·™’H$bÚ§NcğàÖX°àtì¸ÇßV¹¥¥õêÕÀÍ›OÊP)Ã0æ·íÓ¶/@YœÖµİ¯êÜÉår¬Y³6D¥J•Ğºukœ={Víõ­í™LmÛÎbÈÖ¨\ÙZh9¥âï¿cÑ¬™»Ğ24ba!æ¨´dëÖÓè×¯œí…–¢öö6HKÓn6TCÃñI¿ø¨îkÓ7U7TiÑ%6©z.¦¬_®ŠŠ×†a†aó‡û3å¯?Süøë×¯_â<+Ã”ú0®® €§OK¾£’şı[`ãÆ‘Øµëv˜ì3'‘H„	:a÷îñ8s&İº}‰;w„›Ù¦¼ÂşSÿ©êÕ=ÑvCaLÉ¯©C*µÀÚµCqïŞs¬^ı»Ğr0}ú»=ºÆß†?ÿTı¾Ÿ)‰ãŒÔİ£ªüªgŸ€êç¢èâ?”a.÷¥®qíUùRe1B]L‰DØºu+üııáää„E‹aÇ¨W¯ìíí1kÖ¬ZË³OÖSn¨³1uuè26±p}ú]Æ$¨«CÕ8u”'[Ôä7ÔµÕô‰ê(Í}¡J‹º˜DD…ŸŸ*W®ŒöíÛãÀElµ8åéÚ ÊŸhº÷”¡mŒß²e‹ÖïLu‰UêìÕ~Ğ=æiãõ9‡­$3P‰Åtª+V¿¿?]»v"##©eË–4uêTÅú!C†P§Nèîİ»Işşş4oŞ<Ef`ÇéÎ;táÂª_¿>QJJ
I$5jÅÅÅÑ; ½xñBcÆ÷æÍ›iûöíEÖËårš6m5mÚ”Û.^¼˜úõëG>¤ÈÈHzíµ×(00P±_·nİh×®]”––F hÀ€”œœL¡¡¡@Q–¦rÔi+@YªÊUW§2 PÏ=)--öîİ«_F¿	fNÿDıú­Z†YĞ©Ór
	ÙkğrKóe˜â÷€ª{LÓ—†N#FŒ øøxrvv¦.(Ö¾çÒÒÒH*•Òwß}GOŸ>¥M›6‘D"¡ôôtE™]»v¥;wîĞùóçÉËË‹æÎ«·NU¾OÏÔä³ŠSÚ{›g 2_îŞ}FŸ|²…\\&Ñğá¡tÿ¾òë>~ü66lC«cÆ¤Ğq*nÛ¦mO¤:NëÒîWwîV­ZE5jÔ °°0zòä	:tˆÜÜÜÔÎ@Uª>	ö”şÕª5…<Pİ†2=K%—Itòd”ĞR4âå5ƒvî</´“çŸbÉÅe]¾ü@h)z³cÇYòö2Xyº|a–ã“~ñI]?XÓ9U7TiÑ%6©êë+ë—+ÃÏºxFF(ÊÃŒŒùÁ3P1BÁñ–
SŠ·ÜŸ)¿ı™‚ãÿçŸ´šª´}CÆÛÜ\¹¹M¦ƒ7ËDi8s&š¼½ƒhÀ€o)==Kh9jyò$™zöüšê×ŸA˜æù4%ØßjsŒÊ¿h:ßÅ1„_+ëşë¦M'©ví)tíZ\™Õ©
¹\N“&ıHõêM§K—î	-§L1§qFêê Òì‡´9†âËºøâ”ö¾4å¨ÊúÚk/
PeZûöíK©©©´qãF@½{÷¦ÔÔTZ¿~½Ríeí“Mm*shPxYß¬.®—ö\h3&A›±ŒÊW¥µESœJßP7†[Ÿø¡}mAu×wóæÍäææF‡¦çÏŸÓï¿ÿN^^^Fbª3P)ó'DÚµôñÏ4ù]c•:{5„ß!Ò=æi:FSj'‘ÙŒ›*+Îœ‰&—I”˜Xò|âl¹M jĞ íÛ·O±|óæM
#"¢œœ²°° ë×¯+Ö‡……‘———Â`###ëvïŞM”M·nİ¢ôôt’ËåtæÌò§OÓÔ`yÿı÷)))©ÈúéÓ§ º}ûv‘më×¯OOŸ>U,=z”7n¬T :~ü¸â¸
ôhS:m(«SU¹šÖ ıùçŸDD$“ÉŠh×¼ñMòş1Q–-û•š7ŸG2™Ü åúÁ†²{LSC<99™jÕªE7.Ñ,|Ï½|ù’¬¬¬hõêÕ
ß’––F2™Léı·k×®"¾Jê|Ÿ:Ÿ©Ég§´÷6'P™?'OFQ‡Ë¨N@š5+ŒRR2‹¬_»öjÖL}‹a˜r	TÜ¶7LÛ¾ eqZ—v¿ºs× AÚ²eK‘:·mÛ¦öU©ú&ØPF¯^«hôèÍBË(5¿şInn“KÄvSÄÇg&mÛvFh&OPĞOÔ¶íb¡e”ŠcÇn‘‹Ë$zù2Ã åé2@‚ã“~ñI]?Xİ9-Ğ¢*n¨Ò¢KlÒæ¹XA¿\†xÖÅº¡0¥İLÅ¨¡àxË…)Å[îÏ”ßşLÁñkD¨I“¶:ŞÖ«7vï¾h²ŒÁßÇ’¯oIGø    IDAT½÷ŞjJIy%´µdgçÒ´i»ÉÕu2-_ş+Éå†}'_`ÿi|ÿ©Í1*{ş¢É·Ç~­¬û¯r¹œúôYMİ»eğ±3ú““GÃ†m _ßŠŠzªy‡r‚93RW‡6~H›c(¾¬‹ÿ(NiïKsK 2æµ×6^Ô¯Ê
´8q¢ˆÖâËÅË-kŸlj	TæĞ( ğ²¾1X]\7ä¹P×Ò4–QÙñ*£´¶hŠ	Têü†º1ÜúÄuèkê´¨»¾5¢~ø¡ˆ†üÑhãQL5J™?Ñ¶ oŒ×Ö_è«ÔÕOd¿C¤{ÌÓtŒ¦ÔN""³7UVœ:u‡\\&Ñ‹éê6;+A9%66^^^Šå†¢aÃ† €„„Èd2xzz*Ö{yy!..N±\0¥= øøøàéÓ§°´´Dll,???­´¤§§#//UªT)òû¥K—Ğ¾}{,Y²[¶lQüşèÑ#¸¸¸ÙÖÁÁ¡ˆÂ¸ºº ¤Ri‘ß5•£N[q
×©®\mêT¦]ãTiL¹¤oßføæ›£¸té>Zµª'´•¨ºÇ
CDE–ñÉ'Ÿ`şüùøı÷ÿ¦[/~Ï988àôéÓXµjæÏŸæÍ›#88íÛ·WìSØ5lØ°ˆ¯ÒE§&ß§Êg Êg©ÓÂ÷vÅ¤];o=:»v]À²e¿",ì/LÜ#G¶………¾¾nxúô%’’2PµªĞr†1¸moØ¶½º8­M»_İ¹{øğ!š6mZdŸÆë­§<ù—/ßGXX€ĞRJÍ_=@ƒ5aoo-´H¥bäæÊ„–aÒdgçaÿşğÙg„–R*¼¼j  bb¡ys÷2­›ã“~ñI]?Xİ9-®¥xÜP¥%''Gml‰DŠ¿£££¡mûåêô1Ã0Ã0Œ)Áı™òÛŸ)~üš0µ>Œ••YY¹BËPÉk¯ÕÁ¾}øğÃï1xğzìÚ5•*Y	-K)––,_şš6­ƒààŸñàA"¾şz,-Ëí0¡2ı§~şS›cTõüE“o-©ù5MˆD",]: ]»®Ä?œÃ°aoªG*µÀúõ#0hĞz¼¿ü2®®‚j2GŒ9ÎH]Úø!}ĞÕÇÜîËÒ`Ìk¯K¼ĞÆŠkÕ¤]›önqÊÓµ7‡6@…m¬41XU}¥=ÚŒIÈÎÎÖÙŞÔQlPí7 Í>Ûñ£´¶ Ï,Ìİ»wáïï_ä7___µû”·k(÷'ú^C]c¼&¡«_SU¿¡ı.1O—÷Âê¡ n'™&åöl»ººâÁƒŠå+W®`Ñ¢E  gggXXXàŞ½{ŠõwïŞ…›››b¹ğ€‰;wî nİºÈÎÎFß¾}1iÒ$œ;wëÖ­ÓJËáÃ‡Ñ­[·¿<xë×¯Ç®]»püøñ"Ú£££AD "$''ãüùóŠõÅoXU7¦rÔi+Ná:Õ•«M…)üP—©xÔ¯ïŒ†]°ÿßBKQ‹ºÀ”—— xüøq‘ß=z„µk×¢sçÎTü^üËÌÌDff&¶oß„„|ôÑGèÚµ+^¾|©Ø¦¸?*˜ºèÔû>u>³ U>K|o3‰C‡¶ÁéÓÁ<¸5,ø:­ÀŸŞ†¯o~ƒñÖ­§«dÆ\à¶½aÛöêâ´6í~uçÎÃÃW¯^-Ræõë×õÖSØ°áüıİĞºµ§æMœË— Y3w¡eh…T*á*>|Yèßÿu¡¥”
7·*°³³¤mÉñI¿ø¤®¬MßTUÜP¥ESl*Ø¾øKëÂhÛ/W§1bbbtº"‘111FTÄTD
ìPW{,Û&c,Ø¶*.š|û.ó‚û3å·?£íÀ3Mš„B"C&3íg:ŞŞ5€Ç“1dÈz¼z•#´$µÜ?üğ	""n¡_¿uxñ"]hIfûOıü§6Ç¨ìù‹6¾µ8¦æ×´¡Aƒš3æ-,Yr))¯„–KlÛ6öö69r“I'¶š*Æg¤®mü>èê?Šc÷¥¾óÚë/ŒaÅ'«ÂÚ ÊlLß¬®¾ÒmÆ$ècoê(O¶¨ö€fŸmÈøQZ[Ğ5aÄİİ7nÜ(òÛ­[·ÔîSŞ®= ÜŸ”æêã5ù]ıšªúíwtA—÷Âê¡ n'™&å6jØ°a		Áµk×pãÆ(n©TŠâóÏ?Çıû÷qıúuÌš5C‡Uìˆ˜˜\ºt	3gÎÄ°aÃ‘‘ÌÌLH$dffbîÜ¹ €´´4¥
~Ç{ï½Wb½­­-¼½½„qãÆ!++ 0xğ`LŸ>÷îİÃ7Ğ£G¬^½Zçs M9ª´©:&Måª[·qãF¤¤¤è|Lù¦OŸf8pàŠÙn,ÈŞ¶mRSS‹Ü[r¹£FÂgŸ}†;w"""¿üò å÷\—.]/Z!‹aii©X?qâÄ"şhÈ!ziVçûÔùÌTù,¾·u88Ø"$¤'›ºu«ağàõ˜>ı'T©b‹›7k.€aÜ¶×¶}ÚöúÔ©îÜ`Ú´iG||<>ŒÙ³g+Ê¬hí†„„T8pcÆ¼-´”R“›+ÃµkqhÑÂ]h)Z!•Z /Ï¼úeÍo¿]C›6^¨Q£²ĞRJ…X,Âk¯ÕÅåË÷Ë¼nOúÇ'Uı`mú¦ºjÑ›”Qü|«ê—W´¸Æ0LÙãèèˆ3f-ƒ)gÜ»wNNNBË`ÌöIåîÏ”ßşLq
ŸsèÃdgçÁÊJ·$0!pwwÂ?CLÌ3Œµ99yBKRKÛ¶Şÿ		)èÕkîİ{.´$³…ı§~şS›cTöüE“o5¿¦-“'¿‰DŒ5k"„– °··ÁÖ­cğøq2¦Nİ-´œr!Ç©B?¤Ï{C]üGyº/…¡®½6¾´àomlAW*’OV†)·ÔÙ˜¾1¸0Åë+í¹(Œ*ÿ¢MÿJÕy*ï¶¨Îo úµùôõ†´møì³Ï0}út=z/^¼À±cÇ0oŞ<Åúò~íPæOô=ßºÚ‹&¡K¬RW¿1ı&t¯Íí$3…”0cÆ0`²UÂA=®ÕæYYY4uêTruu%4h%%%)Ö'%%Ñ°aÃ¨ZµjäââB”••EÑÑÑ€öìÙCäääDŸş9eeeÑâÅ‹ÉÁÁÜİİiıúõ4hĞ ªQ£†b?"¢ÜÜ\jİº5ÙÙÙQNNuïŞ½ˆ¶ÂÛeff’··7Í;W±<qâDrvv&GGG>|8¥¥¥•Øˆ EGG+]ÖT2m…µ+Óª®\MëÔiU¶¬Õª}û­nû“¼L˜ØØDruLG^7X™IIItüøqÊÉÉÑjûÂv^ÜæÕÙéÜ¹sÉŞŞ¼½½éĞ¡CŠıÖ¬YCMš4QÔ¿oß>rqq¡„„„÷Ñ;Èİİ,--É××—öïß_DË¦M›Èİİœœœ(  €233µÖY|;U¾OÏÔä³}oëzıóâäÉ(êĞa¹ºN¦·ŞZB©©™BKbFÆ#êØQëÍ¹mo˜¶½º:tm÷«:w2™ŒÖ¬YC>>>dkkK-Z´ Ó§O+Ê6xŸÀû…Y¶ìWjÔheeå
-¥ÔüóO,¹¸L¢;wâ…–¢mÛ.¦¯¾:"´“%''4¦O-Å ¬Xñµi³Ğ eU«V¾ÕÒ¯p|Ò/>©îk:§úhÑ›
£ê¹˜²~¹&=Ê–µaÜ¸qÔQ‡v’®»üò€²û@z=Ó4Atñ¦X~yCW;T†9ØfDD çZ¾÷1µòÍ•ÒÚ—9Ø–&8Ş‡Û*•ûR‡)Å[îÏ”¿şLñã×åÙ ªem0t¼­[w*ıüó%ƒ”U\¿GÓÈ‘›(7W&´$$¤R·n_’¯o?Wh9&ûÏ²ñŸšQÙó—ÒøVeËÚ dÿuÃ†?Éİ}*=~œ,HıÊ8y2Šj×Bß\h)FÅÜÆ©«C•R7&°ø1(ó'†ğÊ–5EW®\Ñz{]Ñµ|¡¯½*_ª¬í§Ê4i-¼\øËÚ'Ÿ>}š?~¬õöº¢k;Ö”Û DªmL›:ÔMTV_iÏEaTùuuhãlh[,‹ç<ºØ»*¿Qp~ôÃ­Îg¨B_[P§E]L’Ëåôİwß‘UªT‰:uêDûöí#{{{Ç§lYFÇªc^„&¢Í½§oŒ×e,³.±JYıIIIó;DºÇ<MÇhJí$"2ùqSeÍ©SwÈÅe½x‘®n³³å6Š© ˜ào’÷‰Ó¿ÿZ9r“ÁÊ+/	8†(a”—ëÇ¨&''üjÕšB~~!z‚òòLÿ¥Ã0DÇ*†Q‰	ö
ÈÎÎ¥ÆgÓÊ•‡…–b¾ıöùûÏ"¹\.´­èĞa-_ş«Ğ2L–‚‡F÷ï—g,çÎÅ‹Ë$º{÷Y©ËâşLa„è—ó€nÍ´jÕŠ¾úê+""zñâ ÀÀ@""ÊËË#GGG:tèåääPpp0¹¹¹‘££#}úé§Š&{÷î%²¶¶¦ÚµkÓªU«ˆ¨äË¸ÀÀ@jÒ¤‰Êé hıúõÔ A²··§yóæõø…)è‚°°0òóó#+++òğğ mÛ¶ÑöpàÀjØ°!999Ñ§Ÿ~ªH¤LNN¦#FPµjÕÈÍÍ‹¼L‹ˆˆ :uêĞ©S§TÚœL&£Õ«W“ÙÙÙQ«V­hëÖ­%’rssiÎœ9T»vmrrr¢aÃ†Qr²êAuæ`›œ@¥¹\N¡¡¡äççGvvvôúë¯Óï¿ÿ®4I¥ø²*û¬V­ gggÅ¶ªìSæ`[šàx«…mL[ßE¤>§<Ø—:*z¼eÊ'†Œ·©©™äâ2‰»e eeÇ¥K÷ÈÓs:}öÙ’ÉLÿÙYFF6JÓú‘Ss†ı§°˜Ú¸!í!;;—Z¶ü‚‚ƒ¤~U¬[AµjM1;ÿ¬<NÅt1µ*¦ì0µªòˆ©Å`SÅÔ¨*2(á³÷íÛG>>>F©ÏÔ¨„¤"ø³=F7%Ú&P‰Á0#0ƒµÆÜ@BOMÈ0©Ôıú5‡……={6Á_„£{÷¯qéÒ}¡¥1Ã0f†"¬=“„­[Ï`ÿş¿q—/ßGTT<âãS‘‘-˜¶½{/#%%Ã†½!˜Crşü]´iã	‘H$´­HÄÈÍ•	-Ãd‰ˆ¸	oïšpwwZŠAxıuT­j‡#G®-…a˜2 Gˆˆˆ  œ>}ööö8~ü8 àÊ•+ÈÊÊBûöí +W®Ä;wpîÜ9œ<yçÎCHHRSS1pà@´lÙ111X²d	&Nœˆ¤¤$E=D„3f ""prRí38€Ë—/ãÿûæÍ›‡ÄÄDã Æà¤§§càÀÀƒ0kÖ,Œ5
ŠmÖ¬Yƒğğp<xGÅÒ¥K ˆ‹‹ÃÅ‹ñÛo¿áÈ‘#X¶l™b¿+V`ùòå¨W¯J›[»v-.\ˆÅ‹#::sæÌÁÌ™3Kèüæ›o†_ıÇCTT-Z¤öØØ6ÍŸÍ›7#$$,@tt4æÏŸQ£Fiµ¯*û<ş<  >> ´ò‰ÅaÛb´õ]€êx¬
¶/†©¸< ¨Q£²ÀJt£ElÜ8¿ür‹ZFlm-±yó(¼ÿ~sŒó?üöÛ5¡%1ó/––Œ×;w^@BBªĞr|úiGôêÕ&lÇƒÜ6c†aF"##1tèPüı÷ßxõê.\¸€>\hiÃ˜¡0ÃôèÑ³f…á§Ÿ.#  “ĞrL{{{Œ;Vhc|}]‘““‡‘#ÛaäÈv˜3gúôYƒ~ıš#$¤œí…–È0Ã˜Y°ÀWR‘zå7¤¦f"/O^b‰DŒÊ•màà`{û‚ÖÅş/ş»*W¶†£cşßú$mÚt
}û63»ÊÉä¸páfÌxWh)Zci)á*5;v;û
-Ã`XXˆÑ©“/½ñã;-‡)Gp¿Ü4éŞ½;–/_ÜÜ\œ8qX±b^¾|‰ãÇ£cÇ°µµ üïÿÃÉ“'Q³fMÔ®]Ë–-ÃÔ©S±xñb\»vµk×†­­-<<<  H²@PPV¬XÛ·o£Zµjj5M:•*UBŸ>}  /_¾T›pÅ˜2™b±¹¹¹¨\¹2F‰>ø 666ŠmV®\‰úõë .\ˆY³f!$$»víÂÕ«WQ¯^= À_|éÓ§cÈ! €åË—£Q£FÈÉÉQisß~û-–/_¾}û \\\°dÉ’/}7nÜˆ¥K—Âßß °eËÜ¾}[í±±mš?ß|óM	ûX´h‘ÆA¹¹¹í³ kkk•öYµjU¥å³m1Úú.@u<VÛÃT\>ÍÿØfæ÷¨}{|ùå@|öÙğô¬AƒZ-I-b¬Xñ¬­¥øä“-Xµj0Ş¿¹Ğ²˜

?)ÊàÁ­±jÕQlÜx!!=…–£àË/¢W¯U˜0a;ÂÃ'B"áo¶3Ã˜;ƒmĞ4V‚ˆÊH	0}út¼zõ
}úôÁóçÏáîî!C†`Ê”)e¦¡¢RüEE8Fæ?8ŠaÁ±²’ _¿Ø±ãÆï ~Ğ 5jÔÀ÷ß/´†1
ŞŞ5!•ZàæÍ'èÛ·vïß¿Y³Âğæ›‹0~||öYgXZrS…a†Qòpv‚;0~<  ++))¯••§ø;%%/_æÿŸ’ò
/_æÿÿâE:îŞ}†””Ldgç"++Ï¥)}Àge%££-láà`kk)¬­¥pp°ƒƒ-mëm›ˆ›7Ÿ $¤'²³ó`eeŞñìæÍ'HMÍD›6^BKÑ©Ô99œ@¥ŒääÄÄ<Ãœ9½…–bPºtñÃøñÛ””ªUí„–Ã”¸_n:~A'“ÉP©R%\ºt	'OÄÚµkñÇàäÉ“8~ü8zôè¡ØöÑ£Gpqq)R–ƒƒ,--‹€€ ¤§§ÃÏÏ¯D—.]Bûöí±dÉlÙ²E­>WWW €XÌÏ´Ì…Â6ED8}ú4V­Z…ùóç£yóæVÌd@‘< 6D\\ “Éàéé©Xçåå…¸¸8Å² ¨µ¹‡¢iÓ¦Eô5nÜ¸„æØØXxyı×kØ°!6l¨ö8Ù6Í“Âöicc£•} E+hcŸhã‹Ã¶Uq(lÑÑÑŠ¿µõ]€êx¬
¶/†©¸Ü»÷ööÖ¨^İ<?HÔ¯_Üºõ3gî…··š7¯+´$µˆD",XĞb±'ş¹œĞ¿¡e1~şR++	FzßïÀÚZ*´$ €%¾ÿ~ºv]‰5kşÀäÉ]…–Ä0Ã”ÁŒ6”e‚”&$	.\ˆ…
-¥ÂQüEE8Fæ?Ì{Ã0å†Q£Úâÿ;…#G®£{wå/Ù†)?H¥ğòª¡H ò½¶kçuë"°vmöíû¼|VË0Ã˜ù‰MªaiCAâUA¢•²¬‚„«””LÄÆ¾P¬KJÊ(2ëÑ!OÂÊÿ[y–µµVVÅ:'§Ê‚~dàÜ¹»pt´…·wMÁ4èŠX,`:sM‰Ë—  ^{Í´ñèJûö>°°ã?nâƒ^ZÃ0¦øºwß}ááá¸sçš5k†;â?şÀ©S§°nİ:Åv®®®8räˆ"éäåË—ˆGvv6úöí‹={ö GÈÎÎÆæÍ›‹ÔqğàAÄÅÅ¡qãÆ1b:tP=Ã>³U2ÂRØ¦233‘™™‰íÛ·C&“aÏ=èÚµ+={¦Ø&::5 Ü¹s®®®pvv†……îİ»_ßü™ïŞ½777Å~Riş@7u6çáá«W¯¢I“&Šı®_¿^B³««+<x ˜êÊ•+8tèBBBT'Û¦yRØ>½½½5ÚG^^$	?~¬øMû,@ŸX¶­ŠCa{Œ‰‰Qü­­ïTÇcU°}1LÅåŞ½çğğ¨.´ŒR1sfODG'`ôèMøõ×)puuZ’ZD"¾ø¢/lm-1yòNÈåÄÏUÆ2¤5¾úêÂÃÿÁÀ-…–£ÀË«‚ƒ{`Á‚_Ğ¡ƒš6­#´$†a†a†aá*†aLêèÔÉ¡¡'8Ša*¾¾n¸yóq‘ß¬­¥ì†AƒZcéÒC2d=ºtñÃÂ…ï£víª)e†a*IXÎÎú%bEEÅ£S§e˜7ï}4nì†””Ldeı—pU<9«pÖË—¯§´\u	Xùš%*“³ªV­©ÔBïsrî\Ú´ñü7)É|0¥¯a™ıõ ÕËİ,M•*Y¡]»ú8xğ
ôa˜
@÷îİ1räH´iÓR©:uBß¾}Q·n]¸»»+¶<x0¦OŸ•+W"33Ÿ|ò	š4i‚…"33‰™™™˜?>  --•+çíŞÖÖŞŞŞ

Â¸qãpõêUX[[cãÆ0`€Ú™3ó£K—.E§N˜˜±XKKKÅú‰'bÃ†HNNÆÌ™31dÈH¥R8Ÿş9BCC‘‘‘Y³faèĞ¡%ÊÏÈÈPis˜6mĞªU+\¹r³gÏ.QÆ°aÃ‚ºuëB,#   ÈTl›å“?ş¸„}øoŸmÛ¶¡ÿşX½zµb?mì³Àç©³O€m‹Q¶¾P¿ıö[¶/†aŠpõê#øù•Lö5'ÄbÖ­†Ş½Wá£6"<üsØØXjŞQ`‚‚z /O)SvB,ñLT#0ÕªUÂ»ï6ÂöígM*
 F~G^ÇÄ‰?âÈ‘@“™!‹a†a†aF[8Ša“á“OÚcÀ€uˆŒ|„Æk-‡a#ãëëŠşTºÎÕÕ«WÁ¼Y³öáí·—bÂ„è++n¾0Ã0¦ËçàêZ#G¾©×¬QYY¹Š®ÔÍ‚Uğ{BBj‘ä¬çÏÓ ——L*œ€U0Ã•ºY°
~·´”àÂ…»˜<ùCœ2C$ó§”ó×_Ğ¼¹»Ğ2ŒBŸ>Í0yòN$&¦ÃÉ©’Ğr†1"]ºtAVVŞ~ûm Ào¼œœôèÑ£Èv!!!

Âo¼ììlôîİË—/G¥J•°xñb|øá‡¨R¥
‚ƒƒ1hĞ tëÖgÎœ)RFPPvîÜ‰¥K—bŞ¼yøøãÑ¾}{è]°±±Á¦M›0kÖ,Œ3^^^Ø½{7lmmÛ:]ºtAzz:>üğCÌœ9 °víZLœ8¯¿ş:,--1xğ`ãÑ£GEê¨ZµªJ›{úô)d2‚‚‚ğğáCøúúbûöíhÛ¶m‘2‚ƒƒ‘‘‘nİº!##İ»wÇòåËëÙ6Ë'S¦L L›6?†ŸŸ–.]Š¡C‡¢zõê˜;w.&OŒeË–áë¯¿Æ¾}ûûª²O´nİ...HOOWkŸ			l[ŒRÆ«•ïTÇc€}Ã0ÿ‘““‡ş‰Å‡¶ZJ©©TÉ
›7B÷î_cúôŸ°fÍ¡%iÅ¬Y½  »P½ze¼ıv1LÅfĞ VøğÃïqÿ¾iÍÎ'‹°zõtì¸+Vü†Ù³{-‰a†a†aF'x2Ã0&Ã›oz¡Q£ZX½úlÜ8Rh9Ã__W$$¤ªàÚ¶­7~ÿ}*¶n=ƒåËÅÏ?_ÆÌ™=Ñ«WÓ2VË0Ã0šIOÏÆ=1eÊ;z%O3`Iáà ½gÁÊO¨z¥4KYrVáY°’’2›++QæÜ¹û±xñA•³`$`©JÎªV­2$ıÎ‰>ˆD<•2ˆW®<BïŞ¯	-Å(¼ûncıŒC‡®bÄˆ7…–Ã0Œqpp@nn®bÙÖÖÙÙÙ%¶³¶¶Æ7ß|ƒo¾ù¦Äºàà`+–?ùäÅß…cˆµµ5¢¢¢”®Óf™1†‚!CTl5jFUâ÷*Uª`Û¶m%~÷òò*aêl.   E¶/Ø¿à+++¬X±+V¬Pª‘m³|baaiÓ¦aÚ´iŠßbbbÏ›7óæÍS,¾Îªì Î;WdY[Ÿ¨Í2S~)ìÛ
fÂÓä» õñ˜í‹a˜"#!;;-[z-Å ¸»;aİºa:t:ujˆ>}š	-I+BBz"11ü?„…}óŒaÌ™¶m½áìì€°°¿hZ8sqqÄ¼yï!0pŞ}·Z´(¾›a†a†a˜Šù%PXY	­‚1ÒÒ„VÀ˜É“»bôèÿáæÍ'ğõu-UYQQQ‰DRÆ”…@1å?¿ü—.·n=A»vŞ*·“J-0=Ë    IDATfÌ[èÕ«	-:ˆqã¶aûösX¸°/¼½k–•\†aÍõëÀù‰ <Ê²ÀíWRÜÊâ-Çl¼V9G}¥$W¤ËÅ¨"‘k½Ojö:l_p3C
?»
GM¬?ğãçAD4¨µ :ò“°’€µgÏlß~k×ı7Éªä,X…°²²ò’òJi¹…gÁ*HÀ*H¸R7–££ªT±ƒ¥¥ö0x*å<yòÙhØĞEh)FÁÖÖ]ºø!,ì¯R%PmÜ¸Ç7 2†Ñ¿ÿşuëÖZÃ0Ã0c¦p†)k={fr.^¼5*ÃİİÉ å™:øà£Ú"(è'¼şºÜÜª-I#"‘+VD||*†Û€&¡V-Ó×mŒí?³³-œlÊ•³ag—g´z˜Ò“f"ïÄbzõj‚®˜\ ØûöıÙ³÷áĞ¡É‹ËÇØgdz¤§§ÃÚÚÚ¨udddàÆF­ƒÑ™¬äÁèÑ£aÅã‘5”Õ{›§OŸ"99Ùèõ0ÚSfãX9/‚)&Ò17Ì'ªQ#`È Ç<PêÃÓŒ½Ußú$£–?@QJß¾@»vB«`È;ïø£I“Úøê«#zÏBU©R%8;;C.×o 2#,R©®®®HÌ'D1úáäT	Õ«WÆê¨
pvvÀêÕC0hPkÌš†.]Vbøğ71cFwTªÄ†1+z÷Fê³dÜJÍO”º•!Á­)¢2¥HËA ¶µu­óğZe¡ÅêÎÃ,L¸Srìğ{¡Õ>Q¯¤èz¥6}†¶EÂÄçX`àu'|ß 	U$H…?·ÁÄ;U°¡a2Ş©šYêc0L¨? —¶l9>h	{{ã¾È16…°bc“ğÆõÑµ«¿Ne¨›«ğïÙÙy%’°Ó!“•lË[YI`mm	kk‰ÚY°l”ô
vv©ˆŒ|++)mP½º}¹y‰«/11ùƒš<=k¬Äx¼ÿ~sŒ±¾@:ÕtŞÂ„	¸uë–”1Œv4kÖİºuZÃ0ÿboo±cÇ
-ƒa†a´‚û3ŒÔ¨QcÇE•*¥K²¹xñ>Z¶¬g U¦Ãœ9½qî\v`ïŞ ³x6%•Z 4ô#ôí»C‡n@xøgpp°Z–Q1†ÿ”Ë´4+$%YáåKddH`aAğô|i2	TOŸÚáùs4nœ(´“¢oß¾hg"ïºtñÃÆ'ñøq²I&a.XĞ:-ÇO?]ÂÀ-…–S*xœ‘éR©R%T­ZÕhå;99ñ‡M'''88è÷±HmhÔ¨†‚œ
4™Ñ²xoãææ†ŒŒ£ÖÁèÑÇ±VÀ¼Æ˜Ğ¸)sÂ|F§W¯ìØ!´Š2å‹âQì%8ÿ¼Z-‡aÊ‘H„I“º`äÈÍˆŒ|„Ækë\†T*EÃ† aCãëëŠ[·è´O›68r$»v]À’%‡pğàUÌœÙıû·à¯A1Œ	’—'ÇãÇÉ¸s'‘‘pçN¢¢âí
"‚½½5Üİ«ÃÛÛ½×Fƒ5áçç†ªUí„–®¿ş‰ÀÀİp®iåß´œåå×¯ÂñÑiÔÿå+ ØKôrB‚oÎ÷ÿ G*ïô¾G„K³öá“gñİwÃÑ½{ãR£G^GlìŒÙVh)ƒˆpñâ=L˜ĞIç}9Vá¬ìì<¥ë
'`%%e 7W†›7ãÈ‘ëEÊU6Vá¬ü±¤J×U­Z	R3ï›ß½ûU«Ú¡Jóô±ÚĞ¾½ªU³ÃşıÿàóÏ;ë¼ÿüùó Ša†1WjÔ¨ï¿ÿ^hS///O·Ê0Œ¸?Ã˜+99y8>3ftZŠÁ±²’`ÕªÁèÙó„†ÀØ±í…–¤•+[cûöÑ³ç*Œı?ìÜ9ÎìŸ‹©ÃPşóÅ‹tœ=ƒß¿£Go 55uëVCß¾ŞèÒÅo¿İ ––¦3LkÄˆhĞÀBïÛ2Æ§eËz°±±ÄÉ“Q4¨µĞrJP¿¾3†mƒÅ‹¢{÷Æ¨\Ù|?.ÇãŒ*.U«V5j‚cºT¯^;*ØxdÆtqwwZ#0/‚aLÓé™3EÈÊÊÅ?œÇ˜1o•ëQ£Œ.]üĞ¢…;æÍGXX€Ğr†1"~~nøóÏÛ:ï'‘ˆ1thôìÙ_~y“'ïÄ®]°pa?4Ô2YaÃ“’ò
QQñˆŒŒÃ;ñˆŠŠÇµkqÈÊÊ…D"†›[x{×D¯^Màí]óßÎå"ù1++‹Ä¦M'Ñ¿,[6 66–ZïÿÛo‘x÷İFJ¿@*‹ĞªU=œ;w#U$P‰D",\Ø"0vìV¬Y3}ú4ÓûxİÙ¸ñ$:wö-W3ûDEÅ#11mÚx–yİ¥MÀ0à[8;ÛcÚ´w	WªfÁ*œ€•‹¬¬\<{–¦tPjñ¬|R¥³`OÀrt´ƒ••°aîŞ}//gA5‰DŒ=š`ïŞËz%P1Ã0Ã0Ã0S¶üùçm¤§gãİwËçG¡5ª…)SŞÁÒ¥‡ğöÛàãcï±\\±cÇ'xï½U˜??¾/´$“C.'\¿‡S§îàèÑ¸|ù,--Ğ²e=|öY'tíêúõMóY\n®çÎÅ`Ö¬ŞBKaÔ`e%A«VõpâÄ“L €éÓ»cÿşğí·ÇÊe",Ã0ÌÿÙ»ï¨¦îÿàOHÂŞ+Q†€ÄH\€pZÅUQ«ıiUl­T[«­³¶uk­míöë¨£Uë¬¶UÁ â®‚ DVQ‚²2îïDQnŞ¯sz'Àç>P%É½÷ù¼	!„bx¨@¥£öì¹ˆ’9Ş|³+ÛQit7 Ç€kpğà„‡·g;!DK|}›áÿ;	…BU¯Â°­­9/†ˆÌŸ¿ıú­ÆèÑ1wî@ƒ¬@Û
nİÊ}2QJ*ÍÂ•+·‘›[ °±1‡H$€Dâ†ˆˆ€'65å³œ\;¤Ò,¼ûîÜ½û?ı4ƒw¨Ó×gf>Drò=ÌŸ^ãçtéÒ?üpÃÔX8ãp8X¼x8¦Mûj5ƒáÃ;Õ)©Ÿë×ï#!!;wNa;ŠF%$¤ÃÚÚb±ÛQêŒË5‚©)-Z8Ô{š¦`U-`U®Ÿ‚•—W¥R]íº/›‚UõñŠ‰X¼'st´—kTïïéÖ­\xy9ÕûëõÅğá°yói¤¤ÜC›6ÍÙC!„B!„ZüõW":uò€PX¿tôÁ{ïõÁÑ£)øøã]øãiz³©˜¯o3¬^=ï¾»İºµÂk¯fÉ­.>,Á©S7—¦®!'§nnö	ñAdd0zõò…¥¥	Û1_êÂ…ËâÃvòÁÁ>øöÛ£P«™j7ác›­­9>ø Ë—ÿ‰1cºÀÍ&ùB!„Bt¨tÔÆ§0lXG89Y±…Vøù¹bÄ,Yr}û¶©ÓBˆşhÓÆ
…
iiÙğõ­ÿÍ­‰˜İ»/bñâøë¯DÌ˜†‰ƒtòD2!ú$;»à™‰R‰‰™HKË†ZÍ€ÏçÂÓÓ	‰+Ş~;"‘:´€££%Û±Í®]0gÎnøú6Ctô,¸»×½¬qèP"¬¬LÑ­[«?§k×–X¼ø ÒÒrjİ±’Ãá`Ñ¢¡02âàı÷Ã0xıuÿ:g"u³n],D"ºw÷f;ŠF=›À@¯vØ¢‰{P:«º–Lö´pUÓ¬‚‚R<|XŠòreµëÖVÀªÈÌ«±œuÿ~üı=ğSÑşşpwwÀŞ½—¨@E!„B!„è0…B…èèd|øaÛQ´ŠË5ÂŠ#Ğ¿ÿìÛwY¯6¾<¸=N’âÃw m[—z×w©©Y8z4qqR$$¤ :thÉ“C$‚DâÆrÂº‹‹K…‡‡cƒ6 "#$Ä‹ıÄÄ;hßŞí8Õš0¡6o>¯¾ŠÆš5£ÙC!„B!µ¢•:uê&®_¿Go*I“7wî „„¬ÀªU‡ğé§CØCÑooŒyHN¾× PQˆˆ@¿~mñÅ‡±hÑØ½û"–.}:µĞPbBWAA)RS³ •f?.JİArò]”––ƒË5‚««D"!ÂÃÛA$B$ÂÛ[ĞdKŠ……2|üñï8xğ
&NÂÂ…ƒë5I JBh¨¸Ö¯oÛÖVV¦HHH¯µ@Tü>üüó¡05åãƒ¶ •¨´(/¯û÷_ÆÒ¥¯ëÍÎ±¯‚aœ=›wŞéÉv”zcv¯‰Vå„«Ú¦`U-`ÉåÊ'Å­ÜÜ"¨Õ/ş¾ù&Û¶%<)\=-dU?«êã¦¦|ØØ˜7ôG£uC‡vÀÎ0oŞ &û\E!„B!„èº“'SQXXÖ$&‰Å.=º3–,9ˆ~ıÚÂÂB÷§UZ¼x8®\¹)S¶à?¦×û\¸¾()‘ãÌ™4ÄÄ$ãèÑdeÀÑÑ={¶Æ÷ßÿBBZÃÚÚ”í˜ròd*zö¤éSú uk!-qîÜ--Pñù\DEõÆÜ¹»1sf?¸¸Ø±‰B!„BjD*´aC:wöB»vú·K!š$XãóÏ‡bæÌ0À^lG"„hgoo®_¿§±5­­Í°xñ0ŒßìÅàÁßàõ×;aáÂ!Mj*!5Q(T¸u+‰‰w •fC*­(Keg llÌ!	 ‘¸!"" "‘ mÛºÂÜœ¦AVº|ù?Lºeeåøí·wRÿ‹Œùù%¸x1‘‘Áµ~g$$¤aÜ¸n¯´öÜ¹Áá |°ŒA%*mØ¼ù4ÌÌŒ1lXG¶£hTZZrs‹ĞµkÍ“Ñt‡ÃÃvƒª*
X|ØØ@#S°òòŠñÆï-PPP
™ìiáêù)Xùù%P(TÕ®[Û¬ª¬§ßÃÓ98XÇÓşT³×_÷ÇÚµGqîÜ-tíÚRëÇ#DŸäää`×®]lÇ :¦¼¼\ëÇ¸|ù2ıİ#Ï¸víZ£çÀ°²²j”cı®õcĞó-©Nc<ß¢oöï¿Œİ›ÌÍöóæÄ_]ÅwßÃìÙ¯±ç•™˜ğğóÏãÑ¿ÿ,[ö§An~úßyˆ‰IFLL2ÎM‡ZÍ@,vÁØ±]*†ŸŸ«Ál õğa	’’2ñşû¡lG!¯€Ãá M^O×†ˆˆ ¬Ys6ÄaáBÃûA!„B1T Ò1wîäãèÑüøã8¶£¢F
Äÿ`æÌˆ	33ºy›C#7Gr²æOø¶jåŒíÛßÁşıÿ`Ñ¢^yóaÌ˜.4…€4ÙÙHLÌ„TšõxªT&ÒÓs R©Áçsáéé‰Ä‘‘Á‰„HÜ X³[g1ƒâ±xñtëÖ
k×…“SÃnÂ;|8	<={¶~éçvíÚ
6ÄÕiı9s‚Ãá`ÆŒí`õJª¡P¨°uëŒßİà^§&$¤ÃÂÂ~~®lG©z_ Ò„ªS°îß†a0dH{øû{¾Ò×W-`”>™pUÛ¬§W|~uj*`ULÄâ×:ËÎÎÆÆ/?åí-€Xì‚={.RŠ*\]]qíÚ5Œ9’í(DÇÁÅÅEkë»ººbıúõX¿~½ÖAô“½½=,,,´²¶@ €±±1&Mš¤•õ‰~7N{×áèù–ÔDÛÏ·„è›¼¼büùçU¬X1‚í(ÆÎÎ3f„aéÒ?1rd <=ØôÊ<=°|ùL›ö+ºw÷Fß¾mØÔ eeå¸xñ_DG'ãĞ¡DÜ»÷ööèŞİ«WBX˜X/&±×G\œFFtëæÍvòŠÄâæˆ—²£V|>'aÍš#˜6­/ìì´ó>B!„BŠ
T:fãÆx…6èßßí(„èŒ/¾…¾}¿À¼y{ğÕWo°‡¢a¾¾ÍqìØu­¬Íáp0lXG„…‰ñå—‡1oŞnìÜy+WD›6ÍµrLBØPX(Ã÷ •f?.JİAJÊ=””ÈTLu”HÜ*FTToH$nhÕÊ\®ö'€ŠÜÜ"LŸş+ÒññÇğî»½5RÆ<t(!!>¯4á«k×–X¶ìOddäÖéÂúìÙ¯ÃáàÃw€a€‘#©D¥)û÷_F~~É+OÓ'		iôl”IAÚ`(»ÁjÒƒÅ  GÇW/~V-`Õ×ó%¬‚‚²XÙÙ…?¿â±Š¡R©_X³²€UY¸ªi
V«VÎØ¿ÿ2†ëGG«ÇßÎÎÖôw„4YóçÏÇüùóÙAš +W®°4Ab±r¹œí¤	¢ç[By5Û¶%ÀÌÌC†t`;J£zë­Ø¶-Ë–ı…ÿıï-¶ãÔÉğápüøuÌ½'NÌ†µµ)Û‘êä¿ÿò/ELL2NL…R©BÛ¶®6¬BCÛÀßß³IlÂxòd*:vôĞ»ÿM™¯oslØ…B>ŸËvœ×k×Å–-ghÂ!„B!DgQJ‡”••cçÎóxï½>z{“!ÚĞ¼¹-¾ıv,Æ[.]ZbÔ¨@¶#B4H,n¼¼bääÁÙ¹a“\jbaa‚…‡ "" sæìFÿş_büøøøã°²¢‹D(•j¤§ç@*Í‚TšõdºÔíÛù`ÖÖ¦ğñi!ÂÃÛC"q…Xì¶£ëµ“'S1}ú¯°²2ÅŸ~€¶m5³SpI‰§NİÄÊ•¯¶#µDâssc$$¤×ygÒ? øğÃŠITôzJ36m:…AƒÚ¡Y3[¶£hÃ0HHHÃäÉ!lG©7êÆ¼¨¸¸âæaKËÆ}íÓĞVm,¹\ñx"VõS°òòJ TªñÃëÖ4«j«¢ Å{ácöö–:}£!„B!„¢ëT*5~ı5cÇv1¸Éî/Ãçs1ş L˜°7nÜGëÖÍØT'‹CÏ+±téA¬\ÁvœZÉd
\¸¸8)IBZZlmÍ$Â’%Ã*†@`ÍvÌF—Š1cº°ƒÔA›6ÍQ^®Ä­[¹ğñ²§F––&?¾;6lˆÃ;ïô„©)ŸíH„B!„ò*Pé;ÎC&Sà7:³…Ó§OLÚsæìBÛ¶.‹5sã2!„}•ÿSRîÂÙ¹µVåëÛû÷OÃîİ±hÑüùçÌ›74…èìì‚g&JUüù>är%ø|.<=àã#ÄˆşHÜ 	áînO54¨¼\‰/¾8Œ<áÃ;aùò-£;–¥R¾}Û¼Òçóù\têä„„ôz]Üüè£O&QÉd
Œß½Îk§Î»…+WncÉ’álGÑ¸””{ÈÉ)BHˆvŸ—µa¶#è™L zwÑº¡¬ˆˆ`bÂÅ'ŸyR¸ªm
VÕ–L¦DaaYµ—ª+`U®ª–°ª+gÙÚZÀÄ„NÉB!„Biº¹†{÷áÿşÏğ&»¿ŠĞP1||„øşûãøöÛ±lÇ©;;,^<ï¾»Ã‡wBçÎ^lGzFå”©øx)¿’9D"!úõóÃÒ¥"téÒ²IoŒ#•fáŞ½Gzî·©ñö€Ïç"%åN¨ `âÄ üøãq9r­ÉM$„B!„èº[CG0ƒM›â1b„?ìì,ØCˆNš=û5\¼˜)S¶à¯¿>€µµÛ‘!`ggÀ))÷Ğ³§öOÖs8DD ,LŒÕ«`ÆŒíØµë–/–-µ~|BW\,Ç­[9‹R¥®_¿‡Š 5D"!<1iR||„ğñiF7^kÙ­[¹˜2e3şı÷¾ùf^İ_ãÇ8t(	]ºxÁŞşÕ_ÿwíÚ[·&Ôû˜³fõ‡Ì›·¼õ•¨êkıú8têä[°EãbcoÀÉÉ
bqs¶£Ô‡Ãõ§¥¯ª†ŠˆÀGí„³³U½Ï·Ô6«òñªå¬g§`C©T¿°¦‰	¦¦Æ05åÕ:«¦r–““5ŒŒ¨4M!„B!D?mÜŞ½}Ñ¢…ÛQXÁápÕ|°3göƒ‡‡#Û‘êdğàØ¹ó<æÏßƒ#Gf‚Ë5b-‹R©ÆåËÿ"&&ññR$&Ş¹¹1ºw÷Æ§ŸAŸ>¾hÖÌ–µ|º&>^
kk3´oïÆvR|>îîÈÈÈe;ÊK	Ö	ñÁ®]¨@E!„BÑIt×¥8uê&ÒÒr°nİ[lG!DgñxFøé§q0à+¼ıöflÛö6x<öNÆB4G,nää»zLs,^<ááí0gÎn„†®FTToL›ÖÆÆô‰hR©Æİ»!•V(•…´´l¨Õ,-Màåå‘Hğd÷É6mšÃÁÁ’íèMÎ®]0oŞ´léŒ#GfÂÓÓIãÇP(T8qâfÍê_§¯ëÚµV­:„ÿşË«÷Í3gö‡©)óçï@%ªúÈÌ|ˆ#G’ğİwo²E+bco 8ØG¯'ÚU¨¨AU•L¦ gÔäŞCÔóçïÁÁƒW1n\ıvµnè¬ê
X2ÙÓÂUmS°>,Ey¹²Úu«›‚UYÀªÈ\s9ËŞŞ²Iï¶L!„B!„=çÏßÂ™3iØ½;Ší(¬:´#¾üòş÷¿“Xºôu¶ãÔÙÒ¥¯£gÏ•Ø¶-ãÇ7î9æÜÜ"ÄÆŞÀÑ£)ˆ½¢"Z´p@ß¾bÌŸ?¨ÉO™ªÍéÓièÚµ%«¥7R?ÍšÙ ;»í¯$"" QQÛ]Àší8„B!„òº;XGlŞ|;{¡uëflG!D§	6Ø²e2†]‹Ù³wáË/G±‰¢~~®øë¯«¬;0ĞÑÑ³ğË/§°råßØ³ç–/VòÃPPPúÌD©ÔÔ,\»veeåàñŒàâb‘Hˆğğv‰„‰„ğöĞ$	–Ë1wînìİ{	'aáÂÁZ»Èzöl:
Ë&®Ó×uìØffÆ8{6½A»³FEõ ÌŸ¿Ã`Â„õ^«)Ú´)V0@Âv+--Ç…ÿÒël$—+šÜô) 077FX˜»w_¬wª¡4QÀªœpUÛ¬ª,¹\ù¤¸•›[µúÅBaÕVå„«Ú¦`U}ÜÔ”ó†şh!„B!„4A_~yèÖ­ÛQXÅåaòä,ZôŞ?ÎÎVlGªGDFcÕªC6¬#¬­Í´v,•Jää»ˆ‰IFLL
’’2ajÊ‡¿¿>úh ğƒ‹‹Öo(ÔjçÎİÂŒalG!õ Ú +«€í¯¤_??XX˜`ß¾Ë˜2¥'Ûq!„B!äT ÒÙÙ…ˆ‰IÆ×_a;
!z¡m[üôÓxL˜°­[1yrÛ‘!Ô¶­¾ıö(Š‹å°´4iôãóxFˆŒÆ Aí°pá>¼ñÆOo%K†ÃÉI¿.X‘Æ¥P¨pëVî“‰RRi®^½œœ" “ÎD"$7DD@$ÀÏÏffÆ,''ÏKL¼ƒwßİŠÂÂ2lŞ‰¾}ÛhõxÑÑÉğõmw÷º• ø|.:vtGBBF
lP†¨¨>àp8X°`/ &5h½¦¢¬¬Û·ŸCTToƒÜÅôôé›P(TèÑCÄv”Óç	ZÚÀ0L“ı™Œİ£FıˆÔÔ,øøÙSg,>ll Ñ)XUX2ÙÓÂÕóS°òóK P¨ª]·¶)XUXO¿‡§st´¢İ	!„B!¤‰¹té_ÄÇK±kWÓ>Ué7:ãë¯£±iS<fÏ~í8u6}z(¶o?‡~89sjtí¼¼bœ9“†˜˜dDG'£°°-Z8 (H„™3û!$ÄÆÆtËS]¤¤ÜÃÃ‡%èŞ½i—õ•@`ƒ7î³ã•˜˜ğ0xp{ìÜy
T„B!„CgtÀ¯¿&ÀÊÊ¯½fx»—¢-}û¶Á¼yƒ°hÑ…6oÏv$BHH$nP«¤¤ÜE` k9„B¬[÷bb’1ş-Ç¬Yı1aBº¹“ ;»à™‰R‰‰™HOÏJ¥ŸÏ…§§$WL‘HˆvíÜõnÇÈ¦ˆalØÅ‹ 0Ğ{÷FÕûæôºˆ‰IÆĞ¡êõµ]º´Âï¿Ÿ×H©S{ ,Ø†&N¤ÕËìØqr¹cÆta;ŠVÄÆ¦B,nÀší(¢Tªè¹û9\.·ÆŒ¡ëÑÃ^^NØºõ–,ÎvVhb
VÕVå„«Ú¦`=}¼âó«SS«b"¿Ö)Xöö–Yd%„B!„CöÅ‡áïïIÇLMùxóÍ®øí·s˜5«¿ŞÏ²¶6ETTo¬Ys'7èšHå”©øx)¢£“qñâ¿06æ"0ĞÓ¦õAXX[x{4˜¾é9}ú&ìì,àãÓŒí(¤š5ÓŸ	•òLÇ    IDATT 0rd ¶mK@rò]ˆÅ.lÇ!„B!„'¨@Å2•J;ÎaôèÎ01¡ÿ„ÔÅ»ïöÂƒExï½m077FŸ>ÚAÑ77{ØÛ[ ))“ÕU¥ĞP1zôğÆ?ÇâÅ°k×¬XÜÙFAaanÜ¸©4ûqQêRRî¡¤D ¬!‘¸!4TŒ¨¨ŞHÜĞª•³Ş]Ø$;XÎ˜±±±7ğşû¡˜1£ŒŒ´?åúõû¸};¡¡mëõõ]»¶Ä—_FfæC¸ºÚ58ÏÔ©½ÁápğÉ'ûÀ0&M
nğš†ŠalÚˆØÙY°G+bco`à@ıßÜC©TÓïåçğù\¨Tj¶c°‚Ãá`Ì˜.X»6óæ‚¹9M‚¬«†°€—OÁªúxvváãÏ¯xìÁƒâjÿşV°*WµMÁªúxÅ÷Ãƒ³³u“ÌF!„B!íâÅÄÅ¥bçÎwÙ¢S""ğõ×1ˆ—¢gÏÖlÇ©³‰ƒ°~}¾ıö(/V§¯}ø°§Nİ|\šº†œœ"¸»; 8X„ÈÈ`ôêåKK-%ozÎœIC·n­å:Ñ<¡Ğyy“âõaS¡N<Ğ¼¹-¾F*B!„BˆN¡ÆËKÁİ»0v¬aî^Nˆ¶-X‚‚2Lü~ûítéÒ’íH„z‹]””ÉvŒ'ÌÌŒ1sfÖ	sæìFxø×3¦>ùd0¬¬LÙG4@¡PáÖ­\H¥YJ³L—º};ÃÀÚÚ>>BøøŞ‰+ÄbXXĞÅ:CpútŞ{ox<#ìÙó<íØÑÑ×àèhYïRf§N01ááìÙtŒá¯‘Lï¾Ûî‡ZÍ`òä¬kh»ôô\lØ0‘í(ZqçN>22rõòFç©ÕjğxT ªŠË5‚RÙ4T ğÆñÅ‡ğÇ—ñÆt†š‚Uµ€%—+OÄª~
V~~IØjš‚Uµ€UQĞâ½ğ1+ú]C!„B!¯€a,Zt]»¶DPˆí8:ÅÃÃşşøı÷zy^ÎÔ”¨¨ŞX¶ì/|ğA(,kıüÔÔ,=šŒ¸8)Ò  :´ÀäÉ!
A"qkŒØMJ¥Æ¹s·0{öklG!õäà`	†ağğaiƒ¦½5‡ƒ^½|{3göc;!„B!„<A*–mÙrÁÁ"xz:±…½Äáp°re=*Å[o­Çï¿O¥“ª„è)‰ÄÇ§°ã^^NØ¹s
vï¾ˆE‹ &&óæBDD ÛÑHdg<3QJ*ÍÆ÷Q^®ŸÏ…§§||„1Â‰D"!Z´p`;6Ñ¥Ro¾‰ÆW_E£_¿¶X³f4llÌ5CLL2ÂÂÚÖ{—GÚ·wGB‚æ
T 0eJOqğé§û!“)0mZ_­m(Ö¯CHˆ¼½lGÑŠ'nÀÜÜşşlGi0¥R##*5TÅçsÁ0Tª¦9ËÎÎ¶Ã¦M§¨@¥§4YÀª,\Õ6«jK&S¢  ´Úu«+`U®j›‚ekk;;ÓéYB!„Bˆáûãpùò¿øë¯lGÑI#G`Á‚½(,,ƒµµÛqêlÌ˜.øúëlÜ>ğÌÇJJä8s&11Éˆ‰IAvvœœ¬âƒï¿ÿ?„„´†µ5m\¨mII™(,,C÷î­ØBê©rƒÇÒR9 İ/P@ïŞ¾Ø¾ı,òòŠ_Z®$„B!„ÆBWèYt÷îCœ<™ŠuëŞb;
!zË5Â?üŞzkFü¿şú:ujÁv,BHùù¹à§ŸN ¬¬ffÆlÇy‡ÃADD ÂÂÄX½úfÌØß?åË#Ğª•3ÛñHEE2ddä>.JUL”JI¹‡¼¼b €@`‘Hˆ€ OLš!Z·nF7®6wï>ÄÔ©[‘˜xŸ}6‘‘Á!7·W®ÜÆôé+'uíÚ
û÷_ÖPª§Ş~;ğÙg€aĞàœ†D*ÍB|¼[·Nf;ŠÖÄÆŞ@÷îŞñ;Q¥bh*ÌsÌÌø €ÒÒò&;Msüøî2d-.]úŞ36A-`µOÁªú¸\®|¡„•—W\í8LMajÊ«u
VÕÇ+
Z|ØÚšÁÉÉºŞ¥lB!„Bi2™Ë–ı‰‘#Ñ®m„YÁƒ;`áÂı8xğ
ÆíÊvœ:333ÆÄ‰AX·î$¦NíŠ¦’qöl:Ôjb±Ş|³BCÅğós‡CïeÓ™3ipt´4ØÍÁšsóŠëç%%r–“¼º  ¸\#ÄÅI1lXG¶ãB!„B *P±jË–3pt´Dß¾mØBˆŞ36æaóæH¼óÎfŒõ~ù%=zx³‹R‰T*5RRîëì­66æX¼xÂÃÛaîÜİèÓgŞ~»'fÍêzYÕ˜”J5îŞ}©ôéD©ÔÔ,Ü¼™†a`ee
OO'ˆD„†Šáã#„Xì{{¶£–:”„?Ügg+üı÷øú6g%Gtô5óĞ£‡¨AëtíÚ_¬¬…õ¿¼:“'‡ÀÄ„¹swƒa¼ÿ~¨F××Wë×ÇÁÃÃ={¶f;ŠV(•jœ9s³g¿ÆvP©Tàré&Œªlm+¦í”5ÙU@€':ujŸ~:ÿıï-¶ã=¤É)XUXr¹²ÚU-`=|XŠòreµëV7«j«²pUİÇìí-Áçsòc!„B!„ZıôÓ	<|Xj0ç´ÁÊÊıû·ÅÎô²@UVVÖ­›¡¸XÿÏQPPKtëÖ
«WBX˜66ælÇlÒNŸ¾‰nİ¼©¸¦Ç,,ô¯@eii‚€ O?~
T„B!„Awú²D¡PaÇs7®İ¤@ˆ†ğù\üüóxDEmÅøñë±iÓDû°‹òŠZ´p€µµ’’2u¶@U)0ĞGÌÂ/¿œÂªUã¯¿®bÙ²×ö¦z¶”>3Q*55II™ÉàñŒàâb‘Hˆğğv‰„ÿĞE  Ë•X²ä 6lˆÃˆşX¹2‚Õ)wÑÑÉ
=Ù)°¾üı=Àçsqöl:†ÕüE§qãºÃæÌ©(Q}ğA˜Æ¡O

J±wï%,X0Ø`§|\ºô/
eó\¦R1àré½vU•ªGJáêjÇröLÜS§nÁ¿ÿ>€‡‡#ÛqH£©–Lö´pUÓ¬ª,¹\™Lœœ"0óÂºÏ°*ròk‚Uù¸­­m&A!„B©Qvv!¾ÿş8Ş{¯k¶ãè´aÃ:aüøõÈÎ.Ô‹ŸÕÿå!>^Š˜˜dœ<™
¥Rõ¤$µoß{ğ2Øs©úF©TãÂ…,X0˜í(¤ÌÍM  %%å,'©›^½ZãÇO@­fèw!„B!D'ĞÕm–üıw"òóK0jTg¶£bPø|.~üqfÎÜqãÖãë¯ßĞÊMÅ„Íãp8hÛÖII™lGy%<"#ƒÑ¿¿,Ø‹1c~Æ°añÙgCáädÅv<½¤P¨pëVî“‰RRi®\¹ÜÜ" ÀD"$7DD<ù³©)ŸåäDWİ¼™)S¶àîİ|üøã8ÒÕ<2™§NİÄ¢EC¼–™™1$7$$h§@ ÿ÷İÀáp0{ö.00cFÓ-QmÙr<şlGÑšØØps³‡§§ÛQ4B©TÇ3b;†N±±1 <zTÂrv(»»Ö­‹Å²e#ØCHT°¢¦)XUX•…«ç§`åç—@¡PU»îË¦`U}¼b"ïÉÇ­ÀåÒïlB!„BÑ§Ÿîƒƒƒ%Şy§'ÛQt^Ş01á!6öF
d;Îd2.\È@\œG$!--vvèÑÃK–Gh¨YY0` %tÈÕ«·Q\,G÷î­ØBÀÂÂG¯&P@p°–.ıRiZ·nÆvB!„B¡[¶n=ƒ¾}Û4é]Ÿ	Ñ.×_}õ­µéé9˜9³?Û±!¯@"qÅ©S7ÙQ'®®vøå—Iˆ¾†ö"8x>ûlF 	HµÈÎ.xf¢Tbb&ÒÒ²¡V3àó¹ğôt‚DâŠ·ßH$DûöîTL#u²k×Ì™³­[qäÈ,´háÀv$ÄÅ¥B&S OŸ6Y¯k×–8|8I#kÕäÍ7»‚ÃÁãƒ?ì§Õãé"¥RÍ›OãÍ7»ÂÂÂ„í8Zsòd*zõ2ŒéS  R©éfüçX[›ÁÈˆƒGÊØÂ*.·¢¿téŸ˜5k ìí-ØDH£ÒÔ¬ª,™ìiáª¦)X—B.WV»nm¬ŠÌ¼ËYöö–àóiê !„B!ºæøñë8pà
6o¤Ğ^©)]º´Ä‰×u¦@U9e*>^ŠãÇ¯£¤D‘Hˆ~ıü°t©]º´|æı˜@`víÜ°cÇ9tîìÅbrRÕéÓi¬Ñ²¥3ÛQHq`lÌEY™~M òõm33c\¹r›
T„B!„@*¤¥å !![·Nf;
!‹Ãá`Á‚p…6øì³ıxô¨Ÿ>”vº"DÇùù¹aÃ†xÈåJ˜˜è×Ë”°°¶
aÍšhÌšµ;wÇ_Œlò#

J‘šš©4ûqQê’“ï¢´´âä¾@`‰Ä¡¡bDEõ†Dâooı¾&õVX(ÃìÙ¿ãÀ+˜81Ö™j££“Ñ¾½„Â†M¨Ôµk+|÷İ1dgÔû&èW1vlWp8|üñï``æÌ¦U¢úë¯«ÈÎ.Ä¸qİØ¢5– 1ñ¦OïËvQ©Ôô\ò.×ÖÖfÈË+f;
ëFîŒÕ«cãÆxÌšE›mRš(`UN¸ªm
VÕ–\®|RÜÊÍ-‚ZÍ¼°nÕVå„«Ú¦`=_Îrv¶¦0!„BÑ ²²rÌ›·C‡vDh¨˜í8z£wo_¬^}
…Š•óÚJ¥—/ÿ‹˜˜ÄÇK‘˜xææÆèŞİŸ~:}û¶yéùí#ü±bÅßXºôu˜›7RrR›Ó§o¢[7š>e8NµçEtg„¶m]ğÏ?·1ztg¶ãB!„B¨Ø°eËi¸¸Ø"$Ä‡í(„¼ÈÈ`8;[cúô_qïŞC¬];Ö '¢ïüü\¡P¨pãÆ}´kçÆvœ:333Æüùƒ0dHÌœ¹¡¡«ÕÓ§‡êLC[
nİÊ…Tš©4ëÉt©ÿşË ØØ˜C$ÀÇGˆğğöH\Ñ¶­+]<#õÏ?·1uê”––ã×_ßFÏº3M‡a;–‚qãºklÍÀ@OğxF8w.ƒ·×ØºÕ3¦8à£~‡L¦Àüùƒ´z<]²~ıI¼öšîîìO1Ó–¸8)ŒŒ8èÖÍ›í(£TªÁãöso}4kf‹û÷±ƒuææÆ˜<9?ÿ|‘‘Á°µ5g;!MFEa‰ht
Ve«ºrVÕ)Xùù%P(TÕ®[Û¬ÊVMå,+ğx4ùB!„J+WşÂÂŠ.É«ëİÛîÃåËÿ5Ú§ÜÜ"ÄÆŞÀÑ£)ˆ½¢"Z´p@ß¾bÌŸ?è…)S/3thG,Zt G\Ã°aµ˜œ¼
…B…‹ÿÅ¢EôoÑèë¦a:¸ãÌ™4¶cB!„B *P5:™Lİ»/bêÔŞàré¢:!ağàö
­1yò/ÿ7N„‡‡#Û±!Õğòr‚¥¥	’’2õ²@U©m[üõ×üüó	¬^}ÿ„/¿…öíİÙ¦ÙÙÏL”’J³qãÆ}”—+Áçsáéé!FŒğ‡Dâ‘Hˆ-·x@ØÇ06lˆÇâÅĞµk+¬];ÎÎVlÇzÆµkw‘]ˆ¾}ÛhlMøù¹âìÙ4­¨ à7º€Ãá`Ö¬ Ğ$JTW¯ŞÁ¥KÿaáÂ!lGÑªØØèÔÉÖÖ¦lGÑµš—«Ÿ“µ©ysÜ»G* xûílÜuëNâã°‡Rš˜‚UYÀª,\½l
Våã2™¥Õ®[]«²pUÛ,[[3ØÙYÀØ˜NÕB!„Ã˜x6ÄcÕª89éÖyZ]çååG?~]k*•Jää»ˆ‰IFLL
’’2ajÊ‡¿¿>úh ğƒ‹‹]½×wp°DÏ­±oß%*Pé€¤¤L”••£K—–lG!ÀápÀ0ú5
 :thãQZZN›kB!„BXGWeÙüƒ’9F
d;
!MJ` ™‰‰7âµ×¾ÂO?Cp0M#D×qĞ¦’’2ÙÒ`<¢¢ú`àÀvøøãß1xğ7?¾æÌyMo&áÊğï¿¹‹R¥’“ï"?¿  XC$" À“&ÁÇGˆÖ­›Ñ¤Qåæáı÷ÃéÓ71}z_Ì˜ÑO'wà;~ü:œ­Ğ¶­‹F×íÒ¥%bcS5ºfmFî‡ƒ™3w€a,XŞhÇfÃO?€ŸŸ+<Ù¢5Ã 66ãÇwc;ŠF)•*p¹4êyÍ›ÛáÖ­¶cèL‚o¿=ŠI“‚àà`Év$BH#ih¨}
VÕÇårå%¬Š¡R©_XÓÄ„SSc˜šòj‚UõñŠ‚¶¶fpr²ÖÉ×Á„B!¤i‘Ë•xÿıßĞ¹³FîÌv½Ô«—/bco`îÜ[óÁƒb$$¤!&&ÑÑÉ(,,C‹
aæÌ~	ñÑèµAƒÚá£~GQ‘VV†³i“>:>ööğòrb;
Ñ zY jßŞJeEyÓ¯·B!„BôİİÚÈ¶o?‡şııh§%BX Ú`ïŞ÷0sæŒ»³g¿†¨¨ŞàpèæBt‰DâŠ‹ÿe;†Æxx8bçÎw±{÷E|úé~=šŒ•+#tªÄ©Tªq÷îCH¥O'J¥¦fáæÍl0kkSxx8A$ 4T!Ú¶uÛÑI—ŠéÓ…‰	{÷NC§N-ØT£ãÇ¯£W/_¿îğÄÏ?ÇâÑ£RØÚšktíšŒ¦Mû ¶D•]€¿ÿNÄš5£Ù¢UÉÉ÷]€^½|Ù¢Q*M ªNóæ¶ˆ—²CgDFcıú“X·î¤FoJ"„>MNÁªZÀ’Ë•Õ~¬j+?¿
…ªÚu«›‚Uµ€UY¸ªîcöö–àó©|L!„Bfùò?‘™ù›6M¢k°õÔ¹³¶l9İ I-•S¦âã¥ˆNÆÅ‹ÿÂØ˜‹À@/L›Öaamáí-Ğpò§úõk‹Y³vâøñë2¤ƒÖC^îÂ…[ğ¤¢bÛ)ê®EØÛ[àêÕ;T "„B!„°
T(##.d`Û¶·ÙBH“ejÊÇ÷ßÿ$7,[ö'Ò°víXÚmœâççŠ-[Î@¡PÌÍ[	iö`ôèŸŞË—€½}ã–

JŸ™(•šš…¤¤LÈd
ğxFpq±ƒH$Dxx;ˆDÂÇÿ	èÂ
Ñ)
…
k×Æà«¯¢1|x',_>B§'»”âŸşCdd°Æ×ôÃ —/ÿ‡Ş½¯ 3thGp8L›¶Ãà“O7Ú±ËÆ§`ooÁƒûÿ‘#× Ø@"qe;ŠF©T*ğxFlÇĞ9Í›ÛâşıGP«šRÀÜÜS¦ôÂš5G0qbM£!„ºĞTK&{Z¸ªi
VÕ–\®€L¦@NNQµ;V?_ÀªÈÉ¯u
Våã¶¶01¡Ë„B!MÙ¹s·°~}¾ür4<<Ù£·:tp‡J¥FRR&:wözå¯ËÏ/ÁéÓ7—¦®!'§îî!22½zùÂÒ²qÎ£[[›¡sç–8t(‘
T,»té_¼ıvO¶cáp8P«õ°AÀÇGˆ›7³ÙA!„B!T jL;vœ‡@`à`ÛQiòŞy§'ºti‰)S6£wïUøöÛ±:5†¦ÌÏÏååJH¥Y‹]Ø£QÎÎVX·î-ÄÄ$cÎœİèÕk%,GDD€ÆU\,Ç­[9Ï”¥®_¿‡Š 5D"!$7¼ùfWøøT”¥LMùÏBˆ&İ¹“©S· 55_=#Fø³é¥bcSÁ0@PæßØÛ[ÀËË	.d4j
 †é xï½ŠÕÂ…CõøÚ$“)°m["#ƒ¦Ì[“˜˜d„…‰®(«TªadDªçyy9A.Wâîİ‡ps³g;N˜4)¿ür
+W2ø‰s„ÃQYÀjˆš¦`U-`U®Ÿ‚•—W¥R]íº/›‚UõñŠ‰X¼'st´—KÏß„B!ú¨°P†iÓ¶!4TŒQ£Ù£×ÜÜìáäd…ş¹ıÒUjjMF\œ		i €Z`òä‰ ‘¸5Fäj……‰±zõa(•jÚèˆ%¹ÈÉ)ªSè6µZ.W?Ïå·léŒôô¶cB!„B¨‹ZÍ`Ï‹92€.¢#ÚµsÃáÃâÃw`ìØu˜6­/fÌ3ø›d	ÑuŞŞ˜™#))Óà
T•BCÅèÜ¹%¾øâfÌØşÁŠpq±«óZ*•™™!•f!1ñ¤Òl¤¦f!--j5KKxy9C$ 4T!|}›ÃÑ‘&ïı³k×Ì›·^^N8rd&<=ØôJ¿€ OØÚškeı€ Oœ?K+k¿LÅt&Ş{o+øôSÃ(QíŞ}%%r¼ùfW¶£hUvv’’21kV¶£hœZM7fTÇÛ[  HKË¡Õc&&<Ì;Ó¦mÃ[ougõÆ"BiLšš‚Uµ€%“=-\Õ4«  –¢¼\Yíºµ°*2ój,gÙÛ[Òy=B!„–,X°r¹«Wb;ŠAhßŞW®Ü~áñ’9ÎœICLL2bbR] ''+„„øàûïÿ!!­ammÊBâ…„ø`áÂ}¸zõ6:uò`;N“tş|Œyğóse;
Ñòrx<ı|ßÛ²¥3bb’ÙA!„B!T j,'O¦âŞ½G1Bó&!õgccõë'`óæ3X¼ø ¿µkÇ@$²&‹Ë5B›6Í””‰Ñ£;³Gk¬­M±xñ0„‡·Ã¬Y;¼~†)SzÕX¶.((}f¢Tjj®]»‹²²rp¹FpuµƒH$Dxx;ˆD¥¼½02ÒÏÈ©T\,Ç¼y»±gÏ%Lœ„O>	‡±±~¼•Q«ÄÆŞÀäÉ!Z;F` 'öï¿…BÅÊ£ƒ·‡DEm…ZÍà³Ï†èı4£M›NaøğNpr²b;ŠVEG'ÃÔ”îİ[±EãT*Fo/$k“µµœœ¬––^½Z³GgÚ›6ÂâÅ°kWÛq!D/h¢€U9áª¶)XUXr¹òIq+7·j5óÂºUX•®j›‚UõqSS>ll´³é!„Bˆ!Û½û"öì¹„_~™Ú¼MÚµsÃï¿_  ü÷_ŞãÂT2ÎM‡ZÍ@,vÁ›ovAh¨~~®:y>ÖÛ[ ;ÄÆ¦RŠ%.d Cw½¹B^N©TéíÿÏ–-‘]ˆ¢"¬¬t£èI!„Bišôó]•Ú¹ó½Ğª•3ÛQ!Ïáp8xë­îáı÷E¿~_bîÜAˆŒ¦Ò!,‘HÜ˜˜ÉvŒFè…˜˜ğİwG±jÕ!9’Œ+^—Ë}2QªrºTvv!€Šò§H$€Dâ†ˆˆ ˆDøù¹ÂÌÌ˜åï†ÍKJÊÄ”)[PPPŠ_~™„ĞP1Û‘ê$1ñrs‹Ğ»·¯Öè™LÄÄLtêÔBkÇ©Mxx{p8DEm…\®Àòå#tò¢ı«ˆ‹KÅõë÷ğí·cÙ¢u11É	ñ1Èç¹\¡·’µ­U+g¤§ç°C§p8,X0Ã†}‡˜˜d½{®!„}TQÀâÃÆ‚Uµ€%“=-\=?+?¿
…ªÚuk›‚Uµ€õô{xú1+š‚I!„&%##óæíÆäÉÁô~ZCÊÊÊÁçópûv:vüYYpp°D·n­°zõ(„…‰õ¦ø$Â©SRÌœÙí(MÒùó·Ğ¿¿Û1ˆ†¨Tj¨ÕŒŞ¾ç¬¼_îÖ­\´kçÆrB!„BHSFw5‚GJqøğ5¬X1‚í(„Zxy9aß¾éøùçXºô şüó*¾øb$||h!ÍÏÏ;vœ‡R©ÖÛ“À¯*;» ‰‰™05å£gÏÖˆ—"4t5àó¹ğôt‚DâŠÈÈ`ˆDBH$n¬ÙMˆÖ1ƒâ±dÉAx`Ï(…õ»±’MÇ_‡@`_ßfZ;†§§#-qáBk* 4¨€ŠIT¬X¡Ÿ%ªõëãĞ«´½    IDAT£‡7Ú´iÎv­*++ÇéÓiXºt8ÛQ4N­f TªalL¨ªÓª• 7of³Cçzağàöøä“}èÑÃÛ ‹…„bh41«j«rÂUmS°>^ñùÕ©©€U1‹_ë,;;*B!DoÈåJ¼óÎf´j%ÀüùálÇÑkÿı—‡øx)bb’qòd*”J üı=O½Üø30Ğûö]‚B¡ŸOçêS~~	ÒÓsàÉv¢!J¥ ôö=£››=ŒyHOÏ¡!„B!„Uúù®JÏìÛw	<jÏvBÈKğxFˆŠêƒ^½|1kÖNôë÷%¦Më‹éÓûÒI]B‘ŸŸ+ÊÊÊ‘c0%ÆÂBnÜ¸©4©©¥RRî¡¤D ¬!‘¸aâÄ`äåáÀ+
m°lÙëèÖ­Ëé	i\ùù%˜1c;Nœ¸÷ßÅ„ËÕÏ2å‰×Ñ§O­‰8<qáÂ-L™ÒSkÇyƒµ‡LºÃ`åÊ½*QedäâøñëØ¸q"ÛQ´..N
¹\Ş½Û°EãÊË+nfÖ×ÉÚÖºµ\Ã0zõï³1|şù0/Ç×_Ç`îÜlÇ!„¢e-`/Ÿ‚UõñììÂÇŸ_ñØƒÅP©Ô/¬YYÀª,\Õ6«êãßÎÎÖôO!„F±pá>Ü¾èè™tµd2.\È@\œ‡'!==vvèÑÃK–Gh¨ıú­†¿¿½Ø[oíÚ¹C.WB*Í‚XìÂvœ&åâÅ  •©<ïÍãéçï[.×-Z8 ##—í(„B!„&î&j;vœGxx{XZš°…òŠÚ´iƒßÇÆñX¹òo<x+VŒ@—.-ÙFH“ 	abÂCbâ½+P)*Üº•©4Ri3!•fáöí|0kk3øøáã#Dxx{H$®‹]`añìë„3Â0gÎnDDü€±c»`áÂ!ôZ‚4	§O§aÚ´màr°{w”^_~ô¨W®ÜÁ»ïöÖú±¼ğİwGu¢1p`;lØÀGdä&0°re„Şìº~}\]íÑ§á•ŠŒÜáìlÅv£Uíüü\QPPŠ;wòáîîÀvâìl…Ù³àÓO÷cèĞğõ5ìIt„BNÓS°ª°ärÅã‰XÕOÁÊÏ/B¡ªvİš¦`U-`U´x/|ÌŞŞ’n€&„BÈKíßÛ¶%àÿ{‹Î/¼¢Ê)SññR?~%%rˆDBôïï‡à`ºtiùÌë0//g½/øøaii‚ş¹MªFvş|¼½°µ5g;
ÑŠÉt Ÿ¯Ÿ@³f¶¸¿€í„B!„&î&Ò²ë×ï#))Ÿ>”í(„:âr0yr`îÜ]xıõï1th,\8¸A;ÓB^Ïç¢uëfHJÊDDD Ûqj”]ğÌD©Š?ß‡\®ŸÏ…§§||„1Â‰D"!Üİí_©Üàîî€ß~{^Á¼y{“‚eË^Ç€~ğÒø”J5¾ù&_ƒ°01¾ür´Ş_Ø;~ü:ŒŒ8èÑC¤õcz"?¿àåå¤õã½Lß¾m°~ı„Ç%*«VÔùUQ‘»w_ÄGĞÛ‰g¯J­fpìX2&Lb;ŠVÈåT ªXì.×II™tƒS5Æë]».bŞ¼=Ø»÷=ÖK©„B›&X•…«Ú¦`U-`ÉdJ–a˜Ö­®€UY¸ªm
–­­lm-`bB¯Ã!„Cvıú=Ìšµ‘‘Áxí5	Ûqt–R©ÆåËÿ"&&ññR$&Ş¹¹1ºw÷Æ§ŸAß¾m Öü:ĞËË	ééú] 22âÀÏÏW®ÜÆ›ove;N“ráBiú”!©<ïmjÊg9Iı	…ÖÈÎ¦!„B!„]tKË¶o?wwtî¬¿;çÒÔ¹ºÚaëÖ·“Œ…÷¡[·e˜:µ¦MëK7e¢E‰’’2Ù â¦úŒŒÜÇE©Š‰R))÷—W ¬!	à‰I“‚O˜j¦‘†ÂÃÛ#(H„eËşÄ¤I*ÆªUTä$åîİ‡ˆŠÚ†«WoãÓO‡ 22˜íHqüøuxÂÚÚTëÇòós…™™1ÎŸ¿¥* ¢DµaÃ„'“¨¾øB·KTÛ¶%€aŒÈv­»p!99E{ƒM ª™™1¼¼œpíÚ]Øí8:‡Ë5ÂÊ•8ğ+üòË)ƒ-B1-`µOÁªú¸\®|¡„•—W¥RıÂš&&<˜šÃÔ”Wë¬šÊYNNÖ:ıŞBiÊ

J1iÒ&ˆÅ.X° œí8:''§'OŞÀÑ£)ˆ½¢"Z´p@ß¾bÌŸ?è…)SµñòrÂÉ“©ZN¬}íÛ»Ä÷¡OÊË•HL¼C¥5SVV 055f9Iı	6HI¹ÇvB!„BHGwi‘B¡Â¾}—L;b BCÅöÁ÷ßÃwßÃ=—0{ök<¸=ı'Düü\±wï%¨ÕL£İ4£Tªq÷îCH¥U'Je!--j5++Sxz:A$ 4T!Ú´iK­æ²µ5ÇªU#Ñ¿¿æÌÙ…•X° œ.|ƒpèPfÎÜ''+üı÷øú6g;’F¨ÕââR1eJ¯F9ŸÏE‡î8>£Gwn”c¾Š>}Ú`Ã†‰˜4i#†ÁêÕ£tòFH•JÍ›Oã7º4Jám‡%ÂËË	ŞŞ¶£hEeŠ&ÔÌÏÏUgŠêºÈÏÏÓ§‡bÉ’?ÒZgŠ©„Bˆ6hr
VeK&{:«¶)X–>yíö¼ê¦`U°*2×\Î²··|å“	!„òêÔjQQÛP^®Ä†éùç““ï"&&11)HJÊ„©)şşøè£0À..võZÛÓÓ	÷î=‚L¦Ğë‰3íÚ¹cİº“(--‡¹¹ş?ôÉ•+·!—+@¨‰L¦  ß¨kdg²ƒB!„ÒÄÑİDZ}–`Ä¶£B4ÄÄ„‡?ì‡‘#±jÕßˆŠÚŠ~8¹s¢gÏÖlÇ#Ä øù¹¢¤DŒŒ\´lé¬ñõ
JŸ™(•šš…k×î¢¬¬<\\ì 	Ş"‘"‘ŞŞVoüïİÛ'NÌÆÒ¥1{ö.;–‚+" X³–‰ú’Ë•X²ä 6lˆÃˆşX±"Â .^½z£W/ßF;f@€'şüój£ïUõîí‹'aâÄ`_~9ZçJT‡'!33&ô`;J£8|ø†íÀv­)/W Œé&šH$nX»6ÃĞf5øàƒ0;–‚÷ßÿû÷O—kÄv$B!D'i¢€%—W®^6«²€%—+Ÿ·rs‹ V3/¬[µ€U9áª¶)XU75åÃÆÆ¼¡?B!Äà¬\ù7NŸ¾‰}û¦ÁÑQ»Ëé²ŠqâÄu=š‚“'SQXX†-$ÂÌ™ıâ£‘Éè^^N`àëÛLÉÙÑ¡ƒ;T*5®]ËD` Ûqš„2àädG¶£*+3ŒU^^1
•p	!„B!¬¡•íÜyÁÁ>õŞQˆ¢»\]í°víXL›Ö«WÆØ±ëĞ©“æÏ„ÎéÄ/!šĞ¦Msğù\$&f6¨@¥P¨pëVî“‰RRi®^½œœ" €9D"$7DD@$ÀÏÏffºYä°°0Á²e#0lX'Ì˜±!!+hÑ;7ofcÊ”-ÈÌÌÇ?Ã!†Wäˆ‹K…@`Ö­…vÌ€ O¬]{ëÜ½zµÆ¦M“0aÂÈåJ|ûíXÖÊ©©Y/b×¯Ch¨¸I\PNL¼ƒÛ·ó0`€„í(ZS9Å@7ªª€ Oäç— ==­Zi¾¨nx<#|õÕèß~úé¢¢ú°‰B1H,>ll Ñ)XUX2ÙÓÂÕóS°òóK P¨ª]·¶)XUXO¿‡§st´¢6!„ƒòÇÿà»ïaÍšÑhßŞí8ªº)S&&<xbÚ´>k«•Iïàr‘‘«×*77{ØÚš#9ù¨Éùóô³6@•¨ÌÌô»@¥V3ÈÍ-Bóæ¶lÇ!„B!„4Qt7‘–äæ!6ö¾ûîM¶£B´ÈÛ[€ŸK—şÃ²e1lØ·
á³Ï†À×·9ÛñÑk|>"‘×®ebØ°ÿgï¾Ãª.û?€¿Ïbo'Ã…E–G·–+wfÃ‘e†>ZÙ°Ô43Vš–ZÔpoK4s  â@E5QÙÎúıA&›÷9‡÷ëºëÉï÷û°¾çÜ÷÷süKõ˜„„”§:J]¼x·n=„F£…B!Cıú.ğñ©‡W^é/¯ZhÕÊ®®¶•üJ*GëÖõqøğ,,Yr ï½÷+öí»ˆE‹†s²™ŞÖ­gñŞ{¿¢I“Z8xp&<<jˆT)NœˆFÇ^UÚÙ¥uëúJ%8wî6BBZVÙ¸¥õÜsM±nİD¼ôÒLº_=ryÕ^PxåÊ}ôè±nnN˜4©†ÄíÛ‰8}:[·N©Ò,¢ìÛw	µk;ÀÇ§è(•&¯€ÊÜœSEiÑ¢.,-ÍpæL¨ŠÑ´imÌİŸ¾AA«İbDDDÆB]°
`åu¸*®Ö¿Çsï_˜¢
°r;b)Ší‚åädÃÙ‰ˆ¨Ê>ƒ{÷’ñüóO¿x1o¿½	¯¾ÚÃ‡·”®j%%eàäÉ8t(
‡_Á“'™pw¯Î½0eJ7tíÚ66æ•šÁÌLš5ípçNR¥Sê×wF\\¢èÕÆ…q˜<™›™š¼*ãî@•û™-!!•kÚDDDDD$¯&ª$[·…••zöl!:
U€ lÛ6‡Eá³Ïö W¯%:´Şz+nnN¢ã-7\¼ÿÌñÔÔ,\»ö7¢£ş)”ŠÇ•+÷‘‘‘ w÷*7{cÊ”nğñqC£F®&·ó¯……sæôC¯^Ş˜>}ºuûsçÀ¨Qíª´hƒ¨4ÒÒ”˜={vîŒÀ„	0oŞ “½,;[sçb±páĞ*×ÖÖ^^µpö¬aP@—.Mò;QMº+V<]D¥RiğñÇ»Ğ¯_+´n]_ïã?z”Û}ğîİdÌ»¼nnNhØĞ:4Ôûx†hß¾Kè×¯•IŸ'ò.`eª¢)2øù¹ãìÙÛ9²è8íõ×»",,¯¼²‡Ï„½½•èHDDD¤g-ÀJî‚UğxBBê?÷Ï=–˜˜FûÌsæ`å\×«àñÜ×#‡««I¿ï'""ıÒét˜1cbbáÖ­‡˜5«7€ÜëÆ_ƒví`îÜş‚SV­V‡Ë—ï",,F!<<R©~~˜2¥:uò‚[•çruµCbbZ•«oÎˆ},:Fµp÷n2ÓáçÇ€LMVV ÀÜÜx¨œœ¬ IIé‚“QuÆ«‰*ÉæÍgğÂF½ó•]p°7ºwomÛÎañâıØºõğÃ”)İØ‘Š¨š7¯ƒ]».`çÎ¸q#!¿»T\\î"‹%š4©…&Mj¡_øøÔC‹õ`ee&8yÕ
¬C‡fæw£Ú»÷"-†ºuEG# \¸p“'ÿ„ŒŒllØğ*ºvm*:R¥:s&ÙÙj5®ò±Û¶­3gbª|Ü²èÒ¥	6n|cÆ|‡©S×cÅŠ1Ë¥P©4xíµ±ÿ%üùçM:4Sïc'%e@*•@«ÕA§Ó!33'¿Sá˜1ßãµ×C§N^z×PÄÄ<Btô,\8Dt”J•×ŠTÅkÓ¦BC/ˆağ¤R	¾şz4‚ƒcÖ¬-øî»ñ¢#‘Òw¬‚XÙÙª:bŞ+))*•¦Ğç-ªVÁ¬Ü-ù3·Õ¨a[å]ƒ‰ˆHœ“'o &æ à«¯ááÃ4ÌŸ? ãÇ¯%şïÿÆ™Ü&uOd",,aaÑ8tè
Ràâb‹.]š`âÄÎxî¹¦°µµšÑÕÕ		©B3èƒ§§3öí»(:FµqR©ŞŞuEG!=S*UP(dFıİÚÚ
…iiJÑQˆˆˆˆˆ¨ãÕD• <<7n$àë¯G‰BDH¥Ú/¼ˆ#G®àË/ {÷Ehİº>¦Níà`oÑ‰RBBÊS¥¢£påÊßP«Õ˜:u4pE“&µ0dH ||ÜàåU5DÇ6yİ¨BBZâí·A·n_`Ö¬Ş˜0¡¤Rî6Lbèt:¬Y†v¢]»†øúëÑpuµ«Ò……E£~}Ô«WõEŒõ±qã_ÈÎVÃÜÜp?îµoß6¼Š1c¾ÇÔ©ë±lÙ(Lº‡E ¢¢îá÷ß¯á¹çô[l÷äId2)´Ú/.T«swz»£G¯¢Y³:øè£Á
j¤×±Áîİ‘pr²®”î^†$¯€ÊAëÖõ±lÙA$$¤¢fM;Ñqš³³¾şzFŒø?üøãIŒ$:™}`å\×«`–R©FJJf¡Ï[XV^ÁUq]°,áèhÍMˆˆŒÈwßı¹\µZ­V‡_~9[·"==?ÿüììÄéËõëpøpÆ_İ‚V«ƒ·w]ŒİÁÁŞhÙ²AuptuµÍßTĞ˜yxÔ@\Üchµ:®YU²ÈÈx4n\66æ¢£)•*XZÿ&Ş¶¶HIÉƒˆˆˆˆˆª1®\T‚Í›Ï Y³ÚBZ¸‘áJ%öFp°7Îœ‰Á7ßÅ¸q«Ñ²e=LœØÏ?`r;µ•FZš·o?ú§P*·£TTÔ=$%e  jÖ´ƒ—W-´n]cÇvÀ;ïlÅ²e#ñüó‚“‡€ <8‹ïÇ‡†bÏH,]ú"<=EG£j&11o¾¹aaÑxóÍ`LŸŞ«Ú,Œ8q;‹ébà	•JƒK—âhØE2íÚ5ÄÚµ/cÜ¸Õ^„ØØDh4¹ÅL2™Ÿ¾OïTII™EşªT¹c_½zşyÃ$¨öï¿„–&ÿ4;;·€J¡	NbØÚ¶m 339N¼Á÷Y¥Ğ±ccLŸŞóæí@óæuL¾‘ˆˆˆŒKE°€â»`<­~¦ëñãôüÍ)
27—ÃÂÂòb»`<[ ¥€ƒƒ%\\ìªÍ\‘Hwï&ãèÑ«ĞjuùÇ´Z-Î»88X	LW1™™98yòŠÂÑ£WqÿşÔ¨aƒañâáèÕ«ìì,EÇ,’««Î‹£Â<=¡Tªğğa*jÕ*ÿû*Ydäøúº‹A•@©TÁÂÂø¨ìì,‘šÊ*"""""‡Tz–“£Æ®]‘xóÍ`ÑQˆÈ€´iÓ mÚ4@xx,V¬8‚éÓÁŠG0yr7ä_âîø;w^À¢Eû±jÕXx{×­¢ÔD£Vkqï^2¢£ÿí(uıúÜ¸‘ N[[Ô¯ï/¯šöF“&µàí]NNÖO=Ïš5Çqõêß‚^…q27—cÎœ~èİ»%Ş~{zö\Œ¹s`Ì˜öµs"™®°°h¼ñÆ˜›+°cÇ4xˆTeRS³péÒ]L™ÒMÈø5àâb‹sçâ¾€
ÈíDè‰“'oB«ı÷b;F‡ÈÈ;øóÏ›èĞA…LIIO]ò_r¹]»6Åôé½ô6¦¡ˆ‹{ŒÈÈx¼óNÑQ*]N
…Œç¼XY™ÁßßaaÑ, *¥·ßî‰k×şÆÄ‰k±ÿÛ¨]ÛAt$""""½Ñg¬‚XÙÙêBo+X€•œœ™ßIö¿
ë‚U° +¯àª°Ûœœl¸±Q)üğÃqH¥Owmr×yÎŸ¿ƒAƒ¾ÆæÍ“àìlSéY’’2`mm^¡ÎâqqqèPŠÂ_İ‚F£E‹õ0xp ‚ƒ›#0°¾Ñè:;ÛâáÃTÑ1*ÌÓ³  66‘T•H§ÓáâÅ»èİÛGtªYY*XX˜‰Qaöö–HMUŠADDDDDÕ¨ôìğá+HKËÂÀ¾¢£‘
ğÄÚµ/ãÆ¬\y³goÁGíÄˆm0fL‡";ÄüğCnİzˆ¾}—aéÒ1x°''*^JJæS¥®_€K—îB©TA.—¢n]GxyÕBÿş­àåUëŸÿÕ,Õ…Í>>nˆŒŒ¯‚Wazüı=pğà,^¼sælÃ¾}±dÉÔ©Ã‹}©r¨ÕZ|õÕA,]z}û¶Â¢EÃz÷ÎÊğçŸ7¡ÓéĞ¾½¸îE~~8>VØø¥¥Ñh1mÚÏøóÏ§‹§òÈåR,^| Û·ëïk™œœ‘ßåª°ñ=ñİwã!—›^‡¦ĞĞpt´BPPcÑQ*]NºBÙT';6Æ†§DÇ0‰K—¾ˆşı—aüø5f»¾éƒ¾
°”Ê®Šê‚U° +;[õOG‹4ètÏn˜ñß¬ÜœŠb»`åwp°æg"2y™™9X¿ş/¨ÕšBoW«5¸qãúõ[†_‚zõ+-ËÖ­gñŞ{¿bÌ˜˜?`©§Tªpöìm<….áîİd8:Z£cÇÆøä“Ğ³g¸ºÚVZîÊäêj‹ääL¨T£.
vuµƒ••ââ£]»†¢ã˜¬˜˜GHMÍb*e*¨lmÙŠˆˆˆˆˆÄâ¬¿mß  ÆÜ…˜ˆŠÕ¸qM,]ú"Ş¿¶l9ƒõëOaÕªßÑ±ccŒİ!!-ó'ÁRpöl,  'Gƒ)SÖãÏ?oâÓO_0ê‰rª<gÎÄàƒBÑ·¯¦Lé®×çV©4ˆ‰y”ßQ*:ú""îàÑ£4 €½½¼¼jÂÇÇC‡¶ÎÿïŠLæúúºcß¾‹ĞjuF³# !13“ãı÷û¡wo¼ùæFtíú9ş÷¿=º½èhdbâã“0yòOˆŠº>„‰;‹$DXØB»éU¥À@O¬Y&lüÒĞh´xóÍŸz¡Ğâ) · ï¯¿nâÌ™´iÓ@/ã>|˜Vh*¹\†fÍjaıúWLöâ¸ĞĞè×¯•I‡ıWv¶ff¦ù}Ô·Î½°xñ~ÜºõºŠcllÌ±zõKèÛw)fÍÚ‚åËG²Û‘ä`UDQ]°
`å\ı·ÖãÇéP«ÿ|ZR¬‚Çs;bÉóosv¶…LfúŸÃˆÈxmÛvYYÙÅŞG­ÖáÎÇØ¸ñT¥t7OIÉÄ¬Y[°gÏEèt:ìŞYbU\Üc„…EãĞ¡(?~ÙÙjxyÕÂÀşèÜÙíÛ72‰y0WW[èt:$&¦õ5(‰nnN¸sç±è(&-22
…Í›×…*R©‚¥¥ñPÙÛ["%…TDDDDD$¯(Ò£””L>|Ÿ>Tt"2..¶˜2¥;&Mê†“'o`Ã†S˜2e=jÔ°Á!­1n\víŠ€L&ıgç·Ü~7m:èèX½ú%¸¸çi¤qq±`ÁNìİ{	`f&«PUBBÊS¥.^¼‹›7 Õê PÈP¿¾||êáÕW»ÀË«|}İ+åçÑ××©©JÄÄ<B£F¼°·¼üüÜqèĞ,,^¼ï½÷k~7ªZµ*va
 ìÚY³¶ÀÃ£…\DG&,ì:zöl!4C@€'>ıt7îßb°çvîŒÀöíá%ŞO.—béÒƒøå—×õ2îãÇi…Œ!ƒ»»6mškks½Œchnİzˆ«WïcÁ‚Á¢£T	•J…‚Ó¥áëë;;?~TeĞ°¡+Ö¬y#G®‚‡GÌœ":A]°
`)•ÿ\Õ+÷x&²³Õ…>oqX¹™åEg99Ùp#5"ªTßÿ
ià—O.—ÂÁÁ³g÷Æˆmõ>~xx,^{íÇ:	jHpï^2bb=5Ïœ­Æ™318~<·h*:ú¬¬ÌÔ<=š›äzG6 €¤¤£.  gg<~œ.:†I‹ˆ¸ƒfÍê˜ì&aÕ]V–it ²³³ÄƒODÇ """"¢jŒŸšõh×®HH$@ïŞ>¢£‘‘‘J%èÔÉ:yáÎÇØ°á6m:o¿=WW;h4Oï|©Ñhq=z,Â?N„¯¯» äd22²±jÕ1,_~8‘K§®\ù»TOIÉÄõëğO¡T<¢¢î!33 P³¦||Üì)SºÁÇÇ×¬²nPÍ›×…….Ä±€ª‚ÌÍå˜3§zõòÆ›oş‚çûsçög7**7¥R…O>Ù~Ã„	ğ¿ÿõ¯Ö]_RpóæC|ôQc¡9|}İ —Kqî\,ğš¥(}úø`Ş¼øæ›#HNÎ€N§+ôBµZ‹?ş¸É2:J    IDAT‹ãáããVáq““3ú·\.ƒ““6oGGq]Ã*Ûo¿]€««-Ú¶ÕO'/C—™™c;qV¹\ŠNšàğá+xé¥N¢ã•  FX¸pfÌØŒš5í0fLÑ‘ˆˆˆˆ¨‚ôQ€•×áª¸.X°²³Õù…[Ş5¹`V^‡«âº`<na¡€%»¦Q¡ÂÂ¢qóæÃBoS(d03Sà­·zàå—;ëı¢}µZ‹¯¾:ˆ¥KB"‘ü³šû·J.—áÈ‘+P(Zâ?®#,,¿ÿ~iiJxxÔ@ŞX°`0ÚµkhòE¦ÖÖ r×££5’“3EÇ0i‘‘ñhÕªâóèd˜²³U077şyoKK”J•èDDDDDTUß«+ÁöíáèÕ«%ìì,DG!"#æî^ï¿ß³fõÆ?„áÃC½ŸJ¥ARR\/¾†áÃÛTqRM­ÖbÓ¦Óøì³İHKSB­~ºĞ.=]‰„„”ü•Jƒ˜˜Gˆ~€èèùİ¥ââ ìí­àåUMšÔBÿş¾ğñ©‡-êÁÊÊ¬Ê_[A
…Í›×ADD<†m-4‹©¬#GfaÉ’x÷İ­8~ü:>ûlHşN†D¥qéÒ]Lšô<ÉÄºu/#8Ø[t$áÂÂn@¡¡M±E*––fhÖ¬ÂÃ·€ÊÜ\×_/¿Ü	¿ıv‹ïÇİ»IJ¥Ï+2|ùå¬[7±Âã¦¦*óÿ[.—ÂÚÚÛ¶MEİº~nC¶kWú÷÷ƒL&¥J(•*áï_ŒIp°7fÏŞ‚ôôlØØ˜f¶Êòâ‹í÷sçn‡››{®©èHDDDD$Pn–ööĞk¬¼¬ÂŠ³
vÁJJÊ€J¥)ôy‹ë‚•W€UTqV¶Ë«ÇçI¢êæûïÿ€\.ƒZıïß…B‰D‚W^é‚©S»ÁŞŞJïãŞ¹ó¯¿ş.^Œÿ§pôéâQF‹eËaşüß`mmN¼0oŞ tëÖÌè»0••µuîWzºñP99YãÖ­Âö¨â4-¢¢îaÄ^3`ª²³Õ&Ñ]ÌÜ\^dçV"""""¢ª`üŸ¬Ä½{É8s&k×¾,:
™…B†´4å3i4Zh4LŸşÎ‹Å§Ÿ¾`ò;­Q®°°hÌ»·n=*tWÒ<Ÿ~ºJ¥W¯ŞÇíÛ‰Ğh´07—£I“ÚhÖ¬6ÆïˆæÍë iÓÚpq±­ÂWP6¾¾î¸p!Nt“ba¡Àœ9ıĞ¹³Ş~{ºvıEŸ>ì¤IÅÓétX³&¼øõ×)¨U«|™š'¢ài…£D
…C‡¶Æ/âÈ‘+øì³=¸víd2I~!•J¥Á¡CWpõê}4kV§Üc©Tšü]e2)ÌÍåØºu264íî†W¯ŞGtô,^<Lt”*“ÛJüï¡±èŞ½4-ÂÂ¢Ñ»wKÑqŒÎ;ïôÁß§àå—×bãÆWÑ®]CÑ‘ˆˆˆˆÈˆé£V^V^ÁUI]°ò+•j¤¤Ş¤°¬¼‚«’º`9:ZWëåD†êîİd=z5I.—A£Ñ¢W¯øßÿÀÍÍ©RÆİºõ,Şyg+4m‘ë[:©©Yøé§‰èÒ¥iµ^û´²2ƒT*1‰*GGk$%±Ue‰~€ÌÌ´jå.:
U’ÜTÆÿÊÜ\¬,v """"""qŒÿ“•Ø¾=vv–Üm˜ˆôjëÖ³EOı+wqaÓ¦Óˆ~€Õ«_2èBª˜7ğÁ¿áØ±kÉ¤ÅO)r???ôëç‹fÍj£Y³:¨_ßÙè:PøúºcÃ†SÈÉQs±]Ï:uòÂÑ£³±`ÁNLœ¸ıûûbáÂ!pt´PRR¦OÿG^Å[oã­·zİß“ÊtâÄŒÙNt €¿¿6l8e4;J¥{£Gæ8|ø
¾ür?"#ïB&ËíH%“I±té!|÷İ¸r‘œüïâ¼L&ÅÆ¯¡E‹ºúˆoĞBC/ NxŠRe²²X@U5jØÀ××^fU9H$|ùåää¨1zôwøùç×„w"$"""¢ê«¢X@ñ]°
ÏÎV?S„•˜˜şLgi · ËÂÂòb»`<[ ¥€ƒƒ%\\ì •J*ò¥!¢ÿX»6:.­©{÷f˜3§?5ªœÍ†RS³0kÖìÚùÏ‘¢×· @«Í-°ªÎÅS@î¼ƒ••22”¢£T˜££5’“3DÇ0Yw`n.GãÆ5EG¡J’­†¥èff&Cv6¨ˆˆˆˆˆHÃ¿’ÎHìØqƒùUû	<"ÒŸÈÈxÄÇ'•úşáá±èÙs1Ö¯µZ\\$%eàË/bİº0H¥¹Å
…-D¤ÕjÑ±£¾şzTUD¬T~~îÈÉQãÊ•ûğõåÎiúfkk/¾†Ş½}0cFn7ªE‹†#8Ø[t42 şyS§n€T*Á¯¿NAÛ¶¼8¼ ˜˜G¸ÿ	:uò à	•JƒK—âX_tœR“Hr©‚ƒ½qâD4–.=ˆS§nA£Ñ`ÏHÜ¼ù°Üq$%¥È-Z½ú¥jSà°kW$ğ…DR}.4ËÊRD'8cÒ³§7V¯>­VÇ‹ËA&“bùòQ˜8q-Æı[¶L†›èXDDDDDå¢Ï.X°²³Õ…ŞV° +))*Uá›ÊÖ«`V^ÁUa·99Ùp—¨€¬¬¬_
:]îFLóæD@€G¥wâD4&O^””,”T8•G.—áèÑ«èÙ³E¥å2ÖÖæÈÈÈ£ÂœœX@U™"#ãÑ²¥Ïw&ÌT657W ;[-:UcÆÿÉÊ DEİÃµkã‹/†ŠBDF(**
şşşÈÉyzâÛÚÚvvËô\Z­		©èÖíxôh­>c’PÔ¬ù¤R €V[RW²\/ÆWf°*Ó ìì,ÏªJÔµkS92ï¿¿ãÇ¯Á˜1í1oŞ@^„^Íi4Z,[vË–Bp°7¾ür¬DÇ28§Nİ„••™Áüòôt†‹‹-Î‹ÓKUFFÂÃÃ¡Õ_¼«oo¼Ñ!!uñÛoÑˆˆHÀÂ…[0ztù.šˆMDLšä¹ü!~ÿı¡ÓVŒB¡@ûöíó¥õáüù8Ü¾ıúëí9Aff6,-¢c•–øì³=8}:íÛ7Ç()2¬^ıÆ_Q£¾Ã¶mSàåUKt,""""¢*§¯,¥òß‚«¢º`,ÀÊÎVA©TááÃ4ètÏhü· +7§¢Ø.XyÇ¬¢Ã·h©©JXXÈËtqw\\nß¾]‰©¨0YYj´lY:¹Á×·&ÒÒnã÷ß+çûpëV2æÍËëv%B!ƒN§ƒV‹bçU*vî<—JÉU”Zµj¡iÓ¦U:fI¬­Í‘n
¨¬­Fff×*Add<Z·6ÍÔ¨ìrrÔ077ş99;P‘PœéÕƒ;ÎÃÃ£<EG!"#”€œœ¬Y³¶¶¶ùÇ5şş;³Ğ…¾’ØÙ™ÁŞ¾·>c’`ÑÑOpçN<ÈÄıûxøP	•*waI.—@§“Ú‘êöíD¨ÕZÈåú»[‰D7DFŞ$:Ist´ÆÿıßXôéãƒwßıaa7°|ù¨Jİ}’×ıûO0eÊzDDÜÁüù1qbÙ
{«“Ó§càïïiP»;úùyàüùX½<WNN´Z-š4i¹¼j?Fz{ƒuÄ­[`ccš5íÊı<mÚøÀÅÅFÏ	+.##±±±Ğh4z- Ú¶-¹¢U«êÕ	'+KkÑ1ŒJãÆ5Ñ¬Y„†gUäQõ†]‰íÛ§¢aÃòuÍ#""""ª®ò
°*¢¨.X°ò
®şÛëñãt¨Õ…u”Ô«àñÜXòüÛœm!“÷<}I†_‰¸¸DŒ„±cƒP§C‰ÉÎÎ†µµ5<==+? =%0°U•Œãå¥­­+<ÉDzz22²‘™™ƒŒŒ¤¦*‘’’…ÔT%23s¬,23s7LOÏ›[ØÙYVIÖû÷ï#;;»JÆ*¤§^®²rtÌ¯KNÎ`•©T\½ú7×pL;Pé‡ñ²L§Óa×®ì‰D":±ÀÙÙYt2:÷î=Á	ˆ~€7°wï)¤¦ê Õæ.ÂJ¥¨ÕÄÆ&¢Q#ã¿pÓÏÏ\£ÚèßßíÚ5ÄÌ™›1xğr¼öZWÌİÛ ŠC¨ríß	o¿½	ÎÎ6Ø³g:š7¯#:’A;}:Ã†µã)X³&L¯Ïéìì…BLg—Šï6«ç¨•Q”¦Vk±{w^~¹ú-šgeå°U9ä‡o¿ı<Ïó}XZšaİº‰>|%^|q¶oõê9ŠEDDDDT­è«VÁ,¥òß‚«¢º`¥¤d"9999…_\\Vnfy‘ÅYNN6ÿYíÁƒ<y’…ÿû¿cX±âzôh‰;#(¨q±ëèfff;gCú1lXÙ;4§¥)!‘H`cc^	‰
—œœŒ¬¬¬*¯´llÌ‘‘aüTV €””,Ô­Ë¹}ŠŠº‡œ5|}İEG¡J¤TªannüóŞæær(•ì@EDDDDDâ°€ª‚ÂÃcŸ„ıDG!"¢jD"‘ ^=GÔ«çˆ®]› 22~Gtt4~ùå7DG?ÀÍ›qÿ~2jÕªØn†Â××ß|siiJØÚZˆS-¸¸Øbİº—±qã_øğÃP=z+VŒB³f,¤1eÙÙj|üñ.¬YsC†báÂ¡Ü²¤ >>	mÛ6å)şşøôÓİ¸ÿI©vü%ÓrìØU$&¦cĞ ê÷Y533––ü»UVúaáÂ½8qâFşûK*;;üüók2d%ş›7OBƒ¼ˆˆˆˆÈXè£ +¯ÃUq]°
`eg«ó·=JƒV«{æy`åu¸*®VÁã
ØÛ[UôKS¬´4%€ÜN( päÈU<xnn;¶Fn_éÈtpè_
…,ÿ÷Ê˜åuÎ)ªÈ”Ê/""¶¶¨_ŸóO¦L¥ÒÀÌÌ°‹©KC¡›Äß4"""""2^, ª ĞĞ4jäÊ‰‰ˆÈ`¸ºÚÂÕÕ;6E¯üüÜ¡Õêpñâ]5§ÚH$=º=:uòÂ´iÑ§ÏRÌœ‚I“ºA*e÷MSsóæC¼şúˆOÂÊ•c0h¿èHFá¯¿nA¡ÁßßCt”§øúºC.—âÜ¹Xà+:U±mÛÎ¡mÛpw¯!:J•cªòqw¯??wìÜyTzàèh;¦bÔ¨ï0hĞrüòËëğö®+:UÜ,ìí¡×.X°”Ê®şÛ+))£È“‹ë‚U° ëß×ğïm5jØB.—ú¼Z­YYOw“Ğh´ €»w“±pá,Yr /¼€	:£Y³ÚåúºUGr¹4ÿ÷É˜åuÑcá„ş]¼–-ëqİÎÄ©ÕÈd…Ÿ‡IŞÏ©V«ãÏ,	Áª
ĞjuØ³'£Fµ…ˆˆÈäÕª•»ãgDD¨ğğ¨mÛ¦âÛoá‹/öáøñh,[ö"j×fWS±uëY¼÷Ş¯ğòª…fÀÓÓYt$£qútZ¶¬gpº¬¬ÌĞ´im„‡³€ªºIKSâàÁ(,X0Xt!²²Tì@UNøaÉ’ıX¸p(ÌÍ9eTQvv–Ø¼y&Lø/¼ğ6lxõEÇ""""""#PÑ.X©©J¤¥e!5U‰ÔÔ¬ÿËıwZš))¹Ç>LÃ­[‘’òïñÂ:ÄH$ØÙYÂŞŞ¶¶Oı¿¹¹:İ³]³ @§ÓA£4¶l9‡ÿ‚ŸŸ;^½+6d—!¢’Èd2¨ÕÆ_@•×9''‡Túvùò]™ÖÆšô¬Ü‚#PU¯†©€¿şº…RĞ¿+ÑQˆˆˆª??wDDÄ‹QmÉåRL™ÒAAñÆÑµëç˜;w Ff1¹1KKSâw¶"4ô&Lè„yóäïI¥sútŒÁvk	ôDxx¬èTÅöì‰„N§CÿşÕ³p.33Çà
ÅÀ~X°`'»Š–¢ã˜++3üôÓDL¼#F¬Âš5Ğ¥KÑ±ˆˆˆˆˆÈÄÙÙYÀÎÎuËÙ7;[ıOAUV~aUjjV~ÑUÁ‚¬¤¤<z”^ªçU©r³"#ãñÚk?ÂÉÉ
³fuD«V\o'*Š\.…ZmüEGry^ªg4©üÔj-nÜHÀ+¯t…*™V«ƒLfüGy]´Š*¼&"""""ªlÆ¿5…@;w^@óæuàåUKt"¢İ¼yIÙ'ÔJó¸;wîà¥—^*÷úRØøyÙDH$¸yó¦Şï[ùúºãÂ…8Ñ1ª=__w:4cÆáİw·âµ×~Drr†èXTwĞ«×œ8^Å‚ƒY<UF))™ˆ~€¶mˆR¨€ O\ºtÙÙU»(]ğœ\UïôyÎ/kfC;oÛvÁÁŞ°³³Eˆ¬¬v *§š5íĞ¦M}„†^Å¤˜™Éñí·ãĞ¯_+Œû=öî½(:Q±ÌÍåpuµEÃ†®ğ÷÷@—.MĞ¿¿/FnÉ“»áİwûâÓO‡`ÅŠÑøé§Wğå—ÃKıÜyER©ÎÎÖ033Ì=_E®/éƒ!¬™5gVYó…†6G§/r¹)t Êı]W©Œ¿ÌÜ¼™€ìl5¼½ËY1KFC£ÑšT*Sø»FDDDDDÆÉø?Y	¢Vk±wïEè':
Q•‰‰‰³³ó3Çûí74H@¢’r6*;__7Ü¿ÿ		©¢£T{
Ì™Ó6¼Š3gn£{÷E8~üºèXTJ:«WÇÀËáææ„C‡fl%CwæÌmèt@ëÖõEG)T@€'T*.]×½ÏÁÁï¼óN¥£Ïs~ÁÌE½ÿ1T÷ï?Á©S·ğüó¢£¡Õê­fª
0ÀF!##[t“"“Iñå—/bÄˆ¶xıõ±mÛ9Ñ‘ˆˆˆˆˆˆôæÉ“¬"o“H¿i“%BBZ`éÒqùòÇøî»!hŞÜµªb–‰±¯/6'g(¯©ªæM…L&…Zmü…yrrØJŸ®\¹…B†ÆkŠB•L«Õå³¼Z­–¨ˆˆˆˆˆHP•Ó‰ÑHLLGÿş¾¢£U­V‹Ç?süàÁƒèÙ³§€D%3älTv­Z¹A"‘àâEq… ô´çkŠcÇf£M›úxñÅoñÁ¿qñËÀ%&¦côèïğÑG¡˜6­~ùåuÔ¬i':–Ñ:}:^^5áèh-:J¡<<j Fœ?GXggg,\¸°ÒÇÑç9¿`æ¢Şÿª-[ÎÀÁÁ
İ»7E¥RNKK…è(F«_¨Tj>|Et“#•J°pá¼öZWL›ö3V¬8":‘^¤¥=]@¥PH!‘H “Iàïï‰Y³zãĞ¡™¸zõ|÷İxÚV‚Ò–±¯/6'g(¯©ªæM…\.3‰N-R©r¹”¨ôìÊ•ûhÜ¸f~™.­V™Ìø/óË{, """"""QŒÿ“• ¡¡àççOOãÙ‰œˆLƒZ­ÆüùóáîîŒ;O<É¿ıÉ“'?~<œQ¯^=Ìœ9J¥2ÿö7¢aÃ†pqqÁ¤I“™™	 Ø¾};Z¶l	KKK¸»»cùòåÏŒİ®]; @­Zµò%&&ÂÚÚ–––OİW§ÓaæÌ™ğõõEbb" @¥Ráı÷ßG½zõàèèˆ)S¦ ;;7oŞ„D"ÁÑ£Gááá'N@"‘`Û¶mğóóƒ½½=>úè£üç.êyşë¿ÙvìØ-ZÀÂÂ4Àúõë o¼ñ^~ùåüÇ¥§§ÃÊÊ
.\ €"³”ô½ €£G¢iÓ¦°··Ç‡~Xø7µ÷­®ìí­Ğ ÂÃcEG¡¬°jÕ8¬Z5›6A¯^Kpõê}Ñ±¨aaÑ^„›7bÇ70cFˆIìV'ÒéÓ·Ğ®]CÑ1Š$‘Hàëë†ˆqTyçù‚™
;¯ş÷~ÿŠºuë"99 ğóÏ?ÃËË >ç·k×K—. $%%A"‘`æÌ™  FGGGìİ»@Ñï
]ØûŸÂÂy\§ÓaË–³2$°Ú.˜gfæ  ,-Ùª¼œœ¬Ñ©“~ıõ¬è(&I"‘`Îœ~X´h¾øb/fÌØl»HQõ–şï‹‹-†k‹ï¿+W>Å®]obêÔîğö®ûÔÜOy·UÔ:ûyìÇD‹-àììŒO>ù6l@ƒ`gg‡¹sçæß·à\SIóRÅ­Y·ÖUÜz^Y²–f~ë¿¯I_c”w¬´ó…%}}cstú–ÛÊ4Š
9rrLãµŠ¨¨{ğö®+:UF™Ìø×ôòÖ%µZÎ‰‘, *•Jƒ.cÀ ?ÑQˆ¨Z¶l¶oß½{÷âèÑ£¸~ı:>ùä“üÛ§NŠ»wïâÌ™3Ø·o8€Ï?ÿ<ÿö~øû÷ïÇ={päÈ,X° ©©©>|8Ú´iƒ›7oâ³Ï>Ã›o¾‰¤¤¤§Æşë¯¿  <È?¶k×.ôïßÿ©ûét:¼óÎ;8rä9gçÜbÓÅ‹#::§NÂñãÇqêÔ)Ì™3'ÿq‹-Â_|_ßÜî~›7oÆ±cÇ°dÉÌŸ??¿ûCIÏSX¶ôôt>S§NEll,æÎ‹	& ##C‡Ehh(ÔêÜ®9¡¡¡hĞ A~¢²”ô½ÈËpîÜ9¬]»|ğA~1YaÊrßê, ÀCh'*Zÿş¾8|xìí­Ğ§ÏR¬^}:w3jµK–ìÇ‹/®BëÖõqèĞLxŠeô”J.^¼‹¶mˆR,__w¡T…)ê_”¢G˜>}:ğöÛocÃ†°¶ÎíüUğœß·o_9’ÛÕåÄ‰°³³Ã±cÇ  P*•xî¹ç*ôş§0†pÿóÏ[ˆMÄ°amª|lC‘••[@eeÅªŠ1¢-»†»w“EG1Y#G¶Ã÷ß¿„ß~;‰×æÿì£N¼ğÉ'/àèÑÙˆŒü‹CŸ>>°µµĞë8ÅÍç·”'44§NÂçŸ¹sçbëÖ­ˆŒŒÄâÅ‹ñÉ'ŸäÏQœk*i^ª¤5«¢æÁJZÏ+MÖÒÎoı÷5ék}®“UtM°¬ã¹\j2›¯(2¨TjÑ1LÊ•+÷Ñ¼yÑ1¨
hµ:H$Æ™_^;P‘(ÆÿÉJ€ß¿†””,ôïï[ò‰ˆôlõêÕX°`Z´h–-[bİºuèĞ¡€Ü]Ø6mÚ„¯¾ú
4@Ë–-ñÑGaÃ†ù_¶l7nŒ6mÚàã?ÆæÍ›aaaK—.aùòå¨S§ê×¯ ….°ü×îİ»Ñ·oß§½ûî»X´h6mÚ„5jä_»v-V¬X777´lÙŸş9:”û_|áÃ‡ÃÆÆ 0yòd888`Ü¸q ¿»_IÏSX6F©T
•J[[[¼ôÒKHNN†¥¥%‚‚‚ P(püøq ¹»3æ©İï
ËRÜ÷"ÏÌ™3accƒAƒÀ3;ï•÷¾Õ™¿¿'""â Ñ˜Æb‘©©WÏ¿ş:3g†`Á‚9ò[$$¤ŠU­ÅÇ'ağà¯ñÍ7GñÁƒğİwãaggYò©DááqP©4hÓÆ°¨ZµrG\Üc$'g”|ç*RÔ9¾8_}õ9‚={bÒ¤IhÓæß"¡‚çü>}úà?ş€J¥Âü©S§âÒ¥Kxòä	;†nİºÁÊÊªBï
cçñM›NÃ××½Z/˜ç¡°UÅ„„´„‹‹-6o>-:ŠIëÕ«¶nŒğğXòÓEG""""""*[¼ôRG4mZ»RÇ)n>§¸u <o½õlmm1vìX ÀŒ3òïü;Gõßµ¯âæ¥JZ³*l¬4ëy¥ÉZ–ù­ÂÖó*:†>×É*º&XÖñŒ‰T*1™Íêr»iq}O_>LÃ£Giğö®¾óÁÕ‰Nè¡‘£`‰ÅªrØ³'şş¨SÇAt"ª†âââĞ¨Q£ü7kÖƒ $$$@£Ñ aÃ†ù·7jÔwïŞÍÿwãÆóÿ»iÓ¦øûï¿aff†¸¸88íÛ·Çš5kJ•%==jµO?{ö,{î9|öÙgOGíÚµ!‘H ‘HĞ³gOÄÅÅ=•§ :ur'{
E™§°lööö8qâÎœ9„„„àÜ¹sJ¥Édxşùç±}ûv$&&âğáÃ9 Y”÷    IDATrd‰YŠû^ü÷qRiÉ§Ü²Ü·:ğ@zz6¢£‹ïBâÈåRL™Ò;v¼¸¸Ç^„C‡¢DÇª–vïDpğb¤§+±wïtLœØYt$“rúô-¸¹9üç??wèt:DFÆ‹’¯¨s|Aÿ½(ÀÁÁ¯¾ú*¢¢¢0iÒ¤üãÿ=çûùùÁÆÆgÏÅñãÇ1`À øùùáøñã8vìXş…"å}ÿSÒkuOMUbïŞ‹1¢­ñEff^UÑ?[T2…B†!CZãçŸO³h½’ùû{`×®7ñäIú÷_†˜˜G¢#¬âæsŠ[Êóß9©Âæ¨
[û*j^
(yÍª°1J³Wš¬¥ß*j=¯¢cès¬"k‚åÈ\¹r Ğ¼y]ÁIˆˆˆˆˆˆˆŒgÊH¥ÒààÁ(ôíÛJt"ª¦êÔ©ƒØØØüGDDà“O> Ô¬Y2™111ù·ßºuuëş;izãÆüÿ†‡‡²³³1xğ`¼õÖ[8uê¾ùæ›ReÙ¿?BBB9¾{÷n|ûí·Ø´i;öTö7n@§ÓA§Ó!99ıõWşíÿ])jq£¤ç),[VV²²²°~ız$$$`üøñèÙ³gşÎsC‡ÅöíÛ±eËtìØnnn%f)î{‘GR†m Êrßê¬iÓÚ°¶6GxxÑddüı=pàÀ„„´Äøñk0{ö–üÎ T¹”Jş÷¿xõÕuèÙÓûö½]é»¿VG§OÇ m[Ãî> 5jØÀÍÍ	.Ü%_q0¨Õj À½{÷:+V G˜1cFşñÿó¥R)z÷îĞĞPDGGÃßßİºuÃáÃ‡†>}ú @¹ßÿEôy|Çpèt:ä'4‡hYY* €••¹à$ÆoôèöHHHÁÑ£WEG1yÎØ±ãØÛ[aĞ å8ïs‰ˆˆˆˆˆ
SÜ|NIë@¥UØÚWQóR@ÉkV…Íƒ•f=¯4J;¿UÔz^EÇĞç:YEÖË3‘)¸zõoÔ¬i''kÑQˆˆˆˆˆˆˆŒ¨ÊèäÉxò$½{·…ˆª©1cÆ`Îœ9¸té¢¢¢0uêÔüÅ	…BáÃ‡cÚ´i¸}û6._¾Œ¹sçbôèÑùŸ1cnŞ¼‰³gÏâı÷ßÇ˜1c‘‘¬¬,Èårdeeaşüù €´´´B3äÅÀŸ¹İÊÊ
^^^x÷İwñúë¯C©T F‰Ù³g#&&QQQèÛ·/–/_^æ¯Ai§°lÁÁÁùg‰‰‰J¥033 têÔ	}ôÆŒSªÅ}/J²zõj¤¤¤”ê¾ô4™LŠV­Üxa©‘°µµÀ_ÃªUc±kW$z÷^Š¨¨{%?ÊíúõèÓg)vìÇ?NÄòå£`aÁN,ú¦VkqáBœQP¹]¨""§€ª0ööö €Ÿ~ú	©©©OÛµZ-&L˜€7Şx¿üò9‚;w(üœß§O¬\¹mÛ¶…B¡@÷îİ±víZ¸»»ÃÓÓ Êış0Ìóø¦M§Ñ¯_+ØÙYŠ"T^¡.;PUœ‡G5Æ†§DG©\]m±mÛ´jå†¡CWbÿşK¢#œ’æsŠ[*­ÿÎ57/”oí«4ëy¥QÚù­¢Öó*:FEÖÉJ«¸¯¯!ÎÑU¥èèhÚ´–èDDDDDDDF…Te´gÏEøø¸ÁÃ£†è(DTM½÷Ş{èÙ³'BBBwww|ñÅù·¯X±uêÔAëÖ­óï÷Ş{ïåßşÊ+¯ $$}úôAïŞ½1sæL899áÓO?Åˆ#àíí†âÅ_|f7:OOO´k×µk×†J¥BRRêÔ©SdÖwß} °páB Àœ9sàîî: cÇhÔ¨ÑSÙK«¤ç),›¥¥%Ö¬Yƒyóæ¡~ıúXµj6oŞ+++ €L&ÃóÏ?ÔÔT<ÿüó¥ÊQÒ÷¢8¯¼ò
=zT†WMùû{°€ÊÈôïï‹Ã‡gÂÉÉıú-Ã7ßV«Ëälİz½{	GG+><ÁÁŞ¢#™¬Ë—ï"==mÛ6¥TZµ2ü*ÌŸ?Ó§OGëÖ­1qâÄüÛV®\‰GáwŞ££#V®\‰×_>,ôıHpp0”J%ºté èĞ¡rrrĞ·oßüû”çıOC;_»ö7"#ã1bD[ÑQ„ËÌÌD"aá¨ŒÕG\Áİ»É¢£TÖÖæX·n"FŒhƒ—_^‹•+ŠDDDDDDdPŠ›Ï)i¨4
[_*j^*99÷³ry×¾JZÏ«è×£¸×¤¯1*²NVZÅ}}m¨ª]¿ş ^^, """""""*‰N§{æÊÕwßİŠ˜˜GØ²e²ˆLK£ÑÂÏo>^y¥Şx£‡è8d øûCeuôèQtïŞ=‚³³³è8ÕÚœ9s‹7ŠR.“&MBtt49":J¥;pà2&LøW®|{ûÒ/~’xË—ÆÒ¥Ğ©“–-	[Ñ±Œ^RR¦OÿG^Å[oã­·zB&ã^	•éÛoÇ×_Æ¥K ‘HDÇ)Ñ©S·ğÂ+pöì<Ô­ëXæÇ'''#22AAAP(X˜¢oıúÎ›·‡_ÁÉ“ïÅÏceÚºõ,Şyg+bbô{±Nu¥RiğÆÂŒ!%?€ôfõêãøàƒßğÒKğá‡ƒ •Vïßm"""""2MÑÑÑÈÊÊB«V­DG!2ØŸGSºşÀÛ{.fÏîqã‚DG1z:Mš¼‡ùóbÔ¨ö¢ãP0•ßŸ'n`Ø°•¸|ùc89Y‹CDDDDD&¤”Ÿ7NñªÊ28uêÓÑ§è(DD¤GJ¥111øá‡êvA†+ À:.v7z–L&Åôé=±cÇ4Ü¾ˆ=á?®‹eÔNº…=!*ê¶nŒ3BX<UNŸAÛ¶Œ¦X¥U+7ÈdRƒïBEe§Tª°uë9¼øb[£ùy¬LYY*XZš‰a2
†kƒŸ>F+:Nµ2qbg|ûí8lÜx
'®EVVèHDDDDDDDDd îŞMFzz6š4a*""""""¢²à••e°wo$š5«ƒ†]EG!""=:}ú41aÂtíÚUt*gg¸»×@xxœè(TN8xp&:wn‚‘#¿Åÿş·*•Ft,£¢Ñh±dÉ~¶­Z¹áğáYh×®¡èXÕ‚N§ÃÙ³·Ñ¦MÑQJÍÊÊ×DDD¼è(¤g¡¡™™#ÚŠb23s`iÉ.iú4fL$$¤àèÑ«¢£T;}û¶ÂÖ­“qöìmº‰‰é¢#‘ˆ~  hÜ¸¦à$DDDDDDDÆ…T¥¤Õê°oßeôíËîSDD¦¦K—.HJJÂ'Ÿ|":
•¿¿.\`•1³±1Ç×_Â²e/bÓ¦Ó0à+ÄÆ&Šeîß‚¡CWbÅŠ#˜? ~øa¬DÇª6bcñøq:Z·®/:J™øúº#"‚7MÍO?DŸ>>pq±Å deåÀÊŠ¨ôÉÃ£‚‚ãÇOŠR-xb×®7‘œœ‰şı—áÖ­‡¢#‘`×¯?@­Zö°·çÚQY°€ª”Î»„„ôíÛJt"""BnÕ¹s±Ğét¢£PÚû÷¿µZ‹^½–`ûöpÑ‘Ú—¼‰‰iØ½û-LœØ‰Dt¬jåÜ¹X˜™ÉÑ¢E]ÑQÊÄ××‘‘ñĞjùwÓTDEİÃ…w0n\è(#++––, Ò·‰;ãØ±kù;ÛRÕòôtÆîİoÂÕÕıû…Ó§cDG"""""""""¢£ÀË«–èDDDDDDDF‡T¥´gÏE4hà‚&M8ADDd<‘šš…˜˜G¢£4lèŠ={ŞÂ°amğÆ1mÚFdfæˆeP²³Õøßÿv`Â„Ğ½{3ìß?ŞŞÆUÀc*ÂÃcáãã33¹è(eâëë†ôôlv/1!k×@ãÆ5Ñ¶mÑQFV–ŠT• GæhÔÈß}÷‡è(Õ–££5¶l™ŒÎ½0|øÿ!4ô‚èHDDDDDDDD$Htt¯_"""""""*P•‚N§ÃŞ½Ñ¿¿¯è(DDDô-êÂÂBsçbEG!=13“cÁ‚ÁX»v¹Š%ˆŠº':–A¸yó!úõ[†-[Î`ÅŠÑX¾|¬¬X  Ê¹s±ô£Ìš5«.\¸#:
éAjª¿ıvãÆ±]YY9üûX	$	&NìŒ_=‡‡ÓDÇ©¶ÌÍåøæ›1=º=&O^%Kö‹DDDDDDDDDUL§ÓáæÍxyÕ…ˆˆˆˆˆˆÈè°€ª"#ãqï^2úôñ…ˆˆˆş¡PÈĞ¢E=\¸':
éYÏ-pøğL8;Û¢_¿eX½ú8t:èXÂlİz!!K PÈpàÀì/:Rµ–™™ƒèèğ¥Ì
¼½ë 2’T¦`Û¶³Ğé€^Å dfæÀÒR!:†I6¬ìí-±~ıIÑQª5™LŠ?~~8K—ÄÌ™›¡VkEÇ""""""""¢*rïŞ¤§gÃË‹¨ˆˆˆˆˆˆˆÊJ.:€18pà2êÖuD‹uEG!"öòË/ÃÜÜ\t!t:	$’òGèt€¨ÆYÁÒR›1
8ş<<<Œ¯#JExàÄ‰¢cP%¨]Û[·NÆ²eñá‡¡8yò–.}V¢£U™´4%Ş}w+~ûí&Lè„yó@¡‰Uí?µZk”T Ğª•{…
O¯_¿ÎnG•@¥R•ù1ë×ŸÂàÁş°·¯>K#++66¢c˜$ss9ÆŒé€uëNbÊ”î°°`¡šH'vF­Zö˜6m#?NÇªUã`nÎi>"""""2>ˆŠŠƒééé°°à¼¾[· 6tœ„ˆˆˆˆˆˆÈø°U)8p½zµà…‚DT)Z¶l‰Q£FUÛâ)F‚\ñèQé/şÍÉ‘áúuGääH¡ÕJéŠÇ-+1eát: >Ş.8s¦6nŞt@R’9´Z1çŒ5JÈØ¢øùyàÚµ¿‘‘‘-:
U™LŠ3B°eËdDFÆ#8x1Îœ‰«JDDÜA¯^Kõë_Á‚ƒY<e ÂÃcQ·®#jÕ²¥\|}İqùò=ää¨Ëô8Ô¬Y“Ÿ‰*‰B¡@:u ——®øáÔ©[¸víoŒÛ¡’“Ÿ¬,;PU¢ñã;"=]‰_=':
è×¯¶l™„¿şŠÁèÑß"=ï‰‰ˆˆˆˆÈ¸8;;ÃŞŞ8çÙÈôØØØÀÕ•)døbbÂŞŞ
NNÖ¢£nM[‚øø$\»ö7>úhè(Dd¢\\\°aÃÑ1„™6m#¢£¯á—_>.õÅè99j´h1/¼0cÆtÀäÉëqöìmìŞı.,-Í*9ñ³®_€Ã‡£pğ`Î‹…¹¹:y!8ØÁÁŞ¨YÓ®Ê3UĞh´ˆˆˆGPP#Ñq¨’´oß‡ÏÂôé¿`Èo0{vL™ÒÍ$9t:Ö¬	Ã‚;Ñ¶mC|ıõ(ş10áá±FÛ}
 üüÜ¡RipåÊ}øúº—úq
…Íš5«ÄdTkÖG``}øø¸‰bp23s„¼¬.œmğüóXµêFl©ÔôÎÅÆ&0°>BCßÀˆ«0dÈ7øùç×xñ'''899‰ADdTbbÑ¨‘‹èDDDDDDDF‰¨J°oß%ØÙY mÛ†¢£™œŸşÛ¶…ãË/G”©“‡™YnÒ— óæÀ“'™Xµê÷JJZ¼&MjaÊ”î†‹?ÂçŸ………|ğ>@HÈ—X²d?.^Œ’Ï”Õ©ã€Zµìqş|¬è(TÉœœ¬±nİË˜7o -Ú‡áÃWáÑ£4Ñ±ô*11cÆ|>
Å´i=°iÓë,20:çÏÇ!0ĞSt”rkğÿìİ{\Î÷ÿÇñçuuPRI‘¨äE%‡"§RÌy,;‰}Û‡9nÈ)™óÈa‹ÆœFlÎ¦BÈ!ä°Š2J4’NWW×ï›ß6§Òu]ïëêzŞÿÙm]×õù<"uUŸ×õªWffÆˆç×$mõÇ"*ê
Ú‹NÑHùùE¨\™Tª4bÄ»¸uë¢£E§Ğ_6¬‰]»¾DNN>úö]{÷‰N"""""""""II¹zõ¸-ˆˆˆˆˆˆèmp€ê"#/£sçÆ00ĞBDT¡\»–ÀÀ9²¼½›”ùñ>>®8qâ:rsQ³¦9Fî‚åË!==[µ¥giYx 4ÔW®ÌÁºuÿƒ››-6mŠ…¯ïxyÍA`àN?™L.´µ¢ğğ¨‹¸¸TÑ¤‰°gÏ¤¥=„¯ï’
ówâD2¼½"99;vŒÂøñ¾Üê¡RR²ıT«7PI$4mj‡K—ÒD§Ğ[Z·î,-MÑ­››è”Ÿ_##ÑZıú5Ğ±£BCˆN¡°··ÄÎ_B__Š>}–#55Kt©@JJêÖµADDDDDD¤•8@õå!..>>.¢Sˆˆ*”¼¼"ºÎÎ6˜8±Û[ÃÛ»1JJJpôh `Ø°wQ«VUïUfj¹ÀÛ»	,ø çÏÏDDÄ8ôïßqq©ğóûM›NÇĞ¡ë±}{<)«µPİBI‰Bt
©IÓ¦vˆŠš€æÍëàı÷W`ñâ­ıû/..ÁâÅ8ğ´lY‡MDË–uEgÑ+œ;w•*éÃÅ¥¶è”rqw·ÇÅ‹ ÒFùùEØ²ånËùx…¼<n R‡aÃ:âäÉ¸pá¶èúkk3üúë(Ô¨aŠ¾}—#1ñ®è$""""""""R"™L;wşDıúÜ@EDDDDDDô68@õ^…D"AÇN¢Sˆˆ*”©SEff¾ÿ~Ğ[_ükaaºˆŒ¼ 00ĞÃŒ½±gO<N¼¡Ì\¥J%ps³Ãøñ¾ˆˆ‡ØØi7ÎåaÂ„p4i2½{‡ ,,wï>«U<<êâñã<Ü¸‘):…ÔÈÌÌ«WûcúôŞ	9„!C~Ä£Gy¢³ÊäÎ?Ñ¯ß
¬\™3û`ÍšÁ033E¯qşü-¸¹ÙiıàŠ»»=nÜÈDnn¡è*£_~9‡§OñÑG­E§h¬‚Œ9@¥jíÚ5„§g=,]%:…ş£jÕÊøùça¨_¿Ş%.]JDDDDDDDDDJ’šš¹¼„TDDDDDDDo‰T¯umÚ4à…¬DDJ´{÷ElÛ‡¥K?„]µrËÇÇ^…L& x{7AçÎÎ˜6í×çoÓTuêX"  ÂÃ‡ãÒ¥ÙX¹òSÔ©c‰… eËYèØq>‚ƒ÷áìÙ(Ú¹YG]š4©“Jˆ‹KBj&‘HĞ»vFRÒ=té²çÎiÇÇÁşı—Ğ¥ËB<y’ß~û
D'Q)œ?-[:ˆÎ(7WW[””(ğûïˆN¡2úé§“è×¯ªW7¢±>-„‰I%Ñ:aôè.8tèwÄÇs£¦155ÂæÍCÑ¼y|øá¸z•Ÿï‰ˆˆˆˆˆˆˆ*‚””,H$88X‰N!""""""ÒJ z…¢¢b;–WÑ)DDFjj&NÇĞ¡ïÀÇÇ¥ÜÇëÖÍ99ù8s&åùÛ‚‚ú!5õ6n<Uîã«KÕª•Ñ³§;BB>FBBÂÃ‡£}û†Ø±ã<úôYOÏ Lš´^EQQ±è\£¯/…»»Î»%:…iÖÌŒƒ““Í_kìàaA;ñùç?¡k×&øí·¯àäd#:‹J!7·ÉÉ™hÑÂAtJ¹ÙÚZ Z5\¾|Gt
•ÁñãÉHL¼‹ÁƒÛŠNÑXÅÅ%Éä¨\™¨Ô¡S'g¸»ÛcÙ²ƒ¢Sè%ŒŒ°nİÿĞ¢Eøù}¤¤{¢“ˆˆˆˆˆˆˆˆ¨œRR²`ccÎŸ½%P½ÂñãÉxú´]»6BDT!ã‹/Ö£Ak|óM¥ÓÎ®œœlyåùÛ¬ĞFàáÃ\¥œG*UÒGûöÔçÏÏÀ‘#“1xp[\»–Áƒ„³óTøû‡aÓ¦Xde=«1<<êáìYíØ<DªQ­š	6nüÓ§÷Æ‚0dÈZ<z”':ë_®]Ë@÷îßaûö³õGHÈÇ06æ/¸´ÅÅ‹·!—— yó:¢S”ÂÅÅW®p#‰6ùñÇãğòª77;Ñ)+/¯ `ll ¸DwŒë¨¨«HHHB/a` ‡5k†ÀÙÙ|°
ÉÉ¢“ˆˆˆˆˆˆˆˆ¨RS ^½ê¢3ˆˆˆˆˆˆˆ´¨^!2ò
\]mQ«VUÑ)DDB`à¤§gã‡ÁÀ@OiÇõñqAdäåm›ùê«®022Àüù¿)í<¢4jT#GvÆîİ£qöl fÍê ˜6mš7Ÿ‰Ş½C°råa\¿)¸T,ºHMÍÂıû*Óe‰>—.¥ÃÛ{ÎŸ¿%: °}{ºwÿ&&†ˆŠš€=İE'Q;w¶¶¨YÓ\tŠR¸ºÚ"!¨´Ezz6şÿû_Ñ)-?¿ øê«jÔµ«ÜÜl±bÅaÑ)ô
FFØ°ás8:ZcÀ€U:ÿ}‘6»}ûêÔ±ADDDDDD¤µ8@õ
…şÎíSDDJ²gO<6o>%KÂŞŞR©ÇöñqÁ;"1ñŞó·™˜TÂ´i=ğóÏ§Ÿ¦Ôó‰T»¶>ùÄë× 11k×~†FjbõêcxçyğòšƒÀÀ8~<ÅÅ%¢sÕªeKèéIqáÂ-Ñ)¤Z·®Ã‡'¢aCkôí»+WŠ»¨;'§ Ã†­Ç¸q[1bÄ»Øµk´Ò?’zœ?-[Ö¡4®®µqız

d¢S¨~ü15kš£kWÑ)íïT•+W\¢[¾ü²öïOø×óqÒ,ÆÆ†øé§ ØÙUÃÀ?àöí‡¢“ˆˆˆˆˆˆˆˆè-¤§gÃÎ®šè"""""""­Åª—¸|ù23ÃÛ›TDDåuëÖLœ!CÚ¡{w7¥¿iS;ØØTEDÄå½½_¿ğô¬‡ÀÀÿÚNUQÂÛ»	,ø .ÌÄ®]_¢Gw;–?¿ïáî>£GoÆŞ½ñÈÍ-«r¦¦FhØĞqq©¢SHCT«f‚¿À˜1ŞøöÛı=z3òó‹ÔÚpşümtíºqq·°}ûŒï==>ıÖF
….ÜFË–¢S”ÆÕÕÅÅ%xĞOŸbëÖ32¤ôõù9äuş€Š¨Ô©[7W89Ù $ä èzSS#üüó0X[›¡ÿ•HKã‘6‘ËKp÷î#ØÛs€Šˆˆˆˆˆˆèmñê«—8|8ÖÖfpq©-:…ˆH«cèĞõ°µ­†ÀÀ^*9‡D"·wcDF^yáí³g÷E||vì8¯’sk
==)<=ëaêÔˆ‰ù±±Ó0vlWdfæ`äÈpu?¿ïƒŒŒÇ¢sUÆÃ£.Îå ı?©T‚ñã}±uëp=šŸÅ¸~=Såç•ËK°xqúô	³³š€Ö­ë«ü¼¤:7ofáÑ£<4kVGtŠÒ88XÁÌÌ—/ßBo°m[d²|øa+Ñ)ïï*ccP©“D"Á˜1]°wo<’’8”©ÉÌÌŒ°yó033Æ‡†âÁƒ\ÑIDDDDDDDDTJ÷î=†L&ç*""""""¢rà ÕKDG'¢S§ÆH$¢Sˆˆ´Ú¬Y»‘’’…Õ«ıQ©’¾ÊÎãããŠË—ï ==û_owq©?l…Ù³÷àÉ“•_ÓÔ©c‰€€øøÙX°àT­Zü†æÍg¢cÇùX¼8		éj;—‡G]$$¤£ @&:…4L»vˆˆ33c¼÷ŞwØ·ï’ÊÎuïŞ#°
Ë—ÆŒ½±víg°°0QÙùH=.\¸J•ô+Ô,H$4n\W®p€J“)
¬[wıû·äç’Rà*qzôpGƒÖX¶Œ[¨4……	¶n…BAƒÖ<ÿwCDDDDDDDDšíïâvv–‚Kˆˆˆˆˆˆˆ´¨şãÑ£<ÄÇ§¡S''Ñ)DDZmÿşKX·îæÏ€úõk¨ô\mÛ6€©©úı…Û¦Léââ½˜³Z5àĞP$$!<|8Ú·oˆM›NÃ×w	Z·ƒI“¶áàÁ«Éä¢sËÅÃ£.d29ÒE§ªU«*vì?¿V:t=w*ıc>*ê
ºtY„¬¬'Ø¿,:p ¿‚¸xñ6\\la` ':¹ĞãW    IDATE©\]m¹JÃ;v7ofaÈv¢S´7P‰#•J0q¢/öì‰çç-P½º)¶l†?şøƒÿ¨õßé‚ôôl zõ*¢Sˆˆˆˆˆˆˆ´¨ş#::R©íÛ7BD¤µşøãOLœ¸ƒµA¿~-T~>CC}¼û®"#¯¼p[Õª•1a‚Ö¬9†›7ï«¼E“ }û†
ê‹óçg "b>øÀ		wàï7·é:t=¶oCNN¾èÜ2³··„µµ9ââRE§†24ÔGPP_,[ö~şù4üü¾ÇıûOÊ}Ü¢¢bîÄ!kÑ¹³3""Æ¡I“Š³©ˆ€‹ÓĞ¼yÑJçâR‰‰÷xá¼[³æÚ¶u„““è­ğôi!õ¡¯ÏuˆğŞ{MÑ¼¹=æÍÛ/:…J¡NK¬_€naÒ¤mj3-QE”;»j|ñ>""""""¢ràUEÿOÏº033BD¤•d29†Û€š5Í1sfµ×ÇÇ±±7ğøqŞ·ÔÖ˜:u‡Úz4T*››Æ÷EDÄ8œ9ˆ©S{  @†	ÂÑ¤É4ôî‚•+#%%Ktn©yx8àìYPÑëõïß{öŒFFÆcøú.Æ¹soÿ1sóæ}¼÷ŞR„‡ŸÁòå#$äc˜˜TRb-‰VXXŒÄÄ»pw·¢t®®¶(**Frr†èz‰¤¤{8zô†ë(:Ekäå¡renŸiÊ”8r$	'N\B¥àînÕ«ã×_ÏaùòÃ¢sˆˆˆˆˆˆˆˆè5ÒÒÂÎ®šè"""""""­Æª()Q &æ:uj,:…ˆHkïEbâ]„†úÃÈÈ@mçíÜùÙçî#G’^¸MOOŠ  ~ˆ‰¹†¨¨·T`gWŸ|â…õë0«V}Š:u,±|ùa´k7;ÎGpğ>œ=›¢Ñ¯Nß²e]œ;wK£I34iR‘‘ãÑ¬™=úõ[•+Ë~Ñğöíqğõ]}})¢¢&¨eã©ß•+w “ÉÑ¬YÅ rt´†±±!._¾#:…^bõêc¨W¯::vt¢58@%—W}¼óN#|ûí>>Ó:9cæÌ>˜?ÿ7ìÙsQt½Bzz6ìí9@EDDDDDDT ú‡‹oãÁƒ\tîì,:…ˆH+:ô;Ö¬‰Á¼yàèh­Ös›™¡U«úˆˆxù€”—W}ôéÓS§î@^^‘ZÛ´¹yeôìéqõêìÚõ%¼½›àÀôé³nnÓ1zôfìİ¯q–uñçŸOqó¦ölÍ"qLM6“'wÇ¼y¿aÄˆ¥ú˜ÎÍ-Ä¨Q›0vìØ
{öŒƒƒ•ŠI„‹ÓPµjeÔ©c):Eéôô¤hÜØ—/ÿ!:…şãÁƒ\ìÜyÃ‡¿©T":Gkäår€JöÂ¥KéˆŒäh‹Ï>kÿ6;vâãÓDçÑK¤¥eÃÖ–TDDDDDDDåÁªˆNDíÚhØ°¦è""­s÷î#Œó3üü<Ñ¿K!¾¾.8r$2™ü¥·ÏœÙOäcÕªh5—i/==)<=ëaêÔ8qb
™ŒaÃ:âöí‡6l\\¦Áß?›6Å"33Gt.\\jÃØØqq)¢SHKH$ŒÙ›6}˜˜kèÑc)RS_=€wéR:ºv]„cÇ®aÃ† õ…‹IİâãÓĞ¬™=$’Š9ÄâêjËThíÚã¨RÅˆ›íÊèÙªJ¢3t^ãÆµĞ£GSïCqq‰è*¥Ù³û¡eËºX‡¬¬'¢sˆˆˆˆˆˆˆˆèŠ‹Kpÿ~lm-D§i5PıÃ¡C¿ÃÛ»±è""­S\\‚áÃ7 zuS÷Öáãã‚ÜÜBœ:uã¥·×¨aŠ¯¾òÁŠ‡‘’ÂEo£Q£š9²3vï„„Ù˜? ŒŒ0sæ.´h1¾¾K°xqÒ…ôè¡Y3{ÄÅİr~Ò^ï¼Ó‘‘ãQ©’>ºuûÑÑ‰ÿº]¡P ,,½z-ƒ­­š€Îù¼Q\¼˜†fÍêˆÎP[\½úär9hŠ‚6l8‰ÁƒÛÁÈÈ@tVÉÏ/â*1yrw¤¥=Ä¯¿B¥¤¯/Åš5ş04ÔÇ°aë9üFDDDDDDD¤AîßÏ\^‚ZµªŠN!""""""Òj úËıûOpåÊèÔ‰Â•Õ¼yû‘U«>…±±¸‹Vk×¶@ãÆµyù•÷ùßÿ: Aƒ˜:õW5–UL––U0`€BCıqåÊ¬[÷?¸¹ÙbãÆSğõ]/¯9Ü‰ãÇ“_¹L<=ëáÌn ¢²«]Û»wF÷înøôÓ5Ş‡’>ÌÅ Ak0{önŒİ[·‡µµ¹è\RƒGòpëÖ4mj':Ee\]m‘Ÿ_ÄÁb²m[rs1hPÑ)ZçÙ*Pi‚ºu«càÀVX¼8EEÅ¢s¨”ÌÍ+ãÇ?C||:æÎİ+:‡ˆˆˆˆˆˆˆˆşrïŞc @Íš """""""*Pı%:úwê¡mÛ¢Sˆˆ´Jtt"~øáæÍ€Æk‰Î¯¯""®@¡P¼ôv}})æÎ}11É8pàÕƒVT6FFğön‚>À…³1ıû·ÄñãÉğóûM›NÇĞ¡ë±}{<)PiK«Võšš…ÌÌÇ*=UL††úX²d æÏ€Õ«¢wïtê´ ×®eà×_Gaüx_H¥Ñ™¤&ññiP(pw·¢2NN600ĞÃåËwD§m»ûñÇàêÕMEçhPi–qãº";û)ÂÂbD§P8;Û`Ñ"?„†Ã=ñ¢sˆˆˆˆˆˆˆˆ@FÆ#H$Ô¨ÁŸ•¨şräHÚ´i ts
‘¶¹ÿ	¾újzôp‡ŸŸ§è €+22¿öBpOÏzè×¯w /¯HuºA*•ÀÍÍãÇûâèÑÉˆ†qã|ğèQ&LG“&SÑ»wÂÂbp÷î#¥Ÿ¿eKèq•ËÀ­ğşû-pşü-äå!4t0<<êŠÎ"5»x1öö–zÅÀ@ÕÄ•+ Ò‡ı7îãóÏ;ˆNÑJyy… Ò ÖÖæ>¼–.ÂıûODçPôíÛşşm0aÂVÜ¼y_t‘ÎËÈxKKê‹N!""""""Òj  ——àøñd¼û®³è""­QR¢À¨QQ¥Š.ü@tÎs..µaoo‰ÈÈ+¯½ßôé½›[ˆåË©©LwÕ©c‰€€øøYX¹òSÔ©c‰… eËYèØq>‚ƒ÷áìÙ”Wn+“Jpq©Ó§o*¡tÑ;âı÷W`×®‹˜0ÁZcàÀïõúÏ+TñÄÇ§UèíSsuµã*z:9¡aÃš¢S´7Pi‘#;ÁÜ¼2-: :…ÊhÖ¬¾pt´Æ°aPTT,:‡ˆˆˆˆˆˆˆH§edä fMsÑDDDDDDDZT îàÑ£<tèĞPt
‘ÖX´(qq©õ‡©©‘èœéÒ¥1""^?èP½º)&LğÅªUÑ¸qƒ¯ª®.&èÙÓ!!#!!ááÃÑ¾}CìØq}ú,‡§g&MÚ†ƒ¯–ëBÍÖ­ëãôin ¢²Û¿ÿ¼½áñã|ìßÿÆóÁ_¢{w7²ÁÁû”2èGÚAW¨\\jãòå;üØìòå;8uê†í(:Ek= ª$:ƒşÁÈÈ _İ[¶œAbâ]Ñ9TzXµjÒÒ"8xŸè""""""""–‘ñ˜TDDDDDDDJÀ* 11×`mmGGkÑ)DDZáäÉX¾üfÏî—Ú¢s^àëë‚ÄÄ»¸}ûákï7dH;4lXS§şª¦2ú§J•ôÑ¾}CõÅùó3päÈdÜ×®e`ğàáì<şşaØ´)YYOÊtìÖ­ëãÚµdg?UQ=U42îÄçŸÿoïÆ8pà+8;Û xö±úİwbşüX½ú(†ß€¼¼"±Á¤rééÙÈÊz‚fÍ*ş •››-rr
Şøu“T+4ô(œmĞ¶­£è­•—Wccn Ò4ıúµ@óæu0}úNÑ)TFÏ¶Æú!,,^CDDDDDDD¤³22q€ŠˆˆˆˆˆˆH	8@…gTï¼Ó‰Dt
‘ÆËÊz‚Q£6¢{w7|úiÑ9/ÕªU}˜›WFTÔë·PééI1wîû8qâ:öí»¤¦:z•FjbäÈÎØ½{4ÎÄ¬Y}  Ó¦í@óæ3Ñ»wV®<\ªau!‘ gÏr½YrrŞ{ï;lß~?ü0!!¿ôüO>ñÂ¶m#{={.å°Iwñbôô¤puµ¢r×‚¾¾—/ß¢³22cïŞxö.¿/-‡g¨8@¥i$	¦OïS§n¾ñù9i^½ÜÑ¯_Œ·™™9¢sˆˆˆˆˆˆˆˆtÒ½{Ü@EDDDDDD¤:?@•—W„óço£C‡F¢Sˆˆ4^I‰_~¹ÆÆ†X¸ĞOtÎ+è¡S''DF¾ùMº0 %fÌØ…§OÕPG¥Q»¶>ùÄë× 11k×~†FjbõêcèĞá[xyÍA`àN?Œââ’on^NN68}ú¦€zÒ&Û·Ç¡[·ï`llˆ¨¨	èÕ«ÙkïßªU=ìßÿôô¤èÖm	bb®©©”ÔíÒ¥44jTS'†1ŒQ¿~\¹ò‡èµfÍ1T«V}ú4¢Õ8@¥¹Z´¨ƒ^½Ü1sæn‹Î¡2úöÛş055Â¤IÛD§é¤ÌÌØØp€Šˆˆˆˆˆˆ¨¼t~€*6öd29Ú¶uBD¤ñ–.ÂéÓ7ñÃƒ`ff$:çµ||\qæL
²³Ÿ¾ñ¾Ó¦õB^^–.=¨†2*+ccCx{7Á‚àÂ…™ØµëKôèácÇ’àç÷=Üİ§côèÍØ»7¹¹ÿ?×ºu}œ>ÍTôr996l¾új>ú¨5vîüöö–¥z¬­­öìƒNœññÇ«£âZáâÅ44kVGt†Ú4iRW¯r€J„œœlŞ‹/¾xz¢s´Z^^!¨4ØÔ©=‘‘ñ?ıtRt
•Q•*•ò¢£±}{œè""""""""’›[ˆ§OamÍ*""""""¢òÒùª˜˜d89ÙÀÚÚLt
‘F;}ú&¾û.
3fô‚››èœ7êÜÙzzRDG'¾ñ¾VVU0i’/V¯>Šë×3ÕPGoKOO
OÏz˜:µbb¾Alì4ŒÛ™™99r#\]§ÁÏï{„…ÅÀÉÉW¯şœœÑÙ¤a.\¸®]!6ö6oŠ  ¾eZ022ÀŠŸ`ÆŒŞ˜9s&L‡L&WQ1©›\^‚Ë—ï Y3{Ñ)jãìlƒÄÄ{¢3tÒÚµÏ†0?şØKp‰v“ËKPXXÌ*fkk¡C;bÉ’Hde=CeÔ²e]Ò;pïŞ#Ñ9DDDDDDDD:ãÁƒg?K³²ª"¸„ˆˆˆˆˆˆHûq€*æŞy§¡è""öğa.FŒØˆNœ1xp;Ñ9¥bbR	mÚ4@dä•Rİßß¿š4©É“·C¡P¨¸”¥NKt@xøpÄÇÏÆ‚ jÕÊX°à7Lš´r¹S¦ü‚„„tÑ©¤JJ‹Aß¾Ëáädƒ£G'ãw•ë˜°aÃçØ·/ıû¯Äƒ¹Jª%‘’“3ğôi¡PÕÂ½{ğçŸoŞÜHÊ“Ÿ_„<Ï>ë ñÛ=5]~¾ P¹r%Á%ô:£Gw¹¹1‚ƒ÷ŠN¡·ğÍ7ïÁÒÒ“'oBDDDDDDD¤3>|ös{KKP•—NPİ¿ÿÉÉ™èĞ¡|ÎUd
…ãÆm…Ë–}‰D":©Ô||\pôh
‹ßx_©T‚¹sßÇÙ³)Ø»7^u¤lÕª™`À „†ú#!!ááÃann„ÈÈ+ğõ]‚V­‚0iÒ6<x•›‚tPVÖ|üq(æÌÙ‹ÀÀ^X·î3XX˜(åØ:9c×®ÑÈÌÌAÏK‘”Ä->Ú.>>ÆÆ†pt¬):Em7® HJÊ\¢[¶l9ƒÜÜ­P×dyyE ÀTÎØØÓ§÷Âöíç{St•‘±±!–,ˆèèDlß':‡ˆˆˆˆˆˆˆH'dg?{ñ¾jÕ”ó{-"""""""]¦ÓTÇ%A__
OÏz¢Sˆˆ4ÖŠ‡qôh~øaªV­,:§L|}]—W„'’Kuww{|ğ'¦Oß‰'O
T\Gªddd€öí¢gOw8;×BDÄ8|ğîÀß?nnÓ1tèzlß‡œœ|Ñ¹¤bQQWĞ±ã|Ü¹ó'öí‹€€Jur²Á_ÁÖÖ={.+õö;ÒL—.¥ÃÅ¥6ôõuçÛ¥š5Íaaa‚¤¤»¢StFqq	BCâ£¼P£†©è­——W€TÚà½÷š¢S''Lú+‡ÚµP«Võàïß³gïáÖB""""""""5ÈÎ~
##ógŸDDDDDDDå¥;W¾DLL2ZµªÇ¬ˆˆ^áÂ…ÛX´(S¦ô@‹¢sÊÌÚÚM›Ú•i!0°'Š‹K°ti”
ËH]Zµª‡K—Òàèhñã}1gÎbêÔ((aÂ„p4i2½{‡`åÊÃHIÉLJTTTŒÀÀ2d-:wvFDÄ8¸¸ÔVÙù,,L°eËp|ğ>ûl-/PÙ¹Hµ.]J‡»»½èµsrª‰ÄDnPS—]».àîİGøüó¢S*„ü|n Ò&AAıšš…õëO¾p[||Š‹KTQi}ıuwèaîÜı¢Sˆˆˆˆˆˆˆˆ*¼ìì§°´¬":ƒˆˆˆˆˆˆ¨BĞÙ*…B'’Ñ¡C#Ñ)DDéñã<¶:4Ä_¼#:ç­ùø¸ 2ò
JJ¥º¿……	&Nì†5k!1‘[8´]›6 “Éqşüíço³³«†O>ñÂúõHH˜U«>E:–X¾üÚµ›‹ç#8xÎMBQºÒ<7oŞGK~!!!$äc˜˜TRùyõõ¥~óçÀ²e1|øÈT~^R™LÄÄ{ps³¢vÎÎµøµOM
V­ŠFŸ>Íáà`%:§BÈËã •6qp°Â°aïbáÂÈÌ| ÈÈxŒO?]ƒîİ¿Ã¾}ñ‚éuLM0cFoüüóiÄÅ¥ŠÎ!"""""""ªĞ²³Ÿ¢Z5ÑDDDDDDD‚ÎP%%e 33íÛ7BD¤q
Æİ¹\eË>†D"ôÖ||\•õ/¦•ú1Ÿ~Ú®®¶˜2åWĞh9›ª°··Ä™37_z»¹yeôìéqõj0víúŞŞMpà@úôY7·é=z3öî~a6‰Ÿ†œœüWŞ¾}{|}—@*•"*jŞ¿¥ëùä/lÜøIÂ€«pÿşµ7ĞÛIJº‡¢¢b¸¹Ù‰NQ;gg$&Ş+õĞ1½½ƒ¯âÚµŒÙItJ…Á*í3fŒ7,,L0gÎ^lØp
íÚÍÅ±c× §'ÅéÓ/îFš£wïfèÔÉ	“'o‡L&CDDDDDDDTaq‘òèì Õ©S×an^®®º÷ÊòDDoz‡ÿï¿ÿTë_ÍÊÉÉuëVGdäåR?F*•`îÜşˆ‹KÅ®]UXGêĞºu½R]„«§'…§g=LÚ'NLÁ‘#“1lXGÜ¾ıÃ†m€‹Ë4øû‡aÓ¦Xdfæ¨¡œ^æêÕ?Ğ³ç2|şùO/yäæâË/7cìØ-8°öî#t³Ë;ï4Â_áñã<øú.FBBº°*½K—ÒabR	õë×¢vNNµ—W„ôôlÑ)ŞÊ•ÑèÒ¥1œœlD§Tÿ?@¥úmƒ¤FF1â];vS¦ü‚¼<Š‹åËKpüx²è<*…  ~HMÍÂ?BDDDDDDDTaegçjıïì‰ˆˆˆˆˆˆ4…Pİ€—W}H¥Ú»U…ˆHâãÓğí·û0yrwxzÖ£ŞŞy¥LiÚÔ~Ø³fíBNNŠÊHZµª‡óço£¨¨¸LkÔ¨&FìŒİ»G#!a6æÏ ##Ìœ¹-ZÌ„¯ï,^Á¡5***Æğá  'O^Ç?y~[BB:ºv]„£G“°aC ‚‚úÂÀ@OTêsuëVÇ=cĞ 5úõ[ˆˆÒs’		épuµÕÉïœm •J˜xWtJ…vúôMÄÅ¥bÔ¨Î¢S*”¼¼"èëK5âs?½Yqq	V®<ŒÀÀxô(ÿ¯¡èÿŒ¾uë!şüó©¸@*+ŒÑ	K—FâáÃ\Ñ9DDDDDDDDRvöSP)‰NP)
œ9“/¯ú¢Sˆˆ4JNN>†Û€ví1|x'Ñ9JãããŠë×3‘’’U¦ÇMÚÅÅ%X²$BEe¤^^PP ÃÅ‹io}KË*0À¡¡ş¸|9ëÖınn¶Ø¸ñ|}—ÀËkwâøñdÈdr%ÖÓ?ÍŸÿRS@./AI‰ß~»çÎ¥",,={.ƒ­­š€Î‹Nı—ªU+ãçŸ‡¢ÿ–X‡ĞĞ£¢“è5îÀÍM7·ÔV®l{{K$&ŞR¡­Xq­ZÕƒ‡G]Ñ)J^^!*W6A¥.]bŞ¼ß “ÉQ\ü²çN
œ=›ªö6*»Q£:£J#,^Ìï™ˆˆˆˆˆˆˆˆTTDDDDDDDÊ£“T‰‰÷ı^^D§i”qã¶"?¿ß}÷Q…Ú¼áéYÕª™”yUÕª•ñÍ7ïaíÚãÜÆ¡Å¬`kk“'¯+åxÆÆ†ğön‚>À…³1ıû·ÄñãÉğóûM›NÇĞ¡ë±}{<)ûö²˜˜k˜3g/

dJé­(ââRzryÉ?Ş*ÁG…bÖ¬İ˜8±¶nkksa¯£¯/Å¼y0sfíÁ„	á¶Ó@2™II÷àæf':E''$%q€JU._¾ƒ#G’¸}JòòŠ`l\It•ÂäÉÛ‘œœ¹üÕ_ôpæÌM5VÑÛ266ÄÄ‰İ°qc,¿~©@NN>ÌÍEgU:9@uêÔ˜™ÃÙÙFt
‘ÆøñÇDD\ÆÊ•Ÿ FSÑ9J¥§'EçÎË<@ ~Ønnv˜<ù””(TPGêĞ¦Mœ:uCéÇ•J%ps³Ãøñ¾8zt2bc§aÜ8<z”‡	Âáæ?¿ïƒ{÷•ê˜!!‡±jU4ºtYÈ‹Pÿ’—W„#6B"ù÷`§\^‚‚Z·®Q£:kÅàg@@„…ÁÎ0hĞää”}ÈTç÷ßï¢¨¨M›êî UãÆµğûïV•%K"áâR:9‹N©pòòŠ¸JK¬]ûš6µƒŞ+ïST$Ç‰Ê~'Õ0À..µ1}ú.Ñ)DDDDDDDDÎ“'¨RÅHtQ… “T±±7àåUzz:ùî½ 1ñ.æÌÙ‹ñã}Ñ®]CÑ9*áãã‚sçR‘•õ¤L“J%X¸Ğ—.¥aË–Ó*ª#UkÓÆqq©ÈÏ/RéyêÔ±D@@„‡G|ü,„„|kk3,\x -ZÌBÇó¼gÏ¦@¡xq /'§àù¶…Û·ÂÇg16mŠUi³6˜6m23ÿgûÔ3ÅÅ%8uê:ÂÃÏ
({;¾¾®Ø»w’“3Ñ·oşøãOÑIô—„„tT©R	uëV"Œ““nİz òÏ—ºèêÕ?u&ø¾0JåÇ*íacS»w†¿[H$’Wş{HL¼‹§OÕ\GoC*• 0°NœHÆÑ£I¢sˆˆˆˆˆˆˆˆ*Œââg/&È*"""""""åĞ¹	"…B3gRàåÕ@t
‘Fxú´_|±-Z8`ôè.¢sTæİwP©’¢£ËüXgg|öY{Ì™³äª T­];GÈdrœ;wKmç´°0AÏî	ù		AöíbÇóèÓg9<=ƒ0iÒ6<xEEÅ €#GŸVÉå%Éä˜<y;ÃãÇyjk×$G&!<ü,Š‹_ú|ıõv\¿©¶®òjÜ¸öï©TŠ=–"!!]tHH¸WW[­Øf¦*ÎÎ6ËK´êß“¶X²$MšÔB—.E§TH Ò.††ú˜3§–-ûzĞ×ñÇSr¹.ÜPGo£M›èÚÕsçî{éQÙåå={!şì“ˆˆˆˆˆˆHtn€*)é²³Ÿ¢–‚n    IDATMPÀ¤IÛğøqV®ü´Boæ366D»vˆˆ¸üVŸ4©ÌÌŒ0{ön%—‘:ÔªUuëVÇÉ“×…œ¿R%}´oßAA}qîÜt80|ànÃß?®®6l=~şù4¤Òÿ;T(ˆNÂ;ïÌG\\ª~Q²³ŸbÔ¨xÓ¢…BÂÂbŒ³Y=aJR³¦9vîü..µÑ¯ß
<xUt’ÎKHH‡››è¡¬`llˆÄÄ{¢S*”k×2yãÇsû”ªäåÁØ˜h›şı[bÿş±°¶6ƒ¾¾Ş¿n34ÔÃ™3)‚Êèm|ıuwüşû]ìßŸ :…ˆˆˆˆˆˆˆ¨BÈÍı{€Š¨ˆˆˆˆˆˆˆ”¡â^)ÿ
§Nİ€™™œmD§	·aÃ)ìŞ}+V|kk3Ñ9*çãã‚cÇ®!/¯¨Ì566Ä¬Y}ğË/çpâD²
êHÕÚµs6@õO‰M›ÚaâÄn8th"Î¯¿îìì<œ=›Šâbù).–ãáÃ'èÛw9/@I‰n¼ªÿ¤IÛ“SøÊ÷W*•@*•B"‘ÀÅ¥6>úÈKÍ…åW¥J%¬[€<ğÙgkñã1¢“t–L&GRÒ= ÒÓ“¢aCk$&ŞR¡,ZgçZèÚµ‰è”
+?Ÿ¨´U“&µ=ï¾ëô¯€2™'Oòy·6qr²AÏî˜7oÿ¶‡Qiäæ xöû$"""""""*? Š½‰Ö­Tè-+DD¥‘”t3gîÂ˜1ŞèĞ¡‘èµèÚÕEEÅ8~üí.ÄôõuE×®.˜<ù+¹T­mÛ¸t)OˆNù[[Ò£GwFa¡ì•÷“Ë()Q`É’(ôï¿™™ÕX©~¿ür\~a L__
‰00¢uëú˜9³7ÎŸŸ¨¨	øäí ½Oß~Û3fôÆŒ»0iÒ6^t,ÀÕ«@&“£iSİ ] ÏTÊsíZHÀ¸q>Ü>¥B2ˆÎ ·djj„Ÿ~ú¾ùæ=H$H¥(ÀÅ‹iÉ^.'Í5iR7¤¥=Ä®]D§i½¿7Pq€ŠˆˆˆˆˆˆH9tjŠH¡Pàôé›ğòª/:…ˆH¨¼¼"ºîîöøê+Ñ9jceUÍšÕADÄå·>Fpp?Ü¿Ÿƒ•++±ŒÔ¡MGÈå
œ9“":å¥¢¢®ÂÀ@ÿ÷S(8w.;ÎGtt¢ÊÔïŞ½Gøæ›_ÿ¿¾ş³§¬•1`€'Ö­û’’¾Å/¿ŒD@@Ô¬i.*U©: 4Ô¿ürşşkÿRŒÔ#!áLMàà`%:E8gçZøıwn R–%K"áèhÑ)¨´ŸD"ÁÈ‘±aC Œ+A*• ¨H„„tÑiTuëVGÿşX¸ğ ‡ßˆˆˆˆˆˆˆˆÊééSP)Ó›¯Ò­@’’2ımÚ4BD$Ô×_oGvöS„‡>˜ +|}]°jÕÈå%oµ°vmŒçƒùóC¯^ÍĞ AT’*XYUA£F5qêÔutéÒX9={¸}[)‡úí—sÉJ·Ù¬¸¸99ùøôÓÕŞ©6¦ô¬iZj2)4ñù/„Ô0F÷¦Õàãj‰¦öU½Ÿ}Z8<&•]»¦¦¯¼Ë{ï5EÍšæ<øG°7~+«*jŒÔ]		épuµ…´"ıczKÛàáÃ\de=Aõê¯şx¥7KNÎÀşı—êÏ-+(ÁØX3¨är9öíÛ‡¢¢"Ñ)ZkÜ¸ÆKÂ½{yX³fRRj‹NÒyR©]»v…ékÇümÜ8ìØqáágµvC(‘&øûÅö*Wæ ‘2èÔ Ulì˜™¡qãZ¢Sˆˆ„Ù²å4~ıõ<~úéfkKYøø¸"8xÎŸ¿OÏzouŒÏ?;wÇäÉÛğË/#!‘ğ‚hmÑ¶­#Nœ¸®¼öêdf–û0ÉúÕp·ú è)Ğ“”@	 Š_³,T¡xößŸİÆç[fÂZş´Üš¢Is¼‹x¤Àî^pIt‘­^|şùkïÒ¢…öîƒ>
E¯^Ë°eË0Ô©c©¦@İuéR::th(:C#8;?û~))é¨ÊiÉ’(8:Z£[77Ñ)&m :yò$úôé#:CëI$ú05m‡õë÷#4T‰Ïßè­­^½Ÿ¿áy ØÚZ`à@O,[v~~00ĞSCQÅ“›[€J•ôùó"""""""%Ñ±ª›hÕªş[m!"ª®]ËÀ´i;1bD'x{7#Dƒ5P¿~DF^yë*}}),ø =z,Å®]Ñ·os%W’ª´mÛ ëÖGvöST«fRş«VÃ‡—ë05s
0ö‡#  CT®l}˜›ÃĞP•+¢råJ04Ôƒ™™1*UÒ‡±±LLŒşÚ"·¼üï‹*:@U¬¬}Ì”‚ƒƒöï‹AƒÂĞ«×2lÚô\]mU¨»
‹‘œœQ£:‹NÑ––UP½º)ï¡}{•½­ë×3±o_<¾ÿ~·O©A~~‘ÆPÿõ¹>++VVV‚kˆ”ÃÊÊêùÇvi|ùelÙr¿ü‡?l­Â2"""""""¢Š+/¯ˆÛ§ˆˆˆˆˆˆˆ”H§¨ââRğÅEg	QXXŒ#6ÂÙÙ“&u#”~û-½Şúîîöøøc/Ìœ¹:9ÁÜ¼²IUÚ´i ‰D‚ØØxï½¦¢s333Òù—ô"„‡Ç_ü„~ıV`õêÁx÷]'ÑYÒï¿ß…L&‡›‡Ôşæì\‰‰wEghµÅ‹#àèh­Q_o*2MÚ@ED@íÚ0À!!‡0`€ç_CÿDDDDDDDDT2™††Ü>EDDDDDD¤,:sõÂ­[pÿşxxÔBD$Ä×_oÇİ»ğı÷ƒ`` Û?dõñqÁ­[pızf¹3ujOH¥R|ûí~%•‘ª™™ÃÅ¥6Nº!:…¨T*W6ÄºuÿƒÃŞ½ñ¢“*¤+WîÀÔÔÜó7gg$&Ş¡µÒ±wï%LÜÛ§Ô„TDšgìØ®¸{÷vì8/:…ˆˆˆˆˆˆˆH+ÉdrèééÌ¥]DDDDDDD*§3ßeŸ;w††úps³BD¤v»w_Ä¶mqøî»°³«&:G¸-P£†)"#¯”ë8ffFì‰M›bqî\ª’êHÕÚ¶uÄ‰×Eg•š–/ÿşşm1bÄF„‡ŸTá\¾|..µ!‘pĞåoNN6HNÎ€\^":E+Í»îîvğñq¢3òóe066ADÿ`kk~ıZ`éÒ(óë	QYÉå%:ÿâ¨DDDDDDDÊ¤CT©puµE¥Jú¢SˆˆÔ*55'†ã‹/Ş¯¯«è •JĞ¹sDF^.÷±úõk¶m1yòvÈdr%Ô‘ªµmëˆë×3‘™ùXt
Q©I$Ìİ_İãÆmÅš5ÇD'U(W¯ş&Mj‹ÎĞ(ÕDAééÙ¢S´NlìMÄÄ\Ã7ßôàPq‘f3Æwîdc÷î¢Sˆˆˆˆˆˆˆˆ´7P)—Î|—w¢3ˆˆÔª°°C‡®GƒÖ˜2¥‡èâëë‚‹Ó™™SîcÍŸ? ))Y‹QB©ZëÖõ`` ‡S§nŠN)•7n¼Õø¥y\ZZ†òÖçP–—ÿï¶ÒÜW$	nÜ¸¡öóş×È‘1ujÌœ¹‹GŠÎ©äò$%ep€ê?4°şëãş¾è­3wî^¼û®Úµs¢3JJÉä:7@ÅçoOY_×Eÿù”–Èç1VèÓ§9–,‰âVC"""""""¢2â*"""""""åÒ‰ª'O
œœ-D§©U`à¤¥eã‡ñ«ÿÑ¾}CààÁ«å>–ƒƒ¾ü²-Š@ZÚC%Ô‘*Âİİ'O^¢6)))°²²záí»víBŸ>}½Ùßmÿm¯Zµ*&O,°L¼#:!8ø}|÷]$,8 :Gëİ¸qùùEpuµ¢QªT©kk3\¿):E«ìß	.¤áë¯ß¢S
eP(:7@¥Úü´Ç¸q>HOˆ}û.‰N!"""""""Ò*ÅÅÜ@EDDDDDD¤L:ñ]ö…·!—— eËº¢SˆˆÔfïŞxlŞ|K–„½½¥ècdd€!2ò²R÷å—]`kk)S~UÊñHµÚ·oˆãÇ“Eg¨MII	>|q¸/**
]»vPôf·ı·İÊÊ
óæÍX¦n‹Å‹"$ä -Š£Õ®\¹=8:Z‹NÑ8XãæMn *-¹¼F W/wä©Y~¾ 8@õ´ù9i+ôìéï¾‹BI‰Bt‘Ö(.æ*"""""""eÒ‰ªsçRQ§%¬­ÍD§©Å­[0qb8n‡îİİDçh,?~¹¹…å>–æÍ€#G’¡œ¡,Röí"==©©Yj;gqq1fÌ˜{{{T¯^ƒÂ£GßşèÑ#<VVV°µµÅ„	PPPğüöÍ›7£~ıú¨^½:†¼¼< À;àêê
cccØÛÛ#$$ä…s·nİ P³fÍço{ğàLLL`llü¯û*
L˜0îîîxğà @&“aÊ”)°µµ………F‰ÂÂBÜ¸q‰ÑÑÑ¨S§Nœ8‰D‚_ıÍš5ƒ¹¹9fÏıüØ¯:Îı³í¿íŸóo‰ë×¯‡‹‹¬¬¬ŒM›6¡^½z033Ã´iÓŞxş—½/'''˜››cÖ¬Y/½:ùùybñâXº4
ß}%:Gk]½ú5ªÉ_@¾„£cn *ƒmÛÎ"%å>Æ÷¢s

Pkç Ÿ#¼İs Ø¹s'\\\`dd„zõêaãÆ¥ú3^ıuıU-%%%X¾|9œQ¥J´nİ§NzşgT©R8tè$ÉÏ]şûÿoú3,ëã^Eôó˜±c»âÆLüö[‚ÚÏMDDDDDDD¤­Š‹åĞ××‰K»ˆˆˆˆˆˆˆÔB'¾Ë>wî·O‘Î(**ÆĞ¡ëQ»v5ö£Ñºvm‚’’;–¤”ãyyÕÇûï·À´i;ğôiù‡²HuZ´p€™™½¦¶s.]º;vìÀo¿ı†èèh\»vÁÁÁÏo5jîÜ¹ƒ³gÏâÀˆŒŒÄüùóŸß¾víZDDD`ÿşı8|ø0‚‚‚““???xzzâÆøöÛo1fÌdggÿëÜ§OŸ ddd<ÛŞ½{Ñ³ç¿?G(
L<‡ÆáÃ‡aee X´h’““‹˜˜ÄÆÆbêÔ©Ï·páB,X° îîî €ğğp9r‹/ÆŒ3o¶xÓq^Öö²öÿÚ½{7bcc1ş|L›6Û·oÇ¥K—°hÑ"—úüÿ}?^ÖuîÜ9¬[·3gÎ|~ñ¸H~~X´È‹G`Ù²ƒ¢s´Ò•+wáâÂmA/Ó ¨J«°°K–Dá£Z£Aƒ¢stÎßTÚºŠÏŞî9Bnn.üüü0jÔ(ÜºuÓ¦MÃgŸ}†§OŸ¾ñÏôïc½ìëú«ZV¬X9sæ`îÜ¹¸~ı:¦OŸ)S¦<ÿ;˜:u*‚‚‚pıúuÌš5Ÿ}öÙÿîËò¾—÷q¢ŸÇ8:Z£G¦X¼8‚[¨ˆˆˆˆˆˆˆˆJI&+¾>_ ˆˆˆˆˆˆHY*ü UI‰/ŞF‹¢SˆˆÔbÖ¬=HIÉÂêÕşZ{©ºXX˜ EDF^QÚ1gÍêƒ‚-ŠPÚ1Iùôõ¥ğòj€cÇÔ7@†   ¸¸¸ÀÕÕ?ıôÚ´iàÙ­[·bÙ²e¨W¯\]]1{öllÚ´éùã—.]
GGGxzzbÎœ9‡‘‘._¾ŒÔªUuë>ÿïÅÑ/³oß>¼÷Ş{ÿzÛ×_…bëÖ­°´´|şöuëÖaÅŠ°³³ƒ««+æÏŸƒÿXgÁ‚ğóóC•*U  #FŒ@ÕªUáïï øóÏ?Kuœ×µ½ÎØ±cajjŠAƒ ÆSSS2¤Lçÿïûñ_&L@•*ÿÇŞ}G5yöo ¿’°”!2¨,­uÕ­u¶î­{[WU_­«u:ë¬ûgµ¶
ZµZ÷h•é EeŠÊRfÆï^|Û
*äNàúœÃ9-Iûb%x_Ï·ºté oM²¥wïO°lY/,[vk×ş&:Ş	‹·wEÑ1t’››=’“ÓñâÅ+ÑQtŞöíñâÅ+L˜ĞVt”RIßT<G(Ú9‚B¡€T*ENNÎ›×ı¤¤$˜šš¾ósš§ ×õ‚²lØ°Ë–-C×®]áàà€:`ñâÅo¾¿­}ûöo¶
ò¡{q§ç1“&ùàÁƒµşşEDDDDDDDT’)•JN """""""R#Ñ4íŞ½8¤¦f¢~ıJ¢£iÜéÓ¡Ø±ã"Ö®í‡ªU9ıàCøøÔÄš5§!—«çÏVVæ˜1ã3LŸ~İ»×ã¦|Ö¢…;-:œ5å¶ÇÃÍÍíÍÿ{xxÀÃÃ  …BªU«¾¹İÍÍÑÑÑoş¿ZµjoşÛİİqqq022ÂãÇ1vìX¼zõ
^^^”åÕ«WËå°²²úÇûoÜ¸–-[bñâÅØ±cÇ›÷?}úÿ¸oÙ²eÿ‘çï ††ÿÜÈş¾ã¼+Û»ü{½¢®ÿï£ u¤Rİû‡ª¾}B¥RaÚ´CJ%3¦µèHz!&&	/_¾æsuªU³ <x ›ü‹…¤¦f`İºßğÅÍààPNtœR)##·@ejj$8IÑğ¡hçeË–ÅÅ‹±zõjÌŸ?uëÖÅŒ3Ğ²eËw~Nÿåß¯ëeÉÎÎ~kJe­Zµ  ‘‘‘Şöo*Õ?§/}ÈÇ^œÇåÑ…ó˜êÕ+ }ûZX¹2¾¾ŞH$Â²é•JÅ¿¡©‘îíşT³7¢`nnŒ5Şg""=“„	ö¢ÿFèÖ­®è8zÃ××ÉÉé¸~ı¡ÚÙ·oCÔ©ãŠiÓB¡Pªí¸¤^-[ÖÀ«WY¸u+J+ë9::"*êkİ¾}ûÍd{{{Èd2<|ø¿ïÃÈÈHT¬ø¿RÇƒŞü÷ıû÷áêêŠ¬¬,tíÚ'NÄ•+W°~ıúÊ __ß·ŞÿË/¿`Ó¦MØ¿?Î;÷ì<€J¥‚J¥BRR®^½úæöo‚.hcîûó®lêPØãßtı¨úõk„ùó»à›o~Á†gEÇÑ!!1H$ğğpE'U¨P&ˆˆx&:ŠN[¹ò”JÆeqQ}Ÿ@Ås„¢#ddd ##»wïFBB„víÚ!99ùŸÓ<½®”¥råÊ¸sçÎ?î’;IÉÉÉ©ÀÛòÈår @LLL¡>ö¢>îßtå<fâÄ¶ÅÙ³á¢£Q)“ïÎ•]ÔV¯İº…:u\9Òš´êßW†&Ò´œFÜ…
ÊbŞ¼Î¢ãè•J•lQ½z†¼ÿÎH"‘`Ù²^Á=WÔv\R¯J•láêjƒîke½`Ö¬YFhh(Æûfc¯¡¡!üüü0~üx<zô!!!˜={6ú÷ïÿæñ“'OFDDnÜ¸™3gbÀ€xıú5222```€ŒŒÌ; –––o†¼÷;v;¿ı\aff†êÕ«cúôé9r$233 }ûöÅ´iÓğğáC„††â³Ï>Ãš5k
ı9øã”­ IİëçÙºu+RRRŠ½¦¶Úóæå–¨¶o¿(:Î	‰««,,LDGÑYU«Ú!""AtõÛ·_ÄW_u@¹rf¢ã”Z™™Ù ô·@Ås„¢Ÿ#´mÛöMêùóçJ¥022zçç´¨YÆ‹©S§âØ±cˆG@@ æÌ™ 6lØ[·MŸ>Àÿ¦BíÚµ©©©o}\­WÔÇº}ãåUŸ~êuëÎˆBDDDDDDDDDDDDDDD¥Lª’3úÆG¨_¿²èTŠH¥(•,P‘v-ZôÂÃc±i“?LMDÇÑ;¾¾ŞVë1kÔ¨€áÃ[bÑ¢_ ››	hÑ¢~ÿı®VÖš1cÚµk___4iÒ...X¶lÙ›Û×­[GGGÔ¯_ÿÍıfÌ˜ñæöaÃ†Á××:t@ûöí1eÊX[[cÑ¢Eèİ»7¼¼¼PµjUôéÓç­É•*UBÃ†áàà€œœ¼|ùOÜÉÛğ»dÉ À¬Y³àââ‚Æ£iÓ¦pssûGöõ¾ãä—íïÙ‹«0Ç°aÃ˜˜Xì5E>¼æÌé„Ù³`çÎK¢ãè´ĞĞÔ¬é$:†Nss³ãªw˜;÷(*U²E¿~DG)Õò&PNR4<G(Ú9‚©©)¶mÛ†¯¿ş•+WÆÆqàÀ˜™™½÷sZ”,#FŒÀœ9s0}útT­ZsæÌÁîİ» “&MÂ”)S0uêTT­Z_ıõ›ÏQùòå1wî\|ùå—¨_¿>†úAëõq€îŸÇŒ××®=Të`"""""""""""""""¢÷‘¨ò•3eÊDG'aÿş‘"2©MRÒkx{ÏÁ®]CÑºµ§è8TJÌ}!!18ztœè(TJœ9†·bÕª>èÙ³¾è8zé¯¿à³ÏVâÌ™©ğğ(xÃhaedd£U«eøøcWlØ0@mÇ%õ9y2Ã†mÇ;ÿM™ÂÀÖX° 5Jıá¨äÑò÷ËÊ•§°|y –/ï?¿ZYSß4hğôïßãÇ·Eg­Yóöî½Š«Wg‹¢s.^|€^½6`ïŞhÙÒ]tœRíğá›˜<y??şNt ÀÙ³gÑºuk$&&ÂÖÖVt$""ÕªU+1ªmmm±`ÁŒRÓyLçÎkP¶¬)ví¦–ã•TÓ§ÂÃ‡‰8xp´è(Åæå5Ó¦µ‡¿ÑQôFIúúSñ””ŸŸ¼[		YkksÑqˆˆˆˆˆ¨ùÀß7®0
(	¨îÜy
•J…>r…J™L
…B):•qqÉ˜0a/zõªÏòT1Ô®í‡rQëqMM°hQ=ú'Îœ	Së±I=š6­™LŠK—ˆB¤v_~ÙãÆµÁÔ©pút¨è8:'%%11Éğö®(:ŠNss³CtôKddd‹¢S
%æÎı	mÛz±<¥²²r`jj(:ÂØ±­ñÛoa	‰…ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆJ‰
T*H¥úß ºsç)œœ¬`k[„‰DE$“I T²@Eš'—+1rä.”+g†º‰£×$	Ú´ñD` zT ğé§îøì³0gÎOÈÊ’«ıøT<&¨]ÛçÏß…H#¾úªl‚#vâÚµ‡¢ãè”àà¨T*xy±@õ.ÕªÙC©TááÃDÑQtÊ=Wñ_İIt-‡‘‘èDTmÚxÂÛ»"6l8+:
•¨$%`Õ;O9}Š´N*•B¡P‰A¥ÀÒ¥'ô›7B™2Æ¢ãè=oG#66YíÇ^¸°^¾|…5kN«ıØT|-ZÔÀï¿ßƒHcæÏï‚6m<áï¿¡¡œò'44¶¶e`oo):ŠN«TÉ††2DD<Eg¤¥ebÅŠ@ÜU«Ú‰C ²²,P‘ÎqssƒJÅ¿D"‘`Ô¨V8~ü6=bI—ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆ4ï*mGQ¿;w¢V-'Ñ1¨”‘É¤P(8Š4ëÜ¹»øşû³X¼¸<=EÇ)š6­ss#œ:ªöcÛÛ[bÊ”öX·îîßWûñ©xZ´pG\\2¿6TbÉdR¬_? µk»¢ÿ-xúô¥èH:!445kòw…÷14”ÁÅÅ	¢£èŒ•+‘“£À„	mEG¡ÿâ*"ıÔ©Sm8;[cãÆßEG!""""""""""""""¢R €ô~Ubbââ’ñÑGÎ¢£P)#“I¡T²@Eš“˜˜†/¿Ü‹Ï?¯Ş½?§Ä022@Ë–îÖÈñ¿ø¢jÕrÆäÉû¡TòJôº¤vmg”+g†óçï‰B¤1††2lÙ2åË—Ÿß÷HLLI¸xyUC/¸¹ÙáÁN €¨¨çØ¶íLÚVVæ¢ãĞegËalÌ‘¾‘É¤9òS8p		)¢ã…ß-    IDATQ	÷	Tú] º}û	$	¯*OZ'“I P°Aš¡Tª0fÌ˜™ãÛo{‰Sâøøxãòå¤¦f¨ıØR©Ë–õDPP4öì¹¢öãSÑÉdR4mZ.°@E%›……	öí	©T‚·àõë,Ñ‘„ÉÊ’#2ò¼½Y úÕªÙsÕÍ}Uª”Ç€EG¡¿ÉÊâ*"}Õ»wXY™cË–¢£Q	—oJ©ÔÿUPĞS¸ºÚğªà¤u2™r¹Bt*¡–/À±yó XX˜ˆSâ´më øı÷»9¾‡‡#†o‰o¾9øx^a]—´hQ—/G";[.:
‘FÙØ”Á=Ã—ŒÁƒ·•ÚïùğğXää(àíÍ‹-|ˆªUíù
Eé²züømœ;wv‡A¾¿J“ ÙÙ,Pé+##Ú»v]BJJºè8DDDDDDDDDDDDDDDT‚½c•¶£¨WPP4jÕrƒJ!##de•ÎÍÈ¤Y—/G`Íšß0~WNÌĞKKS4hP![còdØØ”ÁìÙG4¶^‹îÈÈÈÆõëEG!Ò¸J•l±oßHEcÂ„½P*KßäÌĞĞ˜™¡R%[ÑQô‚››=²²äˆNE˜W¯²0wîQøù5@“&n¢ãĞ¿ä¨d¢cQØR©;w^…ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆJ°
T€Tªßª  §øè#¨HûLM‘••#:•0ÏŸ¿Â˜1»Ñ¡C-ØXtœÍÇ§&ÎCNf&É™˜â»ïüpòd0‚5²““ªVµÃùó÷÷@`ôh@"Ñê[”¡–[4Â¦2uµ¾ö¿ß~3©‚—2³¾¿\"Ã^óšPH¤EZo‘eSl-SYRCá{¡ß^¼ÈıÑØºu0NÆÜ¹GEÇÑºĞĞxzVÔûßy´¥Z5; @DD‚à$â,[v™™9˜5ësÑQ(ÙÙ
š@eğßçúòåËC"‘ğ­o††¶Â3ğíŸo/^¼xó½­n&èß¿¶o¿¨±ßÃˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆòİù Tª ‘èïfÂ¸¸d$$¤²@EB˜˜"3“*R¥R…±c÷ÀÔÔß~ë':N‰çë[sçÅ•+hŞ¼†FÖhÜØ=zÔÃŒ‡Ñ¸±,-M5²NË–î8w.¼p›ãşxüXs¡şæÅ«üü×s¹™ˆ[Q¯`giˆ/š;m§keıü$½ÎÁ°¯oba*è×ÈşÍû{­Eƒ*–˜Òşís±¨„Ì\vÉ†`tëÂOÓSşü‹ÿˆÇz“¶×¶"ú7¶‡‘A¾×Ğ=R)Ğ®èo4mZk×öÃ¨Q»àâbaÃZˆ¤5ÁÁ1¨UËIt½aii
{{KDD<CëÖ¢ãh]xx,vì¸ˆ¥K{ÂÆ¦Œè8”Ü	TºS jÒ¤	=ŠììlÑQôRXX¶n½‹/¾¨ookÑqè¿¤R)Úiğ<fèĞæØ²å<¿nİêjl"""""""""""""""*½
Øa¤ßªÛ·ŸB"‘ÀÛ››"IûŒY "õZ½ú4®\‰À‘#ã`ii":N‰çäd†h¬@ óæuF‹K°dÉ¯X´¨‡ÆÖ¡×ª•¶m»€˜˜$T¬hõajĞ ÷MC²²ä¸pá¾‰€€`ÈdR´më…ñóë¡eKwÊ4¶ö‡8¸éwš¡ó†eŒß¼?}g^»Vzv~ë1n ¦à–}€VıàîîP¨5g÷F½x…ÇÂm°ê|"FŒh‰¡C[ÀØXw6Ïë‹kãÉ“˜?ÿ\\làãã-:’Æ)•*Ü½‡>}>E¯¸¹Ù!"â™èZ§Tª0mÚAÔ©S	½{ó{FWegËuê5@&“¡sç·_éınß~‚™37 sç:˜7¯Ÿ^ÿmŠ
§B…²hß¾&6o>ÏiD¾—ëW© }Ş£ôU«–gÑ€„011„\®„\®…J€«W#±bE æÎíŒºu]EÇ)5|}kâäÉ`¨T*­aee¹s;c×®Ë¸qã‘ÆÖ¡×¤‰ÌÍqîÜ]¡9”J®_ˆiÓ¢V­9øâ‹œœï¾óCpğlÚä¶m½„—§ `ß¾kèŞ½Êü­<äN(P(
~=ºj×vÁøñ?"'GQèumlÊ`Ö¬ÏqãÆ×ğóûË—¢I“o°uëdeÉ}¼ÒnÌ˜Öèß¿ÆİƒĞĞÑq4îáÃD¼~oïÂO@+ÍÜÜìñàA‚èZ·sç%Ü¹ó‹ug‘C‡eeéÖ**š¨¨çğ÷ßŠ†«`Õª¾ü™+…†m  §üıˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆ4¢€•
R©şnT¹sç)>úÈEt*¥LL YYœBEÅóâÅ+Œ½­Zy`ğà¦¢ã”*>>ŞˆOAHˆf‹İ»×CëÖ˜<y?²³YúÍÈÈ »áÌ™0!ëGF>ÃÂ…ÇQ·î|té²¡¡1˜6­=şúk>…=ëÃÜÜøıÒ’K—"pÿ~<úõkôÖm2™
EÁD©T‚åËıñë×Ÿ)r†¼"Õõë_£k×ºX´è—7E*şLÎ‚İP§+ú÷ß‚¸¸dÑq4*44RÔ¨Q¸ég¥]µjöˆˆ(]ªÄÄ4,]z#F|
OOGÑqè²³Y ÒwÏŸ¿B¿~›Q±¢6nô‡A¾®¢®^½ÊøøclİzAt"""""""""""""""*òİ‘¢Tª èo*885k:‰A¥”±qn*3“**:•J…I“öC*•`Õª>¼úº–y{W„£c9†h|­o¾é¸¸¬_VãkÑûµní‰?ş¸¯µòMFF6¼®]×¢yó%8zôOôíû	.^œ‰_ıC†4‡­m­d)¬İ»/£n]×|§øÈdR¨TïÄXµª¦Më€•+O!(èi±²ØÚæ©.]š‰öíká›o£I“E,R‚¡¡[·†••üı·"==[t$		‰Aµjö06fÙ¢0ªT)—/_#99]t­™;÷(,,L0qb[ÑQè=²³åü™Öcii™èÛw#T*ví¦S…qÒ¾/¾h†€€`$$¤ŠBDDDDDDDDDDDDDDD%L¨ôu¯~BB
^¼x/¯·7óiCŞ*¨¨8Ö¯?‹sçÂ±qã@XY™‹SêH$øøx#  Xãk99YaÒ$¬^}”®Éº¨MOddäàêÕH®ôsæü„ºuçcêÔ°´4ÅÆqõêLÚUª”×èúÅõòåk£ÿÆùŞ.•¾{UáÃ[ nİJ˜4i?rrÅÎåàPtÅ¥K³àë[ß|sM›.Â=W —¿»ĞE€……	vì‚øøŒ¹
EÉüœ…„DÃÛ›[(¬J•l QQÏ'Ñ3gÂpôèŸX´¨;Ëz +‹¨ôUNÃ†í@bb¥³ÅqÒkÃÒÒû÷_…ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆJ˜
T¹_õQXX ÀÃÃAp*­LMY ¢âùóÏÇøöÛ“˜9³#êÕ«,:N©åãã°°X<yòBãkŞîîøê«CP©Ş_:!Íqt,w÷
8s&\íÇNMÍÀ=WĞ®İwğõ]óçïbÌ˜V¸ukvîŠkÃÀ ßS3³wïU˜˜¢S§ÚùŞ.•J?¨|“7eïñãX³æ´Úò9:æ©.^œ	Ÿš˜=ûš4ù†EªàâbƒmÛ¾ÀÜÇ¢E¿ˆ£aa±¼ØB89YÃĞP†Ç5ÿº(Zjj&¾úêºu«‹¶m½DÇ¡-‡¡¡Lt*$¥R…qãöà¯¿c÷îápv¶‰t€‘‘zö¬‡={®”Ø27‰‘ï.]¥R‰ 
…½}YX[sb‰aff xı:KpÒG))é5jš7¯#ZˆSª5jäKKSœ>ªñµd2)V¬è[·¢°wïU¯GïÖª•§Ú¾îJ¥
×¯?Ä´iññÇóğõ×?¡råò8p`ÎŸŸ1cZëİ¤•J…½{¯¢W¯ú055Ê÷>2™äƒ7¼º¸Ø`ÆŒÏ°fÍoVgTT¬hõß‰T3Ñ®7‹T¨~ıÊX½º6nü;w^G­âãS˜˜oo¨
ËÀ@ŠŠ­ğèQ¢è(7wîOÈÊ’cşü.¢£ĞÊÉQÀØ˜¨ôÍüùÇpòd0¶lÄçeú‡› 66çÎİ…ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆJ&Péoêîİ8xzrú‰S¦Œ	 àÕ+¨¨pT*&NÜ¹\‰Õ«ûéíópIah(Ã§Ÿº#00D+ëyz:bÈfX°àgÄÇ§heMÊ_ëÖˆŠz^¬’@jj&öì¹‚O?]Š.]Ö"((óçwApğlÚäfÍªëíÏøùó÷õıú5*ğ>2™Jå‡OS4¨)4¨Œqã~ÔÈÇ¼"ÕÅ‹3Ñ¢EÌœyM›.b‘ê:uªI“|0gÎ\¸pOtµ		‰D"——£è(zÉÕÕ¦ÄO ºpá¼¥K{ÂÆF¿
®¥YV–FF,Pé“µkÃ¶m°n]4o^CtÒ1•*Ù¢I“jØ½û²è(DDDDDDDDDDDDDDDT‚ä[  =İÓ‹°°XxxpC$‰ca‘W Êœ„ôÍæÍçqæL¾ÿ~ §èé_ßš¸z5II¯µ²Ş”)íQ®œ9æÎ=ª•õ(õëWF¹rf8s&¼ĞÆäÉP»ö×X¸ğg4o^çÏOG@À$ôïßææÆH¬]»w_FÃ†UQ£F…ï#•®@%•J°fM?$$¤bñâ_Õ3_NNVX¶¬.]š…æÍ«cæÌÃhÖ,·Hõ¡³J“I“Ú¡sç:>|"#Ÿ‰£!!Ñpr²BÙ²f¢£è¥Ê•mõ\tIMÍÄ¤IûÑ¥ËÇèĞ¡–è8TÙÙ,Pé“#GnaÉ’˜;·3:v¬-:é¨şıâÜ¹p<{–&:
•%j•\®DDÄ3¸»s‰cll CC'PQ¡Ü¾ı‹ı‚iÓ: Aƒ*¢ãĞµjå‰D‚³g_¤)
33#,YÒÇßF@@°VÖ¤·ÉdR4o^gÎ„}Ğısr8~ü6üü¾‡Ïr\¿ş3g~[·æaÁ‚®¨VÍ^Ã‰µ'!!¿ı†¿ó~R©¤Ğ…$‡rX° +¶n½€sçî'æ{9;[cÙ²^¸xq&š5Ë-Rµjµ‡İ`‘êo$	–/÷Cµjö<xRSõ¿oïŠ¢cè-W×’] š7ï(²²ä˜?¿«è(THÙÙr³@¥Îœ	ÃÄ‰{1n\kÖBtÒa>>5affŒ£Gÿ…ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆJˆ|T
…R©ş¨"#Ÿ!;[OON "±Ê”1AZšşo2&íHMÍÀÈ‘»ğÉ'U0zt+Ñqèo,,LĞ¸±C´¶fË–îèÙ³>fÌ8Œ””t­­KÿÔºµ®\‰|g6!!ë×ŸAÃ†1jÔ.˜˜âÀQ¸pa:†m^"¦MıÛ?^A™2&ïÌ"“I¡T¾ˆÔ£G=tìø&OŞädÍÿ»¸Ø¼)R}òILš´­[Ë"Õß`Û¶!xõ*#GîÔûÏKHH4¼¼X *ªÊ•mñìYÒÓ³EGQ»?ş¸®cÉ’°µ-#:RV'PéƒÛ·Ÿ`äÈ]èÜ¹¾úªƒè8¤ãŒğùçáğá¢£Q	‘oJ©TA&Ë÷&)ÜÜìDG¡RÎÂÂ¯_s}˜I“ö###ëÖĞËòjIçãSçÎİEV–\kkÎŸßJ¥
ş¢µ5éŸZµò€\®À¥KŞº-(è)Æÿü›7ŸG·nuqíÚìÜ9ÍšU×Ë)B©Taÿşkèİ»Á{§|Èd(ª"­³tiOH$Ì}¤H/Š¼"ÕÙ³ÓP«–&MÚ6mr‹TJeÑ>’ÄÎÎ[¶ÆåËX±"Ptœ"KKËÄ“'/9ª\]m¡R©ğøñÑQÔ*--“&íGçÎã³Ï>‡Š ;›*]õnAÃ†U°reŸ{¾DêÕ£G=„„Ä <<Nt"""""""""""""""*
˜@¥ÒËMüááqps³çÆ)ÎÜÜøSKˆòüğÃÆúõıagg!:åÃ××ééÙùi4¥\93,XĞ{÷^ÅÜ×Úºô?66eP»¶Îœ	;ÙbÏ+øôÓ¥ğõ]Ç_`õê¾¸ys.fÍú+Z	N¬ygÎ„!&&ıú5zï}¥Ri‘'•-k†•+{ã§ŸşÄÏ?ÿU¤cUµjöX³¦Îœ™Šš5ÿW¤:~ü6TªÒ]¤ª[×ß~Û«VÆÏ?ß§HÂÃc¡R©àéÉUQUªd©T‚¨¨ç¢£¨ÕüùÇ••ƒ…»‰BE”“£€‘‘Lt*@BB*üü¾‡““56nô‡ş]°‡Äøä“*pv¶ÆÿıßMÑQˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆ¨Èw×ŠJ¥ÔË	TwïÆÁÃÃAt"XX˜ --StÒqáá±X¸ğ8&MòAÓ¦ÕEÇ¡T¨P5k:!00D«ëvêT¾¾Ş˜:õ ÒÓ³µº6åjÕÊ§O‡aÕªShĞà?˜=ûêÔ©„Ó§§àØ±ñèÒ¥KÏfí={® I“j¨R¥ü{ï+“I‹5¹©yóğ÷oŒiÓ!66¹ÈÇ)ªêÕ+¼)Ry{WÄèÑ»Y¤Ğ³g}øû7ÆäÉûõrDhh,,-MQ±b9ÑQô–±±ìíËâÑ£DÑQÔæäÉ`ìÛwK—ö‚µµ¹è8Tr¹
…’RÑQ))éèÛwŒŒ°gÏp˜›‹DzD"‘ K—:øå—;¢£Q	P¢&P……ÅÂÃÃQt"XXãÕ+¨¨`¯_gaøğ¨SÇ&´‡ŞÃÇÇ§N…h½8±hQ¤¤d`ùò ­®KÀÓ§/ñäÉK$$¤`ıú3èÔéc\½:Ë—ûÁË«ôM¯‰OÁÙ³áèß¿áİ_*•@©,Úª<sætBùò˜4i¿°ÒR^‘ê·ß¦ÂË«"FÚ…6m¾+ÕEªùó»â£œ1hĞV¼|ùZtœBÉ»Ø‚D¢¿çè’Ê•mñøñÑ1Ô">>S¦@¿~Ñ¾}MÑq¨ˆär ”ªR³¾ÈÈÈ†¿ÿ6$%½ÆŞ½#XR¤"éĞ¡<yààhÑQˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆHÏP RB*Õ¯	T©©™ˆM†»;'P‘x¦HMÍƒtØW_BJJ:Ö¯ï¯—ÿJ__o$$¤âöí§Z]×ŞŞ³f}Í›Ïãöí'Z]»´
Áøñ?¢I“opùò”+g†Áƒ›aÁ‚®¨P¡¬èxÂìß––¦ğõı°‚T*BQ¼•©©Ö¯ï+W"°cÇ¥b«¸jÔø_‘ÊÍÍ#G–Ş"•¡¡[¶‚D"Á¨Q» —ïë¬MááqğôäÅŠËÕÕQQÏEÇ(6¥R…ñã÷¢lYSÌÛYt*†¼ç!Së–œ†Ûˆˆ80
ÎÎÖ¢#‘úè#g¸¸ØàÄ‰ ÑQˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆHÏå»ÃH©Ô¿	TwïÆB¥RqS$é++3$'§‹A:j÷îË8zôO¬]Ûöö¥·¡O<<áâbƒÀÀ`­¯İ¯_C4nì†É“÷#'G¡õõK‹ë×Âß+Úµ[°°X,_Ş—.ÍB×®upîÜ]Ññ„R©T8xğzö¬##ƒzŒL&…BQübQ­ZÎ?¾.<ˆˆgÅ>^q¹»;`Ó&ÿ©Ú¶Í-R•&VVæØ¶m0nŞŒÂ’%¿ŠóAT*îİ‹ãÅÔÀÅÅOŸ¾£ØÖ¯?ƒk×"±~ı ˜›‹CÅ Pä°@¥+
%ÆÛƒ7aïŞ¨VÍ^t$Òs>>Ş¥î|‹ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆÔ¯€•2™~¨ÂÂâ`ii
–H<++s$%±@Eo»{7sçÅøñmÑ¢EÑq¨ÚµóB``ˆÖ×•H$øöÛ^xüøÖ¯?£õõK²œ¿V¢K—µHNNÇCpúôôìY††2´kçĞĞ<yòBt\a.]z€¨¨çğókğÁ‘É¤P*Õ3™hÂ„vpw¯€1cvëL‰ĞÃ#¯H5U«æ©:v\…Ó§CEGÓ/¯ŠX¶¬'¾ÿşıStœ÷ŠNBZZ&<<X *.ggkÄÄ${ÊœHAAOñİw˜1ãs|ü±‹è8TL99¹ß‹2ÁIÈ-¬NŸ~§N…bÇ¡¨UËYt$*:t¨…‡ñàA‚è(DDDDDDDDDDDDDDD¤ÇŞ1J¿®Ş|ÿ~îå%ı*~QÉT¶¬)Tô–ôôlŒ±}äŒI“|DÇ¡Bòñ©‰{÷âñèQ¢Ö×vq±Á¤I>Xµê4îß×úú%MFF66o>FbìØ=¨R¥<NŸ‚cÇÆ£m[¯œK4nìKKSüö[˜ÀÄbíİ{uëºÂÃãÃ§|Êd(•ÅŸ@äNÙ°a ¢¢ëÜ´#GlÚäÓ§§ÀÑÑ
ƒmCÇ«KM‘ª{÷z6¬9¦L9€{÷tû¹)<<‰5j°@U\ÎÎÖÈÉQ !!Ut”"IOÏÆèÑ»Ñ¨‘†o!:©'Pé–o¾ù^ÇæÍƒĞ¨QUÑq¨„¨W¯¬¬Ìqöl¸è(DDDDDDDDDDDDDDD¤Çòİa¤P(!•êW)""nnv¢cÈ›@õZtÒ13fFbbÖ­ëÏz¨aÃ*°¶6G` ˜bÄˆ-ááá€É“÷ëõÔ‘ş^œZ¶ì>ûì#\¾<ëÖõ‡—WÅ|ch(CË–îB¦é‚äätœ<„>}êq‰T­ß§®®6X° 6nügÎè^™ÍÓ3·HõóÏ`mmÿ­èÔiM©(RÍİ	5k:aÈ––):NÂÃãàìlÑQô‹‹5 àéÓ—‚“ÍÌ™‡‘’’Õ«ûêİï¼”?¹<÷õF&ã*ÑV­:…Ïaõê¾hÓÆSt*Ad2)š6­†î‰BDDDDDDDDDDDDDDDz¬À	T2™~mîŒ|†ªUY "İP®œ²³åÈÈÈ…tÄşı×pøğM¬ZÕ+Z‰CE “IÑª•ƒ…­¿bEoEc×®KB2è«ìl9öì¹‚ÆaéÒèØñc\º4óçwù ŸGo\½‰””Ò7Yğÿşï&dèÔéãB=N&“@¡PÏª<½zÕG—.ãË/÷!11M­ÇV—ºu]±sçP?>VVfğ÷ßŠÎ×àâÅû¢£iŒ›6Âë×Y˜:õ€è8
ÏVKÅggg	cc½,PıòË:tË—ûÁŞŞRtR“¼•¡¡~ı£¤Ù¹ó–-;‰yóº K—:¢ãP	Ô¼yu\¹‰ÌÌÑQˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆHOX Ò§«q§§g#>>…¨HgXY™ ’’Jßf{zÛ½{ñ˜5ëFúíÚy‹CÅàãã›7£ğâÅ+!ë{x8bÌ˜Öøæ›_ğøñ!ôIN{ö\Á'Ÿ,ÄÜ¹Gñùç¹§,èZ¨ó­[çNP8wî®¦¢ê¬ıû¯£sçQ¦Œq¡'“I¡TªRÚâÅ=ajj„/¿Ü•J½-uÊ+Rıüóx”+g†^½¾ÿo‘êèhagguëà×_ƒğÃˆ“¯ğğXxz:ŠQ"H$T¬h¥wª¨¨ç˜2e?jÊó±F.W  8J”Ÿ~ú³fı¦OÿC‡6‡J¨-Ü‘™™ƒ›7‰BDDDDDDDDDDDDDDDz*ß•B¡„Tª?Wo~ø0*•
Uª”… `ee HNfª´ËÊ’cÌ˜İpw¯€¯¾ê :SË–î00â·ßÂ„e˜8±-œœ¬1sæaatİÿŠS0{ö´mëY¤âTKK|òI†h ­îúë¯'AŸ>ıX™L
…Bı*KK¬[×.ÜÃº?‰­^½ÊØ¹s(Ë+Rm@çÎkpéR„èhj×¤‰¦LñÅüùÇpã†nmlÎÎ–ãÑ£DN R#ggk½*PeeÉ1|ø89YcÎœ¢ãšåM Ò·)Ú%E``&NÜ‹#Zbüø6¢ãP	æäd…ªUípş|ÉìIDDDDDDDDDDDDDDDšU"&PEF>ƒ..6¢£ Ê•Ë@õòåkÁIH´3#&&7úÃ+—°    IDATĞWÅ×wææÆhÚ´šĞ"‘‘–/ïîãğá›Ârè¢§Ú´ñÄµk³±lY¯"§şÎÇÇçÎ…#'G¡¦´ºoß¾«ps³Cİº®…~¬T*R©™	QõëWÆ„	mñŸÿCxx¬FÖP·úõs‹TGƒ±±!zö\Î×àòå’U¤?¾Z·öÄÈ‘»„MêËÏıû	Ë•ğğ`J]\\l­?ªéÓáéÓ$lÛöLLEÇ!5Ë+ì°@¥müq#GîD÷îõ0{6Ë‰¤y»áÚµ‡¢c‘*p•>]½9"â\\lXN Q¶¬)¤R	'P•r?ÿü¸•+{ÃÙÙZtRŸš8ş22²…e¨[×6ÁÜ¹G‘˜˜&,‡®xwqª¬ZÖğñ©‰ÔÔL\½©–ãéºôôl;öú÷o\¤ÇK¥L Êóå—>¨SÇ£GïFffÆÖQ·ªààÁQÿ-R GõğóûşùXt4µH$X¹²7e5j—F¿
#,,FF¨\™ÓjÕÅÉÉ
OèGjïŞ«8xğV®ìWW^p£$’ËsËÍü{€6İ¼ùƒoCÇµñİw~Hôç"<¤¿êÖ­„  §ÈÎ–‹BDDDDDDDDDDDDDDDz(ß–”J¥¨ªVµƒè™L
++s$&¦ŠB‚DE=ÇÔ©1lXsøúÖ‡ÔÈÇÇYY9¸xñĞ3f|ss#Ì™sDh‘är%vï¾Œàë¯BÇµqıú×j-Nåqr²‚‡‡#ÄMÓ¦ãÇo#33İ»×-Òãe2©Æ&P¹­µkû#>>×Ø:š’[¤£GÇA©TâóÏWÁÏï{üõ×ÑÑŠ­lY3lÛ67oFaÕªS¢ã  îŞEõêöœN£F..6ˆM‚\®%¹‚„‡Çböì#7®5ÏÇJ°œN Ò¶?ÿ|Œ¾}7¡eKw¬XÑG¯ş~Dú­~ıJÈÎ–#$$Ft"""""""""""""""ÒCN Ò§0‘‘ÏàæÆé;;$&¾ƒÈÊ’cøğ¨R¥<fÍê(:©Yùò¨]ÛEx‘¦Lc¬XÑÇßÁ¯¿ŞšEÛT*~ıõ>ıt)fÏ>‚Ï?ÿW¯ÎÁüù]`gg¡±u}}½qêTT*ÍƒtÅŞ½WÑ¾}-ØØ”)Òã¥R©Æ§9:–Ã·ßöÂöíqê”~Û4¨‚C‡ÆàèÑqËøì³•ğóû·oëw‘ÊË«"æÍë‚•+Oá÷ßïŠƒğğ8xz:ŠQ¢89YC.W">>Et”¥¦f`Èí¨SÇS§¶‡4H¡È›@Å•6„‡Ç¢ÿÍ¨W¯26lÀÏ;iU¥J¶°±)ƒ[·¢DG!"""""""""""""""=T@J™L?6Á¨T*<z”È	T¤sÊ—·Ä³gœ@U}ıõOxòä%6nô‡¡¡LtÒ oœ>¢ñ‚Èû4mZ~~0}úa¼xQ:
›·nE¡[·u>|'<=qşüt,XĞU£Å©<íÚy#&&	aa±_K¤ÈÈg¸y3
}û~RäcÈd­ü||şùGèÑ£&O>€„ı}ÍmĞ 
şïÿÆâÀQxõ*:ä©îÜy*:Z‘Ø]ºÔÁ¸q?"!AlÉ&<<îî,P©“³³5 àéÓ—‚“äO¥RaÒ¤ıHOÏÂúõôæw[*š¼Ih2Ï»5íáÃDôé³ŞŞNØ¾}ŒŒDG¢RF"‘ NW¨ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆ¨HòİI¦TªôfUBB*^½ÊbŠtNîª4Ñ1HË¿İ»/cÉ’puµ‡4ÄÇÇÏŸ¿Â_=óæu±±æÎ=*:ŠF…‡ÇaÀ€ÍèØq5LL8›6ù£R%[­e¨UË	*”>}LÓ~üñ
œœ¬Ğ´iõ"C*•B©ÔÎ¤®o¾éŒ»[x©±¸š5«_ıŒBZZ&Ú·_?¿ï¤ŸEªeËzÁÊÊ£G‹ûÚ¼|ùÏ¥ÁÃÃAÈú%Uùòe`ll€èhİ,PmØp§N…`Ó¦A°··‡4L.Ï@ehÈ¢œ&EE=G÷îëáìlƒíÛ¿€±1ËS$FíÚ.
ŠƒˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆôP*¥Ş\¥;"â °@E:ÇÎÎR¯§aPáEE=ÇÔ©0xpStéRGtÒ êÕ+ J•ò:Q¤±´4ÁÒ¥=qäÈ-œ<,:Ú%%½Æœ9?¡]»ï“Œ;‡bß¾‘ğö®¨õ,‰¾¾Ş8y2HëkkKN‡ß„Ÿ_ƒb•ée2‰Ö
TeÊcÛ¶Á¸uë1V­:¥•55­Y³ê8q"·H•ššöíWÂß+‚ƒõk³°™™6m„?ÿ|Œ5k~’!obœ‡'P©“D"ƒC9ÄÆ&‹ò–+W"±té	Ì˜ñ9>ù¤Šè8¤œ@¥yqqÉèİ{#lmË`Ïa077‰J1<yò¯_g‰BDDDDDDDDDDDDDDDz¦À	T‰~L ŠŒ|KKSØÚ–…èÊ—·À³g,P•ÙÙrŒ¹+ZcÎœN¢ãøøxãÄ	İ(Ò´ní‰=êaæÌÃHIIG-²³åX¿ş6\ˆ“'ƒ°zu_œ93mÛz	ÍÕ¡C-„…ÅâáÃD¡94%00/_¾†Ÿ_ƒbG*•juâ‡‡#æÌé„•+OáÂ…{Z[WÓš5«“''aÿş‘HHH…¯ï
øûoEHHŒèhÌÃÃ³gwÄòå¸t)Bëëß½kksØÙYh}í’ÎÑ±âãSDÇø‡èè$¾>>51rdKÑqHKò^oôã"0úæùóWğóûææF8xpÊ–5‰J9ww(•*Ü¿Ÿ :
é™TÅ™: M&ÂÍÓ§H÷ØÙYâùó4­Mà ±şóŸŸù›7ûÃÄÄPtÒoDE=3	Q´…»A"‘`Ş¼c¢£ÛéÓ¡hÑb	V¬8…›àüùéèÖ­®N”»5rƒµµ9JŞ´/ Ø·ï*>ıÔ+Zë82™vT 0xpStêô1Æû±ÄM€Ì-R}‰;† >>¾¾Ëáï¿¡¡úQ¤úâ‹fh×ÎãÇÿˆ¤¤×Z];<<œ>¥	º5*33C‡n‡M¬XÑ['^3H;ò&Pp•º½|ù½zm€Jìß?
VVæ¢#ÁÅÅffF¸{7Vt"""""""""""""""Ò3z_ ŠŒ|†ªUY "İS¾¼är¥Ö7
“ö>ŠíÛ/bÉ’|>*EêÕ«Œòå-¨EKKS,]Ú\ÇÙ³á¢ãIHHºu[‡Aƒ¶¡~ıÊ¸xqfÍúææÆ¢£½!“IÑ¶­NÔ¯»:ÅÅ%ãÂ…ûèÓ§a±%“I Tj·@ Ë–õ‚……	Æİ­õ—¦I$´më…€€IØ¾}ââ’áã³#FìÔ™"gA$	V®ì™L‚	öB¥Ò^¹<<<,Pi‚ƒƒî¨T*&NÜ‡'O^`Ç!°°0‰´('G ÷µ‡Ô'))·<•‘‘ƒG¡|yNò#İ •JP½z„‡Ç‰BDDDDDDDDDDDDDDDz&ß•J¥Ô›ÕÃ‡‰¨\ÙVt¢·ØÙån0{ö,MpR‡œâãSŞzll2&LØ‹~ı¢{÷z’‘(R©­Zy   Dt”7Ú¶õB§NcÊ”HMÍçƒ¥¤¤cæÌÃhß~är%~ıu"Ö¬é‡r¢£å«C‡ZøóÏÇˆ‹Óâ€ºìÛwVVfhÛÖ«ØÇ’J%P(´?±LclØ0 7nDaÍšß´¾¾6ä©'cûö!xø0-[.Áˆ;©»Eª²eÍ°vmüşû]üğÃZYS©Táşıxxx8he½ÒF—
T«WŸÆ‰w°eË`TªÄßK…B	)§©Qjjúöİ„””80JgÏÉ¨ôrwwÀ½{ñ¢c‘Ñë	TJ¥
±±Épq±…è-vv– €ÄÄTÁIH¶l9şƒ­[/¼™œ‘“£ÀÈ‘»P¡BYÌŸßEpBÁ×·&şúë±N%-ê…B‰…‹ò^*•
‡İ@³f‹qâDV¬ècÇÆ¡vmÑÑŞ©E‹(SÆX§ÊsÅ•÷µèÑ£eÅ>T*…R©ı ÔªåŒ9s:bùò \¼x_Hmøw‘*2òZ´È-R=|˜(:^¾>ù¤
¾üÒGpp´Æ×{üø9ÒÓ³áîÎ•&8:–ERÒkdddÍqêT¾û. óçwE“&nB³r¹2Y¾Ú "HMÍDïŞ‘˜˜†Ã‡Çğï-¤“\]mğäÉÑ1ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆHÏ¼£@¥ûR-‡““•è(Do)[ÖÆÆ:U¬ ¢;vìOÈåJÌ›wşş[‘’’E‹~AXX6mò‡©©‘èˆ$@‹5`llˆß~åkks,XĞ?şxçÏß§@!!1èÜy-&OŞÎëàÂ…™èÙ³¾^L022À§ŸzàäÉ`ÑQÔæêÕ‡xüøzö¬¯–ãÉdR(Jµ«(†i_ßš3fO‰–Js‹T§NMÁ÷ßDxx,š7_Œ#vâÑ#İ+RM˜ĞTÆ¨Q»ğúu–F×
‹…T*Aõê4ºNi•7‘&¿	ÚñãÇÿˆ=ëcğà¦ÂrX¹¨Š_ş¥ÜòTŸ>ß#!!‡«+ËS¤›\]m“„œ…è(DDDDDDDDDDDDDDD¤G
,PéÃæèè$ €³³µà$Do“H$(_ŞÏq•¾‹OAHH,€ÜçÇß¿‹F¾ÁæÍç±xqT«f/8!‰bbbˆfÍª#0P·&uêT:ÔÂÔ©ğê•f
…•’’éÓÁ×w9d2	'cÁ‚®°´4­P:t¨‰+W"ğòåkÑQÔâàÁë¨UËj9L&R)®@ +Vô†©©Æİ-´Ì¥-R©;ÖÆï¿OÇ÷ßDXX,š5Ó½"•T*ÁÚµıœœ¯¿>ªÑµîŞC¥J¶03cÉYò
T11ÉBÖOIIÇÀ[P½º–.í)$é†œTj––‰~ı6"::	ŒB¥J¶¢#ÈÅÅr¹±±b^ƒˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆH?½c•î¨>}	CCìì,EG!Ê—%Köä‹ÒàäÉà<'ÊåJ¤¥e@"<y¥R%0‰æëëóçïé\QiÉ’ÈÈÈÁâÅ¿ˆòÆÏ?ÿ…æÍ—   «VõÅ‘#cÕVØÑ¶Ö­=a` ÅéÓº3}¬¨ÒÓ³ñë¯wĞ«—z¦O€T*…B!ö¹ÑÒÒ7Äµk±~ıY¡Y´)¯Huş|n‘*44-[.Åøñ?"*ê¹èx  {û²X¾¼7öí»ŠŸ¾­±uÂÃãôö9FØØ˜ÃØØ qqÚß¼®P(1fÌddä`Ëh=é¹\	İŸ ­ËÒÓ³áï¿O¼Ä¡C£áæf':Ñ;åMG{òä…à$DDDDDDDDDDDDDDD¤Oòİe¤R© ¨GÇrÉ¸YŠt'P•'NAõ¯€B¡‚R©ÂÊ•§Ğ«×åJ±6m¼ P(ñÇ÷EGù›2˜7¯3vî¼„+W"…fIHHÁĞ¡Û1jÔn´hQçÎ}…=êéÅ´Ë‚˜›£yó8q"Ht”bûõ×;ÈÊ’£K—:j;¦T*Ñ‰©Oµk»`Ö¬øöÛ“¸xñè8Z•W¤ºpaÖ­ë[·£E‹%:S¤òññF¿~ğÕW‡46=",,îî96åN[up(‡¸¸­¯=oŞ1\¾;‡ÀŞ¾¬Ö×'İ¢P°@UÙ8p""pèĞhT¯^At$¢÷²±)<~Ì}¸TR©îo@Š~	ggkÑ1ˆ
Ä	Tú/55W¯FB©Ì¿ Tªpıú#´nı-"#Ÿi9é[Û2¨[·ƒEGyK÷îõĞ®7¾ür^¿Öş„,¥R…={® Y³Å‹Å#±fM?XY™k=‹&tèPçÏßCZZ¦è(ÅrèĞ´kçkkõ}]d2)Tÿn
2lXs´ní‰ñãÄ‹¯DÇÑº¼"Õï¿…ï¾óÃÍ›QoŠT¢7ÏŸß¶¶e0nÜµOsLOÏÆ“'/àéÉ	TšäàPVë¨~üñ
~øá,_Şµj9kumÒM
…R/ş~¡‹òÊS÷îÅãĞ¡1,O‘^qr²BLL’èDDDDDDDDDDDDDDD¤Gòİe¤Tª •êşTˆ§O_¢bE+Ñ1ˆ
dgg„N ÒggÎ„@	@…Bìl…V2‘îñññÆ©S¡ËÅOÜù·Å‹{ %%ß~{R«ë†‡Ç¢S§Õ˜5ëÿ0lXœ;÷š6­®ÕšÖ®”J%Î¥È¢£“pùrzõª¯ÖãÊdR˜@äNÉYµªe5j—ÎäÒ6CCzö¬óç§¿)R5o¾Ó¦Ôz&™™Ö¯ï›7£°eËù·nW(”ÈÌÌù c>|'OãÑ£D(JÜ»¥RN Ò$‡r› –ŸsçîbÆŒÃ˜1ã3tíª¾©y¤ßT*èÅm]“‘‘ÿ­¸{7F,O‘~)_¬!""""""""""""""¢Â)°@%ÑƒHÑÑIprâ*Ò]¶¶xöŒzôÙ‰A^Ñ^"‘@"||jâ?fr“v)Ö¾}M$'§ãÆG¢£¼ÅŞŞóæuÆÖ­pó¦æóÉåJ¬_¾¾+ ‘HpêÔLÚÆÆ_[Û¬¬ÌÑ°¡NœĞ½écêàÁë°¶6GË–îj=®T*R©Ò™)TåÊ™aûö!¸uë1–,9!:Pÿ.R]¼ø .Ä´iŸ¢õ<µj9còd_,^ü+BCcŞ¼?88-[.AŸ>ß¿÷r¹'îÃ!? I“E¨ReÆŒÙÊ•Ëã—_nãôéP<yòBg¾K{{ím^¿w/£FíD÷îõ0vlk­¬IúA©TêÅ`tIffüı·!88{÷àï1¤—ìì,X """""""""""""""¢By« Tæn,ÔõH*•
11IpvfŠt×ÿ³wßaU–ÿÀßg±·€ŠŠ ¸!Wš©¥ij(8qosàÈÌ\å
Íš–¹wDPTp~SKË‘&šWŠì=ÎúıÁ“(ÈA<çÀûu]^yqßïs8èş<ŸÊ•­’’‰œ…ĞQèäæ*pòä(¯v–’J%055Â¢E½±nİØÙ™ô…‹‹=j×®ŒÈHı,¤éÓ§Ú¶­‹Ï>Û¥u7—7qóæS|òI0–-‹Ä¬Y¾›Pî»têä‰'nä÷yµZ_~¹ˆ=Ş…L&ÑéØIŞ%fşu¥>hĞÀ	‹÷Â?œDxøU¡ãîåBª3gnã½÷æcêÔ=ˆ-ÛBªÀÀhŞÜãÆmGZZ6–-‹@çÎßáşıx\¼ø éé9¯=_*ÃÉÉZóX.W"&&ÆcéÒ¼-[~w÷/¡Ÿß§•½}Ùt[MÅ€kÑ A5,^Ü»Ôç#Ãc7€Ñù§¢¢ã—_ÆÂÓ³ºĞ‘ˆŞˆƒƒ%?gÇo"""""""""""""""ÒŞ+Tùwf×÷ª¸¸tdgËQ½º­ĞQˆŠäèh \Ôc NŸ¾¬¬—‹"òºNµiãß~›Ş$éoo9¢¿ó—/@||:.<¤ó±•ÊÿºNÉdb=:#G¶Õûk	]èÔÉYY¹8}ú–ĞQJìÏ?ï#&&½z5×ùØúX@ =z¼‹şı[â³Ï~ÆíÛÏ„£ò©NŸ  8~üŞ{ï›2-¤‹Eøî»~xò$íÛ/ÆwßƒR©‚J¥†R©Æ¹sÑÅÑ°aµW¾ç(•jäæşW“£@Íšö:Ï_‘U®l…øø´Rı¬ggË1lØ˜šÊ°iÓ0|’áS©ÔâšC23s1hĞ:DE=Á=cÑ°a5¡#½1{{v """""""""""""""¢’)²•¾ßÁùÑ£D `*ÒkÕªåø=y’$pz‘‘QéJ¥˜›Ë°hQoìÜ9•+[¿ælªh¼½=ñèQ"nŞ|*t”BU®l9sºaÃ†Ó8wî®ÎÆ‰‰GÏ«±xñŒß¡¡àîî¨³ñõ]•*ÖhÚÔ^:J‰íÙsÕÑ “ÎÇÎ_È®Tªt>öÛ

êœ0|ø&¤¥eGoÈdğ>şøã+|óMw?~­Z-ÀW_í×ªÃPhèeÜ¿÷Fs«TjDD\Cvv.bcS Rı÷¾‘ÉÄ8sæv±c4hà©´èÂ©TŒŞ½[ ~ıªo”‘
çèh	¹\‰ääÌR_¥RcìØmˆ‰IÀÖ­#ammV*óaS«Õzÿû}™™‹Áƒ×áæÍgøå—±ğğ`ñ6GÇ¼ªüAÇ`;P=y’‰DŒ*UXÀ@úËÑÑÆÆR<~Ì*C£R©qøğUÈå
äuáı÷İpú4»NQáš4qFåÊVˆŒŒ:J‘úôioo|öÙÏHOÏy«±Ôj56l8öí#;[£G§àóÏ}4‡*_ßFˆŒŒBNÎËëôWv¶‡]AïŞºï>üw©o¨€¼B¡„ääLLš´“‹n_òb!ÕÜ¹~¿ŠÖ­ƒğÕWûñüyá]îÜ‰E`àvtë¶11ñ%šïÁƒøû9sB¡Tª P,º“Ë•8yòŸbÇ©[·

e‘ûÅb1¾øÂ§DÙ¨x¥ÛmuŞ¼0œ:õ¶lv£ÂñÛxñ22r0hĞ:Üºõ{öŒEıúº/&*kööyE¼,ˆ'"""""""""""""""mÙJß¨=JD•*ÖºÃé‘H„ªUmğøq¢ĞQ¨„._ARR&ÄbÀÔT†%Kzc×®Ñ¨ZÕFèh¤§Äb>ş¸¡^PÀ‚=‘šš……ÃßxŒøøt´sç†aÜ¸8xpêÖ­¢Ã”†Å×·122rpúô-¡£h-<ü*²²äğókZ*ãçÒéc* pr²Á?ÂÑ£×±nİi¡ãè¥ÿ
©faÎ?„‡_A«Vßà«¯ö#.®`!ÕÒ¥HÄHNÎ„¿ÿ÷ZwŞ¼}ûÚµ[„Ë—¼¶ØîşıxÄÆ¦¼v¬:uª9†T*Æøñøox)pt´€WŞº°sçy¬[wË–àİw]u>>•*•Jï!¤ÔÔlüˆ;wb±wï8vâ£rÃÊÊ@Ş{œˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆHÒ—7ä/<‰ô{ÒãÇI¨QÃNèDÅª^İN/:P9r›6m:†Á¸ß
€%,-sQ§N,BC—#4TèT%ãããƒaÃ†	£BñööÀÎçñôi²Ş.Ô¯\Ù
AA=¸;6D»võJtş™3·1aÂNH¥bìİ;ï½W«”’*U¬Ñ´©ÂÃ¯¢cÇ†BÇÑÊ=ğñÇP©’E©ŒŸ_@¥Rég ´iSS§vÂ7ß€§gu¼ÿ¾›Ğ‘ô’‘‘¼=šaÇóX½ú~şù<úöm‰	>FRRÂÃ¯j:y%$dÀÏï{„‡ODåÊ¯ïëädûÿİ__|(gÎÜAÏïyŒ››#$q¡E{ÆøôÓ´x¶TR66f02’ê¼Õ±c×1mÚ^LÚ	İ»7ÓéØTş¨Õúÿû¡¤¦f¡oß5xò$	{÷E:·àÊ++ @ZZ [aÃ‘A0ØTO$¡Z5. ıW½º­^P8p ¿şú«Ğ1†M.j×N†§gŒBÇ)±Ë—/cÇBÇ¨p>ü°ÌÍpìØ¡£¼–¿Stéò¦Nİƒ´4íîØ.—+±lYúö]ƒæÍ]püøO½À×·""®!'Gÿ¿_<}šŒsç¢Ñ»w‹R›C,Îï@UtW!}Ø>>=z={}‡£ŠÎÔÔ#F|ˆß~›‰Ï>óÂşı—Ğ¦ÍLšô³¦` 
%bcSÑ­ÛJ<şú®DÆØ±cæÌñƒD"Ö¼o^&‹qæÌë‹¬d2	œ_½¹‚X,ÂŒ¾°°0ÖâYRI‰D"88X"6VwTW®<Ä˜1[Ñ»wLœØQgãRù¥R©õş÷BHIÉD@ÀÄÆ¦"4t‹§¨Üa*"""""""""""""""*©";Péû¤gÏRP·nU¡c«zu[üùç=¡c  <<<°gÏ¡cP3fnß¾-tŒ
ÇÈHŠ¶më!2ò†ò ~    IDATj%tœ×úöÛ^øè£E˜7ï –,éıÚcïŞ}1c¶"&&Ë—÷EïŞÍË(¥áøä“F˜3'§OßÒû.T»wÿ	3´o_¿ÔæÈ¿,¬>‰DX¾¼/ºtù#GnFHH d2‰Ğ±ôš™™Æë€!CÚ`Ñ¢ÃØ°á4Ô/ÕÉ)J<}š‚^½V#4t<lmÍ‹O$aÄˆÑ¼¹+FŒØ„ØØ(ß7
…'NÜ,6›‡G5<xPàçgçJx¯äO”´æèh‰øø×Ëi+&&ƒ¯G«VîøöÛ^:“*5;P½$!!½{ÿˆÔÔ,üòË8¸¸Ø‰Hçş+ Ê8	ŠBnónTqqépp°:Q±ªW·Ã“'IP¿¼º˜ˆÊ%ooœ={GëÎNB±³3ÇâÅ½±sçyœ<ùO‘Ç……ıŸåJ%8zt
‹§ŠPµªš5sAxøU¡£kß¾KèŞ½Y©
I$y×‘ù…,úÌÂÂ7ÃíÛÏ0ş¡ãssc<y’©´ğ÷‘\®DLL<ºw_””ÌbÇkÔ¨Nœ
Ÿw ¼úsHbb:îÜ‰}íuëV-ĞK­æÏ÷‡TZxg+Ò«b»i#11¬…““Ö¬Ì¯iM­X?õŸøøtôîıÒÒX<Eå›±±FFR½ÿ¹‹ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆô‡A®JS©ÔHLL‡£#¨HÿU¯n‹œâãÓ…BDeàã@­VãÔ©â»¥ÍÛÛ]»6ÆçŸï~¥ÀA¡P!((cÆl…¿S„…MàÜbøú6BDÄ5ää(„R¤îãîİç¥^—_Ä¢Réwª|nnX²¤7Ö¯?½{/Ç Ü¼ù× —+‹<F.Wâîİçø	éé9Åiii‚µkcÅŠ¾02’( ‘J%8sæõëÕ«
…BùÿÇ‹Ñ¼¹+:th å3¢7åèhùÖTYY¹<xT*5¶n	33#¥£Š@­Vëı`ÊJ\\zõZôôìÛˆš5+	‰¨TYY™ 5•TDDDDDDDDDDDDDDD¤B
¨òés³œ¤¤ÈåJØÛ³€Šô_õê¶ €Ç“NBDeÁÆÆ-ZÔBdä5¡£heÁ‚P«U˜=;T³íéÓdøûÍ›ÏâÇañâŞ¥Ú­¨¼øä“FHOÏÁéÓ·„R¤={. ~ıªhØ°Z©Î#ç]b*•z|Aù’®]›`äÈ¶˜6íDE=:Ş[¼øHnOEQ(”¸~ı1ü	ÙÙr­ÆîÕ«9"#?‡³s%M•J¥Âÿş÷úÂÔºu«h~†Q*Õ˜7ÏO«ùèí8:Z!..õÏW*U;vîßÇöí£Øe˜J,¯Û!¨?OC¯^?@.W",ljÔ°:Q©355BffñEÚDDDDDDDDDDDDDDDD@!T¢ÿ_w”·I?åßáœ¨ÈT­j‰DŒÇ…BDeÄÛÛ'NÜxmg}akk%Kú`Ï8räÎ½ŸåHIÉDxø$tëÖDèˆ£jU4mZááW…R¨ìl9¼‚€€÷J}.‰$ï‚R©4ŒTù¾şº+Şß®Ã³g)BÇÑ[ÙÙr?~
…R©FFÒ×vQ(T¸té!†YÜ\í:´Õ­[Ÿ£k×&‰DP©Ôøı÷h(E¿§\\ì5ÅşşMñÎ;5JöÄèTªd„„7ë´ªV«ñÅ{púômlÙ2µj9è8Uì@<z”?¿•P«ÕØ·/UªX‰¨LKõºû+ééËò©õ¸U||~••ÀIˆŠ'“IàèhUa:PEGG£víÚ%ş¢Íy>ÄìÙ³±iÓ¦·©ÕüùóÍœ9óSif#ıæãã‰Ù³CñÇwÑ¦M¡ã«cÇ†èÙ³9&NÜÌÌ\øû7Ã¢E½`ff$t4ƒãëÛË—G"7W#£W.³uøğßÈÌÌŸ_ÓRŸ+¿•JeXT‰«W@çÎÁ9r3öí§w_Ç)•J„‡‡#77·Ìç5«1bc³ƒ„„l$$d#..ññ9š…Ì"Q^1H$‚\®ÂéÓ·Ñ¥ËŒQOëb‡¶mabâ†½{ï!33Ë—o‚«kÑ?ØÙ!>>ï¼ìİ»W'ÏÕĞˆÅbxyyÁÒ²ln6akkääL¨ÕjˆD%+bYº4{÷^ÀúõCÑ¬™Ké¤rO¥R£„o½råîİçèÓçGØØ˜a×®1°··:Q™16–i]œMDDDDDDDDDDDDDDDôÊŠĞüEoúİ*2™ÖÖ¦BG!ÒJõê¶¦€Jîİ»‡-Z >>¾ÀöĞĞPøùù•Êœ666øòË/Ël>*ßjÔ°CıúUeT9HJÊDzz7vÆ÷ß÷:’Áòõm„¹sÃğë¯·Ğ±cC¡ã°gÏtèĞ ¥_T‘ßJŸ¯'‹bmm†­[G K—`L™²+Wêïçá·ß~ÓË§ÄbcH$ÖH¬ ‘XC*µşÿÿÚâÚµ\ôï¿JeÉ:|I¥v°¶n¯¾ÚÜÜ§EgnŞ€
Ÿ~úİ[>Ã¶víZŒ9²Læ²µ5‡B¡BZZ¬¬L´>oÇs>†¥K{ÃÛÛ£Ry§V£ÄÅ{åÅ­[Ï°UªXaçÎOakk.t$¢2eb"Ev¶\èDDDDDDDDDDDDDDDd Ä¯l0€TÏŸ§ÁÁÁ²Â.’"Ã“W@•(tƒ¡R©ğÊö£GÂËË«Tæ´··Ç·ß~[fóQùçíí‰ÈÈ(½ş÷ >MF÷î«pùr¾şº+®^}„ğğ«BÇ2XU«Ú iÓšz÷>{–‚ß~»ƒŞ½[”É|ù¨”JÃê@•ÏÍÍ?ı4û÷_Æ?:N‘Š¼qqqP«ÕzóG©ÌFnn,²²î =ı"’“O !!±±ğìÙj(É%S.O@|ü^ääüûÚãÒÓ/"=ı²à¯*Uª¤yo”[[3 @bbºÖç=…éÓÁäÉŞèÛ·eiE£
B­VkİÕ®<¹zõºw_WW{ìÙ3–ÅST!Ë“Ã*"""""""""""""""ÒÎ+TùEIú¼à;>>­Lº'éJõêv×J¡P`öìÙpvv†ƒƒ„äädÍşääd2ööö¨^½:¦L™‚ììlÍş;vÀÍÍ3f233 !!!ğôô„©©)œ±råÊWænÙ2o!m•*U4ÛâããannSSSDGG( |ùqQsäÀÁÁãÆCvvö+c¼8ß‹Ôj5¦L™‚Æk:dÉårÌ˜1Õ«W‡­­-Æ‡œœÍ˜'ODÍš5qöìYˆD"ìÛ·Mš4µµ5æÍ›§»¨qÈ0y{{àÉ“$Ü¸ñ¯ĞQŠtáÂ}øø,‡B¡DDÄdŒıŞÃ´i{—&t<ƒåëÛ‘‘QÈÍ-»†âìÙsVV¦èĞ¡~™Ì'‘äPéïõdqÚ¶­‹™3}tÇ]:‘Ş²³³  $%ejuüÜÃèÑ[Ñ·oK|ş¹wiF£
B­VW¸›«œ?½{ÿ€¦M±sç§°´Ô¾ûQybl,Ev¶ş\s‘~{Mª2Ï¢µ¸¸48:Z	ƒHk†Ø*88!!!8|ø0N<‰[·n!((H³?00?ÆŸş‰#G 22‹-Òìß¸q#"""pèĞ!œ8qóçÏGjj*úôéƒ-Z ::.ÄÄ‰‘˜Xğµ9ş< àÙ³gšm„¯¯o±¹µ™ãûï¿GXXÂÃÃqôèÑW:O5ŸZ­Æ—_~‰'NàÄ‰°·· ,]º·oßÆ¹sçpúôiœ;w3gÎÔœ·dÉ,^¼7 ìŞ½§NÂ²eË0{ölM·­âÆ!ÃòÎ;Õáädƒˆˆ(¡£jçÎóèÙs55ªĞĞ	¨QÃ 0gN7˜™aêÔ='4\]º¼ƒ´´lüúë-¡£hìÛwşşMad$-“ù$’¼ëI•Ê0;På=ºúöm‰qã¶áæÍ§BÇ!ÒKù¨’’2Š=öæÍ§2dÚ¶­‹  ¥*ˆŠÖêÄ‰è×ï'´jå†ÁÄD&t$"ÁËÍTDDDDDDDDDDDDDDD¤W
¨ò©Tú[Aõü9;P‘a©^İiiÙHMÍ.ş`=±~ızÌŸ?ğôôÄæÍ›ÑªU+ y’víÚ…+V V­ZğôôÄ¼yó°}ûvÍùÁÁÁ¨]»6Z´ho¾ù»wï†‰‰	®]»†•+WÂÉÉ	®®® ğJUaÂÃÃÑ¥K—bÓf¥K—¢víÚxï½÷ğÍ7ß`ÇZÍ7mÚ4,Y²»víB¥J•4Û7mÚ„U«V¡FğôôÄ¢E‹pìØ1ÍşÅ‹£OŸ>°°ÈëĞ0vìXØØØ`ğàÁ €¤¤$­Æ!Ã"‰àåÕ‘‘×„R€J¥Æ×_ïÇ_ìA``lÙ2¢@×KK,[€£G¯#4ô²€IWµj¶x÷]½yı®]{Œ;wbÑ½{³2›3¿ˆRiØT °`AxzVÇ!.t"½cnn##i±T& oß5hØĞ	kÖ†TZä¢D%¢R©QQPEFFaøğMèÒ¥Ö­Zf…ÑDúJ&“”‹ëM"""""""""""""""*¯é@¥¿Tqq, "Ã’ßÙåÉÃéBõàÁ¸»»k×¯_şşş €ØØX(•J¸¹¹iö»»»ãñãÇšÇµk×Öü½^½zxúô)ŒŒŒğàÁtëÖï¿ÿ>6lØ U–ôôt(
ØÚÚºÿÅïWÚÌñb¶úõëÈıºù.\¸€víÚaáÂ…¶?zôU«V…H$úÿ¢/<xğ Àó‘““ @&“•h2<ŞŞˆŠz‚‡„ ÈÉQ`Ô¨ÍØ¶íwüøã@|ñE'M¡Ë‹>ø †iéÓ÷áÙ³’>?¿¦ˆˆˆBFFĞQr	..öhÒÄ¹Ìæ”Hò.1õ¹ _[2™ëÖ…HŒ±	r¹RèHDzÇÖÖII™EîOHHGÿşkagg‡ÁØ˜E¤;j5 •ÿ‚¼}û.bäÈMè×ï=¬XÑEˆDÈ+Úgië•7ù©õyÁk\\*¨È T«f‘H„G§€ÊÉÉ	111šÇW®\APP  råÊH$¸wïfÿİ»wQ­Z5Íã;wîhş~ûömÔ¬Y999ğ÷÷Ç¤I“pîÜ9¬^½Z«,ğññye»B¡  <yòD³M›9^Î–_ĞTÜ|áááøé§Ÿ°k×.œ:uJ³İÉÉ	wîÜZ­†Z­FRRÎŸ?¯Ùÿr¡”X\øbÇâÆ!ÃÓª•;¬¬Lqüø¡£ %%?â·ß¢ñóÏ£Ñµk“×?k–/ìí-0qâN½.ªÖW]»6†\®ük¯R©öºwoVh±\iÉ/ R*ËÇ{ÇÎÎ6Ãµk1mÚ/BÇ)sÑÑÑoôşÑæ¼‡bèĞ¡o<‡®6~¶²$‰]¦sê‚y‘¨ÒÒ²Ñ¯ßOP*UøùçÑ°²2-ãtTŞU„T[¶ü†‰wâÓO?Â‚=57¾!ªè$‘^ÿş’ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆô‹Áu R*UHLÌ`SS#88X &F?ºĞhcàÀ˜9s&®]»†ë×¯#00PSP%“ÉĞ§OL˜0÷ïßGTTfÍš…hÎÿüóÏ.`ÆŒ8p 222••©TŠ¬¬,Ì= ––Vh†üíaaaèÖ­›f»µµ5 `ëÖ­HMMÅÊ•+5û´™câÄ‰²õïß¿À¼/Ï—ÏÌÌuêÔÁ´iÓ0zôhdgg úõë‡©S§âŞ½{¸~ı:ºtéR “¶t5é™L‚víê!""JĞÏ¥ {÷Õˆ‰I@HÈ8´léVì9¦¦FX½z ÎŸ¿‹Í›+ƒ”åK¥JhÓ¦öï¿,hßÆ³g)ğ÷oZ¦óJ$ùùå§#@ƒNøşûØ½ûlÙÂÏDIİ»wööö¯l…ŸŸŸ ‰Š§M¶¢×Ûkhlm/ ’Ë•9r3>MÆ£àèÈŸáH÷Ôjµ ˜¥mõê˜>ıLì™3?:‘^‹Åì@EDDDDDDDDDDDDDDDZ+´ŠH$ÒÛª„„¨TjP‘Áquu@LLœĞ1´6}útxyyÁÇÇ­[·†³³3/^¬Ù¿jÕ*899¡yóæšã¦OŸ®Ù?räHøøø sçÎèÔ©¦L™;;;,X° hØ°!ÜÜÜĞ·oßWº=¹¸¸ eË–¨Zµ*är9t‰rppÀìÙ³ñÙgŸ¡yóæ1b„fŸ6s0 ;vDçÎáíí3fhö6ßË¦M› øöÛo 3gÎ„³³3Zµj…6mÚÀİİ½Àk¥-]CúÅÇÇüq))™‚ÌóæStéµZC‡&¡~ı¢ßÛ/{çì€o¾9ˆ»wŸ—bÊòÉÏ¯)NúÉÉÂ|í $ä5ª77Ç27¿Ó^y[ĞÚ©“'&OöÆW_…àìÙÛBÇ1(*•
		¯’=z^^^$*6ÙŠz^o{¬¡±µ5GbbÁ*•JÀÀíøë¯Ø¹s4\]JGåZrÛ‘iÙ²,Xpóæùcòdo¡ãé¼Tåëz“ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆJOTy‹ôQşÍíìÌNBT2..ö¸w/^èZ366Æ’%KğäÉ$''cçÎ°µµÕì·µµÅÖ­[ÿıK—.…±±1Üİİ¡V«Ñ«W/DGG#..+V¬€±±1€¼Â¬äädÜ¿£FÂÎ;«9 ¤R)Î;‡ôôtÈd2:tè•|sæÌAJJ
nİº…Î;(ú,j|Ã†Ãıû÷‡ï¿ÿ&&&šù›ïÅl `bb‚[·naÎœ9šÇÁÁÁxöì’’’°eËXXX¼rw‡|ww÷B—d2íÛ7  œ<y³Ìç>{öºu[	77G„†N€““M‰Çøì3oÔ«WãÆm‡\®,…”åW§NHÄ8|øoAæÏÉQàğá¿Ñ½{³2Ÿ;!»RYş¾w}ö™:w~£FmÁıû†S 
…³gÏ†³³30hĞ $''kö'''cÈ!°··GõêÕ1eÊM·E Ø±cÜÜÜààà€1cÆ 33¯80$$055…³³s¡İ[¶l	 ¨R¥Šf[||<ÌÍÍajjZàXµZ)S¦ qãÆˆÏ»v’Ëå˜1cªW¯[[[Œ7999ˆ†H$ÂÉ“'Q³fMœ={"‘ûöíC“&M`mmyóæiÆ.jœ—½œmÿşığğğ€‰‰	jÕª…mÛ¶ù¼Šz=
;¶0'OD½zõ`mm¹sç¾öX}akk†¤¤‚Å¢_½Ç]Ç–-#àáQM dT¨Õ*”·T*•3gîÃŠÇ°bE?Œñ¡Ğ‘ˆô’X,†JUş®7‰ˆˆˆˆˆˆˆˆˆˆˆˆˆˆ¨tZ@%‹ôvBZZ ÀÊÊ´˜#‰ôK­Zˆ‰1œ*"Ò++´lé†ÈÈke:ïÉ“ÿ`Ğ uhß¾>vì++“7G*cÅŠş¸}û¾ÿş¸S–o––&hß¾>BC/2ÿñã×‘_ßÆe>·D’w‰©V—¿ "‘ß}×..ö0`İ+]wôYpp0BBBpøğaœ<y·nİBPPf`` ?~Œ?ÿüGAdd$-Z¤Ù¿qãFDDDàĞ¡C8qâæÏŸÔÔTôéÓ-Z´@tt4.\ˆ‰'"11±ÀÜçÏŸ <{öL³íàÁƒğõõ-pœZ­Æ—_~‰'NàÄ‰°·· ,]º·oßÆ¹sçpúôiœ;w3gÎÔœ·dÉ,^¼ç½ßwïŞS§NaÙ²e˜={¶¦óSqã–-==}úôA`` bbb0kÖ,6¯<¯×½…½…9xğ .^¼ˆM›6aÎœ9š"2}feeŠ´´ÿŠí/>‚-[~ÃªUĞ²¥›€É¨"(o¨är%Æß;ÎcÍšÁèÙó]¡#é-±XT.ö‰ˆˆˆˆˆˆˆˆˆˆˆˆˆˆ¨tÑJ¤·İNRSóæYZ¾ÙBp"¡¸¸ØãñãDäæ*„RaYYYáÓO?:U@>>8qâŸ2ûü;vÃ‡oDçÎïàûï@&“¼Õxîî˜>½‚ƒâ¯¿ê(eÅàç×¿ÿgÏRÊ|îKhÓ¦ªT±.ó¹Åâ¼KÌòº ÕÔÔÛ¶„Z­ÆÀk‘••+t$­¬_¿óçÏ‡‡‡<==±yóf´jÕ
@^g¦]»vaÅŠ¨U«<==1oŞ<lß¾]s~pp0j×®-Zà›o¾Áîİ»abb‚k×®aåÊ•prr‚««+ ¼R@U˜ğğptéÒ¥À¶iÓ¦aÉ’%Øµk*Uª¤Ù¾iÓ&¬Zµ
5jÔ€§§'-Z„cÇiö/^¼}úô…… `ìØ±°±±ÁàÁƒ IIIZSX6¥R	±X¹\KKK:III¯tÎğV¯G¾)S¦ÀÂÂ~~~ P K˜¾277ÖP­_+VÃ’%½Ñ¹ó;'£Š@_wñ&23s1tè=š×½Ÿ!¢×“HÄP©Ê_Á>•"¨ô·U6$1ÌÌŒ„BT"µj9@¥RãáCíĞ’n9::bÍš5BÇ 
¨S§w™™‹ß.õ¹¸‚#6¡wïX¹²?¤ÒBÿ©/±#>D›6u0qâdgËu2fEĞ±cCXX#<üj™Î›šš“'ÿ¿Ó27ŸD’×	D©,¿Z+U²À–-#pï^<&MúYo¯_ôàÁ¸»»k×¯_şşş €ØØX(•J¸¹ı×-Èİİ?Ö<®]»¶æïõêÕÃÓ§Oadd„ [·nxÿı÷±aÃ­²¤§§C¡PÀÖÖ¶Àö. ]»vX¸paí=BÕªU!‰ ‰àåå…Èó"''' €L&+Ñ8…e³¶¶ÆÙ³gñçŸ¢fÍšğññÁÅ‹5…‚/zÓ×£°ì…¯¯,-M_~¹ˆ9sB1sæ'xOèXTˆD†ß*99kğ×_±k×´m[WèHDz¯|ô‰ˆˆˆˆˆˆˆˆˆˆˆˆˆˆ¨Q@¥¿wqNMÍ‚……I¹X E‹‹‹=D"îß:
•±*U¬ááQ‘‘Q¥:Ïşı—¸¼o¿í	±XwÿVŠD",_€¸¸t,X®³qË;cc)¼½=z¹Lç¿ ¯xOI~ªò[@ µkWÆ¦MÃ…o¿=$tœb999!&&FóøÊ•+

 T®\‰÷îİÓì¿{÷.ªU«¦y|çÎÍßoß¾š5k"''şşş˜4iÎ;‡Õ«Wk•%"">>>¯lÇO?ı„]»váÔ©S²ß¹sjµjµIII8ş¼fÿË…RE7NaÙ²²²••…mÛ¶!66C†——W¡¡Şôõx‘!şœcii‚ääLLü3ÆÿcÇ¶:‘A‰MA«›‚ƒ'¢Y³šBG"""""""""""""""""*w
]Y(‹õö.úiiÙ°´4:Q‰™›ÃÑÑ÷ïÇE/=|øC‡dn‘H„èhí:•äX¢y{{ ""ªÔ
”·mûãÇoÇØ±íÔ£TàW©byóü°aÃœ:uSçã—W~~Mqùòƒ2- İ¿ÿ¼¼<`eeRfs¾(¿xO_¯'u©eK7¬XÑ«WŸÄæÍ¿	çµˆ™3gâÚµk¸~ı:5U2™}úôÁ„	pÿş}DEEaÖ¬Y0`€æüÏ?ÿÑÑÑ¸páfÌ˜"##YYYJ¥ÈÊÊÂìÙ³ iii…fÈß†nİº½²ßÌÌuêÔÁ´iÓ0zôhdgg úõë‡©S§âŞ½{¸~ı:ºté‚•+W–ø5ĞfœÂ²uìØQS@±X#£ÿ:âæ?/m^ÿ¾~ız¤¤¤”øyè›Ç‘“£@¿~-ñå—…CdPîÜ‰E—.ÁP©ÔZµ„DDDDDDDDDzD©TyÓ0""""""""*™BË"•Šõ¶c@jj,-M…AôF\\ìÙª¡¡¡ğóó:Q©ñññDll
®^}¤ó±wíúÓ¦ı‚)S|0mZÿ¢^½šã“OáóÏw!%%³Tç*/>ø ìí-pàÀ•2™/66çÏßC÷îÍÊd¾Âäÿ¼ŠP@ İº5ÁäÉŞøúëœBôeR    IDAT<ùĞqŠ4}útxyyÁÇÇ­[·†³³3/^¬Ù¿jÕ*899¡yóæšã¦OŸ®Ù?räHøøø sçÎèÔ©¦L™;;;,X° hØ°!ÜÜÜĞ·oßWºK¹¸¸ eË–¨Zµ*är9áääTdÖiÓ¦ ¾ıö[ ÀÌ™3áììŒV­Z¡M›6pww/][ÅSX6SSSlØ°_ı5\]]±fÍìŞ½fff€×¾/›ÿšÆÅöµáåË°zõI (õƒˆÊ›+WÂßÿ{T©b@T­j#t$""""""""Ò39077*ş@""""""""*–´°ÆÆRääÈË:‹VÒÒ²ë¦@ô¶\]ØªGÅŞ½{…ATj4p‚³s%DFF¡qcg{øğß˜:u&OöÂ¤I^:÷u.ì‰öíá«¯öcåÊşe2§!“JÅøä“F	¹„‰;–ú|!!—aaa‚>ªWêsE"Éë@¥¯ù¥aòd/<z”€O?İ‚½{Çêôs®+ÆÆÆX²d	–,YRè~[[[lİºõ•íîîîšîy½zõzeÿôéÓZ5Jó÷üó¤R)Î;§Ù~èĞ¡"ç  Üºu«Àãàà`¿ö¼ç,ì±6ã¼œ ú÷ïşı_ı~÷òó^ÿz¼|lI²ë£şyŠÖÂÓ³.\¸‡ŒŒØØ˜	‹È œ9sÃ‡oÄûï»ã§ŸÃÄD&t$""""""""ÒCü½+‘îÚÊÈHŠœeYgÑJjj6¬¬ØŠ“«+;P&>>æææ05Íûlïß¿011A­Zµ°mÛ6 Àøñã1|øpÍyééé033Ã_ı ‰DØ·oš4ikkkÌ›7  P(0{öl8;;ÃÁÁƒBrrr'OD½zõ`mm¹sç¾6oI%zQÇ¥³ñş÷¿›;vnƒÏ?÷)ş±³3Gpp?ìÛw©Ìº*:?¿¦¸s'ÿüó´Ôç
	¹_ßF02*´N¾LˆD"ˆD"¨T§€J$aÉ’>xï½Z0`-îŞ}.t$¢R~ıÖ aC'uw³"*^HÈ%°>>X¿~(‹§ˆˆˆˆˆˆˆˆ¨Hì@EDDDDDDD¤;…PË›«(ë,ZIMÍ‚¥%;P‘aruuÀ“'IÈÉÑÏÏ—P<___ yEQ}úôA`` bbb0kÖ,6èÕ«ÂÂÂ Pä½~aaa¨U«7n¬k÷îİ8uê–-[†Ù³g#!!ÁÁÁ		ÁáÃ‡qòäIÜºuAAA¯d¸xñ"6mÚ„9sæ >¾èNa%9–èEŞŞ¸yó©N
)Ï½ƒ¡C7Àß¿)æÍóÓAº’i×®úõk‰3~Allj™Ïohš7wEv½\ªóÜ¹‹ë×ŸÀß¿Y©Î£‰D¥R¿»çèšL&ÁºuCP«–#ú÷_‹çÏÓ„DT*=KA@ÀT­jƒM›F R%s @z:¨ˆŠ³qãL˜°ƒµÆŠı “I„DDDDDDDDDzìéÓ88X	ƒˆˆˆˆˆˆˆ¨\(¢€Jª·TiiÙ°²b&WW{¨Tj<|˜ t½.]º  ”J%Äb1är9,--1tèP$%%ÁÔÔ­[·†L&ÃéÓ§ ;wîÄÀ!‰4c;666<x0  ))	ë×¯ÇüùóáááOOOlŞ¼­Zµ*aÊ”)°°°€Ÿ_^!ÊËªŞôX¢µlékk3;vã­Æ¹té†İ€béÒ>>eiî\?X[›aÒ¤P«+V¡LI‰D"øú6Æşı—JõµÚ·ï"œœlğŞ{µJmm‰Åb(•§U>SS#lŞ<2™}ûşˆÔÔ,¡#éTbbÖÀÔT†;FÁÂÂy?Ÿ¥¥åœH©Õj,[¯¾Ú3>Áüùş‚]Ã‘aP(Txü8µj9…ˆˆˆˆˆˆˆ¨\(²€*;[^ÖY´’×ÊTèDoÄÕÕ"‘11ìX”/==
…¶¶¶  kkkœ={şù'jÖ¬	\¼xb±‰İ»wGHHâããqüøqôë×¯ÀxNNN  ™L¦ÙöàÁ¸»»k×¯_şşş…'úmñ%z‘T*F‡õyíÇøçŸ§èß>ø ~øa$áŞ‡ffFX±¢/Î½ƒ;Ï–ÃPøù5ÅãÇI¸|ùA©Œ¯V«úüüšB,~A¶X,ªT `gg;F!11Ã‡oÔÛ•TZZ6ú÷ÿ	9Ø¾}lmó:O™›C,!-¨ˆ
£Tª0uê^Ã²e}0vl{¡#‘xô(r¹’TDDDDDDDD:Rèªk##v "*ffFpt´Ä½{qBGÑğññÑ<ÎÊÊBVV¶mÛ†ØØX2^^^š.O½zõBHHöìÙƒ6mÚ FÆ+¬¨ÉÉÉ	111šÇW®\APPPcJr÷wŞ)Ş†··şüó>3J|nll
\êX³f¤Rá‹øŞ}×£G„9sÂXZj¨S§
öï¿\*ã_¼ƒ‡Ğ£G³R¿¤$q…îLæì\	Û·Âß?ÆÄ‰;¡RUÜ×‚Ê‡ìl9†Y'O’°{÷T«f«Ù'‹`ff„ŒP½,++Ã‡oBHÈ%lŞ<ï	‰ˆˆˆˆˆˆˆˆDtôsˆD"¸¸Ø…ˆˆˆˆˆˆˆ¨\(¢•99úY@•ššÍTdĞ\]Xdğ‚°°0tëÖ­À¶;j
¨âãã!‹add øàƒ T*1oŞ<8P«9ˆ™3gâÚµk¸~ı:T½Îúõë‘’’R¢çDô:íÛ×‡T*Æ‰7Jt^VV.†Û33#lØ0FFÒRJXr_|áƒš5+aüøP(*fÇ!muíÚüU*¯Óşı—P§NÔ¯ï¤ó±ß„DRq;PåkØ°6l†#G®aæÌ}BÇ!zcr¹Ÿ~º×¯ÿ‹Ÿ]èİNŒ¤ÈÎÖÏŸ!‰„Ÿ^½~À…÷±gÏtèĞ@èHDDDDDDDDd@şøãêÔ©KKŞd˜ˆˆˆˆˆˆˆHŠ( ’èe*µZŒv "ÃæâbÏTÿO.—#11NNÿ-ö755Å†ğõ×_ÃÕÕkÖ¬Áîİ»aff H$èŞ½;RSSÑ½{w­æ™>}:¼¼¼àããƒÖ­[ÃÙÙ‹/ÖêÜ‘#G"._/Òssc´n]‘‘QZŸ£Tª0vì6<x€­[GÂÚÚ¬–œ‘‘?ü0×¯?ÁŠÇ„£×ºwo†øøtœ;­Óq
ÂÃ¯¢gÏwu:îÛ‹ÅP*Ùu©M›ÚX»v0vì8‡…	‡¨ÄT*5&NÜ‰³gï`Û¶‘hØ°Z¡ÇËôògH"¡ÄÄÄ£[·•HHHÇĞ¬™‹Ğ‘ˆˆˆˆˆˆˆˆÈÀüñÇ]´lé&t"""""""¢r£ĞöúÚ*;[…Bssc¡£½177œ9s[èzA&“áĞ¡W“÷ïßıû÷/ò<;;;øûûÃÊÊªÀvµZ]äã%K–`É’%…÷ºó^·¯°ÇDÚğööÀœ9aÈÊÊ…©©Q±ÇÏŠ_½…½{ÇÂÅÅ¾–\:U0sæ'˜;7íÚÕå"á"¸¸Øãwj`ÿşËøàƒ::÷ÿ»‰„„tëÖDgc¾-‰D\á;PåóòòÀwßõÅÄ‰;aii‚ÀÀBG"ÒŠZ­ÆŒ¿àĞ¡«Ø²eš7w-òXcc©^şI$„K—b0dÈ8;ÛaË–‘°··:˜¬¬\üı÷cş¡ĞQˆˆˆˆˆˆˆˆÊB;PI‘“#/ë,ÅÊ¿£¹‘Q¡u_DÁİ½2şı7éé9BG18ÙÙÙ¸wï6nÜˆ#F‡èyy5Dv¶gÏŞ)öØµkÅ¦Mg±|y€Ş%öÚµ«‡qã¶#--[è8zËÏ¯)ºªÓBƒKhŞÜ5jØélÌ·%‹ R±€*_ïâ›oz`Á‚p¬[÷«NÆ”Jó®‰ ‰*ô#£Ê06®!x}ø“ yo¼­aÇóX½z Úµ«÷Úc¥ì@EàĞ¡«èÕë4oîŠ_~Çâ)""""""""z#¿şzJ¥
­ZÕ:
Q¹QD*)ÒÒ²Ê:K±rs•  ™L"p¢7W§Ne¨ÕjÜ½ûÕ:Aùã?àïï1cÆà£>:Ñ«\Ù×@dd:vlXäqÿûßMÌ›†Y³|áç×´¾‘H„åËû¢C‡Åøê«÷:’^ò÷o‚  ƒ8uêøøx¾õx™™¹8vì:¾úª«ÒéX,†JÅ.}/2¤5’“30gN¬¬LÑ§O‹·¯uëÖEnn®®={î"..ãÆı=µ¢‹ÅğòòzëqÖ­û?üpË–õÁ'Ÿ4*öø¼›p°€Š*¶õëOcÎœPúæÎõƒX,:¨°°¿Ğ²¥-…BDDDDDDDTnY@¥‹ßäò¼*##P‘árv®cc)nß~ÆªjÛ¶-…A¤ŞŞX¿şW¨T½]\ûäI·£k×&3Æp
íí-ğİw}1pà:|ôQ}tëÖDèHz§rek´háŠĞĞË:) :räoäæ*´*p(K‰J%¨^6i’ÒÓs0uêØÚšÁËËãÇ’H$èÖ­›Ó®K—öB$ŠC¯^½„R.ìŞı'æÌ	ÃìÙİğVçËô²‹1QYP*UøúëıØ¼ù7Ì˜ÑãÆu:°¬¬\?~³fù
…ˆˆˆˆˆˆˆ¨\¶1oñ›şPåææe’É
­û"2‰µj9àÎX¡£‘€¼½=Ÿ¿şzğÊ¾Ü\FÜŒÊ•­°tiŸ²÷–Ú·¯ßÇ—_îÅ“'IBÇÑK~~M…´´ì·+$äÚµ«;;s$Ó‰D•J%t½4sæ'x£FmÁ‰7„CTÀáÃcÊ”İøâŒÕVëóŒ%šŸ×ˆ*’ÌÌ\¶;wÇ?dñ½µcÇ®#;[Îß:
Q¹Rh•‘;P•¦Úµ«àömPUduëV««""¢^Ù7cÆ>DGÇâ§Ÿ†ÀÌÌH€tooî\89Ù 0p;”JÑ¼Ì×·1T*5}õë_		é8sæ6zôh¦£dº#‘ˆùµ/‚H$Â·ßöD@@¶Ç³ˆŠôÃéÓ·0vì6Ü“&y•è\}½	Qizş<=z¬ÂÅ‹1Ø½{ºveçM""""""""z{ë×Ÿ··,…BDDDDDDDT®Z@eb"ÕË»‡ÿW@ÅTdØj×®ÌTD/¯†ˆŒ¼V`Û¾}ñóÏà»ïúÂİİQ doÏØXŠ•+ûãòåX³æ”ĞqôÚ¶­‹ĞĞËo5ÎÁÄD†ê(™îˆÅ"P½†H$ÂÂ…=Ñ»wŒ±	'Oş#t$ªà.^¼aÃ6ÂÏ¯	æÏ÷/ñùúz¢Òrûö3øú#%%ND‹µ„DDDDDDDDDåÀß?ÂÅ‹÷1bÄ‡BG!"""""""*wªU~Q—LÆTdØêÔ©Œ‡ôòsFDeÇÛÛÑÑÏq÷îs @TÔ|ñÅŒÛ]º48İÛóğ¨†©S;añâ#øë¯‡BÇÑ;~~Mñë¯·ŸşÆc„…]——LMõ¯S™X,‚J¥:†^ËïDåëÛ#GnÆÙ³w„DÔÿbÀ€uøğÃºXº4 "‘¨ÄcK‘“#/…tDúçâÅûèŞ}-qğàDÔªå t$""""""""*'~úéğğ¨†–-İ„BDDDDDDDTîÚÊÉØX¦—‹ßØŠÊ‹Úµ+C©TáŞ½ç¨_ß©ÌæŠŠBïŞ½Ël>ÎåË—Q³fM¡cP1š7w…9"#£0thŒ³ÍšÕÄ´i…¦3cÆ´Ç¯¿ŞÂ¸qÛpìØ˜›Iox{{@&“âğá¿1hP«Ÿÿôi2.^¼qãÚ—Bº·'‘ˆY@¥‰DŒàà¾P«Õ<x=¶m‰V­Ü…EÈıûqèÛw5ª5kA*-ôÅ21‘!==[ÇéˆôÏÁƒW0aÂtèĞ «V€‰‰LèHDDDDDDDDTNDG?ÇÁƒWÜOè(DDDDDDDDåR¡«ãLMeÈÌÌ-ë,ÅÊÍÍ+ b*2tnnJÅ¸s'¶ÌæìÚµ+Ú¶m[fóé»´4bb¬„Qjš6mŠşıûƒŠ!‘ˆÑ±cCDFFaşüˆ‹KCpp?H$o¶x]‰Å"¬\ÙÉÉ™˜?ÿ€ĞqôŠ¹¹1¼¼bß¾‹otşW`aa‚¶mëê8™nˆÅb(•*¡c„¼"ª~èĞ¡>†Ysçî
‰*ˆ˜˜xôìùjÖ´ÇæÍÃßêF"»ÎQù¦V«|£GoÅ°a`íÚ!,"""""""""Z´è0Üİ+ÃÏ¯©ĞQˆˆˆˆˆˆˆˆÊ¥BWÈYZšèåİÃår @&c*2l2™5kÚ—iU§NĞ©S§2›Oß8qƒ­GhèR89Ù‡*0ooŒ±	/Æ`õê¨VÍVèH:W¥Š5–.íƒ‘#7£}ûúğòò:’ŞèÑã]¼11ñpq±/Ñ¹ü…N<õ¶3§D"bU	H¥b¬^=ãÇoÇ€k±aÃP´kWOèXT=|˜€^½~€££%¶o	SS#¡#é­œ&Oş^APPÒZèHDDDDDDDDTÎ\½ú‡ÿÍ›‡C,	‡ˆˆˆˆˆˆˆ¨\*´Å………	
²²ô«•\×ÊÈˆ¨ÈğÕ©S·o—]ôÁu`aaŒÈÈkBG¡
®iSg¨Õ€§gµr}7¹ÎßA¯^ïbòä]ˆM:Şh×®,°oß¥÷äI®\y„nİš”R²·'‘ˆÙ¦„d2	V¯ˆ®]cğàõ8|øo¡#Q9õï¿ÉèİûGØØ˜açÎOaeeª“qÕüÈS9›Š=VáøñØ¸q8‹§ˆˆˆˆˆˆˆˆHçÔj5æÎÃ»ïº cÇ†BÇ!"""""""*·
- ²´4 ¤¥å”i˜âäææw b¾Úµ+—i**ÈÈHŠ>ª‡#G¢„BÜìÙaÉ$°³³:J©
êkk3Lš´j®²×uÈÏ¯)öî½P¢×$4ô2¬¬LÑºuíRL÷vÄbT*v *)‰DŒåË0hPk|úéìİ{AèHTÎüûo2zö\cìÙ3¶¶æ:W$âQ©ü¹qã_øú#11áá“ğñÇ„DDDDDDDDDåĞ®]àÂ…û˜?ß_è(DDDDDDDDåÚk¨ÒÓ³Ë4Lqär%$1$’Bc”Úµ+ãîİçP(¸¸\(>>8>ÉÉ™BG¡
*4ô2¸‚Áƒ[áüù»ÈÌÔ¯ÎºfnnŒÕ«à÷ß£±qã¡ãè=›ãáÃ\¼£õ9aaá“OéuQ¹X,†RÉB¹7!‰0oFü“'ïÂ®]‰Ê‰§OóŠ§LMeØ³g¬ÎŠ§ˆÊ£C‡®¢k×¨VÍáá“P»ve¡#Q9”˜˜  pŒñ!Şy§†ĞqˆˆˆˆˆˆˆˆÊµ×P¥¦f•i˜âäæ*õz¡0QIÔ©Sr¹Ä¥Âjß¾D"¿!tª€’’20kVj…ñã;B.Wâôé[BÇ*u;cÂ„1şAüóÏ¿BÇÑÕP¿~UüòËE­‰‰GTÔtëÖ¸”“½‰D¥’EÂoJ$áë¯»aüøñùç»±yóoBG"›‚=€±±{öŒ…î‹§Ø]ÊµZÕ«OàÓO· {÷f¥öy!"ú?öî;¬É«ø„L* ¨¼â¨«*Á‰{W[m¸ªÖÖÚ¾Ö:ZW[Ñ¶j­£U‹»Ô¨¨Uë¶V‘¡â({%ùıá¯¼µÊ9	¹?×åuIÆ9wÈ‘œïó%""""""€O>Ù33#Ìœ)…ˆˆˆˆˆˆˆ¨ÊÓ©T, ¢ªÃÅÅR©×¯'‹¢·,-MĞ¾}#„‡G‰BzháÂ}00böì¨Q£¼¼ê""âªèX1uªš5«ƒI“6#7·@t­Ğ¿¿7BCÿDNN~‰½„êÕ«¡m[$+?™L¥’T5kV fÏî9svaùòÑqHGİ¿Ÿ‚¾}WÁÀ@ŠíÛ'¢zõjjŸC"QûD——W€©S·âË/`Ş¼@,Y2ˆ¿ƒ """""""¢J³{÷E„†^ÂâÅƒ`nn,:Q•÷ÚªjÕ^P¥§çj4LIT*7æQ•ajj''[\¿şPt½&—{âèÑ8dgç‰Bzä¯¿î!$ä,>ÿ¼/,-_¼çÊå8x0U¿àÄÀ@Š•+‡#11Ÿ*:Vèß¿%23óJÕï·ß.¡W¯æ00xí2NkÈdR(•ìF£“&ùà«¯†`ÅŠƒxÿı_ôâç©ÏÍ›Ğ·ïÊÂÎSvv•6P‘.KNNCß¾+qèP¶n‡1c:‰DDDDDDDDDUØİ»O1{öNŒÛ	]º¸ŠCDDDDDDD¤^»óÖÀ@
SS#¤¥ek:O±$	7åQ•Ò¤I-ÄÅ=C¯x"77'N\…ô„B¡Ä¬YÛÑ¾}#ôîíUx{@€'RS3qñâqá4¨nİêXºt06nüƒ]à Ô¬i…açÎÅ>.>şbc¼tîh+‰D…‚7u<¸5Ö­{¡¡—ğî»JÕ­ŒèÚµ‡0à[ØÛ[b÷îI¨YÓ²Òæ’ğJ¤Ãbb’Ğ³ç7HMÍÂŞ½SÑ±ccÑ‘ˆˆˆˆˆˆˆˆ¨
+(PbÒ¤Ípt´ÁÇ÷‡ˆˆˆˆˆˆˆHoÙºÀÆÆ©©YšÌR"‰äE*¢ªÂİİ±±, ÉÎÎ^^uÆÒŒõëOàÚµ‡X¸°ÿK·×¯o‡†í¡?çb¯^-0xpk¼ÿ~REÇnÀ o9ƒÇÓ‹|LhèŸ°··@«Võ5˜¬|d2)
vJR'??ìÜ„óçocàÀo‘šš):i±¿şº‡~ıV¡aC{lß>66æ¢#i¥ıû/£W¯hØĞaaïÃÅÅ^t$""""""""ªâşûßİˆMÂÚµ£all :‘Ş(²€ÊÖÖ\ë6eJ¥R(•, ¢ªÃÍ­6nİz„ÜÜÑQôš\îƒ£QPÀşT¹=JÇòåá˜<Ù÷µ›sårO„‡_LœúÁŞŞ“'oÖûb›îİ›ÁÄÄ¿ıv©ÈÇìİ{½zyA&+r	§5d2	”Jış7­ÿùO]ìŞ=	<Gß¾«”ôLt$ÒB§NÅcĞ ïàí][¶ŒCµjÆ™—» ]¢R©ğí·‘7nú÷o‰Ÿ~VVf¢cQr›6ÂW_áÅ|ˆˆˆˆˆˆˆˆ4¬˜ªjHIÑ®* à<ªJÜÜPP ÄÉ¢£èµîİ›!55çÏß…ª¸~ƒ­m5LšäóÚûårÜ¹ó×®=Ôp2qÌÌŒ°fÍ(\¾|ß|sHt¡LMĞ½{3ìÜyáµ÷ÇÆ&áúõ‡èÓ§…†“•T*…BÁ…[ehÜ¸BC§  ƒÇn–ô?aaQ6lüü<ğãïhìê¥yy¼R*éŒ¼¼L™²‹À¼yX²de¢cQwîÜ-|øáLŸîŞ½½DÇ!"""""""Ò;EPÙØ˜!%%C“YJ$‘HxUsªR4°ƒ‰‰!bb’DGÑkõëÛ¡qãZ…ª°¸¸Ø½û">ú¨LL_û/¯º°··@D„~u¡ru­O?í…¯¿ÀÉ“7DÇjÀ o\¾|ÿµ1{÷^†ƒƒ5Z¶¬§ù`å “IÙª9:Úà×_'ÃÑÑÁ8~üšèH¤6l8‰÷ŞÛˆaÃÚ 8x84×­.77¿È÷7"m’”ô+ƒ­[ÇaÌ˜N¢#‘ˆ„·ß^LŸî':‘^*¶Ujj–&³”H*•@©dU2™ÕD\¨D“Ë=v…EšTi/>€&Mj£gÏæE>F*•À×·)""ô¯˜ïí·;ÂÏÏS§nEjªöuÀÔ”víÁÁÁ{öüùÊ}ûöı…=›C"‘HVvR©„¨*™µµ¶oŸ??¾7ş!:	¢R©°|yT²Ù²    IDAT8>ùd7¦Më†E‹@*ÕìÏŠœœ³€Š´ÛÄÃß9²³ó°ÿ4tèĞXt$""""""""ÒIIÏ0dÈ÷hĞÀ+VÓ™Ïzˆˆˆˆˆˆˆˆªšb
¨Ì’¢]˜¥Rv ¢ªÇİİ11¯v!Í’Ë=‘Šèh³‘úıõ×=<?îQâ†vüõ×}<xğLCé´Ç×_L&ÁÔ©[õöı^*• oìØq
Åÿº7ÅÅ=@|ü#ôèQt¶a*Í04”aÅŠaøè£î˜3g>ıt/8 gòó˜<y‚ƒ#8xfÌÉ‘››cc!s•ÆæÍ§1lØjx{×ChèTÔ¯o':é””Lº&øùçwajj$:‘Ş*¦€Ê))šÌR"òóz»©šª&W×ÚˆeÑhÍ›×ƒƒµ^vş¡Ê·hÑ>x{×ƒ{‰}óÍ&077ÂáÃ1H¦]¬¬Ì°rå=§×tğÆÃ‡Ïqút|ámû÷_†½½Z¶¬'.X½è@Å*MH$
òÁ÷ß¿…Í›Oáİw7 ;;Ot,Ò€ÌÌ\ŒµW±qãXôïï-,KNN>LLØŠ´Off.Æß„Ù³wbÖ¬ ¬_ÿ,-MDÇ"""""""""=––ƒ‘#×"''!!ãamm&:‘^+²€ÊÆÆ©©YZuû¿¯hŸ¯œ„H}Üİğøq:<Ñ®‚E}#‘HàïïX@Eêuüø5œ<y~Ø½T722@Çqµ’“i§6m`Ú´n˜7/ÑÑ‰¢ãÑ¨QM4o^;w^(¼mÿş+èÑ£E‰Ì´‰L&…B¡=ëH}Ğ»wlİ:§OßÄÀßáÑ£tÑ‘¨%'?G`àJÄÆ&aÏÉèÒÅUhÜÜP‘Ö¹sç	zõZ“'o`ëÖq
òD¢;ï¥DDDDDDDD¤»ÒÒ²1tè÷HJzñ¨YÓJt$""""""""½WdUP(”HMÍÔdb½( ÊËcUîî À.TZ@.÷DllîŞ}*:
U!‹@—.®h×Î¥ÔÏñ÷÷ÄÉ“7‘‘[‰É´×ûïû£uëúxï½Mz{ğÆ¾}—‘™™‹[·#.îzôh&:V™ÈdRvà7bß¾iHIÉD÷î_!**At$ªQQ	ø
ìßÿ><<EGBnn~á/ˆ´ÁáÃ1Ë¿‚¡¡aaÓÑ±ccÑ‘ˆˆˆˆˆˆˆˆHO¼(Zää4ìŞ„úõíDG"""""""""S@U«Ö‹«ß$'§i,LIe €¼¼ÁIˆÔ§zõj°³³@L¨DkÛ¶!¬­ÍÎ.T¤§NÅãÒ¥{˜93 LÏëÖÍJ¥ÇÅUR2í&•J°bÅ0<{–…¹sGˆ~ıZ"?_ğğ(ìİûlmÍÑºuÑ±ÊD*•@¡PŠ¡—4°Ãï£aC{ôî½»v](ùI¤3öï¿ŒÀÀ•hÒ¤BC§ÀÁÁZt$ @NNŒÙŠÄS©TøöÛHŒ½~~M:uêØŠEDDDDDDDDz"%%ıû‹ÇÓ±k×$Oi‘"¨jÖ´ <|ø\caJò÷ÍY@EU››ââˆ¡÷eğõug©Íš5ÇĞ¦Mxy9—éy66æğö®ˆˆ«•”LûÕ®m+†!$ä,öìùSt³±1G—.nØ¹óöï¿Œ=šÃÀ Èe›V’J¥, ÈÚÚ[·ÃØ±obÊ”­X¸p”JvÓuëÖÇ¸q›Ğ¿KüôÓ»°´4©Pnn>LLX@Eb¥§çàwÖcéÒp|öY ‚ƒ‡ó¼$""""""""¹?}ú###»vMBİºÕEG""""""""¢(r'®……	ÌÍ‘œ¬=Tì@EU•›[mv Òşş8ş6=J…tÜíÛƒ÷Şë\®çûû{àĞ¡häç+ÔL‡øúºcôèö˜5k;nß~,:Æà'®#::	=z4§Ìd2	
ìˆ$“I1gNO,]:k×Ã¨Q? --Gt,*‡¼¼Lºóæ…bŞ¼@,Y2¨ğÿFÚ"7· ğ‚D"ÄÄ$Áß9._¾]»&aìØN¢#‘‰‹{€ÀÀ•04”aÏÉìŠNDDDDDDD¤…ŠmeP³¦%<Ğªÿu ÒßÍäT5¹ºÖÆµkQPÀN¢uíêccCDFF‹B:î‡~‡““-üüš–ëùr¹'ÒÒ²qöì-5'Ó-sçöA½z5´YïŠÉüı=`llccC¼ñ†‹è8e&“I¡Tò}MÖ»váÊ•ôíŒ{÷ŠDe’’‰!CV#,ì
6lƒ1c´³($##ææÆ¢czü8½{¯@­ZVŸ–-ëŠDDDDDDDDDzäÔ©x£aC{„†NA­ZV¢#Ñk[@U«–=JÓT–™˜ rrò'!R/wwäåèe‡mcjj„#<üªè(¤Ã?ÏÂöíçñî» “ûV[¤ºu«ÃÕµ6""ôû\422ÀÚµ£ŸŒ%KÂDÇÑ(CCÌÍ`ll ufJC*•B©d*máí]ááÓadd€€€¯qôhœèHT
QQ	ğ÷_ää4„…M‡¯¯»èH¯•••‡ÜÜØØ˜‰Bz¦ @‰?ÿ¼‹k×¢_¿–Ø¶mìí-DÇ"""""""""=òË/g0tèjtîì†-[Şƒ……‰èHDDDDDDDDT„;P=|¨=TffF €¬¬\ÁIˆÔËÕµ6e¸z5Qtà‰ß¿†Œş¬¡òùé§SÉ¤4¨u…Æñ÷÷@DDT*ı.B©_ßóæâûïàøñk¢ãhÌƒÏğôi&?ÏÒÉ÷©T…‚¨´IíÚÖøõ×)ğ÷÷Àˆk±pá>¹i±;/ OŸ`4h`‡ıû§¡aC{Ñ‘ŠôìY ÀÚÚ\pÒ'OŸf`Ø°Õ¸ví!\]kaÉ’A:YpLDDDDDDDDºI¡PbáÂ}˜9s;Ş{¯3¾ûn$?EDDDDDDD¤åJì@õğásMe)‘™™1  33Op"õ24”¡qãZ¸z5Atàç×J¥GÆŠB:H©TaÓ¦?0bÄ¾Âœ¿¿Rû@Mét×Ğ¡mÑ³gL¼ÉÉÚSÜ]™öî½cÔ¯_;w§Ìd2	”JPicc|õÕ,^<k×Ã!ßãÉ“Ñ±è

^|è>eÊà-[ÆÁÚZ»;;¥¦f ;P‘Æœ>}¾¾K‘˜ør¹'jÔ`×)""""""""ÒœŒŒ\¼óÎz¬[÷;‚ƒ‡aÎœJ%¢cQ	Š- ª]Û<ÓT–™›C"‘ 3“]a¨êñôtBT¨´9Zµªˆˆ«¢£:uê’’aèĞ¶«yó:¨]ÛááQjH¦û–/KKSLœø“^t6Ú¿ÿ2üü<Ğ¯Ÿ7vï¾ˆü|…èHe"“I¡P°»‘¶1âìİ;wï>…\¾şyWt$’’‰aÃVãÇcÅŠaX²dŠı/›VHM}ÑŠTTÙ”JV¬8„Aƒ¾CË–õ6çiTLLüü–!**¿ş:ıû{‹DDDDDDDDD¥Tìn¼:ulñøqºÖ,I¥˜˜"+‹¨¨êñôtDTT"T*n6×r¹'Ö¹‚o×®‹hÑÂ..öK"‘ [7wóı?ssc¬];
—.İÃW_EˆS©=JÇÅ‹wĞ£GsÔ
OŸfâøñk¢c•‰T*Õ‹B7]Ö¬Y„‡OGãÆµĞ¯ß*¬[w\t$½• ¹|9R±ÿû8°•èH¥öìY$	,-MEG¡*,%%o½õ–/ÇGuÇ?Œ†¥eÅº}•EHÈYôìù¬>Í›×‰ˆˆˆˆˆˆˆˆÊ Ø*gg[ @BBªFÂ”†¹¹‘Öt©“‡‡?ÏÒªï7}Ğéé¹8u*^tÒ!¹¹»‚~ıZªmLODE%àşıµ©ËÜÜ0o^ V¬8„cÇâDÇ©4û÷_†©©Ş|³	êÔ±E«Võ±sçÑ±ÊD&“°€JØØ˜cË–÷ğÁr|öÙ¯˜2e²³y±MÛ¼ù4zõZÆk!,ì}¸¹Õ©LRS3aii
™Lû»e‘nºté¾B\ÜìÙ3AA>H$¢c‘ÈÍ-À¬YÛ1cÆ6ş~ùe<ìí-DÇ""""""""¢2*¡€ª: àŞ½§	SææÆÈÊbU=M›:B*• **Atàädww„‡G‰B:$<<
YYyèİÛKmc¶oï>£¶1uİÈ‘íĞ¯_KL¼>§R„‡G¡kW7˜˜ ôFxxÒÒ²'+=©TÊ®Š:B"‘ (È7Å¡C1èİ;wî<K/dgçaêÔ­øğÃ˜0¡~úé]XY™‰UfÏeÁÆF÷r“öS©TX·î8ƒáêZ‡€–-ë‰EDDDDDDDDz$.îºwÿ
ûö]ÆÆc0~_ÊDÇ""""""""¢r(¶€ÊÜÜÕ«WÓª*33cdfòªøTõ˜™¡A;\½š(:
ı?¹ÜááWY @¥¶k×têÔD­Wœ322@çÎ®ˆˆ¸ª¶1«‚/¿[[s¼ûîäç+DÇQ«´´lœ9s…·õîí©TŠ={ş˜¬l^t âÏO]âëëÃ‡gÂĞPÿåcqeºuë1zöü‡Çà§ŸÆâÃ»C*ÕÍ:ÏŸgÃÚšT¤^©©™5jæÏÿ³g÷ÄÆcx‘Æ¨T*¬__¡Z5DDÌ@·nMEÇ""""""""¢
(¶€
 êÖ­{÷R4‘¥T,-MtªûQYxx8áêUv ÒHN~K—î‰B:àéÓüşû5ôïï­ö±ıı=pút<ßÿşÁÌÌkÖŒBLÌ,Y&:Z< èÚÕ­ğ6ôèÑÛ¶«Ì¤R)
¥èTF6Ø³g2zõj±c7`áÂ}üw¬aaQèŞı+ ,ì}øø¸‹T!©©Y°²2ƒªÓ§oÂ×wbb’°{÷$Œß‰n‘îyú4£GÿˆÏ>ûcÇ¾‰;ƒP§­èXDDDDDDDDTA%PÕ©c«U¨¬­ÍğìY–èD•ÂÃÃQQ, Òîî¨[·:ÂÃÙƒJõÿ][<Ô>¶¯ï‹«Ù9«ö±u™«km,ZÔß}w¤Juè
Bûö`iùr1ÂàÁmğ×_÷›$(YÙÈd, ÒUÆÆX¶l0/ˆ~ø#F¬EJJ¦èXUBAîÃ˜1ëÑ»·öî
gçê¢cUXròsÔ¬i):U
…Ë—‡cĞ ïĞ¬™š‰–-ë‰EDDDDDDDDz$,,
]º,Æõë±gÏdÌ™Ó††2Ñ±ˆˆˆˆˆˆˆˆHJÙJ»
¨?gUMÍš9!99¥‹BÿO.÷ÄşıWDÇ pôh,Ú·o33#µmii‚6m"<¼ê	©ËàÁ­1hP+L›öîß×™å•›[€ãÇ¯A.÷|å¾ví¢^½Ø¾ı¼€de'“I TªDÇ 
1â„†NÁÍ›àë»§NÅ‹¤ÓîÜy‚Ş½W`Ó¦“X½z–,Te>tOHH…“¯¾J“”ô~‡U«"1wn¬_ÿllÌEÇ"""""""""=‘šš‰‰Æ˜1ëÑ­›äÅ}ˆˆˆˆˆˆˆˆªš¨êÕ«»wŸjÍXv ¢ªÌÓÓ	‰W¯²•¶Ë=qûöcÄÇ?…´XAüq;7©´9är=‹ü|E¥Í¡«¾øb ­1~ü&?>¿ÿ‡ÌÌ<tëæşÊ}‰xcûöóÈË+®l$	”Jv ÒuÍ›×ÁáÃ³Ğ¦Mø>ıtÎŸ‰°k×øù-C~¾aaÓÑ»wÑ‘Ô*))Ö¢c‹ˆ¸Šnİ–áÉ“tìÛ7cÇv‚D"‹ˆˆˆˆˆˆˆˆôDdd||–âÔ©Ø¸q–/Ñ±ˆˆˆˆˆˆˆˆHÍJ, rq±GVVS5‘§DVV¦HMeUMVVfpr²ATT23sqæÌM¬YsÓ§‡hÍ÷ ¾iÕª>ìí-Æ.TT´n#--]º¸UÚşşÈÈÈe˜×011ÄÚµ£qãF2-Ú':N…„‡_ÅşãŒÚµ__ˆ0th¤¥e#22VÃÉÊN&“B¡Ğ|ªKK|ÿı[øæ›¡Øºõƒq÷®öt¨Õf¹˜2e¦LÙŠÁƒÛ`ÿşihØĞ^t,µzö,¹pr²…tPnn>ıtŞyg=||Ü>M›:ŠEDDDDDDDDzâÑ£tL˜ğFüo¾ÙÇÏ†ŸŸ‡èXDDDDDDDDTIJz@ãÆµ  7n$£NÛJT++3<-:‘Zåç+ˆË—ïÃÖÖ›6ı¥KÃ Tªşºıúµ„£#7¦jšT*OSDD\ÅäÉ¾¢ã–:v,ÎÎÕQ¯^J›ÃÑÑîîˆˆˆÂ›oV^§+]Õ –.Œ‰F«VõÑ½{3Ñ‘ÊL¡PâĞ¡hŒß¹ÈÇÔ®möí!$ä,<5®d2);PU1¶B‹Î?ş'øû/ÃâÅƒĞ§—Æs<y’¹s÷  àçW||2²³ó1nÜ¦ÂÛ$`êT?¸¹ÕÖxF øë¯{˜8ñg¤§ç`ãÆ1èÖ­©•-!áE‘?×©TV×®=ÄÄ‰?#11ß?½{kşç	é'¥R…-[NcáÂ}°´4ÁÏ?¿wÑ±ˆˆˆˆˆˆˆˆ¨’•X@eiiŠš5-qız2ºv­¼Î¥ecc†çÏ³ R© ‘HDÇ!ªŒŒ\ü®\I€B¡„Á‹¦pÿÜ¬P¼ø»³³øF}%—{ $ä,<xVdWÒoGÆÁÇ§òß#årlÙröç{àkôéã…“'o`úô4mêˆºu«‹T&çÏßÆÓ§Ë‹/Œ2¤5¦LÙ‚ääç¨YÓJCéÊN&“¾‡QÕÑ¨QM8ğ>,Ø‹	~Bdd/SS£×>>''††2Èd%6¾-µÜÜ|üúë%¨T¯v8»sçÉK_ş ÍP©T*üøã	ÌŸÿÚ´iˆ•+‡iõ÷jEıİ%ÕÁk$*•J…õëO`Á‚½ğğpÂÁƒ3áì¬[ïÙDDDDDDDD¤»nİzŒ?Ü³goaÔ¨øğÃî¨VÍXt,""""""""Ò€RídlÔ¨nÜH®ì,¥bmm†‚%ÒÓsEG!ª0cc<~œ^¸¸ @ùRñÔß¤ppàUıEyóÍ&077BDD´è(¤…>Í@tt":wv­ô¹üı=ñğásDE%Tú\ºjÁ‚~pv¶Åøñ›—W :N™„‡G¡Q£šhØĞ¾ØÇ4ƒ¹¹	víº¨¡då#•J¡P¼ZàBºÏØØ óç÷Å?¾ƒÃ‡c —…ØØ¤W—™™‹N¾ÄÔ©[Õ:¿££¼¼œ!•_Hjcc†ví\Ô:w~¾|°—.İ{íı§cøğµ˜?ÿ7L™â‹ñUºx
xQ@U½zµ"‹èˆşéñãtŒµóæ…bìØ7±{÷$O‘FddäbÁ‚½èÒe1²²ò6óç÷eñ‘)UUãÆ5qıúÃÊÎR*vv €'OÒ'!ª8CC–,¥²øæöö–…İ©HóŒŒĞ¹³+ÂÃ£DG!-ôÇ7 “IÕ¾Iÿu<<Q§-""®Vú\ºÊØØ k×ÆíÛ1oŞo¢ã”IDÄÕ»O/^c¿~ÿÁÖ­g^ÛG[H¥’ßßH·xâĞ¡™°±1G÷î_cİºã/İÿé§{ğàÁ3ìÙó'vì8¯Ö¹hUl'>CCôïï­ÖÎW °xñlÙrï½·YYy/İq;/Æıû)Ø·ofÌ—XäU$&¦ÂÉ‰…şT²® K—Å¸~=»vMÂœ9=ah(‹ˆˆˆˆˆˆˆˆª8•J…]». cÇEØºõæÍë‹½{§¡iSGÑÑˆˆˆˆˆˆˆˆHÃJÙJ{
¨jÔxQ@õø1¨¨jèÜÙİº¹ÃÀ èÍƒõëÛi0½\î‰Ó§ãñüy–è(¤e._¾FjÂÜ\3W§óõmŠğpP§^½Xºt06l8={ş§Tbb’p÷îÓRPÀàÁ­qëÖc\¼x§rƒU€L&…RùjWEªZm°sg&MòÁ¼y¡3f==ËÂÁƒWr
Å‹sàÃwàæÍGj›·W¯æÅŞŸŸ_€ÀÀÿ¨m> ˆŒŒÁ÷ß <|øì äæàÓO÷àwÖÃÇÇááÓáéé¤Ö¹µYbb*Y@EEËÈÈÅ¬YÛ1vìtíê†ÈÈĞªU}Ñ±ˆˆˆˆˆˆˆˆHDG'¢oßU˜:u+:vlŒãÇgcôèözqñ+""""""""zU);PÕBzz’“ŸWvU¯^R©¥‰B¤6‹€Löú_ÒÊĞ°!¨Dóõm
 ˆŒŒœ„´Í•+÷Ñ¬YÍ'—{ 66	÷î=ÕØœº¨W¯xûí˜5k;âãÕW´QYÂÂ¢P³¦Z´(İ¹Ô¬Y¸»; $ä\%'+?™LZX<CU›3fÈñË/ãñçŸ÷àë»S§n-ì¥R© P(1nÜ&äç+Ô2gõêÕĞ¾½K‘¦màåå¬–¹€SAA›¿V(”Ø´élÙr=z|íÛÏaÕª®±‚Zmqûö8;ÛŠAZêÒ¥{ğ÷_°°(lØ0F/¿GˆˆˆˆˆˆˆˆHó>|3¶A.ÿ
J¥
aaÓ<5jTˆˆˆˆˆˆˆˆ*UU“&µ  11*5LiHacc'OØŠªGGLìûÚMÀ‰ÎÎÕ¤¢²´4Áo¸ <<JtÒ"*•
QQ‰- jÛ¶!¬¬ÌÁ.T%™;·\\ì1aÂOÈÉÉ§XááQğ(,8)Áƒ[#4ô23s+1YùI¥Pé™áğá™É¤ÈÊÊƒJ¥*¼/?_ë×bñâj›¯o(•ªWn74”aàÀVeú~*R©ÂÄ‰?¿òš$à“OöÀÄÄ‘‘³Ğ·¯z;^é…B‰7’áêê :
i™ü|–/GïŞ+àìl‹Ã‡gÂßßCt,""""""""ªâÒÒrğå—ûÑ¾ı"œ8qß|3¡¡“áéé$:iRPÙÚšÃÑÑW®Ü¯ì<¥booÇ3DÇ R«I“|àà`ıJ'ªü|¨´„\î‰£Gã›[ :
i‰»wŸ"--ÍšiîCCCºvueU)`ÍšQHHHÅGí§H		©ˆ‰I‚\îY¦çàü|öï¿RIÉ*F&“¾¶¸…ª¶ƒ¯"!!åµ¦

”øşû£8|8F-s4ƒÁ«ÿÉÏW O/µÌ Ë–…ãÜ¹[((xù5)•/:k¹¸Ô„““ÚæÓ%·o?ANN>ÜÜj‹BZ$::rùr¬^}‹õÇÖ­ãP³¦•èXDDDDDDDDT…åç+°yóitì¸›6Âôé~8qâcôïï­¶‹m‘î+U 4o^Gk
¨jÔ°À£Gi¢c©•‘‘–,…âåÍæ*•
uë²€Jx ++Ç_…´Ä•+÷!“I5¾qÜßßgÏŞBJJ¦FçÕEÎÎÕ±fÍ[Øµë"6múCtœ×Šˆˆ‚……1ŞxÃ¥LÏ³±1G·nM±mÛÙJJV1R©„TzæŞ½§øôÓ=PóÏ.‘ S¦lÆ£Gï&[­š1üü<şUD%AãÆµ
;èVÔ©Sñ>Tä¹\P Àç©¢0]›™LŠFjŠBZ  @‰o¿D÷î_ÃÜÜÎÀÈ‘í¸A…ˆˆˆˆˆˆˆˆ*J¥ÂŞ½áÍ7¿Äœ9»àïï“'g#(ÈÆÆ¢ã‘–)uU³fupåJBef)5;;<~\ñM—DÚæÍ7› [·¦00½t;¨´CÍšVhÑ¢ÂÃÙù‡^¸r%×„©©‘FçõñqƒL&Å‘#±WWuêÔÓ¦ùá¿ÿİƒsçn‰óŠƒ£Ñ¥‹e%?ø_n3gnáÎ'•¬b¤R)
¥è¤!*•
“&m.±K£R©Bffvî9Â    IDAT¦NİUq•V¥Ô¯_Ë—Î3)jUáqàÉ“Œ·±Äâ‰˜:u+=ËRË¼ºäÚµ‡¨W¯LLEG!Á®_ˆŞ½W`Ù²pÌš€_ŒúõíDÇ""""""""¢*ìÂ…Û\‰	~‚§§Nœ˜%K¡zõj¢£‘–*C•SñäIFeæ)•Zµ¬œÌTT5-ZÔ2Ùÿ6êV«fKKS‰èŸärODDD±(€  ÑÑ‰ğôtÒø¼ææÆh×Î,æ+­éÓıàããqã6iÕ"33gÏŞ‚¯¯{¹ß¥‹+j×¶ÂöíçÕœ¬âş~/c*ı™™‡‡ŸC¡PÂĞPVlÑQ~¾'N\Ç?¯ğ¼>>n055.üZ¡P¢W¯W©TaüøMHKË)Õ{~JJ&Ö®ı½ÂóêšØØ$wa$í¢R©°yói|‰8tèù@*e×)""""""""ª±±0räZôîssc<8kÖŒ‚³3/JJDDDDDDDDÅ+S* ˆŠß…ÊÁÁII©¢cU
GGL›æ™ìÅ·g:üE¯6éÑ£9RR2qáÂÑQHÜ½ûõêÕ2·¿¿‹+±Û½ ‘Hğõ×C`jj„  ŸQP EGÆA¡P¢K·r=_&“¢_¿–	9«u…¿i[.ªÕªãÜ¹ÿâôéO°patéâZØUíuİÕ”JæÏÿ—.İ«Ğ¼FFèÕ«Åÿm-Z8£NÛ
	 +WÆ™37‘Ÿ¯xíıw54”¡M›˜3§'F|£ÂóêšØØpue•¾ºuë1WbÎœ]˜:µBC§ÂÅÅ^t,""""""""ª¢ââ`Ê”-ğó[†ÄÄgøé§w±uë8¸»;ˆFDDDDDDDD:¢ÔT¶¶æpr²Á•+÷+3O©88XãéÓLäää‹BT)&Nì
GG €‹‹à4ôOØÁÅÅááQ¢£`*•
<ƒ“SÅ7ê—‡\î¬¬<œ<y]ÈüºÈÊÊ?şø6.]º‡/¾Ø': àğáhx{×ƒ­­y¹Ç2¤’“Ópâ„vP±•~©[·:FŒx›7¿‡¸¸EØ¼ù=Œİ¡°ØT&“ÂÀàÅ¹¡R½èò”™™[¡9ûõûòóH$0À»Â¯áìÙ[X¶,ì¥s×ĞP©T‰D77Œ×Û¶MÀõë_b×®I
òAíÚÖ[—dgçáŞ½§, ÒCJ|ûm$||– ;;aaÓ1eŠoá÷6‘:]½šˆwŞYŸ¥ˆ‰IÂêÕoáğáàëë.:éƒ²<¸Y³:ZQ@åèhS¸q½~}—T5IIIøã?DÇ®{÷šX½ú)²³Ÿ`Ç¢ãh%©T
???XXXht^¹Ü¡¡—0wnÎKÚåÑ£täæ;jZÍšVhÖÌ	WáãÃˆJËÍÍË–Æ¤I›Ñ¼¹3z÷n!,‹R©ÂÑ£qxï½7+4NƒvhÕª>BBÎ¡sgW5¥«8‰D€¨ÔéÜ¹s¸{÷®èeæáxx4Fjj]ÄÅ=C\Ü3ÄÆ>Cn®÷ï§`ôèo0hPƒr¯Rææ†ÈÎÎ‡Ju¯Bë¦ÌÌ||ñÅe(*H$/Æ¶µ5†»»57¶FãÆV055 ‡/ã·ß.—{.M²µµ…ZÇ¼ví!”J¨ôLlìÌ˜‚èèD¼÷^gÌšğÚ.sDDDDDDDDD“„+aß¾Ëpu­Õ«ßBÏÍ? """"""""*«2Pyy9ã‡~¯¬,¥ö÷fõÄDPUE‹-Â·ß~+:†V¨V­5BBîâçŸ“EGÑZk×®Å»ï¾«Ñ9årO¬Z‰˜˜$¸»;htnÒ‰‰©  ''1T àïïNâË/B*å‡E¥Õ·ïpáÂmÌ˜‚&Mj¡I“ZBr\ºt§£[·¦kÈÖøğÃHIÉ¬P7+ub*õëİ»7’“«Êš@CÃZ06®‹°°ìÜùW…F³°h™ÌcÆ|S¡qŒŒamí¼¼$äæŞC^Ş}<xèè
«RSSam­¾.Y/Ş••Yaw1ªÚòóX»ö–,	C³fupøğhÔ¨¦èXDDDDDDDDT]¼xÁÁ‡pøpÜİX8EDDDDDDDDj#-ËƒÛ´i€GÒqçÎ“ÊÊS*¶¶æ055*Ü¼NU‹B¡@×®]¡R©ôşOzúYäå=C[ÿT¯^?G½¼œQ»¶5ÂÂ¢4>7iÄÄTÈdRÔªe%,ƒ¿¿'?NÇ_İ–AW}öY <<1fÌz¤¥åÉpèP4œ«£qãŠpõêÕÆÆıSÉÔC&{ñA¦RÉTêRPP€ï¾ûNøû¯zş(‘——„ôôÓÈÈ¸TáñÒÒN#5u…ÇÉÍM@ròHMCVV4

Ò´àXUìOdddáù£NçÏßA«VõXÀ«.^¼‹nİ–á«¯bÖ¬ üúëdO‘Ú]¸p£F­C¯^ß %%7ÁÁƒ3Ğ«WO‘Z”©€ªysg˜šáÌ™›••§Ô¬‘”ôLt"ÒC‰~~MÎ*}–
{{KÊ„eps«úõíqUX]eh(Ãš5£‘™™‡©S·@¥Ò|—¤C‡¢ÕÒ}
 ÌÍÑ£Gs„„œSËxê •¾Xf*, "ªŠ.\¸oïú¢cP%ÊÌÌÅÜ¹¿"00µjYáØ±äSØaˆˆˆˆˆˆˆˆ¨¢T*~ÿıü½{#==Û·OÀŞ½SÑ­[SN‘Z•iç“¡¡^^Î8{öVeå)5kv ""aärODG'âŞ½§¢£ ‰‰©pr²İº¹³˜¯œìí-ğÃ£päH,¾ûîˆFçNLLElìtëæ®¶1‡iƒ¨¨DG'ªmÌŠø{ƒ½B¡ùâ4"ª\‰‰©HJz†–-ë‰B•äàÁ«èÜy1¶o?eËã—_Æ¡N[Ñ±ˆˆˆˆˆˆˆˆ¨ŠÈÏW`ûöóğõ]Š¡CWC*•b×®IØ½{:th,:UQe¾tt›6´¢€ÊÙ¹:îİKƒˆôT»v.°²2cç=–šš‰5ª‰OÜ¸‘Œ[·‹¢“¼½ëãã{â‹/öãØ±8Í{ğ`4ÌÍÑ¶mCµÙ¦M¸¸ØkM*©ôÅU!ÙŠ¨ê9yòŒĞ²e]ÑQHÍ’“Ó0eÊŒı#şóŸº8qb6nÍ+ı‘Z¤§ç`İºãhÛv>ø`\\jbÿş÷±mÛ¼ñ†ú>3!""""""""zrPİ¹ó<«Œ<¥V¯^uÜ¹ÃÍâD$†¡¡]»º²óËÎÎ‡©©‘èhİº>lmÍYÌWãÆuF¿~-1qâÏë*wøp4:wv…‘‘ZÇ8°vï¾ˆ¼¼µ[2Ù‹Íö*;PU5Ç_CëÖ`bb(:
©‰R©ÂæÍ§Ñ©Ó8ş6¶n‡5kFiE±8é¾{÷báÂ}hÕj–,9€îİ›áôéO°fÍ(xy9‹GDDDDDDDDz¢ÌTŞŞõah(Ãùó·+#O©Õ«WIIÏ›+~ƒ0é¦øøør]I½4Ï»wïŞ~ûírÏ¡.¯›ÿïl  ‘H/"šVÌ_Qr¹'Î»§O3DG!²³ó´¢€J&“ÂÇÇTôå—Q«–Æİ€œœüJ+++§NÅÃ××]ícØ
ééÙZQÜ)•¾Xf²•náú¨lÏSÇÜÅÑÆµ’J¥ÂÜ@§NEG!5‰ND¯^ß`Îœ]4¨5"#g¡sgWÑ±ˆˆˆˆˆˆˆˆ¨
¸rå>¦LÙ‚á·ß.aòd_\¸0óç÷…ƒƒµèxDDDDDDDD¤gÊ\@effOO'œ>}³2ò”Z½z5 Tª4Ö)‚èunİº…5j¼rû¯¿şŠÀÀ@‰J¦ÍÙtM×®n00âğáÑQH€¨´£ó†¿¿.\¸ÇÓEGÑYffFøñÇ·qïŞSü÷¿{*u®ãÇ¯!?_®]İÔ>v­ZVèÒÅ[¶œQûØe%“±€J_q}TµÅÄ$áÑ£ttìÈ*]—ƒ¹s…\şŒŒpèĞLÌŸßffâÄ‰ˆˆˆˆˆˆˆHw)J8p}úC.ÿ
7n$cÕªøã9
ò¥¥©èˆDDDDDDDD¤§Ê\@ :4ÂÑ£qêÎR&õêÕ€D"Á;O„æ ı¦T*ñôé«E|„ŸŸŸ€D%ÓælºÆÜÜ:5AX˜øN/¤yÙÙy01ÑªÎ]ah(Ã‘#±¢£è´úõí<[¶œÁ/¿T^Ò¡C1ğòr†E¥Œ?bÄ8yò†ğ5ÒßTJ¥JhÒ<®ª¶ğğ(ÔªeOO'ÑQ¨œT*vî¼€N¾ÀÎ°dÉ@ìŞ=	×ˆˆˆˆˆˆˆˆtØ“'øöÛH´o¿ï½·&&†Ø´i,ÂÂ¦£wo/”k{
‘Ú”ë7T]»ºáŞ½§¸}û±ºó”š¹¹1jÔ¨&|s0‰WPP€¹sçÂÙÙvvvxë­·ğìÙ³ÂûŸ={†Ñ£G£FprrÂÌ™3‘““Sxÿ–-[Ğ°aCØÙÙaÂ„	ÈÊÊ ìŞ½055…³³3‚ƒƒ_™»mÛ¶ €Zµş·ÙğÉ“'077‡©éËWÎR©T˜9s&Z´h'O^œ·ùùùøøãáää!77ñññH$8räêÖ­‹“'OB"‘`×®]ğòò‚••>ÿüóÂ±‹çß^—íÈ‘#puu…••æÍ›Wª1‹:6çŞ·oÜİİagg‡   —÷¿5¿®ğ÷÷Àï¿Ç!#ãÕãMU›6P™™¡cÇÆg1_Eùùy`Ò$|üñ.\¾|_íã«T*9_ß¦jûo]»º¡vm+„„œ­´9JC*• `*Q¸>*ßú¨¤ãöOEÃÒñº×ş:Ú¶V:p 
H$¢£P9DG'¢oßU˜6m+:vlŒãÇ?ÂĞ¡mùïIDDDDDDDDåvşümıoïyXµêär?>Û¶M@·n•÷yQY•«€ªeËz°¶6Şé¢^½¸sçÕ«Û“~ùæ›o°{÷n8p GÁµk×°páÂÂû'Mš„„„œ;waaaˆˆˆÀâÅ‹ï_¿~=ÂÃÃ±ÿ~DFFbşüùHKKÃàÁƒÑºukÄÇÇã‹/¾ÀÔ©S‘’’òÒÜgÎ¼èPòğáÃÂÛöîİ‹^½z½ô8•J…?ü‘‘‘ˆŒŒD5  Ë–-Ãõë×qúôi?~§OŸÆœ9s
Ÿ·téR,Y²-Z´  lÛ¶GÅòåË1wîÜÂî%S\¶½{÷âÂ…Ø°a>ûì³Â¼EYšc³råJ„††bß¾}8xğ ¾üòË"ÿıŠš_Wøùy  @‰ãÇ¯‰B–SS#Ñ1
½(æ»†ìì<ÑQtŞ¬YhÛ¶!Şyg==JWëØQQ	HN~__wµûO2™ƒµFHÈYäç+*m’ü]@ÅTbp}T¾õQIÇíŸŠ:†¥£¨×ş:Ú´Vº?±±IË=…e òyş<Ÿ~ºrùWÈÍÍGhèTGõêÕDG#""""""""”›[€;Î£[·eèÓ'ññ°`A?\¼8Ÿ}ˆìDG$""""""""zE¹
¨d2):th$¼€ªA;Ü¼ùHhoİºu˜?><<<àéé‰7¢]»v ^t		ÁŠ+Ğ AxzzâóÏ?ÇæÍ›ŸÿÍ7ß Q£Fhİº5,X€mÛ¶ÁÄÄQQQ†ƒƒê×¯ ¯l~}ûö¡G/İöÑGaéÒ¥		AõêÕoß°aV­Z…:uêÀÓÓ‹/Æ¡C‡
ï_²d	ŒjÕ^llœ8q"¬­­1jÔ( @jjj©Æ).ÛÌ™3Q­Z5@a‡„¢Æ,Í±Y¶l5j„6mÚ`Á‚Ø²eK‘Ç«¨ùuEÕàí]ôPNN¾Öt ^óååàÄ‰ë¢£è<™LŠµkGÃÂÂcÆ¬G^^ÚÆ>r$ööpwwPÛ˜¯3|x[<}š)t­&“½Xf²•\•o}TÜqû§âaiÆ(êµ¿6­•~ûí¬­ÍĞ¶mCa¨lT*vì8¿Àîİ1wnìßÿ>Z¶¬+:é [·cáÂ}ğòš‹>Øì°mÛDDÌÀˆoÀÌL{.>HDDDDDDDDôoå}b×®n˜={'²³ó„uàhÔ¨&~ÿ]_ôİİ»wáââRøµ››ÜÜÜ  ÉÉÉP(hØğ›<]\\Pøu£F
ÿîêêŠÀÈÈwïŞÅ¤I“‘‘¦M›–*KFF


`ccóÒíçÏŸGçÎñÅ_`ãÆ…·ß¿µk×~é±VVV/åù'‡î_.Ú(iœâ²ı=¦Túr=eQc–æØüó˜º¹¹½t¼ÿ­¨ùu‰\î‰¯¿>ˆü|e¢ã†(•ªÂ;ÚÀÎÎ^^u~~~¢ãè<üøãÛèÑã|ğÁv¬X1L-ã;v]º¸A"©ÜsÇÑÑ:4Â–-§áï/æ|ø»€Š¨Äàú¨|ë£âÛ?•tK£¨×ş:Ú´VÚµë"½¸ŞÑ.ÜÆ§ŸîAtt"Fî€™3`ii":é…B‰#Gb±nİqœ<yuëVGPPWÚ¶¶æ¢ã•Z¹wáuéâ†¼<Îœ¹¥Î<eÒ¸q-<|øÏŸg	Ë@â988àÎ;…_ÿõ×_X¸p!  fÍšÉd¸uëçéÍ›7áèèXøõ7
ÿ~ıúuÔ­[¹¹¹èÛ·/¦M›†Ó§OãÛo¿-U–ğğpÈåòWnß·oÖ¬Yƒ=zô¥ì7nÜ€J¥‚J¥Bjj*Îœ9Sxÿ¿7µq¶¤qŠËVÔ&ş¢Æ,Í±ù÷1ı{ãïëTv&tïŞiiÙ8sæ¦è(¤çärDD\eÇ5iØĞ«W¿…İ»/â‡~¯ğxiiÙøóÏ;èÒåÕbŒÊ0|ø8r$‰‰©™ïßş.0äù(×Gå[wÜş©¸cXš1Šzí¯£-k¥+Wî#.îú÷o%:
•àşıŒ¿	}ú¬DµjÆ8xp&>ÿ¼/‹§ˆˆˆˆˆˆˆˆ¨LnŞ|„…÷ÁÛ{Şyg=LL±yó{8yòcù°xŠˆˆˆˆˆˆˆˆtN¹¨jÖ´„›[m9«Î<eÒ¤I- ÀÉÂ2x#GÄœ9s…èèhLš4©pÓª¡¡!Œ)S¦àöíÛ¸zõ*>ùäŒ1¢ğù3fÌ@||<ÎŸ??ş#GDff&²³³a``€ììlÌ; şÚßŠ>}ú¼r¿™™7nŒ>úãÇGNN `Ø°a˜5knİº…èèhôèÑÁÁÁe>¥§¨le³4ÇfêÔ©/ÓáÃ‡ Ö­[‡çÏŸ—ùõi»:uláææ€ğğ«¢£ó÷÷Djj&.^¼#:J•Ñ¹³+>ú¨;>ÿü7DFÆTh¬ß¿•
èÔ©±šÒÏßß¶¶æØ¶íœFæû7P‰ÅõQùÖGÅ·*î–fŒ¢^»6¯•¶o?ìĞ²e]ÑQ¨YYyX¾<:}¨¨D¬^ıvì‚«kí’Ÿ¬Ã
•Vth#"""""""ª
23s±mÛ9®DÇ_`÷î‹:´-NŸş›6E—.®…¿ÿ'*+…B	™Œ¿Ë#"""""""q*ô›	__w<x*•J]yÊÄÉÉÕªãúuPé³Ù³gÃÏÏr¹íÛ·‡³³3–,YRxÿªU«ààà€V­Z>nöìÙ…÷¿ûî»ËåèŞ½;0sæLØÚÚbÑ¢E2dš6mŠ†bèĞ¡¯tO¨W¯Ú¶m‹Úµk#??)))Åv[úè£  _~ù% `Îœ9pvvF»víĞ¡C¸¸¸¼”½´J§4ÙJ;fiÍˆ#Ğ­[7tïŞşşşøøã¼8Ö?.óëÓ»"ìç! ¸¸Ø£aC{DD°˜O‚‚|Ğ§&MÚ‚Û·Ëÿ3ìØ±kğòªkk35¦+š¡¡ƒµÆÖ­g„1ıı˜BÁŸ‹"p}T¾õQIÇíŸŠ:†eãß¯][×J¹Ø¹ó<Fl':
½†R©ÂçÑ®İ¬[w3gÊqôè,ôêÕBt4ÈÈÈAµjÆ¢cé´+WîcÖ¬íğòš‹Y³¶ÃÊÊkÖŒÂÙ³ŸbÖ¬ 89ÙˆHU@VV.—GDDDDDDDBITØí• ÿå8pà}´há¬Î\¥Ö½û×hÕª>æÍ2?©ß„	pıúuDFFŠBeFi¬ˆ¨F˜?>&L˜ ‘ùŠsõj"üü–	ıyHšÕ´é'˜5+ £Fµå%ìÅWpêÔÑQª”ÜÜôë·ii9Ø¿,-MË<†·÷<ÖÓ§ûÿ{÷×Ô½¿ü!a„„°d(	
DÁ8QXjİV»´Z­ímmo‡ÕZíO½j¯uV­{Õ‰±.18A•!H=’ßH*½"’ÆçızùÏ‘œï'
á¾Ïy40aİRSsàïÿ3víú }ûºim] ÈÌ”ÁËë?>]»:kuí–ª)}ß#ÍÇùóçÑ¿äääÀÒÒ²Açøı÷ËXºô$nÜø^k!PR?‘‘R|ÿı1¤¤daÜ8_|ùåXX3=–VM¼	ÆX½zÓ£B´ì«¯"55ÌbzB!„Bi–²³_àøñ[Ø»÷Ÿ@( $¤+ÆïÖêŞc"šWZZ—á?f"0ĞéqšzÿƒÔhªûŞTdä=Œûâã—ÀÜ¼ÓãB!„BZzş¼qõ­¨<=íáäd‰ĞĞ;osš·"	 •f2¶>!„ €‡‡Ú¶µÀ™3qLBZ¹Aƒ<ğàÁ3Ü»GíŒÉÀ@[·Î@QQ>úhÇ7:%&>Á“'ùè×¯ƒ†&¬›‹‹ºwwÁîİWµº. °XÔ@EHK —+°uk$Æõ¡ğTÿ&lÄØ±ëáà`¾Ä/¿Œm•[
ËĞ¦‡é1!„B!„Bš…ª*9""¤øğÃ?àã³+Vœ†··#ƒ‹¿ÄìÙı[å{LDó
Ë  ÆÆô^!„B!„B˜óV* :´BCïh­qæï„B’’(@EHSÀårñá‡2=còÀ™3ñLAZ9oo'X[› ,Œ>ŸÏÅæÍÓ•‚åËO½Ñc/\H‚¹yˆÅšîŸMœØgÏÆ#+«@«ë²Ù: ğÆa3BHÓrüø-<|˜‹÷ßïÍô(ÀƒÏğñÇ;0hĞJäçãàÁÙØ¾}\\¬˜1ÏakËczB!„B!„&íÎGøşû£ğòúï¾»ùùÅX³fîÜYŒ_~__¦G$-\~~1 €Ç3dxB!„B!„´fºo{‚ààNX·î/ÄÅe0²)¸cG[deÉ“óVV&Z_Ÿò’µµ56lØÀôŒ4È›7_ÂıûÙh×ÎšéqH+Åbé _¿‹Ã'ŸôgzœÇÛÛ	+VŒÃ§ŸîA‡¶9Ò«^»x1	}ú¸ÅÒÑğ„¯:´şıïÃ8t(³gkïs¢æ¹Êå "„imñé§Áç›ÁÂÂÆ033‚¹yÕcp¹ê¿¸–ËX»öFŒğjÕ¦ 7·6\ÄæÍ—àà`¦`Ø°NĞÑÑş÷•¦¤´´OŸæÓµ7!„B!„BHÒÓsqøğ9r))Ùpv¶Â”)½0nœ/ìíÍ˜´2ii9ĞÑÑ££Ó£B!„B!¤{ë •Xì ''Kœ8q‡‘ •Xl HHxŒ>}Ü´¾>!„ÔèÖÍÆ‹Ç¬Yı˜‡´bAA8p@‚¬¬ğù\¦ÇiqÆŒéŠøø|öÙ^89Y¢K—¶ÿóã‹‹Ë!‘¤aÅŠqZšP.FîŠ]»®bÖ¬~ZÛlÏf+‹N«ª˜i)%„¼¤PÈah¨‡ÌL#/¯yyE())Wû8]]ÌÍÛÀÌLù§´´ÉÉ™ğõuÆæÍ—`fÖFõ÷––Æ07oƒ6mzV­CQQ¶oÄš5á011Ä’%£0~|7èê¾u™t‹––¹\A?B!„B!„j2Y1ÎMÀ¡C×y<!†ë„+ÆÁÇÇ¹Õß‡0'%%|>—ŞS&„B!„B£Ş:@ C†ˆqâÄm|ıõP­¿áffÖ¶¶¦ˆ§ !„Yl6tÄ™™¦J    IDATéÓq "Œ
ÃÑÃ¹s	˜8±Óã´Hß~;÷ïgã½÷~ÇéÓŸA àıãÇFDHQYY…Ş½EZœPİÄ‰İñûï—u½zµ×Êš,–rs¿\N*B˜V^eËFÀÒÒRíxYY%òó‹Ÿ_™¬2Y	òó‹‘]€ŒŒç8x066<$&>Å¥KÉxúT†òòÊWÎÏãÏç‚Ç3„©©x<Cğù¼WñxF¸àñŒ´õÔ›­âârlß‰ÿş÷/èèè`şüA˜>İÓ£5)wï>NN–¯ÿ`B!„B!„ª¬¬—/'ãĞ¡ë8s&l6îØ¾}úôqƒ›é	AjjÚ·§&yB!„B!„0«QTÃ†uÂo¿Gll:uÒ~•‡‡=âã3´¾.!„üİàÁxï½­ÈÊ’Ïÿç@!šÄáè! @„°°x
Pi›ÍÂÿ;	C†¬ÆûïoÇŸÎ†¾~İ—U/&ÁÓÓVV&Ú²77x{;b÷î«ZP±ÙÊP}U•\+ëBŞœnuĞéÕk–åËOÅÒÁÉ“óÕÚKK+ “«BWYYÈÊ*P;&“•@*ÍBV–yyE¨¨¨ze]e¨ÊH°âó¹Õ+£W‚X66¼|mij‚S6\@IIfÎÀÇ÷—Ëaz´&)*ê>¼¼[Íç!„B!„BH¹\ë×ÓpèĞu=z%%èÙ³=V¬‡!CÄÔòCšœ¤¤§ğô´czB!„B!„´r²Ë¨sç¶puåãÀ	#*OO;üùç­¯K!WÓü–€)Sz2=iÅòÀ—_DaaŒé—dšÀãaÇ™:t5¾øâ Ö¬™PçÇ]¼˜„‘#½µ<İ«&Nì/¿<ˆÜÜ‘°°0ÖøzlvM¨inîßÏÆ†°pá0µğ ér8u‡®şIíĞUvv23eÉJÔBWéé¹HÒ “#7·••ê¯]	<X[sajjXgËÜÜ¸YİY·¸¸{öDcİº¿ğâE)Ş}·;æÌ kkæÂ·ÍATÔ=ŒÅü÷XB!„B!„mËHRqâÄmœ<yÙÙ/àííˆ…‡bøğ.ZyïŸ†())Glì#ÌœÀô(„B!„Biåí6ÍãÆùbíÚp|ûípp8zuÚzñô´ÇªUgQPPJwæ&„0ŠÃÑCŸ>n‹£ aÔÀîøâ‹ı¸t)	C‡vbzœ«];klØ0“'o†‡‡Ş¿·Úßß¿Ÿôô\ôé#bhÂ—†ï‚ï¿?ŠÃ‡o¼2§&°XÊ UU•BãkBOe¥sçî†››¦O÷k”sÖ]‰D‚z=¦&tUÓp•Ÿ_¬ºÊÎ.@lì#Õ±gÏ
_i¼«ºªİpU;tU;ˆeaa]]V£<çú¢àTÃed<Gzz.zôhÇô(„B!„B!#—+“¦
Mee CLê‡‘#½àädÉôˆ„¼Öµk©¨¨¨B÷î.LB!„B!„V®ÑT!!>X¾üÎœ‰Ãˆ^uÚzñô´‡B¡@BÂcÚ<Õ°Ùlœ?:::¯ü‹e 'p8íPVöÅÅw˜°ñ¹£¼<••¹õ~Œ#ªª
ßè1µéèèƒÇë‡ÂÂk¨¬|Ş sh7 ººf¨¨x†ÊÊTTä ²2
E% @W·Ñ^ÆMP',Ø‡‚‚p¹†LCZ)3³6ğövBXX<¨4¬O7|ùå,^|"‘ /ÃRçÏ'‚Ëå KG'T22ÒÇˆ^Ø¹3
3gÔù}¶1±XÊóÿ=Ğ@NWWsæ|ùó—AW×
ººæĞÓ³Dié}J˜ïµ8œöàp\‘ŸšéQš,sów ——£¢â	ÊËŸ ¢â€Æ	!Ö÷šiíÚp$&>EXØFœÚt¥\)®j‡®j‚Xéé¹ªcÙÙ/ P¨ÿûÖ„®ø|^uàÊPºªë˜•Wõz÷&ŠŠÊğÇW°aÃ””T`Ú4?|üq_˜›·yãsµV'NÜ—k__ÚtA!„B!„–E.Wàúõ4œ8q'OŞAf¦B¡ “&õ@ppg…õ»I!METT
\]ùoô~/!„B!„Bˆ&4ZòÀÊÊ}ûvÀŞ½×´ ²±1…¥¥1îÜyDªàë¯¿FïŞ/›1òóË÷qqyHI‘ ÚµãÁß_ ±Øœ©1ßÚíÛ¹Ø¾=#F8£O›z?nåÊX8:š`Ìç­ûìY)¶nMFVVGôïo‹À@{èéi÷NûoâÖ­\H¥ùxò¤O£¼\KVVØÙ£ ÀıuîîvšÆ®ºP'´ızHHmƒybíÚpTVÊµŞ¨ÑÚÌİ‰‰OğÁàøñ¹ª_^^¾œ£!„Ú&Nì;£pãÆtíÚ°ï#õÅbé@GGr95P5DAA	’“3‘”ôTõ‡Ë
« ÀåêA 0‚­­ÜİûA(üœá‰ÿY||NŸ~„Ç‹Ğ¹³ÆŸ§i|M45çÎ=Æıû2¤¥¢¤¤NN&pv6‹‹	M``ğæÿvæææ055}íÇ]¸„ÿüç,~øá¸ºòòÅáèÁÑÑõúøòòJ<^„ü|e ª&t•]€ÌÌÕ±šĞUf¦%¯œ§¦áŠÇ3¬n¼R¬nu»ÕËc
…'NÜÁ¶m‘¨¨¨¢àÔ[8vì†í}ı¦wCB!„B!„†HNÎDhèm:téé¹pt´ÀèÑ]Ò•BS¤Y»p!	~~®LA!„B!„Òx* ?Ş3flS½™§M^^N¸qãV×$šakk_ß~OÀ‰·qıúp8zğósÅŒä	KKc¦Ç|+ÑÑ÷ñ¯mÀäÉ=±lYÈ=6)É çÏ'"$äÍWÛ‡*°gO4/>¤¤,Y2
ıûwlğù4éïO3+K†ØØÄÆ>‚Tš…'â°jÕ9(
p¹†‰‹ 	 ò!;€ÃÑÓêÌ\®!ºukÇH#!µyàÇA"IEÏí™§EÓÑÑÁªUïbìØß0yòf„†Îƒ©©¢£SñİwÃ™OE,v€§§=vïÖx€
P†¨ärj ú_**ªšš©4³úO’“3qï^
LL8pv¶‚PÈG¿~ 
Ğ©S[X[›0=úkI$©X¶ì¢£ïÃß_ˆß†§§=Óc5iµ¯{ÒÓs!‘¤"&&INŸ¾6›…ví¬áëëgtïŞsC””l|üñŒå3åœM¾¾nu«Ô›µ\ÉdÅj¡«šÖ«ÚÇÒÓsqî\>•¡¼¼Rí::@›6xHR!•f‚ÇSo¸ªº²±áQ«éß<xğ±±ğïczB!„B!„S(¸qãNœ¸ƒĞĞ;xú4®®|ŒÓÃ†u†HD¡)Òü¥¤d#!á1~üq$Ó£B!„B!„4n€jÀ wX[›àĞ¡,XÔ˜§~­®]ğûïZ]“4®›7ÓzgÎÄãÁƒg°¶6ÁÀ˜;w üü„00hw—J31}úVôîí†Ÿ~ıÆïÙ³=6l¸ˆœœ°²jØæiK“&õ@` ;~úé&OŞŒÀ@w,]:vvf:§¶ğù<òè®:VPPŠ¤¤'ªMç±±°gO4JJÊ¡«Ë‚‹‹µZ J,v ŸÏÕèœƒ{`éÒ“(+«l1Ÿ»¤ùqr²„P(@XX<¨´ÀÀ@Û·ÏÀ°ak0eÊf|õÕP•Áß_Èôhj&LèE‹aÑ¢ßÏbé ªŠT5jBÀRi&’“•a©¤¤§(/¯„ÎÎV‰î¡P ¡P WW>X,¦G#11iøå—S¸r%şşBœ:5;·ez¬f§¦I)$Ä ıwî<„D’‰$û÷KPQQ>Ÿ__øø8Ã××öoü9óäI>&MÚ‘H€ÿû¿±šx:-‡£§ş¡«¤¤§øõ×s½3³6>¼3Äbäç¿Ä’J³•%C^^**ªÔÎc` [ª2R¬ø|nuàÊH-tÅçó`kkÚdÚ5a×®«xèÑƒ®o!„B!„Ò¼TUÉU¡©“'ï 3S†¶m-0dˆÁÁàëëÂôˆ„4ª?ÿ¼€‡nİès›B!„B!ÌkÔ]ıºº,Œİû÷K0oŞ@°Ù¬Æ<ıÿäíí„¥KCñøñó& !/¥§çâğáøóÏëHMÍ‹‹†í„  téâØì6¿NV–“&m‚›› 7NmĞ×H·níÀfë :ú>‚ƒ;¿Õ<|>k×NÄ¸qİ°páA,Ã¬Y}1wn`³ÚpÉåràëë¢ö…ÊJ9?~©T¨ŠÍÀ¡C×±re €Ç3ª¨²‡H$€››ôõçeqğ`1şıï#ˆŒ”6Ùv/Ò:ä£GobÑ¢LÒ*˜™µÁîİ 8x¾ÿş(ììÌàädÉôXjFôÆâÅÇqäÈMLÚK£k±Ù,TU)4ºFS$“Wz_†¥£¸¸€òû¯Xì !fÌğoôïAL¹q#k×†#<<>>Î8th6…7‘µµ	İU!òâârÄÇg¨ªV®ƒLVcctéâ__gøúº kW'êÿãyŸ>ÍÇ˜1ëĞ¦>¶m›Ñì?›Š+WR°iÓEœ;wB!+VŒÃˆ^õ¾Æ®İt•]€ÌLd²µĞ•²¥,2Y1rsQY©Xı{èJ àÁÚšSSÃ:ƒXææÆÍâg€ÂÂ2ìÚusæô×ê{„B!„B!UXX†qútÎŸ¿‹‚‚RxzÚcòä
òD‡6LHˆÆ;v£Fy·¸½„B!„Bi}wÜ„	İ±aÃ„‡' (È³±Oÿºti==6nÜx@ª&®  aañ8tè:"#ïÇ3Ä°a°jÕxøø8CG§e¾qöâE)&NÜ##lÛ6£Á­DÆÆğô´GTTÊ[¨jôêÕıõ/lÚt+VœÁ©SqX¾|ºvun”ó3AW—¥jn¨İVõ÷Mí±±°kWÊÊ^¶Ôª„Bºtq„¥¥ñ¯/ğ ÛãÌ™x
PFä_=‡ÄÄ§ô8-qr²Ä–-Ó1jÔáæÖôşÍ¹\‚ƒ;c×®«Z	PÉå-·ª  ä¨}_IL|‚gÏ
¨‡uCB| òááa#£³4G‰‰O±zõY„†Ş——#ø~~M«y­%22ÒWÈgÏVŞ¹6%%»:P•Šƒ•Áñš6N__gøø8£gÏöªŸ—?~±c×ÃÀ@û÷Ï‚¹y†ŸUóVQQ…ãÇoaãÆ‹ˆŒnİ\°mÛ{tãŸqj7]‰D‚z=¦´´YYÈÊR†­”-WÊ°•òxbc©åä¼€\®r­	]ñù¼êv+eØª&tU»õÊÔÔ––&Z1íÙÊÊ*L˜Ğ]«ëB!„B!„¼‰çÏ‹pîÜ]œ;wıuee•ğòrÄœ90dˆÎÎVLHˆÆEFJñàÁ3ŒíÍô(„B!„B! 4 rq±B¿~°eËe­¨8=tè`‹ë×`øğ.Z[—ÔOyy%.]JÆ‰·z
…"lØ0AAÍâNço£¢¢
3gnCnnNœø¦¦Fou¾=]qöl|#M§¤§ÇÆìÙı1th'|óÍŸxç_1z´7~øaD‹ÚLËãÕÙVuÿ~6¤ÒÌêPU6mº„œœ ”M!B¡2P%ÛC,v@ûöÖ¯İ,ä‰ß¿ŒeËÆĞİñ	cºtiS„…ÅQ€J‹ÜİíÀfë )é)¶o¿‚iÓ4TzS“&õDpğjÜ¼™//G­Ãbé¼²9¿9ª¨¨BjjÚ÷	©4æA¡P€ËåÀÉÉ
B!îªF)++¦G×¨ääL¬Z†ĞĞ;ps³Á†S-ÜMŞ›Í‚H$€H$À¤I= (ÛO%eCUlì#ìß/AEEø|.D"Üº•KKcìÛ÷qƒãDéÅ‹Rìß/Á†™)CÿşñóÏcàíí¤Õ98=ÕêK&+Fffd²bµĞUí Vzz®*t•ı
Å«¡«—íVFj¡«º‚XVVÜßm¶¼¼›7_Âøñİ`fÖr~F!„B!„BHËğèQÂÂâ€«WSÀf³ Â?ŒÀÀ°¶nÙïòwëÖ‡ŸŸ:Ø2=
!„B!„B ¨ `æÌ Œ¿wî<B§NšX¢NŞŞN¸qãÖÖ#¯'‘¤âĞ¡ë8qâ
KÑ³g{,[‚!CÄ066`z<­P(X°`nß~ˆÃ‡?½ıÛ7¤õìÙëÖı…¬,ø|^#Lù’““%vïşáá	X¸ğüü–â³Ïá½÷ü¼Ñ±©ÓÕ}¹á¸¶ÚmU±±“†;® ¢¢J­­J,v€H$€‡‡ÚFÎÁƒ=±|ù)Ü¼™ŸæÛæEš7Ğaañ˜7o Óã´ÑÑ÷QU¥ÀGõÁwß†©ZÓ¼½ááa‡;£4 b¡ªªù4PUVÊñøñsUPªæ{ÀıûÙ¨ª’«^ûE"ÆŒé
±ØB¡ mÛš·ØÍº¤¤dcíÚp9r®®|lØ0Ã†ujUÿÍŸÏCppgU°­¨¨		±oß5:t –ö?£sç¶ğõuVÍÚ–Úš¤¥å`Ë–ìßºº,LœØï½çß¬‘y<#ğxõ¿¹CYY%òó‹Ÿ_¢ºÊÎ.PbÕ„®23óQPPZçº5ÁªÚ¡+€ûA, Øº5¹¹…˜5«_£ıB!„B!„4”\®ÀíÛ€°°x$%=…™YvÄÆÓĞ§††úLI#Ÿâòe)vïş€éQ!„B!„BT4²+. @„l±m[V¯ ‰%êÔµ«víŠBii8=­­KÔ”âøñ[Ø¶-‰‰O 
0s¦?Æõ…ƒƒ9Óãiİ¢EÇpìØ-ìÜù>Üİíåœ¾¾ÎĞÓc#::ï¼£™ÆµÀ@wôêåŠÿüç,-:†“'ïàçŸÇÀÍ­õ4ØÔÕVUÓBûHÕ@²fM8rs(Ûªj6Ô…|88˜ãôé8
PFä]»®âÉ“|ØÚš2=N«)…››şıï`Èd%øğÃ?°oßGj¯'L›8±-:†~xç6Ï¿	6[UUM³*+K©4ÉÉ/ÃRññQRR6›{{3…ºcöì~õnlÉ22cíÚpìÛwÎÎVXµj<FîÚbÖ-‘¡¡>¢¢RpğàuŒÓ?ÿ<éé¹ˆ‰IƒD’Šıû%X¹2ºº,tìhgøú:£gÏö°° †*@¹)æüùDlÛK—’agg†/¿‚wßíŞ*na` [İ*Uÿ›8”–V@&+V]Õ4\Õ>–‹sç
ğäI>**ª^Y—Ç3Dnn¬­¹X¸ğx<õ†«Ú¡+Sp¹œÆ~ú„B!„B!(,,Ã¥KI8wî.şúë.=+„ƒƒ9ôÀ?D÷îí «ÛzßG&¤Æúõçáæ&@ïŞ"¦G!„B!„BQÑØmÅgÌğÇÂ…‡ğõ×ÁZ«¢ïŞİU¸~ıüü\µ²&y)6övíºŠÃ‡o€ÅÒÁˆ^X½ú]xzÚ3=c6l¸ˆÍ›/cÍš	h¼7Û´1€Xì€+Wîi,@ FFúøæ›a1¢¾úê \©Sığå—CZÅÑºèé±UmU!!>ªãYY2U *99áá	X¿ş<är6mºˆ¨¨…|ˆÅ‹íááa##ºãÑ??W´i£³g0mZ/¦Çi""¤ğ÷BGGË—‡ ?¿S¦lÆ‘#sĞ¡ƒ-Óã ÆŒéŠ¥KCqèĞuÌ˜ ‘5Ølärf¨

J”ôT-,•ğyyE ”ÁW¡P ±Ø!!>
ùğô´§»‚ÖòäI>Ö¯¿€;£Àçs±té¼ûn·V&k

J1ş„‡'à«¯†`öìş  º®™4© å5D’‰$11iØ¶-r¹Õ*øø8C(ä·ªÖ±/JqìØ-lŞ|	÷îeÁÇÇë×OÁàÁbÚó8œ·]ee`çÎ«¸q#¸£¤¤YYˆÍ€LVŒ¼¼¢:CWÊP•2X%ğªÛ­UÇLM•MX|>ææÆĞÓc7öÓ'„B!„BHğğa.._–"<<—.%£²²
ö˜:µİáéißªŞ+#äu’“3qôèM¬^=¾6!„B!„Ò¤h,@5fLW,_~
;w^Á‚AšZF)œœ,•B*-)+«Ä‘#7°eËeÜ½ûöøşûw0r¤w«ØÔ8~ü–,9ï¾1cº6úùıı…øóÏë~Şº¸»ÛáøñOqèĞuUÕÂ…CÕD­ŸÏC` îªc……e8yò6æÏß‡öí­‘‹Ó§ãPTTVı®*P¥l¬´ºÍÈD;ôõuÑ§ÂÂâ(@¥Ï")) ı÷¿“ğî»0qâ&?ş)ìíÍRÆ1Â;vDá½÷ü5òÚÃb±PU¥ Uí†@©4R©2,• àrUA‘À@wˆDtìhK­:ÿÃ³g…Ø¸ñ"¶l¹KK,Y2
ãÇw£°H3)Åüùû  GÎ…——ã?~,ŸÏCppgw ¼¹u+I*$’4|÷İ”–VÀÊÊ;·…¯¯3||œÑ¹s[èëkìÇKÆÜ¿ŸíÛ¯`ïŞhÕM"6nœÚªZY™ğ÷ĞUbâS\»v?üğ¦O÷¯ó15¡+e»Uòó•ÍV5A¬ììÄÆ>R{ö¬ğ•ïQµCW5Á*ÏH-tU;ˆeaaB¯‰„B!„BHTU%Ç~RÄÆ>‚‘‘>zõrÅ’%£0p ‡Ön"KHsôãÇ Ù`Ä/¦G!„B!„BQ£±núúº˜0¡;şøã
æÌ µÍt={¶GTTŠVÖjÍ²²
°cÇìÜ™¬ï¼Ó+VŒCçÎm™­I¸zõ>æÎİƒ)SzâÃûhd~ıÜ°zõYÜ»—WW¾FÖ¨MGG!!>tÇÒ¥¡˜7o/BCï`É’Qpp0×øúÍ‘±±BB|±lÙ)´kgÿşw€—mU5›üOœ¸ƒ{÷ÎB¡P€Ëå@$²Xì ‘H j­âpô~6¤¹4ÈŸ}¶%àr™§E‹Œ”‚ÍÖA·n.ªcşøã}Œõ+&MÚ„£GçÀÔÔˆÁ)•¦Ní…;£píZ*ºwo×èçg±t —+õœ••r<~üRi¦êu499))YËĞÓcÃÙÙ
b±=&Mê¡
¨¶mkNÕzÊË+Âúõğûï—afÖß|Œ)Sz¶ÈpLKWRR%KB±}{$†cùò˜™µy£sÀß_! å×àİ»UU7^ÄO?…BOl«[ªœáççúÆk5åå•‹Ç®]Wy˜? &Mêù×îÖF.Wà_ÿ: OO{L™òÏAğ†6])W2Èd%j¡«š Vzz®êXNÎ‹W¾¯Õ„®ø|^uàÊP-tõ÷ –¥¥	5øB!„B!MP^^ÎŸOÄ¹s	¸x1%hßŞîøî»áğõu¡©R‘‘÷páBø,ı^†B!„B!M‹FwAN›æ‡õë/`ïŞk˜:U;={¶ÇÁƒ1(..‡‘‘¾VÖlMâãcãÆ‹8~üx<CL™ÒS¦ô¢;lÕ’œœ‰÷ŞÛŠ  ,Y2Zcëtéâ3³68>Q+ª¦¦Føå—±5ÊBïŞË0{v?­%›KzàÌ™8ÌŸ?@İmU¥HJz¢
ÄÆ>Â=Ñ())‡®...Öj*±Ø|>—©§Eš¡šÏ·‹“0|x†§iÙ""îÁËË	&&µã\.»w€àà5˜4i˜ÅøµJÇ¶èÒ¥-vîŒÒH€ŠÍÖy«ª¬,™ÚëbM³TiituY°³3ƒP(@pp'UPª}{kÚ˜Ş@ùùÅøı÷ËØ´éôõu±`Á Ì˜@!Şf***_|q yyEøõ×‰5Ê»QÎ««ËR]‹Ìœ  HOÏ…D’ŠØØÄÄ¤aëÖ(
8:ZTª\àãã‘HĞ(3hJjjvîŒÂ1(,,ÅÀØ»÷Cøû)€É -[.#6öÎı¼Ñ_ß9=8:ZÀÑÑ¢Ş‘ÉŠ‘™Y ™¬X-tU;ˆU;t••UğÊ9tk5YoÉå    IDAT©…®ê
bY[sésB!„BidUUr$$<FD„—/Kqõªò&­]º8bÎœş8ĞC«¿ƒ%¤%¨¬”ãûï`Ğ øù	™‡B!„B!äM;ğù\L˜Ğ¿şzï¾ÛM+áŠ^½\QQQ…ë×Ó Òøz­ETT
şûß¿pñb:t°Å/¿ŒÅÈ‘^˜ù›ÌL&NÜˆm°víDŞQ‰Íf¡woÎŸOÔXËÕÿÒ½{;œ=û9şøã
–/?…#GnâçŸÇ¨Ú	ÈKAAØ¹3
æ¢mÛº7gr¹øúºÀ×÷ecMU•/[Vbc3pèĞu¬\ àñŒjªì!	àæfC_—¤N\®!|}qæL<¨4,2RŠ±c}êü;>Ÿ‡İ»?Äˆ¿âãw`Ë–éĞÓckyBu“'÷Ä—_Ä¢E#aiiÜ¨çf³Yõj ’ÉŠ‘œœ©–JL|‚ÂÂ2 ÊkJ¡P gÌ˜á_(P°§‘•aûöHüúë_`³YøàƒŞøğÃ¾066`z4Ò ¹¹…X¼ø8¼:bùòõoäiˆš JHˆòµïÅ‹RÜ¾ıI*$’4|ûía”•UÂÚÚ:µ…¯¯3||œÑ¥‹#ã¯U8s&NÕ6¥ü¶;¦Më;;3Fg#Ê›S,_~
sçh2<ÏèšÈÊÊ*‘Ÿ_„üüµĞUvvZ+==ÙÙxúT†òòÊ:×­	VÕ„®j‡­j±.µ¥B!„B!uxú4/&áÂ…$DDÜƒLVsôéã†iÓüàï/¤÷E	yëÖı…´´gØ²e:Ó£B!„B!„ÔIã»ì?ùd öì¹†ıû%˜<¹§¦—ŸÏ…‹‹®\I¡ Õ[R(8wî.Ö®=‡7ÀÇÇü1t¤»_×¡  'n‚‰	[·¾§•K¿~°`Á>•¡Mí¿™¯§ÇÆÌ™:TŒï¾;ŠqãÖ#8¸3~úit£oÂoÎüü\Áå"<<3fÔûql6Kµ!Y½­ªIIO›¡
WíÚ…²²Jèé±áìl¥
T	…téâHÿ 0h'V¬8ŠŠ*Æ7¬·T<Ã£Gyÿ3LêêÊÇïcüøõ˜7o~ıu’F·¯3b„-:$˜5«_£›Åb©5P–!55[–ªy«iç¨	†ŠDw†H$€»»ÌÍÛ4ê\D©¸¸Û¶E`İºó¨¬¬ÂÔ©~˜3g ¸\ÎëLšœª*9öî½†¥KCah¨-[¦cğ`OFf11áÀß_¨z-¬¨¨BbâH$iˆ‰IÃúõğÓO¡02Ò‡»»]uˆÜ¾¾ÎZ}$&>Å>|yyEèß¿#vì˜‰¾};0úšL^*+«ÄìÙ;áæ&ÀÜ¹LÓ`ºÕA§úKK+ “«BWÊv«µc2Y	¤Ò,deÉ—W„ŠŠªWÖU†ªŒT+>Ÿ[¸2z%ˆecÃ£1B!„Biq*+å¸yóÂÃï""BŠ¸¸èÂÇÇŸ|ÒşşBˆÅLIH‹pï^V¯>‹¯¾
gg+¦Ç!„B!„B©“ÆwÇØÚšâİw»aíÚs?¾›V6l÷êåŠ¨¨{_§¥’Ë½U«ÎâŞ½,ºãÄ‰OáííÄôhMVEEfÎÜ†çÏ‹:Ok?ûöuƒ\®ÀåËRÆ6È€)6o†ğğ|óÍŸğó[ŠÏ?Âôé~`³YŒÍÕTèé±Ñ·¯Îœ‰{£ Õ?Q6	©·UUVÊqÿ~6¤ÒÌê@B6o¾„ìì ^¶·…ˆÅö‹Ğ¾½5ıÿ´2AAøî»#ˆ¾Omq!…‘‘>ºtqüŸçííˆmÛf`òäMĞ×ß‡U«Æ3Næpô0z´7víºŠ>êÛ(ÁŠŠ*¤¦æ ¤¤RÜ½ûÉÉ™HIÉ‚\®P{Îœ z}rt¬»¥4®òòJ8ƒ+N£¨¨Ó¦ùá“OúQ[I3!Å?CJJ¦O÷ÃçŸnRwÊÕÓcW7f:`æLåµPzz.$’TÄÄ¤!<<¿ıv,–Úµ³V5Tuëæòíñüy¹‰ıû%ˆ‹Ë€££¦Lé…	ºÁÆÆ´ÑÖ!ãÛo##ã9ÂÃ?ouÁoGNÃCWÊv+d²µĞ•òë.2Y1rsQY)W;ÇßCWÖÖ\˜šÖÄ277nuÿ7„B!„Bš¾ôô\DDH!Å…‰(,,ƒ££üı…˜=»úõëÀÈ)	iÉ*+åøôÓ=ğğ°S½L!„B!„ÒiåöÂsæÀŞ½ÊªI“zh|=??Wìİ™¬˜6‚¾…B3gâ±bÅi$'gbÄ/lÜ8"‘€éÑš4¹\Ù³w"6ö!™[[ím¾´°0†··Îœ‰c4@U#0Ğ~~®øí·óX¼ø8ŒÁòå!èÜ¹-Ó£1nğ`OÌ½yyEiRÑÕeA$¼òõ*“#9Y¨Š}„˜˜4ìØqEÕ@T`‹ 	àáa33jzi©ìíÍĞ±£-Îœ‰§ •†DFŞCíêµ™ØÏÏ7NÅûïo‡‰	?ş8Róşƒ©S{aÛ¶HDFJß¸Á3+K¦jÄ«i–JN~Š²²Jèèè ´´>>.î¤
J¹ºò©á…UØ¿_‚•+ÃPPP‚	ºcîÜ°²2az4Ò@Ri&~ú)áá	tÇ¦MSÑ®5ÓcÕKMËfHˆ  'çnß~‰$I*ˆAyy%ø|.|}]àãã±Ø]º8¾Q`£ªJ¨¨<ƒĞĞ; ”×¬ÿşw0üü\©Y·‰:|øvíºŠ-[¦ÃÁÁœéqš…Ú¡«úş_ºªi¸ÊÏ/V]eg 6ö‘êØ³g…jÍ’€zèªvÃUíĞUí –……	tué&„B!„BO^^"#ï!"BŠË—“ñèQ¸\Cøûñı÷ï O7ØÙ™1=&!-Úš5áHL|‚ğğ/è„B!„BiÒ´ ²µ5Å¸q¾X³&ãÆùjüÅ½{+7ş^¾,Eppg®ÕRDDH±ti(bc30`@Güúë$tìhËôXÍÂ?EXX<vïş :hÿß,(Èk×†£²RŞ$6¢êcÁ‚ Œá……ÿÄ°a«1aBw|ûíp˜˜p˜1ıûw„®.çÎİÅØ±>Z[—Ç3z¥­ª¦&6ö¤Ò,H¥™X³&¹¹… ”mUb±CuĞ±ØÂ-HP'öì‰Æ’%#iÓx#S(ˆŠJÁ'Ÿô¯÷côÀo¿MÆGí€¹yÌ›7Pƒş3WW>|}±sçÕPÕdÖ„¥îŞ}‚¢¢2 /›î||œ1c†?D"æÍÛƒ  1şõ¯ÁÚ|:äo**ªpôèM¬Z†'Oò1nœ/,ŸÏez4Ò@æbåÊ0>|B¡ û÷Üìƒ±VV&tG` ;  ¤¤qqˆ‰IƒD’†U«ÂŸ_Œ6mĞ±£mõõ3ºuk.÷ÕkL©4^Çää¼€Xì€‰‘#½èÃMÜ°`Á>|ôQ"fzœ­¡MWÊÀ•²áªvèª&ˆ•«:–ı
…Bí5¡+>ŸW¸2T…®ê:feÅ¥ŸE!„B!„¨”–V@"IÅåËÊ–©„„Ç`±tĞ©S[ŒÓ½{‹àååÔ$~oJHk!ÅêÕgñã#Ñ¾}ó¸Á!„B!„BZ/­¨ `îÜØ·ïŒÁ„	İ5º—k//'œ?ŸHª×HR±xñqÜ¼ùºcÕªñŒ„€š«uëşÂÖ­Ø°a*üü˜Ù´:t¨?şxÑÑ÷áççÊÈui×Îû÷„C‡®ãÇ#<<_=LÕ2ĞÚ´ic ??Wœ9§Õ U]ôôØu¶Uı½E&<<ë×Ÿ‡\®€±±\\¬U*±Øö02ÒgèY†4È«V…!>ş1<=í™§E‘J³›[ˆ=Ú½Ñã†í„+Æá³ÏöÃÑÇGõÑÌ€¯1yrOÌ›·))Ù(..SK%%=ENÎ Ê`¦PÈ‡H$@ppgˆÅöpw·«3Àf³_iª Ú#—+pòä,[v
y7ÎŸ}6Aı7Ê“¦%3S†µkÃ±{w4ììÌ°fÍŒáÕ"ƒ††úªøìÙÊÏç{÷²Tšáá	X·î/°Ù,´kg__gxxØA&+Å¹s	ˆ‰Iƒ­­)ÆõÅÄ‰İáädÉôS"õ‘ñï½·={¶Ç7ß3=©‡£§j«òòJ<^„ü|e ª&t•]€ÌÌÕ±šĞUf¦%¯œ§¦áŠÇ3¬n¼R¬nu»•‘ZèÊÚšK7 „B!„B.W >>£ºaJ
‰$ee•pt´€¿¿Ÿ|ÒBğxFLJH«“ısæìÂĞ¡0}ºÓãB!„B!„¼–ÖTvvf?¾şóŸ³5ÊF×ë×¯¶n½…BA›fêššƒ¥KCqêT,üü„8uj>:ur`z¬fåØ±[øùç“øá‡6¬cs88˜£C[œ9×¤T  ££ƒè+Â0ş^8 ÁÏ?‡´Ê»Oä‰ï¾;‚ââò&<âóyä©š  °°©©Ùª Elì#œ>§Ö8S¨R6V)[«èu·éòğ°ƒ­­)ÂÂâ)@ÕÈ¢£ïÃÄ„ww»7~ì¸q¾ÈÍ-ÄâÅÇaff„qã|50¡ºš6:©4³:$•	…ø `bÂ³³„B>„
èÔ©-¬­Mê½›Í¢ j‚S¿ürii9:´vïş€$ÍØ½{Yøí·ó8|ø,-MğÓO£µÒìÛ”°X:ª xM ?+« ·o?ÄÑ£7qútvíº
@ğèÑ£‚‚<Ñ­›Ú¶­_Ğƒ0ëÅ‹RLº––ÆØ¸qØlºKtK ¯¯[İ*õf-W2Y±Zèª¦õªö±ôô\œ;W€§Oe(/¯T;GMËg¤ºªİpU;tecÃ—kØØOŸB!„BH¥§ç""BÙ0yÏŸÁÒÒ=z´ÇâÅ£Ğ§ìíÍ˜“V­²R?ÜccşïÿÆ2=!„B!„BH½h-@ Ÿ„#Gn`óæK˜3g€F×ê×¯–-;‰„„'ğğxóÌ-U~~1Ö­;Í›/¡m[slÜ8•ZºàÊ•|úé|üq?ÌœÀô8<Øûö]ÃâÅ#›dp…Ç3ÂâÅ#1fLW|õÕAôïÿ>ø >ÿ<Z}bÔ AX¸ğ._NFP'ÓãÔ‹±±Au@ÊA­=¬¦­*6ö¤Ò,œ8q÷î…B¡ —ËHd‘H¨‹í!;h<8KêGGGƒyàÌ™8|şyÓã´(ÑÑ÷áããÜàß³fõCQQ>ÿ|?tuY=ºk£Íö÷†9©4IIOQ^^	==6œ­ 	àåÕ))98xpÜÜlŞºÕ†ÍÖB¡h¤gAê#"BŠÅ‹ãîİ':´şøc&\\¬˜‹4P\\6o¾„#GnÂÁÁß~;“'÷lU×Ou‘Ëˆ‰IÃñã·pâÄmäå¡{÷v1ÂmÛš#..IV®CAA	ŒĞ¥‹#|}áëëgº.ibJK+0mÚäåáÄ‰Oalüj«!i=8=p8oºR®
^	bI¥YÈÊ’!/¯Ujç¨+tÅçs«W¯±lmM[U•B!„B4)3S†+WîáÊ•\¹rå¡MôèÑóæÂß_77¦Ç$„ÔòÕW—“'çÃÄ„Ãô8„B!„B!õ¢ÕwVV&øè£¾øõ×s7®Û5¼)ww[ğù<œ?ŸH*([&¶nÀşCC}üôÓ(Œßîêİ ‰‰O1cÆVì‰…‡2= `È1V­
ÃÍ›éğövbzœÔ©“Nœ˜‡íÛ#ñË/§pòä,]:}ú¸1=šVXY™ÀËËgÎÄ5› Õ?©«­êÅ‹R$&>TšUİXõşy%%åĞÕeÁÅÅº:TÅW…²ø|.ƒÏ¢õ4ÈÛ¶EâáÃ\jåhDÑÑ©˜1Ãÿ­ÎñÅƒQY)Ç¼y{Áb±0r¤×=^&+V5ÆÕ„¥£¸¸ÀËÖ8!fÌğ‡H$€››ôõ•—„<ƒŸßR<~ü;Ú¾Õs”1Ô@¥R,]ŠØØĞ«WOh”ÿCÂ‰$ëÖGxx<=í±jÕxŒåİª¯İ
nŞ|ˆãÇo!4ô>Í‡››Ş{Ï£Gw…ƒƒ¹êcD˜=¨ª’#%%11iHRqà@V®ƒ®.;ÚÁÇÇ¾¾ÎèÑ£=,-|v­[U•Ÿ|²		OğçŸ³éîÑ¤AŞ6t•]€ÌLd²µĞUzz.$’4ÈdÅÈÍ-De¥úuÍßCWÖÖ\˜šÖÄ277¦Ğ!„B!„@Ù,•¢ú“––==6¼¼â!¼¼ég(Bš¨Õ«Ïbÿ~	6o‘HÀô8„B!„B!õ¦õ[—ÏšÕ{öDcÕª3X¶,Dcëèèè OÎŸOÄÜ¹šm»jê®^½o¾ùii9˜5«fÏî##}¦Çj–>ÍÇ¤I›àéi‡5k&¼u3GcéØÑB¡ ÇİjÒ* ĞÕeaæÌ wÂO?…bÂ„tÇÏ?­­)Óãi\P'~ıõ*+åĞÕmY› ML8ğõu¯¯‹êXU•Ï!•*U±±8tè:V® l'{¨²%ÌA4£Göàr€3˜oÑk	<x†¬,ºwwyı¿ÆÂ…C!—+0wîn°Ù:>¼Ë+SPPŠrÔÂR‰‰OğìY! õ¯­…|xxØ¿öû¿““%zötÅ®]WÕ’Åb±PUETš$‘¤bùòS¸zõ>üı…8sæ3xzÚ3=i€ŠŠ*=zë×_@rr&ú÷ï€Ã‡?A÷îí˜QÉÉ™½Ã‡o"--æ2DŒ®‹şçcÙlD"D"&Mê@ÙÈ'‘¤A"ICLL¶m‹€\®€££||œ!;À××öM²Ùµ¥‘Ë˜7o/.]JÆ¾}Ãİn~B´§vèª¾}JK+ªÛ­”a«üübUèª¦õ*6ö‘êXNÎÈåê×B5¡+>ŸWİn¥[Õ„®j·^™šÂÒÒ¤Uh	!„B!-Ã³g…¸z5EõL\\X,¸»ÛaÈ1|}Ñ½{;j±!¤8vìşïÿÎ`É’‘Íş¦¡„B!„Bi}´¾CÃÑÃ_ÆçŸïÇ´i~ps³ÑØZıûwÄ¬Y;—Wsó6[§©ÊÎ~%KãÏ?o W/WlÚ4íÛ[3=V³õüyÆ[SSCüşû{M.àÜ	;wFáûïßi›«ø|Ö®ˆ±c}±pá!üŒùóâ£ú6‹ùjğ`O,^|ÑÑ÷áççÊô8Çf³àèhGGµ0FAA	’’ª‚±±°kWÊÊ*¡§Ç†³³•*P%
Ğ¥‹#5C4"==6úöuCXX<¨Itô}p8zèÔ©m£œïë¯‡¢¸¸sæìFnn!,-Mª¿V”_3æA¡P€ËåÀÉÉ
B!îª¢•UÃ[>'Oî?ŞGòÔ]‚ÍfA.§*M¸~=¿ür‘‘÷àï/Ä©SóÑ¹sã|şíÊÌ”a÷î«øã+ÉJä‰Õ«ß}m8¨%«	M=z÷ïgÃÎÎAA¯Ôn>Ÿ‡ààÎî (,,Ã­[éHR›+N£  &&tîÜ¾¾Îª€¸AÓºşoîªªäøì³}½;Ş‡··#Ó#òZêç›ú’ÉŠ‘™Y ™¬X-tU;ˆ•«
]eg¿€Bñjèêe»•‘Zèª® –•·ÉÜğ…B!„Ò:åæâæÍtH$iˆˆª¦||œ1{v?ôîí.—S„4'RÌ»³fõÃôéşLC!„B!„òÆÙâƒmÛ"ñÓO'°sç[§o_7èê²€qã|5¶NS#—+°}{$~ùåx<#üşûtºóÏ[*-­Àôé[QTTĞĞOÁå2=Ò+FŒğÂÊ•aˆNE¯^í™§Şüü\ş9Ö­ûÿ÷gpôè-,[Òb7P:9YÂÍÍaañ­"@õO¸\ÃWÚª*+å¸?Ri¦*(²yó%dg¿  ğù\…Ê@•Xl±ØíÛ[·èÀ&ybÎœ]ÉŠÁã1=N³}]»:AOİ ÇWVÊñøñsÕç¿²Yêªªäøæ›Ã`³Yh×Î"‘ cÆ([W„BÚ¶5oô†”ÁƒÅ°²âbïŞkø×¿¿Õ¹ØlTUQ€ª1İ¼™5kÂ g:4={6ŸïûDI.WàÊ•{Øµë*NŠ…¥¥1Æë†iÓzÁÎÎŒéññèQÂÂâqğ`ââ2`ccŠ!CÄX¹r||œ5Öell !üı… ^^ÄÄ¤A"IÅ¾}¬\==6:t°…3|}Ñ«—k«¼IGc©ª’cşü½½ƒíÛgªşı	i‰x<£7ºŞ.+«D~~òóKÔBWÙÙjA¬šĞUff>

Jë\·&XU;t%pÿ1ˆE!„B!••%Ctt*®]»èèT$'g‚ÅÒ§§=üü\ñÅAèÖ­Œ˜•Ò@W¯ŞÇ´i¿cøğ.øúë¡LC!„B!„Ò Œ¨X,|÷İpŒ³—.%£wo‘FÖiÓÆ úü±­&@•’’Ï>Û‡;wbÖ¬~˜;w õ™«Y“Ëøä“]¸w/ÇÍ…)Ó#Õ©];k¸»ÛáØ±›Í*@(ïâ½`AFòÆ×_ÿ‰áÃ×`ôho,Z4ff-ocjP'öï—àÇGhl3ps¤«Ë‚H$€H$P;.“W‡I2û11iØ¹3
ååêmUb±D"ÜİíhCs=ôíÛ:::øë¯DŒåÍô8Í^tt*BBºÖëc³²dJ³œü2,ÿ%%å`³Y°·7ƒP(@` fÍ²Æ™3ñ¸p!‹ĞØ5Smºº,Œï‹={®bşü… ‹Å‚\®xı’×JL|ŠÕ«Ï"4ô¼¼±ÿÇ8h†²³_ààA	vìˆÂãÇÏÑ«—+~ûm2CW·õ‚ÓÒrpòd,»…„„Ç°¶6Á°a±xñHtíêÌH{Jíë‘I“z P¾nK$iHÒ“†mÛ" —+àèhQ¨r3„B>]ÛÕCEEfÍÚ‰óçñÇ"äït«[¥êh*-­€LV¬ºªi¸ª},==çÎàÉ“|TTT½²®2Te¤ºªİpU;teccJwŠ'„B!¤KOÏÅµk©¸z5×®¥âÁƒgĞÕeÁÓÓ}úˆ°páPtïŞ&&ôs!-Á0uêfôíë†ÿüç]z”B!„B!Í#* èÙ³=İ±hÑ1„…-x«Í¹ÿË!b|ùåA¼xQÚ¢ß ­¬”cûÿ³wßQMmÀ¯$l%¨	²Qƒ2‚WÅ›j·uÔªU?GµÖZ­Õ¶jmµîªU«¶îU[5!"ÈR†(a„‘õı¡¸„Àı;‡ÓÓWxsG!$oë¹v]ÁªU§áâÒ§N}oo}U+|ùåQüóÏ=80ÍšÙê{œW8°6mº€o¾Ze?SUÉÕÕû÷OEXX.<„WbÑ¢ş5ª]­ºÛ»·~üñ¢¢ÒÀç;ê{œÏÊÊ¢R[•L¦@bb6D¢TˆÅ™‹3°~}rr
 ¨Ûª4=<|¾#š7çèe!vMÅf›¡C‡f¦ Õ{zü8))9h×®bx5/¯qq+„¥bbÒñôi!€ç­j|¾#‚ƒıÀãqàííP)ø<l˜>ûìwŒ·;vL@÷î-«ü>Õ6üĞĞhôïïóÎça2P((@õ>Äâ¬YŠS§î¢E;lŞ<AA¾ú‹¼…B‰+WÔmSçÎEƒÍ6Çğá„„´‡‹Kc}W­”JnßNAhhBC£qÿ~&5ª‡~ı|ğÕWƒĞ®[l–äp¬ä«ıÙËÏ/Æ;)
!&áË/¢¸XKøú:A p…ŸŸ+|}`b¢·—Ü5Raa	&OŞ…ˆˆ$ìÛ7íÚ5Õ÷H„Ô
ffÆ03{¿Ğ•:p•Wé˜H”‰DŠ§O_ºâr­ÊÚ­Ì+±86865ªo×*!„B!êÀ”P˜ˆˆˆ$\ºÔÔ§02bÂÃÃıúù@ p…¿¿Øls}JÑ±¨¨4„„lC§N<lÚ4¦Nn8œèâ    IDATF!„B!„ÚC¯«¹–-„îİ¿ÃÖ­1}úUr={zbŞ¼ƒ¸p!ÔÎÅ¦qq1wîDG§còä®˜?¿-HÑ‘õëÃ°k×lİ:®Bx£¦8°V­:ş¹‡^½¼ô=Î;ô„¿¿¾ÿş,>ÿü¹…o¿V©™ÈPñùpr²ÆÙ³Ñ zGÆÆ¬¶U•oö‰RƒM›şR©Bıú¦ps³Õªø|xy9ÀÂ¢î¶ôõêåo¾9‰’9LMi÷»ºrå>ŒŒ˜xø0/ÆA,V‡¥’“s  l¶¹öû50Ğîî\xx4µuı7:?“ÉÀúõ#Q¯)Æß-[Æ¢woïª¼KpphˆnİZà·ß®¾W€ŠÅbB©Têp²º#%%6üıûo Y3[lŞ<ıûûÔª@qmwïŞ#:tGD"3S7üøãHôëÇ¯S¡š’9„ÂDœ;ƒÓ§ï"#CGÇFèÒÅ_|„®][ÜkKK3ğ´ÍIr¹±±éÚ†ªÍ›/â›oNÁÜÜ^^öeApu¨ªA=O¯?ÏbÌ˜íHLÌÆşıSÑ¦‹¾G"¤N{ŸĞ•&l•›«n¶Ò„®²²ò ¥j=yR …¢âsÁò¡+M°ÊÊÊ¢Bèª|ËÚÚ’fB!„RÍ
%bbÒË¦@(LÄÓ§…¨_ßmÛºbäÈvhß¾)mCHğï¿0nÜvnØ²e¬Á]Ë%„B!„Bù/½^ÑtqiŒ™3{`ÍšPôïïggkßFÃ†õĞ®]Süõ—¨Ö¨T*6o¾ˆU«NƒÏwÄùóóĞ¼9GßcÕGFâ»ïşÂòåƒÑ·/_ßã¼GÇFhß¾)t€
P–/ŒáÃX¸ğOôìùÆŒéˆ…û¢^=S}÷Ş=qölæÏï£ïQjG½ P³ ¨ØV%¥A$JÅ_E¡°°¤ìkØÚ@•º±JİZUB
½{{añâÃ¸zõ~µ´:¹\‰ôôg‹3´ígññ¸?*•
‹†««ø|„„´×~?995zïï'ƒ•+‡‚ÉdbÊ”İØ´iL•ÿn;¶#FŞ†øøŒw°²XÌJ‹fÉ«¥¥=ÃO?…áÀpuµÁÚµ#0dH›ÙÊC*ËÌ”àäÉ»8tè&D¢T4iÒ Ã†µÅGùÃÍÍFßãU‰DŠË—Å‹Ahh4òó‹Áãq1jT;zÂÛÛ¡Vı52b–=—pÄ¤ITÜ•9,,¿üòT*œ­áçç
À~~®µfƒ€×IIÉÁÈ‘[ —+qòä¬:õó@Hmò®¡+uàJ‰¤¨BèJÄJNÎÑËÎÎ‡RY±ÁTºR¿ŞcÃÊJ¶º{7ùùÅ8yòN… VãÆ–ôÜ‰B!„·PXX‚˜˜tDD$A(TH$RXZšÁ××	Ó¦uƒŸŸ+Zµr¦ğ!uHXX¦LÙ>ğÀÆ!ôóO!„B!„ZAï[BMŸş»E‹aß¾)Ur}úxcåÊÓµªa#++³fíÃµk	˜7¯¦MëF‹CtèÊ•ûøì³ß1sfL˜ ïqŞÊğáş˜3g?²³óacc©ïqŞ›——=Nœ˜…Ã‡obéÒc‹ÁŠCĞ£‡‡¾G{/½zyaÇËHLÌ¦¤U¬|[Up°Ÿöxf¦D¨‹3qòä]Ü¿*•
l¶Üİíàî®Àğùàóaff¬Ç{¢{\®¼½Mªÿøo›™Xœ	±8ÅÅ21aoß<AA>Ø·ï:ºw÷ÄêÕÃªôw1ƒÁÀŠƒÁd20eÊnüøãG:´m•İ^÷î-áêjƒ½{¯cùòÁït&“Aª7ôèQ.6mº€={®ÃacåÊaøè#z~g Š‹e‹Á¡C7qáÂ=XX˜¢gOO,^Ü:5¯UA¡WIK{†‹ãƒ‹ã TªĞºµ3æÍëƒ~ıø°³k ï«•³³5œ­µÏ=<)ÀíÛÉ‰R!&á‹/ ´T®rkªjãB¤ˆˆ$Lœø+š4iˆ={>®¯Q!oÎÌÌXû˜ø¦$)22ò ‘H+„®Ê±’“sœœ©´S¦ì®tSS£rMVÚĞUƒæ•‚X˜ÃÖ–]g~gB!„’şBanŞ|¡0qq¡P(áâÒmÛº`Ñ¢~ÜêÌfs„Ê¾‰9s`Ğ ÖX³fµCB!„B!¤ÖĞ{šÈØ˜…Õ«ƒ1dÈœ<yAAºo‰êİÛ_|q—/Ç#0ĞSçç¯n—/ÇcÖ¬ßabb„C‡¦ÃÏÏUß#Õ*"Q*Æßşı}²¨|ñÅa;‰?î¢ïqt‚Éd 8Ø]º´ÀŠ'0vìvôèáo¾
‡†úï´oßÕChh4¦Më¦ïqê$Ç
V~/äçãŞ½G‚3‡ßBQQi…ĞŸï ™L¼¼b=ŞİèÕË¿ıv«V«“o„J$RÄÇgTø7¿wï

7”ñx\øù¹bâÄ m¨N¦ËÉ)ÀÚµçĞ·¯wµ]¾şzX,>ûl?”JU…` ®okÔ¨vøñÇsX° /ê×ûö?u•êõŸX‡åä`óæ‹Ø¾ı7¶ÄŠC0b„?½YÃ•”ÈqñbNœ¸³g£¡P(ñÁ-±eË8|ğAK˜˜èıeV•S*UˆŠJÃ¹sÑFlì#°ÙæèŞ½%~şyºuk	KK3}Yc4n\Úç2™÷î=‚P˜„ˆˆ$üòË<{v
&ğô´‡@àÀşşn`³Íõ<ı»;pà,øİ»·Ä†!µ¢I–Rõ¬¬,`eeñÚÏ[¸ğO$&fcÏÉÈÍ-DnnQ…ĞUVV^… Vrr²²òğø±¥¥òŞ®&X¥	]•[•bq¹ì7š‘B!„}S(”HHÈ*k—J„P˜„””1áæfÀ“'wAûöÍö=7BˆnmŞ|Ë—ŸÀôéİñùçıêäû‡„B!„B©½jÄÊ>7.À’%GĞ¥‹»ÎˆÙÙ5€@àŠ#Gnt€ª´TåËOâ×_Ã1th¬\9ì3“—KIÉÁ˜1ÛĞª•~üq¤A^433F¿~¾Ø¿ÿF­	PiØÚZâ§ŸFaÄ|şù!té²
Ÿ|Ò3gÜNı,=zxàìÙ(
PÕ ––fe–İ´Ç
%ÒÒA,V‡kD¢4:tÅøöÛSøå—ÀãqÀç;‚Ïw(k»²3˜ÆÃŞ½½ğı÷áÎT´jå¤ïqªLAA	³´a)Í¿gff õbIww.‚‚|áîÎ…§§=5ª÷Êó^¿ş L&mÛV_˜™Á`à«¯ÁÂÂsæ€R©Âğá‚*¹­Q£ÚaÍšP=z£Gwxë¯g2P©(@õ"OŸbÓ¦øõ×pÔ«g‚ÿı¯7&Mêb0uQQQ)şşûNŸ¾‹¿ÿ…TZ
??W,]:ø¢AƒÚ¿ˆúÙ³B\¹ráábœ?‹Œ	7®®][`Á‚¾èÚµ…Á='ÓccVÙsGLšÔ œœ¡0I‹ÁÆƒÅb¢iS[mCU»vMáèØHÏÓ¿B¡ÄªUg°qãß˜8±3–-&Óğ^[Bƒ©©QYĞÉê¿¦¸X‰Dª]©Û­ò*“HŠ g"3S‚§O!“)*İ®:Te¡Xq8ì²À•E¥ –UYB!„ı’H¤¸u+‘‘É
“pûv2
K`ee??ŒÙ+||ann¢ïq	!5ˆL¦ÀâÅ‡ñûïÿbéÒ˜<¹v­5 „B!„BjH€
 ¾ür ÎŸÁêÕá›o†èüüƒ·Á²eÇQPPb¡£Œ	&MÚ‰û÷3±aCn­ï‘jgÏ
1jÔVp¹°sçDƒ^ü9b„ û÷ÿ‹¨¨4x{;è{ëĞ¡ÎŸŸ‡İ»¯bÕªÓ8sF„U«‚®­wooLš´™™yàpØú‡¼‹Å„³³5œ­+„p=<cøpìíjÃ8{÷^CI‰ÆÆ,¸ºÚhU<¾¾N°±±Ôã=y±–-›ÀÉÉ¡¡Qµ"@%“)˜˜±8£ìCİ,•	¥RUáßfÒ¤ÎàñÔÿ>ÎÎÖït{7n$ÂÓÓlvõ·¬ÌŸß,sæ@Q‘ãÆuÔùmXYY (È»v]}Ç r¹âõŸX‡äæJ±cÇelİz	ÆÆ,Ì™Ó'vÖ¶š‘š¥¸X†ğp1N¼ƒ³g£ •–¢MÌŸßAA>oµPÛ)JÜ¾ŒâpáBD¢T°XLm+_×®-àáÑÄ 7¨‰4Ï74Í‚YYù¸{7B¡z‡èƒ…ÉàpØÜàçç
À^^5*œôôi!¦Oßƒ7ñË/£1h½v%„Ô<ffÆ03{÷Ğ•ºİJ‰¤¨BèJ†M‚D"ENNäre…sü7tÅåZÁÖ–Ì_ÄjÔ¨¾A_Ÿ"„B!UK¡PB,ÎÄ­[qëÖCDF&#!!*•
®®6hÛÖ„ŸŸ+x<]Ã!„¼”D"ÅÇïFdäClß>½{{ë{$B!„B!„*QcTX`É’˜={?n¥ó&‡|±dÉœ=…aÃÚêôÜUM(LÄäÉ»P¿¾Nœ«ï‘jâbÆİ™Lß~ûõê^È®¼¶m]Ğ´©-öí»U«‚õ=N•06faÒ¤ÎôÄâÅ‡1hĞÏ:´–.këúúïtíÚffÆ‹AHH{}CŞƒÁ€‹KcŒû<´"—+ñàA–6¼#¥aÛ¶KÈÊÊ p8lm`‡Ïw ŸïˆfÍlÁb1õu7  ={z"44öÓëo+3S‘(bq†¶Y*>ş1JJä02bÂŞ¾!x<.‚‚|´ïÍ›stºÈüÆhß¾™ÎÎ÷¶æÎí33c,^|J¥&èü6Æí„~ıÖ!""é­ƒª,%%Ê×bPXX‚]»®àçŸÕ2“'wÁäÉ]aiYıá;òjyyE¸t)aa18sF„’9Z·v.MùÖúĞó“'¸~=aa18>¹¹RØÚZ¢sgwL›Ö­JƒÉ‹ÙÚZ"0ĞSà–JK†ˆˆ$…IX³&‰õê™¢ukg®àóáïßT/Á^ ¸u+S¦ì“ÉÀÑ£3àãã¨—9!¤*”]¹»¿Ùµ9MèJÓp•›+­ºÊÊÊƒH”ª=öäIŠ—‡®Ê7\•]•bY[[ÂÈH¿¯1	!„BHÕÈÏ/Æ;)
!©¯äæJaaaOO{tîìÿı¯7Ú·o†Æã½2Bˆş=|øcÆlCAA	ù|>]Ó#„B!„BHíUcT ì‡“'ï`ÆŒ}›§Ó¦¨,Ğµk=zË T{÷^ÇâÅ‡ÑµküüsˆŞÂÕf
…Ó§ïÁƒY8qb&lmk^CÌÛb03¦¾ûî/,ZT«¿oœ­±wïd„…Å`Ñ¢ÃèÔé[ÌÛ&Ô¨ø_ÄÌÌ;»#44ªB€J"‘B*-…]=NGŞ…‘îîÜJ‹é$)âãÕ*‘(IØ³çJK+¶UñùpwçÂÓÓÕ«¶¹{õòÆöí—‘””WW›j»İ7UşïO–Š}„ÂÂ ÏƒišFõ¿LM«öiTZŠ¸¸Ç˜1£G•ŞÎëLŸş–,9
…B‰?î¢Óó·jåGìÚuåTL(•*Îch¤ÒRüşû¿øé§°²Àv'Ì˜Ñ£Vÿn6D))9¸|YŒ°°\º…B‰Ö­±pa?ØªF6êŠB¡DLL:ÂÂb‹¨¨4˜˜° ¸aúôîàÁÛÛv(®,,L ¸•ıÛ¨ÿí²ÊU‰8tè&Ö¬	…‘nn¶\áççŠšÁŞ¾a•Ï§yíêïß¿ü2šjBŞ½éJ¸R7\•]i‚XÉÉ9ÚcYYùP©*>çÖ„®8«²À•¹6tõ¢c66ì…B!¤®Q(”ˆÏ@DD"#“qëÖC$&f š6µEëÖÎX° /üü\áîÎÕûFm„Ãƒ™3‡ƒCC<8ŞŸ&„B!„BH­W£T °víGèŞ}5V¬8¡óæœ¡CÛàÓO÷";;¿Æ/‚,)‘ãÿ;ˆcÇ"1~|úé´h±Š|ùåQ\¸‡?ş˜†¦Mmõ=Î.ÀêÕgpøpÆ×}#IMè‰›cÓ¦°|ù	œ<y«V£eK;}öJ½{{cşü?pÿ~&®\¹S§îB(L„««._^¨ïñˆXYYh<kÈd
$&fC$J…Xœ	±8ë×‡!'§ €:Äç;–5'qÀç;ê¼=I£];74lXçÎÅ`Ê”®:?ÿ›ÊÏ/FRRv…°T\Ücdg«¼¬¬,ÀãqàîÎEP/ø|xzÚë­5ğÎÈåJ´iã¢—Û/ï“OºƒÉdbéÒcJK1kV NÏ?n\'ÌŸÿ¾újĞ[=‡b±˜•vĞ¯+d2bÍš³ÈÏ/ÆøñøôÓî°²²Ğ÷hêÆ@¡0ÿ‹°°$$dÍ6G×®-°fÍpzÖê–%±8W¯ŞGxø}\¹"FAA	ÜÜlĞ­[KÌŸßíÛ7…¹¹‰¾Ç$¯Áb=nkÂøšvF¡Pª:xP™L‡À~~®\áåå ³çyyE˜7ïœ9#ÂÜ¹½0sf -Â'„÷`ffggk8;[¿Ñç—–ÊñìY!rsÕ*Mè*++yÚcšĞUF†yyE•Î£i¸²²2/k¼R¬¸\vY»•E…Ğ•­-›®UB!„èæ5½H”
¡0	·n=„TZŠzõLááÑİºµÄ‚}Ñ¡C3X[Ó¦%„÷#—+±zõüòË?1Â+W­ò		!„B!„Bj‚w¤qãúX½úCLš´øà»W/o˜››àäÉ;˜0¡æJ=+Ä¸q; gbïŞÉèÒÅ]ß#¼¥K¡Mà[áøš5¡øí·kØºuÚ¶}»VšÍ6ÇàÁm°k×UŒ×©N,j±°0ÁÜ¹½Ñ§B¯^?`ìØNX° ¯NítE,Î@RR6ÌÌŒÑµëj°X(•€R©„B¡Ğ÷x¤Š³^ØV•™)XœY"JEXX6múJ¥
õë›ÂÍÍV¨âóàåå ‹÷[äÎb1ñÁ-]-*MxL,Î(ûPßßû÷3¡R©`iiWWğxtîÌÇ…SkŒŒL‡c…&MjÆn|S§v………	>ÿü”JfÏî©³sØ
_}û÷ßÀÌ™oŞ¸ÅdÖ½*MpjíÚPH$E9²fÎìQãÃûuAn®áábmÓ’D"…³³5xX²d ºvmcc–¾Ç¬>Áµk	¸rå>®]»¬¬|XZš¡}ûfX´(İºµxãEÚ¤fãp¬h…À@O @aa	bbÒËZª’ğÃg‘—WKK3øú:A pÕ«ÌÌŒßúö„ÂD|úé^Èd
ìß?:ñt}—!„¼†‰‰QY«ÔÛµ\I$Ò
¡+MëUùcÉÉ98>KPZ*¯pMË•••E…ĞUù†«ò¡+;;«ZP'„By™™Ü¹“Š;wRpçN
îŞMEn®Tû¾¯¯l…V­œÁãq¨]Š¢S99øä“=
ñİwÁ5ª½¾G"„B!„B©65.@ }úxcĞ VøßÿâŸæ£aÃz:9¯©©z÷öÆ¡C7kl€*%%!![QR"Ç‰3Ñ¼9Gß#¼ØØGØ¶í¶o¿ŒGr1ujW ÀáÃ7±vm(V¬‚>}¼õ;d?¾öí»k× cÇfú§Úxx4Áñã3pèĞM,[v§NİÅ¢Eıì§ïÑ—W„Ÿş'NÜFjêS³ —+¡R)!—?¹½ËVR;h¾<_€\¾­JÓÌ´nİ9<{VXö5lm JİX¥n­z›àd¯^^˜:õ7ääèt÷JÍ®™bqâãÕa©¸¸Ç(-•ÃØ˜WW›²F)íìUÕ´¥k‘‘ÉhÛÖEßcT0fL(•*,^|¥¥r,XĞW'ç533Æğá~øí·«˜>½û¿aÏd2êL•L¦À±c‘X·îÒÓŸaøpæÎíõVY‰n)•*DG§áÒ¥xüóÏ=Ü¼ùL&şşM1gNOzÂÅ¥±¾Ç¬YYù¸qãÂÃÅ¸|YŒ””˜›› m[ŒİÚµkZkcä¹zõLµ-˜Ó§
…		YeªÄ²¦¼P1ááa¯m¨zİnÖr¹ë×ŸÃ?†! €‡Yã‚Î„B^ÎÌÌffïºR®ò*±ÄâLdfJğôi!d²Š›Ã¼(tÅá°ËW•ƒXMš4 ç+„B1xùùÅ¸wï‘¶]Js½x~múôîğós…··µ‚BªTx¸3gîƒ……)Îœ™–-›è{$B!„B!„jU#T ğí·ÃĞ½ûw˜7ïlß>^gçığC‚ƒ7"&&ö:;¯.Ü¹“‚±c·£qcKüñÇ'àriÁ­.ìŞ}ÆÆ,Èd
,_~å¢sçæ˜={?æÌé‰ñã;é{Ä*ãáÑmÛºâ·ß®Ö©  0û!0Ğ+WÂgŸíÇÉ“w°bÅ89½¸a!99{ö\Ã‚}«lÎ½{±qãßÚÿ¾˜¨bXÄÌŒŞ #Ï•o«*Ô„“D¢TˆÅ™8yò.îß?•J6ÛîîvpwW‡’ø|‡W¾ùÚµk1qş|,†¼õŒ‰´¬5ëyX*&&Ri)€çoğ0qb Üİ¹hÑÂ&&5ö©Èkİ¾‚?î¬ï1*7®#,-M1{ö~äæJñÍ7CuH3¦#¶n½„óçcÑ«—×}ºY¯v¨”JNŸ¾‹U«Î -í)l…¦¾ôw©Z\º‹ãpåÊ}ääÀÖÖ]»¶ÀÄ‰Ñ¥‹;,-Íô=¦Îåä 22BaÂÃÅˆŠJ‹Å€‡‡=‚‚|Ñ¹3şşnı˜KtƒÅbjŸS„„¨w–ÍÌ”@(T7TED$açÎp(•*8;[—ªÔUšpöÃ‡O0cÆ>ÄÄ¤cùò!;¶Ch»%„ºî}CWYYyÈÈ@")ªºJNÎP˜‰DŠœœÈå_?ü7tÅåZÁÖ–Ì_ÄjÔ¨>…®!„¢72™÷î=‚P˜¤K%$dB©Ti¯‘ù€Ïï¶m]t¶‰(!„¼Ni©«VÆ–-—ä‹ï¿ÿ°V^+'„B!„By»‚Í6ÇºuaÄˆÍ8~ü6l¥“óvèĞ®®68p@ˆåËëäœºpî\4¦MÛƒšbóæ±¨WÏTß#Õ
%8t(BRQ©€_½Œ¿ÿÁ!m1gN/=OXõÆëˆÙ³÷ãñã\ØÙ5Ğ÷8Õ®A|÷İ‡:´->ÿüºv]éÓ»cÆŒ•Ï™s ×¯'   «VWÉ<şşn=º~ÿıßW¶²ĞƒäMp8V´B` §ö˜f7K±8³,Ğ”ŠÃ‡o¡¨¨FFLØÛ7Ôªø|Gğx\8;[£^=StêÔ¡¡Ñ¯PååãáÃì
a©{÷áÉ“ €••x<ø|GûÇãÀËËµë{:5õ)23%hÓÆEß£¼ĞĞ¡mÁf›còä]ÈË+Â?|ïE„..Ñ¥‹;vï¾ú*&
Õ{İnM¥R©pş|,V­:ƒøøÇè×ÏûöM®µF5Uq±I¸|Y¬™˜° ¸aêÔ®àÁÛÛ¡Ö…;>-DDD®\¹k×î#..,|¾#ºtqÇ¢EıàççJÏ'Èáp¬ä‹  _ ê×P·o'C(L„P˜„/¿<Šâb7®Æ-ñàAìíâøñYğö®Y›’B©YÊ‡®Üİ¹oô5ÅÅ²²v+uØ*7Wª]iZ¯D¢Tí±ìì|(•_shBWê†g6¬¬Ôa+Mèª|ëUƒæhÜØò[v	!„B4är%<ÈÒ¥D¢TÜ½›ŠÒR¹vƒ³€ æÎíÿ¦ÔÜLÑ›„„,|òÉoxøğ	V¯Ön¬D!„B!„RÕØ  ğ0vl|şù!´iã‡†ï}Nƒ#Ø¸ñ,^ÜffÆ:˜ôı;‰™3÷aÄ¬\9FFô†½®üù§¥¥Š
Ç”JRR‚Í6Gn®´Öïîä‹•+OaÛ¶KøòËúGoüıİpîÜÿ°k×¬^}GDbåÊ¡èÒÅ pôh$şı7 °gÏuxzÚcôèU2Ëòåƒ‘ˆ² “½8Den®ÿÇ&b˜,-Í ¸A pÓSfº|    IDAT(”HK{±8Cûfî¡C7±v­º­Jz211ÂåË÷V­\®şõ×©ÃR))OµW..6àñ8ôÔ6JÙØÔ7##“alÌŸï ïQ^*0ĞûöMÁ¸qÛ1iÒNlÙ2ö½Ÿ÷Œ×	ãÆí@bb6ÜÜl^ûùL&ó•aQC.Æòå'ûıúù`Û¶qoô÷AŞŸB¡Dtt:®^½‹ã!&¢´T–-íĞ¥‹;>ÿ¼üıİjÄs|]úoCPttš¶!( €‡Ï>ë‰Îy°²²Ğ÷¨¤¨_ß<ğ ¨„]¼x_}ubqLMğğáôï¿-[6)k©rE§NÍkık+B!UÏÌÌÎÎÖpv~óFW‰DŠŒŒ<H$Ò
¡«òA¬äämè*++*UåĞÕóv+‹
¡«±llØ:iú%„BˆáÈÌ”@$J+»F“ˆèèt•¢^=Sxx4Ÿïˆöe—qjİ†>„Ã£R©°{÷5|ıõqxz6Á¹sÿ£Mà!„B!„RçÕè  ,Y2 ÿş›ˆiÓvãÈ‘ïİ  Ã‡ûã‡Îâ¯¿¢0xpkLùîÄ¬Yû0iRç:n©*¿şz¥Ò.´€zñmLL:‚‚ÖãàÁi°·ÿp^MelÌÂ„	øñÇsøì³`³Íõ=’Ş11iRgôïïƒ¥Ká£6#(ÈöÃ’%GµŸ§R©°hÑa4mj‹šé|#üúëDôèñ=ärY¥E;j][Ñ/‹©]€V¾­*/¯11.Æİ»)ˆ™LáÃ7k?‡Éd Q£úps³Aß¾|´k×<NNêôÀ‘‘ÉhÙ²IowéĞ¡şøã„„lÅ¨Q[°k×$XZš½óù>øÀ°gÏ5,]úúç-,ã…¿‡Ux¸+W‚H”†=<°nİGğô¤ö•ª¤Tªû×®%àêÕû¸qãòòŠacc‰€ ¾ÿşCtîì‡­ïQuF¡P"!!êÅ8ÿşû iiÏ`dÄ„‡‡=üü\1}zwtìØQX…T-¥R…½{¯cåÊ“pph„3gfƒÏw¬êûõ×p¨TêPŸ:På??WZ0F!¤ZXYY¼U¼¤DÜÜBäæU]eeåUbiBW¹ÈË+~áíj‚UåCW\.û¥A,B!„Ô|
…IIO†èèô²MÉR‘—W#xz6¯¯Fj__G4kÆ¡`5!¤ÆINÎÁÿşw 7n$bÆŒ˜=»mäK!„B!„P™››`Çñèİ{-V¬8‰eË½÷9mm-Ñ½{Küşûu½¨~ÿı_ÌŸÿ¦Ní†/¾ÒÛµÕõëğàAÖKÿ\.W"%%}û®Ãñã3kõnKcÆtÄO?ÇîİW1cF}£w\®¶l‹!CÚ`É’#Şˆ¼<)*æ˜T?şWœ;7÷­v=~S..±víG˜6í·JÆd2k]s©23%‹3¯n•ŠÏĞî’Éb1áàĞVVæ°¶¶DçÎ<¨T*¤§?ƒH”
¡0Ba"¹>ß|¾#š5³‹U·Şt‰Œ|ˆ6mœõ=ÆñõuÂ‘#ŸbÄˆÍşûöM†µuıw:“É@HH{lØğ7æÏï£åæJqî\‚‚|*„Ê˜L”JÃo 
±zõ\¿ş <üõ—:@@ªFrrÂÃÅãÊ•ûxö¬õë›¢U+gÌ˜Ñ<x{;ÔšPFQQ)¢¢ÒÊSê‰Dª½ÏÃ‡´az~@ªStt:,øÑÑé˜:µæÎíõ%Ç
AA¾
ò äçãÎ”²çIX²äJJä°µµ„Wøù¹¢U+glŠB!„¼SS£²V©74Ë ‘H+„®4Wå%'çàüù<<z”™LQévÕ¡*‹
¡«òWåCWvvÀf¿û„By=™L{÷!::½,0õ±±éJKalÌÇ…··úõó¯¯<<šĞëZBH¦R©°oß¿X¶ì8áÄ‰YğõuÒ÷X„B!„B!5FP€««¾ÿşCL›¶+úõóyïsÙãÆí@RR6\]mt0åÛÙ³ç>ÿü¦MëÅ‹ûWûí×»v]±12ÙËn3€TZ‚œœ‚Z ª_ß£GwÀöí—ññÇ]hñm™^½¼Ğ°¡†ÙP©!E¡P¡¨¨cÇnÃ™3sª¤jÀ _\º‡?şˆ€Bñüû”Á`ÀÔÔ I•—W„¸¸ÇÂR11éxú´ Àá°ËPöÇ··ÌÍMğóÏç±mÛ%,_>¸B(J"‘">>"QD¢TDD$aÏk(-•ÃØ˜WWm ÊİOOûZÛŒRZ*GTT:Æí¤ïQŞÇÅ±c30bÄfü3œ;»/ü\•JõÊ`ÊÈ‘í°fÍY?~ŞŞøõ×p:t2™_}u2™¼Ü¹Ôÿutœ«}œc0Ø°!Dï- oâæÍ$|÷İY\¹"F@ §OÏF«VôF£.)•*ÄÇ?ÆõëpíZ®_€gÏ
aeevíÜ0{vOtìØîîvµf'ßGr™Œ›7ÕÍ=QQiË•°·o7,\Øşşnàñ¸µæ>Ã"•–bİºsØ²åZ·vAhè\´ha÷Ê¯±´4C@ < êÍ*bcÓµU›6]À7ßœ‚……	<=í!¸A p…@àúV!„Bˆ¾˜™ÃÌìıBWêÀU^¥c"Q$)>-|mèŠËµ*k·2¯ÄâpØàpØhÔ¨>-ê&„B^¢°°dU¸Î-¥¢¤¤â5î|µ×ºéı4Bˆ!ILÌÆœ9pûv2fÌèY³éõ!„B!„BÈÌ
ıZáÚµÌ½-ZØ¡iSÛ÷:_÷î-ÁåZaß¾«½ıi÷î«X´è0.ìKm@U$++gÎˆ*„RÊ32bA¥RáÃ˜?¿/ll,«yÂê7yrlß~	‡İDHH{}S#(•*,Yr´¬!EUéÏår%ŸàÓO÷bÇñUÒt±rå0Üº•ŒÄÄlÈåêE2`jJoÊ‘×“ÉHLÌ†H”
±8b±:,•œœ `³ÍáîÎ…»;pwçÂÃ£É+Û‡zõòÂ·ßÆíÛÉhÛÖU{ÜÊÊ¢l±³Û+oÿ§ŸÂğäI uP‹Ïw,k¬â€ÏwDóæƒDE¥£´Tn0TNNÖ8vl&>úhü	N«"—Éøè£-077Æ=¿ô<––fèÔ‰‡õëÃœœcc#Èd
0• ¤DàåÿÆ*•
NNty×t.22ë×‡!,,~~®øóÏéèØ±™¾Çªşª#7WŠzõLÑºµ3>ù¤xğòr0øÇ
@İÊs÷n*nßNFdd2îÜIAffX,&x<.ÚµsÃ¤I]àïï†&M^j$¤:……Å`Ñ¢Ã(((Á—_Ä„	ïô³hdÄŸï>ß“&u n—
‘„°°üòË?`2hÚÔVÛP%¸UIû+!„¢ïºÒ„­rsÕÍVšĞUVVD¢Tí±'O
*]ÿ,ºÒ«¬¬,*„®Ê±¬­-adT·Z¥	!„Ô~šMÆ¥Ò	¥R6ÛîîvàóÒ|¾#š5³­°¡!„™L­[/â‡ÎÂÍÍ'OÎŸï¨ï±!„B!„Bj$ƒ	PÀ×_Æ;©˜<y7NŸşì½vıb±˜=º=¶l¹„9szUI»Ì‹œ8q‹Æ¼y½)<U…~ÿı:^´x›ÅbB¡PÂßß+V»;·ú‡ÓKÒ›7_ÀÈ‘íjÅ¢ä÷µ{÷UÄÄ¤¿0<¥!—+pî\4~şùoÌœ©ûŸYSS#ìÜ9=z|…B•JİÎB»’òär%ÒÓŸA,ÎĞ†•âã3´oø–ß3$¤}Y`‰'§Foüãñ¸ps³ÁÙ³ÑT/blÌÒ´ÊËÌ”hg‰RƒM›şR©Bıú¦ps³Õªø|xzÚ£^=Ó·ş{Ñ—ÈÈ‡hØ°A6ÚÚZâÈ‘O²ƒıŒıû§ÂÃ£	”JfÌØ‡ÿ} ¥R‰ğp±¶EDãÉ“<xÛ¶]Fvvö{KÓ8edÄ„——#D¢”J»¦—gcc‰Ö­kfø,.î1Ö­;‡S§î¢uk'ìŞ=	úË ”àöíd…‰
“ &¢¤D[[Køø8aúôîğósE«VÎ¿¦B¡DBB–vQNDD¢£Ó Tª´RÍ¢jİ!5Mrr/>Œâ0th,]:ğ•ëwáìlggkû ²³óqçNŠö±á?"PZ*×ş¼hBUµáñBySïºR®$HŠ*„®4A¬ääí±ììüJ×Â4¡+Çª,pe^!tõß VãÆ–´ÈœBH‘™)Ñ¥4×¥ïßÏ„J¥¾&ÃãqÀÃôéİË6üâTÉ†y„¢W®ˆ±pá!ddH0o^|üqº–F!„B!„ò
 211ÂæÍcĞ»÷,]z«W¿×ùFî€õëÃpäÈ­jiä¹rå>fÎÜ‡1c:à³ÏzVùíÕU
…»w_…Rù|ñ6“É€J´hÁÅ×_AûöMõ8¡şL›Öü!Äñã·1xpk}£W¹¹R|óÍ©W†§4”JV¯>ƒ–-íªd!½««Ö®ıŸ|²€z33ƒzx&:ôßğ‘¦Ù©¸X##&ìí‚Çã"(ÈG”Òõî˜½zyá¯¿¢Ş¹¡Q½àÊªB §|[•H”±8ëÖÃ³g…e_ÃÖª4÷«¦¾‘™Œ6mœkäloÂÊÊNÃ„	¿bÈØ»÷cœ>-Â©Sw TªÀb1ğÅGpáÂmØv×®«X²äu P7I•Ç`0ÀãqpëVÒKoÛÈˆ…aÃÚVÛß]\Üc\½z'v~åç‰ÅØ°áo9rîîvØ¼y‚‚|«eÆÚ&99‘‘ÉˆˆHÄ‰ˆÏ€J4kfÀÃ†µ­53åç…I¸yó!ŠŠJQ¯)<<šÀÏÏ'ÀßßNN†Ií$“)°{÷U¬Zu\®œŠNx¯ÿB°±±D` §öùuQQ)¢¢ÔáC¡0	7ş£m¨óğhRÖ„é
7°ÙæÕ2#!„bÌÌŒµAå7%‘H‘‘‘‰DZ!tU>ˆU>t•™™Wé¦¦Fåš¬,*„®^Ä²µeìëhB!5ƒB¡DRÒDG§!::QQiˆŠJCn®..áímàà¶ğòr€——½Î7!„š";;Ë—ŸÀáÃ·Ğ£‡˜‡†ú‹B!„B!¤Æ3¸ú..±víGøøã]hÛÖE»{õ»°¶®AƒZcÇË5ª]•¾{÷n*&LØ¾}ùX±bh•İÎŸEff¾öÿY,&5ª‡yóúÔùæ¥fÍl1hPküğÃYùÂÈ¨îîËd2Ñ£GKüûïdeåƒÁP‡4KJä/ıš©SÃ_Í§ûæ²[áŸîáèÑH(J˜˜ÜÃ3yK‰ññÂR÷î=BAA	 hwÆÔ,ÀwwW‡Šª£¬W//lÚt		YhÖÌV'ç,ßVUşw·&€ g >>'OŞEBÂ9(•*°Ùfpw·ÓŞw>ßŞŞ07¯ÖÈ—‰ŒLÆˆşzá}YX˜`÷îI˜2e7æÌ9€„„lhœ
…
dáÈ‘[6¬- ÀÁ¡!T*ŠW…NUhĞÀ\®22$/ü¹\QmÁ¤ÄÄlºÏIáããøÂFµ””lØğ7öï¿fÍl±iÓôïïC‹úŞPaa	îÜIÅ­[™ŒÈÈ‡xò¤ ÆÆ,ğùèÒÅóç÷…ŸŸ+5ª§ïqßKrrvQNt´ú¿OÀÈˆ	ww;´níŒ!CÚÀ××	Í›sêôóMb8.\ˆÃÒ¥GñèQ.æÌé¥÷İiÍÍMÊBRn˜>]},99Ba"""’ƒÿ‹ÅDÓ¦¶Ú†ªöí›ÑâB!ä-YYY¼U#jI‰¹¹…ÈÍ-ªºÊÊÊ«ÄJNÎAVV?– ´´ò56M›•••¹6tU>lU>ˆÅå²©µ•Bê°¼¼"ÄÅ=®pı<&&Ri)ŒŒ˜ps³Ÿï€Î»ƒÇã¢m[4lhØ×Ÿ!äMÈd
ìÚukÖ„‚Í6ÃÎĞ³§—¾Ç"„B!„B1¹B¿o_>¦Më†yóş€››Ú´qyçsMšÔ?àêÕûU¶Óvbb6BB¶ÂÏÏë×¤•UlçÎp0*°X,˜˜aîÜ^˜81€)eæÎí…Î¿ÅáÃ71|¸@ßãè›m†Í›ÇP8"#SpëÖCÜ¼™‘(ÅÅ2°XL0™Èd
¨T*””È²aas«dÇ·ßÃ­[‘˜˜]-!R=

J˜˜¥K‰Åê7{5»7[YY€ÇãÀİ‹  _¸»sáéi¯×°AÛ¶®°±±Dhhš5û Jo‹Ã±B` U…v·üübÜ»÷¨Â›ãGÜÒ¾9®iáâóÀç;‚ÇãV[›Í“'HM}Š6mœ«åöª’©©‚‚|1sæŞJ¦R_}ıúñann‚=<°jU0æÏÿã¥çS*UHŠì‡M›.@.WTú;»ğñqÔéıx‘´´g2d

JÀb1±råi9ò©öÏÓÓŸaıú08p£,œ?C†´Ñi“[m¤	2hZ—îÜIL¦Ğ6ÈÛüü\ö÷˜R©BbbvYX*ÑÑé‰Ò—W¤mx{;àÓO{À××±F„:	y[÷î=Â×_ŸÀ¥KñèÓÇ¿ÿ>µÆ4mšğuff¶õM(LÄÁƒBíãæñG p…——½î&„BtÈÔÔHÛ6ı¦Š‹eH¤ÚĞ•ºİ*¯Â1‰¤bq&23%xú´2YÅ×‘¦¦Fe¡*mÀŠÃa—®,*±ìì¬è0!„™L„„,Ü»÷÷î=Fll:îİ{¬İ ©aÃzğôlGŒ!€§§=Z´°£Ç{BHtş|,–-;´´§˜<¹+fÍ
„…]Ÿ&„B!„By{uyÑ¢şHHÈÂ„	¿â¯¿æ I“ïtOO{øû»aûöğ*	PåæJ²ÎÎÖØ¶mü›ïè½t)pïÎç©íRŠY¿Å*Œ³•`¶S>^Ø\Ø¤ïÑ^É¾øğªúİ¡\\#8X€5kÎbÈ6zİeşéøçƒ OÙL E ^jŒ[ù&ˆÌ3Æ|3$± Tª–ö3:ÌÅo9:»} ;£Óì}»€°:¿ƒT?ïC&S 11bqFÙ‡:ü“	¥Rcc\]mÀç;`Ò¤Îàñ¸ÕüyL&İ»·ÄÙ³Ñ˜>½jT/bii¦m ĞP(”HK{¦ ‰Di8tè&Ö®=•J¥¢ñùeUøø8ÁÔT·OunßNƒÁ€§§=®^M@‡M¶­èêÕÌ½ª”J©T*<{&Å¯¿†k¿BBÚ#++kÖ„Bõ‚/’ËUÈÍ•bÊ”®øùçó•şÜØ˜…¡CÛTùß×“'6l#>-€\® üûï\½š 7·Æøå—Ø³ç86V®†#üët#ãËdfæáîİÜ½«JEF¦@"‘ÂÔÔ|¾#Ú´qÆäÉ]Ğ¦¸Ü7_DY“ÈåJ<x¥}LQ?¾¤A"‘VØÉ¸gO/ğùğòr 7£‰AËÌ”`ÍšPìß^^ö8|øS´oßTßc½‡À@OmğZ*-Ett""’ &aÍšPH$RÔ¯oŠV­œ!¸|°“B1TffÆ03{÷Ğ•ºİJ‰¤¨BèJ½±C$)rr¿îÓøoèŠËµ‚­-˜¿0ˆÕ¨Q}Ã¼>J!H"‘–m˜¥¾Ÿ¨(õ†všk1îî\ŒÕN»q–“S#ƒ½şJ!ºòàA–-;óçcè‰½{'×È÷	!„B!„BÁ¨˜L6lÁÀë1vìv?>ó4NœØS§îÆÃ‡OàâÒXg3ÊåJL¼EE2ìØ1şíæÛ¸pvšÖ‚6}«ÇRar“Œµ+„‹™\ßã¼¹£G.]ª- 2gNO>|
Ò¾ZnS§ªøçƒÅ <êÉàQO†Ñ\õ±<9w
Œ™ocÆÒ:ân!Ã•6™°5Q¾ş“ëŠ·øùP*U8zô<)À”)]«l¤ÌL	d2.]ŠÇ­[ËÂRQR"¯Ğä£J5oÎ1¨&„Ş½½1qâ¯ÈÊÊ‡­­¥¾Ç‹ÅÔ¶P”o«ÊË+B\Üãrá‡TìÛwÅÅ2mhM¨âóáëë›w¿?"Q*\\#<\ŒO>Ùoo{¬\9ì½Ú0õ!**cÆl…RùòÇ3…B‰uëÂ0rd;4l¨nD›3§—6XU9D¥ÂÓ§…hŞœƒ–-› .îq…Ï‘É0 UUÜ­§O1xğOxô(·Â":‹…Ï>ûÙÙêïç•+‡âÃœ*“—W¤J©?Rñøq.\]Ã××	óæõF«VÎğò²7ÈÅ…99ÚŒãâ2´»—–Êaff&ğò²Ç€¾ğöv@Ë–Mò~ò"Ri)vîÇúõa°´4Ç·ßÃÈ‘íêyÉËXX˜hC×Ó§«w%$d•ªñçŸ7±fM(ŒŒ˜ğğ°×6Tµoß××÷ø„Bùò¡+wwî}&t¥i¸ÊÍ•V]ee©,5Ç<)€BñòĞUù†«ò¡«òA,kkKz=I!¯ ÙlL$J…Xœ	±8wï¦ ++ *l†ìWe›aBˆ¡{ò¤ ëÖ…bÏkhÑÂÎ 7D"„B!„B©iúJtıú¦Øµkúõ[‡™3÷aëÖqï´¬wooØÙ5Àöí—±bÅÍ·téQÜ¼™„#G>}«6µ&M¦MÓÙ<u5€¥úâ]4Ö]pïMØÛ7ÄGùãÇÏáÃı`bb€ÕüóÁĞ¹ì£ª5©†Û0(oøóqíZ¾üòbcÓaaa‚É“»¼÷Î”/Ú36ö
K  W¯Ş‡¯¯üü\1qb Üİ¹pw·«oôvéâSScœ?ƒ‘#Ûé{œ—b³Í+µUiZe4m`"Qöî½ÌÌP êö
M°Ïw ŸïˆfÍlÁb½~ñ“H”ooÄÄ<‚‘±±1`ÀOèßß_~9 öö«ì¾êÒ‚¢¨HàÕĞÒR9Ö­;‡¯¿¬=¶lÙ dfJpölT¥¾Ÿ=+ Œ!Àòå' —??¿½}CxyÙëîNüG~~1†ß„ääœJs)
¤§çbüøøê«A5:óàAìíVYSJaa	bciÃRwï¦")é	T*š4i __'Œ×­Z9Ïw›m^%sT•’9Äbõcu|ücÄÆ>F\Ü#íkëúhÙ²	7Œ oo4oÎ¡Å¤VR*U8|ø&V®<…‚‚LÚŸ~Ú£V<Oy‹Yö|Œ«İ("3S¡PİP‘„;Ã¡TªÀá°µíT+¼½hWsB!Ä ½kÓ•:p¥n¸*ºÒ±’“s´Ç²²ò+m"¢	]q8Ve+smèêEÇllØµ"ÀN©ùd2bcÁÇÇ±ÊoK¥R!5õ)îİ{¬İ¸&6ö>|…B	ss¸»sááÑ3fô@‹MàéÙXTùl„bÈ
K°eËElŞ|õê™aõê`îOÏ'	!„B!„BtÀàWN9:6Âöíãñá‡›°n](æÎíıÖç02bbÊ”®øöÛÓ˜=»'¬­ß'êƒ…Øµë*~ùe4|}Şû|„èÚ¬Y8pàvï¾Š?î¢ïqygdaÙ²ã8>V» ^*-Ezz.Ş,Ì’Ÿ_Œ¤¤ì
a©¸¸ÇÈÎ®¸#¦»;AA¾àó0nÜ,XĞcÇv¬²û¦OffÆà!44ºF¨^ÄÈèùâéòÊâD¢TDD$aÏk(-•kÛª4*ww.<=íÑ¨Q½
çˆŠJÃ¤Iqñb
4ë§ÎÂÙ³Q˜<¹+fÎìKK³êº»ïäçŸGaëÖKøóÏÈd
(•ª4Jr¹;w^Á„	Ú–N&“GcäÈ-¸qãA…°R^^ `ğà6øúëãÚãÆÆ,Ö¶ÊîOQQ)BB¶">>£RxJƒÅnÜH¬±A™´´gøæ›“8qâ/îO>éşŞç,ßĞ&¥B$JCBB&”JØl3¸»Û¡[·–X°ÀşşMkDÛÜÛÈÌ””5 fhw4‹{\ágÚİ‹Ñ£;€ÏwÇ…³³µ¾Ç&¤Z„‡‹±lÙqÜ¿Ÿ‰áÃ˜7¯Ï{502Ç
AA¾
ò ^€™¡0"Q~øá/äåÃÒÒ¾Y¿Z¤    IDAT¾N\µáìÚ6#„Bê233cmËõ›(-•ãÙ³BäæªUšĞUVV22ò´Ç4¡«Œ‰öõqyš†+++ó²Æ+uÀŠËe—µ[YT]ÙÚ²)àMyc*•
ÇßÆŠ'ñèQ.nİZ
;»:;ÿ‹6»wï

Ô›q8lğùèİÛ[Û.õ¦›VBQ“É8xPˆ5kÎ¢  ãÆuÂ¬Y¨_ßTß£B!„B!„Ôµb5@à†Õ«ƒ1gÎ4mj‹AƒZ¿õ9Fj‡õëÃ°cG8æÏïó^ó…‰˜?ÿÌ™Ó¶z¯sRU¸\+L™ÒkÖ„bèĞ¶•B„Ôt¹¹RlÜø¶l¹ÍZ’çÁ	ââW
PÉd
$&fk›‰4ïïßÏ„J¥‚¥¥\]mÀãqĞ¹3<>>N/Ô…,½{{aáÂC(((©oÎXYYTj«Ò|OhÂbq~ú)O xşÆ?Ç…22$ğò²Ç†£|ŞH&S  6o¾€n`Á‚¾øè#ÿ»@ iS[¬^Œ%KàØ±HlÛv÷ïgÁÈˆ¹\Qás™LV®<…­[Çi³°sçDøşÏŞ½Çå|ÿtuP¡RÑI¥¨(,¬f›™hÌiCFcÃÆœ2‡s1Æf³-3‡as¶/6[1sˆT+9Ut¤t¼®Ïï¸~¢åêğºßnnô¹>ŸÏûyåútx_ï×ç• }ş·ne`m]V­ÜùãHòò4äæªéÒÅ»TKn®šAƒVsòdl‘ÅS jµÂ¹sqìß??¯RÉò$nİÊbéÒı¬\ù»ö5ví±Î¡(
—.%söìÎ½JXØUÎœ¹JBB ööxy9ğúëÏáåå@Ã†8:Z–ôS)yy._NâÂ…x¢¢®™FE]'##===œœ,iĞÀ¶m0bD[4°ÇÅÅºÌ^B”¦ãÇc˜7o7GFàïßˆ¯¿~W×šºU¦T­Z…Ö­İiİÚøÿÎ•¡¡1„„Dóã!,\¸ÚU-[ºÉïLB!D%eddp§«Ôãu¹JK»] èên×«{·ÅÆ&±ÿMââÒÈÉÉ+p»]®ÌÍM]İÛáêŞ¢+;;ór×EXQ2¾ÀŒ¿páBœv~)""á‰
¨âãÓ¸p!¿@*¿P*ˆˆí¼Ÿ9îî6x{;Ñ«—õëÛááaW!æ…BW4…;şeşüß¸|9Y[8%sQB!„B!„%¯BPøv•±cƒqr²¢iSçÇ:ŞÄÄˆAƒZ³rå!†{3³'ëqùr2ï¼³†ví<ùàƒOt!•÷ßoGpp(üÆìÙ=tGˆbÉÍU³nİÌ™ó+ÙÙ¹¨ÕLª8~<šìì\ÂÃóßä=>‹Q«5Üé(eGÏÏkßä-nÇªÊ¢];/ÔêM9Ák¯5ÒuœRah¨_h·ª+WR8şaaW9>_=ÍÅ‹7 4h·ogz>µZCrr'şÄš5G˜5ëMš7¯[êÏãIU«V…ÀÀ	|‘Ó§/óõ×ÿcûö“¨TzÚ¢¨Ü\5»væøñŞ¥À±›6§cÇÏ¹v-µZÍíÛ9h4
*•¾9€““Ø—xşÜ\5ï¼³š£G#ıZp?•
fÍÚI»v:/‚Ôh~şù8Ó§oãæÍlÔêÿ/\;}úr‘Çİ]èoÑß‰INÎ ş¿è/0°9;âííT.ºÎäääñß×‰Œ¼Ndd~akddQQ×ÉÍU£§§‡ƒƒnn64o^—~ıZàáaGıú¶T­*t„øçŸX.ÜÍ¡Cáøúº²eËÈ2ıı§,¹·se`à‹@~‡»BBbaÍš#h4
ÎÎVw
ª\ññqÁİİFçßO„BQ6blütEWùW7(ÄŠˆH !!ääíïîwVteccv§àêÁB,{{õKúé!‘ğğ8fÎÜÁÁƒçÑ×W¡ÑäWOè•ÀË/{yìİRwo2‘ßQêî¥ÌÍMqw·¡A{ºvmŠ‡‡-õëÛ•‹y&!„(/Eá×_O³pá"#èÖ­)ß?'§âuJB!„B!„¯ÂPL›Ö•ØØ$ú÷ÿ†íÛGQ·n­Ç:şw^båÊC|÷İŸ¼÷^ÛÇ?++—·ß^…­­9K—¢RÉB*Q¶U­Z…‰;2n\0ıúµ¤A;]G¢HŠ¢°sç)fÌØNBÂÍ‡Kh4
ûögÉ’ÚbÿFwŠ¦òßè52ªPßK…µu5š6ufÏ3¶€ª(µk× ví:ÍŸÿßÿ;{³jÕá"UEˆˆxŞxãK^}Õ“™3ßÀÙ¹l¿áÕ¸±#_~È”)Ù°áOÖ¯ÿƒääÛ¨Tzh4
3flgÇ1±²ªFpğp:uZLZÚm4…ôôlÌÌŒéĞ¡!Uª™™Ë›o6+ñ¼jµ†‘#¿ãĞ¡ğ‡~=00P¡R©ÈËS£Ñ(ü÷ßuâãÓè¼%åÈ‘¦Lù™ÿş»¡}½ÜëâÅDrsÕÚ¢¢â9}ú
§O_æÌ™+deåbh¨‹KM7®Í˜1íiÜ¸6ÖÆÔÔH7Oª˜’’Ò‰‰¹Áÿİ¸S0•@DD—.%¡Vk00Páèh…‡‡-¯¾êÉğámqs³¡^½ZR(%D!ÎŸ¿ÆâÅûØ¹óM›:±nİà2Õe¯¼²±1§sgo:wÎï˜ÍÉ“±„„DÃÔ©[ÉÊÊ¥fÍêx{;áëë‚ŞŞNò3¦B!ØÓ]]¿~“øø4ÒÒ2]ÅÆ&CZÚm’’ÒèŞ|Ñ•­­9µj™aaaRè6KËjRt%„]½šÂçŸïå‡şÆÀ ÿ½È{çÇôô 22(¼P*<<7nÿ_(åáa‹ŸŸ×LØQ«–J	!Di:r$‚Y³vræÌÚµóäË/ñô,ùÑ	!„B!„Bˆ‚*ÔÊ}}+W  à+zõúŠ;Fco_üÅ±ffÆ¶`åÊß4¨5ÆÆ†5şÔ©[¹v-½{Ç–ùÅ« QQQ¸¹¹¡Ü¿j·»téÓ¦McÍš5O³Xãß/((è‰Sif+ëzöôaıú?˜6m+›6½§ë8e†\%ïi®®fññë‹ù÷ßKèééiï¤YµZCNNÑÑóûk¹(¨C‡†,[v¼¼üÂ†Ê,<<fÍê`g—wæûïò|?µ:ÿuzèĞyZµšEÛ¶ö¼öšúúe¿ÀºN
jÌéÓIüïqÄÄÜâÄ‰X¦M[IÃ†–ì?xp=¾øâ,99j~øa3––ù….Õ $ä:Uª\ç§Ÿ~*ÑŒßÿÿ¿D¥ÒCOïÿ?ç GÕªX[WÁÖÖ”š5M°¶6ÆÚº
ÖÖ&=º¯D³<Œ¥¥%¯¾ú*_T7}ú6~ÿıB»ßO­ÖĞ¢Å,ââRÑhÌÍMiÔÈ¦Méß¿^^Ô«gSf¯É›7³ˆ‰¹¡-”Š¾NLL"ÑÑ7¸y3È_ çêZ7·Z¼ñF3ÜÜl´…R²OˆG;>Å‹÷²sç)š4qbíÚw¤pªU«V…Ö­İiİÚÈïxîÜUm‡ª+~gÖ¬˜˜Ñ°¡¾¾®Ú¢*S§B!DEvoÑÕıİµ‹’••{§»U~±UjêmmÑÕİ®W§O_Ön»qãÖ¿¿Ş-º²±1¿Óİ*¿ØênÑÕ½]¯,,L°¶®¾~Ùü¶Ì¸vşøC×)DY¤RAûöP½:)),_~ˆ•+GO/ÿFN¹¹Î/åæª9pàNÑv-¯Q£*õëÛâînËk¯5ÆÍÍ†ì°´¬ú¬Ÿ‘BTZŠ¢°o_‹íåÌ™+¼öZ#>ÿü-¹É©B!„B!Ä3T¡
¨ ÿÃµkß¡[·¥~ÍÖ­#17/ş‚¥¡CÛ°zõ6m
¥ÿÅ>nçÎS|÷İ1¾úª?.,®¨¢££ñõõ%11±ÀömÛ¶Ñ­[·RÓÂÂ‚	&<³ñ*:•JO>éN—.KØ»÷,íÛ7Ôu¤
C®’1Mÿy¾Y}Iûqq°bc“00EøO«cÇÆÌœ¹ƒĞĞ^|±®®ãèÔ™3WèÛ÷EÂÂ®=²ˆò»U*ÈÍÍ¿ûë¾}—ùá‡yäæŞ(í¨%ÎÀÀSS/æÌ	&''®Ğ}ŒŒ©QÃŸ÷Ş†F“qÏqŒ½¸DóèéU¡V­(J.yy)¨Õ)äå¥¡V§Şù;EÉ#*ªD‡}b—X¹òO~üñom‡Ò‡uÍR©ôhÒÄ‰O?í——C™üÙ2==›K—’îJåGåÿ¹Nbb: ††ú8:ZâêZ__|qu­‰‹KMìí-¤[«O <<Ï?Ï/œª_ß+úóúëÏ¡§'×Ó³d` ¢qcG7vdğà— îtvˆ&44†}ûÂX¾ü Š¢àìl…¾¾®øø¸{a³B!Di166ÄÙÙê±:e§¥İ&>ş&ii·]İ[ˆ›¤-ºº~ıÖsxUªÜÓÉÊ´@ÑUa…X5kš•Ûß?ÿ|/¿şzŠwßmC·nM‹w£Ù³aÙ²Ò'Ê¥Û_®`õøüó½ää¨ÉË{ø RSo3iÒë¸»ÛâáaKÍšÒQJ!tE£QØ¹óK–ìãüù8üü¼X° €†tM!„B!„¢Ò©pTµFçÎ_0hĞj¾ÿ~Uªï©Ö¬Y€ _¾ür?½{ûbdôèã®^Má£61p`+ºvmò´ñËFCRRÒÛ÷îİ[â&î²¶¶fÎœ9…wõêÕR³¢kÖ¬;{3}úv^~¹~±¯ñpr}”Œç”$:Ö¯ÎÙÛF\½šŒZ­ Réİé ¤A£)¼!/OMLÌÜÜlqâŠ¥NkÜÜlØ³çL¥. JIÉàÊ•5ªÍæÍ¡Š_ôõõE»­J•ü…H^^dğõ×9xpÍš¹cdô…Á³ôµ®”ûöà7¦Ğ¾ı4Eû§84ÿF¥œğáÒÒn›Dll—.%ø÷¥KÉÚÅpææ¦¸»Ûàáa‹ŸŸ'NNùñ<<ìäg
!JÈùóq,\¸›ß~;CÃ†¬]ûíÚyJáTrwrÏ>@~7¾S§.MHH¼…ìì<llÌhÜØQÛ¡ªIgé¼'„Bˆ2ÏÜÜô±nT—Gjj©©™Š®®_¿Y ënÑU||*7of:îİÂª{‹®lmÍŠ,Ä*şı÷aa×øàƒ˜1c;ƒ¿D¿~-°²ªVôAj5´m<» ¢\ØWË›> ùvøc—‘‘C÷îM©QC:L	!„®h4
»vbÁ‚İü÷ßu^}Õ“E‹zÓ¸±£®£	!„B!„BTZvE£ß}÷.İ»É°aëXµj úúªb;fŒÁÁ!lÜxŒ[?tßÜ\5Ã†­ÇÎÎœ?îRÑ[^^Ÿ~ú)kÖ¬!33“×^{%K–`aa@jj*cÆŒaçÎÓ»wofÎœ©=~ãÆL:•›7oÒ£G.\ˆ©©)[¶laÚ´iDEEQ³fMÆÇ¨Q£
Œİ¼ys lmm‰ 11‘ªU«bbbBTTnnnÚ¶÷\Ôw÷Û±cãÇçÆôêÕ‹…råÊ•ç¸w¼{)ŠÂG}ÄşıûÙ¿?ÖÖÖäææ2mÚ4Ö¯_OFF}úôaÑ¢E\¾|7778ÀÀÙ¸q#­[·fóæÍÌœ9“èèhÆËÔ©SŠ<Oy6ujÚ´™ÃçŸïaâÄNºSbäú(ÿ×ÇšŞèiÃ‡“›«&*ê:‘‘ñ\¸ÿ',ì*W®,¬ÊËÓ Vk“ªĞ¡CCvìø—éÓËo'³§–_€èååÀùİu¬¬ªáæfKıú6¸¹ÙP¯uëÖÂŞŞB{ÜÁƒY²$7·ZÅ*ÊKJJÕª=Ovv ‡‘‘jµæ¡İ§ ÿMÕ3g.—z¾ää®^MáÊ•”;…Q‰Ú"©Ë—“ÉÍÍ¿›±©©ÎÎV8:ZQ¿¾:4ÔI9;[Ék[ˆRtúôeV­:ÌÖ­ÿàæf#§Ê33cZ·v§ukw îàüùk„„ÄÃòå‡HIÙ‰©©^^øúºâëë‚¯¯Ëc-NB!„(‹ªT1¸ÓUªøMYY¹¤¥İ.Ptu·ÃÕ½Ûbc“Ø¿ÿ&×®¥jo½wÜü¢*ÓEW÷v¸º·èÊÎÎ33ã’~ú\¿~Èÿı>99ƒ…÷²hÑ^ºvõæ½÷^¥A»ST\	˜`b¨‚¢(èë«Ğ××#'çÑ]¨"#ğõu})…BÜ+33‡ààPV¬8D\\*İ»7eõêAÔ­[K×Ñ„B!„B!*½
½Ú±~};V¯DŸ>+
ú™9szë8súõkÁ’%ûéİûLLŒŠÜwÎœ]œ?ß~ûccÃ’ŠşX/^Ì–-[øõ×_Q…Áƒ3kÖ,æÏŸÀÈ‘#‰'$$D[ÌP½zuúöíÀêÕ«Ù½{7)))òé§Ÿ2iÒ$èß¿?»wïæ÷ß'00ÀÀÀcÿõ×_¸¹¹i‹C vìØAçÎ™ûæÍ›céÒ¥lß¾ääd™3gÎ
OQ&L˜À8pà VVV ,X°€ˆˆ;Fjj* ((ˆaÃ†0ş|æÍ›‡··7 ÁÁÁ:tˆÍ›73dÈFŒ••Õ#ÏSÙÛ[0iÒëL›¶•N£Q£ÚºT"äú¨X×‡¡¡>Ø=°Èàÿ«ˆˆˆ'<<ÈÈxªW/ù•Q‡øòË„‡ÇQ¿~å\àqş|––U±±1ãèÑÉR­Z]Çeœµµ	ññËøçŸÜ¸‘MDDş×¨°°kDGß ;;÷Îz@ÁÎTwõÆı¤âãorıúMbc“ˆ‰¹Á­[ÿwossSmAÔk¯5ÖşÛÉÉ
GGKT*)ÖâYQ…ıûÏ±lÙABB¢iÖ¬«V¤}{/)œ*ÇõiÜØ‘Æ<ø% bc“	‰&44†}ûÂX¾ü *•uëÖÒv¨záWœœ¬tœ^!„¢ôblüäEWùİ­ÒHKË,Pˆ•p“Ó§¯–v›ääŒG]ÙÚšßéneR ËÆÆ3,-«=²ƒhRÒ­«ÕùcşòË¿üüó	š6ufèĞ6tìØ¸Ø7ş•W &’ÀQıÉ|û.\ˆçÜ¹kœ;w³g¯vŒŒüùûoÜ£RéI•B<c		7Y½ú6üIVV.¾¼÷^[-uM!„B!„BÜQ¡¨ ^|±.K–ôeøğõØÚš3fLûb7jT;~øá/Ö¬9Ê{ïµ-tŸÿıï+VüÎâÅoé´ÃÉªU«˜3g6`íÚµ„‡‡ù`~üñGN:…«kş›$Ÿ|ò	ãÇ×ˆ,^¼777 fÎœÉÄ‰™1cgÎœÁÑÑSSS\\\ HNN~d;w²jÕªGîgllüÈ1,XP Û”)S()l¼‰'2ş|ÂÃÃµÅ! kÖ¬áğáÃØÚÚâèèÈÜ¹s7nœ¶°cŞ¼y4jÔH»ÿ{ï½‡……`È!¤¤¤`eeõÈó”W´ä—_NòÁ?ğÛo>òàò@®Êq}UX%JF“&NØØ˜±gÏÙJ]@åéi€µu5§å‹‚£cš4±¦}ûüïEÉÉ¬^}˜•+ÿÇíÛ9€‚R°~Š¬¬\4¥ĞÂ%EQ¸~ıññi$$¤qõj
qqiÄÇ§qùr2W¯¦ŸF^^ş‚CC}ìí-¨]»5ğóó¤vmK,ppÈß&]¤„Ğ½Ü\5Û¶ıÃòå¹p!Ö­ŒŸŸ—®£‰Rr·XµgO ¿SÁ©S—	‰!$$šààrsÕØØ˜áëëŠO~‡ª†kKa«B!‹®<<l‹uLrr))şNNÎ ))]ûïÿ½¤},5õöç033ÁÊª––U±´¬J¦wş]+«ª$%e:öİâ­Ó§/3tèz,:´}ú4GzŠG111ÂÛÛ	oo§Û¯]Kåüùkœ?ÇÙ³W8sæ
—.%¡V+ÄÅ¥é(­BT.çÎ]cíÚ£üôS(Õ«óÎ;­8°5––UuM!„B!„BÜ§R¬”ìÜÙ›ää&Oşcc#†kóÈc¬¬ª1p`k–-;H¿~-èb’ÍGÓ¹³·v±“®ÄÆÆR¯^=íÇ4 Aƒ $$$ V«©[·®öñzõêqåÊíÇw0 ê×¯O\\FFFÄÆÆ2räHÒÓÓñò*Ş¢½ôôtòòò¨Q£F¡+÷¬.Î÷fkĞ AÜ/44”6mÚğÙgŸ±víZíöË—/cgWpñ¿¹ùÿßÑ²~ıú³·Ï_,ohX°»Ø£ÎS^©Tz,\Ø›W_Ç7ßü¯ÈâÁòD®¹>ÄÓS©ôh×Î‹={Î2z´Ÿ®ãèÄ…q4kVG×1D9wéRß|s˜şD£Ñhœ
caaÊ¯¿&..•k×R‰OãÚµTââRIH¸YàÙùİÑÌ©]»ØÑ®'5¨]»–Ô¬i&í…(ÃnßÎáûïÿbåÊß‰‹KåÕW=Y¼¸Ï=ç¨ëhâ«U«:~~^Ú¢¹Û·s8{ö
¡¡1„„Ä°hÑRSoSµj<=íñõuÅ××…^¨‹™™t^B!„(»EO÷L	?”Z­¹¯èê6IIé$%¥k·%%¥™ ıwVVÎCÏyw>àÚµ¦OßÆ¼y¿ò¶CõŞ£âqÙÛ[`ooÁ«¯zj·åääu]:!D)R…£G#Yµê0û÷ŸÃÅÅš  Î¾ˆ±±á£O „B!„B!t¢RPA~gÜ\5S§nEQ†å‘ÇŒÑ–õëÿä›oşÇ‡v(ğØgŸí"##‡™3ß(­ÈÅfooÏÅ‹µvşı÷_víÚEPP666èëë§gş›'ÿı÷Úã###µ]e"""pvv&;;›îİ»³iÓ&:uêDvv6«W¯~d–İ»wãïïÿÀö¼¼<¸zõªv[qÆ¸?Ûİ‚G·sçN®\¹BãÆ0` ¯¼òŠösµgÏmAMjj*ñññÚãî/Q©T…>ÏG§<su­Ét`Ş¼ßhß¾!õêÕÒu¤§"×‡\¢dtèĞï¿ÿ‹¸¸Tìì,tç™Òh""|Q×QŠ…››[BÌ’:îÒ¥KL›6   '£¤–µ°lOú¹(Œ‘‘‘
qŸDDÄu¦OßÍöíÿ R©
?%--“wß]‹¹¹)66fØØ˜ááaËK/¹ccc³³µj™aooñ@¡¿¢|HNÎ`Íš#¬^}”ŒŒlºtñæƒÚãâRS×ÑDajjt§HÊ•#òïFE]¿SPÍ¾}a,[v ®®µğõuÁÇÇ…_¬GíÚ…ß´A!„B<}}5kV§fÍêÅÚ?))F>.Ö¾w§.ÒÓ³ù2Ò UM¦<iĞbªìsHkÖ¬yè±£Gfİºu¤¦¦8ÏÓÌ7•ÔüÒã022ÀÓÓşÑ;
!„xl99ylß~²@ùµkß¡];OôôäFfB!„B!„e]¥) <ø%ÔjŸ|ò¦¦FĞò¡û›™™0tèË¬Xqˆ[Q£F~‹õ'bY·î(_|ÑkëjÏ"úCõë×   œQ©TŒ9RÛaÇĞĞ€€ FÅ7ß|CFFS¦L!00P{üØ±cY¾|9)))L<™‘‘Aff&dff2cÆ nİºEõê¾QxwûöíÛ™;w®vûİ®3ë×¯§G,Y²DûXqÆ=z4_ıµ6[ß¾}Œ{ÿxw™ššâîîÎÄ‰6l§NÂØØ˜>}ú0~üx,X@ff&ï¾û.Ï=÷~øác}ÎKê<eÕğá¯°cÇ¿Lœø›6½W®»VÈõ!×‡(/½äNÕªFìÛwşı[è:Î3uéRÙÔ¯_±DGGãëëKbbbíÛ¶m£[·n:Jõp…e³°°`Â„	<¶¨ç[ÒªUó¡Go´«Õ.‚ü»W>ı	ÖÖÅ[ %„(?¢£oğí·‡ùñÇŒ4¨¶ÆÒ²ª®£‰2N__…‡‡-¶ÚÂî„„›œ>}™ü¢ªààrsÕØØ˜áëëŠ¾¾.4lX»\ÿ^'„BQ^$'g<rCCrsó00Ğ§iS'Ú´©OëcÛñ¾÷>½Š2‡t¿ÄÄD–.]ÊÅ‹âÏ1	!„¨ÓY·î(kÖåÖ­,ºvmÂW_õ§~};]GB!„B!„¡ğö!ØĞ¡møğÃLü37{äşC†¼Œ±±!îòï(4vì´iSŸ7ß|¾´ãË¤I“hß¾=şşş´lÙ'Š¹hî    IDAT''æÍ›§}üË/¿ÄŞŞí~“&MÒ>>dÈüııéØ±#¯½öãÆÃÒÒ’Ù³gÓ»wo¼¼¼¨[·.o½õÖİlêÔ©CóæÍ±³³#77—äää]pjÖ¬É´iÓøàƒğññağàÁÚÇŠ3F`` ~~~tìØ‘:0yòdíc…w¿‰'0gÎ ‚‚‚prr¢E‹´jÕŠzõêø\WI§¬24ÔgÑ¢Ş„†Æ°|ùA]Çy*r}Èõ!J†‘‘/½äÁ=gtå™C¥ÒÃİİF×QJ•F£!))éí{÷î¥}ûö:Hôh…e³¶¶Ö~]{˜¢oIËÊŠ&0Ğ—úõmï,\×ÃØØ°Xw¢,Î¢+!Dù (
¿ÿN`à×¼ôÒg8pÉ“;:•±cı¥xJ<13üü¼
zíÛGqîÜ,¶m{ŸÁƒ_"++—vãï¿ˆúõ'ğîæÈ‘²²ru]!„¢BJJJ`›¡¡¾vÀÁ¡>¬\9€°°™lÛ6Š1cÚÓÌRƒ~9©w¯(sH÷KMMEQœœœ€âÏ1	!„¨ØaÔ¨<ÿüÖ­ûƒ[qâÄt–,é+ÅSB!„B!„å‘RIÍ™³K©]ûCåçŸ?rß)*ááqÊœ9»”ºuÇ+±±‰¥ĞÊJQ–//İ1Ê°ÈÈH¥R½<Ëèÿ÷Š‡GÇ•h]G)¨Œ~¾¹>ÊOÏ eíÚ£ºñLmÚ¢8;SnŞÌÔu”gjÑ¢=Ê‹/Î|¢c8  Ê7Šµnn®2uêTÅÑÑQ±¶¶Vúõë§¤¤¤hOIIQ XYY)ÊØ±c•ÌÌLí×…ï¾ûNquuU¬­­•aÃ†)Š¢(ÊÏ?ÿ¬4lØP166V•/¾øBQ”‚_O¬¬¬@±±±ÑwãÆ¥W¯^ì«Ñh”±cÇ*Ï=÷œö¹åää(“&MRå½÷ŞS²²²´Ç8p@qrrR9¢ ÊæÍ›oooÅÌÌL™1c†vÌGçQÙîßoË–-Š———R¥JÅÅÅEY¿~}‘Ï÷~€²råJÅÃÃC133S¦OŸ^¬ÿÇ»îÿÿOOÏR¾ ,Xğ›Ò­ÛR¥ví;»1Š³ó8ÅŞ~ŒbgWğÏ‘#5¢ìIOÏR6løSiÓfbg7FéÒåå—_N*¹¹j]G•D^Z	S6løSyÿıï_ßO;»1Š£ã‡J‡•)S¶(¿ürRIL¼¥ë¨B<¶	6)={.Óu!„¢€ß~;­ØÙQ>PììÆ(M›NWÆV¶oÿçá?s¦(mÛ{™Cz²9¤®]»*~ø¡ö±¬¬,ÅÂÂBÙµk×ÏëaóME]˜§_*«óãBQ‘¥¥e*kÖUÚ¶«ØÙQüüæ+7S²²ruMTB2ÿ!îª(ë‰PììÆ(IIéº"„B!„¨`ŠùûÆŸ•®Õ]&tdøğW=ú{¶o?ùĞ}{÷~OO&OŞÌòå	
z''«g”Tİy÷İ—iÛÖ“áÃ×“’"]0„¨ìüü¼Ğh4:®ë(ÏTxxÜ3»‹àâÅ‹Ù²e¿şú+äÂ…Ìš5KûøÈ‘#¹rå
!!!üöÛoìÙ³‡¹sçj_½z5»wïf×®]8p€O?ı”›7o€¯¯/QQQ|öÙgŒ=šäääcÿõ×_ ÄÇÇk·íØ±ƒÎ;ØOQ&L˜À8pà ÖÖÖ ,X°€ˆˆ;ÆáÃ‡9vìAAAÚãæÏŸÏ¼yóğöö 88˜C‡±páB¦M›¦½sñ£Îó°l÷KOO'  €‘#GrñâE¦L™Â AƒÈÈÈ(ôùfÇ?~œ5kÖ0}útºÿÃT­Z…Ö­İ;ÖŸ­[G>›~Æğá¯Ğ´iò4744 àúõ›O<–B·bc“˜5k'>>Ÿ0eÊ5ªÍ±}û(:wöÖ^ïB”6}}¶¾È’%}ùûï9yr:Ë–õÃÇÇ…ĞĞ†_O£Fóâ‹35j#ß}wŒâQE×ñ…B!Ê[z÷~9szrìØNœ˜Æüù½èÒ¥	VVÕJl™Cz²9¤·Şz‹Í›7kÖİ³g&&&´oß¾ØsE3ö½Jj~I!Dé9}ú2ãÇo¢Y³éÌ˜±zõlÎŞ½ãèÓ§9Uªè:¢B!„B!„xJ•z†gÒ¤NÜ¾Ã¨Q166¤C‡†…î§RéññÇ]èÙsuêX1`@«gœ´ò133cèĞ¡ºQéééé±xñ[øù-`Ì˜X»öôôôt«Ò“ëCèŠ……)¾¾®ìÙs†.]¼uç™	ãõ×Ÿ{&c­ZµŠ9sæĞ°aşÏ$k×®%<<¿`-77—ü‘S§Náêê
À'Ÿ|ÂøñãéÛ·/¿xÆÍÍ€™3g2qâDfÌ˜Á™3gpttÄÔÔ€¿fçÎ¬ZµªÀ¶‰'2ş|ÂÃÃ±²úÿ‚ò5kÖpøğalmmqttdîÜ¹Œ7aÃ†0oŞ<5j¤İÿ½÷ŞÃÂÂ‚0dÈRRR°²²zäy–í~jµ•JEnn.Õ«WgàÀôêÕ“G>÷»ÆGµjÕèÖ­ ©©©Ú?O«jÕ*¼ü²/¿ìÁ„	••Ë‰±üõ×üóÏEêÔ)™q„ÏNHH4ß~{„_=µuuŞy§5¶ÆÒ²ª®£	¡eccNçÎŞtîœÿó\zz6'OÆMHHS§n%++33c{Î	__|}]ñõu•…BB!„àâR“E‹z—ú82‡ôdsH;wæwŞáøñãøøøğÃ?ğöÛoc`ğx?ç5vQJs~I!ÄÓÉÎÎcïŞ³¬Zu˜ĞĞêÖ­Å˜1~ôéÓœ5dNO!„B!„¢¢©Ô+_ôôôøôÓî¨ÕŞ}w-K–ô¥k×&Eì›ÿw^‚F£ RIIiªU«+V¬ĞuA~ÁÄÒ¥}éÙs9k×şÁÀR@¨kr}]êĞ¡!î&7W¡¡¾®ã”ºœœ<bbnàáñl:PÅÆÆR¯^=íÇ4 Aƒ $$$ V«©[·®öñzõêqåÊíÇw¾ Ô¯_Ÿ¸¸8ŒŒŒˆeäÈ‘¤§§ãååU¬,éééäååQ£FÛCCCiÓ¦Ÿ}ök×®Õn¿|ù2vv?OæææòÜËŞŞ CCÃÛu‡e»Ÿ¹¹9Gå‹/¾`ÆŒ4kÖŒI“&Ñ¦M›‡WXN•ªô»ÅÒ²e=Z¶¬÷è…eÆíÛ9lŞ|œÕ«Ï‹/ÖeÅŠşøû7B__:M‰²¯Zµü‰­[»—§áÜ¹«„„Äpúôe~øáo.Üƒ¡¡>Øããã‚¯¯­Z¹ÉB"!„B‘9¤'›C255¥k×®lŞ¼OOOvìØÁÉ“'‹õ<wìÂÃ³˜_BQ<QQ×	aãÆcÜ¾C‡	N«VnrCQ!„B!„Bˆ
¬RPA~ÕìÙobbbÈÈ‘ß‘™™CïŞ/ØG£Qøä“_hÑ¢Ç_ä‡ş¢_¿:J,Ä³×¼y]ÆŒiÏ'ŸlçùçëĞ¨Qm]GBèˆ¿#¦MÛÆßÿG«VîºSê¢£o—§Áİİæ™ŒgooÏÅ‹µwş÷ßÙµkAAAØØØ ¯¯Ott4 ü÷ß888hŒŒÔŞ¡7""ggg²³³éŞ½;›6m¢S§Ndgg³zõêGfÙ½{7şşşlß¹s'W®\¡qãÆ0€W^yE›}Ï=ÚÅ;©©©ÄÇÇk»‘KQFu‡e»_ff&™™™lØ°µZÍ¦M›hß¾=×¯_ä±wÉ¥Bˆ¢DF&°iS¨v‘E—.Ş,_ŞOO{]Gâ©¨hÜØ‘ÆµÛÒ	‰!$$†ĞĞV¯>‚¢(8;[İ)¨rÅÇÇwwùŞ)„BñÈÒ“Ï!½õÖ[Œ=oooš5kV ˜¬¸Š3ö½ägd!„(²²rùå—Ù°áONœ¸Hİºµ=Ú^½|ä&1B!„B!„•„ÜêŒü7.¦NíÊÄ‰;6˜o¾ù_Ç·l9AXØUfÎ|ƒZ2şo¤¥İÖQÚ²çÒ¥K8Èÿ\FEEé,‹®Ç¯ÈÆŒñÃ××•·ßş–„„4]Ç)óî½.Ê¹NÄÓpt´¤A;vï>«ë(ÏDddúú*\\j>“ñúõëGPPgÎœ!,,Œ‘#GrñâE ñH@@ £F"&&†³gÏ2eÊµÇ;–¨¨(BCC™<y2ıúõ###ƒÌÌLÈÌÌdÚ´i Üºu«Ğw·oß¾®]»>ğ¸©©)îîîLœ8‘aÃ†‘••@Ÿ>}?~<ÑÑÑ„……Ñ©S'–,YòØŸƒâœ§¨l…ñóócÃ†$$$˜˜ˆJ¥ÂÈÈèç°jÕ*ÒÒä{œ¢h·oçğãóúë‹yùå9ìŞ}†Ñ£ı8yr:K–ô•â)QaÙØ˜Ó¹³7Ÿ~Úİ»?$<|6ÁÁÃéÑãynòñÇ[xå•¹4i2V±l#ifndef	AFFS_HARDBLOCKS_H
#define	AFFS_HARDBLOCKS_H

#include <linux/types.h>

/* Just the needed definitions for the RDB of an Amiga HD. */

struct RigidDiskBlock {
	__u32	rdb_ID;
	__be32	rdb_SummedLongs;
	__s32	rdb_ChkSum;
	__u32	rdb_HostID;
	__be32	rdb_BlockBytes;
	__u32	rdb_Flags;
	__u32	rdb_BadBlockList;
	__be32	rdb_PartitionList;
	__u32	rdb_FileSysHeaderList;
	__u32	rdb_DriveInit;
	__u32	rdb_Reserved1[6];
	__u32	rdb_Cylinders;
	__u32	rdb_Sectors;
	__u32	rdb_Heads;
	__u32	rdb_Interleave;
	__u32	rdb_Park;
	__u32	rdb_Reserved2[3];
	__u32	rdb_WritePreComp;
	__u32	rdb_ReducedWrite;
	__u32	rdb_StepRate;
	__u32	rdb_Reserved3[5];
	__u32	rdb_RDBBlocksLo;
	__u32	rdb_RDBBlocksHi;
	__u32	rdb_LoCylinder;
	__u32	rdb_HiCylinder;
	__u32	rdb_CylBlocks;
	__u32	rdb_AutoParkSeconds;
	__u32	rdb_HighRDSKBlock;
	__u32	rdb_Reserved4;
	char	rdb_DiskVendor[8];
	char	rdb_DiskProduct[16];
	char	rdb_DiskRevision[4];
	char	rdb_ControllerVendor[8];
	char	rdb_ControllerProduct[16];
	char	rdb_ControllerRevision[4];
	__u32	rdb_Reserved5[10];
};

#define	IDNAME_RIGIDDISK	0x5244534B	/* "RDSK" */

struct PartitionBlock {
	__be32	pb_ID;
	__be32	pb_SummedLongs;
	__s32	pb_ChkSum;
	__u32	pb_HostID;
	__be32	pb_Next;
	__u32	pb_Flags;
	__u32	pb_Reserved1[2];
	__u32	pb_DevFlags;
	__u8	pb_DriveName[32];
	__u32	pb_Reserved2[15];
	__be32	pb_Environment[17];
	__u32	pb_EReserved[15];
};

#define	IDNAME_PARTITION	0x50415254	/* "PART" */

#define RDB_ALLOCATION_LIMIT	16

#endif	/* AFFS_HARDBLOCKS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * AGPGART module version 0.99
 * Copyright (C) 1999 Jeff Hartmann
 * Copyright (C) 1999 Precision Insight, Inc.
 * Copyright (C) 1999 Xi Graphics, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * JEFF HARTMANN, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef _AGP_H
#define _AGP_H

#define AGPIOC_BASE       'A'
#define AGPIOC_INFO       _IOR (AGPIOC_BASE, 0, struct agp_info*)
#define AGPIOC_ACQUIRE    _IO  (AGPIOC_BASE, 1)
#define AGPIOC_RELEASE    _IO  (AGPIOC_BASE, 2)
#define AGPIOC_SETUP      _IOW (AGPIOC_BASE, 3, struct agp_setup*)
#define AGPIOC_RESERVE    _IOW (AGPIOC_BASE, 4, struct agp_region*)
#define AGPIOC_PROTECT    _IOW (AGPIOC_BASE, 5, struct agp_region*)
#define AGPIOC_ALLOCATE   _IOWR(AGPIOC_BASE, 6, struct agp_allocate*)
#define AGPIOC_DEALLOCATE _IOW (AGPIOC_BASE, 7, int)
#define AGPIOC_BIND       _IOW (AGPIOC_BASE, 8, struct agp_bind*)
#define AGPIOC_UNBIND     _IOW (AGPIOC_BASE, 9, struct agp_unbind*)
#define AGPIOC_CHIPSET_FLUSH _IO (AGPIOC_BASE, 10)

#define AGP_DEVICE      "/dev/agpgart"

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#include <linux/types.h>

struct agp_version {
	__u16 major;
	__u16 minor;
};

typedef struct _agp_info {
	struct agp_version version;	/* version of the driver        */
	__u32 bridge_id;	/* bridge vendor/device         */
	__u32 agp_mode;		/* mode info of bridge          */
	unsigned long aper_base;/* base of aperture             */
	size_t aper_size;	/* size of aperture             */
	size_t pg_total;	/* max pages (swap + system)    */
	size_t pg_system;	/* max pages (system)           */
	size_t pg_used;		/* current pages used           */
} agp_info;

typedef struct _agp_setup {
	__u32 agp_mode;		/* mode info of bridge          */
} agp_setup;

/*
 * The "prot" down below needs still a "sleep" flag somehow ...
 */
typedef struct _agp_segment {
	__kernel_off_t pg_start;	/* starting page to populate    */
	__kernel_size_t pg_count;	/* number of pages              */
	int prot;			/* prot flags for mmap          */
} agp_segment;

typedef struct _agp_region {
	__kernel_pid_t pid;		/* pid of process       */
	__kernel_size_t seg_count;	/* number of segments   */
	struct _agp_segment *seg_list;
} agp_region;

typedef struct _agp_allocate {
	int key;		/* tag of allocation            */
	__kernel_size_t pg_count;/* number of pages             */
	__u32 type;		/* 0 == normal, other devspec   */
   	__u32 physical;         /* device specific (some devices  
				 * need a phys address of the     
				 * actual page behind the gatt    
				 * table)                        */
} agp_allocate;

typedef struct _agp_bind {
	int key;		/* tag of allocation            */
	__kernel_off_t pg_start;/* starting page to populate    */
} agp_bind;

typedef struct _agp_unbind {
	int key;		/* tag of allocation            */
	__u32 priority;		/* priority for paging out      */
} agp_unbind;


#endif /* _AGP_H */
                                                                                                                                                                                /* include/linux/aio_abi.h
 *
 * Copyright 2000,2001,2002 Red Hat.
 *
 * Written by Benjamin LaHaise <bcrl@kvack.org>
 *
 * Distribute under the terms of the GPLv2 (see ../../COPYING) or under 
 * the following terms.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation is hereby granted, provided that the above copyright
 * notice appears in all copies.  This software is provided without any
 * warranty, express or implied.  Red Hat makes no representations about
 * the suitability of this software for any purpose.
 *
 * IN NO EVENT SHALL RED HAT BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
 * SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
 * THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF RED HAT HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * RED HAT DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND
 * RED HAT HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 * ENHANCEMENTS, OR MODIFICATIONS.
 */
#ifndef __LINUX__AIO_ABI_H
#define __LINUX__AIO_ABI_H

#include <linux/types.h>
#include <asm/byteorder.h>

typedef __kernel_ulong_t aio_context_t;

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	/* These two are experimental.
	 * IOCB_CMD_PREADX = 4,
	 * IOCB_CMD_POLL = 5,
	 */
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

/*
 * Valid flags for the "aio_flags" member of the "struct iocb".
 *
 * IOCB_FLAG_RESFD - Set if the "aio_resfd" member of the "struct iocb"
 *                   is valid.
 */
#define IOCB_FLAG_RESFD		(1 << 0)

/* read() from /dev/aio returns these structures. */
struct io_event {
	__u64		data;		/* the data field from the iocb */
	__u64		obj;		/* what iocb this event came from */
	__s64		res;		/* result code for this event */
	__s64		res2;		/* secondary result */
};

#if defined(__BYTE_ORDER) ? __BYTE_ORDER == __LITTLE_ENDIAN : defined(__LITTLE_ENDIAN)
#define PADDED(x,y)	x, y
#elif defined(__BYTE_ORDER) ? __BYTE_ORDER == __BIG_ENDIAN : defined(__BIG_ENDIAN)
#define PADDED(x,y)	y, x
#else
#error edit for your odd byteorder.
#endif

/*
 * we always use a 64bit off_t when communicating
 * with userland.  its up to libraries to do the
 * proper padding and aio_error abstraction
 */

struct iocb {
	/* these are internal to the kernel/libc. */
	__u64	aio_data;	/* data to be returned in event's data */
	__u32	PADDED(aio_key, aio_reserved1);
				/* the kernel sets aio_key to the req # */

	/* common fields */
	__u16	aio_lio_opcode;	/* see IOCB_CMD_ above */
	__s16	aio_reqprio;
	__u32	aio_fildes;

	__u64	aio_buf;
	__u64	aio_nbytes;
	__s64	aio_offset;

	/* extra parameters */
	__u64	aio_reserved2;	/* TODO: use this for a (struct sigevent *) */

	/* flags for the "struct iocb" */
	__u32	aio_flags;

	/*
	 * if the IOCB_FLAG_RESFD flag of "aio_flags" is set, this is an
	 * eventfd to signal AIO readiness to
	 */
	__u32	aio_resfd;
}; /* 64 bytes */

#undef IFBIG
#undef IFLITTLE

#endif /* __LINUX__AIO_ABI_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * Include file for the interface to an APM BIOS
 * Copyright 1994-2001 Stephen Rothwell (sfr@canb.auug.org.au)
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 */
#ifndef _LINUX_APM_H
#define _LINUX_APM_H


#include <linux/types.h>

typedef unsigned short	apm_event_t;
typedef unsigned short	apm_eventinfo_t;

struct apm_bios_info {
	__u16	version;
	__u16	cseg;
	__u32	offset;
	__u16	cseg_16;
	__u16	dseg;
	__u16	flags;
	__u16	cseg_len;
	__u16	cseg_16_len;
	__u16	dseg_len;
};


/*
 * Power states
 */
#define APM_STATE_READY		0x0000
#define APM_STATE_STANDBY	0x0001
#define APM_STATE_SUSPEND	0x0002
#define APM_STATE_OFF		0x0003
#define APM_STATE_BUSY		0x0004
#define APM_STATE_REJECT	0x0005
#define APM_STATE_OEM_SYS	0x0020
#define APM_STATE_OEM_DEV	0x0040

#define APM_STATE_DISABLE	0x0000
#define APM_STATE_ENABLE	0x0001

#define APM_STATE_DISENGAGE	0x0000
#define APM_STATE_ENGAGE	0x0001

/*
 * Events (results of Get PM Event)
 */
#define APM_SYS_STANDBY		0x0001
#define APM_SYS_SUSPEND		0x0002
#define APM_NORMAL_RESUME	0x0003
#define APM_CRITICAL_RESUME	0x0004
#define APM_LOW_BATTERY		0x0005
#define APM_POWER_STATUS_CHANGE	0x0006
#define APM_UPDATE_TIME		0x0007
#define APM_CRITICAL_SUSPEND	0x0008
#define APM_USER_STANDBY	0x0009
#define APM_USER_SUSPEND	0x000a
#define APM_STANDBY_RESUME	0x000b
#define APM_CAPABILITY_CHANGE	0x000c
#define APM_USER_HIBERNATION	0x000d
#define APM_HIBERNATION_RESUME	0x000e

/*
 * Error codes
 */
#define APM_SUCCESS		0x00
#define APM_DISABLED		0x01
#define APM_CONNECTED		0x02
#define APM_NOT_CONNECTED	0x03
#define APM_16_CONNECTED	0x05
#define APM_16_UNSUPPORTED	0x06
#define APM_32_CONNECTED	0x07
#define APM_32_UNSUPPORTED	0x08
#define APM_BAD_DEVICE		0x09
#define APM_BAD_PARAM		0x0a
#define APM_NOT_ENGAGED		0x0b
#define APM_BAD_FUNCTION	0x0c
#define APM_RESUME_DISABLED	0x0d
#define APM_NO_ERROR		0x53
#define APM_BAD_STATE		0x60
#define APM_NO_EVENTS		0x80
#define APM_NOT_PRESENT		0x86

/*
 * APM Device IDs
 */
#define APM_DEVICE_BIOS		0x0000
#define APM_DEVICE_ALL		0x0001
#define APM_DEVICE_DISPLAY	0x0100
#define APM_DEVICE_STORAGE	0x0200
#define APM_DEVICE_PARALLEL	0x0300
#define APM_DEVICE_SERIAL	0x0400
#define APM_DEVICE_NETWORK	0x0500
#define APM_DEVICE_PCMCIA	0x0600
#define APM_DEVICE_BATTERY	0x8000
#define APM_DEVICE_OEM		0xe000
#define APM_DEVICE_OLD_ALL	0xffff
#define APM_DEVICE_CLASS	0x00ff
#define APM_DEVICE_MASK		0xff00


/*
 * Battery status
 */
#define APM_MAX_BATTERIES	2

/*
 * APM defined capability bit flags
 */
#define APM_CAP_GLOBAL_STANDBY		0x0001
#define APM_CAP_GLOBAL_SUSPEND		0x0002
#define APM_CAP_RESUME_STANDBY_TIMER	0x0004 /* Timer resume from standby */
#define APM_CAP_RESUME_SUSPEND_TIMER	0x0008 /* Timer resume from suspend */
#define APM_CAP_RESUME_STANDBY_RING	0x0010 /* Resume on Ring fr standby */
#define APM_CAP_RESUME_SUSPEND_RING	0x0020 /* Resume on Ring fr suspend */
#define APM_CAP_RESUME_STANDBY_PCMCIA	0x0040 /* Resume on PCMCIA Ring	*/
#define APM_CAP_RESUME_SUSPEND_PCMCIA	0x0080 /* Resume on PCMCIA Ring	*/

/*
 * ioctl operations
 */
#include <linux/ioctl.h>

#define APM_IOC_STANDBY		_IO('A', 1)
#define APM_IOC_SUSPEND		_IO('A', 2)

#endif /* _LINUX_APM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #ifndef __LINUX_ARCFB_H__
#define __LINUX_ARCFB_H__

#define FBIO_WAITEVENT		_IO('F', 0x88)
#define FBIO_GETCONTROL2	_IOR('F', 0x89, size_t)

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef __LINUX_ATALK_H__
#define __LINUX_ATALK_H__

#include <linux/types.h>
#include <asm/byteorder.h>
#include <linux/socket.h>

/*
 * AppleTalk networking structures
 *
 * The following are directly referenced from the University Of Michigan
 * netatalk for compatibility reasons.
 */
#define ATPORT_FIRST	1
#define ATPORT_RESERVED	128
#define ATPORT_LAST	254		/* 254 is only legal on localtalk */ 
#define ATADDR_ANYNET	(__u16)0
#define ATADDR_ANYNODE	(__u8)0
#define ATADDR_ANYPORT  (__u8)0
#define ATADDR_BCAST	(__u8)255
#define DDP_MAXSZ	587
#define DDP_MAXHOPS     15		/* 4 bits of hop counter */

#define SIOCATALKDIFADDR       (SIOCPROTOPRIVATE + 0)

struct atalk_addr {
	__be16	s_net;
	__u8	s_node;
};

struct sockaddr_at {
	__kernel_sa_family_t sat_family;
	__u8		  sat_port;
	struct atalk_addr sat_addr;
	char		  sat_zero[8];
};

struct atalk_netrange {
	__u8	nr_phase;
	__be16	nr_firstnet;
	__be16	nr_lastnet;
};

#endif /* __LINUX_ATALK_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /* atm_eni.h - Driver-specific declarations of the ENI driver (for use by
	       driver-specific utilities) */

/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */


#ifndef LINUX_ATM_ENI_H
#define LINUX_ATM_ENI_H

#include <linux/atmioc.h>


struct eni_multipliers {
	int tx,rx;	/* values are in percent and must be > 100 */
};


#define ENI_MEMDUMP     _IOW('a',ATMIOC_SARPRV,struct atmif_sioc)
                                                /* printk memory map */
#define ENI_SETMULT	_IOW('a',ATMIOC_SARPRV+7,struct atmif_sioc)
						/* set buffer multipliers */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* atm.h - general ATM declarations */
 
/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
 

/*
 * WARNING: User-space programs should not #include <linux/atm.h> directly.
 *          Instead, #include <atm.h>
 */

#ifndef _LINUX_ATM_H
#define _LINUX_ATM_H

/*
 * BEGIN_xx and END_xx markers are used for automatic generation of
 * documentation. Do not change them.
 */


#include <linux/atmapi.h>
#include <linux/atmsap.h>
#include <linux/atmioc.h>
#include <linux/types.h>


/* general ATM constants */
#define ATM_CELL_SIZE		    53	/* ATM cell size incl. header */
#define ATM_CELL_PAYLOAD	    48	/* ATM payload size */
#define ATM_AAL0_SDU		    52	/* AAL0 SDU size */
#define ATM_MAX_AAL34_PDU	 65535	/* maximum AAL3/4 PDU payload */
#define ATM_AAL5_TRAILER	     8	/* AAL5 trailer size */
#define ATM_MAX_AAL5_PDU	 65535	/* maximum AAL5 PDU payload */
#define ATM_MAX_CDV		  9999	/* maximum (default) CDV */
#define ATM_NOT_RSV_VCI		    32	/* first non-reserved VCI value */

#define ATM_MAX_VPI		   255	/* maximum VPI at the UNI */
#define ATM_MAX_VPI_NNI		  4096	/* maximum VPI at the NNI */
#define ATM_MAX_VCI		 65535	/* maximum VCI */


/* "protcol" values for the socket system call */
#define ATM_NO_AAL	0		/* AAL not specified */
#define ATM_AAL0	13		/* "raw" ATM cells */
#define ATM_AAL1	1		/* AAL1 (CBR) */
#define ATM_AAL2	2		/* AAL2 (VBR) */
#define ATM_AAL34	3		/* AAL3/4 (data) */
#define ATM_AAL5	5		/* AAL5 (data) */

/*
 * socket option name coding functions
 *
 * Note that __SO_ENCODE and __SO_LEVEL are somewhat a hack since the
 * << 22 only reserves 9 bits for the level.  On some architectures
 * SOL_SOCKET is 0xFFFF, so that's a bit of a problem
 */

#define __SO_ENCODE(l,n,t)	((((l) & 0x1FF) << 22) | ((n) << 16) | \
				sizeof(t))
#define __SO_LEVEL_MATCH(c,m)	(((c) >> 22) == ((m) & 0x1FF))
#define __SO_NUMBER(c)		(((c) >> 16) & 0x3f)
#define __SO_SIZE(c)		((c) & 0x3fff)

/*
 * ATM layer
 */

#define SO_SETCLP	__SO_ENCODE(SOL_ATM,0,int)
			    /* set CLP bit value - TODO */
#define SO_CIRANGE	__SO_ENCODE(SOL_ATM,1,struct atm_cirange)
			    /* connection identifier range; socket must be
			       bound or connected */
#define SO_ATMQOS	__SO_ENCODE(SOL_ATM,2,struct atm_qos)
			    /* Quality of Service setting */
#define SO_ATMSAP	__SO_ENCODE(SOL_ATM,3,struct atm_sap)
			    /* Service Access Point */
#define SO_ATMPVC	__SO_ENCODE(SOL_ATM,4,struct sockaddr_atmpvc)
			    /* "PVC" address (also for SVCs); get only */
#define SO_MULTIPOINT	__SO_ENCODE(SOL_ATM, 5, int)
			    /* make this vc a p2mp */


/*
 * Note @@@: since the socket layers don't really distinguish the control and
 * the data plane but generally seems to be data plane-centric, any layer is
 * about equally wrong for the SAP. If you have a better idea about this,
 * please speak up ...
 */


/* ATM cell header (for AAL0) */

/* BEGIN_CH */
#define ATM_HDR_GFC_MASK	0xf0000000
#define ATM_HDR_GFC_SHIFT	28
#define ATM_HDR_VPI_MASK	0x0ff00000
#define ATM_HDR_VPI_SHIFT	20
#define ATM_HDR_VCI_MASK	0x000ffff0
#define ATM_HDR_VCI_SHIFT	4
#define ATM_HDR_PTI_MASK	0x0000000e
#define ATM_HDR_PTI_SHIFT	1
#define ATM_HDR_CLP		0x00000001
/* END_CH */


/* PTI codings */

/* BEGIN_PTI */
#define ATM_PTI_US0	0  /* user data cell, congestion not exp, SDU-type 0 */
#define ATM_PTI_US1	1  /* user data cell, congestion not exp, SDU-type 1 */
#define ATM_PTI_UCES0	2  /* user data cell, cong. experienced, SDU-type 0 */
#define ATM_PTI_UCES1	3  /* user data cell, cong. experienced, SDU-type 1 */
#define ATM_PTI_SEGF5	4  /* segment OAM F5 flow related cell */
#define ATM_PTI_E2EF5	5  /* end-to-end OAM F5 flow related cell */
#define ATM_PTI_RSV_RM	6  /* reserved for traffic control/resource mgmt */
#define ATM_PTI_RSV	7  /* reserved */
/* END_PTI */


/*
 * The following items should stay in linux/atm.h, which should be linked to
 * netatm/atm.h
 */

/* Traffic description */

#define ATM_NONE	0		/* no traffic */
#define ATM_UBR		1
#define ATM_CBR		2
#define ATM_VBR		3
#define ATM_ABR		4
#define ATM_ANYCLASS	5		/* compatible with everything */

#define ATM_MAX_PCR	-1		/* maximum available PCR */

struct atm_trafprm {
	unsigned char	traffic_class;	/* traffic class (ATM_UBR, ...) */
	int		max_pcr;	/* maximum PCR in cells per second */
	int		pcr;		/* desired PCR in cells per second */
	int		min_pcr;	/* minimum PCR in cells per second */
	int		max_cdv;	/* maximum CDV in microseconds */
	int		max_sdu;	/* maximum SDU in bytes */
        /* extra params for ABR */
        unsigned int 	icr;         	/* Initial Cell Rate (24-bit) */
        unsigned int	tbe;		/* Transient Buffer Exposure (24-bit) */ 
        unsigned int 	frtt : 24;	/* Fixed Round Trip Time (24-bit) */
        unsigned int 	rif  : 4;       /* Rate Increment Factor (4-bit) */
        unsigned int 	rdf  : 4;       /* Rate Decrease Factor (4-bit) */
        unsigned int nrm_pres  :1;      /* nrm present bit */
        unsigned int trm_pres  :1;     	/* rm present bit */
        unsigned int adtf_pres :1;     	/* adtf present bit */
        unsigned int cdf_pres  :1;    	/* cdf present bit*/
        unsigned int nrm       :3;     	/* Max # of Cells for each forward RM cell (3-bit) */
        unsigned int trm       :3;    	/* Time between forward RM cells (3-bit) */    
	unsigned int adtf      :10;     /* ACR Decrease Time Factor (10-bit) */
	unsigned int cdf       :3;      /* Cutoff Decrease Factor (3-bit) */
        unsigned int spare     :9;      /* spare bits */ 
};

struct atm_qos {
	struct atm_trafprm txtp;	/* parameters in TX direction */
	struct atm_trafprm rxtp __ATM_API_ALIGN;
					/* parameters in RX direction */
	unsigned char aal __ATM_API_ALIGN;
};

/* PVC addressing */

#define ATM_ITF_ANY	-1		/* "magic" PVC address values */
#define ATM_VPI_ANY	-1
#define ATM_VCI_ANY	-1
#define ATM_VPI_UNSPEC	-2
#define ATM_VCI_UNSPEC	-2


struct sockaddr_atmpvc {
	unsigned short 	sap_family;	/* address family, AF_ATMPVC  */
	struct {			/* PVC address */
		short	itf;		/* ATM interface */
		short	vpi;		/* VPI (only 8 bits at UNI) */
		int	vci;		/* VCI (only 16 bits at UNI) */
	} sap_addr __ATM_API_ALIGN;	/* PVC address */
};

/* SVC addressing */

#define	ATM_ESA_LEN	20		/* ATM End System Address length */
#define ATM_E164_LEN	12		/* maximum E.164 number length */

#define ATM_AFI_DCC	0x39		/* DCC ATM Format */
#define ATM_AFI_ICD	0x47		/* ICD ATM Format */
#define ATM_AFI_E164	0x45		/* E.164 ATM Format */
#define ATM_AFI_LOCAL	0x49		/* Local ATM Format */ 

#define ATM_AFI_DCC_GROUP	0xBD	/* DCC ATM Group Format */
#define ATM_AFI_ICD_GROUP	0xC5	/* ICD ATM Group Format */
#define ATM_AFI_E164_GROUP	0xC3	/* E.164 ATM Group Format */
#define ATM_AFI_LOCAL_GROUP	0xC7	/* Local ATM Group Format */

#define ATM_LIJ_NONE	0		/* no leaf-initiated join */
#define ATM_LIJ		1		/* request joining */
#define ATM_LIJ_RPJ	2		/* set to root-prompted join */
#define ATM_LIJ_NJ	3		/* set to network join */


struct sockaddr_atmsvc {
    unsigned short 	sas_family;	/* address family, AF_ATMSVC */
    struct {				/* SVC address */
        unsigned char	prv[ATM_ESA_LEN];/* private ATM address */
        char		pub[ATM_E164_LEN+1]; /* public address (E.164) */
    					/* unused addresses must be bzero'ed */
	char		lij_type;	/* role in LIJ call; one of ATM_LIJ* */
	__u32	lij_id;		/* LIJ call identifier */
    } sas_addr __ATM_API_ALIGN;		/* SVC address */
};


static __inline__ int atmsvc_addr_in_use(struct sockaddr_atmsvc addr)
{
	return *addr.sas_addr.prv || *addr.sas_addr.pub;
}


static __inline__ int atmpvc_addr_in_use(struct sockaddr_atmpvc addr)
{
	return addr.sap_addr.itf || addr.sap_addr.vpi || addr.sap_addr.vci;
}


/*
 * Some stuff for linux/sockios.h
 */

struct atmif_sioc {
	int number;
	int length;
	void *arg;
};


typedef unsigned short atm_backend_t;
#endif /* _LINUX_ATM_H */
                                                                                                                                                                                                                                                                                                                                                                               /* atm_he.h */

#ifndef LINUX_ATM_HE_H
#define LINUX_ATM_HE_H

#include <linux/atmioc.h>

#define HE_GET_REG	_IOW('a', ATMIOC_SARPRV, struct atmif_sioc)

#define HE_REGTYPE_PCI	1
#define HE_REGTYPE_RCM	2
#define HE_REGTYPE_TCM	3
#define HE_REGTYPE_MBOX	4

struct he_ioctl_reg {
	unsigned addr, val;
	char type;
};

#endif /* LINUX_ATM_HE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /* atm_idt77105.h - Driver-specific declarations of the IDT77105 driver (for
 * use by driver-specific utilities) */

/* Written 1999 by Greg Banks <gnb@linuxfan.com>. Copied from atm_suni.h. */


#ifndef LINUX_ATM_IDT77105_H
#define LINUX_ATM_IDT77105_H

#include <linux/types.h>
#include <linux/atmioc.h>
#include <linux/atmdev.h>

/*
 * Structure for IDT77105_GETSTAT and IDT77105_GETSTATZ ioctls.
 * Pointed to by `arg' in atmif_sioc.
 */
struct idt77105_stats {
        __u32 symbol_errors;  /* wire symbol errors */
        __u32 tx_cells;       /* cells transmitted */
        __u32 rx_cells;       /* cells received */
        __u32 rx_hec_errors;  /* Header Error Check errors on receive */
};

#define IDT77105_GETSTAT	_IOW('a',ATMIOC_PHYPRV+2,struct atmif_sioc)	/* get stats */
#define IDT77105_GETSTATZ	_IOW('a',ATMIOC_PHYPRV+3,struct atmif_sioc)	/* get stats and zero */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /******************************************************************************
 *
 * atm_nicstar.h
 *
 * Driver-specific declarations for use by NICSTAR driver specific utils.
 *
 * Author: Rui Prior
 *
 * (C) INESC 1998
 *
 ******************************************************************************/


#ifndef LINUX_ATM_NICSTAR_H
#define LINUX_ATM_NICSTAR_H

/* Note: non-kernel programs including this file must also include
 * sys/types.h for struct timeval
 */

#include <linux/atmapi.h>
#include <linux/atmioc.h>

#define NS_GETPSTAT	_IOWR('a',ATMIOC_SARPRV+1,struct atmif_sioc)
						/* get pool statistics */
#define NS_SETBUFLEV	_IOW('a',ATMIOC_SARPRV+2,struct atmif_sioc)
						/* set buffer level markers */
#define NS_ADJBUFLEV	_IO('a',ATMIOC_SARPRV+3)
						/* adjust buffer level */

typedef struct buf_nr
{
   unsigned min;
   unsigned init;
   unsigned max;
}buf_nr;


typedef struct pool_levels
{
   int buftype;
   int count;		/* (At least for now) only used in NS_GETPSTAT */
   buf_nr level;
} pool_levels;

/* type must be one of the following: */
#define NS_BUFTYPE_SMALL 1
#define NS_BUFTYPE_LARGE 2
#define NS_BUFTYPE_HUGE 3
#define NS_BUFTYPE_IOVEC 4


#endif /* LINUX_ATM_NICSTAR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /* atm_tcp.h - Driver-specific declarations of the ATMTCP driver (for use by
	       driver-specific utilities) */

/* Written 1997-2000 by Werner Almesberger, EPFL LRC/ICA */


#ifndef LINUX_ATM_TCP_H
#define LINUX_ATM_TCP_H

#include <linux/atmapi.h>
#include <linux/atm.h>
#include <linux/atmioc.h>
#include <linux/types.h>


/*
 * All values in struct atmtcp_hdr are in network byte order
 */

struct atmtcp_hdr {
	__u16	vpi;
	__u16	vci;
	__u32	length;		/* ... of data part */
};

/*
 * All values in struct atmtcp_command are in host byte order
 */

#define ATMTCP_HDR_MAGIC	(~0)	/* this length indicates a command */
#define ATMTCP_CTRL_OPEN	1	/* request/reply */
#define ATMTCP_CTRL_CLOSE	2	/* request/reply */

struct atmtcp_control {
	struct atmtcp_hdr hdr;	/* must be first */
	int type;		/* message type; both directions */
	atm_kptr_t vcc;		/* both directions */
	struct sockaddr_atmpvc addr; /* suggested value from kernel */
	struct atm_qos	qos;	/* both directions */
	int result;		/* to kernel only */
} __ATM_API_ALIGN;

/*
 * Field usage:
 * Messge type	dir.	hdr.v?i	type	addr	qos	vcc	result
 * -----------  ----	------- ----	----	---	---	------
 * OPEN		K->D	Y	Y	Y	Y	Y	0
 * OPEN		D->K	-	Y	Y	Y	Y	Y
 * CLOSE	K->D	-	-	Y	-	Y	0
 * CLOSE	D->K	-	-	-	-	Y	Y
 */

#define SIOCSIFATMTCP	_IO('a',ATMIOC_ITF)	/* set ATMTCP mode */
#define ATMTCP_CREATE	_IO('a',ATMIOC_ITF+14)	/* create persistent ATMTCP
						   interface */
#define ATMTCP_REMOVE	_IO('a',ATMIOC_ITF+15)	/* destroy persistent ATMTCP
						   interface */



#endif /* LINUX_ATM_TCP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /* atm_zatm.h - Driver-specific declarations of the ZATM driver (for use by
		driver-specific utilities) */

/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */


#ifndef LINUX_ATM_ZATM_H
#define LINUX_ATM_ZATM_H

/*
 * Note: non-kernel programs including this file must also include
 * sys/types.h for struct timeval
 */

#include <linux/atmapi.h>
#include <linux/atmioc.h>

#define ZATM_GETPOOL	_IOW('a',ATMIOC_SARPRV+1,struct atmif_sioc)
						/* get pool statistics */
#define ZATM_GETPOOLZ	_IOW('a',ATMIOC_SARPRV+2,struct atmif_sioc)
						/* get statistics and zero */
#define ZATM_SETPOOL	_IOW('a',ATMIOC_SARPRV+3,struct atmif_sioc)
						/* set pool parameters */

struct zatm_pool_info {
	int ref_count;			/* free buffer pool usage counters */
	int low_water,high_water;	/* refill parameters */
	int rqa_count,rqu_count;	/* queue condition counters */
	int offset,next_off;		/* alignment optimizations: offset */
	int next_cnt,next_thres;	/* repetition counter and threshold */
};

struct zatm_pool_req {
	int pool_num;			/* pool number */
	struct zatm_pool_info info;	/* actual information */
};

struct zatm_t_hist {
	struct timeval real;		/* real (wall-clock) time */
	struct timeval expected;	/* expected real time */
};


#define ZATM_OAM_POOL		0	/* free buffer pool for OAM cells */
#define ZATM_AAL0_POOL		1	/* free buffer pool for AAL0 cells */
#define ZATM_AAL5_POOL_BASE	2	/* first AAL5 free buffer pool */
#define ZATM_LAST_POOL	ZATM_AAL5_POOL_BASE+10 /* max. 64 kB */

#define ZATM_TIMER_HISTORY_SIZE	16	/* number of timer adjustments to
					   record; must be 2^n */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /* atmapi.h - ATM API user space/kernel compatibility */
 
/* Written 1999,2000 by Werner Almesberger, EPFL ICA */
 

#ifndef _LINUX_ATMAPI_H
#define _LINUX_ATMAPI_H

#if defined(__sparc__) || defined(__ia64__)
/* such alignment is not required on 32 bit sparcs, but we can't
   figure that we are on a sparc64 while compiling user-space programs. */
#define __ATM_API_ALIGN	__attribute__((aligned(8)))
#else
#define __ATM_API_ALIGN
#endif


/*
 * Opaque type for kernel pointers. Note that _ is never accessed. We need
 * the struct in order hide the array, so that we can make simple assignments
 * instead of being forced to use memcpy. It also improves error reporting for
 * code that still assumes that we're passing unsigned longs.
 *
 * Convention: NULL pointers are passed as a field of all zeroes.
 */
 
typedef struct { unsigned char _[8]; } __ATM_API_ALIGN atm_kptr_t;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* atmarp.h - ATM ARP protocol and kernel-demon interface definitions */
 
/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
 

#ifndef _LINUX_ATMARP_H
#define _LINUX_ATMARP_H

#include <linux/types.h>
#include <linux/atmapi.h>
#include <linux/atmioc.h>


#define ATMARP_RETRY_DELAY 30		/* request next resolution or forget
					   NAK after 30 sec - should go into
					   atmclip.h */
#define ATMARP_MAX_UNRES_PACKETS 5	/* queue that many packets while
					   waiting for the resolver */


#define ATMARPD_CTRL	_IO('a',ATMIOC_CLIP+1)	/* become atmarpd ctrl sock */
#define ATMARP_MKIP	_IO('a',ATMIOC_CLIP+2)	/* attach socket to IP */
#define ATMARP_SETENTRY	_IO('a',ATMIOC_CLIP+3)	/* fill or hide ARP entry */
#define ATMARP_ENCAP	_IO('a',ATMIOC_CLIP+5)	/* change encapsulation */


enum atmarp_ctrl_type {
	act_invalid,		/* catch uninitialized structures */
	act_need,		/* need address resolution */
	act_up,			/* interface is coming up */
	act_down,		/* interface is going down */
	act_change		/* interface configuration has changed */
};

struct atmarp_ctrl {
	enum atmarp_ctrl_type	type;	/* message type */
	int			itf_num;/* interface number (if present) */
	__be32			ip;	/* IP address (act_need only) */
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #ifndef _LINUX_ATMBR2684_H
#define _LINUX_ATMBR2684_H

#include <linux/types.h>
#include <linux/atm.h>
#include <linux/if.h>		/* For IFNAMSIZ */

/*
 * Type of media we're bridging (ethernet, token ring, etc)  Currently only
 * ethernet is supported
 */
#define BR2684_MEDIA_ETHERNET	(0)	/* 802.3 */
#define BR2684_MEDIA_802_4	(1)	/* 802.4 */
#define BR2684_MEDIA_TR		(2)	/* 802.5 - token ring */
#define BR2684_MEDIA_FDDI	(3)
#define BR2684_MEDIA_802_6	(4)	/* 802.6 */

					/* used only at device creation:  */
#define BR2684_FLAG_ROUTED	(1<<16)	/* payload is routed, not bridged */

/*
 * Is there FCS inbound on this VC?  This currently isn't supported.
 */
#define BR2684_FCSIN_NO		(0)
#define BR2684_FCSIN_IGNORE	(1)
#define BR2684_FCSIN_VERIFY	(2)

/*
 * Is there FCS outbound on this VC?  This currently isn't supported.
 */
#define BR2684_FCSOUT_NO	(0)
#define BR2684_FCSOUT_SENDZERO	(1)
#define BR2684_FCSOUT_GENERATE	(2)

/*
 * Does this VC include LLC encapsulation?
 */
#define BR2684_ENCAPS_VC	(0)	/* VC-mux */
#define BR2684_ENCAPS_LLC	(1)
#define BR2684_ENCAPS_AUTODETECT (2)	/* Unsuported */

/*
 * Is this VC bridged or routed?
 */

#define BR2684_PAYLOAD_ROUTED   (0)
#define BR2684_PAYLOAD_BRIDGED  (1)

/*
 * This is for the ATM_NEWBACKENDIF call - these are like socket families:
 * the first element of the structure is the backend number and the rest
 * is per-backend specific
 */
struct atm_newif_br2684 {
	atm_backend_t backend_num;	/* ATM_BACKEND_BR2684 */
	int media;		/* BR2684_MEDIA_*, flags in upper bits */
	char ifname[IFNAMSIZ];
	int mtu;
};

/*
 * This structure is used to specify a br2684 interface - either by a
 * positive integer (returned by ATM_NEWBACKENDIF) or the interfaces name
 */
#define BR2684_FIND_BYNOTHING	(0)
#define BR2684_FIND_BYNUM	(1)
#define BR2684_FIND_BYIFNAME	(2)
struct br2684_if_spec {
	int method;		/* BR2684_FIND_* */
	union {
		char ifname[IFNAMSIZ];
		int devnum;
	} spec;
};

/*
 * This is for the ATM_SETBACKEND call - these are like socket families:
 * the first element of the structure is the backend number and the rest
 * is per-backend specific
 */
struct atm_backend_br2684 {
	atm_backend_t backend_num;	/* ATM_BACKEND_BR2684 */
	struct br2684_if_spec ifspec;
	int fcs_in;		/* BR2684_FCSIN_* */
	int fcs_out;		/* BR2684_FCSOUT_* */
	int fcs_auto;		/* 1: fcs_{in,out} disabled if no FCS rx'ed */
	int encaps;		/* BR2684_ENCAPS_* */
	int has_vpiid;		/* 1: use vpn_id - Unsupported */
	__u8 vpn_id[7];
	int send_padding;	/* unsupported */
	int min_size;		/* we will pad smaller packets than this */
};

/*
 * The BR2684_SETFILT ioctl is an experimental mechanism for folks
 * terminating a large number of IP-only vcc's.  When netfilter allows
 * efficient per-if in/out filters, this support will be removed
 */
struct br2684_filter {
	__be32 prefix;		/* network byte order */
	__be32 netmask;		/* 0 = disable filter */
};

struct br2684_filter_set {
	struct br2684_if_spec ifspec;
	struct br2684_filter filter;
};

enum br2684_payload {
	p_routed = BR2684_PAYLOAD_ROUTED,
	p_bridged = BR2684_PAYLOAD_BRIDGED,
};

#define BR2684_SETFILT	_IOW( 'a', ATMIOC_BACKEND + 0, \
				struct br2684_filter_set)

#endif /* _LINUX_ATMBR2684_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /* atmclip.h - Classical IP over ATM */
 
/* Written 1995-1998 by Werner Almesberger, EPFL LRC/ICA */
 

#ifndef LINUX_ATMCLIP_H
#define LINUX_ATMCLIP_H

#include <linux/sockios.h>
#include <linux/atmioc.h>


#define RFC1483LLC_LEN	8		/* LLC+OUI+PID = 8 */
#define RFC1626_MTU	9180		/* RFC1626 default MTU */

#define CLIP_DEFAULT_IDLETIMER 1200	/* 20 minutes, see RFC1755 */
#define CLIP_CHECK_INTERVAL	 10	/* check every ten seconds */

#define	SIOCMKCLIP	_IO('a',ATMIOC_CLIP)	/* create IP interface */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /* atmioc.h - ranges for ATM-related ioctl numbers */
 
/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */


/*
 * See http://icawww1.epfl.ch/linux-atm/magic.html for the complete list of
 * "magic" ioctl numbers.
 */


#ifndef _LINUX_ATMIOC_H
#define _LINUX_ATMIOC_H

#include <asm/ioctl.h>
		/* everybody including atmioc.h will also need _IO{,R,W,WR} */

#define ATMIOC_PHYCOM	  0x00 /* PHY device common ioctls, globally unique */
#define ATMIOC_PHYCOM_END 0x0f
#define ATMIOC_PHYTYP	  0x10 /* PHY dev type ioctls, unique per PHY type */
#define ATMIOC_PHYTYP_END 0x2f
#define ATMIOC_PHYPRV	  0x30 /* PHY dev private ioctls, unique per driver */
#define ATMIOC_PHYPRV_END 0x4f
#define ATMIOC_SARCOM	  0x50 /* SAR device common ioctls, globally unique */
#define ATMIOC_SARCOM_END 0x50
#define ATMIOC_SARPRV	  0x60 /* SAR dev private ioctls, unique per driver */
#define ATMIOC_SARPRV_END 0x7f
#define ATMIOC_ITF	  0x80 /* Interface ioctls, globally unique */
#define ATMIOC_ITF_END	  0x8f
#define ATMIOC_BACKEND	  0x90 /* ATM generic backend ioctls, u. per backend */
#define ATMIOC_BACKEND_END 0xaf
/* 0xb0-0xbf: Reserved for future use */
#define ATMIOC_AREQUIPA	  0xc0 /* Application requested IP over ATM, glob. u. */
#define ATMIOC_LANE	  0xd0 /* LAN Emulation, globally unique */
#define ATMIOC_MPOA       0xd8 /* MPOA, globally unique */
#define	ATMIOC_CLIP	  0xe0 /* Classical IP over ATM control, globally u. */
#define	ATMIOC_CLIP_END	  0xef
#define	ATMIOC_SPECIAL	  0xf0 /* Special-purpose controls, globally unique */
#define	ATMIOC_SPECIAL_END 0xff

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /* atmdev.h - ATM device driver declarations and various related items */
 
/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
 

#ifndef LINUX_ATMDEV_H
#define LINUX_ATMDEV_H


#include <linux/atmapi.h>
#include <linux/atm.h>
#include <linux/atmioc.h>


#define ESI_LEN		6

#define ATM_OC3_PCR	(155520000/270*260/8/53)
			/* OC3 link rate:  155520000 bps
			   SONET overhead: /270*260 (9 section, 1 path)
			   bits per cell:  /8/53
			   max cell rate:  353207.547 cells/sec */
#define ATM_25_PCR	((25600000/8-8000)/54)
			/* 25 Mbps ATM cell rate (59111) */
#define ATM_OC12_PCR	(622080000/1080*1040/8/53)
			/* OC12 link rate: 622080000 bps
			   SONET overhead: /1080*1040
			   bits per cell:  /8/53
			   max cell rate:  1412830.188 cells/sec */
#define ATM_DS3_PCR	(8000*12)
			/* DS3: 12 cells in a 125 usec time slot */


#define __AAL_STAT_ITEMS \
    __HANDLE_ITEM(tx);			/* TX okay */ \
    __HANDLE_ITEM(tx_err);		/* TX errors */ \
    __HANDLE_ITEM(rx);			/* RX okay */ \
    __HANDLE_ITEM(rx_err);		/* RX errors */ \
    __HANDLE_ITEM(rx_drop);		/* RX out of memory */

struct atm_aal_stats {
#define __HANDLE_ITEM(i) int i
	__AAL_STAT_ITEMS
#undef __HANDLE_ITEM
};


struct atm_dev_stats {
	struct atm_aal_stats aal0;
	struct atm_aal_stats aal34;
	struct atm_aal_stats aal5;
} __ATM_API_ALIGN;


#define ATM_GETLINKRATE	_IOW('a',ATMIOC_ITF+1,struct atmif_sioc)
					/* get link rate */
#define ATM_GETNAMES	_IOW('a',ATMIOC_ITF+3,struct atm_iobuf)
					/* get interface names (numbers) */
#define ATM_GETTYPE	_IOW('a',ATMIOC_ITF+4,struct atmif_sioc)
					/* get interface type name */
#define ATM_GETESI	_IOW('a',ATMIOC_ITF+5,struct atmif_sioc)
					/* get interface ESI */
#define ATM_GETADDR	_IOW('a',ATMIOC_ITF+6,struct atmif_sioc)
					/* get itf's local ATM addr. list */
#define ATM_RSTADDR	_IOW('a',ATMIOC_ITF+7,struct atmif_sioc)
					/* reset itf's ATM address list */
#define ATM_ADDADDR	_IOW('a',ATMIOC_ITF+8,struct atmif_sioc)
					/* add a local ATM address */
#define ATM_DELADDR	_IOW('a',ATMIOC_ITF+9,struct atmif_sioc)
					/* remove a local ATM address */
#define ATM_GETCIRANGE	_IOW('a',ATMIOC_ITF+10,struct atmif_sioc)
					/* get connection identifier range */
#define ATM_SETCIRANGE	_IOW('a',ATMIOC_ITF+11,struct atmif_sioc)
					/* set connection identifier range */
#define ATM_SETESI	_IOW('a',ATMIOC_ITF+12,struct atmif_sioc)
					/* set interface ESI */
#define ATM_SETESIF	_IOW('a',ATMIOC_ITF+13,struct atmif_sioc)
					/* force interface ESI */
#define ATM_ADDLECSADDR	_IOW('a', ATMIOC_ITF+14, struct atmif_sioc)
					/* register a LECS address */
#define ATM_DELLECSADDR	_IOW('a', ATMIOC_ITF+15, struct atmif_sioc)
					/* unregister a LECS address */
#define ATM_GETLECSADDR	_IOW('a', ATMIOC_ITF+16, struct atmif_sioc)
					/* retrieve LECS address(es) */

#define ATM_GETSTAT	_IOW('a',ATMIOC_SARCOM+0,struct atmif_sioc)
					/* get AAL layer statistics */
#define ATM_GETSTATZ	_IOW('a',ATMIOC_SARCOM+1,struct atmif_sioc)
					/* get AAL layer statistics and zero */
#define ATM_GETLOOP	_IOW('a',ATMIOC_SARCOM+2,struct atmif_sioc)
					/* get loopback mode */
#define ATM_SETLOOP	_IOW('a',ATMIOC_SARCOM+3,struct atmif_sioc)
					/* set loopback mode */
#define ATM_QUERYLOOP	_IOW('a',ATMIOC_SARCOM+4,struct atmif_sioc)
					/* query supported loopback modes */
#define ATM_SETSC	_IOW('a',ATMIOC_SPECIAL+1,int)
					/* enable or disable single-copy */
#define ATM_SETBACKEND	_IOW('a',ATMIOC_SPECIAL+2,atm_backend_t)
					/* set backend handler */
#define ATM_NEWBACKENDIF _IOW('a',ATMIOC_SPECIAL+3,atm_backend_t)
					/* use backend to make new if */
#define ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
 					/* add party to p2mp call */
#ifdef CONFIG_COMPAT
/* It actually takes struct sockaddr_atmsvc, not struct atm_iobuf */
#define COMPAT_ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct compat_atm_iobuf)
#endif
#define ATM_DROPPARTY 	_IOW('a', ATMIOC_SPECIAL+5,int)
					/* drop party from p2mp call */

/*
 * These are backend handkers that can be set via the ATM_SETBACKEND call
 * above.  In the future we may support dynamic loading of these - for now,
 * they're just being used to share the ATMIOC_BACKEND ioctls
 */
#define ATM_BACKEND_RAW		0	
#define ATM_BACKEND_PPP		1	/* PPPoATM - RFC2364 */
#define ATM_BACKEND_BR2684	2	/* Bridged RFC1483/2684 */

/* for ATM_GETTYPE */
#define ATM_ITFTYP_LEN	8	/* maximum length of interface type name */

/*
 * Loopback modes for ATM_{PHY,SAR}_{GET,SET}LOOP
 */

/* Point of loopback				CPU-->SAR-->PHY-->line--> ... */
#define __ATM_LM_NONE	0	/* no loop back     ^     ^     ^      ^      */
#define __ATM_LM_AAL	1	/* loop back PDUs --'     |     |      |      */
#define __ATM_LM_ATM	2	/* loop back ATM cells ---'     |      |      */
/* RESERVED		4	loop back on PHY side  ---'		      */
#define __ATM_LM_PHY	8	/* loop back bits (digital) ----'      |      */
#define __ATM_LM_ANALOG 16	/* loop back the analog signal --------'      */

/* Direction of loopback */
#define __ATM_LM_MKLOC(n)	((n))	    /* Local (i.e. loop TX to RX) */
#define __ATM_LM_MKRMT(n)	((n) << 8)  /* Remote (i.e. loop RX to TX) */

#define __ATM_LM_XTLOC(n)	((n) & 0xff)
#define __ATM_LM_XTRMT(n)	(((n) >> 8) & 0xff)

#define ATM_LM_NONE	0	/* no loopback */

#define ATM_LM_LOC_AAL	__ATM_LM_MKLOC(__ATM_LM_AAL)
#define ATM_LM_LOC_ATM	__ATM_LM_MKLOC(__ATM_LM_ATM)
#define ATM_LM_LOC_PHY	__ATM_LM_MKLOC(__ATM_LM_PHY)
#define ATM_LM_LOC_ANALOG __ATM_LM_MKLOC(__ATM_LM_ANALOG)

#define ATM_LM_RMT_AAL	__ATM_LM_MKRMT(__ATM_LM_AAL)
#define ATM_LM_RMT_ATM	__ATM_LM_MKRMT(__ATM_LM_ATM)
#define ATM_LM_RMT_PHY	__ATM_LM_MKRMT(__ATM_LM_PHY)
#define ATM_LM_RMT_ANALOG __ATM_LM_MKRMT(__ATM_LM_ANALOG)

/*
 * Note: ATM_LM_LOC_* and ATM_LM_RMT_* can be combined, provided that
 * __ATM_LM_XTLOC(x) <= __ATM_LM_XTRMT(x)
 */


struct atm_iobuf {
	int length;
	void *buffer;
};

/* for ATM_GETCIRANGE / ATM_SETCIRANGE */

#define ATM_CI_MAX      -1              /* use maximum range of VPI/VCI */
 
struct atm_cirange {
	signed char	vpi_bits;	/* 1..8, ATM_CI_MAX (-1) for maximum */
	signed char	vci_bits;	/* 1..16, ATM_CI_MAX (-1) for maximum */
};

/* for ATM_SETSC; actually taken from the ATM_VF number space */

#define ATM_SC_RX	1024		/* enable RX single-copy */
#define ATM_SC_TX	2048		/* enable TX single-copy */

#define ATM_BACKLOG_DEFAULT 32 /* if we get more, we're likely to time out
				  anyway */

/* MF: change_qos (Modify) flags */

#define ATM_MF_IMMED	 1	/* Block until change is effective */
#define ATM_MF_INC_RSV	 2	/* Change reservation on increase */
#define ATM_MF_INC_SHP	 4	/* Change shaping on increase */
#define ATM_MF_DEC_RSV	 8	/* Change reservation on decrease */
#define ATM_MF_DEC_SHP	16	/* Change shaping on decrease */
#define ATM_MF_BWD	32	/* Set the backward direction parameters */

#define ATM_MF_SET	(ATM_MF_INC_RSV | ATM_MF_INC_SHP | ATM_MF_DEC_RSV | \
			  ATM_MF_DEC_SHP | ATM_MF_BWD)

/*
 * ATM_VS_* are used to express VC state in a human-friendly way.
 */

#define ATM_VS_IDLE	0	/* VC is not used */
#define ATM_VS_CONNECTED 1	/* VC is connected */
#define ATM_VS_CLOSING	2	/* VC is closing */
#define ATM_VS_LISTEN	3	/* VC is listening for incoming setups */
#define ATM_VS_INUSE	4	/* VC is in use (registered with atmsigd) */
#define ATM_VS_BOUND	5	/* VC is bound */

#define ATM_VS2TXT_MAP \
    "IDLE", "CONNECTED", "CLOSING", "LISTEN", "INUSE", "BOUND"

#define ATM_VF2TXT_MAP \
    "ADDR",	"READY",	"PARTIAL",	"REGIS", \
    "RELEASED", "HASQOS",	"LISTEN",	"META", \
    "256",	"512",		"1024",		"2048", \
    "SESSION",	"HASSAP",	"BOUND",	"CLOSE"



#endif /* LINUX_ATMDEV_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * ATM Lan Emulation Daemon driver interface
 *
 * Marko Kiiskila <mkiiskila@yahoo.com>
 */

#ifndef _ATMLEC_H_
#define _ATMLEC_H_

#include <linux/atmapi.h>
#include <linux/atmioc.h>
#include <linux/atm.h>
#include <linux/if_ether.h>
#include <linux/types.h>

/* ATM lec daemon control socket */
#define ATMLEC_CTRL	_IO('a', ATMIOC_LANE)
#define ATMLEC_DATA	_IO('a', ATMIOC_LANE+1)
#define ATMLEC_MCAST	_IO('a', ATMIOC_LANE+2)

/* Maximum number of LEC interfaces (tweakable) */
#define MAX_LEC_ITF 48

typedef enum {
	l_set_mac_addr,
	l_del_mac_addr,
	l_svc_setup,
	l_addr_delete,
	l_topology_change,
	l_flush_complete,
	l_arp_update,
	l_narp_req,		/* LANE2 mandates the use of this */
	l_config,
	l_flush_tran_id,
	l_set_lecid,
	l_arp_xmt,
	l_rdesc_arp_xmt,
	l_associate_req,
	l_should_bridge		/* should we bridge this MAC? */
} atmlec_msg_type;

#define ATMLEC_MSG_TYPE_MAX l_should_bridge

struct atmlec_config_msg {
	unsigned int maximum_unknown_frame_count;
	unsigned int max_unknown_frame_time;
	unsigned short max_retry_count;
	unsigned int aging_time;
	unsigned int forward_delay_time;
	unsigned int arp_response_time;
	unsigned int flush_timeout;
	unsigned int path_switching_delay;
	unsigned int lane_version;	/* LANE2: 1 for LANEv1, 2 for LANEv2 */
	int mtu;
	int is_proxy;
};

struct atmlec_msg {
	atmlec_msg_type type;
	int sizeoftlvs;		/* LANE2: if != 0, tlvs follow */
	union {
		struct {
			unsigned char mac_addr[ETH_ALEN];
			unsigned char atm_addr[ATM_ESA_LEN];
			unsigned int flag;	/*
						 * Topology_change flag,
						 * remoteflag, permanent flag,
						 * lecid, transaction id
						 */
			unsigned int targetless_le_arp;	/* LANE2 */
			unsigned int no_source_le_narp;	/* LANE2 */
		} normal;
		struct atmlec_config_msg config;
		struct {
			__u16 lec_id;				/* requestor lec_id  */
			__u32 tran_id;				/* transaction id    */
			unsigned char mac_addr[ETH_ALEN];	/* dst mac addr      */
			unsigned char atm_addr[ATM_ESA_LEN];	/* reqestor ATM addr */
		} proxy;	/*
				 * For mapping LE_ARP requests to responses. Filled by
				 * zeppelin, returned by kernel. Used only when proxying
				 */
	} content;
} __ATM_API_ALIGN;

struct atmlec_ioc {
	int dev_num;
	unsigned char atm_addr[ATM_ESA_LEN];
	unsigned char receive;	/* 1= receive vcc, 0 = send vcc */
};
#endif /* _ATMLEC_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /* atmppp.h - RFC2364 PPPoATM */

/* Written 2000 by Mitchell Blank Jr */

#ifndef _LINUX_ATMPPP_H
#define _LINUX_ATMPPP_H

#include <linux/atm.h>

#define PPPOATM_ENCAPS_AUTODETECT	(0)
#define PPPOATM_ENCAPS_VC		(1)
#define PPPOATM_ENCAPS_LLC		(2)

/*
 * This is for the ATM_SETBACKEND call - these are like socket families:
 * the first element of the structure is the backend number and the rest
 * is per-backend specific
 */
struct atm_backend_ppp {
	atm_backend_t	backend_num;	/* ATM_BACKEND_PPP */
	int		encaps;		/* PPPOATM_ENCAPS_* */
};

#endif	/* _LINUX_ATMPPP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #ifndef _ATMMPC_H_
#define _ATMMPC_H_

#include <linux/atmapi.h>
#include <linux/atmioc.h>
#include <linux/atm.h>
#include <linux/types.h>

#define ATMMPC_CTRL _IO('a', ATMIOC_MPOA)
#define ATMMPC_DATA _IO('a', ATMIOC_MPOA+1)

#define MPC_SOCKET_INGRESS 1
#define MPC_SOCKET_EGRESS  2

struct atmmpc_ioc {
        int dev_num;
        __be32 ipaddr;              /* the IP address of the shortcut    */
        int type;                     /* ingress or egress                 */
};

typedef struct in_ctrl_info {
        __u8   Last_NHRP_CIE_code;
        __u8   Last_Q2931_cause_value;
        __u8   eg_MPC_ATM_addr[ATM_ESA_LEN];
        __be32  tag;
        __be32  in_dst_ip;      /* IP address this ingress MPC sends packets to */
        __u16  holding_time;
        __u32  request_id;
} in_ctrl_info;

typedef struct eg_ctrl_info {
        __u8   DLL_header[256];
        __u8   DH_length;
        __be32  cache_id;
        __be32  tag;
        __be32  mps_ip;
        __be32  eg_dst_ip;      /* IP address to which ingress MPC sends packets */
        __u8   in_MPC_data_ATM_addr[ATM_ESA_LEN];
        __u16  holding_time;
} eg_ctrl_info;

struct mpc_parameters {
        __u16 mpc_p1;   /* Shortcut-Setup Frame Count    */
        __u16 mpc_p2;   /* Shortcut-Setup Frame Time     */
        __u8 mpc_p3[8]; /* Flow-detection Protocols      */
        __u16 mpc_p4;   /* MPC Initial Retry Time        */
        __u16 mpc_p5;   /* MPC Retry Time Maximum        */
        __u16 mpc_p6;   /* Hold Down Time                */
} ;

struct k_message {
        __u16 type;
        __be32 ip_mask;
        __u8  MPS_ctrl[ATM_ESA_LEN];
        union {
                in_ctrl_info in_info;
                eg_ctrl_info eg_info;
                struct mpc_parameters params;
        } content;
        struct atm_qos qos;       
} __ATM_API_ALIGN;

struct llc_snap_hdr {
	/* RFC 1483 LLC/SNAP encapsulation for routed IP PDUs */
        __u8  dsap;    /* Destination Service Access Point (0xAA)     */
        __u8  ssap;    /* Source Service Access Point      (0xAA)     */
        __u8  ui;      /* Unnumbered Information           (0x03)     */
        __u8  org[3];  /* Organizational identification    (0x000000) */
        __u8  type[2]; /* Ether type (for IP)              (0x0800)   */
};

/* TLVs this MPC recognizes */
#define TLV_MPOA_DEVICE_TYPE         0x00a03e2a  

/* MPOA device types in MPOA Device Type TLV */
#define NON_MPOA    0
#define MPS         1
#define MPC         2
#define MPS_AND_MPC 3


/* MPC parameter defaults */

#define MPC_P1 10  /* Shortcut-Setup Frame Count  */ 
#define MPC_P2 1   /* Shortcut-Setup Frame Time   */
#define MPC_P3 0   /* Flow-detection Protocols    */
#define MPC_P4 5   /* MPC Initial Retry Time      */
#define MPC_P5 40  /* MPC Retry Time Maximum      */
#define MPC_P6 160 /* Hold Down Time              */
#define HOLDING_TIME_DEFAULT 1200 /* same as MPS-p7 */

/* MPC constants */

#define MPC_C1 2   /* Retry Time Multiplier       */
#define MPC_C2 60  /* Initial Keep-Alive Lifetime */

/* Message types - to MPOA daemon */

#define SND_MPOA_RES_RQST    201
#define SET_MPS_CTRL_ADDR    202
#define SND_MPOA_RES_RTRY    203 /* Different type in a retry due to req id         */
#define STOP_KEEP_ALIVE_SM   204
#define EGRESS_ENTRY_REMOVED 205
#define SND_EGRESS_PURGE     206
#define DIE                  207 /* tell the daemon to exit()                       */
#define DATA_PLANE_PURGE     208 /* Data plane purge because of egress cache hit miss or dead MPS */
#define OPEN_INGRESS_SVC     209

/* Message types - from MPOA daemon */

#define MPOA_TRIGGER_RCVD     101
#define MPOA_RES_REPLY_RCVD   102
#define INGRESS_PURGE_RCVD    103
#define EGRESS_PURGE_RCVD     104
#define MPS_DEATH             105
#define CACHE_IMPOS_RCVD      106
#define SET_MPC_CTRL_ADDR     107 /* Our MPC's control ATM address   */
#define SET_MPS_MAC_ADDR      108
#define CLEAN_UP_AND_EXIT     109
#define SET_MPC_PARAMS        110 /* MPC configuration parameters    */

/* Message types - bidirectional */       

#define RELOAD                301 /* kill -HUP the daemon for reload */

#endif /* _ATMMPC_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /* atmsap.h - ATM Service Access Point addressing definitions */

/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */


#ifndef _LINUX_ATMSAP_H
#define _LINUX_ATMSAP_H

#include <linux/atmapi.h>

/*
 * BEGIN_xx and END_xx markers are used for automatic generation of
 * documentation. Do not change them.
 */


/*
 * Layer 2 protocol identifiers
 */

/* BEGIN_L2 */
#define ATM_L2_NONE	0	/* L2 not specified */
#define ATM_L2_ISO1745  0x01	/* Basic mode ISO 1745 */
#define ATM_L2_Q291	0x02	/* ITU-T Q.291 (Rec. I.441) */
#define ATM_L2_X25_LL	0x06	/* ITU-T X.25, link layer */
#define ATM_L2_X25_ML	0x07	/* ITU-T X.25, multilink */
#define ATM_L2_LAPB	0x08	/* Extended LAPB, half-duplex (Rec. T.71) */
#define ATM_L2_HDLC_ARM	0x09	/* HDLC ARM (ISO/IEC 4335) */
#define ATM_L2_HDLC_NRM	0x0a	/* HDLC NRM (ISO/IEC 4335) */
#define ATM_L2_HDLC_ABM	0x0b	/* HDLC ABM (ISO/IEC 4335) */
#define ATM_L2_ISO8802	0x0c	/* LAN LLC (ISO/IEC 8802/2) */
#define ATM_L2_X75	0x0d	/* ITU-T X.75, SLP */
#define ATM_L2_Q922	0x0e	/* ITU-T Q.922 */
#define ATM_L2_USER	0x10	/* user-specified */
#define ATM_L2_ISO7776	0x11	/* ISO 7776 DTE-DTE */
/* END_L2 */


/*
 * Layer 3 protocol identifiers
 */

/* BEGIN_L3 */
#define ATM_L3_NONE	0	/* L3 not specified */
#define ATM_L3_X25	0x06	/* ITU-T X.25, packet layer */
#define ATM_L3_ISO8208	0x07	/* ISO/IEC 8208 */
#define ATM_L3_X223	0x08	/* ITU-T X.223 | ISO/IEC 8878 */
#define ATM_L3_ISO8473	0x09	/* ITU-T X.233 | ISO/IEC 8473 */
#define ATM_L3_T70	0x0a	/* ITU-T T.70 minimum network layer */
#define ATM_L3_TR9577	0x0b	/* ISO/IEC TR 9577 */
#define ATM_L3_H310	0x0c	/* ITU-T Recommendation H.310 */
#define ATM_L3_H321	0x0d	/* ITU-T Recommendation H.321 */
#define ATM_L3_USER	0x10	/* user-specified */
/* END_L3 */


/*
 * High layer identifiers
 */

/* BEGIN_HL */
#define ATM_HL_NONE	0	/* HL not specified */
#define ATM_HL_ISO	0x01	/* ISO */
#define ATM_HL_USER	0x02	/* user-specific */
#define ATM_HL_HLP	0x03	/* high layer profile - UNI 3.0 only */
#define ATM_HL_VENDOR	0x04	/* vendor-specific application identifier */
/* END_HL */


/*
 * ITU-T coded mode of operation
 */

/* BEGIN_IMD */
#define ATM_IMD_NONE	 0	/* mode not specified */
#define ATM_IMD_NORMAL	 1	/* normal mode of operation */
#define ATM_IMD_EXTENDED 2	/* extended mode of operation */
/* END_IMD */

/*
 * H.310 code points
 */

#define ATM_TT_NONE	0	/* terminal type not specified */
#define ATM_TT_RX	1	/* receive only */
#define ATM_TT_TX	2	/* send only */
#define ATM_TT_RXTX	3	/* receive and send */

#define ATM_MC_NONE	0	/* no multiplexing */
#define ATM_MC_TS	1	/* transport stream (TS) */
#define ATM_MC_TS_FEC	2	/* transport stream with forward error corr. */
#define ATM_MC_PS	3	/* program stream (PS) */
#define ATM_MC_PS_FEC	4	/* program stream with forward error corr. */
#define ATM_MC_H221	5	/* ITU-T Rec. H.221 */

/*
 * SAP structures
 */

#define ATM_MAX_HLI	8	/* maximum high-layer information length */


struct atm_blli {
    unsigned char l2_proto;	/* layer 2 protocol */
    union {
	struct {
	    unsigned char mode;	/* mode of operation (ATM_IMD_xxx), 0 if */
				/* absent */
	    unsigned char window; /* window size (k), 1-127 (0 to omit) */
	} itu;			/* ITU-T encoding */
	unsigned char user;	/* user-specified l2 information */
    } l2;
    unsigned char l3_proto;	/* layer 3 protocol */
    union {
	struct {
	    unsigned char mode;	/* mode of operation (ATM_IMD_xxx), 0 if */
				/* absent */
	    unsigned char def_size; /* default packet size (log2), 4-12 (0 to */
				    /* omit) */
	    unsigned char window;/* packet window size, 1-127 (0 to omit) */
	} itu;			/* ITU-T encoding */
	unsigned char user;	/* user specified l3 information */
	struct {		      /* if l3_proto = ATM_L3_H310 */
	    unsigned char term_type;  /* terminal type */
	    unsigned char fw_mpx_cap; /* forward multiplexing capability */
				      /* only if term_type != ATM_TT_NONE */
	    unsigned char bw_mpx_cap; /* backward multiplexing capability */
				      /* only if term_type != ATM_TT_NONE */
	} h310;
	struct {		  /* if l3_proto = ATM_L3_TR9577 */
	    unsigned char ipi;	  /* initial protocol id */
	    unsigned char snap[5];/* IEEE 802.1 SNAP identifier */
				  /* (only if ipi == NLPID_IEEE802_1_SNAP) */
	} tr9577;
    } l3;
} __ATM_API_ALIGN;


struct atm_bhli {
    unsigned char hl_type;	/* high layer information type */
    unsigned char hl_length;	/* length (only if hl_type == ATM_HL_USER || */
				/* hl_type == ATM_HL_ISO) */
    unsigned char hl_info[ATM_MAX_HLI];/* high layer information */
};


#define ATM_MAX_BLLI	3		/* maximum number of BLLI elements */


struct atm_sap {
	struct atm_bhli bhli;		/* local SAP, high-layer information */
	struct atm_blli blli[ATM_MAX_BLLI] __ATM_API_ALIGN;
					/* local SAP, low-layer info */
};


static __inline__ int blli_in_use(struct atm_blli blli)
{
	return blli.l2_proto || blli.l3_proto;
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /* atmsvc.h - ATM signaling kernel-demon interface definitions */
 
/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
 

#ifndef _LINUX_ATMSVC_H
#define _LINUX_ATMSVC_H

#include <linux/atmapi.h>
#include <linux/atm.h>
#include <linux/atmioc.h>


#define ATMSIGD_CTRL _IO('a',ATMIOC_SPECIAL)
				/* become ATM signaling demon control socket */

enum atmsvc_msg_type { as_catch_null, as_bind, as_connect, as_accept, as_reject,
		       as_listen, as_okay, as_error, as_indicate, as_close,
		       as_itf_notify, as_modify, as_identify, as_terminate,
		       as_addparty, as_dropparty };

struct atmsvc_msg {
	enum atmsvc_msg_type type;
	atm_kptr_t vcc;
	atm_kptr_t listen_vcc;		/* indicate */
	int reply;			/* for okay and close:		   */
					/*   < 0: error before active	   */
					/*        (sigd has discarded ctx) */
					/*   ==0: success		   */
				        /*   > 0: error when active (still */
					/*        need to close)	   */
	struct sockaddr_atmpvc pvc;	/* indicate, okay (connect) */
	struct sockaddr_atmsvc local;	/* local SVC address */
	struct atm_qos qos;		/* QOS parameters */
	struct atm_sap sap;		/* SAP */
	unsigned int session;		/* for p2pm */
	struct sockaddr_atmsvc svc;	/* SVC address */
} __ATM_API_ALIGN;

/*
 * Message contents: see ftp://icaftp.epfl.ch/pub/linux/atm/docs/isp-*.tar.gz
 */

/*
 * Some policy stuff for atmsigd and for net/atm/svc.c. Both have to agree on
 * what PCR is used to request bandwidth from the device driver. net/atm/svc.c
 * tries to do better than that, but only if there's no routing decision (i.e.
 * if signaling only uses one ATM interface).
 */

#define SELECT_TOP_PCR(tp) ((tp).pcr ? (tp).pcr : \
  (tp).max_pcr && (tp).max_pcr != ATM_MAX_PCR ? (tp).max_pcr : \
  (tp).min_pcr ? (tp).min_pcr : ATM_MAX_PCR)

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /* audit.h -- Auditing support
 *
 * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Written by Rickard E. (Rik) Faith <faith@redhat.com>
 *
 */

#ifndef _LINUX_AUDIT_H_
#define _LINUX_AUDIT_H_

#include <linux/types.h>
#include <linux/elf-em.h>

/* The netlink messages for the audit system is divided into blocks:
 * 1000 - 1099 are for commanding the audit system
 * 1100 - 1199 user space trusted application messages
 * 1200 - 1299 messages internal to the audit daemon
 * 1300 - 1399 audit event messages
 * 1400 - 1499 SE Linux use
 * 1500 - 1599 kernel LSPP events
 * 1600 - 1699 kernel crypto events
 * 1700 - 1799 kernel anomaly records
 * 1800 - 1899 kernel integrity events
 * 1900 - 1999 future kernel use
 * 2000 is for otherwise unclassified kernel audit messages (legacy)
 * 2001 - 2099 unused (kernel)
 * 2100 - 2199 user space anomaly records
 * 2200 - 2299 user space actions taken in response to anomalies
 * 2300 - 2399 user space generated LSPP events
 * 2400 - 2499 user space crypto events
 * 2500 - 2999 future user space (maybe integrity labels and related events)
 *
 * Messages from 1000-1199 are bi-directional. 1200-1299 & 2100 - 2999 are
 * exclusively user space. 1300-2099 is kernel --> user space 
 * communication.
 */
#define AUDIT_GET		1000	/* Get status */
#define AUDIT_SET		1001	/* Set status (enable/disable/auditd) */
#define AUDIT_LIST		1002	/* List syscall rules -- deprecated */
#define AUDIT_ADD		1003	/* Add syscall rule -- deprecated */
#define AUDIT_DEL		1004	/* Delete syscall rule -- deprecated */
#define AUDIT_USER		1005	/* Message from userspace -- deprecated */
#define AUDIT_LOGIN		1006	/* Define the login id and information */
#define AUDIT_WATCH_INS		1007	/* Insert file/dir watch entry */
#define AUDIT_WATCH_REM		1008	/* Remove file/dir watch entry */
#define AUDIT_WATCH_LIST	1009	/* List all file/dir watches */
#define AUDIT_SIGNAL_INFO	1010	/* Get info about sender of signal to auditd */
#define AUDIT_ADD_RULE		1011	/* Add syscall filtering rule */
#define AUDIT_DEL_RULE		1012	/* Delete syscall filtering rule */
#define AUDIT_LIST_RULES	1013	/* List syscall filtering rules */
#define AUDIT_TRIM		1014	/* Trim junk from watched tree */
#define AUDIT_MAKE_EQUIV	1015	/* Append to watched tree */
#define AUDIT_TTY_GET		1016	/* Get TTY auditing status */
#define AUDIT_TTY_SET		1017	/* Set TTY auditing status */
#define AUDIT_SET_FEATURE	1018	/* Turn an audit feature on or off */
#define AUDIT_GET_FEATURE	1019	/* Get which features are enabled */

#define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages mostly uninteresting to kernel */
#define AUDIT_USER_AVC		1107	/* We filter this differently */
#define AUDIT_USER_TTY		1124	/* Non-ICANON TTY input meaning */
#define AUDIT_LAST_USER_MSG	1199
#define AUDIT_FIRST_USER_MSG2	2100	/* More user space messages */
#define AUDIT_LAST_USER_MSG2	2999
 
#define AUDIT_DAEMON_START      1200    /* Daemon startup record */
#define AUDIT_DAEMON_END        1201    /* Daemon normal stop record */
#define AUDIT_DAEMON_ABORT      1202    /* Daemon error stop record */
#define AUDIT_DAEMON_CONFIG     1203    /* Daemon config change */

#define AUDIT_SYSCALL		1300	/* Syscall event */
/* #define AUDIT_FS_WATCH	1301	 * Deprecated */
#define AUDIT_PATH		1302	/* Filename path information */
#define AUDIT_IPC		1303	/* IPC record */
#define AUDIT_SOCKETCALL	1304	/* sys_socketcall arguments */
#define AUDIT_CONFIG_CHANGE	1305	/* Audit system configuration change */
#define AUDIT_SOCKADDR		1306	/* sockaddr copied as syscall arg */
#define AUDIT_CWD		1307	/* Current working directory */
#define AUDIT_EXECVE		1309	/* execve arguments */
#define AUDIT_IPC_SET_PERM	1311	/* IPC new permissions record type */
#define AUDIT_MQ_OPEN		1312	/* POSIX MQ open record type */
#define AUDIT_MQ_SENDRECV	1313	/* POSIX MQ send/receive record type */
#define AUDIT_MQ_NOTIFY		1314	/* POSIX MQ notify record type */
#define AUDIT_MQ_GETSETATTR	1315	/* POSIX MQ get/set attribute record type */
#define AUDIT_KERNEL_OTHER	1316	/* For use by 3rd party modules */
#define AUDIT_FD_PAIR		1317    /* audit record for pipe/socketpair */
#define AUDIT_OBJ_PID		1318	/* ptrace target */
#define AUDIT_TTY		1319	/* Input on an administrative TTY */
#define AUDIT_EOE		1320	/* End of multi-record event */
#define AUDIT_BPRM_FCAPS	1321	/* Information about fcaps increasing perms */
#define AUDIT_CAPSET		1322	/* Record showing argument to sys_capset */
#define AUDIT_MMAP		1323	/* Record showing descriptor and flags in mmap */
#define AUDIT_NETFILTER_PKT	1324	/* Packets traversing netfilter chains */
#define AUDIT_NETFILTER_CFG	1325	/* Netfilter chain modifications */
#define AUDIT_SECCOMP		1326	/* Secure Computing event */
#define AUDIT_PROCTITLE		1327	/* Proctitle emit event */
#define AUDIT_FEATURE_CHANGE	1328	/* audit log listing feature changes */

#define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
#define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
#define AUDIT_AVC_PATH		1402	/* dentry, vfsmount pair from avc */
#define AUDIT_MAC_POLICY_LOAD	1403	/* Policy file load */
#define AUDIT_MAC_STATUS	1404	/* Changed enforcing,permissive,off */
#define AUDIT_MAC_CONFIG_CHANGE	1405	/* Changes to booleans */
#define AUDIT_MAC_UNLBL_ALLOW	1406	/* NetLabel: allow unlabeled traffic */
#define AUDIT_MAC_CIPSOV4_ADD	1407	/* NetLabel: add CIPSOv4 DOI entry */
#define AUDIT_MAC_CIPSOV4_DEL	1408	/* NetLabel: del CIPSOv4 DOI entry */
#define AUDIT_MAC_MAP_ADD	1409	/* NetLabel: add LSM domain mapping */
#define AUDIT_MAC_MAP_DEL	1410	/* NetLabel: del LSM domain mapping */
#define AUDIT_MAC_IPSEC_ADDSA	1411	/* Not used */
#define AUDIT_MAC_IPSEC_DELSA	1412	/* Not used  */
#define AUDIT_MAC_IPSEC_ADDSPD	1413	/* Not used */
#define AUDIT_MAC_IPSEC_DELSPD	1414	/* Not used */
#define AUDIT_MAC_IPSEC_EVENT	1415	/* Audit an IPSec event */
#define AUDIT_MAC_UNLBL_STCADD	1416	/* NetLabel: add a static label */
#define AUDIT_MAC_UNLBL_STCDEL	1417	/* NetLabel: del a static label */

#define AUDIT_FIRST_KERN_ANOM_MSG   1700
#define AUDIT_LAST_KERN_ANOM_MSG    1799
#define AUDIT_ANOM_PROMISCUOUS      1700 /* Device changed promiscuous mode */
#define AUDIT_ANOM_ABEND            1701 /* Process ended abnormally */
#define AUDIT_ANOM_LINK		    1702 /* Suspicious use of file links */
#define AUDIT_INTEGRITY_DATA	    1800 /* Data integrity verification */
#define AUDIT_INTEGRITY_METADATA    1801 /* Metadata integrity verification */
#define AUDIT_INTEGRITY_STATUS	    1802 /* Integrity enable status */
#define AUDIT_INTEGRITY_HASH	    1803 /* Integrity HASH type */
#define AUDIT_INTEGRITY_PCR	    1804 /* PCR invalidation msgs */
#define AUDIT_INTEGRITY_RULE	    1805 /* policy rule */

#define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */

/* Rule flags */
#define AUDIT_FILTER_USER	0x00	/* Apply rule to user-generated messages */
#define AUDIT_FILTER_TASK	0x01	/* Apply rule at task creation (not syscall) */
#define AUDIT_FILTER_ENTRY	0x02	/* Apply rule at syscall entry */
#define AUDIT_FILTER_WATCH	0x03	/* Apply rule to file system watches */
#define AUDIT_FILTER_EXIT	0x04	/* Apply rule at syscall exit */
#define AUDIT_FILTER_TYPE	0x05	/* Apply rule at audit_log_start */

#define AUDIT_NR_FILTERS	6

#define AUDIT_FILTER_PREPEND	0x10	/* Prepend to front of list */

/* Rule actions */
#define AUDIT_NEVER    0	/* Do not build context if rule matches */
#define AUDIT_POSSIBLE 1	/* Build context if rule matches  */
#define AUDIT_ALWAYS   2	/* Generate audit record if rule matches */

/* Rule structure sizes -- if these change, different AUDIT_ADD and
 * AUDIT_LIST commands must be implemented. */
#define AUDIT_MAX_FIELDS   64
#define AUDIT_MAX_KEY_LEN  256
#define AUDIT_BITMASK_SIZE 64
#define AUDIT_WORD(nr) ((__u32)((nr)/32))
#define AUDIT_BIT(nr)  (1 << ((nr) - AUDIT_WORD(nr)*32))

#define AUDIT_SYSCALL_CLASSES 16
#define AUDIT_CLASS_DIR_WRITE 0
#define AUDIT_CLASS_DIR_WRITE_32 1
#define AUDIT_CLASS_CHATTR 2
#define AUDIT_CLASS_CHATTR_32 3
#define AUDIT_CLASS_READ 4
#define AUDIT_CLASS_READ_32 5
#define AUDIT_CLASS_WRITE 6
#define AUDIT_CLASS_WRITE_32 7
#define AUDIT_CLASS_SIGNAL 8
#define AUDIT_CLASS_SIGNAL_32 9

/* This bitmask is used to validate user input.  It represents all bits that
 * are currently used in an audit field constant understood by the kernel.
 * If you are adding a new #define AUDIT_<whatever>, please ensure that
 * AUDIT_UNUSED_BITS is updated if need be. */
#define AUDIT_UNUSED_BITS	0x07FFFC00

/* AUDIT_FIELD_COMPARE rule list */
#define AUDIT_COMPARE_UID_TO_OBJ_UID	1
#define AUDIT_COMPARE_GID_TO_OBJ_GID	2
#define AUDIT_COMPARE_EUID_TO_OBJ_UID	3
#define AUDIT_COMPARE_EGID_TO_OBJ_GID	4
#define AUDIT_COMPARE_AUID_TO_OBJ_UID	5
#define AUDIT_COMPARE_SUID_TO_OBJ_UID	6
#define AUDIT_COMPARE_SGID_TO_OBJ_GID	7
#define AUDIT_COMPARE_FSUID_TO_OBJ_UID	8
#define AUDIT_COMPARE_FSGID_TO_OBJ_GID	9

#define AUDIT_COMPARE_UID_TO_AUID	10
#define AUDIT_COMPARE_UID_TO_EUID	11
#define AUDIT_COMPARE_UID_TO_FSUID	12
#define AUDIT_COMPARE_UID_TO_SUID	13

#define AUDIT_COMPARE_AUID_TO_FSUID	14
#define AUDIT_COMPARE_AUID_TO_SUID	15
#define AUDIT_COMPARE_AUID_TO_EUID	16

#define AUDIT_COMPARE_EUID_TO_SUID	17
#define AUDIT_COMPARE_EUID_TO_FSUID	18

#define AUDIT_COMPARE_SUID_TO_FSUID	19

#define AUDIT_COMPARE_GID_TO_EGID	20
#define AUDIT_COMPARE_GID_TO_FSGID	21
#define AUDIT_COMPARE_GID_TO_SGID	22

#define AUDIT_COMPARE_EGID_TO_FSGID	23
#define AUDIT_COMPARE_EGID_TO_SGID	24
#define AUDIT_COMPARE_SGID_TO_FSGID	25

#define AUDIT_MAX_FIELD_COMPARE		AUDIT_COMPARE_SGID_TO_FSGID

/* Rule fields */
				/* These are useful when checking the
				 * task structure at task creation time
				 * (AUDIT_PER_TASK).  */
#define AUDIT_PID	0
#define AUDIT_UID	1
#define AUDIT_EUID	2
#define AUDIT_SUID	3
#define AUDIT_FSUID	4
#define AUDIT_GID	5
#define AUDIT_EGID	6
#define AUDIT_SGID	7
#define AUDIT_FSGID	8
#define AUDIT_LOGINUID	9
#define AUDIT_PERS	10
#define AUDIT_ARCH	11
#define AUDIT_MSGTYPE	12
#define AUDIT_SUBJ_USER	13	/* security label user */
#define AUDIT_SUBJ_ROLE	14	/* security label role */
#define AUDIT_SUBJ_TYPE	15	/* security label type */
#define AUDIT_SUBJ_SEN	16	/* security label sensitivity label */
#define AUDIT_SUBJ_CLR	17	/* security label clearance label */
#define AUDIT_PPID	18
#define AUDIT_OBJ_USER	19
#define AUDIT_OBJ_ROLE	20
#define AUDIT_OBJ_TYPE	21
#define AUDIT_OBJ_LEV_LOW	22
#define AUDIT_OBJ_LEV_HIGH	23
#define AUDIT_LOGINUID_SET	24

				/* These are ONLY useful when checking
				 * at syscall exit time (AUDIT_AT_EXIT). */
#define AUDIT_DEVMAJOR	100
#define AUDIT_DEVMINOR	101
#define AUDIT_INODE	102
#define AUDIT_EXIT	103
#define AUDIT_SUCCESS   104	/* exit >= 0; value ignored */
#define AUDIT_WATCH	105
#define AUDIT_PERM	106
#define AUDIT_DIR	107
#define AUDIT_FILETYPE	108
#define AUDIT_OBJ_UID	109
#define AUDIT_OBJ_GID	110
#define AUDIT_FIELD_COMPARE	111

#define AUDIT_ARG0      200
#define AUDIT_ARG1      (AUDIT_ARG0+1)
#define AUDIT_ARG2      (AUDIT_ARG0+2)
#define AUDIT_ARG3      (AUDIT_ARG0+3)

#define AUDIT_FILTERKEY	210

#define AUDIT_NEGATE			0x80000000

/* These are the supported operators.
 *	4  2  1  8
 *	=  >  <  ?
 *	----------
 *	0  0  0	 0	00	nonsense
 *	0  0  0	 1	08	&  bit mask
 *	0  0  1	 0	10	<
 *	0  1  0	 0	20	>
 *	0  1  1	 0	30	!=
 *	1  0  0	 0	40	=
 *	1  0  0	 1	48	&=  bit test
 *	1  0  1	 0	50	<=
 *	1  1  0	 0	60	>=
 *	1  1  1	 1	78	all operators
 */
#define AUDIT_BIT_MASK			0x08000000
#define AUDIT_LESS_THAN			0x10000000
#define AUDIT_GREATER_THAN		0x20000000
#define AUDIT_NOT_EQUAL			0x30000000
#define AUDIT_EQUAL			0x40000000
#define AUDIT_BIT_TEST			(AUDIT_BIT_MASK|AUDIT_EQUAL)
#define AUDIT_LESS_THAN_OR_EQUAL	(AUDIT_LESS_THAN|AUDIT_EQUAL)
#define AUDIT_GREATER_THAN_OR_EQUAL	(AUDIT_GREATER_THAN|AUDIT_EQUAL)
#define AUDIT_OPERATORS			(AUDIT_EQUAL|AUDIT_NOT_EQUAL|AUDIT_BIT_MASK)

enum {
	Audit_equal,
	Audit_not_equal,
	Audit_bitmask,
	Audit_bittest,
	Audit_lt,
	Audit_gt,
	Audit_le,
	Audit_ge,
	Audit_bad
};

/* Status symbols */
				/* Mask values */
#define AUDIT_STATUS_ENABLED		0x0001
#define AUDIT_STATUS_FAILURE		0x0002
#define AUDIT_STATUS_PID		0x0004
#define AUDIT_STATUS_RATE_LIMIT		0x0008
#define AUDIT_STATUS_BACKLOG_LIMIT	0x0010
#define AUDIT_STATUS_BACKLOG_WAIT_TIME	0x0020

#define AUDIT_VERSION_BACKLOG_LIMIT	1
#define AUDIT_VERSION_BACKLOG_WAIT_TIME	2
#define AUDIT_VERSION_LATEST AUDIT_VERSION_BACKLOG_WAIT_TIME

				/* Failure-to-log actions */
#define AUDIT_FAIL_SILENT	0
#define AUDIT_FAIL_PRINTK	1
#define AUDIT_FAIL_PANIC	2

/*
 * These bits disambiguate different calling conventions that share an
 * ELF machine type, bitness, and endianness
 */
#define __AUDIT_ARCH_CONVENTION_MASK 0x30000000
#define __AUDIT_ARCH_CONVENTION_MIPS64_N32 0x20000000

/* distinguish syscall tables */
#define __AUDIT_ARCH_64BIT 0x80000000
#define __AUDIT_ARCH_LE	   0x40000000

#define AUDIT_ARCH_ALPHA	(EM_ALPHA|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
#define AUDIT_ARCH_ARM		(EM_ARM|__AUDIT_ARCH_LE)
#define AUDIT_ARCH_ARMEB	(EM_ARM)
#define AUDIT_ARCH_CRIS		(EM_CRIS|__AUDIT_ARCH_LE)
#define AUDIT_ARCH_FRV		(EM_FRV)
#define AUDIT_ARCH_I386		(EM_386|__AUDIT_ARCH_LE)
#define AUDIT_ARCH_IA64		(EM_IA_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
#define AUDIT_ARCH_M32R		(EM_M32R)
#define AUDIT_ARCH_M68K		(EM_68K)
#define AUDIT_ARCH_MIPS		(EM_MIPS)
#define AUDIT_ARCH_MIPSEL	(EM_MIPS|__AUDIT_ARCH_LE)
#define AUDIT_ARCH_MIPS64	(EM_MIPS|__AUDIT_ARCH_64BIT)
#define AUDIT_ARCH_MIPS64N32	(EM_MIPS|__AUDIT_ARCH_64BIT|\
				 __AUDIT_ARCH_CONVENTION_MIPS64_N32)
#define AUDIT_ARCH_MIPSEL64	(EM_MIPS|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
#define AUDIT_ARCH_MIPSEL64N32	(EM_MIPS|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE|\
				 __AUDIT_ARCH_CONVENTION_MIPS64_N32)
#define AUDIT_ARCH_OPENRISC	(EM_OPENRISC)
#define AUDIT_ARCH_PARISC	(EM_PARISC)
#define AUDIT_ARCH_PARISC64	(EM_PARISC|__AUDIT_ARCH_64BIT)
#define AUDIT_ARCH_PPC		(EM_PPC)
/* do not define AUDIT_ARCH_PPCLE since it is not supported by audit */
#define AUDIT_ARCH_PPC64	(EM_PPC64|__AUDIT_ARCH_64BIT)
#define AUDIT_ARCH_PPC64LE	(EM_PPC64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
#define AUDIT_ARCH_S390		(EM_S390)
#define AUDIT_ARCH_S390X	(EM_S390|__AUDIT_ARCH_64BIT)
#define AUDIT_ARCH_SH		(EM_SH)
#define AUDIT_ARCH_SHEL		(EM_SH|__AUDIT_ARCH_LE)
#define AUDIT_ARCH_SH64		(EM_SH|__AUDIT_ARCH_64BIT)
#define AUDIT_ARCH_SHEL64	(EM_SH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
#define AUDIT_ARCH_SPARC	(EM_SPARC)
#define AUDIT_ARCH_SPARC64	(EM_SPARCV9|__AUDIT_ARCH_64BIT)
#define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)

#define AUDIT_PERM_EXEC		1
#define AUDIT_PERM_WRITE	2
#define AUDIT_PERM_READ		4
#define AUDIT_PERM_ATTR		8

/* MAX_AUDIT_MESSAGE_LENGTH is set in audit:lib/libaudit.h as:
 * 8970 // PATH_MAX*2+CONTEXT_SIZE*2+11+256+1
 * max header+body+tailer: 44 + 29 + 32 + 262 + 7 + pad
 */
#define AUDIT_MESSAGE_TEXT_MAX	8560

/* Multicast Netlink socket groups (default up to 32) */
enum audit_nlgrps {
	AUDIT_NLGRP_NONE,	/* Group 0 not used */
	AUDIT_NLGRP_READLOG,	/* "best effort" read only socket */
	__AUDIT_NLGRP_MAX
};
#define AUDIT_NLGRP_MAX                (__AUDIT_NLGRP_MAX - 1)

struct audit_status {
	__u32		mask;		/* Bit mask for valid entries */
	__u32		enabled;	/* 1 = enabled, 0 = disabled */
	__u32		failure;	/* Failure-to-log action */
	__u32		pid;		/* pid of auditd process */
	__u32		rate_limit;	/* messages rate limit (per second) */
	__u32		backlog_limit;	/* waiting messages limit */
	__u32		lost;		/* messages lost */
	__u32		backlog;	/* messages waiting in queue */
	__u32		version;	/* audit api version number */
	__u32		backlog_wait_time;/* message queue wait timeout */
};

struct audit_features {
#define AUDIT_FEATURE_VERSION	1
	__u32	vers;
	__u32	mask;		/* which bits we are dealing with */
	__u32	features;	/* which feature to enable/disable */
	__u32	lock;		/* which features to lock */
};

#define AUDIT_FEATURE_ONLY_UNSET_LOGINUID	0
#define AUDIT_FEATURE_LOGINUID_IMMUTABLE	1
#define AUDIT_LAST_FEATURE			AUDIT_FEATURE_LOGINUID_IMMUTABLE

#define audit_feature_valid(x)		((x) >= 0 && (x) <= AUDIT_LAST_FEATURE)
#define AUDIT_FEATURE_TO_MASK(x)	(1 << ((x) & 31)) /* mask for __u32 */

struct audit_tty_status {
	__u32		enabled;	/* 1 = enabled, 0 = disabled */
	__u32		log_passwd;	/* 1 = enabled, 0 = disabled */
};

#define AUDIT_UID_UNSET (unsigned int)-1

/* audit_rule_data supports filter rules with both integer and string
 * fields.  It corresponds with AUDIT_ADD_RULE, AUDIT_DEL_RULE and
 * AUDIT_LIST_RULES requests.
 */
struct audit_rule_data {
	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
	__u32		field_count;
	__u32		mask[AUDIT_BITMASK_SIZE]; /* syscall(s) affected */
	__u32		fields[AUDIT_MAX_FIELDS];
	__u32		values[AUDIT_MAX_FIELDS];
	__u32		fieldflags[AUDIT_MAX_FIELDS];
	__u32		buflen;	/* total length of string fields */
	char		buf[0];	/* string fields buffer */
};

/* audit_rule is supported to maintain backward compatibility with
 * userspace.  It supports integer fields only and corresponds to
 * AUDIT_ADD, AUDIT_DEL and AUDIT_LIST requests.
 */
struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
	__u32		field_count;
	__u32		mask[AUDIT_BITMASK_SIZE];
	__u32		fields[AUDIT_MAX_FIELDS];
	__u32		values[AUDIT_MAX_FIELDS];
};

#endif /* _LINUX_AUDIT_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * Copyright (C) 2005-2014 Junjiro R. Okajima
 *
 * This program, aufs is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __AUFS_TYPE_H__
#define __AUFS_TYPE_H__

#define AUFS_NAME	"aufs"

#include <stdint.h>
#include <sys/types.h>

#include <linux/limits.h>

#define AUFS_VERSION	"3.16-20140908"

/* todo? move this to linux-2.6.19/include/magic.h */
#define AUFS_SUPER_MAGIC	('a' << 24 | 'u' << 16 | 'f' << 8 | 's')

/* ---------------------------------------------------------------------- */

#ifdef CONFIG_AUFS_BRANCH_MAX_127
typedef int8_t aufs_bindex_t;
#define AUFS_BRANCH_MAX 127
#else
typedef int16_t aufs_bindex_t;
#ifdef CONFIG_AUFS_BRANCH_MAX_511
#define AUFS_BRANCH_MAX 511
#elif defined(CONFIG_AUFS_BRANCH_MAX_1023)
#define AUFS_BRANCH_MAX 1023
#elif defined(CONFIG_AUFS_BRANCH_MAX_32767)
#define AUFS_BRANCH_MAX 32767
#endif
#endif


/* ---------------------------------------------------------------------- */

#define AUFS_FSTYPE		AUFS_NAME

#define AUFS_ROOT_INO		2
#define AUFS_FIRST_INO		11

#define AUFS_WH_PFX		".wh."
#define AUFS_WH_PFX_LEN		((int)sizeof(AUFS_WH_PFX) - 1)
#define AUFS_WH_TMP_LEN		4
/* a limit for rmdir/rename a dir and copyup */
#define AUFS_MAX_NAMELEN	(NAME_MAX \
				- AUFS_WH_PFX_LEN * 2	/* doubly whiteouted */\
				- 1			/* dot */\
				- AUFS_WH_TMP_LEN)	/* hex */
#define AUFS_XINO_FNAME		"." AUFS_NAME ".xino"
#define AUFS_XINO_DEFPATH	"/tmp/" AUFS_XINO_FNAME
#define AUFS_XINO_DEF_SEC	30 /* seconds */
#define AUFS_XINO_DEF_TRUNC	45 /* percentage */
#define AUFS_DIRWH_DEF		3
#define AUFS_RDCACHE_DEF	10 /* seconds */
#define AUFS_RDCACHE_MAX	3600 /* seconds */
#define AUFS_RDBLK_DEF		512 /* bytes */
#define AUFS_RDHASH_DEF		32
#define AUFS_WKQ_NAME		AUFS_NAME "d"
#define AUFS_MFS_DEF_SEC	30 /* seconds */
#define AUFS_MFS_MAX_SEC	3600 /* seconds */
#define AUFS_FHSM_CACHE_DEF_SEC	30 /* seconds */
#define AUFS_PLINK_WARN		50 /* number of plinks in a single bucket */

/* pseudo-link maintenace under /proc */
#define AUFS_PLINK_MAINT_NAME	"plink_maint"
#define AUFS_PLINK_MAINT_DIR	"fs/" AUFS_NAME
#define AUFS_PLINK_MAINT_PATH	AUFS_PLINK_MAINT_DIR "/" AUFS_PLINK_MAINT_NAME

#define AUFS_DIROPQ_NAME	AUFS_WH_PFX ".opq" /* whiteouted doubly */
#define AUFS_WH_DIROPQ		AUFS_WH_PFX AUFS_DIROPQ_NAME

#define AUFS_BASE_NAME		AUFS_WH_PFX AUFS_NAME
#define AUFS_PLINKDIR_NAME	AUFS_WH_PFX "plnk"
#define AUFS_ORPHDIR_NAME	AUFS_WH_PFX "orph"

/* doubly whiteouted */
#define AUFS_WH_BASE		AUFS_WH_PFX AUFS_BASE_NAME
#define AUFS_WH_PLINKDIR	AUFS_WH_PFX AUFS_PLINKDIR_NAME
#define AUFS_WH_ORPHDIR		AUFS_WH_PFX AUFS_ORPHDIR_NAME

/* branch permissions and attributes */
#define AUFS_BRPERM_RW		"rw"
#define AUFS_BRPERM_RO		"ro"
#define AUFS_BRPERM_RR		"rr"
#define AUFS_BRATTR_COO_REG	"coo_reg"
#define AUFS_BRATTR_COO_ALL	"coo_all"
#define AUFS_BRATTR_FHSM	"fhsm"
#define AUFS_BRATTR_UNPIN	"unpin"
#define AUFS_BRRATTR_WH		"wh"
#define AUFS_BRWATTR_NLWH	"nolwh"
#define AUFS_BRWATTR_MOO	"moo"

#define AuBrPerm_RW		1		/* writable, hardlinkable wh */
#define AuBrPerm_RO		(1 << 1)	/* readonly */
#define AuBrPerm_RR		(1 << 2)	/* natively readonly */
#define AuBrPerm_Mask		(AuBrPerm_RW | AuBrPerm_RO | AuBrPerm_RR)

#define AuBrAttr_COO_REG	(1 << 3)	/* copy-up on open */
#define AuBrAttr_COO_ALL	(1 << 4)
#define AuBrAttr_COO_Mask	(AuBrAttr_COO_REG | AuBrAttr_COO_ALL)

#define AuBrAttr_FHSM		(1 << 5)	/* file-based hsm */
#define AuBrAttr_UNPIN		(1 << 6)	/* rename-able top dir of
						   branch */

#define AuBrRAttr_WH		(1 << 7)	/* whiteout-able */
#define AuBrRAttr_Mask		AuBrRAttr_WH

#define AuBrWAttr_NoLinkWH	(1 << 8)	/* un-hardlinkable whiteouts */
#define AuBrWAttr_MOO		(1 << 9)	/* move-up on open */
#define AuBrWAttr_Mask		(AuBrWAttr_NoLinkWH | AuBrWAttr_MOO)

#define AuBrAttr_CMOO_Mask	(AuBrAttr_COO_Mask | AuBrWAttr_MOO)


/* the longest combination */
#define AuBrPermStrSz	sizeof(AUFS_BRPERM_RW		\
			       "+" AUFS_BRATTR_COO_REG	\
			       "+" AUFS_BRATTR_FHSM	\
			       "+" AUFS_BRATTR_UNPIN	\
			       "+" AUFS_BRWATTR_NLWH)

typedef struct {
	char a[AuBrPermStrSz];
} au_br_perm_str_t;

static __inline__ int au_br_writable(int brperm)
{
	return brperm & AuBrPerm_RW;
}

static __inline__ int au_br_whable(int brperm)
{
	return brperm & (AuBrPerm_RW | AuBrRAttr_WH);
}

static __inline__ int au_br_wh_linkable(int brperm)
{
	return !(brperm & AuBrWAttr_NoLinkWH);
}

static __inline__ int au_br_cmoo(int brperm)
{
	return brperm & AuBrAttr_CMOO_Mask;
}

static __inline__ int au_br_fhsm(int brperm)
{
	return brperm & AuBrAttr_FHSM;
}

/* ---------------------------------------------------------------------- */

/* ioctl */
enum {
	/* readdir in userspace */
	AuCtl_RDU,
	AuCtl_RDU_INO,

	AuCtl_WBR_FD,	/* pathconf wrapper */
	AuCtl_IBUSY,	/* busy inode */
	AuCtl_MVDOWN,	/* move-down */
	AuCtl_BR,	/* info about branches */
	AuCtl_FHSM_FD	/* connection for fhsm */
};

/* borrowed from linux/include/linux/kernel.h */
#ifndef ALIGN
#define ALIGN(x, a)		__ALIGN_MASK(x, (typeof(x))(a)-1)
#define __ALIGN_MASK(x, mask)	(((x)+(mask))&~(mask))
#endif

/* borrowed from linux/include/linux/compiler-gcc3.h */
#ifndef __aligned
#define __aligned(x)			__attribute__((aligned(x)))
#endif


struct au_rdu_cookie {
	uint64_t	h_pos;
	int16_t		bindex;
	uint8_t		flags;
	uint8_t		pad;
	uint32_t	generation;
} __aligned(8);

struct au_rdu_ent {
	uint64_t	ino;
	int16_t		bindex;
	uint8_t		type;
	uint8_t		nlen;
	uint8_t		wh;
	char		name[0];
} __aligned(8);

static __inline__ int au_rdu_len(int nlen)
{
	/* include the terminating NULL */
	return ALIGN(sizeof(struct au_rdu_ent) + nlen + 1,
		     sizeof(uint64_t));
}

union au_rdu_ent_ul {
	struct au_rdu_ent *e;
	uint64_t			ul;
};

enum {
	AufsCtlRduV_SZ,
	AufsCtlRduV_End
};

struct aufs_rdu {
	/* input */
	union {
		uint64_t	sz;	/* AuCtl_RDU */
		uint64_t	nent;	/* AuCtl_RDU_INO */
	};
	union au_rdu_ent_ul	ent;
	uint16_t		verify[AufsCtlRduV_End];

	/* input/output */
	uint32_t		blk;

	/* output */
	union au_rdu_ent_ul	tail;
	/* number of entries which were added in a single call */
	uint64_t		rent;
	uint8_t			full;
	uint8_t			shwh;

	struct au_rdu_cookie	cookie;
} __aligned(8);

/* ---------------------------------------------------------------------- */

struct aufs_wbr_fd {
	uint32_t	oflags;
	int16_t		brid;
} __aligned(8);

/* ---------------------------------------------------------------------- */

struct aufs_ibusy {
	uint64_t	ino, h_ino;
	int16_t		bindex;
} __aligned(8);

/* ---------------------------------------------------------------------- */

/* error code for move-down */
/* the actual message strings are implemented in aufs-util.git */
enum {
	EAU_MVDOWN_OPAQUE = 1,
	EAU_MVDOWN_WHITEOUT,
	EAU_MVDOWN_UPPER,
	EAU_MVDOWN_BOTTOM,
	EAU_MVDOWN_NOUPPER,
	EAU_MVDOWN_NOLOWERBR,
	EAU_Last
};

/* flags for move-down */
#define AUFS_MVDOWN_DMSG	1
#define AUFS_MVDOWN_OWLOWER	(1 << 1)	/* overwrite lower */
#define AUFS_MVDOWN_KUPPER	(1 << 2)	/* keep upper */
#define AUFS_MVDOWN_ROLOWER	(1 << 3)	/* do even if lower is RO */
#define AUFS_MVDOWN_ROLOWER_R	(1 << 4)	/* did on lower RO */
#define AUFS_MVDOWN_ROUPPER	(1 << 5)	/* do even if upper is RO */
#define AUFS_MVDOWN_ROUPPER_R	(1 << 6)	/* did on upper RO */
#define AUFS_MVDOWN_BRID_UPPER	(1 << 7)	/* upper brid */
#define AUFS_MVDOWN_BRID_LOWER	(1 << 8)	/* lower brid */
#define AUFS_MVDOWN_FHSM_LOWER	(1 << 9)	/* find fhsm attr for lower */
#define AUFS_MVDOWN_STFS	(1 << 10)	/* req. stfs */
#define AUFS_MVDOWN_STFS_FAILED	(1 << 11)	/* output: stfs is unusable */
#define AUFS_MVDOWN_BOTTOM	(1 << 12)	/* output: no more lowers */

/* index for move-down */
enum {
	AUFS_MVDOWN_UPPER,
	AUFS_MVDOWN_LOWER,
	AUFS_MVDOWN_NARRAY
};

/*
 * additional info of move-down
 * number of free blocks and inodes.
 * subset of struct kstatfs, but smaller and always 64bit.
 */
struct aufs_stfs {
	uint64_t	f_blocks;
	uint64_t	f_bavail;
	uint64_t	f_files;
	uint64_t	f_ffree;
};

struct aufs_stbr {
	int16_t			brid;	/* optional input */
	int16_t			bindex;	/* output */
	struct aufs_stfs	stfs;	/* output when AUFS_MVDOWN_STFS set */
} __aligned(8);

struct aufs_mvdown {
	uint32_t		flags;			/* input/output */
	struct aufs_stbr	stbr[AUFS_MVDOWN_NARRAY]; /* input/output */
	int8_t			au_errno;		/* output */
} __aligned(8);

/* ---------------------------------------------------------------------- */

union aufs_brinfo {
	/* PATH_MAX may differ between kernel-space and user-space */
	char	_spacer[4096];
	struct {
		int16_t	id;
		int	perm;
		char	path[0];
	};
} __aligned(8);

/* ---------------------------------------------------------------------- */

#define AuCtlType		'A'
#define AUFS_CTL_RDU		_IOWR(AuCtlType, AuCtl_RDU, struct aufs_rdu)
#define AUFS_CTL_RDU_INO	_IOWR(AuCtlType, AuCtl_RDU_INO, struct aufs_rdu)
#define AUFS_CTL_WBR_FD		_IOW(AuCtlType, AuCtl_WBR_FD, \
				     struct aufs_wbr_fd)
#define AUFS_CTL_IBUSY		_IOWR(AuCtlType, AuCtl_IBUSY, struct aufs_ibusy)
#define AUFS_CTL_MVDOWN		_IOWR(AuCtlType, AuCtl_MVDOWN, \
				      struct aufs_mvdown)
#define AUFS_CTL_BRINFO		_IOW(AuCtlType, AuCtl_BR, union aufs_brinfo)
#define AUFS_CTL_FHSM_FD	_IOW(AuCtlType, AuCtl_FHSM_FD, int)

#endif /* __AUFS_TYPE_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /* -*- linux-c -*- ------------------------------------------------------- *
 *   
 * linux/include/linux/auto_fs.h
 *
 *   Copyright 1997 Transmeta Corporation - All Rights Reserved
 *
 * This file is part of the Linux kernel and is made available under
 * the terms of the GNU General Public License, version 2, or at your
 * option, any later version, incorporated herein by reference.
 *
 * ----------------------------------------------------------------------- */


#ifndef _LINUX_AUTO_FS_H
#define _LINUX_AUTO_FS_H

#include <linux/types.h>
#include <sys/ioctl.h>


/* This file describes autofs v3 */
#define AUTOFS_PROTO_VERSION	3

/* Range of protocol versions defined */
#define AUTOFS_MAX_PROTO_VERSION	AUTOFS_PROTO_VERSION
#define AUTOFS_MIN_PROTO_VERSION	AUTOFS_PROTO_VERSION

/*
 * The wait_queue_token (autofs_wqt_t) is part of a structure which is passed
 * back to the kernel via ioctl from userspace. On architectures where 32- and
 * 64-bit userspace binaries can be executed it's important that the size of
 * autofs_wqt_t stays constant between 32- and 64-bit Linux kernels so that we
 * do not break the binary ABI interface by changing the structure size.
 */
#if defined(__ia64__) || defined(__alpha__) /* pure 64bit architectures */
typedef unsigned long autofs_wqt_t;
#else
typedef unsigned int autofs_wqt_t;
#endif

/* Packet types */
#define autofs_ptype_missing	0	/* Missing entry (mount request) */
#define autofs_ptype_expire	1	/* Expire entry (umount request) */

struct autofs_packet_hdr {
	int proto_version;		/* Protocol version */
	int type;			/* Type of packet */
};

struct autofs_packet_missing {
	struct autofs_packet_hdr hdr;
        autofs_wqt_t wait_queue_token;
	int len;
	char name[NAME_MAX+1];
};	

/* v3 expire (via ioctl) */
struct autofs_packet_expire {
	struct autofs_packet_hdr hdr;
	int len;
	char name[NAME_MAX+1];
};

#define AUTOFS_IOC_READY      _IO(0x93,0x60)
#define AUTOFS_IOC_FAIL       _IO(0x93,0x61)
#define AUTOFS_IOC_CATATONIC  _IO(0x93,0x62)
#define AUTOFS_IOC_PROTOVER   _IOR(0x93,0x63,int)
#define AUTOFS_IOC_SETTIMEOUT32 _IOWR(0x93,0x64,compat_ulong_t)
#define AUTOFS_IOC_SETTIMEOUT _IOWR(0x93,0x64,unsigned long)
#define AUTOFS_IOC_EXPIRE     _IOR(0x93,0x65,struct autofs_packet_expire)

#endif /* _LINUX_AUTO_FS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /* -*- c -*-
 * linux/include/linux/auto_fs4.h
 *
 * Copyright 1999-2000 Jeremy Fitzhardinge <jeremy@goop.org>
 *
 * This file is part of the Linux kernel and is made available under
 * the terms of the GNU General Public License, version 2, or at your
 * option, any later version, incorporated herein by reference.
 */

#ifndef _LINUX_AUTO_FS4_H
#define _LINUX_AUTO_FS4_H

/* Include common v3 definitions */
#include <linux/types.h>
#include <linux/auto_fs.h>

/* autofs v4 definitions */
#undef AUTOFS_PROTO_VERSION
#undef AUTOFS_MIN_PROTO_VERSION
#undef AUTOFS_MAX_PROTO_VERSION

#define AUTOFS_PROTO_VERSION		5
#define AUTOFS_MIN_PROTO_VERSION	3
#define AUTOFS_MAX_PROTO_VERSION	5

#define AUTOFS_PROTO_SUBVERSION		2

/* Mask for expire behaviour */
#define AUTOFS_EXP_IMMEDIATE		1
#define AUTOFS_EXP_LEAVES		2

#define AUTOFS_TYPE_ANY			0U
#define AUTOFS_TYPE_INDIRECT		1U
#define AUTOFS_TYPE_DIRECT		2U
#define AUTOFS_TYPE_OFFSET		4U

static __inline__ void set_autofs_type_indirect(unsigned int *type)
{
	*type = AUTOFS_TYPE_INDIRECT;
	return;
}

static __inline__ unsigned int autofs_type_indirect(unsigned int type)
{
	return (type == AUTOFS_TYPE_INDIRECT);
}

static __inline__ void set_autofs_type_direct(unsigned int *type)
{
	*type = AUTOFS_TYPE_DIRECT;
	return;
}

static __inline__ unsigned int autofs_type_direct(unsigned int type)
{
	return (type == AUTOFS_TYPE_DIRECT);
}

static __inline__ void set_autofs_type_offset(unsigned int *type)
{
	*type = AUTOFS_TYPE_OFFSET;
	return;
}

static __inline__ unsigned int autofs_type_offset(unsigned int type)
{
	return (type == AUTOFS_TYPE_OFFSET);
}

static __inline__ unsigned int autofs_type_trigger(unsigned int type)
{
	return (type == AUTOFS_TYPE_DIRECT || type == AUTOFS_TYPE_OFFSET);
}

/*
 * This isn't really a type as we use it to say "no type set" to
 * indicate we want to search for "any" mount in the
 * autofs_dev_ioctl_ismountpoint() device ioctl function.
 */
static __inline__ void set_autofs_type_any(unsigned int *type)
{
	*type = AUTOFS_TYPE_ANY;
	return;
}

static __inline__ unsigned int autofs_type_any(unsigned int type)
{
	return (type == AUTOFS_TYPE_ANY);
}

/* Daemon notification packet types */
enum autofs_notify {
	NFY_NONE,
	NFY_MOUNT,
	NFY_EXPIRE
};

/* Kernel protocol version 4 packet types */

/* Expire entry (umount request) */
#define autofs_ptype_expire_multi	2

/* Kernel protocol version 5 packet types */

/* Indirect mount missing and expire requests. */
#define autofs_ptype_missing_indirect	3
#define autofs_ptype_expire_indirect	4

/* Direct mount missing and expire requests */
#define autofs_ptype_missing_direct	5
#define autofs_ptype_expire_direct	6

/* v4 multi expire (via pipe) */
struct autofs_packet_expire_multi {
	struct autofs_packet_hdr hdr;
        autofs_wqt_t wait_queue_token;
	int len;
	char name[NAME_MAX+1];
};

union autofs_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_packet_missing missing;
	struct autofs_packet_expire expire;
	struct autofs_packet_expire_multi expire_multi;
};

/* autofs v5 common packet struct */
struct autofs_v5_packet {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	__u32 dev;
	__u64 ino;
	__u32 uid;
	__u32 gid;
	__u32 pid;
	__u32 tgid;
	__u32 len;
	char name[NAME_MAX+1];
};

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;
typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;
typedef struct autofs_v5_packet autofs_packet_missing_direct_t;
typedef struct autofs_v5_packet autofs_packet_expire_direct_t;

union autofs_v5_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_v5_packet v5_packet;
	autofs_packet_missing_indirect_t missing_indirect;
	autofs_packet_expire_indirect_t expire_indirect;
	autofs_packet_missing_direct_t missing_direct;
	autofs_packet_expire_direct_t expire_direct;
};

#define AUTOFS_IOC_EXPIRE_MULTI		_IOW(0x93,0x66,int)
#define AUTOFS_IOC_EXPIRE_INDIRECT	AUTOFS_IOC_EXPIRE_MULTI
#define AUTOFS_IOC_EXPIRE_DIRECT	AUTOFS_IOC_EXPIRE_MULTI
#define AUTOFS_IOC_PROTOSUBVER		_IOR(0x93,0x67,int)
#define AUTOFS_IOC_ASKUMOUNT		_IOR(0x93,0x70,int)


#endif /* _LINUX_AUTO_FS4_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #ifndef _LINUX_AUXVEC_H
#define _LINUX_AUXVEC_H

#include <asm/auxvec.h>

/* Symbolic values for the entries in the auxiliary table
   put on the initial stack */
#define AT_NULL   0	/* end of vector */
#define AT_IGNORE 1	/* entry should be ignored */
#define AT_EXECFD 2	/* file descriptor of program */
#define AT_PHDR   3	/* program headers for program */
#define AT_PHENT  4	/* size of program header entry */
#define AT_PHNUM  5	/* number of program headers */
#define AT_PAGESZ 6	/* system page size */
#define AT_BASE   7	/* base address of interpreter */
#define AT_FLAGS  8	/* flags */
#define AT_ENTRY  9	/* entry point of program */
#define AT_NOTELF 10	/* program is not ELF */
#define AT_UID    11	/* real uid */
#define AT_EUID   12	/* effective uid */
#define AT_GID    13	/* real gid */
#define AT_EGID   14	/* effective gid */
#define AT_PLATFORM 15  /* string identifying CPU for optimizations */
#define AT_HWCAP  16    /* arch dependent hints at CPU capabilities */
#define AT_CLKTCK 17	/* frequency at which times() increments */
/* AT_* values 18 through 22 are reserved */
#define AT_SECURE 23   /* secure mode boolean */
#define AT_BASE_PLATFORM 24	/* string identifying real platform, may
				 * differ from AT_PLATFORM. */
#define AT_RANDOM 25	/* address of 16 random bytes */
#define AT_HWCAP2 26	/* extension of AT_HWCAP */

#define AT_EXECFN  31	/* filename of program */


#endif /* _LINUX_AUXVEC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * These are the public elements of the Linux kernel AX.25 code. A similar
 * file netrom.h exists for the NET/ROM protocol.
 */

#ifndef	AX25_KERNEL_H
#define	AX25_KERNEL_H

#include <linux/socket.h>

#define AX25_MTU	256
#define AX25_MAX_DIGIS  8

#define AX25_WINDOW	1
#define AX25_T1		2
#define AX25_N2		3
#define AX25_T3		4
#define AX25_T2		5
#define	AX25_BACKOFF	6
#define	AX25_EXTSEQ	7
#define	AX25_PIDINCL	8
#define AX25_IDLE	9
#define AX25_PACLEN	10
#define AX25_IAMDIGI	12

#define AX25_KILL	99

#define SIOCAX25GETUID		(SIOCPROTOPRIVATE+0)
#define SIOCAX25ADDUID		(SIOCPROTOPRIVATE+1)
#define SIOCAX25DELUID		(SIOCPROTOPRIVATE+2)
#define SIOCAX25NOUID		(SIOCPROTOPRIVATE+3)
#define SIOCAX25OPTRT		(SIOCPROTOPRIVATE+7)
#define SIOCAX25CTLCON		(SIOCPROTOPRIVATE+8)
#define SIOCAX25GETINFOOLD	(SIOCPROTOPRIVATE+9)
#define SIOCAX25ADDFWD		(SIOCPROTOPRIVATE+10)
#define SIOCAX25DELFWD		(SIOCPROTOPRIVATE+11)
#define SIOCAX25DEVCTL          (SIOCPROTOPRIVATE+12)
#define SIOCAX25GETINFO         (SIOCPROTOPRIVATE+13)

#define AX25_SET_RT_IPMODE	2

#define AX25_NOUID_DEFAULT	0
#define AX25_NOUID_BLOCK	1

typedef struct {
	char		ax25_call[7];	/* 6 call + SSID (shifted ascii!) */
} ax25_address;

struct sockaddr_ax25 {
	__kernel_sa_family_t sax25_family;
	ax25_address	sax25_call;
	int		sax25_ndigis;
	/* Digipeater ax25_address sets follow */
};

#define sax25_uid	sax25_ndigis

struct full_sockaddr_ax25 {
	struct sockaddr_ax25 fsa_ax25;
	ax25_address	fsa_digipeater[AX25_MAX_DIGIS];
};

struct ax25_routes_struct {
	ax25_address	port_addr;
	ax25_address	dest_addr;
	unsigned char	digi_count;
	ax25_address	digi_addr[AX25_MAX_DIGIS];
};

struct ax25_route_opt_struct {
	ax25_address	port_addr;
	ax25_address	dest_addr;
	int		cmd;
	int		arg;
};

struct ax25_ctl_struct {
        ax25_address            port_addr;
        ax25_address            source_addr;
        ax25_address            dest_addr;
        unsigned int            cmd;
        unsigned long           arg;
        unsigned char           digi_count;
        ax25_address            digi_addr[AX25_MAX_DIGIS];
};

/* this will go away. Please do not export to user land */
struct ax25_info_struct_deprecated {
	unsigned int	n2, n2count;
	unsigned int	t1, t1timer;
	unsigned int	t2, t2timer;
	unsigned int	t3, t3timer;
	unsigned int	idle, idletimer;
	unsigned int	state;
	unsigned int	rcv_q, snd_q;
};

struct ax25_info_struct {
	unsigned int	n2, n2count;
	unsigned int	t1, t1timer;
	unsigned int	t2, t2timer;
	unsigned int	t3, t3timer;
	unsigned int	idle, idletimer;
	unsigned int	state;
	unsigned int	rcv_q, snd_q;
	unsigned int	vs, vr, va, vs_max;
	unsigned int	paclen;
	unsigned int	window;
};

struct ax25_fwd_struct {
	ax25_address	port_from;
	ax25_address	port_to;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* $Id: b1lli.h,v 1.8.8.3 2001/09/23 22:25:05 kai Exp $
 *
 * ISDN lowlevel-module for AVM B1-card.
 *
 * Copyright 1996 by Carsten Paeth (calle@calle.in-berlin.de)
 *
 * This software may be used and distributed according to the terms
 * of the GNU General Public License, incorporated herein by reference.
 *
 */

#ifndef _B1LLI_H_
#define _B1LLI_H_
/*
 * struct for loading t4 file 
 */
typedef struct avmb1_t4file {
	int len;
	unsigned char *data;
} avmb1_t4file;

typedef struct avmb1_loaddef {
	int contr;
	avmb1_t4file t4file;
} avmb1_loaddef;

typedef struct avmb1_loadandconfigdef {
	int contr;
	avmb1_t4file t4file;
        avmb1_t4file t4config; 
} avmb1_loadandconfigdef;

typedef struct avmb1_resetdef {
	int contr;
} avmb1_resetdef;

typedef struct avmb1_getdef {
	int contr;
	int cardtype;
	int cardstate;
} avmb1_getdef;

/*
 * struct for adding new cards 
 */
typedef struct avmb1_carddef {
	int port;
	int irq;
} avmb1_carddef;

#define AVM_CARDTYPE_B1		0
#define AVM_CARDTYPE_T1		1
#define AVM_CARDTYPE_M1		2
#define AVM_CARDTYPE_M2		3

typedef struct avmb1_extcarddef {
	int port;
	int irq;
        int cardtype;
        int cardnr;  /* for HEMA/T1 */
} avmb1_extcarddef;

#define	AVMB1_LOAD		0	/* load image to card */
#define AVMB1_ADDCARD		1	/* add a new card - OBSOLETE */
#define AVMB1_RESETCARD		2	/* reset a card */
#define	AVMB1_LOAD_AND_CONFIG	3	/* load image and config to card */
#define	AVMB1_ADDCARD_WITH_TYPE	4	/* add a new card, with cardtype */
#define AVMB1_GET_CARDINFO	5	/* get cardtype */
#define AVMB1_REMOVECARD	6	/* remove a card - OBSOLETE */

#define	AVMB1_REGISTERCARD_IS_OBSOLETE

#endif				/* _B1LLI_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * The Linux BAYCOM driver for the Baycom serial 1200 baud modem
 * and the parallel 9600 baud modem
 * (C) 1997-1998 by Thomas Sailer, HB9JNX/AE4WA
 */

#ifndef _BAYCOM_H
#define _BAYCOM_H

/* -------------------------------------------------------------------- */
/*
 * structs for the IOCTL commands
 */

struct baycom_debug_data {
	unsigned long debug1;
	unsigned long debug2;
	long debug3;
};

struct baycom_ioctl {
	int cmd;
	union {
		struct baycom_debug_data dbg;
	} data;
};

/* -------------------------------------------------------------------- */

/*
 * ioctl values change for baycom
 */
#define BAYCOMCTL_GETDEBUG       0x92

/* -------------------------------------------------------------------- */

#endif /* _BAYCOM_H */

/* --------------------------------------------------------------------- */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * Broadcom Cable Modem firmware format
 */

#ifndef __BCM933XX_HCS_H
#define __BCM933XX_HCS_H

#include <linux/types.h>

struct bcm_hcs {
	__u16 magic;
	__u16 control;
	__u16 rev_maj;
	__u16 rev_min;
	__u32 build_date;
	__u32 filelen;
	__u32 ldaddress;
	char filename[64];
	__u16 hcs;
	__u16 her_znaet_chto;
	__u32 crc;
};

#endif /* __BCM933XX_HCS */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 *	include/linux/bfs_fs.h - BFS data structures on disk.
 *	Copyright (C) 1999 Tigran Aivazian <tigran@veritas.com>
 */

#ifndef _LINUX_BFS_FS_H
#define _LINUX_BFS_FS_H

#include <linux/types.h>

#define BFS_BSIZE_BITS		9
#define BFS_BSIZE		(1<<BFS_BSIZE_BITS)

#define BFS_MAGIC		0x1BADFACE
#define BFS_ROOT_INO		2
#define BFS_INODES_PER_BLOCK	8

/* SVR4 vnode type values (bfs_inode->i_vtype) */
#define BFS_VDIR 2L
#define BFS_VREG 1L

/* BFS inode layout on disk */
struct bfs_inode {
	__le16 i_ino;
	__u16 i_unused;
	__le32 i_sblock;
	__le32 i_eblock;
	__le32 i_eoffset;
	__le32 i_vtype;
	__le32 i_mode;
	__le32 i_uid;
	__le32 i_gid;
	__le32 i_nlink;
	__le32 i_atime;
	__le32 i_mtime;
	__le32 i_ctime;
	__u32 i_padding[4];
};

#define BFS_NAMELEN		14	
#define BFS_DIRENT_SIZE		16
#define BFS_DIRS_PER_BLOCK	32

struct bfs_dirent {
	__le16 ino;
	char name[BFS_NAMELEN];
};

/* BFS superblock layout on disk */
struct bfs_super_block {
	__le32 s_magic;
	__le32 s_start;
	__le32 s_end;
	__le32 s_from;
	__le32 s_to;
	__s32 s_bfrom;
	__s32 s_bto;
	char  s_fsname[6];
	char  s_volume[6];
	__u32 s_padding[118];
};


#define BFS_OFF2INO(offset) \
        ((((offset) - BFS_BSIZE) / sizeof(struct bfs_inode)) + BFS_ROOT_INO)

#define BFS_INO2OFF(ino) \
	((__u32)(((ino) - BFS_ROOT_INO) * sizeof(struct bfs_inode)) + BFS_BSIZE)
#define BFS_NZFILESIZE(ip) \
        ((le32_to_cpu((ip)->i_eoffset) + 1) -  le32_to_cpu((ip)->i_sblock) * BFS_BSIZE)

#define BFS_FILESIZE(ip) \
        ((ip)->i_sblock == 0 ? 0 : BFS_NZFILESIZE(ip))

#define BFS_FILEBLOCKS(ip) \
        ((ip)->i_sblock == 0 ? 0 : (le32_to_cpu((ip)->i_eblock) + 1) -  le32_to_cpu((ip)->i_sblock))
#define BFS_UNCLEAN(bfs_sb, sb)	\
	((le32_to_cpu(bfs_sb->s_from) != -1) && (le32_to_cpu(bfs_sb->s_to) != -1) && !(sb->s_flags & MS_RDONLY))


#endif	/* _LINUX_BFS_FS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef _LINUX_BINFMTS_H
#define _LINUX_BINFMTS_H

#include <linux/capability.h>

struct pt_regs;

/*
 * These are the maximum length and maximum number of strings passed to the
 * execve() system call.  MAX_ARG_STRLEN is essentially random but serves to
 * prevent the kernel from being unduly impacted by misaddressed pointers.
 * MAX_ARG_STRINGS is chosen to fit in a signed 32-bit integer.
 */
#define MAX_ARG_STRLEN (PAGE_SIZE * 32)
#define MAX_ARG_STRINGS 0x7FFFFFFF

/* sizeof(linux_binprm->buf) */
#define BINPRM_BUF_SIZE 128

#endif /* _LINUX_BINFMTS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #ifndef _LINUX_BLKPG_H
#define _LINUX_BLKPG_H

/*
 * Partition table and disk geometry handling
 *
 * A single ioctl with lots of subfunctions:
 *
 * Device number stuff:
 *    get_whole_disk()		(given the device number of a partition,
 *                               find the device number of the encompassing disk)
 *    get_all_partitions()	(given the device number of a disk, return the
 *				 device numbers of all its known partitions)
 *
 * Partition stuff:
 *    add_partition()
 *    delete_partition()
 *    test_partition_in_use()	(also for test_disk_in_use)
 *
 * Geometry stuff:
 *    get_geometry()
 *    set_geometry()
 *    get_bios_drivedata()
 *
 * For today, only the partition stuff - aeb, 990515
 */

#include <linux/ioctl.h>

#define BLKPG      _IO(0x12,105)

/* The argument structure */
struct blkpg_ioctl_arg {
        int op;
        int flags;
        int datalen;
        void *data;
};

/* The subfunctions (for the op field) */
#define BLKPG_ADD_PARTITION	1
#define BLKPG_DEL_PARTITION	2
#define BLKPG_RESIZE_PARTITION	3

/* Sizes of name fields. Unused at present. */
#define BLKPG_DEVNAMELTH	64
#define BLKPG_VOLNAMELTH	64

/* The data structure for ADD_PARTITION and DEL_PARTITION */
struct blkpg_partition {
	long long start;		/* starting offset in bytes */
	long long length;		/* length in bytes */
	int pno;			/* partition number */
	char devname[BLKPG_DEVNAMELTH];	/* partition name, like sda5 or c0d1p2,
					   to be used in kernel messages */
	char volname[BLKPG_VOLNAMELTH];	/* volume label */
};

#endif /* _LINUX_BLKPG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #ifndef BLKTRACE_H
#define BLKTRACE_H

#include <linux/types.h>

/*
 * Trace categories
 */
enum blktrace_cat {
	BLK_TC_READ	= 1 << 0,	/* reads */
	BLK_TC_WRITE	= 1 << 1,	/* writes */
	BLK_TC_FLUSH	= 1 << 2,	/* flush */
	BLK_TC_SYNC	= 1 << 3,	/* sync IO */
	BLK_TC_SYNCIO	= BLK_TC_SYNC,
	BLK_TC_QUEUE	= 1 << 4,	/* queueing/merging */
	BLK_TC_REQUEUE	= 1 << 5,	/* requeueing */
	BLK_TC_ISSUE	= 1 << 6,	/* issue */
	BLK_TC_COMPLETE	= 1 << 7,	/* completions */
	BLK_TC_FS	= 1 << 8,	/* fs requests */
	BLK_TC_PC	= 1 << 9,	/* pc requests */
	BLK_TC_NOTIFY	= 1 << 10,	/* special message */
	BLK_TC_AHEAD	= 1 << 11,	/* readahead */
	BLK_TC_META	= 1 << 12,	/* metadata */
	BLK_TC_DISCARD	= 1 << 13,	/* discard requests */
	BLK_TC_DRV_DATA	= 1 << 14,	/* binary per-driver data */
	BLK_TC_FUA	= 1 << 15,	/* fua requests */

	BLK_TC_END	= 1 << 15,	/* we've run out of bits! */
};

#define BLK_TC_SHIFT		(16)
#define BLK_TC_ACT(act)		((act) << BLK_TC_SHIFT)

/*
 * Basic trace actions
 */
enum blktrace_act {
	__BLK_TA_QUEUE = 1,		/* queued */
	__BLK_TA_BACKMERGE,		/* back merged to existing rq */
	__BLK_TA_FRONTMERGE,		/* front merge to existing rq */
	__BLK_TA_GETRQ,			/* allocated new request */
	__BLK_TA_SLEEPRQ,		/* sleeping on rq allocation */
	__BLK_TA_REQUEUE,		/* request requeued */
	__BLK_TA_ISSUE,			/* sent to driver */
	__BLK_TA_COMPLETE,		/* completed by driver */
	__BLK_TA_PLUG,			/* queue was plugged */
	__BLK_TA_UNPLUG_IO,		/* queue was unplugged by io */
	__BLK_TA_UNPLUG_TIMER,		/* queue was unplugged by timer */
	__BLK_TA_INSERT,		/* insert request */
	__BLK_TA_SPLIT,			/* bio was split */
	__BLK_TA_BOUNCE,		/* bio was bounced */
	__BLK_TA_REMAP,			/* bio was remapped */
	__BLK_TA_ABORT,			/* request aborted */
	__BLK_TA_DRV_DATA,		/* driver-specific binary data */
};

/*
 * Notify events.
 */
enum blktrace_notify {
	__BLK_TN_PROCESS = 0,		/* establish pid/name mapping */
	__BLK_TN_TIMESTAMP,		/* include system clock */
	__BLK_TN_MESSAGE,		/* Character string message */
};


/*
 * Trace actions in full. Additionally, read or write is masked
 */
#define BLK_TA_QUEUE		(__BLK_TA_QUEUE | BLK_TC_ACT(BLK_TC_QUEUE))
#define BLK_TA_BACKMERGE	(__BLK_TA_BACKMERGE | BLK_TC_ACT(BLK_TC_QUEUE))
#define BLK_TA_FRONTMERGE	(__BLK_TA_FRONTMERGE | BLK_TC_ACT(BLK_TC_QUEUE))
#define	BLK_TA_GETRQ		(__BLK_TA_GETRQ | BLK_TC_ACT(BLK_TC_QUEUE))
#define	BLK_TA_SLEEPRQ		(__BLK_TA_SLEEPRQ | BLK_TC_ACT(BLK_TC_QUEUE))
#define	BLK_TA_REQUEUE		(__BLK_TA_REQUEUE | BLK_TC_ACT(BLK_TC_REQUEUE))
#define BLK_TA_ISSUE		(__BLK_TA_ISSUE | BLK_TC_ACT(BLK_TC_ISSUE))
#define BLK_TA_COMPLETE		(__BLK_TA_COMPLETE| BLK_TC_ACT(BLK_TC_COMPLETE))
#define BLK_TA_PLUG		(__BLK_TA_PLUG | BLK_TC_ACT(BLK_TC_QUEUE))
#define BLK_TA_UNPLUG_IO	(__BLK_TA_UNPLUG_IO | BLK_TC_ACT(BLK_TC_QUEUE))
#define BLK_TA_UNPLUG_TIMER	(__BLK_TA_UNPLUG_TIMER | BLK_TC_ACT(BLK_TC_QUEUE))
#define BLK_TA_INSERT		(__BLK_TA_INSERT | BLK_TC_ACT(BLK_TC_QUEUE))
#define BLK_TA_SPLIT		(__BLK_TA_SPLIT)
#define BLK_TA_BOUNCE		(__BLK_TA_BOUNCE)
#define BLK_TA_REMAP		(__BLK_TA_REMAP | BLK_TC_ACT(BLK_TC_QUEUE))
#define BLK_TA_ABORT		(__BLK_TA_ABORT | BLK_TC_ACT(BLK_TC_QUEUE))
#define BLK_TA_DRV_DATA	(__BLK_TA_DRV_DATA | BLK_TC_ACT(BLK_TC_DRV_DATA))

#define BLK_TN_PROCESS		(__BLK_TN_PROCESS | BLK_TC_ACT(BLK_TC_NOTIFY))
#define BLK_TN_TIMESTAMP	(__BLK_TN_TIMESTAMP | BLK_TC_ACT(BLK_TC_NOTIFY))
#define BLK_TN_MESSAGE		(__BLK_TN_MESSAGE | BLK_TC_ACT(BLK_TC_NOTIFY))

#define BLK_IO_TRACE_MAGIC	0x65617400
#define BLK_IO_TRACE_VERSION	0x07

/*
 * The trace itself
 */
struct blk_io_trace {
	__u32 magic;		/* MAGIC << 8 | version */
	__u32 sequence;		/* event number */
	__u64 time;		/* in microseconds */
	__u64 sector;		/* disk offset */
	__u32 bytes;		/* transfer length */
	__u32 action;		/* what happened */
	__u32 pid;		/* who did it */
	__u32 device;		/* device number */
	__u32 cpu;		/* on what cpu did it happen */
	__u16 error;		/* completion error */
	__u16 pdu_len;		/* length of data after this trace */
};

/*
 * The remap event
 */
struct blk_io_trace_remap {
	__be32 device_from;
	__be32 device_to;
	__be64 sector_from;
};

enum {
	Blktrace_setup = 1,
	Blktrace_running,
	Blktrace_stopped,
};

#define BLKTRACE_BDEV_SIZE	32

/*
 * User setup structure passed with BLKTRACESTART
 */
struct blk_user_trace_setup {
	char name[BLKTRACE_BDEV_SIZE];	/* output */
	__u16 act_mask;			/* input */
	__u32 buf_size;			/* input */
	__u32 buf_nr;			/* input */
	__u64 start_lba;
	__u64 end_lba;
	__u32 pid;
};

#endif /* BLKTRACE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #ifndef	__BPQETHER_H
#define	__BPQETHER_H

/*
 * 	Defines for the BPQETHER pseudo device driver
 */

#ifndef __LINUX_IF_ETHER_H
#include <linux/if_ether.h>
#endif

#define SIOCSBPQETHOPT		(SIOCDEVPRIVATE+0)	/* reserved */
#define SIOCSBPQETHADDR		(SIOCDEVPRIVATE+1)
 
struct bpq_ethaddr {
	unsigned char destination[ETH_ALEN];
	unsigned char accept[ETH_ALEN];
};

/* 
 * For SIOCSBPQETHOPT - this is compatible with PI2/PacketTwin card drivers,
 * currently not implemented, though. If someone wants to hook a radio
 * to his Ethernet card he may find this useful. ;-)
 */

#define SIOCGBPQETHPARAM	0x5000  /* get Level 1 parameters */
#define SIOCSBPQETHPARAM	0x5001  /* set */

struct bpq_req  {
    int cmd;
    int speed;			/* unused */
    int clockmode;		/* unused */
    int txdelay;
    unsigned char persist;	/* unused */
    int slotime;		/* unused */
    int squeldelay;
    int dmachan;		/* unused */
    int irq;			/* unused */
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef BSG_H
#define BSG_H

#include <linux/types.h>

#define BSG_PROTOCOL_SCSI		0

#define BSG_SUB_PROTOCOL_SCSI_CMD	0
#define BSG_SUB_PROTOCOL_SCSI_TMF	1
#define BSG_SUB_PROTOCOL_SCSI_TRANSPORT	2

/*
 * For flags member below
 * sg.h sg_io_hdr also has bits defined for it's flags member. However
 * none of these bits are implemented/used by bsg. The bits below are
 * allocated to not conflict with sg.h ones anyway.
 */
#define BSG_FLAG_Q_AT_TAIL 0x10 /* default, == 0 at this bit, is Q_AT_HEAD */

struct sg_io_v4 {
	__s32 guard;		/* [i] 'Q' to differentiate from v3 */
	__u32 protocol;		/* [i] 0 -> SCSI , .... */
	__u32 subprotocol;	/* [i] 0 -> SCSI command, 1 -> SCSI task
				   management function, .... */

	__u32 request_len;	/* [i] in bytes */
	__u64 request;		/* [i], [*i] {SCSI: cdb} */
	__u64 request_tag;	/* [i] {SCSI: task tag (only if flagged)} */
	__u32 request_attr;	/* [i] {SCSI: task attribute} */
	__u32 request_priority;	/* [i] {SCSI: task priority} */
	__u32 request_extra;	/* [i] {spare, for padding} */
	__u32 max_response_len;	/* [i] in bytes */
	__u64 response;		/* [i], [*o] {SCSI: (auto)sense data} */

        /* "dout_": data out (to device); "din_": data in (from device) */
	__u32 dout_iovec_count;	/* [i] 0 -> "flat" dout transfer else
				   dout_xfer points to array of iovec */
	__u32 dout_xfer_len;	/* [i] bytes to be transferred to device */
	__u32 din_iovec_count;	/* [i] 0 -> "flat" din transfer */
	__u32 din_xfer_len;	/* [i] bytes to be transferred from device */
	__u64 dout_xferp;	/* [i], [*i] */
	__u64 din_xferp;	/* [i], [*o] */

	__u32 timeout;		/* [i] units: millisecond */
	__u32 flags;		/* [i] bit mask */
	__u64 usr_ptr;		/* [i->o] unused internally */
	__u32 spare_in;		/* [i] */

	__u32 driver_status;	/* [o] 0 -> ok */
	__u32 transport_status;	/* [o] 0 -> ok */
	__u32 device_status;	/* [o] {SCSI: command completion status} */
	__u32 retry_delay;	/* [o] {SCSI: status auxiliary information} */
	__u32 info;		/* [o] additional information */
	__u32 duration;		/* [o] time to complete, in milliseconds */
	__u32 response_len;	/* [o] bytes of response actually written */
	__s32 din_resid;	/* [o] din_xfer_len - actual_din_xfer_len */
	__s32 dout_resid;	/* [o] dout_xfer_len - actual_dout_xfer_len */
	__u64 generated_tag;	/* [o] {SCSI: transport generated task tag} */
	__u32 spare_out;	/* [o] */

	__u32 padding;
};


#endif /* BSG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Copyright (C) 2007 Oracle.  All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License v2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 021110-1307, USA.
 */

#ifndef _LINUX_BTRFS_H
#define _LINUX_BTRFS_H
#include <linux/types.h>
#include <linux/ioctl.h>

#define BTRFS_IOCTL_MAGIC 0x94
#define BTRFS_VOL_NAME_MAX 255

/* this should be 4k */
#define BTRFS_PATH_NAME_MAX 4087
struct btrfs_ioctl_vol_args {
	__s64 fd;
	char name[BTRFS_PATH_NAME_MAX + 1];
};

#define BTRFS_DEVICE_PATH_NAME_MAX 1024

#define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
#define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
#define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
#define BTRFS_FSID_SIZE 16
#define BTRFS_UUID_SIZE 16
#define BTRFS_UUID_UNPARSED_SIZE	37

#define BTRFS_QGROUP_INHERIT_SET_LIMITS	(1ULL << 0)

struct btrfs_qgroup_limit {
	__u64	flags;
	__u64	max_rfer;
	__u64	max_excl;
	__u64	rsv_rfer;
	__u64	rsv_excl;
};

struct btrfs_qgroup_inherit {
	__u64	flags;
	__u64	num_qgroups;
	__u64	num_ref_copies;
	__u64	num_excl_copies;
	struct btrfs_qgroup_limit lim;
	__u64	qgroups[0];
};

struct btrfs_ioctl_qgroup_limit_args {
	__u64	qgroupid;
	struct btrfs_qgroup_limit lim;
};

#define BTRFS_SUBVOL_NAME_MAX 4039
struct btrfs_ioctl_vol_args_v2 {
	__s64 fd;
	__u64 transid;
	__u64 flags;
	union {
		struct {
			__u64 size;
			struct btrfs_qgroup_inherit *qgroup_inherit;
		};
		__u64 unused[4];
	};
	char name[BTRFS_SUBVOL_NAME_MAX + 1];
};

/*
 * structure to report errors and progress to userspace, either as a
 * result of a finished scrub, a canceled scrub or a progress inquiry
 */
struct btrfs_scrub_progress {
	__u64 data_extents_scrubbed;	/* # of data extents scrubbed */
	__u64 tree_extents_scrubbed;	/* # of tree extents scrubbed */
	__u64 data_bytes_scrubbed;	/* # of data bytes scrubbed */
	__u64 tree_bytes_scrubbed;	/* # of tree bytes scrubbed */
	__u64 read_errors;		/* # of read errors encountered (EIO) */
	__u64 csum_errors;		/* # of failed csum checks */
	__u64 verify_errors;		/* # of occurences, where the metadata
					 * of a tree block did not match the
					 * expected values, like generation or
					 * logical */
	__u64 no_csum;			/* # of 4k data block for which no csum
					 * is present, probably the result of
					 * data written with nodatasum */
	__u64 csum_discards;		/* # of csum for which no data was found
					 * in the extent tree. */
	__u64 super_errors;		/* # of bad super blocks encountered */
	__u64 malloc_errors;		/* # of internal kmalloc errors. These
					 * will likely cause an incomplete
					 * scrub */
	__u64 uncorrectable_errors;	/* # of errors where either no intact
					 * copy was found or the writeback
					 * failed */
	__u64 corrected_errors;		/* # of errors corrected */
	__u64 last_physical;		/* last physical address scrubbed. In
					 * case a scrub was aborted, this can
					 * be used to restart the scrub */
	__u64 unverified_errors;	/* # of occurences where a read for a
					 * full (64k) bio failed, but the re-
					 * check succeeded for each 4k piece.
					 * Intermittent error. */
};

#define BTRFS_SCRUB_READONLY	1
struct btrfs_ioctl_scrub_args {
	__u64 devid;				/* in */
	__u64 start;				/* in */
	__u64 end;				/* in */
	__u64 flags;				/* in */
	struct btrfs_scrub_progress progress;	/* out */
	/* pad to 1k */
	__u64 unused[(1024-32-sizeof(struct btrfs_scrub_progress))/8];
};

#define BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS	0
#define BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID	1
struct btrfs_ioctl_dev_replace_start_params {
	__u64 srcdevid;	/* in, if 0, use srcdev_name instead */
	__u64 cont_reading_from_srcdev_mode;	/* in, see #define
						 * above */
	__u8 srcdev_name[BTRFS_DEVICE_PATH_NAME_MAX + 1];	/* in */
	__u8 tgtdev_name[BTRFS_DEVICE_PATH_NAME_MAX + 1];	/* in */
};

#define BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED	0
#define BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED		1
#define BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED		2
#define BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED		3
#define BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED		4
struct btrfs_ioctl_dev_replace_status_params {
	__u64 replace_state;	/* out, see #define above */
	__u64 progress_1000;	/* out, 0 <= x <= 1000 */
	__u64 time_started;	/* out, seconds since 1-Jan-1970 */
	__u64 time_stopped;	/* out, seconds since 1-Jan-1970 */
	__u64 num_write_errors;	/* out */
	__u64 num_uncorrectable_read_errors;	/* out */
};

#define BTRFS_IOCTL_DEV_REPLACE_CMD_START			0
#define BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS			1
#define BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL			2
#define BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR			0
#define BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED		1
#define BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED		2
struct btrfs_ioctl_dev_replace_args {
	__u64 cmd;	/* in */
	__u64 result;	/* out */

	union {
		struct btrfs_ioctl_dev_replace_start_params start;
		struct btrfs_ioctl_dev_replace_status_params status;
	};	/* in/out */

	__u64 spare[64];
};

struct btrfs_ioctl_dev_info_args {
	__u64 devid;				/* in/out */
	__u8 uuid[BTRFS_UUID_SIZE];		/* in/out */
	__u64 bytes_used;			/* out */
	__u64 total_bytes;			/* out */
	__u64 unused[379];			/* pad to 4k */
	__u8 path[BTRFS_DEVICE_PATH_NAME_MAX];	/* out */
};

struct btrfs_ioctl_fs_info_args {
	__u64 max_id;				/* out */
	__u64 num_devices;			/* out */
	__u8 fsid[BTRFS_FSID_SIZE];		/* out */
	__u32 nodesize;				/* out */
	__u32 sectorsize;			/* out */
	__u32 clone_alignment;			/* out */
	__u32 reserved32;
	__u64 reserved[122];			/* pad to 1k */
};

struct btrfs_ioctl_feature_flags {
	__u64 compat_flags;
	__u64 compat_ro_flags;
	__u64 incompat_flags;
};

/* balance control ioctl modes */
#define BTRFS_BALANCE_CTL_PAUSE		1
#define BTRFS_BALANCE_CTL_CANCEL	2

/*
 * this is packed, because it should be exactly the same as its disk
 * byte order counterpart (struct btrfs_disk_balance_args)
 */
struct btrfs_balance_args {
	__u64 profiles;
	__u64 usage;
	__u64 devid;
	__u64 pstart;
	__u64 pend;
	__u64 vstart;
	__u64 vend;

	__u64 target;

	__u64 flags;

	__u64 limit;		/* limit number of processed chunks */
	__u64 unused[7];
} __attribute__ ((__packed__));

/* report balance progress to userspace */
struct btrfs_balance_progress {
	__u64 expected;		/* estimated # of chunks that will be
				 * relocated to fulfill the request */
	__u64 considered;	/* # of chunks we have considered so far */
	__u64 completed;	/* # of chunks relocated so far */
};

#define BTRFS_BALANCE_STATE_RUNNING	(1ULL << 0)
#define BTRFS_BALANCE_STATE_PAUSE_REQ	(1ULL << 1)
#define BTRFS_BALANCE_STATE_CANCEL_REQ	(1ULL << 2)

struct btrfs_ioctl_balance_args {
	__u64 flags;				/* in/out */
	__u64 state;				/* out */

	struct btrfs_balance_args data;		/* in/out */
	struct btrfs_balance_args meta;		/* in/out */
	struct btrfs_balance_args sys;		/* in/out */

	struct btrfs_balance_progress stat;	/* out */

	__u64 unused[72];			/* pad to 1k */
};

#define BTRFS_INO_LOOKUP_PATH_MAX 4080
struct btrfs_ioctl_ino_lookup_args {
	__u64 treeid;
	__u64 objectid;
	char name[BTRFS_INO_LOOKUP_PATH_MAX];
};

struct btrfs_ioctl_search_key {
	/* which root are we searching.  0 is the tree of tree roots */
	__u64 tree_id;

	/* keys returned will be >= min and <= max */
	__u64 min_objectid;
	__u64 max_objectid;

	/* keys returned will be >= min and <= max */
	__u64 min_offset;
	__u64 max_offset;

	/* max and min transids to search for */
	__u64 min_transid;
	__u64 max_transid;

	/* keys returned will be >= min and <= max */
	__u32 min_type;
	__u32 max_type;

	/*
	 * how many items did userland ask for, and how many are we
	 * returning
	 */
	__u32 nr_items;

	/* align to 64 bits */
	__u32 unused;

	/* some extra for later */
	__u64 unused1;
	__u64 unused2;
	__u64 unused3;
	__u64 unused4;
};

struct btrfs_ioctl_search_header {
	__u64 transid;
	__u64 objectid;
	__u64 offset;
	__u32 type;
	__u32 len;
};

#define BTRFS_SEARCH_ARGS_BUFSIZE (4096 - sizeof(struct btrfs_ioctl_search_key))
/*
 * the buf is an array of search headers where
 * each header is followed by the actual item
 * the type field is expanded to 32 bits for alignment
 */
struct btrfs_ioctl_search_args {
	struct btrfs_ioctl_search_key key;
	char buf[BTRFS_SEARCH_ARGS_BUFSIZE];
};

struct btrfs_ioctl_search_args_v2 {
	struct btrfs_ioctl_search_key key; /* in/out - search parameters */
	__u64 buf_size;		   /* in - size of buffer
					    * out - on EOVERFLOW: needed size
					    *       to store item */
	__u64 buf[0];                       /* out - found items */
};

struct btrfs_ioctl_clone_range_args {
  __s64 src_fd;
  __u64 src_offset, src_length;
  __u64 dest_offset;
};

/* flags for the defrag range ioctl */
#define BTRFS_DEFRAG_RANGE_COMPRESS 1
#define BTRFS_DEFRAG_RANGE_START_IO 2

#define BTRFS_SAME_DATA_DIFFERS	1
/* For extent-same ioctl */
struct btrfs_ioctl_same_extent_info {
	__s64 fd;		/* in - destination file */
	__u64 logical_offset;	/* in - start of extent in destination */
	__u64 bytes_deduped;	/* out - total # of bytes we were able
				 * to dedupe from this file */
	/* status of this dedupe operation:
	 * 0 if dedup succeeds
	 * < 0 for error
	 * == BTRFS_SAME_DATA_DIFFERS if data differs
	 */
	__s32 status;		/* out - see above description */
	__u32 reserved;
};

struct btrfs_ioctl_same_args {
	__u64 logical_offset;	/* in - start of extent in source */
	__u64 length;		/* in - length of extent */
	__u16 dest_count;	/* in - total elements in info array */
	__u16 reserved1;
	__u32 reserved2;
	struct btrfs_ioctl_same_extent_info info[0];
};

struct btrfs_ioctl_space_info {
	__u64 flags;
	__u64 total_bytes;
	__u64 used_bytes;
};

struct btrfs_ioctl_space_args {
	__u64 space_slots;
	__u64 total_spaces;
	struct btrfs_ioctl_space_info spaces[0];
};

struct btrfs_data_container {
	__u32	bytes_left;	/* out -- bytes not needed to deliver output */
	__u32	bytes_missing;	/* out -- additional bytes needed for result */
	__u32	elem_cnt;	/* out */
	__u32	elem_missed;	/* out */
	__u64	val[0];		/* out */
};

struct btrfs_ioctl_ino_path_args {
	__u64				inum;		/* in */
	__u64				size;		/* in */
	__u64				reserved[4];
	/* struct btrfs_data_container	*fspath;	   out */
	__u64				fspath;		/* out */
};

struct btrfs_ioctl_logical_ino_args {
	__u64				logical;	/* in */
	__u64				size;		/* in */
	__u64				reserved[4];
	/* struct btrfs_data_container	*inodes;	out   */
	__u64				inodes;
};

enum btrfs_dev_stat_values {
	/* disk I/O failure stats */
	BTRFS_DEV_STAT_WRITE_ERRS, /* EIO or EREMOTEIO from lower layers */
	BTRFS_DEV_STAT_READ_ERRS, /* EIO or EREMOTEIO from lower layers */
	BTRFS_DEV_STAT_FLUSH_ERRS, /* EIO or EREMOTEIO from lower layers */

	/* stats for indirect indications for I/O failures */
	BTRFS_DEV_STAT_CORRUPTION_ERRS, /* checksum error, bytenr error or
					 * contents is illegal: this is an
					 * indication that the block was damaged
					 * during read or write, or written to
					 * wrong location or read from wrong
					 * location */
	BTRFS_DEV_STAT_GENERATION_ERRS, /* an indication that blocks have not
					 * been written */

	BTRFS_DEV_STAT_VALUES_MAX
};

/* Reset statistics after reading; needs SYS_ADMIN capability */
#define	BTRFS_DEV_STATS_RESET		(1ULL << 0)

struct btrfs_ioctl_get_dev_stats {
	__u64 devid;				/* in */
	__u64 nr_items;				/* in/out */
	__u64 flags;				/* in/out */

	/* out values: */
	__u64 values[BTRFS_DEV_STAT_VALUES_MAX];

	__u64 unused[128 - 2 - BTRFS_DEV_STAT_VALUES_MAX]; /* pad to 1k */
};

#define BTRFS_QUOTA_CTL_ENABLE	1
#define BTRFS_QUOTA_CTL_DISABLE	2
#define BTRFS_QUOTA_CTL_RESCAN__NOTUSED	3
struct btrfs_ioctl_quota_ctl_args {
	__u64 cmd;
	__u64 status;
};

struct btrfs_ioctl_quota_rescan_args {
	__u64	flags;
	__u64   progress;
	__u64   reserved[6];
};

struct btrfs_ioctl_qgroup_assign_args {
	__u64 assign;
	__u64 src;
	__u64 dst;
};

struct btrfs_ioctl_qgroup_create_args {
	__u64 create;
	__u64 qgroupid;
};
struct btrfs_ioctl_timespec {
	__u64 sec;
	__u32 nsec;
};

struct btrfs_ioctl_received_subvol_args {
	char	uuid[BTRFS_UUID_SIZE];	/* in */
	__u64	stransid;		/* in */
	__u64	rtransid;		/* out */
	struct btrfs_ioctl_timespec stime; /* in */
	struct btrfs_ioctl_timespec rtime; /* out */
	__u64	flags;			/* in */
	__u64	reserved[16];		/* in */
};

/*
 * Caller doesn't want file data in the send stream, even if the
 * search of clone sources doesn't find an extent. UPDATE_EXTENT
 * commands will be sent instead of WRITE commands.
 */
#define BTRFS_SEND_FLAG_NO_FILE_DATA		0x1

/*
 * Do not add the leading stream header. Used when multiple snapshots
 * are sent back to back.
 */
#define BTRFS_SEND_FLAG_OMIT_STREAM_HEADER	0x2

/*
 * Omit the command at the end of the stream that indicated the end
 * of the stream. This option is used when multiple snapshots are
 * sent back to back.
 */
#define BTRFS_SEND_FLAG_OMIT_END_CMD		0x4

#define BTRFS_SEND_FLAG_MASK \
	(BTRFS_SEND_FLAG_NO_FILE_DATA | \
	 BTRFS_SEND_FLAG_OMIT_STREAM_HEADER | \
	 BTRFS_SEND_FLAG_OMIT_END_CMD)

struct btrfs_ioctl_send_args {
	__s64 send_fd;			/* in */
	__u64 clone_sources_count;	/* in */
	__u64 *clone_sources;	/* in */
	__u64 parent_root;		/* in */
	__u64 flags;			/* in */
	__u64 reserved[4];		/* in */
};

/* Error codes as returned by the kernel */
enum btrfs_err_code {
	notused,
	BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET,
	BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET,
	BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET,
	BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET,
	BTRFS_ERROR_DEV_TGT_REPLACE,
	BTRFS_ERROR_DEV_MISSING_NOT_FOUND,
	BTRFS_ERROR_DEV_ONLY_WRITABLE,
	BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS
};
/* An error code to error string mapping for the kernel
*  error codes
*/
static __inline__ char *btrfs_err_str(enum btrfs_err_code err_code)
{
	switch (err_code) {
		case BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET:
			return "unable to go below two devices on raid1";
		case BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET:
			return "unable to go below four devices on raid10";
		case BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET:
			return "unable to go below two devices on raid5";
		case BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET:
			return "unable to go below three devices on raid6";
		case BTRFS_ERROR_DEV_TGT_REPLACE:
			return "unable to remove the dev_replace target dev";
		case BTRFS_ERROR_DEV_MISSING_NOT_FOUND:
			return "no missing devices found to remove";
		case BTRFS_ERROR_DEV_ONLY_WRITABLE:
			return "unable to remove the only writeable device";
		case BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS:
			return "add/delete/balance/replace/resize operation "\
				"in progress";
		default:
			return NULL;
	}
}

#define BTRFS_IOC_SNAP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 1, \
				   struct btrfs_ioctl_vol_args)
#define BTRFS_IOC_DEFRAG _IOW(BTRFS_IOCTL_MAGIC, 2, \
				   struct btrfs_ioctl_vol_args)
#define BTRFS_IOC_RESIZE _IOW(BTRFS_IOCTL_MAGIC, 3, \
				   struct btrfs_ioctl_vol_args)
#define BTRFS_IOC_SCAN_DEV _IOW(BTRFS_IOCTL_MAGIC, 4, \
				   struct btrfs_ioctl_vol_args)
/* trans start and trans end are dangerous, and only for
 * use by applications that know how to avoid the
 * resulting deadlocks
 */
#define BTRFS_IOC_TRANS_START  _IO(BTRFS_IOCTL_MAGIC, 6)
#define BTRFS_IOC_TRANS_END    _IO(BTRFS_IOCTL_MAGIC, 7)
#define BTRFS_IOC_SYNC         _IO(BTRFS_IOCTL_MAGIC, 8)

#define BTRFS_IOC_CLONE        _IOW(BTRFS_IOCTL_MAGIC, 9, int)
#define BTRFS_IOC_ADD_DEV _IOW(BTRFS_IOCTL_MAGIC, 10, \
				   struct btrfs_ioctl_vol_args)
#define BTRFS_IOC_RM_DEV _IOW(BTRFS_IOCTL_MAGIC, 11, \
				   struct btrfs_ioctl_vol_args)
#define BTRFS_IOC_BALANCE _IOW(BTRFS_IOCTL_MAGIC, 12, \
				   struct btrfs_ioctl_vol_args)

#define BTRFS_IOC_CLONE_RANGE _IOW(BTRFS_IOCTL_MAGIC, 13, \
				  struct btrfs_ioctl_clone_range_args)

#define BTRFS_IOC_SUBVOL_CREATE _IOW(BTRFS_IOCTL_MAGIC, 14, \
				   struct btrfs_ioctl_vol_args)
#define BTRFS_IOC_SNAP_DESTROY _IOW(BTRFS_IOCTL_MAGIC, 15, \
				struct btrfs_ioctl_vol_args)
#define BTRFS_IOC_DEFRAG_RANGE _IOW(BTRFS_IOCTL_MAGIC, 16, \
				struct btrfs_ioctl_defrag_range_args)
#define BTRFS_IOC_TREE_SEARCH _IOWR(BTRFS_IOCTL_MAGIC, 17, \
				   struct btrfs_ioctl_search_args)
#define BTRFS_IOC_TREE_SEARCH_V2 _IOWR(BTRFS_IOCTL_MAGIC, 17, \
					   struct btrfs_ioctl_search_args_v2)
#define BTRFS_IOC_INO_LOOKUP _IOWR(BTRFS_IOCTL_MAGIC, 18, \
				   struct btrfs_ioctl_ino_lookup_args)
#define BTRFS_IOC_DEFAULT_SUBVOL _IOW(BTRFS_IOCTL_MAGIC, 19, __u64)
#define BTRFS_IOC_SPACE_INFO _IOWR(BTRFS_IOCTL_MAGIC, 20, \
				    struct btrfs_ioctl_space_args)
#define BTRFS_IOC_START_SYNC _IOR(BTRFS_IOCTL_MAGIC, 24, __u64)
#define BTRFS_IOC_WAIT_SYNC  _IOW(BTRFS_IOCTL_MAGIC, 22, __u64)
#define BTRFS_IOC_SNAP_CREATE_V2 _IOW(BTRFS_IOCTL_MAGIC, 23, \
				   struct btrfs_ioctl_vol_args_v2)
#define BTRFS_IOC_SUBVOL_CREATE_V2 _IOW(BTRFS_IOCTL_MAGIC, 24, \
				   struct btrfs_ioctl_vol_args_v2)
#define BTRFS_IOC_SUBVOL_GETFLAGS _IOR(BTRFS_IOCTL_MAGIC, 25, __u64)
#define BTRFS_IOC_SUBVOL_SETFLAGS _IOW(BTRFS_IOCTL_MAGIC, 26, __u64)
#define BTRFS_IOC_SCRUB _IOWR(BTRFS_IOCTL_MAGIC, 27, \
			      struct btrfs_ioctl_scrub_args)
#define BTRFS_IOC_SCRUB_CANCEL _IO(BTRFS_IOCTL_MAGIC, 28)
#define BTRFS_IOC_SCRUB_PROGRESS _IOWR(BTRFS_IOCTL_MAGIC, 29, \
				       struct btrfs_ioctl_scrub_args)
#define BTRFS_IOC_DEV_INFO _IOWR(BTRFS_IOCTL_MAGIC, 30, \
				 struct btrfs_ioctl_dev_info_args)
#define BTRFS_IOC_FS_INFO _IOR(BTRFS_IOCTL_MAGIC, 31, \
			       struct btrfs_ioctl_fs_info_args)
#define BTRFS_IOC_BALANCE_V2 _IOWR(BTRFS_IOCTL_MAGIC, 32, \
				   struct btrfs_ioctl_balance_args)
#define BTRFS_IOC_BALANCE_CTL _IOW(BTRFS_IOCTL_MAGIC, 33, int)
#define BTRFS_IOC_BALANCE_PROGRESS _IOR(BTRFS_IOCTL_MAGIC, 34, \
					struct btrfs_ioctl_balance_args)
#define BTRFS_IOC_INO_PATHS _IOWR(BTRFS_IOCTL_MAGIC, 35, \
					struct btrfs_ioctl_ino_path_args)
#define BTRFS_IOC_LOGICAL_INO _IOWR(BTRFS_IOCTL_MAGIC, 36, \
					struct btrfs_ioctl_ino_path_args)
#define BTRFS_IOC_SET_RECEIVED_SUBVOL _IOWR(BTRFS_IOCTL_MAGIC, 37, \
				struct btrfs_ioctl_received_subvol_args)
#define BTRFS_IOC_SEND _IOW(BTRFS_IOCTL_MAGIC, 38, struct btrfs_ioctl_send_args)
#define BTRFS_IOC_DEVICES_READY _IOR(BTRFS_IOCTL_MAGIC, 39, \
				     struct btrfs_ioctl_vol_args)
#define BTRFS_IOC_QUOTA_CTL _IOWR(BTRFS_IOCTL_MAGIC, 40, \
			       struct btrfs_ioctl_quota_ctl_args)
#define BTRFS_IOC_QGROUP_ASSIGN _IOW(BTRFS_IOCTL_MAGIC, 41, \
			       struct btrfs_ioctl_qgroup_assign_args)
#define BTRFS_IOC_QGROUP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 42, \
			       struct btrfs_ioctl_qgroup_create_args)
#define BTRFS_IOC_QGROUP_LIMIT _IOR(BTRFS_IOCTL_MAGIC, 43, \
			       struct btrfs_ioctl_qgroup_limit_args)
#define BTRFS_IOC_QUOTA_RESCAN _IOW(BTRFS_IOCTL_MAGIC, 44, \
			       struct btrfs_ioctl_quota_rescan_args)
#define BTRFS_IOC_QUOTA_RESCAN_STATUS _IOR(BTRFS_IOCTL_MAGIC, 45, \
			       struct btrfs_ioctl_quota_rescan_args)
#define BTRFS_IOC_QUOTA_RESCAN_WAIT _IO(BTRFS_IOCTL_MAGIC, 46)
#define BTRFS_IOC_GET_FSLABEL _IOR(BTRFS_IOCTL_MAGIC, 49, \
				   char[BTRFS_LABEL_SIZE])
#define BTRFS_IOC_SET_FSLABEL _IOW(BTRFS_IOCTL_MAGIC, 50, \
				   char[BTRFS_LABEL_SIZE])
#define BTRFS_IOC_GET_DEV_STATS _IOWR(BTRFS_IOCTL_MAGIC, 52, \
				      struct btrfs_ioctl_get_dev_stats)
#define BTRFS_IOC_DEV_REPLACE _IOWR(BTRFS_IOCTL_MAGIC, 53, \
				    struct btrfs_ioctl_dev_replace_args)
#define BTRFS_IOC_FILE_EXTENT_SAME _IOWR(BTRFS_IOCTL_MAGIC, 54, \
					 struct btrfs_ioctl_same_args)
#define BTRFS_IOC_GET_FEATURES _IOR(BTRFS_IOCTL_MAGIC, 57, \
				   struct btrfs_ioctl_feature_flags)
#define BTRFS_IOC_SET_FEATURES _IOW(BTRFS_IOCTL_MAGIC, 57, \
				   struct btrfs_ioctl_feature_flags[2])
#define BTRFS_IOC_GET_SUPPORTED_FEATURES _IOR(BTRFS_IOCTL_MAGIC, 57, \
				   struct btrfs_ioctl_feature_flags[3])

#endif /* _LINUX_BTRFS_H */
                                                                                                                                                                                                                                                                                                                                                /* $Id: capi.h,v 1.4.6.1 2001/09/23 22:25:05 kai Exp $
 * 
 * CAPI 2.0 Interface for Linux
 * 
 * Copyright 1997 by Carsten Paeth (calle@calle.in-berlin.de)
 * 
 * This software may be used and distributed according to the terms
 * of the GNU General Public License, incorporated herein by reference.
 *
 */

#ifndef __LINUX_CAPI_H__
#define __LINUX_CAPI_H__

#include <linux/types.h>
#include <linux/ioctl.h>
#include <linux/kernelcapi.h>

/*
 * CAPI_REGISTER
 */

typedef struct capi_register_params {	/* CAPI_REGISTER */
	__u32 level3cnt;	/* No. of simulatneous user data connections */
	__u32 datablkcnt;	/* No. of buffered data messages */
	__u32 datablklen;	/* Size of buffered data messages */
} capi_register_params;

#define	CAPI_REGISTER	_IOW('C',0x01,struct capi_register_params)

/*
 * CAPI_GET_MANUFACTURER
 */

#define CAPI_MANUFACTURER_LEN		64

#define	CAPI_GET_MANUFACTURER	_IOWR('C',0x06,int)	/* broken: wanted size 64 (CAPI_MANUFACTURER_LEN) */

/*
 * CAPI_GET_VERSION
 */

typedef struct capi_version {
	__u32 majorversion;
	__u32 minorversion;
	__u32 majormanuversion;
	__u32 minormanuversion;
} capi_version;

#define CAPI_GET_VERSION	_IOWR('C',0x07,struct capi_version)

/*
 * CAPI_GET_SERIAL
 */

#define CAPI_SERIAL_LEN		8
#define CAPI_GET_SERIAL		_IOWR('C',0x08,int)	/* broken: wanted size 8 (CAPI_SERIAL_LEN) */

/*
 * CAPI_GET_PROFILE
 */

typedef struct capi_profile {
	__u16 ncontroller;	/* number of installed controller */
	__u16 nbchannel;	/* number of B-Channels */
	__u32 goptions;		/* global options */
	__u32 support1;		/* B1 protocols support */
	__u32 support2;		/* B2 protocols support */
	__u32 support3;		/* B3 protocols support */
	__u32 reserved[6];	/* reserved */
	__u32 manu[5];		/* manufacturer specific information */
} capi_profile;

#define CAPI_GET_PROFILE	_IOWR('C',0x09,struct capi_profile)

typedef struct capi_manufacturer_cmd {
	unsigned long cmd;
	void *data;
} capi_manufacturer_cmd;

/*
 * CAPI_MANUFACTURER_CMD
 */

#define CAPI_MANUFACTURER_CMD	_IOWR('C',0x20, struct capi_manufacturer_cmd)

/*
 * CAPI_GET_ERRCODE
 * capi errcode is set, * if read, write, or ioctl returns EIO,
 * ioctl returns errcode directly, and in arg, if != 0
 */

#define CAPI_GET_ERRCODE	_IOR('C',0x21, __u16)

/*
 * CAPI_INSTALLED
 */
#define CAPI_INSTALLED		_IOR('C',0x22, __u16)


/*
 * member contr is input for
 * CAPI_GET_MANUFACTURER, CAPI_GET_VERSION, CAPI_GET_SERIAL
 * and CAPI_GET_PROFILE
 */
typedef union capi_ioctl_struct {
	__u32 contr;
	capi_register_params rparams;
	__u8 manufacturer[CAPI_MANUFACTURER_LEN];
	capi_version version;
	__u8 serial[CAPI_SERIAL_LEN];
	capi_profile profile;
	capi_manufacturer_cmd cmd;
	__u16 errcode;
} capi_ioctl_struct;

/*
 * Middleware extension
 */

#define CAPIFLAG_HIGHJACKING	0x0001

#define CAPI_GET_FLAGS		_IOR('C',0x23, unsigned)
#define CAPI_SET_FLAGS		_IOR('C',0x24, unsigned)
#define CAPI_CLR_FLAGS		_IOR('C',0x25, unsigned)

#define CAPI_NCCI_OPENCOUNT	_IOR('C',0x26, unsigned)

#define CAPI_NCCI_GETUNIT	_IOR('C',0x27, unsigned)

#endif				/* __LINUX_CAPI_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * linux/can.h
 *
 * Definitions for CAN network layer (socket addr / CAN frame / CAN filter)
 *
 * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
 *          Urs Thuermann   <urs.thuermann@volkswagen.de>
 * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of Volkswagen nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * Alternatively, provided that this notice is retained in full, this
 * software may be distributed under the terms of the GNU General
 * Public License ("GPL") version 2, in which case the provisions of the
 * GPL apply INSTEAD OF those given above.
 *
 * The provided data structures and external interfaces from this code
 * are not restricted to be used by modules with a GPL compatible license.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

#ifndef _CAN_H
#define _CAN_H

#include <linux/types.h>
#include <linux/socket.h>

/* controller area network (CAN) kernel definitions */

/* special address description flags for the CAN_ID */
#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */
#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */
#define CAN_ERR_FLAG 0x20000000U /* error message frame */

/* valid bits in CAN ID for frame formats */
#define CAN_SFF_MASK 0x000007FFU /* standard frame format (SFF) */
#define CAN_EFF_MASK 0x1FFFFFFFU /* extended frame format (EFF) */
#define CAN_ERR_MASK 0x1FFFFFFFU /* omit EFF, RTR, ERR flags */

/*
 * Controller Area Network Identifier structure
 *
 * bit 0-28	: CAN identifier (11/29 bit)
 * bit 29	: error message frame flag (0 = data frame, 1 = error message)
 * bit 30	: remote transmission request flag (1 = rtr frame)
 * bit 31	: frame format flag (0 = standard 11 bit, 1 = extended 29 bit)
 */
typedef __u32 canid_t;

#define CAN_SFF_ID_BITS		11
#define CAN_EFF_ID_BITS		29

/*
 * Controller Area Network Error Message Frame Mask structure
 *
 * bit 0-28	: error class mask (see include/linux/can/error.h)
 * bit 29-31	: set to zero
 */
typedef __u32 can_err_mask_t;

/* CAN payload length and DLC definitions according to ISO 11898-1 */
#define CAN_MAX_DLC 8
#define CAN_MAX_DLEN 8

/* CAN FD payload length and DLC definitions according to ISO 11898-7 */
#define CANFD_MAX_DLC 15
#define CANFD_MAX_DLEN 64

/**
 * struct can_frame - basic CAN frame structure
 * @can_id:  CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
 * @can_dlc: frame payload length in byte (0 .. 8) aka data length code
 *           N.B. the DLC field from ISO 11898-1 Chapter 8.4.2.3 has a 1:1
 *           mapping of the 'data length code' to the real payload length
 * @data:    CAN frame payload (up to 8 byte)
 */
struct can_frame {
	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
	__u8    can_dlc; /* frame payload length in byte (0 .. CAN_MAX_DLEN) */
	__u8    data[CAN_MAX_DLEN] __attribute__((aligned(8)));
};

/*
 * defined bits for canfd_frame.flags
 *
 * The use of struct canfd_frame implies the Extended Data Length (EDL) bit to
 * be set in the CAN frame bitstream on the wire. The EDL bit switch turns
 * the CAN controllers bitstream processor into the CAN FD mode which creates
 * two new options within the CAN FD frame specification:
 *
 * Bit Rate Switch - to indicate a second bitrate is/was used for the payload
 * Error State Indicator - represents the error state of the transmitting node
 *
 * As the CANFD_ESI bit is internally generated by the transmitting CAN
 * controller only the CANFD_BRS bit is relevant for real CAN controllers when
 * building a CAN FD frame for transmission. Setting the CANFD_ESI bit can make
 * sense for virtual CAN interfaces to test applications with echoed frames.
 */
#define CANFD_BRS 0x01 /* bit rate switch (second bitrate for payload data) */
#define CANFD_ESI 0x02 /* error state indicator of the transmitting node */

/**
 * struct canfd_frame - CAN flexible data rate frame structure
 * @can_id: CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
 * @len:    frame payload length in byte (0 .. CANFD_MAX_DLEN)
 * @flags:  additional flags for CAN FD
 * @__res0: reserved / padding
 * @__res1: reserved / padding
 * @data:   CAN FD frame payload (up to CANFD_MAX_DLEN byte)
 */
struct canfd_frame {
	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
	__u8    len;     /* frame payload length in byte */
	__u8    flags;   /* additional flags for CAN FD */
	__u8    __res0;  /* reserved / padding */
	__u8    __res1;  /* reserved / padding */
	__u8    data[CANFD_MAX_DLEN] __attribute__((aligned(8)));
};

#define CAN_MTU		(sizeof(struct can_frame))
#define CANFD_MTU	(sizeof(struct canfd_frame))

/* particular protocols of the protocol family PF_CAN */
#define CAN_RAW		1 /* RAW sockets */
#define CAN_BCM		2 /* Broadcast Manager */
#define CAN_TP16	3 /* VAG Transport Protocol v1.6 */
#define CAN_TP20	4 /* VAG Transport Protocol v2.0 */
#define CAN_MCNET	5 /* Bosch MCNet */
#define CAN_ISOTP	6 /* ISO 15765-2 Transport Protocol */
#define CAN_NPROTO	7

#define SOL_CAN_BASE 100

/**
 * struct sockaddr_can - the sockaddr structure for CAN sockets
 * @can_family:  address family number AF_CAN.
 * @can_ifindex: CAN network interface index.
 * @can_addr:    protocol specific address information
 */
struct sockaddr_can {
	__kernel_sa_family_t can_family;
	int         can_ifindex;
	union {
		/* transport protocol class address information (e.g. ISOTP) */
		struct { canid_t rx_id, tx_id; } tp;

		/* reserved for future CAN protocols address information */
	} can_addr;
};

/**
 * struct can_filter - CAN ID based filter in can_register().
 * @can_id:   relevant bits of CAN ID which are not masked out.
 * @can_mask: CAN mask (see description)
 *
 * Description:
 * A filter matches, when
 *
 *          <received_can_id> & mask == can_id & mask
 *
 * The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
 * filter for error message frames (CAN_ERR_FLAG bit set in mask).
 */
struct can_filter {
	canid_t can_id;
	canid_t can_mask;
};

#define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */

#endif /* !_UAPI_CAN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * This is <linux/capability.h>
 *
 * Andrew G. Morgan <morgan@kernel.org>
 * Alexander Kjeldaas <astor@guardian.no>
 * with help from Aleph1, Roland Buresund and Andrew Main.
 *
 * See here for the libcap library ("POSIX draft" compliance):
 *
 * ftp://www.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.6/
 */

#ifndef _LINUX_CAPABILITY_H
#define _LINUX_CAPABILITY_H

#include <linux/types.h>

struct task_struct;

/* User-level do most of the mapping between kernel and user
   capabilities based on the version tag given by the kernel. The
   kernel might be somewhat backwards compatible, but don't bet on
   it. */

/* Note, cap_t, is defined by POSIX (draft) to be an "opaque" pointer to
   a set of three capability sets.  The transposition of 3*the
   following structure to such a composite is better handled in a user
   library since the draft standard requires the use of malloc/free
   etc.. */

#define _LINUX_CAPABILITY_VERSION_1  0x19980330
#define _LINUX_CAPABILITY_U32S_1     1

#define _LINUX_CAPABILITY_VERSION_2  0x20071026  /* deprecated - use v3 */
#define _LINUX_CAPABILITY_U32S_2     2

#define _LINUX_CAPABILITY_VERSION_3  0x20080522
#define _LINUX_CAPABILITY_U32S_3     2

typedef struct __user_cap_header_struct {
	__u32 version;
	int pid;
} *cap_user_header_t;

typedef struct __user_cap_data_struct {
        __u32 effective;
        __u32 permitted;
        __u32 inheritable;
} *cap_user_data_t;


#define VFS_CAP_REVISION_MASK	0xFF000000
#define VFS_CAP_REVISION_SHIFT	24
#define VFS_CAP_FLAGS_MASK	~VFS_CAP_REVISION_MASK
#define VFS_CAP_FLAGS_EFFECTIVE	0x000001

#define VFS_CAP_REVISION_1	0x01000000
#define VFS_CAP_U32_1           1
#define XATTR_CAPS_SZ_1         (sizeof(__le32)*(1 + 2*VFS_CAP_U32_1))

#define VFS_CAP_REVISION_2	0x02000000
#define VFS_CAP_U32_2           2
#define XATTR_CAPS_SZ_2         (sizeof(__le32)*(1 + 2*VFS_CAP_U32_2))

#define XATTR_CAPS_SZ           XATTR_CAPS_SZ_2
#define VFS_CAP_U32             VFS_CAP_U32_2
#define VFS_CAP_REVISION	VFS_CAP_REVISION_2

struct vfs_cap_data {
	__le32 magic_etc;            /* Little endian */
	struct {
		__le32 permitted;    /* Little endian */
		__le32 inheritable;  /* Little endian */
	} data[VFS_CAP_U32];
};


/*
 * Backwardly compatible definition for source code - trapped in a
 * 32-bit world. If you find you need this, please consider using
 * libcap to untrap yourself...
 */
#define _LINUX_CAPABILITY_VERSION  _LINUX_CAPABILITY_VERSION_1
#define _LINUX_CAPABILITY_U32S     _LINUX_CAPABILITY_U32S_1



/**
 ** POSIX-draft defined capabilities.
 **/

/* In a system with the [_POSIX_CHOWN_RESTRICTED] option defined, this
   overrides the restriction of changing file ownership and group
   ownership. */

#define CAP_CHOWN            0

/* Override all DAC access, including ACL execute access if
   [_POSIX_ACL] is defined. Excluding DAC access covered by
   CAP_LINUX_IMMUTABLE. */

#define CAP_DAC_OVERRIDE     1

/* Overrides all DAC restrictions regarding read and search on files
   and directories, including ACL restrictions if [_POSIX_ACL] is
   defined. Excluding DAC access covered by CAP_LINUX_IMMUTABLE. */

#define CAP_DAC_READ_SEARCH  2

/* Overrides all restrictions about allowed operations on files, where
   file owner ID must be equal to the user ID, except where CAP_FSETID
   is applicable. It doesn't override MAC and DAC restrictions. */

#define CAP_FOWNER           3

/* Overrides the following restrictions that the effective user ID
   shall match the file owner ID when setting the S_ISUID and S_ISGID
   bits on that file; that the effective group ID (or one of the
   supplementary group IDs) shall match the file owner ID when setting
   the S_ISGID bit on that file; that the S_ISUID and S_ISGID bits are
   cleared on successful return from chown(2) (not implemented). */

#define CAP_FSETID           4

/* Overrides the restriction that the real or effective user ID of a
   process sending a signal must match the real or effective user ID
   of the process receiving the signal. */

#define CAP_KILL             5

/* Allows setgid(2) manipulation */
/* Allows setgroups(2) */
/* Allows forged gids on socket credentials passing. */

#define CAP_SETGID           6

/* Allows set*uid(2) manipulation (including fsuid). */
/* Allows forged pids on socket credentials passing. */

#define CAP_SETUID           7


/**
 ** Linux-specific capabilities
 **/

/* Without VFS support for capabilities:
 *   Transfer any capability in your permitted set to any pid,
 *   remove any capability in your permitted set from any pid
 * With VFS support for capabilities (neither of above, but)
 *   Add any capability from current's capability bounding set
 *       to the current process' inheritable set
 *   Allow taking bits out of capability bounding set
 *   Allow modification of the securebits for a process
 */

#define CAP_SETPCAP          8

/* Allow modification of S_IMMUTABLE and S_APPEND file attributes */

#define CAP_LINUX_IMMUTABLE  9

/* Allows binding to TCP/UDP sockets below 1024 */
/* Allows binding to ATM VCIs below 32 */

#define CAP_NET_BIND_SERVICE 10

/* Allow broadcasting, listen to multicast */

#define CAP_NET_BROADCAST    11

/* Allow interface configuration */
/* Allow administration of IP firewall, masquerading and accounting */
/* Allow setting debug option on sockets */
/* Allow modification of routing tables */
/* Allow setting arbitrary process / process group ownership on
   sockets */
/* Allow binding to any address for transparent proxying (also via NET_RAW) */
/* Allow setting TOS (type of service) */
/* Allow setting promiscuous mode */
/* Allow clearing driver statistics */
/* Allow multicasting */
/* Allow read/write of device-specific registers */
/* Allow activation of ATM control sockets */

#define CAP_NET_ADMIN        12

/* Allow use of RAW sockets */
/* Allow use of PACKET sockets */
/* Allow binding to any address for transparent proxying (also via NET_ADMIN) */

#define CAP_NET_RAW          13

/* Allow locking of shared memory segments */
/* Allow mlock and mlockall (which doesn't really have anything to do
   with IPC) */

#define CAP_IPC_LOCK         14

/* Override IPC ownership checks */

#define CAP_IPC_OWNER        15

/* Insert and remove kernel modules - modify kernel without limit */
#define CAP_SYS_MODULE       16

/* Allow ioperm/iopl access */
/* Allow sending USB messages to any device via /proc/bus/usb */

#define CAP_SYS_RAWIO        17

/* Allow use of chroot() */

#define CAP_SYS_CHROOT       18

/* Allow ptrace() of any process */

#define CAP_SYS_PTRACE       19

/* Allow configuration of process accounting */

#define CAP_SYS_PACCT        20

/* Allow configuration of the secure attention key */
/* Allow administration of the random device */
/* Allow examination and configuration of disk quotas */
/* Allow setting the domainname */
/* Allow setting the hostname */
/* Allow calling bdflush() */
/* Allow mount() and umount(), setting up new smb connection */
/* Allow some autofs root ioctls */
/* Allow nfsservctl */
/* Allow VM86_REQUEST_IRQ */
/* Allow to read/write pci config on alpha */
/* Allow irix_prctl on mips (setstacksize) */
/* Allow flushing all cache on m68k (sys_cacheflush) */
/* Allow removing semaphores */
/* Used instead of CAP_CHOWN to "chown" IPC message queues, semaphores
   and shared memory */
/* Allow locking/unlocking of shared memory segment */
/* Allow turning swap on/off */
/* Allow forged pids on socket credentials passing */
/* Allow setting readahead and flushing buffers on block devices */
/* Allow setting geometry in floppy driver */
/* Allow turning DMA on/off in xd driver */
/* Allow administration of md devices (mostly the above, but some
   extra ioctls) */
/* Allow tuning the ide driver */
/* Allow access to the nvram device */
/* Allow administration of apm_bios, serial and bttv (TV) device */
/* Allow manufacturer commands in isdn CAPI support driver */
/* Allow reading non-standardized portions of pci configuration space */
/* Allow DDI debug ioctl on sbpcd driver */
/* Allow setting up serial ports */
/* Allow sending raw qic-117 commands */
/* Allow enabling/disabling tagged queuing on SCSI controllers and sending
   arbitrary SCSI commands */
/* Allow setting encryption key on loopback filesystem */
/* Allow setting zone reclaim policy */

#define CAP_SYS_ADMIN        21

/* Allow use of reboot() */

#define CAP_SYS_BOOT         22

/* Allow raising priority and setting priority on other (different
   UID) processes */
/* Allow use of FIFO and round-robin (realtime) scheduling on own
   processes and setting the scheduling algorithm used by another
   process. */
/* Allow setting cpu affinity on other processes */

#define CAP_SYS_NICE         23

/* Override resource limits. Set resource limits. */
/* Override quota limits. */
/* Override reserved space on ext2 filesystem */
/* Modify data journaling mode on ext3 filesystem (uses journaling
   resources) */
/* NOTE: ext2 honors fsuid when checking for resource overrides, so
   you can override using fsuid too */
/* Override size restrictions on IPC message queues */
/* Allow more than 64hz interrupts from the real-time clock */
/* Override max number of consoles on console allocation */
/* Override max number of keymaps */

#define CAP_SYS_RESOURCE     24

/* Allow manipulation of system clock */
/* Allow irix_stime on mips */
/* Allow setting the real-time clock */

#define CAP_SYS_TIME         25

/* Allow configuration of tty devices */
/* Allow vhangup() of tty */

#define CAP_SYS_TTY_CONFIG   26

/* Allow the privileged aspects of mknod() */

#define CAP_MKNOD            27

/* Allow taking of leases on files */

#define CAP_LEASE            28

/* Allow writing the audit log via unicast netlink socket */

#define CAP_AUDIT_WRITE      29

/* Allow configuration of audit via unicast netlink socket */

#define CAP_AUDIT_CONTROL    30

#define CAP_SETFCAP	     31

/* Override MAC access.
   The base kernel enforces no MAC policy.
   An LSM may enforce a MAC policy, and if it does and it chooses
   to implement capability based overrides of that policy, this is
   the capability it should use to do so. */

#define CAP_MAC_OVERRIDE     32

/* Allow MAC configuration or state changes.
   The base kernel requires no MAC configuration.
   An LSM may enforce a MAC policy, and if it does and it chooses
   to implement capability based checks on modifications to that
   policy or the data required to maintain it, this is the
   capability it should use to do so. */

#define CAP_MAC_ADMIN        33

/* Allow configuring the kernel's syslog (printk behaviour) */

#define CAP_SYSLOG           34

/* Allow triggering something that will wake the system */

#define CAP_WAKE_ALARM            35

/* Allow preventing system suspends */

#define CAP_BLOCK_SUSPEND    36

/* Allow reading the audit log via multicast netlink socket */

#define CAP_AUDIT_READ		37


#define CAP_LAST_CAP         CAP_AUDIT_READ

#define cap_valid(x) ((x) >= 0 && (x) <= CAP_LAST_CAP)

/*
 * Bit location of each capability (used by user-space library and kernel)
 */

#define CAP_TO_INDEX(x)     ((x) >> 5)        /* 1 << 5 == bits in __u32 */
#define CAP_TO_MASK(x)      (1 << ((x) & 31)) /* mask for indexed __u32 */


#endif /* _LINUX_CAPABILITY_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #ifndef CCISS_DEFS_H
#define CCISS_DEFS_H

#include <linux/types.h>

/* general boundary definitions */
#define SENSEINFOBYTES          32 /* note that this value may vary
				      between host implementations */

/* Command Status value */
#define CMD_SUCCESS             0x0000
#define CMD_TARGET_STATUS       0x0001
#define CMD_DATA_UNDERRUN       0x0002
#define CMD_DATA_OVERRUN        0x0003
#define CMD_INVALID             0x0004
#define CMD_PROTOCOL_ERR        0x0005
#define CMD_HARDWARE_ERR        0x0006
#define CMD_CONNECTION_LOST     0x0007
#define CMD_ABORTED             0x0008
#define CMD_ABORT_FAILED        0x0009
#define CMD_UNSOLICITED_ABORT   0x000A
#define CMD_TIMEOUT             0x000B
#define CMD_UNABORTABLE		0x000C

/* transfer direction */
#define XFER_NONE               0x00
#define XFER_WRITE              0x01
#define XFER_READ               0x02
#define XFER_RSVD               0x03

/* task attribute */
#define ATTR_UNTAGGED           0x00
#define ATTR_SIMPLE             0x04
#define ATTR_HEADOFQUEUE        0x05
#define ATTR_ORDERED            0x06
#define ATTR_ACA                0x07

/* cdb type */
#define TYPE_CMD				0x00
#define TYPE_MSG				0x01

/* Type defs used in the following structs */
#define BYTE __u8
#define WORD __u16
#define HWORD __u16
#define DWORD __u32

#define CISS_MAX_LUN	1024

#define LEVEL2LUN   1 /* index into Target(x) structure, due to byte swapping */
#define LEVEL3LUN   0

#pragma pack(1)

/* Command List Structure */
typedef union _SCSI3Addr_struct {
   struct {
    BYTE Dev;
    BYTE Bus:6;
    BYTE Mode:2;        /* b00 */
  } PeripDev;
   struct {
    BYTE DevLSB;
    BYTE DevMSB:6;
    BYTE Mode:2;        /* b01 */
  } LogDev;
   struct {
    BYTE Dev:5;
    BYTE Bus:3;
    BYTE Targ:6;
    BYTE Mode:2;        /* b10 */
  } LogUnit;
} SCSI3Addr_struct;

typedef struct _PhysDevAddr_struct {
  DWORD             TargetId:24;
  DWORD             Bus:6;
  DWORD             Mode:2;
  SCSI3Addr_struct  Target[2]; /* 2 level target device addr */
} PhysDevAddr_struct;

typedef struct _LogDevAddr_struct {
  DWORD            VolId:30;
  DWORD            Mode:2;
  BYTE             reserved[4];
} LogDevAddr_struct;

typedef union _LUNAddr_struct {
  BYTE               LunAddrBytes[8];
  SCSI3Addr_struct   SCSI3Lun[4];
  PhysDevAddr_struct PhysDev;
  LogDevAddr_struct  LogDev;
} LUNAddr_struct;

typedef struct _RequestBlock_struct {
  BYTE   CDBLen;
  struct {
    BYTE Type:3;
    BYTE Attribute:3;
    BYTE Direction:2;
  } Type;
  HWORD  Timeout;
  BYTE   CDB[16];
} RequestBlock_struct;

typedef union _MoreErrInfo_struct{
  struct {
    BYTE  Reserved[3];
    BYTE  Type;
    DWORD ErrorInfo;
  } Common_Info;
  struct{
    BYTE  Reserved[2];
    BYTE  offense_size; /* size of offending entry */
    BYTE  offense_num;  /* byte # of offense 0-base */
    DWORD offense_value;
  } Invalid_Cmd;
} MoreErrInfo_struct;
typedef struct _ErrorInfo_struct {
  BYTE               ScsiStatus;
  BYTE               SenseLen;
  HWORD              CommandStatus;
  DWORD              ResidualCnt;
  MoreErrInfo_struct MoreErrInfo;
  BYTE               SenseInfo[SENSEINFOBYTES];
} ErrorInfo_struct;

#pragma pack()

#endif /* CCISS_DEFS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef CCISS_IOCTLH
#define CCISS_IOCTLH

#include <linux/types.h>
#include <linux/ioctl.h>
#include <linux/cciss_defs.h>

#define CCISS_IOC_MAGIC 'B'


typedef struct _cciss_pci_info_struct
{
	unsigned char 	bus;
	unsigned char 	dev_fn;
	unsigned short	domain;
	__u32 		board_id;
} cciss_pci_info_struct; 

typedef struct _cciss_coalint_struct
{
	__u32  delay;
	__u32  count;
} cciss_coalint_struct;

typedef char NodeName_type[16];

typedef __u32 Heartbeat_type;

#define CISS_PARSCSIU2 	0x0001
#define CISS_PARCSCIU3 	0x0002
#define CISS_FIBRE1G	0x0100
#define CISS_FIBRE2G	0x0200
typedef __u32 BusTypes_type;

typedef char FirmwareVer_type[4];
typedef __u32 DriverVer_type;

#define MAX_KMALLOC_SIZE 128000

typedef struct _IOCTL_Command_struct {
  LUNAddr_struct	   LUN_info;
  RequestBlock_struct      Request;
  ErrorInfo_struct  	   error_info; 
  WORD			   buf_size;  /* size in bytes of the buf */
  BYTE			   *buf;
} IOCTL_Command_struct;

typedef struct _BIG_IOCTL_Command_struct {
  LUNAddr_struct	   LUN_info;
  RequestBlock_struct      Request;
  ErrorInfo_struct  	   error_info;
  DWORD			   malloc_size; /* < MAX_KMALLOC_SIZE in cciss.c */
  DWORD			   buf_size;    /* size in bytes of the buf */
  				        /* < malloc_size * MAXSGENTRIES */
  BYTE			   *buf;
} BIG_IOCTL_Command_struct;

typedef struct _LogvolInfo_struct{
	__u32	LunID;
	int	num_opens;  /* number of opens on the logical volume */
	int	num_parts;  /* number of partitions configured on logvol */
} LogvolInfo_struct;

#define CCISS_GETPCIINFO _IOR(CCISS_IOC_MAGIC, 1, cciss_pci_info_struct)

#define CCISS_GETINTINFO _IOR(CCISS_IOC_MAGIC, 2, cciss_coalint_struct)
#define CCISS_SETINTINFO _IOW(CCISS_IOC_MAGIC, 3, cciss_coalint_struct)

#define CCISS_GETNODENAME _IOR(CCISS_IOC_MAGIC, 4, NodeName_type)
#define CCISS_SETNODENAME _IOW(CCISS_IOC_MAGIC, 5, NodeName_type)

#define CCISS_GETHEARTBEAT _IOR(CCISS_IOC_MAGIC, 6, Heartbeat_type)
#define CCISS_GETBUSTYPES  _IOR(CCISS_IOC_MAGIC, 7, BusTypes_type)
#define CCISS_GETFIRMVER   _IOR(CCISS_IOC_MAGIC, 8, FirmwareVer_type)
#define CCISS_GETDRIVVER   _IOR(CCISS_IOC_MAGIC, 9, DriverVer_type)
#define CCISS_REVALIDVOLS  _IO(CCISS_IOC_MAGIC, 10)
#define CCISS_PASSTHRU	   _IOWR(CCISS_IOC_MAGIC, 11, IOCTL_Command_struct)
#define CCISS_DEREGDISK	   _IO(CCISS_IOC_MAGIC, 12)

/* no longer used... use REGNEWD instead */ 
#define CCISS_REGNEWDISK  _IOW(CCISS_IOC_MAGIC, 13, int)

#define CCISS_REGNEWD	   _IO(CCISS_IOC_MAGIC, 14)
#define CCISS_RESCANDISK   _IO(CCISS_IOC_MAGIC, 16)
#define CCISS_GETLUNINFO   _IOR(CCISS_IOC_MAGIC, 17, LogvolInfo_struct)
#define CCISS_BIG_PASSTHRU _IOWR(CCISS_IOC_MAGIC, 18, BIG_IOCTL_Command_struct)

#endif /* CCISS_IOCTLH */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /* cgroupstats.h - exporting per-cgroup statistics
 *
 * Copyright IBM Corporation, 2007
 * Author Balbir Singh <balbir@linux.vnet.ibm.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2.1 of the GNU Lesser General Public License
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it would be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifndef _LINUX_CGROUPSTATS_H
#define _LINUX_CGROUPSTATS_H

#include <linux/types.h>
#include <linux/taskstats.h>

/*
 * Data shared between user space and kernel space on a per cgroup
 * basis. This data is shared using taskstats.
 *
 * Most of these states are derived by looking at the task->state value
 * For the nr_io_wait state, a flag in the delay accounting structure
 * indicates that the task is waiting on IO
 *
 * Each member is aligned to a 8 byte boundary.
 */
struct cgroupstats {
	__u64	nr_sleeping;		/* Number of tasks sleeping */
	__u64	nr_running;		/* Number of tasks running */
	__u64	nr_stopped;		/* Number of tasks in stopped state */
	__u64	nr_uninterruptible;	/* Number of tasks in uninterruptible */
					/* state */
	__u64	nr_io_wait;		/* Number of tasks waiting on IO */
};

/*
 * Commands sent from userspace
 * Not versioned. New commands should only be inserted at the enum's end
 * prior to __CGROUPSTATS_CMD_MAX
 */

enum {
	CGROUPSTATS_CMD_UNSPEC = __TASKSTATS_CMD_MAX,	/* Reserved */
	CGROUPSTATS_CMD_GET,		/* user->kernel request/get-response */
	CGROUPSTATS_CMD_NEW,		/* kernel->user event */
	__CGROUPSTATS_CMD_MAX,
};

#define CGROUPSTATS_CMD_MAX (__CGROUPSTATS_CMD_MAX - 1)

enum {
	CGROUPSTATS_TYPE_UNSPEC = 0,	/* Reserved */
	CGROUPSTATS_TYPE_CGROUP_STATS,	/* contains name + stats */
	__CGROUPSTATS_TYPE_MAX,
};

#define CGROUPSTATS_TYPE_MAX (__CGROUPSTATS_TYPE_MAX - 1)

enum {
	CGROUPSTATS_CMD_ATTR_UNSPEC = 0,
	CGROUPSTATS_CMD_ATTR_FD,
	__CGROUPSTATS_CMD_ATTR_MAX,
};

#define CGROUPSTATS_CMD_ATTR_MAX (__CGROUPSTATS_CMD_ATTR_MAX - 1)

#endif /* _LINUX_CGROUPSTATS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * ioctl interface for the scsi media changer driver
 */

/* changer element types */
#define CHET_MT   0	/* media transport element (robot) */
#define CHET_ST   1	/* storage element (media slots) */
#define CHET_IE   2	/* import/export element */
#define CHET_DT   3	/* data transfer element (tape/cdrom/whatever) */
#define CHET_V1   4	/* vendor specific #1 */
#define CHET_V2   5	/* vendor specific #2 */
#define CHET_V3   6	/* vendor specific #3 */
#define CHET_V4   7	/* vendor specific #4 */


/*
 * CHIOGPARAMS
 *    query changer properties
 *
 * CHIOVGPARAMS
 *    query vendor-specific element types
 *
 *    accessing elements works by specifing type and unit of the element.
 *    for example, storage elements are addressed with type = CHET_ST and
 *    unit = 0 .. cp_nslots-1
 *
 */
struct changer_params {
	int cp_curpicker;  /* current transport element */
	int cp_npickers;   /* number of transport elements      (CHET_MT) */
	int cp_nslots;     /* number of storage elements        (CHET_ST) */
	int cp_nportals;   /* number of import/export elements  (CHET_IE) */
	int cp_ndrives;    /* number of data transfer elements  (CHET_DT) */
};
struct changer_vendor_params {
	int  cvp_n1;       /* number of vendor specific elems   (CHET_V1) */
	char cvp_label1[16];
	int  cvp_n2;       /* number of vendor specific elems   (CHET_V2) */
	char cvp_label2[16];
	int  cvp_n3;       /* number of vendor specific elems   (CHET_V3) */
	char cvp_label3[16];
	int  cvp_n4;       /* number of vendor specific elems   (CHET_V4) */
	char cvp_label4[16];
	int  reserved[8];
};


/*
 * CHIOMOVE
 *    move a medium from one element to another
 */
struct changer_move {
	int cm_fromtype;	/* type/unit of source element */
	int cm_fromunit;	
	int cm_totype;	/* type/unit of destination element */
	int cm_tounit;
	int cm_flags;
};
#define CM_INVERT   1   /* flag: rotate media (for double-sided like MOD) */


/*
 * CHIOEXCHANGE
 *    move one medium from element #1 to element #2,
 *    and another one from element #2 to element #3.
 *    element #1 and #3 are allowed to be identical.
 */
struct changer_exchange {
	int ce_srctype;	    /* type/unit of element #1 */
	int ce_srcunit;
	int ce_fdsttype;    /* type/unit of element #2 */
	int ce_fdstunit;
	int ce_sdsttype;    /* type/unit of element #3 */
	int ce_sdstunit;
	int ce_flags;
};
#define CE_INVERT1   1
#define CE_INVERT2   2


/*
 * CHIOPOSITION
 *    move the transport element (robot arm) to a specific element.
 */
struct changer_position {
	int cp_type;
	int cp_unit;
	int cp_flags;
};
#define CP_INVERT   1


/*
 * CHIOGSTATUS
 *    get element status for all elements of a specific type
 */
struct changer_element_status {
	int             ces_type;
	unsigned char   *ces_data;
};
#define CESTATUS_FULL     0x01 /* full */
#define CESTATUS_IMPEXP   0x02	/* media was imported (inserted by sysop) */
#define CESTATUS_EXCEPT   0x04	/* error condition */
#define CESTATUS_ACCESS   0x08	/* access allowed */
#define CESTATUS_EXENAB   0x10	/* element can export media */
#define CESTATUS_INENAB   0x20	/* element can import media */


/*
 * CHIOGELEM
 *    get more detailed status information for a single element
 */
struct changer_get_element {
	int	cge_type;	 /* type/unit */
	int	cge_unit;
	int	cge_status;      /* status */
	int     cge_errno;       /* errno */
	int     cge_srctype;     /* source element of the last move/exchange */
	int     cge_srcunit;
	int     cge_id;          /* scsi id  (for data transfer elements) */
	int     cge_lun;         /* scsi lun (for data transfer elements) */
	char    cge_pvoltag[36]; /* primary volume tag */
	char    cge_avoltag[36]; /* alternate volume tag */
	int     cge_flags;
};
/* flags */
#define CGE_ERRNO     0x01       /* errno available       */
#define CGE_INVERT    0x02       /* media inverted        */
#define CGE_SRC       0x04       /* media src available   */
#define CGE_IDLUN     0x08       /* ID+LUN available      */
#define CGE_PVOLTAG   0x10       /* primary volume tag available */
#define CGE_AVOLTAG   0x20       /* alternate volume tag available */


/*
 * CHIOSVOLTAG
 *    set volume tag
 */
struct changer_set_voltag {
	int	csv_type;	 /* type/unit */
	int	csv_unit;
	char    csv_voltag[36];  /* volume tag */
	int     csv_flags;
};
#define CSV_PVOLTAG   0x01       /* primary volume tag */
#define CSV_AVOLTAG   0x02       /* alternate volume tag */
#define CSV_CLEARTAG  0x04       /* clear volume tag */

/* ioctls */
#define CHIOMOVE       _IOW('c', 1,struct changer_move)
#define CHIOEXCHANGE   _IOW('c', 2,struct changer_exchange)
#define CHIOPOSITION   _IOW('c', 3,struct changer_position)
#define CHIOGPICKER    _IOR('c', 4,int)                        /* not impl. */
#define CHIOSPICKER    _IOW('c', 5,int)                        /* not impl. */
#define CHIOGPARAMS    _IOR('c', 6,struct changer_params)
#define CHIOGSTATUS    _IOW('c', 8,struct changer_element_status)
#define CHIOGELEM      _IOW('c',16,struct changer_get_element)
#define CHIOINITELEM   _IO('c',17)
#define CHIOSVOLTAG    _IOW('c',18,struct changer_set_voltag)
#define CHIOGVPARAMS   _IOR('c',19,struct changer_vendor_params)

/* ---------------------------------------------------------------------- */

/*
 * Local variables:
 * c-basic-offset: 8
 * End:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #ifndef _CM4000_H_
#define _CM4000_H_

#include <linux/types.h>
#include <linux/ioctl.h>

#define	MAX_ATR			33

#define	CM4000_MAX_DEV		4

/* those two structures are passed via ioctl() from/to userspace.  They are
 * used by existing userspace programs, so I kepth the awkward "bIFSD" naming
 * not to break compilation of userspace apps. -HW */

typedef struct atreq {
	__s32 atr_len;
	unsigned char atr[64];
	__s32 power_act;
	unsigned char bIFSD;
	unsigned char bIFSC;
} atreq_t;


/* what is particularly stupid in the original driver is the arch-dependent
 * member sizes. This leads to CONFIG_COMPAT breakage, since 32bit userspace
 * will lay out the structure members differently than the 64bit kernel.
 *
 * I've changed "ptsreq.protocol" from "unsigned long" to "__u32".
 * On 32bit this will make no difference.  With 64bit kernels, it will make
 * 32bit apps work, too.
 */

typedef struct ptsreq {
	__u32 protocol; /*T=0: 2^0, T=1:  2^1*/
 	unsigned char flags;
 	unsigned char pts1;
 	unsigned char pts2;
	unsigned char pts3;
} ptsreq_t;

#define	CM_IOC_MAGIC		'c'
#define	CM_IOC_MAXNR	        255

#define	CM_IOCGSTATUS		_IOR (CM_IOC_MAGIC, 0, unsigned char *)
#define	CM_IOCGATR		_IOWR(CM_IOC_MAGIC, 1, atreq_t *)
#define	CM_IOCSPTS		_IOW (CM_IOC_MAGIC, 2, ptsreq_t *)
#define	CM_IOCSRDR		_IO  (CM_IOC_MAGIC, 3)
#define CM_IOCARDOFF            _IO  (CM_IOC_MAGIC, 4)

#define CM_IOSDBGLVL            _IOW(CM_IOC_MAGIC, 250, int*)

/* card and device states */
#define	CM_CARD_INSERTED		0x01
#define	CM_CARD_POWERED			0x02
#define	CM_ATR_PRESENT			0x04
#define	CM_ATR_VALID	 		0x08
#define	CM_STATE_VALID			0x0f
/* extra info only from CM4000 */
#define	CM_NO_READER			0x10
#define	CM_BAD_CARD			0x20


#endif /* _CM4000_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * cn_proc.h - process events connector
 *
 * Copyright (C) Matt Helsley, IBM Corp. 2005
 * Based on cn_fork.h by Nguyen Anh Quynh and Guillaume Thouvenin
 * Copyright (C) 2005 Nguyen Anh Quynh <aquynh@gmail.com>
 * Copyright (C) 2005 Guillaume Thouvenin <guillaume.thouvenin@bull.net>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2.1 of the GNU Lesser General Public License
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it would be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifndef CN_PROC_H
#define CN_PROC_H

#include <linux/types.h>

/*
 * Userspace sends this enum to register with the kernel that it is listening
 * for events on the connector.
 */
enum proc_cn_mcast_op {
	PROC_CN_MCAST_LISTEN = 1,
	PROC_CN_MCAST_IGNORE = 2
};

/*
 * From the user's point of view, the process
 * ID is the thread group ID and thread ID is the internal
 * kernel "pid". So, fields are assigned as follow:
 *
 *  In user space     -  In  kernel space
 *
 * parent process ID  =  parent->tgid
 * parent thread  ID  =  parent->pid
 * child  process ID  =  child->tgid
 * child  thread  ID  =  child->pid
 */

struct proc_event {
	enum what {
		/* Use successive bits so the enums can be used to record
		 * sets of events as well
		 */
		PROC_EVENT_NONE = 0x00000000,
		PROC_EVENT_FORK = 0x00000001,
		PROC_EVENT_EXEC = 0x00000002,
		PROC_EVENT_UID  = 0x00000004,
		PROC_EVENT_GID  = 0x00000040,
		PROC_EVENT_SID  = 0x00000080,
		PROC_EVENT_PTRACE = 0x00000100,
		PROC_EVENT_COMM = 0x00000200,
		/* "next" should be 0x00000400 */
		/* "last" is the last process event: exit,
		 * while "next to last" is coredumping event */
		PROC_EVENT_COREDUMP = 0x40000000,
		PROC_EVENT_EXIT = 0x80000000
	} what;
	__u32 cpu;
	__u64 __attribute__((aligned(8))) timestamp_ns;
		/* Number of nano seconds since system boot */
	union { /* must be last field of proc_event struct */
		struct {
			__u32 err;
		} ack;

		struct fork_proc_event {
			__kernel_pid_t parent_pid;
			__kernel_pid_t parent_tgid;
			__kernel_pid_t child_pid;
			__kernel_pid_t child_tgid;
		} fork;

		struct exec_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
		} exec;

		struct id_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
			union {
				__u32 ruid; /* task uid */
				__u32 rgid; /* task gid */
			} r;
			union {
				__u32 euid;
				__u32 egid;
			} e;
		} id;

		struct sid_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
		} sid;

		struct ptrace_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
			__kernel_pid_t tracer_pid;
			__kernel_pid_t tracer_tgid;
		} ptrace;

		struct comm_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
			char           comm[16];
		} comm;

		struct coredump_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
		} coredump;

		struct exit_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
			__u32 exit_code, exit_signal;
		} exit;

	} event_data;
};

#endif /* CN_PROC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * -- <linux/cdrom.h>
 * General header file for linux CD-ROM drivers 
 * Copyright (C) 1992         David Giller, rafetmad@oxy.edu
 *               1994, 1995   Eberhard MÃ¶nkeberg, emoenke@gwdg.de
 *               1996         David van Leeuwen, david@tm.tno.nl
 *               1997, 1998   Erik Andersen, andersee@debian.org
 *               1998-2002    Jens Axboe, axboe@suse.de
 */
 
#ifndef _LINUX_CDROM_H
#define _LINUX_CDROM_H

#include <linux/types.h>
#include <asm/byteorder.h>

/*******************************************************
 * As of Linux 2.1.x, all Linux CD-ROM application programs will use this 
 * (and only this) include file.  It is my hope to provide Linux with
 * a uniform interface between software accessing CD-ROMs and the various 
 * device drivers that actually talk to the drives.  There may still be
 * 23 different kinds of strange CD-ROM drives, but at least there will 
 * now be one, and only one, Linux CD-ROM interface.
 *
 * Additionally, as of Linux 2.1.x, all Linux application programs 
 * should use the O_NONBLOCK option when opening a CD-ROM device 
 * for subsequent ioctl commands.  This allows for neat system errors 
 * like "No medium found" or "Wrong medium type" upon attempting to 
 * mount or play an empty slot, mount an audio disc, or play a data disc.
 * Generally, changing an application program to support O_NONBLOCK
 * is as easy as the following:
 *       -    drive = open("/dev/cdrom", O_RDONLY);
 *       +    drive = open("/dev/cdrom", O_RDONLY | O_NONBLOCK);
 * It is worth the small change.
 *
 *  Patches for many common CD programs (provided by David A. van Leeuwen)
 *  can be found at:  ftp://ftp.gwdg.de/pub/linux/cdrom/drivers/cm206/
 * 
 *******************************************************/

/* When a driver supports a certain function, but the cdrom drive we are 
 * using doesn't, we will return the error EDRIVE_CANT_DO_THIS.  We will 
 * borrow the "Operation not supported" error from the network folks to 
 * accomplish this.  Maybe someday we will get a more targeted error code, 
 * but this will do for now... */
#define EDRIVE_CANT_DO_THIS  EOPNOTSUPP

/*******************************************************
 * The CD-ROM IOCTL commands  -- these should be supported by 
 * all the various cdrom drivers.  For the CD-ROM ioctls, we 
 * will commandeer byte 0x53, or 'S'.
 *******************************************************/
#define CDROMPAUSE		0x5301 /* Pause Audio Operation */ 
#define CDROMRESUME		0x5302 /* Resume paused Audio Operation */
#define CDROMPLAYMSF		0x5303 /* Play Audio MSF (struct cdrom_msf) */
#define CDROMPLAYTRKIND		0x5304 /* Play Audio Track/index 
                                           (struct cdrom_ti) */
#define CDROMREADTOCHDR		0x5305 /* Read TOC header 
                                           (struct cdrom_tochdr) */
#define CDROMREADTOCENTRY	0x5306 /* Read TOC entry 
                                           (struct cdrom_tocentry) */
#define CDROMSTOP		0x5307 /* Stop the cdrom drive */
#define CDROMSTART		0x5308 /* Start the cdrom drive */
#define CDROMEJECT		0x5309 /* Ejects the cdrom media */
#define CDROMVOLCTRL		0x530a /* Control output volume 
                                           (struct cdrom_volctrl) */
#define CDROMSUBCHNL		0x530b /* Read subchannel data 
                                           (struct cdrom_subchnl) */
#define CDROMREADMODE2		0x530c /* Read CDROM mode 2 data (2336 Bytes) 
                                           (struct cdrom_read) */
#define CDROMREADMODE1		0x530d /* Read CDROM mode 1 data (2048 Bytes)
                                           (struct cdrom_read) */
#define CDROMREADAUDIO		0x530e /* (struct cdrom_read_audio) */
#define CDROMEJECT_SW		0x530f /* enable(1)/disable(0) auto-ejecting */
#define CDROMMULTISESSION	0x5310 /* Obtain the start-of-last-session 
                                           address of multi session disks 
                                           (struct cdrom_multisession) */
#define CDROM_GET_MCN		0x5311 /* Obtain the "Universal Product Code" 
                                           if available (struct cdrom_mcn) */
#define CDROM_GET_UPC		CDROM_GET_MCN  /* This one is deprecated, 
                                          but here anyway for compatibility */
#define CDROMRESET		0x5312 /* hard-reset the drive */
#define CDROMVOLREAD		0x5313 /* Get the drive's volume setting 
                                          (struct cdrom_volctrl) */
#define CDROMREADRAW		0x5314	/* read data in raw mode (2352 Bytes)
                                           (struct cdrom_read) */
/* 
 * These ioctls are used only used in aztcd.c and optcd.c
 */
#define CDROMREADCOOKED		0x5315	/* read data in cooked mode */
#define CDROMSEEK		0x5316  /* seek msf address */
  
/*
 * This ioctl is only used by the scsi-cd driver.  
   It is for playing audio in logical block addressing mode.
 */
#define CDROMPLAYBLK		0x5317	/* (struct cdrom_blk) */

/* 
 * These ioctls are only used in optcd.c
 */
#define CDROMREADALL		0x5318	/* read all 2646 bytes */

/* 
 * These ioctls are (now) only in ide-cd.c for controlling 
 * drive spindown time.  They should be implemented in the
 * Uniform driver, via generic packet commands, GPCMD_MODE_SELECT_10,
 * GPCMD_MODE_SENSE_10 and the GPMODE_POWER_PAGE...
 *  -Erik
 */
#define CDROMGETSPINDOWN        0x531d
#define CDROMSETSPINDOWN        0x531e

/* 
 * These ioctls are implemented through the uniform CD-ROM driver
 * They _will_ be adopted by all CD-ROM drivers, when all the CD-ROM
 * drivers are eventually ported to the uniform CD-ROM driver interface.
 */
#define CDROMCLOSETRAY		0x5319	/* pendant of CDROMEJECT */
#define CDROM_SET_OPTIONS	0x5320  /* Set behavior options */
#define CDROM_CLEAR_OPTIONS	0x5321  /* Clear behavior options */
#define CDROM_SELECT_SPEED	0x5322  /* Set the CD-ROM speed */
#define CDROM_SELECT_DISC	0x5323  /* Select disc (for juke-boxes) */
#define CDROM_MEDIA_CHANGED	0x5325  /* Check is media changed  */
#define CDROM_DRIVE_STATUS	0x5326  /* Get tray position, etc. */
#define CDROM_DISC_STATUS	0x5327  /* Get disc type, etc. */
#define CDROM_CHANGER_NSLOTS    0x5328  /* Get number of slots */
#define CDROM_LOCKDOOR		0x5329  /* lock or unlock door */
#define CDROM_DEBUG		0x5330	/* Turn debug messages on/off */
#define CDROM_GET_CAPABILITY	0x5331	/* get capabilities */

/* Note that scsi/scsi_ioctl.h also uses 0x5382 - 0x5386.
 * Future CDROM ioctls should be kept below 0x537F
 */

/* This ioctl is only used by sbpcd at the moment */
#define CDROMAUDIOBUFSIZ        0x5382	/* set the audio buffer size */
					/* conflict with SCSI_IOCTL_GET_IDLUN */

/* DVD-ROM Specific ioctls */
#define DVD_READ_STRUCT		0x5390  /* Read structure */
#define DVD_WRITE_STRUCT	0x5391  /* Write structure */
#define DVD_AUTH		0x5392  /* Authentication */

#define CDROM_SEND_PACKET	0x5393	/* send a packet to the drive */
#define CDROM_NEXT_WRITABLE	0x5394	/* get next writable block */
#define CDROM_LAST_WRITTEN	0x5395	/* get last block written on disc */

/*******************************************************
 * CDROM IOCTL structures
 *******************************************************/

/* Address in MSF format */
struct cdrom_msf0		
{
	__u8	minute;
	__u8	second;
	__u8	frame;
};

/* Address in either MSF or logical format */
union cdrom_addr		
{
	struct cdrom_msf0	msf;
	int			lba;
};

/* This struct is used by the CDROMPLAYMSF ioctl */ 
struct cdrom_msf 
{
	__u8	cdmsf_min0;	/* start minute */
	__u8	cdmsf_sec0;	/* start second */
	__u8	cdmsf_frame0;	/* start frame */
	__u8	cdmsf_min1;	/* end minute */
	__u8	cdmsf_sec1;	/* end second */
	__u8	cdmsf_frame1;	/* end frame */
};

/* This struct is used by the CDROMPLAYTRKIND ioctl */
struct cdrom_ti 
{
	__u8	cdti_trk0;	/* start track */
	__u8	cdti_ind0;	/* start index */
	__u8	cdti_trk1;	/* end track */
	__u8	cdti_ind1;	/* end index */
};

/* This struct is used by the CDROMREADTOCHDR ioctl */
struct cdrom_tochdr 	
{
	__u8	cdth_trk0;	/* start track */
	__u8	cdth_trk1;	/* end track */
};

/* This struct is used by the CDROMVOLCTRL and CDROMVOLREAD ioctls */
struct cdrom_volctrl
{
	__u8	channel0;
	__u8	channel1;
	__u8	channel2;
	__u8	channel3;
};

/* This struct is used by the CDROMSUBCHNL ioctl */
struct cdrom_subchnl 
{
	__u8	cdsc_format;
	__u8	cdsc_audiostatus;
	__u8	cdsc_adr:	4;
	__u8	cdsc_ctrl:	4;
	__u8	cdsc_trk;
	__u8	cdsc_ind;
	union cdrom_addr cdsc_absaddr;
	union cdrom_addr cdsc_reladdr;
};


/* This struct is used by the CDROMREADTOCENTRY ioctl */
struct cdrom_tocentry 
{
	__u8	cdte_track;
	__u8	cdte_adr	:4;
	__u8	cdte_ctrl	:4;
	__u8	cdte_format;
	union cdrom_addr cdte_addr;
	__u8	cdte_datamode;
};

/* This struct is used by the CDROMREADMODE1, and CDROMREADMODE2 ioctls */
struct cdrom_read      
{
	int	cdread_lba;
	char 	*cdread_bufaddr;
	int	cdread_buflen;
};

/* This struct is used by the CDROMREADAUDIO ioctl */
struct cdrom_read_audio
{
	union cdrom_addr addr; /* frame address */
	__u8 addr_format;      /* CDROM_LBA or CDROM_MSF */
	int nframes;           /* number of 2352-byte-frames to read at once */
	__u8 *buf;      /* frame buffer (size: nframes*2352 bytes) */
};

/* This struct is used with the CDROMMULTISESSION ioctl */
struct cdrom_multisession
{
	union cdrom_addr addr; /* frame address: start-of-last-session 
	                           (not the new "frame 16"!).  Only valid
	                           if the "xa_flag" is true. */
	__u8 xa_flag;        /* 1: "is XA disk" */
	__u8 addr_format;    /* CDROM_LBA or CDROM_MSF */
};

/* This struct is used with the CDROM_GET_MCN ioctl.  
 * Very few audio discs actually have Universal Product Code information, 
 * which should just be the Medium Catalog Number on the box.  Also note 
 * that the way the codeis written on CD is _not_ uniform across all discs!
 */  
struct cdrom_mcn 
{
  __u8 medium_catalog_number[14]; /* 13 ASCII digits, null-terminated */
};

/* This is used by the CDROMPLAYBLK ioctl */
struct cdrom_blk 
{
	unsigned from;
	unsigned short len;
};

#define CDROM_PACKET_SIZE	12

#define CGC_DATA_UNKNOWN	0
#define CGC_DATA_WRITE		1
#define CGC_DATA_READ		2
#define CGC_DATA_NONE		3

/* for CDROM_PACKET_COMMAND ioctl */
struct cdrom_generic_command
{
	unsigned char 		cmd[CDROM_PACKET_SIZE];
	unsigned char		*buffer;
	unsigned int 		buflen;
	int			stat;
	struct request_sense	*sense;
	unsigned char		data_direction;
	int			quiet;
	int			timeout;
	void			*reserved[1];	/* unused, actually */
};

/*
 * A CD-ROM physical sector size is 2048, 2052, 2056, 2324, 2332, 2336, 
 * 2340, or 2352 bytes long.  

*         Sector types of the standard CD-ROM data formats:
 *
 * format   sector type               user data size (bytes)
 * -----------------------------------------------------------------------------
 *   1     (Red Book)    CD-DA          2352    (CD_FRAMESIZE_RAW)
 *   2     (Yellow Book) Mode1 Form1    2048    (CD_FRAMESIZE)
 *   3     (Yellow Book) Mode1 Form2    2336    (CD_FRAMESIZE_RAW0)
 *   4     (Green Book)  Mode2 Form1    2048    (CD_FRAMESIZE)
 *   5     (Green Book)  Mode2 Form2    2328    (2324+4 spare bytes)
 *
 *
 *       The layout of the standard CD-ROM data formats:
 * -----------------------------------------------------------------------------
 * - audio (red):                  | audio_sample_bytes |
 *                                 |        2352        |
 *
 * - data (yellow, mode1):         | sync - head - data - EDC - zero - ECC |
 *                                 |  12  -   4  - 2048 -  4  -   8  - 276 |
 *
 * - data (yellow, mode2):         | sync - head - data |
 *                                 |  12  -   4  - 2336 |
 *
 * - XA data (green, mode2 form1): | sync - head - sub - data - EDC - ECC |
 *                                 |  12  -   4  -  8  - 2048 -  4  - 276 |
 *
 * - XA data (green, mode2 form2): | sync - head - sub - data - Spare |
 *                                 |  12  -   4  -  8  - 2324 -  4    |
 *
 */

/* Some generally useful CD-ROM information -- mostly based on the above */
#define CD_MINS              74 /* max. minutes per CD, not really a limit */
#define CD_SECS              60 /* seconds per minute */
#define CD_FRAMES            75 /* frames per second */
#define CD_SYNC_SIZE         12 /* 12 sync bytes per raw data frame */
#define CD_MSF_OFFSET       150 /* MSF numbering offset of first frame */
#define CD_CHUNK_SIZE        24 /* lowest-level "data bytes piece" */
#define CD_NUM_OF_CHUNKS     98 /* chunks per frame */
#define CD_FRAMESIZE_SUB     96 /* subchannel data "frame" size */
#define CD_HEAD_SIZE          4 /* header (address) bytes per raw data frame */
#define CD_SUBHEAD_SIZE       8 /* subheader bytes per raw XA data frame */
#define CD_EDC_SIZE           4 /* bytes EDC per most raw data frame types */
#define CD_ZERO_SIZE          8 /* bytes zero per yellow book mode 1 frame */
#define CD_ECC_SIZE         276 /* bytes ECC per most raw data frame types */
#define CD_FRAMESIZE       2048 /* bytes per frame, "cooked" mode */
#define CD_FRAMESIZE_RAW   2352 /* bytes per frame, "raw" mode */
#define CD_FRAMESIZE_RAWER 2646 /* The maximum possible returned bytes */ 
/* most drives don't deliver everything: */
#define CD_FRAMESIZE_RAW1 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE) /*2340*/
#define CD_FRAMESIZE_RAW0 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE-CD_HEAD_SIZE) /*2336*/

#define CD_XA_HEAD        (CD_HEAD_SIZE+CD_SUBHEAD_SIZE) /* "before data" part of raw XA frame */
#define CD_XA_TAIL        (CD_EDC_SIZE+CD_ECC_SIZE) /* "after data" part of raw XA frame */
#define CD_XA_SYNC_HEAD   (CD_SYNC_SIZE+CD_XA_HEAD) /* sync bytes + header of XA frame */

/* CD-ROM address types (cdrom_tocentry.cdte_format) */
#define	CDROM_LBA 0x01 /* "logical block": first frame is #0 */
#define	CDROM_MSF 0x02 /* "minute-second-frame": binary, not bcd here! */

/* bit to tell whether track is data or audio (cdrom_tocentry.cdte_ctrl) */
#define	CDROM_DATA_TRACK	0x04

/* The leadout track is always 0xAA, regardless of # of tracks on disc */
#define	CDROM_LEADOUT		0xAA

/* audio states (from SCSI-2, but seen with other drives, too) */
#define	CDROM_AUDIO_INVALID	0x00	/* audio status not supported */
#define	CDROM_AUDIO_PLAY	0x11	/* audio play operation in progress */
#define	CDROM_AUDIO_PAUSED	0x12	/* audio play operation paused */
#define	CDROM_AUDIO_COMPLETED	0x13	/* audio play successfully completed */
#define	CDROM_AUDIO_ERROR	0x14	/* audio play stopped due to error */
#define	CDROM_AUDIO_NO_STATUS	0x15	/* no current audio status to return */

/* capability flags used with the uniform CD-ROM driver */ 
#define CDC_CLOSE_TRAY		0x1     /* caddy systems _can't_ close */
#define CDC_OPEN_TRAY		0x2     /* but _can_ eject.  */
#define CDC_LOCK		0x4     /* disable manual eject */
#define CDC_SELECT_SPEED 	0x8     /* programmable speed */
#define CDC_SELECT_DISC		0x10    /* select disc from juke-box */
#define CDC_MULTI_SESSION 	0x20    /* read sessions>1 */
#define CDC_MCN			0x40    /* Medium Catalog Number */
#define CDC_MEDIA_CHANGED 	0x80    /* media changed */
#define CDC_PLAY_AUDIO		0x100   /* audio functions */
#define CDC_RESET               0x200   /* hard reset device */
#define CDC_DRIVE_STATUS        0x800   /* driver implements drive status */
#define CDC_GENERIC_PACKET	0x1000	/* driver implements generic packets */
#define CDC_CD_R		0x2000	/* drive is a CD-R */
#define CDC_CD_RW		0x4000	/* drive is a CD-RW */
#define CDC_DVD			0x8000	/* drive is a DVD */
#define CDC_DVD_R		0x10000	/* drive can write DVD-R */
#define CDC_DVD_RAM		0x20000	/* drive can write DVD-RAM */
#define CDC_MO_DRIVE		0x40000 /* drive is an MO device */
#define CDC_MRW			0x80000 /* drive can read MRW */
#define CDC_MRW_W		0x100000 /* drive can write MRW */
#define CDC_RAM			0x200000 /* ok to open for WRITE */

/* drive status possibilities returned by CDROM_DRIVE_STATUS ioctl */
#define CDS_NO_INFO		0	/* if not implemented */
#define CDS_NO_DISC		1
#define CDS_TRAY_OPEN		2
#define CDS_DRIVE_NOT_READY	3
#define CDS_DISC_OK		4

/* return values for the CDROM_DISC_STATUS ioctl */
/* can also return CDS_NO_[INFO|DISC], from above */
#define CDS_AUDIO		100
#define CDS_DATA_1		101
#define CDS_DATA_2		102
#define CDS_XA_2_1		103
#define CDS_XA_2_2		104
#define CDS_MIXED		105

/* User-configurable behavior options for the uniform CD-ROM driver */
#define CDO_AUTO_CLOSE		0x1     /* close tray on first open() */
#define CDO_AUTO_EJECT		0x2     /* open tray on last release() */
#define CDO_USE_FFLAGS		0x4     /* use O_NONBLOCK information on open */
#define CDO_LOCK		0x8     /* lock tray on open files */
#define CDO_CHECK_TYPE		0x10    /* check type on open for data */

/* Special codes used when specifying changer slots. */
#define CDSL_NONE       	(INT_MAX-1)
#define CDSL_CURRENT    	INT_MAX

/* For partition based multisession access. IDE can handle 64 partitions
 * per drive - SCSI CD-ROM's use minors to differentiate between the
 * various drives, so we can't do multisessions the same way there.
 * Use the -o session=x option to mount on them.
 */
#define CD_PART_MAX		64
#define CD_PART_MASK		(CD_PART_MAX - 1)

/*********************************************************************
 * Generic Packet commands, MMC commands, and such
 *********************************************************************/

 /* The generic packet command opcodes for CD/DVD Logical Units,
 * From Table 57 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
#define GPCMD_BLANK			    0xa1
#define GPCMD_CLOSE_TRACK		    0x5b
#define GPCMD_FLUSH_CACHE		    0x35
#define GPCMD_FORMAT_UNIT		    0x04
#define GPCMD_GET_CONFIGURATION		    0x46
#define GPCMD_GET_EVENT_STATUS_NOTIFICATION 0x4a
#define GPCMD_GET_PERFORMANCE		    0xac
#define GPCMD_INQUIRY			    0x12
#define GPCMD_LOAD_UNLOAD		    0xa6
#define GPCMD_MECHANISM_STATUS		    0xbd
#define GPCMD_MODE_SELECT_10		    0x55
#define GPCMD_MODE_SENSE_10		    0x5a
#define GPCMD_PAUSE_RESUME		    0x4b
#define GPCMD_PLAY_AUDIO_10		    0x45
#define GPCMD_PLAY_AUDIO_MSF		    0x47
#define GPCMD_PLAY_AUDIO_TI		    0x48
#define GPCMD_PLAY_CD			    0xbc
#define GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL  0x1e
#define GPCMD_READ_10			    0x28
#define GPCMD_READ_12			    0xa8
#define GPCMD_READ_BUFFER		    0x3c
#define GPCMD_READ_BUFFER_CAPACITY	    0x5c
#define GPCMD_READ_CDVD_CAPACITY	    0x25
#define GPCMD_READ_CD			    0xbe
#define GPCMD_READ_CD_MSF		    0xb9
#define GPCMD_READ_DISC_INFO		    0x51
#define GPCMD_READ_DVD_STRUCTURE	    0xad
#define GPCMD_READ_FORMAT_CAPACITIES	    0x23
#define GPCMD_READ_HEADER		    0x44
#define GPCMD_READ_TRACK_RZONE_INFO	    0x52
#define GPCMD_READ_SUBCHANNEL		    0x42
#define GPCMD_READ_TOC_PMA_ATIP		    0x43
#define GPCMD_REPAIR_RZONE_TRACK	    0x58
#define GPCMD_REPORT_KEY		    0xa4
#define GPCMD_REQUEST_SENSE		    0x03
#define GPCMD_RESERVE_RZONE_TRACK	    0x53
#define GPCMD_SEND_CUE_SHEET		    0x5d
#define GPCMD_SCAN			    0xba
#define GPCMD_SEEK			    0x2b
#define GPCMD_SEND_DVD_STRUCTURE	    0xbf
#define GPCMD_SEND_EVENT		    0xa2
#define GPCMD_SEND_KEY			    0xa3
#define GPCMD_SEND_OPC			    0x54
#define GPCMD_SET_READ_AHEAD		    0xa7
#define GPCMD_SET_STREAMING		    0xb6
#define GPCMD_START_STOP_UNIT		    0x1b
#define GPCMD_STOP_PLAY_SCAN		    0x4e
#define GPCMD_TEST_UNIT_READY		    0x00
#define GPCMD_VERIFY_10			    0x2f
#define GPCMD_WRITE_10			    0x2a
#define GPCMD_WRITE_12			    0xaa
#define GPCMD_WRITE_AND_VERIFY_10	    0x2e
#define GPCMD_WRITE_BUFFER		    0x3b
/* This is listed as optional in ATAPI 2.6, but is (curiously) 
 * missing from Mt. Fuji, Table 57.  It _is_ mentioned in Mt. Fuji
 * Table 377 as an MMC command for SCSi devices though...  Most ATAPI
 * drives support it. */
#define GPCMD_SET_SPEED			    0xbb
/* This seems to be a SCSI specific CD-ROM opcode 
 * to play data at track/index */
#define GPCMD_PLAYAUDIO_TI		    0x48
/*
 * From MS Media Status Notification Support Specification. For
 * older drives only.
 */
#define GPCMD_GET_MEDIA_STATUS		    0xda

/* Mode page codes for mode sense/set */
#define GPMODE_VENDOR_PAGE		0x00
#define GPMODE_R_W_ERROR_PAGE		0x01
#define GPMODE_WRITE_PARMS_PAGE		0x05
#define GPMODE_WCACHING_PAGE		0x08
#define GPMODE_AUDIO_CTL_PAGE		0x0e
#define GPMODE_POWER_PAGE		0x1a
#define GPMODE_FAULT_FAIL_PAGE		0x1c
#define GPMODE_TO_PROTECT_PAGE		0x1d
#define GPMODE_CAPABILITIES_PAGE	0x2a
#define GPMODE_ALL_PAGES		0x3f
/* Not in Mt. Fuji, but in ATAPI 2.6 -- deprecated now in favor
 * of MODE_SENSE_POWER_PAGE */
#define GPMODE_CDROM_PAGE		0x0d



/* DVD struct types */
#define DVD_STRUCT_PHYSICAL	0x00
#define DVD_STRUCT_COPYRIGHT	0x01
#define DVD_STRUCT_DISCKEY	0x02
#define DVD_STRUCT_BCA		0x03
#define DVD_STRUCT_MANUFACT	0x04

struct dvd_layer {
	__u8 book_version	: 4;
	__u8 book_type		: 4;
	__u8 min_rate		: 4;
	__u8 disc_size		: 4;
	__u8 layer_type		: 4;
	__u8 track_path		: 1;
	__u8 nlayers		: 2;
	__u8 track_density	: 4;
	__u8 linear_density	: 4;
	__u8 bca		: 1;
	__u32 start_sector;
	__u32 end_sector;
	__u32 end_sector_l0;
};

#define DVD_LAYERS	4

struct dvd_physical {
	__u8 type;
	__u8 layer_num;
	struct dvd_layer layer[DVD_LAYERS];
};

struct dvd_copyright {
	__u8 type;

	__u8 layer_num;
	__u8 cpst;
	__u8 rmi;
};

struct dvd_disckey {
	__u8 type;

	unsigned agid		: 2;
	__u8 value[2048];
};

struct dvd_bca {
	__u8 type;

	int len;
	__u8 value[188];
};

struct dvd_manufact {
	__u8 type;

	__u8 layer_num;
	int len;
	__u8 value[2048];
};

typedef union {
	__u8 type;

	struct dvd_physical	physical;
	struct dvd_copyright	copyright;
	struct dvd_disckey	disckey;
	struct dvd_bca		bca;
	struct dvd_manufact	manufact;
} dvd_struct;

/*
 * DVD authentication ioctl
 */

/* Authentication states */
#define DVD_LU_SEND_AGID	0
#define DVD_HOST_SEND_CHALLENGE	1
#define DVD_LU_SEND_KEY1	2
#define DVD_LU_SEND_CHALLENGE	3
#define DVD_HOST_SEND_KEY2	4

/* Termination states */
#define DVD_AUTH_ESTABLISHED	5
#define DVD_AUTH_FAILURE	6

/* Other functions */
#define DVD_LU_SEND_TITLE_KEY	7
#define DVD_LU_SEND_ASF		8
#define DVD_INVALIDATE_AGID	9
#define DVD_LU_SEND_RPC_STATE	10
#define DVD_HOST_SEND_RPC_STATE	11

/* State data */
typedef __u8 dvd_key[5];		/* 40-bit value, MSB is first elem. */
typedef __u8 dvd_challenge[10];	/* 80-bit value, MSB is first elem. */

struct dvd_lu_send_agid {
	__u8 type;
	unsigned agid		: 2;
};

struct dvd_host_send_challenge {
	__u8 type;
	unsigned agid		: 2;

	dvd_challenge chal;
};

struct dvd_send_key {
	__u8 type;
	unsigned agid		: 2;

	dvd_key key;
};

struct dvd_lu_send_challenge {
	__u8 type;
	unsigned agid		: 2;

	dvd_challenge chal;
};

#define DVD_CPM_NO_COPYRIGHT	0
#define DVD_CPM_COPYRIGHTED	1

#define DVD_CP_SEC_NONE		0
#define DVD_CP_SEC_EXIST	1

#define DVD_CGMS_UNRESTRICTED	0
#define DVD_CGMS_SINGLE		2
#define DVD_CGMS_RESTRICTED	3

struct dvd_lu_send_title_key {
	__u8 type;
	unsigned agid		: 2;

	dvd_key title_key;
	int lba;
	unsigned cpm		: 1;
	unsigned cp_sec		: 1;
	unsigned cgms		: 2;
};

struct dvd_lu_send_asf {
	__u8 type;
	unsigned agid		: 2;

	unsigned asf		: 1;
};

struct dvd_host_send_rpcstate {
	__u8 type;
	__u8 pdrc;
};

struct dvd_lu_send_rpcstate {
	__u8 type		: 2;
	__u8 vra		: 3;
	__u8 ucca		: 3;
	__u8 region_mask;
	__u8 rpc_scheme;
};

typedef union {
	__u8 type;

	struct dvd_lu_send_agid		lsa;
	struct dvd_host_send_challenge	hsc;
	struct dvd_send_key		lsk;
	struct dvd_lu_send_challenge	lsc;
	struct dvd_send_key		hsk;
	struct dvd_lu_send_title_key	lstk;
	struct dvd_lu_send_asf		lsasf;
	struct dvd_host_send_rpcstate	hrpcs;
	struct dvd_lu_send_rpcstate	lrpcs;
} dvd_authinfo;

struct request_sense {
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 valid		: 1;
	__u8 error_code		: 7;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
	__u8 error_code		: 7;
	__u8 valid		: 1;
#endif
	__u8 segment_number;
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 reserved1		: 2;
	__u8 ili		: 1;
	__u8 reserved2		: 1;
	__u8 sense_key		: 4;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
	__u8 sense_key		: 4;
	__u8 reserved2		: 1;
	__u8 ili		: 1;
	__u8 reserved1		: 2;
#endif
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

/*
 * feature profile
 */
#define CDF_RWRT	0x0020	/* "Random Writable" */
#define CDF_HWDM	0x0024	/* "Hardware Defect Management" */
#define CDF_MRW 	0x0028

/*
 * media status bits
 */
#define CDM_MRW_NOTMRW			0
#define CDM_MRW_BGFORMAT_INACTIVE	1
#define CDM_MRW_BGFORMAT_ACTIVE		2
#define CDM_MRW_BGFORMAT_COMPLETE	3

/*
 * mrw address spaces
 */
#define MRW_LBA_DMA			0
#define MRW_LBA_GAA			1

/*
 * mrw mode pages (first is deprecated) -- probed at init time and
 * cdi->mrw_mode_page is set
 */
#define MRW_MODE_PC_PRE1		0x2c
#define MRW_MODE_PC			0x03

struct mrw_feature_desc {
	__be16 feature_code;
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 reserved1		: 2;
	__u8 feature_version	: 4;
	__u8 persistent		: 1;
	__u8 curr		: 1;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
	__u8 curr		: 1;
	__u8 persistent		: 1;
	__u8 feature_version	: 4;
	__u8 reserved1		: 2;
#endif
	__u8 add_len;
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 reserved2		: 7;
	__u8 write		: 1;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
	__u8 write		: 1;
	__u8 reserved2		: 7;
#endif
	__u8 reserved3;
	__u8 reserved4;
	__u8 reserved5;
};

/* cf. mmc4r02g.pdf 5.3.10 Random Writable Feature (0020h) pg 197 of 635 */
struct rwrt_feature_desc {
	__be16 feature_code;
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 reserved1		: 2;
	__u8 feature_version	: 4;
	__u8 persistent		: 1;
	__u8 curr		: 1;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
	__u8 curr		: 1;
	__u8 persistent		: 1;
	__u8 feature_version	: 4;
	__u8 reserved1		: 2;
#endif
	__u8 add_len;
	__u32 last_lba;
	__u32 block_size;
	__u16 blocking;
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 reserved2		: 7;
	__u8 page_present	: 1;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
	__u8 page_present	: 1;
	__u8 reserved2		: 7;
#endif
	__u8 reserved3;
};

typedef struct {
	__be16 disc_information_length;
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 reserved1			: 3;
        __u8 erasable			: 1;
        __u8 border_status		: 2;
        __u8 disc_status		: 2;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
        __u8 disc_status		: 2;
        __u8 border_status		: 2;
        __u8 erasable			: 1;
	__u8 reserved1			: 3;
#else
#error "Please fix <asm/byteorder.h>"
#endif
	__u8 n_first_track;
	__u8 n_sessions_lsb;
	__u8 first_track_lsb;
	__u8 last_track_lsb;
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 did_v			: 1;
        __u8 dbc_v			: 1;
        __u8 uru			: 1;
        __u8 reserved2			: 2;
	__u8 dbit			: 1;
	__u8 mrw_status			: 2;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
	__u8 mrw_status			: 2;
	__u8 dbit			: 1;
        __u8 reserved2			: 2;
        __u8 uru			: 1;
        __u8 dbc_v			: 1;
	__u8 did_v			: 1;
#endif
	__u8 disc_type;
	__u8 n_sessions_msb;
	__u8 first_track_msb;
	__u8 last_track_msb;
	__u32 disc_id;
	__u32 lead_in;
	__u32 lead_out;
	__u8 disc_bar_code[8];
	__u8 reserved3;
	__u8 n_opc;
} disc_information;

typedef struct {
	__be16 track_information_length;
	__u8 track_lsb;
	__u8 session_lsb;
	__u8 reserved1;
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 reserved2			: 2;
        __u8 damage			: 1;
        __u8 copy			: 1;
        __u8 track_mode			: 4;
	__u8 rt				: 1;
	__u8 blank			: 1;
	__u8 packet			: 1;
	__u8 fp				: 1;
	__u8 data_mode			: 4;
	__u8 reserved3			: 6;
	__u8 lra_v			: 1;
	__u8 nwa_v			: 1;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
        __u8 track_mode			: 4;
        __u8 copy			: 1;
        __u8 damage			: 1;
	__u8 reserved2			: 2;
	__u8 data_mode			: 4;
	__u8 fp				: 1;
	__u8 packet			: 1;
	__u8 blank			: 1;
	__u8 rt				: 1;
	__u8 nwa_v			: 1;
	__u8 lra_v			: 1;
	__u8 reserved3			: 6;
#endif
	__be32 track_start;
	__be32 next_writable;
	__be32 free_blocks;
	__be32 fixed_packet_size;
	__be32 track_size;
	__be32 last_rec_address;
} track_information;

struct feature_header {
	__u32 data_len;
	__u8 reserved1;
	__u8 reserved2;
	__u16 curr_profile;
};

struct mode_page_header {
	__be16 mode_data_length;
	__u8 medium_type;
	__u8 reserved1;
	__u8 reserved2;
	__u8 reserved3;
	__be16 desc_length;
};

/* removable medium feature descriptor */
struct rm_feature_desc {
	__be16 feature_code;
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 reserved1:2;
	__u8 feature_version:4;
	__u8 persistent:1;
	__u8 curr:1;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
	__u8 curr:1;
	__u8 persistent:1;
	__u8 feature_version:4;
	__u8 reserved1:2;
#endif
	__u8 add_len;
#if defined(__BIG_ENDIAN_BITFIELD)
	__u8 mech_type:3;
	__u8 load:1;
	__u8 eject:1;
	__u8 pvnt_jmpr:1;
	__u8 dbml:1;
	__u8 lock:1;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
	__u8 lock:1;
	__u8 dbml:1;
	__u8 pvnt_jmpr:1;
	__u8 eject:1;
	__u8 load:1;
	__u8 mech_type:3;
#endif
	__u8 reserved2;
	__u8 reserved3;
	__u8 reserved4;
};

#endif /* _LINUX_CDROM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /* 
   You may distribute this file under either of the two licenses that
   follow at your discretion.
*/

/* BLURB lgpl

                           Coda File System
                              Release 5

          Copyright (c) 1987-1999 Carnegie Mellon University
                  Additional copyrights listed below

This code is distributed "AS IS" without warranty of any kind under
the terms of the GNU Library General Public Licence Version 2, as
shown in the file LICENSE, or under the license shown below. The
technical and financial contributors to Coda are listed in the file
CREDITS.

                        Additional copyrights 
*/

/*

            Coda: an Experimental Distributed File System
                             Release 4.0

          Copyright (c) 1987-1999 Carnegie Mellon University
                         All Rights Reserved

Permission  to  use, copy, modify and distribute this software and its
documentation is hereby granted,  provided  that  both  the  copyright
notice  and  this  permission  notice  appear  in  all  copies  of the
software, derivative works or  modified  versions,  and  any  portions
thereof, and that both notices appear in supporting documentation, and
that credit is given to Carnegie Mellon University  in  all  documents
and publicity pertaining to direct or indirect use of this code or its
derivatives.

CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,
SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS
FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON
DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER
RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF
ANY DERIVATIVE WORK.

Carnegie  Mellon  encourages  users  of  this  software  to return any
improvements or extensions that  they  make,  and  to  grant  Carnegie
Mellon the rights to redistribute these changes without encumbrance.
*/

/*
 *
 * Based on cfs.h from Mach, but revamped for increased simplicity.
 * Linux modifications by 
 * Peter Braam, Aug 1996
 */

#ifndef _CODA_HEADER_
#define _CODA_HEADER_


/* Catch new _KERNEL defn for NetBSD and DJGPP/__CYGWIN32__ */
#if defined(__NetBSD__) || \
  ((defined(DJGPP) || defined(__CYGWIN32__)) && !defined(KERNEL))
#include <sys/types.h>
#endif 

#ifndef CODA_MAXSYMLINKS
#define CODA_MAXSYMLINKS 10
#endif

#if defined(DJGPP) || defined(__CYGWIN32__)
#ifdef KERNEL
typedef unsigned long u_long;
typedef unsigned int u_int;
typedef unsigned short u_short;
typedef u_long ino_t;
typedef u_long dev_t;
typedef void * caddr_t;
#ifdef DOS
typedef unsigned __int64 u_quad_t;
#else 
typedef unsigned long long u_quad_t;
#endif

#define __inline__

struct timespec {
        long       ts_sec;
        long       ts_nsec;
};
#else  /* DJGPP but not KERNEL */
#include <sys/time.h>
typedef unsigned long long u_quad_t;
#endif /* !KERNEL */
#endif /* !DJGPP */


#if defined(__linux__)
#include <linux/time.h>
#define cdev_t u_quad_t
#if !defined(_UQUAD_T_) && (!defined(__GLIBC__) || __GLIBC__ < 2)
#define _UQUAD_T_ 1
typedef unsigned long long u_quad_t;
#endif
#else
#define cdev_t dev_t
#endif

#ifdef __CYGWIN32__
struct timespec {
        time_t  tv_sec;         /* seconds */
        long    tv_nsec;        /* nanoseconds */
};
#endif

#ifndef __BIT_TYPES_DEFINED__
#define __BIT_TYPES_DEFINED__
typedef signed char	      int8_t;
typedef unsigned char	    u_int8_t;
typedef short		     int16_t;
typedef unsigned short	   u_int16_t;
typedef int		     int32_t;
typedef unsigned int	   u_int32_t;
#endif


/*
 * Cfs constants
 */
#define CODA_MAXNAMLEN   255
#define CODA_MAXPATHLEN  1024
#define CODA_MAXSYMLINK  10

/* these are Coda's version of O_RDONLY etc combinations
 * to deal with VFS open modes
 */
#define	C_O_READ	0x001
#define	C_O_WRITE       0x002
#define C_O_TRUNC       0x010
#define C_O_EXCL	0x100
#define C_O_CREAT	0x200

/* these are to find mode bits in Venus */ 
#define C_M_READ  00400
#define C_M_WRITE 00200

/* for access Venus will use */
#define C_A_C_OK    8               /* Test for writing upon create.  */
#define C_A_R_OK    4               /* Test for read permission.  */
#define C_A_W_OK    2               /* Test for write permission.  */
#define C_A_X_OK    1               /* Test for execute permission.  */
#define C_A_F_OK    0               /* Test for existence.  */



#ifndef _VENUS_DIRENT_T_
#define _VENUS_DIRENT_T_ 1
struct venus_dirent {
        u_int32_t d_fileno;		/* file number of entry */
        u_int16_t d_reclen;		/* length of this record */
        u_int8_t  d_type;			/* file type, see below */
        u_int8_t  d_namlen;		/* length of string in d_name */
        char	  d_name[CODA_MAXNAMLEN + 1];/* name must be no longer than this */
};
#undef DIRSIZ
#define DIRSIZ(dp)      ((sizeof (struct venus_dirent) - (CODA_MAXNAMLEN+1)) + \
                         (((dp)->d_namlen+1 + 3) &~ 3))

/*
 * File types
 */
#define	CDT_UNKNOWN	 0
#define	CDT_FIFO	 1
#define	CDT_CHR		 2
#define	CDT_DIR		 4
#define	CDT_BLK		 6
#define	CDT_REG		 8
#define	CDT_LNK		10
#define	CDT_SOCK	12
#define	CDT_WHT		14

/*
 * Convert between stat structure types and directory types.
 */
#define	IFTOCDT(mode)	(((mode) & 0170000) >> 12)
#define	CDTTOIF(dirtype)	((dirtype) << 12)

#endif

#ifndef _VUID_T_
#define _VUID_T_
typedef u_int32_t vuid_t;
typedef u_int32_t vgid_t;
#endif /*_VUID_T_ */

struct CodaFid {
	u_int32_t opaque[4];
};

#define coda_f2i(fid)\
	(fid ? (fid->opaque[3] ^ (fid->opaque[2]<<10) ^ (fid->opaque[1]<<20) ^ fid->opaque[0]) : 0)

#ifndef _VENUS_VATTR_T_
#define _VENUS_VATTR_T_
/*
 * Vnode types.  VNON means no type.
 */
enum coda_vtype	{ C_VNON, C_VREG, C_VDIR, C_VBLK, C_VCHR, C_VLNK, C_VSOCK, C_VFIFO, C_VBAD };

struct coda_vattr {
	long     	va_type;	/* vnode type (for create) */
	u_short		va_mode;	/* files access mode and type */
	short		va_nlink;	/* number of references to file */
	vuid_t		va_uid;		/* owner user id */
	vgid_t		va_gid;		/* owner group id */
	long		va_fileid;	/* file id */
	u_quad_t	va_size;	/* file size in bytes */
	long		va_blocksize;	/* blocksize preferred for i/o */
	struct timespec	va_atime;	/* time of last access */
	struct timespec	va_mtime;	/* time of last modification */
	struct timespec	va_ctime;	/* time file changed */
	u_long		va_gen;		/* generation number of file */
	u_long		va_flags;	/* flags defined for file */
	cdev_t	        va_rdev;	/* device special file represents */
	u_quad_t	va_bytes;	/* bytes of disk space held by file */
	u_quad_t	va_filerev;	/* file modification number */
};

#endif 

/* structure used by CODA_STATFS for getting cache information from venus */
struct coda_statfs {
    int32_t f_blocks;
    int32_t f_bfree;
    int32_t f_bavail;
    int32_t f_files;
    int32_t f_ffree;
};

/*
 * Kernel <--> Venus communications.
 */

#define CODA_ROOT	2
#define CODA_OPEN_BY_FD	3
#define CODA_OPEN	4
#define CODA_CLOSE	5
#define CODA_IOCTL	6
#define CODA_GETATTR	7
#define CODA_SETATTR	8
#define CODA_ACCESS	9
#define CODA_LOOKUP	10
#define CODA_CREATE	11
#define CODA_REMOVE	12
#define CODA_LINK	13
#define CODA_RENAME	14
#define CODA_MKDIR	15
#define CODA_RMDIR	16
#define CODA_SYMLINK	18
#define CODA_READLINK	19
#define CODA_FSYNC	20
#define CODA_VGET	22
#define CODA_SIGNAL	23
#define CODA_REPLACE	 24 /* DOWNCALL */
#define CODA_FLUSH       25 /* DOWNCALL */
#define CODA_PURGEUSER   26 /* DOWNCALL */
#define CODA_ZAPFILE     27 /* DOWNCALL */
#define CODA_ZAPDIR      28 /* DOWNCALL */
#define CODA_PURGEFID    30 /* DOWNCALL */
#define CODA_OPEN_BY_PATH 31
#define CODA_RESOLVE     32
#define CODA_REINTEGRATE 33
#define CODA_STATFS	 34
#define CODA_STORE	 35
#define CODA_RELEASE	 36
#define CODA_NCALLS 37

#define DOWNCALL(opcode) (opcode >= CODA_REPLACE && opcode <= CODA_PURGEFID)

#define VC_MAXDATASIZE	    8192
#define VC_MAXMSGSIZE      sizeof(union inputArgs)+sizeof(union outputArgs) +\
                            VC_MAXDATASIZE  

#define CIOC_KERNEL_VERSION _IOWR('c', 10, size_t)

#define CODA_KERNEL_VERSION 3 /* 128-bit file identifiers */

/*
 *        Venus <-> Coda  RPC arguments
 */
struct coda_in_hdr {
    u_int32_t opcode;
    u_int32_t unique;	    /* Keep multiple outstanding msgs distinct */
    pid_t pid;
    pid_t pgid;
    vuid_t uid;
};

/* Really important that opcode and unique are 1st two fields! */
struct coda_out_hdr {
    u_int32_t opcode;
    u_int32_t unique;	
    u_int32_t result;
};

/* coda_root: NO_IN */
struct coda_root_out {
    struct coda_out_hdr oh;
    struct CodaFid VFid;
};

struct coda_root_in {
    struct coda_in_hdr in;
};

/* coda_open: */
struct coda_open_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_open_out {
    struct coda_out_hdr oh;
    cdev_t	dev;
    ino_t	inode;
};


/* coda_store: */
struct coda_store_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_store_out {
    struct coda_out_hdr out;
};

/* coda_release: */
struct coda_release_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_release_out {
    struct coda_out_hdr out;
};

/* coda_close: */
struct coda_close_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_close_out {
    struct coda_out_hdr out;
};

/* coda_ioctl: */
struct coda_ioctl_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	cmd;
    int	len;
    int	rwflag;
    char *data;			/* Place holder for data. */
};

struct coda_ioctl_out {
    struct coda_out_hdr oh;
    int	len;
    caddr_t	data;		/* Place holder for data. */
};


/* coda_getattr: */
struct coda_getattr_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
};

struct coda_getattr_out {
    struct coda_out_hdr oh;
    struct coda_vattr attr;
};


/* coda_setattr: NO_OUT */
struct coda_setattr_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    struct coda_vattr attr;
};

struct coda_setattr_out {
    struct coda_out_hdr out;
};

/* coda_access: NO_OUT */
struct coda_access_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_access_out {
    struct coda_out_hdr out;
};


/* lookup flags */
#define CLU_CASE_SENSITIVE     0x01
#define CLU_CASE_INSENSITIVE   0x02

/* coda_lookup: */
struct  coda_lookup_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int         name;		/* Place holder for data. */
    int         flags;	
};

struct coda_lookup_out {
    struct coda_out_hdr oh;
    struct CodaFid VFid;
    int	vtype;
};


/* coda_create: */
struct coda_create_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    struct coda_vattr attr;
    int excl;
    int mode;
    int 	name;		/* Place holder for data. */
};

struct coda_create_out {
    struct coda_out_hdr oh;
    struct CodaFid VFid;
    struct coda_vattr attr;
};


/* coda_remove: NO_OUT */
struct coda_remove_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int name;		/* Place holder for data. */
};

struct coda_remove_out {
    struct coda_out_hdr out;
};

/* coda_link: NO_OUT */
struct coda_link_in {
    struct coda_in_hdr ih;
    struct CodaFid sourceFid;	/* cnode to link *to* */
    struct CodaFid destFid;	/* Directory in which to place link */
    int tname;		/* Place holder for data. */
};

struct coda_link_out {
    struct coda_out_hdr out;
};


/* coda_rename: NO_OUT */
struct coda_rename_in {
    struct coda_in_hdr ih;
    struct CodaFid sourceFid;
    int 	srcname;
    struct CodaFid destFid;
    int 	destname;
};

struct coda_rename_out {
    struct coda_out_hdr out;
};

/* coda_mkdir: */
struct coda_mkdir_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    struct coda_vattr attr;
    int	   name;		/* Place holder for data. */
};

struct coda_mkdir_out {
    struct coda_out_hdr oh;
    struct CodaFid VFid;
    struct coda_vattr attr;
};


/* coda_rmdir: NO_OUT */
struct coda_rmdir_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int name;		/* Place holder for data. */
};

struct coda_rmdir_out {
    struct coda_out_hdr out;
};

/* coda_symlink: NO_OUT */
struct coda_symlink_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;	/* Directory to put symlink in */
    int srcname;
    struct coda_vattr attr;
    int tname;
};

struct coda_symlink_out {
    struct coda_out_hdr out;
};

/* coda_readlink: */
struct coda_readlink_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
};

struct coda_readlink_out {
    struct coda_out_hdr oh;
    int	count;
    caddr_t	data;		/* Place holder for data. */
};


/* coda_fsync: NO_OUT */
struct coda_fsync_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
};

struct coda_fsync_out {
    struct coda_out_hdr out;
};

/* coda_vget: */
struct coda_vget_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
};

struct coda_vget_out {
    struct coda_out_hdr oh;
    struct CodaFid VFid;
    int	vtype;
};


/* CODA_SIGNAL is out-of-band, doesn't need data. */
/* CODA_INVALIDATE is a venus->kernel call */
/* CODA_FLUSH is a venus->kernel call */

/* coda_purgeuser: */
/* CODA_PURGEUSER is a venus->kernel call */
struct coda_purgeuser_out {
    struct coda_out_hdr oh;
    vuid_t uid;
};

/* coda_zapfile: */
/* CODA_ZAPFILE is a venus->kernel call */
struct coda_zapfile_out {  
    struct coda_out_hdr oh;
    struct CodaFid CodaFid;
};

/* coda_zapdir: */
/* CODA_ZAPDIR is a venus->kernel call */	
struct coda_zapdir_out {	  
    struct coda_out_hdr oh;
    struct CodaFid CodaFid;
};

/* coda_purgefid: */
/* CODA_PURGEFID is a venus->kernel call */	
struct coda_purgefid_out { 
    struct coda_out_hdr oh;
    struct CodaFid CodaFid;
};

/* coda_replace: */
/* CODA_REPLACE is a venus->kernel call */	
struct coda_replace_out { /* coda_replace is a venus->kernel call */
    struct coda_out_hdr oh;
    struct CodaFid NewFid;
    struct CodaFid OldFid;
};

/* coda_open_by_fd: */
struct coda_open_by_fd_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int        flags;
};

struct coda_open_by_fd_out {
    struct coda_out_hdr oh;
    int fd;

};

/* coda_open_by_path: */
struct coda_open_by_path_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_open_by_path_out {
    struct coda_out_hdr oh;
	int path;
};

/* coda_statfs: NO_IN */
struct coda_statfs_in {
    struct coda_in_hdr in;
};

struct coda_statfs_out {
    struct coda_out_hdr oh;
    struct coda_statfs stat;
};

/* 
 * Occasionally, we don't cache the fid returned by CODA_LOOKUP. 
 * For instance, if the fid is inconsistent. 
 * This case is handled by setting the top bit of the type result parameter.
 */
#define CODA_NOCACHE          0x80000000

union inputArgs {
    struct coda_in_hdr ih;		/* NB: every struct below begins with an ih */
    struct coda_open_in coda_open;
    struct coda_store_in coda_store;
    struct coda_release_in coda_release;
    struct coda_close_in coda_close;
    struct coda_ioctl_in coda_ioctl;
    struct coda_getattr_in coda_getattr;
    struct coda_setattr_in coda_setattr;
    struct coda_access_in coda_access;
    struct coda_lookup_in coda_lookup;
    struct coda_create_in coda_create;
    struct coda_remove_in coda_remove;
    struct coda_link_in coda_link;
    struct coda_rename_in coda_rename;
    struct coda_mkdir_in coda_mkdir;
    struct coda_rmdir_in coda_rmdir;
    struct coda_symlink_in coda_symlink;
    struct coda_readlink_in coda_readlink;
    struct coda_fsync_in coda_fsync;
    struct coda_vget_in coda_vget;
    struct coda_open_by_fd_in coda_open_by_fd;
    struct coda_open_by_path_in coda_open_by_path;
    struct coda_statfs_in coda_statfs;
};

union outputArgs {
    struct coda_out_hdr oh;		/* NB: every struct below begins with an oh */
    struct coda_root_out coda_root;
    struct coda_open_out coda_open;
    struct coda_ioctl_out coda_ioctl;
    struct coda_getattr_out coda_getattr;
    struct coda_lookup_out coda_lookup;
    struct coda_create_out coda_create;
    struct coda_mkdir_out coda_mkdir;
    struct coda_readlink_out coda_readlink;
    struct coda_vget_out coda_vget;
    struct coda_purgeuser_out coda_purgeuser;
    struct coda_zapfile_out coda_zapfile;
    struct coda_zapdir_out coda_zapdir;
    struct coda_purgefid_out coda_purgefid;
    struct coda_replace_out coda_replace;
    struct coda_open_by_fd_out coda_open_by_fd;
    struct coda_open_by_path_out coda_open_by_path;
    struct coda_statfs_out coda_statfs;
};    

union coda_downcalls {
    /* CODA_INVALIDATE is a venus->kernel call */
    /* CODA_FLUSH is a venus->kernel call */
    struct coda_purgeuser_out purgeuser;
    struct coda_zapfile_out zapfile;
    struct coda_zapdir_out zapdir;
    struct coda_purgefid_out purgefid;
    struct coda_replace_out replace;
};


/*
 * Used for identifying usage of "Control" and pioctls
 */

#define PIOCPARM_MASK 0x0000ffff
struct ViceIoctl {
        void *in;        /* Data to be transferred in */
        void *out;       /* Data to be transferred out */
        u_short in_size;        /* Size of input buffer <= 2K */
        u_short out_size;       /* Maximum size of output buffer, <= 2K */
};

struct PioctlData {
        const char *path;
        int follow;
        struct ViceIoctl vi;
};

#define CODA_CONTROL		".CONTROL"
#define CODA_CONTROLLEN		8
#define CTL_INO			-1

/* Data passed to mount */

#define CODA_MOUNT_VERSION 1

struct coda_mount_data {
	int		version;
	int		fd;       /* Opened device */
};

#endif /* _CODA_HEADER_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #ifndef __CODA_PSDEV_H
#define __CODA_PSDEV_H

#include <linux/magic.h>

#define CODA_PSDEV_MAJOR 67
#define MAX_CODADEVS  5	   /* how many do we allow */


/* messages between coda filesystem in kernel and Venus */
struct upc_req {
	struct list_head    uc_chain;
	caddr_t	            uc_data;
	u_short	            uc_flags;
	u_short             uc_inSize;  /* Size is at most 5000 bytes */
	u_short	            uc_outSize;
	u_short	            uc_opcode;  /* copied from data to save lookup */
	int		    uc_unique;
	wait_queue_head_t   uc_sleep;   /* process' wait queue */
};

#define CODA_REQ_ASYNC  0x1
#define CODA_REQ_READ   0x2
#define CODA_REQ_WRITE  0x4
#define CODA_REQ_ABORT  0x8

#endif /* __CODA_PSDEV_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * 	connector.h
 * 
 * 2004-2005 Copyright (c) Evgeniy Polyakov <zbr@ioremap.net>
 * All rights reserved.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef __CONNECTOR_H
#define __CONNECTOR_H

#include <linux/types.h>

/*
 * Process Events connector unique ids -- used for message routing
 */
#define CN_IDX_PROC			0x1
#define CN_VAL_PROC			0x1
#define CN_IDX_CIFS			0x2
#define CN_VAL_CIFS                     0x1
#define CN_W1_IDX			0x3	/* w1 communication */
#define CN_W1_VAL			0x1
#define CN_IDX_V86D			0x4
#define CN_VAL_V86D_UVESAFB		0x1
#define CN_IDX_BB			0x5	/* BlackBoard, from the TSP GPL sampling framework */
#define CN_DST_IDX			0x6
#define CN_DST_VAL			0x1
#define CN_IDX_DM			0x7	/* Device Mapper */
#define CN_VAL_DM_USERSPACE_LOG		0x1
#define CN_IDX_DRBD			0x8
#define CN_VAL_DRBD			0x1
#define CN_KVP_IDX			0x9	/* HyperV KVP */
#define CN_KVP_VAL			0x1	/* queries from the kernel */
#define CN_VSS_IDX			0xA     /* HyperV VSS */
#define CN_VSS_VAL			0x1     /* queries from the kernel */


#define CN_NETLINK_USERS		11	/* Highest index + 1 */

/*
 * Maximum connector's message size.
 */
#define CONNECTOR_MAX_MSG_SIZE		16384

/*
 * idx and val are unique identifiers which 
 * are used for message routing and 
 * must be registered in connector.h for in-kernel usage.
 */

struct cb_id {
	__u32 idx;
	__u32 val;
};

struct cn_msg {
	struct cb_id id;

	__u32 seq;
	__u32 ack;

	__u16 len;		/* Length of the following data */
	__u16 flags;
	__u8 data[0];
};

#endif /* __CONNECTOR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /* const.h: Macros for dealing with constants.  */

#ifndef _LINUX_CONST_H
#define _LINUX_CONST_H

/* Some constant macros are used in both assembler and
 * C code.  Therefore we cannot annotate them always with
 * 'UL' and other type specifiers unilaterally.  We
 * use the following macros to deal with this.
 *
 * Similarly, _AT() will cast an expression with a type in C, but
 * leave it unchanged in asm.
 */

#ifdef __ASSEMBLY__
#define _AC(X,Y)	X
#define _AT(T,X)	X
#else
#define __AC(X,Y)	(X##Y)
#define _AC(X,Y)	__AC(X,Y)
#define _AT(T,X)	((T)(X))
#endif

#define _BITUL(x)	(_AC(1,UL) << (x))
#define _BITULL(x)	(_AC(1,ULL) << (x))

#endif /* !(_LINUX_CONST_H) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /* This file is derived from the GAS 2.1.4 assembler control file.
   The GAS product is under the GNU General Public License, version 2 or later.
   As such, this file is also under that license.

   If the file format changes in the COFF object, this file should be
   subsequently updated to reflect the changes.

   The actual loader module only uses a few of these structures. The full
   set is documented here because I received the full set. If you wish
   more information about COFF, then O'Reilly has a very excellent book.
*/

#define  E_SYMNMLEN  8   /* Number of characters in a symbol name         */
#define  E_FILNMLEN 14   /* Number of characters in a file name           */
#define  E_DIMNUM    4   /* Number of array dimensions in auxiliary entry */

/*
 * These defines are byte order independent. There is no alignment of fields
 * permitted in the structures. Therefore they are declared as characters
 * and the values loaded from the character positions. It also makes it
 * nice to have it "endian" independent.
 */
 
/* Load a short int from the following tables with little-endian formats */
#define COFF_SHORT_L(ps) ((short)(((unsigned short)((unsigned char)ps[1])<<8)|\
				  ((unsigned short)((unsigned char)ps[0]))))

/* Load a long int from the following tables with little-endian formats */
#define COFF_LONG_L(ps) (((long)(((unsigned long)((unsigned char)ps[3])<<24) |\
				 ((unsigned long)((unsigned char)ps[2])<<16) |\
				 ((unsigned long)((unsigned char)ps[1])<<8)  |\
				 ((unsigned long)((unsigned char)ps[0])))))
 
/* Load a short int from the following tables with big-endian formats */
#define COFF_SHORT_H(ps) ((short)(((unsigned short)((unsigned char)ps[0])<<8)|\
				  ((unsigned short)((unsigned char)ps[1]))))

/* Load a long int from the following tables with big-endian formats */
#define COFF_LONG_H(ps) (((long)(((unsigned long)((unsigned char)ps[0])<<24) |\
				 ((unsigned long)((unsigned char)ps[1])<<16) |\
				 ((unsigned long)((unsigned char)ps[2])<<8)  |\
				 ((unsigned long)((unsigned char)ps[3])))))

/* These may be overridden later by brain dead implementations which generate
   a big-endian header with little-endian data. In that case, generate a
   replacement macro which tests a flag and uses either of the two above
   as appropriate. */

#define COFF_LONG(v)   COFF_LONG_L(v)
#define COFF_SHORT(v)  COFF_SHORT_L(v)

/*** coff information for Intel 386/486.  */

/********************** FILE HEADER **********************/

struct COFF_filehdr {
	char f_magic[2];	/* magic number			*/
	char f_nscns[2];	/* number of sections		*/
	char f_timdat[4];	/* time & date stamp		*/
	char f_symptr[4];	/* file pointer to symtab	*/
	char f_nsyms[4];	/* number of symtab entries	*/
	char f_opthdr[2];	/* sizeof(optional hdr)		*/
	char f_flags[2];	/* flags			*/
};

/*
 *   Bits for f_flags:
 *
 *	F_RELFLG	relocation info stripped from file
 *	F_EXEC		file is executable  (i.e. no unresolved external
 *			references)
 *	F_LNNO		line numbers stripped from file
 *	F_LSYMS		local symbols stripped from file
 *	F_MINMAL	this is a minimal object file (".m") output of fextract
 *	F_UPDATE	this is a fully bound update file, output of ogen
 *	F_SWABD		this file has had its bytes swabbed (in names)
 *	F_AR16WR	this file has the byte ordering of an AR16WR
 *			(e.g. 11/70) machine
 *	F_AR32WR	this file has the byte ordering of an AR32WR machine
 *			(e.g. vax and iNTEL 386)
 *	F_AR32W		this file has the byte ordering of an AR32W machine
 *			(e.g. 3b,maxi)
 *	F_PATCH		file contains "patch" list in optional header
 *	F_NODF		(minimal file only) no decision functions for
 *			replaced functions
 */

#define  COFF_F_RELFLG		0000001
#define  COFF_F_EXEC		0000002
#define  COFF_F_LNNO		0000004
#define  COFF_F_LSYMS		0000010
#define  COFF_F_MINMAL		0000020
#define  COFF_F_UPDATE		0000040
#define  COFF_F_SWABD		0000100
#define  COFF_F_AR16WR		0000200
#define  COFF_F_AR32WR		0000400
#define  COFF_F_AR32W		0001000
#define  COFF_F_PATCH		0002000
#define  COFF_F_NODF		0002000

#define	COFF_I386MAGIC	        0x14c   /* Linux's system    */

#if 0   /* Perhaps, someday, these formats may be used.      */
#define COFF_I386PTXMAGIC	0x154
#define COFF_I386AIXMAGIC	0x175   /* IBM's AIX system  */
#define COFF_I386BADMAG(x) ((COFF_SHORT((x).f_magic) != COFF_I386MAGIC) \
			  && COFF_SHORT((x).f_magic) != COFF_I386PTXMAGIC \
			  && COFF_SHORT((x).f_magic) != COFF_I386AIXMAGIC)
#else
#define COFF_I386BADMAG(x) (COFF_SHORT((x).f_magic) != COFF_I386MAGIC)
#endif

#define	COFF_FILHDR	struct COFF_filehdr
#define	COFF_FILHSZ	sizeof(COFF_FILHDR)

/********************** AOUT "OPTIONAL HEADER" **********************/

/* Linux COFF must have this "optional" header. Standard COFF has no entry
   location for the "entry" point. They normally would start with the first
   location of the .text section. This is not a good idea for linux. So,
   the use of this "optional" header is not optional. It is required.

   Do not be tempted to assume that the size of the optional header is
   a constant and simply index the next byte by the size of this structure.
   Use the 'f_opthdr' field in the main coff header for the size of the
   structure actually written to the file!!
*/

typedef struct 
{
  char 	magic[2];		/* type of file				 */
  char	vstamp[2];		/* version stamp			 */
  char	tsize[4];		/* text size in bytes, padded to FW bdry */
  char	dsize[4];		/* initialized   data "   "		 */
  char	bsize[4];		/* uninitialized data "   "		 */
  char	entry[4];		/* entry pt.				 */
  char 	text_start[4];		/* base of text used for this file       */
  char 	data_start[4];		/* base of data used for this file       */
}
COFF_AOUTHDR;

#define COFF_AOUTSZ (sizeof(COFF_AOUTHDR))

#define COFF_STMAGIC	0401
#define COFF_OMAGIC     0404
#define COFF_JMAGIC     0407    /* dirty text and data image, can't share  */
#define COFF_DMAGIC     0410    /* dirty text segment, data aligned        */
#define COFF_ZMAGIC     0413    /* The proper magic number for executables  */
#define COFF_SHMAGIC	0443	/* shared library header                   */

/********************** SECTION HEADER **********************/

struct COFF_scnhdr {
  char		s_name[8];	/* section name			    */
  char		s_paddr[4];	/* physical address, aliased s_nlib */
  char		s_vaddr[4];	/* virtual address		    */
  char		s_size[4];	/* section size			    */
  char		s_scnptr[4];	/* file ptr to raw data for section */
  char		s_relptr[4];	/* file ptr to relocation	    */
  char		s_lnnoptr[4];	/* file ptr to line numbers	    */
  char		s_nreloc[2];	/* number of relocation entries	    */
  char		s_nlnno[2];	/* number of line number entries    */
  char		s_flags[4];	/* flags			    */
};

#define	COFF_SCNHDR	struct COFF_scnhdr
#define	COFF_SCNHSZ	sizeof(COFF_SCNHDR)

/*
 * names of "special" sections
 */

#define COFF_TEXT	".text"
#define COFF_DATA	".data"
#define COFF_BSS	".bss"
#define COFF_COMMENT    ".comment"
#define COFF_LIB        ".lib"

#define COFF_SECT_TEXT  0      /* Section for instruction code             */
#define COFF_SECT_DATA  1      /* Section for initialized globals          */
#define COFF_SECT_BSS   2      /* Section for un-initialized globals       */
#define COFF_SECT_REQD  3      /* Minimum number of sections for good file */

#define COFF_STYP_REG     0x00 /* regular segment                          */
#define COFF_STYP_DSECT   0x01 /* dummy segment                            */
#define COFF_STYP_NOLOAD  0x02 /* no-load segment                          */
#define COFF_STYP_GROUP   0x04 /* group segment                            */
#define COFF_STYP_PAD     0x08 /* .pad segment                             */
#define COFF_STYP_COPY    0x10 /* copy section                             */
#define COFF_STYP_TEXT    0x20 /* .text segment                            */
#define COFF_STYP_DATA    0x40 /* .data segment                            */
#define COFF_STYP_BSS     0x80 /* .bss segment                             */
#define COFF_STYP_INFO   0x200 /* .comment section                         */
#define COFF_STYP_OVER   0x400 /* overlay section                          */
#define COFF_STYP_LIB    0x800 /* library section                          */

/*
 * Shared libraries have the following section header in the data field for
 * each library.
 */

struct COFF_slib {
  char		sl_entsz[4];	/* Size of this entry               */
  char		sl_pathndx[4];	/* size of the header field         */
};

#define	COFF_SLIBHD	struct COFF_slib
#define	COFF_SLIBSZ	sizeof(COFF_SLIBHD)

/********************** LINE NUMBERS **********************/

/* 1 line number entry for every "breakpointable" source line in a section.
 * Line numbers are grouped on a per function basis; first entry in a function
 * grouping will have l_lnno = 0 and in place of physical address will be the
 * symbol table index of the function name.
 */

struct COFF_lineno {
  union {
    char l_symndx[4];	/* function name symbol index, iff l_lnno == 0*/
    char l_paddr[4];	/* (physical) address of line number	*/
  } l_addr;
  char l_lnno[2];	/* line number		*/
};

#define	COFF_LINENO	struct COFF_lineno
#define	COFF_LINESZ	6

/********************** SYMBOLS **********************/

#define COFF_E_SYMNMLEN	 8	/* # characters in a short symbol name	*/
#define COFF_E_FILNMLEN	14	/* # characters in a file name		*/
#define COFF_E_DIMNUM	 4	/* # array dimensions in auxiliary entry */

/*
 *  All symbols and sections have the following definition
 */

struct COFF_syment 
{
  union {
    char e_name[E_SYMNMLEN];    /* Symbol name (first 8 characters) */
    struct {
      char e_zeroes[4];         /* Leading zeros */
      char e_offset[4];         /* Offset if this is a header section */
    } e;
  } e;

  char e_value[4];              /* Value (address) of the segment */
  char e_scnum[2];              /* Section number */
  char e_type[2];               /* Type of section */
  char e_sclass[1];             /* Loader class */
  char e_numaux[1];             /* Number of auxiliary entries which follow */
};

#define COFF_N_BTMASK	(0xf)   /* Mask for important class bits */
#define COFF_N_TMASK	(0x30)  /* Mask for important type bits  */
#define COFF_N_BTSHFT	(4)     /* # bits to shift class field   */
#define COFF_N_TSHIFT	(2)     /* # bits to shift type field    */

/*
 *  Auxiliary entries because the main table is too limiting.
 */
  
union COFF_auxent {

/*
 *  Debugger information
 */

  struct {
    char x_tagndx[4];	        /* str, un, or enum tag indx */
    union {
      struct {
	char  x_lnno[2];        /* declaration line number */
	char  x_size[2];        /* str/union/array size */
      } x_lnsz;
      char x_fsize[4];	        /* size of function */
    } x_misc;

    union {
      struct {		        /* if ISFCN, tag, or .bb */
	char x_lnnoptr[4];	/* ptr to fcn line # */
	char x_endndx[4];	/* entry ndx past block end */
      } x_fcn;

      struct {		        /* if ISARY, up to 4 dimen. */
	char x_dimen[E_DIMNUM][2];
      } x_ary;
    } x_fcnary;

    char x_tvndx[2];	/* tv index */
  } x_sym;

/*
 *   Source file names (debugger information)
 */

  union {
    char x_fname[E_FILNMLEN];
    struct {
      char x_zeroes[4];
      char x_offset[4];
    } x_n;
  } x_file;

/*
 *   Section information
 */

  struct {
    char x_scnlen[4];	/* section length */
    char x_nreloc[2];	/* # relocation entries */
    char x_nlinno[2];	/* # line numbers */
  } x_scn;

/*
 *   Transfer vector (branch table)
 */
  
  struct {
    char x_tvfill[4];	/* tv fill value */
    char x_tvlen[2];	/* length of .tv */
    char x_tvran[2][2];	/* tv range */
  } x_tv;		/* info about .tv section (in auxent of symbol .tv)) */
};

#define	COFF_SYMENT	struct COFF_syment
#define	COFF_SYMESZ	18	
#define	COFF_AUXENT	union COFF_auxent
#define	COFF_AUXESZ	18

#define COFF_ETEXT	"etext"

/********************** RELOCATION DIRECTIVES **********************/

struct COFF_reloc {
  char r_vaddr[4];        /* Virtual address of item    */
  char r_symndx[4];       /* Symbol index in the symtab */
  char r_type[2];         /* Relocation type            */
};

#define COFF_RELOC struct COFF_reloc
#define COFF_RELSZ 10

#define COFF_DEF_DATA_SECTION_ALIGNMENT  4
#define COFF_DEF_BSS_SECTION_ALIGNMENT   4
#define COFF_DEF_TEXT_SECTION_ALIGNMENT  4

/* For new sections we haven't heard of before */
#define COFF_DEF_SECTION_ALIGNMENT       4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #ifndef __CRAMFS_H
#define __CRAMFS_H

#include <linux/types.h>
#include <linux/magic.h>

#define CRAMFS_SIGNATURE	"Compressed ROMFS"

/*
 * Width of various bitfields in struct cramfs_inode.
 * Primarily used to generate warnings in mkcramfs.
 */
#define CRAMFS_MODE_WIDTH 16
#define CRAMFS_UID_WIDTH 16
#define CRAMFS_SIZE_WIDTH 24
#define CRAMFS_GID_WIDTH 8
#define CRAMFS_NAMELEN_WIDTH 6
#define CRAMFS_OFFSET_WIDTH 26

/*
 * Since inode.namelen is a unsigned 6-bit number, the maximum cramfs
 * path length is 63 << 2 = 252.
 */
#define CRAMFS_MAXPATHLEN (((1 << CRAMFS_NAMELEN_WIDTH) - 1) << 2)

/*
 * Reasonably terse representation of the inode data.
 */
struct cramfs_inode {
	__u32 mode:CRAMFS_MODE_WIDTH, uid:CRAMFS_UID_WIDTH;
	/* SIZE for device files is i_rdev */
	__u32 size:CRAMFS_SIZE_WIDTH, gid:CRAMFS_GID_WIDTH;
	/* NAMELEN is the length of the file name, divided by 4 and
           rounded up.  (cramfs doesn't support hard links.) */
	/* OFFSET: For symlinks and non-empty regular files, this
	   contains the offset (divided by 4) of the file data in
	   compressed form (starting with an array of block pointers;
	   see README).  For non-empty directories it is the offset
	   (divided by 4) of the inode of the first file in that
	   directory.  For anything else, offset is zero. */
	__u32 namelen:CRAMFS_NAMELEN_WIDTH, offset:CRAMFS_OFFSET_WIDTH;
};

struct cramfs_info {
	__u32 crc;
	__u32 edition;
	__u32 blocks;
	__u32 files;
};

/*
 * Superblock information at the beginning of the FS.
 */
struct cramfs_super {
	__u32 magic;			/* 0x28cd3d45 - random number */
	__u32 size;			/* length in bytes */
	__u32 flags;			/* feature flags */
	__u32 future;			/* reserved for future use */
	__u8 signature[16];		/* "Compressed ROMFS" */
	struct cramfs_info fsid;	/* unique filesystem info */
	__u8 name[16];			/* user-defined name */
	struct cramfs_inode root;	/* root inode data */
};

/*
 * Feature flags
 *
 * 0x00000000 - 0x000000ff: features that work for all past kernels
 * 0x00000100 - 0xffffffff: features that don't work for past kernels
 */
#define CRAMFS_FLAG_FSID_VERSION_2	0x00000001	/* fsid version #2 */
#define CRAMFS_FLAG_SORTED_DIRS		0x00000002	/* sorted dirs */
#define CRAMFS_FLAG_HOLES		0x00000100	/* support for holes */
#define CRAMFS_FLAG_WRONG_SIGNATURE	0x00000200	/* reserved */
#define CRAMFS_FLAG_SHIFTED_ROOT_OFFSET	0x00000400	/* shifted root fs */

/*
 * Valid values in super.flags.  Currently we refuse to mount
 * if (flags & ~CRAMFS_SUPPORTED_FLAGS).  Maybe that should be
 * changed to test super.future instead.
 */
#define CRAMFS_SUPPORTED_FLAGS	( 0x000000ff \
				| CRAMFS_FLAG_HOLES \
				| CRAMFS_FLAG_WRONG_SIGNATURE \
				| CRAMFS_FLAG_SHIFTED_ROOT_OFFSET )


#endif /* __CRAMFS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Definitions for talking to the CUDA.  The CUDA is a microcontroller
 * which controls the ADB, system power, RTC, and various other things.
 *
 * Copyright (C) 1996 Paul Mackerras.
 */

#ifndef _LINUX_CUDA_H
#define _LINUX_CUDA_H

/* CUDA commands (2nd byte) */
#define CUDA_WARM_START		0
#define CUDA_AUTOPOLL		1
#define CUDA_GET_6805_ADDR	2
#define CUDA_GET_TIME		3
#define CUDA_GET_PRAM		7
#define CUDA_SET_6805_ADDR	8
#define CUDA_SET_TIME		9
#define CUDA_POWERDOWN		0xa
#define CUDA_POWERUP_TIME	0xb
#define CUDA_SET_PRAM		0xc
#define CUDA_MS_RESET		0xd
#define CUDA_SEND_DFAC		0xe
#define CUDA_RESET_SYSTEM	0x11
#define CUDA_SET_IPL		0x12
#define CUDA_SET_AUTO_RATE	0x14
#define CUDA_GET_AUTO_RATE	0x16
#define CUDA_SET_DEVICE_LIST	0x19
#define CUDA_GET_DEVICE_LIST	0x1a
#define CUDA_GET_SET_IIC	0x22


#endif /* _LINUX_CUDA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /* $Revision: 3.0 $$Date: 1998/11/02 14:20:59 $
 * linux/include/linux/cyclades.h
 *
 * This file was initially written by
 * Randolph Bentson <bentson@grieg.seaslug.org> and is maintained by
 * Ivan Passos <ivan@cyclades.com>.
 *
 * This file contains the general definitions for the cyclades.c driver
 *$Log: cyclades.h,v $
 *Revision 3.1  2002/01/29 11:36:16  henrique
 *added throttle field on struct cyclades_port to indicate whether the
 *port is throttled or not
 *
 *Revision 3.1  2000/04/19 18:52:52  ivan
 *converted address fields to unsigned long and added fields for physical
 *addresses on cyclades_card structure;
 *
 *Revision 3.0  1998/11/02 14:20:59  ivan
 *added nports field on cyclades_card structure;
 *
 *Revision 2.5  1998/08/03 16:57:01  ivan
 *added cyclades_idle_stats structure;
 * 
 *Revision 2.4  1998/06/01 12:09:53  ivan
 *removed closing_wait2 from cyclades_port structure;
 *
 *Revision 2.3  1998/03/16 18:01:12  ivan
 *changes in the cyclades_port structure to get it closer to the 
 *standard serial port structure;
 *added constants for new ioctls;
 *
 *Revision 2.2  1998/02/17 16:50:00  ivan
 *changes in the cyclades_port structure (addition of shutdown_wait and 
 *chip_rev variables);
 *added constants for new ioctls and for CD1400 rev. numbers.
 *
 *Revision 2.1	1997/10/24 16:03:00  ivan
 *added rflow (which allows enabling the CD1400 special flow control 
 *feature) and rtsdtr_inv (which allows DTR/RTS pin inversion) to 
 *cyclades_port structure;
 *added Alpha support
 *
 *Revision 2.0  1997/06/30 10:30:00  ivan
 *added some new doorbell command constants related to IOCTLW and
 *UART error signaling
 *
 *Revision 1.8  1997/06/03 15:30:00  ivan
 *added constant ZFIRM_HLT
 *added constant CyPCI_Ze_win ( = 2 * Cy_PCI_Zwin)
 *
 *Revision 1.7  1997/03/26 10:30:00  daniel
 *new entries at the end of cyclades_port struct to reallocate
 *variables illegally allocated within card memory.
 *
 *Revision 1.6  1996/09/09 18:35:30  bentson
 *fold in changes for Cyclom-Z -- including structures for
 *communicating with board as well modest changes to original
 *structures to support new features.
 *
 *Revision 1.5  1995/11/13 21:13:31  bentson
 *changes suggested by Michael Chastain <mec@duracef.shout.net>
 *to support use of this file in non-kernel applications
 *
 *
 */

#ifndef _LINUX_CYCLADES_H
#define _LINUX_CYCLADES_H

#include <linux/types.h>

struct cyclades_monitor {
        unsigned long           int_count;
        unsigned long           char_count;
        unsigned long           char_max;
        unsigned long           char_last;
};

/*
 * These stats all reflect activity since the device was last initialized.
 * (i.e., since the port was opened with no other processes already having it
 * open)
 */
struct cyclades_idle_stats {
    __kernel_time_t in_use;	/* Time device has been in use (secs) */
    __kernel_time_t recv_idle;	/* Time since last char received (secs) */
    __kernel_time_t xmit_idle;	/* Time since last char transmitted (secs) */
    unsigned long  recv_bytes;	/* Bytes received */
    unsigned long  xmit_bytes;	/* Bytes transmitted */
    unsigned long  overruns;	/* Input overruns */
    unsigned long  frame_errs;	/* Input framing errors */
    unsigned long  parity_errs;	/* Input parity errors */
};

#define CYCLADES_MAGIC  0x4359

#define CYGETMON                0x435901
#define CYGETTHRESH             0x435902
#define CYSETTHRESH             0x435903
#define CYGETDEFTHRESH          0x435904
#define CYSETDEFTHRESH          0x435905
#define CYGETTIMEOUT            0x435906
#define CYSETTIMEOUT            0x435907
#define CYGETDEFTIMEOUT         0x435908
#define CYSETDEFTIMEOUT         0x435909
#define CYSETRFLOW		0x43590a
#define CYGETRFLOW		0x43590b
#define CYSETRTSDTR_INV		0x43590c
#define CYGETRTSDTR_INV		0x43590d
#define CYZSETPOLLCYCLE		0x43590e
#define CYZGETPOLLCYCLE		0x43590f
#define CYGETCD1400VER		0x435910
#define	CYSETWAIT		0x435912
#define	CYGETWAIT		0x435913

/*************** CYCLOM-Z ADDITIONS ***************/

#define CZIOC           ('M' << 8)
#define CZ_NBOARDS      (CZIOC|0xfa)
#define CZ_BOOT_START   (CZIOC|0xfb)
#define CZ_BOOT_DATA    (CZIOC|0xfc)
#define CZ_BOOT_END     (CZIOC|0xfd)
#define CZ_TEST         (CZIOC|0xfe)

#define CZ_DEF_POLL	(HZ/25)

#define MAX_BOARD       4       /* Max number of boards */
#define MAX_DEV         256     /* Max number of ports total */
#define	CYZ_MAX_SPEED	921600

#define	CYZ_FIFO_SIZE	16

#define CYZ_BOOT_NWORDS 0x100
struct CYZ_BOOT_CTRL {
        unsigned short  nboard;
        int             status[MAX_BOARD];
        int             nchannel[MAX_BOARD];
        int             fw_rev[MAX_BOARD];
        unsigned long   offset;
        unsigned long   data[CYZ_BOOT_NWORDS];
};


#ifndef DP_WINDOW_SIZE
/*
 *	Memory Window Sizes
 */

#define	DP_WINDOW_SIZE		(0x00080000)	/* window size 512 Kb */
#define	ZE_DP_WINDOW_SIZE	(0x00100000)	/* window size 1 Mb (Ze and
						  8Zo V.2 */
#define	CTRL_WINDOW_SIZE	(0x00000080)	/* runtime regs 128 bytes */

/*
 *	CUSTOM_REG - Cyclom-Z/PCI Custom Registers Set. The driver
 *	normally will access only interested on the fpga_id, fpga_version,
 *	start_cpu and stop_cpu.
 */

struct	CUSTOM_REG {
	__u32	fpga_id;		/* FPGA Identification Register */
	__u32	fpga_version;		/* FPGA Version Number Register */
	__u32	cpu_start;		/* CPU start Register (write) */
	__u32	cpu_stop;		/* CPU stop Register (write) */
	__u32	misc_reg;		/* Miscellaneous Register */
	__u32	idt_mode;		/* IDT mode Register */
	__u32	uart_irq_status;	/* UART IRQ status Register */
	__u32	clear_timer0_irq;	/* Clear timer interrupt Register */
	__u32	clear_timer1_irq;	/* Clear timer interrupt Register */
	__u32	clear_timer2_irq;	/* Clear timer interrupt Register */
	__u32	test_register;		/* Test Register */
	__u32	test_count;		/* Test Count Register */
	__u32	timer_select;		/* Timer select register */
	__u32	pr_uart_irq_status;	/* Prioritized UART IRQ stat Reg */
	__u32	ram_wait_state;		/* RAM wait-state Register */
	__u32	uart_wait_state;	/* UART wait-state Register */
	__u32	timer_wait_state;	/* timer wait-state Register */
	__u32	ack_wait_state;		/* ACK wait State Register */
};

/*
 *	RUNTIME_9060 - PLX PCI9060ES local configuration and shared runtime
 *	registers. This structure can be used to access the 9060 registers
 *	(memory mapped).
 */

struct RUNTIME_9060 {
	__u32	loc_addr_range;	/* 00h - Local Address Range */
	__u32	loc_addr_base;	/* 04h - Local Address Base */
	__u32	loc_arbitr;	/* 08h - Local Arbitration */
	__u32	endian_descr;	/* 0Ch - Big/Little Endian Descriptor */
	__u32	loc_rom_range;	/* 10h - Local ROM Range */
	__u32	loc_rom_base;	/* 14h - Local ROM Base */
	__u32	loc_bus_descr;	/* 18h - Local Bus descriptor */
	__u32	loc_range_mst;	/* 1Ch - Local Range for Master to PCI */
	__u32	loc_base_mst;	/* 20h - Local Base for Master PCI */
	__u32	loc_range_io;	/* 24h - Local Range for Master IO */
	__u32	pci_base_mst;	/* 28h - PCI Base for Master PCI */
	__u32	pci_conf_io;	/* 2Ch - PCI configuration for Master IO */
	__u32	filler1;	/* 30h */
	__u32	filler2;	/* 34h */
	__u32	filler3;	/* 38h */
	__u32	filler4;	/* 3Ch */
	__u32	mail_box_0;	/* 40h - Mail Box 0 */
	__u32	mail_box_1;	/* 44h - Mail Box 1 */
	__u32	mail_box_2;	/* 48h - Mail Box 2 */
	__u32	mail_box_3;	/* 4Ch - Mail Box 3 */
	__u32	filler5;	/* 50h */
	__u32	filler6;	/* 54h */
	__u32	filler7;	/* 58h */
	__u32	filler8;	/* 5Ch */
	__u32	pci_doorbell;	/* 60h - PCI to Local Doorbell */
	__u32	loc_doorbell;	/* 64h - Local to PCI Doorbell */
	__u32	intr_ctrl_stat;	/* 68h - Interrupt Control/Status */
	__u32	init_ctrl;	/* 6Ch - EEPROM control, Init Control, etc */
};

/* Values for the Local Base Address re-map register */

#define	WIN_RAM		0x00000001L	/* set the sliding window to RAM */
#define	WIN_CREG	0x14000001L	/* set the window to custom Registers */

/* Values timer select registers */

#define	TIMER_BY_1M	0x00		/* clock divided by 1M */
#define	TIMER_BY_256K	0x01		/* clock divided by 256k */
#define	TIMER_BY_128K	0x02		/* clock divided by 128k */
#define	TIMER_BY_32K	0x03		/* clock divided by 32k */

/****************** ****************** *******************/
#endif

#ifndef ZFIRM_ID
/* #include "zfwint.h" */
/****************** ****************** *******************/
/*
 *	This file contains the definitions for interfacing with the
 *	Cyclom-Z ZFIRM Firmware.
 */

/* General Constant definitions */

#define	MAX_CHAN	64		/* max number of channels per board */

/* firmware id structure (set after boot) */

#define ID_ADDRESS	0x00000180L	/* signature/pointer address */
#define	ZFIRM_ID	0x5557465AL	/* ZFIRM/U signature */
#define	ZFIRM_HLT	0x59505B5CL	/* ZFIRM needs external power supply */
#define	ZFIRM_RST	0x56040674L	/* RST signal (due to FW reset) */

#define	ZF_TINACT_DEF	1000		/* default inactivity timeout 
					   (1000 ms) */
#define	ZF_TINACT	ZF_TINACT_DEF

struct	FIRM_ID {
	__u32	signature;		/* ZFIRM/U signature */
	__u32	zfwctrl_addr;		/* pointer to ZFW_CTRL structure */
};

/* Op. System id */

#define	C_OS_LINUX	0x00000030	/* generic Linux system */

/* channel op_mode */

#define	C_CH_DISABLE	0x00000000	/* channel is disabled */
#define	C_CH_TXENABLE	0x00000001	/* channel Tx enabled */
#define	C_CH_RXENABLE	0x00000002	/* channel Rx enabled */
#define	C_CH_ENABLE	0x00000003	/* channel Tx/Rx enabled */
#define	C_CH_LOOPBACK	0x00000004	/* Loopback mode */

/* comm_parity - parity */

#define	C_PR_NONE	0x00000000	/* None */
#define	C_PR_ODD	0x00000001	/* Odd */
#define C_PR_EVEN	0x00000002	/* Even */
#define C_PR_MARK	0x00000004	/* Mark */
#define C_PR_SPACE	0x00000008	/* Space */
#define C_PR_PARITY	0x000000ff

#define	C_PR_DISCARD	0x00000100	/* discard char with frame/par error */
#define C_PR_IGNORE	0x00000200	/* ignore frame/par error */

/* comm_data_l - data length and stop bits */

#define C_DL_CS5	0x00000001
#define C_DL_CS6	0x00000002
#define C_DL_CS7	0x00000004
#define C_DL_CS8	0x00000008
#define	C_DL_CS		0x0000000f
#define C_DL_1STOP	0x00000010
#define C_DL_15STOP	0x00000020
#define C_DL_2STOP	0x00000040
#define	C_DL_STOP	0x000000f0

/* interrupt enabling/status */

#define	C_IN_DISABLE	0x00000000	/* zero, disable interrupts */
#define	C_IN_TXBEMPTY	0x00000001	/* tx buffer empty */
#define	C_IN_TXLOWWM	0x00000002	/* tx buffer below LWM */
#define	C_IN_RXHIWM	0x00000010	/* rx buffer above HWM */
#define	C_IN_RXNNDT	0x00000020	/* rx no new data timeout */
#define	C_IN_MDCD	0x00000100	/* modem DCD change */
#define	C_IN_MDSR	0x00000200	/* modem DSR change */
#define	C_IN_MRI	0x00000400	/* modem RI change */
#define	C_IN_MCTS	0x00000800	/* modem CTS change */
#define	C_IN_RXBRK	0x00001000	/* Break received */
#define	C_IN_PR_ERROR	0x00002000	/* parity error */
#define	C_IN_FR_ERROR	0x00004000	/* frame error */
#define C_IN_OVR_ERROR  0x00008000      /* overrun error */
#define C_IN_RXOFL	0x00010000      /* RX buffer overflow */
#define C_IN_IOCTLW	0x00020000      /* I/O control w/ wait */
#define C_IN_MRTS	0x00040000	/* modem RTS drop */
#define C_IN_ICHAR	0x00080000
 
/* flow control */

#define	C_FL_OXX	0x00000001	/* output Xon/Xoff flow control */
#define	C_FL_IXX	0x00000002	/* output Xon/Xoff flow control */
#define C_FL_OIXANY	0x00000004	/* output Xon/Xoff (any xon) */
#define	C_FL_SWFLOW	0x0000000f

/* flow status */

#define	C_FS_TXIDLE	0x00000000	/* no Tx data in the buffer or UART */
#define	C_FS_SENDING	0x00000001	/* UART is sending data */
#define	C_FS_SWFLOW	0x00000002	/* Tx is stopped by received Xoff */

/* rs_control/rs_status RS-232 signals */

#define C_RS_PARAM	0x80000000	/* Indicates presence of parameter in 
					   IOCTLM command */
#define	C_RS_RTS	0x00000001	/* RTS */
#define	C_RS_DTR	0x00000004	/* DTR */
#define	C_RS_DCD	0x00000100	/* CD */
#define	C_RS_DSR	0x00000200	/* DSR */
#define	C_RS_RI		0x00000400	/* RI */
#define	C_RS_CTS	0x00000800	/* CTS */

/* commands Host <-> Board */

#define	C_CM_RESET	0x01		/* reset/flush buffers */
#define	C_CM_IOCTL	0x02		/* re-read CH_CTRL */
#define	C_CM_IOCTLW	0x03		/* re-read CH_CTRL, intr when done */
#define	C_CM_IOCTLM	0x04		/* RS-232 outputs change */
#define	C_CM_SENDXOFF	0x10		/* send Xoff */
#define	C_CM_SENDXON	0x11		/* send Xon */
#define C_CM_CLFLOW	0x12		/* Clear flow control (resume) */
#define	C_CM_SENDBRK	0x41		/* send break */
#define	C_CM_INTBACK	0x42		/* Interrupt back */
#define	C_CM_SET_BREAK	0x43		/* Tx break on */
#define	C_CM_CLR_BREAK	0x44		/* Tx break off */
#define	C_CM_CMD_DONE	0x45		/* Previous command done */
#define C_CM_INTBACK2	0x46		/* Alternate Interrupt back */
#define	C_CM_TINACT	0x51		/* set inactivity detection */
#define	C_CM_IRQ_ENBL	0x52		/* enable generation of interrupts */
#define	C_CM_IRQ_DSBL	0x53		/* disable generation of interrupts */
#define	C_CM_ACK_ENBL	0x54		/* enable acknowledged interrupt mode */
#define	C_CM_ACK_DSBL	0x55		/* disable acknowledged intr mode */
#define	C_CM_FLUSH_RX	0x56		/* flushes Rx buffer */
#define	C_CM_FLUSH_TX	0x57		/* flushes Tx buffer */
#define C_CM_Q_ENABLE	0x58		/* enables queue access from the 
					   driver */
#define C_CM_Q_DISABLE  0x59            /* disables queue access from the 
					   driver */

#define	C_CM_TXBEMPTY	0x60		/* Tx buffer is empty */
#define	C_CM_TXLOWWM	0x61		/* Tx buffer low water mark */
#define	C_CM_RXHIWM	0x62		/* Rx buffer high water mark */
#define	C_CM_RXNNDT	0x63		/* rx no new data timeout */
#define	C_CM_TXFEMPTY	0x64
#define	C_CM_ICHAR	0x65
#define	C_CM_MDCD	0x70		/* modem DCD change */
#define	C_CM_MDSR	0x71		/* modem DSR change */
#define	C_CM_MRI	0x72		/* modem RI change */
#define	C_CM_MCTS	0x73		/* modem CTS change */
#define C_CM_MRTS	0x74		/* modem RTS drop */
#define	C_CM_RXBRK	0x84		/* Break received */
#define	C_CM_PR_ERROR	0x85		/* Parity error */
#define	C_CM_FR_ERROR	0x86		/* Frame error */
#define C_CM_OVR_ERROR  0x87            /* Overrun error */
#define C_CM_RXOFL	0x88            /* RX buffer overflow */
#define	C_CM_CMDERROR	0x90		/* command error */
#define	C_CM_FATAL	0x91		/* fatal error */
#define	C_CM_HW_RESET	0x92		/* reset board */

/*
 *	CH_CTRL - This per port structure contains all parameters
 *	that control an specific port. It can be seen as the
 *	configuration registers of a "super-serial-controller".
 */

struct CH_CTRL {
	__u32	op_mode;	/* operation mode */
	__u32	intr_enable;	/* interrupt masking */
	__u32	sw_flow;	/* SW flow control */
	__u32	flow_status;	/* output flow status */
	__u32	comm_baud;	/* baud rate  - numerically specified */
	__u32	comm_parity;	/* parity */
	__u32	comm_data_l;	/* data length/stop */
	__u32	comm_flags;	/* other flags */
	__u32	hw_flow;	/* HW flow control */
	__u32	rs_control;	/* RS-232 outputs */
	__u32	rs_status;	/* RS-232 inputs */
	__u32	flow_xon;	/* xon char */
	__u32	flow_xoff;	/* xoff char */
	__u32	hw_overflow;	/* hw overflow counter */
	__u32	sw_overflow;	/* sw overflow counter */
	__u32	comm_error;	/* frame/parity error counter */
	__u32 ichar;
	__u32 filler[7];
};


/*
 *	BUF_CTRL - This per channel structure contains
 *	all Tx and Rx buffer control for a given channel.
 */

struct	BUF_CTRL	{
	__u32	flag_dma;	/* buffers are in Host memory */
	__u32	tx_bufaddr;	/* address of the tx buffer */
	__u32	tx_bufsize;	/* tx buffer size */
	__u32	tx_threshold;	/* tx low water mark */
	__u32	tx_get;		/* tail index tx buf */
	__u32	tx_put;		/* head index tx buf */
	__u32	rx_bufaddr;	/* address of the rx buffer */
	__u32	rx_bufsize;	/* rx buffer size */
	__u32	rx_threshold;	/* rx high water mark */
	__u32	rx_get;		/* tail index rx buf */
	__u32	rx_put;		/* head index rx buf */
	__u32	filler[5];	/* filler to align structures */
};

/*
 *	BOARD_CTRL - This per board structure contains all global 
 *	control fields related to the board.
 */

struct BOARD_CTRL {

	/* static info provided by the on-board CPU */
	__u32	n_channel;	/* number of channels */
	__u32	fw_version;	/* firmware version */

	/* static info provided by the driver */
	__u32	op_system;	/* op_system id */
	__u32	dr_version;	/* driver version */

	/* board control area */
	__u32	inactivity;	/* inactivity control */

	/* host to FW commands */
	__u32	hcmd_channel;	/* channel number */
	__u32	hcmd_param;	/* pointer to parameters */

	/* FW to Host commands */
	__u32	fwcmd_channel;	/* channel number */
	__u32	fwcmd_param;	/* pointer to parameters */
	__u32	zf_int_queue_addr; /* offset for INT_QUEUE structure */

	/* filler so the structures are aligned */
	__u32	filler[6];
};

/* Host Interrupt Queue */

#define QUEUE_SIZE	(10*MAX_CHAN)

struct	INT_QUEUE {
	unsigned char	intr_code[QUEUE_SIZE];
	unsigned long	channel[QUEUE_SIZE];
	unsigned long	param[QUEUE_SIZE];
	unsigned long	put;
	unsigned long	get;
};

/*
 *	ZFW_CTRL - This is the data structure that includes all other
 *	data structures used by the Firmware.
 */
 
struct ZFW_CTRL {
	struct BOARD_CTRL	board_ctrl;
	struct CH_CTRL		ch_ctrl[MAX_CHAN];
	struct BUF_CTRL		buf_ctrl[MAX_CHAN];
};

/****************** ****************** *******************/
#endif

#endif /* _LINUX_CYCLADES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
* cycx_cfm.h	Cyclom 2X WAN Link Driver.
*		Definitions for the Cyclom 2X Firmware Module (CFM).
*
* Author:	Arnaldo Carvalho de Melo <acme@conectiva.com.br>
*
* Copyright:	(c) 1998-2003 Arnaldo Carvalho de Melo
*
* Based on sdlasfm.h by Gene Kozin <74604.152@compuserve.com>
*
*		This program is free software; you can redistribute it and/or
*		modify it under the terms of the GNU General Public License
*		as published by the Free Software Foundation; either version
*		2 of the License, or (at your option) any later version.
* ============================================================================
* 1998/08/08	acme		Initial version.
*/
#ifndef	_CYCX_CFM_H
#define	_CYCX_CFM_H

/* Defines */

#define	CFM_VERSION	2
#define	CFM_SIGNATURE	"CFM - Cyclades CYCX Firmware Module"

/* min/max */
#define	CFM_IMAGE_SIZE	0x20000	/* max size of CYCX code image file */
#define	CFM_DESCR_LEN	256	/* max length of description string */
#define	CFM_MAX_CYCX	1	/* max number of compatible adapters */
#define	CFM_LOAD_BUFSZ	0x400	/* buffer size for reset code (buffer_load) */

/* Firmware Commands */
#define GEN_POWER_ON	0x1280

#define GEN_SET_SEG	0x1401	/* boot segment setting. */
#define GEN_BOOT_DAT	0x1402	/* boot data. */
#define GEN_START	0x1403	/* board start. */
#define GEN_DEFPAR	0x1404	/* buffer length for boot. */

/* Adapter Types */
#define CYCX_2X		2
/* for now only the 2X is supported, no plans to support 8X or 16X */
#define CYCX_8X		8
#define CYCX_16X	16

#define	CFID_X25_2X	5200

/**
 *	struct cycx_fw_info - firmware module information.
 *	@codeid - firmware ID
 *	@version - firmware version number
 *	@adapter - compatible adapter types
 *	@memsize - minimum memory size
 *	@reserved - reserved
 *	@startoffs - entry point offset
 *	@winoffs - dual-port memory window offset
 *	@codeoffs - code load offset
 *	@codesize - code size
 *	@dataoffs - configuration data load offset
 *	@datasize - configuration data size
 */
struct cycx_fw_info {
	unsigned short	codeid;
	unsigned short	version;
	unsigned short	adapter[CFM_MAX_CYCX];
	unsigned long	memsize;
	unsigned short	reserved[2];
	unsigned short	startoffs;
	unsigned short	winoffs;
	unsigned short	codeoffs;
	unsigned long	codesize;
	unsigned short	dataoffs;
	unsigned long	datasize;
};

/**
 *	struct cycx_firmware - CYCX firmware file structure
 *	@signature - CFM file signature
 *	@version - file format version
 *	@checksum - info + image
 *	@reserved - reserved
 *	@descr - description string
 *	@info - firmware module info
 *	@image - code image (variable size)
 */
struct cycx_firmware {
	char		    signature[80];
	unsigned short	    version;
	unsigned short	    checksum;
	unsigned short	    reserved[6];
	char		    descr[CFM_DESCR_LEN];
	struct cycx_fw_info info;
	unsigned char	    image[0];
};

struct cycx_fw_header {
	unsigned long  reset_size;
	unsigned long  data_size;
	unsigned long  code_size;
};
#endif	/* _CYCX_CFM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * Copyright (c) 2008-2011, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place - Suite 330, Boston, MA 02111-1307 USA.
 *
 * Author: Lucy Liu <lucy.liu@intel.com>
 */

#ifndef __LINUX_DCBNL_H__
#define __LINUX_DCBNL_H__

#include <linux/types.h>

/* IEEE 802.1Qaz std supported values */
#define IEEE_8021QAZ_MAX_TCS	8

#define IEEE_8021QAZ_TSA_STRICT		0
#define IEEE_8021QAZ_TSA_CB_SHAPER	1
#define IEEE_8021QAZ_TSA_ETS		2
#define IEEE_8021QAZ_TSA_VENDOR		255

/* This structure contains the IEEE 802.1Qaz ETS managed object
 *
 * @willing: willing bit in ETS configuration TLV
 * @ets_cap: indicates supported capacity of ets feature
 * @cbs: credit based shaper ets algorithm supported
 * @tc_tx_bw: tc tx bandwidth indexed by traffic class
 * @tc_rx_bw: tc rx bandwidth indexed by traffic class
 * @tc_tsa: TSA Assignment table, indexed by traffic class
 * @prio_tc: priority assignment table mapping 8021Qp to traffic class
 * @tc_reco_bw: recommended tc bandwidth indexed by traffic class for TLV
 * @tc_reco_tsa: recommended tc bandwidth indexed by traffic class for TLV
 * @reco_prio_tc: recommended tc tx bandwidth indexed by traffic class for TLV
 *
 * Recommended values are used to set fields in the ETS recommendation TLV
 * with hardware offloaded LLDP.
 *
 * ----
 *  TSA Assignment 8 bit identifiers
 *	0	strict priority
 *	1	credit-based shaper
 *	2	enhanced transmission selection
 *	3-254	reserved
 *	255	vendor specific
 */
struct ieee_ets {
	__u8	willing;
	__u8	ets_cap;
	__u8	cbs;
	__u8	tc_tx_bw[IEEE_8021QAZ_MAX_TCS];
	__u8	tc_rx_bw[IEEE_8021QAZ_MAX_TCS];
	__u8	tc_tsa[IEEE_8021QAZ_MAX_TCS];
	__u8	prio_tc[IEEE_8021QAZ_MAX_TCS];
	__u8	tc_reco_bw[IEEE_8021QAZ_MAX_TCS];
	__u8	tc_reco_tsa[IEEE_8021QAZ_MAX_TCS];
	__u8	reco_prio_tc[IEEE_8021QAZ_MAX_TCS];
};

/* This structure contains rate limit extension to the IEEE 802.1Qaz ETS
 * managed object.
 * Values are 64 bits long and specified in Kbps to enable usage over both
 * slow and very fast networks.
 *
 * @tc_maxrate: maximal tc tx bandwidth indexed by traffic class
 */
struct ieee_maxrate {
	__u64	tc_maxrate[IEEE_8021QAZ_MAX_TCS];
};

/* This structure contains the IEEE 802.1Qaz PFC managed object
 *
 * @pfc_cap: Indicates the number of traffic classes on the local device
 *	     that may simultaneously have PFC enabled.
 * @pfc_en: bitmap indicating pfc enabled traffic classes
 * @mbc: enable macsec bypass capability
 * @delay: the allowance made for a round-trip propagation delay of the
 *	   link in bits.
 * @requests: count of the sent pfc frames
 * @indications: count of the received pfc frames
 */
struct ieee_pfc {
	__u8	pfc_cap;
	__u8	pfc_en;
	__u8	mbc;
	__u16	delay;
	__u64	requests[IEEE_8021QAZ_MAX_TCS];
	__u64	indications[IEEE_8021QAZ_MAX_TCS];
};

/* CEE DCBX std supported values */
#define CEE_DCBX_MAX_PGS	8
#define CEE_DCBX_MAX_PRIO	8

/**
 * struct cee_pg - CEE Priority-Group managed object
 *
 * @willing: willing bit in the PG tlv
 * @error: error bit in the PG tlv
 * @pg_en: enable bit of the PG feature
 * @tcs_supported: number of traffic classes supported
 * @pg_bw: bandwidth percentage for each priority group
 * @prio_pg: priority to PG mapping indexed by priority
 */
struct cee_pg {
	__u8    willing;
	__u8    error;
	__u8    pg_en;
	__u8    tcs_supported;
	__u8    pg_bw[CEE_DCBX_MAX_PGS];
	__u8    prio_pg[CEE_DCBX_MAX_PGS];
};

/**
 * struct cee_pfc - CEE PFC managed object
 *
 * @willing: willing bit in the PFC tlv
 * @error: error bit in the PFC tlv
 * @pfc_en: bitmap indicating pfc enabled traffic classes
 * @tcs_supported: number of traffic classes supported
 */
struct cee_pfc {
	__u8    willing;
	__u8    error;
	__u8    pfc_en;
	__u8    tcs_supported;
};

/* IEEE 802.1Qaz std supported values */
#define IEEE_8021QAZ_APP_SEL_ETHERTYPE	1
#define IEEE_8021QAZ_APP_SEL_STREAM	2
#define IEEE_8021QAZ_APP_SEL_DGRAM	3
#define IEEE_8021QAZ_APP_SEL_ANY	4

/* This structure contains the IEEE 802.1Qaz APP managed object. This
 * object is also used for the CEE std as well. There is no difference
 * between the objects.
 *
 * @selector: protocol identifier type
 * @protocol: protocol of type indicated
 * @priority: 3-bit unsigned integer indicating priority
 *
 * ----
 *  Selector field values
 *	0	Reserved
 *	1	Ethertype
 *	2	Well known port number over TCP or SCTP
 *	3	Well known port number over UDP or DCCP
 *	4	Well known port number over TCP, SCTP, UDP, or DCCP
 *	5-7	Reserved
 */
struct dcb_app {
	__u8	selector;
	__u8	priority;
	__u16	protocol;
};

/**
 * struct dcb_peer_app_info - APP feature information sent by the peer
 *
 * @willing: willing bit in the peer APP tlv
 * @error: error bit in the peer APP tlv
 *
 * In addition to this information the full peer APP tlv also contains
 * a table of 'app_count' APP objects defined above.
 */
struct dcb_peer_app_info {
	__u8	willing;
	__u8	error;
};

struct dcbmsg {
	__u8               dcb_family;
	__u8               cmd;
	__u16              dcb_pad;
};

/**
 * enum dcbnl_commands - supported DCB commands
 *
 * @DCB_CMD_UNDEFINED: unspecified command to catch errors
 * @DCB_CMD_GSTATE: request the state of DCB in the device
 * @DCB_CMD_SSTATE: set the state of DCB in the device
 * @DCB_CMD_PGTX_GCFG: request the priority group configuration for Tx
 * @DCB_CMD_PGTX_SCFG: set the priority group configuration for Tx
 * @DCB_CMD_PGRX_GCFG: request the priority group configuration for Rx
 * @DCB_CMD_PGRX_SCFG: set the priority group configuration for Rx
 * @DCB_CMD_PFC_GCFG: request the priority flow control configuration
 * @DCB_CMD_PFC_SCFG: set the priority flow control configuration
 * @DCB_CMD_SET_ALL: apply all changes to the underlying device
 * @DCB_CMD_GPERM_HWADDR: get the permanent MAC address of the underlying
 *                        device.  Only useful when using bonding.
 * @DCB_CMD_GCAP: request the DCB capabilities of the device
 * @DCB_CMD_GNUMTCS: get the number of traffic classes currently supported
 * @DCB_CMD_SNUMTCS: set the number of traffic classes
 * @DCB_CMD_GBCN: set backward congestion notification configuration
 * @DCB_CMD_SBCN: get backward congestion notification configration.
 * @DCB_CMD_GAPP: get application protocol configuration
 * @DCB_CMD_SAPP: set application protocol configuration
 * @DCB_CMD_IEEE_SET: set IEEE 802.1Qaz configuration
 * @DCB_CMD_IEEE_GET: get IEEE 802.1Qaz configuration
 * @DCB_CMD_GDCBX: get DCBX engine configuration
 * @DCB_CMD_SDCBX: set DCBX engine configuration
 * @DCB_CMD_GFEATCFG: get DCBX features flags
 * @DCB_CMD_SFEATCFG: set DCBX features negotiation flags
 * @DCB_CMD_CEE_GET: get CEE aggregated configuration
 * @DCB_CMD_IEEE_DEL: delete IEEE 802.1Qaz configuration
 */
enum dcbnl_commands {
	DCB_CMD_UNDEFINED,

	DCB_CMD_GSTATE,
	DCB_CMD_SSTATE,

	DCB_CMD_PGTX_GCFG,
	DCB_CMD_PGTX_SCFG,
	DCB_CMD_PGRX_GCFG,
	DCB_CMD_PGRX_SCFG,

	DCB_CMD_PFC_GCFG,
	DCB_CMD_PFC_SCFG,

	DCB_CMD_SET_ALL,

	DCB_CMD_GPERM_HWADDR,

	DCB_CMD_GCAP,

	DCB_CMD_GNUMTCS,
	DCB_CMD_SNUMTCS,

	DCB_CMD_PFC_GSTATE,
	DCB_CMD_PFC_SSTATE,

	DCB_CMD_BCN_GCFG,
	DCB_CMD_BCN_SCFG,

	DCB_CMD_GAPP,
	DCB_CMD_SAPP,

	DCB_CMD_IEEE_SET,
	DCB_CMD_IEEE_GET,

	DCB_CMD_GDCBX,
	DCB_CMD_SDCBX,

	DCB_CMD_GFEATCFG,
	DCB_CMD_SFEATCFG,

	DCB_CMD_CEE_GET,
	DCB_CMD_IEEE_DEL,

	__DCB_CMD_ENUM_MAX,
	DCB_CMD_MAX = __DCB_CMD_ENUM_MAX - 1,
};

/**
 * enum dcbnl_attrs - DCB top-level netlink attributes
 *
 * @DCB_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_ATTR_IFNAME: interface name of the underlying device (NLA_STRING)
 * @DCB_ATTR_STATE: enable state of DCB in the device (NLA_U8)
 * @DCB_ATTR_PFC_STATE: enable state of PFC in the device (NLA_U8)
 * @DCB_ATTR_PFC_CFG: priority flow control configuration (NLA_NESTED)
 * @DCB_ATTR_NUM_TC: number of traffic classes supported in the device (NLA_U8)
 * @DCB_ATTR_PG_CFG: priority group configuration (NLA_NESTED)
 * @DCB_ATTR_SET_ALL: bool to commit changes to hardware or not (NLA_U8)
 * @DCB_ATTR_PERM_HWADDR: MAC address of the physical device (NLA_NESTED)
 * @DCB_ATTR_CAP: DCB capabilities of the device (NLA_NESTED)
 * @DCB_ATTR_NUMTCS: number of traffic classes supported (NLA_NESTED)
 * @DCB_ATTR_BCN: backward congestion notification configuration (NLA_NESTED)
 * @DCB_ATTR_IEEE: IEEE 802.1Qaz supported attributes (NLA_NESTED)
 * @DCB_ATTR_DCBX: DCBX engine configuration in the device (NLA_U8)
 * @DCB_ATTR_FEATCFG: DCBX features flags (NLA_NESTED)
 * @DCB_ATTR_CEE: CEE std supported attributes (NLA_NESTED)
 */
enum dcbnl_attrs {
	DCB_ATTR_UNDEFINED,

	DCB_ATTR_IFNAME,
	DCB_ATTR_STATE,
	DCB_ATTR_PFC_STATE,
	DCB_ATTR_PFC_CFG,
	DCB_ATTR_NUM_TC,
	DCB_ATTR_PG_CFG,
	DCB_ATTR_SET_ALL,
	DCB_ATTR_PERM_HWADDR,
	DCB_ATTR_CAP,
	DCB_ATTR_NUMTCS,
	DCB_ATTR_BCN,
	DCB_ATTR_APP,

	/* IEEE std attributes */
	DCB_ATTR_IEEE,

	DCB_ATTR_DCBX,
	DCB_ATTR_FEATCFG,

	/* CEE nested attributes */
	DCB_ATTR_CEE,

	__DCB_ATTR_ENUM_MAX,
	DCB_ATTR_MAX = __DCB_ATTR_ENUM_MAX - 1,
};

/**
 * enum ieee_attrs - IEEE 802.1Qaz get/set attributes
 *
 * @DCB_ATTR_IEEE_UNSPEC: unspecified
 * @DCB_ATTR_IEEE_ETS: negotiated ETS configuration
 * @DCB_ATTR_IEEE_PFC: negotiated PFC configuration
 * @DCB_ATTR_IEEE_APP_TABLE: negotiated APP configuration
 * @DCB_ATTR_IEEE_PEER_ETS: peer ETS configuration - get only
 * @DCB_ATTR_IEEE_PEER_PFC: peer PFC configuration - get only
 * @DCB_ATTR_IEEE_PEER_APP: peer APP tlv - get only
 */
enum ieee_attrs {
	DCB_ATTR_IEEE_UNSPEC,
	DCB_ATTR_IEEE_ETS,
	DCB_ATTR_IEEE_PFC,
	DCB_ATTR_IEEE_APP_TABLE,
	DCB_ATTR_IEEE_PEER_ETS,
	DCB_ATTR_IEEE_PEER_PFC,
	DCB_ATTR_IEEE_PEER_APP,
	DCB_ATTR_IEEE_MAXRATE,
	__DCB_ATTR_IEEE_MAX
};
#define DCB_ATTR_IEEE_MAX (__DCB_ATTR_IEEE_MAX - 1)

enum ieee_attrs_app {
	DCB_ATTR_IEEE_APP_UNSPEC,
	DCB_ATTR_IEEE_APP,
	__DCB_ATTR_IEEE_APP_MAX
};
#define DCB_ATTR_IEEE_APP_MAX (__DCB_ATTR_IEEE_APP_MAX - 1)

/**
 * enum cee_attrs - CEE DCBX get attributes.
 *
 * @DCB_ATTR_CEE_UNSPEC: unspecified
 * @DCB_ATTR_CEE_PEER_PG: peer PG configuration - get only
 * @DCB_ATTR_CEE_PEER_PFC: peer PFC configuration - get only
 * @DCB_ATTR_CEE_PEER_APP_TABLE: peer APP tlv - get only
 * @DCB_ATTR_CEE_TX_PG: TX PG configuration (DCB_CMD_PGTX_GCFG)
 * @DCB_ATTR_CEE_RX_PG: RX PG configuration (DCB_CMD_PGRX_GCFG)
 * @DCB_ATTR_CEE_PFC: PFC configuration (DCB_CMD_PFC_GCFG)
 * @DCB_ATTR_CEE_APP_TABLE: APP configuration (multi DCB_CMD_GAPP)
 * @DCB_ATTR_CEE_FEAT: DCBX features flags (DCB_CMD_GFEATCFG)
 *
 * An aggregated collection of the cee std negotiated parameters.
 */
enum cee_attrs {
	DCB_ATTR_CEE_UNSPEC,
	DCB_ATTR_CEE_PEER_PG,
	DCB_ATTR_CEE_PEER_PFC,
	DCB_ATTR_CEE_PEER_APP_TABLE,
	DCB_ATTR_CEE_TX_PG,
	DCB_ATTR_CEE_RX_PG,
	DCB_ATTR_CEE_PFC,
	DCB_ATTR_CEE_APP_TABLE,
	DCB_ATTR_CEE_FEAT,
	__DCB_ATTR_CEE_MAX
};
#define DCB_ATTR_CEE_MAX (__DCB_ATTR_CEE_MAX - 1)

enum peer_app_attr {
	DCB_ATTR_CEE_PEER_APP_UNSPEC,
	DCB_ATTR_CEE_PEER_APP_INFO,
	DCB_ATTR_CEE_PEER_APP,
	__DCB_ATTR_CEE_PEER_APP_MAX
};
#define DCB_ATTR_CEE_PEER_APP_MAX (__DCB_ATTR_CEE_PEER_APP_MAX - 1)

enum cee_attrs_app {
	DCB_ATTR_CEE_APP_UNSPEC,
	DCB_ATTR_CEE_APP,
	__DCB_ATTR_CEE_APP_MAX
};
#define DCB_ATTR_CEE_APP_MAX (__DCB_ATTR_CEE_APP_MAX - 1)

/**
 * enum dcbnl_pfc_attrs - DCB Priority Flow Control user priority nested attrs
 *
 * @DCB_PFC_UP_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_PFC_UP_ATTR_0: Priority Flow Control value for User Priority 0 (NLA_U8)
 * @DCB_PFC_UP_ATTR_1: Priority Flow Control value for User Priority 1 (NLA_U8)
 * @DCB_PFC_UP_ATTR_2: Priority Flow Control value for User Priority 2 (NLA_U8)
 * @DCB_PFC_UP_ATTR_3: Priority Flow Control value for User Priority 3 (NLA_U8)
 * @DCB_PFC_UP_ATTR_4: Priority Flow Control value for User Priority 4 (NLA_U8)
 * @DCB_PFC_UP_ATTR_5: Priority Flow Control value for User Priority 5 (NLA_U8)
 * @DCB_PFC_UP_ATTR_6: Priority Flow Control value for User Priority 6 (NLA_U8)
 * @DCB_PFC_UP_ATTR_7: Priority Flow Control value for User Priority 7 (NLA_U8)
 * @DCB_PFC_UP_ATTR_MAX: highest attribute number currently defined
 * @DCB_PFC_UP_ATTR_ALL: apply to all priority flow control attrs (NLA_FLAG)
 *
 */
enum dcbnl_pfc_up_attrs {
	DCB_PFC_UP_ATTR_UNDEFINED,

	DCB_PFC_UP_ATTR_0,
	DCB_PFC_UP_ATTR_1,
	DCB_PFC_UP_ATTR_2,
	DCB_PFC_UP_ATTR_3,
	DCB_PFC_UP_ATTR_4,
	DCB_PFC_UP_ATTR_5,
	DCB_PFC_UP_ATTR_6,
	DCB_PFC_UP_ATTR_7,
	DCB_PFC_UP_ATTR_ALL,

	__DCB_PFC_UP_ATTR_ENUM_MAX,
	DCB_PFC_UP_ATTR_MAX = __DCB_PFC_UP_ATTR_ENUM_MAX - 1,
};

/**
 * enum dcbnl_pg_attrs - DCB Priority Group attributes
 *
 * @DCB_PG_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_PG_ATTR_TC_0: Priority Group Traffic Class 0 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_1: Priority Group Traffic Class 1 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_2: Priority Group Traffic Class 2 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_3: Priority Group Traffic Class 3 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_4: Priority Group Traffic Class 4 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_5: Priority Group Traffic Class 5 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_6: Priority Group Traffic Class 6 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_7: Priority Group Traffic Class 7 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_MAX: highest attribute number currently defined
 * @DCB_PG_ATTR_TC_ALL: apply to all traffic classes (NLA_NESTED)
 * @DCB_PG_ATTR_BW_ID_0: Percent of link bandwidth for Priority Group 0 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_1: Percent of link bandwidth for Priority Group 1 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_2: Percent of link bandwidth for Priority Group 2 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_3: Percent of link bandwidth for Priority Group 3 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_4: Percent of link bandwidth for Priority Group 4 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_5: Percent of link bandwidth for Priority Group 5 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_6: Percent of link bandwidth for Priority Group 6 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_7: Percent of link bandwidth for Priority Group 7 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_MAX: highest attribute number currently defined
 * @DCB_PG_ATTR_BW_ID_ALL: apply to all priority groups (NLA_FLAG)
 *
 */
enum dcbnl_pg_attrs {
	DCB_PG_ATTR_UNDEFINED,

	DCB_PG_ATTR_TC_0,
	DCB_PG_ATTR_TC_1,
	DCB_PG_ATTR_TC_2,
	DCB_PG_ATTR_TC_3,
	DCB_PG_ATTR_TC_4,
	DCB_PG_ATTR_TC_5,
	DCB_PG_ATTR_TC_6,
	DCB_PG_ATTR_TC_7,
	DCB_PG_ATTR_TC_MAX,
	DCB_PG_ATTR_TC_ALL,

	DCB_PG_ATTR_BW_ID_0,
	DCB_PG_ATTR_BW_ID_1,
	DCB_PG_ATTR_BW_ID_2,
	DCB_PG_ATTR_BW_ID_3,
	DCB_PG_ATTR_BW_ID_4,
	DCB_PG_ATTR_BW_ID_5,
	DCB_PG_ATTR_BW_ID_6,
	DCB_PG_ATTR_BW_ID_7,
	DCB_PG_ATTR_BW_ID_MAX,
	DCB_PG_ATTR_BW_ID_ALL,

	__DCB_PG_ATTR_ENUM_MAX,
	DCB_PG_ATTR_MAX = __DCB_PG_ATTR_ENUM_MAX - 1,
};

/**
 * enum dcbnl_tc_attrs - DCB Traffic Class attributes
 *
 * @DCB_TC_ATTR_PARAM_UNDEFINED: unspecified attribute to catch errors
 * @DCB_TC_ATTR_PARAM_PGID: (NLA_U8) Priority group the traffic class belongs to
 *                          Valid values are:  0-7
 * @DCB_TC_ATTR_PARAM_UP_MAPPING: (NLA_U8) Traffic class to user priority map
 *                                Some devices may not support changing the
 *                                user priority map of a TC.
 * @DCB_TC_ATTR_PARAM_STRICT_PRIO: (NLA_U8) Strict priority setting
 *                                 0 - none
 *                                 1 - group strict
 *                                 2 - link strict
 * @DCB_TC_ATTR_PARAM_BW_PCT: optional - (NLA_U8) If supported by the device and
 *                            not configured to use link strict priority,
 *                            this is the percentage of bandwidth of the
 *                            priority group this traffic class belongs to
 * @DCB_TC_ATTR_PARAM_ALL: (NLA_FLAG) all traffic class parameters
 *
 */
enum dcbnl_tc_attrs {
	DCB_TC_ATTR_PARAM_UNDEFINED,

	DCB_TC_ATTR_PARAM_PGID,
	DCB_TC_ATTR_PARAM_UP_MAPPING,
	DCB_TC_ATTR_PARAM_STRICT_PRIO,
	DCB_TC_ATTR_PARAM_BW_PCT,
	DCB_TC_ATTR_PARAM_ALL,

	__DCB_TC_ATTR_PARAM_ENUM_MAX,
	DCB_TC_ATTR_PARAM_MAX = __DCB_TC_ATTR_PARAM_ENUM_MAX - 1,
};

/**
 * enum dcbnl_cap_attrs - DCB Capability attributes
 *
 * @DCB_CAP_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_CAP_ATTR_ALL: (NLA_FLAG) all capability parameters
 * @DCB_CAP_ATTR_PG: (NLA_U8) device supports Priority Groups
 * @DCB_CAP_ATTR_PFC: (NLA_U8) device supports Priority Flow Control
 * @DCB_CAP_ATTR_UP2TC: (NLA_U8) device supports user priority to
 *                               traffic class mapping
 * @DCB_CAP_ATTR_PG_TCS: (NLA_U8) bitmap where each bit represents a
 *                                number of traffic classes the device
 *                                can be configured to use for Priority Groups
 * @DCB_CAP_ATTR_PFC_TCS: (NLA_U8) bitmap where each bit represents a
 *                                 number of traffic classes the device can be
 *                                 configured to use for Priority Flow Control
 * @DCB_CAP_ATTR_GSP: (NLA_U8) device supports group strict priority
 * @DCB_CAP_ATTR_BCN: (NLA_U8) device supports Backwards Congestion
 *                             Notification
 * @DCB_CAP_ATTR_DCBX: (NLA_U8) device supports DCBX engine
 *
 */
enum dcbnl_cap_attrs {
	DCB_CAP_ATTR_UNDEFINED,
	DCB_CAP_ATTR_ALL,
	DCB_CAP_ATTR_PG,
	DCB_CAP_ATTR_PFC,
	DCB_CAP_ATTR_UP2TC,
	DCB_CAP_ATTR_PG_TCS,
	DCB_CAP_ATTR_PFC_TCS,
	DCB_CAP_ATTR_GSP,
	DCB_CAP_ATTR_BCN,
	DCB_CAP_ATTR_DCBX,

	__DCB_CAP_ATTR_ENUM_MAX,
	DCB_CAP_ATTR_MAX = __DCB_CAP_ATTR_ENUM_MAX - 1,
};

/**
 * DCBX capability flags
 *
 * @DCB_CAP_DCBX_HOST: DCBX negotiation is performed by the host LLDP agent.
 *                     'set' routines are used to configure the device with
 *                     the negotiated parameters
 *
 * @DCB_CAP_DCBX_LLD_MANAGED: DCBX negotiation is not performed in the host but
 *                            by another entity
 *                            'get' routines are used to retrieve the
 *                            negotiated parameters
 *                            'set' routines can be used to set the initial
 *                            negotiation configuration
 *
 * @DCB_CAP_DCBX_VER_CEE: for a non-host DCBX engine, indicates the engine
 *                        supports the CEE protocol flavor
 *
 * @DCB_CAP_DCBX_VER_IEEE: for a non-host DCBX engine, indicates the engine
 *                         supports the IEEE protocol flavor
 *
 * @DCB_CAP_DCBX_STATIC: for a non-host DCBX engine, indicates the engine
 *                       supports static configuration (i.e no actual
 *                       negotiation is performed negotiated parameters equal
 *                       the initial configuration)
 *
 */
#define DCB_CAP_DCBX_HOST		0x01
#define DCB_CAP_DCBX_LLD_MANAGED	0x02
#define DCB_CAP_DCBX_VER_CEE		0x04
#define DCB_CAP_DCBX_VER_IEEE		0x08
#define DCB_CAP_DCBX_STATIC		0x10

/**
 * enum dcbnl_numtcs_attrs - number of traffic classes
 *
 * @DCB_NUMTCS_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_NUMTCS_ATTR_ALL: (NLA_FLAG) all traffic class attributes
 * @DCB_NUMTCS_ATTR_PG: (NLA_U8) number of traffic classes used for
 *                               priority groups
 * @DCB_NUMTCS_ATTR_PFC: (NLA_U8) number of traffic classes which can
 *                                support priority flow control
 */
enum dcbnl_numtcs_attrs {
	DCB_NUMTCS_ATTR_UNDEFINED,
	DCB_NUMTCS_ATTR_ALL,
	DCB_NUMTCS_ATTR_PG,
	DCB_NUMTCS_ATTR_PFC,

	__DCB_NUMTCS_ATTR_ENUM_MAX,
	DCB_NUMTCS_ATTR_MAX = __DCB_NUMTCS_ATTR_ENUM_MAX - 1,
};

enum dcbnl_bcn_attrs{
	DCB_BCN_ATTR_UNDEFINED = 0,

	DCB_BCN_ATTR_RP_0,
	DCB_BCN_ATTR_RP_1,
	DCB_BCN_ATTR_RP_2,
	DCB_BCN_ATTR_RP_3,
	DCB_BCN_ATTR_RP_4,
	DCB_BCN_ATTR_RP_5,
	DCB_BCN_ATTR_RP_6,
	DCB_BCN_ATTR_RP_7,
	DCB_BCN_ATTR_RP_ALL,

	DCB_BCN_ATTR_BCNA_0,
	DCB_BCN_ATTR_BCNA_1,
	DCB_BCN_ATTR_ALPHA,
	DCB_BCN_ATTR_BETA,
	DCB_BCN_ATTR_GD,
	DCB_BCN_ATTR_GI,
	DCB_BCN_ATTR_TMAX,
	DCB_BCN_ATTR_TD,
	DCB_BCN_ATTR_RMIN,
	DCB_BCN_ATTR_W,
	DCB_BCN_ATTR_RD,
	DCB_BCN_ATTR_RU,
	DCB_BCN_ATTR_WRTT,
	DCB_BCN_ATTR_RI,
	DCB_BCN_ATTR_C,
	DCB_BCN_ATTR_ALL,

	__DCB_BCN_ATTR_ENUM_MAX,
	DCB_BCN_ATTR_MAX = __DCB_BCN_ATTR_ENUM_MAX - 1,
};

/**
 * enum dcb_general_attr_values - general DCB attribute values
 *
 * @DCB_ATTR_UNDEFINED: value used to indicate an attribute is not supported
 *
 */
enum dcb_general_attr_values {
	DCB_ATTR_VALUE_UNDEFINED = 0xff
};

#define DCB_APP_IDTYPE_ETHTYPE	0x00
#define DCB_APP_IDTYPE_PORTNUM	0x01
enum dcbnl_app_attrs {
	DCB_APP_ATTR_UNDEFINED,

	DCB_APP_ATTR_IDTYPE,
	DCB_APP_ATTR_ID,
	DCB_APP_ATTR_PRIORITY,

	__DCB_APP_ATTR_ENUM_MAX,
	DCB_APP_ATTR_MAX = __DCB_APP_ATTR_ENUM_MAX - 1,
};

/**
 * enum dcbnl_featcfg_attrs - features conifiguration flags
 *
 * @DCB_FEATCFG_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_FEATCFG_ATTR_ALL: (NLA_FLAG) all features configuration attributes
 * @DCB_FEATCFG_ATTR_PG: (NLA_U8) configuration flags for priority groups
 * @DCB_FEATCFG_ATTR_PFC: (NLA_U8) configuration flags for priority
 *                                 flow control
 * @DCB_FEATCFG_ATTR_APP: (NLA_U8) configuration flags for application TLV
 *
 */
#define DCB_FEATCFG_ERROR	0x01	/* error in feature resolution */
#define DCB_FEATCFG_ENABLE	0x02	/* enable feature */
#define DCB_FEATCFG_WILLING	0x04	/* feature is willing */
#define DCB_FEATCFG_ADVERTISE	0x08	/* advertise feature */
enum dcbnl_featcfg_attrs {
	DCB_FEATCFG_ATTR_UNDEFINED,
	DCB_FEATCFG_ATTR_ALL,
	DCB_FEATCFG_ATTR_PG,
	DCB_FEATCFG_ATTR_PFC,
	DCB_FEATCFG_ATTR_APP,

	__DCB_FEATCFG_ATTR_ENUM_MAX,
	DCB_FEATCFG_ATTR_MAX = __DCB_FEATCFG_ATTR_ENUM_MAX - 1,
};

#endif /* __LINUX_DCBNL_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef _LINUX_DCCP_H
#define _LINUX_DCCP_H

#include <linux/types.h>
#include <asm/byteorder.h>

/**
 * struct dccp_hdr - generic part of DCCP packet header
 *
 * @dccph_sport - Relevant port on the endpoint that sent this packet
 * @dccph_dport - Relevant port on the other endpoint
 * @dccph_doff - Data Offset from the start of the DCCP header, in 32-bit words
 * @dccph_ccval - Used by the HC-Sender CCID
 * @dccph_cscov - Parts of the packet that are covered by the Checksum field
 * @dccph_checksum - Internet checksum, depends on dccph_cscov
 * @dccph_x - 0 = 24 bit sequence number, 1 = 48
 * @dccph_type - packet type, see DCCP_PKT_ prefixed macros
 * @dccph_seq - sequence number high or low order 24 bits, depends on dccph_x
 */
struct dccp_hdr {
	__be16	dccph_sport,
		dccph_dport;
	__u8	dccph_doff;
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u8	dccph_cscov:4,
		dccph_ccval:4;
#elif defined(__BIG_ENDIAN_BITFIELD)
	__u8	dccph_ccval:4,
		dccph_cscov:4;
#else
#error  "Adjust your <asm/byteorder.h> defines"
#endif
	__sum16	dccph_checksum;
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u8	dccph_x:1,
		dccph_type:4,
		dccph_reserved:3;
#elif defined(__BIG_ENDIAN_BITFIELD)
	__u8	dccph_reserved:3,
		dccph_type:4,
		dccph_x:1;
#else
#error  "Adjust your <asm/byteorder.h> defines"
#endif
	__u8	dccph_seq2;
	__be16	dccph_seq;
};

/**
 * struct dccp_hdr_ext - the low bits of a 48 bit seq packet
 *
 * @dccph_seq_low - low 24 bits of a 48 bit seq packet
 */
struct dccp_hdr_ext {
	__be32	dccph_seq_low;
};

/**
 * struct dccp_hdr_request - Connection initiation request header
 *
 * @dccph_req_service - Service to which the client app wants to connect
 */
struct dccp_hdr_request {
	__be32	dccph_req_service;
};
/**
 * struct dccp_hdr_ack_bits - acknowledgment bits common to most packets
 *
 * @dccph_resp_ack_nr_high - 48 bit ack number high order bits, contains GSR
 * @dccph_resp_ack_nr_low - 48 bit ack number low order bits, contains GSR
 */
struct dccp_hdr_ack_bits {
	__be16	dccph_reserved1;
	__be16	dccph_ack_nr_high;
	__be32	dccph_ack_nr_low;
};
/**
 * struct dccp_hdr_response - Connection initiation response header
 *
 * @dccph_resp_ack - 48 bit Acknowledgment Number Subheader (5.3)
 * @dccph_resp_service - Echoes the Service Code on a received DCCP-Request
 */
struct dccp_hdr_response {
	struct dccp_hdr_ack_bits	dccph_resp_ack;
	__be32				dccph_resp_service;
};

/**
 * struct dccp_hdr_reset - Unconditionally shut down a connection
 *
 * @dccph_reset_ack - 48 bit Acknowledgment Number Subheader (5.6)
 * @dccph_reset_code - one of %dccp_reset_codes
 * @dccph_reset_data - the Data 1 ... Data 3 fields from 5.6
 */
struct dccp_hdr_reset {
	struct dccp_hdr_ack_bits	dccph_reset_ack;
	__u8				dccph_reset_code,
					dccph_reset_data[3];
};

enum dccp_pkt_type {
	DCCP_PKT_REQUEST = 0,
	DCCP_PKT_RESPONSE,
	DCCP_PKT_DATA,
	DCCP_PKT_ACK,
	DCCP_PKT_DATAACK,
	DCCP_PKT_CLOSEREQ,
	DCCP_PKT_CLOSE,
	DCCP_PKT_RESET,
	DCCP_PKT_SYNC,
	DCCP_PKT_SYNCACK,
	DCCP_PKT_INVALID,
};

#define DCCP_NR_PKT_TYPES DCCP_PKT_INVALID

static __inline__ unsigned int dccp_packet_hdr_len(const __u8 type)
{
	if (type == DCCP_PKT_DATA)
		return 0;
	if (type == DCCP_PKT_DATAACK	||
	    type == DCCP_PKT_ACK	||
	    type == DCCP_PKT_SYNC	||
	    type == DCCP_PKT_SYNCACK	||
	    type == DCCP_PKT_CLOSE	||
	    type == DCCP_PKT_CLOSEREQ)
		return sizeof(struct dccp_hdr_ack_bits);
	if (type == DCCP_PKT_REQUEST)
		return sizeof(struct dccp_hdr_request);
	if (type == DCCP_PKT_RESPONSE)
		return sizeof(struct dccp_hdr_response);
	return sizeof(struct dccp_hdr_reset);
}
enum dccp_reset_codes {
	DCCP_RESET_CODE_UNSPECIFIED = 0,
	DCCP_RESET_CODE_CLOSED,
	DCCP_RESET_CODE_ABORTED,
	DCCP_RESET_CODE_NO_CONNECTION,
	DCCP_RESET_CODE_PACKET_ERROR,
	DCCP_RESET_CODE_OPTION_ERROR,
	DCCP_RESET_CODE_MANDATORY_ERROR,
	DCCP_RESET_CODE_CONNECTION_REFUSED,
	DCCP_RESET_CODE_BAD_SERVICE_CODE,
	DCCP_RESET_CODE_TOO_BUSY,
	DCCP_RESET_CODE_BAD_INIT_COOKIE,
	DCCP_RESET_CODE_AGGRESSION_PENALTY,

	DCCP_MAX_RESET_CODES		/* Leave at the end!  */
};

/* DCCP options */
enum {
	DCCPO_PADDING = 0,
	DCCPO_MANDATORY = 1,
	DCCPO_MIN_RESERVED = 3,
	DCCPO_MAX_RESERVED = 31,
	DCCPO_CHANGE_L = 32,
	DCCPO_CONFIRM_L = 33,
	DCCPO_CHANGE_R = 34,
	DCCPO_CONFIRM_R = 35,
	DCCPO_NDP_COUNT = 37,
	DCCPO_ACK_VECTOR_0 = 38,
	DCCPO_ACK_VECTOR_1 = 39,
	DCCPO_TIMESTAMP = 41,
	DCCPO_TIMESTAMP_ECHO = 42,
	DCCPO_ELAPSED_TIME = 43,
	DCCPO_MAX = 45,
	DCCPO_MIN_RX_CCID_SPECIFIC = 128,	/* from sender to receiver */
	DCCPO_MAX_RX_CCID_SPECIFIC = 191,
	DCCPO_MIN_TX_CCID_SPECIFIC = 192,	/* from receiver to sender */
	DCCPO_MAX_TX_CCID_SPECIFIC = 255,
};
/* maximum size of a single TLV-encoded DCCP option (sans type/len bytes) */
#define DCCP_SINGLE_OPT_MAXLEN	253

/* DCCP CCIDS */
enum {
	DCCPC_CCID2 = 2,
	DCCPC_CCID3 = 3,
};

/* DCCP features (RFC 4340 section 6.4) */
enum dccp_feature_numbers {
	DCCPF_RESERVED = 0,
	DCCPF_CCID = 1,
	DCCPF_SHORT_SEQNOS = 2,
	DCCPF_SEQUENCE_WINDOW = 3,
	DCCPF_ECN_INCAPABLE = 4,
	DCCPF_ACK_RATIO = 5,
	DCCPF_SEND_ACK_VECTOR = 6,
	DCCPF_SEND_NDP_COUNT = 7,
	DCCPF_MIN_CSUM_COVER = 8,
	DCCPF_DATA_CHECKSUM = 9,
	/* 10-127 reserved */
	DCCPF_MIN_CCID_SPECIFIC = 128,
	DCCPF_SEND_LEV_RATE = 192,	/* RFC 4342, sec. 8.4 */
	DCCPF_MAX_CCID_SPECIFIC = 255,
};

/* DCCP socket control message types for cmsg */
enum dccp_cmsg_type {
	DCCP_SCM_PRIORITY = 1,
	DCCP_SCM_QPOLICY_MAX = 0xFFFF,
	/* ^-- Up to here reserved exclusively for qpolicy parameters */
	DCCP_SCM_MAX
};

/* DCCP priorities for outgoing/queued packets */
enum dccp_packet_dequeueing_policy {
	DCCPQ_POLICY_SIMPLE,
	DCCPQ_POLICY_PRIO,
	DCCPQ_POLICY_MAX
};

/* DCCP socket options */
#define DCCP_SOCKOPT_PACKET_SIZE	1 /* XXX deprecated, without effect */
#define DCCP_SOCKOPT_SERVICE		2
#define DCCP_SOCKOPT_CHANGE_L		3
#define DCCP_SOCKOPT_CHANGE_R		4
#define DCCP_SOCKOPT_GET_CUR_MPS	5
#define DCCP_SOCKOPT_SERVER_TIMEWAIT	6
#define DCCP_SOCKOPT_SEND_CSCOV		10
#define DCCP_SOCKOPT_RECV_CSCOV		11
#define DCCP_SOCKOPT_AVAILABLE_CCIDS	12
#define DCCP_SOCKOPT_CCID		13
#define DCCP_SOCKOPT_TX_CCID		14
#define DCCP_SOCKOPT_RX_CCID		15
#define DCCP_SOCKOPT_QPOLICY_ID		16
#define DCCP_SOCKOPT_QPOLICY_TXQLEN	17
#define DCCP_SOCKOPT_CCID_RX_INFO	128
#define DCCP_SOCKOPT_CCID_TX_INFO	192

/* maximum number of services provided on the same listening port */
#define DCCP_SERVICE_LIST_MAX_LEN      32


#endif /* _LINUX_DCCP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /******************************************************************************
*******************************************************************************
**
**  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.
**  Copyright (C) 2004-2011 Red Hat, Inc.  All rights reserved.
**
**  This copyrighted material is made available to anyone wishing to use,
**  modify, copy, or redistribute it subject to the terms and conditions
**  of the GNU General Public License v.2.
**
*******************************************************************************
******************************************************************************/

#ifndef __DLM_DOT_H__
#define __DLM_DOT_H__

/*
 * Interface to Distributed Lock Manager (DLM)
 * routines and structures to use DLM lockspaces
 */

/* Lock levels and flags are here */
#include <linux/dlmconstants.h>
#include <linux/types.h>

typedef void dlm_lockspace_t;

/*
 * Lock status block
 *
 * Use this structure to specify the contents of the lock value block.  For a
 * conversion request, this structure is used to specify the lock ID of the
 * lock.  DLM writes the status of the lock request and the lock ID assigned
 * to the request in the lock status block.
 *
 * sb_lkid: the returned lock ID.  It is set on new (non-conversion) requests.
 * It is available when dlm_lock returns.
 *
 * sb_lvbptr: saves or returns the contents of the lock's LVB according to rules
 * shown for the DLM_LKF_VALBLK flag.
 *
 * sb_flags: DLM_SBF_DEMOTED is returned if in the process of promoting a lock,
 * it was first demoted to NL to avoid conversion deadlock.
 * DLM_SBF_VALNOTVALID is returned if the resource's LVB is marked invalid.
 *
 * sb_status: the returned status of the lock request set prior to AST
 * execution.  Possible return values:
 *
 * 0 if lock request was successful
 * -EAGAIN if request would block and is flagged DLM_LKF_NOQUEUE
 * -DLM_EUNLOCK if unlock request was successful
 * -DLM_ECANCEL if a cancel completed successfully
 * -EDEADLK if a deadlock was detected
 * -ETIMEDOUT if the lock request was canceled due to a timeout
 */

#define DLM_SBF_DEMOTED		0x01
#define DLM_SBF_VALNOTVALID	0x02
#define DLM_SBF_ALTMODE		0x04

struct dlm_lksb {
	int 	 sb_status;
	__u32	 sb_lkid;
	char 	 sb_flags;
	char *	 sb_lvbptr;
};

/* dlm_new_lockspace() flags */

#define DLM_LSFL_TIMEWARN	0x00000002
#define DLM_LSFL_FS     	0x00000004
#define DLM_LSFL_NEWEXCL     	0x00000008


#endif /* __DLM_DOT_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /******************************************************************************
*******************************************************************************
**
**  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.
**  Copyright (C) 2004-2007 Red Hat, Inc.  All rights reserved.
**
**  This copyrighted material is made available to anyone wishing to use,
**  modify, copy, or redistribute it subject to the terms and conditions
**  of the GNU General Public License v.2.
**
*******************************************************************************
******************************************************************************/

#ifndef _LINUX_DLM_DEVICE_H
#define _LINUX_DLM_DEVICE_H

/* This is the device interface for dlm, most users will use a library
 * interface.
 */

#include <linux/dlm.h>
#include <linux/types.h>

#define DLM_USER_LVB_LEN	32

/* Version of the device interface */
#define DLM_DEVICE_VERSION_MAJOR 6
#define DLM_DEVICE_VERSION_MINOR 0
#define DLM_DEVICE_VERSION_PATCH 1

/* struct passed to the lock write */
struct dlm_lock_params {
	__u8 mode;
	__u8 namelen;
	__u16 unused;
	__u32 flags;
	__u32 lkid;
	__u32 parent;
	__u64 xid;
	__u64 timeout;
	void *castparam;
	void *castaddr;
	void *bastparam;
	void *bastaddr;
	struct dlm_lksb *lksb;
	char lvb[DLM_USER_LVB_LEN];
	char name[0];
};

struct dlm_lspace_params {
	__u32 flags;
	__u32 minor;
	char name[0];
};

struct dlm_purge_params {
	__u32 nodeid;
	__u32 pid;
};

struct dlm_write_request {
	__u32 version[3];
	__u8 cmd;
	__u8 is64bit;
	__u8 unused[2];

	union  {
		struct dlm_lock_params   lock;
		struct dlm_lspace_params lspace;
		struct dlm_purge_params  purge;
	} i;
};

struct dlm_device_version {
	__u32 version[3];
};

/* struct read from the "device" fd,
   consists mainly of userspace pointers for the library to use */

struct dlm_lock_result {
	__u32 version[3];
	__u32 length;
	void * user_astaddr;
	void * user_astparam;
	struct dlm_lksb * user_lksb;
	struct dlm_lksb lksb;
	__u8 bast_mode;
	__u8 unused[3];
	/* Offsets may be zero if no data is present */
	__u32 lvb_offset;
};

/* Commands passed to the device */
#define DLM_USER_LOCK         1
#define DLM_USER_UNLOCK       2
#define DLM_USER_QUERY        3
#define DLM_USER_CREATE_LOCKSPACE  4
#define DLM_USER_REMOVE_LOCKSPACE  5
#define DLM_USER_PURGE        6
#define DLM_USER_DEADLOCK     7

/* Lockspace flags */
#define DLM_USER_LSFLG_AUTOFREE   1
#define DLM_USER_LSFLG_FORCEFREE  2

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * Copyright (C) 2007 Red Hat, Inc.  All rights reserved.
 *
 * This copyrighted material is made available to anyone wishing to use,
 * modify, copy, or redistribute it subject to the terms and conditions
 * of the GNU General Public License v.2.
 */

#ifndef _DLM_NETLINK_H
#define _DLM_NETLINK_H

#include <linux/types.h>

enum {
	DLM_STATUS_WAITING = 1,
	DLM_STATUS_GRANTED = 2,
	DLM_STATUS_CONVERT = 3,
};

#define DLM_LOCK_DATA_VERSION 1

struct dlm_lock_data {
	__u16 version;
	__u32 lockspace_id;
	int nodeid;
	int ownpid;
	__u32 id;
	__u32 remid;
	__u64 xid;
	__s8 status;
	__s8 grmode;
	__s8 rqmode;
	unsigned long timestamp;
	int resource_namelen;
	char resource_name[DLM_RESNAME_MAXLEN];
};

enum {
	DLM_CMD_UNSPEC = 0,
	DLM_CMD_HELLO,		/* user->kernel */
	DLM_CMD_TIMEOUT,	/* kernel->user */
	__DLM_CMD_MAX,
};

#define DLM_CMD_MAX (__DLM_CMD_MAX - 1)

enum {
	DLM_TYPE_UNSPEC = 0,
	DLM_TYPE_LOCK,
	__DLM_TYPE_MAX,
};

#define DLM_TYPE_MAX (__DLM_TYPE_MAX - 1)

#define DLM_GENL_VERSION 0x1
#define DLM_GENL_NAME "DLM"

#endif /* _DLM_NETLINK_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * Copyright (C) 2005-2008 Red Hat, Inc.  All rights reserved.
 *
 * This copyrighted material is made available to anyone wishing to use,
 * modify, copy, or redistribute it subject to the terms and conditions
 * of the GNU General Public License v.2.
 */

#ifndef __DLM_PLOCK_DOT_H__
#define __DLM_PLOCK_DOT_H__

#include <linux/types.h>

#define DLM_PLOCK_MISC_NAME		"dlm_plock"

#define DLM_PLOCK_VERSION_MAJOR	1
#define DLM_PLOCK_VERSION_MINOR	2
#define DLM_PLOCK_VERSION_PATCH	0

enum {
	DLM_PLOCK_OP_LOCK = 1,
	DLM_PLOCK_OP_UNLOCK,
	DLM_PLOCK_OP_GET,
};

#define DLM_PLOCK_FL_CLOSE 1

struct dlm_plock_info {
	__u32 version[3];
	__u8 optype;
	__u8 ex;
	__u8 wait;
	__u8 flags;
	__u32 pid;
	__s32 nodeid;
	__s32 rv;
	__u32 fsid;
	__u64 number;
	__u64 start;
	__u64 end;
	__u64 owner;
};


#endif /* __DLM_PLOCK_DOT_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /******************************************************************************
*******************************************************************************
**
**  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.
**  Copyright (C) 2004-2007 Red Hat, Inc.  All rights reserved.
**
**  This copyrighted material is made available to anyone wishing to use,
**  modify, copy, or redistribute it subject to the terms and conditions
**  of the GNU General Public License v.2.
**
*******************************************************************************
******************************************************************************/

#ifndef __DLMCONSTANTS_DOT_H__
#define __DLMCONSTANTS_DOT_H__

/*
 * Constants used by DLM interface.
 */

#define DLM_LOCKSPACE_LEN       64
#define DLM_RESNAME_MAXLEN      64


/*
 * Lock Modes
 */

#define DLM_LOCK_IV		(-1)	/* invalid */
#define DLM_LOCK_NL		0	/* null */
#define DLM_LOCK_CR		1	/* concurrent read */
#define DLM_LOCK_CW		2	/* concurrent write */
#define DLM_LOCK_PR		3	/* protected read */
#define DLM_LOCK_PW		4	/* protected write */
#define DLM_LOCK_EX		5	/* exclusive */


/*
 * Flags to dlm_lock
 *
 * DLM_LKF_NOQUEUE
 *
 * Do not queue the lock request on the wait queue if it cannot be granted
 * immediately.  If the lock cannot be granted because of this flag, DLM will
 * either return -EAGAIN from the dlm_lock call or will return 0 from
 * dlm_lock and -EAGAIN in the lock status block when the AST is executed.
 *
 * DLM_LKF_CANCEL
 *
 * Used to cancel a pending lock request or conversion.  A converting lock is
 * returned to its previously granted mode.
 *
 * DLM_LKF_CONVERT
 *
 * Indicates a lock conversion request.  For conversions the name and namelen
 * are ignored and the lock ID in the LKSB is used to identify the lock.
 *
 * DLM_LKF_VALBLK
 *
 * Requests DLM to return the current contents of the lock value block in the
 * lock status block.  When this flag is set in a lock conversion from PW or EX
 * modes, DLM assigns the value specified in the lock status block to the lock
 * value block of the lock resource.  The LVB is a DLM_LVB_LEN size array
 * containing application-specific information.
 *
 * DLM_LKF_QUECVT
 *
 * Force a conversion request to be queued, even if it is compatible with
 * the granted modes of other locks on the same resource.
 *
 * DLM_LKF_IVVALBLK
 *
 * Invalidate the lock value block.
 *
 * DLM_LKF_CONVDEADLK
 *
 * Allows the dlm to resolve conversion deadlocks internally by demoting the
 * granted mode of a converting lock to NL.  The DLM_SBF_DEMOTED flag is
 * returned for a conversion that's been effected by this.
 *
 * DLM_LKF_PERSISTENT
 *
 * Only relevant to locks originating in userspace.  A persistent lock will not
 * be removed if the process holding the lock exits.
 *
 * DLM_LKF_NODLCKWT
 *
 * Do not cancel the lock if it gets into conversion deadlock.
 * Exclude this lock from being monitored due to DLM_LSFL_TIMEWARN.
 *
 * DLM_LKF_NODLCKBLK
 *
 * net yet implemented
 *
 * DLM_LKF_EXPEDITE
 *
 * Used only with new requests for NL mode locks.  Tells the lock manager
 * to grant the lock, ignoring other locks in convert and wait queues.
 *
 * DLM_LKF_NOQUEUEBAST
 *
 * Send blocking AST's before returning -EAGAIN to the caller.  It is only
 * used along with the NOQUEUE flag.  Blocking AST's are not sent for failed
 * NOQUEUE requests otherwise.
 *
 * DLM_LKF_HEADQUE
 *
 * Add a lock to the head of the convert or wait queue rather than the tail.
 *
 * DLM_LKF_NOORDER
 *
 * Disregard the standard grant order rules and grant a lock as soon as it
 * is compatible with other granted locks.
 *
 * DLM_LKF_ORPHAN
 *
 * not yet implemented
 *
 * DLM_LKF_ALTPR
 *
 * If the requested mode cannot be granted immediately, try to grant the lock
 * in PR mode instead.  If this alternate mode is granted instead of the
 * requested mode, DLM_SBF_ALTMODE is returned in the lksb.
 *
 * DLM_LKF_ALTCW
 *
 * The same as ALTPR, but the alternate mode is CW.
 *
 * DLM_LKF_FORCEUNLOCK
 *
 * Unlock the lock even if it is converting or waiting or has sublocks.
 * Only really for use by the userland device.c code.
 *
 */

#define DLM_LKF_NOQUEUE		0x00000001
#define DLM_LKF_CANCEL		0x00000002
#define DLM_LKF_CONVERT		0x00000004
#define DLM_LKF_VALBLK		0x00000008
#define DLM_LKF_QUECVT		0x00000010
#define DLM_LKF_IVVALBLK	0x00000020
#define DLM_LKF_CONVDEADLK	0x00000040
#define DLM_LKF_PERSISTENT	0x00000080
#define DLM_LKF_NODLCKWT	0x00000100
#define DLM_LKF_NODLCKBLK	0x00000200
#define DLM_LKF_EXPEDITE	0x00000400
#define DLM_LKF_NOQUEUEBAST	0x00000800
#define DLM_LKF_HEADQUE		0x00001000
#define DLM_LKF_NOORDER		0x00002000
#define DLM_LKF_ORPHAN		0x00004000
#define DLM_LKF_ALTPR		0x00008000
#define DLM_LKF_ALTCW		0x00010000
#define DLM_LKF_FORCEUNLOCK	0x00020000
#define DLM_LKF_TIMEOUT		0x00040000

/*
 * Some return codes that are not in errno.h
 */

#define DLM_ECANCEL		0x10001
#define DLM_EUNLOCK		0x10002

#endif  /* __DLMCONSTANTS_DOT_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * Copyright (C) 2001 - 2003 Sistina Software (UK) Limited.
 * Copyright (C) 2004 - 2009 Red Hat, Inc. All rights reserved.
 *
 * This file is released under the LGPL.
 */

#ifndef _LINUX_DM_IOCTL_V4_H
#define _LINUX_DM_IOCTL_V4_H

#include <linux/types.h>

#define DM_DIR "mapper"		/* Slashes not supported */
#define DM_CONTROL_NODE "control"
#define DM_MAX_TYPE_NAME 16
#define DM_NAME_LEN 128
#define DM_UUID_LEN 129

/*
 * A traditional ioctl interface for the device mapper.
 *
 * Each device can have two tables associated with it, an
 * 'active' table which is the one currently used by io passing
 * through the device, and an 'inactive' one which is a table
 * that is being prepared as a replacement for the 'active' one.
 *
 * DM_VERSION:
 * Just get the version information for the ioctl interface.
 *
 * DM_REMOVE_ALL:
 * Remove all dm devices, destroy all tables.  Only really used
 * for debug.
 *
 * DM_LIST_DEVICES:
 * Get a list of all the dm device names.
 *
 * DM_DEV_CREATE:
 * Create a new device, neither the 'active' or 'inactive' table
 * slots will be filled.  The device will be in suspended state
 * after creation, however any io to the device will get errored
 * since it will be out-of-bounds.
 *
 * DM_DEV_REMOVE:
 * Remove a device, destroy any tables.
 *
 * DM_DEV_RENAME:
 * Rename a device or set its uuid if none was previously supplied.
 *
 * DM_SUSPEND:
 * This performs both suspend and resume, depending which flag is
 * passed in.
 * Suspend: This command will not return until all pending io to
 * the device has completed.  Further io will be deferred until
 * the device is resumed.
 * Resume: It is no longer an error to issue this command on an
 * unsuspended device.  If a table is present in the 'inactive'
 * slot, it will be moved to the active slot, then the old table
 * from the active slot will be _destroyed_.  Finally the device
 * is resumed.
 *
 * DM_DEV_STATUS:
 * Retrieves the status for the table in the 'active' slot.
 *
 * DM_DEV_WAIT:
 * Wait for a significant event to occur to the device.  This
 * could either be caused by an event triggered by one of the
 * targets of the table in the 'active' slot, or a table change.
 *
 * DM_TABLE_LOAD:
 * Load a table into the 'inactive' slot for the device.  The
 * device does _not_ need to be suspended prior to this command.
 *
 * DM_TABLE_CLEAR:
 * Destroy any table in the 'inactive' slot (ie. abort).
 *
 * DM_TABLE_DEPS:
 * Return a set of device dependencies for the 'active' table.
 *
 * DM_TABLE_STATUS:
 * Return the targets status for the 'active' table.
 *
 * DM_TARGET_MSG:
 * Pass a message string to the target at a specific offset of a device.
 *
 * DM_DEV_SET_GEOMETRY:
 * Set the geometry of a device by passing in a string in this format:
 *
 * "cylinders heads sectors_per_track start_sector"
 *
 * Beware that CHS geometry is nearly obsolete and only provided
 * for compatibility with dm devices that can be booted by a PC
 * BIOS.  See struct hd_geometry for range limits.  Also note that
 * the geometry is erased if the device size changes.
 */

/*
 * All ioctl arguments consist of a single chunk of memory, with
 * this structure at the start.  If a uuid is specified any
 * lookup (eg. for a DM_INFO) will be done on that, *not* the
 * name.
 */
struct dm_ioctl {
	/*
	 * The version number is made up of three parts:
	 * major - no backward or forward compatibility,
	 * minor - only backwards compatible,
	 * patch - both backwards and forwards compatible.
	 *
	 * All clients of the ioctl interface should fill in the
	 * version number of the interface that they were
	 * compiled with.
	 *
	 * All recognised ioctl commands (ie. those that don't
	 * return -ENOTTY) fill out this field, even if the
	 * command failed.
	 */
	__u32 version[3];	/* in/out */
	__u32 data_size;	/* total size of data passed in
				 * including this struct */

	__u32 data_start;	/* offset to start of data
				 * relative to start of this struct */

	__u32 target_count;	/* in/out */
	__s32 open_count;	/* out */
	__u32 flags;		/* in/out */

	/*
	 * event_nr holds either the event number (input and output) or the
	 * udev cookie value (input only).
	 * The DM_DEV_WAIT ioctl takes an event number as input.
	 * The DM_SUSPEND, DM_DEV_REMOVE and DM_DEV_RENAME ioctls
	 * use the field as a cookie to return in the DM_COOKIE
	 * variable with the uevents they issue.
	 * For output, the ioctls return the event number, not the cookie.
	 */
	__u32 event_nr;      	/* in/out */
	__u32 padding;

	__u64 dev;		/* in/out */

	char name[DM_NAME_LEN];	/* device name */
	char uuid[DM_UUID_LEN];	/* unique identifier for
				 * the block device */
	char data[7];		/* padding or data */
};

/*
 * Used to specify tables.  These structures appear after the
 * dm_ioctl.
 */
struct dm_target_spec {
	__u64 sector_start;
	__u64 length;
	__s32 status;		/* used when reading from kernel only */

	/*
	 * Location of the next dm_target_spec.
	 * - When specifying targets on a DM_TABLE_LOAD command, this value is
	 *   the number of bytes from the start of the "current" dm_target_spec
	 *   to the start of the "next" dm_target_spec.
	 * - When retrieving targets on a DM_TABLE_STATUS command, this value
	 *   is the number of bytes from the start of the first dm_target_spec
	 *   (that follows the dm_ioctl struct) to the start of the "next"
	 *   dm_target_spec.
	 */
	__u32 next;

	char target_type[DM_MAX_TYPE_NAME];

	/*
	 * Parameter string starts immediately after this object.
	 * Be careful to add padding after string to ensure correct
	 * alignment of subsequent dm_target_spec.
	 */
};

/*
 * Used to retrieve the target dependencies.
 */
struct dm_target_deps {
	__u32 count;	/* Array size */
	__u32 padding;	/* unused */
	__u64 dev[0];	/* out */
};

/*
 * Used to get a list of all dm devices.
 */
struct dm_name_list {
	__u64 dev;
	__u32 next;		/* offset to the next record from
				   the _start_ of this */
	char name[0];
};

/*
 * Used to retrieve the target versions
 */
struct dm_target_versions {
        __u32 next;
        __u32 version[3];

        char name[0];
};

/*
 * Used to pass message to a target
 */
struct dm_target_msg {
	__u64 sector;	/* Device sector */

	char message[0];
};

/*
 * If you change this make sure you make the corresponding change
 * to dm-ioctl.c:lookup_ioctl()
 */
enum {
	/* Top level cmds */
	DM_VERSION_CMD = 0,
	DM_REMOVE_ALL_CMD,
	DM_LIST_DEVICES_CMD,

	/* device level cmds */
	DM_DEV_CREATE_CMD,
	DM_DEV_REMOVE_CMD,
	DM_DEV_RENAME_CMD,
	DM_DEV_SUSPEND_CMD,
	DM_DEV_STATUS_CMD,
	DM_DEV_WAIT_CMD,

	/* Table level cmds */
	DM_TABLE_LOAD_CMD,
	DM_TABLE_CLEAR_CMD,
	DM_TABLE_DEPS_CMD,
	DM_TABLE_STATUS_CMD,

	/* Added later */
	DM_LIST_VERSIONS_CMD,
	DM_TARGET_MSG_CMD,
	DM_DEV_SET_GEOMETRY_CMD
};

#define DM_IOCTL 0xfd

#define DM_VERSION       _IOWR(DM_IOCTL, DM_VERSION_CMD, struct dm_ioctl)
#define DM_REMOVE_ALL    _IOWR(DM_IOCTL, DM_REMOVE_ALL_CMD, struct dm_ioctl)
#define DM_LIST_DEVICES  _IOWR(DM_IOCTL, DM_LIST_DEVICES_CMD, struct dm_ioctl)

#define DM_DEV_CREATE    _IOWR(DM_IOCTL, DM_DEV_CREATE_CMD, struct dm_ioctl)
#define DM_DEV_REMOVE    _IOWR(DM_IOCTL, DM_DEV_REMOVE_CMD, struct dm_ioctl)
#define DM_DEV_RENAME    _IOWR(DM_IOCTL, DM_DEV_RENAME_CMD, struct dm_ioctl)
#define DM_DEV_SUSPEND   _IOWR(DM_IOCTL, DM_DEV_SUSPEND_CMD, struct dm_ioctl)
#define DM_DEV_STATUS    _IOWR(DM_IOCTL, DM_DEV_STATUS_CMD, struct dm_ioctl)
#define DM_DEV_WAIT      _IOWR(DM_IOCTL, DM_DEV_WAIT_CMD, struct dm_ioctl)

#define DM_TABLE_LOAD    _IOWR(DM_IOCTL, DM_TABLE_LOAD_CMD, struct dm_ioctl)
#define DM_TABLE_CLEAR   _IOWR(DM_IOCTL, DM_TABLE_CLEAR_CMD, struct dm_ioctl)
#define DM_TABLE_DEPS    _IOWR(DM_IOCTL, DM_TABLE_DEPS_CMD, struct dm_ioctl)
#define DM_TABLE_STATUS  _IOWR(DM_IOCTL, DM_TABLE_STATUS_CMD, struct dm_ioctl)

#define DM_LIST_VERSIONS _IOWR(DM_IOCTL, DM_LIST_VERSIONS_CMD, struct dm_ioctl)

#define DM_TARGET_MSG	 _IOWR(DM_IOCTL, DM_TARGET_MSG_CMD, struct dm_ioctl)
#define DM_DEV_SET_GEOMETRY	_IOWR(DM_IOCTL, DM_DEV_SET_GEOMETRY_CMD, struct dm_ioctl)

#define DM_VERSION_MAJOR	4
#define DM_VERSION_MINOR	27
#define DM_VERSION_PATCHLEVEL	0
#define DM_VERSION_EXTRA	"-ioctl (2013-10-30)"

/* Status bits */
#define DM_READONLY_FLAG	(1 << 0) /* In/Out */
#define DM_SUSPEND_FLAG		(1 << 1) /* In/Out */
#define DM_PERSISTENT_DEV_FLAG	(1 << 3) /* In */

/*
 * Flag passed into ioctl STATUS command to get table information
 * rather than current status.
 */
#define DM_STATUS_TABLE_FLAG	(1 << 4) /* In */

/*
 * Flags that indicate whether a table is present in either of
 * the two table slots that a device has.
 */
#define DM_ACTIVE_PRESENT_FLAG   (1 << 5) /* Out */
#define DM_INACTIVE_PRESENT_FLAG (1 << 6) /* Out */

/*
 * Indicates that the buffer passed in wasn't big enough for the
 * results.
 */
#define DM_BUFFER_FULL_FLAG	(1 << 8) /* Out */

/*
 * This flag is now ignored.
 */
#define DM_SKIP_BDGET_FLAG	(1 << 9) /* In */

/*
 * Set this to avoid attempting to freeze any filesystem when suspending.
 */
#define DM_SKIP_LOCKFS_FLAG	(1 << 10) /* In */

/*
 * Set this to suspend without flushing queued ios.
 * Also disables flushing uncommitted changes in the thin target before
 * generating statistics for DM_TABLE_STATUS and DM_DEV_WAIT.
 */
#define DM_NOFLUSH_FLAG		(1 << 11) /* In */

/*
 * If set, any table information returned will relate to the inactive
 * table instead of the live one.  Always check DM_INACTIVE_PRESENT_FLAG
 * is set before using the data returned.
 */
#define DM_QUERY_INACTIVE_TABLE_FLAG	(1 << 12) /* In */

/*
 * If set, a uevent was generated for which the caller may need to wait.
 */
#define DM_UEVENT_GENERATED_FLAG	(1 << 13) /* Out */

/*
 * If set, rename changes the uuid not the name.  Only permitted
 * if no uuid was previously supplied: an existing uuid cannot be changed.
 */
#define DM_UUID_FLAG			(1 << 14) /* In */

/*
 * If set, all buffers are wiped after use. Use when sending
 * or requesting sensitive data such as an encryption key.
 */
#define DM_SECURE_DATA_FLAG		(1 << 15) /* In */

/*
 * If set, a message generated output data.
 */
#define DM_DATA_OUT_FLAG		(1 << 16) /* Out */

/*
 * If set with DM_DEV_REMOVE or DM_REMOVE_ALL this indicates that if
 * the device cannot be removed immediately because it is still in use
 * it should instead be scheduled for removal when it gets closed.
 *
 * On return from DM_DEV_REMOVE, DM_DEV_STATUS or other ioctls, this
 * flag indicates that the device is scheduled to be removed when it
 * gets closed.
 */
#define DM_DEFERRED_REMOVE		(1 << 17) /* In/Out */

#endif				/* _LINUX_DM_IOCTL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * efs_fs_sb.h
 *
 * Copyright (c) 1999 Al Smith
 *
 * Portions derived from IRIX header files (c) 1988 Silicon Graphics
 */

#ifndef __EFS_FS_SB_H__
#define __EFS_FS_SB_H__

#include <linux/types.h>
#include <linux/magic.h>

/* EFS superblock magic numbers */
#define EFS_MAGIC	0x072959
#define EFS_NEWMAGIC	0x07295a

#define IS_EFS_MAGIC(x)	((x == EFS_MAGIC) || (x == EFS_NEWMAGIC))

#define EFS_SUPER		1
#define EFS_ROOTINODE		2

/* efs superblock on disk */
struct efs_super {
	__be32		fs_size;        /* size of filesystem, in sectors */
	__be32		fs_firstcg;     /* bb offset to first cg */
	__be32		fs_cgfsize;     /* size of cylinder group in bb's */
	__be16		fs_cgisize;     /* bb's of inodes per cylinder group */
	__be16		fs_sectors;     /* sectors per track */
	__be16		fs_heads;       /* heads per cylinder */
	__be16		fs_ncg;         /* # of cylinder groups in filesystem */
	__be16		fs_dirty;       /* fs needs to be fsck'd */
	__be32		fs_time;        /* last super-block update */
	__be32		fs_magic;       /* magic number */
	char		fs_fname[6];    /* file system name */
	char		fs_fpack[6];    /* file system pack name */
	__be32		fs_bmsize;      /* size of bitmap in bytes */
	__be32		fs_tfree;       /* total free data blocks */
	__be32		fs_tinode;      /* total free inodes */
	__be32		fs_bmblock;     /* bitmap location. */
	__be32		fs_replsb;      /* Location of replicated superblock. */
	__be32		fs_lastialloc;  /* last allocated inode */
	char		fs_spare[20];   /* space for expansion - MUST BE ZERO */
	__be32		fs_checksum;    /* checksum of volume portion of fs */
};

/* efs superblock information in memory */
struct efs_sb_info {
	__u32	fs_magic;	/* superblock magic number */
	__u32	fs_start;	/* first block of filesystem */
	__u32	first_block;	/* first data block in filesystem */
	__u32	total_blocks;	/* total number of blocks in filesystem */
	__u32	group_size;	/* # of blocks a group consists of */ 
	__u32	data_free;	/* # of free data blocks */
	__u32	inode_free;	/* # of free inodes */
	__u16	inode_blocks;	/* # of blocks used for inodes in every grp */
	__u16	total_groups;	/* # of groups */
};

#endif /* __EFS_FS_SB_H__ */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #ifndef _LINUX_DN_H
#define _LINUX_DN_H

#include <linux/ioctl.h>
#include <linux/types.h>
#include <linux/if_ether.h>

/*

	DECnet Data Structures and Constants

*/

/* 
 * DNPROTO_NSP can't be the same as SOL_SOCKET, 
 * so increment each by one (compared to ULTRIX)
 */
#define DNPROTO_NSP     2                       /* NSP protocol number       */
#define DNPROTO_ROU     3                       /* Routing protocol number   */
#define DNPROTO_NML     4                       /* Net mgt protocol number   */
#define DNPROTO_EVL     5                       /* Evl protocol number (usr) */
#define DNPROTO_EVR     6                       /* Evl protocol number (evl) */
#define DNPROTO_NSPT    7                       /* NSP trace protocol number */


#define DN_ADDL		2
#define DN_MAXADDL	2 /* ULTRIX headers have 20 here, but pathworks has 2 */
#define DN_MAXOPTL	16
#define DN_MAXOBJL	16
#define DN_MAXACCL	40
#define DN_MAXALIASL	128
#define DN_MAXNODEL	256
#define DNBUFSIZE	65023

/* 
 * SET/GET Socket options  - must match the DSO_ numbers below
 */
#define SO_CONDATA      1
#define SO_CONACCESS    2
#define SO_PROXYUSR     3
#define SO_LINKINFO     7

#define DSO_CONDATA     1        /* Set/Get connect data                */
#define DSO_DISDATA     10       /* Set/Get disconnect data             */
#define DSO_CONACCESS   2        /* Set/Get connect access data         */
#define DSO_ACCEPTMODE  4        /* Set/Get accept mode                 */
#define DSO_CONACCEPT   5        /* Accept deferred connection          */
#define DSO_CONREJECT   6        /* Reject deferred connection          */
#define DSO_LINKINFO    7        /* Set/Get link information            */
#define DSO_STREAM      8        /* Set socket type to stream           */
#define DSO_SEQPACKET   9        /* Set socket type to sequenced packet */
#define DSO_MAXWINDOW   11       /* Maximum window size allowed         */
#define DSO_NODELAY	12       /* Turn off nagle                      */
#define DSO_CORK        13       /* Wait for more data!                 */
#define DSO_SERVICES	14       /* NSP Services field                  */
#define DSO_INFO	15       /* NSP Info field                      */
#define DSO_MAX         15       /* Maximum option number               */


/* LINK States */
#define LL_INACTIVE	0
#define LL_CONNECTING	1
#define LL_RUNNING	2
#define LL_DISCONNECTING 3

#define ACC_IMMED 0
#define ACC_DEFER 1

#define SDF_WILD        1                  /* Wild card object          */
#define SDF_PROXY       2                  /* Addr eligible for proxy   */
#define SDF_UICPROXY    4                  /* Use uic-based proxy       */

/* Structures */


struct dn_naddr {
	__le16		a_len;
	__u8 a_addr[DN_MAXADDL]; /* Two bytes little endian */
};

struct sockaddr_dn {
	__u16		sdn_family;
	__u8		sdn_flags;
	__u8		sdn_objnum;
	__le16		sdn_objnamel;
	__u8		sdn_objname[DN_MAXOBJL];
	struct   dn_naddr	sdn_add;
};
#define sdn_nodeaddrl   sdn_add.a_len   /* Node address length  */
#define sdn_nodeaddr    sdn_add.a_addr  /* Node address         */



/*
 * DECnet set/get DSO_CONDATA, DSO_DISDATA (optional data) structure
 */
struct optdata_dn {
        __le16  opt_status;     /* Extended status return */
#define opt_sts opt_status
        __le16  opt_optl;       /* Length of user data    */
        __u8   opt_data[16];   /* User data              */
};

struct accessdata_dn {
	__u8		acc_accl;
	__u8		acc_acc[DN_MAXACCL];
	__u8 		acc_passl;
	__u8		acc_pass[DN_MAXACCL];
	__u8 		acc_userl;
	__u8		acc_user[DN_MAXACCL];
};

/*
 * DECnet logical link information structure
 */
struct linkinfo_dn {
        __u16  idn_segsize;    /* Segment size for link */
        __u8   idn_linkstate;  /* Logical link state    */
};

/*
 * Ethernet address format (for DECnet)
 */
union etheraddress {
        __u8 dne_addr[ETH_ALEN];      /* Full ethernet address */
  struct {
                __u8 dne_hiord[4];    /* DECnet HIORD prefix   */
                __u8 dne_nodeaddr[2]; /* DECnet node address   */
  } dne_remote;
};


/*
 * DECnet physical socket address format
 */
struct dn_addr {
        __le16 dna_family;      /* AF_DECnet               */
        union etheraddress dna_netaddr; /* DECnet ethernet address */
};

#define DECNET_IOCTL_BASE 0x89 /* PROTOPRIVATE range */

#define SIOCSNETADDR  _IOW(DECNET_IOCTL_BASE, 0xe0, struct dn_naddr)
#define SIOCGNETADDR  _IOR(DECNET_IOCTL_BASE, 0xe1, struct dn_naddr)
#define OSIOCSNETADDR _IOW(DECNET_IOCTL_BASE, 0xe0, int)
#define OSIOCGNETADDR _IOR(DECNET_IOCTL_BASE, 0xe1, int)

#endif /* _LINUX_DN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * Copyright (C) 2006-2009 Red Hat, Inc.
 *
 * This file is released under the LGPL.
 */

#ifndef __DM_LOG_USERSPACE_H__
#define __DM_LOG_USERSPACE_H__

#include <linux/dm-ioctl.h> /* For DM_UUID_LEN */

/*
 * The device-mapper userspace log module consists of a kernel component and
 * a user-space component.  The kernel component implements the API defined
 * in dm-dirty-log.h.  Its purpose is simply to pass the parameters and
 * return values of those API functions between kernel and user-space.
 *
 * Below are defined the 'request_types' - DM_ULOG_CTR, DM_ULOG_DTR, etc.
 * These request types represent the different functions in the device-mapper
 * dirty log API.  Each of these is described in more detail below.
 *
 * The user-space program must listen for requests from the kernel (representing
 * the various API functions) and process them.
 *
 * User-space begins by setting up the communication link (error checking
 * removed for clarity):
 *	fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);
 *	addr.nl_family = AF_NETLINK;
 *	addr.nl_groups = CN_IDX_DM;
 *	addr.nl_pid = 0;
 *	r = bind(fd, (struct sockaddr *) &addr, sizeof(addr));
 *	opt = addr.nl_groups;
 *	setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &opt, sizeof(opt));
 *
 * User-space will then wait to receive requests form the kernel, which it
 * will process as described below.  The requests are received in the form,
 * ((struct dm_ulog_request) + (additional data)).  Depending on the request
 * type, there may or may not be 'additional data'.  In the descriptions below,
 * you will see 'Payload-to-userspace' and 'Payload-to-kernel'.  The
 * 'Payload-to-userspace' is what the kernel sends in 'additional data' as
 * necessary parameters to complete the request.  The 'Payload-to-kernel' is
 * the 'additional data' returned to the kernel that contains the necessary
 * results of the request.  The 'data_size' field in the dm_ulog_request
 * structure denotes the availability and amount of payload data.
 */

/*
 * DM_ULOG_CTR corresponds to (found in dm-dirty-log.h):
 * int (*ctr)(struct dm_dirty_log *log, struct dm_target *ti,
 *	      unsigned argc, char **argv);
 *
 * Payload-to-userspace:
 *	A single string containing all the argv arguments separated by ' 's
 * Payload-to-kernel:
 *	A NUL-terminated string that is the name of the device that is used
 *	as the backing store for the log data.  'dm_get_device' will be called
 *	on this device.  ('dm_put_device' will be called on this device
 *	automatically after calling DM_ULOG_DTR.)  If there is no device needed
 *	for log data, 'data_size' in the dm_ulog_request struct should be 0.
 *
 * The UUID contained in the dm_ulog_request structure is the reference that
 * will be used by all request types to a specific log.  The constructor must
 * record this association with the instance created.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field, filling the
 * data field with the log device if necessary, and setting 'data_size'
 * appropriately.
 */
#define DM_ULOG_CTR                    1

/*
 * DM_ULOG_DTR corresponds to (found in dm-dirty-log.h):
 * void (*dtr)(struct dm_dirty_log *log);
 *
 * Payload-to-userspace:
 *	A single string containing all the argv arguments separated by ' 's
 * Payload-to-kernel:
 *	None.  ('data_size' in the dm_ulog_request struct should be 0.)
 *
 * The UUID contained in the dm_ulog_request structure is all that is
 * necessary to identify the log instance being destroyed.  There is no
 * payload data.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and clearing
 * 'data_size' appropriately.
 */
#define DM_ULOG_DTR                    2

/*
 * DM_ULOG_PRESUSPEND corresponds to (found in dm-dirty-log.h):
 * int (*presuspend)(struct dm_dirty_log *log);
 *
 * Payload-to-userspace:
 *	None.
 * Payload-to-kernel:
 *	None.
 *
 * The UUID contained in the dm_ulog_request structure is all that is
 * necessary to identify the log instance being presuspended.  There is no
 * payload data.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and
 * 'data_size' appropriately.
 */
#define DM_ULOG_PRESUSPEND             3

/*
 * DM_ULOG_POSTSUSPEND corresponds to (found in dm-dirty-log.h):
 * int (*postsuspend)(struct dm_dirty_log *log);
 *
 * Payload-to-userspace:
 *	None.
 * Payload-to-kernel:
 *	None.
 *
 * The UUID contained in the dm_ulog_request structure is all that is
 * necessary to identify the log instance being postsuspended.  There is no
 * payload data.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and
 * 'data_size' appropriately.
 */
#define DM_ULOG_POSTSUSPEND            4

/*
 * DM_ULOG_RESUME corresponds to (found in dm-dirty-log.h):
 * int (*resume)(struct dm_dirty_log *log);
 *
 * Payload-to-userspace:
 *	None.
 * Payload-to-kernel:
 *	None.
 *
 * The UUID contained in the dm_ulog_request structure is all that is
 * necessary to identify the log instance being resumed.  There is no
 * payload data.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and
 * 'data_size' appropriately.
 */
#define DM_ULOG_RESUME                 5

/*
 * DM_ULOG_GET_REGION_SIZE corresponds to (found in dm-dirty-log.h):
 * uint32_t (*get_region_size)(struct dm_dirty_log *log);
 *
 * Payload-to-userspace:
 *	None.
 * Payload-to-kernel:
 *	uint64_t - contains the region size
 *
 * The region size is something that was determined at constructor time.
 * It is returned in the payload area and 'data_size' is set to
 * reflect this.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field appropriately.
 */
#define DM_ULOG_GET_REGION_SIZE        6

/*
 * DM_ULOG_IS_CLEAN corresponds to (found in dm-dirty-log.h):
 * int (*is_clean)(struct dm_dirty_log *log, region_t region);
 *
 * Payload-to-userspace:
 *	uint64_t - the region to get clean status on
 * Payload-to-kernel:
 *	int64_t  - 1 if clean, 0 otherwise
 *
 * Payload is sizeof(uint64_t) and contains the region for which the clean
 * status is being made.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - filling the payload with 0 (not clean) or
 * 1 (clean), setting 'data_size' and 'error' appropriately.
 */
#define DM_ULOG_IS_CLEAN               7

/*
 * DM_ULOG_IN_SYNC corresponds to (found in dm-dirty-log.h):
 * int (*in_sync)(struct dm_dirty_log *log, region_t region,
 *		  int can_block);
 *
 * Payload-to-userspace:
 *	uint64_t - the region to get sync status on
 * Payload-to-kernel:
 *	int64_t - 1 if in-sync, 0 otherwise
 *
 * Exactly the same as 'is_clean' above, except this time asking "has the
 * region been recovered?" vs. "is the region not being modified?"
 */
#define DM_ULOG_IN_SYNC                8

/*
 * DM_ULOG_FLUSH corresponds to (found in dm-dirty-log.h):
 * int (*flush)(struct dm_dirty_log *log);
 *
 * Payload-to-userspace:
 *	If the 'integrated_flush' directive is present in the constructor
 *	table, the payload is as same as DM_ULOG_MARK_REGION:
 *		uint64_t [] - region(s) to mark
 *	else
 *		None
 * Payload-to-kernel:
 *	None.
 *
 * If the 'integrated_flush' option was used during the creation of the
 * log, mark region requests are carried as payload in the flush request.
 * Piggybacking the mark requests in this way allows for fewer communications
 * between kernel and userspace.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and clearing
 * 'data_size' appropriately.
 */
#define DM_ULOG_FLUSH                  9

/*
 * DM_ULOG_MARK_REGION corresponds to (found in dm-dirty-log.h):
 * void (*mark_region)(struct dm_dirty_log *log, region_t region);
 *
 * Payload-to-userspace:
 *	uint64_t [] - region(s) to mark
 * Payload-to-kernel:
 *	None.
 *
 * Incoming payload contains the one or more regions to mark dirty.
 * The number of regions contained in the payload can be determined from
 * 'data_size/sizeof(uint64_t)'.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and clearing
 * 'data_size' appropriately.
 */
#define DM_ULOG_MARK_REGION           10

/*
 * DM_ULOG_CLEAR_REGION corresponds to (found in dm-dirty-log.h):
 * void (*clear_region)(struct dm_dirty_log *log, region_t region);
 *
 * Payload-to-userspace:
 *	uint64_t [] - region(s) to clear
 * Payload-to-kernel:
 *	None.
 *
 * Incoming payload contains the one or more regions to mark clean.
 * The number of regions contained in the payload can be determined from
 * 'data_size/sizeof(uint64_t)'.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and clearing
 * 'data_size' appropriately.
 */
#define DM_ULOG_CLEAR_REGION          11

/*
 * DM_ULOG_GET_RESYNC_WORK corresponds to (found in dm-dirty-log.h):
 * int (*get_resync_work)(struct dm_dirty_log *log, region_t *region);
 *
 * Payload-to-userspace:
 *	None.
 * Payload-to-kernel:
 *	{
 *		int64_t i; -- 1 if recovery necessary, 0 otherwise
 *		uint64_t r; -- The region to recover if i=1
 *	}
 * 'data_size' should be set appropriately.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field appropriately.
 */
#define DM_ULOG_GET_RESYNC_WORK       12

/*
 * DM_ULOG_SET_REGION_SYNC corresponds to (found in dm-dirty-log.h):
 * void (*set_region_sync)(struct dm_dirty_log *log,
 *			   region_t region, int in_sync);
 *
 * Payload-to-userspace:
 *	{
 *		uint64_t - region to set sync state on
 *		int64_t  - 0 if not-in-sync, 1 if in-sync
 *	}
 * Payload-to-kernel:
 *	None.
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and clearing
 * 'data_size' appropriately.
 */
#define DM_ULOG_SET_REGION_SYNC       13

/*
 * DM_ULOG_GET_SYNC_COUNT corresponds to (found in dm-dirty-log.h):
 * region_t (*get_sync_count)(struct dm_dirty_log *log);
 *
 * Payload-to-userspace:
 *	None.
 * Payload-to-kernel:
 *	uint64_t - the number of in-sync regions
 *
 * No incoming payload.  Kernel-bound payload contains the number of
 * regions that are in-sync (in a size_t).
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and
 * 'data_size' appropriately.
 */
#define DM_ULOG_GET_SYNC_COUNT        14

/*
 * DM_ULOG_STATUS_INFO corresponds to (found in dm-dirty-log.h):
 * int (*status)(struct dm_dirty_log *log, STATUSTYPE_INFO,
 *		 char *result, unsigned maxlen);
 *
 * Payload-to-userspace:
 *	None.
 * Payload-to-kernel:
 *	Character string containing STATUSTYPE_INFO
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and
 * 'data_size' appropriately.
 */
#define DM_ULOG_STATUS_INFO           15

/*
 * DM_ULOG_STATUS_TABLE corresponds to (found in dm-dirty-log.h):
 * int (*status)(struct dm_dirty_log *log, STATUSTYPE_TABLE,
 *		 char *result, unsigned maxlen);
 *
 * Payload-to-userspace:
 *	None.
 * Payload-to-kernel:
 *	Character string containing STATUSTYPE_TABLE
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and
 * 'data_size' appropriately.
 */
#define DM_ULOG_STATUS_TABLE          16

/*
 * DM_ULOG_IS_REMOTE_RECOVERING corresponds to (found in dm-dirty-log.h):
 * int (*is_remote_recovering)(struct dm_dirty_log *log, region_t region);
 *
 * Payload-to-userspace:
 *	uint64_t - region to determine recovery status on
 * Payload-to-kernel:
 *	{
 *		int64_t is_recovering;  -- 0 if no, 1 if yes
 *		uint64_t in_sync_hint;  -- lowest region still needing resync
 *	}
 *
 * When the request has been processed, user-space must return the
 * dm_ulog_request to the kernel - setting the 'error' field and
 * 'data_size' appropriately.
 */
#define DM_ULOG_IS_REMOTE_RECOVERING  17

/*
 * (DM_ULOG_REQUEST_MASK & request_type) to get the request type
 *
 * Payload-to-userspace:
 *	A single string containing all the argv arguments separated by ' 's
 * Payload-to-kernel:
 *	None.  ('data_size' in the dm_ulog_request struct should be 0.)
 *
 * We are reserving 8 bits of the 32-bit 'request_type' field for the
 * various request types above.  The remaining 24-bits are currently
 * set to zero and are reserved for future use and compatibility concerns.
 *
 * User-space should always use DM_ULOG_REQUEST_TYPE to acquire the
 * request type from the 'request_type' field to maintain forward compatibility.
 */
#define DM_ULOG_REQUEST_MASK 0xFF
#define DM_ULOG_REQUEST_TYPE(request_type) \
	(DM_ULOG_REQUEST_MASK & (request_type))

/*
 * DM_ULOG_REQUEST_VERSION is incremented when there is a
 * change to the way information is passed between kernel
 * and userspace.  This could be a structure change of
 * dm_ulog_request or a change in the way requests are
 * issued/handled.  Changes are outlined here:
 *	version 1:  Initial implementation
 *	version 2:  DM_ULOG_CTR allowed to return a string containing a
 *	            device name that is to be registered with DM via
 *	            'dm_get_device'.
 *	version 3:  DM_ULOG_FLUSH is capable of carrying payload for marking
 *		    regions.  This "integrated flush" reduces the number of
 *		    requests between the kernel and userspace by effectively
 *		    merging 'mark' and 'flush' requests.  A constructor table
 *		    argument ('integrated_flush') is required to turn this
 *		    feature on, so it is backwards compatible with older
 *		    userspace versions.
 */
#define DM_ULOG_REQUEST_VERSION 3

struct dm_ulog_request {
	/*
	 * The local unique identifier (luid) and the universally unique
	 * identifier (uuid) are used to tie a request to a specific
	 * mirror log.  A single machine log could probably make due with
	 * just the 'luid', but a cluster-aware log must use the 'uuid' and
	 * the 'luid'.  The uuid is what is required for node to node
	 * communication concerning a particular log, but the 'luid' helps
	 * differentiate between logs that are being swapped and have the
	 * same 'uuid'.  (Think "live" and "inactive" device-mapper tables.)
	 */
	uint64_t luid;
	char uuid[DM_UUID_LEN];
	char padding[3];        /* Padding because DM_UUID_LEN = 129 */

	uint32_t version;       /* See DM_ULOG_REQUEST_VERSION */
	int32_t error;          /* Used to report back processing errors */

	uint32_t seq;           /* Sequence number for request */
	uint32_t request_type;  /* DM_ULOG_* defined above */
	uint32_t data_size;     /* How much data (not including this struct) */

	char data[0];
};

#endif /* __DM_LOG_USERSPACE_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * Copyright (c) 1995-2001,2004 Silicon Graphics, Inc.  All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesset General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#ifndef _LINUX_DQBLK_XFS_H
#define _LINUX_DQBLK_XFS_H

#include <linux/types.h>

/*
 * Disk quota - quotactl(2) commands for the XFS Quota Manager (XQM).
 */

#define XQM_CMD(x)	(('X'<<8)+(x))	/* note: forms first QCMD argument */
#define XQM_COMMAND(x)	(((x) & (0xff<<8)) == ('X'<<8))	/* test if for XFS */

#define XQM_USRQUOTA	0	/* system call user quota type */
#define XQM_GRPQUOTA	1	/* system call group quota type */
#define XQM_PRJQUOTA	2	/* system call project quota type */
#define XQM_MAXQUOTAS	3

#define Q_XQUOTAON	XQM_CMD(1)	/* enable accounting/enforcement */
#define Q_XQUOTAOFF	XQM_CMD(2)	/* disable accounting/enforcement */
#define Q_XGETQUOTA	XQM_CMD(3)	/* get disk limits and usage */
#define Q_XSETQLIM	XQM_CMD(4)	/* set disk limits */
#define Q_XGETQSTAT	XQM_CMD(5)	/* get quota subsystem status */
#define Q_XQUOTARM	XQM_CMD(6)	/* free disk space used by dquots */
#define Q_XQUOTASYNC	XQM_CMD(7)	/* delalloc flush, updates dquots */
#define Q_XGETQSTATV	XQM_CMD(8)	/* newer version of get quota */

/*
 * fs_disk_quota structure:
 *
 * This contains the current quota information regarding a user/proj/group.
 * It is 64-bit aligned, and all the blk units are in BBs (Basic Blocks) of
 * 512 bytes.
 */
#define FS_DQUOT_VERSION	1	/* fs_disk_quota.d_version */
typedef struct fs_disk_quota {
	__s8		d_version;	/* version of this structure */
	__s8		d_flags;	/* FS_{USER,PROJ,GROUP}_QUOTA */
	__u16		d_fieldmask;	/* field specifier */
	__u32		d_id;		/* user, project, or group ID */
	__u64		d_blk_hardlimit;/* absolute limit on disk blks */
	__u64		d_blk_softlimit;/* preferred limit on disk blks */
	__u64		d_ino_hardlimit;/* maximum # allocated inodes */
	__u64		d_ino_softlimit;/* preferred inode limit */
	__u64		d_bcount;	/* # disk blocks owned by the user */
	__u64		d_icount;	/* # inodes owned by the user */
	__s32		d_itimer;	/* zero if within inode limits */
					/* if not, we refuse service */
	__s32		d_btimer;	/* similar to above; for disk blocks */
	__u16	  	d_iwarns;       /* # warnings issued wrt num inodes */
	__u16	  	d_bwarns;       /* # warnings issued wrt disk blocks */
	__s32		d_padding2;	/* padding2 - for future use */
	__u64		d_rtb_hardlimit;/* absolute limit on realtime blks */
	__u64		d_rtb_softlimit;/* preferred limit on RT disk blks */
	__u64		d_rtbcount;	/* # realtime blocks owned */
	__s32		d_rtbtimer;	/* similar to above; for RT disk blks */
	__u16	  	d_rtbwarns;     /* # warnings issued wrt RT disk blks */
	__s16		d_padding3;	/* padding3 - for future use */	
	char		d_padding4[8];	/* yet more padding */
} fs_disk_quota_t;

/*
 * These fields are sent to Q_XSETQLIM to specify fields that need to change.
 */
#define FS_DQ_ISOFT	(1<<0)
#define FS_DQ_IHARD	(1<<1)
#define FS_DQ_BSOFT	(1<<2)
#define FS_DQ_BHARD 	(1<<3)
#define FS_DQ_RTBSOFT	(1<<4)
#define FS_DQ_RTBHARD	(1<<5)
#define FS_DQ_LIMIT_MASK	(FS_DQ_ISOFT | FS_DQ_IHARD | FS_DQ_BSOFT | \
				 FS_DQ_BHARD | FS_DQ_RTBSOFT | FS_DQ_RTBHARD)
/*
 * These timers can only be set in super user's dquot. For others, timers are
 * automatically started and stopped. Superusers timer values set the limits
 * for the rest.  In case these values are zero, the DQ_{F,B}TIMELIMIT values
 * defined below are used. 
 * These values also apply only to the d_fieldmask field for Q_XSETQLIM.
 */
#define FS_DQ_BTIMER	(1<<6)
#define FS_DQ_ITIMER	(1<<7)
#define FS_DQ_RTBTIMER 	(1<<8)
#define FS_DQ_TIMER_MASK	(FS_DQ_BTIMER | FS_DQ_ITIMER | FS_DQ_RTBTIMER)

/*
 * Warning counts are set in both super user's dquot and others. For others,
 * warnings are set/cleared by the administrators (or automatically by going
 * below the soft limit).  Superusers warning values set the warning limits
 * for the rest.  In case these values are zero, the DQ_{F,B}WARNLIMIT values
 * defined below are used. 
 * These values also apply only to the d_fieldmask field for Q_XSETQLIM.
 */
#define FS_DQ_BWARNS	(1<<9)
#define FS_DQ_IWARNS	(1<<10)
#define FS_DQ_RTBWARNS	(1<<11)
#define FS_DQ_WARNS_MASK	(FS_DQ_BWARNS | FS_DQ_IWARNS | FS_DQ_RTBWARNS)

/*
 * Accounting values.  These can only be set for filesystem with
 * non-transactional quotas that require quotacheck(8) in userspace.
 */
#define FS_DQ_BCOUNT		(1<<12)
#define FS_DQ_ICOUNT		(1<<13)
#define FS_DQ_RTBCOUNT		(1<<14)
#define FS_DQ_ACCT_MASK		(FS_DQ_BCOUNT | FS_DQ_ICOUNT | FS_DQ_RTBCOUNT)

/*
 * Various flags related to quotactl(2).
 */
#define FS_QUOTA_UDQ_ACCT	(1<<0)  /* user quota accounting */
#define FS_QUOTA_UDQ_ENFD	(1<<1)  /* user quota limits enforcement */
#define FS_QUOTA_GDQ_ACCT	(1<<2)  /* group quota accounting */
#define FS_QUOTA_GDQ_ENFD	(1<<3)  /* group quota limits enforcement */
#define FS_QUOTA_PDQ_ACCT	(1<<4)  /* project quota accounting */
#define FS_QUOTA_PDQ_ENFD	(1<<5)  /* project quota limits enforcement */

#define FS_USER_QUOTA		(1<<0)	/* user quota type */
#define FS_PROJ_QUOTA		(1<<1)	/* project quota type */
#define FS_GROUP_QUOTA		(1<<2)	/* group quota type */

/*
 * fs_quota_stat is the struct returned in Q_XGETQSTAT for a given file system.
 * Provides a centralized way to get meta information about the quota subsystem.
 * eg. space taken up for user and group quotas, number of dquots currently
 * incore.
 */
#define FS_QSTAT_VERSION	1	/* fs_quota_stat.qs_version */

/*
 * Some basic information about 'quota files'.
 */
typedef struct fs_qfilestat {
	__u64		qfs_ino;	/* inode number */
	__u64		qfs_nblks;	/* number of BBs 512-byte-blks */
	__u32		qfs_nextents;	/* number of extents */
} fs_qfilestat_t;

typedef struct fs_quota_stat {
	__s8		qs_version;	/* version number for future changes */
	__u16		qs_flags;	/* FS_QUOTA_{U,P,G}DQ_{ACCT,ENFD} */
	__s8		qs_pad;		/* unused */
	fs_qfilestat_t	qs_uquota;	/* user quota storage information */
	fs_qfilestat_t	qs_gquota;	/* group quota storage information */
	__u32		qs_incoredqs;	/* number of dquots incore */
	__s32		qs_btimelimit;  /* limit for blks timer */	
	__s32		qs_itimelimit;  /* limit for inodes timer */	
	__s32		qs_rtbtimelimit;/* limit for rt blks timer */	
	__u16		qs_bwarnlimit;	/* limit for num warnings */
	__u16		qs_iwarnlimit;	/* limit for num warnings */
} fs_quota_stat_t;

/*
 * fs_quota_statv is used by Q_XGETQSTATV for a given file system. It provides
 * a centralized way to get meta information about the quota subsystem. eg.
 * space taken up for user, group, and project quotas, number of dquots
 * currently incore.
 *
 * This version has proper versioning support with appropriate padding for
 * future expansions, and ability to expand for future without creating any
 * backward compatibility issues.
 *
 * Q_XGETQSTATV uses the passed in value of the requested version via
 * fs_quota_statv.qs_version to determine the return data layout of
 * fs_quota_statv.  The kernel will fill the data fields relevant to that
 * version.
 *
 * If kernel does not support user space caller specified version, EINVAL will
 * be returned. User space caller can then reduce the version number and retry
 * the same command.
 */
#define FS_QSTATV_VERSION1	1	/* fs_quota_statv.qs_version */
/*
 * Some basic information about 'quota files' for Q_XGETQSTATV command
 */
struct fs_qfilestatv {
	__u64		qfs_ino;	/* inode number */
	__u64		qfs_nblks;	/* number of BBs 512-byte-blks */
	__u32		qfs_nextents;	/* number of extents */
	__u32		qfs_pad;	/* pad for 8-byte alignment */
};

struct fs_quota_statv {
	__s8			qs_version;	/* version for future changes */
	__u8			qs_pad1;	/* pad for 16bit alignment */
	__u16			qs_flags;	/* FS_QUOTA_.* flags */
	__u32			qs_incoredqs;	/* number of dquots incore */
	struct fs_qfilestatv	qs_uquota;	/* user quota information */
	struct fs_qfilestatv	qs_gquota;	/* group quota information */
	struct fs_qfilestatv	qs_pquota;	/* project quota information */
	__s32			qs_btimelimit;  /* limit for blks timer */
	__s32			qs_itimelimit;  /* limit for inodes timer */
	__s32			qs_rtbtimelimit;/* limit for rt blks timer */
	__u16			qs_bwarnlimit;	/* limit for num warnings */
	__u16			qs_iwarnlimit;	/* limit for num warnings */
	__u64			qs_pad2[8];	/* for future proofing */
};

#endif	/* _LINUX_DQBLK_XFS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #ifndef _LINUX_ELF_EM_H
#define _LINUX_ELF_EM_H

/* These constants define the various ELF target machines */
#define EM_NONE		0
#define EM_M32		1
#define EM_SPARC	2
#define EM_386		3
#define EM_68K		4
#define EM_88K		5
#define EM_486		6	/* Perhaps disused */
#define EM_860		7
#define EM_MIPS		8	/* MIPS R3000 (officially, big-endian only) */
				/* Next two are historical and binaries and
				   modules of these types will be rejected by
				   Linux.  */
#define EM_MIPS_RS3_LE	10	/* MIPS R3000 little-endian */
#define EM_MIPS_RS4_BE	10	/* MIPS R4000 big-endian */

#define EM_PARISC	15	/* HPPA */
#define EM_SPARC32PLUS	18	/* Sun's "v8plus" */
#define EM_PPC		20	/* PowerPC */
#define EM_PPC64	21	 /* PowerPC64 */
#define EM_SPU		23	/* Cell BE SPU */
#define EM_ARM		40	/* ARM 32 bit */
#define EM_SH		42	/* SuperH */
#define EM_SPARCV9	43	/* SPARC v9 64-bit */
#define EM_IA_64	50	/* HP/Intel IA-64 */
#define EM_X86_64	62	/* AMD x86-64 */
#define EM_S390		22	/* IBM S/390 */
#define EM_CRIS		76	/* Axis Communications 32-bit embedded processor */
#define EM_V850		87	/* NEC v850 */
#define EM_M32R		88	/* Renesas M32R */
#define EM_MN10300	89	/* Panasonic/MEI MN10300, AM33 */
#define EM_BLACKFIN     106     /* ADI Blackfin Processor */
#define EM_TI_C6000	140	/* TI C6X DSPs */
#define EM_AARCH64	183	/* ARM 64 bit */
#define EM_FRV		0x5441	/* Fujitsu FR-V */
#define EM_AVR32	0x18ad	/* Atmel AVR32 */

/*
 * This is an interim value that we will use until the committee comes
 * up with a final number.
 */
#define EM_ALPHA	0x9026

/* Bogus old v850 magic number, used by old tools. */
#define EM_CYGNUS_V850	0x9080
/* Bogus old m32r magic number, used by old tools. */
#define EM_CYGNUS_M32R	0x9041
/* This is the old interim value for S/390 architecture */
#define EM_S390_OLD	0xA390
/* Also Panasonic/MEI MN10300, AM33 */
#define EM_CYGNUS_MN10300 0xbeef


#endif /* _LINUX_ELF_EM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * linux/include/linux/edd.h
 *  Copyright (C) 2002, 2003, 2004 Dell Inc.
 *  by Matt Domsch <Matt_Domsch@dell.com>
 *
 * structures and definitions for the int 13h, ax={41,48}h
 * BIOS Enhanced Disk Drive Services
 * This is based on the T13 group document D1572 Revision 0 (August 14 2002)
 * available at http://www.t13.org/docs2002/d1572r0.pdf.  It is
 * very similar to D1484 Revision 3 http://www.t13.org/docs2002/d1484r3.pdf
 *
 * In a nutshell, arch/{i386,x86_64}/boot/setup.S populates a scratch
 * table in the boot_params that contains a list of BIOS-enumerated
 * boot devices.
 * In arch/{i386,x86_64}/kernel/setup.c, this information is
 * transferred into the edd structure, and in drivers/firmware/edd.c, that
 * information is used to identify BIOS boot disk.  The code in setup.S
 * is very sensitive to the size of these structures.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License v2.0 as published by
 * the Free Software Foundation
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */
#ifndef _LINUX_EDD_H
#define _LINUX_EDD_H

#include <linux/types.h>

#define EDDNR 0x1e9		/* addr of number of edd_info structs at EDDBUF
				   in boot_params - treat this as 1 byte  */
#define EDDBUF	0xd00		/* addr of edd_info structs in boot_params */
#define EDDMAXNR 6		/* number of edd_info structs starting at EDDBUF  */
#define EDDEXTSIZE 8		/* change these if you muck with the structures */
#define EDDPARMSIZE 74
#define CHECKEXTENSIONSPRESENT 0x41
#define GETDEVICEPARAMETERS 0x48
#define LEGACYGETDEVICEPARAMETERS 0x08
#define EDDMAGIC1 0x55AA
#define EDDMAGIC2 0xAA55


#define READ_SECTORS 0x02         /* int13 AH=0x02 is READ_SECTORS command */
#define EDD_MBR_SIG_OFFSET 0x1B8  /* offset of signature in the MBR */
#define EDD_MBR_SIG_BUF    0x290  /* addr in boot params */
#define EDD_MBR_SIG_MAX 16        /* max number of signatures to store */
#define EDD_MBR_SIG_NR_BUF 0x1ea  /* addr of number of MBR signtaures at EDD_MBR_SIG_BUF
				     in boot_params - treat this as 1 byte  */

#ifndef __ASSEMBLY__

#define EDD_EXT_FIXED_DISK_ACCESS           (1 << 0)
#define EDD_EXT_DEVICE_LOCKING_AND_EJECTING (1 << 1)
#define EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT (1 << 2)
#define EDD_EXT_64BIT_EXTENSIONS            (1 << 3)

#define EDD_INFO_DMA_BOUNDARY_ERROR_TRANSPARENT (1 << 0)
#define EDD_INFO_GEOMETRY_VALID                (1 << 1)
#define EDD_INFO_REMOVABLE                     (1 << 2)
#define EDD_INFO_WRITE_VERIFY                  (1 << 3)
#define EDD_INFO_MEDIA_CHANGE_NOTIFICATION     (1 << 4)
#define EDD_INFO_LOCKABLE                      (1 << 5)
#define EDD_INFO_NO_MEDIA_PRESENT              (1 << 6)
#define EDD_INFO_USE_INT13_FN50                (1 << 7)

struct edd_device_params {
	__u16 length;
	__u16 info_flags;
	__u32 num_default_cylinders;
	__u32 num_default_heads;
	__u32 sectors_per_track;
	__u64 number_of_sectors;
	__u16 bytes_per_sector;
	__u32 dpte_ptr;		/* 0xFFFFFFFF for our purposes */
	__u16 key;		/* = 0xBEDD */
	__u8 device_path_info_length;	/* = 44 */
	__u8 reserved2;
	__u16 reserved3;
	__u8 host_bus_type[4];
	__u8 interface_type[8];
	union {
		struct {
			__u16 base_address;
			__u16 reserved1;
			__u32 reserved2;
		} __attribute__ ((packed)) isa;
		struct {
			__u8 bus;
			__u8 slot;
			__u8 function;
			__u8 channel;
			__u32 reserved;
		} __attribute__ ((packed)) pci;
		/* pcix is same as pci */
		struct {
			__u64 reserved;
		} __attribute__ ((packed)) ibnd;
		struct {
			__u64 reserved;
		} __attribute__ ((packed)) xprs;
		struct {
			__u64 reserved;
		} __attribute__ ((packed)) htpt;
		struct {
			__u64 reserved;
		} __attribute__ ((packed)) unknown;
	} interface_path;
	union {
		struct {
			__u8 device;
			__u8 reserved1;
			__u16 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} __attribute__ ((packed)) ata;
		struct {
			__u8 device;
			__u8 lun;
			__u8 reserved1;
			__u8 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} __attribute__ ((packed)) atapi;
		struct {
			__u16 id;
			__u64 lun;
			__u16 reserved1;
			__u32 reserved2;
		} __attribute__ ((packed)) scsi;
		struct {
			__u64 serial_number;
			__u64 reserved;
		} __attribute__ ((packed)) usb;
		struct {
			__u64 eui;
			__u64 reserved;
		} __attribute__ ((packed)) i1394;
		struct {
			__u64 wwid;
			__u64 lun;
		} __attribute__ ((packed)) fibre;
		struct {
			__u64 identity_tag;
			__u64 reserved;
		} __attribute__ ((packed)) i2o;
		struct {
			__u32 array_number;
			__u32 reserved1;
			__u64 reserved2;
		} __attribute__ ((packed)) raid;
		struct {
			__u8 device;
			__u8 reserved1;
			__u16 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} __attribute__ ((packed)) sata;
		struct {
			__u64 reserved1;
			__u64 reserved2;
		} __attribute__ ((packed)) unknown;
	} device_path;
	__u8 reserved4;
	__u8 checksum;
} __attribute__ ((packed));

struct edd_info {
	__u8 device;
	__u8 version;
	__u16 interface_support;
	__u16 legacy_max_cylinder;
	__u8 legacy_max_head;
	__u8 legacy_sectors_per_track;
	struct edd_device_params params;
} __attribute__ ((packed));

struct edd {
	unsigned int mbr_signature[EDD_MBR_SIG_MAX];
	struct edd_info edd_info[EDDMAXNR];
	unsigned char mbr_signature_nr;
	unsigned char edd_info_nr;
};

#endif				/*!__ASSEMBLY__ */

#endif /* _LINUX_EDD_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /* elf-fdpic.h: FDPIC ELF load map
 *
 * Copyright (C) 2003 Red Hat, Inc. All Rights Reserved.
 * Written by David Howells (dhowells@redhat.com)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 */

#ifndef _LINUX_ELF_FDPIC_H
#define _LINUX_ELF_FDPIC_H

#include <linux/elf.h>

#define PT_GNU_STACK    (PT_LOOS + 0x474e551)

/* segment mappings for ELF FDPIC libraries/executables/interpreters */
struct elf32_fdpic_loadseg {
	Elf32_Addr	addr;		/* core address to which mapped */
	Elf32_Addr	p_vaddr;	/* VMA recorded in file */
	Elf32_Word	p_memsz;	/* allocation size recorded in file */
};

struct elf32_fdpic_loadmap {
	Elf32_Half	version;	/* version of these structures, just in case... */
	Elf32_Half	nsegs;		/* number of segments */
	struct elf32_fdpic_loadseg segs[];
};

#define ELF32_FDPIC_LOADMAP_VERSION	0x0000

#endif /* _LINUX_ELF_FDPIC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #ifndef _LINUX_ELF_H
#define _LINUX_ELF_H

#include <linux/types.h>
#include <linux/elf-em.h>

/* 32-bit ELF base types. */
typedef __u32	Elf32_Addr;
typedef __u16	Elf32_Half;
typedef __u32	Elf32_Off;
typedef __s32	Elf32_Sword;
typedef __u32	Elf32_Word;

/* 64-bit ELF base types. */
typedef __u64	Elf64_Addr;
typedef __u16	Elf64_Half;
typedef __s16	Elf64_SHalf;
typedef __u64	Elf64_Off;
typedef __s32	Elf64_Sword;
typedef __u32	Elf64_Word;
typedef __u64	Elf64_Xword;
typedef __s64	Elf64_Sxword;

/* These constants are for the segment types stored in the image headers */
#define PT_NULL    0
#define PT_LOAD    1
#define PT_DYNAMIC 2
#define PT_INTERP  3
#define PT_NOTE    4
#define PT_SHLIB   5
#define PT_PHDR    6
#define PT_TLS     7               /* Thread local storage segment */
#define PT_LOOS    0x60000000      /* OS-specific */
#define PT_HIOS    0x6fffffff      /* OS-specific */
#define PT_LOPROC  0x70000000
#define PT_HIPROC  0x7fffffff
#define PT_GNU_EH_FRAME		0x6474e550

#define PT_GNU_STACK	(PT_LOOS + 0x474e551)

/*
 * Extended Numbering
 *
 * If the real number of program header table entries is larger than
 * or equal to PN_XNUM(0xffff), it is set to sh_info field of the
 * section header at index 0, and PN_XNUM is set to e_phnum
 * field. Otherwise, the section header at index 0 is zero
 * initialized, if it exists.
 *
 * Specifications are available in:
 *
 * - Oracle: Linker and Libraries.
 *   Part No: 817â€“1984â€“19, August 2011.
 *   http://docs.oracle.com/cd/E18752_01/pdf/817-1984.pdf
 *
 * - System V ABI AMD64 Architecture Processor Supplement
 *   Draft Version 0.99.4,
 *   January 13, 2010.
 *   http://www.cs.washington.edu/education/courses/cse351/12wi/supp-docs/abi.pdf
 */
#define PN_XNUM 0xffff

/* These constants define the different elf file types */
#define ET_NONE   0
#define ET_REL    1
#define ET_EXEC   2
#define ET_DYN    3
#define ET_CORE   4
#define ET_LOPROC 0xff00
#define ET_HIPROC 0xffff

/* This is the info that is needed to parse the dynamic section of the file */
#define DT_NULL		0
#define DT_NEEDED	1
#define DT_PLTRELSZ	2
#define DT_PLTGOT	3
#define DT_HASH		4
#define DT_STRTAB	5
#define DT_SYMTAB	6
#define DT_RELA		7
#define DT_RELASZ	8
#define DT_RELAENT	9
#define DT_STRSZ	10
#define DT_SYMENT	11
#define DT_INIT		12
#define DT_FINI		13
#define DT_SONAME	14
#define DT_RPATH 	15
#define DT_SYMBOLIC	16
#define DT_REL	        17
#define DT_RELSZ	18
#define DT_RELENT	19
#define DT_PLTREL	20
#define DT_DEBUG	21
#define DT_TEXTREL	22
#define DT_JMPREL	23
#define DT_ENCODING	32
#define OLD_DT_LOOS	0x60000000
#define DT_LOOS		0x6000000d
#define DT_HIOS		0x6ffff000
#define DT_VALRNGLO	0x6ffffd00
#define DT_VALRNGHI	0x6ffffdff
#define DT_ADDRRNGLO	0x6ffffe00
#define DT_ADDRRNGHI	0x6ffffeff
#define DT_VERSYM	0x6ffffff0
#define DT_RELACOUNT	0x6ffffff9
#define DT_RELCOUNT	0x6ffffffa
#define DT_FLAGS_1	0x6ffffffb
#define DT_VERDEF	0x6ffffffc
#define	DT_VERDEFNUM	0x6ffffffd
#define DT_VERNEED	0x6ffffffe
#define	DT_VERNEEDNUM	0x6fffffff
#define OLD_DT_HIOS     0x6fffffff
#define DT_LOPROC	0x70000000
#define DT_HIPROC	0x7fffffff

/* This info is needed when parsing the symbol table */
#define STB_LOCAL  0
#define STB_GLOBAL 1
#define STB_WEAK   2

#define STT_NOTYPE  0
#define STT_OBJECT  1
#define STT_FUNC    2
#define STT_SECTION 3
#define STT_FILE    4
#define STT_COMMON  5
#define STT_TLS     6

#define ELF_ST_BIND(x)		((x) >> 4)
#define ELF_ST_TYPE(x)		(((unsigned int) x) & 0xf)
#define ELF32_ST_BIND(x)	ELF_ST_BIND(x)
#define ELF32_ST_TYPE(x)	ELF_ST_TYPE(x)
#define ELF64_ST_BIND(x)	ELF_ST_BIND(x)
#define ELF64_ST_TYPE(x)	ELF_ST_TYPE(x)

typedef struct dynamic{
  Elf32_Sword d_tag;
  union{
    Elf32_Sword	d_val;
    Elf32_Addr	d_ptr;
  } d_un;
} Elf32_Dyn;

typedef struct {
  Elf64_Sxword d_tag;		/* entry tag value */
  union {
    Elf64_Xword d_val;
    Elf64_Addr d_ptr;
  } d_un;
} Elf64_Dyn;

/* The following are used with relocations */
#define ELF32_R_SYM(x) ((x) >> 8)
#define ELF32_R_TYPE(x) ((x) & 0xff)

#define ELF64_R_SYM(i)			((i) >> 32)
#define ELF64_R_TYPE(i)			((i) & 0xffffffff)

typedef struct elf32_rel {
  Elf32_Addr	r_offset;
  Elf32_Word	r_info;
} Elf32_Rel;

typedef struct elf64_rel {
  Elf64_Addr r_offset;	/* Location at which to apply the action */
  Elf64_Xword r_info;	/* index and type of relocation */
} Elf64_Rel;

typedef struct elf32_rela{
  Elf32_Addr	r_offset;
  Elf32_Word	r_info;
  Elf32_Sword	r_addend;
} Elf32_Rela;

typedef struct elf64_rela {
  Elf64_Addr r_offset;	/* Location at which to apply the action */
  Elf64_Xword r_info;	/* index and type of relocation */
  Elf64_Sxword r_addend;	/* Constant addend used to compute value */
} Elf64_Rela;

typedef struct elf32_sym{
  Elf32_Word	st_name;
  Elf32_Addr	st_value;
  Elf32_Word	st_size;
  unsigned char	st_info;
  unsigned char	st_other;
  Elf32_Half	st_shndx;
} Elf32_Sym;

typedef struct elf64_sym {
  Elf64_Word st_name;		/* Symbol name, index in string tbl */
  unsigned char	st_info;	/* Type and binding attributes */
  unsigned char	st_other;	/* No defined meaning, 0 */
  Elf64_Half st_shndx;		/* Associated section index */
  Elf64_Addr st_value;		/* Value of the symbol */
  Elf64_Xword st_size;		/* Associated symbol size */
} Elf64_Sym;


#define EI_NIDENT	16

typedef struct elf32_hdr{
  unsigned char	e_ident[EI_NIDENT];
  Elf32_Half	e_type;
  Elf32_Half	e_machine;
  Elf32_Word	e_version;
  Elf32_Addr	e_entry;  /* Entry point */
  Elf32_Off	e_phoff;
  Elf32_Off	e_shoff;
  Elf32_Word	e_flags;
  Elf32_Half	e_ehsize;
  Elf32_Half	e_phentsize;
  Elf32_Half	e_phnum;
  Elf32_Half	e_shentsize;
  Elf32_Half	e_shnum;
  Elf32_Half	e_shstrndx;
} Elf32_Ehdr;

typedef struct elf64_hdr {
  unsigned char	e_ident[EI_NIDENT];	/* ELF "magic number" */
  Elf64_Half e_type;
  Elf64_Half e_machine;
  Elf64_Word e_version;
  Elf64_Addr e_entry;		/* Entry point virtual address */
  Elf64_Off e_phoff;		/* Program header table file offset */
  Elf64_Off e_shoff;		/* Section header table file offset */
  Elf64_Word e_flags;
  Elf64_Half e_ehsize;
  Elf64_Half e_phentsize;
  Elf64_Half e_phnum;
  Elf64_Half e_shentsize;
  Elf64_Half e_shnum;
  Elf64_Half e_shstrndx;
} Elf64_Ehdr;

/* These constants define the permissions on sections in the program
   header, p_flags. */
#define PF_R		0x4
#define PF_W		0x2
#define PF_X		0x1

typedef struct elf32_phdr{
  Elf32_Word	p_type;
  Elf32_Off	p_offset;
  Elf32_Addr	p_vaddr;
  Elf32_Addr	p_paddr;
  Elf32_Word	p_filesz;
  Elf32_Word	p_memsz;
  Elf32_Word	p_flags;
  Elf32_Word	p_align;
} Elf32_Phdr;

typedef struct elf64_phdr {
  Elf64_Word p_type;
  Elf64_Word p_flags;
  Elf64_Off p_offset;		/* Segment file offset */
  Elf64_Addr p_vaddr;		/* Segment virtual address */
  Elf64_Addr p_paddr;		/* Segment physical address */
  Elf64_Xword p_filesz;		/* Segment size in file */
  Elf64_Xword p_memsz;		/* Segment size in memory */
  Elf64_Xword p_align;		/* Segment alignment, file & memory */
} Elf64_Phdr;

/* sh_type */
#define SHT_NULL	0
#define SHT_PROGBITS	1
#define SHT_SYMTAB	2
#define SHT_STRTAB	3
#define SHT_RELA	4
#define SHT_HASH	5
#define SHT_DYNAMIC	6
#define SHT_NOTE	7
#define SHT_NOBITS	8
#define SHT_REL		9
#define SHT_SHLIB	10
#define SHT_DYNSYM	11
#define SHT_NUM		12
#define SHT_LOPROC	0x70000000
#define SHT_HIPROC	0x7fffffff
#define SHT_LOUSER	0x80000000
#define SHT_HIUSER	0xffffffff

/* sh_flags */
#define SHF_WRITE	0x1
#define SHF_ALLOC	0x2
#define SHF_EXECINSTR	0x4
#define SHF_MASKPROC	0xf0000000

/* special section indexes */
#define SHN_UNDEF	0
#define SHN_LORESERVE	0xff00
#define SHN_LOPROC	0xff00
#define SHN_HIPROC	0xff1f
#define SHN_ABS		0xfff1
#define SHN_COMMON	0xfff2
#define SHN_HIRESERVE	0xffff
 
typedef struct elf32_shdr {
  Elf32_Word	sh_name;
  Elf32_Word	sh_type;
  Elf32_Word	sh_flags;
  Elf32_Addr	sh_addr;
  Elf32_Off	sh_offset;
  Elf32_Word	sh_size;
  Elf32_Word	sh_link;
  Elf32_Word	sh_info;
  Elf32_Word	sh_addralign;
  Elf32_Word	sh_entsize;
} Elf32_Shdr;

typedef struct elf64_shdr {
  Elf64_Word sh_name;		/* Section name, index in string tbl */
  Elf64_Word sh_type;		/* Type of section */
  Elf64_Xword sh_flags;		/* Miscellaneous section attributes */
  Elf64_Addr sh_addr;		/* Section virtual addr at execution */
  Elf64_Off sh_offset;		/* Section file offset */
  Elf64_Xword sh_size;		/* Size of section in bytes */
  Elf64_Word sh_link;		/* Index of another section */
  Elf64_Word sh_info;		/* Additional section information */
  Elf64_Xword sh_addralign;	/* Section alignment */
  Elf64_Xword sh_entsize;	/* Entry size if section holds table */
} Elf64_Shdr;

#define	EI_MAG0		0		/* e_ident[] indexes */
#define	EI_MAG1		1
#define	EI_MAG2		2
#define	EI_MAG3		3
#define	EI_CLASS	4
#define	EI_DATA		5
#define	EI_VERSION	6
#define	EI_OSABI	7
#define	EI_PAD		8

#define	ELFMAG0		0x7f		/* EI_MAG */
#define	ELFMAG1		'E'
#define	ELFMAG2		'L'
#define	ELFMAG3		'F'
#define	ELFMAG		"\177ELF"
#define	SELFMAG		4

#define	ELFCLASSNONE	0		/* EI_CLASS */
#define	ELFCLASS32	1
#define	ELFCLASS64	2
#define	ELFCLASSNUM	3

#define ELFDATANONE	0		/* e_ident[EI_DATA] */
#define ELFDATA2LSB	1
#define ELFDATA2MSB	2

#define EV_NONE		0		/* e_version, EI_VERSION */
#define EV_CURRENT	1
#define EV_NUM		2

#define ELFOSABI_NONE	0
#define ELFOSABI_LINUX	3

#ifndef ELF_OSABI
#define ELF_OSABI ELFOSABI_NONE
#endif

/*
 * Notes used in ET_CORE. Architectures export some of the arch register sets
 * using the corresponding note types via the PTRACE_GETREGSET and
 * PTRACE_SETREGSET requests.
 */
#define NT_PRSTATUS	1
#define NT_PRFPREG	2
#define NT_PRPSINFO	3
#define NT_TASKSTRUCT	4
#define NT_AUXV		6
/*
 * Note to userspace developers: size of NT_SIGINFO note may increase
 * in the future to accomodate more fields, don't assume it is fixed!
 */
#define NT_SIGINFO      0x53494749
#define NT_FILE         0x46494c45
#define NT_PRXFPREG     0x46e62b7f      /* copied from gdb5.1/include/elf/common.h */
#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
#define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */
#define NT_S390_HIGH_GPRS	0x300	/* s390 upper register halves */
#define NT_S390_TIMER	0x301		/* s390 timer register */
#define NT_S390_TODCMP	0x302		/* s390 TOD clock comparator register */
#define NT_S390_TODPREG	0x303		/* s390 TOD programmable register */
#define NT_S390_CTRS	0x304		/* s390 control registers */
#define NT_S390_PREFIX	0x305		/* s390 prefix register */
#define NT_S390_LAST_BREAK	0x306	/* s390 breaking event address */
#define NT_S390_SYSTEM_CALL	0x307	/* s390 system call restart data */
#define NT_S390_TDB	0x308		/* s390 transaction diagnostic block */
#define NT_ARM_VFP	0x400		/* ARM VFP/NEON registers */
#define NT_ARM_TLS	0x401		/* ARM TLS register */
#define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */
#define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */
#define NT_METAG_CBUF	0x500		/* Metag catch buffer registers */
#define NT_METAG_RPIPE	0x501		/* Metag read pipeline state */
#define NT_METAG_TLS	0x502		/* Metag TLS pointer */


/* Note header in a PT_NOTE section */
typedef struct elf32_note {
  Elf32_Word	n_namesz;	/* Name size */
  Elf32_Word	n_descsz;	/* Content size */
  Elf32_Word	n_type;		/* Content type */
} Elf32_Nhdr;

/* Note header in a PT_NOTE section */
typedef struct elf64_note {
  Elf64_Word n_namesz;	/* Name size */
  Elf64_Word n_descsz;	/* Content size */
  Elf64_Word n_type;	/* Content type */
} Elf64_Nhdr;

#endif /* _LINUX_ELF_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #ifndef _LINUX_ELFCORE_H
#define _LINUX_ELFCORE_H

#include <linux/types.h>
#include <linux/signal.h>
#include <linux/time.h>
#include <linux/ptrace.h>
#include <linux/elf.h>
#include <linux/fs.h>

struct elf_siginfo
{
	int	si_signo;			/* signal number */
	int	si_code;			/* extra code */
	int	si_errno;			/* errno */
};


typedef elf_greg_t greg_t;
typedef elf_gregset_t gregset_t;
typedef elf_fpregset_t fpregset_t;
typedef elf_fpxregset_t fpxregset_t;
#define NGREG ELF_NGREG

/*
 * Definitions to generate Intel SVR4-like core files.
 * These mostly have the same names as the SVR4 types with "elf_"
 * tacked on the front to prevent clashes with linux definitions,
 * and the typedef forms have been avoided.  This is mostly like
 * the SVR4 structure, but more Linuxy, with things that Linux does
 * not support and which gdb doesn't really use excluded.
 * Fields present but not used are marked with "XXX".
 */
struct elf_prstatus
{
#if 0
	long	pr_flags;	/* XXX Process flags */
	short	pr_why;		/* XXX Reason for process halt */
	short	pr_what;	/* XXX More detailed reason */
#endif
	struct elf_siginfo pr_info;	/* Info associated with signal */
	short	pr_cursig;		/* Current signal */
	unsigned long pr_sigpend;	/* Set of pending signals */
	unsigned long pr_sighold;	/* Set of held signals */
#if 0
	struct sigaltstack pr_altstack;	/* Alternate stack info */
	struct sigaction pr_action;	/* Signal action for current sig */
#endif
	pid_t	pr_pid;
	pid_t	pr_ppid;
	pid_t	pr_pgrp;
	pid_t	pr_sid;
	struct timeval pr_utime;	/* User time */
	struct timeval pr_stime;	/* System time */
	struct timeval pr_cutime;	/* Cumulative user time */
	struct timeval pr_cstime;	/* Cumulative system time */
#if 0
	long	pr_instr;		/* Current instruction */
#endif
	elf_gregset_t pr_reg;	/* GP registers */
#ifdef CONFIG_BINFMT_ELF_FDPIC
	/* When using FDPIC, the loadmap addresses need to be communicated
	 * to GDB in order for GDB to do the necessary relocations.  The
	 * fields (below) used to communicate this information are placed
	 * immediately after ``pr_reg'', so that the loadmap addresses may
	 * be viewed as part of the register set if so desired.
	 */
	unsigned long pr_exec_fdpic_loadmap;
	unsigned long pr_interp_fdpic_loadmap;
#endif
	int pr_fpvalid;		/* True if math co-processor being used.  */
};

#define ELF_PRARGSZ	(80)	/* Number of chars for args */

struct elf_prpsinfo
{
	char	pr_state;	/* numeric process state */
	char	pr_sname;	/* char for pr_state */
	char	pr_zomb;	/* zombie */
	char	pr_nice;	/* nice val */
	unsigned long pr_flag;	/* flags */
	__kernel_uid_t	pr_uid;
	__kernel_gid_t	pr_gid;
	pid_t	pr_pid, pr_ppid, pr_pgrp, pr_sid;
	/* Lots missing */
	char	pr_fname[16];	/* filename of executable */
	char	pr_psargs[ELF_PRARGSZ];	/* initial part of arg list */
};

typedef struct elf_prstatus prstatus_t;
typedef struct elf_prpsinfo prpsinfo_t;
#define PRARGSZ ELF_PRARGSZ 


#endif /* _LINUX_ELFCORE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #include <asm/errno.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef _LINUX_ERRQUEUE_H
#define _LINUX_ERRQUEUE_H

#include <linux/types.h>

struct sock_extended_err {
	__u32	ee_errno;	
	__u8	ee_origin;
	__u8	ee_type;
	__u8	ee_code;
	__u8	ee_pad;
	__u32   ee_info;
	__u32   ee_data;
};

#define SO_EE_ORIGIN_NONE	0
#define SO_EE_ORIGIN_LOCAL	1
#define SO_EE_ORIGIN_ICMP	2
#define SO_EE_ORIGIN_ICMP6	3
#define SO_EE_ORIGIN_TXSTATUS	4
#define SO_EE_ORIGIN_TIMESTAMPING SO_EE_ORIGIN_TXSTATUS

#define SO_EE_OFFENDER(ee)	((struct sockaddr*)((ee)+1))


#endif /* _LINUX_ERRQUEUE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * ethtool.h: Defines for Linux ethtool.
 *
 * Copyright (C) 1998 David S. Miller (davem@redhat.com)
 * Copyright 2001 Jeff Garzik <jgarzik@pobox.com>
 * Portions Copyright 2001 Sun Microsystems (thockin@sun.com)
 * Portions Copyright 2002 Intel (eli.kupermann@intel.com,
 *                                christopher.leech@intel.com,
 *                                scott.feldman@intel.com)
 * Portions Copyright (C) Sun Microsystems 2008
 */

#ifndef _LINUX_ETHTOOL_H
#define _LINUX_ETHTOOL_H

#include <linux/types.h>
#include <linux/if_ether.h>

/* All structures exposed to userland should be defined such that they
 * have the same layout for 32-bit and 64-bit userland.
 */

/**
 * struct ethtool_cmd - link control and status
 * @cmd: Command number = %ETHTOOL_GSET or %ETHTOOL_SSET
 * @supported: Bitmask of %SUPPORTED_* flags for the link modes,
 *	physical connectors and other link features for which the
 *	interface supports autonegotiation or auto-detection.
 *	Read-only.
 * @advertising: Bitmask of %ADVERTISED_* flags for the link modes,
 *	physical connectors and other link features that are
 *	advertised through autonegotiation or enabled for
 *	auto-detection.
 * @speed: Low bits of the speed
 * @duplex: Duplex mode; one of %DUPLEX_*
 * @port: Physical connector type; one of %PORT_*
 * @phy_address: MDIO address of PHY (transceiver); 0 or 255 if not
 *	applicable.  For clause 45 PHYs this is the PRTAD.
 * @transceiver: Historically used to distinguish different possible
 *	PHY types, but not in a consistent way.  Deprecated.
 * @autoneg: Enable/disable autonegotiation and auto-detection;
 *	either %AUTONEG_DISABLE or %AUTONEG_ENABLE
 * @mdio_support: Bitmask of %ETH_MDIO_SUPPORTS_* flags for the MDIO
 *	protocols supported by the interface; 0 if unknown.
 *	Read-only.
 * @maxtxpkt: Historically used to report TX IRQ coalescing; now
 *	obsoleted by &struct ethtool_coalesce.  Read-only; deprecated.
 * @maxrxpkt: Historically used to report RX IRQ coalescing; now
 *	obsoleted by &struct ethtool_coalesce.  Read-only; deprecated.
 * @speed_hi: High bits of the speed
 * @eth_tp_mdix: Ethernet twisted-pair MDI(-X) status; one of
 *	%ETH_TP_MDI_*.  If the status is unknown or not applicable, the
 *	value will be %ETH_TP_MDI_INVALID.  Read-only.
 * @eth_tp_mdix_ctrl: Ethernet twisted pair MDI(-X) control; one of
 *	%ETH_TP_MDI_*.  If MDI(-X) control is not implemented, reads
 *	yield %ETH_TP_MDI_INVALID and writes may be ignored or rejected.
 *	When written successfully, the link should be renegotiated if
 *	necessary.
 * @lp_advertising: Bitmask of %ADVERTISED_* flags for the link modes
 *	and other link features that the link partner advertised
 *	through autonegotiation; 0 if unknown or not applicable.
 *	Read-only.
 *
 * The link speed in Mbps is split between @speed and @speed_hi.  Use
 * the ethtool_cmd_speed() and ethtool_cmd_speed_set() functions to
 * access it.
 *
 * If autonegotiation is disabled, the speed and @duplex represent the
 * fixed link mode and are writable if the driver supports multiple
 * link modes.  If it is enabled then they are read-only; if the link
 * is up they represent the negotiated link mode; if the link is down,
 * the speed is 0, %SPEED_UNKNOWN or the highest enabled speed and
 * @duplex is %DUPLEX_UNKNOWN or the best enabled duplex mode.
 *
 * Some hardware interfaces may have multiple PHYs and/or physical
 * connectors fitted or do not allow the driver to detect which are
 * fitted.  For these interfaces @port and/or @phy_address may be
 * writable, possibly dependent on @autoneg being %AUTONEG_DISABLE.
 * Otherwise, attempts to write different values may be ignored or
 * rejected.
 *
 * Users should assume that all fields not marked read-only are
 * writable and subject to validation by the driver.  They should use
 * %ETHTOOL_GSET to get the current values before making specific
 * changes and then applying them with %ETHTOOL_SSET.
 *
 * Drivers that implement set_settings() should validate all fields
 * other than @cmd that are not described as read-only or deprecated,
 * and must ignore all fields described as read-only.
 *
 * Deprecated fields should be ignored by both users and drivers.
 */
struct ethtool_cmd {
	__u32	cmd;
	__u32	supported;
	__u32	advertising;
	__u16	speed;
	__u8	duplex;
	__u8	port;
	__u8	phy_address;
	__u8	transceiver;
	__u8	autoneg;
	__u8	mdio_support;
	__u32	maxtxpkt;
	__u32	maxrxpkt;
	__u16	speed_hi;
	__u8	eth_tp_mdix;
	__u8	eth_tp_mdix_ctrl;
	__u32	lp_advertising;
	__u32	reserved[2];
};

static __inline__ void ethtool_cmd_speed_set(struct ethtool_cmd *ep,
					 __u32 speed)
{

	ep->speed = (__u16)speed;
	ep->speed_hi = (__u16)(speed >> 16);
}

static __inline__ __u32 ethtool_cmd_speed(const struct ethtool_cmd *ep)
{
	return (ep->speed_hi << 16) | ep->speed;
}

/* Device supports clause 22 register access to PHY or peripherals
 * using the interface defined in <linux/mii.h>.  This should not be
 * set if there are known to be no such peripherals present or if
 * the driver only emulates clause 22 registers for compatibility.
 */
#define ETH_MDIO_SUPPORTS_C22	1

/* Device supports clause 45 register access to PHY or peripherals
 * using the interface defined in <linux/mii.h> and <linux/mdio.h>.
 * This should not be set if there are known to be no such peripherals
 * present.
 */
#define ETH_MDIO_SUPPORTS_C45	2

#define ETHTOOL_FWVERS_LEN	32
#define ETHTOOL_BUSINFO_LEN	32

/**
 * struct ethtool_drvinfo - general driver and device information
 * @cmd: Command number = %ETHTOOL_GDRVINFO
 * @driver: Driver short name.  This should normally match the name
 *	in its bus driver structure (e.g. pci_driver::name).  Must
 *	not be an empty string.
 * @version: Driver version string; may be an empty string
 * @fw_version: Firmware version string; may be an empty string
 * @bus_info: Device bus address.  This should match the dev_name()
 *	string for the underlying bus device, if there is one.  May be
 *	an empty string.
 * @n_priv_flags: Number of flags valid for %ETHTOOL_GPFLAGS and
 *	%ETHTOOL_SPFLAGS commands; also the number of strings in the
 *	%ETH_SS_PRIV_FLAGS set
 * @n_stats: Number of u64 statistics returned by the %ETHTOOL_GSTATS
 *	command; also the number of strings in the %ETH_SS_STATS set
 * @testinfo_len: Number of results returned by the %ETHTOOL_TEST
 *	command; also the number of strings in the %ETH_SS_TEST set
 * @eedump_len: Size of EEPROM accessible through the %ETHTOOL_GEEPROM
 *	and %ETHTOOL_SEEPROM commands, in bytes
 * @regdump_len: Size of register dump returned by the %ETHTOOL_GREGS
 *	command, in bytes
 *
 * Users can use the %ETHTOOL_GSSET_INFO command to get the number of
 * strings in any string set (from Linux 2.6.34).
 *
 * Drivers should set at most @driver, @version, @fw_version and
 * @bus_info in their get_drvinfo() implementation.  The ethtool
 * core fills in the other fields using other driver operations.
 */
struct ethtool_drvinfo {
	__u32	cmd;
	char	driver[32];
	char	version[32];
	char	fw_version[ETHTOOL_FWVERS_LEN];
	char	bus_info[ETHTOOL_BUSINFO_LEN];
	char	reserved1[32];
	char	reserved2[12];
	__u32	n_priv_flags;
	__u32	n_stats;
	__u32	testinfo_len;
	__u32	eedump_len;
	__u32	regdump_len;
};

#define SOPASS_MAX	6

/**
 * struct ethtool_wolinfo - Wake-On-Lan configuration
 * @cmd: Command number = %ETHTOOL_GWOL or %ETHTOOL_SWOL
 * @supported: Bitmask of %WAKE_* flags for supported Wake-On-Lan modes.
 *	Read-only.
 * @wolopts: Bitmask of %WAKE_* flags for enabled Wake-On-Lan modes.
 * @sopass: SecureOn(tm) password; meaningful only if %WAKE_MAGICSECURE
 *	is set in @wolopts.
 */
struct ethtool_wolinfo {
	__u32	cmd;
	__u32	supported;
	__u32	wolopts;
	__u8	sopass[SOPASS_MAX];
};

/* for passing single values */
struct ethtool_value {
	__u32	cmd;
	__u32	data;
};

/**
 * struct ethtool_regs - hardware register dump
 * @cmd: Command number = %ETHTOOL_GREGS
 * @version: Dump format version.  This is driver-specific and may
 *	distinguish different chips/revisions.  Drivers must use new
 *	version numbers whenever the dump format changes in an
 *	incompatible way.
 * @len: On entry, the real length of @data.  On return, the number of
 *	bytes used.
 * @data: Buffer for the register dump
 *
 * Users should use %ETHTOOL_GDRVINFO to find the maximum length of
 * a register dump for the interface.  They must allocate the buffer
 * immediately following this structure.
 */
struct ethtool_regs {
	__u32	cmd;
	__u32	version;
	__u32	len;
	__u8	data[0];
};

/**
 * struct ethtool_eeprom - EEPROM dump
 * @cmd: Command number = %ETHTOOL_GEEPROM, %ETHTOOL_GMODULEEEPROM or
 *	%ETHTOOL_SEEPROM
 * @magic: A 'magic cookie' value to guard against accidental changes.
 *	The value passed in to %ETHTOOL_SEEPROM must match the value
 *	returned by %ETHTOOL_GEEPROM for the same device.  This is
 *	unused when @cmd is %ETHTOOL_GMODULEEEPROM.
 * @offset: Offset within the EEPROM to begin reading/writing, in bytes
 * @len: On entry, number of bytes to read/write.  On successful
 *	return, number of bytes actually read/written.  In case of
 *	error, this may indicate at what point the error occurred.
 * @data: Buffer to read/write from
 *
 * Users may use %ETHTOOL_GDRVINFO or %ETHTOOL_GMODULEINFO to find
 * the length of an on-board or module EEPROM, respectively.  They
 * must allocate the buffer immediately following this structure.
 */
struct ethtool_eeprom {
	__u32	cmd;
	__u32	magic;
	__u32	offset;
	__u32	len;
	__u8	data[0];
};

/**
 * struct ethtool_eee - Energy Efficient Ethernet information
 * @cmd: ETHTOOL_{G,S}EEE
 * @supported: Mask of %SUPPORTED_* flags for the speed/duplex combinations
 *	for which there is EEE support.
 * @advertised: Mask of %ADVERTISED_* flags for the speed/duplex combinations
 *	advertised as eee capable.
 * @lp_advertised: Mask of %ADVERTISED_* flags for the speed/duplex
 *	combinations advertised by the link partner as eee capable.
 * @eee_active: Result of the eee auto negotiation.
 * @eee_enabled: EEE configured mode (enabled/disabled).
 * @tx_lpi_enabled: Whether the interface should assert its tx lpi, given
 *	that eee was negotiated.
 * @tx_lpi_timer: Time in microseconds the interface delays prior to asserting
 *	its tx lpi (after reaching 'idle' state). Effective only when eee
 *	was negotiated and tx_lpi_enabled was set.
 */
struct ethtool_eee {
	__u32	cmd;
	__u32	supported;
	__u32	advertised;
	__u32	lp_advertised;
	__u32	eee_active;
	__u32	eee_enabled;
	__u32	tx_lpi_enabled;
	__u32	tx_lpi_timer;
	__u32	reserved[2];
};

/**
 * struct ethtool_modinfo - plugin module eeprom information
 * @cmd: %ETHTOOL_GMODULEINFO
 * @type: Standard the module information conforms to %ETH_MODULE_SFF_xxxx
 * @eeprom_len: Length of the eeprom
 *
 * This structure is used to return the information to
 * properly size memory for a subsequent call to %ETHTOOL_GMODULEEEPROM.
 * The type code indicates the eeprom data format
 */
struct ethtool_modinfo {
	__u32   cmd;
	__u32   type;
	__u32   eeprom_len;
	__u32   reserved[8];
};

/**
 * struct ethtool_coalesce - coalescing parameters for IRQs and stats updates
 * @cmd: ETHTOOL_{G,S}COALESCE
 * @rx_coalesce_usecs: How many usecs to delay an RX interrupt after
 *	a packet arrives.
 * @rx_max_coalesced_frames: Maximum number of packets to receive
 *	before an RX interrupt.
 * @rx_coalesce_usecs_irq: Same as @rx_coalesce_usecs, except that
 *	this value applies while an IRQ is being serviced by the host.
 * @rx_max_coalesced_frames_irq: Same as @rx_max_coalesced_frames,
 *	except that this value applies while an IRQ is being serviced
 *	by the host.
 * @tx_coalesce_usecs: How many usecs to delay a TX interrupt after
 *	a packet is sent.
 * @tx_max_coalesced_frames: Maximum number of packets to be sent
 *	before a TX interrupt.
 * @tx_coalesce_usecs_irq: Same as @tx_coalesce_usecs, except that
 *	this value applies while an IRQ is being serviced by the host.
 * @tx_max_coalesced_frames_irq: Same as @tx_max_coalesced_frames,
 *	except that this value applies while an IRQ is being serviced
 *	by the host.
 * @stats_block_coalesce_usecs: How many usecs to delay in-memory
 *	statistics block updates.  Some drivers do not have an
 *	in-memory statistic block, and in such cases this value is
 *	ignored.  This value must not be zero.
 * @use_adaptive_rx_coalesce: Enable adaptive RX coalescing.
 * @use_adaptive_tx_coalesce: Enable adaptive TX coalescing.
 * @pkt_rate_low: Threshold for low packet rate (packets per second).
 * @rx_coalesce_usecs_low: How many usecs to delay an RX interrupt after
 *	a packet arrives, when the packet rate is below @pkt_rate_low.
 * @rx_max_coalesced_frames_low: Maximum number of packets to be received
 *	before an RX interrupt, when the packet rate is below @pkt_rate_low.
 * @tx_coalesce_usecs_low: How many usecs to delay a TX interrupt after
 *	a packet is sent, when the packet rate is below @pkt_rate_low.
 * @tx_max_coalesced_frames_low: Maximum nuumber of packets to be sent before
 *	a TX interrupt, when the packet rate is below @pkt_rate_low.
 * @pkt_rate_high: Threshold for high packet rate (packets per second).
 * @rx_coalesce_usecs_high: How many usecs to delay an RX interrupt after
 *	a packet arrives, when the packet rate is above @pkt_rate_high.
 * @rx_max_coalesced_frames_high: Maximum number of packets to be received
 *	before an RX interrupt, when the packet rate is above @pkt_rate_high.
 * @tx_coalesce_usecs_high: How many usecs to delay a TX interrupt after
 *	a packet is sent, when the packet rate is above @pkt_rate_high.
 * @tx_max_coalesced_frames_high: Maximum number of packets to be sent before
 *	a TX interrupt, when the packet rate is above @pkt_rate_high.
 * @rate_sample_interval: How often to do adaptive coalescing packet rate
 *	sampling, measured in seconds.  Must not be zero.
 *
 * Each pair of (usecs, max_frames) fields specifies that interrupts
 * should be coalesced until
 *	(usecs > 0 && time_since_first_completion >= usecs) ||
 *	(max_frames > 0 && completed_frames >= max_frames)
 *
 * It is illegal to set both usecs and max_frames to zero as this
 * would cause interrupts to never be generated.  To disable
 * coalescing, set usecs = 0 and max_frames = 1.
 *
 * Some implementations ignore the value of max_frames and use the
 * condition time_since_first_completion >= usecs
 *
 * This is deprecated.  Drivers for hardware that does not support
 * counting completions should validate that max_frames == !rx_usecs.
 *
 * Adaptive RX/TX coalescing is an algorithm implemented by some
 * drivers to improve latency under low packet rates and improve
 * throughput under high packet rates.  Some drivers only implement
 * one of RX or TX adaptive coalescing.  Anything not implemented by
 * the driver causes these values to be silently ignored.
 *
 * When the packet rate is below @pkt_rate_high but above
 * @pkt_rate_low (both measured in packets per second) the
 * normal {rx,tx}_* coalescing parameters are used.
 */
struct ethtool_coalesce {
	__u32	cmd;
	__u32	rx_coalesce_usecs;
	__u32	rx_max_coalesced_frames;
	__u32	rx_coalesce_usecs_irq;
	__u32	rx_max_coalesced_frames_irq;
	__u32	tx_coalesce_usecs;
	__u32	tx_max_coalesced_frames;
	__u32	tx_coalesce_usecs_irq;
	__u32	tx_max_coalesced_frames_irq;
	__u32	stats_block_coalesce_usecs;
	__u32	use_adaptive_rx_coalesce;
	__u32	use_adaptive_tx_coalesce;
	__u32	pkt_rate_low;
	__u32	rx_coalesce_usecs_low;
	__u32	rx_max_coalesced_frames_low;
	__u32	tx_coalesce_usecs_low;
	__u32	tx_max_coalesced_frames_low;
	__u32	pkt_rate_high;
	__u32	rx_coalesce_usecs_high;
	__u32	rx_max_coalesced_frames_high;
	__u32	tx_coalesce_usecs_high;
	__u32	tx_max_coalesced_frames_high;
	__u32	rate_sample_interval;
};

/**
 * struct ethtool_ringparam - RX/TX ring parameters
 * @cmd: Command number = %ETHTOOL_GRINGPARAM or %ETHTOOL_SRINGPARAM
 * @rx_max_pending: Maximum supported number of pending entries per
 *	RX ring.  Read-only.
 * @rx_mini_max_pending: Maximum supported number of pending entries
 *	per RX mini ring.  Read-only.
 * @rx_jumbo_max_pending: Maximum supported number of pending entries
 *	per RX jumbo ring.  Read-only.
 * @tx_max_pending: Maximum supported number of pending entries per
 *	TX ring.  Read-only.
 * @rx_pending: Current maximum number of pending entries per RX ring
 * @rx_mini_pending: Current maximum number of pending entries per RX
 *	mini ring
 * @rx_jumbo_pending: Current maximum number of pending entries per RX
 *	jumbo ring
 * @tx_pending: Current maximum supported number of pending entries
 *	per TX ring
 *
 * If the interface does not have separate RX mini and/or jumbo rings,
 * @rx_mini_max_pending and/or @rx_jumbo_max_pending will be 0.
 *
 * There may also be driver-dependent minimum values for the number
 * of entries per ring.
 */
struct ethtool_ringparam {
	__u32	cmd;
	__u32	rx_max_pending;
	__u32	rx_mini_max_pending;
	__u32	rx_jumbo_max_pending;
	__u32	tx_max_pending;
	__u32	rx_pending;
	__u32	rx_mini_pending;
	__u32	rx_jumbo_pending;
	__u32	tx_pending;
};

/**
 * struct ethtool_channels - configuring number of network channel
 * @cmd: ETHTOOL_{G,S}CHANNELS
 * @max_rx: Read only. Maximum number of receive channel the driver support.
 * @max_tx: Read only. Maximum number of transmit channel the driver support.
 * @max_other: Read only. Maximum number of other channel the driver support.
 * @max_combined: Read only. Maximum number of combined channel the driver
 *	support. Set of queues RX, TX or other.
 * @rx_count: Valid values are in the range 1 to the max_rx.
 * @tx_count: Valid values are in the range 1 to the max_tx.
 * @other_count: Valid values are in the range 1 to the max_other.
 * @combined_count: Valid values are in the range 1 to the max_combined.
 *
 * This can be used to configure RX, TX and other channels.
 */

struct ethtool_channels {
	__u32	cmd;
	__u32	max_rx;
	__u32	max_tx;
	__u32	max_other;
	__u32	max_combined;
	__u32	rx_count;
	__u32	tx_count;
	__u32	other_count;
	__u32	combined_count;
};

/**
 * struct ethtool_pauseparam - Ethernet pause (flow control) parameters
 * @cmd: Command number = %ETHTOOL_GPAUSEPARAM or %ETHTOOL_SPAUSEPARAM
 * @autoneg: Flag to enable autonegotiation of pause frame use
 * @rx_pause: Flag to enable reception of pause frames
 * @tx_pause: Flag to enable transmission of pause frames
 *
 * Drivers should reject a non-zero setting of @autoneg when
 * autoneogotiation is disabled (or not supported) for the link.
 *
 * If the link is autonegotiated, drivers should use
 * mii_advertise_flowctrl() or similar code to set the advertised
 * pause frame capabilities based on the @rx_pause and @tx_pause flags,
 * even if @autoneg is zero.  They should also allow the advertised
 * pause frame capabilities to be controlled directly through the
 * advertising field of &struct ethtool_cmd.
 *
 * If @autoneg is non-zero, the MAC is configured to send and/or
 * receive pause frames according to the result of autonegotiation.
 * Otherwise, it is configured directly based on the @rx_pause and
 * @tx_pause flags.
 */
struct ethtool_pauseparam {
	__u32	cmd;
	__u32	autoneg;
	__u32	rx_pause;
	__u32	tx_pause;
};

#define ETH_GSTRING_LEN		32

/**
 * enum ethtool_stringset - string set ID
 * @ETH_SS_TEST: Self-test result names, for use with %ETHTOOL_TEST
 * @ETH_SS_STATS: Statistic names, for use with %ETHTOOL_GSTATS
 * @ETH_SS_PRIV_FLAGS: Driver private flag names, for use with
 *	%ETHTOOL_GPFLAGS and %ETHTOOL_SPFLAGS
 * @ETH_SS_NTUPLE_FILTERS: Previously used with %ETHTOOL_GRXNTUPLE;
 *	now deprecated
 * @ETH_SS_FEATURES: Device feature names
 */
enum ethtool_stringset {
	ETH_SS_TEST		= 0,
	ETH_SS_STATS,
	ETH_SS_PRIV_FLAGS,
	ETH_SS_NTUPLE_FILTERS,
	ETH_SS_FEATURES,
};

/**
 * struct ethtool_gstrings - string set for data tagging
 * @cmd: Command number = %ETHTOOL_GSTRINGS
 * @string_set: String set ID; one of &enum ethtool_stringset
 * @len: On return, the number of strings in the string set
 * @data: Buffer for strings.  Each string is null-padded to a size of
 *	%ETH_GSTRING_LEN.
 *
 * Users must use %ETHTOOL_GSSET_INFO to find the number of strings in
 * the string set.  They must allocate a buffer of the appropriate
 * size immediately following this structure.
 */
struct ethtool_gstrings {
	__u32	cmd;
	__u32	string_set;
	__u32	len;
	__u8	data[0];
};

/**
 * struct ethtool_sset_info - string set information
 * @cmd: Command number = %ETHTOOL_GSSET_INFO
 * @sset_mask: On entry, a bitmask of string sets to query, with bits
 *	numbered according to &enum ethtool_stringset.  On return, a
 *	bitmask of those string sets queried that are supported.
 * @data: Buffer for string set sizes.  On return, this contains the
 *	size of each string set that was queried and supported, in
 *	order of ID.
 *
 * Example: The user passes in @sset_mask = 0x7 (sets 0, 1, 2) and on
 * return @sset_mask == 0x6 (sets 1, 2).  Then @data[0] contains the
 * size of set 1 and @data[1] contains the size of set 2.
 *
 * Users must allocate a buffer of the appropriate size (4 * number of
 * sets queried) immediately following this structure.
 */
struct ethtool_sset_info {
	__u32	cmd;
	__u32	reserved;
	__u64	sset_mask;
	__u32	data[0];
};

/**
 * enum ethtool_test_flags - flags definition of ethtool_test
 * @ETH_TEST_FL_OFFLINE: if set perform online and offline tests, otherwise
 *	only online tests.
 * @ETH_TEST_FL_FAILED: Driver set this flag if test fails.
 * @ETH_TEST_FL_EXTERNAL_LB: Application request to perform external loopback
 *	test.
 * @ETH_TEST_FL_EXTERNAL_LB_DONE: Driver performed the external loopback test
 */

enum ethtool_test_flags {
	ETH_TEST_FL_OFFLINE	= (1 << 0),
	ETH_TEST_FL_FAILED	= (1 << 1),
	ETH_TEST_FL_EXTERNAL_LB	= (1 << 2),
	ETH_TEST_FL_EXTERNAL_LB_DONE	= (1 << 3),
};

/**
 * struct ethtool_test - device self-test invocation
 * @cmd: Command number = %ETHTOOL_TEST
 * @flags: A bitmask of flags from &enum ethtool_test_flags.  Some
 *	flags may be set by the user on entry; others may be set by
 *	the driver on return.
 * @len: On return, the number of test results
 * @data: Array of test results
 *
 * Users must use %ETHTOOL_GSSET_INFO or %ETHTOOL_GDRVINFO to find the
 * number of test results that will be returned.  They must allocate a
 * buffer of the appropriate size (8 * number of results) immediately
 * following this structure.
 */
struct ethtool_test {
	__u32	cmd;
	__u32	flags;
	__u32	reserved;
	__u32	len;
	__u64	data[0];
};

/**
 * struct ethtool_stats - device-specific statistics
 * @cmd: Command number = %ETHTOOL_GSTATS
 * @n_stats: On return, the number of statistics
 * @data: Array of statistics
 *
 * Users must use %ETHTOOL_GSSET_INFO or %ETHTOOL_GDRVINFO to find the
 * number of statistics that will be returned.  They must allocate a
 * buffer of the appropriate size (8 * number of statistics)
 * immediately following this structure.
 */
struct ethtool_stats {
	__u32	cmd;
	__u32	n_stats;
	__u64	data[0];
};

/**
 * struct ethtool_perm_addr - permanent hardware address
 * @cmd: Command number = %ETHTOOL_GPERMADDR
 * @size: On entry, the size of the buffer.  On return, the size of the
 *	address.  The command fails if the buffer is too small.
 * @data: Buffer for the address
 *
 * Users must allocate the buffer immediately following this structure.
 * A buffer size of %MAX_ADDR_LEN should be sufficient for any address
 * type.
 */
struct ethtool_perm_addr {
	__u32	cmd;
	__u32	size;
	__u8	data[0];
};

/* boolean flags controlling per-interface behavior characteristics.
 * When reading, the flag indicates whether or not a certain behavior
 * is enabled/present.  When writing, the flag indicates whether
 * or not the driver should turn on (set) or off (clear) a behavior.
 *
 * Some behaviors may read-only (unconditionally absent or present).
 * If such is the case, return EINVAL in the set-flags operation if the
 * flag differs from the read-only value.
 */
enum ethtool_flags {
	ETH_FLAG_TXVLAN		= (1 << 7),	/* TX VLAN offload enabled */
	ETH_FLAG_RXVLAN		= (1 << 8),	/* RX VLAN offload enabled */
	ETH_FLAG_LRO		= (1 << 15),	/* LRO is enabled */
	ETH_FLAG_NTUPLE		= (1 << 27),	/* N-tuple filters enabled */
	ETH_FLAG_RXHASH		= (1 << 28),
};

/* The following structures are for supporting RX network flow
 * classification and RX n-tuple configuration. Note, all multibyte
 * fields, e.g., ip4src, ip4dst, psrc, pdst, spi, etc. are expected to
 * be in network byte order.
 */

/**
 * struct ethtool_tcpip4_spec - flow specification for TCP/IPv4 etc.
 * @ip4src: Source host
 * @ip4dst: Destination host
 * @psrc: Source port
 * @pdst: Destination port
 * @tos: Type-of-service
 *
 * This can be used to specify a TCP/IPv4, UDP/IPv4 or SCTP/IPv4 flow.
 */
struct ethtool_tcpip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__be16	psrc;
	__be16	pdst;
	__u8    tos;
};

/**
 * struct ethtool_ah_espip4_spec - flow specification for IPsec/IPv4
 * @ip4src: Source host
 * @ip4dst: Destination host
 * @spi: Security parameters index
 * @tos: Type-of-service
 *
 * This can be used to specify an IPsec transport or tunnel over IPv4.
 */
struct ethtool_ah_espip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__be32	spi;
	__u8    tos;
};

#define	ETH_RX_NFC_IP4	1

/**
 * struct ethtool_usrip4_spec - general flow specification for IPv4
 * @ip4src: Source host
 * @ip4dst: Destination host
 * @l4_4_bytes: First 4 bytes of transport (layer 4) header
 * @tos: Type-of-service
 * @ip_ver: Value must be %ETH_RX_NFC_IP4; mask must be 0
 * @proto: Transport protocol number; mask must be 0
 */
struct ethtool_usrip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__be32	l4_4_bytes;
	__u8    tos;
	__u8    ip_ver;
	__u8    proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec		tcp_ip4_spec;
	struct ethtool_tcpip4_spec		udp_ip4_spec;
	struct ethtool_tcpip4_spec		sctp_ip4_spec;
	struct ethtool_ah_espip4_spec		ah_ip4_spec;
	struct ethtool_ah_espip4_spec		esp_ip4_spec;
	struct ethtool_usrip4_spec		usr_ip4_spec;
	struct ethhdr				ether_spec;
	__u8					hdata[52];
};

/**
 * struct ethtool_flow_ext - additional RX flow fields
 * @h_dest: destination MAC address
 * @vlan_etype: VLAN EtherType
 * @vlan_tci: VLAN tag control information
 * @data: user defined data
 *
 * Note, @vlan_etype, @vlan_tci, and @data are only valid if %FLOW_EXT
 * is set in &struct ethtool_rx_flow_spec @flow_type.
 * @h_dest is valid if %FLOW_MAC_EXT is set.
 */
struct ethtool_flow_ext {
	__u8		padding[2];
	unsigned char	h_dest[ETH_ALEN];
	__be16		vlan_etype;
	__be16		vlan_tci;
	__be32		data[2];
};

/**
 * struct ethtool_rx_flow_spec - classification rule for RX flows
 * @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW
 * @h_u: Flow fields to match (dependent on @flow_type)
 * @h_ext: Additional fields to match
 * @m_u: Masks for flow field bits to be matched
 * @m_ext: Masks for additional field bits to be matched
 *	Note, all additional fields must be ignored unless @flow_type
 *	includes the %FLOW_EXT or %FLOW_MAC_EXT flag
 *	(see &struct ethtool_flow_ext description).
 * @ring_cookie: RX ring/queue index to deliver to, or %RX_CLS_FLOW_DISC
 *	if packets should be discarded
 * @location: Location of rule in the table.  Locations must be
 *	numbered such that a flow matching multiple rules will be
 *	classified according to the first (lowest numbered) rule.
 */
struct ethtool_rx_flow_spec {
	__u32		flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	__u64		ring_cookie;
	__u32		location;
};

/**
 * struct ethtool_rxnfc - command to get or set RX flow classification rules
 * @cmd: Specific command number - %ETHTOOL_GRXFH, %ETHTOOL_SRXFH,
 *	%ETHTOOL_GRXRINGS, %ETHTOOL_GRXCLSRLCNT, %ETHTOOL_GRXCLSRULE,
 *	%ETHTOOL_GRXCLSRLALL, %ETHTOOL_SRXCLSRLDEL or %ETHTOOL_SRXCLSRLINS
 * @flow_type: Type of flow to be affected, e.g. %TCP_V4_FLOW
 * @data: Command-dependent value
 * @fs: Flow classification rule
 * @rule_cnt: Number of rules to be affected
 * @rule_locs: Array of used rule locations
 *
 * For %ETHTOOL_GRXFH and %ETHTOOL_SRXFH, @data is a bitmask indicating
 * the fields included in the flow hash, e.g. %RXH_IP_SRC.  The following
 * structure fields must not be used.
 *
 * For %ETHTOOL_GRXRINGS, @data is set to the number of RX rings/queues
 * on return.
 *
 * For %ETHTOOL_GRXCLSRLCNT, @rule_cnt is set to the number of defined
 * rules on return.  If @data is non-zero on return then it is the
 * size of the rule table, plus the flag %RX_CLS_LOC_SPECIAL if the
 * driver supports any special location values.  If that flag is not
 * set in @data then special location values should not be used.
 *
 * For %ETHTOOL_GRXCLSRULE, @fs.@location specifies the location of an
 * existing rule on entry and @fs contains the rule on return.
 *
 * For %ETHTOOL_GRXCLSRLALL, @rule_cnt specifies the array size of the
 * user buffer for @rule_locs on entry.  On return, @data is the size
 * of the rule table, @rule_cnt is the number of defined rules, and
 * @rule_locs contains the locations of the defined rules.  Drivers
 * must use the second parameter to get_rxnfc() instead of @rule_locs.
 *
 * For %ETHTOOL_SRXCLSRLINS, @fs specifies the rule to add or update.
 * @fs.@location either specifies the location to use or is a special
 * location value with %RX_CLS_LOC_SPECIAL flag set.  On return,
 * @fs.@location is the actual rule location.
 *
 * For %ETHTOOL_SRXCLSRLDEL, @fs.@location specifies the location of an
 * existing rule on entry.
 *
 * A driver supporting the special location values for
 * %ETHTOOL_SRXCLSRLINS may add the rule at any suitable unused
 * location, and may remove a rule at a later location (lower
 * priority) that matches exactly the same set of flows.  The special
 * values are %RX_CLS_LOC_ANY, selecting any location;
 * %RX_CLS_LOC_FIRST, selecting the first suitable location (maximum
 * priority); and %RX_CLS_LOC_LAST, selecting the last suitable
 * location (minimum priority).  Additional special values may be
 * defined in future and drivers must return -%EINVAL for any
 * unrecognised value.
 */
struct ethtool_rxnfc {
	__u32				cmd;
	__u32				flow_type;
	__u64				data;
	struct ethtool_rx_flow_spec	fs;
	__u32				rule_cnt;
	__u32				rule_locs[0];
};


/**
 * struct ethtool_rxfh_indir - command to get or set RX flow hash indirection
 * @cmd: Specific command number - %ETHTOOL_GRXFHINDIR or %ETHTOOL_SRXFHINDIR
 * @size: On entry, the array size of the user buffer, which may be zero.
 *	On return from %ETHTOOL_GRXFHINDIR, the array size of the hardware
 *	indirection table.
 * @ring_index: RX ring/queue index for each hash value
 *
 * For %ETHTOOL_GRXFHINDIR, a @size of zero means that only the size
 * should be returned.  For %ETHTOOL_SRXFHINDIR, a @size of zero means
 * the table should be reset to default values.  This last feature
 * is not supported by the original implementations.
 */
struct ethtool_rxfh_indir {
	__u32	cmd;
	__u32	size;
	__u32	ring_index[0];
};

/**
 * struct ethtool_rxfh - command to get/set RX flow hash indir or/and hash key.
 * @cmd: Specific command number - %ETHTOOL_GRSSH or %ETHTOOL_SRSSH
 * @rss_context: RSS context identifier.
 * @indir_size: On entry, the array size of the user buffer for the
 *	indirection table, which may be zero, or (for %ETHTOOL_SRSSH),
 *	%ETH_RXFH_INDIR_NO_CHANGE.  On return from %ETHTOOL_GRSSH,
 *	the array size of the hardware indirection table.
 * @key_size: On entry, the array size of the user buffer for the hash key,
 *	which may be zero.  On return from %ETHTOOL_GRSSH, the size of the
 *	hardware hash key.
 * @rsvd:	Reserved for future extensions.
 * @rss_config: RX ring/queue index for each hash value i.e., indirection table
 *	of @indir_size __u32 elements, followed by hash key of @key_size
 *	bytes.
 *
 * For %ETHTOOL_GRSSH, a @indir_size and key_size of zero means that only the
 * size should be returned.  For %ETHTOOL_SRSSH, an @indir_size of
 * %ETH_RXFH_INDIR_NO_CHANGE means that indir table setting is not requested
 * and a @indir_size of zero means the indir table should be reset to default
 * values.
 */
struct ethtool_rxfh {
	__u32   cmd;
	__u32	rss_context;
	__u32   indir_size;
	__u32   key_size;
	__u32	rsvd[2];
	__u32   rss_config[0];
};
#define ETH_RXFH_INDIR_NO_CHANGE	0xffffffff

/**
 * struct ethtool_rx_ntuple_flow_spec - specification for RX flow filter
 * @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW
 * @h_u: Flow field values to match (dependent on @flow_type)
 * @m_u: Masks for flow field value bits to be ignored
 * @vlan_tag: VLAN tag to match
 * @vlan_tag_mask: Mask for VLAN tag bits to be ignored
 * @data: Driver-dependent data to match
 * @data_mask: Mask for driver-dependent data bits to be ignored
 * @action: RX ring/queue index to deliver to (non-negative) or other action
 *	(negative, e.g. %ETHTOOL_RXNTUPLE_ACTION_DROP)
 *
 * For flow types %TCP_V4_FLOW, %UDP_V4_FLOW and %SCTP_V4_FLOW, where
 * a field value and mask are both zero this is treated as if all mask
 * bits are set i.e. the field is ignored.
 */
struct ethtool_rx_ntuple_flow_spec {
	__u32		 flow_type;
	union {
		struct ethtool_tcpip4_spec		tcp_ip4_spec;
		struct ethtool_tcpip4_spec		udp_ip4_spec;
		struct ethtool_tcpip4_spec		sctp_ip4_spec;
		struct ethtool_ah_espip4_spec		ah_ip4_spec;
		struct ethtool_ah_espip4_spec		esp_ip4_spec;
		struct ethtool_usrip4_spec		usr_ip4_spec;
		struct ethhdr				ether_spec;
		__u8					hdata[72];
	} h_u, m_u;

	__u16	        vlan_tag;
	__u16	        vlan_tag_mask;
	__u64		data;
	__u64		data_mask;

	__s32		action;
#define ETHTOOL_RXNTUPLE_ACTION_DROP	(-1)	/* drop packet */
#define ETHTOOL_RXNTUPLE_ACTION_CLEAR	(-2)	/* clear filter */
};

/**
 * struct ethtool_rx_ntuple - command to set or clear RX flow filter
 * @cmd: Command number - %ETHTOOL_SRXNTUPLE
 * @fs: Flow filter specification
 */
struct ethtool_rx_ntuple {
	__u32					cmd;
	struct ethtool_rx_ntuple_flow_spec	fs;
};

#define ETHTOOL_FLASH_MAX_FILENAME	128
enum ethtool_flash_op_type {
	ETHTOOL_FLASH_ALL_REGIONS	= 0,
};

/* for passing firmware flashing related parameters */
struct ethtool_flash {
	__u32	cmd;
	__u32	region;
	char	data[ETHTOOL_FLASH_MAX_FILENAME];
};

/**
 * struct ethtool_dump - used for retrieving, setting device dump
 * @cmd: Command number - %ETHTOOL_GET_DUMP_FLAG, %ETHTOOL_GET_DUMP_DATA, or
 * 	%ETHTOOL_SET_DUMP
 * @version: FW version of the dump, filled in by driver
 * @flag: driver dependent flag for dump setting, filled in by driver during
 *        get and filled in by ethtool for set operation.
 *        flag must be initialized by macro ETH_FW_DUMP_DISABLE value when
 *        firmware dump is disabled.
 * @len: length of dump data, used as the length of the user buffer on entry to
 * 	 %ETHTOOL_GET_DUMP_DATA and this is returned as dump length by driver
 * 	 for %ETHTOOL_GET_DUMP_FLAG command
 * @data: data collected for get dump data operation
 */
struct ethtool_dump {
	__u32	cmd;
	__u32	version;
	__u32	flag;
	__u32	len;
	__u8	data[0];
};

#define ETH_FW_DUMP_DISABLE 0

/* for returning and changing feature sets */

/**
 * struct ethtool_get_features_block - block with state of 32 features
 * @available: mask of changeable features
 * @requested: mask of features requested to be enabled if possible
 * @active: mask of currently enabled features
 * @never_changed: mask of features not changeable for any device
 */
struct ethtool_get_features_block {
	__u32	available;
	__u32	requested;
	__u32	active;
	__u32	never_changed;
};

/**
 * struct ethtool_gfeatures - command to get state of device's features
 * @cmd: command number = %ETHTOOL_GFEATURES
 * @size: On entry, the number of elements in the features[] array;
 *	on return, the number of elements in features[] needed to hold
 *	all features
 * @features: state of features
 */
struct ethtool_gfeatures {
	__u32	cmd;
	__u32	size;
	struct ethtool_get_features_block features[0];
};

/**
 * struct ethtool_set_features_block - block with request for 32 features
 * @valid: mask of features to be changed
 * @requested: values of features to be changed
 */
struct ethtool_set_features_block {
	__u32	valid;
	__u32	requested;
};

/**
 * struct ethtool_sfeatures - command to request change in device's features
 * @cmd: command number = %ETHTOOL_SFEATURES
 * @size: array size of the features[] array
 * @features: feature change masks
 */
struct ethtool_sfeatures {
	__u32	cmd;
	__u32	size;
	struct ethtool_set_features_block features[0];
};

/**
 * struct ethtool_ts_info - holds a device's timestamping and PHC association
 * @cmd: command number = %ETHTOOL_GET_TS_INFO
 * @so_timestamping: bit mask of the sum of the supported SO_TIMESTAMPING flags
 * @phc_index: device index of the associated PHC, or -1 if there is none
 * @tx_types: bit mask of the supported hwtstamp_tx_types enumeration values
 * @rx_filters: bit mask of the supported hwtstamp_rx_filters enumeration values
 *
 * The bits in the 'tx_types' and 'rx_filters' fields correspond to
 * the 'hwtstamp_tx_types' and 'hwtstamp_rx_filters' enumeration values,
 * respectively.  For example, if the device supports HWTSTAMP_TX_ON,
 * then (1 << HWTSTAMP_TX_ON) in 'tx_types' will be set.
 */
struct ethtool_ts_info {
	__u32	cmd;
	__u32	so_timestamping;
	__s32	phc_index;
	__u32	tx_types;
	__u32	tx_reserved[3];
	__u32	rx_filters;
	__u32	rx_reserved[3];
};

/*
 * %ETHTOOL_SFEATURES changes features present in features[].valid to the
 * values of corresponding bits in features[].requested. Bits in .requested
 * not set in .valid or not changeable are ignored.
 *
 * Returns %EINVAL when .valid contains undefined or never-changeable bits
 * or size is not equal to required number of features words (32-bit blocks).
 * Returns >= 0 if request was completed; bits set in the value mean:
 *   %ETHTOOL_F_UNSUPPORTED - there were bits set in .valid that are not
 *	changeable (not present in %ETHTOOL_GFEATURES' features[].available)
 *	those bits were ignored.
 *   %ETHTOOL_F_WISH - some or all changes requested were recorded but the
 *      resulting state of bits masked by .valid is not equal to .requested.
 *      Probably there are other device-specific constraints on some features
 *      in the set. When %ETHTOOL_F_UNSUPPORTED is set, .valid is considered
 *      here as though ignored bits were cleared.
 *   %ETHTOOL_F_COMPAT - some or all changes requested were made by calling
 *      compatibility functions. Requested offload state cannot be properly
 *      managed by kernel.
 *
 * Meaning of bits in the masks are obtained by %ETHTOOL_GSSET_INFO (number of
 * bits in the arrays - always multiple of 32) and %ETHTOOL_GSTRINGS commands
 * for ETH_SS_FEATURES string set. First entry in the table corresponds to least
 * significant bit in features[0] fields. Empty strings mark undefined features.
 */
enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT,
	ETHTOOL_F_WISH__BIT,
	ETHTOOL_F_COMPAT__BIT,
};

#define ETHTOOL_F_UNSUPPORTED   (1 << ETHTOOL_F_UNSUPPORTED__BIT)
#define ETHTOOL_F_WISH          (1 << ETHTOOL_F_WISH__BIT)
#define ETHTOOL_F_COMPAT        (1 << ETHTOOL_F_COMPAT__BIT)


/* CMDs currently supported */
#define ETHTOOL_GSET		0x00000001 /* Get settings. */
#define ETHTOOL_SSET		0x00000002 /* Set settings. */
#define ETHTOOL_GDRVINFO	0x00000003 /* Get driver info. */
#define ETHTOOL_GREGS		0x00000004 /* Get NIC registers. */
#define ETHTOOL_GWOL		0x00000005 /* Get wake-on-lan options. */
#define ETHTOOL_SWOL		0x00000006 /* Set wake-on-lan options. */
#define ETHTOOL_GMSGLVL		0x00000007 /* Get driver message level */
#define ETHTOOL_SMSGLVL		0x00000008 /* Set driver msg level. */
#define ETHTOOL_NWAY_RST	0x00000009 /* Restart autonegotiation. */
/* Get link status for host, i.e. whether the interface *and* the
 * physical port (if there is one) are up (ethtool_value). */
#define ETHTOOL_GLINK		0x0000000a
#define ETHTOOL_GEEPROM		0x0000000b /* Get EEPROM data */
#define ETHTOOL_SEEPROM		0x0000000c /* Set EEPROM data. */
#define ETHTOOL_GCOALESCE	0x0000000e /* Get coalesce config */
#define ETHTOOL_SCOALESCE	0x0000000f /* Set coalesce config. */
#define ETHTOOL_GRINGPARAM	0x00000010 /* Get ring parameters */
#define ETHTOOL_SRINGPARAM	0x00000011 /* Set ring parameters. */
#define ETHTOOL_GPAUSEPARAM	0x00000012 /* Get pause parameters */
#define ETHTOOL_SPAUSEPARAM	0x00000013 /* Set pause parameters. */
#define ETHTOOL_GRXCSUM		0x00000014 /* Get RX hw csum enable (ethtool_value) */
#define ETHTOOL_SRXCSUM		0x00000015 /* Set RX hw csum enable (ethtool_value) */
#define ETHTOOL_GTXCSUM		0x00000016 /* Get TX hw csum enable (ethtool_value) */
#define ETHTOOL_STXCSUM		0x00000017 /* Set TX hw csum enable (ethtool_value) */
#define ETHTOOL_GSG		0x00000018 /* Get scatter-gather enable
					    * (ethtool_value) */
#define ETHTOOL_SSG		0x00000019 /* Set scatter-gather enable
					    * (ethtool_value). */
#define ETHTOOL_TEST		0x0000001a /* execute NIC self-test. */
#define ETHTOOL_GSTRINGS	0x0000001b /* get specified string set */
#define ETHTOOL_PHYS_ID		0x0000001c /* identify the NIC */
#define ETHTOOL_GSTATS		0x0000001d /* get NIC-specific statistics */
#define ETHTOOL_GTSO		0x0000001e /* Get TSO enable (ethtool_value) */
#define ETHTOOL_STSO		0x0000001f /* Set TSO enable (ethtool_value) */
#define ETHTOOL_GPERMADDR	0x00000020 /* Get permanent hardware address */
#define ETHTOOL_GUFO		0x00000021 /* Get UFO enable (ethtool_value) */
#define ETHTOOL_SUFO		0x00000022 /* Set UFO enable (ethtool_value) */
#define ETHTOOL_GGSO		0x00000023 /* Get GSO enable (ethtool_value) */
#define ETHTOOL_SGSO		0x00000024 /* Set GSO enable (ethtool_value) */
#define ETHTOOL_GFLAGS		0x00000025 /* Get flags bitmap(ethtool_value) */
#define ETHTOOL_SFLAGS		0x00000026 /* Set flags bitmap(ethtool_value) */
#define ETHTOOL_GPFLAGS		0x00000027 /* Get driver-private flags bitmap */
#define ETHTOOL_SPFLAGS		0x00000028 /* Set driver-private flags bitmap */

#define ETHTOOL_GRXFH		0x00000029 /* Get RX flow hash configuration */
#define ETHTOOL_SRXFH		0x0000002a /* Set RX flow hash configuration */
#define ETHTOOL_GGRO		0x0000002b /* Get GRO enable (ethtool_value) */
#define ETHTOOL_SGRO		0x0000002c /* Set GRO enable (ethtool_value) */
#define ETHTOOL_GRXRINGS	0x0000002d /* Get RX rings available for LB */
#define ETHTOOL_GRXCLSRLCNT	0x0000002e /* Get RX class rule count */
#define ETHTOOL_GRXCLSRULE	0x0000002f /* Get RX classification rule */
#define ETHTOOL_GRXCLSRLALL	0x00000030 /* Get all RX classification rule */
#define ETHTOOL_SRXCLSRLDEL	0x00000031 /* Delete RX classification rule */
#define ETHTOOL_SRXCLSRLINS	0x00000032 /* Insert RX classification rule */
#define ETHTOOL_FLASHDEV	0x00000033 /* Flash firmware to device */
#define ETHTOOL_RESET		0x00000034 /* Reset hardware */
#define ETHTOOL_SRXNTUPLE	0x00000035 /* Add an n-tuple filter to device */
#define ETHTOOL_GRXNTUPLE	0x00000036 /* deprecated */
#define ETHTOOL_GSSET_INFO	0x00000037 /* Get string set info */
#define ETHTOOL_GRXFHINDIR	0x00000038 /* Get RX flow hash indir'n table */
#define ETHTOOL_SRXFHINDIR	0x00000039 /* Set RX flow hash indir'n table */

#define ETHTOOL_GFEATURES	0x0000003a /* Get device offload settings */
#define ETHTOOL_SFEATURES	0x0000003b /* Change device offload settings */
#define ETHTOOL_GCHANNELS	0x0000003c /* Get no of channels */
#define ETHTOOL_SCHANNELS	0x0000003d /* Set no of channels */
#define ETHTOOL_SET_DUMP	0x0000003e /* Set dump settings */
#define ETHTOOL_GET_DUMP_FLAG	0x0000003f /* Get dump settings */
#define ETHTOOL_GET_DUMP_DATA	0x00000040 /* Get dump data */
#define ETHTOOL_GET_TS_INFO	0x00000041 /* Get time stamping and PHC info */
#define ETHTOOL_GMODULEINFO	0x00000042 /* Get plug-in module information */
#define ETHTOOL_GMODULEEEPROM	0x00000043 /* Get plug-in module eeprom */
#define ETHTOOL_GEEE		0x00000044 /* Get EEE settings */
#define ETHTOOL_SEEE		0x00000045 /* Set EEE settings */

#define ETHTOOL_GRSSH		0x00000046 /* Get RX flow hash configuration */
#define ETHTOOL_SRSSH		0x00000047 /* Set RX flow hash configuration */

/* compatibility with older code */
#define SPARC_ETH_GSET		ETHTOOL_GSET
#define SPARC_ETH_SSET		ETHTOOL_SSET

#define SUPPORTED_10baseT_Half		(1 << 0)
#define SUPPORTED_10baseT_Full		(1 << 1)
#define SUPPORTED_100baseT_Half		(1 << 2)
#define SUPPORTED_100baseT_Full		(1 << 3)
#define SUPPORTED_1000baseT_Half	(1 << 4)
#define SUPPORTED_1000baseT_Full	(1 << 5)
#define SUPPORTED_Autoneg		(1 << 6)
#define SUPPORTED_TP			(1 << 7)
#define SUPPORTED_AUI			(1 << 8)
#define SUPPORTED_MII			(1 << 9)
#define SUPPORTED_FIBRE			(1 << 10)
#define SUPPORTED_BNC			(1 << 11)
#define SUPPORTED_10000baseT_Full	(1 << 12)
#define SUPPORTED_Pause			(1 << 13)
#define SUPPORTED_Asym_Pause		(1 << 14)
#define SUPPORTED_2500baseX_Full	(1 << 15)
#define SUPPORTED_Backplane		(1 << 16)
#define SUPPORTED_1000baseKX_Full	(1 << 17)
#define SUPPORTED_10000baseKX4_Full	(1 << 18)
#define SUPPORTED_10000baseKR_Full	(1 << 19)
#define SUPPORTED_10000baseR_FEC	(1 << 20)
#define SUPPORTED_20000baseMLD2_Full	(1 << 21)
#define SUPPORTED_20000baseKR2_Full	(1 << 22)
#define SUPPORTED_40000baseKR4_Full	(1 << 23)
#define SUPPORTED_40000baseCR4_Full	(1 << 24)
#define SUPPORTED_40000baseSR4_Full	(1 << 25)
#define SUPPORTED_40000baseLR4_Full	(1 << 26)

#define ADVERTISED_10baseT_Half		(1 << 0)
#define ADVERTISED_10baseT_Full		(1 << 1)
#define ADVERTISED_100baseT_Half	(1 << 2)
#define ADVERTISED_100baseT_Full	(1 << 3)
#define ADVERTISED_1000baseT_Half	(1 << 4)
#define ADVERTISED_1000baseT_Full	(1 << 5)
#define ADVERTISED_Autoneg		(1 << 6)
#define ADVERTISED_TP			(1 << 7)
#define ADVERTISED_AUI			(1 << 8)
#define ADVERTISED_MII			(1 << 9)
#define ADVERTISED_FIBRE		(1 << 10)
#define ADVERTISED_BNC			(1 << 11)
#define ADVERTISED_10000baseT_Full	(1 << 12)
#define ADVERTISED_Pause		(1 << 13)
#define ADVERTISED_Asym_Pause		(1 << 14)
#define ADVERTISED_2500baseX_Full	(1 << 15)
#define ADVERTISED_Backplane		(1 << 16)
#define ADVERTISED_1000baseKX_Full	(1 << 17)
#define ADVERTISED_10000baseKX4_Full	(1 << 18)
#define ADVERTISED_10000baseKR_Full	(1 << 19)
#define ADVERTISED_10000baseR_FEC	(1 << 20)
#define ADVERTISED_20000baseMLD2_Full	(1 << 21)
#define ADVERTISED_20000baseKR2_Full	(1 << 22)
#define ADVERTISED_40000baseKR4_Full	(1 << 23)
#define ADVERTISED_40000baseCR4_Full	(1 << 24)
#define ADVERTISED_40000baseSR4_Full	(1 << 25)
#define ADVERTISED_40000baseLR4_Full	(1 << 26)

/* The following are all involved in forcing a particular link
 * mode for the device for setting things.  When getting the
 * devices settings, these indicate the current mode and whether
 * it was forced up into this mode or autonegotiated.
 */

/* The forced speed, 10Mb, 100Mb, gigabit, 2.5Gb, 10GbE. */
#define SPEED_10		10
#define SPEED_100		100
#define SPEED_1000		1000
#define SPEED_2500		2500
#define SPEED_10000		10000
#define SPEED_UNKNOWN		-1

/* Duplex, half or full. */
#define DUPLEX_HALF		0x00
#define DUPLEX_FULL		0x01
#define DUPLEX_UNKNOWN		0xff

/* Which connector port. */
#define PORT_TP			0x00
#define PORT_AUI		0x01
#define PORT_MII		0x02
#define PORT_FIBRE		0x03
#define PORT_BNC		0x04
#define PORT_DA			0x05
#define PORT_NONE		0xef
#define PORT_OTHER		0xff

/* Which transceiver to use. */
#define XCVR_INTERNAL		0x00 /* PHY and MAC are in the same package */
#define XCVR_EXTERNAL		0x01 /* PHY and MAC are in different packages */
#define XCVR_DUMMY1		0x02
#define XCVR_DUMMY2		0x03
#define XCVR_DUMMY3		0x04

/* Enable or disable autonegotiation. */
#define AUTONEG_DISABLE		0x00
#define AUTONEG_ENABLE		0x01

/* MDI or MDI-X status/control - if MDI/MDI_X/AUTO is set then
 * the driver is required to renegotiate link
 */
#define ETH_TP_MDI_INVALID	0x00 /* status: unknown; control: unsupported */
#define ETH_TP_MDI		0x01 /* status: MDI;     control: force MDI */
#define ETH_TP_MDI_X		0x02 /* status: MDI-X;   control: force MDI-X */
#define ETH_TP_MDI_AUTO		0x03 /*                  control: auto-select */

/* Wake-On-Lan options. */
#define WAKE_PHY		(1 << 0)
#define WAKE_UCAST		(1 << 1)
#define WAKE_MCAST		(1 << 2)
#define WAKE_BCAST		(1 << 3)
#define WAKE_ARP		(1 << 4)
#define WAKE_MAGIC		(1 << 5)
#define WAKE_MAGICSECURE	(1 << 6) /* only meaningful if WAKE_MAGIC */

/* L2-L4 network traffic flow types */
#define	TCP_V4_FLOW	0x01	/* hash or spec (tcp_ip4_spec) */
#define	UDP_V4_FLOW	0x02	/* hash or spec (udp_ip4_spec) */
#define	SCTP_V4_FLOW	0x03	/* hash or spec (sctp_ip4_spec) */
#define	AH_ESP_V4_FLOW	0x04	/* hash only */
#define	TCP_V6_FLOW	0x05	/* hash only */
#define	UDP_V6_FLOW	0x06	/* hash only */
#define	SCTP_V6_FLOW	0x07	/* hash only */
#define	AH_ESP_V6_FLOW	0x08	/* hash only */
#define	AH_V4_FLOW	0x09	/* hash or spec (ah_ip4_spec) */
#define	ESP_V4_FLOW	0x0a	/* hash or spec (esp_ip4_spec) */
#define	AH_V6_FLOW	0x0b	/* hash only */
#define	ESP_V6_FLOW	0x0c	/* hash only */
#define	IP_USER_FLOW	0x0d	/* spec only (usr_ip4_spec) */
#define	IPV4_FLOW	0x10	/* hash only */
#define	IPV6_FLOW	0x11	/* hash only */
#define	ETHER_FLOW	0x12	/* spec only (ether_spec) */
/* Flag to enable additional fields in struct ethtool_rx_flow_spec */
#define	FLOW_EXT	0x80000000
#define	FLOW_MAC_EXT	0x40000000

/* L3-L4 network traffic flow hash options */
#define	RXH_L2DA	(1 << 1)
#define	RXH_VLAN	(1 << 2)
#define	RXH_L3_PROTO	(1 << 3)
#define	RXH_IP_SRC	(1 << 4)
#define	RXH_IP_DST	(1 << 5)
#define	RXH_L4_B_0_1	(1 << 6) /* src port in case of TCP/UDP/SCTP */
#define	RXH_L4_B_2_3	(1 << 7) /* dst port in case of TCP/UDP/SCTP */
#define	RXH_DISCARD	(1 << 31)

#define	RX_CLS_FLOW_DISC	0xffffffffffffffffULL

/* Special RX classification rule insert location values */
#define RX_CLS_LOC_SPECIAL	0x80000000	/* flag */
#define RX_CLS_LOC_ANY		0xffffffff
#define RX_CLS_LOC_FIRST	0xfffffffe
#define RX_CLS_LOC_LAST		0xfffffffd

/* EEPROM Standards for plug in modules */
#define ETH_MODULE_SFF_8079		0x1
#define ETH_MODULE_SFF_8079_LEN		256
#define ETH_MODULE_SFF_8472		0x2
#define ETH_MODULE_SFF_8472_LEN		512

/* Reset flags */
/* The reset() operation must clear the flags for the components which
 * were actually reset.  On successful return, the flags indicate the
 * components which were not reset, either because they do not exist
 * in the hardware or because they cannot be reset independently.  The
 * driver must never reset any components that were not requested.
 */
enum ethtool_reset_flags {
	/* These flags represent components dedicated to the interface
	 * the command is addressed to.  Shift any flag left by
	 * ETH_RESET_SHARED_SHIFT to reset a shared component of the
	 * same type.
	 */
	ETH_RESET_MGMT		= 1 << 0,	/* Management processor */
	ETH_RESET_IRQ		= 1 << 1,	/* Interrupt requester */
	ETH_RESET_DMA		= 1 << 2,	/* DMA engine */
	ETH_RESET_FILTER	= 1 << 3,	/* Filtering/flow direction */
	ETH_RESET_OFFLOAD	= 1 << 4,	/* Protocol offload */
	ETH_RESET_MAC		= 1 << 5,	/* Media access controller */
	ETH_RESET_PHY		= 1 << 6,	/* Transceiver/PHY */
	ETH_RESET_RAM		= 1 << 7,	/* RAM shared between
						 * multiple components */

	ETH_RESET_DEDICATED	= 0x0000ffff,	/* All components dedicated to
						 * this interface */
	ETH_RESET_ALL		= 0xffffffff,	/* All components used by this
						 * interface, even if shared */
};
#define ETH_RESET_SHARED_SHIFT	16

#endif /* _LINUX_ETHTOOL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 *  include/linux/eventpoll.h ( Efficient event polling implementation )
 *  Copyright (C) 2001,...,2006	 Davide Libenzi
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Davide Libenzi <davidel@xmailserver.org>
 *
 */

#ifndef _LINUX_EVENTPOLL_H
#define _LINUX_EVENTPOLL_H

/* For O_CLOEXEC */
#include <linux/fcntl.h>
#include <linux/types.h>

/* Flags for epoll_create1.  */
#define EPOLL_CLOEXEC O_CLOEXEC

/* Valid opcodes to issue to sys_epoll_ctl() */
#define EPOLL_CTL_ADD 1
#define EPOLL_CTL_DEL 2
#define EPOLL_CTL_MOD 3

/*
 * Request the handling of system wakeup events so as to prevent system suspends
 * from happening while those events are being processed.
 *
 * Assuming neither EPOLLET nor EPOLLONESHOT is set, system suspends will not be
 * re-allowed until epoll_wait is called again after consuming the wakeup
 * event(s).
 *
 * Requires CAP_BLOCK_SUSPEND
 */
#define EPOLLWAKEUP (1 << 29)

/* Set the One Shot behaviour for the target file descriptor */
#define EPOLLONESHOT (1 << 30)

/* Set the Edge Triggered behaviour for the target file descriptor */
#define EPOLLET (1 << 31)

/* 
 * On x86-64 make the 64bit structure have the same alignment as the
 * 32bit structure. This makes 32bit emulation easier.
 *
 * UML/x86_64 needs the same packing as x86_64
 */
#ifdef __x86_64__
#define EPOLL_PACKED __attribute__((packed))
#else
#define EPOLL_PACKED
#endif

struct epoll_event {
	__u32 events;
	__u64 data;
} EPOLL_PACKED;

#ifdef CONFIG_PM_SLEEP
static __inline__ void ep_take_care_of_epollwakeup(struct epoll_event *epev)
{
	if ((epev->events & EPOLLWAKEUP) && !capable(CAP_BLOCK_SUSPEND))
		epev->events &= ~EPOLLWAKEUP;
}
#else
static __inline__ void ep_take_care_of_epollwakeup(struct epoll_event *epev)
{
	epev->events &= ~EPOLLWAKEUP;
}
#endif
#endif /* _LINUX_EVENTPOLL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef FADVISE_H_INCLUDED
#define FADVISE_H_INCLUDED

#define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
#define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
#define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.  */
#define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */

/*
 * The advise values for POSIX_FADV_DONTNEED and POSIX_ADV_NOREUSE
 * for s390-64 differ from the values for the rest of the world.
 */
#if defined(__s390x__)
#define POSIX_FADV_DONTNEED	6 /* Don't need these pages.  */
#define POSIX_FADV_NOREUSE	7 /* Data will be accessed once.  */
#else
#define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
#define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
#endif

#endif	/* FADVISE_H_INCLUDED */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef _FALLOC_H_
#define _FALLOC_H_

#define FALLOC_FL_KEEP_SIZE	0x01 /* default is extend size */
#define FALLOC_FL_PUNCH_HOLE	0x02 /* de-allocates range */
#define FALLOC_FL_NO_HIDE_STALE	0x04 /* reserved codepoint */

/*
 * FALLOC_FL_COLLAPSE_RANGE is used to remove a range of a file
 * without leaving a hole in the file. The contents of the file beyond
 * the range being removed is appended to the start offset of the range
 * being removed (i.e. the hole that was punched is "collapsed"),
 * resulting in a file layout that looks like the range that was
 * removed never existed. As such collapsing a range of a file changes
 * the size of the file, reducing it by the same length of the range
 * that has been removed by the operation.
 *
 * Different filesystems may implement different limitations on the
 * granularity of the operation. Most will limit operations to
 * filesystem block size boundaries, but this boundary may be larger or
 * smaller depending on the filesystem and/or the configuration of the
 * filesystem or file.
 *
 * Attempting to collapse a range that crosses the end of the file is
 * considered an illegal operation - just use ftruncate(2) if you need
 * to collapse a range that crosses EOF.
 */
#define FALLOC_FL_COLLAPSE_RANGE	0x08

/*
 * FALLOC_FL_ZERO_RANGE is used to convert a range of file to zeros preferably
 * without issuing data IO. Blocks should be preallocated for the regions that
 * span holes in the file, and the entire range is preferable converted to
 * unwritten extents - even though file system may choose to zero out the
 * extent or do whatever which will result in reading zeros from the range
 * while the range remains allocated for the file.
 *
 * This can be also used to preallocate blocks past EOF in the same way as
 * with fallocate. Flag FALLOC_FL_KEEP_SIZE should cause the inode
 * size to remain the same.
 */
#define FALLOC_FL_ZERO_RANGE		0x10

#endif /* _FALLOC_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef _LINUX_FANOTIFY_H
#define _LINUX_FANOTIFY_H

#include <linux/types.h>

/* the following events that user-space can register for */
#define FAN_ACCESS		0x00000001	/* File was accessed */
#define FAN_MODIFY		0x00000002	/* File was modified */
#define FAN_CLOSE_WRITE		0x00000008	/* Writtable file closed */
#define FAN_CLOSE_NOWRITE	0x00000010	/* Unwrittable file closed */
#define FAN_OPEN		0x00000020	/* File was opened */

#define FAN_Q_OVERFLOW		0x00004000	/* Event queued overflowed */

#define FAN_OPEN_PERM		0x00010000	/* File open in perm check */
#define FAN_ACCESS_PERM		0x00020000	/* File accessed in perm check */

#define FAN_ONDIR		0x40000000	/* event occurred against dir */

#define FAN_EVENT_ON_CHILD	0x08000000	/* interested in child events */

/* helper events */
#define FAN_CLOSE		(FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE) /* close */

/* flags used for fanotify_init() */
#define FAN_CLOEXEC		0x00000001
#define FAN_NONBLOCK		0x00000002

/* These are NOT bitwise flags.  Both bits are used togther.  */
#define FAN_CLASS_NOTIF		0x00000000
#define FAN_CLASS_CONTENT	0x00000004
#define FAN_CLASS_PRE_CONTENT	0x00000008
#define FAN_ALL_CLASS_BITS	(FAN_CLASS_NOTIF | FAN_CLASS_CONTENT | \
				 FAN_CLASS_PRE_CONTENT)

#define FAN_UNLIMITED_QUEUE	0x00000010
#define FAN_UNLIMITED_MARKS	0x00000020

#define FAN_ALL_INIT_FLAGS	(FAN_CLOEXEC | FAN_NONBLOCK | \
				 FAN_ALL_CLASS_BITS | FAN_UNLIMITED_QUEUE |\
				 FAN_UNLIMITED_MARKS)

/* flags used for fanotify_modify_mark() */
#define FAN_MARK_ADD		0x00000001
#define FAN_MARK_REMOVE		0x00000002
#define FAN_MARK_DONT_FOLLOW	0x00000004
#define FAN_MARK_ONLYDIR	0x00000008
#define FAN_MARK_MOUNT		0x00000010
#define FAN_MARK_IGNORED_MASK	0x00000020
#define FAN_MARK_IGNORED_SURV_MODIFY	0x00000040
#define FAN_MARK_FLUSH		0x00000080

#define FAN_ALL_MARK_FLAGS	(FAN_MARK_ADD |\
				 FAN_MARK_REMOVE |\
				 FAN_MARK_DONT_FOLLOW |\
				 FAN_MARK_ONLYDIR |\
				 FAN_MARK_MOUNT |\
				 FAN_MARK_IGNORED_MASK |\
				 FAN_MARK_IGNORED_SURV_MODIFY |\
				 FAN_MARK_FLUSH)

/*
 * All of the events - we build the list by hand so that we can add flags in
 * the future and not break backward compatibility.  Apps will get only the
 * events that they originally wanted.  Be sure to add new events here!
 */
#define FAN_ALL_EVENTS (FAN_ACCESS |\
			FAN_MODIFY |\
			FAN_CLOSE |\
			FAN_OPEN)

/*
 * All events which require a permission response from userspace
 */
#define FAN_ALL_PERM_EVENTS (FAN_OPEN_PERM |\
			     FAN_ACCESS_PERM)

#define FAN_ALL_OUTGOING_EVENTS	(FAN_ALL_EVENTS |\
				 FAN_ALL_PERM_EVENTS |\
				 FAN_Q_OVERFLOW)

#define FANOTIFY_METADATA_VERSION	3

struct fanotify_event_metadata {
	__u32 event_len;
	__u8 vers;
	__u8 reserved;
	__u16 metadata_len;
	__aligned_u64 mask;
	__s32 fd;
	__s32 pid;
};

struct fanotify_response {
	__s32 fd;
	__u32 response;
};

/* Legit userspace responses to a _PERM event */
#define FAN_ALLOW	0x01
#define FAN_DENY	0x02
/* No fd set in event */
#define FAN_NOFD	-1

/* Helper functions to deal with fanotify_event_metadata buffers */
#define FAN_EVENT_METADATA_LEN (sizeof(struct fanotify_event_metadata))

#define FAN_EVENT_NEXT(meta, len) ((len) -= (meta)->event_len, \
				   (struct fanotify_event_metadata*)(((char *)(meta)) + \
				   (meta)->event_len))

#define FAN_EVENT_OK(meta, len)	((long)(len) >= (long)FAN_EVENT_METADATA_LEN && \
				(long)(meta)->event_len >= (long)FAN_EVENT_METADATA_LEN && \
				(long)(meta)->event_len <= (long)(len))

#endif /* _LINUX_FANOTIFY_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef _LINUX_FB_H
#define _LINUX_FB_H

#include <linux/types.h>
#include <linux/i2c.h>

/* Definitions of frame buffers						*/

#define FB_MAX			32	/* sufficient for now */

/* ioctls
   0x46 is 'F'								*/
#define FBIOGET_VSCREENINFO	0x4600
#define FBIOPUT_VSCREENINFO	0x4601
#define FBIOGET_FSCREENINFO	0x4602
#define FBIOGETCMAP		0x4604
#define FBIOPUTCMAP		0x4605
#define FBIOPAN_DISPLAY		0x4606
#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
/* 0x4607-0x460B are defined below */
/* #define FBIOGET_MONITORSPEC	0x460C */
/* #define FBIOPUT_MONITORSPEC	0x460D */
/* #define FBIOSWITCH_MONIBIT	0x460E */
#define FBIOGET_CON2FBMAP	0x460F
#define FBIOPUT_CON2FBMAP	0x4610
#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
#define FBIO_ALLOC              0x4613
#define FBIO_FREE               0x4614
#define FBIOGET_GLYPH           0x4615
#define FBIOGET_HWCINFO         0x4616
#define FBIOPUT_MODEINFO        0x4617
#define FBIOGET_DISPINFO        0x4618
#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, __u32)
/*
 * HACK: use 'z' in order not to clash with any other ioctl numbers which might
 * be concurrently added to the mainline kernel
 */
#define FBIOCOPYAREA		_IOW('z', 0x21, struct fb_copyarea)

#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
#define FB_TYPE_PLANES			1	/* Non interleaved planes */
#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
#define FB_TYPE_TEXT			3	/* Text/attributes	*/
#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
#define FB_TYPE_FOURCC			5	/* Type identified by a V4L2 FOURCC */

#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
#define FB_AUX_TEXT_SVGA_GROUP	8	/* 8-15: SVGA tileblit compatible modes */
#define FB_AUX_TEXT_SVGA_MASK	7	/* lower three bits says step */
#define FB_AUX_TEXT_SVGA_STEP2	8	/* SVGA text mode:  text, attr */
#define FB_AUX_TEXT_SVGA_STEP4	9	/* SVGA text mode:  text, attr,  2 reserved bytes */
#define FB_AUX_TEXT_SVGA_STEP8	10	/* SVGA text mode:  text, attr,  6 reserved bytes */
#define FB_AUX_TEXT_SVGA_STEP16	11	/* SVGA text mode:  text, attr, 14 reserved bytes */
#define FB_AUX_TEXT_SVGA_LAST	15	/* reserved up to 15 */

#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */

#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
#define FB_VISUAL_FOURCC		6	/* Visual identified by a V4L2 FOURCC */

#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
#define FB_ACCEL_I810           39      /* Intel 810/815                */
#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
#define FB_ACCEL_OMAP1610	49	/* TI OMAP16xx                  */
#define FB_ACCEL_TRIDENT_TGUI	50	/* Trident TGUI			*/
#define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
#define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
#define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
#define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
#define FB_ACCEL_PXA3XX		 99	/* PXA3xx			*/

#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */

#define FB_ACCEL_PUV3_UNIGFX	0xa0	/* PKUnity-v3 Unigfx		*/

#define FB_CAP_FOURCC		1	/* Device supports FOURCC-based formats */

struct fb_fix_screeninfo {
	char id[16];			/* identification string eg "TT Builtin" */
	unsigned long smem_start;	/* Start of frame buffer mem */
					/* (physical address) */
	__u32 smem_len;			/* Length of frame buffer mem */
	__u32 type;			/* see FB_TYPE_*		*/
	__u32 type_aux;			/* Interleave for interleaved Planes */
	__u32 visual;			/* see FB_VISUAL_*		*/ 
	__u16 xpanstep;			/* zero if no hardware panning  */
	__u16 ypanstep;			/* zero if no hardware panning  */
	__u16 ywrapstep;		/* zero if no hardware ywrap    */
	__u32 line_length;		/* length of a line in bytes    */
	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
					/* (physical address) */
	__u32 mmio_len;			/* Length of Memory Mapped I/O  */
	__u32 accel;			/* Indicate to driver which	*/
					/*  specific chip/card we have	*/
	__u16 capabilities;		/* see FB_CAP_*			*/
	__u16 reserved[2];		/* Reserved for future compatibility */
};

/* Interpretation of offset for color fields: All offsets are from the right,
 * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
 * can use the offset as right argument to <<). A pixel afterwards is a bit
 * stream and is written to video memory as that unmodified.
 *
 * For pseudocolor: offset and length should be the same for all color
 * components. Offset specifies the position of the least significant bit
 * of the pallette index in a pixel value. Length indicates the number
 * of available palette entries (i.e. # of entries = 1 << length).
 */
struct fb_bitfield {
	__u32 offset;			/* beginning of bitfield	*/
	__u32 length;			/* length of bitfield		*/
	__u32 msb_right;		/* != 0 : Most significant bit is */ 
					/* right */ 
};

#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
#define FB_NONSTD_REV_PIX_IN_B	2	/* order of pixels in each byte is reversed */

#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
#define FB_ACTIVATE_MASK       15
					/* values			*/
#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */

#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */

#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
#define FB_SYNC_EXT		4	/* external sync		*/
#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
					/* vtotal = 144d/288n/576i => PAL  */
					/* vtotal = 121d/242n/484i => NTSC */
#define FB_SYNC_ON_GREEN	32	/* sync on green */

#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
#define FB_VMODE_INTERLACED	1	/* interlaced	*/
#define FB_VMODE_DOUBLE		2	/* double scan */
#define FB_VMODE_ODD_FLD_FIRST	4	/* interlaced: top line first */
#define FB_VMODE_MASK		255

#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/

/*
 * Display rotation support
 */
#define FB_ROTATE_UR      0
#define FB_ROTATE_CW      1
#define FB_ROTATE_UD      2
#define FB_ROTATE_CCW     3

#define PICOS2KHZ(a) (1000000000UL/(a))
#define KHZ2PICOS(a) (1000000000UL/(a))

struct fb_var_screeninfo {
	__u32 xres;			/* visible resolution		*/
	__u32 yres;
	__u32 xres_virtual;		/* virtual resolution		*/
	__u32 yres_virtual;
	__u32 xoffset;			/* offset from virtual to visible */
	__u32 yoffset;			/* resolution			*/

	__u32 bits_per_pixel;		/* guess what			*/
	__u32 grayscale;		/* 0 = color, 1 = grayscale,	*/
					/* >1 = FOURCC			*/
	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
	struct fb_bitfield green;	/* else only length is significant */
	struct fb_bitfield blue;
	struct fb_bitfield transp;	/* transparency			*/	

	__u32 nonstd;			/* != 0 Non standard pixel format */

	__u32 activate;			/* see FB_ACTIVATE_*		*/

	__u32 height;			/* height of picture in mm    */
	__u32 width;			/* width of picture in mm     */

	__u32 accel_flags;		/* (OBSOLETE) see fb_info.flags */

	/* Timing: All values in pixclocks, except pixclock (of course) */
	__u32 pixclock;			/* pixel clock in ps (pico seconds) */
	__u32 left_margin;		/* time from sync to picture	*/
	__u32 right_margin;		/* time from picture to sync	*/
	__u32 upper_margin;		/* time from sync to picture	*/
	__u32 lower_margin;
	__u32 hsync_len;		/* length of horizontal sync	*/
	__u32 vsync_len;		/* length of vertical sync	*/
	__u32 sync;			/* see FB_SYNC_*		*/
	__u32 vmode;			/* see FB_VMODE_*		*/
	__u32 rotate;			/* angle we rotate counter clockwise */
	__u32 colorspace;		/* colorspace for FOURCC-based modes */
	__u32 reserved[4];		/* Reserved for future compatibility */
};

struct fb_cmap {
	__u32 start;			/* First entry	*/
	__u32 len;			/* Number of entries */
	__u16 *red;			/* Red values	*/
	__u16 *green;
	__u16 *blue;
	__u16 *transp;			/* transparency, can be NULL */
};

struct fb_con2fbmap {
	__u32 console;
	__u32 framebuffer;
};

/* VESA Blanking Levels */
#define VESA_NO_BLANKING        0
#define VESA_VSYNC_SUSPEND      1
#define VESA_HSYNC_SUSPEND      2
#define VESA_POWERDOWN          3


enum {
	/* screen: unblanked, hsync: on,  vsync: on */
	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,

	/* screen: blanked,   hsync: on,  vsync: on */
	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,

	/* screen: blanked,   hsync: on,  vsync: off */
	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,

	/* screen: blanked,   hsync: off, vsync: on */
	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,

	/* screen: blanked,   hsync: off, vsync: off */
	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
};

#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */

struct fb_vblank {
	__u32 flags;			/* FB_VBLANK flags */
	__u32 count;			/* counter of retraces since boot */
	__u32 vcount;			/* current scanline position */
	__u32 hcount;			/* current scandot position */
	__u32 reserved[4];		/* reserved for future compatibility */
};

/* Internal HW accel */
#define ROP_COPY 0
#define ROP_XOR  1

struct fb_copyarea {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 sx;
	__u32 sy;
};

struct fb_fillrect {
	__u32 dx;	/* screen-relative */
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 color;
	__u32 rop;
};

struct fb_image {
	__u32 dx;		/* Where to place image */
	__u32 dy;
	__u32 width;		/* Size of image */
	__u32 height;
	__u32 fg_color;		/* Only used when a mono bitmap */
	__u32 bg_color;
	__u8  depth;		/* Depth of the image */
	const char *data;	/* Pointer to image data */
	struct fb_cmap cmap;	/* color map info */
};

/*
 * hardware cursor control
 */

#define FB_CUR_SETIMAGE 0x01
#define FB_CUR_SETPOS   0x02
#define FB_CUR_SETHOT   0x04
#define FB_CUR_SETCMAP  0x08
#define FB_CUR_SETSHAPE 0x10
#define FB_CUR_SETSIZE	0x20
#define FB_CUR_SETALL   0xFF

struct fbcurpos {
	__u16 x, y;
};

struct fb_cursor {
	__u16 set;		/* what to set */
	__u16 enable;		/* cursor on/off */
	__u16 rop;		/* bitop operation */
	const char *mask;	/* cursor mask bits */
	struct fbcurpos hot;	/* cursor hot spot */
	struct fb_image	image;	/* Cursor image */
};

#ifdef CONFIG_FB_BACKLIGHT
/* Settings for the generic backlight code */
#define FB_BACKLIGHT_LEVELS	128
#define FB_BACKLIGHT_MAX	0xFF
#endif


#endif /* _LINUX_FB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #ifndef _LINUX_FCNTL_H
#define _LINUX_FCNTL_H

#include <asm/fcntl.h>

#define F_SETLEASE	(F_LINUX_SPECIFIC_BASE + 0)
#define F_GETLEASE	(F_LINUX_SPECIFIC_BASE + 1)

/*
 * Cancel a blocking posix lock; internal use only until we expose an
 * asynchronous lock api to userspace:
 */
#define F_CANCELLK	(F_LINUX_SPECIFIC_BASE + 5)

/* Create a file descriptor with FD_CLOEXEC set. */
#define F_DUPFD_CLOEXEC	(F_LINUX_SPECIFIC_BASE + 6)

/*
 * Request nofications on a directory.
 * See below for events that may be notified.
 */
#define F_NOTIFY	(F_LINUX_SPECIFIC_BASE+2)

/*
 * Set and get of pipe page size array
 */
#define F_SETPIPE_SZ	(F_LINUX_SPECIFIC_BASE + 7)
#define F_GETPIPE_SZ	(F_LINUX_SPECIFIC_BASE + 8)

/*
 * Set/Get seals
 */
#define F_ADD_SEALS	(F_LINUX_SPECIFIC_BASE + 9)
#define F_GET_SEALS	(F_LINUX_SPECIFIC_BASE + 10)

/*
 * Types of seals
 */
#define F_SEAL_SEAL	0x0001	/* prevent further seals from being set */
#define F_SEAL_SHRINK	0x0002	/* prevent file from shrinking */
#define F_SEAL_GROW	0x0004	/* prevent file from growing */
#define F_SEAL_WRITE	0x0008	/* prevent writes */
/* (1U << 31) is reserved for signed error codes */

/*
 * Types of directory notifications that may be requested.
 */
#define DN_ACCESS	0x00000001	/* File accessed */
#define DN_MODIFY	0x00000002	/* File modified */
#define DN_CREATE	0x00000004	/* File created */
#define DN_DELETE	0x00000008	/* File removed */
#define DN_RENAME	0x00000010	/* File renamed */
#define DN_ATTRIB	0x00000020	/* File changed attibutes */
#define DN_MULTISHOT	0x80000000	/* Don't remove notifier */

#define AT_FDCWD		-100    /* Special value used to indicate
                                           openat should use the current
                                           working directory. */
#define AT_SYMLINK_NOFOLLOW	0x100   /* Do not follow symbolic links.  */
#define AT_REMOVEDIR		0x200   /* Remove directory instead of
                                           unlinking file.  */
#define AT_SYMLINK_FOLLOW	0x400   /* Follow symbolic links.  */
#define AT_NO_AUTOMOUNT		0x800	/* Suppress terminal automount traversal */
#define AT_EMPTY_PATH		0x1000	/* Allow empty relative pathname */


#endif /* _LINUX_FCNTL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef _LINUX_FD_H
#define _LINUX_FD_H

#include <linux/ioctl.h>


/* New file layout: Now the ioctl definitions immediately follow the
 * definitions of the structures that they use */

/*
 * Geometry
 */
struct floppy_struct {
	unsigned int	size,		/* nr of sectors total */
			sect,		/* sectors per track */
			head,		/* nr of heads */
			track,		/* nr of tracks */
			stretch;	/* bit 0 !=0 means double track steps */
					/* bit 1 != 0 means swap sides */
					/* bits 2..9 give the first sector */
					/*  number (the LSB is flipped) */
#define FD_STRETCH 1
#define FD_SWAPSIDES 2
#define FD_ZEROBASED 4
#define FD_SECTBASEMASK 0x3FC
#define FD_MKSECTBASE(s) (((s) ^ 1) << 2)
#define FD_SECTBASE(floppy) ((((floppy)->stretch & FD_SECTBASEMASK) >> 2) ^ 1)

	unsigned char	gap,		/* gap1 size */

			rate,		/* data rate. |= 0x40 for perpendicular */
#define FD_2M 0x4
#define FD_SIZECODEMASK 0x38
#define FD_SIZECODE(floppy) (((((floppy)->rate&FD_SIZECODEMASK)>> 3)+ 2) %8)
#define FD_SECTSIZE(floppy) ( (floppy)->rate & FD_2M ? \
			     512 : 128 << FD_SIZECODE(floppy) )
#define FD_PERP 0x40

			spec1,		/* stepping rate, head unload time */
			fmt_gap;	/* gap2 size */
	const char	* name; /* used only for predefined formats */
};


/* commands needing write access have 0x40 set */
/* commands needing super user access have 0x80 set */

#define FDCLRPRM _IO(2, 0x41)
/* clear user-defined parameters */

#define FDSETPRM _IOW(2, 0x42, struct floppy_struct) 
#define FDSETMEDIAPRM FDSETPRM
/* set user-defined parameters for current media */

#define FDDEFPRM _IOW(2, 0x43, struct floppy_struct) 
#define FDGETPRM _IOR(2, 0x04, struct floppy_struct)
#define FDDEFMEDIAPRM FDDEFPRM
#define FDGETMEDIAPRM FDGETPRM
/* set/get disk parameters */


#define	FDMSGON  _IO(2,0x45)
#define	FDMSGOFF _IO(2,0x46)
/* issue/don't issue kernel messages on media type change */


/* 
 * Formatting (obsolete)
 */
#define FD_FILL_BYTE 0xF6 /* format fill byte. */

struct format_descr {
	unsigned int device,head,track;
};

#define FDFMTBEG _IO(2,0x47)
/* begin formatting a disk */
#define	FDFMTTRK _IOW(2,0x48, struct format_descr)
/* format the specified track */
#define FDFMTEND _IO(2,0x49)
/* end formatting a disk */


/*
 * Error thresholds
 */
struct floppy_max_errors {
	unsigned int
	  abort,      /* number of errors to be reached before aborting */
	  read_track, /* maximal number of errors permitted to read an
		       * entire track at once */
	  reset,      /* maximal number of errors before a reset is tried */
	  recal,      /* maximal number of errors before a recalibrate is
		       * tried */

	  /*
	   * Threshold for reporting FDC errors to the console.
	   * Setting this to zero may flood your screen when using
	   * ultra cheap floppies ;-)
	   */
	  reporting;

};

#define FDSETEMSGTRESH	_IO(2,0x4a)
/* set fdc error reporting threshold */

#define FDFLUSH  _IO(2,0x4b)
/* flush buffers for media; either for verifying media, or for
 * handling a media change without closing the file descriptor */

#define FDSETMAXERRS _IOW(2, 0x4c, struct floppy_max_errors)
#define FDGETMAXERRS _IOR(2, 0x0e, struct floppy_max_errors)
/* set/get abortion and read_track threshold. See also floppy_drive_params
 * structure */


typedef char floppy_drive_name[16];
#define FDGETDRVTYP _IOR(2, 0x0f, floppy_drive_name)
/* get drive type: 5 1/4 or 3 1/2 */


/*
 * Drive parameters (user modifiable)
 */
struct floppy_drive_params {
	signed char cmos;		/* CMOS type */
	
	/* Spec2 is (HLD<<1 | ND), where HLD is head load time (1=2ms, 2=4 ms 
	 * etc) and ND is set means no DMA. Hardcoded to 6 (HLD=6ms, use DMA).
	 */
	unsigned long max_dtr;		/* Step rate, usec */
	unsigned long hlt;     		/* Head load/settle time, msec */
	unsigned long hut;     		/* Head unload time (remnant of 
					 * 8" drives) */
	unsigned long srt;     		/* Step rate, usec */

	unsigned long spinup;		/* time needed for spinup (expressed
					 * in jiffies) */
	unsigned long spindown;		/* timeout needed for spindown */
	unsigned char spindown_offset;	/* decides in which position the disk
					 * will stop */
	unsigned char select_delay;	/* delay to wait after select */
	unsigned char rps;		/* rotations per second */
	unsigned char tracks;		/* maximum number of tracks */
	unsigned long timeout;		/* timeout for interrupt requests */
	
	unsigned char interleave_sect;	/* if there are more sectors, use 
					 * interleave */
	
	struct floppy_max_errors max_errors;
	
	char flags;			/* various flags, including ftd_msg */
/*
 * Announce successful media type detection and media information loss after
 * disk changes.
 * Also used to enable/disable printing of overrun warnings.
 */

#define FTD_MSG 0x10
#define FD_BROKEN_DCL 0x20
#define FD_DEBUG 0x02
#define FD_SILENT_DCL_CLEAR 0x4
#define FD_INVERTED_DCL 0x80 /* must be 0x80, because of hardware 
				considerations */

	char read_track;		/* use readtrack during probing? */

/*
 * Auto-detection. Each drive type has eight formats which are
 * used in succession to try to read the disk. If the FDC cannot lock onto
 * the disk, the next format is tried. This uses the variable 'probing'.
 */
	short autodetect[8];		/* autodetected formats */
	
	int checkfreq; /* how often should the drive be checked for disk 
			* changes */
	int native_format; /* native format of this drive */
};

enum {
	FD_NEED_TWADDLE_BIT,	/* more magic */
	FD_VERIFY_BIT,		/* inquire for write protection */
	FD_DISK_NEWCHANGE_BIT,	/* change detected, and no action undertaken yet
				 * to clear media change status */
	FD_UNUSED_BIT,
	FD_DISK_CHANGED_BIT,	/* disk has been changed since last i/o */
	FD_DISK_WRITABLE_BIT,	/* disk is writable */
	FD_OPEN_SHOULD_FAIL_BIT
};

#define FDSETDRVPRM _IOW(2, 0x90, struct floppy_drive_params)
#define FDGETDRVPRM _IOR(2, 0x11, struct floppy_drive_params)
/* set/get drive parameters */


/*
 * Current drive state (not directly modifiable by user, readonly)
 */
struct floppy_drive_struct {
	unsigned long flags;
/* values for these flags */
#define FD_NEED_TWADDLE (1 << FD_NEED_TWADDLE_BIT)
#define FD_VERIFY (1 << FD_VERIFY_BIT)
#define FD_DISK_NEWCHANGE (1 << FD_DISK_NEWCHANGE_BIT)
#define FD_DISK_CHANGED (1 << FD_DISK_CHANGED_BIT)
#define FD_DISK_WRITABLE (1 << FD_DISK_WRITABLE_BIT)

	unsigned long spinup_date;
	unsigned long select_date;
	unsigned long first_read_date;
	short probed_format;
	short track; /* current track */
	short maxblock; /* id of highest block read */
	short maxtrack; /* id of highest half track read */
	int generation; /* how many diskchanges? */

/*
 * (User-provided) media information is _not_ discarded after a media change
 * if the corresponding keep_data flag is non-zero. Positive values are
 * decremented after each probe.
 */
	int keep_data;
	
	/* Prevent "aliased" accesses. */
	int fd_ref;
	int fd_device;
	unsigned long last_checked; /* when was the drive last checked for a disk 
			   * change? */
	
	char *dmabuf;
	int bufblocks;
};

#define FDGETDRVSTAT _IOR(2, 0x12, struct floppy_drive_struct)
#define FDPOLLDRVSTAT _IOR(2, 0x13, struct floppy_drive_struct)
/* get drive state: GET returns the cached state, POLL polls for new state */


/*
 * reset FDC
 */
enum reset_mode {
	FD_RESET_IF_NEEDED,	/* reset only if the reset flags is set */
	FD_RESET_IF_RAWCMD,	/* obsolete */
	FD_RESET_ALWAYS		/* reset always */
};
#define FDRESET _IO(2, 0x54)


/*
 * FDC state
 */
struct floppy_fdc_state {	
	int spec1;		/* spec1 value last used */
	int spec2;		/* spec2 value last used */
	int dtr;
	unsigned char version;	/* FDC version code */
	unsigned char dor;
	unsigned long address;	/* io address */
	unsigned int rawcmd:2;
	unsigned int reset:1;
	unsigned int need_configure:1;
	unsigned int perp_mode:2;
	unsigned int has_fifo:1;
	unsigned int driver_version;	/* version code for floppy driver */
#define FD_DRIVER_VERSION 0x100
/* user programs using the floppy API should use floppy_fdc_state to
 * get the version number of the floppy driver that they are running
 * on. If this version number is bigger than the one compiled into the
 * user program (the FD_DRIVER_VERSION define), it should be prepared
 * to bigger structures
 */

	unsigned char track[4];
	/* Position of the heads of the 4 units attached to this FDC,
	 * as stored on the FDC. In the future, the position as stored
	 * on the FDC might not agree with the actual physical
	 * position of these drive heads. By allowing such
	 * disagreement, it will be possible to reset the FDC without
	 * incurring the expensive cost of repositioning all heads.
	 * Right now, these positions are hard wired to 0. */

};

#define FDGETFDCSTAT _IOR(2, 0x15, struct floppy_fdc_state)


/*
 * Asynchronous Write error tracking
 */
struct floppy_write_errors {
	/* Write error logging.
	 *
	 * These fields can be cleared with the FDWERRORCLR ioctl.
	 * Only writes that were attempted but failed due to a physical media
	 * error are logged.  write(2) calls that fail and return an error code
	 * to the user process are not counted.
	 */

	unsigned int write_errors;  /* number of physical write errors 
				     * encountered */
	
	/* position of first and last write errors */
	unsigned long first_error_sector;
	int           first_error_generation;
	unsigned long last_error_sector;
	int           last_error_generation;
	
	unsigned int badness; /* highest retry count for a read or write 
			       * operation */
};

#define FDWERRORCLR  _IO(2, 0x56)
/* clear write error and badness information */
#define FDWERRORGET  _IOR(2, 0x17, struct floppy_write_errors)
/* get write error and badness information */


/*
 * Raw commands
 */
/* new interface flag: now we can do them in batches */
#define FDHAVEBATCHEDRAWCMD

struct floppy_raw_cmd {
	unsigned int flags;
#define FD_RAW_READ 1
#define FD_RAW_WRITE 2
#define FD_RAW_NO_MOTOR 4
#define FD_RAW_DISK_CHANGE 4 /* out: disk change flag was set */
#define FD_RAW_INTR 8    /* wait for an interrupt */
#define FD_RAW_SPIN 0x10 /* spin up the disk for this command */
#define FD_RAW_NO_MOTOR_AFTER 0x20 /* switch the motor off after command 
				    * completion */
#define FD_RAW_NEED_DISK 0x40  /* this command needs a disk to be present */
#define FD_RAW_NEED_SEEK 0x80  /* this command uses an implied seek (soft) */

/* more "in" flags */
#define FD_RAW_MORE 0x100  /* more records follow */
#define FD_RAW_STOP_IF_FAILURE 0x200 /* stop if we encounter a failure */
#define FD_RAW_STOP_IF_SUCCESS 0x400 /* stop if command successful */
#define FD_RAW_SOFTFAILURE 0x800 /* consider the return value for failure
				  * detection too */

/* more "out" flags */
#define FD_RAW_FAILURE 0x10000 /* command sent to fdc, fdc returned error */
#define FD_RAW_HARDFAILURE 0x20000 /* fdc had to be reset, or timed out */

	void *data;
	char *kernel_data; /* location of data buffer in the kernel */
	struct floppy_raw_cmd *next; /* used for chaining of raw cmd's 
				      * within the kernel */
	long length; /* in: length of dma transfer. out: remaining bytes */
	long phys_length; /* physical length, if different from dma length */
	int buffer_length; /* length of allocated buffer */

	unsigned char rate;
	unsigned char cmd_count;
	unsigned char cmd[16];
	unsigned char reply_count;
	unsigned char reply[16];
	int track;
	int resultcode;

	int reserved1;
	int reserved2;
};

#define FDRAWCMD _IO(2, 0x58)
/* send a raw command to the fdc. Structure size not included, because of
 * batches */

#define FDTWADDLE _IO(2, 0x59)
/* flicker motor-on bit before reading a sector. Experimental */


#define FDEJECT _IO(2, 0x5a)
/* eject the disk */



#endif /* _LINUX_FD_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #ifndef __LINUX_FIB_RULES_H
#define __LINUX_FIB_RULES_H

#include <linux/types.h>
#include <linux/rtnetlink.h>

/* rule is permanent, and cannot be deleted */
#define FIB_RULE_PERMANENT	0x00000001
#define FIB_RULE_INVERT		0x00000002
#define FIB_RULE_UNRESOLVED	0x00000004
#define FIB_RULE_IIF_DETACHED	0x00000008
#define FIB_RULE_DEV_DETACHED	FIB_RULE_IIF_DETACHED
#define FIB_RULE_OIF_DETACHED	0x00000010

/* try to find source address in routing lookups */
#define FIB_RULE_FIND_SADDR	0x00010000

struct fib_rule_hdr {
	__u8		family;
	__u8		dst_len;
	__u8		src_len;
	__u8		tos;

	__u8		table;
	__u8		res1;	/* reserved */
	__u8		res2;	/* reserved */
	__u8		action;

	__u32		flags;
};

enum {
	FRA_UNSPEC,
	FRA_DST,	/* destination address */
	FRA_SRC,	/* source address */
	FRA_IIFNAME,	/* interface name */
#define FRA_IFNAME	FRA_IIFNAME
	FRA_GOTO,	/* target to jump to (FR_ACT_GOTO) */
	FRA_UNUSED2,
	FRA_PRIORITY,	/* priority/preference */
	FRA_UNUSED3,
	FRA_UNUSED4,
	FRA_UNUSED5,
	FRA_FWMARK,	/* mark */
	FRA_FLOW,	/* flow/class id */
	FRA_UNUSED6,
	FRA_SUPPRESS_IFGROUP,
	FRA_SUPPRESS_PREFIXLEN,
	FRA_TABLE,	/* Extended table id */
	FRA_FWMASK,	/* mask for netfilter mark */
	FRA_OIFNAME,
	__FRA_MAX
};

#define FRA_MAX (__FRA_MAX - 1)

enum {
	FR_ACT_UNSPEC,
	FR_ACT_TO_TBL,		/* Pass to fixed table */
	FR_ACT_GOTO,		/* Jump to another rule */
	FR_ACT_NOP,		/* No operation */
	FR_ACT_RES3,
	FR_ACT_RES4,
	FR_ACT_BLACKHOLE,	/* Drop without notification */
	FR_ACT_UNREACHABLE,	/* Drop with ENETUNREACH */
	FR_ACT_PROHIBIT,	/* Drop with EACCES */
	__FR_ACT_MAX,
};

#define FR_ACT_MAX (__FR_ACT_MAX - 1)

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef _LINUX_FDREG_H
#define _LINUX_FDREG_H
/*
 * This file contains some defines for the floppy disk controller.
 * Various sources. Mostly "IBM Microcomputers: A Programmers
 * Handbook", Sanches and Canton.
 */

#ifdef FDPATCHES
#define FD_IOPORT fdc_state[fdc].address
#else
/* It would be a lot saner just to force fdc_state[fdc].address to always
   be set ! FIXME */
#define FD_IOPORT 0x3f0
#endif

/* Fd controller regs. S&C, about page 340 */
#define FD_STATUS	(4 + FD_IOPORT )
#define FD_DATA		(5 + FD_IOPORT )

/* Digital Output Register */
#define FD_DOR		(2 + FD_IOPORT )

/* Digital Input Register (read) */
#define FD_DIR		(7 + FD_IOPORT )

/* Diskette Control Register (write)*/
#define FD_DCR		(7 + FD_IOPORT )

/* Bits of main status register */
#define STATUS_BUSYMASK	0x0F		/* drive busy mask */
#define STATUS_BUSY	0x10		/* FDC busy */
#define STATUS_DMA	0x20		/* 0- DMA mode */
#define STATUS_DIR	0x40		/* 0- cpu->fdc */
#define STATUS_READY	0x80		/* Data reg ready */

/* Bits of FD_ST0 */
#define ST0_DS		0x03		/* drive select mask */
#define ST0_HA		0x04		/* Head (Address) */
#define ST0_NR		0x08		/* Not Ready */
#define ST0_ECE		0x10		/* Equipment check error */
#define ST0_SE		0x20		/* Seek end */
#define ST0_INTR	0xC0		/* Interrupt code mask */

/* Bits of FD_ST1 */
#define ST1_MAM		0x01		/* Missing Address Mark */
#define ST1_WP		0x02		/* Write Protect */
#define ST1_ND		0x04		/* No Data - unreadable */
#define ST1_OR		0x10		/* OverRun */
#define ST1_CRC		0x20		/* CRC error in data or addr */
#define ST1_EOC		0x80		/* End Of Cylinder */

/* Bits of FD_ST2 */
#define ST2_MAM		0x01		/* Missing Address Mark (again) */
#define ST2_BC		0x02		/* Bad Cylinder */
#define ST2_SNS		0x04		/* Scan Not Satisfied */
#define ST2_SEH		0x08		/* Scan Equal Hit */
#define ST2_WC		0x10		/* Wrong Cylinder */
#define ST2_CRC		0x20		/* CRC error in data field */
#define ST2_CM		0x40		/* Control Mark = deleted */

/* Bits of FD_ST3 */
#define ST3_HA		0x04		/* Head (Address) */
#define ST3_DS		0x08		/* drive is double-sided */
#define ST3_TZ		0x10		/* Track Zero signal (1=track 0) */
#define ST3_RY		0x20		/* drive is ready */
#define ST3_WP		0x40		/* Write Protect */
#define ST3_FT		0x80		/* Drive Fault */

/* Values for FD_COMMAND */
#define FD_RECALIBRATE		0x07	/* move to track 0 */
#define FD_SEEK			0x0F	/* seek track */
#define FD_READ			0xE6	/* read with MT, MFM, SKip deleted */
#define FD_WRITE		0xC5	/* write with MT, MFM */
#define FD_SENSEI		0x08	/* Sense Interrupt Status */
#define FD_SPECIFY		0x03	/* specify HUT etc */
#define FD_FORMAT		0x4D	/* format one track */
#define FD_VERSION		0x10	/* get version code */
#define FD_CONFIGURE		0x13	/* configure FIFO operation */
#define FD_PERPENDICULAR	0x12	/* perpendicular r/w mode */
#define FD_GETSTATUS		0x04	/* read ST3 */
#define FD_DUMPREGS		0x0E	/* dump the contents of the fdc regs */
#define FD_READID		0xEA	/* prints the header of a sector */
#define FD_UNLOCK		0x14	/* Fifo config unlock */
#define FD_LOCK			0x94	/* Fifo config lock */
#define FD_RSEEK_OUT		0x8f	/* seek out (i.e. to lower tracks) */
#define FD_RSEEK_IN		0xcf	/* seek in (i.e. to higher tracks) */

/* the following commands are new in the 82078. They are not used in the
 * floppy driver, except the first three. These commands may be useful for apps
 * which use the FDRAWCMD interface. For doc, get the 82078 spec sheets at
 * http://www.intel.com/design/archives/periphrl/docs/29046803.htm */

#define FD_PARTID		0x18	/* part id ("extended" version cmd) */
#define FD_SAVE			0x2e	/* save fdc regs for later restore */
#define FD_DRIVESPEC		0x8e	/* drive specification: Access to the
					 * 2 Mbps data transfer rate for tape
					 * drives */

#define FD_RESTORE		0x4e    /* later restore */
#define FD_POWERDOWN		0x27	/* configure FDC's powersave features */
#define FD_FORMAT_N_WRITE	0xef    /* format and write in one go. */
#define FD_OPTION		0x33	/* ISO format (which is a clean way to
					 * pack more sectors on a track) */

/* DMA commands */
#define DMA_READ	0x46
#define DMA_WRITE	0x4A

/* FDC version return types */
#define FDC_NONE	0x00
#define FDC_UNKNOWN	0x10	/* DO NOT USE THIS TYPE EXCEPT IF IDENTIFICATION
				   FAILS EARLY */
#define FDC_8272A	0x20	/* Intel 8272a, NEC 765 */
#define FDC_765ED	0x30	/* Non-Intel 1MB-compatible FDC, can't detect */
#define FDC_82072	0x40	/* Intel 82072; 8272a + FIFO + DUMPREGS */
#define FDC_82072A	0x45	/* 82072A (on Sparcs) */
#define FDC_82077_ORIG	0x51	/* Original version of 82077AA, sans LOCK */
#define FDC_82077	0x52	/* 82077AA-1 */
#define FDC_82078_UNKN	0x5f	/* Unknown 82078 variant */
#define FDC_82078	0x60	/* 44pin 82078 or 64pin 82078SL */
#define FDC_82078_1	0x61	/* 82078-1 (2Mbps fdc) */
#define FDC_S82078B	0x62	/* S82078B (first seen on Adaptec AVA-2825 VLB
				 * SCSI/EIDE/Floppy controller) */
#define FDC_87306	0x63	/* National Semiconductor PC 87306 */

/*
 * Beware: the fdc type list is roughly sorted by increasing features.
 * Presence of features is tested by comparing the FDC version id with the
 * "oldest" version that has the needed feature.
 * If during FDC detection, an obscure test fails late in the sequence, don't
 * assign FDC_UNKNOWN. Else the FDC will be treated as a dumb 8272a, or worse.
 * This is especially true if the tests are unneeded.
 */

#define FD_RESET_DELAY 20
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * FS_IOC_FIEMAP ioctl infrastructure.
 *
 * Some portions copyright (C) 2007 Cluster File Systems, Inc
 *
 * Authors: Mark Fasheh <mfasheh@suse.com>
 *          Kalpak Shah <kalpak.shah@sun.com>
 *          Andreas Dilger <adilger@sun.com>
 */

#ifndef _LINUX_FIEMAP_H
#define _LINUX_FIEMAP_H

#include <linux/types.h>

struct fiemap_extent {
	__u64 fe_logical;  /* logical offset in bytes for the start of
			    * the extent from the beginning of the file */
	__u64 fe_physical; /* physical offset in bytes for the start
			    * of the extent from the beginning of the disk */
	__u64 fe_length;   /* length in bytes for this extent */
	__u64 fe_reserved64[2];
	__u32 fe_flags;    /* FIEMAP_EXTENT_* flags for this extent */
	__u32 fe_reserved[3];
};

struct fiemap {
	__u64 fm_start;		/* logical offset (inclusive) at
				 * which to start mapping (in) */
	__u64 fm_length;	/* logical length of mapping which
				 * userspace wants (in) */
	__u32 fm_flags;		/* FIEMAP_FLAG_* flags for request (in/out) */
	__u32 fm_mapped_extents;/* number of extents that were mapped (out) */
	__u32 fm_extent_count;  /* size of fm_extents array (in) */
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0]; /* array of mapped extents (out) */
};

#define FIEMAP_MAX_OFFSET	(~0ULL)

#define FIEMAP_FLAG_SYNC	0x00000001 /* sync file data before map */
#define FIEMAP_FLAG_XATTR	0x00000002 /* map extended attribute tree */
#define FIEMAP_FLAG_CACHE	0x00000004 /* request caching of the extents */

#define FIEMAP_FLAGS_COMPAT	(FIEMAP_FLAG_SYNC | FIEMAP_FLAG_XATTR)

#define FIEMAP_EXTENT_LAST		0x00000001 /* Last extent in file. */
#define FIEMAP_EXTENT_UNKNOWN		0x00000002 /* Data location unknown. */
#define FIEMAP_EXTENT_DELALLOC		0x00000004 /* Location still pending.
						    * Sets EXTENT_UNKNOWN. */
#define FIEMAP_EXTENT_ENCODED		0x00000008 /* Data can not be read
						    * while fs is unmounted */
#define FIEMAP_EXTENT_DATA_ENCRYPTED	0x00000080 /* Data is encrypted by fs.
						    * Sets EXTENT_NO_BYPASS. */
#define FIEMAP_EXTENT_NOT_ALIGNED	0x00000100 /* Extent offsets may not be
						    * block aligned. */
#define FIEMAP_EXTENT_DATA_INLINE	0x00000200 /* Data mixed with metadata.
						    * Sets EXTENT_NOT_ALIGNED.*/
#define FIEMAP_EXTENT_DATA_TAIL		0x00000400 /* Multiple files in block.
						    * Sets EXTENT_NOT_ALIGNED.*/
#define FIEMAP_EXTENT_UNWRITTEN		0x00000800 /* Space allocated, but
						    * no data (i.e. zero). */
#define FIEMAP_EXTENT_MERGED		0x00001000 /* File does not natively
						    * support extents. Result
						    * merged for efficiency. */
#define FIEMAP_EXTENT_SHARED		0x00002000 /* Space shared with other
						    * files. */

#endif /* _LINUX_FIEMAP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * Linux Socket Filter Data Structures
 */

#ifndef __LINUX_FILTER_H__
#define __LINUX_FILTER_H__


#include <linux/types.h>


/*
 * Current version of the filter code architecture.
 */
#define BPF_MAJOR_VERSION 1
#define BPF_MINOR_VERSION 1

/*
 *	Try and keep these values and structures similar to BSD, especially
 *	the BPF code definitions which need to match so you can share filters
 */
 
struct sock_filter {	/* Filter block */
	__u16	code;   /* Actual filter code */
	__u8	jt;	/* Jump true */
	__u8	jf;	/* Jump false */
	__u32	k;      /* Generic multiuse field */
};

struct sock_fprog {	/* Required for SO_ATTACH_FILTER. */
	unsigned short		len;	/* Number of filter blocks */
	struct sock_filter *filter;
};

/*
 * Instruction classes
 */

#define BPF_CLASS(code) ((code) & 0x07)
#define         BPF_LD          0x00
#define         BPF_LDX         0x01
#define         BPF_ST          0x02
#define         BPF_STX         0x03
#define         BPF_ALU         0x04
#define         BPF_JMP         0x05
#define         BPF_RET         0x06
#define         BPF_MISC        0x07

/* ld/ldx fields */
#define BPF_SIZE(code)  ((code) & 0x18)
#define         BPF_W           0x00
#define         BPF_H           0x08
#define         BPF_B           0x10
#define BPF_MODE(code)  ((code) & 0xe0)
#define         BPF_IMM         0x00
#define         BPF_ABS         0x20
#define         BPF_IND         0x40
#define         BPF_MEM         0x60
#define         BPF_LEN         0x80
#define         BPF_MSH         0xa0

/* alu/jmp fields */
#define BPF_OP(code)    ((code) & 0xf0)
#define         BPF_ADD         0x00
#define         BPF_SUB         0x10
#define         BPF_MUL         0x20
#define         BPF_DIV         0x30
#define         BPF_OR          0x40
#define         BPF_AND         0x50
#define         BPF_LSH         0x60
#define         BPF_RSH         0x70
#define         BPF_NEG         0x80
#define		BPF_MOD		0x90
#define		BPF_XOR		0xa0

#define         BPF_JA          0x00
#define         BPF_JEQ         0x10
#define         BPF_JGT         0x20
#define         BPF_JGE         0x30
#define         BPF_JSET        0x40
#define BPF_SRC(code)   ((code) & 0x08)
#define         BPF_K           0x00
#define         BPF_X           0x08

/* ret - BPF_K and BPF_X also apply */
#define BPF_RVAL(code)  ((code) & 0x18)
#define         BPF_A           0x10

/* misc */
#define BPF_MISCOP(code) ((code) & 0xf8)
#define         BPF_TAX         0x00
#define         BPF_TXA         0x80

#ifndef BPF_MAXINSNS
#define BPF_MAXINSNS 4096
#endif

/*
 * Macros for filter block array initializers.
 */
#ifndef BPF_STMT
#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }
#endif
#ifndef BPF_JUMP
#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }
#endif

/*
 * Number of scratch memory words for: BPF_ST and BPF_STX
 */
#define BPF_MEMWORDS 16

/* RATIONALE. Negative offsets are invalid in BPF.
   We use them to reference ancillary data.
   Unlike introduction new instructions, it does not break
   existing compilers/optimizers.
 */
#define SKF_AD_OFF    (-0x1000)
#define SKF_AD_PROTOCOL 0
#define SKF_AD_PKTTYPE 	4
#define SKF_AD_IFINDEX 	8
#define SKF_AD_NLATTR	12
#define SKF_AD_NLATTR_NEST	16
#define SKF_AD_MARK 	20
#define SKF_AD_QUEUE	24
#define SKF_AD_HATYPE	28
#define SKF_AD_RXHASH	32
#define SKF_AD_CPU	36
#define SKF_AD_ALU_XOR_X	40
#define SKF_AD_VLAN_TAG	44
#define SKF_AD_VLAN_TAG_PRESENT 48
#define SKF_AD_PAY_OFFSET	52
#define SKF_AD_RANDOM	56
#define SKF_AD_MAX	60
#define SKF_NET_OFF   (-0x100000)
#define SKF_LL_OFF    (-0x200000)


#endif /* __LINUX_FILTER_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * Char device interface.
 *
 * Copyright (C) 2005-2007  Kristian Hoegsberg <krh@bitplanet.net>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef _LINUX_FIREWIRE_CDEV_H
#define _LINUX_FIREWIRE_CDEV_H

#include <linux/ioctl.h>
#include <linux/types.h>
#include <linux/firewire-constants.h>

/* available since kernel version 2.6.22 */
#define FW_CDEV_EVENT_BUS_RESET				0x00
#define FW_CDEV_EVENT_RESPONSE				0x01
#define FW_CDEV_EVENT_REQUEST				0x02
#define FW_CDEV_EVENT_ISO_INTERRUPT			0x03

/* available since kernel version 2.6.30 */
#define FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED		0x04
#define FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED		0x05

/* available since kernel version 2.6.36 */
#define FW_CDEV_EVENT_REQUEST2				0x06
#define FW_CDEV_EVENT_PHY_PACKET_SENT			0x07
#define FW_CDEV_EVENT_PHY_PACKET_RECEIVED		0x08
#define FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL	0x09

/**
 * struct fw_cdev_event_common - Common part of all fw_cdev_event_ types
 * @closure:	For arbitrary use by userspace
 * @type:	Discriminates the fw_cdev_event_ types
 *
 * This struct may be used to access generic members of all fw_cdev_event_
 * types regardless of the specific type.
 *
 * Data passed in the @closure field for a request will be returned in the
 * corresponding event.  It is big enough to hold a pointer on all platforms.
 * The ioctl used to set @closure depends on the @type of event.
 */
struct fw_cdev_event_common {
	__u64 closure;
	__u32 type;
};

/**
 * struct fw_cdev_event_bus_reset - Sent when a bus reset occurred
 * @closure:	See &fw_cdev_event_common; set by %FW_CDEV_IOC_GET_INFO ioctl
 * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_BUS_RESET
 * @node_id:       New node ID of this node
 * @local_node_id: Node ID of the local node, i.e. of the controller
 * @bm_node_id:    Node ID of the bus manager
 * @irm_node_id:   Node ID of the iso resource manager
 * @root_node_id:  Node ID of the root node
 * @generation:    New bus generation
 *
 * This event is sent when the bus the device belongs to goes through a bus
 * reset.  It provides information about the new bus configuration, such as
 * new node ID for this device, new root ID, and others.
 *
 * If @bm_node_id is 0xffff right after bus reset it can be reread by an
 * %FW_CDEV_IOC_GET_INFO ioctl after bus manager selection was finished.
 * Kernels with ABI version < 4 do not set @bm_node_id.
 */
struct fw_cdev_event_bus_reset {
	__u64 closure;
	__u32 type;
	__u32 node_id;
	__u32 local_node_id;
	__u32 bm_node_id;
	__u32 irm_node_id;
	__u32 root_node_id;
	__u32 generation;
};

/**
 * struct fw_cdev_event_response - Sent when a response packet was received
 * @closure:	See &fw_cdev_event_common; set by %FW_CDEV_IOC_SEND_REQUEST
 *		or %FW_CDEV_IOC_SEND_BROADCAST_REQUEST
 *		or %FW_CDEV_IOC_SEND_STREAM_PACKET ioctl
 * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_RESPONSE
 * @rcode:	Response code returned by the remote node
 * @length:	Data length, i.e. the response's payload size in bytes
 * @data:	Payload data, if any
 *
 * This event is sent when the stack receives a response to an outgoing request
 * sent by %FW_CDEV_IOC_SEND_REQUEST ioctl.  The payload data for responses
 * carrying data (read and lock responses) follows immediately and can be
 * accessed through the @data field.
 *
 * The event is also generated after conclusions of transactions that do not
 * involve response packets.  This includes unified write transactions,
 * broadcast write transactions, and transmission of asynchronous stream
 * packets.  @rcode indicates success or failure of such transmissions.
 */
struct fw_cdev_event_response {
	__u64 closure;
	__u32 type;
	__u32 rcode;
	__u32 length;
	__u32 data[0];
};

/**
 * struct fw_cdev_event_request - Old version of &fw_cdev_event_request2
 * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_REQUEST
 *
 * This event is sent instead of &fw_cdev_event_request2 if the kernel or
 * the client implements ABI version <= 3.  &fw_cdev_event_request lacks
 * essential information; use &fw_cdev_event_request2 instead.
 */
struct fw_cdev_event_request {
	__u64 closure;
	__u32 type;
	__u32 tcode;
	__u64 offset;
	__u32 handle;
	__u32 length;
	__u32 data[0];
};

/**
 * struct fw_cdev_event_request2 - Sent on incoming request to an address region
 * @closure:	See &fw_cdev_event_common; set by %FW_CDEV_IOC_ALLOCATE ioctl
 * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_REQUEST2
 * @tcode:	Transaction code of the incoming request
 * @offset:	The offset into the 48-bit per-node address space
 * @source_node_id: Sender node ID
 * @destination_node_id: Destination node ID
 * @card:	The index of the card from which the request came
 * @generation:	Bus generation in which the request is valid
 * @handle:	Reference to the kernel-side pending request
 * @length:	Data length, i.e. the request's payload size in bytes
 * @data:	Incoming data, if any
 *
 * This event is sent when the stack receives an incoming request to an address
 * region registered using the %FW_CDEV_IOC_ALLOCATE ioctl.  The request is
 * guaranteed to be completely contained in the specified region.  Userspace is
 * responsible for sending the response by %FW_CDEV_IOC_SEND_RESPONSE ioctl,
 * using the same @handle.
 *
 * The payload data for requests carrying data (write and lock requests)
 * follows immediately and can be accessed through the @data field.
 *
 * Unlike &fw_cdev_event_request, @tcode of lock requests is one of the
 * firewire-core specific %TCODE_LOCK_MASK_SWAP...%TCODE_LOCK_VENDOR_DEPENDENT,
 * i.e. encodes the extended transaction code.
 *
 * @card may differ from &fw_cdev_get_info.card because requests are received
 * from all cards of the Linux host.  @source_node_id, @destination_node_id, and
 * @generation pertain to that card.  Destination node ID and bus generation may
 * therefore differ from the corresponding fields of the last
 * &fw_cdev_event_bus_reset.
 *
 * @destination_node_id may also differ from the current node ID because of a
 * non-local bus ID part or in case of a broadcast write request.  Note, a
 * client must call an %FW_CDEV_IOC_SEND_RESPONSE ioctl even in case of a
 * broadcast write request; the kernel will then release the kernel-side pending
 * request but will not actually send a response packet.
 *
 * In case of a write request to FCP_REQUEST or FCP_RESPONSE, the kernel already
 * sent a write response immediately after the request was received; in this
 * case the client must still call an %FW_CDEV_IOC_SEND_RESPONSE ioctl to
 * release the kernel-side pending request, though another response won't be
 * sent.
 *
 * If the client subsequently needs to initiate requests to the sender node of
 * an &fw_cdev_event_request2, it needs to use a device file with matching
 * card index, node ID, and generation for outbound requests.
 */
struct fw_cdev_event_request2 {
	__u64 closure;
	__u32 type;
	__u32 tcode;
	__u64 offset;
	__u32 source_node_id;
	__u32 destination_node_id;
	__u32 card;
	__u32 generation;
	__u32 handle;
	__u32 length;
	__u32 data[0];
};

/**
 * struct fw_cdev_event_iso_interrupt - Sent when an iso packet was completed
 * @closure:	See &fw_cdev_event_common;
 *		set by %FW_CDEV_CREATE_ISO_CONTEXT ioctl
 * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_ISO_INTERRUPT
 * @cycle:	Cycle counter of the last completed packet
 * @header_length: Total length of following headers, in bytes
 * @header:	Stripped headers, if any
 *
 * This event is sent when the controller has completed an &fw_cdev_iso_packet
 * with the %FW_CDEV_ISO_INTERRUPT bit set, when explicitly requested with
 * %FW_CDEV_IOC_FLUSH_ISO, or when there have been so many completed packets
 * without the interrupt bit set that the kernel's internal buffer for @header
 * is about to overflow.  (In the last case, ABI versions < 5 drop header data
 * up to the next interrupt packet.)
 *
 * Isochronous transmit events (context type %FW_CDEV_ISO_CONTEXT_TRANSMIT):
 *
 * In version 3 and some implementations of version 2 of the ABI, &header_length
 * is a multiple of 4 and &header contains timestamps of all packets up until
 * the interrupt packet.  The format of the timestamps is as described below for
 * isochronous reception.  In version 1 of the ABI, &header_length was 0.
 *
 * Isochronous receive events (context type %FW_CDEV_ISO_CONTEXT_RECEIVE):
 *
 * The headers stripped of all packets up until and including the interrupt
 * packet are returned in the @header field.  The amount of header data per
 * packet is as specified at iso context creation by
 * &fw_cdev_create_iso_context.header_size.
 *
 * Hence, _interrupt.header_length / _context.header_size is the number of
 * packets received in this interrupt event.  The client can now iterate
 * through the mmap()'ed DMA buffer according to this number of packets and
 * to the buffer sizes as the client specified in &fw_cdev_queue_iso.
 *
 * Since version 2 of this ABI, the portion for each packet in _interrupt.header
 * consists of the 1394 isochronous packet header, followed by a timestamp
 * quadlet if &fw_cdev_create_iso_context.header_size > 4, followed by quadlets
 * from the packet payload if &fw_cdev_create_iso_context.header_size > 8.
 *
 * Format of 1394 iso packet header:  16 bits data_length, 2 bits tag, 6 bits
 * channel, 4 bits tcode, 4 bits sy, in big endian byte order.
 * data_length is the actual received size of the packet without the four
 * 1394 iso packet header bytes.
 *
 * Format of timestamp:  16 bits invalid, 3 bits cycleSeconds, 13 bits
 * cycleCount, in big endian byte order.
 *
 * In version 1 of the ABI, no timestamp quadlet was inserted; instead, payload
 * data followed directly after the 1394 is header if header_size > 4.
 * Behaviour of ver. 1 of this ABI is no longer available since ABI ver. 2.
 */
struct fw_cdev_event_iso_interrupt {
	__u64 closure;
	__u32 type;
	__u32 cycle;
	__u32 header_length;
	__u32 header[0];
};

/**
 * struct fw_cdev_event_iso_interrupt_mc - An iso buffer chunk was completed
 * @closure:	See &fw_cdev_event_common;
 *		set by %FW_CDEV_CREATE_ISO_CONTEXT ioctl
 * @type:	%FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL
 * @completed:	Offset into the receive buffer; data before this offset is valid
 *
 * This event is sent in multichannel contexts (context type
 * %FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL) for &fw_cdev_iso_packet buffer
 * chunks that have been completely filled and that have the
 * %FW_CDEV_ISO_INTERRUPT bit set, or when explicitly requested with
 * %FW_CDEV_IOC_FLUSH_ISO.
 *
 * The buffer is continuously filled with the following data, per packet:
 *  - the 1394 iso packet header as described at &fw_cdev_event_iso_interrupt,
 *    but in little endian byte order,
 *  - packet payload (as many bytes as specified in the data_length field of
 *    the 1394 iso packet header) in big endian byte order,
 *  - 0...3 padding bytes as needed to align the following trailer quadlet,
 *  - trailer quadlet, containing the reception timestamp as described at
 *    &fw_cdev_event_iso_interrupt, but in little endian byte order.
 *
 * Hence the per-packet size is data_length (rounded up to a multiple of 4) + 8.
 * When processing the data, stop before a packet that would cross the
 * @completed offset.
 *
 * A packet near the end of a buffer chunk will typically spill over into the
 * next queued buffer chunk.  It is the responsibility of the client to check
 * for this condition, assemble a broken-up packet from its parts, and not to
 * re-queue any buffer chunks in which as yet unread packet parts reside.
 */
struct fw_cdev_event_iso_interrupt_mc {
	__u64 closure;
	__u32 type;
	__u32 completed;
};

/**
 * struct fw_cdev_event_iso_resource - Iso resources were allocated or freed
 * @closure:	See &fw_cdev_event_common;
 *		set by %FW_CDEV_IOC_(DE)ALLOCATE_ISO_RESOURCE(_ONCE) ioctl
 * @type:	%FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED or
 *		%FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED
 * @handle:	Reference by which an allocated resource can be deallocated
 * @channel:	Isochronous channel which was (de)allocated, if any
 * @bandwidth:	Bandwidth allocation units which were (de)allocated, if any
 *
 * An %FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED event is sent after an isochronous
 * resource was allocated at the IRM.  The client has to check @channel and
 * @bandwidth for whether the allocation actually succeeded.
 *
 * An %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event is sent after an isochronous
 * resource was deallocated at the IRM.  It is also sent when automatic
 * reallocation after a bus reset failed.
 *
 * @channel is <0 if no channel was (de)allocated or if reallocation failed.
 * @bandwidth is 0 if no bandwidth was (de)allocated or if reallocation failed.
 */
struct fw_cdev_event_iso_resource {
	__u64 closure;
	__u32 type;
	__u32 handle;
	__s32 channel;
	__s32 bandwidth;
};

/**
 * struct fw_cdev_event_phy_packet - A PHY packet was transmitted or received
 * @closure:	See &fw_cdev_event_common; set by %FW_CDEV_IOC_SEND_PHY_PACKET
 *		or %FW_CDEV_IOC_RECEIVE_PHY_PACKETS ioctl
 * @type:	%FW_CDEV_EVENT_PHY_PACKET_SENT or %..._RECEIVED
 * @rcode:	%RCODE_..., indicates success or failure of transmission
 * @length:	Data length in bytes
 * @data:	Incoming data
 *
 * If @type is %FW_CDEV_EVENT_PHY_PACKET_SENT, @length is 0 and @data empty,
 * except in case of a ping packet:  Then, @length is 4, and @data[0] is the
 * ping time in 49.152MHz clocks if @rcode is %RCODE_COMPLETE.
 *
 * If @type is %FW_CDEV_EVENT_PHY_PACKET_RECEIVED, @length is 8 and @data
 * consists of the two PHY packet quadlets, in host byte order.
 */
struct fw_cdev_event_phy_packet {
	__u64 closure;
	__u32 type;
	__u32 rcode;
	__u32 length;
	__u32 data[0];
};

/**
 * union fw_cdev_event - Convenience union of fw_cdev_event_ types
 * @common:		Valid for all types
 * @bus_reset:		Valid if @common.type == %FW_CDEV_EVENT_BUS_RESET
 * @response:		Valid if @common.type == %FW_CDEV_EVENT_RESPONSE
 * @request:		Valid if @common.type == %FW_CDEV_EVENT_REQUEST
 * @request2:		Valid if @common.type == %FW_CDEV_EVENT_REQUEST2
 * @iso_interrupt:	Valid if @common.type == %FW_CDEV_EVENT_ISO_INTERRUPT
 * @iso_interrupt_mc:	Valid if @common.type ==
 *				%FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL
 * @iso_resource:	Valid if @common.type ==
 *				%FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED or
 *				%FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED
 * @phy_packet:		Valid if @common.type ==
 *				%FW_CDEV_EVENT_PHY_PACKET_SENT or
 *				%FW_CDEV_EVENT_PHY_PACKET_RECEIVED
 *
 * Convenience union for userspace use.  Events could be read(2) into an
 * appropriately aligned char buffer and then cast to this union for further
 * processing.  Note that for a request, response or iso_interrupt event,
 * the data[] or header[] may make the size of the full event larger than
 * sizeof(union fw_cdev_event).  Also note that if you attempt to read(2)
 * an event into a buffer that is not large enough for it, the data that does
 * not fit will be discarded so that the next read(2) will return a new event.
 */
union fw_cdev_event {
	struct fw_cdev_event_common		common;
	struct fw_cdev_event_bus_reset		bus_reset;
	struct fw_cdev_event_response		response;
	struct fw_cdev_event_request		request;
	struct fw_cdev_event_request2		request2;		/* added in 2.6.36 */
	struct fw_cdev_event_iso_interrupt	iso_interrupt;
	struct fw_cdev_event_iso_interrupt_mc	iso_interrupt_mc;	/* added in 2.6.36 */
	struct fw_cdev_event_iso_resource	iso_resource;		/* added in 2.6.30 */
	struct fw_cdev_event_phy_packet		phy_packet;		/* added in 2.6.36 */
};

/* available since kernel version 2.6.22 */
#define FW_CDEV_IOC_GET_INFO           _IOWR('#', 0x00, struct fw_cdev_get_info)
#define FW_CDEV_IOC_SEND_REQUEST        _IOW('#', 0x01, struct fw_cdev_send_request)
#define FW_CDEV_IOC_ALLOCATE           _IOWR('#', 0x02, struct fw_cdev_allocate)
#define FW_CDEV_IOC_DEALLOCATE          _IOW('#', 0x03, struct fw_cdev_deallocate)
#define FW_CDEV_IOC_SEND_RESPONSE       _IOW('#', 0x04, struct fw_cdev_send_response)
#define FW_CDEV_IOC_INITIATE_BUS_RESET  _IOW('#', 0x05, struct fw_cdev_initiate_bus_reset)
#define FW_CDEV_IOC_ADD_DESCRIPTOR     _IOWR('#', 0x06, struct fw_cdev_add_descriptor)
#define FW_CDEV_IOC_REMOVE_DESCRIPTOR   _IOW('#', 0x07, struct fw_cdev_remove_descriptor)
#define FW_CDEV_IOC_CREATE_ISO_CONTEXT _IOWR('#', 0x08, struct fw_cdev_create_iso_context)
#define FW_CDEV_IOC_QUEUE_ISO          _IOWR('#', 0x09, struct fw_cdev_queue_iso)
#define FW_CDEV_IOC_START_ISO           _IOW('#', 0x0a, struct fw_cdev_start_iso)
#define FW_CDEV_IOC_STOP_ISO            _IOW('#', 0x0b, struct fw_cdev_stop_iso)

/* available since kernel version 2.6.24 */
#define FW_CDEV_IOC_GET_CYCLE_TIMER     _IOR('#', 0x0c, struct fw_cdev_get_cycle_timer)

/* available since kernel version 2.6.30 */
#define FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE       _IOWR('#', 0x0d, struct fw_cdev_allocate_iso_resource)
#define FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE      _IOW('#', 0x0e, struct fw_cdev_deallocate)
#define FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE   _IOW('#', 0x0f, struct fw_cdev_allocate_iso_resource)
#define FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE_ONCE _IOW('#', 0x10, struct fw_cdev_allocate_iso_resource)
#define FW_CDEV_IOC_GET_SPEED                     _IO('#', 0x11) /* returns speed code */
#define FW_CDEV_IOC_SEND_BROADCAST_REQUEST       _IOW('#', 0x12, struct fw_cdev_send_request)
#define FW_CDEV_IOC_SEND_STREAM_PACKET           _IOW('#', 0x13, struct fw_cdev_send_stream_packet)

/* available since kernel version 2.6.34 */
#define FW_CDEV_IOC_GET_CYCLE_TIMER2   _IOWR('#', 0x14, struct fw_cdev_get_cycle_timer2)

/* available since kernel version 2.6.36 */
#define FW_CDEV_IOC_SEND_PHY_PACKET    _IOWR('#', 0x15, struct fw_cdev_send_phy_packet)
#define FW_CDEV_IOC_RECEIVE_PHY_PACKETS _IOW('#', 0x16, struct fw_cdev_receive_phy_packets)
#define FW_CDEV_IOC_SET_ISO_CHANNELS    _IOW('#', 0x17, struct fw_cdev_set_iso_channels)

/* available since kernel version 3.4 */
#define FW_CDEV_IOC_FLUSH_ISO           _IOW('#', 0x18, struct fw_cdev_flush_iso)

/*
 * ABI version history
 *  1  (2.6.22)  - initial version
 *     (2.6.24)  - added %FW_CDEV_IOC_GET_CYCLE_TIMER
 *  2  (2.6.30)  - changed &fw_cdev_event_iso_interrupt.header if
 *                 &fw_cdev_create_iso_context.header_size is 8 or more
 *               - added %FW_CDEV_IOC_*_ISO_RESOURCE*,
 *                 %FW_CDEV_IOC_GET_SPEED, %FW_CDEV_IOC_SEND_BROADCAST_REQUEST,
 *                 %FW_CDEV_IOC_SEND_STREAM_PACKET
 *     (2.6.32)  - added time stamp to xmit &fw_cdev_event_iso_interrupt
 *     (2.6.33)  - IR has always packet-per-buffer semantics now, not one of
 *                 dual-buffer or packet-per-buffer depending on hardware
 *               - shared use and auto-response for FCP registers
 *  3  (2.6.34)  - made &fw_cdev_get_cycle_timer reliable
 *               - added %FW_CDEV_IOC_GET_CYCLE_TIMER2
 *  4  (2.6.36)  - added %FW_CDEV_EVENT_REQUEST2, %FW_CDEV_EVENT_PHY_PACKET_*,
 *                 and &fw_cdev_allocate.region_end
 *               - implemented &fw_cdev_event_bus_reset.bm_node_id
 *               - added %FW_CDEV_IOC_SEND_PHY_PACKET, _RECEIVE_PHY_PACKETS
 *               - added %FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL,
 *                 %FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL, and
 *                 %FW_CDEV_IOC_SET_ISO_CHANNELS
 *  5  (3.4)     - send %FW_CDEV_EVENT_ISO_INTERRUPT events when needed to
 *                 avoid dropping data
 *               - added %FW_CDEV_IOC_FLUSH_ISO
 */

/**
 * struct fw_cdev_get_info - General purpose information ioctl
 * @version:	The version field is just a running serial number.  Both an
 *		input parameter (ABI version implemented by the client) and
 *		output parameter (ABI version implemented by the kernel).
 *		A client shall fill in the ABI @version for which the client
 *		was implemented.  This is necessary for forward compatibility.
 * @rom_length:	If @rom is non-zero, up to @rom_length bytes of Configuration
 *		ROM will be copied into that user space address.  In either
 *		case, @rom_length is updated with the actual length of the
 *		Configuration ROM.
 * @rom:	If non-zero, address of a buffer to be filled by a copy of the
 *		device's Configuration ROM
 * @bus_reset:	If non-zero, address of a buffer to be filled by a
 *		&struct fw_cdev_event_bus_reset with the current state
 *		of the bus.  This does not cause a bus reset to happen.
 * @bus_reset_closure: Value of &closure in this and subsequent bus reset events
 * @card:	The index of the card this device belongs to
 *
 * The %FW_CDEV_IOC_GET_INFO ioctl is usually the very first one which a client
 * performs right after it opened a /dev/fw* file.
 *
 * As a side effect, reception of %FW_CDEV_EVENT_BUS_RESET events to be read(2)
 * is started by this ioctl.
 */
struct fw_cdev_get_info {
	__u32 version;
	__u32 rom_length;
	__u64 rom;
	__u64 bus_reset;
	__u64 bus_reset_closure;
	__u32 card;
};

/**
 * struct fw_cdev_send_request - Send an asynchronous request packet
 * @tcode:	Transaction code of the request
 * @length:	Length of outgoing payload, in bytes
 * @offset:	48-bit offset at destination node
 * @closure:	Passed back to userspace in the response event
 * @data:	Userspace pointer to payload
 * @generation:	The bus generation where packet is valid
 *
 * Send a request to the device.  This ioctl implements all outgoing requests.
 * Both quadlet and block request specify the payload as a pointer to the data
 * in the @data field.  Once the transaction completes, the kernel writes an
 * &fw_cdev_event_response event back.  The @closure field is passed back to
 * user space in the response event.
 */
struct fw_cdev_send_request {
	__u32 tcode;
	__u32 length;
	__u64 offset;
	__u64 closure;
	__u64 data;
	__u32 generation;
};

/**
 * struct fw_cdev_send_response - Send an asynchronous response packet
 * @rcode:	Response code as determined by the userspace handler
 * @length:	Length of outgoing payload, in bytes
 * @data:	Userspace pointer to payload
 * @handle:	The handle from the &fw_cdev_event_request
 *
 * Send a response to an incoming request.  By setting up an address range using
 * the %FW_CDEV_IOC_ALLOCATE ioctl, userspace can listen for incoming requests.  An
 * incoming request will generate an %FW_CDEV_EVENT_REQUEST, and userspace must
 * send a reply using this ioctl.  The event has a handle to the kernel-side
 * pending transaction, which should be used with this ioctl.
 */
struct fw_cdev_send_response {
	__u32 rcode;
	__u32 length;
	__u64 data;
	__u32 handle;
};

/**
 * struct fw_cdev_allocate - Allocate a CSR in an address range
 * @offset:	Start offset of the address range
 * @closure:	To be passed back to userspace in request events
 * @length:	Length of the CSR, in bytes
 * @handle:	Handle to the allocation, written by the kernel
 * @region_end:	First address above the address range (added in ABI v4, 2.6.36)
 *
 * Allocate an address range in the 48-bit address space on the local node
 * (the controller).  This allows userspace to listen for requests with an
 * offset within that address range.  Every time when the kernel receives a
 * request within the range, an &fw_cdev_event_request2 event will be emitted.
 * (If the kernel or the client implements ABI version <= 3, an
 * &fw_cdev_event_request will be generated instead.)
 *
 * The @closure field is passed back to userspace in these request events.
 * The @handle field is an out parameter, returning a handle to the allocated
 * range to be used for later deallocation of the range.
 *
 * The address range is allocated on all local nodes.  The address allocation
 * is exclusive except for the FCP command and response registers.  If an
 * exclusive address region is already in use, the ioctl fails with errno set
 * to %EBUSY.
 *
 * If kernel and client implement ABI version >= 4, the kernel looks up a free
 * spot of size @length inside [@offset..@region_end) and, if found, writes
 * the start address of the new CSR back in @offset.  I.e. @offset is an
 * in and out parameter.  If this automatic placement of a CSR in a bigger
 * address range is not desired, the client simply needs to set @region_end
 * = @offset + @length.
 *
 * If the kernel or the client implements ABI version <= 3, @region_end is
 * ignored and effectively assumed to be @offset + @length.
 *
 * @region_end is only present in a kernel header >= 2.6.36.  If necessary,
 * this can for example be tested by #ifdef FW_CDEV_EVENT_REQUEST2.
 */
struct fw_cdev_allocate {
	__u64 offset;
	__u64 closure;
	__u32 length;
	__u32 handle;
	__u64 region_end;	/* available since kernel version 2.6.36 */
};

/**
 * struct fw_cdev_deallocate - Free a CSR address range or isochronous resource
 * @handle:	Handle to the address range or iso resource, as returned by the
 *		kernel when the range or resource was allocated
 */
struct fw_cdev_deallocate {
	__u32 handle;
};

#define FW_CDEV_LONG_RESET	0
#define FW_CDEV_SHORT_RESET	1

/**
 * struct fw_cdev_initiate_bus_reset - Initiate a bus reset
 * @type:	%FW_CDEV_SHORT_RESET or %FW_CDEV_LONG_RESET
 *
 * Initiate a bus reset for the bus this device is on.  The bus reset can be
 * either the original (long) bus reset or the arbitrated (short) bus reset
 * introduced in 1394a-2000.
 *
 * The ioctl returns immediately.  A subsequent &fw_cdev_event_bus_reset
 * indicates when the reset actually happened.  Since ABI v4, this may be
 * considerably later than the ioctl because the kernel ensures a grace period
 * between subsequent bus resets as per IEEE 1394 bus management specification.
 */
struct fw_cdev_initiate_bus_reset {
	__u32 type;
};

/**
 * struct fw_cdev_add_descriptor - Add contents to the local node's config ROM
 * @immediate:	If non-zero, immediate key to insert before pointer
 * @key:	Upper 8 bits of root directory pointer
 * @data:	Userspace pointer to contents of descriptor block
 * @length:	Length of descriptor block data, in quadlets
 * @handle:	Handle to the descriptor, written by the kernel
 *
 * Add a descriptor block and optionally a preceding immediate key to the local
 * node's Configuration ROM.
 *
 * The @key field specifies the upper 8 bits of the descriptor root directory
 * pointer and the @data and @length fields specify the contents. The @key
 * should be of the form 0xXX000000. The offset part of the root directory entry
 * will be filled in by the kernel.
 *
 * If not 0, the @immediate field specifies an immediate key which will be
 * inserted before the root directory pointer.
 *
 * @immediate, @key, and @data array elements are CPU-endian quadlets.
 *
 * If successful, the kernel adds the descriptor and writes back a @handle to
 * the kernel-side object to be used for later removal of the descriptor block
 * and immediate key.  The kernel will also generate a bus reset to signal the
 * change of the Configuration ROM to other nodes.
 *
 * This ioctl affects the Configuration ROMs of all local nodes.
 * The ioctl only succeeds on device files which represent a local node.
 */
struct fw_cdev_add_descriptor {
	__u32 immediate;
	__u32 key;
	__u64 data;
	__u32 length;
	__u32 handle;
};

/**
 * struct fw_cdev_remove_descriptor - Remove contents from the Configuration ROM
 * @handle:	Handle to the descriptor, as returned by the kernel when the
 *		descriptor was added
 *
 * Remove a descriptor block and accompanying immediate key from the local
 * nodes' Configuration ROMs.  The kernel will also generate a bus reset to
 * signal the change of the Configuration ROM to other nodes.
 */
struct fw_cdev_remove_descriptor {
	__u32 handle;
};

#define FW_CDEV_ISO_CONTEXT_TRANSMIT			0
#define FW_CDEV_ISO_CONTEXT_RECEIVE			1
#define FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL	2 /* added in 2.6.36 */

/**
 * struct fw_cdev_create_iso_context - Create a context for isochronous I/O
 * @type:	%FW_CDEV_ISO_CONTEXT_TRANSMIT or %FW_CDEV_ISO_CONTEXT_RECEIVE or
 *		%FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL
 * @header_size: Header size to strip in single-channel reception
 * @channel:	Channel to bind to in single-channel reception or transmission
 * @speed:	Transmission speed
 * @closure:	To be returned in &fw_cdev_event_iso_interrupt or
 *		&fw_cdev_event_iso_interrupt_multichannel
 * @handle:	Handle to context, written back by kernel
 *
 * Prior to sending or receiving isochronous I/O, a context must be created.
 * The context records information about the transmit or receive configuration
 * and typically maps to an underlying hardware resource.  A context is set up
 * for either sending or receiving.  It is bound to a specific isochronous
 * @channel.
 *
 * In case of multichannel reception, @header_size and @channel are ignored
 * and the channels are selected by %FW_CDEV_IOC_SET_ISO_CHANNELS.
 *
 * For %FW_CDEV_ISO_CONTEXT_RECEIVE contexts, @header_size must be at least 4
 * and must be a multiple of 4.  It is ignored in other context types.
 *
 * @speed is ignored in receive context types.
 *
 * If a context was successfully created, the kernel writes back a handle to the
 * context, which must be passed in for subsequent operations on that context.
 *
 * Limitations:
 * No more than one iso context can be created per fd.
 * The total number of contexts that all userspace and kernelspace drivers can
 * create on a card at a time is a hardware limit, typically 4 or 8 contexts per
 * direction, and of them at most one multichannel receive context.
 */
struct fw_cdev_create_iso_context {
	__u32 type;
	__u32 header_size;
	__u32 channel;
	__u32 speed;
	__u64 closure;
	__u32 handle;
};

/**
 * struct fw_cdev_set_iso_channels - Select channels in multichannel reception
 * @channels:	Bitmask of channels to listen to
 * @handle:	Handle of the mutichannel receive context
 *
 * @channels is the bitwise or of 1ULL << n for each channel n to listen to.
 *
 * The ioctl fails with errno %EBUSY if there is already another receive context
 * on a channel in @channels.  In that case, the bitmask of all unoccupied
 * channels is returned in @channels.
 */
struct fw_cdev_set_iso_channels {
	__u64 channels;
	__u32 handle;
};

#define FW_CDEV_ISO_PAYLOAD_LENGTH(v)	(v)
#define FW_CDEV_ISO_INTERRUPT		(1 << 16)
#define FW_CDEV_ISO_SKIP		(1 << 17)
#define FW_CDEV_ISO_SYNC		(1 << 17)
#define FW_CDEV_ISO_TAG(v)		((v) << 18)
#define FW_CDEV_ISO_SY(v)		((v) << 20)
#define FW_CDEV_ISO_HEADER_LENGTH(v)	((v) << 24)

/**
 * struct fw_cdev_iso_packet - Isochronous packet
 * @control:	Contains the header length (8 uppermost bits),
 *		the sy field (4 bits), the tag field (2 bits), a sync flag
 *		or a skip flag (1 bit), an interrupt flag (1 bit), and the
 *		payload length (16 lowermost bits)
 * @header:	Header and payload in case of a transmit context.
 *
 * &struct fw_cdev_iso_packet is used to describe isochronous packet queues.
 * Use the FW_CDEV_ISO_ macros to fill in @control.
 * The @header array is empty in case of receive contexts.
 *
 * Context type %FW_CDEV_ISO_CONTEXT_TRANSMIT:
 *
 * @control.HEADER_LENGTH must be a multiple of 4.  It specifies the numbers of
 * bytes in @header that will be prepended to the packet's payload.  These bytes
 * are copied into the kernel and will not be accessed after the ioctl has
 * returned.
 *
 * The @control.SY and TAG fields are copied to the iso packet header.  These
 * fields are specified by IEEE 1394a and IEC 61883-1.
 *
 * The @control.SKIP flag specifies that no packet is to be sent in a frame.
 * When using this, all other fields except @control.INTERRUPT must be zero.
 *
 * When a packet with the @control.INTERRUPT flag set has been completed, an
 * &fw_cdev_event_iso_interrupt event will be sent.
 *
 * Context type %FW_CDEV_ISO_CONTEXT_RECEIVE:
 *
 * @control.HEADER_LENGTH must be a multiple of the context's header_size.
 * If the HEADER_LENGTH is larger than the context's header_size, multiple
 * packets are queued for this entry.
 *
 * The @control.SY and TAG fields are ignored.
 *
 * If the @control.SYNC flag is set, the context drops all packets until a
 * packet with a sy field is received which matches &fw_cdev_start_iso.sync.
 *
 * @control.PAYLOAD_LENGTH defines how many payload bytes can be received for
 * one packet (in addition to payload quadlets that have been defined as headers
 * and are stripped and returned in the &fw_cdev_event_iso_interrupt structure).
 * If more bytes are received, the additional bytes are dropped.  If less bytes
 * are received, the remaining bytes in this part of the payload buffer will not
 * be written to, not even by the next packet.  I.e., packets received in
 * consecutive frames will not necessarily be consecutive in memory.  If an
 * entry has queued multiple packets, the PAYLOAD_LENGTH is divided equally
 * among them.
 *
 * When a packet with the @control.INTERRUPT flag set has been completed, an
 * &fw_cdev_event_iso_interrupt event will be sent.  An entry that has queued
 * multiple receive packets is completed when its last packet is completed.
 *
 * Context type %FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL:
 *
 * Here, &fw_cdev_iso_packet would be more aptly named _iso_buffer_chunk since
 * it specifies a chunk of the mmap()'ed buffer, while the number and alignment
 * of packets to be placed into the buffer chunk is not known beforehand.
 *
 * @control.PAYLOAD_LENGTH is the size of the buffer chunk and specifies room
 * for header, payload, padding, and trailer bytes of one or more packets.
 * It must be a multiple of 4.
 *
 * @control.HEADER_LENGTH, TAG and SY are ignored.  SYNC is treated as described
 * for single-channel reception.
 *
 * When a buffer chunk with the @control.INTERRUPT flag set has been filled
 * entirely, an &fw_cdev_event_iso_interrupt_mc event will be sent.
 */
struct fw_cdev_iso_packet {
	__u32 control;
	__u32 header[0];
};

/**
 * struct fw_cdev_queue_iso - Queue isochronous packets for I/O
 * @packets:	Userspace pointer to an array of &fw_cdev_iso_packet
 * @data:	Pointer into mmap()'ed payload buffer
 * @size:	Size of the @packets array, in bytes
 * @handle:	Isochronous context handle
 *
 * Queue a number of isochronous packets for reception or transmission.
 * This ioctl takes a pointer to an array of &fw_cdev_iso_packet structs,
 * which describe how to transmit from or receive into a contiguous region
 * of a mmap()'ed payload buffer.  As part of transmit packet descriptors,
 * a series of headers can be supplied, which will be prepended to the
 * payload during DMA.
 *
 * The kernel may or may not queue all packets, but will write back updated
 * values of the @packets, @data and @size fields, so the ioctl can be
 * resubmitted easily.
 *
 * In case of a multichannel receive context, @data must be quadlet-aligned
 * relative to the buffer start.
 */
struct fw_cdev_queue_iso {
	__u64 packets;
	__u64 data;
	__u32 size;
	__u32 handle;
};

#define FW_CDEV_ISO_CONTEXT_MATCH_TAG0		 1
#define FW_CDEV_ISO_CONTEXT_MATCH_TAG1		 2
#define FW_CDEV_ISO_CONTEXT_MATCH_TAG2		 4
#define FW_CDEV_ISO_CONTEXT_MATCH_TAG3		 8
#define FW_CDEV_ISO_CONTEXT_MATCH_ALL_TAGS	15

/**
 * struct fw_cdev_start_iso - Start an isochronous transmission or reception
 * @cycle:	Cycle in which to start I/O.  If @cycle is greater than or
 *		equal to 0, the I/O will start on that cycle.
 * @sync:	Determines the value to wait for for receive packets that have
 *		the %FW_CDEV_ISO_SYNC bit set
 * @tags:	Tag filter bit mask.  Only valid for isochronous reception.
 *		Determines the tag values for which packets will be accepted.
 *		Use FW_CDEV_ISO_CONTEXT_MATCH_ macros to set @tags.
 * @handle:	Isochronous context handle within which to transmit or receive
 */
struct fw_cdev_start_iso {
	__s32 cycle;
	__u32 sync;
	__u32 tags;
	__u32 handle;
};

/**
 * struct fw_cdev_stop_iso - Stop an isochronous transmission or reception
 * @handle:	Handle of isochronous context to stop
 */
struct fw_cdev_stop_iso {
	__u32 handle;
};

/**
 * struct fw_cdev_flush_iso - flush completed iso packets
 * @handle:	handle of isochronous context to flush
 *
 * For %FW_CDEV_ISO_CONTEXT_TRANSMIT or %FW_CDEV_ISO_CONTEXT_RECEIVE contexts,
 * report any completed packets.
 *
 * For %FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL contexts, report the current
 * offset in the receive buffer, if it has changed; this is typically in the
 * middle of some buffer chunk.
 *
 * Any %FW_CDEV_EVENT_ISO_INTERRUPT or %FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL
 * events generated by this ioctl are sent synchronously, i.e., are available
 * for reading from the file descriptor when this ioctl returns.
 */
struct fw_cdev_flush_iso {
	__u32 handle;
};

/**
 * struct fw_cdev_get_cycle_timer - read cycle timer register
 * @local_time:   system time, in microseconds since the Epoch
 * @cycle_timer:  Cycle Time register contents
 *
 * Same as %FW_CDEV_IOC_GET_CYCLE_TIMER2, but fixed to use %CLOCK_REALTIME
 * and only with microseconds resolution.
 *
 * In version 1 and 2 of the ABI, this ioctl returned unreliable (non-
 * monotonic) @cycle_timer values on certain controllers.
 */
struct fw_cdev_get_cycle_timer {
	__u64 local_time;
	__u32 cycle_timer;
};

/**
 * struct fw_cdev_get_cycle_timer2 - read cycle timer register
 * @tv_sec:       system time, seconds
 * @tv_nsec:      system time, sub-seconds part in nanoseconds
 * @clk_id:       input parameter, clock from which to get the system time
 * @cycle_timer:  Cycle Time register contents
 *
 * The %FW_CDEV_IOC_GET_CYCLE_TIMER2 ioctl reads the isochronous cycle timer
 * and also the system clock.  This allows to correlate reception time of
 * isochronous packets with system time.
 *
 * @clk_id lets you choose a clock like with POSIX' clock_gettime function.
 * Supported @clk_id values are POSIX' %CLOCK_REALTIME and %CLOCK_MONOTONIC
 * and Linux' %CLOCK_MONOTONIC_RAW.
 *
 * @cycle_timer consists of 7 bits cycleSeconds, 13 bits cycleCount, and
 * 12 bits cycleOffset, in host byte order.  Cf. the Cycle Time register
 * per IEEE 1394 or Isochronous Cycle Timer register per OHCI-1394.
 */
struct fw_cdev_get_cycle_timer2 {
	__s64 tv_sec;
	__s32 tv_nsec;
	__s32 clk_id;
	__u32 cycle_timer;
};

/**
 * struct fw_cdev_allocate_iso_resource - (De)allocate a channel or bandwidth
 * @closure:	Passed back to userspace in corresponding iso resource events
 * @channels:	Isochronous channels of which one is to be (de)allocated
 * @bandwidth:	Isochronous bandwidth units to be (de)allocated
 * @handle:	Handle to the allocation, written by the kernel (only valid in
 *		case of %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE ioctls)
 *
 * The %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE ioctl initiates allocation of an
 * isochronous channel and/or of isochronous bandwidth at the isochronous
 * resource manager (IRM).  Only one of the channels specified in @channels is
 * allocated.  An %FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED is sent after
 * communication with the IRM, indicating success or failure in the event data.
 * The kernel will automatically reallocate the resources after bus resets.
 * Should a reallocation fail, an %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event
 * will be sent.  The kernel will also automatically deallocate the resources
 * when the file descriptor is closed.
 *
 * The %FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE ioctl can be used to initiate
 * deallocation of resources which were allocated as described above.
 * An %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event concludes this operation.
 *
 * The %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE ioctl is a variant of allocation
 * without automatic re- or deallocation.
 * An %FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED event concludes this operation,
 * indicating success or failure in its data.
 *
 * The %FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE_ONCE ioctl works like
 * %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE except that resources are freed
 * instead of allocated.
 * An %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event concludes this operation.
 *
 * To summarize, %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE allocates iso resources
 * for the lifetime of the fd or @handle.
 * In contrast, %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE allocates iso resources
 * for the duration of a bus generation.
 *
 * @channels is a host-endian bitfield with the least significant bit
 * representing channel 0 and the most significant bit representing channel 63:
 * 1ULL << c for each channel c that is a candidate for (de)allocation.
 *
 * @bandwidth is expressed in bandwidth allocation units, i.e. the time to send
 * one quadlet of data (payload or header data) at speed S1600.
 */
struct fw_cdev_allocate_iso_resource {
	__u64 closure;
	__u64 channels;
	__u32 bandwidth;
	__u32 handle;
};

/**
 * struct fw_cdev_send_stream_packet - send an asynchronous stream packet
 * @length:	Length of outgoing payload, in bytes
 * @tag:	Data format tag
 * @channel:	Isochronous channel to transmit to
 * @sy:		Synchronization code
 * @closure:	Passed back to userspace in the response event
 * @data:	Userspace pointer to payload
 * @generation:	The bus generation where packet is valid
 * @speed:	Speed to transmit at
 *
 * The %FW_CDEV_IOC_SEND_STREAM_PACKET ioctl sends an asynchronous stream packet
 * to every device which is listening to the specified channel.  The kernel
 * writes an &fw_cdev_event_response event which indicates success or failure of
 * the transmission.
 */
struct fw_cdev_send_stream_packet {
	__u32 length;
	__u32 tag;
	__u32 channel;
	__u32 sy;
	__u64 closure;
	__u64 data;
	__u32 generation;
	__u32 speed;
};

/**
 * struct fw_cdev_send_phy_packet - send a PHY packet
 * @closure:	Passed back to userspace in the PHY-packet-sent event
 * @data:	First and second quadlet of the PHY packet
 * @generation:	The bus generation where packet is valid
 *
 * The %FW_CDEV_IOC_SEND_PHY_PACKET ioctl sends a PHY packet to all nodes
 * on the same card as this device.  After transmission, an
 * %FW_CDEV_EVENT_PHY_PACKET_SENT event is generated.
 *
 * The payload @data[] shall be specified in host byte order.  Usually,
 * @data[1] needs to be the bitwise inverse of @data[0].  VersaPHY packets
 * are an exception to this rule.
 *
 * The ioctl is only permitted on device files which represent a local node.
 */
struct fw_cdev_send_phy_packet {
	__u64 closure;
	__u32 data[2];
	__u32 generation;
};

/**
 * struct fw_cdev_receive_phy_packets - start reception of PHY packets
 * @closure: Passed back to userspace in phy packet events
 *
 * This ioctl activates issuing of %FW_CDEV_EVENT_PHY_PACKET_RECEIVED due to
 * incoming PHY packets from any node on the same bus as the device.
 *
 * The ioctl is only permitted on device files which represent a local node.
 */
struct fw_cdev_receive_phy_packets {
	__u64 closure;
};

#define FW_CDEV_VERSION 3 /* Meaningless legacy macro; don't use it. */

#endif /* _LINUX_FIREWIRE_CDEV_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * IEEE 1394 constants.
 *
 * Copyright (C) 2005-2007  Kristian Hoegsberg <krh@bitplanet.net>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef _LINUX_FIREWIRE_CONSTANTS_H
#define _LINUX_FIREWIRE_CONSTANTS_H

#define TCODE_WRITE_QUADLET_REQUEST	0x0
#define TCODE_WRITE_BLOCK_REQUEST	0x1
#define TCODE_WRITE_RESPONSE		0x2
#define TCODE_READ_QUADLET_REQUEST	0x4
#define TCODE_READ_BLOCK_REQUEST	0x5
#define TCODE_READ_QUADLET_RESPONSE	0x6
#define TCODE_READ_BLOCK_RESPONSE	0x7
#define TCODE_CYCLE_START		0x8
#define TCODE_LOCK_REQUEST		0x9
#define TCODE_STREAM_DATA		0xa
#define TCODE_LOCK_RESPONSE		0xb

#define EXTCODE_MASK_SWAP		0x1
#define EXTCODE_COMPARE_SWAP		0x2
#define EXTCODE_FETCH_ADD		0x3
#define EXTCODE_LITTLE_ADD		0x4
#define EXTCODE_BOUNDED_ADD		0x5
#define EXTCODE_WRAP_ADD		0x6
#define EXTCODE_VENDOR_DEPENDENT	0x7

/* Linux firewire-core (Juju) specific tcodes */
#define TCODE_LOCK_MASK_SWAP		(0x10 | EXTCODE_MASK_SWAP)
#define TCODE_LOCK_COMPARE_SWAP		(0x10 | EXTCODE_COMPARE_SWAP)
#define TCODE_LOCK_FETCH_ADD		(0x10 | EXTCODE_FETCH_ADD)
#define TCODE_LOCK_LITTLE_ADD		(0x10 | EXTCODE_LITTLE_ADD)
#define TCODE_LOCK_BOUNDED_ADD		(0x10 | EXTCODE_BOUNDED_ADD)
#define TCODE_LOCK_WRAP_ADD		(0x10 | EXTCODE_WRAP_ADD)
#define TCODE_LOCK_VENDOR_DEPENDENT	(0x10 | EXTCODE_VENDOR_DEPENDENT)

#define RCODE_COMPLETE			0x0
#define RCODE_CONFLICT_ERROR		0x4
#define RCODE_DATA_ERROR		0x5
#define RCODE_TYPE_ERROR		0x6
#define RCODE_ADDRESS_ERROR		0x7

/* Linux firewire-core (Juju) specific rcodes */
#define RCODE_SEND_ERROR		0x10
#define RCODE_CANCELLED			0x11
#define RCODE_BUSY			0x12
#define RCODE_GENERATION		0x13
#define RCODE_NO_ACK			0x14

#define SCODE_100			0x0
#define SCODE_200			0x1
#define SCODE_400			0x2
#define SCODE_800			0x3
#define SCODE_1600			0x4
#define SCODE_3200			0x5
#define SCODE_BETA			0x3

#define ACK_COMPLETE			0x1
#define ACK_PENDING			0x2
#define ACK_BUSY_X			0x4
#define ACK_BUSY_A			0x5
#define ACK_BUSY_B			0x6
#define ACK_DATA_ERROR			0xd
#define ACK_TYPE_ERROR			0xe

#define RETRY_1				0x00
#define RETRY_X				0x01
#define RETRY_A				0x02
#define RETRY_B				0x03

#endif /* _LINUX_FIREWIRE_CONSTANTS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Copyright (C) 2002-2003  David McCullough <davidm@snapgear.com>
 * Copyright (C) 1998       Kenneth Albanowski <kjahds@kjahds.com>
 *                          The Silver Hammer Group, Ltd.
 *
 * This file provides the definitions and structures needed to
 * support uClinux flat-format executables.
 */

#ifndef _LINUX_FLAT_H
#define _LINUX_FLAT_H


#define	FLAT_VERSION			0x00000004L

#ifdef CONFIG_BINFMT_SHARED_FLAT
#define	MAX_SHARED_LIBS			(4)
#else
#define	MAX_SHARED_LIBS			(1)
#endif

/*
 * To make everything easier to port and manage cross platform
 * development,  all fields are in network byte order.
 */

struct flat_hdr {
	char magic[4];
	unsigned long rev;          /* version (as above) */
	unsigned long entry;        /* Offset of first executable instruction
	                               with text segment from beginning of file */
	unsigned long data_start;   /* Offset of data segment from beginning of
	                               file */
	unsigned long data_end;     /* Offset of end of data segment
	                               from beginning of file */
	unsigned long bss_end;      /* Offset of end of bss segment from beginning
	                               of file */

	/* (It is assumed that data_end through bss_end forms the bss segment.) */

	unsigned long stack_size;   /* Size of stack, in bytes */
	unsigned long reloc_start;  /* Offset of relocation records from
	                               beginning of file */
	unsigned long reloc_count;  /* Number of relocation records */
	unsigned long flags;       
	unsigned long build_date;   /* When the program/library was built */
	unsigned long filler[5];    /* Reservered, set to zero */
};

#define FLAT_FLAG_RAM    0x0001 /* load program entirely into RAM */
#define FLAT_FLAG_GOTPIC 0x0002 /* program is PIC with GOT */
#define FLAT_FLAG_GZIP   0x0004 /* all but the header is compressed */
#define FLAT_FLAG_GZDATA 0x0008 /* only data/relocs are compressed (for XIP) */
#define FLAT_FLAG_KTRACE 0x0010 /* output useful kernel trace for debugging */



#endif /* _LINUX_FLAT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 *  Copyright (c) 1999-2002 Vojtech Pavlik
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 */
#ifndef _GAMEPORT_H
#define _GAMEPORT_H



#define GAMEPORT_MODE_DISABLED		0
#define GAMEPORT_MODE_RAW		1
#define GAMEPORT_MODE_COOKED		2

#define GAMEPORT_ID_VENDOR_ANALOG	0x0001
#define GAMEPORT_ID_VENDOR_MADCATZ	0x0002
#define GAMEPORT_ID_VENDOR_LOGITECH	0x0003
#define GAMEPORT_ID_VENDOR_CREATIVE	0x0004
#define GAMEPORT_ID_VENDOR_GENIUS	0x0005
#define GAMEPORT_ID_VENDOR_INTERACT	0x0006
#define GAMEPORT_ID_VENDOR_MICROSOFT	0x0007
#define GAMEPORT_ID_VENDOR_THRUSTMASTER	0x0008
#define GAMEPORT_ID_VENDOR_GRAVIS	0x0009
#define GAMEPORT_ID_VENDOR_GUILLEMOT	0x000a

#endif /* _GAMEPORT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef _LINUX_FS_H
#define _LINUX_FS_H

/*
 * This file has definitions for some important file table
 * structures etc.
 */

#include <linux/limits.h>
#include <linux/ioctl.h>
#include <linux/types.h>

/*
 * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
 * the file limit at runtime and only root can increase the per-process
 * nr_file rlimit, so it's safe to set up a ridiculously high absolute
 * upper limit on files-per-process.
 *
 * Some programs (notably those using select()) may have to be 
 * recompiled to take full advantage of the new limits..  
 */

/* Fixed constants first: */
#undef NR_OPEN
#define INR_OPEN_CUR 1024	/* Initial setting for nfile rlimits */
#define INR_OPEN_MAX 4096	/* Hard limit for nfile rlimits */

#define BLOCK_SIZE_BITS 10
#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)

#define SEEK_SET	0	/* seek relative to beginning of file */
#define SEEK_CUR	1	/* seek relative to current file position */
#define SEEK_END	2	/* seek relative to end of file */
#define SEEK_DATA	3	/* seek to the next data */
#define SEEK_HOLE	4	/* seek to the next hole */
#define SEEK_MAX	SEEK_HOLE

#define RENAME_NOREPLACE	(1 << 0)	/* Don't overwrite target */
#define RENAME_EXCHANGE		(1 << 1)	/* Exchange source and dest */

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

/* And dynamically-tunable limits and defaults: */
struct files_stat_struct {
	unsigned long nr_files;		/* read only */
	unsigned long nr_free_files;	/* read only */
	unsigned long max_files;		/* tunable */
};

struct inodes_stat_t {
	long nr_inodes;
	long nr_unused;
	long dummy[5];		/* padding for sysctl ABI compatibility */
};


#define NR_FILE  8192	/* this can well be larger on a larger system */


/*
 * These are the fs-independent mount-flags: up to 32 flags are supported
 */
#define MS_RDONLY	 1	/* Mount read-only */
#define MS_NOSUID	 2	/* Ignore suid and sgid bits */
#define MS_NODEV	 4	/* Disallow access to device special files */
#define MS_NOEXEC	 8	/* Disallow program execution */
#define MS_SYNCHRONOUS	16	/* Writes are synced at once */
#define MS_REMOUNT	32	/* Alter flags of a mounted FS */
#define MS_MANDLOCK	64	/* Allow mandatory locks on an FS */
#define MS_DIRSYNC	128	/* Directory modifications are synchronous */
#define MS_NOATIME	1024	/* Do not update access times. */
#define MS_NODIRATIME	2048	/* Do not update directory access times */
#define MS_BIND		4096
#define MS_MOVE		8192
#define MS_REC		16384
#define MS_VERBOSE	32768	/* War is peace. Verbosity is silence.
				   MS_VERBOSE is deprecated. */
#define MS_SILENT	32768
#define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
#define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
#define MS_PRIVATE	(1<<18)	/* change to private */
#define MS_SLAVE	(1<<19)	/* change to slave */
#define MS_SHARED	(1<<20)	/* change to shared */
#define MS_RELATIME	(1<<21)	/* Update atime relative to mtime/ctime. */
#define MS_KERNMOUNT	(1<<22) /* this is a kern_mount call */
#define MS_I_VERSION	(1<<23) /* Update inode I_version field */
#define MS_STRICTATIME	(1<<24) /* Always perform atime updates */

/* These sb flags are internal to the kernel */
#define MS_NOSEC	(1<<28)
#define MS_BORN		(1<<29)
#define MS_ACTIVE	(1<<30)
#define MS_NOUSER	(1<<31)

/*
 * Superblock flags that can be altered by MS_REMOUNT
 */
#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)

/*
 * Old magic mount flag and mask
 */
#define MS_MGC_VAL 0xC0ED0000
#define MS_MGC_MSK 0xffff0000

/* the read-only stuff doesn't really belong here, but any other place is
   probably as bad and I don't want to create yet another include file. */

#define BLKROSET   _IO(0x12,93)	/* set device read-only (0 = read-write) */
#define BLKROGET   _IO(0x12,94)	/* get read-only status (0 = read_write) */
#define BLKRRPART  _IO(0x12,95)	/* re-read partition table */
#define BLKGETSIZE _IO(0x12,96)	/* return device size /512 (long *arg) */
#define BLKFLSBUF  _IO(0x12,97)	/* flush buffer cache */
#define BLKRASET   _IO(0x12,98)	/* set read ahead for block device */
#define BLKRAGET   _IO(0x12,99)	/* get current read ahead setting */
#define BLKFRASET  _IO(0x12,100)/* set filesystem (mm/filemap.c) read-ahead */
#define BLKFRAGET  _IO(0x12,101)/* get filesystem (mm/filemap.c) read-ahead */
#define BLKSECTSET _IO(0x12,102)/* set max sectors per request (ll_rw_blk.c) */
#define BLKSECTGET _IO(0x12,103)/* get max sectors per request (ll_rw_blk.c) */
#define BLKSSZGET  _IO(0x12,104)/* get block device sector size */
#if 0
#define BLKPG      _IO(0x12,105)/* See blkpg.h */

/* Some people are morons.  Do not use sizeof! */

#define BLKELVGET  _IOR(0x12,106,size_t)/* elevator get */
#define BLKELVSET  _IOW(0x12,107,size_t)/* elevator set */
/* This was here just to show that the number is taken -
   probably all these _IO(0x12,*) ioctls should be moved to blkpg.h. */
#endif
/* A jump here: 108-111 have been used for various private purposes. */
#define BLKBSZGET  _IOR(0x12,112,size_t)
#define BLKBSZSET  _IOW(0x12,113,size_t)
#define BLKGETSIZE64 _IOR(0x12,114,size_t)	/* return device size in bytes (u64 *arg) */
#define BLKTRACESETUP _IOWR(0x12,115,struct blk_user_trace_setup)
#define BLKTRACESTART _IO(0x12,116)
#define BLKTRACESTOP _IO(0x12,117)
#define BLKTRACETEARDOWN _IO(0x12,118)
#define BLKDISCARD _IO(0x12,119)
#define BLKIOMIN _IO(0x12,120)
#define BLKIOOPT _IO(0x12,121)
#define BLKALIGNOFF _IO(0x12,122)
#define BLKPBSZGET _IO(0x12,123)
#define BLKDISCARDZEROES _IO(0x12,124)
#define BLKSECDISCARD _IO(0x12,125)
#define BLKROTATIONAL _IO(0x12,126)
#define BLKZEROOUT _IO(0x12,127)

#define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
#define FIBMAP	   _IO(0x00,1)	/* bmap access */
#define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */
#define FIFREEZE	_IOWR('X', 119, int)	/* Freeze */
#define FITHAW		_IOWR('X', 120, int)	/* Thaw */
#define FITRIM		_IOWR('X', 121, struct fstrim_range)	/* Trim */

#define	FS_IOC_GETFLAGS			_IOR('f', 1, long)
#define	FS_IOC_SETFLAGS			_IOW('f', 2, long)
#define	FS_IOC_GETVERSION		_IOR('v', 1, long)
#define	FS_IOC_SETVERSION		_IOW('v', 2, long)
#define FS_IOC_FIEMAP			_IOWR('f', 11, struct fiemap)
#define FS_IOC32_GETFLAGS		_IOR('f', 1, int)
#define FS_IOC32_SETFLAGS		_IOW('f', 2, int)
#define FS_IOC32_GETVERSION		_IOR('v', 1, int)
#define FS_IOC32_SETVERSION		_IOW('v', 2, int)

/*
 * Inode flags (FS_IOC_GETFLAGS / FS_IOC_SETFLAGS)
 */
#define	FS_SECRM_FL			0x00000001 /* Secure deletion */
#define	FS_UNRM_FL			0x00000002 /* Undelete */
#define	FS_COMPR_FL			0x00000004 /* Compress file */
#define FS_SYNC_FL			0x00000008 /* Synchronous updates */
#define FS_IMMUTABLE_FL			0x00000010 /* Immutable file */
#define FS_APPEND_FL			0x00000020 /* writes to file may only append */
#define FS_NODUMP_FL			0x00000040 /* do not dump file */
#define FS_NOATIME_FL			0x00000080 /* do not update atime */
/* Reserved for compression usage... */
#define FS_DIRTY_FL			0x00000100
#define FS_COMPRBLK_FL			0x00000200 /* One or more compressed clusters */
#define FS_NOCOMP_FL			0x00000400 /* Don't compress */
#define FS_ECOMPR_FL			0x00000800 /* Compression error */
/* End compression flags --- maybe not all used */
#define FS_BTREE_FL			0x00001000 /* btree format dir */
#define FS_INDEX_FL			0x00001000 /* hash-indexed directory */
#define FS_IMAGIC_FL			0x00002000 /* AFS directory */
#define FS_JOURNAL_DATA_FL		0x00004000 /* Reserved for ext3 */
#define FS_NOTAIL_FL			0x00008000 /* file tail should not be merged */
#define FS_DIRSYNC_FL			0x00010000 /* dirsync behaviour (directories only) */
#define FS_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
#define FS_EXTENT_FL			0x00080000 /* Extents */
#define FS_DIRECTIO_FL			0x00100000 /* Use direct i/o */
#define FS_NOCOW_FL			0x00800000 /* Do not cow file */
#define FS_RESERVED_FL			0x80000000 /* reserved for ext2 lib */

#define FS_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */
#define FS_FL_USER_MODIFIABLE		0x000380FF /* User modifiable flags */


#define SYNC_FILE_RANGE_WAIT_BEFORE	1
#define SYNC_FILE_RANGE_WRITE		2
#define SYNC_FILE_RANGE_WAIT_AFTER	4

#endif /* _LINUX_FS_H */
                                      /*
 * Freescale hypervisor ioctl and kernel interface
 *
 * Copyright (C) 2008-2011 Freescale Semiconductor, Inc.
 * Author: Timur Tabi <timur@freescale.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Freescale Semiconductor nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 *
 * ALTERNATIVELY, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") as published by the Free Software
 * Foundation, either version 2 of that License or (at your option) any
 * later version.
 *
 * This software is provided by Freescale Semiconductor "as is" and any
 * express or implied warranties, including, but not limited to, the implied
 * warranties of merchantability and fitness for a particular purpose are
 * disclaimed. In no event shall Freescale Semiconductor be liable for any
 * direct, indirect, incidental, special, exemplary, or consequential damages
 * (including, but not limited to, procurement of substitute goods or services;
 * loss of use, data, or profits; or business interruption) however caused and
 * on any theory of liability, whether in contract, strict liability, or tort
 * (including negligence or otherwise) arising in any way out of the use of this
 * software, even if advised of the possibility of such damage.
 *
 * This file is used by the Freescale hypervisor management driver.  It can
 * also be included by applications that need to communicate with the driver
 * via the ioctl interface.
 */

#ifndef FSL_HYPERVISOR_H
#define FSL_HYPERVISOR_H

#include <linux/types.h>

/**
 * struct fsl_hv_ioctl_restart - restart a partition
 * @ret: return error code from the hypervisor
 * @partition: the ID of the partition to restart, or -1 for the
 *             calling partition
 *
 * Used by FSL_HV_IOCTL_PARTITION_RESTART
 */
struct fsl_hv_ioctl_restart {
	__u32 ret;
	__u32 partition;
};

/**
 * struct fsl_hv_ioctl_status - get a partition's status
 * @ret: return error code from the hypervisor
 * @partition: the ID of the partition to query, or -1 for the
 *             calling partition
 * @status: The returned status of the partition
 *
 * Used by FSL_HV_IOCTL_PARTITION_GET_STATUS
 *
 * Values of 'status':
 *    0 = Stopped
 *    1 = Running
 *    2 = Starting
 *    3 = Stopping
 */
struct fsl_hv_ioctl_status {
	__u32 ret;
	__u32 partition;
	__u32 status;
};

/**
 * struct fsl_hv_ioctl_start - start a partition
 * @ret: return error code from the hypervisor
 * @partition: the ID of the partition to control
 * @entry_point: The offset within the guest IMA to start execution
 * @load: If non-zero, reload the partition's images before starting
 *
 * Used by FSL_HV_IOCTL_PARTITION_START
 */
struct fsl_hv_ioctl_start {
	__u32 ret;
	__u32 partition;
	__u32 entry_point;
	__u32 load;
};

/**
 * struct fsl_hv_ioctl_stop - stop a partition
 * @ret: return error code from the hypervisor
 * @partition: the ID of the partition to stop, or -1 for the calling
 *             partition
 *
 * Used by FSL_HV_IOCTL_PARTITION_STOP
 */
struct fsl_hv_ioctl_stop {
	__u32 ret;
	__u32 partition;
};

/**
 * struct fsl_hv_ioctl_memcpy - copy memory between partitions
 * @ret: return error code from the hypervisor
 * @source: the partition ID of the source partition, or -1 for this
 *          partition
 * @target: the partition ID of the target partition, or -1 for this
 *          partition
 * @reserved: reserved, must be set to 0
 * @local_addr: user-space virtual address of a buffer in the local
 *              partition
 * @remote_addr: guest physical address of a buffer in the
 *           remote partition
 * @count: the number of bytes to copy.  Both the local and remote
 *         buffers must be at least 'count' bytes long
 *
 * Used by FSL_HV_IOCTL_MEMCPY
 *
 * The 'local' partition is the partition that calls this ioctl.  The
 * 'remote' partition is a different partition.  The data is copied from
 * the 'source' paritition' to the 'target' partition.
 *
 * The buffer in the remote partition must be guest physically
 * contiguous.
 *
 * This ioctl does not support copying memory between two remote
 * partitions or within the same partition, so either 'source' or
 * 'target' (but not both) must be -1.  In other words, either
 *
 *      source == local and target == remote
 * or
 *      source == remote and target == local
 */
struct fsl_hv_ioctl_memcpy {
	__u32 ret;
	__u32 source;
	__u32 target;
	__u32 reserved;	/* padding to ensure local_vaddr is aligned */
	__u64 local_vaddr;
	__u64 remote_paddr;
	__u64 count;
};

/**
 * struct fsl_hv_ioctl_doorbell - ring a doorbell
 * @ret: return error code from the hypervisor
 * @doorbell: the handle of the doorbell to ring doorbell
 *
 * Used by FSL_HV_IOCTL_DOORBELL
 */
struct fsl_hv_ioctl_doorbell {
	__u32 ret;
	__u32 doorbell;
};

/**
 * struct fsl_hv_ioctl_prop - get/set a device tree property
 * @ret: return error code from the hypervisor
 * @handle: handle of partition whose tree to access
 * @path: virtual address of path name of node to access
 * @propname: virtual address of name of property to access
 * @propval: virtual address of property data buffer
 * @proplen: Size of property data buffer
 * @reserved: reserved, must be set to 0
 *
 * Used by FSL_HV_IOCTL_DOORBELL
 */
struct fsl_hv_ioctl_prop {
	__u32 ret;
	__u32 handle;
	__u64 path;
	__u64 propname;
	__u64 propval;
	__u32 proplen;
	__u32 reserved;	/* padding to ensure structure is aligned */
};

/* The ioctl type, documented in ioctl-number.txt */
#define FSL_HV_IOCTL_TYPE	0xAF

/* Restart another partition */
#define FSL_HV_IOCTL_PARTITION_RESTART \
	_IOWR(FSL_HV_IOCTL_TYPE, 1, struct fsl_hv_ioctl_restart)

/* Get a partition's status */
#define FSL_HV_IOCTL_PARTITION_GET_STATUS \
	_IOWR(FSL_HV_IOCTL_TYPE, 2, struct fsl_hv_ioctl_status)

/* Boot another partition */
#define FSL_HV_IOCTL_PARTITION_START \
	_IOWR(FSL_HV_IOCTL_TYPE, 3, struct fsl_hv_ioctl_start)

/* Stop this or another partition */
#define FSL_HV_IOCTL_PARTITION_STOP \
	_IOWR(FSL_HV_IOCTL_TYPE, 4, struct fsl_hv_ioctl_stop)

/* Copy data from one partition to another */
#define FSL_HV_IOCTL_MEMCPY \
	_IOWR(FSL_HV_IOCTL_TYPE, 5, struct fsl_hv_ioctl_memcpy)

/* Ring a doorbell */
#define FSL_HV_IOCTL_DOORBELL \
	_IOWR(FSL_HV_IOCTL_TYPE, 6, struct fsl_hv_ioctl_doorbell)

/* Get a property from another guest's device tree */
#define FSL_HV_IOCTL_GETPROP \
	_IOWR(FSL_HV_IOCTL_TYPE, 7, struct fsl_hv_ioctl_prop)

/* Set a property in another guest's device tree */
#define FSL_HV_IOCTL_SETPROP \
	_IOWR(FSL_HV_IOCTL_TYPE, 8, struct fsl_hv_ioctl_prop)


#endif /* FSL_HYPERVISOR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
    This file defines the kernel interface of FUSE
    Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>

    This program can be distributed under the terms of the GNU GPL.
    See the file COPYING.

    This -- and only this -- header file may also be distributed under
    the terms of the BSD Licence as follows:

    Copyright (C) 2001-2007 Miklos Szeredi. All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
    OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
    OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.
*/

/*
 * This file defines the kernel interface of FUSE
 *
 * Protocol changelog:
 *
 * 7.9:
 *  - new fuse_getattr_in input argument of GETATTR
 *  - add lk_flags in fuse_lk_in
 *  - add lock_owner field to fuse_setattr_in, fuse_read_in and fuse_write_in
 *  - add blksize field to fuse_attr
 *  - add file flags field to fuse_read_in and fuse_write_in
 *
 * 7.10
 *  - add nonseekable open flag
 *
 * 7.11
 *  - add IOCTL message
 *  - add unsolicited notification support
 *  - add POLL message and NOTIFY_POLL notification
 *
 * 7.12
 *  - add umask flag to input argument of open, mknod and mkdir
 *  - add notification messages for invalidation of inodes and
 *    directory entries
 *
 * 7.13
 *  - make max number of background requests and congestion threshold
 *    tunables
 *
 * 7.14
 *  - add splice support to fuse device
 *
 * 7.15
 *  - add store notify
 *  - add retrieve notify
 *
 * 7.16
 *  - add BATCH_FORGET request
 *  - FUSE_IOCTL_UNRESTRICTED shall now return with array of 'struct
 *    fuse_ioctl_iovec' instead of ambiguous 'struct iovec'
 *  - add FUSE_IOCTL_32BIT flag
 *
 * 7.17
 *  - add FUSE_FLOCK_LOCKS and FUSE_RELEASE_FLOCK_UNLOCK
 *
 * 7.18
 *  - add FUSE_IOCTL_DIR flag
 *  - add FUSE_NOTIFY_DELETE
 *
 * 7.19
 *  - add FUSE_FALLOCATE
 *
 * 7.20
 *  - add FUSE_AUTO_INVAL_DATA
 *
 * 7.21
 *  - add FUSE_READDIRPLUS
 *  - send the requested events in POLL request
 *
 * 7.22
 *  - add FUSE_ASYNC_DIO
 *
 * 7.23
 *  - add FUSE_WRITEBACK_CACHE
 *  - add time_gran to fuse_init_out
 *  - add reserved space to fuse_init_out
 *  - add FATTR_CTIME
 *  - add ctime and ctimensec to fuse_setattr_in
 *  - add FUSE_RENAME2 request
 *  - add FUSE_NO_OPEN_SUPPORT flag
 */

#ifndef _LINUX_FUSE_H
#define _LINUX_FUSE_H

#include <stdint.h>

/*
 * Version negotiation:
 *
 * Both the kernel and userspace send the version they support in the
 * INIT request and reply respectively.
 *
 * If the major versions match then both shall use the smallest
 * of the two minor versions for communication.
 *
 * If the kernel supports a larger major version, then userspace shall
 * reply with the major version it supports, ignore the rest of the
 * INIT message and expect a new INIT message from the kernel with a
 * matching major version.
 *
 * If the library supports a larger major version, then it shall fall
 * back to the major protocol version sent by the kernel for
 * communication and reply with that major version (and an arbitrary
 * supported minor version).
 */

/** Version number of this interface */
#define FUSE_KERNEL_VERSION 7

/** Minor version number of this interface */
#define FUSE_KERNEL_MINOR_VERSION 23

/** The node ID of the root inode */
#define FUSE_ROOT_ID 1

/* Make sure all structures are padded to 64bit boundary, so 32bit
   userspace works under 64bit kernels */

struct fuse_attr {
	uint64_t	ino;
	uint64_t	size;
	uint64_t	blocks;
	uint64_t	atime;
	uint64_t	mtime;
	uint64_t	ctime;
	uint32_t	atimensec;
	uint32_t	mtimensec;
	uint32_t	ctimensec;
	uint32_t	mode;
	uint32_t	nlink;
	uint32_t	uid;
	uint32_t	gid;
	uint32_t	rdev;
	uint32_t	blksize;
	uint32_t	padding;
};

struct fuse_kstatfs {
	uint64_t	blocks;
	uint64_t	bfree;
	uint64_t	bavail;
	uint64_t	files;
	uint64_t	ffree;
	uint32_t	bsize;
	uint32_t	namelen;
	uint32_t	frsize;
	uint32_t	padding;
	uint32_t	spare[6];
};

struct fuse_file_lock {
	uint64_t	start;
	uint64_t	end;
	uint32_t	type;
	uint32_t	pid; /* tgid */
};

/**
 * Bitmasks for fuse_setattr_in.valid
 */
#define FATTR_MODE	(1 << 0)
#define FATTR_UID	(1 << 1)
#define FATTR_GID	(1 << 2)
#define FATTR_SIZE	(1 << 3)
#define FATTR_ATIME	(1 << 4)
#define FATTR_MTIME	(1 << 5)
#define FATTR_FH	(1 << 6)
#define FATTR_ATIME_NOW	(1 << 7)
#define FATTR_MTIME_NOW	(1 << 8)
#define FATTR_LOCKOWNER	(1 << 9)
#define FATTR_CTIME	(1 << 10)

/**
 * Flags returned by the OPEN request
 *
 * FOPEN_DIRECT_IO: bypass page cache for this open file
 * FOPEN_KEEP_CACHE: don't invalidate the data cache on open
 * FOPEN_NONSEEKABLE: the file is not seekable
 */
#define FOPEN_DIRECT_IO		(1 << 0)
#define FOPEN_KEEP_CACHE	(1 << 1)
#define FOPEN_NONSEEKABLE	(1 << 2)

/**
 * INIT request/reply flags
 *
 * FUSE_ASYNC_READ: asynchronous read requests
 * FUSE_POSIX_LOCKS: remote locking for POSIX file locks
 * FUSE_FILE_OPS: kernel sends file handle for fstat, etc... (not yet supported)
 * FUSE_ATOMIC_O_TRUNC: handles the O_TRUNC open flag in the filesystem
 * FUSE_EXPORT_SUPPORT: filesystem handles lookups of "." and ".."
 * FUSE_BIG_WRITES: filesystem can handle write size larger than 4kB
 * FUSE_DONT_MASK: don't apply umask to file mode on create operations
 * FUSE_SPLICE_WRITE: kernel supports splice write on the device
 * FUSE_SPLICE_MOVE: kernel supports splice move on the device
 * FUSE_SPLICE_READ: kernel supports splice read on the device
 * FUSE_FLOCK_LOCKS: remote locking for BSD style file locks
 * FUSE_HAS_IOCTL_DIR: kernel supports ioctl on directories
 * FUSE_AUTO_INVAL_DATA: automatically invalidate cached pages
 * FUSE_DO_READDIRPLUS: do READDIRPLUS (READDIR+LOOKUP in one)
 * FUSE_READDIRPLUS_AUTO: adaptive readdirplus
 * FUSE_ASYNC_DIO: asynchronous direct I/O submission
 * FUSE_WRITEBACK_CACHE: use writeback cache for buffered writes
 * FUSE_NO_OPEN_SUPPORT: kernel supports zero-message opens
 */
#define FUSE_ASYNC_READ		(1 << 0)
#define FUSE_POSIX_LOCKS	(1 << 1)
#define FUSE_FILE_OPS		(1 << 2)
#define FUSE_ATOMIC_O_TRUNC	(1 << 3)
#define FUSE_EXPORT_SUPPORT	(1 << 4)
#define FUSE_BIG_WRITES		(1 << 5)
#define FUSE_DONT_MASK		(1 << 6)
#define FUSE_SPLICE_WRITE	(1 << 7)
#define FUSE_SPLICE_MOVE	(1 << 8)
#define FUSE_SPLICE_READ	(1 << 9)
#define FUSE_FLOCK_LOCKS	(1 << 10)
#define FUSE_HAS_IOCTL_DIR	(1 << 11)
#define FUSE_AUTO_INVAL_DATA	(1 << 12)
#define FUSE_DO_READDIRPLUS	(1 << 13)
#define FUSE_READDIRPLUS_AUTO	(1 << 14)
#define FUSE_ASYNC_DIO		(1 << 15)
#define FUSE_WRITEBACK_CACHE	(1 << 16)
#define FUSE_NO_OPEN_SUPPORT	(1 << 17)

/**
 * CUSE INIT request/reply flags
 *
 * CUSE_UNRESTRICTED_IOCTL:  use unrestricted ioctl
 */
#define CUSE_UNRESTRICTED_IOCTL	(1 << 0)

/**
 * Release flags
 */
#define FUSE_RELEASE_FLUSH	(1 << 0)
#define FUSE_RELEASE_FLOCK_UNLOCK	(1 << 1)

/**
 * Getattr flags
 */
#define FUSE_GETATTR_FH		(1 << 0)

/**
 * Lock flags
 */
#define FUSE_LK_FLOCK		(1 << 0)

/**
 * WRITE flags
 *
 * FUSE_WRITE_CACHE: delayed write from page cache, file handle is guessed
 * FUSE_WRITE_LOCKOWNER: lock_owner field is valid
 */
#define FUSE_WRITE_CACHE	(1 << 0)
#define FUSE_WRITE_LOCKOWNER	(1 << 1)

/**
 * Read flags
 */
#define FUSE_READ_LOCKOWNER	(1 << 1)

/**
 * Ioctl flags
 *
 * FUSE_IOCTL_COMPAT: 32bit compat ioctl on 64bit machine
 * FUSE_IOCTL_UNRESTRICTED: not restricted to well-formed ioctls, retry allowed
 * FUSE_IOCTL_RETRY: retry with new iovecs
 * FUSE_IOCTL_32BIT: 32bit ioctl
 * FUSE_IOCTL_DIR: is a directory
 *
 * FUSE_IOCTL_MAX_IOV: maximum of in_iovecs + out_iovecs
 */
#define FUSE_IOCTL_COMPAT	(1 << 0)
#define FUSE_IOCTL_UNRESTRICTED	(1 << 1)
#define FUSE_IOCTL_RETRY	(1 << 2)
#define FUSE_IOCTL_32BIT	(1 << 3)
#define FUSE_IOCTL_DIR		(1 << 4)

#define FUSE_IOCTL_MAX_IOV	256

/**
 * Poll flags
 *
 * FUSE_POLL_SCHEDULE_NOTIFY: request poll notify
 */
#define FUSE_POLL_SCHEDULE_NOTIFY (1 << 0)

enum fuse_opcode {
	FUSE_LOOKUP	   = 1,
	FUSE_FORGET	   = 2,  /* no reply */
	FUSE_GETATTR	   = 3,
	FUSE_SETATTR	   = 4,
	FUSE_READLINK	   = 5,
	FUSE_SYMLINK	   = 6,
	FUSE_MKNOD	   = 8,
	FUSE_MKDIR	   = 9,
	FUSE_UNLINK	   = 10,
	FUSE_RMDIR	   = 11,
	FUSE_RENAME	   = 12,
	FUSE_LINK	   = 13,
	FUSE_OPEN	   = 14,
	FUSE_READ	   = 15,
	FUSE_WRITE	   = 16,
	FUSE_STATFS	   = 17,
	FUSE_RELEASE       = 18,
	FUSE_FSYNC         = 20,
	FUSE_SETXATTR      = 21,
	FUSE_GETXATTR      = 22,
	FUSE_LISTXATTR     = 23,
	FUSE_REMOVEXATTR   = 24,
	FUSE_FLUSH         = 25,
	FUSE_INIT          = 26,
	FUSE_OPENDIR       = 27,
	FUSE_READDIR       = 28,
	FUSE_RELEASEDIR    = 29,
	FUSE_FSYNCDIR      = 30,
	FUSE_GETLK         = 31,
	FUSE_SETLK         = 32,
	FUSE_SETLKW        = 33,
	FUSE_ACCESS        = 34,
	FUSE_CREATE        = 35,
	FUSE_INTERRUPT     = 36,
	FUSE_BMAP          = 37,
	FUSE_DESTROY       = 38,
	FUSE_IOCTL         = 39,
	FUSE_POLL          = 40,
	FUSE_NOTIFY_REPLY  = 41,
	FUSE_BATCH_FORGET  = 42,
	FUSE_FALLOCATE     = 43,
	FUSE_READDIRPLUS   = 44,
	FUSE_RENAME2       = 45,

	/* CUSE specific operations */
	CUSE_INIT          = 4096,
};

enum fuse_notify_code {
	FUSE_NOTIFY_POLL   = 1,
	FUSE_NOTIFY_INVAL_INODE = 2,
	FUSE_NOTIFY_INVAL_ENTRY = 3,
	FUSE_NOTIFY_STORE = 4,
	FUSE_NOTIFY_RETRIEVE = 5,
	FUSE_NOTIFY_DELETE = 6,
	FUSE_NOTIFY_CODE_MAX,
};

/* The read buffer is required to be at least 8k, but may be much larger */
#define FUSE_MIN_READ_BUFFER 8192

#define FUSE_COMPAT_ENTRY_OUT_SIZE 120

struct fuse_entry_out {
	uint64_t	nodeid;		/* Inode ID */
	uint64_t	generation;	/* Inode generation: nodeid:gen must
					   be unique for the fs's lifetime */
	uint64_t	entry_valid;	/* Cache timeout for the name */
	uint64_t	attr_valid;	/* Cache timeout for the attributes */
	uint32_t	entry_valid_nsec;
	uint32_t	attr_valid_nsec;
	struct fuse_attr attr;
};

struct fuse_forget_in {
	uint64_t	nlookup;
};

struct fuse_forget_one {
	uint64_t	nodeid;
	uint64_t	nlookup;
};

struct fuse_batch_forget_in {
	uint32_t	count;
	uint32_t	dummy;
};

struct fuse_getattr_in {
	uint32_t	getattr_flags;
	uint32_t	dummy;
	uint64_t	fh;
};

#define FUSE_COMPAT_ATTR_OUT_SIZE 96

struct fuse_attr_out {
	uint64_t	attr_valid;	/* Cache timeout for the attributes */
	uint32_t	attr_valid_nsec;
	uint32_t	dummy;
	struct fuse_attr attr;
};

#define FUSE_COMPAT_MKNOD_IN_SIZE 8

struct fuse_mknod_in {
	uint32_t	mode;
	uint32_t	rdev;
	uint32_t	umask;
	uint32_t	padding;
};

struct fuse_mkdir_in {
	uint32_t	mode;
	uint32_t	umask;
};

struct fuse_rename_in {
	uint64_t	newdir;
};

struct fuse_rename2_in {
	uint64_t	newdir;
	uint32_t	flags;
	uint32_t	padding;
};

struct fuse_link_in {
	uint64_t	oldnodeid;
};

struct fuse_setattr_in {
	uint32_t	valid;
	uint32_t	padding;
	uint64_t	fh;
	uint64_t	size;
	uint64_t	lock_owner;
	uint64_t	atime;
	uint64_t	mtime;
	uint64_t	ctime;
	uint32_t	atimensec;
	uint32_t	mtimensec;
	uint32_t	ctimensec;
	uint32_t	mode;
	uint32_t	unused4;
	uint32_t	uid;
	uint32_t	gid;
	uint32_t	unused5;
};

struct fuse_open_in {
	uint32_t	flags;
	uint32_t	unused;
};

struct fuse_create_in {
	uint32_t	flags;
	uint32_t	mode;
	uint32_t	umask;
	uint32_t	padding;
};

struct fuse_open_out {
	uint64_t	fh;
	uint32_t	open_flags;
	uint32_t	padding;
};

struct fuse_release_in {
	uint64_t	fh;
	uint32_t	flags;
	uint32_t	release_flags;
	uint64_t	lock_owner;
};

struct fuse_flush_in {
	uint64_t	fh;
	uint32_t	unused;
	uint32_t	padding;
	uint64_t	lock_owner;
};

struct fuse_read_in {
	uint64_t	fh;
	uint64_t	offset;
	uint32_t	size;
	uint32_t	read_flags;
	uint64_t	lock_owner;
	uint32_t	flags;
	uint32_t	padding;
};

#define FUSE_COMPAT_WRITE_IN_SIZE 24

struct fuse_write_in {
	uint64_t	fh;
	uint64_t	offset;
	uint32_t	size;
	uint32_t	write_flags;
	uint64_t	lock_owner;
	uint32_t	flags;
	uint32_t	padding;
};

struct fuse_write_out {
	uint32_t	size;
	uint32_t	padding;
};

#define FUSE_COMPAT_STATFS_SIZE 48

struct fuse_statfs_out {
	struct fuse_kstatfs st;
};

struct fuse_fsync_in {
	uint64_t	fh;
	uint32_t	fsync_flags;
	uint32_t	padding;
};

struct fuse_setxattr_in {
	uint32_t	size;
	uint32_t	flags;
};

struct fuse_getxattr_in {
	uint32_t	size;
	uint32_t	padding;
};

struct fuse_getxattr_out {
	uint32_t	size;
	uint32_t	padding;
};

struct fuse_lk_in {
	uint64_t	fh;
	uint64_t	owner;
	struct fuse_file_lock lk;
	uint32_t	lk_flags;
	uint32_t	padding;
};

struct fuse_lk_out {
	struct fuse_file_lock lk;
};

struct fuse_access_in {
	uint32_t	mask;
	uint32_t	padding;
};

struct fuse_init_in {
	uint32_t	major;
	uint32_t	minor;
	uint32_t	max_readahead;
	uint32_t	flags;
};

#define FUSE_COMPAT_INIT_OUT_SIZE 8
#define FUSE_COMPAT_22_INIT_OUT_SIZE 24

struct fuse_init_out {
	uint32_t	major;
	uint32_t	minor;
	uint32_t	max_readahead;
	uint32_t	flags;
	uint16_t	max_background;
	uint16_t	congestion_threshold;
	uint32_t	max_write;
	uint32_t	time_gran;
	uint32_t	unused[9];
};

#define CUSE_INIT_INFO_MAX 4096

struct cuse_init_in {
	uint32_t	major;
	uint32_t	minor;
	uint32_t	unused;
	uint32_t	flags;
};

struct cuse_init_out {
	uint32_t	major;
	uint32_t	minor;
	uint32_t	unused;
	uint32_t	flags;
	uint32_t	max_read;
	uint32_t	max_write;
	uint32_t	dev_major;		/* chardev major */
	uint32_t	dev_minor;		/* chardev minor */
	uint32_t	spare[10];
};

struct fuse_interrupt_in {
	uint64_t	unique;
};

struct fuse_bmap_in {
	uint64_t	block;
	uint32_t	blocksize;
	uint32_t	padding;
};

struct fuse_bmap_out {
	uint64_t	block;
};

struct fuse_ioctl_in {
	uint64_t	fh;
	uint32_t	flags;
	uint32_t	cmd;
	uint64_t	arg;
	uint32_t	in_size;
	uint32_t	out_size;
};

struct fuse_ioctl_iovec {
	uint64_t	base;
	uint64_t	len;
};

struct fuse_ioctl_out {
	int32_t		result;
	uint32_t	flags;
	uint32_t	in_iovs;
	uint32_t	out_iovs;
};

struct fuse_poll_in {
	uint64_t	fh;
	uint64_t	kh;
	uint32_t	flags;
	uint32_t	events;
};

struct fuse_poll_out {
	uint32_t	revents;
	uint32_t	padding;
};

struct fuse_notify_poll_wakeup_out {
	uint64_t	kh;
};

struct fuse_fallocate_in {
	uint64_t	fh;
	uint64_t	offset;
	uint64_t	length;
	uint32_t	mode;
	uint32_t	padding;
};

struct fuse_in_header {
	uint32_t	len;
	uint32_t	opcode;
	uint64_t	unique;
	uint64_t	nodeid;
	uint32_t	uid;
	uint32_t	gid;
	uint32_t	pid;
	uint32_t	padding;
};

struct fuse_out_header {
	uint32_t	len;
	int32_t		error;
	uint64_t	unique;
};

struct fuse_dirent {
	uint64_t	ino;
	uint64_t	off;
	uint32_t	namelen;
	uint32_t	type;
	char name[];
};

#define FUSE_NAME_OFFSET offsetof(struct fuse_dirent, name)
#define FUSE_DIRENT_ALIGN(x) \
	(((x) + sizeof(uint64_t) - 1) & ~(sizeof(uint64_t) - 1))
#define FUSE_DIRENT_SIZE(d) \
	FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + (d)->namelen)

struct fuse_direntplus {
	struct fuse_entry_out entry_out;
	struct fuse_dirent dirent;
};

#define FUSE_NAME_OFFSET_DIRENTPLUS \
	offsetof(struct fuse_direntplus, dirent.name)
#define FUSE_DIRENTPLUS_SIZE(d) \
	FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET_DIRENTPLUS + (d)->dirent.namelen)

struct fuse_notify_inval_inode_out {
	uint64_t	ino;
	int64_t		off;
	int64_t		len;
};

struct fuse_notify_inval_entry_out {
	uint64_t	parent;
	uint32_t	namelen;
	uint32_t	padding;
};

struct fuse_notify_delete_out {
	uint64_t	parent;
	uint64_t	child;
	uint32_t	namelen;
	uint32_t	padding;
};

struct fuse_notify_store_out {
	uint64_t	nodeid;
	uint64_t	offset;
	uint32_t	size;
	uint32_t	padding;
};

struct fuse_notify_retrieve_out {
	uint64_t	notify_unique;
	uint64_t	nodeid;
	uint64_t	offset;
	uint32_t	size;
	uint32_t	padding;
};

/* Matches the size of fuse_write_in */
struct fuse_notify_retrieve_in {
	uint64_t	dummy1;
	uint64_t	offset;
	uint32_t	size;
	uint32_t	dummy2;
	uint64_t	dummy3;
	uint64_t	dummy4;
};

#endif /* _LINUX_FUSE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #ifndef __LINUX_GEN_STATS_H
#define __LINUX_GEN_STATS_H

#include <linux/types.h>

enum {
	TCA_STATS_UNSPEC,
	TCA_STATS_BASIC,
	TCA_STATS_RATE_EST,
	TCA_STATS_QUEUE,
	TCA_STATS_APP,
	TCA_STATS_RATE_EST64,
	__TCA_STATS_MAX,
};
#define TCA_STATS_MAX (__TCA_STATS_MAX - 1)

/**
 * struct gnet_stats_basic - byte/packet throughput statistics
 * @bytes: number of seen bytes
 * @packets: number of seen packets
 */
struct gnet_stats_basic {
	__u64	bytes;
	__u32	packets;
};
struct gnet_stats_basic_packed {
	__u64	bytes;
	__u32	packets;
} __attribute__ ((packed));

/**
 * struct gnet_stats_rate_est - rate estimator
 * @bps: current byte rate
 * @pps: current packet rate
 */
struct gnet_stats_rate_est {
	__u32	bps;
	__u32	pps;
};

/**
 * struct gnet_stats_rate_est64 - rate estimator
 * @bps: current byte rate
 * @pps: current packet rate
 */
struct gnet_stats_rate_est64 {
	__u64	bps;
	__u64	pps;
};

/**
 * struct gnet_stats_queue - queuing statistics
 * @qlen: queue length
 * @backlog: backlog size of queue
 * @drops: number of dropped packets
 * @requeues: number of requeues
 * @overlimits: number of enqueues over the limit
 */
struct gnet_stats_queue {
	__u32	qlen;
	__u32	backlog;
	__u32	drops;
	__u32	requeues;
	__u32	overlimits;
};

/**
 * struct gnet_estimator - rate estimator configuration
 * @interval: sampling period
 * @ewma_log: the log of measurement window weight
 */
struct gnet_estimator {
	signed char	interval;
	unsigned char	ewma_log;
};


#endif /* __LINUX_GEN_STATS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef _LINUX_FUTEX_H
#define _LINUX_FUTEX_H


#include <linux/types.h>

/* Second argument to futex syscall */


#define FUTEX_WAIT		0
#define FUTEX_WAKE		1
#define FUTEX_FD		2
#define FUTEX_REQUEUE		3
#define FUTEX_CMP_REQUEUE	4
#define FUTEX_WAKE_OP		5
#define FUTEX_LOCK_PI		6
#define FUTEX_UNLOCK_PI		7
#define FUTEX_TRYLOCK_PI	8
#define FUTEX_WAIT_BITSET	9
#define FUTEX_WAKE_BITSET	10
#define FUTEX_WAIT_REQUEUE_PI	11
#define FUTEX_CMP_REQUEUE_PI	12

#define FUTEX_PRIVATE_FLAG	128
#define FUTEX_CLOCK_REALTIME	256
#define FUTEX_CMD_MASK		~(FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME)

#define FUTEX_WAIT_PRIVATE	(FUTEX_WAIT | FUTEX_PRIVATE_FLAG)
#define FUTEX_WAKE_PRIVATE	(FUTEX_WAKE | FUTEX_PRIVATE_FLAG)
#define FUTEX_REQUEUE_PRIVATE	(FUTEX_REQUEUE | FUTEX_PRIVATE_FLAG)
#define FUTEX_CMP_REQUEUE_PRIVATE (FUTEX_CMP_REQUEUE | FUTEX_PRIVATE_FLAG)
#define FUTEX_WAKE_OP_PRIVATE	(FUTEX_WAKE_OP | FUTEX_PRIVATE_FLAG)
#define FUTEX_LOCK_PI_PRIVATE	(FUTEX_LOCK_PI | FUTEX_PRIVATE_FLAG)
#define FUTEX_UNLOCK_PI_PRIVATE	(FUTEX_UNLOCK_PI | FUTEX_PRIVATE_FLAG)
#define FUTEX_TRYLOCK_PI_PRIVATE (FUTEX_TRYLOCK_PI | FUTEX_PRIVATE_FLAG)
#define FUTEX_WAIT_BITSET_PRIVATE	(FUTEX_WAIT_BITSET | FUTEX_PRIVATE_FLAG)
#define FUTEX_WAKE_BITSET_PRIVATE	(FUTEX_WAKE_BITSET | FUTEX_PRIVATE_FLAG)
#define FUTEX_WAIT_REQUEUE_PI_PRIVATE	(FUTEX_WAIT_REQUEUE_PI | \
					 FUTEX_PRIVATE_FLAG)
#define FUTEX_CMP_REQUEUE_PI_PRIVATE	(FUTEX_CMP_REQUEUE_PI | \
					 FUTEX_PRIVATE_FLAG)

/*
 * Support for robust futexes: the kernel cleans up held futexes at
 * thread exit time.
 */

/*
 * Per-lock list entry - embedded in user-space locks, somewhere close
 * to the futex field. (Note: user-space uses a double-linked list to
 * achieve O(1) list add and remove, but the kernel only needs to know
 * about the forward link)
 *
 * NOTE: this structure is part of the syscall ABI, and must not be
 * changed.
 */
struct robust_list {
	struct robust_list *next;
};

/*
 * Per-thread list head:
 *
 * NOTE: this structure is part of the syscall ABI, and must only be
 * changed if the change is first communicated with the glibc folks.
 * (When an incompatible change is done, we'll increase the structure
 *  size, which glibc will detect)
 */
struct robust_list_head {
	/*
	 * The head of the list. Points back to itself if empty:
	 */
	struct robust_list list;

	/*
	 * This relative offset is set by user-space, it gives the kernel
	 * the relative position of the futex field to examine. This way
	 * we keep userspace flexible, to freely shape its data-structure,
	 * without hardcoding any particular offset into the kernel:
	 */
	long futex_offset;

	/*
	 * The death of the thread may race with userspace setting
	 * up a lock's links. So to handle this race, userspace first
	 * sets this field to the address of the to-be-taken lock,
	 * then does the lock acquire, and then adds itself to the
	 * list, and then clears this field. Hence the kernel will
	 * always have full knowledge of all locks that the thread
	 * _might_ have taken. We check the owner TID in any case,
	 * so only truly owned locks will be handled.
	 */
	struct robust_list *list_op_pending;
};

/*
 * Are there any waiters for this robust futex:
 */
#define FUTEX_WAITERS		0x80000000

/*
 * The kernel signals via this bit that a thread holding a futex
 * has exited without unlocking the futex. The kernel also does
 * a FUTEX_WAKE on such futexes, after setting the bit, to wake
 * up any possible waiters:
 */
#define FUTEX_OWNER_DIED	0x40000000

/*
 * The rest of the robust-futex field is for the TID:
 */
#define FUTEX_TID_MASK		0x3fffffff

/*
 * This limit protects against a deliberately circular list.
 * (Not worth introducing an rlimit for it)
 */
#define ROBUST_LIST_LIMIT	2048

/*
 * bitset with all bits set for the FUTEX_xxx_BITSET OPs to request a
 * match of any bit.
 */
#define FUTEX_BITSET_MATCH_ANY	0xffffffff


#define FUTEX_OP_SET		0	/* *(int *)UADDR2 = OPARG; */
#define FUTEX_OP_ADD		1	/* *(int *)UADDR2 += OPARG; */
#define FUTEX_OP_OR		2	/* *(int *)UADDR2 |= OPARG; */
#define FUTEX_OP_ANDN		3	/* *(int *)UADDR2 &= ~OPARG; */
#define FUTEX_OP_XOR		4	/* *(int *)UADDR2 ^= OPARG; */

#define FUTEX_OP_OPARG_SHIFT	8	/* Use (1 << OPARG) instead of OPARG.  */

#define FUTEX_OP_CMP_EQ		0	/* if (oldval == CMPARG) wake */
#define FUTEX_OP_CMP_NE		1	/* if (oldval != CMPARG) wake */
#define FUTEX_OP_CMP_LT		2	/* if (oldval < CMPARG) wake */
#define FUTEX_OP_CMP_LE		3	/* if (oldval <= CMPARG) wake */
#define FUTEX_OP_CMP_GT		4	/* if (oldval > CMPARG) wake */
#define FUTEX_OP_CMP_GE		5	/* if (oldval >= CMPARG) wake */

/* FUTEX_WAKE_OP will perform atomically
   int oldval = *(int *)UADDR2;
   *(int *)UADDR2 = oldval OP OPARG;
   if (oldval CMP CMPARG)
     wake UADDR2;  */

#define FUTEX_OP(op, oparg, cmp, cmparg) \
  (((op & 0xf) << 28) | ((cmp & 0xf) << 24)		\
   | ((oparg & 0xfff) << 12) | (cmparg & 0xfff))

#endif /* _LINUX_FUTEX_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef __LINUX_GENERIC_NETLINK_H
#define __LINUX_GENERIC_NETLINK_H

#include <linux/types.h>
#include <linux/netlink.h>

#define GENL_NAMSIZ	16	/* length of family name */

#define GENL_MIN_ID	NLMSG_MIN_TYPE
#define GENL_MAX_ID	1023

struct genlmsghdr {
	__u8	cmd;
	__u8	version;
	__u16	reserved;
};

#define GENL_HDRLEN	NLMSG_ALIGN(sizeof(struct genlmsghdr))

#define GENL_ADMIN_PERM		0x01
#define GENL_CMD_CAP_DO		0x02
#define GENL_CMD_CAP_DUMP	0x04
#define GENL_CMD_CAP_HASPOL	0x08

/*
 * List of reserved static generic netlink identifiers:
 */
#define GENL_ID_GENERATE	0
#define GENL_ID_CTRL		NLMSG_MIN_TYPE
#define GENL_ID_VFS_DQUOT	(NLMSG_MIN_TYPE + 1)
#define GENL_ID_PMCRAID		(NLMSG_MIN_TYPE + 2)

/**************************************************************************
 * Controller
 **************************************************************************/

enum {
	CTRL_CMD_UNSPEC,
	CTRL_CMD_NEWFAMILY,
	CTRL_CMD_DELFAMILY,
	CTRL_CMD_GETFAMILY,
	CTRL_CMD_NEWOPS,
	CTRL_CMD_DELOPS,
	CTRL_CMD_GETOPS,
	CTRL_CMD_NEWMCAST_GRP,
	CTRL_CMD_DELMCAST_GRP,
	CTRL_CMD_GETMCAST_GRP, /* unused */
	__CTRL_CMD_MAX,
};

#define CTRL_CMD_MAX (__CTRL_CMD_MAX - 1)

enum {
	CTRL_ATTR_UNSPEC,
	CTRL_ATTR_FAMILY_ID,
	CTRL_ATTR_FAMILY_NAME,
	CTRL_ATTR_VERSION,
	CTRL_ATTR_HDRSIZE,
	CTRL_ATTR_MAXATTR,
	CTRL_ATTR_OPS,
	CTRL_ATTR_MCAST_GROUPS,
	__CTRL_ATTR_MAX,
};

#define CTRL_ATTR_MAX (__CTRL_ATTR_MAX - 1)

enum {
	CTRL_ATTR_OP_UNSPEC,
	CTRL_ATTR_OP_ID,
	CTRL_ATTR_OP_FLAGS,
	__CTRL_ATTR_OP_MAX,
};

#define CTRL_ATTR_OP_MAX (__CTRL_ATTR_OP_MAX - 1)

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC,
	CTRL_ATTR_MCAST_GRP_NAME,
	CTRL_ATTR_MCAST_GRP_ID,
	__CTRL_ATTR_MCAST_GRP_MAX,
};

#define CTRL_ATTR_MCAST_GRP_MAX (__CTRL_ATTR_MCAST_GRP_MAX - 1)


#endif /* __LINUX_GENERIC_NETLINK_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.
 *
 * This copyrighted material is made available to anyone wishing to use,
 * modify, copy, or redistribute it subject to the terms and conditions
 * of the GNU General Public License v.2.
 */

#ifndef __GFS2_ONDISK_DOT_H__
#define __GFS2_ONDISK_DOT_H__

#include <linux/types.h>

#define GFS2_MAGIC		0x01161970
#define GFS2_BASIC_BLOCK	512
#define GFS2_BASIC_BLOCK_SHIFT	9

/* Lock numbers of the LM_TYPE_NONDISK type */

#define GFS2_MOUNT_LOCK		0
#define GFS2_LIVE_LOCK		1
#define GFS2_FREEZE_LOCK	2
#define GFS2_RENAME_LOCK	3
#define GFS2_CONTROL_LOCK	4
#define GFS2_MOUNTED_LOCK	5

/* Format numbers for various metadata types */

#define GFS2_FORMAT_NONE	0
#define GFS2_FORMAT_SB		100
#define GFS2_FORMAT_RG		200
#define GFS2_FORMAT_RB		300
#define GFS2_FORMAT_DI		400
#define GFS2_FORMAT_IN		500
#define GFS2_FORMAT_LF		600
#define GFS2_FORMAT_JD		700
#define GFS2_FORMAT_LH		800
#define GFS2_FORMAT_LD		900
#define GFS2_FORMAT_LB		1000
#define GFS2_FORMAT_EA		1600
#define GFS2_FORMAT_ED		1700
#define GFS2_FORMAT_QC		1400
/* These are format numbers for entities contained in files */
#define GFS2_FORMAT_RI		1100
#define GFS2_FORMAT_DE		1200
#define GFS2_FORMAT_QU		1500
/* These are part of the superblock */
#define GFS2_FORMAT_FS		1801
#define GFS2_FORMAT_MULTI	1900

/*
 * An on-disk inode number
 */

struct gfs2_inum {
	__be64 no_formal_ino;
	__be64 no_addr;
};

/*
 * Generic metadata head structure
 * Every inplace buffer logged in the journal must start with this.
 */

#define GFS2_METATYPE_NONE	0
#define GFS2_METATYPE_SB	1
#define GFS2_METATYPE_RG	2
#define GFS2_METATYPE_RB	3
#define GFS2_METATYPE_DI	4
#define GFS2_METATYPE_IN	5
#define GFS2_METATYPE_LF	6
#define GFS2_METATYPE_JD	7
#define GFS2_METATYPE_LH	8
#define GFS2_METATYPE_LD	9
#define GFS2_METATYPE_LB	12
#define GFS2_METATYPE_EA	10
#define GFS2_METATYPE_ED	11
#define GFS2_METATYPE_QC	14

struct gfs2_meta_header {
	__be32 mh_magic;
	__be32 mh_type;
	__be64 __pad0;		/* Was generation number in gfs1 */
	__be32 mh_format;
	/* This union is to keep userspace happy */
	union {
		__be32 mh_jid;		/* Was incarnation number in gfs1 */
		__be32 __pad1;
	};
};

/*
 * super-block structure
 *
 * It's probably good if SIZEOF_SB <= GFS2_BASIC_BLOCK (512 bytes)
 *
 * Order is important, need to be able to read old superblocks to do on-disk
 * version upgrades.
 */

/* Address of superblock in GFS2 basic blocks */
#define GFS2_SB_ADDR		128

/* The lock number for the superblock (must be zero) */
#define GFS2_SB_LOCK		0

/* Requirement:  GFS2_LOCKNAME_LEN % 8 == 0
   Includes: the fencing zero at the end */
#define GFS2_LOCKNAME_LEN	64

struct gfs2_sb {
	struct gfs2_meta_header sb_header;

	__be32 sb_fs_format;
	__be32 sb_multihost_format;
	__u32  __pad0;	/* Was superblock flags in gfs1 */

	__be32 sb_bsize;
	__be32 sb_bsize_shift;
	__u32 __pad1;	/* Was journal segment size in gfs1 */

	struct gfs2_inum sb_master_dir; /* Was jindex dinode in gfs1 */
	struct gfs2_inum __pad2; /* Was rindex dinode in gfs1 */
	struct gfs2_inum sb_root_dir;

	char sb_lockproto[GFS2_LOCKNAME_LEN];
	char sb_locktable[GFS2_LOCKNAME_LEN];

	struct gfs2_inum __pad3; /* Was quota inode in gfs1 */
	struct gfs2_inum __pad4; /* Was licence inode in gfs1 */
#define GFS2_HAS_UUID 1
	__u8 sb_uuid[16]; /* The UUID, maybe 0 for backwards compat */
};

/*
 * resource index structure
 */

struct gfs2_rindex {
	__be64 ri_addr;	/* grp block disk address */
	__be32 ri_length;	/* length of rgrp header in fs blocks */
	__u32 __pad;

	__be64 ri_data0;	/* first data location */
	__be32 ri_data;	/* num of data blocks in rgrp */

	__be32 ri_bitbytes;	/* number of bytes in data bitmaps */

	__u8 ri_reserved[64];
};

/*
 * resource group header structure
 */

/* Number of blocks per byte in rgrp */
#define GFS2_NBBY		4
#define GFS2_BIT_SIZE		2
#define GFS2_BIT_MASK		0x00000003

#define GFS2_BLKST_FREE		0
#define GFS2_BLKST_USED		1
#define GFS2_BLKST_UNLINKED	2
#define GFS2_BLKST_DINODE	3

#define GFS2_RGF_JOURNAL	0x00000001
#define GFS2_RGF_METAONLY	0x00000002
#define GFS2_RGF_DATAONLY	0x00000004
#define GFS2_RGF_NOALLOC	0x00000008
#define GFS2_RGF_TRIMMED	0x00000010

struct gfs2_rgrp_lvb {
	__be32 rl_magic;
	__be32 rl_flags;
	__be32 rl_free;
	__be32 rl_dinodes;
	__be64 rl_igeneration;
	__be32 rl_unlinked;
	__be32 __pad;
};

struct gfs2_rgrp {
	struct gfs2_meta_header rg_header;

	__be32 rg_flags;
	__be32 rg_free;
	__be32 rg_dinodes;
	__be32 __pad;
	__be64 rg_igeneration;

	__u8 rg_reserved[80]; /* Several fields from gfs1 now reserved */
};

/*
 * quota structure
 */

struct gfs2_quota {
	__be64 qu_limit;
	__be64 qu_warn;
	__be64 qu_value;
	__u8 qu_reserved[64];
};

/*
 * dinode structure
 */

#define GFS2_MAX_META_HEIGHT	10
#define GFS2_DIR_MAX_DEPTH	17

#define DT2IF(dt) (((dt) << 12) & S_IFMT)
#define IF2DT(sif) (((sif) & S_IFMT) >> 12)

enum {
	gfs2fl_Jdata		= 0,
	gfs2fl_ExHash		= 1,
	gfs2fl_Unused		= 2,
	gfs2fl_EaIndirect	= 3,
	gfs2fl_Directio		= 4,
	gfs2fl_Immutable	= 5,
	gfs2fl_AppendOnly	= 6,
	gfs2fl_NoAtime		= 7,
	gfs2fl_Sync		= 8,
	gfs2fl_System		= 9,
	gfs2fl_TopLevel		= 10,
	gfs2fl_TruncInProg	= 29,
	gfs2fl_InheritDirectio	= 30,
	gfs2fl_InheritJdata	= 31,
};

/* Dinode flags */
#define GFS2_DIF_JDATA			0x00000001
#define GFS2_DIF_EXHASH			0x00000002
#define GFS2_DIF_UNUSED			0x00000004  /* only in gfs1 */
#define GFS2_DIF_EA_INDIRECT		0x00000008
#define GFS2_DIF_DIRECTIO		0x00000010
#define GFS2_DIF_IMMUTABLE		0x00000020
#define GFS2_DIF_APPENDONLY		0x00000040
#define GFS2_DIF_NOATIME		0x00000080
#define GFS2_DIF_SYNC			0x00000100
#define GFS2_DIF_SYSTEM			0x00000200 /* New in gfs2 */
#define GFS2_DIF_TOPDIR			0x00000400 /* New in gfs2 */
#define GFS2_DIF_TRUNC_IN_PROG		0x20000000 /* New in gfs2 */
#define GFS2_DIF_INHERIT_DIRECTIO	0x40000000 /* only in gfs1 */
#define GFS2_DIF_INHERIT_JDATA		0x80000000

struct gfs2_dinode {
	struct gfs2_meta_header di_header;

	struct gfs2_inum di_num;

	__be32 di_mode;	/* mode of file */
	__be32 di_uid;	/* owner's user id */
	__be32 di_gid;	/* owner's group id */
	__be32 di_nlink;	/* number of links to this file */
	__be64 di_size;	/* number of bytes in file */
	__be64 di_blocks;	/* number of blocks in file */
	__be64 di_atime;	/* time last accessed */
	__be64 di_mtime;	/* time last modified */
	__be64 di_ctime;	/* time last changed */
	__be32 di_major;	/* device major number */
	__be32 di_minor;	/* device minor number */

	/* This section varies from gfs1. Padding added to align with
         * remainder of dinode
	 */
	__be64 di_goal_meta;	/* rgrp to alloc from next */
	__be64 di_goal_data;	/* data block goal */
	__be64 di_generation;	/* generation number for NFS */

	__be32 di_flags;	/* GFS2_DIF_... */
	__be32 di_payload_format;  /* GFS2_FORMAT_... */
	__u16 __pad1;	/* Was ditype in gfs1 */
	__be16 di_height;	/* height of metadata */
	__u32 __pad2;	/* Unused incarnation number from gfs1 */

	/* These only apply to directories  */
	__u16 __pad3;	/* Padding */
	__be16 di_depth;	/* Number of bits in the table */
	__be32 di_entries;	/* The number of entries in the directory */

	struct gfs2_inum __pad4; /* Unused even in current gfs1 */

	__be64 di_eattr;	/* extended attribute block number */
	__be32 di_atime_nsec;   /* nsec portion of atime */
	__be32 di_mtime_nsec;   /* nsec portion of mtime */
	__be32 di_ctime_nsec;   /* nsec portion of ctime */

	__u8 di_reserved[44];
};

/*
 * directory structure - many of these per directory file
 */

#define GFS2_FNAMESIZE		255
#define GFS2_DIRENT_SIZE(name_len) ((sizeof(struct gfs2_dirent) + (name_len) + 7) & ~7)

struct gfs2_dirent {
	struct gfs2_inum de_inum;
	__be32 de_hash;
	__be16 de_rec_len;
	__be16 de_name_len;
	__be16 de_type;
	union {
		__u8 __pad[14];
		struct {
			__be16 de_rahead;
			__u8 pad2[12];
		};
	};
};

/*
 * Header of leaf directory nodes
 */

struct gfs2_leaf {
	struct gfs2_meta_header lf_header;

	__be16 lf_depth;		/* Depth of leaf */
	__be16 lf_entries;		/* Number of dirents in leaf */
	__be32 lf_dirent_format;	/* Format of the dirents */
	__be64 lf_next;			/* Next leaf, if overflow */

	union {
		__u8 lf_reserved[64];
		struct {
			__be64 lf_inode;	/* Dir inode number */
			__be32 lf_dist;		/* Dist from inode on chain */
			__be32 lf_nsec;		/* Last ins/del usecs */
			__be64 lf_sec;		/* Last ins/del in secs */
			__u8 lf_reserved2[40];
		};
	};
};

/*
 * Extended attribute header format
 *
 * This works in a similar way to dirents. There is a fixed size header
 * followed by a variable length section made up of the name and the
 * associated data. In the case of a "stuffed" entry, the value is
 * __inline__ directly after the name, the ea_num_ptrs entry will be
 * zero in that case. For non-"stuffed" entries, there will be
 * a set of pointers (aligned to 8 byte boundary) to the block(s)
 * containing the value.
 *
 * The blocks containing the values and the blocks containing the
 * extended attribute headers themselves all start with the common
 * metadata header. Each inode, if it has extended attributes, will
 * have either a single block containing the extended attribute headers
 * or a single indirect block pointing to blocks containing the
 * extended attribute headers.
 *
 * The maximum size of the data part of an extended attribute is 64k
 * so the number of blocks required depends upon block size. Since the
 * block size also determines the number of pointers in an indirect
 * block, its a fairly complicated calculation to work out the maximum
 * number of blocks that an inode may have relating to extended attributes.
 *
 */

#define GFS2_EA_MAX_NAME_LEN	255
#define GFS2_EA_MAX_DATA_LEN	65536

#define GFS2_EATYPE_UNUSED	0
#define GFS2_EATYPE_USR		1
#define GFS2_EATYPE_SYS		2
#define GFS2_EATYPE_SECURITY	3

#define GFS2_EATYPE_LAST	3
#define GFS2_EATYPE_VALID(x)	((x) <= GFS2_EATYPE_LAST)

#define GFS2_EAFLAG_LAST	0x01	/* last ea in block */

struct gfs2_ea_header {
	__be32 ea_rec_len;
	__be32 ea_data_len;
	__u8 ea_name_len;	/* no NULL pointer after the string */
	__u8 ea_type;		/* GFS2_EATYPE_... */
	__u8 ea_flags;		/* GFS2_EAFLAG_... */
	__u8 ea_num_ptrs;
	__u32 __pad;
};

/*
 * Log header structure
 */

#define GFS2_LOG_HEAD_UNMOUNT	0x00000001	/* log is clean */

struct gfs2_log_header {
	struct gfs2_meta_header lh_header;

	__be64 lh_sequence;	/* Sequence number of this transaction */
	__be32 lh_flags;	/* GFS2_LOG_HEAD_... */
	__be32 lh_tail;		/* Block number of log tail */
	__be32 lh_blkno;
	__be32 lh_hash;
};

/*
 * Log type descriptor
 */

#define GFS2_LOG_DESC_METADATA	300
/* ld_data1 is the number of metadata blocks in the descriptor.
   ld_data2 is unused. */

#define GFS2_LOG_DESC_REVOKE	301
/* ld_data1 is the number of revoke blocks in the descriptor.
   ld_data2 is unused. */

#define GFS2_LOG_DESC_JDATA	302
/* ld_data1 is the number of data blocks in the descriptor.
   ld_data2 is unused. */

struct gfs2_log_descriptor {
	struct gfs2_meta_header ld_header;

	__be32 ld_type;		/* GFS2_LOG_DESC_... */
	__be32 ld_length;	/* Number of buffers in this chunk */
	__be32 ld_data1;	/* descriptor-specific field */
	__be32 ld_data2;	/* descriptor-specific field */

	__u8 ld_reserved[32];
};

/*
 * Inum Range
 * Describe a range of formal inode numbers allocated to
 * one machine to assign to inodes.
 */

#define GFS2_INUM_QUANTUM	1048576

struct gfs2_inum_range {
	__be64 ir_start;
	__be64 ir_length;
};

/*
 * Statfs change
 * Describes an change to the pool of free and allocated
 * blocks.
 */

struct gfs2_statfs_change {
	__be64 sc_total;
	__be64 sc_free;
	__be64 sc_dinodes;
};

/*
 * Quota change
 * Describes an allocation change for a particular
 * user or group.
 */

#define GFS2_QCF_USER		0x00000001

struct gfs2_quota_change {
	__be64 qc_change;
	__be32 qc_flags;	/* GFS2_QCF_... */
	__be32 qc_id;
};

struct gfs2_quota_lvb {
        __be32 qb_magic;
        __u32 __pad;
        __be64 qb_limit;      /* Hard limit of # blocks to alloc */
        __be64 qb_warn;       /* Warn user when alloc is above this # */
        __be64 qb_value;       /* Current # blocks allocated */
};

#endif /* __GFS2_ONDISK_DOT_H__ */
                                                                                             /*
 * interface to user space for the gigaset driver
 *
 * Copyright (c) 2004 by Hansjoerg Lipp <hjlipp@web.de>
 *
 * =====================================================================
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License as
 *    published by the Free Software Foundation; either version 2 of
 *    the License, or (at your option) any later version.
 * =====================================================================
 */

#ifndef GIGASET_INTERFACE_H
#define GIGASET_INTERFACE_H

#include <linux/ioctl.h>

/* The magic IOCTL value for this interface. */
#define GIGASET_IOCTL 0x47

/* enable/disable device control via character device (lock out ISDN subsys) */
#define GIGASET_REDIR    _IOWR(GIGASET_IOCTL, 0, int)

/* enable adapter configuration mode (M10x only) */
#define GIGASET_CONFIG   _IOWR(GIGASET_IOCTL, 1, int)

/* set break characters (M105 only) */
#define GIGASET_BRKCHARS _IOW(GIGASET_IOCTL, 2, unsigned char[6])

/* get version information selected by arg[0] */
#define GIGASET_VERSION  _IOWR(GIGASET_IOCTL, 3, unsigned[4])
/* values for GIGASET_VERSION arg[0] */
#define GIGVER_DRIVER 0		/* get driver version */
#define GIGVER_COMPAT 1		/* get interface compatibility version */
#define GIGVER_FWBASE 2		/* get base station firmware version */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * Generic HDLC support routines for Linux
 *
 * Copyright (C) 1999-2005 Krzysztof Halasa <khc@pm.waw.pl>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License
 * as published by the Free Software Foundation.
 */

#ifndef __HDLC_H
#define __HDLC_H


#define HDLC_MAX_MTU 1500	/* Ethernet 1500 bytes */
#if 0
#define HDLC_MAX_MRU (HDLC_MAX_MTU + 10 + 14 + 4) /* for ETH+VLAN over FR */
#else
#define HDLC_MAX_MRU 1600 /* as required for FR network */
#endif


#endif /* __HDLC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  