tor>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng);
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      param_type _M_param;

      std::normal_distribution<result_type> _M_nd;
      std::gamma_distribution<result_type> _M_gd;
    };

  /**
   * @brief Return true if two Student t distributions are different.
   */
  template<typename _RealType>
    inline bool
    operator!=(const std::student_t_distribution<_RealType>& __d1,
	       const std::student_t_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }


  /* @} */ // group random_distributions_normal

  /**
   * @addtogroup random_distributions_bernoulli Bernoulli Distributions
   * @ingroup random_distributions
   * @{
   */

  /**
   * @brief A Bernoulli random number distribution.
   *
   * Generates a sequence of true and false values with likelihood @f$p@f$
   * that true will come up and @f$(1 - p)@f$ that false will appear.
   */
  class bernoulli_distribution
  {
  public:
    /** The type of the range of the distribution. */
    typedef bool result_type;
    /** Parameter type. */
    struct param_type
    {
      typedef bernoulli_distribution distribution_type;

      explicit
      param_type(double __p = 0.5)
      : _M_p(__p)
      {
	_GLIBCXX_DEBUG_ASSERT((_M_p >= 0.0) && (_M_p <= 1.0));
      }

      double
      p() const
      { return _M_p; }

      friend bool
      operator==(const param_type& __p1, const param_type& __p2)
      { return __p1._M_p == __p2._M_p; }

    private:
      double _M_p;
    };

  public:
    /**
     * @brief Constructs a Bernoulli distribution with likelihood @p p.
     *
     * @param __p  [IN]  The likelihood of a true result being returned.
     *                   Must be in the interval @f$[0, 1]@f$.
     */
    explicit
    bernoulli_distribution(double __p = 0.5)
    : _M_param(__p)
    { }

    explicit
    bernoulli_distribution(const param_type& __p)
    : _M_param(__p)
    { }

    /**
     * @brief Resets the distribution state.
     *
     * Does nothing for a Bernoulli distribution.
     */
    void
    reset() { }

    /**
     * @brief Returns the @p p parameter of the distribution.
     */
    double
    p() const
    { return _M_param.p(); }

    /**
     * @brief Returns the parameter set of the distribution.
     */
    param_type
    param() const
    { return _M_param; }

    /**
     * @brief Sets the parameter set of the distribution.
     * @param __param The new parameter set of the distribution.
     */
    void
    param(const param_type& __param)
    { _M_param = __param; }

    /**
     * @brief Returns the greatest lower bound value of the distribution.
     */
    result_type
    min() const
    { return std::numeric_limits<result_type>::min(); }

    /**
     * @brief Returns the least upper bound value of the distribution.
     */
    result_type
    max() const
    { return std::numeric_limits<result_type>::max(); }

    /**
     * @brief Generating functions.
     */
    template<typename _UniformRandomNumberGenerator>
      result_type
      operator()(_UniformRandomNumberGenerator& __urng)
      { return this->operator()(__urng, _M_param); }

    template<typename _UniformRandomNumberGenerator>
      result_type
      operator()(_UniformRandomNumberGenerator& __urng,
		 const param_type& __p)
      {
	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
	  __aurng(__urng);
	if ((__aurng() - __aurng.min())
	     < __p.p() * (__aurng.max() - __aurng.min()))
	  return true;
	return false;
      }

    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      __generate(_ForwardIterator __f, _ForwardIterator __t,
		 _UniformRandomNumberGenerator& __urng)
      { this->__generate(__f, __t, __urng, _M_param); }

    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      __generate(_ForwardIterator __f, _ForwardIterator __t,
		 _UniformRandomNumberGenerator& __urng, const param_type& __p)
      { this->__generate_impl(__f, __t, __urng, __p); }

    template<typename _UniformRandomNumberGenerator>
      void
      __generate(result_type* __f, result_type* __t,
		 _UniformRandomNumberGenerator& __urng,
		 const param_type& __p)
      { this->__generate_impl(__f, __t, __urng, __p); }

    /**
     * @brief Return true if two Bernoulli distributions have
     *        the same parameters.
     */
    friend bool
    operator==(const bernoulli_distribution& __d1,
	       const bernoulli_distribution& __d2)
    { return __d1._M_param == __d2._M_param; }

  private:
    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
		      _UniformRandomNumberGenerator& __urng,
		      const param_type& __p);

    param_type _M_param;
  };

  /**
   * @brief Return true if two Bernoulli distributions have
   *        different parameters.
   */
  inline bool
  operator!=(const std::bernoulli_distribution& __d1,
	     const std::bernoulli_distribution& __d2)
  { return !(__d1 == __d2); }

  /**
   * @brief Inserts a %bernoulli_distribution random number distribution
   * @p __x into the output stream @p __os.
   *
   * @param __os An output stream.
   * @param __x  A %bernoulli_distribution random number distribution.
   *
   * @returns The output stream with the state of @p __x inserted or in
   * an error state.
   */
  template<typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const std::bernoulli_distribution& __x);

  /**
   * @brief Extracts a %bernoulli_distribution random number distribution
   * @p __x from the input stream @p __is.
   *
   * @param __is An input stream.
   * @param __x  A %bernoulli_distribution random number generator engine.
   *
   * @returns The input stream with @p __x extracted or in an error state.
   */
  template<typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       std::bernoulli_distribution& __x)
    {
      double __p;
      __is >> __p;
      __x.param(bernoulli_distribution::param_type(__p));
      return __is;
    }


  /**
   * @brief A discrete binomial random number distribution.
   *
   * The formula for the binomial probability density function is
   * @f$p(i|t,p) = \binom{t}{i} p^i (1 - p)^{t - i}@f$ where @f$t@f$
   * and @f$p@f$ are the parameters of the distribution.
   */
  template<typename _IntType = int>
    class binomial_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
		    "template argument not an integral type");

    public:
      /** The type of the range of the distribution. */
      typedef _IntType result_type;
      /** Parameter type. */
      struct param_type
      {
	typedef binomial_distribution<_IntType> distribution_type;
	friend class binomial_distribution<_IntType>;

	explicit
	param_type(_IntType __t = _IntType(1), double __p = 0.5)
	: _M_t(__t), _M_p(__p)
	{
	  _GLIBCXX_DEBUG_ASSERT((_M_t >= _IntType(0))
				&& (_M_p >= 0.0)
				&& (_M_p <= 1.0));
	  _M_initialize();
	}

	_IntType
	t() const
	{ return _M_t; }

	double
	p() const
	{ return _M_p; }

	friend bool
	operator==(const param_type& __p1, const param_type& __p2)
	{ return __p1._M_t == __p2._M_t && __p1._M_p == __p2._M_p; }

      private:
	void
	_M_initialize();

	_IntType _M_t;
	double _M_p;

	double _M_q;
#if _GLIBCXX_USE_C99_MATH_TR1
	double _M_d1, _M_d2, _M_s1, _M_s2, _M_c,
	       _M_a1, _M_a123, _M_s, _M_lf, _M_lp1p;
#endif
	bool   _M_easy;
      };

      // constructors and member function
      explicit
      binomial_distribution(_IntType __t = _IntType(1),
			    double __p = 0.5)
      : _M_param(__t, __p), _M_nd()
      { }

      explicit
      binomial_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }

      /**
       * @brief Resets the distribution state.
       */
      void
      reset()
      { _M_nd.reset(); }

      /**
       * @brief Returns the distribution @p t parameter.
       */
      _IntType
      t() const
      { return _M_param.t(); }

      /**
       * @brief Returns the distribution @p p parameter.
       */
      double
      p() const
      { return _M_param.p(); }

      /**
       * @brief Returns the parameter set of the distribution.
       */
      param_type
      param() const
      { return _M_param; }

      /**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       */
      void
      param(const param_type& __param)
      { _M_param = __param; }

      /**
       * @brief Returns the greatest lower bound value of the distribution.
       */
      result_type
      min() const
      { return 0; }

      /**
       * @brief Returns the least upper bound value of the distribution.
       */
      result_type
      max() const
      { return _M_param.t(); }

      /**
       * @brief Generating functions.
       */
      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng)
	{ return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p);

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      /**
       * @brief Return true if two binomial distributions have
       *        the same parameters and the sequences that would
       *        be generated are equal.
       */
	friend bool
        operator==(const binomial_distribution& __d1,
		   const binomial_distribution& __d2)
#ifdef _GLIBCXX_USE_C99_MATH_TR1
	{ return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd; }
#else
        { return __d1._M_param == __d2._M_param; }
#endif

      /**
       * @brief Inserts a %binomial_distribution random number distribution
       * @p __x into the output stream @p __os.
       *
       * @param __os An output stream.
       * @param __x  A %binomial_distribution random number distribution.
       *
       * @returns The output stream with the state of @p __x inserted or in
       * an error state.
       */
      template<typename _IntType1,
	       typename _CharT, typename _Traits>
	friend std::basic_ostream<_CharT, _Traits>&
	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
		   const std::binomial_distribution<_IntType1>& __x);

      /**
       * @brief Extracts a %binomial_distribution random number distribution
       * @p __x from the input stream @p __is.
       *
       * @param __is An input stream.
       * @param __x  A %binomial_distribution random number generator engine.
       *
       * @returns The input stream with @p __x extracted or in an error
       *          state.
       */
      template<typename _IntType1,
	       typename _CharT, typename _Traits>
	friend std::basic_istream<_CharT, _Traits>&
	operator>>(std::basic_istream<_CharT, _Traits>& __is,
		   std::binomial_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      template<typename _UniformRandomNumberGenerator>
	result_type
	_M_waiting(_UniformRandomNumberGenerator& __urng,
		   _IntType __t, double __q);

      param_type _M_param;

      // NB: Unused when _GLIBCXX_USE_C99_MATH_TR1 is undefined.
      std::normal_distribution<double> _M_nd;
    };

  /**
   * @brief Return true if two binomial distributions are different.
   */
  template<typename _IntType>
    inline bool
    operator!=(const std::binomial_distribution<_IntType>& __d1,
	       const std::binomial_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }


  /**
   * @brief A discrete geometric random number distribution.
   *
   * The formula for the geometric probability density function is
   * @f$p(i|p) = p(1 - p)^{i}@f$ where @f$p@f$ is the parameter of the
   * distribution.
   */
  template<typename _IntType = int>
    class geometric_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
		    "template argument not an integral type");

    public:
      /** The type of the range of the distribution. */
      typedef _IntType  result_type;
      /** Parameter type. */
      struct param_type
      {
	typedef geometric_distribution<_IntType> distribution_type;
	friend class geometric_distribution<_IntType>;

	explicit
	param_type(double __p = 0.5)
	: _M_p(__p)
	{
	  _GLIBCXX_DEBUG_ASSERT((_M_p > 0.0) && (_M_p < 1.0));
	  _M_initialize();
	}

	double
	p() const
	{ return _M_p; }

	friend bool
	operator==(const param_type& __p1, const param_type& __p2)
	{ return __p1._M_p == __p2._M_p; }

      private:
	void
	_M_initialize()
	{ _M_log_1_p = std::log(1.0 - _M_p); }

	double _M_p;

	double _M_log_1_p;
      };

      // constructors and member function
      explicit
      geometric_distribution(double __p = 0.5)
      : _M_param(__p)
      { }

      explicit
      geometric_distribution(const param_type& __p)
      : _M_param(__p)
      { }

      /**
       * @brief Resets the distribution state.
       *
       * Does nothing for the geometric distribution.
       */
      void
      reset() { }

      /**
       * @brief Returns the distribution parameter @p p.
       */
      double
      p() const
      { return _M_param.p(); }

      /**
       * @brief Returns the parameter set of the distribution.
       */
      param_type
      param() const
      { return _M_param; }

      /**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       */
      void
      param(const param_type& __param)
      { _M_param = __param; }

      /**
       * @brief Returns the greatest lower bound value of the distribution.
       */
      result_type
      min() const
      { return 0; }

      /**
       * @brief Returns the least upper bound value of the distribution.
       */
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }

      /**
       * @brief Generating functions.
       */
      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng)
	{ return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p);

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      /**
       * @brief Return true if two geometric distributions have
       *        the same parameters.
       */
      friend bool
      operator==(const geometric_distribution& __d1,
		 const geometric_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      param_type _M_param;
    };

  /**
   * @brief Return true if two geometric distributions have
   *        different parameters.
   */
  template<typename _IntType>
    inline bool
    operator!=(const std::geometric_distribution<_IntType>& __d1,
	       const std::geometric_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }

  /**
   * @brief Inserts a %geometric_distribution random number distribution
   * @p __x into the output stream @p __os.
   *
   * @param __os An output stream.
   * @param __x  A %geometric_distribution random number distribution.
   *
   * @returns The output stream with the state of @p __x inserted or in
   * an error state.
   */
  template<typename _IntType,
	   typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const std::geometric_distribution<_IntType>& __x);

  /**
   * @brief Extracts a %geometric_distribution random number distribution
   * @p __x from the input stream @p __is.
   *
   * @param __is An input stream.
   * @param __x  A %geometric_distribution random number generator engine.
   *
   * @returns The input stream with @p __x extracted or in an error state.
   */
  template<typename _IntType,
	   typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       std::geometric_distribution<_IntType>& __x);


  /**
   * @brief A negative_binomial_distribution random number distribution.
   *
   * The formula for the negative binomial probability mass function is
   * @f$p(i) = \binom{n}{i} p^i (1 - p)^{t - i}@f$ where @f$t@f$
   * and @f$p@f$ are the parameters of the distribution.
   */
  template<typename _IntType = int>
    class negative_binomial_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
		    "template argument not an integral type");

    public:
      /** The type of the range of the distribution. */
      typedef _IntType result_type;
      /** Parameter type. */
      struct param_type
      {
	typedef negative_binomial_distribution<_IntType> distribution_type;

	explicit
	param_type(_IntType __k = 1, double __p = 0.5)
	: _M_k(__k), _M_p(__p)
	{
	  _GLIBCXX_DEBUG_ASSERT((_M_k > 0) && (_M_p > 0.0) && (_M_p <= 1.0));
	}

	_IntType
	k() const
	{ return _M_k; }

	double
	p() const
	{ return _M_p; }

	friend bool
	operator==(const param_type& __p1, const param_type& __p2)
	{ return __p1._M_k == __p2._M_k && __p1._M_p == __p2._M_p; }

      private:
	_IntType _M_k;
	double _M_p;
      };

      explicit
      negative_binomial_distribution(_IntType __k = 1, double __p = 0.5)
      : _M_param(__k, __p), _M_gd(__k, (1.0 - __p) / __p)
      { }

      explicit
      negative_binomial_distribution(const param_type& __p)
      : _M_param(__p), _M_gd(__p.k(), (1.0 - __p.p()) / __p.p())
      { }

      /**
       * @brief Resets the distribution state.
       */
      void
      reset()
      { _M_gd.reset(); }

      /**
       * @brief Return the @f$k@f$ parameter of the distribution.
       */
      _IntType
      k() const
      { return _M_param.k(); }

      /**
       * @brief Return the @f$p@f$ parameter of the distribution.
       */
      double
      p() const
      { return _M_param.p(); }

      /**
       * @brief Returns the parameter set of the distribution.
       */
      param_type
      param() const
      { return _M_param; }

      /**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       */
      void
      param(const param_type& __param)
      { _M_param = __param; }

      /**
       * @brief Returns the greatest lower bound value of the distribution.
       */
      result_type
      min() const
      { return result_type(0); }

      /**
       * @brief Returns the least upper bound value of the distribution.
       */
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }

      /**
       * @brief Generating functions.
       */
      template<typename _UniformRandomNumberGenerator>
	result_type
        operator()(_UniformRandomNumberGenerator& __urng);

      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p);

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate_impl(__f, __t, __urng); }

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate_impl(__f, __t, __urng); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      /**
       * @brief Return true if two negative binomial distributions have
       *        the same parameters and the sequences that would be
       *        generated are equal.
       */
      friend bool
      operator==(const negative_binomial_distribution& __d1,
		 const negative_binomial_distribution& __d2)
      { return __d1._M_param == __d2._M_param && __d1._M_gd == __d2._M_gd; }

      /**
       * @brief Inserts a %negative_binomial_distribution random
       *        number distribution @p __x into the output stream @p __os.
       *
       * @param __os An output stream.
       * @param __x  A %negative_binomial_distribution random number
       *             distribution.
       *
       * @returns The output stream with the state of @p __x inserted or in
       *          an error state.
       */
      template<typename _IntType1, typename _CharT, typename _Traits>
	friend std::basic_ostream<_CharT, _Traits>&
	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
		   const std::negative_binomial_distribution<_IntType1>& __x);

      /**
       * @brief Extracts a %negative_binomial_distribution random number
       *        distribution @p __x from the input stream @p __is.
       *
       * @param __is An input stream.
       * @param __x A %negative_binomial_distribution random number
       *            generator engine.
       *
       * @returns The input stream with @p __x extracted or in an error state.
       */
      template<typename _IntType1, typename _CharT, typename _Traits>
	friend std::basic_istream<_CharT, _Traits>&
	operator>>(std::basic_istream<_CharT, _Traits>& __is,
		   std::negative_binomial_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng);
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      param_type _M_param;

      std::gamma_distribution<double> _M_gd;
    };

  /**
   * @brief Return true if two negative binomial distributions are different.
   */
  template<typename _IntType>
    inline bool
    operator!=(const std::negative_binomial_distribution<_IntType>& __d1,
	       const std::negative_binomial_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }


  /* @} */ // group random_distributions_bernoulli

  /**
   * @addtogroup random_distributions_poisson Poisson Distributions
   * @ingroup random_distributions
   * @{
   */

  /**
   * @brief A discrete Poisson random number distribution.
   *
   * The formula for the Poisson probability density function is
   * @f$p(i|\mu) = \frac{\mu^i}{i!} e^{-\mu}@f$ where @f$\mu@f$ is the
   * parameter of the distribution.
   */
  template<typename _IntType = int>
    class poisson_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
		    "template argument not an integral type");

    public:
      /** The type of the range of the distribution. */
      typedef _IntType  result_type;
      /** Parameter type. */
      struct param_type
      {
	typedef poisson_distribution<_IntType> distribution_type;
	friend class poisson_distribution<_IntType>;

	explicit
	param_type(double __mean = 1.0)
	: _M_mean(__mean)
	{
	  _GLIBCXX_DEBUG_ASSERT(_M_mean > 0.0);
	  _M_initialize();
	}

	double
	mean() const
	{ return _M_mean; }

	friend bool
	operator==(const param_type& __p1, const param_type& __p2)
	{ return __p1._M_mean == __p2._M_mean; }

      private:
	// Hosts either log(mean) or the threshold of the simple method.
	void
	_M_initialize();

	double _M_mean;

	double _M_lm_thr;
#if _GLIBCXX_USE_C99_MATH_TR1
	double _M_lfm, _M_sm, _M_d, _M_scx, _M_1cx, _M_c2b, _M_cb;
#endif
      };

      // constructors and member function
      explicit
      poisson_distribution(double __mean = 1.0)
      : _M_param(__mean), _M_nd()
      { }

      explicit
      poisson_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }

      /**
       * @brief Resets the distribution state.
       */
      void
      reset()
      { _M_nd.reset(); }

      /**
       * @brief Returns the distribution parameter @p mean.
       */
      double
      mean() const
      { return _M_param.mean(); }

      /**
       * @brief Returns the parameter set of the distribution.
       */
      param_type
      param() const
      { return _M_param; }

      /**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       */
      void
      param(const param_type& __param)
      { _M_param = __param; }

      /**
       * @brief Returns the greatest lower bound value of the distribution.
       */
      result_type
      min() const
      { return 0; }

      /**
       * @brief Returns the least upper bound value of the distribution.
       */
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }

      /**
       * @brief Generating functions.
       */
      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng)
	{ return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p);

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

       /**
	* @brief Return true if two Poisson distributions have the same
	*        parameters and the sequences that would be generated
	*        are equal.
	*/
      friend bool
      operator==(const poisson_distribution& __d1,
		 const poisson_distribution& __d2)
#ifdef _GLIBCXX_USE_C99_MATH_TR1
      { return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd; }
#else
      { return __d1._M_param == __d2._M_param; }
#endif

      /**
       * @brief Inserts a %poisson_distribution random number distribution
       * @p __x into the output stream @p __os.
       *
       * @param __os An output stream.
       * @param __x  A %poisson_distribution random number distribution.
       *
       * @returns The output stream with the state of @p __x inserted or in
       * an error state.
       */
      template<typename _IntType1, typename _CharT, typename _Traits>
	friend std::basic_ostream<_CharT, _Traits>&
	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
		   const std::poisson_distribution<_IntType1>& __x);

      /**
       * @brief Extracts a %poisson_distribution random number distribution
       * @p __x from the input stream @p __is.
       *
       * @param __is An input stream.
       * @param __x  A %poisson_distribution random number generator engine.
       *
       * @returns The input stream with @p __x extracted or in an error
       *          state.
       */
      template<typename _IntType1, typename _CharT, typename _Traits>
	friend std::basic_istream<_CharT, _Traits>&
	operator>>(std::basic_istream<_CharT, _Traits>& __is,
		   std::poisson_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      param_type _M_param;

      // NB: Unused when _GLIBCXX_USE_C99_MATH_TR1 is undefined.
      std::normal_distribution<double> _M_nd;
    };

  /**
   * @brief Return true if two Poisson distributions are different.
   */
  template<typename _IntType>
    inline bool
    operator!=(const std::poisson_distribution<_IntType>& __d1,
	       const std::poisson_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }


  /**
   * @brief An exponential continuous distribution for random numbers.
   *
   * The formula for the exponential probability density function is
   * @f$p(x|\lambda) = \lambda e^{-\lambda x}@f$.
   *
   * <table border=1 cellpadding=10 cellspacing=0>
   * <caption align=top>Distribution Statistics</caption>
   * <tr><td>Mean</td><td>@f$\frac{1}{\lambda}@f$</td></tr>
   * <tr><td>Median</td><td>@f$\frac{\ln 2}{\lambda}@f$</td></tr>
   * <tr><td>Mode</td><td>@f$zero@f$</td></tr>
   * <tr><td>Range</td><td>@f$[0, \infty]@f$</td></tr>
   * <tr><td>Standard Deviation</td><td>@f$\frac{1}{\lambda}@f$</td></tr>
   * </table>
   */
  template<typename _RealType = double>
    class exponential_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
		    "template argument not a floating point type");

    public:
      /** The type of the range of the distribution. */
      typedef _RealType result_type;
      /** Parameter type. */
      struct param_type
      {
	typedef exponential_distribution<_RealType> distribution_type;

	explicit
	param_type(_RealType __lambda = _RealType(1))
	: _M_lambda(__lambda)
	{
	  _GLIBCXX_DEBUG_ASSERT(_M_lambda > _RealType(0));
	}

	_RealType
	lambda() const
	{ return _M_lambda; }

	friend bool
	operator==(const param_type& __p1, const param_type& __p2)
	{ return __p1._M_lambda == __p2._M_lambda; }

      private:
	_RealType _M_lambda;
      };

    public:
      /**
       * @brief Constructs an exponential distribution with inverse scale
       *        parameter @f$\lambda@f$.
       */
      explicit
      exponential_distribution(const result_type& __lambda = result_type(1))
      : _M_param(__lambda)
      { }

      explicit
      exponential_distribution(const param_type& __p)
      : _M_param(__p)
      { }

      /**
       * @brief Resets the distribution state.
       *
       * Has no effect on exponential distributions.
       */
      void
      reset() { }

      /**
       * @brief Returns the inverse scale parameter of the distribution.
       */
      _RealType
      lambda() const
      { return _M_param.lambda(); }

      /**
       * @brief Returns the parameter set of the distribution.
       */
      param_type
      param() const
      { return _M_param; }

      /**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       */
      void
      param(const param_type& __param)
      { _M_param = __param; }

      /**
       * @brief Returns the greatest lower bound value of the distribution.
       */
      result_type
      min() const
      { return result_type(0); }

      /**
       * @brief Returns the least upper bound value of the distribution.
       */
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }

      /**
       * @brief Generating functions.
       */
      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{
	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	    __aurng(__urng);
	  return -std::log(result_type(1) - __aurng()) / __p.lambda();
	}

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      /**
       * @brief Return true if two exponential distributions have the same
       *        parameters.
       */
      friend bool
      operator==(const exponential_distribution& __d1,
		 const exponential_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      param_type _M_param;
    };

  /**
   * @brief Return true if two exponential distributions have different
   *        parameters.
   */
  template<typename _RealType>
    inline bool
    operator!=(const std::exponential_distribution<_RealType>& __d1,
	       const std::exponential_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }

  /**
   * @brief Inserts a %exponential_distribution random number distribution
   * @p __x into the output stream @p __os.
   *
   * @param __os An output stream.
   * @param __x  A %exponential_distribution random number distribution.
   *
   * @returns The output stream with the state of @p __x inserted or in
   * an error state.
   */
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const std::exponential_distribution<_RealType>& __x);

  /**
   * @brief Extracts a %exponential_distribution random number distribution
   * @p __x from the input stream @p __is.
   *
   * @param __is An input stream.
   * @param __x A %exponential_distribution random number
   *            generator engine.
   *
   * @returns The input stream with @p __x extracted or in an error state.
   */
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       std::exponential_distribution<_RealType>& __x);


  /**
   * @brief A weibull_distribution random number distribution.
   *
   * The formula for the normal probability density function is:
   * @f[
   *     p(x|\alpha,\beta) = \frac{\alpha}{\beta} (\frac{x}{\beta})^{\alpha-1}
   *                         \exp{(-(\frac{x}{\beta})^\alpha)} 
   * @f]
   */
  template<typename _RealType = double>
    class weibull_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
		    "template argument not a floating point type");

    public:
      /** The type of the range of the distribution. */
      typedef _RealType result_type;
      /** Parameter type. */
      struct param_type
      {
	typedef weibull_distribution<_RealType> distribution_type;

	explicit
	param_type(_RealType __a = _RealType(1),
		   _RealType __b = _RealType(1))
	: _M_a(__a), _M_b(__b)
	{ }

	_RealType
	a() const
	{ return _M_a; }

	_RealType
	b() const
	{ return _M_b; }

	friend bool
	operator==(const param_type& __p1, const param_type& __p2)
	{ return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
	_RealType _M_a;
	_RealType _M_b;
      };

      explicit
      weibull_distribution(_RealType __a = _RealType(1),
			   _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      weibull_distribution(const param_type& __p)
      : _M_param(__p)
      { }

      /**
       * @brief Resets the distribution state.
       */
      void
      reset()
      { }

      /**
       * @brief Return the @f$a@f$ parameter of the distribution.
       */
      _RealType
      a() const
      { return _M_param.a(); }

      /**
       * @brief Return the @f$b@f$ parameter of the distribution.
       */
      _RealType
      b() const
      { return _M_param.b(); }

      /**
       * @brief Returns the parameter set of the distribution.
       */
      param_type
      param() const
      { return _M_param; }

      /**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       */
      void
      param(const param_type& __param)
      { _M_param = __param; }

      /**
       * @brief Returns the greatest lower bound value of the distribution.
       */
      result_type
      min() const
      { return result_type(0); }

      /**
       * @brief Returns the least upper bound value of the distribution.
       */
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }

      /**
       * @brief Generating functions.
       */
      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng)
	{ return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p);

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      /**
       * @brief Return true if two Weibull distributions have the same
       *        parameters.
       */
      friend bool
      operator==(const weibull_distribution& __d1,
		 const weibull_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      param_type _M_param;
    };

   /**
    * @brief Return true if two Weibull distributions have different
    *        parameters.
    */
  template<typename _RealType>
    inline bool
    operator!=(const std::weibull_distribution<_RealType>& __d1,
	       const std::weibull_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }

  /**
   * @brief Inserts a %weibull_distribution random number distribution
   * @p __x into the output stream @p __os.
   *
   * @param __os An output stream.
   * @param __x  A %weibull_distribution random number distribution.
   *
   * @returns The output stream with the state of @p __x inserted or in
   * an error state.
   */
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const std::weibull_distribution<_RealType>& __x);

  /**
   * @brief Extracts a %weibull_distribution random number distribution
   * @p __x from the input stream @p __is.
   *
   * @param __is An input stream.
   * @param __x A %weibull_distribution random number
   *            generator engine.
   *
   * @returns The input stream with @p __x extracted or in an error state.
   */
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       std::weibull_distribution<_RealType>& __x);


  /**
   * @brief A extreme_value_distribution random number distribution.
   *
   * The formula for the normal probability mass function is
   * @f[
   *     p(x|a,b) = \frac{1}{b}
   *                \exp( \frac{a-x}{b} - \exp(\frac{a-x}{b})) 
   * @f]
   */
  template<typename _RealType = double>
    class extreme_value_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
		    "template argument not a floating point type");

    public:
      /** The type of the range of the distribution. */
      typedef _RealType result_type;
      /** Parameter type. */
      struct param_type
      {
	typedef extreme_value_distribution<_RealType> distribution_type;

	explicit
	param_type(_RealType __a = _RealType(0),
		   _RealType __b = _RealType(1))
	: _M_a(__a), _M_b(__b)
	{ }

	_RealType
	a() const
	{ return _M_a; }

	_RealType
	b() const
	{ return _M_b; }

	friend bool
	operator==(const param_type& __p1, const param_type& __p2)
	{ return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
	_RealType _M_a;
	_RealType _M_b;
      };

      explicit
      extreme_value_distribution(_RealType __a = _RealType(0),
				 _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      extreme_value_distribution(const param_type& __p)
      : _M_param(__p)
      { }

      /**
       * @brief Resets the distribution state.
       */
      void
      reset()
      { }

      /**
       * @brief Return the @f$a@f$ parameter of the distribution.
       */
      _RealType
      a() const
      { return _M_param.a(); }

      /**
       * @brief Return the @f$b@f$ parameter of the distribution.
       */
      _RealType
      b() const
      { return _M_param.b(); }

      /**
       * @brief Returns the parameter set of the distribution.
       */
      param_type
      param() const
      { return _M_param; }

      /**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       */
      void
      param(const param_type& __param)
      { _M_param = __param; }

      /**
       * @brief Returns the greatest lower bound value of the distribution.
       */
      result_type
      min() const
      { return std::numeric_limits<result_type>::lowest(); }

      /**
       * @brief Returns the least upper bound value of the distribution.
       */
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }

      /**
       * @brief Generating functions.
       */
      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng)
	{ return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p);

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      /**
       * @brief Return true if two extreme value distributions have the same
       *        parameters.
       */
      friend bool
      operator==(const extreme_value_distribution& __d1,
		 const extreme_value_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      param_type _M_param;
    };

  /**
    * @brief Return true if two extreme value distributions have different
    *        parameters.
   */
  template<typename _RealType>
    inline bool
    operator!=(const std::extreme_value_distribution<_RealType>& __d1,
	       const std::extreme_value_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }

  /**
   * @brief Inserts a %extreme_value_distribution random number distribution
   * @p __x into the output stream @p __os.
   *
   * @param __os An output stream.
   * @param __x  A %extreme_value_distribution random number distribution.
   *
   * @returns The output stream with the state of @p __x inserted or in
   * an error state.
   */
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const std::extreme_value_distribution<_RealType>& __x);

  /**
   * @brief Extracts a %extreme_value_distribution random number
   *        distribution @p __x from the input stream @p __is.
   *
   * @param __is An input stream.
   * @param __x A %extreme_value_distribution random number
   *            generator engine.
   *
   * @returns The input stream with @p __x extracted or in an error state.
   */
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       std::extreme_value_distribution<_RealType>& __x);


  /**
   * @brief A discrete_distribution random number distribution.
   *
   * The formula for the discrete probability mass function is
   *
   */
  template<typename _IntType = int>
    class discrete_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
		    "template argument not an integral type");

    public:
      /** The type of the range of the distribution. */
      typedef _IntType result_type;
      /** Parameter type. */
      struct param_type
      {
	typedef discrete_distribution<_IntType> distribution_type;
	friend class discrete_distribution<_IntType>;

	param_type()
	: _M_prob(), _M_cp()
	{ }

	template<typename _InputIterator>
	  param_type(_InputIterator __wbegin,
		     _InputIterator __wend)
	  : _M_prob(__wbegin, __wend), _M_cp()
	  { _M_initialize(); }

	param_type(initializer_list<double> __wil)
	: _M_prob(__wil.begin(), __wil.end()), _M_cp()
	{ _M_initialize(); }

	template<typename _Func>
	  param_type(size_t __nw, double __xmin, double __xmax,
		     _Func __fw);

	// See: http://cpp-next.com/archive/2010/10/implicit-move-must-go/
	param_type(const param_type&) = default;
	param_type& operator=(const param_type&) = default;

	std::vector<double>
	probabilities() const
	{ return _M_prob.empty() ? std::vector<double>(1, 1.0) : _M_prob; }

	friend bool
	operator==(const param_type& __p1, const param_type& __p2)
	{ return __p1._M_prob == __p2._M_prob; }

      private:
	void
	_M_initialize();

	std::vector<double> _M_prob;
	std::vector<double> _M_cp;
      };

      discrete_distribution()
      : _M_param()
      { }

      template<typename _InputIterator>
	discrete_distribution(_InputIterator __wbegin,
			      _InputIterator __wend)
	: _M_param(__wbegin, __wend)
	{ }

      discrete_distribution(initializer_list<double> __wl)
      : _M_param(__wl)
      { }

      template<typename _Func>
	discrete_distribution(size_t __nw, double __xmin, double __xmax,
			      _Func __fw)
	: _M_param(__nw, __xmin, __xmax, __fw)
	{ }

      explicit
      discrete_distribution(const param_type& __p)
      : _M_param(__p)
      { }

      /**
       * @brief Resets the distribution state.
       */
      void
      reset()
      { }

      /**
       * @brief Returns the probabilities of the distribution.
       */
      std::vector<double>
      probabilities() const
      {
	return _M_param._M_prob.empty()
	  ? std::vector<double>(1, 1.0) : _M_param._M_prob;
      }

      /**
       * @brief Returns the parameter set of the distribution.
       */
      param_type
      param() const
      { return _M_param; }

      /**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       */
      void
      param(const param_type& __param)
      { _M_param = __param; }

      /**
       * @brief Returns the greatest lower bound value of the distribution.
       */
      result_type
      min() const
      { return result_type(0); }

      /**
       * @brief Returns the least upper bound value of the distribution.
       */
      result_type
      max() const
      {
	return _M_param._M_prob.empty()
	  ? result_type(0) : result_type(_M_param._M_prob.size() - 1);
      }

      /**
       * @brief Generating functions.
       */
      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng)
	{ return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p);

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      /**
       * @brief Return true if two discrete distributions have the same
       *        parameters.
       */
      friend bool
      operator==(const discrete_distribution& __d1,
		 const discrete_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

      /**
       * @brief Inserts a %discrete_distribution random number distribution
       * @p __x into the output stream @p __os.
       *
       * @param __os An output stream.
       * @param __x  A %discrete_distribution random number distribution.
       *
       * @returns The output stream with the state of @p __x inserted or in
       * an error state.
       */
      template<typename _IntType1, typename _CharT, typename _Traits>
	friend std::basic_ostream<_CharT, _Traits>&
	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
		   const std::discrete_distribution<_IntType1>& __x);

      /**
       * @brief Extracts a %discrete_distribution random number distribution
       * @p __x from the input stream @p __is.
       *
       * @param __is An input stream.
       * @param __x A %discrete_distribution random number
       *            generator engine.
       *
       * @returns The input stream with @p __x extracted or in an error
       *          state.
       */
      template<typename _IntType1, typename _CharT, typename _Traits>
	friend std::basic_istream<_CharT, _Traits>&
	operator>>(std::basic_istream<_CharT, _Traits>& __is,
		   std::discrete_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      param_type _M_param;
    };

  /**
    * @brief Return true if two discrete distributions have different
    *        parameters.
    */
  template<typename _IntType>
    inline bool
    operator!=(const std::discrete_distribution<_IntType>& __d1,
	       const std::discrete_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }


  /**
   * @brief A piecewise_constant_distribution random number distribution.
   *
   * The formula for the piecewise constant probability mass function is
   *
   */
  template<typename _RealType = double>
    class piecewise_constant_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
		    "template argument not a floating point type");

    public:
      /** The type of the range of the distribution. */
      typedef _RealType result_type;
      /** Parameter type. */
      struct param_type
      {
	typedef piecewise_constant_distribution<_RealType> distribution_type;
	friend class piecewise_constant_distribution<_RealType>;

	param_type()
	: _M_int(), _M_den(), _M_cp()
	{ }

	template<typename _InputIteratorB, typename _InputIteratorW>
	  param_type(_InputIteratorB __bfirst,
		     _InputIteratorB __bend,
		     _InputIteratorW __wbegin);

	template<typename _Func>
	  param_type(initializer_list<_RealType> __bi, _Func __fw);

	template<typename _Func>
	  param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
		     _Func __fw);

	// See: http://cpp-next.com/archive/2010/10/implicit-move-must-go/
	param_type(const param_type&) = default;
	param_type& operator=(const param_type&) = default;

	std::vector<_RealType>
	intervals() const
	{
	  if (_M_int.empty())
	    {
	      std::vector<_RealType> __tmp(2);
	      __tmp[1] = _RealType(1);
	      return __tmp;
	    }
	  else
	    return _M_int;
	}

	std::vector<double>
	densities() const
	{ return _M_den.empty() ? std::vector<double>(1, 1.0) : _M_den; }

	friend bool
	operator==(const param_type& __p1, const param_type& __p2)
	{ return __p1._M_int == __p2._M_int && __p1._M_den == __p2._M_den; }

      private:
	void
	_M_initialize();

	std::vector<_RealType> _M_int;
	std::vector<double> _M_den;
	std::vector<double> _M_cp;
      };

      explicit
      piecewise_constant_distribution()
      : _M_param()
      { }

      template<typename _InputIteratorB, typename _InputIteratorW>
	piecewise_constant_distribution(_InputIteratorB __bfirst,
					_InputIteratorB __bend,
					_InputIteratorW __wbegin)
	: _M_param(__bfirst, __bend, __wbegin)
	{ }

      template<typename _Func>
	piecewise_constant_distribution(initializer_list<_RealType> __bl,
					_Func __fw)
	: _M_param(__bl, __fw)
	{ }

      template<typename _Func>
	piecewise_constant_distribution(size_t __nw,
					_RealType __xmin, _RealType __xmax,
					_Func __fw)
	: _M_param(__nw, __xmin, __xmax, __fw)
	{ }

      explicit
      piecewise_constant_distribution(const param_type& __p)
      : _M_param(__p)
      { }

      /**
       * @brief Resets the distribution state.
       */
      void
      reset()
      { }

      /**
       * @brief Returns a vector of the intervals.
       */
      std::vector<_RealType>
      intervals() const
      {
	if (_M_param._M_int.empty())
	  {
	    std::vector<_RealType> __tmp(2);
	    __tmp[1] = _RealType(1);
	    return __tmp;
	  }
	else
	  return _M_param._M_int;
      }

      /**
       * @brief Returns a vector of the probability densities.
       */
      std::vector<double>
      densities() const
      {
	return _M_param._M_den.empty()
	  ? std::vector<double>(1, 1.0) : _M_param._M_den;
      }

      /**
       * @brief Returns the parameter set of the distribution.
       */
      param_type
      param() const
      { return _M_param; }

      /**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       */
      void
      param(const param_type& __param)
      { _M_param = __param; }

      /**
       * @brief Returns the greatest lower bound value of the distribution.
       */
      result_type
      min() const
      {
	return _M_param._M_int.empty()
	  ? result_type(0) : _M_param._M_int.front();
      }

      /**
       * @brief Returns the least upper bound value of the distribution.
       */
      result_type
      max() const
      {
	return _M_param._M_int.empty()
	  ? result_type(1) : _M_param._M_int.back();
      }

      /**
       * @brief Generating functions.
       */
      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng)
	{ return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p);

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      /**
       * @brief Return true if two piecewise constant distributions have the
       *        same parameters.
       */
      friend bool
      operator==(const piecewise_constant_distribution& __d1,
		 const piecewise_constant_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

      /**
       * @brief Inserts a %piecewise_constant_distribution random
       *        number distribution @p __x into the output stream @p __os.
       *
       * @param __os An output stream.
       * @param __x  A %piecewise_constant_distribution random number
       *             distribution.
       *
       * @returns The output stream with the state of @p __x inserted or in
       * an error state.
       */
      template<typename _RealType1, typename _CharT, typename _Traits>
	friend std::basic_ostream<_CharT, _Traits>&
	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
		   const std::piecewise_constant_distribution<_RealType1>& __x);

      /**
       * @brief Extracts a %piecewise_constant_distribution random
       *        number distribution @p __x from the input stream @p __is.
       *
       * @param __is An input stream.
       * @param __x A %piecewise_constant_distribution random number
       *            generator engine.
       *
       * @returns The input stream with @p __x extracted or in an error
       *          state.
       */
      template<typename _RealType1, typename _CharT, typename _Traits>
	friend std::basic_istream<_CharT, _Traits>&
	operator>>(std::basic_istream<_CharT, _Traits>& __is,
		   std::piecewise_constant_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      param_type _M_param;
    };

  /**
    * @brief Return true if two piecewise constant distributions have 
    *        different parameters.
   */
  template<typename _RealType>
    inline bool
    operator!=(const std::piecewise_constant_distribution<_RealType>& __d1,
	       const std::piecewise_constant_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }


  /**
   * @brief A piecewise_linear_distribution random number distribution.
   *
   * The formula for the piecewise linear probability mass function is
   *
   */
  template<typename _RealType = double>
    class piecewise_linear_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
		    "template argument not a floating point type");

    public:
      /** The type of the range of the distribution. */
      typedef _RealType result_type;
      /** Parameter type. */
      struct param_type
      {
	typedef piecewise_linear_distribution<_RealType> distribution_type;
	friend class piecewise_linear_distribution<_RealType>;

	param_type()
	: _M_int(), _M_den(), _M_cp(), _M_m()
	{ }

	template<typename _InputIteratorB, typename _InputIteratorW>
	  param_type(_InputIteratorB __bfirst,
		     _InputIteratorB __bend,
		     _InputIteratorW __wbegin);

	template<typename _Func>
	  param_type(initializer_list<_RealType> __bl, _Func __fw);

	template<typename _Func>
	  param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
		     _Func __fw);

	// See: http://cpp-next.com/archive/2010/10/implicit-move-must-go/
	param_type(const param_type&) = default;
	param_type& operator=(const param_type&) = default;

	std::vector<_RealType>
	intervals() const
	{
	  if (_M_int.empty())
	    {
	      std::vector<_RealType> __tmp(2);
	      __tmp[1] = _RealType(1);
	      return __tmp;
	    }
	  else
	    return _M_int;
	}

	std::vector<double>
	densities() const
	{ return _M_den.empty() ? std::vector<double>(2, 1.0) : _M_den; }

	friend bool
	operator==(const param_type& __p1, const param_type& __p2)
	{ return (__p1._M_int == __p2._M_int
		  && __p1._M_den == __p2._M_den); }

      private:
	void
	_M_initialize();

	std::vector<_RealType> _M_int;
	std::vector<double> _M_den;
	std::vector<double> _M_cp;
	std::vector<double> _M_m;
      };

      explicit
      piecewise_linear_distribution()
      : _M_param()
      { }

      template<typename _InputIteratorB, typename _InputIteratorW>
	piecewise_linear_distribution(_InputIteratorB __bfirst,
				      _InputIteratorB __bend,
				      _InputIteratorW __wbegin)
	: _M_param(__bfirst, __bend, __wbegin)
	{ }

      template<typename _Func>
	piecewise_linear_distribution(initializer_list<_RealType> __bl,
				      _Func __fw)
	: _M_param(__bl, __fw)
	{ }

      template<typename _Func>
	piecewise_linear_distribution(size_t __nw,
				      _RealType __xmin, _RealType __xmax,
				      _Func __fw)
	: _M_param(__nw, __xmin, __xmax, __fw)
	{ }

      explicit
      piecewise_linear_distribution(const param_type& __p)
      : _M_param(__p)
      { }

      /**
       * Resets the distribution state.
       */
      void
      reset()
      { }

      /**
       * @brief Return the intervals of the distribution.
       */
      std::vector<_RealType>
      intervals() const
      {
	if (_M_param._M_int.empty())
	  {
	    std::vector<_RealType> __tmp(2);
	    __tmp[1] = _RealType(1);
	    return __tmp;
	  }
	else
	  return _M_param._M_int;
      }

      /**
       * @brief Return a vector of the probability densities of the
       *        distribution.
       */
      std::vector<double>
      densities() const
      {
	return _M_param._M_den.empty()
	  ? std::vector<double>(2, 1.0) : _M_param._M_den;
      }

      /**
       * @brief Returns the parameter set of the distribution.
       */
      param_type
      param() const
      { return _M_param; }

      /**
       * @brief Sets the parameter set of the distribution.
       * @param __param The new parameter set of the distribution.
       */
      void
      param(const param_type& __param)
      { _M_param = __param; }

      /**
       * @brief Returns the greatest lower bound value of the distribution.
       */
      result_type
      min() const
      {
	return _M_param._M_int.empty()
	  ? result_type(0) : _M_param._M_int.front();
      }

      /**
       * @brief Returns the least upper bound value of the distribution.
       */
      result_type
      max() const
      {
	return _M_param._M_int.empty()
	  ? result_type(1) : _M_param._M_int.back();
      }

      /**
       * @brief Generating functions.
       */
      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng)
	{ return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
	result_type
	operator()(_UniformRandomNumberGenerator& __urng,
		   const param_type& __p);

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng)
	{ this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate(_ForwardIterator __f, _ForwardIterator __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
	void
	__generate(result_type* __f, result_type* __t,
		   _UniformRandomNumberGenerator& __urng,
		   const param_type& __p)
	{ this->__generate_impl(__f, __t, __urng, __p); }

      /**
       * @brief Return true if two piecewise linear distributions have the
       *        same parameters.
       */
      friend bool
      operator==(const piecewise_linear_distribution& __d1,
		 const piecewise_linear_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

      /**
       * @brief Inserts a %piecewise_linear_distribution random number
       *        distribution @p __x into the output stream @p __os.
       *
       * @param __os An output stream.
       * @param __x  A %piecewise_linear_distribution random number
       *             distribution.
       *
       * @returns The output stream with the state of @p __x inserted or in
       *          an error state.
       */
      template<typename _RealType1, typename _CharT, typename _Traits>
	friend std::basic_ostream<_CharT, _Traits>&
	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
		   const std::piecewise_linear_distribution<_RealType1>& __x);

      /**
       * @brief Extracts a %piecewise_linear_distribution random number
       *        distribution @p __x from the input stream @p __is.
       *
       * @param __is An input stream.
       * @param __x  A %piecewise_linear_distribution random number
       *             generator engine.
       *
       * @returns The input stream with @p __x extracted or in an error
       *          state.
       */
      template<typename _RealType1, typename _CharT, typename _Traits>
	friend std::basic_istream<_CharT, _Traits>&
	operator>>(std::basic_istream<_CharT, _Traits>& __is,
		   std::piecewise_linear_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
	       typename _UniformRandomNumberGenerator>
	void
	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
			_UniformRandomNumberGenerator& __urng,
			const param_type& __p);

      param_type _M_param;
    };

  /**
    * @brief Return true if two piecewise linear distributions have
    *        different parameters.
   */
  template<typename _RealType>
    inline bool
    operator!=(const std::piecewise_linear_distribution<_RealType>& __d1,
	       const std::piecewise_linear_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }


  /* @} */ // group random_distributions_poisson

  /* @} */ // group random_distributions

  /**
   * @addtogroup random_utilities Random Number Utilities
   * @ingroup random
   * @{
   */

  /**
   * @brief The seed_seq class generates sequences of seeds for random
   *        number generators.
   */
  class seed_seq
  {

  public:
    /** The type of the seed vales. */
    typedef uint_least32_t result_type;

    /** Default constructor. */
    seed_seq()
    : _M_v()
    { }

    template<typename _IntType>
      seed_seq(std::initializer_list<_IntType> il);

    template<typename _InputIterator>
      seed_seq(_InputIterator __begin, _InputIterator __end);

    // generating functions
    template<typename _RandomAccessIterator>
      void
      generate(_RandomAccessIterator __begin, _RandomAccessIterator __end);

    // property functions
    size_t size() const
    { return _M_v.size(); }

    template<typename OutputIterator>
      void
      param(OutputIterator __dest) const
      { std::copy(_M_v.begin(), _M_v.end(), __dest); }

  private:
    ///
    std::vector<result_type> _M_v;
  };

  /* @} */ // group random_utilities

  /* @} */ // group random

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    // Algorithm implementation -*- C++ -*-

// Copyright (C) 2001-2014 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_algo.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 */

#ifndef _STL_ALGO_H
#define _STL_ALGO_H 1

#include <cstdlib>             // for rand
#include <bits/algorithmfwd.h>
#include <bits/stl_heap.h>
#include <bits/stl_tempbuf.h>  // for _Temporary_buffer
#include <bits/predefined_ops.h>

#if __cplusplus >= 201103L
#include <random>     // for std::uniform_int_distribution
#endif

// See concept_check.h for the __glibcxx_*_requires macros.

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
			   _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
	{
	  if (__comp(__b, __c))
	    std::iter_swap(__result, __b);
	  else if (__comp(__a, __c))
	    std::iter_swap(__result, __c);
	  else
	    std::iter_swap(__result, __a);
	}
      else if (__comp(__a, __c))
	std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
	std::iter_swap(__result, __c);
      else
	std::iter_swap(__result, __b);
    }

  /// This is an overload used by find algos for the Input Iterator case.
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
	      _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
	++__first;
      return __first;
    }

  /// This is an overload used by find algos for the RAI case.
  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
	      _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
	__trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
	{
	  if (__pred(__first))
	    return __first;
	  ++__first;

	  if (__pred(__first))
	    return __first;
	  ++__first;

	  if (__pred(__first))
	    return __first;
	  ++__first;

	  if (__pred(__first))
	    return __first;
	  ++__first;
	}

      switch (__last - __first)
	{
	case 3:
	  if (__pred(__first))
	    return __first;
	  ++__first;
	case 2:
	  if (__pred(__first))
	    return __first;
	  ++__first;
	case 1:
	  if (__pred(__first))
	    return __first;
	  ++__first;
	case 0:
	default:
	  return __last;
	}
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
		       std::__iterator_category(__first));
    }

  /// Provided for stable_partition to use.
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
		  _Predicate __pred)
    {
      return std::__find_if(__first, __last,
			    __gnu_cxx::__ops::__negate(__pred),
			    std::__iterator_category(__first));
    }

  /// Like find_if_not(), but uses and updates a count of the
  /// remaining range length instead of comparing against an end
  /// iterator.
  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
	if (!__pred(__first))
	  break;
      return __first;
    }

  // set_difference
  // set_intersection
  // set_symmetric_difference
  // set_union
  // for_each
  // find
  // find_if
  // find_first_of
  // adjacent_find
  // count
  // count_if
  // search

  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
	     _BinaryPredicate  __predicate)
    {
      // Test for empty ranges
      if (__first1 == __last1 || __first2 == __last2)
	return __first1;

      // Test for a pattern of length 1.
      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
	return std::__find_if(__first1, __last1,
		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

      // General case.
      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
	{
	  __first1 =
	    std::__find_if(__first1, __last1,
		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

	  if (__first1 == __last1)
	    return __last1;

	  __p = __p1;
	  __current = __first1;
	  if (++__current == __last1)
	    return __last1;

	  while (__predicate(__current, __p))
	    {
	      if (++__p == __last2)
		return __first1;
	      if (++__current == __last1)
		return __last1;
	    }
	  ++__first1;
	}
      return __first1;
    }

  // search_n

  /**
   *  This is an helper function for search_n overloaded for forward iterators.
  */
  template<typename _ForwardIterator, typename _Integer,
	   typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
		   _Integer __count, _UnaryPredicate __unary_pred,
		   std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
	{
	  typename iterator_traits<_ForwardIterator>::difference_type
	    __n = __count;
	  _ForwardIterator __i = __first;
	  ++__i;
	  while (__i != __last && __n != 1 && __unary_pred(__i))
	    {
	      ++__i;
	      --__n;
	    }
	  if (__n == 1)
	    return __first;
	  if (__i == __last)
	    return __last;
	  __first = std::__find_if(++__i, __last, __unary_pred);
	}
      return __last;
    }

  /**
   *  This is an helper function for search_n overloaded for random access
   *  iterators.
  */
  template<typename _RandomAccessIter, typename _Integer,
	   typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
		   _Integer __count, _UnaryPredicate __unary_pred,
		   std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
	_DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize) // the main loop...
	{
	  __first += __remainder;
	  __tailSize -= __remainder;
	  // __first here is always pointing to one past the last element of
	  // next possible match.
	  _RandomAccessIter __backTrack = __first; 
	  while (__unary_pred(--__backTrack))
	    {
	      if (--__remainder == 0)
	        return (__first - __count); // Success
	    }
	  __remainder = __count + 1 - (__first - __backTrack);
	}
      return __last; // Failure
    }

  template<typename _ForwardIterator, typename _Integer,
           typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
	       _Integer __count,
	       _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
	return __first;

      if (__count == 1)
	return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
				 std::__iterator_category(__first));
    }

  // find_end for forward iterators.
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
	       forward_iterator_tag, forward_iterator_tag,
	       _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
	return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
	{
	  _ForwardIterator1 __new_result
	    = std::__search(__first1, __last1, __first2, __last2, __comp);
	  if (__new_result == __last1)
	    return __result;
	  else
	    {
	      __result = __new_result;
	      __first1 = __new_result;
	      ++__first1;
	    }
	}
    }

  // find_end for bidirectional iterators (much faster).
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
	   typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
	       _BidirectionalIterator1 __last1,
	       _BidirectionalIterator2 __first2,
	       _BidirectionalIterator2 __last2,
	       bidirectional_iterator_tag, bidirectional_iterator_tag,
	       _BinaryPredicate __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator1>)
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator2>)

      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
					      _RevIterator2(__last2), __rlast2,
					      __comp);

      if (__rresult == __rlast1)
	return __last1;
      else
	{
	  _BidirectionalIterator1 __result = __rresult.base();
	  std::advance(__result, -std::distance(__first2, __last2));
	  return __result;
	}
    }

  /**
   *  @brief  Find last matching subsequence in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of sequence to match.
   *  @param  __last2   End of sequence to match.
   *  @return   The last iterator @c i in the range
   *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
   *  @p *(__first2+N) for each @c N in the range @p
   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) and returns an iterator to the __first
   *  element of the sub-sequence, or @p __last1 if the sub-sequence
   *  is not found.  The sub-sequence will be the last such
   *  subsequence contained in [__first1,__last1).
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.  This means that the returned
   *  iterator @c i will be in the range @p
   *  [__first1,__last1-(__last2-__first2))
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_ForwardIterator1>::value_type,
	    typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__find_end(__first1, __last1, __first2, __last2,
			     std::__iterator_category(__first1),
			     std::__iterator_category(__first2),
			     __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief  Find last matching subsequence in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of sequence to match.
   *  @param  __last2   End of sequence to match.
   *  @param  __comp    The predicate to use.
   *  @return The last iterator @c i in the range @p
   *  [__first1,__last1-(__last2-__first2)) such that @c
   *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
   *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
   *  exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) using comp as a predicate and returns an
   *  iterator to the first element of the sub-sequence, or @p __last1
   *  if the sub-sequence is not found.  The sub-sequence will be the
   *  last such subsequence contained in [__first,__last1).
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.  This means that the returned
   *  iterator @c i will be in the range @p
   *  [__first1,__last1-(__last2-__first2))
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
	     _BinaryPredicate __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_ForwardIterator1>::value_type,
	    typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__find_end(__first1, __last1, __first2, __last2,
			     std::__iterator_category(__first1),
			     std::__iterator_category(__first2),
			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

#if __cplusplus >= 201103L
  /**
   *  @brief  Checks that a predicate is true for all the elements
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if @p __pred is true for each element in the range
   *  @p [__first,__last), and false otherwise.
  */
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }

  /**
   *  @brief  Checks that a predicate is false for all the elements
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if @p __pred is false for each element in the range
   *  @p [__first,__last), and false otherwise.
  */
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == _GLIBCXX_STD_A::find_if(__first, __last, __pred); }

  /**
   *  @brief  Checks that a predicate is false for at least an element
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if an element exists in the range @p
   *  [__first,__last) such that @p __pred is true, and false
   *  otherwise.
  */
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }

  /**
   *  @brief  Find the first element in a sequence for which a
   *          predicate is false.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
  */
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
		_Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	      typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);
      return std::__find_if_not(__first, __last,
				__gnu_cxx::__ops::__pred_iter(__pred));
    }

  /**
   *  @brief  Checks whether the sequence is partitioned.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
   *  i.e. if all elements that satisfy @p __pred appear before those that
   *  do not.
  */
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
		   _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }

  /**
   *  @brief  Find the partition point of a partitioned range.
   *  @ingroup mutating_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __pred    A predicate.
   *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
   *           and @p none_of(mid, __last, __pred) are both true.
  */
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
		    _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	      typename iterator_traits<_ForwardIterator>::value_type>)

      // A specific debug-mode test will be necessary...
      __glibcxx_requires_valid_range(__first, __last);

      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
	{
	  __half = __len >> 1;
	  __middle = __first;
	  std::advance(__middle, __half);
	  if (__pred(*__middle))
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
	    }
	  else
	    __len = __half;
	}
      return __first;
    }
#endif

  template<typename _InputIterator, typename _OutputIterator,
	   typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
		     _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
	if (!__pred(__first))
	  {
	    *__result = *__first;
	    ++__result;
	  }
      return __result;
    }

  /**
   *  @brief Copy a sequence, removing elements of a given value.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __value   The value to be removed.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) not equal
   *  to @p __value to the range beginning at @p __result.
   *  remove_copy() is stable, so the relative order of elements that
   *  are copied is unchanged.
  */
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
		_OutputIterator __result, const _Tp& __value)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__remove_copy_if(__first, __last, __result,
	__gnu_cxx::__ops::__iter_equals_val(__value));
    }

  /**
   *  @brief Copy a sequence, removing elements for which a predicate is true.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns false to the range beginning at @p __result.
   *
   *  remove_copy_if() is stable, so the relative order of elements that are
   *  copied is unchanged.
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
		   _OutputIterator __result, _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__remove_copy_if(__first, __last, __result,
				   __gnu_cxx::__ops::__pred_iter(__pred));
    }

#if __cplusplus >= 201103L
  /**
   *  @brief Copy the elements of a sequence for which a predicate is true.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns true to the range beginning at @p __result.
   *
   *  copy_if() is stable, so the relative order of elements that are
   *  copied is unchanged.
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
	    _OutputIterator __result, _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first)
	if (__pred(*__first))
	  {
	    *__result = *__first;
	    ++__result;
	  }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
	     _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
	{
	  while (true)
	    {
	      *__result = *__first;
	      ++__result;
	      if (--__n > 0)
		++__first;
	      else
		break;
	    }
	}
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
	   typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
	     _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }

  /**
   *  @brief Copies the range [first,first+n) into [result,result+n).
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __n      The number of elements to copy.
   *  @param  __result An output iterator.
   *  @return  result+n.
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
  */
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)

      return std::__copy_n(__first, __n, __result,
			   std::__iterator_category(__first));
    }

  /**
   *  @brief Copy the elements of a sequence to separate output sequences
   *         depending on the truth value of a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __out_true   An output iterator.
   *  @param  __out_false  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   A pair designating the ends of the resulting sequences.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns true to the range beginning at @p out_true
   *  and each element for which @p __pred returns false to @p __out_false.
  */
  template<typename _InputIterator, typename _OutputIterator1,
	   typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
		   _OutputIterator1 __out_true, _OutputIterator2 __out_false,
		   _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator1,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator2,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);
      
      for (; __first != __last; ++__first)
	if (__pred(*__first))
	  {
	    *__out_true = *__first;
	    ++__out_true;
	  }
	else
	  {
	    *__out_false = *__first;
	    ++__out_false;
	  }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }
#endif

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
		_Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
        if (!__pred(__first))
          {
            *__result = _GLIBCXX_MOVE(*__first);
            ++__result;
          }
      return __result;
    }

  /**
   *  @brief Remove elements from a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __value  The value to be removed.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  All elements equal to @p __value are removed from the range
   *  @p [__first,__last).
   *
   *  remove() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
	   const _Tp& __value)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__remove_if(__first, __last,
		__gnu_cxx::__ops::__iter_equals_val(__value));
    }

  /**
   *  @brief Remove elements from a sequence using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __pred   A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  All elements for which @p __pred returns true are removed from the range
   *  @p [__first,__last).
   *
   *  remove_if() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
	      _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__remove_if(__first, __last,
			      __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
		    _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
	return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
	{
	  if (__binary_pred(__first, __next))
	    return __first;
	  __first = __next;
	}
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
	     _BinaryPredicate __binary_pred)
    {
      // Skip the beginning, if already unique.
      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
	return __last;

      // Do the real copy work.
      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
	if (!__binary_pred(__dest, __first))
	  *++__dest = _GLIBCXX_MOVE(*__first);
      return ++__dest;
    }

  /**
   *  @brief Remove consecutive duplicate values from a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Removes all but the first element from each group of consecutive
   *  values that compare equal.
   *  unique() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_EqualityComparableConcept<
		     typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__unique(__first, __last,
			   __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief Remove consecutive values from a sequence using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first        A forward iterator.
   *  @param  __last         A forward iterator.
   *  @param  __binary_pred  A binary predicate.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Removes all but the first element from each group of consecutive
   *  values for which @p __binary_pred returns true.
   *  unique() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
		typename iterator_traits<_ForwardIterator>::value_type,
		typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__unique(__first, __last,
			   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }

  /**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for forward iterators and output iterator as result.
  */
  template<typename _ForwardIterator, typename _OutputIterator,
	   typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
		  _OutputIterator __result, _BinaryPredicate __binary_pred,
		  forward_iterator_tag, output_iterator_tag)
    {
      // concept requirements -- iterators already checked
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	  typename iterator_traits<_ForwardIterator>::value_type,
	  typename iterator_traits<_ForwardIterator>::value_type>)

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
	if (!__binary_pred(__first, __next))
	  {
	    __first = __next;
	    *++__result = *__first;
	  }
      return ++__result;
    }

  /**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for input iterators and output iterator as result.
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
		  _OutputIterator __result, _BinaryPredicate __binary_pred,
		  input_iterator_tag, output_iterator_tag)
    {
      // concept requirements -- iterators already checked
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	  typename iterator_traits<_InputIterator>::value_type,
	  typename iterator_traits<_InputIterator>::value_type>)

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
	__rebound_pred
	= __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
	if (!__rebound_pred(__first, __value))
	  {
	    __value = *__first;
	    *++__result = __value;
	  }
      return ++__result;
    }

  /**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for input iterators and forward iterator as result.
  */
  template<typename _InputIterator, typename _ForwardIterator,
	   typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
		  _ForwardIterator __result, _BinaryPredicate __binary_pred,
		  input_iterator_tag, forward_iterator_tag)
    {
      // concept requirements -- iterators already checked
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	  typename iterator_traits<_ForwardIterator>::value_type,
	  typename iterator_traits<_InputIterator>::value_type>)
      *__result = *__first;
      while (++__first != __last)
	if (!__binary_pred(__result, __first))
	  *++__result = *__first;
      return ++__result;
    }

  /**
   *  This is an uglified reverse(_BidirectionalIterator,
   *                              _BidirectionalIterator)
   *  overloaded for bidirectional iterators.
  */
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
	      bidirectional_iterator_tag)
    {
      while (true)
	if (__first == __last || __first == --__last)
	  return;
	else
	  {
	    std::iter_swap(__first, __last);
	    ++__first;
	  }
    }

  /**
   *  This is an uglified reverse(_BidirectionalIterator,
   *                              _BidirectionalIterator)
   *  overloaded for random access iterators.
  */
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
	      random_access_iterator_tag)
    {
      if (__first == __last)
	return;
      --__last;
      while (__first < __last)
	{
	  std::iter_swap(__first, __last);
	  ++__first;
	  --__last;
	}
    }

  /**
   *  @brief Reverse a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A bidirectional iterator.
   *  @param  __last   A bidirectional iterator.
   *  @return   reverse() returns no value.
   *
   *  Reverses the order of the elements in the range @p [__first,__last),
   *  so that the first element becomes the last etc.
   *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
   *  swaps @p *(__first+i) and @p *(__last-(i+1))
  */
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_requires_valid_range(__first, __last);
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }

  /**
   *  @brief Copy a sequence, reversing its elements.
   *  @ingroup mutating_algorithms
   *  @param  __first   A bidirectional iterator.
   *  @param  __last    A bidirectional iterator.
   *  @param  __result  An output iterator.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Copies the elements in the range @p [__first,__last) to the
   *  range @p [__result,__result+(__last-__first)) such that the
   *  order of the elements is reversed.  For every @c i such that @p
   *  0<=i<=(__last-__first), @p reverse_copy() performs the
   *  assignment @p *(__result+(__last-__first)-1-i) = *(__first+i).
   *  The ranges @p [__first,__last) and @p
   *  [__result,__result+(__last-__first)) must not overlap.
  */
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
		 _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
		typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      while (__first != __last)
	{
	  --__last;
	  *__result = *__last;
	  ++__result;
	}
      return __result;
    }

  /**
   *  This is a helper function for the rotate algorithm specialized on RAIs.
   *  It returns the greatest common divisor of two integer values.
  */
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
	{
	  _EuclideanRingElement __t = __m % __n;
	  __m = __n;
	  __n = __t;
	}
      return __m;
    }

  /// This is a helper function for the rotate algorithm.
  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
	     _ForwardIterator __middle,
	     _ForwardIterator __last,
	     forward_iterator_tag)
    {
      if (__first == __middle || __last  == __middle)
	return;

      _ForwardIterator __first2 = __middle;
      do
	{
	  std::iter_swap(__first, __first2);
	  ++__first;
	  ++__first2;
	  if (__first == __middle)
	    __middle = __first2;
	}
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
	{
	  std::iter_swap(__first, __first2);
	  ++__first;
	  ++__first2;
	  if (__first == __middle)
	    __middle = __first2;
	  else if (__first2 == __last)
	    __first2 = __middle;
	}
    }

   /// This is a helper function for the rotate algorithm.
  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
	     _BidirectionalIterator __middle,
	     _BidirectionalIterator __last,
	      bidirectional_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)

      if (__first == __middle || __last  == __middle)
	return;

      std::__reverse(__first,  __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last,   bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
	{
	  std::iter_swap(__first, --__last);
	  ++__first;
	}

      if (__first == __middle)
	std::__reverse(__middle, __last,   bidirectional_iterator_tag());
      else
	std::__reverse(__first,  __middle, bidirectional_iterator_tag());
    }

  /// This is a helper function for the rotate algorithm.
  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
	     _RandomAccessIterator __middle,
	     _RandomAccessIterator __last,
	     random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)

      if (__first == __middle || __last  == __middle)
	return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	_ValueType;

      _Distance __n = __last   - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
	{
	  std::swap_ranges(__first, __middle, __middle);
	  return;
	}

      _RandomAccessIterator __p = __first;

      for (;;)
	{
	  if (__k < __n - __k)
	    {
	      if (__is_pod(_ValueType) && __k == 1)
		{
		  _ValueType __t = _GLIBCXX_MOVE(*__p);
		  _GLIBCXX_MOVE3(__p + 1, __p + __n, __p);
		  *(__p + __n - 1) = _GLIBCXX_MOVE(__t);
		  return;
		}
	      _RandomAccessIterator __q = __p + __k;
	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
		{
		  std::iter_swap(__p, __q);
		  ++__p;
		  ++__q;
		}
	      __n %= __k;
	      if (__n == 0)
		return;
	      std::swap(__n, __k);
	      __k = __n - __k;
	    }
	  else
	    {
	      __k = __n - __k;
	      if (__is_pod(_ValueType) && __k == 1)
		{
		  _ValueType __t = _GLIBCXX_MOVE(*(__p + __n - 1));
		  _GLIBCXX_MOVE_BACKWARD3(__p, __p + __n - 1, __p + __n);
		  *__p = _GLIBCXX_MOVE(__t);
		  return;
		}
	      _RandomAccessIterator __q = __p + __n;
	      __p = __q - __k;
	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
		{
		  --__p;
		  --__q;
		  std::iter_swap(__p, __q);
		}
	      __n %= __k;
	      if (__n == 0)
		return;
	      std::swap(__n, __k);
	    }
	}
    }

  /**
   *  @brief Rotate the elements of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __middle  A forward iterator.
   *  @param  __last    A forward iterator.
   *  @return  Nothing.
   *
   *  Rotates the elements of the range @p [__first,__last) by 
   *  @p (__middle - __first) positions so that the element at @p __middle
   *  is moved to @p __first, the element at @p __middle+1 is moved to
   *  @p __first+1 and so on for each element in the range
   *  @p [__first,__last).
   *
   *  This effectively swaps the ranges @p [__first,__middle) and
   *  @p [__middle,__last).
   *
   *  Performs
   *   @p *(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n)
   *  for each @p n in the range @p [0,__last-__first).
  */
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
	   _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_requires_valid_range(__first, __middle);
      __glibcxx_requires_valid_range(__middle, __last);

      std::__rotate(__first, __middle, __last,
		    std::__iterator_category(__first));
    }

  /**
   *  @brief Copy a sequence, rotating its elements.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __middle  A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __result  An output iterator.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies the elements of the range @p [__first,__last) to the
   *  range beginning at @result, rotating the copied elements by 
   *  @p (__middle-__first) positions so that the element at @p __middle
   *  is moved to @p __result, the element at @p __middle+1 is moved
   *  to @p __result+1 and so on for each element in the range @p
   *  [__first,__last).
   *
   *  Performs 
   *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
   *  for each @p n in the range @p [0,__last-__first).
  */
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
		typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __middle);
      __glibcxx_requires_valid_range(__middle, __last);

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }

  /// This is a helper function...
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
		_Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
	return __first;

      while (__pred(*__first))
	if (++__first == __last)
	  return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
	if (__pred(*__next))
	  {
	    std::iter_swap(__first, __next);
	    ++__first;
	  }

      return __first;
    }

  /// This is a helper function...
  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
		_Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
	{
	  while (true)
	    if (__first == __last)
	      return __first;
	    else if (__pred(*__first))
	      ++__first;
	    else
	      break;
	  --__last;
	  while (true)
	    if (__first == __last)
	      return __first;
	    else if (!bool(__pred(*__last)))
	      --__last;
	    else
	      break;
	  std::iter_swap(__first, __last);
	  ++__first;
	}
    }

  // partition

  /// This is a helper function...
  /// Requires __len != 0 and !__pred(*__first),
  /// same as __stable_partition_adaptive.
  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
			       _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
	return __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
	std::__inplace_stable_partition(__first, __pred, __len / 2);
      // Advance past true-predicate values to satisfy this
      // function's preconditions.
      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
	std::__find_if_not_n(__middle, __right_len, __pred);
      if (__right_len)
	__right_split = std::__inplace_stable_partition(__middle,
							__pred,
							__right_len);
      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  /// This is a helper function...
  /// Requires __first != __last and !__pred(__first)
  /// and __len == distance(__first, __last).
  ///
  /// !__pred(__first) allows us to guarantee that we don't
  /// move-assign an element onto itself.
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
	   typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
				_ForwardIterator __last,
				_Predicate __pred, _Distance __len,
				_Pointer __buffer,
				_Distance __buffer_size)
    {
      if (__len <= __buffer_size)
	{
	  _ForwardIterator __result1 = __first;
	  _Pointer __result2 = __buffer;
	  // The precondition guarantees that !__pred(__first), so
	  // move that element to the buffer before starting the loop.
	  // This ensures that we only call __pred once per element.
	  *__result2 = _GLIBCXX_MOVE(*__first);
	  ++__result2;
	  ++__first;
	  for (; __first != __last; ++__first)
	    if (__pred(__first))
	      {
		*__result1 = _GLIBCXX_MOVE(*__first);
		++__result1;
	      }
	    else
	      {
		*__result2 = _GLIBCXX_MOVE(*__first);
		++__result2;
	      }
	  _GLIBCXX_MOVE3(__buffer, __result2, __result1);
	  return __result1;
	}
      else
	{
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __len / 2);
	  _ForwardIterator __left_split =
	    std::__stable_partition_adaptive(__first, __middle, __pred,
					     __len / 2, __buffer,
					     __buffer_size);
	  // Advance past true-predicate values to satisfy this
	  // function's preconditions.
	  _Distance __right_len = __len - __len / 2;
	  _ForwardIterator __right_split =
	    std::__find_if_not_n(__middle, __right_len, __pred);
	  if (__right_len)
	    __right_split =
	      std::__stable_partition_adaptive(__right_split, __last, __pred,
					       __right_len,
					       __buffer, __buffer_size);
	  std::rotate(__left_split, __middle, __right_split);
	  std::advance(__left_split, std::distance(__middle, __right_split));
	  return __left_split;
	}
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
		       _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
	return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      if (__buf.size() > 0)
	return
	  std::__stable_partition_adaptive(__first, __last, __pred,
					   _DistanceType(__buf.requested_size()),
					   __buf.begin(),
					   _DistanceType(__buf.size()));
      else
	return
	  std::__inplace_stable_partition(__first, __pred,
					  _DistanceType(__buf.requested_size()));
    }

  /**
   *  @brief Move elements for which a predicate is true to the beginning
   *         of a sequence, preserving relative ordering.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __pred    A predicate functor.
   *  @return  An iterator @p middle such that @p __pred(i) is true for each
   *  iterator @p i in the range @p [first,middle) and false for each @p i
   *  in the range @p [middle,last).
   *
   *  Performs the same function as @p partition() with the additional
   *  guarantee that the relative ordering of elements in each group is
   *  preserved, so any two elements @p x and @p y in the range
   *  @p [__first,__last) such that @p __pred(x)==__pred(y) will have the same
   *  relative ordering after calling @p stable_partition().
  */
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
		     _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__stable_partition(__first, __last,
				     __gnu_cxx::__ops::__pred_iter(__pred));
    }

  /// This is a helper function for the sort routines.
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
		  _RandomAccessIterator __middle,
		  _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
	if (__comp(__i, __first))
	  std::__pop_heap(__first, __middle, __i, __comp);
    }

  // partial_sort

  template<typename _InputIterator, typename _RandomAccessIterator,
	   typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
			_RandomAccessIterator __result_first,
			_RandomAccessIterator __result_last,
			_Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
	_InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
	return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
	{
	  *__result_real_last = *__first;
	  ++__result_real_last;
	  ++__first;
	}
      
      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
	{
	  if (__comp(__first, __result_first))
	    std::__adjust_heap(__result_first, _DistanceType(0),
			       _DistanceType(__result_real_last
					     - __result_first),
			       _InputValueType(*__first), __comp);
	  ++__first;
	}
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }

  /**
   *  @brief Copy the smallest elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __result_first   A random-access iterator.
   *  @param  __result_last    Another random-access iterator.
   *  @return   An iterator indicating the end of the resulting sequence.
   *
   *  Copies and sorts the smallest N values from the range @p [__first,__last)
   *  to the range beginning at @p __result_first, where the number of
   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
   *  @p (__result_last-__result_first).
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__result_first,__result_first+N) such that i precedes j then
   *  *j<*i is false.
   *  The value returned is @p __result_first+N.
  */
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
		      _RandomAccessIterator __result_first,
		      _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
	_InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	_OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_DistanceType;

      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
				  _OutputValueType>)
      __glibcxx_function_requires(_LessThanOpConcept<_InputValueType,
				                     _OutputValueType>)
      __glibcxx_function_requires(_LessThanComparableConcept<_OutputValueType>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_valid_range(__result_first, __result_last);

      return std::__partial_sort_copy(__first, __last,
				      __result_first, __result_last,
				      __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Copy the smallest elements of a sequence using a predicate for
   *         comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    Another input iterator.
   *  @param  __result_first   A random-access iterator.
   *  @param  __result_last    Another random-access iterator.
   *  @param  __comp    A comparison functor.
   *  @return   An iterator indicating the end of the resulting sequence.
   *
   *  Copies and sorts the smallest N values from the range @p [__first,__last)
   *  to the range beginning at @p result_first, where the number of
   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
   *  @p (__result_last-__result_first).
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__result_first,__result_first+N) such that i precedes j then
   *  @p __comp(*j,*i) is false.
   *  The value returned is @p __result_first+N.
  */
  template<typename _InputIterator, typename _RandomAccessIterator,
	   typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
		      _RandomAccessIterator __result_first,
		      _RandomAccessIterator __result_last,
		      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
	_InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	_OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_DistanceType;

      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
				  _OutputValueType>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _InputValueType, _OutputValueType>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _OutputValueType, _OutputValueType>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_valid_range(__result_first, __result_last);

      return std::__partial_sort_copy(__first, __last,
				      __result_first, __result_last,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  /// This is a helper function for the sort routine.
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
			      _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
	__val = _GLIBCXX_MOVE(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
	{
	  *__last = _GLIBCXX_MOVE(*__next);
	  __last = __next;
	  --__next;
	}
      *__last = _GLIBCXX_MOVE(__val);
    }

  /// This is a helper function for the sort routine.
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
		     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
	{
	  if (__comp(__i, __first))
	    {
	      typename iterator_traits<_RandomAccessIterator>::value_type
		__val = _GLIBCXX_MOVE(*__i);
	      _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
	      *__first = _GLIBCXX_MOVE(__val);
	    }
	  else
	    std::__unguarded_linear_insert(__i,
				__gnu_cxx::__ops::__val_comp_iter(__comp));
	}
    }

  /// This is a helper function for the sort routine.
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
			       _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
	std::__unguarded_linear_insert(__i,
				__gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  /**
   *  @doctodo
   *  This controls some aspect of the sort routines.
  */
  enum { _S_threshold = 16 };

  /// This is a helper function for the sort routine.
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
			   _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
	{
	  std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
	  std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
					  __comp);
	}
      else
	std::__insertion_sort(__first, __last, __comp);
    }

  /// This is a helper function...
  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
			  _RandomAccessIterator __last,
			  _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
	{
	  while (__comp(__first, __pivot))
	    ++__first;
	  --__last;
	  while (__comp(__pivot, __last))
	    --__last;
	  if (!(__first < __last))
	    return __first;
	  std::iter_swap(__first, __last);
	  ++__first;
	}
    }

  /// This is a helper function...
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
				_RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
				  __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
		   _RandomAccessIterator __middle,
		   _RandomAccessIterator __last,
		   _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }

  /// This is a helper function for the sort routine.
  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
		     _RandomAccessIterator __last,
		     _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
	{
	  if (__depth_limit == 0)
	    {
	      std::__partial_sort(__first, __last, __last, __comp);
	      return;
	    }
	  --__depth_limit;
	  _RandomAccessIterator __cut =
	    std::__unguarded_partition_pivot(__first, __last, __comp);
	  std::__introsort_loop(__cut, __last, __depth_limit, __comp);
	  __last = __cut;
	}
    }

  // sort

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
	   _Compare __comp)
    {
      if (__first != __last)
	{
	  std::__introsort_loop(__first, __last,
				std::__lg(__last - __first) * 2,
				__comp);
	  std::__final_insertion_sort(__first, __last, __comp);
	}
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
		  _RandomAccessIterator __last, _Size __depth_limit,
		  _Compare __comp)
    {
      while (__last - __first > 3)
	{
	  if (__depth_limit == 0)
	    {
	      std::__heap_select(__first, __nth + 1, __last, __comp);
	      // Place the nth largest element in its final position.
	      std::iter_swap(__first, __nth);
	      return;
	    }
	  --__depth_limit;
	  _RandomAccessIterator __cut =
	    std::__unguarded_partition_pivot(__first, __last, __comp);
	  if (__cut <= __nth)
	    __first = __cut;
	  else
	    __last = __cut;
	}
      std::__insertion_sort(__first, __last, __comp);
    }

  // nth_element

  // lower_bound moved to stl_algobase.h

  /**
   *  @brief Finds the first position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return An iterator pointing to the first element <em>not less
   *           than</em> @p __val, or end() if every element is less
   *           than @p __val.
   *  @ingroup binary_search_algorithms
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _ValueType, _Tp>)
      __glibcxx_requires_partitioned_lower_pred(__first, __last,
						__val, __comp);

      return std::__lower_bound(__first, __last, __val,
				__gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
		  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
	{
	  _DistanceType __half = __len >> 1;
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp(__val, __middle))
	    __len = __half;
	  else
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
	    }
	}
      return __first;
    }

  /**
   *  @brief Finds the last position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return  An iterator pointing to the first element greater than @p __val,
   *           or end() if no elements are greater than @p __val.
   *  @ingroup binary_search_algorithms
  */
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanOpConcept<_Tp, _ValueType>)
      __glibcxx_requires_partitioned_upper(__first, __last, __val);

      return std::__upper_bound(__first, __last, __val,
				__gnu_cxx::__ops::__val_less_iter());
    }

  /**
   *  @brief Finds the last position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  An iterator pointing to the first element greater than @p __val,
   *           or end() if no elements are greater than @p __val.
   *  @ingroup binary_search_algorithms
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _Tp, _ValueType>)
      __glibcxx_requires_partitioned_upper_pred(__first, __last,
						__val, __comp);

      return std::__upper_bound(__first, __last, __val,
				__gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
	   typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
		  const _Tp& __val,
		  _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
	{
	  _DistanceType __half = __len >> 1;
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp_it_val(__middle, __val))
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
	    }
	  else if (__comp_val_it(__val, __middle))
	    __len = __half;
	  else
	    {
	      _ForwardIterator __left
		= std::__lower_bound(__first, __middle, __val, __comp_it_val);
	      std::advance(__first, __len);
	      _ForwardIterator __right
		= std::__upper_bound(++__middle, __first, __val, __comp_val_it);
	      return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
	    }
	}
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }

  /**
   *  @brief Finds the largest subrange in which @p __val could be inserted
   *         at any place in it without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return  An pair of iterators defining the subrange.
   *  @ingroup binary_search_algorithms
   *
   *  This is equivalent to
   *  @code
   *    std::make_pair(lower_bound(__first, __last, __val),
   *                   upper_bound(__first, __last, __val))
   *  @endcode
   *  but does not actually call those functions.
  */
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)
      __glibcxx_function_requires(_LessThanOpConcept<_Tp, _ValueType>)
      __glibcxx_requires_partitioned_lower(__first, __last, __val);
      __glibcxx_requires_partitioned_upper(__first, __last, __val);      

      return std::__equal_range(__first, __last, __val,
				__gnu_cxx::__ops::__iter_less_val(),
				__gnu_cxx::__ops::__val_less_iter());
    }

  /**
   *  @brief Finds the largest subrange in which @p __val could be inserted
   *         at any place in it without changing the ordering.
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  An pair of iterators defining the subrange.
   *  @ingroup binary_search_algorithms
   *
   *  This is equivalent to
   *  @code
   *    std::make_pair(lower_bound(__first, __last, __val, __comp),
   *                   upper_bound(__first, __last, __val, __comp))
   *  @endcode
   *  but does not actually call those functions.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _ValueType, _Tp>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _Tp, _ValueType>)
      __glibcxx_requires_partitioned_lower_pred(__first, __last,
						__val, __comp);
      __glibcxx_requires_partitioned_upper_pred(__first, __last,
						__val, __comp);

      return std::__equal_range(__first, __last, __val,
				__gnu_cxx::__ops::__iter_comp_val(__comp),
				__gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  /**
   *  @brief Determines whether an element exists in a range.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return True if @p __val (or its equivalent) is in [@p
   *  __first,@p __last ].
   *
   *  Note that this does not actually return an iterator to @p __val.  For
   *  that, use std::find or a container's specialized find member functions.
  */
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanOpConcept<_Tp, _ValueType>)
      __glibcxx_requires_partitioned_lower(__first, __last, __val);
      __glibcxx_requires_partitioned_upper(__first, __last, __val);

      _ForwardIterator __i
	= std::__lower_bound(__first, __last, __val,
			     __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }

  /**
   *  @brief Determines whether an element exists in a range.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  True if @p __val (or its equivalent) is in @p [__first,__last].
   *
   *  Note that this does not actually return an iterator to @p __val.  For
   *  that, use std::find or a container's specialized find member functions.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _Tp, _ValueType>)
      __glibcxx_requires_partitioned_lower_pred(__first, __last,
						__val, __comp);
      __glibcxx_requires_partitioned_upper_pred(__first, __last,
						__val, __comp);

      _ForwardIterator __i
	= std::__lower_bound(__first, __last, __val,
			     __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }

  // merge

  /// This is a helper function for the __merge_adaptive routines.
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
			  _InputIterator2 __first2, _InputIterator2 __last2,
			  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	{
	  if (__comp(__first2, __first1))
	    {
	      *__result = _GLIBCXX_MOVE(*__first2);
	      ++__first2;
	    }
	  else
	    {
	      *__result = _GLIBCXX_MOVE(*__first1);
	      ++__first1;
	    }
	  ++__result;
	}
      if (__first1 != __last1)
	_GLIBCXX_MOVE3(__first1, __last1, __result);
    }

  /// This is a helper function for the __merge_adaptive routines.
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
	   typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
				   _BidirectionalIterator1 __last1,
				   _BidirectionalIterator2 __first2,
				   _BidirectionalIterator2 __last2,
				   _BidirectionalIterator3 __result,
				   _Compare __comp)
    {
      if (__first1 == __last1)
	{
	  _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
	  return;
	}
      else if (__first2 == __last2)
	return;

      --__last1;
      --__last2;
      while (true)
	{
	  if (__comp(__last2, __last1))
	    {
	      *--__result = _GLIBCXX_MOVE(*__last1);
	      if (__first1 == __last1)
		{
		  _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
		  return;
		}
	      --__last1;
	    }
	  else
	    {
	      *--__result = _GLIBCXX_MOVE(*__last2);
	      if (__first2 == __last2)
		return;
	      --__last2;
	    }
	}
    }

  /// This is a helper function for the merge routines.
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
	   typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
		      _BidirectionalIterator1 __middle,
		      _BidirectionalIterator1 __last,
		      _Distance __len1, _Distance __len2,
		      _BidirectionalIterator2 __buffer,
		      _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
	{
	  if (__len2)
	    {
	      __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
	      _GLIBCXX_MOVE_BACKWARD3(__first, __middle, __last);
	      return _GLIBCXX_MOVE3(__buffer, __buffer_end, __first);
	    }
	  else
	    return __first;
	}
      else if (__len1 <= __buffer_size)
	{
	  if (__len1)
	    {
	      __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
	      _GLIBCXX_MOVE3(__middle, __last, __first);
	      return _GLIBCXX_MOVE_BACKWARD3(__buffer, __buffer_end, __last);
	    }
	  else
	    return __last;
	}
      else
	{
	  std::rotate(__first, __middle, __last);
	  std::advance(__first, std::distance(__middle, __last));
	  return __first;
	}
    }

  /// This is a helper function for the merge routines.
  template<typename _BidirectionalIterator, typename _Distance, 
	   typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
		     _BidirectionalIterator __last,
		     _Distance __len1, _Distance __len2,
		     _Pointer __buffer, _Distance __buffer_size,
		     _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
	{
	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
	  std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
				     __first, __comp);
	}
      else if (__len2 <= __buffer_size)
	{
	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
	  std::__move_merge_adaptive_backward(__first, __middle, __buffer,
					      __buffer_end, __last, __comp);
	}
      else
	{
	  _BidirectionalIterator __first_cut = __first;
	  _BidirectionalIterator __second_cut = __middle;
	  _Distance __len11 = 0;
	  _Distance __len22 = 0;
	  if (__len1 > __len2)
	    {
	      __len11 = __len1 / 2;
	      std::advance(__first_cut, __len11);
	      __second_cut
		= std::__lower_bound(__middle, __last, *__first_cut,
				     __gnu_cxx::__ops::__iter_comp_val(__comp));
	      __len22 = std::distance(__middle, __second_cut);
	    }
	  else
	    {
	      __len22 = __len2 / 2;
	      std::advance(__second_cut, __len22);
	      __first_cut
		= std::__upper_bound(__first, __middle, *__second_cut,
				     __gnu_cxx::__ops::__val_comp_iter(__comp));
	      __len11 = std::distance(__first, __first_cut);
	    }
	  _BidirectionalIterator __new_middle
	    = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
				     __len1 - __len11, __len22, __buffer,
				     __buffer_size);
	  std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
				__len22, __buffer, __buffer_size, __comp);
	  std::__merge_adaptive(__new_middle, __second_cut, __last,
				__len1 - __len11,
				__len2 - __len22, __buffer,
				__buffer_size, __comp);
	}
    }

  /// This is a helper function for the merge routines.
  template<typename _BidirectionalIterator, typename _Distance,
	   typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
			   _BidirectionalIterator __last,
			   _Distance __len1, _Distance __len2,
			   _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
	return;
      if (__len1 + __len2 == 2)
	{
	  if (__comp(__middle, __first))
	    std::iter_swap(__first, __middle);
	  return;
	}
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
	{
	  __len11 = __len1 / 2;
	  std::advance(__first_cut, __len11);
	  __second_cut
	    = std::__lower_bound(__middle, __last, *__first_cut,
				 __gnu_cxx::__ops::__iter_comp_val(__comp));
	  __len22 = std::distance(__middle, __second_cut);
	}
      else
	{
	  __len22 = __len2 / 2;
	  std::advance(__second_cut, __len22);
	  __first_cut
	    = std::__upper_bound(__first, __middle, *__second_cut,
				 __gnu_cxx::__ops::__val_comp_iter(__comp));
	  __len11 = std::distance(__first, __first_cut);
	}
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
				  __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
				  __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
		    _BidirectionalIterator __middle,
		    _BidirectionalIterator __last,
		    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;

      if (__first == __middle || __middle == __last)
	return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
	std::__merge_without_buffer
	  (__first, __middle, __last, __len1, __len2, __comp);
      else
	std::__merge_adaptive
	  (__first, __middle, __last, __len1, __len2, __buf.begin(),
	   _DistanceType(__buf.size()), __comp);
    }

  /**
   *  @brief Merges two sorted ranges in place.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Merges two sorted and consecutive ranges, [__first,__middle) and
   *  [__middle,__last), and puts the result in [__first,__last).  The
   *  output will be sorted.  The sort is @e stable, that is, for
   *  equivalent elements in the two ranges, elements from the first
   *  range will always come before elements from the second.
   *
   *  If enough additional memory is available, this takes (__last-__first)-1
   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
   *  distance(__first,__last).
  */
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
		  _BidirectionalIterator __middle,
		  _BidirectionalIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
	    _BidirectionalIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_sorted(__first, __middle);
      __glibcxx_requires_sorted(__middle, __last);

      std::__inplace_merge(__first, __middle, __last,
			   __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Merges two sorted ranges in place.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  Nothing.
   *
   *  Merges two sorted and consecutive ranges, [__first,__middle) and
   *  [middle,last), and puts the result in [__first,__last).  The output will
   *  be sorted.  The sort is @e stable, that is, for equivalent
   *  elements in the two ranges, elements from the first range will always
   *  come before elements from the second.
   *
   *  If enough additional memory is available, this takes (__last-__first)-1
   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
   *  distance(__first,__last).
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
		  _BidirectionalIterator __middle,
		  _BidirectionalIterator __last,
		  _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
	    _BidirectionalIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_BidirectionalIterator>::value_type,
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_sorted_pred(__first, __middle, __comp);
      __glibcxx_requires_sorted_pred(__middle, __last, __comp);

      std::__inplace_merge(__first, __middle, __last,
			   __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  /// This is a helper function for the __merge_sort_loop routines.
  template<typename _InputIterator, typename _OutputIterator,
	   typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
		 _InputIterator __first2, _InputIterator __last2,
		 _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	{
	  if (__comp(__first2, __first1))
	    {
	      *__result = _GLIBCXX_MOVE(*__first2);
	      ++__first2;
	    }
	  else
	    {
	      *__result = _GLIBCXX_MOVE(*__first1);
	      ++__first1;
	    }
	  ++__result;
	}
      return _GLIBCXX_MOVE3(__first2, __last2,
			    _GLIBCXX_MOVE3(__first1, __last1,
					   __result));
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
	   typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
		      _RandomAccessIterator1 __last,
		      _RandomAccessIterator2 __result, _Distance __step_size,
		      _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
	{
	  __result = std::__move_merge(__first, __first + __step_size,
				       __first + __step_size,
				       __first + __two_step,
				       __result, __comp);
	  __first += __two_step;
	}
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
			__first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
	   typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
			   _RandomAccessIterator __last,
			   _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
	{
	  std::__insertion_sort(__first, __first + __chunk_size, __comp);
	  __first += __chunk_size;
	}
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
			     _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
	{
	  std::__merge_sort_loop(__first, __last, __buffer,
				 __step_size, __comp);
	  __step_size *= 2;
	  std::__merge_sort_loop(__buffer, __buffer_last, __first,
				 __step_size, __comp);
	  __step_size *= 2;
	}
    }

  template<typename _RandomAccessIterator, typename _Pointer,
	   typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
			   _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
	{
	  std::__stable_sort_adaptive(__first, __middle, __buffer,
				      __buffer_size, __comp);
	  std::__stable_sort_adaptive(__middle, __last, __buffer,
				      __buffer_size, __comp);
	}
      else
	{
	  std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
	  std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
	}
      std::__merge_adaptive(__first, __middle, __last,
			    _Distance(__middle - __first),
			    _Distance(__last - __middle),
			    __buffer, __buffer_size,
			    __comp);
    }

  /// This is a helper function for the stable sorting routines.
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
			  _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
	{
	  std::__insertion_sort(__first, __last, __comp);
	  return;
	}
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
				  __middle - __first,
				  __last - __middle,
				  __comp);
    }

  // stable_sort

  // Set algorithms: includes, set_union, set_intersection, set_difference,
  // set_symmetric_difference.  All of these algorithms have the precondition
  // that their input ranges are sorted and the postcondition that their output
  // ranges are sorted.

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
	       _InputIterator2 __first2, _InputIterator2 __last2,
	       _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	if (__comp(__first2, __first1))
	  return false;
	else if (__comp(__first1, __first2))
	  ++__first1;
	else
	  ++__first1, ++__first2;

      return __first2 == __last2;
    }

  /**
   *  @brief Determines whether all elements of a sequence exists in a range.
   *  @param  __first1  Start of search range.
   *  @param  __last1   End of search range.
   *  @param  __first2  Start of sequence
   *  @param  __last2   End of sequence.
   *  @return  True if each element in [__first2,__last2) is contained in order
   *  within [__first1,__last1).  False otherwise.
   *  @ingroup set_algorithms
   *
   *  This operation expects both [__first1,__last1) and
   *  [__first2,__last2) to be sorted.  Searches for the presence of
   *  each element in [__first2,__last2) within [__first1,__last1).
   *  The iterators over each range only move forward, so this is a
   *  linear algorithm.  If an element in [__first2,__last2) is not
   *  found before the search iterator reaches @p __last2, false is
   *  returned.
  */
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
	     _InputIterator2 __first2, _InputIterator2 __last2)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return std::__includes(__first1, __last1, __first2, __last2,
			     __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Determines whether all elements of a sequence exists in a range
   *  using comparison.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of search range.
   *  @param  __last1   End of search range.
   *  @param  __first2  Start of sequence
   *  @param  __last2   End of sequence.
   *  @param  __comp    Comparison function to use.
   *  @return True if each element in [__first2,__last2) is contained
   *  in order within [__first1,__last1) according to comp.  False
   *  otherwise.  @ingroup set_algorithms
   *
   *  This operation expects both [__first1,__last1) and
   *  [__first2,__last2) to be sorted.  Searches for the presence of
   *  each element in [__first2,__last2) within [__first1,__last1),
   *  using comp to decide.  The iterators over each range only move
   *  forward, so this is a linear algorithm.  If an element in
   *  [__first2,__last2) is not found before the search iterator
   *  reaches @p __last2, false is returned.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
	     _InputIterator2 __first2, _InputIterator2 __last2,
	     _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return std::__includes(__first1, __last1, __first2, __last2,
			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  // nth_element
  // merge
  // set_difference
  // set_intersection
  // set_union
  // stable_sort
  // set_symmetric_difference
  // min_element
  // max_element

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
		       _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
	return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
	return false;
      __i = __last;
      --__i;

      for(;;)
	{
	  _BidirectionalIterator __ii = __i;
	  --__i;
	  if (__comp(__i, __ii))
	    {
	      _BidirectionalIterator __j = __last;
	      while (!__comp(__i, --__j))
		{}
	      std::iter_swap(__i, __j);
	      std::__reverse(__ii, __last,
			     std::__iterator_category(__first));
	      return true;
	    }
	  if (__i == __first)
	    {
	      std::__reverse(__first, __last,
			     std::__iterator_category(__first));
	      return false;
	    }
	}
    }

  /**
   *  @brief  Permute range into the next @e dictionary ordering.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  False if wrapped to first permutation, true otherwise.
   *
   *  Treats all permutations of the range as a set of @e dictionary sorted
   *  sequences.  Permutes the current sequence into the next one of this set.
   *  Returns true if there are more sequences to generate.  If the sequence
   *  is the largest of the set, the smallest is generated and false returned.
  */
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
		     _BidirectionalIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__next_permutation
	(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Permute range into the next @e dictionary ordering using
   *          comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   A comparison functor.
   *  @return  False if wrapped to first permutation, true otherwise.
   *
   *  Treats all permutations of the range [__first,__last) as a set of
   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
   *  sequence into the next one of this set.  Returns true if there are more
   *  sequences to generate.  If the sequence is the largest of the set, the
   *  smallest is generated and false returned.
  */
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
		     _BidirectionalIterator __last, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_BidirectionalIterator>::value_type,
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__next_permutation
	(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
		       _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
	return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
	return false;
      __i = __last;
      --__i;

      for(;;)
	{
	  _BidirectionalIterator __ii = __i;
	  --__i;
	  if (__comp(__ii, __i))
	    {
	      _BidirectionalIterator __j = __last;
	      while (!__comp(--__j, __i))
		{}
	      std::iter_swap(__i, __j);
	      std::__reverse(__ii, __last,
			     std::__iterator_category(__first));
	      return true;
	    }
	  if (__i == __first)
	    {
	      std::__reverse(__first, __last,
			     std::__iterator_category(__first));
	      return false;
	    }
	}
    }

  /**
   *  @brief  Permute range into the previous @e dictionary ordering.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  False if wrapped to last permutation, true otherwise.
   *
   *  Treats all permutations of the range as a set of @e dictionary sorted
   *  sequences.  Permutes the current sequence into the previous one of this
   *  set.  Returns true if there are more sequences to generate.  If the
   *  sequence is the smallest of the set, the largest is generated and false
   *  returned.
  */
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
		     _BidirectionalIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__prev_permutation(__first, __last,
				     __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Permute range into the previous @e dictionary ordering using
   *          comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   A comparison functor.
   *  @return  False if wrapped to last permutation, true otherwise.
   *
   *  Treats all permutations of the range [__first,__last) as a set of
   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
   *  sequence into the previous one of this set.  Returns true if there are
   *  more sequences to generate.  If the sequence is the smallest of the set,
   *  the largest is generated and false returned.
  */
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
		     _BidirectionalIterator __last, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_BidirectionalIterator>::value_type,
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__prev_permutation(__first, __last,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  // replace
  // replace_if

  template<typename _InputIterator, typename _OutputIterator,
	   typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
		      _OutputIterator __result,
		      _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, ++__result)
	if (__pred(__first))
	  *__result = __new_value;
	else
	  *__result = *__first;
      return __result;
    }

  /**
   *  @brief Copy a sequence, replacing each element of one value with another
   *         value.
   *  @param  __first      An input iterator.
   *  @param  __last       An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __old_value  The value to be replaced.
   *  @param  __new_value  The replacement value.
   *  @return   The end of the output sequence, @p result+(last-first).
   *
   *  Copies each element in the input range @p [__first,__last) to the
   *  output range @p [__result,__result+(__last-__first)) replacing elements
   *  equal to @p __old_value with @p __new_value.
  */
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
		 _OutputIterator __result,
		 const _Tp& __old_value, const _Tp& __new_value)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__replace_copy_if(__first, __last, __result,
			__gnu_cxx::__ops::__iter_equals_val(__old_value),
					      __new_value);
    }

  /**
   *  @brief Copy a sequence, replacing each value for which a predicate
   *         returns true with another value.
   *  @ingroup mutating_algorithms
   *  @param  __first      An input iterator.
   *  @param  __last       An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __pred       A predicate.
   *  @param  __new_value  The replacement value.
   *  @return   The end of the output sequence, @p __result+(__last-__first).
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  @p [__result,__result+(__last-__first)) replacing elements for which
   *  @p __pred returns true with @p __new_value.
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
		    _OutputIterator __result,
		    _Predicate __pred, const _Tp& __new_value)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__replace_copy_if(__first, __last, __result,
				__gnu_cxx::__ops::__pred_iter(__pred),
					      __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
	if (__pred(__first))
	  ++__n;
      return __n;
    }

#if __cplusplus >= 201103L
  /**
   *  @brief  Determines whether the elements of a sequence are sorted.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  True if the elements are sorted, false otherwise.
  */
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }

  /**
   *  @brief  Determines whether the elements of a sequence are sorted
   *          according to a comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  True if the elements are sorted, false otherwise.
  */
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
	      _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
		      _Compare __comp)
    {
      if (__first == __last)
	return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
	if (__comp(__next, __first))
	  return __next;
      return __next;
    }

  /**
   *  @brief  Determines the end of a sorted sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  An iterator pointing to the last iterator i in [__first, __last)
   *           for which the range [__first, i) is sorted.
  */
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__is_sorted_until(__first, __last,
				    __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Determines the end of a sorted sequence using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  An iterator pointing to the last iterator i in [__first, __last)
   *           for which the range [__first, i) is sorted.
  */
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
		    _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_ForwardIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__is_sorted_until(__first, __last,
				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  /**
   *  @brief  Determines min and max at once as an ordered pair.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
   *  __b) otherwise.
  */
  template<typename _Tp>
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
	               : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  /**
   *  @brief  Determines min and max at once as an ordered pair.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor @endlink.
   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
   *  __b) otherwise.
  */
  template<typename _Tp, typename _Compare>
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
	                      : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
		     _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
	  || ++__next == __last)
	return std::make_pair(__first, __first);

      _ForwardIterator __min, __max;
      if (__comp(__next, __first))
	{
	  __min = __next;
	  __max = __first;
	}
      else
	{
	  __min = __first;
	  __max = __next;
	}

      __first = __next;
      ++__first;

      while (__first != __last)
	{
	  __next = __first;
	  if (++__next == __last)
	    {
	      if (__comp(__first, __min))
		__min = __first;
	      else if (!__comp(__first, __max))
		__max = __first;
	      break;
	    }

	  if (__comp(__next, __first))
	    {
	      if (__comp(__next, __min))
		__min = __next;
	      if (!__comp(__first, __max))
		__max = __first;
	    }
	  else
	    {
	      if (__comp(__first, __min))
		__min = __first;
	      if (!__comp(__next, __max))
		__max = __next;
	    }

	  __first = __next;
	  ++__first;
	}

      return std::make_pair(__min, __max);
    }

  /**
   *  @brief  Return a pair of iterators pointing to the minimum and maximum
   *          elements in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  make_pair(m, M), where m is the first iterator i in 
   *           [__first, __last) such that no other element in the range is
   *           smaller, and where M is the last iterator i in [__first, __last)
   *           such that no other element in the range is larger.
  */
  template<typename _ForwardIterator>
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__minmax_element(__first, __last,
				   __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Return a pair of iterators pointing to the minimum and maximum
   *          elements in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  make_pair(m, M), where m is the first iterator i in 
   *           [__first, __last) such that no other element in the range is
   *           smaller, and where M is the last iterator i in [__first, __last)
   *           such that no other element in the range is larger.
  */
  template<typename _ForwardIterator, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
		   _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_ForwardIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__minmax_element(__first, __last,
				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  // N2722 + DR 915.
  template<typename _Tp>
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
	std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
	std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {
      // Efficiently compare identical prefixes:  O(N) if sequences
      // have the same elements in the same order.
      for (; __first1 != __last1; ++__first1, ++__first2)
	if (!__pred(__first1, __first2))
	  break;

      if (__first1 == __last1)
	return true;

      // Establish __last2 assuming equal ranges by iterating over the
      // rest of the list.
      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
	{
	  if (__scan != std::__find_if(__first1, __scan,
			  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
	    continue; // We've seen this one before.
	  
	  auto __matches
	    = std::__count_if(__first2, __last2,
			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
	  if (0 == __matches ||
	      std::__count_if(__scan, __last1,
			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
	      != __matches)
	    return false;
	}
      return true;
    }

  /**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __first2 + (__last1 - __first1)), beginning with 
   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)
   *          returns true; otherwise, returns false.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		   _ForwardIterator2 __first2)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_EqualOpConcept<
		typename iterator_traits<_ForwardIterator1>::value_type,
		typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);

      return std::__is_permutation(__first1, __last1, __first2,
				   __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __pred    A binary predicate.
   *  @return true if there exists a permutation of the elements in
   *          the range [__first2, __first2 + (__last1 - __first1)),
   *          beginning with ForwardIterator2 begin, such that
   *          equal(__first1, __last1, __begin, __pred) returns true;
   *          otherwise, returns false.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		   _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_ForwardIterator1>::value_type,
	    typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);

      return std::__is_permutation(__first1, __last1, __first2,
				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }

#if __cplusplus > 201103L
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
		     _BinaryPredicate __pred)
    {
      using _Cat1
	= typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
	= typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
	{
	  auto __d1 = std::distance(__first1, __last1);
	  auto __d2 = std::distance(__first2, __last2);
	  if (__d1 != __d2)
	    return false;
	}

      // Efficiently compare identical prefixes:  O(N) if sequences
      // have the same elements in the same order.
      for (; __first1 != __last1; ++__first1, ++__first2)
	if (!__pred(__first1, __first2))
	  break;

      if (__ra_iters)
	{
	  if (__first1 == __last1)
	    return true;
	}
      else
	{
	  auto __d1 = std::distance(__first1, __last1);
	  auto __d2 = std::distance(__first2, __last2);
	  if (__d1 == 0 && __d2 == 0)
	    return true;
	  if (__d1 != __d2)
	    return false;
	}

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
	{
	  if (__scan != std::__find_if(__first1, __scan,
			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
	    continue; // We've seen this one before.

	  auto __matches = std::__count_if(__first2, __last2,
		__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
	  if (0 == __matches
	      || std::__count_if(__scan, __last1,
			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
	      != __matches)
	    return false;
	}
      return true;
    }

  /**
   *  @brief  Checks whether a permutaion of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of first range.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __last2), beginning with ForwardIterator2 begin,
   *          such that equal(__first1, __last1, begin) returns true;
   *          otherwise, returns false.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return
	std::__is_permutation(__first1, __last1, __first2, __last2,
			      __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of first range.
   *  @param  __pred    A binary predicate.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __last2), beginning with ForwardIterator2 begin,
   *          such that equal(__first1, __last1, __begin, __pred) returns true;
   *          otherwise, returns false.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
		   _BinaryPredicate __pred)
    {
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__is_permutation(__first1, __last1, __first2, __last2,
				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
#endif

#ifdef _GLIBCXX_USE_C99_STDINT_TR1
  /**
   *  @brief Shuffle the elements of a sequence using a uniform random
   *         number generator.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).
   *  @return  Nothing.
   *
   *  Reorders the elements in the range @p [__first,__last) using @p __g to
   *  provide random numbers.
  */
  template<typename _RandomAccessIterator,
	   typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
	    _UniformRandomNumberGenerator&& __g)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first == __last)
	return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
	std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }
#endif

#endif // C++11

_GLIBCXX_END_NAMESPACE_VERSION

_GLIBCXX_BEGIN_NAMESPACE_ALGO

  /**
   *  @brief Apply a function to every element of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __f      A unary function object.
   *  @return   @p __f (std::move(@p __f) in C++0x).
   *
   *  Applies the function object @p __f to each element in the range
   *  @p [first,last).  @p __f must not modify the order of the sequence.
   *  If @p __f has a return value it is ignored.
  */
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_requires_valid_range(__first, __last);
      for (; __first != __last; ++__first)
	__f(*__first);
      return _GLIBCXX_MOVE(__f);
    }

  /**
   *  @brief Find the first occurrence of a value in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __val    The value to find.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
  */
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
	 const _Tp& __val)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
		typename iterator_traits<_InputIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);
      return std::__find_if(__first, __last,
			    __gnu_cxx::__ops::__iter_equals_val(__val));
    }

  /**
   *  @brief Find the first element in a sequence for which a
   *         predicate is true.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
  */
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
	    _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	      typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__find_if(__first, __last,
			    __gnu_cxx::__ops::__pred_iter(__pred));
    }

  /**
   *  @brief  Find element from a set in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of match candidates.
   *  @param  __last2   End of match candidates.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for an element that is
   *  equal to some element in the range [__first2,__last2).  If
   *  found, returns an iterator in the range [__first1,__last1),
   *  otherwise returns @p __last1.
  */
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
		  _ForwardIterator __first2, _ForwardIterator __last2)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_InputIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      for (; __first1 != __last1; ++__first1)
	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
	  if (*__first1 == *__iter)
	    return __first1;
      return __last1;
    }

  /**
   *  @brief  Find element from a set in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of match candidates.
   *  @param  __last2   End of match candidates.
   *  @param  __comp    Predicate to use.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
   *  such iterator exists.
   *

   *  Searches the range @p [__first1,__last1) for an element that is
   *  equal to some element in the range [__first2,__last2).  If
   *  found, returns an iterator in the range [__first1,__last1),
   *  otherwise returns @p __last1.
  */
  template<typename _InputIterator, typename _ForwardIterator,
	   typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
		  _ForwardIterator __first2, _ForwardIterator __last2,
		  _BinaryPredicate __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_InputIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      for (; __first1 != __last1; ++__first1)
	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
	  if (__comp(*__first1, *__iter))
	    return __first1;
      return __last1;
    }

  /**
   *  @brief Find two adjacent values in a sequence that are equal.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @return   The first iterator @c i such that @c i and @c i+1 are both
   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
   *  or @p __last if no such iterator exists.
  */
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_EqualityComparableConcept<
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__adjacent_find(__first, __last,
				  __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief Find two adjacent values in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first         A forward iterator.
   *  @param  __last          A forward iterator.
   *  @param  __binary_pred   A binary predicate.
   *  @return   The first iterator @c i such that @c i and @c i+1 are both
   *  valid iterators in @p [__first,__last) and such that
   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
   *  exists.
  */
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
		  _BinaryPredicate __binary_pred)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_ForwardIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__adjacent_find(__first, __last,
			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }

  /**
   *  @brief Count the number of copies of a value in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __value  The value to be counted.
   *  @return   The number of iterators @c i in the range @p [__first,__last)
   *  for which @c *i == @p __value
  */
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__count_if(__first, __last,
			     __gnu_cxx::__ops::__iter_equals_val(__value));
    }

  /**
   *  @brief Count the elements of a sequence for which a predicate is true.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The number of iterators @c i in the range @p [__first,__last)
   *  for which @p __pred(*i) is true.
  */
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__count_if(__first, __last,
			     __gnu_cxx::__ops::__pred_iter(__pred));
    }

  /**
   *  @brief Search a sequence for a matching sub-sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  A forward iterator.
   *  @param  __last1   A forward iterator.
   *  @param  __first2  A forward iterator.
   *  @param  __last2   A forward iterator.
   *  @return The first iterator @c i in the range @p
   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
   *  *(__first2+N) for each @c N in the range @p
   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) and returns an iterator to the first element
   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
   *  found.
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.
   *
   *  This means that the returned iterator @c i will be in the range
   *  @p [__first1,__last1-(__last2-__first2))
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_ForwardIterator1>::value_type,
	    typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__search(__first1, __last1, __first2, __last2,
			   __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief Search a sequence for a matching sub-sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1     A forward iterator.
   *  @param  __last1      A forward iterator.
   *  @param  __first2     A forward iterator.
   *  @param  __last2      A forward iterator.
   *  @param  __predicate  A binary predicate.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1-(__last2-__first2)) such that
   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2), using @p __predicate to determine equality,
   *  and returns an iterator to the first element of the
   *  sub-sequence, or @p __last1 if no such iterator exists.
   *
   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
	   _BinaryPredicate  __predicate)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_ForwardIterator1>::value_type,
	    typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__search(__first1, __last1, __first2, __last2,
			   __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }

  /**
   *  @brief Search a sequence for a number of consecutive values.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __count  The number of consecutive values.
   *  @param  __val    The value to find.
   *  @return The first iterator @c i in the range @p
   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
   *  each @c N in the range @p [0,__count), or @p __last if no such
   *  iterator exists.
   *
   *  Searches the range @p [__first,__last) for @p count consecutive elements
   *  equal to @p __val.
  */
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
	     _Integer __count, const _Tp& __val)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__search_n(__first, __last, __count,
			     __gnu_cxx::__ops::__iter_equals_val(__val));
    }


  /**
   *  @brief Search a sequence for a number of consecutive values using a
   *         predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first        A forward iterator.
   *  @param  __last         A forward iterator.
   *  @param  __count        The number of consecutive values.
   *  @param  __val          The value to find.
   *  @param  __binary_pred  A binary predicate.
   *  @return The first iterator @c i in the range @p
   *  [__first,__last-__count) such that @p
   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
   *  @p [0,__count), or @p __last if no such iterator exists.
   *
   *  Searches the range @p [__first,__last) for @p __count
   *  consecutive elements for which the predicate returns true.
  */
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
	     _Integer __count, const _Tp& __val,
	     _BinaryPredicate __binary_pred)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__search_n(__first, __last, __count,
		__gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }


  /**
   *  @brief Perform an operation on a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first     An input iterator.
   *  @param  __last      An input iterator.
   *  @param  __result    An output iterator.
   *  @param  __unary_op  A unary operator.
   *  @return   An output iterator equal to @p __result+(__last-__first).
   *
   *  Applies the operator to each element in the input range and assigns
   *  the results to successive elements of the output sequence.
   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
   *  range @p [0,__last-__first).
   *
   *  @p unary_op must not alter its argument.
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
	      _OutputIterator __result, _UnaryOperation __unary_op)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
            // "the type returned by a _UnaryOperation"
            __typeof__(__unary_op(*__first))>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first, ++__result)
	*__result = __unary_op(*__first);
      return __result;
    }

  /**
   *  @brief Perform an operation on corresponding elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1     An input iterator.
   *  @param  __last1      An input iterator.
   *  @param  __first2     An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __binary_op  A binary operator.
   *  @return   An output iterator equal to @p result+(last-first).
   *
   *  Applies the operator to the corresponding elements in the two
   *  input ranges and assigns the results to successive elements of the
   *  output sequence.
   *  Evaluates @p
   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
   *  @c N in the range @p [0,__last1-__first1).
   *
   *  @p binary_op must not alter either of its arguments.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
	      _InputIterator2 __first2, _OutputIterator __result,
	      _BinaryOperation __binary_op)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
            // "the type returned by a _BinaryOperation"
            __typeof__(__binary_op(*__first1,*__first2))>)
      __glibcxx_requires_valid_range(__first1, __last1);

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
	*__result = __binary_op(*__first1, *__first2);
      return __result;
    }

  /**
   *  @brief Replace each occurrence of one value in a sequence with another
   *         value.
   *  @ingroup mutating_algorithms
   *  @param  __first      A forward iterator.
   *  @param  __last       A forward iterator.
   *  @param  __old_value  The value to be replaced.
   *  @param  __new_value  The replacement value.
   *  @return   replace() returns no value.
   *
   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
  */
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
	    const _Tp& __old_value, const _Tp& __new_value)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first)
	if (*__first == __old_value)
	  *__first = __new_value;
    }

  /**
   *  @brief Replace each value in a sequence for which a predicate returns
   *         true with another value.
   *  @ingroup mutating_algorithms
   *  @param  __first      A forward iterator.
   *  @param  __last       A forward iterator.
   *  @param  __pred       A predicate.
   *  @param  __new_value  The replacement value.
   *  @return   replace_if() returns no value.
   *
   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
   *  is true then the assignment @c *i = @p __new_value is performed.
  */
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
	       _Predicate __pred, const _Tp& __new_value)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first)
	if (__pred(*__first))
	  *__first = __new_value;
    }

  /**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __gen    A function object taking no arguments and returning
   *                 std::iterator_traits<_ForwardIterator>::value_type
   *  @return   generate() returns no value.
   *
   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
   *  @p [__first,__last).
  */
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
	     _Generator __gen)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_GeneratorConcept<_Generator,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first)
	*__first = __gen();
    }

  /**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __n      The length of the sequence.
   *  @param  __gen    A function object taking no arguments and returning
   *                 std::iterator_traits<_ForwardIterator>::value_type
   *  @return   The end of the sequence, @p __first+__n
   *
   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
   *  @p [__first,__first+__n).
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 865. More algorithms that throw away information
  */
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {
      // concept requirements
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
            // "the type returned by a _Generator"
            __typeof__(__gen())>)

      for (__decltype(__n + 0) __niter = __n;
	   __niter > 0; --__niter, ++__first)
	*__first = __gen();
      return __first;
    }

  /**
   *  @brief Copy a sequence, removing consecutive duplicate values.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  beginning at @p __result, except that only the first element is copied
   *  from groups of consecutive elements that compare equal.
   *  unique_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
   *  
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
   *  Assignable?
  */
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
		_OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_EqualityComparableConcept<
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first == __last)
	return __result;
      return std::__unique_copy(__first, __last, __result,
				__gnu_cxx::__ops::__iter_equal_to_iter(),
				std::__iterator_category(__first),
				std::__iterator_category(__result));
    }

  /**
   *  @brief Copy a sequence, removing consecutive values using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first        An input iterator.
   *  @param  __last         An input iterator.
   *  @param  __result       An output iterator.
   *  @param  __binary_pred  A binary predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  beginning at @p __result, except that only the first element is copied
   *  from groups of consecutive elements for which @p __binary_pred returns
   *  true.
   *  unique_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
		_OutputIterator __result,
		_BinaryPredicate __binary_pred)
    {
      // concept requirements -- predicates checked later
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first == __last)
	return __result;
      return std::__unique_copy(__first, __last, __result,
			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
				std::__iterator_category(__first),
				std::__iterator_category(__result));
    }

  /**
   *  @brief Randomly shuffle the elements of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @return  Nothing.
   *
   *  Reorder the elements in the range @p [__first,__last) using a random
   *  distribution, so that every possible ordering of the sequence is
   *  equally likely.
  */
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first != __last)
	for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
	  {
	    _RandomAccessIterator __j = __first
					+ std::rand() % ((__i - __first) + 1);
	    if (__i != __j)
	      std::iter_swap(__i, __j);
	  }
    }

  /**
   *  @brief Shuffle the elements of a sequence using a random number
   *         generator.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __rand    The RNG functor or function.
   *  @return  Nothing.
   *
   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
   *  provide a random distribution. Calling @p __rand(N) for a positive
   *  integer @p N should return a randomly chosen integer from the
   *  range [0,N).
  */
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
#if __cplusplus >= 201103L
		   _RandomNumberGenerator&& __rand)
#else
		   _RandomNumberGenerator& __rand)
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first == __last)
	return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
	{
	  _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
	  if (__i != __j)
	    std::iter_swap(__i, __j);
	}
    }


  /**
   *  @brief Move elements for which a predicate is true to the beginning
   *         of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __pred    A predicate functor.
   *  @return  An iterator @p middle such that @p __pred(i) is true for each
   *  iterator @p i in the range @p [__first,middle) and false for each @p i
   *  in the range @p [middle,__last).
   *
   *  @p __pred must not modify its operand. @p partition() does not preserve
   *  the relative ordering of elements in each group, use
   *  @p stable_partition() if this is needed.
  */
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
	      _Predicate   __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__partition(__first, __last, __pred,
			      std::__iterator_category(__first));
    }


  /**
   *  @brief Sort the smallest elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the smallest @p (__middle-__first) elements in the range
   *  @p [first,last) and moves them to the range @p [__first,__middle). The
   *  order of the remaining elements in the range @p [__middle,__last) is
   *  undefined.
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
  */
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
		 _RandomAccessIterator __middle,
		 _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __middle);
      __glibcxx_requires_valid_range(__middle, __last);

      std::__partial_sort(__first, __middle, __last,
			  __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Sort the smallest elements of a sequence using a predicate
   *         for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the smallest @p (__middle-__first) elements in the range
   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
   *  order of the remaining elements in the range @p [__middle,__last) is
   *  undefined.
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
   *  are both false.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
		 _RandomAccessIterator __middle,
		 _RandomAccessIterator __last,
		 _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_RandomAccessIterator>::value_type,
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __middle);
      __glibcxx_requires_valid_range(__middle, __last);

      std::__partial_sort(__first, __middle, __last,
			  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  /**
   *  @brief Sort a sequence just enough to find a particular position.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __nth     Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
   *  is the same element that would have been in that position had the
   *  whole sequence been sorted. The elements either side of @p *__nth are
   *  not completely sorted, but for any iterator @e i in the range
   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
   *  holds that *j < *i is false.
  */
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
		_RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __nth);
      __glibcxx_requires_valid_range(__nth, __last);

      if (__first == __last || __nth == __last)
	return;

      std::__introselect(__first, __nth, __last,
			 std::__lg(__last - __first) * 2,
			 __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Sort a sequence just enough to find a particular position
   *         using a predicate for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __nth     Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
   *  is the same element that would have been in that position had the
   *  whole sequence been sorted. The elements either side of @p *__nth are
   *  not completely sorted, but for any iterator @e i in the range
   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
   *  holds that @p __comp(*j,*i) is false.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
		_RandomAccessIterator __last, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_RandomAccessIterator>::value_type,
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __nth);
      __glibcxx_requires_valid_range(__nth, __last);

      if (__first == __last || __nth == __last)
	return;

      std::__introselect(__first, __nth, __last,
			 std::__lg(__last - __first) * 2,
			 __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  /**
   *  @brief Sort the elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @e i in the range @p [__first,__last-1),  
   *  *(i+1)<*i is false.
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  */
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Sort the elements of a sequence using a predicate for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
   *  range @p [__first,__last-1).
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
	 _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_RandomAccessIterator>::value_type,
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
	    _InputIterator2 __first2, _InputIterator2 __last2,
	    _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	{
	  if (__comp(__first2, __first1))
	    {
	      *__result = *__first2;
	      ++__first2;
	    }
	  else
	    {
	      *__result = *__first1;
	      ++__first1;
	    }
	  ++__result;
	}
      return std::copy(__first2, __last2,
		       std::copy(__first1, __last1, __result));
    }

  /**
   *  @brief Merges two sorted ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An iterator.
   *  @param  __first2  Another iterator.
   *  @param  __last1   Another iterator.
   *  @param  __last2   Another iterator.
   *  @param  __result  An iterator pointing to the end of the merged range.
   *  @return         An iterator pointing to the first element <em>not less
   *                  than</em> @e val.
   *
   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
   *  the sorted range @p [__result, __result + (__last1-__first1) +
   *  (__last2-__first2)).  Both input ranges must be sorted, and the
   *  output range must not overlap with either of the input ranges.
   *  The sort is @e stable, that is, for equivalent elements in the
   *  two ranges, elements from the first range will always come
   *  before elements from the second.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
	  _InputIterator2 __first2, _InputIterator2 __last2,
	  _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)	
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return _GLIBCXX_STD_A::__merge(__first1, __last1,
				     __first2, __last2, __result,
				     __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Merges two sorted ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An iterator.
   *  @param  __first2  Another iterator.
   *  @param  __last1   Another iterator.
   *  @param  __last2   Another iterator.
   *  @param  __result  An iterator pointing to the end of the merged range.
   *  @param  __comp    A functor to use for comparisons.
   *  @return         An iterator pointing to the first element "not less
   *                  than" @e val.
   *
   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
   *  the sorted range @p [__result, __result + (__last1-__first1) +
   *  (__last2-__first2)).  Both input ranges must be sorted, and the
   *  output range must not overlap with either of the input ranges.
   *  The sort is @e stable, that is, for equivalent elements in the
   *  two ranges, elements from the first range will always come
   *  before elements from the second.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
	  _InputIterator2 __first2, _InputIterator2 __last2,
	  _OutputIterator __result, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return _GLIBCXX_STD_A::__merge(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
		  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	_ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
	std::__inplace_stable_sort(__first, __last, __comp);
      else
	std::__stable_sort_adaptive(__first, __last, __buf.begin(),
				    _DistanceType(__buf.size()), __comp);
    }

  /**
   *  @brief Sort the elements of a sequence, preserving the relative order
   *         of equivalent elements.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @p i in the range @p [__first,__last-1),
   *  @p *(i+1)<*i is false.
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [__first,__last) such that
   *  @p x<y is false and @p y<x is false will have the same relative
   *  ordering after calling @p stable_sort().
  */
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      _GLIBCXX_STD_A::__stable_sort(__first, __last,
				    __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Sort the elements of a sequence using a predicate for comparison,
   *         preserving the relative order of equivalent elements.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @p i in the range @p [__first,__last-1),
   *  @p __comp(*(i+1),*i) is false.
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [__first,__last) such that
   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
   *  relative ordering after calling @p stable_sort().
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
		_Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_RandomAccessIterator>::value_type,
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      _GLIBCXX_STD_A::__stable_sort(__first, __last,
				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator,
	   typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
		_InputIterator2 __first2, _InputIterator2 __last2,
		_OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	{
	  if (__comp(__first1, __first2))
	    {
	      *__result = *__first1;
	      ++__first1;
	    }
	  else if (__comp(__first2, __first1))
	    {
	      *__result = *__first2;
	      ++__first2;
	    }
	  else
	    {
	      *__result = *__first1;
	      ++__first1;
	      ++__first2;
	    }
	  ++__result;
	}
      return std::copy(__first2, __last2,
		       std::copy(__first1, __last1, __result));
    }

  /**
   *  @brief Return the union of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  each range in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other,
   *  that element is copied and the iterator advanced.  If an element is
   *  contained in both ranges, the element from the first range is copied and
   *  both ranges advance.  The output range may not overlap either input
   *  range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
	      _InputIterator2 __first2, _InputIterator2 __last2,
	      _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Return the union of two sorted ranges using a comparison functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  each range in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other
   *  according to @p __comp, that element is copied and the iterator advanced.
   *  If an equivalent element according to @p __comp is contained in both
   *  ranges, the element from the first range is copied and both ranges
   *  advance.  The output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
	      _InputIterator2 __first2, _InputIterator2 __last2,
	      _OutputIterator __result, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator,
	   typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
		       _InputIterator2 __first2, _InputIterator2 __last2,
		       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	if (__comp(__first1, __first2))
	  ++__first1;
	else if (__comp(__first2, __first1))
	  ++__first2;
	else
	  {
	    *__result = *__first1;
	    ++__first1;
	    ++__first2;
	    ++__result;
	  }
      return __result;
    }

  /**
   *  @brief Return the intersection of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  both ranges in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other,
   *  that iterator advances.  If an element is contained in both ranges, the
   *  element from the first range is copied and both ranges advance.  The
   *  output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
		     _InputIterator2 __first2, _InputIterator2 __last2,
		     _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
				     __first2, __last2, __result,
				     __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Return the intersection of two sorted ranges using comparison
   *  functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  both ranges in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other
   *  according to @p __comp, that iterator advances.  If an element is
   *  contained in both ranges according to @p __comp, the element from the
   *  first range is copied and both ranges advance.  The output range may not
   *  overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
		     _InputIterator2 __first2, _InputIterator2 __last2,
		     _OutputIterator __result, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator,
	   typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
		     _InputIterator2 __first2, _InputIterator2 __last2,
		     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	if (__comp(__first1, __first2))
	  {
	    *__result = *__first1;
	    ++__first1;
	    ++__result;
	  }
	else if (__comp(__first2, __first1))
	  ++__first2;
	else
	  {
	    ++__first1;
	    ++__first2;
	  }
      return std::copy(__first1, __last1, __result);
    }

  /**
   *  @brief Return the difference of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  the first range but not the second in order to the output range.
   *  Iterators increment for each range.  When the current element of the
   *  first range is less than the second, that element is copied and the
   *  iterator advances.  If the current element of the second range is less,
   *  the iterator advances, but no element is copied.  If an element is
   *  contained in both ranges, no elements are copied and both ranges
   *  advance.  The output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
		   _InputIterator2 __first2, _InputIterator2 __last2,
		   _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)	
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
				   __first2, __last2, __result,
				   __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Return the difference of two sorted ranges using comparison
   *  functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  the first range but not the second in order to the output range.
   *  Iterators increment for each range.  When the current element of the
   *  first range is less than the second according to @p __comp, that element
   *  is copied and the iterator advances.  If the current element of the
   *  second range is less, no element is copied and the iterator advances.
   *  If an element is contained in both ranges according to @p __comp, no
   *  elements are copied and both ranges advance.  The output range may not
   *  overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
		   _InputIterator2 __first2, _InputIterator2 __last2,
		   _OutputIterator __result, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
				   __first2, __last2, __result,
				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator,
	   typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
			       _InputIterator1 __last1,
			       _InputIterator2 __first2,
			       _InputIterator2 __last2,
			       _OutputIterator __result,
			       _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	if (__comp(__first1, __first2))
	  {
	    *__result = *__first1;
	    ++__first1;
	    ++__result;
	  }
	else if (__comp(__first2, __first1))
	  {
	    *__result = *__first2;
	    ++__first2;
	    ++__result;
	  }
	else
	  {
	    ++__first1;
	    ++__first2;
	  }
      return std::copy(__first2, __last2, 
		       std::copy(__first1, __last1, __result));
    }

  /**
   *  @brief  Return the symmetric difference of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  one range but not the other in order to the output range.  Iterators
   *  increment for each range.  When the current element of one range is less
   *  than the other, that element is copied and the iterator advances.  If an
   *  element is contained in both ranges, no elements are copied and both
   *  ranges advance.  The output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
			     _InputIterator2 __first2, _InputIterator2 __last2,
			     _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)	
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
					__first2, __last2, __result,
					__gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Return the symmetric difference of two sorted ranges using
   *  comparison functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  one range but not the other in order to the output range.  Iterators
   *  increment for each range.  When the current element of one range is less
   *  than the other according to @p comp, that element is copied and the
   *  iterator advances.  If an element is contained in both ranges according
   *  to @p __comp, no elements are copied and both ranges advance.  The output
   *  range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
			     _InputIterator2 __first2, _InputIterator2 __last2,
			     _OutputIterator __result,
			     _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
		  _Compare __comp)
    {
      if (__first == __last)
	return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
	if (__comp(__first, __result))
	  __result = __first;
      return __result;
    }

  /**
   *  @brief  Return the minimum element in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  Iterator referencing the first instance of the smallest value.
  */
  template<typename _ForwardIterator>
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return _GLIBCXX_STD_A::__min_element(__first, __last,
				__gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Return the minimum element in a range using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  Iterator referencing the first instance of the smallest value
   *  according to __comp.
  */
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
		_Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_ForwardIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return _GLIBCXX_STD_A::__min_element(__first, __last,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
		  _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
	if (__comp(__result, __first))
	  __result = __first;
      return __result;
    }

  /**
   *  @brief  Return the maximum element in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  Iterator referencing the first instance of the largest value.
  */
  template<typename _ForwardIterator>
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return _GLIBCXX_STD_A::__max_element(__first, __last,
				__gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Return the maximum element in a range using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  Iterator referencing the first instance of the largest value
   *  according to __comp.
  */
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
		_Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_ForwardIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return _GLIBCXX_STD_A::__max_element(__first, __last,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

_GLIBCXX_END_NAMESPACE_ALGO
} // namespace std

#endif /* _STL_ALGO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // class template regex -*- C++ -*-

// Copyright (C) 2010-2014 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/**
 *  @file bits/regex.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{regex}
 */

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION
  template<typename, typename>
    class basic_regex;

  template<typename, typename>
    class match_results;

_GLIBCXX_END_NAMESPACE_VERSION

namespace __detail
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  enum class _RegexExecutorPolicy : int
    { _S_auto, _S_alternate };

  template<typename _BiIter, typename _Alloc,
	   typename _CharT, typename _TraitsT,
	   _RegexExecutorPolicy __policy,
	   bool __match_mode>
    bool
    __regex_algo_impl(_BiIter                              __s,
		      _BiIter                              __e,
		      match_results<_BiIter, _Alloc>&      __m,
		      const basic_regex<_CharT, _TraitsT>& __re,
		      regex_constants::match_flag_type     __flags);

  template<typename, typename, typename, bool>
    class _Executor;

  template<typename _TraitsT>
    inline std::shared_ptr<_NFA<_TraitsT>>
    __compile_nfa(const typename _TraitsT::char_type* __first,
		  const typename _TraitsT::char_type* __last,
		  const _TraitsT& __traits,
		  regex_constants::syntax_option_type __flags);

_GLIBCXX_END_NAMESPACE_VERSION
}

_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   * @addtogroup regex
   * @{
   */

  /**
   * @brief Describes aspects of a regular expression.
   *
   * A regular expression traits class that satisfies the requirements of
   * section [28.7].
   *
   * The class %regex is parameterized around a set of related types and
   * functions used to complete the definition of its semantics.  This class
   * satisfies the requirements of such a traits class.
   */
  template<typename _Ch_type>
    struct regex_traits
    {
    public:
      typedef _Ch_type                     	char_type;
      typedef std::basic_string<char_type> 	string_type;
      typedef std::locale                  	locale_type;
    private:
      struct _RegexMask
	{
	  typedef typename std::ctype<char_type>::mask _BaseType;
	  _BaseType _M_base;
	  unsigned char _M_extended;
	  static constexpr unsigned char _S_under = 1 << 0;
	  // FIXME: _S_blank should be removed in the future,
	  // when locale's complete.
	  static constexpr unsigned char _S_blank = 1 << 1;
	  static constexpr unsigned char _S_valid_mask = 0x3;

	  constexpr _RegexMask(_BaseType __base = 0,
			       unsigned char __extended = 0)
	  : _M_base(__base), _M_extended(__extended)
	  { }

	  constexpr _RegexMask
	  operator&(_RegexMask __other) const
	  {
	    return _RegexMask(_M_base & __other._M_base,
			      _M_extended & __other._M_extended);
	  }

	  constexpr _RegexMask
	  operator|(_RegexMask __other) const
	  {
	    return _RegexMask(_M_base | __other._M_base,
			      _M_extended | __other._M_extended);
	  }

	  constexpr _RegexMask
	  operator^(_RegexMask __other) const
	  {
	    return _RegexMask(_M_base ^ __other._M_base,
			      _M_extended ^ __other._M_extended);
	  }

	  constexpr _RegexMask
	  operator~() const
	  { return _RegexMask(~_M_base, ~_M_extended); }

	  _RegexMask&
	  operator&=(_RegexMask __other)
	  { return *this = (*this) & __other; }

	  _RegexMask&
	  operator|=(_RegexMask __other)
	  { return *this = (*this) | __other; }

	  _RegexMask&
	  operator^=(_RegexMask __other)
	  { return *this = (*this) ^ __other; }

	  constexpr bool
	  operator==(_RegexMask __other) const
	  {
	    return (_M_extended & _S_valid_mask)
		   == (__other._M_extended & _S_valid_mask)
		     && _M_base == __other._M_base;
	  }

	  constexpr bool
	  operator!=(_RegexMask __other) const
	  { return !((*this) == __other); }

	};
    public:
      typedef _RegexMask char_class_type;

    public:
      /**
       * @brief Constructs a default traits object.
       */
      regex_traits() { }

      /**
       * @brief Gives the length of a C-style string starting at @p __p.
       *
       * @param __p a pointer to the start of a character sequence.
       *
       * @returns the number of characters between @p *__p and the first
       * default-initialized value of type @p char_type.  In other words, uses
       * the C-string algorithm for determining the length of a sequence of
       * characters.
       */
      static std::size_t
      length(const char_type* __p)
      { return string_type::traits_type::length(__p); }

      /**
       * @brief Performs the identity translation.
       *
       * @param __c A character to the locale-specific character set.
       *
       * @returns __c.
       */
      char_type
      translate(char_type __c) const
      { return __c; }

      /**
       * @brief Translates a character into a case-insensitive equivalent.
       *
       * @param __c A character to the locale-specific character set.
       *
       * @returns the locale-specific lower-case equivalent of __c.
       * @throws std::bad_cast if the imbued locale does not support the ctype
       *         facet.
       */
      char_type
      translate_nocase(char_type __c) const
      {
	typedef std::ctype<char_type> __ctype_type;
	const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));
	return __fctyp.tolower(__c);
      }

      /**
       * @brief Gets a sort key for a character sequence.
       *
       * @param __first beginning of the character sequence.
       * @param __last  one-past-the-end of the character sequence.
       *
       * Returns a sort key for the character sequence designated by the
       * iterator range [F1, F2) such that if the character sequence [G1, G2)
       * sorts before the character sequence [H1, H2) then
       * v.transform(G1, G2) < v.transform(H1, H2).
       *
       * What this really does is provide a more efficient way to compare a
       * string to multiple other strings in locales with fancy collation
       * rules and equivalence classes.
       *
       * @returns a locale-specific sort key equivalent to the input range.
       *
       * @throws std::bad_cast if the current locale does not have a collate
       *         facet.
       */
      template<typename _Fwd_iter>
	string_type
	transform(_Fwd_iter __first, _Fwd_iter __last) const
	{
	  typedef std::collate<char_type> __collate_type;
	  const __collate_type& __fclt(use_facet<__collate_type>(_M_locale));
	  string_type __s(__first, __last);
	  return __fclt.transform(__s.data(), __s.data() + __s.size());
	}

      /**
       * @brief Gets a sort key for a character sequence, independent of case.
       *
       * @param __first beginning of the character sequence.
       * @param __last  one-past-the-end of the character sequence.
       *
       * Effects: if typeid(use_facet<collate<_Ch_type> >) ==
       * typeid(collate_byname<_Ch_type>) and the form of the sort key
       * returned by collate_byname<_Ch_type>::transform(__first, __last)
       * is known and can be converted into a primary sort key
       * then returns that key, otherwise returns an empty string.
       *
       * @todo Implement this function correctly.
       */
      template<typename _Fwd_iter>
	string_type
	transform_primary(_Fwd_iter __first, _Fwd_iter __last) const
	{
	  // TODO : this is not entirely correct.
	  // This function requires extra support from the platform.
	  //
	  // Read http://gcc.gnu.org/ml/libstdc++/2013-09/msg00117.html and
	  // http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2003/n1429.htm
	  // for details.
	  typedef std::ctype<char_type> __ctype_type;
	  const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));
	  std::vector<char_type> __s(__first, __last);
	  __fctyp.tolower(__s.data(), __s.data() + __s.size());
	  return this->transform(__s.data(), __s.data() + __s.size());
	}

      /**
       * @brief Gets a collation element by name.
       *
       * @param __first beginning of the collation element name.
       * @param __last  one-past-the-end of the collation element name.
       *
       * @returns a sequence of one or more characters that represents the
       * collating element consisting of the character sequence designated by
       * the iterator range [__first, __last). Returns an empty string if the
       * character sequence is not a valid collating element.
       */
      template<typename _Fwd_iter>
	string_type
	lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const;

      /**
       * @brief Maps one or more characters to a named character
       *        classification.
       *
       * @param __first beginning of the character sequence.
       * @param __last  one-past-the-end of the character sequence.
       * @param __icase ignores the case of the classification name.
       *
       * @returns an unspecified value that represents the character
       * classification named by the character sequence designated by
       * the iterator range [__first, __last). If @p icase is true,
       * the returned mask identifies the classification regardless of
       * the case of the characters to be matched (for example,
       * [[:lower:]] is the same as [[:alpha:]]), otherwise a
       * case-dependent classification is returned.  The value
       * returned shall be independent of the case of the characters
       * in the character sequence. If the name is not recognized then
       * returns a value that compares equal to 0.
       *
       * At least the following names (or their wide-character equivalent) are
       * supported.
       * - d
       * - w
       * - s
       * - alnum
       * - alpha
       * - blank
       * - cntrl
       * - digit
       * - graph
       * - lower
       * - print
       * - punct
       * - space
       * - upper
       * - xdigit
       */
      template<typename _Fwd_iter>
	char_class_type
	lookup_classname(_Fwd_iter __first, _Fwd_iter __last,
			 bool __icase = false) const;

      /**
       * @brief Determines if @p c is a member of an identified class.
       *
       * @param __c a character.
       * @param __f a class type (as returned from lookup_classname).
       *
       * @returns true if the character @p __c is a member of the classification
       * represented by @p __f, false otherwise.
       *
       * @throws std::bad_cast if the current locale does not have a ctype
       *         facet.
       */
      bool
      isctype(_Ch_type __c, char_class_type __f) const;

      /**
       * @brief Converts a digit to an int.
       *
       * @param __ch    a character representing a digit.
       * @param __radix the radix if the numeric conversion (limited to 8, 10,
       *              or 16).
       *
       * @returns the value represented by the digit __ch in base radix if the
       * character __ch is a valid digit in base radix; otherwise returns -1.
       */
      int
      value(_Ch_type __ch, int __radix) const;

      /**
       * @brief Imbues the regex_traits object with a copy of a new locale.
       *
       * @param __loc A locale.
       *
       * @returns a copy of the previous locale in use by the regex_traits
       *          object.
       *
       * @note Calling imbue with a different locale than the one currently in
       *       use invalidates all cached data held by *this.
       */
      locale_type
      imbue(locale_type __loc)
      {
	std::swap(_M_locale, __loc);
	return __loc;
      }

      /**
       * @brief Gets a copy of the current locale in use by the regex_traits
       * object.
       */
      locale_type
      getloc() const
      { return _M_locale; }

    protected:
      locale_type _M_locale;
    };

  // [7.8] Class basic_regex
  /**
   * Objects of specializations of this class represent regular expressions
   * constructed from sequences of character type @p _Ch_type.
   *
   * Storage for the regular expression is allocated and deallocated as
   * necessary by the member functions of this class.
   */
  template<typename _Ch_type, typename _Rx_traits = regex_traits<_Ch_type>>
    class basic_regex
    {
    public:
      static_assert(is_same<_Ch_type, typename _Rx_traits::char_type>::value,
		    "regex traits class must have the same char_type");

      // types:
      typedef _Ch_type                            value_type;
      typedef _Rx_traits                          traits_type;
      typedef typename traits_type::string_type   string_type;
      typedef regex_constants::syntax_option_type flag_type;
      typedef typename traits_type::locale_type   locale_type;

      /**
       * @name Constants
       * std [28.8.1](1)
       */
      //@{
      static constexpr flag_type icase = regex_constants::icase;
      static constexpr flag_type nosubs = regex_constants::nosubs;
      static constexpr flag_type optimize = regex_constants::optimize;
      static constexpr flag_type collate = regex_constants::collate;
      static constexpr flag_type ECMAScript = regex_constants::ECMAScript;
      static constexpr flag_type basic = regex_constants::basic;
      static constexpr flag_type extended = regex_constants::extended;
      static constexpr flag_type awk = regex_constants::awk;
      static constexpr flag_type grep = regex_constants::grep;
      static constexpr flag_type egrep = regex_constants::egrep;
      //@}

      // [7.8.2] construct/copy/destroy
      /**
       * Constructs a basic regular expression that does not match any
       * character sequence.
       */
      basic_regex()
      : _M_flags(ECMAScript), _M_automaton(nullptr)
      { }

      /**
       * @brief Constructs a basic regular expression from the
       * sequence [__p, __p + char_traits<_Ch_type>::length(__p))
       * interpreted according to the flags in @p __f.
       *
       * @param __p A pointer to the start of a C-style null-terminated string
       *          containing a regular expression.
       * @param __f Flags indicating the syntax rules and options.
       *
       * @throws regex_error if @p __p is not a valid regular expression.
       */
      explicit
      basic_regex(const _Ch_type* __p, flag_type __f = ECMAScript)
      : basic_regex(__p, __p + _Rx_traits::length(__p), __f)
      { }

      /**
       * @brief Constructs a basic regular expression from the sequence
       * [p, p + len) interpreted according to the flags in @p f.
       *
       * @param __p   A pointer to the start of a string containing a regular
       *              expression.
       * @param __len The length of the string containing the regular
       *              expression.
       * @param __f   Flags indicating the syntax rules and options.
       *
       * @throws regex_error if @p __p is not a valid regular expression.
       */
      basic_regex(const _Ch_type* __p, std::size_t __len,
		  flag_type __f = ECMAScript)
      : basic_regex(__p, __p + __len, __f)
      { }

      /**
       * @brief Copy-constructs a basic regular expression.
       *
       * @param __rhs A @p regex object.
       */
      basic_regex(const basic_regex& __rhs)
      : _M_flags(__rhs._M_flags), _M_original_str(__rhs._M_original_str)
      { this->imbue(__rhs.getloc()); }

      /**
       * @brief Move-constructs a basic regular expression.
       *
       * @param __rhs A @p regex object.
       *
       * The implementation is a workaround concerning ABI compatibility. See:
       * https://gcc.gnu.org/ml/libstdc++/2014-09/msg00067.html
       */
      basic_regex(basic_regex&& __rhs)
      : _M_flags(__rhs._M_flags),
      _M_original_str(std::move(__rhs._M_original_str))
      {
	this->imbue(__rhs.getloc());
	__rhs._M_automaton.reset();
      }

      /**
       * @brief Constructs a basic regular expression from the string
       * @p s interpreted according to the flags in @p f.
       *
       * @param __s A string containing a regular expression.
       * @param __f Flags indicating the syntax rules and options.
       *
       * @throws regex_error if @p __s is not a valid regular expression.
       */
      template<typename _Ch_traits, typename _Ch_alloc>
	explicit
	basic_regex(const std::basic_string<_Ch_type, _Ch_traits,
					    _Ch_alloc>& __s,
		    flag_type __f = ECMAScript)
	: basic_regex(__s.begin(), __s.end(), __f)
	{ }

      /**
       * @brief Constructs a basic regular expression from the range
       * [first, last) interpreted according to the flags in @p f.
       *
       * @param __first The start of a range containing a valid regular
       *                expression.
       * @param __last  The end of a range containing a valid regular
       *                expression.
       * @param __f     The format flags of the regular expression.
       *
       * @throws regex_error if @p [__first, __last) is not a valid regular
       *         expression.
       */
      template<typename _FwdIter>
	basic_regex(_FwdIter __first, _FwdIter __last,
		    flag_type __f = ECMAScript)
	: _M_flags(__f),
	  _M_original_str(__first, __last),
	  _M_automaton(__detail::__compile_nfa(_M_original_str.c_str(),
					       _M_original_str.c_str()
						 + _M_original_str.size(),
					       _M_traits,
					       _M_flags))
	{ }

      /**
       * @brief Constructs a basic regular expression from an initializer list.
       *
       * @param __l  The initializer list.
       * @param __f  The format flags of the regular expression.
       *
       * @throws regex_error if @p __l is not a valid regular expression.
       */
      basic_regex(initializer_list<_Ch_type> __l, flag_type __f = ECMAScript)
      : basic_regex(__l.begin(), __l.end(), __f)
      { }

      /**
       * @brief Destroys a basic regular expression.
       */
      ~basic_regex()
      { }

      /**
       * @brief Assigns one regular expression to another.
       */
      basic_regex&
      operator=(const basic_regex& __rhs)
      { return this->assign(__rhs); }

      /**
       * @brief Move-assigns one regular expression to another.
       *
       * The implementation is a workaround concerning ABI compatibility. See:
       * https://gcc.gnu.org/ml/libstdc++/2014-09/msg00067.html
       */
      basic_regex&
      operator=(basic_regex&& __rhs)
      { return this->assign(std::move(__rhs)); }

      /**
       * @brief Replaces a regular expression with a new one constructed from
       * a C-style null-terminated string.
       *
       * @param __p A pointer to the start of a null-terminated C-style string
       *        containing a regular expression.
       */
      basic_regex&
      operator=(const _Ch_type* __p)
      { return this->assign(__p, flags()); }

      /**
       * @brief Replaces a regular expression with a new one constructed from
       * a string.
       *
       * @param __s A pointer to a string containing a regular expression.
       */
      template<typename _Ch_typeraits, typename _Alloc>
	basic_regex&
	operator=(const basic_string<_Ch_type, _Ch_typeraits, _Alloc>& __s)
	{ return this->assign(__s, flags()); }

      // [7.8.3] assign
      /**
       * @brief the real assignment operator.
       *
       * @param __rhs Another regular expression object.
       */
      basic_regex&
      assign(const basic_regex& __rhs)
      {
	_M_flags = __rhs._M_flags;
	_M_original_str = __rhs._M_original_str;
	this->imbue(__rhs.getloc());
	return *this;
      }

      /**
       * @brief The move-assignment operator.
       *
       * @param __rhs Another regular expression object.
       *
       * The implementation is a workaround concerning ABI compatibility. See:
       * https://gcc.gnu.org/ml/libstdc++/2014-09/msg00067.html
       */
      basic_regex&
      assign(basic_regex&& __rhs)
      {
	_M_flags = __rhs._M_flags;
	_M_original_str = std::move(__rhs._M_original_str);
	__rhs._M_automaton.reset();
	this->imbue(__rhs.getloc());
      }

      /**
       * @brief Assigns a new regular expression to a regex object from a
       * C-style null-terminated string containing a regular expression
       * pattern.
       *
       * @param __p     A pointer to a C-style null-terminated string containing
       *              a regular expression pattern.
       * @param __flags Syntax option flags.
       *
       * @throws regex_error if __p does not contain a valid regular
       * expression pattern interpreted according to @p __flags.  If
       * regex_error is thrown, *this remains unchanged.
       */
      basic_regex&
      assign(const _Ch_type* __p, flag_type __flags = ECMAScript)
      { return this->assign(string_type(__p), __flags); }

      /**
       * @brief Assigns a new regular expression to a regex object from a
       * C-style string containing a regular expression pattern.
       *
       * @param __p     A pointer to a C-style string containing a
       *                regular expression pattern.
       * @param __len   The length of the regular expression pattern string.
       * @param __flags Syntax option flags.
       *
       * @throws regex_error if p does not contain a valid regular
       * expression pattern interpreted according to @p __flags.  If
       * regex_error is thrown, *this remains unchanged.
       */
      basic_regex&
      assign(const _Ch_type* __p, std::size_t __len, flag_type __flags)
      { return this->assign(string_type(__p, __len), __flags); }

      /**
       * @brief Assigns a new regular expression to a regex object from a
       * string containing a regular expression pattern.
       *
       * @param __s     A string containing a regular expression pattern.
       * @param __flags Syntax option flags.
       *
       * @throws regex_error if __s does not contain a valid regular
       * expression pattern interpreted according to @p __flags.  If
       * regex_error is thrown, *this remains unchanged.
       */
      template<typename _Ch_typeraits, typename _Alloc>
	basic_regex&
	assign(const basic_string<_Ch_type, _Ch_typeraits, _Alloc>& __s,
	       flag_type __flags = ECMAScript)
	{
	  _M_flags = __flags;
	  _M_original_str.assign(__s.begin(), __s.end());
	  auto __p = _M_original_str.c_str();
	  _M_automaton = __detail::__compile_nfa(__p,
						 __p + _M_original_str.size(),
						 _M_traits, _M_flags);
	  return *this;
	}

      /**
       * @brief Assigns a new regular expression to a regex object.
       *
       * @param __first The start of a range containing a valid regular
       *                expression.
       * @param __last  The end of a range containing a valid regular
       *                expression.
       * @param __flags Syntax option flags.
       *
       * @throws regex_error if p does not contain a valid regular
       * expression pattern interpreted according to @p __flags.  If
       * regex_error is thrown, the object remains unchanged.
       */
      template<typename _InputIterator>
	basic_regex&
	assign(_InputIterator __first, _InputIterator __last,
	       flag_type __flags = ECMAScript)
	{ return this->assign(string_type(__first, __last), __flags); }

      /**
       * @brief Assigns a new regular expression to a regex object.
       *
       * @param __l     An initializer list representing a regular expression.
       * @param __flags Syntax option flags.
       *
       * @throws regex_error if @p __l does not contain a valid
       * regular expression pattern interpreted according to @p
       * __flags.  If regex_error is thrown, the object remains
       * unchanged.
       */
      basic_regex&
      assign(initializer_list<_Ch_type> __l, flag_type __flags = ECMAScript)
      { return this->assign(__l.begin(), __l.end(), __flags); }

      // [7.8.4] const operations
      /**
       * @brief Gets the number of marked subexpressions within the regular
       * expression.
       */
      unsigned int
      mark_count() const
      { return _M_automaton->_M_sub_count() - 1; }

      /**
       * @brief Gets the flags used to construct the regular expression
       * or in the last call to assign().
       */
      flag_type
      flags() const
      { return _M_flags; }

      // [7.8.5] locale
      /**
       * @brief Imbues the regular expression object with the given locale.
       *
       * @param __loc A locale.
       */
      locale_type
      imbue(locale_type __loc)
      {
	auto __ret = _M_traits.imbue(__loc);
	this->assign(_M_original_str, _M_flags);
	return __ret;
      }

      /**
       * @brief Gets the locale currently imbued in the regular expression
       *        object.
       */
      locale_type
      getloc() const
      { return _M_traits.getloc(); }

      // [7.8.6] swap
      /**
       * @brief Swaps the contents of two regular expression objects.
       *
       * @param __rhs Another regular expression object.
       */
      void
      swap(basic_regex& __rhs)
      {
	std::swap(_M_flags, __rhs._M_flags);
	std::swap(_M_original_str, __rhs._M_original_str);
	this->imbue(__rhs.imbue(this->getloc()));
      }

#ifdef _GLIBCXX_DEBUG
      void
      _M_dot(std::ostream& __ostr)
      { _M_automaton->_M_dot(__ostr); }
#endif

    protected:
      typedef std::shared_ptr<__detail::_NFA<_Rx_traits>> _AutomatonPtr;

      template<typename _Bp, typename _Ap, typename _Cp, typename _Rp,
	__detail::_RegexExecutorPolicy, bool>
	friend bool
	__detail::__regex_algo_impl(_Bp, _Bp, match_results<_Bp, _Ap>&,
				    const basic_regex<_Cp, _Rp>&,
				    regex_constants::match_flag_type);

      template<typename, typename, typename, bool>
	friend class __detail::_Executor;

      flag_type              _M_flags;
      _Rx_traits             _M_traits;
      basic_string<_Ch_type> _M_original_str;
      _AutomatonPtr          _M_automaton;
    };

  /** @brief Standard regular expressions. */
  typedef basic_regex<char>    regex;

#ifdef _GLIBCXX_USE_WCHAR_T
  /** @brief Standard wide-character regular expressions. */
  typedef basic_regex<wchar_t> wregex;
#endif


  // [7.8.6] basic_regex swap
  /**
   * @brief Swaps the contents of two regular expression objects.
   * @param __lhs First regular expression.
   * @param __rhs Second regular expression.
   */
  template<typename _Ch_type, typename _Rx_traits>
    inline void
    swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,
	 basic_regex<_Ch_type, _Rx_traits>& __rhs)
    { __lhs.swap(__rhs); }


  // [7.9] Class template sub_match
  /**
   * A sequence of characters matched by a particular marked sub-expression.
   *
   * An object of this class is essentially a pair of iterators marking a
   * matched subexpression within a regular expression pattern match. Such
   * objects can be converted to and compared with std::basic_string objects
   * of a similar base character type as the pattern matched by the regular
   * expression.
   *
   * The iterators that make up the pair are the usual half-open interval
   * referencing the actual original pattern matched.
   */
  template<typename _BiIter>
    class sub_match : public std::pair<_BiIter, _BiIter>
    {
      typedef iterator_traits<_BiIter>			__iter_traits;
	
    public:
      typedef typename __iter_traits::value_type      	value_type;
      typedef typename __iter_traits::difference_type 	difference_type;
      typedef _BiIter                                   iterator;
      typedef std::basic_string<value_type>             string_type;

      bool matched;

      constexpr sub_match() : matched() { }

      /**
       * Gets the length of the matching sequence.
       */
      difference_type
      length() const
      { return this->matched ? std::distance(this->first, this->second) : 0; }

      /**
       * @brief Gets the matching sequence as a string.
       *
       * @returns the matching sequence as a string.
       *
       * This is the implicit conversion operator.  It is identical to the
       * str() member function except that it will want to pop up in
       * unexpected places and cause a great deal of confusion and cursing
       * from the unwary.
       */
      operator string_type() const
      {
	return this->matched
	  ? string_type(this->first, this->second)
	  : string_type();
      }

      /**
       * @brief Gets the matching sequence as a string.
       *
       * @returns the matching sequence as a string.
       */
      string_type
      str() const
      {
	return this->matched
	  ? string_type(this->first, this->second)
	  : string_type();
      }

      /**
       * @brief Compares this and another matched sequence.
       *
       * @param __s Another matched sequence to compare to this one.
       *
       * @retval <0 this matched sequence will collate before @p __s.
       * @retval =0 this matched sequence is equivalent to @p __s.
       * @retval <0 this matched sequence will collate after @p __s.
       */
      int
      compare(const sub_match& __s) const
      { return this->str().compare(__s.str()); }

      /**
       * @brief Compares this sub_match to a string.
       *
       * @param __s A string to compare to this sub_match.
       *
       * @retval <0 this matched sequence will collate before @p __s.
       * @retval =0 this matched sequence is equivalent to @p __s.
       * @retval <0 this matched sequence will collate after @p __s.
       */
      int
      compare(const string_type& __s) const
      { return this->str().compare(__s); }

      /**
       * @brief Compares this sub_match to a C-style string.
       *
       * @param __s A C-style string to compare to this sub_match.
       *
       * @retval <0 this matched sequence will collate before @p __s.
       * @retval =0 this matched sequence is equivalent to @p __s.
       * @retval <0 this matched sequence will collate after @p __s.
       */
      int
      compare(const value_type* __s) const
      { return this->str().compare(__s); }
    };


  /** @brief Standard regex submatch over a C-style null-terminated string. */
  typedef sub_match<const char*>             csub_match;

  /** @brief Standard regex submatch over a standard string. */
  typedef sub_match<string::const_iterator>  ssub_match;

#ifdef _GLIBCXX_USE_WCHAR_T
  /** @brief Regex submatch over a C-style null-terminated wide string. */
  typedef sub_match<const wchar_t*>          wcsub_match;

  /** @brief Regex submatch over a standard wide string. */
  typedef sub_match<wstring::const_iterator> wssub_match;
#endif

  // [7.9.2] sub_match non-member operators

  /**
   * @brief Tests the equivalence of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  /**
   * @brief Tests the inequivalence of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs  is not equivalent to @a __rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) != 0; }

  /**
   * @brief Tests the ordering of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) < 0; }

  /**
   * @brief Tests the ordering of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator<=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  /**
   * @brief Tests the ordering of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  /**
   * @brief Tests the ordering of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   */
  template<typename _BiIter>
    inline bool
    operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
    { return __lhs.compare(__rhs) > 0; }

  // Alias for sub_match'd string.
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    using __sub_match_string = basic_string<
			      typename iterator_traits<_Bi_iter>::value_type,
			      _Ch_traits, _Ch_alloc>;

  /**
   * @brief Tests the equivalence of a string and a regular expression
   *        submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator==(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __rhs.compare(__lhs.c_str()) == 0; }

  /**
   * @brief Tests the inequivalence of a string and a regular expression
   *        submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs  is not equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator!=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return !(__lhs == __rhs); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator<(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
	      const sub_match<_Bi_iter>& __rhs)
     { return __rhs.compare(__lhs.c_str()) > 0; }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator>(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
	      const sub_match<_Bi_iter>& __rhs)
    { return __rhs < __lhs; }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator>=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return !(__lhs < __rhs); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator<=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return !(__rhs < __lhs); }

  /**
   * @brief Tests the equivalence of a regular expression submatch and a
   *        string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs is equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator==(const sub_match<_Bi_iter>& __lhs,
	       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
    { return __lhs.compare(__rhs.c_str()) == 0; }

  /**
   * @brief Tests the inequivalence of a regular expression submatch and a
   *        string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
    inline bool
    operator!=(const sub_match<_Bi_iter>& __lhs,
	       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
    { return !(__lhs == __rhs); }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
    inline bool
    operator<(const sub_match<_Bi_iter>& __lhs,
	      const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
    { return __lhs.compare(__rhs.c_str()) < 0; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
    inline bool
    operator>(const sub_match<_Bi_iter>& __lhs,
	      const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
    { return __rhs < __lhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
    inline bool
    operator>=(const sub_match<_Bi_iter>& __lhs,
	       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
    { return !(__lhs < __rhs); }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   */
  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
    inline bool
    operator<=(const sub_match<_Bi_iter>& __lhs,
	       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
    { return !(__rhs < __lhs); }

  /**
   * @brief Tests the equivalence of a C string and a regular expression
   *        submatch.
   * @param __lhs A C string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator==(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return __rhs.compare(__lhs) == 0; }

  /**
   * @brief Tests the inequivalence of an iterator value and a regular
   *        expression submatch.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator!=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return !(__lhs == __rhs); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	      const sub_match<_Bi_iter>& __rhs)
    { return __rhs.compare(__lhs) > 0; }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	      const sub_match<_Bi_iter>& __rhs)
    { return __rhs < __lhs; }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return !(__lhs < __rhs); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return !(__rhs < __lhs); }

  /**
   * @brief Tests the equivalence of a regular expression submatch and a
   *        string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A pointer to a string?
   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator==(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return __lhs.compare(__rhs) == 0; }

  /**
   * @brief Tests the inequivalence of a regular expression submatch and a
   *        string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A pointer to a string.
   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator!=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return !(__lhs == __rhs); }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<(const sub_match<_Bi_iter>& __lhs,
	      typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return __lhs.compare(__rhs) < 0; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>(const sub_match<_Bi_iter>& __lhs,
	      typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return __rhs < __lhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return !(__lhs < __rhs); }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
    { return !(__rhs < __lhs); }

  /**
   * @brief Tests the equivalence of a string and a regular expression
   *        submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs is equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    {
      typedef typename sub_match<_Bi_iter>::string_type string_type;
      return __rhs.compare(string_type(1, __lhs)) == 0;
    }

  /**
   * @brief Tests the inequivalence of a string and a regular expression
   *        submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator!=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return !(__lhs == __rhs); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	      const sub_match<_Bi_iter>& __rhs)
    {
      typedef typename sub_match<_Bi_iter>::string_type string_type;
      return __rhs.compare(string_type(1, __lhs)) > 0;
    }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	      const sub_match<_Bi_iter>& __rhs)
    { return __rhs < __lhs; }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return !(__lhs < __rhs); }

  /**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
	       const sub_match<_Bi_iter>& __rhs)
    { return !(__rhs < __lhs); }

  /**
   * @brief Tests the equivalence of a regular expression submatch and a
   *        string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A const string reference.
   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator==(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    {
      typedef typename sub_match<_Bi_iter>::string_type string_type;
      return __lhs.compare(string_type(1, __rhs)) == 0;
    }

  /**
   * @brief Tests the inequivalence of a regular expression submatch and a
   *        string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A const string reference.
   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator!=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    { return !(__lhs == __rhs); }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A const string reference.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<(const sub_match<_Bi_iter>& __lhs,
	      typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    {
      typedef typename sub_match<_Bi_iter>::string_type string_type;
      return __lhs.compare(string_type(1, __rhs)) < 0;
    }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A const string reference.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>(const sub_match<_Bi_iter>& __lhs,
	      typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    { return __rhs < __lhs; }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A const string reference.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator>=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    { return !(__lhs < __rhs); }

  /**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A const string reference.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   */
  template<typename _Bi_iter>
    inline bool
    operator<=(const sub_match<_Bi_iter>& __lhs,
	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
    { return !(__rhs < __lhs); }

  /**
   * @brief Inserts a matched string into an output stream.
   *
   * @param __os The output stream.
   * @param __m  A submatch string.
   *
   * @returns the output stream with the submatch string inserted.
   */
  template<typename _Ch_type, typename _Ch_traits, typename _Bi_iter>
    inline
    basic_ostream<_Ch_type, _Ch_traits>&
    operator<<(basic_ostream<_Ch_type, _Ch_traits>& __os,
	       const sub_match<_Bi_iter>& __m)
    { return __os << __m.str(); }

  // [7.10] Class template match_results

  /*
   * Special sub_match object representing an unmatched sub-expression.
   */
  template<typename _Bi_iter>
    inline const sub_match<_Bi_iter>&
    __unmatched_sub()
    {
      static const sub_match<_Bi_iter> __unmatched = sub_match<_Bi_iter>();
      return __unmatched;
    }

  /**
   * @brief The results of a match or search operation.
   *
   * A collection of character sequences representing the result of a regular
   * expression match.  Storage for the collection is allocated and freed as
   * necessary by the member functions of class template match_results.
   *
   * This class satisfies the Sequence requirements, with the exception that
   * only the operations defined for a const-qualified Sequence are supported.
   *
   * The sub_match object stored at index 0 represents sub-expression 0, i.e.
   * the whole match. In this case the %sub_match member matched is always true.
   * The sub_match object stored at index n denotes what matched the marked
   * sub-expression n within the matched expression. If the sub-expression n
   * participated in a regular expression match then the %sub_match member
   * matched evaluates to true, and members first and second denote the range
   * of characters [first, second) which formed that match. Otherwise matched
   * is false, and members first and second point to the end of the sequence
   * that was searched.
   *
   * @nosubgrouping
   */
  template<typename _Bi_iter,
	   typename _Alloc = allocator<sub_match<_Bi_iter> > >
    class match_results
    : private std::vector<sub_match<_Bi_iter>, _Alloc>
    {
    private:
      /*
       * The vector base is empty if this does not represent a successful match.
       * Otherwise it contains n+3 elements where n is the number of marked
       * sub-expressions:
       * [0] entire match
       * [1] 1st marked subexpression
       * ...
       * [n] nth marked subexpression
       * [n+1] prefix
       * [n+2] suffix
       */
      typedef std::vector<sub_match<_Bi_iter>, _Alloc>     _Base_type;
      typedef std::iterator_traits<_Bi_iter>   	   	   __iter_traits;
      typedef regex_constants::match_flag_type		   match_flag_type;

    public:
      /**
       * @name 10.? Public Types
       */
      //@{
      typedef sub_match<_Bi_iter>                          value_type;
      typedef const value_type&                            const_reference;
      typedef const_reference                              reference;
      typedef typename _Base_type::const_iterator          const_iterator;
      typedef const_iterator                               iterator;
      typedef typename __iter_traits::difference_type	   difference_type;
      typedef typename allocator_traits<_Alloc>::size_type size_type;
      typedef _Alloc                                       allocator_type;
      typedef typename __iter_traits::value_type 	   char_type;
      typedef std::basic_string<char_type>                 string_type;
      //@}

    public:
      /**
       * @name 28.10.1 Construction, Copying, and Destruction
       */
      //@{

      /**
       * @brief Constructs a default %match_results container.
       * @post size() returns 0 and str() returns an empty string.
       */
      explicit
      match_results(const _Alloc& __a = _Alloc())
      : _Base_type(__a)
      { }

      /**
       * @brief Copy constructs a %match_results.
       */
      match_results(const match_results& __rhs) = default;

      /**
       * @brief Move constructs a %match_results.
       */
      match_results(match_results&& __rhs) noexcept = default;

      /**
       * @brief Assigns rhs to *this.
       */
      match_results&
      operator=(const match_results& __rhs) = default;

      /**
       * @brief Move-assigns rhs to *this.
       */
      match_results&
      operator=(match_results&& __rhs) = default;

      /**
       * @brief Destroys a %match_results object.
       */
      ~match_results()
      { }

      //@}

      // 28.10.2, state:
      /**
       * @brief Indicates if the %match_results is ready.
       * @retval true   The object has a fully-established result state.
       * @retval false  The object is not ready.
       */
      bool ready() const { return !_Base_type::empty(); }

      /**
       * @name 28.10.2 Size
       */
      //@{

      /**
       * @brief Gets the number of matches and submatches.
       *
       * The number of matches for a given regular expression will be either 0
       * if there was no match or mark_count() + 1 if a match was successful.
       * Some matches may be empty.
       *
       * @returns the number of matches found.
       */
      size_type
      size() const
      {
      	size_type __size = _Base_type::size();
      	return (__size && _Base_type::operator[](0).matched) ? __size - 2 : 0;
      }

      size_type
      max_size() const
      { return _Base_type::max_size(); }

      /**
       * @brief Indicates if the %match_results contains no results.
       * @retval true The %match_results object is empty.
       * @retval false The %match_results object is not empty.
       */
      bool
      empty() const
      { return size() == 0; }

      //@}

      /**
       * @name 10.3 Element Access
       */
      //@{

      /**
       * @brief Gets the length of the indicated submatch.
       * @param __sub indicates the submatch.
       * @pre   ready() == true
       *
       * This function returns the length of the indicated submatch, or the
       * length of the entire match if @p __sub is zero (the default).
       */
      difference_type
      length(size_type __sub = 0) const
      { return (*this)[__sub].length(); }

      /**
       * @brief Gets the offset of the beginning of the indicated submatch.
       * @param __sub indicates the submatch.
       * @pre   ready() == true
       *
       * This function returns the offset from the beginning of the target
       * sequence to the beginning of the submatch, unless the value of @p __sub
       * is zero (the default), in which case this function returns the offset
       * from the beginning of the target sequence to the beginning of the
       * match.
       *
       * Returns -1 if @p __sub is out of range.
       */
      difference_type
      position(size_type __sub = 0) const
      {
	return __sub < size() ? std::distance(_M_begin,
					      (*this)[__sub].first) : -1;
      }

      /**
       * @brief Gets the match or submatch converted to a string type.
       * @param __sub indicates the submatch.
       * @pre   ready() == true
       *
       * This function gets the submatch (or match, if @p __sub is
       * zero) extracted from the target range and converted to the
       * associated string type.
       */
      string_type
      str(size_type __sub = 0) const
      { return (*this)[__sub].str(); }

      /**
       * @brief Gets a %sub_match reference for the match or submatch.
       * @param __sub indicates the submatch.
       * @pre   ready() == true
       *
       * This function gets a reference to the indicated submatch, or
       * the entire match if @p __sub is zero.
       *
       * If @p __sub >= size() then this function returns a %sub_match with a
       * special value indicating no submatch.
       */
      const_reference
      operator[](size_type __sub) const
      {
      	_GLIBCXX_DEBUG_ASSERT( ready() );
      	return __sub < size()
	       ?  _Base_type::operator[](__sub)
	       : __unmatched_sub<_Bi_iter>();
      }

      /**
       * @brief Gets a %sub_match representing the match prefix.
       * @pre   ready() == true
       *
       * This function gets a reference to a %sub_match object representing the
       * part of the target range between the start of the target range and the
       * start of the match.
       */
      const_reference
      prefix() const
      {
      	_GLIBCXX_DEBUG_ASSERT( ready() );
      	return !empty()
      	       ? _Base_type::operator[](_Base_type::size() - 2)
	       : __unmatched_sub<_Bi_iter>();
      }

      /**
       * @brief Gets a %sub_match representing the match suffix.
       * @pre   ready() == true
       *
       * This function gets a reference to a %sub_match object representing the
       * part of the target range between the end of the match and the end of
       * the target range.
       */
      const_reference
      suffix() const
      {
	_GLIBCXX_DEBUG_ASSERT( ready() );
	return !empty()
	       ? _Base_type::operator[](_Base_type::size() - 1)
	       : __unmatched_sub<_Bi_iter>();
      }

      /**
       * @brief Gets an iterator to the start of the %sub_match collection.
       */
      const_iterator
      begin() const
      { return _Base_type::begin(); }

      /**
       * @brief Gets an iterator to the start of the %sub_match collection.
       */
      const_iterator
      cbegin() const
      { return this->begin(); }

      /**
       * @brief Gets an iterator to one-past-the-end of the collection.
       */
      const_iterator
      end() const
      { return _Base_type::end() - 2; }

      /**
       * @brief Gets an iterator to one-past-the-end of the collection.
       */
      const_iterator
      cend() const
      { return this->end(); }

      //@}

      /**
       * @name 10.4 Formatting
       *
       * These functions perform formatted substitution of the matched
       * character sequences into their target.  The format specifiers and
       * escape sequences accepted by these functions are determined by
       * their @p flags parameter as documented above.
       */
       //@{

      /**
       * @pre   ready() == true
       */
      template<typename _Out_iter>
	_Out_iter
	format(_Out_iter __out, const char_type* __fmt_first,
	       const char_type* __fmt_last,
	       match_flag_type __flags = regex_constants::format_default) const;

      /**
       * @pre   ready() == true
       */
      template<typename _Out_iter, typename _St, typename _Sa>
	_Out_iter
	format(_Out_iter __out, const basic_string<char_type, _St, _Sa>& __fmt,
	       match_flag_type __flags = regex_constants::format_default) const
	{
	  return format(__out, __fmt.data(), __fmt.data() + __fmt.size(),
			__flags);
	}

      /**
       * @pre   ready() == true
       */
      template<typename _St, typename _Sa>
	basic_string<char_type, _St, _Sa>
	format(const basic_string<char_type, _St, _Sa>& __fmt,
	       match_flag_type __flags = regex_constants::format_default) const
	{
	  basic_string<char_type, _St, _Sa> __result;
	  format(std::back_inserter(__result), __fmt, __flags);
	  return __result;
	}

      /**
       * @pre   ready() == true
       */
      string_type
      format(const char_type* __fmt,
	     match_flag_type __flags = regex_constants::format_default) const
      {
	string_type __result;
	format(std::back_inserter(__result),
	       __fmt,
	       __fmt + char_traits<char_type>::length(__fmt),
	       __flags);
	return __result;
      }

      //@}

      /**
       * @name 10.5 Allocator
       */
      //@{

      /**
       * @brief Gets a copy of the allocator.
       */
      allocator_type
      get_allocator() const
      { return _Base_type::get_allocator(); }

      //@}

      /**
       * @name 10.6 Swap
       */
       //@{

      /**
       * @brief Swaps the contents of two match_results.
       */
      void
      swap(match_results& __that)
      {
	_Base_type::swap(__that);
	swap(_M_begin, __that._M_begin);
      }
      //@}

    private:
      template<typename, typename, typename, bool>
	friend class __detail::_Executor;

      template<typename, typename, typename>
	friend class regex_iterator;

      template<typename _Bp, typename _Ap, typename _Cp, typename _Rp,
	__detail::_RegexExecutorPolicy, bool>
	friend bool
	__detail::__regex_algo_impl(_Bp, _Bp, match_results<_Bp, _Ap>&,
				    const basic_regex<_Cp, _Rp>&,
				    regex_constants::match_flag_type);

      _Bi_iter _M_begin;
      bool     _M_in_iterator;
    };

  typedef match_results<const char*>             cmatch;
  typedef match_results<string::const_iterator>  smatch;
#ifdef _GLIBCXX_USE_WCHAR_T
  typedef match_results<const wchar_t*>          wcmatch;
  typedef match_results<wstring::const_iterator> wsmatch;
#endif

  // match_results comparisons
  /**
   * @brief Compares two match_results for equality.
   * @returns true if the two objects refer to the same match,
   * false otherwise.
   */
  template<typename _Bi_iter, typename _Alloc>
    inline bool
    operator==(const match_results<_Bi_iter, _Alloc>& __m1,
	       const match_results<_Bi_iter, _Alloc>& __m2)
    {
      if (__m1.ready() != __m2.ready())
	return false;
      if (!__m1.ready())  // both are not ready
	return true;
      if (__m1.empty() != __m2.empty())
	return false;
      if (__m1.empty())   // both are empty
	return true;
      return __m1.prefix() == __m2.prefix()
	&& __m1.size() == __m2.size()
	&& std::equal(__m1.begin(), __m1.end(), __m2.begin())
	&& __m1.suffix() == __m2.suffix();
    }

  /**
   * @brief Compares two match_results for inequality.
   * @returns true if the two objects do not refer to the same match,
   * false otherwise.
   */
  template<typename _Bi_iter, class _Alloc>
    inline bool
    operator!=(const match_results<_Bi_iter, _Alloc>& __m1,
	       const match_results<_Bi_iter, _Alloc>& __m2)
    { return !(__m1 == __m2); }

  // [7.10.6] match_results swap
  /**
   * @brief Swaps two match results.
   * @param __lhs A match result.
   * @param __rhs A match result.
   *
   * The contents of the two match_results objects are swapped.
   */
  template<typename _Bi_iter, typename _Alloc>
    inline void
    swap(match_results<_Bi_iter, _Alloc>& __lhs,
	 match_results<_Bi_iter, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }

  // [7.11.2] Function template regex_match
  /**
   * @name Matching, Searching, and Replacing
   */
  //@{

  /**
   * @brief Determines if there is a match between the regular expression @p e
   * and all of the character sequence [first, last).
   *
   * @param __s     Start of the character sequence to match.
   * @param __e     One-past-the-end of the character sequence to match.
   * @param __m     The match results.
   * @param __re    The regular expression.
   * @param __flags Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Bi_iter, typename _Alloc,
	   typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_match(_Bi_iter                                 __s,
		_Bi_iter                                 __e,
		match_results<_Bi_iter, _Alloc>&         __m,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type         __flags
			       = regex_constants::match_default)
    {
      return __detail::__regex_algo_impl<_Bi_iter, _Alloc, _Ch_type, _Rx_traits,
	__detail::_RegexExecutorPolicy::_S_auto, true>
	  (__s, __e, __m, __re, __flags);
    }

  /**
   * @brief Indicates if there is a match between the regular expression @p e
   * and all of the character sequence [first, last).
   *
   * @param __first Beginning of the character sequence to match.
   * @param __last  One-past-the-end of the character sequence to match.
   * @param __re    The regular expression.
   * @param __flags Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_match(_Bi_iter __first, _Bi_iter __last,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __flags
		= regex_constants::match_default)
    {
      match_results<_Bi_iter> __what;
      return regex_match(__first, __last, __what, __re, __flags);
    }

  /**
   * @brief Determines if there is a match between the regular expression @p e
   * and a C-style null-terminated string.
   *
   * @param __s  The C-style null-terminated string to match.
   * @param __m  The match results.
   * @param __re The regular expression.
   * @param __f  Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Ch_type, typename _Alloc, typename _Rx_traits>
    inline bool
    regex_match(const _Ch_type* __s,
		match_results<const _Ch_type*, _Alloc>& __m,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __f
		= regex_constants::match_default)
    { return regex_match(__s, __s + _Rx_traits::length(__s), __m, __re, __f); }

  /**
   * @brief Determines if there is a match between the regular expression @p e
   * and a string.
   *
   * @param __s     The string to match.
   * @param __m     The match results.
   * @param __re    The regular expression.
   * @param __flags Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Ch_traits, typename _Ch_alloc,
	   typename _Alloc, typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,
		match_results<typename basic_string<_Ch_type,
		_Ch_traits, _Ch_alloc>::const_iterator, _Alloc>& __m,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __flags
		= regex_constants::match_default)
    { return regex_match(__s.begin(), __s.end(), __m, __re, __flags); }

  /**
   * @brief Indicates if there is a match between the regular expression @p e
   * and a C-style null-terminated string.
   *
   * @param __s  The C-style null-terminated string to match.
   * @param __re The regular expression.
   * @param __f  Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Ch_type, class _Rx_traits>
    inline bool
    regex_match(const _Ch_type* __s,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __f
		= regex_constants::match_default)
    { return regex_match(__s, __s + _Rx_traits::length(__s), __re, __f); }

  /**
   * @brief Indicates if there is a match between the regular expression @p e
   * and a string.
   *
   * @param __s     [IN] The string to match.
   * @param __re    [IN] The regular expression.
   * @param __flags [IN] Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Ch_traits, typename _Str_allocator,
	   typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_match(const basic_string<_Ch_type, _Ch_traits, _Str_allocator>& __s,
		const basic_regex<_Ch_type, _Rx_traits>& __re,
		regex_constants::match_flag_type __flags
		= regex_constants::match_default)
    { return regex_match(__s.begin(), __s.end(), __re, __flags); }

  // [7.11.3] Function template regex_search
  /**
   * Searches for a regular expression within a range.
   * @param __s     [IN]  The start of the string to search.
   * @param __e     [IN]  One-past-the-end of the string to search.
   * @param __m     [OUT] The match results.
   * @param __re    [IN]  The regular expression to search for.
   * @param __flags [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string, the content of %m is
   *               undefined.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Bi_iter, typename _Alloc,
	   typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_search(_Bi_iter __s, _Bi_iter __e,
		 match_results<_Bi_iter, _Alloc>& __m,
		 const basic_regex<_Ch_type, _Rx_traits>& __re,
		 regex_constants::match_flag_type __flags
		 = regex_constants::match_default)
    {
      return __detail::__regex_algo_impl<_Bi_iter, _Alloc, _Ch_type, _Rx_traits,
	__detail::_RegexExecutorPolicy::_S_auto, false>
	  (__s, __e, __m, __re, __flags);
    }

  /**
   * Searches for a regular expression within a range.
   * @param __first [IN]  The start of the string to search.
   * @param __last  [IN]  One-past-the-end of the string to search.
   * @param __re    [IN]  The regular expression to search for.
   * @param __flags [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_search(_Bi_iter __first, _Bi_iter __last,
		 const basic_regex<_Ch_type, _Rx_traits>& __re,
		 regex_constants::match_flag_type __flags
		 = regex_constants::match_default)
    {
      match_results<_Bi_iter> __what;
      return regex_search(__first, __last, __what, __re, __flags);
    }

  /**
   * @brief Searches for a regular expression within a C-string.
   * @param __s [IN]  A C-string to search for the regex.
   * @param __m [OUT] The set of regex matches.
   * @param __e [IN]  The regex to search for in @p s.
   * @param __f [IN]  The search flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string, the content of %m is
   *               undefined.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Ch_type, class _Alloc, class _Rx_traits>
    inline bool
    regex_search(const _Ch_type* __s,
		 match_results<const _Ch_type*, _Alloc>& __m,
		 const basic_regex<_Ch_type, _Rx_traits>& __e,
		 regex_constants::match_flag_type __f
		 = regex_constants::match_default)
    { return regex_search(__s, __s + _Rx_traits::length(__s), __m, __e, __f); }

  /**
   * @brief Searches for a regular expression within a C-string.
   * @param __s [IN]  The C-string to search.
   * @param __e [IN]  The regular expression to search for.
   * @param __f [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_search(const _Ch_type* __s,
		 const basic_regex<_Ch_type, _Rx_traits>& __e,
		 regex_constants::match_flag_type __f
		 = regex_constants::match_default)
    { return regex_search(__s, __s + _Rx_traits::length(__s), __e, __f); }

  /**
   * @brief Searches for a regular expression within a string.
   * @param __s     [IN]  The string to search.
   * @param __e     [IN]  The regular expression to search for.
   * @param __flags [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Ch_traits, typename _String_allocator,
	   typename _Ch_type, typename _Rx_traits>
    inline bool
    regex_search(const basic_string<_Ch_type, _Ch_traits,
		 _String_allocator>& __s,
		 const basic_regex<_Ch_type, _Rx_traits>& __e,
		 regex_constants::match_flag_type __flags
		 = regex_constants::match_default)
    { return regex_search(__s.begin(), __s.end(), __e, __flags); }

  /**
   * @brief Searches for a regular expression within a string.
   * @param __s [IN]  A C++ string to search for the regex.
   * @param __m [OUT] The set of regex matches.
   * @param __e [IN]  The regex to search for in @p s.
   * @param __f [IN]  The search flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string, the content of %m is
   *               undefined.
   *
   * @throws an exception of type regex_error.
   */
  template<typename _Ch_traits, typename _Ch_alloc,
	   typename _Alloc, typename _Ch_type,
	   typename _Rx_traits>
    inline bool
    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,
		 match_results<typename basic_string<_Ch_type,
		 _Ch_traits, _Ch_alloc>::const_iterator, _Alloc>& __m,
		 const basic_regex<_Ch_type, _Rx_traits>& __e,
		 regex_constants::match_flag_type __f
		 = regex_constants::match_default)
    { return regex_search(__s.begin(), __s.end(), __m, __e, __f); }

  // std [28.11.4] Function template regex_replace
  /**
   * @brief Search for a regular expression within a range for multiple times,
   and replace the matched parts through filling a format string.
   * @param __out   [OUT] The output iterator.
   * @param __first [IN]  The start of the string to search.
   * @param __last  [IN]  One-past-the-end of the string to search.
   * @param __e     [IN]  The regular expression to search for.
   * @param __fmt   [IN]  The format string.
   * @param __flags [IN]  Search and replace policy flags.
   *
   * @returns __out
   * @throws an exception of type regex_error.
   */
  template<typename _Out_iter, typename _Bi_iter,
	   typename _Rx_traits, typename _Ch_type,
	   typename _St, typename _Sa>
    inline _Out_iter
    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
		  const basic_regex<_Ch_type, _Rx_traits>& __e,
		  const basic_string<_Ch_type, _St, _Sa>& __fmt,
		  regex_constants::match_flag_type __flags
		  = regex_constants::match_default)
    {
      return regex_replace(__out, __first, __last, __e, __fmt.c_str(), __flags);
    }

  /**
   * @brief Search for a regular expression within a range for multiple times,
   and replace the matched parts through filling a format C-string.
   * @param __out   [OUT] The output iterator.
   * @param __first [IN]  The start of the string to search.
   * @param __last  [IN]  One-past-the-end of the string to search.
   * @param __e     [IN]  The regular expression to search for.
   * @param __fmt   [IN]  The format C-string.
   * @param __flags [IN]  Search and replace policy flags.
   *
   * @returns __out
   * @throws an exception of type regex_error.
   */
  template<typename _Out_iter, typename _Bi_iter,
	   typename _Rx_traits, typename _Ch_type>
    _Out_iter
    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
		  const basic_regex<_Ch_type, _Rx_traits>& __e,
		  const _Ch_type* __fmt,
		  regex_constants::match_flag_type __flags
		  = regex_constants::match_default);

  /**
   * @brief Search for a regular expression within a string for multiple times,
   and replace the matched parts through filling a format string.
   * @param __s     [IN] The string to search and replace.
   * @param __e     [IN] The regular expression to search for.
   * @param __fmt   [IN] The format string.
   * @param __flags [IN] Search and replace policy flags.
   *
   * @returns The string after replacing.
   * @throws an exception of type regex_error.
   */
  template<typename _Rx_traits, typename _Ch_type,
	   typename _St, typename _Sa, typename _Fst, typename _Fsa>
    inline basic_string<_Ch_type, _St, _Sa>
    regex_replace(const basic_string<_Ch_type, _St, _Sa>& __s,
		  const basic_regex<_Ch_type, _Rx_traits>& __e,
		  const basic_string<_Ch_type, _Fst, _Fsa>& __fmt,
		  regex_constants::match_flag_type __flags
		  = regex_constants::match_default)
    {
      basic_string<_Ch_type, _St, _Sa> __result;
      regex_replace(std::back_inserter(__result),
		    __s.begin(), __s.end(), __e, __fmt, __flags);
      return __result;
    }

  /**
   * @brief Search for a regular expression within a string for multiple times,
   and replace the matched parts through filling a format C-string.
   * @param __s     [IN] The string to search and replace.
   * @param __e     [IN] The regular expression to search for.
   * @param __fmt   [IN] The format C-string.
   * @param __flags [IN] Search and replace policy flags.
   *
   * @returns The string after replacing.
   * @throws an exception of type regex_error.
   */
  template<typename _Rx_traits, typename _Ch_type,
	   typename _St, typename _Sa>
    inline basic_string<_Ch_type, _St, _Sa>
    regex_replace(const basic_string<_Ch_type, _St, _Sa>& __s,
		  const basic_regex<_Ch_type, _Rx_traits>& __e,
		  const _Ch_type* __fmt,
		  regex_constants::match_flag_type __flags
		  = regex_constants::match_default)
    {
      basic_string<_Ch_type, _St, _Sa> __result;
      regex_replace(std::back_inserter(__result),
		    __s.begin(), __s.end(), __e, __fmt, __flags);
      return __result;
    }

  /**
   * @brief Search for a regular expression within a C-string for multiple
   times, and replace the matched parts through filling a format string.
   * @param __s     [IN] The C-string to search and replace.
   * @param __e     [IN] The regular expression to search for.
   * @param __fmt   [IN] The format string.
   * @param __flags [IN] Search and replace policy flags.
   *
   * @returns The string after replacing.
   * @throws an exception of type regex_error.
   */
  template<typename _Rx_traits, typename _Ch_type,
	   typename _St, typename _Sa>
    inline basic_string<_Ch_type>
    regex_replace(const _Ch_type* __s,
		  const basic_regex<_Ch_type, _Rx_traits>& __e,
		  const basic_string<_Ch_type, _St, _Sa>& __fmt,
		  regex_constants::match_flag_type __flags
		  = regex_constants::match_default)
    {
      basic_string<_Ch_type> __result;
      regex_replace(std::back_inserter(__result), __s,
		    __s + char_traits<_Ch_type>::length(__s),
		    __e, __fmt, __flags);
      return __result;
    }

  /**
   * @brief Search for a regular expression within a C-string for multiple
   times, and replace the matched parts through filling a format C-string.
   * @param __s     [IN] The C-string to search and replace.
   * @param __e     [IN] The regular expression to search for.
   * @param __fmt   [IN] The format C-string.
   * @param __flags [IN] Search and replace policy flags.
   *
   * @returns The string after replacing.
   * @throws an exception of type regex_error.
   */
  template<typename _Rx_traits, typename _Ch_type>
    inline basic_string<_Ch_type>
    regex_replace(const _Ch_type* __s,
		  const basic_regex<_Ch_type, _Rx_traits>& __e,
		  const _Ch_type* __fmt,
		  regex_constants::match_flag_type __flags
		  = regex_constants::match_default)
    {
      basic_string<_Ch_type> __result;
      regex_replace(std::back_inserter(__result), __s,
		    __s + char_traits<_Ch_type>::length(__s),
		    __e, __fmt, __flags);
      return __result;
    }

  //@}

  // std [28.12] Class template regex_iterator
  /**
   * An iterator adaptor that will provide repeated calls of regex_search over
   * a range until no more matches remain.
   */
  template<typename _Bi_iter,
	   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,
	   typename _Rx_traits = regex_traits<_Ch_type> >
    class regex_iterator
    {
    public:
      typedef basic_regex<_Ch_type, _Rx_traits>  regex_type;
      typedef match_results<_Bi_iter>            value_type;
      typedef std::ptrdiff_t                     difference_type;
      typedef const value_type*                  pointer;
      typedef const value_type&                  reference;
      typedef std::forward_iterator_tag          iterator_category;

      /**
       * @brief Provides a singular iterator, useful for indicating
       * one-past-the-end of a range.
       */
      regex_iterator()
      : _M_match()
      { }

      /**
       * Constructs a %regex_iterator...
       * @param __a  [IN] The start of a text range to search.
       * @param __b  [IN] One-past-the-end of the text range to search.
       * @param __re [IN] The regular expression to match.
       * @param __m  [IN] Policy flags for match rules.
       */
      regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,
		     regex_constants::match_flag_type __m
		     = regex_constants::match_default)
      : _M_begin(__a), _M_end(__b), _M_pregex(&__re), _M_flags(__m), _M_match()
      {
	if (!regex_search(_M_begin, _M_end, _M_match, *_M_pregex, _M_flags))
	  *this = regex_iterator();
      }

      /**
       * Copy constructs a %regex_iterator.
       */
      regex_iterator(const regex_iterator& __rhs) = default;

      /**
       * @brief Assigns one %regex_iterator to another.
       */
      regex_iterator&
      operator=(const regex_iterator& __rhs) = default;

      /**
       * @brief Tests the equivalence of two regex iterators.
       */
      bool
      operator==(const regex_iterator& __rhs) const;

      /**
       * @brief Tests the inequivalence of two regex iterators.
       */
      bool
      operator!=(const regex_iterator& __rhs) const
      { return !(*this == __rhs); }

      /**
       * @brief Dereferences a %regex_iterator.
       */
      const value_type&
      operator*() const
      { return _M_match; }

      /**
       * @brief Selects a %regex_iterator member.
       */
      const value_type*
      operator->() const
      { return &_M_match; }

      /**
       * @brief Increments a %regex_iterator.
       */
      regex_iterator&
      operator++();

      /**
       * @brief Postincrements a %regex_iterator.
       */
      regex_iterator
      operator++(int)
      {
	auto __tmp = *this;
	++(*this);
	return __tmp;
      }

    private:
      _Bi_iter                         _M_begin;
      _Bi_iter                         _M_end;
      const regex_type*                _M_pregex;
      regex_constants::match_flag_type _M_flags;
      match_results<_Bi_iter>          _M_match;
    };

  typedef regex_iterator<const char*>             cregex_iterator;
  typedef regex_iterator<string::const_iterator>  sregex_iterator;
#ifdef _GLIBCXX_USE_WCHAR_T
  typedef regex_iterator<const wchar_t*>          wcregex_iterator;
  typedef regex_iterator<wstring::const_iterator> wsregex_iterator;
#endif

  // [7.12.2] Class template regex_token_iterator
  /**
   * Iterates over submatches in a range (or @a splits a text string).
   *
   * The purpose of this iterator is to enumerate all, or all specified,
   * matches of a regular expression within a text range.  The dereferenced
   * value of an iterator of this class is a std::sub_match object.
   */
  template<typename _Bi_iter,
	   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,
	   typename _Rx_traits = regex_traits<_Ch_type> >
    class regex_token_iterator
    {
    public:
      typedef basic_regex<_Ch_type, _Rx_traits> regex_type;
      typedef sub_match<_Bi_iter>               value_type;
      typedef std::ptrdiff_t                    difference_type;
      typedef const value_type*                 pointer;
      typedef const value_type&                 reference;
      typedef std::forward_iterator_tag         iterator_category;

    public:
      /**
       * @brief Default constructs a %regex_token_iterator.
       *
       * A default-constructed %regex_token_iterator is a singular iterator
       * that will compare equal to the one-past-the-end value for any
       * iterator of the same type.
       */
      regex_token_iterator()
      : _M_position(), _M_subs(), _M_suffix(), _M_n(0), _M_result(nullptr),
      _M_has_m1(false)
      { }

      /**
       * Constructs a %regex_token_iterator...
       * @param __a          [IN] The start of the text to search.
       * @param __b          [IN] One-past-the-end of the text to search.
       * @param __re         [IN] The regular expression to search for.
       * @param __submatch   [IN] Which submatch to return.  There are some
       *                        special values for this parameter:
       *                        - -1 each enumerated subexpression does NOT
       *                          match the regular expression (aka field
       *                          splitting)
       *                        - 0 the entire string matching the
       *                          subexpression is returned for each match
       *                          within the text.
       *                        - >0 enumerates only the indicated
       *                          subexpression from a match within the text.
       * @param __m          [IN] Policy flags for match rules.
       */
      regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,
			   int __submatch = 0,
			   regex_constants::match_flag_type __m
			   = regex_constants::match_default)
      : _M_position(__a, __b, __re, __m), _M_subs(1, __submatch), _M_n(0)
      { _M_init(__a, __b); }

      /**
       * Constructs a %regex_token_iterator...
       * @param __a          [IN] The start of the text to search.
       * @param __b          [IN] One-past-the-end of the text to search.
       * @param __re         [IN] The regular expression to search for.
       * @param __submatches [IN] A list of subexpressions to return for each
       *                          regular expression match within the text.
       * @param __m          [IN] Policy flags for match rules.
       */
      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,
			   const regex_type& __re,
			   const std::vector<int>& __submatches,
			   regex_constants::match_flag_type __m
			     = regex_constants::match_default)
      : _M_position(__a, __b, __re, __m), _M_subs(__submatches), _M_n(0)
      { _M_init(__a, __b); }

      /**
       * Constructs a %regex_token_iterator...
       * @param __a          [IN] The start of the text to search.
       * @param __b          [IN] One-past-the-end of the text to search.
       * @param __re         [IN] The regular expression to search for.
       * @param __submatches [IN] A list of subexpressions to return for each
       *                          regular expression match within the text.
       * @param __m          [IN] Policy flags for match rules.
       */
      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,
			   const regex_type& __re,
			   initializer_list<int> __submatches,
			   regex_constants::match_flag_type __m
			     = regex_constants::match_default)
      : _M_position(__a, __b, __re, __m), _M_subs(__submatches), _M_n(0)
      { _M_init(__a, __b); }

      /**
       * Constructs a %regex_token_iterator...
       * @param __a          [IN] The start of the text to search.
       * @param __b          [IN] One-past-the-end of the text to search.
       * @param __re         [IN] The regular expression to search for.
       * @param __submatches [IN] A list of subexpressions to return for each
       *                          regular expression match within the text.
       * @param __m          [IN] Policy flags for match rules.
       */
      template<std::size_t _Nm>
	regex_token_iterator(_Bi_iter __a, _Bi_iter __b,
			     const regex_type& __re,
			     const int (&__submatches)[_Nm],
			     regex_constants::match_flag_type __m
			     = regex_constants::match_default)
      : _M_position(__a, __b, __re, __m),
      _M_subs(__submatches, __submatches + _Nm), _M_n(0)
      { _M_init(__a, __b); }

      /**
       * @brief Copy constructs a %regex_token_iterator.
       * @param __rhs [IN] A %regex_token_iterator to copy.
       */
      regex_token_iterator(const regex_token_iterator& __rhs)
      : _M_position(__rhs._M_position), _M_subs(__rhs._M_subs),
      _M_suffix(__rhs._M_suffix), _M_n(__rhs._M_n), _M_has_m1(__rhs._M_has_m1)
      { _M_normalize_result(); }

      /**
       * @brief Assigns a %regex_token_iterator to another.
       * @param __rhs [IN] A %regex_token_iterator to copy.
       */
      regex_token_iterator&
      operator=(const regex_token_iterator& __rhs);

      /**
       * @brief Compares a %regex_token_iterator to another for equality.
       */
      bool
      operator==(const regex_token_iterator& __rhs) const;

      /**
       * @brief Compares a %regex_token_iterator to another for inequality.
       */
      bool
      operator!=(const regex_token_iterator& __rhs) const
      { return !(*this == __rhs); }

      /**
       * @brief Dereferences a %regex_token_iterator.
       */
      const value_type&
      operator*() const
      { return *_M_result; }

      /**
       * @brief Selects a %regex_token_iterator member.
       */
      const value_type*
      operator->() const
      { return _M_result; }

      /**
       * @brief Increments a %regex_token_iterator.
       */
      regex_token_iterator&
      operator++();

      /**
       * @brief Postincrements a %regex_token_iterator.
       */
      regex_token_iterator
      operator++(int)
      {
	auto __tmp = *this;
	++(*this);
	return __tmp;
      }

    private:
      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> _Position;

      void
      _M_init(_Bi_iter __a, _Bi_iter __b);

      const value_type&
      _M_current_match() const
      {
	if (_M_subs[_M_n] == -1)
	  return (*_M_position).prefix();
	else
	  return (*_M_position)[_M_subs[_M_n]];
      }

      constexpr bool
      _M_end_of_seq() const
      { return _M_result == nullptr; }

      // [28.12.2.2.4]
      void
      _M_normalize_result()
      {
	if (_M_position != _Position())
	  _M_result = &_M_current_match();
	else if (_M_has_m1)
	  _M_result = &_M_suffix;
	else
	  _M_result = nullptr;
      }

      _Position         _M_position;
      std::vector<int>  _M_subs;
      value_type        _M_suffix;
      std::size_t       _M_n;
      const value_type* _M_result;

      // Show whether _M_subs contains -1
      bool              _M_has_m1;
    };

  /** @brief Token iterator for C-style NULL-terminated strings. */
  typedef regex_token_iterator<const char*>             cregex_token_iterator;

  /** @brief Token iterator for standard strings. */
  typedef regex_token_iterator<string::const_iterator>  sregex_token_iterator;

#ifdef _GLIBCXX_USE_WCHAR_T
  /** @brief Token iterator for C-style NULL-terminated wide strings. */
  typedef regex_token_iterator<const wchar_t*>          wcregex_token_iterator;

  /** @brief Token iterator for standard wide-character strings. */
  typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
#endif

  //@} // group regex
_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#include <bits/regex.tcc>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            // The template and inlines for the numeric_limits classes. -*- C++ -*-

// Copyright (C) 1999-2014 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/limits
 *  This is a Standard C++ Library header.
 */

// Note: this is not a conforming implementation.
// Written by Gabriel Dos Reis <gdr@codesourcery.com>

//
// ISO 14882:1998
// 18.2.1
//

#ifndef _GLIBCXX_NUMERIC_LIMITS
#define _GLIBCXX_NUMERIC_LIMITS 1

#pragma GCC system_header

#include <bits/c++config.h>

//
// The numeric_limits<> traits document implementation-defined aspects
// of fundamental arithmetic data types (integers and floating points).
// From Standard C++ point of view, there are 14 such types:
//   * integers
//         bool							(1)
//         char, signed char, unsigned char, wchar_t            (4)
//         short, unsigned short				(2)
//         int, unsigned					(2)
//         long, unsigned long					(2)
//
//   * floating points
//         float						(1)
//         double						(1)
//         long double						(1)
//
// GNU C++ understands (where supported by the host C-library)
//   * integer
//         long long, unsigned long long			(2)
//
// which brings us to 16 fundamental arithmetic data types in GNU C++.
//
//
// Since a numeric_limits<> is a bit tricky to get right, we rely on
// an interface composed of macros which should be defined in config/os
// or config/cpu when they differ from the generic (read arbitrary)
// definitions given here.
//

// These values can be overridden in the target configuration file.
// The default values are appropriate for many 32-bit targets.

// GCC only intrinsically supports modulo integral types.  The only remaining
// integral exceptional values is division by zero.  Only targets that do not
// signal division by zero in some "hard to ignore" way should use false.
#ifndef __glibcxx_integral_traps
# define __glibcxx_integral_traps true
#endif

// float
//

// Default values.  Should be overridden in configuration files if necessary.

#ifndef __glibcxx_float_has_denorm_loss
#  define __glibcxx_float_has_denorm_loss false
#endif
#ifndef __glibcxx_float_traps
#  define __glibcxx_float_traps false
#endif
#ifndef __glibcxx_float_tinyness_before
#  define __glibcxx_float_tinyness_before false
#endif

// double

// Default values.  Should be overridden in configuration files if necessary.

#ifndef __glibcxx_double_has_denorm_loss
#  define __glibcxx_double_has_denorm_loss false
#endif
#ifndef __glibcxx_double_traps
#  define __glibcxx_double_traps false
#endif
#ifndef __glibcxx_double_tinyness_before
#  define __glibcxx_double_tinyness_before false
#endif

// long double

// Default values.  Should be overridden in configuration files if necessary.

#ifndef __glibcxx_long_double_has_denorm_loss
#  define __glibcxx_long_double_has_denorm_loss false
#endif
#ifndef __glibcxx_long_double_traps
#  define __glibcxx_long_double_traps false
#endif
#ifndef __glibcxx_long_double_tinyness_before
#  define __glibcxx_long_double_tinyness_before false
#endif

// You should not need to define any macros below this point.

#define __glibcxx_signed(T)	((T)(-1) < 0)

#define __glibcxx_min(T) \
  (__glibcxx_signed (T) ? -__glibcxx_max (T) - 1 : (T)0)

#define __glibcxx_max(T) \
  (__glibcxx_signed (T) ? \
   (((((T)1 << (__glibcxx_digits (T) - 1)) - 1) << 1) + 1) : ~(T)0)

#define __glibcxx_digits(T) \
  (sizeof(T) * __CHAR_BIT__ - __glibcxx_signed (T))

// The fraction 643/2136 approximates log10(2) to 7 significant digits.
#define __glibcxx_digits10(T) \
  (__glibcxx_digits (T) * 643L / 2136)

#define __glibcxx_max_digits10(T) \
  (2 + (T) * 643L / 2136)

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @brief Describes the rounding style for floating-point types.
   *
   *  This is used in the std::numeric_limits class.
  */
  enum float_round_style
  {
    round_indeterminate       = -1,    /// Intermediate.
    round_toward_zero         = 0,     /// To zero.
    round_to_nearest          = 1,     /// To the nearest representable value.
    round_toward_infinity     = 2,     /// To infinity.
    round_toward_neg_infinity = 3      /// To negative infinity.
  };

  /**
   *  @brief Describes the denormalization for floating-point types.
   *
   *  These values represent the presence or absence of a variable number
   *  of exponent bits.  This type is used in the std::numeric_limits class.
  */
  enum float_denorm_style
  {
    /// Indeterminate at compile time whether denormalized values are allowed.
    denorm_indeterminate = -1,
    /// The type does not allow denormalized values.
    denorm_absent        = 0,
    /// The type allows denormalized values.
    denorm_present       = 1
  };

  /**
   *  @brief Part of std::numeric_limits.
   *
   *  The @c static @c const members are usable as integral constant
   *  expressions.
   *
   *  @note This is a separate class for purposes of efficiency; you
   *        should only access these members as part of an instantiation
   *        of the std::numeric_limits class.
  */
  struct __numeric_limits_base
  {
    /** This will be true for all fundamental types (which have
	specializations), and false for everything else.  */
    static _GLIBCXX_USE_CONSTEXPR bool is_specialized = false;

    /** The number of @c radix digits that be represented without change:  for
	integer types, the number of non-sign bits in the mantissa; for
	floating types, the number of @c radix digits in the mantissa.  */
    static _GLIBCXX_USE_CONSTEXPR int digits = 0;

    /** The number of base 10 digits that can be represented without change. */
    static _GLIBCXX_USE_CONSTEXPR int digits10 = 0;

#if __cplusplus >= 201103L
    /** The number of base 10 digits required to ensure that values which
	differ are always differentiated.  */
    static constexpr int max_digits10 = 0;
#endif

    /** True if the type is signed.  */
    static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;

    /** True if the type is integer.  */
    static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;

    /** True if the type uses an exact representation. All integer types are
	exact, but not all exact types are integer.  For example, rational and
	fixed-exponent representations are exact but not integer. */
    static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;

    /** For integer types, specifies the base of the representation.  For
	floating types, specifies the base of the exponent representation.  */
    static _GLIBCXX_USE_CONSTEXPR int radix = 0;

    /** The minimum negative integer such that @c radix raised to the power of
	(one less than that integer) is a normalized floating point number.  */
    static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;

    /** The minimum negative integer such that 10 raised to that power is in
	the range of normalized floating point numbers.  */
    static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;

    /** The maximum positive integer such that @c radix raised to the power of
	(one less than that integer) is a representable finite floating point
	number.  */
    static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;

    /** The maximum positive integer such that 10 raised to that power is in
	the range of representable finite floating point numbers.  */
    static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

    /** True if the type has a representation for positive infinity.  */
    static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;

    /** True if the type has a representation for a quiet (non-signaling)
	Not a Number.  */
    static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;

    /** True if the type has a representation for a signaling
	Not a Number.  */
    static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;

    /** See std::float_denorm_style for more information.  */
    static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm = denorm_absent;

    /** True if loss of accuracy is detected as a denormalization loss,
	rather than as an inexact result. */
    static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

    /** True if-and-only-if the type adheres to the IEC 559 standard, also
	known as IEEE 754.  (Only makes sense for floating point types.)  */
    static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;

    /** True if the set of values representable by the type is
	finite.  All built-in types are bounded, this member would be
	false for arbitrary precision types. */
    static _GLIBCXX_USE_CONSTEXPR bool is_bounded = false;

    /** True if the type is @e modulo. A type is modulo if, for any
	operation involving +, -, or * on values of that type whose
	result would fall outside the range [min(),max()], the value
	returned differs from the true value by an integer multiple of
	max() - min() + 1. On most machines, this is false for floating
	types, true for unsigned integers, and true for signed integers.
	See PR22200 about signed integers.  */
    static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

    /** True if trapping is implemented for this type.  */
    static _GLIBCXX_USE_CONSTEXPR bool traps = false;

    /** True if tininess is detected before rounding.  (see IEC 559)  */
    static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;

    /** See std::float_round_style for more information.  This is only
	meaningful for floating types; integer types will all be
	round_toward_zero.  */
    static _GLIBCXX_USE_CONSTEXPR float_round_style round_style = 
						    round_toward_zero;
  };

  /**
   *  @brief Properties of fundamental types.
   *
   *  This class allows a program to obtain information about the
   *  representation of a fundamental type on a given platform.  For
   *  non-fundamental types, the functions will return 0 and the data
   *  members will all be @c false.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS:  DRs 201 and 184 (hi Gaby!) are
   *  noted, but not incorporated in this documented (yet).
  */
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {
      /** The minimum finite value, or for floating types with
	  denormalization, the minimum positive normalized value.  */
      static _GLIBCXX_CONSTEXPR _Tp
      min() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

      /** The maximum finite value.  */
      static _GLIBCXX_CONSTEXPR _Tp
      max() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

#if __cplusplus >= 201103L
      /** A finite value x such that there is no other finite value y
       *  where y < x.  */
      static constexpr _Tp
      lowest() noexcept { return _Tp(); }
#endif

      /** The @e machine @e epsilon:  the difference between 1 and the least
	  value greater than 1 that is representable.  */
      static _GLIBCXX_CONSTEXPR _Tp
      epsilon() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

      /** The maximum rounding error measurement (see LIA-1).  */
      static _GLIBCXX_CONSTEXPR _Tp
      round_error() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

      /** The representation of positive infinity, if @c has_infinity.  */
      static _GLIBCXX_CONSTEXPR _Tp
      infinity() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

      /** The representation of a quiet Not a Number,
	  if @c has_quiet_NaN. */
      static _GLIBCXX_CONSTEXPR _Tp
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

      /** The representation of a signaling Not a Number, if
	  @c has_signaling_NaN. */
      static _GLIBCXX_CONSTEXPR _Tp
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

      /** The minimum positive denormalized value.  For types where
	  @c has_denorm is false, this is the minimum positive normalized
	  value.  */
      static _GLIBCXX_CONSTEXPR _Tp
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }
    };

#if __cplusplus >= 201103L
  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
#endif

  // Now there follow 16 explicit specializations.  Yes, 16.  Make sure
  // you get the count right. (18 in c++0x mode)

  /// numeric_limits<bool> specialization.
  template<>
    struct numeric_limits<bool>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR bool 
      min() _GLIBCXX_USE_NOEXCEPT { return false; }

      static _GLIBCXX_CONSTEXPR bool 
      max() _GLIBCXX_USE_NOEXCEPT { return true; }

#if __cplusplus >= 201103L
      static constexpr bool
      lowest() noexcept { return min(); }
#endif
      static _GLIBCXX_USE_CONSTEXPR int digits = 1;
      static _GLIBCXX_USE_CONSTEXPR int digits10 = 0;
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR bool 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return false; }

      static _GLIBCXX_CONSTEXPR bool 
      round_error() _GLIBCXX_USE_NOEXCEPT { return false; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR bool 
      infinity() _GLIBCXX_USE_NOEXCEPT { return false; }

      static _GLIBCXX_CONSTEXPR bool 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return false; }

      static _GLIBCXX_CONSTEXPR bool 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return false; }

      static _GLIBCXX_CONSTEXPR bool 
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return false; }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

      // It is not clear what it means for a boolean type to trap.
      // This is a DR on the LWG issue list.  Here, I use integer
      // promotion semantics.
      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<char> specialization.
  template<>
    struct numeric_limits<char>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR char 
      min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min(char); }

      static _GLIBCXX_CONSTEXPR char 
      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max(char); }

#if __cplusplus >= 201103L
      static constexpr char 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (char);
      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (char);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = __glibcxx_signed (char);
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR char 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR char 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR 
      char infinity() _GLIBCXX_USE_NOEXCEPT { return char(); }

      static _GLIBCXX_CONSTEXPR char 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return char(); }

      static _GLIBCXX_CONSTEXPR char 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return char(); }

      static _GLIBCXX_CONSTEXPR char 
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast<char>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = !is_signed;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<signed char> specialization.
  template<>
    struct numeric_limits<signed char>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR signed char 
      min() _GLIBCXX_USE_NOEXCEPT { return -__SCHAR_MAX__ - 1; }

      static _GLIBCXX_CONSTEXPR signed char 
      max() _GLIBCXX_USE_NOEXCEPT { return __SCHAR_MAX__; }

#if __cplusplus >= 201103L
      static constexpr signed char 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (signed char);
      static _GLIBCXX_USE_CONSTEXPR int digits10 
       = __glibcxx_digits10 (signed char);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR signed char 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR signed char 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR signed char 
      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<signed char>(0); }

      static _GLIBCXX_CONSTEXPR signed char 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<signed char>(0); }

      static _GLIBCXX_CONSTEXPR signed char 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<signed char>(0); }

      static _GLIBCXX_CONSTEXPR signed char 
      denorm_min() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<signed char>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<unsigned char> specialization.
  template<>
    struct numeric_limits<unsigned char>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR unsigned char 
      min() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned char 
      max() _GLIBCXX_USE_NOEXCEPT { return __SCHAR_MAX__ * 2U + 1; }

#if __cplusplus >= 201103L
      static constexpr unsigned char 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits 
       = __glibcxx_digits (unsigned char);
      static _GLIBCXX_USE_CONSTEXPR int digits10 
       = __glibcxx_digits10 (unsigned char);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR unsigned char 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned char 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR unsigned char 
      infinity() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned char>(0); }

      static _GLIBCXX_CONSTEXPR unsigned char 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned char>(0); }

      static _GLIBCXX_CONSTEXPR unsigned char 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned char>(0); }

      static _GLIBCXX_CONSTEXPR unsigned char 
      denorm_min() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned char>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<wchar_t> specialization.
  template<>
    struct numeric_limits<wchar_t>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR wchar_t 
      min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min (wchar_t); }

      static _GLIBCXX_CONSTEXPR wchar_t 
      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max (wchar_t); }

#if __cplusplus >= 201103L
      static constexpr wchar_t
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (wchar_t);
      static _GLIBCXX_USE_CONSTEXPR int digits10 
       = __glibcxx_digits10 (wchar_t);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = __glibcxx_signed (wchar_t);
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR wchar_t 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR wchar_t 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR wchar_t 
      infinity() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }

      static _GLIBCXX_CONSTEXPR wchar_t 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }

      static _GLIBCXX_CONSTEXPR wchar_t 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }

      static _GLIBCXX_CONSTEXPR wchar_t 
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = !is_signed;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

#if __cplusplus >= 201103L
  /// numeric_limits<char16_t> specialization.
  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t 
      min() noexcept { return __glibcxx_min (char16_t); }

      static constexpr char16_t 
      max() noexcept { return __glibcxx_max (char16_t); }

      static constexpr char16_t 
      lowest() noexcept { return min(); }

      static constexpr int digits = __glibcxx_digits (char16_t);
      static constexpr int digits10 = __glibcxx_digits10 (char16_t);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = __glibcxx_signed (char16_t);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t 
      epsilon() noexcept { return 0; }

      static constexpr char16_t 
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t 
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t 
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t 
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t 
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = __glibcxx_integral_traps;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };

  /// numeric_limits<char32_t> specialization.
  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t 
      min() noexcept { return __glibcxx_min (char32_t); }

      static constexpr char32_t 
      max() noexcept { return __glibcxx_max (char32_t); }

      static constexpr char32_t 
      lowest() noexcept { return min(); }

      static constexpr int digits = __glibcxx_digits (char32_t);
      static constexpr int digits10 = __glibcxx_digits10 (char32_t);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = __glibcxx_signed (char32_t);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t 
      epsilon() noexcept { return 0; }

      static constexpr char32_t 
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t 
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t 
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t 
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t 
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = __glibcxx_integral_traps;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };
#endif

  /// numeric_limits<short> specialization.
  template<>
    struct numeric_limits<short>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR short 
      min() _GLIBCXX_USE_NOEXCEPT { return -__SHRT_MAX__ - 1; }

      static _GLIBCXX_CONSTEXPR short 
      max() _GLIBCXX_USE_NOEXCEPT { return __SHRT_MAX__; }

#if __cplusplus >= 201103L
      static constexpr short 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (short);
      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (short);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR short 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR short 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR short 
      infinity() _GLIBCXX_USE_NOEXCEPT { return short(); }

      static _GLIBCXX_CONSTEXPR short 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return short(); }

      static _GLIBCXX_CONSTEXPR short 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return short(); }

      static _GLIBCXX_CONSTEXPR short 
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return short(); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<unsigned short> specialization.
  template<>
    struct numeric_limits<unsigned short>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR unsigned short 
      min() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned short 
      max() _GLIBCXX_USE_NOEXCEPT { return __SHRT_MAX__ * 2U + 1; }

#if __cplusplus >= 201103L
      static constexpr unsigned short 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits 
       = __glibcxx_digits (unsigned short);
      static _GLIBCXX_USE_CONSTEXPR int digits10 
       = __glibcxx_digits10 (unsigned short);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR unsigned short 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned short 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR unsigned short 
      infinity() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned short>(0); }

      static _GLIBCXX_CONSTEXPR unsigned short 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned short>(0); }

      static _GLIBCXX_CONSTEXPR unsigned short 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned short>(0); }

      static _GLIBCXX_CONSTEXPR unsigned short 
      denorm_min() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned short>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<int> specialization.
  template<>
    struct numeric_limits<int>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR int 
      min() _GLIBCXX_USE_NOEXCEPT { return -__INT_MAX__ - 1; }

      static _GLIBCXX_CONSTEXPR int 
      max() _GLIBCXX_USE_NOEXCEPT { return __INT_MAX__; }

#if __cplusplus >= 201103L
      static constexpr int 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (int);
      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (int);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR int 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR int 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR int 
      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<int>(0); }

      static _GLIBCXX_CONSTEXPR int 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<int>(0); }

      static _GLIBCXX_CONSTEXPR int 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<int>(0); }

      static _GLIBCXX_CONSTEXPR int 
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast<int>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<unsigned int> specialization.
  template<>
    struct numeric_limits<unsigned int>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR unsigned int 
      min() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned int 
      max() _GLIBCXX_USE_NOEXCEPT { return __INT_MAX__ * 2U + 1; }

#if __cplusplus >= 201103L
      static constexpr unsigned int 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits 
       = __glibcxx_digits (unsigned int);
      static _GLIBCXX_USE_CONSTEXPR int digits10 
       = __glibcxx_digits10 (unsigned int);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR unsigned int 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned int 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR unsigned int 
      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<unsigned int>(0); }

      static _GLIBCXX_CONSTEXPR unsigned int 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned int>(0); }

      static _GLIBCXX_CONSTEXPR unsigned int 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned int>(0); }

      static _GLIBCXX_CONSTEXPR unsigned int 
      denorm_min() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned int>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<long> specialization.
  template<>
    struct numeric_limits<long>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR long
      min() _GLIBCXX_USE_NOEXCEPT { return -__LONG_MAX__ - 1; }

      static _GLIBCXX_CONSTEXPR long 
      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_MAX__; }

#if __cplusplus >= 201103L
      static constexpr long 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (long);
      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (long);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR long 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR long 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR long 
      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<long>(0); }

      static _GLIBCXX_CONSTEXPR long 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<long>(0); }

      static _GLIBCXX_CONSTEXPR long 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<long>(0); }

      static _GLIBCXX_CONSTEXPR long 
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast<long>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<unsigned long> specialization.
  template<>
    struct numeric_limits<unsigned long>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR unsigned long 
      min() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned long 
      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_MAX__ * 2UL + 1; }

#if __cplusplus >= 201103L
      static constexpr unsigned long 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits 
       = __glibcxx_digits (unsigned long);
      static _GLIBCXX_USE_CONSTEXPR int digits10 
       = __glibcxx_digits10 (unsigned long);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR unsigned long 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned long 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR unsigned long 
      infinity() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned long>(0); }

      static _GLIBCXX_CONSTEXPR unsigned long 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned long>(0); }

      static _GLIBCXX_CONSTEXPR unsigned long 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned long>(0); }

      static _GLIBCXX_CONSTEXPR unsigned long 
      denorm_min() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned long>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<long long> specialization.
  template<>
    struct numeric_limits<long long>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR long long 
      min() _GLIBCXX_USE_NOEXCEPT { return -__LONG_LONG_MAX__ - 1; }

      static _GLIBCXX_CONSTEXPR long long 
      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_LONG_MAX__; }

#if __cplusplus >= 201103L
      static constexpr long long 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits 
       = __glibcxx_digits (long long);
      static _GLIBCXX_USE_CONSTEXPR int digits10 
       = __glibcxx_digits10 (long long);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR long long 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR long long 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR long long 
      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<long long>(0); }

      static _GLIBCXX_CONSTEXPR long long 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<long long>(0); }

      static _GLIBCXX_CONSTEXPR long long 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<long long>(0); }

      static _GLIBCXX_CONSTEXPR long long 
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast<long long>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<unsigned long long> specialization.
  template<>
    struct numeric_limits<unsigned long long>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR unsigned long long 
      min() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned long long 
      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_LONG_MAX__ * 2ULL + 1; }

#if __cplusplus >= 201103L
      static constexpr unsigned long long 
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits 
       = __glibcxx_digits (unsigned long long);
      static _GLIBCXX_USE_CONSTEXPR int digits10 
       = __glibcxx_digits10 (unsigned long long);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR unsigned long long 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned long long 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR unsigned long long 
      infinity() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned long long>(0); }

      static _GLIBCXX_CONSTEXPR unsigned long long 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned long long>(0); }

      static _GLIBCXX_CONSTEXPR unsigned long long 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned long long>(0); }

      static _GLIBCXX_CONSTEXPR unsigned long long 
      denorm_min() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned long long>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_toward_zero;
    };

#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)
  /// numeric_limits<__int128> specialization.
  template<>
    struct numeric_limits<__int128>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR __int128
      min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min (__int128); }

      static _GLIBCXX_CONSTEXPR __int128
      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max (__int128); }

#if __cplusplus >= 201103L
      static constexpr __int128
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits
       = __glibcxx_digits (__int128);
      static _GLIBCXX_USE_CONSTEXPR int digits10
       = __glibcxx_digits10 (__int128);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR __int128
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR __int128
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR __int128
      infinity() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<__int128>(0); }

      static _GLIBCXX_CONSTEXPR __int128
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<__int128>(0); }
      
      static _GLIBCXX_CONSTEXPR __int128
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<__int128>(0); }
      
      static _GLIBCXX_CONSTEXPR __int128
      denorm_min() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<__int128>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

      static _GLIBCXX_USE_CONSTEXPR bool traps
       = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<unsigned __int128> specialization.
  template<>
    struct numeric_limits<unsigned __int128>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR unsigned __int128
      min() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned __int128
      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max (unsigned __int128); }

#if __cplusplus >= 201103L
      static constexpr unsigned __int128
      lowest() noexcept { return min(); }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits
       = __glibcxx_digits (unsigned __int128);
      static _GLIBCXX_USE_CONSTEXPR int digits10
       = __glibcxx_digits10 (unsigned __int128);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
      static _GLIBCXX_USE_CONSTEXPR int radix = 2;

      static _GLIBCXX_CONSTEXPR unsigned __int128
      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_CONSTEXPR unsigned __int128
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm
       = denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;

      static _GLIBCXX_CONSTEXPR unsigned __int128
      infinity() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned __int128>(0); }

      static _GLIBCXX_CONSTEXPR unsigned __int128
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned __int128>(0); }

      static _GLIBCXX_CONSTEXPR unsigned __int128
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned __int128>(0); }

      static _GLIBCXX_CONSTEXPR unsigned __int128
      denorm_min() _GLIBCXX_USE_NOEXCEPT
      { return static_cast<unsigned __int128>(0); }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style
       = round_toward_zero;
    };
#endif

  /// numeric_limits<float> specialization.
  template<>
    struct numeric_limits<float>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR float 
      min() _GLIBCXX_USE_NOEXCEPT { return __FLT_MIN__; }

      static _GLIBCXX_CONSTEXPR float 
      max() _GLIBCXX_USE_NOEXCEPT { return __FLT_MAX__; }

#if __cplusplus >= 201103L
      static constexpr float 
      lowest() noexcept { return -__FLT_MAX__; }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits = __FLT_MANT_DIG__;
      static _GLIBCXX_USE_CONSTEXPR int digits10 = __FLT_DIG__;
#if __cplusplus >= 201103L
      static constexpr int max_digits10
	 = __glibcxx_max_digits10 (__FLT_MANT_DIG__);
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;
      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;

      static _GLIBCXX_CONSTEXPR float 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return __FLT_EPSILON__; }

      static _GLIBCXX_CONSTEXPR float 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0.5F; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __FLT_MIN_EXP__;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __FLT_MIN_10_EXP__;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __FLT_MAX_EXP__;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __FLT_MAX_10_EXP__;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __FLT_HAS_INFINITY__;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm
	= bool(__FLT_HAS_DENORM__) ? denorm_present : denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss 
       = __glibcxx_float_has_denorm_loss;

      static _GLIBCXX_CONSTEXPR float 
      infinity() _GLIBCXX_USE_NOEXCEPT { return __builtin_huge_valf(); }

      static _GLIBCXX_CONSTEXPR float 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nanf(""); }

      static _GLIBCXX_CONSTEXPR float 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nansf(""); }

      static _GLIBCXX_CONSTEXPR float 
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return __FLT_DENORM_MIN__; }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559
	= has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_float_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before 
       = __glibcxx_float_tinyness_before;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_to_nearest;
    };

#undef __glibcxx_float_has_denorm_loss
#undef __glibcxx_float_traps
#undef __glibcxx_float_tinyness_before

  /// numeric_limits<double> specialization.
  template<>
    struct numeric_limits<double>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR double 
      min() _GLIBCXX_USE_NOEXCEPT { return __DBL_MIN__; }

      static _GLIBCXX_CONSTEXPR double 
      max() _GLIBCXX_USE_NOEXCEPT { return __DBL_MAX__; }

#if __cplusplus >= 201103L
      static constexpr double 
      lowest() noexcept { return -__DBL_MAX__; }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits = __DBL_MANT_DIG__;
      static _GLIBCXX_USE_CONSTEXPR int digits10 = __DBL_DIG__;
#if __cplusplus >= 201103L
      static constexpr int max_digits10
	 = __glibcxx_max_digits10 (__DBL_MANT_DIG__);
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;
      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;

      static _GLIBCXX_CONSTEXPR double 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return __DBL_EPSILON__; }

      static _GLIBCXX_CONSTEXPR double 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0.5; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __DBL_MIN_EXP__;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __DBL_MIN_10_EXP__;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __DBL_MAX_EXP__;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __DBL_MAX_10_EXP__;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __DBL_HAS_INFINITY__;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm
	= bool(__DBL_HAS_DENORM__) ? denorm_present : denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss 
        = __glibcxx_double_has_denorm_loss;

      static _GLIBCXX_CONSTEXPR double 
      infinity() _GLIBCXX_USE_NOEXCEPT { return __builtin_huge_val(); }

      static _GLIBCXX_CONSTEXPR double 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nan(""); }

      static _GLIBCXX_CONSTEXPR double 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nans(""); }

      static _GLIBCXX_CONSTEXPR double 
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return __DBL_DENORM_MIN__; }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559
	= has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_double_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before 
       = __glibcxx_double_tinyness_before;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
       = round_to_nearest;
    };

#undef __glibcxx_double_has_denorm_loss
#undef __glibcxx_double_traps
#undef __glibcxx_double_tinyness_before

  /// numeric_limits<long double> specialization.
  template<>
    struct numeric_limits<long double>
    {
      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;

      static _GLIBCXX_CONSTEXPR long double 
      min() _GLIBCXX_USE_NOEXCEPT { return __LDBL_MIN__; }

      static _GLIBCXX_CONSTEXPR long double 
      max() _GLIBCXX_USE_NOEXCEPT { return __LDBL_MAX__; }

#if __cplusplus >= 201103L
      static constexpr long double 
      lowest() noexcept { return -__LDBL_MAX__; }
#endif

      static _GLIBCXX_USE_CONSTEXPR int digits = __LDBL_MANT_DIG__;
      static _GLIBCXX_USE_CONSTEXPR int digits10 = __LDBL_DIG__;
#if __cplusplus >= 201103L
      static _GLIBCXX_USE_CONSTEXPR int max_digits10
	 = __glibcxx_max_digits10 (__LDBL_MANT_DIG__);
#endif
      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;
      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;
      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;

      static _GLIBCXX_CONSTEXPR long double 
      epsilon() _GLIBCXX_USE_NOEXCEPT { return __LDBL_EPSILON__; }

      static _GLIBCXX_CONSTEXPR long double 
      round_error() _GLIBCXX_USE_NOEXCEPT { return 0.5L; }

      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __LDBL_MIN_EXP__;
      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __LDBL_MIN_10_EXP__;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __LDBL_MAX_EXP__;
      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __LDBL_MAX_10_EXP__;

      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __LDBL_HAS_INFINITY__;
      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __LDBL_HAS_QUIET_NAN__;
      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;
      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm
	= bool(__LDBL_HAS_DENORM__) ? denorm_present : denorm_absent;
      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss
	= __glibcxx_long_double_has_denorm_loss;

      static _GLIBCXX_CONSTEXPR long double 
      infinity() _GLIBCXX_USE_NOEXCEPT { return __builtin_huge_vall(); }

      static _GLIBCXX_CONSTEXPR long double 
      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nanl(""); }

      static _GLIBCXX_CONSTEXPR long double 
      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nansl(""); }

      static _GLIBCXX_CONSTEXPR long double 
      denorm_min() _GLIBCXX_USE_NOEXCEPT { return __LDBL_DENORM_MIN__; }

      static _GLIBCXX_USE_CONSTEXPR bool is_iec559
	= has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;

      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_long_double_traps;
      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = 
					 __glibcxx_long_double_tinyness_before;
      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style = 
						      round_to_nearest;
    };

#undef __glibcxx_long_double_has_denorm_loss
#undef __glibcxx_long_double_traps
#undef __glibcxx_long_double_tinyness_before

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#undef __glibcxx_signed
#undef __glibcxx_min
#undef __glibcxx_max
#undef __glibcxx_digits
#undef __glibcxx_digits10
#undef __glibcxx_max_digits10

#endif // _GLIBCXX_NUMERIC_LIMITS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ELF          (    X  4   p  4    (                  L L             8  <                                      D   D         Qtd                          Rtd                        GNU SqW%8+Z]?         GNU                                   c5R                           
            t              F           "                                                             U               ,                             {     d    i           __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses gconv_init strcmp gconv _dl_mcount_wrapper_check __assert_fail __pointer_chk_guard libc.so.6 ld-linux-armhf.so.3 GLIBC_PRIVATE GLIBC_2.4                                    c	                      ii                  8        $   (   ,   0 	  4 
                 @-  -  H H H H H0 0   R/ ,   @-808 0  00` S$00 0  S3/  X $   @-@ @0  00`4 C1 ?0    R2/X T  4   L @- D0  0  R4 0  S  
(0 0 0           4 @-  ,0  0  R  
 0  S   
3/@h P 0    Q   /8@- @P P  P  PP 08 P$(, 00040  8 o  P	  0   8 $0(0,0  8T O-lM@$(  ?<T <@08 P@@	  <P  Q@  
0 0(@  T`   X@ 0  @$$@  XX@,@`@,  \X0 
  8@(80 / .B BD4    SHL" 
@$`@P@p d Y/  
@ Y : V   0  1u  
Hs\ xR @x@ v  R  x    \ x    i   V  ,d dd 0`Pdp Y   @(  \ P_  P  U  
` @(`$@   P  
    p0</P  U` @000 $ W  hP@  00%  P T0@</ P   
\ \   X  8@ $(<80 p R  0d0  `0dp0P`0sP0 VL  w d0  d0  d `PdpP  `Pa   R:  0S  

 R*#R`@PO
,  \Z  
 @  TK  
` 0dp`P`8(  @  T9  
  I  0  p`
 </ P
 P` 01 
`Pdp&0 V@SD4=0a  \
   R 
0  S0  
 Vd0    Rd0d  ` 0`Pdp<@   
,P`P 0 0 0@" Tb
  X_
  \  l Y 
$@ V :L0<$
p  @1 P0 <@,   0 C} R#   Y  @ S@B#"   | \ g,B  P B%  01  S!  
P 0p Y  
 V0  : 01 0 C} R SP  ZD  
 @  TA  
 0P0 Y 0<<@'   R  
 R,  
	  R,  
JR0  
  Z+  
    R(  
 00 0 V0P<0*@   0P  V%p!*p@ ( P  \
  pl  @ (8 809@@  T 8@80  S6 
($@ \ d@`   \0  
0\P   0 S0l@0 Y :$@ TS  * L\P0  0 Y `0 X S   Q  p`P\0  
|  pR  w S x c  OS 0t0 r   R  z
  j   'V  $@0 V!  "$d0  d  0d `    R=  
 p e0 Ra  ((0c d@ 8 $@80  @@<@0 l  XA  T P 0 @  T@ 
88   R 
` Qh  :! "$    ppI  
0@ 0  l  S(8 80$&$0 Vwd0 d 0 d   `  0 ` %% S  $ d  0`  0 ` 4  -0 
    S6   R?  
 @ S*;   S  :@ x@ 0 @P T 0@</l lh@ 0(b  ppP T0@8/ P
d0 V @  P
l# .B Bd    P/  3S``E  
,  \k  
 @  Ti  
`dpP  .( 8  0, p </ P-  @  T` 
P< 0
,@ `  00 00 0 S0  
  S$0  
$0 V$@d0     Rd0d  ] `q p` ` 
 R
P 0 P* Xc  
(@  j   `   R  P   RF   
 X   `j]` Q   R0 ` Q[:!    00 0 @  @  P T0@@4/l1  .0  R 0  @!0 0  w/0 0   0( Y 	  0 `0 S0 S 0p pp0  b/0k, (   {   t  v v w p  r r $t Ls r s s r s 8s r s r 0r ,s l
  n n o n hn xo n Hn Xo   n (n 8o   m m n @m Xm n /  m l 0n   Xf @ f      b    d    &  Hh 0g h   h g |h (@ \ @@    \  
  \@d  @e $ P V&: dp @ Y  T   Z     d0 C} PW  e@ R9  e  @B#"q Q  S00g,B  S B  101  S   Rb  
 R]  
01 RW  
JRF  
,  X

< 
 00 0 0$Pg  Q.  @( b 8   @0 0$P80@f   RF  
 g@ l(@ P 5   PC   R ; @   Q06
00 Se;  
$@ 0 02  -0?$  V11$@%f"$ %0% 05 0%$P5f2???<<<3  w/0yPPP3  X#0q```3  h#0i,  X
< 
 0e0 0 0$ gf@<3  b/0N3  #0F XF(@ 0	 c R   Y  (
  @     0   0 Y0    +TTT4  \$0!@$pP@$p	P@ `0$0!  P`0 @`Pdp&( @ @8@80L@  S @  
D4@.0@@0`@$@`d@@$P,`@>CL@@ 0C p< H0   Y/  
   Yl  : TY     0!J  
trQ xS  x  *  S 0x0 9  Q x 1  05     T:  !d  d d   `pdP Y 0` 0-  X0  @0 p 0<6  T  wd  d   d  0`pdPp `p66 S   d  0`0dP0p`0`0(@\  p U   S  $ U@00C0`0   S   R  
< S*  @ Y@   
$ @ \  : 0 p`L0,`H  Pp< 1n   0C} Qg  
 Y+   S  H@A!H x X gA  PA  <1  Sg   QK  
 QF  
  Q7  
JQ$  
  V  
0  Q  
 0
 p0 0@ \  : 0` 0H ( H@  @`H  0`H  0?    \  :0P Y`H  0? 1 0`H  P0? ?  S   
 0P  V
00  S
 0 0 0p$P0$P0 	9  )0	9  ..00!-  lH   Q$  3S`  p
  V=  
   X6  
dP`p    X.  
  ( 8  0P` </ P
 P  .  
`pdP 0 S  
0  S0  
 Td0    Rd0d   `00 p`0`pdPL   `0 0p0 `p 0  q` 0`pdP@-C  2L  F  E  xE  gr wM  E  | L  | ;  6G  DG  GL  @L  B 6 Rs n p WL  Q OG  E  L  l| M  J  F  #k %r  TZ c > a? Mf  V      }  Y   =  4  { [  ^ Z  %6   Z  [  \  ng    E at  t  u8  S 6 !` >                                                                                                                                          X :  z    aA  1 
 ^2 
C      /  0I    X  J    y  2z  `f  )j    Lt  {  g  ,z  OR  F  4  s  ] t    W  /I  LT  1A  6 X  rz  e{   F  n A  ] {  $   $ $ $     5 @    D   b  np                                                                                                                                                1  1  1  1  1   1      1  1     1    1  1  1  1   1  1                       L                                   Q            +          M          k                                                                                                                                                                            a  #  #                                                                                                                                                                                                                                                                                                                                                                   E     
e          =N  n  N            5w d  O  (O  O  VQ  tQ  Q  Q  R  R  ;S  NS  S  S  V  X  Y  Y  2Y  4Y  f[  [  [  \  ^  ;`  e  g  h  eh  Nm  p  5u  ~  ~  ~  ~  ~  ~    7  z    o        f  g  n                                                                                                                                          t  |  }  Fi  z  'R                    x  ^            	             L      >L   p 
  3 5      n  >  u      I  l      y  l   * $N  N  N  N  N  N  7O  L4  O  H>  P  P  }4  4  4  Q  Y  Q  Q  R  N  yR  R  'S  5  S  Q5  S  S5  S  #T  m5  r5  6  T  T  T  T  T  T  U  #U  (U  5  ?U  5  5  U  5                  } %U      B  +Q U  , 9  A F  M  S@   zw  8, 4:  G  ] i M d  |    d  ~    d , V D     F M  G  N ,   g:   ?  5  R  x D- n        C  ` d  T  L- + w 9  o                                                                                                                                         f g y d  RP C h  ! L 1     H   ?  sX  -     E  ` L  yU  @  C      J  f*       yc  9  u'   V  |d  C>       	 * ,      9 9  :   x5  I^   RV  1 ,   4  =l  ;N         tu . " [  z 4 h    ( 9) 5  Q    ?  0 G O L       H  = ?  & 2d                   3 9v + ~  Q, U, :    . 2 Pk      T    U       &    ^w - @q  m    \  re 4  7  _S       w  5  M 	6   V  '   x x H  U y PN - TZ      W                                                                                                                                           v   { ~Q 7    R  I : wA | X  hR  6  =W {  h[   H  ,K  '  I      t[ =1 U  5  V  (N  Y   x Q    [N  N  >5  #\  Q_  _  8  Lb  5e  zk  5l  :l  lp  +r  ,N  r  H R  ;y  |  S  jb 4      Kc     f Qi ]S  d    x       x         u      c   |      ok    7N      7b                        ;P  m  s   =    NA wp  \   K  Q Y5  0] "a  2     q  g  s  2  <   K  x  t  Q   	@  cj   #B    o
 *z  G  U  Mp  $S  ~    v     w  N  O  P  /N  O    4T  }  X  X   ^  ^  _  ' e                                                                                                                                          3 i  Cj  c< l       r  E s  >  J [  t    \ V z  {  |  l~                  _    !     ? q@  B  Z              h  kg  vB  =W        {I   q L  tm {]  k o     [    f  [~  Wn  y  =  D  V2 ' C  6E      \  ;   x\  =  Q5 x]    Wq  XE  @ # wL  x9  J4   Al   O  9 Y  l  V   ;_                       ! m A  F  y ?     @  7  F  Fl |A   s mE  8  T aE  E  M  {L  vM  E  ?  K a6  D  D  A  >]  H]  V]  =  8  ]  ]   8  88  B^  ^  %_  _  9  9  ?9  M9  `  =a  \  9  a  a  a  9  ,b  b  b  c  9  V                                                                                                                                          :  c  c  d  Zd  K:  d  ]  !V    :  e  :  e  Sf  :  f  ";  g  B;  g   h  X;  Jh  h  r;  q;  {;  	i  Ci  \r  di  i  i  ;  i  ;  ej  tj  qj  j  ;  j  ;  j  j  j  j  k  k  k  ul  l  <  m  m  &m  m  <  m  m  n  n  )n  n   n  n  n    n  n  $o  4o  F=  A? o  o  j=  u=  q  \  =  ,p  =  Pp  Tp  op  p  p  % C  5                   > W  n >q  W N6  i   t[  Iz  X  ez  }z  Y z  z  z  z  q  d A  z  z  z  A  T  \ {  U{  ){  S \ {  o{    [ l {  !  {       ] =  e\   {      5|  \ D|  |  H |  }f  xE |  |  |  t|  |  |                                                                                                                                              g~  E  Dn ]}  n t  }  }  5q  }      W@ )` }  =  }   }  m     !a Za n~  ~  +C  l  '~  @  A  G  6y  b     Qc   a h  \E  f7 E  :   d             /   l ;  <  a  ' I  &f = f %g    H     X  & l  d O d     ^ Sj  eJ J zD  )   Rj ~= O     b  
k I 05 s =   i   A                  K        6  }1 Z5 {      > m k k 5 =    U    E  m         ~4  n Wj  Z  4  Bn . X  [ q  =  D  j  J  < Xy      k wn Cn         D      \ @B  \ CE  4  Z  n 'E  s  E  g                                                                                                                                            % ;   p    p  jE  (  H6   S  s ~  q     ',       aV  l  Vh  F  E  F  u = u ^    [F      c    ww  w                 %   $y z   w      Yz z  :{ ? G  8{ |q      0T eU ?  L  M    zJ        F  O    T} }  %7  S}   } }        \p    L >                          I |;   q z            -  e       P
   *I   = = ^  b2      %# 9  n 7  < z a  l              g  :      |  3    l  A  b  U      <  U                                                                                                                                         1 ,  k    p  Z    eI  D   9  s  [        &    o  B  z&  | .> I  l  {    lA    n a    x     S  I  l t d   J  
3 1  B  6  J  =E  E  J up  A[         W  J[   _  %  P  0 0               lT   t  3        zy J  4  3  K  f  ;  uq Q=  0 \A                 W         J  'm  U        x  9  )J rK  W      ;    X  %W 6           L    -    4P  4  i 8  }0 P  @  > EZ  c   KB       h       #  ~    4   h                                                                                                                                            [!    ; 3 9            4M      dC   `;  9  =  2O  7  +     K  $  m       9  V  V  E         b  i  z    r  K  uI I wq  I HC QJ s    y  ~ 6 i    D       l D r  >  rw  Cz  p  sD C ~q   p   5 >   /T  "7   9 6  t  K_ #7   [W  %J                       6     U  I eq 1> \U > Rp D  6  &o g  37  <  =  lX  " h  W@  ?7 @ @ A !l T  V  f V          N  +Q  8  6D N  e  KO  O  QV hZ    9  
  54  )O    u    N                                                                                                                                          P  Q  O  O  J > BO  .P  lP  P  O  O  XP  P                  vn  5 9> > rm   > Q  Q   D     z    YR  R  s R      zF  q  C   I  i       >  t  t  Vt  s  K  J @ S  5  r  @ U  E T   W  ]    f  W  W  W  >6  X  Z  F  o  ,Z  Y    ~Z  Z  Z  FY  a B 6  m  Ct  !Z  ^                 Z      t   q  rI       7  \  \  ^^  H^   | : ^  O[    7   6   6  *  G  r4  _  _  '  kZ  ; D[    u `  ~`  `( +& _  >  % %  so a  >  F  & a  a  u`  , - F M                                                                                                                                         qd  eF j+ ):  "+ P4  x. 7c  [ d  1c  c  I g- b  , ;d  ke  ri  ;  0 2 I 2 U  2  ? f  2 1 :  A  U " U  [U %T x  1 * 42 d4  2 1 B f  $m kf  K  0f  px  cf  2 2 f  rX 8  :8 7 ;  7 3 t  ;  g  *F h  h  ;  j  c8  7 D 3j  Rj  j  k   e  h  Lj  ;  zj  Wk  ? <                           g  m  o  I     ? =  n  <@ =Z  
n  GX  $m  Bx  ;q  C vB p  Pr  r  r  G %G yQ  J  zt  > _6 JJ I _ ?  >  J # 5? `  >  t  <t    7t  D  m QE  u  c?  L M X?  Uu  sv   ;  ht   I I :                                                                                                                                          =  NJ >  I H   2W  B   d P  !R Q xw  22 w  w  {w  F 7 ^:  H 8t  t  >  J J @  J a   U x  x  x  x  s  Yy  Aw V A        y  -j  > :z  y  nA   2A  5  y  L I  = n 5  kU  p5  6    z  YZ  & Z Z Z  [ x  *Z  [ z  A  ]|  m|  B  [ ^ ^ |  I  |  ||  |  j  }  ~  }  N  ab                 \a H{ }  ^ jB  uk 	 g  N  5 W  d c bI   '{  , Z C] {  ^   E  c  j  ?4 9  I e   e   'q l D  7  D    	  B  g   Bj b  e  Qj S  m   r Z  A  @ +[   Z      = -  "t Z                                                                                                                                          n  EO        e  M  V T  w w     >    F  F  7  =    H M_  +  B e  )q  p  E m      } Y  w  Y  nC  6  *    	L 0  J  B  Xl  o  !# H  yo  n     6  /I       qU  I      K b@   '   ;   +          4 Et  >  H BJ C >  %2    f e >  I xJ ? t  kt  >  A                   Gh  J   W     h   & / c   [  i  <I  s  B   q  8  & ]   J         D  P gJ d   E  ?  *  %I    ;  M  { =    oK    \  e X j  !  Z  /   K  H   K  K  }  rX   "X  I                                                                                                                                          Dx  ' = h  }=  X  '9  Pa  ' k) a  O  S  {  5        -     !  L  A   L       /     n o k   3E  m n m       n 7 d` y  5 @6 -I  I b=      H   x  w  M  O  @4  d  ]U =x  Tx  x  Kx  W 1 AI 6  rO  o  o      p  T  A W  X  W    W  4q  4  A q  @l O      I                 a  Z  Z  B  D ,7  {K         r  l  B &, C Y  = Ag }  [a ` I I    s  >  t  c  >  J j  s  s  >  >J J  fJ  $ I Ht  I p  vI   s  _   1       U 5I   kq                                                                                                                                          CI  V     U  y   }   PJ R .E    
7   I Y    t Z  6  [= 6  _  yZ   b t  <  
 J  9  P  i=  L=   uq  B   n   D  Wm  O~ gp  l  <  ? -> n  o  o=   Qu  6  4  F  >  qH  Y  n  >I  A   k X  W  6  R p  bC qJ /  # h  gi   4 { 6  7 3 L j  6 l >  D  D                  &m Qm l o o  	q =  :   l Sp  Y  Z   aZ  qZ   A -7  Y  < 6  q    f  B nZ  +Z  B +j  > 6w [D B q  YB  O  (m \  D M~ C j  VB  p  3q  C =  l  % OJ e~  Y  /]  =  \_  ]J  }  &                                                                                                                                          T  :  3  ~W    ?    p  [ p]  s  |  Y   O    r  s  z 8s  9s  V As  Hs  >  { l  q  H s    >  w  >  l  V  t  t  t  >  >  >  >  t  ?  S?  Bu  mu  ru  u  |?  u  u  ?  Mv  ?  tv  ?  zv  \O q  #V    iX  @  Cw  9@  ag  E@  5  w  j@  o@  ^\  w  w  X  x  p  x  @  9x  Gx  Qx  fx  H  5U 3y  h  2y  A                  	A  y  y    z    gA  z  A  z  y  A  z  z  A  !N  b{  l{  {{  |  |  `B  zB  {|  |  B  |  B  |    p   }  }  }  }      r  C     %  9{  .  1  T  =  W  p      C    *s      `u    D  9;  V  Y  Z                                                                                                                                          D  :X  |    %D    -D    W      T  D    v        D  W  i  i    p  d  `    E          8  R  ;E  o  p    wE  r        E    F  F      $  G    gy )  8      Q        G  _X    G  N  :  U  TW  q  U    7H                    3    H      I  (  X  k                                  C      EI  QI      S    -  >  jI  T  y  -    I    3  I  g  $J  @  5J      TV  J  `    K    DX      Q    7  B  ]  b  pK    K  <    z  i          mL     o7   I  :                                                                                                                                            PV              {                  z  D      i    Y   @X    7    v  WW  sq  
 
  jT  ;  T   ; S e | `   zV     o   Ui  /        - s  \   ^  \ O v g  {   G6    / ; dS     u 6   w    xN  p  - j                 - E * p   b    q  Uh  E  i  6  |" # # *' q( O)   g) ) *   *   +   ?+ G    L,     , , [ - - - - B. t/ / 30 f0 3 3 _  Hf  f  yz g5 5     I     6 7     F X  g                                                                                                                                          i  : Wv _ > > u   H  J  A  B C ;@ 4C C EJ  Q   Y   ;  < D D W  tF 9  /G   b7  ! ^  N     H H J 	r  J x eY  N O y   ,P R  ?W  qq  R T J? J U  FT nT Rk     s4  ?U 2v ^U G  bU fU W ?I ]X fP  4  3     Y |G  H Z [ \  W  Qq      a | V  a O b  d Jd                 []  k     d    I d ? e K  e f ' e  W a  'Z       V  !E f jN  4I V  m  l 6  w  g nh d ^h     h B{   
 &i     9i Ez      i &  -j _6  id !  y  4j [k ,]  5     k F  l ;u  e  m X                                                                                                                                          7  % Kp q T<  r r   z! r 0  r I 9l    Pt  '    &) s  n  *J   9  6          ?E  f    C  w Xx V  @  
 9  /7   q  f  y      L  p  y 
z { f} zA C{  ~y  	 o   j   S  n   6h  ]  o # i  /2 H ]  0  W  #  I ]  I e  i  S  J ? <  6g    .  O                     /  5  h  H  c  V x  U   C   C   F  Y  	            < =  ^ J   r  V      2  I j  (  Z  ~   # L  G   q   M     M     U                                                                                                                                            $   J 	E  ~  Vo  j  N  4  , x :7     $ l  >z f =  Uv < 5V VY N  ^ Xb V  m   m[  > L c       { 0e  -V  J\ T  S =   }L  "V  V  I  ^ uY  @= p  N   I 6   ^    ;v  E  Nv  w  E  2T  H    %V  2      U  by  CV  T   5  V  U  f   -6  4u  U  U  T  rU  A  ^  HQ v b,                    Z}  U  u b  m  T    q  v  c  c  c  iU  C+ r  . Q  4   Q  MT  U  U  fv  -  h u               D  s  G [    h {V  & /} A s} n r p     <    fr   NG  O   @                                                                                                                                          ]  e  - H  G |  
     u      H`  q  ~  P  N  N  w5  [  l  gS  6  9  }S  6  F X  nK -  KT  W  Z y	     R:  e$ ts   	M    < 0 [L  O   \  = r g  7 .c  %}  > ,> *:    R  t>  z6  E   @v  Z   zx  . X  @  |V    t]  Tv  4   L      7  a  0 C     ]V   W  cI  4R  p 5      |                  V|  9  W  l S\  d   5c dq   ( "m J q     Q   ]       L  {    \  {  hb  5c    {  *  ~|      B|  |    {  	        >I Z  sU  [  O    O  `R  >  R  gW  VP  Y  ^      \  iT    @    ,S  0a                                                                                                                                          ,i  S  
    ;L  A  i  P  Fu  m   sR      Y    \      Q   c  #m j  V    zu  b   Os  p|  !\ <     I v    *N     B      J\  i      zW  R  ]  N  1l   9O  T  T  R    5      5      Rk  |      .          zq  {      k    x       V  J w  S        O      b  } (  u  z  wJ >z  x  l  g  v                  Z &  l    u   Sx  @   r  qs  -  s  t    J /  _    D      ; n     ~  %     `  gv    D  n                ,s  !    5  r  L  Q|  J  Ya Ya  L    }a      _W  oa  b  9b      \:  a  S  3 dc  h  5                                                                                                                                          W]     9     P  F y  2S  8  ; e@      w      |  _ |  -z  f  c  M}  u  t      g  b  t [  t    $w    g Su  n         I    C  +w  t    56  i              m    @ t  =  vq  `  a  <      w`      q  -     `  ~K   R  <  < ^ Vv 1U D   m p \  a  w6   Fh O bE  [  Lc P    kb                  0    0  0    "           0  &   %   P  d  R     T  U  V  W  \     1     3      4  O    	  5  6  [  ]  7  8  0  0  9  :  0  0  ;  <  
0  0  =  >  0  	0  ?  @  0  0  A  B  0  0  C  D  Y  Z                                                                                                                                          [  \  ]  ^              0  0  5   2       
  ;      0  %  %  %  %  %  &  &  %  %  %  %  %  %  2  !  >       ?      I  J  M  N  K  L  _  `  a               "        f"  g"  `"  "  R"  a"  b  c  d  e  f  <"  )"  *"  "   "  "  "  3  3  +"  ."  5"  4"  @&  B&  A&  	&  !  !  !  !  !  !  !  !  %"  #"                            <       0             !  	!  i  j  k  3  3  3  3  3  3  3  3  3     YQ  [Q  ^Q  ]Q  aQ  cQ  U  t  |  %  %  %  %  %  %  %  %  %  %  %  %  %  %  %  <%  4%  ,%  $%  %  %   %  %  %  %  %  %  %  m%                                                                                                                                          n%  p%  o%  P%  ^%  j%  a%  %  %  %  %  q%  r%  s%                      `!  a!  b!  c!  d!  e!  f!  g!  h!  i!  !0  "0  #0  $0  %0  &0  '0  (0  )0      DS      !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V                  W  X  Y  Z                                                                                                  1  1  1  1  	1  
1  1  1  1  1  1                                                                                                                                          1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1   1  !1  "1  #1  $1  %1  &1  '1  (1  )1                                                                                                                                                                                                                                                                                         N  YN  N  N  CN  ]N  N  N  N  ?Q  eQ  kQ  Q   R  R  R  S  AS  \S  S  	N  N  N  
N  +N  8N  Q  EN  HN  _N  ^N  N  N  @Q  R  R  CS  S  S  W  X  Y  'Y  sY  P[  Q[  S[  [  \  "\  8\  q\  ]  ]  ]  ]  ]  ]  r^  ^  _  _  Mb                                                                                                                                          N  N  N  -N  0N  9N  KN  9\  N  N  N  N  N  N  N  N  N  N  N  N  N  N  N  CQ  AQ  gQ  mQ  nQ  lQ  Q  Q  R  R  R  R  R  R  S  9S  HS  GS  ES  ^S  S  S  S  S  X  )Y  +Y  *Y  -Y  T[  \  $\  :\  o\  ]  {^  ^  _  _  _  b  6b  Kb  Nb  /e  e  e  e  e  e  f  g  (g   k  bk  yk  k  k  k  l  4l  kp  *r  6r  ;r  Gr  Yr  [r  r  s  N                  N  N  N  N  ;N  MN  ON  NN  N  N  N  N  N  N  N  N  N  N  EQ  DQ  Q  Q  Q  Q  Q  Q  
R  R  R  S  S  S  S  N  JS  IS  aS  `S  oS  nS  S  S  S  S  S  S  S  S  S  S  S  S  S  S  S  S  S  S  S  S  V  V  Y                                                                                                                                          .Y  1Y  tY  vY  U[  [  <\  ]  ]  ]  ^  ^  s^  |^  _  _  _  _  
b  Sb  Tb  Rb  Qb  e  e  .g  ,g  *g  +g  -g  ck  k  l  l  8l  Al  @l  >l  r  s  s  t  t  u  u  (u  )u  0u  1u  2u  3u  u  }v  v  v  v  w  w  w  :y  y  tz  z  N  N  RN  SN  iN  N  N  N  N  N  	O  O  
O  O  O  O  O  O  N  N  N  N  N  N  O  O  IQ  GQ  FQ  HQ  hQ                  qQ  Q  Q  R  R  R  R  R  R  S  !S   S  pS  qS  	T  T  T  
T  T  T  T  T  T  T  T  T  T  T  T  V  V  V  3W  0W  (W  -W  ,W  /W  )W  Y  Y  7Y  8Y  Y  xY  Y  }Y  yY  Y  Y  W[  X[  [  [  [  [  [  \  y\  ]  ^  v^  t^                                                                                                                                          _  _  _  _  b  b  b  b  cb  [b  Xb  6e  e  e  e  e  f  f  	g  =g  4g  1g  5g  !k  dk  {k  l  ]l  Wl  Yl  _l  `l  Pl  Ul  al  [l  Ml  Nl  pp  _r  ]r  ~v  z  s|  |  6              3                        n  r  ~  k  @  L  c    !  2N  N  MO  OO  GO  WO  ^O  4O  [O  UO  0O  PO  QO  =O  :O  8O  CO  TO  <O  FO  cO                  \O  `O  /O  NO  6O  YO  ]O  HO  ZO  LQ  KQ  MQ  uQ  Q  Q  %R  $R  )R  *R  (R  R  R  R  R  #S  sS  uS  T  -T  T  >T  &T  NT  'T  FT  CT  3T  HT  BT  T  )T  JT  9T  ;T  8T  .T  5T  6T   T  <T  @T  1T  +T  T  ,T  V  V  V  V  JW  QW  @W  MW                                                                                                                                          GW  NW  >W  PW  OW  ;W  X  >Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  ][  \[  Z[  [[  [  [  [  ,\  @\  A\  ?\  >\  \  \  \  \  ]  ^  ^  ^  ^  ^  _  _  d_  b_  w_  y_  _  _  _  _  _  _  _  _  b  b  b  b  b  b  vb  b  mb  b  |b  ~b  yb  sb  b  ob  b  nb  b  b  b  b  9e  ;e  8e  e  f  _g  Ng  Og  Pg  Qg  \g  Vg  ^g  Ig  Fg  `g                  Sg  Wg  ek  k  Bl  ^l  l  l  l  l  l  l  jl  zl  l  pl  l  hl  l  l  }l  l  rl  ~l  tl  l  vl  l  l  l  l  vp  |p  }p  xp  br  ar  `r  r  r  s  ,u  +u  7u  8u  v  v  w  y  y  y  vz  |  U                o                                                                                                                                                       7  F  U    d  p                    ]            I      2  .  1  *  ,  &N  VN  sN  N  N  N  N  N  oO  O  O  sO  O  lO  O  O  O  O  pO  uO  O  iO  {O  O  ~O  O  O  zO  TQ  RQ  UQ  iQ  wQ  vQ  xQ  Q  Q  ;R  8R  7R  :R  0R  .R  6R  AR  R  R  RS  TS  SS  QS  fS  wS  xS  yS  S  S  S  sT  uT                  T  xT  T  T  {T  wT  T  T  T  |T  T  qT  vT  T  T  bT  hT  T  }T  T  V  W  wW  jW  iW  aW  fW  dW  |W  Y  IY  GY  HY  DY  TY  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  _[  d[  c[  [  [  [  [  [  [  \  H\  E\                                                                                                                                          F\  \  \  \  \  \  \  \  ^  ^  ^  ^  ^  ^  x^  ^  ^  ^  ^  ^  ^  &_  '_  )_  _  _  _  |_  _  _  _  _  _  `  `  /`  5`  `  *`  `  !`  '`  )`  +`  `  b  b  ?b  >b  @b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  >e  e  e  e  f  f  f  f  f  f   f  f  f  
f                  f  g  g  mg  g  g  qg  g  sg  wg  g  g  g  og  pg  g  g  ~g  g  ug  g  g  |g  jg  rg  #k  fk  gk  k  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l                                                                                                                                          p  p  p  p  p  ,r  -r  8r  Hr  gr  ir  r  r  r  r  r  s  s  s  s  s  =u  u  u  u  v  v  v  v  w  w  >y  @y  Ay  y  y  zz  yz  z  |  T                                                                  N  q  R  h                      w      @  ?  ;  D                  B      R  ^  N  N  N  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  WQ  Q  Q  Q  NR  CR  JR  MR  LR  KR  GR  R  R  R  R  S  WS  {S  S  S  T  T  T  T  T  T  T  T  T  T  T  T  T                                                                                                                                          T  T  T  T  T  T  T  T  T  V  W  W  W  W  W  W  W  W  UY  QY  OY  NY  PY  Y  Y  Y  Y  Y  Z  Y  Y  Y  Y  Z  Y  i[  [  [  [  [  [  \  N\  O\  M\  K\  \  \  ]  ^  %^  ^  }^  ^  ^  ^  _  -_  e_  _  _  _  _  _  _  _  `  `   `  %`  `  (`  M`  p`  h`  b`  F`  C`  l`  k`  j`  d`  Ab  b  c  	c  b  b  c  b  b  c  b  b                  b  b  b  b  c  c  ?e  Ee  e  e  e  %f  -f   f  'f  /f  f  (f  1f  $f  f  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  jk  k  k  k  k  k  l  l  m  2m  *m  Am  %m  m  1m  m  m                                                                                                                                          ;m  =m  >m  6m  m  l  9m  'm  8m  )m  .m  5m  m  +m  p  p  p  p  p  p  p  p  p  0r  rr  or  tr  r  r  r  s  s  s  s  s  s  s  u  -u  Ou  Lu  Nu  Ku  u  u  u  u  u  xv  v  v  v  v  v  v  v  w  v  v  	w  w  v  v  w  w  x  x  x  x  Fy  Iy  Hy  Gy  y  y  y  y  y  z  z  z  z  }|  }  }   }  	}  }  }  }  8                              6                            "                    	                          P  y  {  z  M  k                t  s                                                                                                                                                                          K  J      P  K  L  M  b  i                    XN  N  P  P  #P  O  &P  %P  O  )P  P  P  <P  P  P  P  P  O   P  P  (P  O  !P  P  P  P  O  O  -P  *P  O  +P  	P  |Q  Q  Q  Q  Q  Q  Q  Q  VR  \R  TR  [R  ]R  *S  S  S  S  S  T  U  U  7U  T  T  T  U  T  U  T  T  T  	U  T  T                  T  'U  U  T  U  W  W  W  W  W  W  	X  Y  WY  XY  ZY  Z  Z  Z  Z  Z  Z  Y   Z  #Z  )Z  %Z  Z  	Z  k[  X\  [  [  [  [  [  [  [  [  \  Q\  U\  P\  \  \  \  \  \  \  \  ]  \  ]  -^  +^  ^  ^  ^  1_  _  _  _  Y`                                                                                                                                          c`  e`  P`  U`  m`  i`  o`  `  `  `  `  `  `  `  `  Gb  b  c  b  Nc  >c  /c  Uc  Bc  Fc  Oc  Ic  :c  Pc  =c  *c  +c  (c  Mc  Lc  He  Ie  e  e  e  Bf  If  Of  Cf  Rf  Lf  Ef  Af  f  g  g  g  !h  8h  Hh  Fh  Sh  9h  Bh  Th  )h  h  h  Lh  Qh  =h  g  Ph  @h  <h  Ch  *h  Eh  h  h  Ah  k  k  k  #l  'l  (l  &l  $l  l  jm  m  m  m  fm  xm  wm  Ym  m                  lm  m  nm  Zm  tm  im  m  m  ym  m  em  m  p  p  p  p  p  p  9r  yr  r  r  r  r  r  s  s  	t  s  s  s  s  Tu  ]u  \u  Zu  Yu  u  u  u  u  u  u  u  u  u  u  v  v  v  v  v  )w  w   w  (w  w  0x  'x  8x  x  4x  7x                                                                                                                                          %x  -x   x  x  2x  Uy  Py  `y  _y  Vy  ^y  ]y  Wy  Zy  y  y  y  y  y  y  y  z  z  z  {  {  |  !}  }  }  
}   }  "}  }  }  }  }  }  }  }  }  :  _                  =  ?                        
               *  +  (  ,    +  R  T  J  8  P  I  5  4  O  2  9  6    @  1  (  C                  T                  p  w      }  y            
            H  z  y      w                                         R  M  L              b  c  a                                                                                                                                          [  ]  d  X  ^            %  2  <  ~N  zP  }P  \P  GP  CP  LP  ZP  IP  eP  vP  NP  UP  uP  tP  wP  OP  P  oP  mP  \Q  Q  Q  jR  oR  R  R  R  R  S  S  S  ?S  @S  >S  S  f  FU  jU  fU  DU  ^U  aU  CU  JU  1U  VU  OU  UU  /U  dU  8U  .U  \U  ,U  cU  3U  AU  WU  W  W  	W  W  X  
X  X  W  W  W  X  5X  W  W   Y  bY  6Z  AZ  IZ  fZ  jZ  @Z                  <Z  bZ  ZZ  FZ  JZ  p[  [  [  [  [  [  [  	\  \  \  `\  \\  ]\  ]  ]  ]  ]  ]  "]  ]  )]  ]  ]  $]  ']  ]  ]  8^  6^  3^  7^  ^  ^  ^  ^  ^  5_  7_  W_  l_  i_  k_  _  _  _  _  _  _  _  `  `  `  `  `  `  `  `  `                                                                                                                                          `  `  `  `  `  `  `  `  `  `  `  `  b  b  Hb  c  c  rc  c  c  c  wc  gc  c  c  qc  c  c  c  c  kc  c  c  c  c  c  c  c  c  c  {c  ic  hc  zc  ]e  Ve  Qe  Ye  We  _U  Oe  Xe  Ue  Te  e  e  e  e  e  e  e  ]f  Zf  df  hf  ff  ^f  f  R  g  h  h  h  h  h  h  vh  h  h  h  h  h  h  h  h  h  h  h  h  h  h  h  2k  k                  k  k  +l  m  m  m  m  m  m  m  m  m  m  n  m  m  m  m  m  m  m  m  m  m  m  m  n  m  m  m  m  m  m  m  m  m  m  m  m  m  m  p  	q  
q  p  p  =r  }r  r  s  s  s  s  s  s  t  
t  t  t  s  t  t  t                                                                                                                                          t  u  "u  eu  fu  bu  pu  u  u  u  u  u  u  v  v  v  v  7w  >w  <w  6w  8w  :w  kx  Cx  Nx  ey  hy  my  y  z  z   {  ({  {  ,{  &{  {  {  .{  |  |  |  F}  C}  q}  .}  9}  <}  @}  0}  3}  D}  /}  B}  2}  1}  =              J  F  /    #  +  )  0  $    5  7  6  9        x                    w  {  |                      U  j_                      S                    *    #  %  1  -      "  I  Z              g  f                  #                 "                                                                                                                                                      W                  j  u  s  x  p  t  v  w  l        z  z      Z    u        P  P  P  P  P  P  P  P  P   g  Q  rR  tR  uR  iR  R  R  R  ZS  S  {U  U  U  |U  U  U  U  U  U  U  U  U  U  U  U  U  U  >U  U  U  U  U  U  ~U  U  U  U  W  /X  *X  4X  $X  0X  1X  !X  X   X  X  X  `Y                  wZ  Z  Z  Z  Z  Z  s[  q[  [  [  [  [  
\  \  1\  L]  P]  4]  G]  ]  E^  =^  @^  C^  ~^  ^  ^  ^  ^  <_  m_  _  _  _  `  `  `  `  `  a  #a  `  a  `  `  `  ha  `  a  `  	a   a  a  b  Ib  c  c  c  c  c  c  c  c                                                                                                                                          c  c  c  c  c  c  c  vc  c  c  c  Rd  c  c  ^e  fe  be  ce  e  e  e  nf  pf  tf  vf  of  f  zf  ~f  wf  f  f  g  g  h  h  h  h  h  i  h  h  h  h  h  h  h  h  h  h  i  i  i  h  h  ni  h  >k  :k  =k  k  k  k  k  .l  /l  ,l  /n  8n  Tn  !n  2n  gn  Jn   n  %n  #n  n  [n  Xn  $n  Vn  nn  -n  &n  on  4n  Mn  :n  ,n  Cn  n  >n  n                  n  n  Nn  cn  Dn  rn  in  _n  q  q  &q  0q  !q  6q  nq  q  Lr  r  r  6s  %s  4s  )s  :t  *t  3t  "t  %t  5t  6t  4t  /t  t  &t  (t  %u  &u  ku  ju  u  u  u  u  u  u  u  {v  |v  v  v  v  v  Ow  w  ]x  lx  ox  z  z  z  z   z  z                                                                                                                                          z  z  z  z  I{  V{  F{  P{  R{  T{  M{  K{  O{  Q{  |  |  ^}  P}  h}  U}  +}  n}  r}  a}  f}  b}  p}  s}  U        R    U  T  K  Q  N  9  F  >  L  S  t                            W  
              8              [                  W            ;  `  U  ^  <  A                  T  [  P  F  4  :  6  V  a                                                          .  5  1  8  2  6      	    c  e        #  	                                                                                                                                                                        }        r                                                N  P  P  P  P  P  P  P  P  P  P  P  R  wR  }R  R  R  R  R  R  /S  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  W  W  ^X  QX  XX  WX  ZX  TX  kX  LX  mX  JX  bX  RX  KX  gY  Z  Z  Z  Z  Z  Z                  Z  Z  Z  i]  o]  L^  y^  ^  ^  _  Y_  _  _  a  a  Ha  a  `  a  `  a  a  Na  La  Da  Ma  >a  4a  'a  a  a  7a  !b  "b  d  >d  d  *d  -d  =d  ,d  d  d  d  d  6d  d  d  d  le  e  e  f  f  f  f  f  f  f  f  g  i  mi                                                                                                                                          Zi  wi  `i  Ti  ui  0i  i  Ji  hi  ki  ^i  Si  yi  i  ]i  ci  [i  Gk  rk  k  k  k  k  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  Nq  Yq  iq  dq  Iq  gq  \q  lq  fq  Lq  eq  ^q  Fq  hq  Vq  :r  Rr  7s  Es  ?s  >s  ot  Zt  Ut  _t  ^t  At  ?t  Yt  [t  \t  vu  xu   v  u  v  u  u  u  u  u  u  v  v  [w  kw  fw  ^w  cw                  yw  jw  lw  \w  ew  hw  bw  w  x  x  x  x  x  x  |x  x  x  x  zy  y  y  ,  y  z  z   z  z  z  z  z  z  w{  {  `{  n{  g{  |  |  |  }  y}  }  }  }  [}  n  i  j  r        V  X      q  p  x  e  n  s  k                                                                                                                                          y  z  f    G    w  =  1  u  f  k  I  l  [  <  5  a  c  i  m  F  ^  \  _                       
  Y                          k  r  s  f  i  p    |  c    q    m  b  n  l  y  {  >  h  b                                            	    
                      K  J  S  B  T  <  U  P  G  O  N  M  Q  >  A      l  j  i    7  W  8  =  @  >  [  K  d  Q  4  I  M  E  9  ?  Z                          V  t  v        
                                                                                                                                                                         P  P  P  P  P  P  P  P  P  P  P  P  bQ  Q  R  R  1S  S  U   V  V  V  U  V  V  	V  V  V  U  V  V  V  V  U  W  W  uX  ~X  X  X  X  yX  X  }X  X  %Y  "Y  $Y  jY  iY  Z  Z  Z  Z  Z  Z  Z  u[  [  [  [  [  [  [  [  [  [  \  b\  ]  ]  [^  c^  U^  W^  T^  ^  ^  
_  F_  p_  _  Ga                  ?a  Ka  wa  ba  ca  _a  Za  Xa  ua  *b  d  Xd  Td  d  xd  _d  zd  Qd  gd  4d  md  {d  re  e  e  e  f  f  f  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  Ik  Lk  3l  3o  o  n  o  n  )o  >o   o  ,o  o  o  "o                                                                                                                                          n  n  o  1o  8o  2o  #o  o  +o  /o  o  *o  n  o  n  n  n  q  q  }q  q  q  q  >r  r  r  Ds  Ps  dt  ct  jt  pt  mt  u  u  'v  v  v  	v  v  v  v  w  }w  w  aw  x  x  x  x  x  x  y  y  y  .z  1z  z  z  z  z  {  {  {  u{  {  {  {  {  {  {  {  |  |  |  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }                  p        ^  Z    P                        K                                  ?    ;  "  %  4    U  7  )                                                                                                                                                                                          j            k                  `  X  \  c  Y  ^  b  ]  [        u  x  w  t  x          {        |                             |                    	          A  B          ;  J  Q   Q  P  P  P  Q  Q  	Q  Q  Q                  R  R  R  R  R  R  S  .V  ;V  9V  2V  ?V  4V  )V  SV  NV  WV  tV  6V  /V  0V  X  X  X  X  X  X  X  X  mY  	[  Z  [  Z  [  [  [  [  [  [  d\  e\  ]  ]  b^  _^  a^  ^  ^  ^  ^  ^  ^  H_  q_  _  _  va  ga  na  ]a  Ua  a                                                                                                                                          |a  pa  ka  ~a  a  a  a  a  a  a  a  a  a  .b  id  od  yd  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  ue  we  xe  f  f  f  f  #j  j  i  j  j  j  i  !j  j  
j  i  j  j  i  j  Pk  Nk  k  k  k  ?o  |o  o  Qo  fo  To  o  mo  [o  xo  no  o  zo  po  do  o  Xo  n  oo  `o  _o  q  q  q  q  Vr  r  Ns  Ws  it  t  t                  ~t  t  u   v  )v  v  $v  &v  !v  "v  v  v  v  w  w  w  w  w  x  x  x  x  x  x  x  x  ?z  <z  @z  =z  7z  ;z  z  z  {  {  {  {  {  {  {  {  {  |  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  u  w                                                                                                                                              &                =      ,  -      #  !      %        t  v  `  f  x  h  Y  W  L  S  [  ]            
                                    L  N  l                        m      +      "    )    !            )  &  *                      %  i  n  h  m  w  0  -  '  1                                              	  `        !  +      
                              '  E  D  w  o    	                                                                                                                                                  X  R  Q  Q  Q  Q  Q  Q  Q  Q  R  R  R  YV  kV  yV  iV  dV  xV  jV  hV  eV  qV  oV  lV  bV  vV  X  X  X  X  nY  [  4[  x[  [  \  J_  a  a  a  a  a  a  a  a  a  0b  d  d  d  d  d  d  d  d  d  d  d  d  d  d  te  f  f  f  f  f  f  =j  8j  :j  Yj  kj  Xj  9j  Dj  bj  aj  Kj  Gj  5j  _j  Hj  Yk  wk  l  o  o  o                  o  o  o  o  o  o  o  o  o  o  o  q  q  q  q  q  q  q  q  q  q  q  q  hs  t  t  t  t  t  t  u  u  4v  8v  :v  v  v  w  w  w  w  x  x  x  x  y  Mz  Nz  Fz  Lz  Kz  z  {  |  {  {  {  {  {  {  |  |  
~                                                                                                                                          ~  ~  ~  #~  ~  ~  	~  ~  y          (            X  Y  J  Y  H  h  i  C  I  m  j  ^            a  *  2  %  +  !                                       k  m      D  1  4  B  9  5  ;  /  8  3      u  t  x  r  |  z  4       6    3  /  "    +                        &  !    .                          [  \  f    0  8  ;  7  -  9  $    (      !                  (      #  &  (              *Q  Q  !Q  2Q  R  V  V  V  V  V                                                                                                                                          V  X  X  X  X  0[  *[  $[  z[  7\  h\  ]  ]  ]  ]  k^  L_  _  a  a  a  a  a  2b  4b  d  d  d  d  d  d  d  d  d  d  e  e  f  f  j  j  j  j  j  j  j  ~j  j  j  j  \k  k  k  l  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  q  q  q  q  q  q  q  q  q  5r  Fr  ps  rs  t  t  t  t  Fv  Bv  Lv  v  w  w  w  w                  w  w  w  x  x  x  x  y  y  y  Wz  z  |  |  {  {  |  {  |  |  |  |  |  |  |  .~  >~  F~  7~  2~  C~  +~  =~  1~  E~  A~  4~  9~  H~  5~  ?~  /~  D      q  r  p  o  s                      	  q                                                                                                                                              ~                  g                      ;  6  D  8  =            
           A  ?  s              I  K  H  J  D  >  B  E  ?    }          9        M    (  u  J  e  K    ~  l  [  p  Z  T                          F    5                              ;  ?              >  K  S  V  V  X  X  8[  ]_  a  3b  d  d  d  e  d  d  d  e  f  &g  j  j  j  j  j  j  j  j  _k  xk  k  	p  p  o  p  o  p  p  q  q  q  q  ws  us  t  t  u  Vv  Xv                                                                                                                                          Rv  w  w  w  w  y  y  az  bz  `z  z  z  +|  '|  *|  |  #|  !|  |  T~  U~  ^~  Z~  a~  R~  Y~  H      w  v      
                                  (  9  ,  +  P    Y  c  f  d  _  U    I  M                                                      $                          M  O  L  N  S    >  ?  =  .            O  N  M            Q  ]  `      ,  3Q  V  X  X  X  [    ^  a  a  a  a   e  e  f  f  j  j  j  j  p  p  (p  p  p  p  p  r  r  Xr  r  xs                                                                                                                                          zs  t  t  t  u  u  _v  av  w  y  y  kz  iz  >|  ?|  8|  =|  7|  @|  k~  m~  y~  i~  j~    s~                                  `  _  V  ^  A  \  X  I  Z  N  O  F  Y    
  |  r    v  l  z  t  T  N                                              *  '  a      ^                  X  [    E  I                  a  r  j  l          R  V  V  V  V  V  X  @[  C[  }[  [  ]  a  a  e  e  e  f  'g  j  >p  0p  2p  r  {s  t  bv  ev  &y  *y  ,y  +y  z  z  L|  C|  M|  |  |    }~  |~                                                                                                                                          ~  L       f                
      d      p  l  f  o  _  k                          0    R  Q    +  0  7  5      y      /  _  c  a  7Q  8Q  V  V  V  Y  l\  ]  a  a  e  e  e  f  j  k  j  k  Lp  r  r  t  t  iv  w  P|  ~  ~      -    #  "  !    j  l    t                  w  }          _      .  3  5  :  8  2  +    8  9  2    g  e  W  E  C  @  >    T  Q  -  %                \  f  g  <Q  ;Q  V  V  V  [  ]  ]  N_  a  $e  
k  ak  Qp  Xp  s  t  u  nv  lv                                                                                                                                          y  `|  _|  ~  }    r  o              a  H  D  Q  R  =  >      k  U  U  M      I  1  >  ;      4  l  j    V  ]   b  #e  +e  *e  f  k  t  z  d|  c|  e|  ~  ~  ~    8  ?  1        c  `  d  h  o  \  Z  [  W        T  W  V        V  X  ,e  ^p  qv  rv  w  P    6  9  b                        w      j  B  H  D    p  _  "  X  _      |  }    w  r  ^  k  cp  l|  n|  ;        r  p  q  ^    #    dp  w    w    b  e  ~        }  ~  |  w  x    T      (r  j  1      r|                                                                                                                                          `$  a$  b$  c$  d$  e$  f$  g$  h$  i$  t$  u$  v$  w$  x$  y$  z$  {$  |$  }$  p!  q!  r!  s!  t!  u!  v!  w!  x!  y!  6N  ?N  N  N  Q  Q  Q  R  8S  iS  S  
Y  [  ]  3/  ^      P_  a_  4e      u                 0  0  0  0          0  0  0  0  ;  =  ='  A0  B0  C0  D0  E0  F0  G0  H0  I0  J0  K0  L0  M0  N0  O0  P0  Q0  R0  S0  T0  U0  V0  W0  X0                  Y0  Z0  [0  \0  ]0  ^0  _0  `0  a0  b0  c0  d0  e0  f0  g0  h0  i0  j0  k0  l0  m0  n0  o0  p0  q0  r0  s0  t0  u0  v0  w0  x0  y0  z0  {0  |0  }0  ~0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0                                                                                                                                          0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0                                                       !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  Q  6  7  8  9  :  ;  <  =  >  ?  @  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  !  !  !  1    ZN    R  D                                                                                                                                            Q    v                                                                                                                                                                         12  !  !!  0  0  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .                P  [  T  u  S     K    j                  BN  \N  Q  S  S  N  N  GN  N  V    n\  s_  N  Q  N  .N  N  N  N  N  Q  R  lS  S   W  Y  ,Y  \  ]  e  k  k  l  ?r  1N  <N  N  N  N  N  N  N  R  S  LS  "W  #W  Y  /Y  [  [  \  ;\  t\  s\  ^  ^  ^  _  	b  Pb  l                                                                                                                                          6l  Cl  ?l  ;l  r  r  s  y      O  O  ,O  N  O  N   O  N  O  O  O  O  "O  O  O  N  O  Q  R  	R  R  R  "S  S  MS  S  T  V  V  .W  *W  4W  <Y  Y  |Y  Y  {Y  ~Y  wY  Y  V[  \  %\  |\  z\  {\  ~\  ]  u^  ^  _  _  t_  _  _  _  \b  ^b  db  ab  fb  bb  Yb  `b  Zb  eb  e  e  >g  9g  8g  ;g  :g  ?g  <g  3g  l  Fl  Rl  \l  Ol  Jl  Tl  Kl                  Ll  qp  ^r  r  r  s  *u  v  uz  Q  x  |    }    M  ~            "  $     #  VO  ;O  bO  IO  SO  dO  >O  gO  RO  _O  AO  XO  -O  3O  ?O  aO  Q  Q  R  R  !R  R  R  	S  cS  rS  S  S  0T  7T  *T  TT  ET  T  T  %T  T                                                                                                                                          =T  OT  AT  (T  $T  GT  V  V  V  AW  EW  LW  IW  KW  RW  Y  @Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  [  [  (\  *\  \  \  \  \  \  \  \  \  \  \  ]  
^  ^  ^  ^  ^  ^  ^  _  _  x_  v_  _  _  _  _  _  _  _  _  _  _  _  _  _  _   `  _  :b  b  b  b  b  b  b  qb  {b  zb  pb  b  b  wb  }b  rb  tb  7e  e  e  e  e  e  Eg  Gg                  Yg  Ug  Lg  Hg  ]g  Mg  Zg  Kg  k  l  l  xl  gl  kl  l  l  l  ql  ol  il  l  ml  l  l  l  fl  sl  el  {l  l  tp  zp  cr  r  r  r  r  r  r  r  s  s  s  s  s  :u  9u  u  u  v  =y  4                                                                                                                                                                      x                  0  (  /  -  3N  O  |O  O  }O  O  O  vO  tO  O  O  wO  LO  O  jO  O  yO  O  xO  O  O  O  O  O  O  O  kO  nO  Q  Q  Q  5R  2R  3R  FR  1R  R  
S  S  <S  S  S  T  T  T  T  T  T  kT  zT  ~T  eT  lT  tT  fT  T  oT  aT  `T  T  cT  gT  dT  V  V  oW  rW  mW  kW  qW  pW  vW  W  uW  {W  sW  tW  bW                  hW  }W  Y  EY  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  b[  e[  [  [  D\  G\  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  ^  ^  ^  (_  "_  #_  $_  T_  _  ~_  }_  _  _  -`  &`  `  2`  `                                                                                                                                          4`  
`  `  3`  `  `  ,`  "`  `  `  .`  `  `  `  	`  `  b  =b  b  b  b  b  b  b  b  b  b  b  b  b  b  b  =e  e  e  	f  e  f  f  f  e  f  f  f  f  e  f  f  f  
g  g  lg  g  g  vg  {g  g  g  g  tg  g  g  zg  g  g  g  g  }g  g  xg  yg  g  %k  k  ~k  k  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l                  l  l  l  l  l  l  l  l  0m  l  l  l  l  l  l  l  p  p  p  p  p  p  p  p  p  p  p  jr  r  r  r  r  r  r  r  r  r  r  s  s  s  s  s  s  s  s  t  t  ?u  @u  >u  u  u  v  v  v  v  v  w  w  w  w  w                                                                                                                                          w  By  ?y  y  xz  {z  z  u|  |  5                                                           p  o  m  n  V                          9  =  <  :  C  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  O  DR  IR  R  R  =S  |S  S  S  S  S  T  T  T  T  T                  T    T  T  T  T  T  T  T  pT  T  T  T  rT  T  T  W  W  W  W  W  W  W  W  W  W  W  W  W  W  W  X  Y  SY  Y  Y  Y   Z  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  Y  [  L\  \  \  \  \  \  \                                                                                                                                          \  \  \  \  \  \  \  \  \  \  \  \  \  \  ]  !^  "^  #^   ^  $^  ^  ^  ^  ^  ^  ^  _  ._  V_  _  7`  9`  T`  r`  ^`  E`  S`  G`  I`  [`  L`  @`  B`  _`  $`  D`  X`  f`  n`  Bb  Cb  b  c  c  b  c  c  b  b  c  c  b  b   c  c  c  b  c  b  b  Ae  Ce  e  e  6f  !f  2f  5f  f  &f  "f  3f  +f  :f  f  4f  9f  .f  g  g  g  g  g  g                  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  g  (k  k  k  k  k  k  k   l  !l  (m  4m  -m  m  <m  ?m  m  
m  l  3m  m  m  :m  m  m   m  m  Bm                                                                                                                                          m  m  7m  m  m  @m  m   m  ,m  m  "m  	m  m  p  p  p  p  p  p  p  p  p  Ar  Ir  Jr  lr  pr  sr  nr  r  r  r  r  r  r  r  r  s  s  s  s  s  s  s  s  s  s  s  s  s  s  s  s  s  t  t  .u  Gu  Hu  u  u  yv  v  w  w  w  w  
w  v  v  v  w  w  x  x  x  x  x  x  x  	x  x  x  Jy  Ly  Ky  Ey  Dy  y  y  y  y  y  z                  ~z  z   {  {  z|  x|  y|  |  |  |  }  }  }  X                7                                        !                   :                                                                                                                                                                            w  t  |  s  A  N  g  j  i        r                                T  O  Q  S  J  N  P  P  P  P  "P  0P  P  O  O  3P  7P  ,P  O  O  P  P   P  'P  5P  /P  1P  P  ZQ  Q  Q  Q  Q  Q  Q  Q  aR  ZR  RR  ^R  _R  UR  bR  R  S  S  &U  T  U  U  T  T  T  U  T  U  U  T  U  U  T                  
U  T  T  T  T  U  U  U  W  W  W  2X  W  W  W  W  W  W  W  W  W  W  W  W  W  Y  JY  Z  Z  -Z  .Z  Z  Z  Z  
Z  Z  3Z  l[  [  [  [  \  V\  T\  \  \  \  \  \   ]  \  )^  (^  ^  ^  ^  ^  3_  0_  g_  ]`  Z`  g`                                                                                                                                          A`  `  `  `  `  `  `  `  `  `  `  `  `  `  b  Fb  b  c  Vc  ,c  Dc  Ec  6c  Cc  c  9c  Kc  Jc  <c  )c  Ac  4c  Xc  Tc  Yc  -c  Gc  3c  Zc  Qc  8c  Wc  @c  Hc  Je  Fe  e  e  e  e  Jf  _f  Gf  Qf  g  g  h  h  Ih  2h  3h  ;h  Kh  Oh  h  1h  h  5h  +h  -h  /h  Nh  Dh  4h  h  h  h  &h  (h  .h  Mh  :h  %h   h  ,k  /k  -k  1k  4k  mk    k  k  k                  k  k  k  k  %l  zm  cm  dm  vm  m  am  m  Xm  bm  mm  om  m  m  m  m  m  ^m  gm  `m  m  pm  |m  _m  m  m  /m  hm  m  ~m  m  m  m  m  {m  }m  um  m  p  p  p  p  p  9  p  p  p  p  p  p  p  p  p  p  p  p  p  Br  xr                                                                                                                                          wr  vr   s  r  r  r  r  r  r  s  s  s  s  s  s  s  s  s  s  s  s  s  s  s  s  s  s  t  t  t  t  !u  [u  _u  u  u  u  u  u  u  u  u  v  v  w  w  w  w  w  #w  w  w  w  w  "w  'w  #x  ,x  "x  5x  /x  (x  .x  +x  !x  )x  3x  *x  1x  Ty  [y  Oy  \y  Sy  Ry  Qy  y  y  y  y  y  y  y  y  y  z  z  z  z  z  z  z  z  {                  {  {  {  {  {  
{  {  	{  {  |  |  |  |  |  |  |  }  }  }  }  }  }  }  }  }  }  }  \  a  ^  `  ]  [              >  9                   /  %  3  -  D    Q  %  V  ?  A  &    "                                                                                                                                          B  N    *    <  M    $     7  /  )  G  E  L  S    ,  K  '  H  S  R                                              C  D  m  u  v  r    q    o    ~  t  |    G  W  {      v  x                                                    P                  N  O        \  _        /  N  pP  jP  aP  ^P  `P  SP  KP  ]P  rP  HP  MP  AP  [P  JP  bP  P  EP  _P  iP  kP  cP  dP  FP  @P  nP  sP  WP  QP  Q  kR  mR  lR  nR  R  R  -S  S  uU  vU  <U  MU  PU  4U  *U  QU  bU  6U  5U  0U  RU  EU                                                                                                                                          U  2U  eU  NU  9U  HU  -U  ;U  @U  KU  
W  W  W  X  W  W  W  W   X  W  W  X  W  X  W  W  X  W  W  W  W  W  W  X  W  X  W  X  X  W  W  W  X  X  \Y  `Z  XZ  UZ  gZ  ^Z  8Z  5Z  mZ  PZ  _Z  eZ  lZ  SZ  dZ  WZ  CZ  ]Z  RZ  DZ  [Z  HZ  Z  >Z  MZ  9Z  LZ  pZ  iZ  GZ  QZ  VZ  BZ  \Z  r[  n[  [  [  Y\  ]  ]  ]  ]   ]  ]  (]  ]  &]  %]  ]                  0]  ]  #]  ]  .]  >^  4^  ^  ^  ^  ^  ^  6_  8_  _  _  _  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  2c  ec  c  c  }c  c  c  c  c  c  c  c  oc  c  c  nc  c  uc  c  mc  c  |c  c  ;c  c                                                                                                                                          xc  c  c  c  c  pc  Se  e  ef  af  [f  Yf  \f  bf  g  yh  h  h  h  mh  nh  h  h  Vi  oh  h  h  h  uh  th  h  h  wh  h  |h  kh  rh  h  h  qh  ~h  h  h  h  h  h  h  xh  {h  h  h  h  }h  6k  3k  7k  8k  k  k  k  k  k  *l  m  m  m  m  tn  m  m  m  m  m  m   n  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m                  m  m  m  m  m  m  m  m  p  q  p  q  p  q  p  q  p  q  p  p  q  q   q  p  p  q  q  q  ~r  {r  |r  r  s  s  s  s  s  
s  s  r  s  s  s  s  s  s  t  t  s  t   t  s  s  s  t  t  s  t  du  cu  u  u  u                                                                                                                                          u  u  u  u  v  v  v  9w  /w  -w  1w  2w  4w  3w  =w  %w  ;w  5w  Hx  Rx  Ix  Mx  Jx  Lx  &x  Ex  Px  dy  gy  iy  jy  cy  ky  ay  y  y  y  y  y  z  z  z  5{  G{  4{  %{  0{  "{  ${  3{  {  *{  {  1{  +{  -{  /{  2{  8{  {  #{  |  |  |  |  5}  =}  8}  6}  :}  E}  ,}  )}  A}  G}  >}  ?}  J}  ;}  (}  c                                                G  C  H    %      -    ,    !    '    "    8  3  :  4  2  t          z  s    t          u      }              ~                    v    Y  V                                                                                                                                                                              R                                                0  '  ,    9  ;  \  ]  }    }  {  y                          $          !                      V  X  Z  S  U                                          z      |  m  k  q  o    j        P  P  P  P  P  P  P  P  P  P  hP  P  P  P  P  _Q  Q  S  S  S  S  U  U  U  U  wU  EV  U  U  U  U  U  U  U  U  U  }U  U  U  U  U  U  U  W  )X  7X                                                                                                                                          X  X  'X  #X  (X  W  HX  %X  X  X  3X  ?X  6X  .X  9X  8X  -X  ,X  ;X  aY  Z  Z  Z  zZ  Z  Z  xZ  Z  |Z  Z  Z  Z  Z  7Z  Z  Z  Z  Z  Z  Z  {Z  }Z  Z  Z  Z  Z  Z  [  [  [  [  [  [  [  \  0\  7]  C]  k]  A]  K]  ?]  5]  Q]  N]  U]  3]  :]  R]  =]  1]  Y]  B]  9]  I]  8]  <]  2]  6]  @]  E]  D^  A^  X_  _  _  _  `  `  `  `  `  `  a                  `  
a  a  a  `  a  `  `  `  `  a  a  a  a  `  a  a  Jb  c  c  c  c  c  c  c  c  d  c  c  c  c  c  c  c  ad  c  c  c  c  c  c  c  c  c  c  c  c  c  c  c  2e  ge  je  de  \e  he  ee  e  e  e  e  e  e                                                                                                                                          |f  lf  {f  f  qf  yf  jf  rf  g  i  h  i  h  *i  h  h  h  i  h  h  h  h  h  i  i  h  h  i  h  i  pi  h  i  h  h  i  h  h  h  h  h  i  
i  i  h  h  h  h  h  h  h  i  h  h  i  %i  h  9k  ;k  ?k  <k  k  k  k  k  k  k  k  k  0l  m  Fn  Gn  n  In  n  <n  =n  En  bn  +n  ?n  An  ]n  sn  n  3n  Kn  @n  Qn  ;n  n  .n  ^n                  hn  \n  an  1n  (n  `n  qn  kn  9n  "n  0n  Sn  en  'n  xn  dn  wn  Un  yn  Rn  fn  5n  6n  Zn   q  q  /q  p  .q  1q  #q  %q  "q  2q  q  (q  :q  q  Kr  Zr  r  r  r  r  r  s  s  0s  "s  1s  3s  's  2s  -s  &s  #s  5s  s  .t  ,t  0t  +t  t                                                                                                                                          t  !t  -t  1t  $t  #t  t  )t   t  2t  t  /u  ou  lu  u  u  u  u  u  u  u  u  v  v  v  Fw  Gw  Dw  Mw  Ew  Jw  Nw  Kw  Lw  w  w  `x  dx  ex  \x  mx  qx  jx  nx  px  ix  hx  ^x  bx  ty  sy  ry  py  z  
z  z  z  z  z  z  z  J{  ;{  D{  H{  L{  N{  @{  X{  E{  |  |  |  |  X}  o}  c}  S}  V}  g}  j}  O}  m}  \}  k}  R}  T}  i}  Q}  _}  N}  >  ?  e                  f          Q  O  P      C  J  R  O  G  =  M  :              <  =  ?  u  ;      #                                                  	                                                                                                                                                                                                                    H  V  U                                        N  M  9  Y  @  W  X  D  E  R  H  Q  J  L  O  _                                                                                              -  4  /    ,                         a  d  _  b  `    
  %      &                   '      $          {          ~                                                                                                                                                            l  p  n            N  N  N  P  P  P  P  P  P  P  P  P  P  P  P  P  P  P  P  P  Q  zR  xR  {R  |R  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  U  W  SX  hX  dX  OX  MX  IX  oX  UX  NX  ]X  YX  eX  [X  =X  cX  qX  X  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z                  Z  Z  Z  Z  Z  Z  Z  Z  [  [  [  \  3\  q]  c]  J]  e]  r]  l]  ^]  h]  g]  b]  ]  O^  N^  J^  M^  K^  ^  ^  ^  ^  ^  @_  _  _  `  Ia  Ja  +a  Ea  6a  2a  .a  Fa  /a  Oa  )a  @a   b  h  #b  %b  $b  c  c  c  d  d  	d   d  $d                                                                                                                                          3d  Cd  d  d  d  9d  7d  "d  #d  d  &d  0d  (d  Ad  5d  /d  
d  d  @d  %d  'd  d  c  d  .d  !d  d  oe  e  e  f  f  f  f  f  f  f  f  xf   g  fi  _i  8i  Ni  bi  qi  ?i  Ei  ji  9i  Bi  Wi  Yi  zi  Hi  Ii  5i  li  3i  =i  ei  h  xi  4i  ii  @i  oi  Di  vi  Xi  Ai  ti  Li  ;i  Ki  7i  \i  Oi  Qi  2i  Ri  /i  {i  <i  Fk  Ek  Ck  Bk  Hk  Ak  k    k  k                  k  k  k  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  Gq  Tq  Rq  cq  `q  Aq  ]q  bq  rq  xq  jq  aq  Bq  Xq  Cq  Kq  pq  _q  Pq  Sq                                                                                                                                          Dq  Mq  Zq  Or  r  r  r  r  r  <s  Bs  ;s  :s  @s  Js  Is  Dt  Jt  Kt  Rt  Qt  Wt  @t  Ot  Pt  Nt  Bt  Ft  Mt  Tt  t  t  t  t  u  yu  wu  i  u  v  v  u  u  u  u  u  v  u  u  u  u  u  v  v  v  Uw  _w  `w  Rw  Vw  Zw  iw  gw  Tw  Yw  mw  w  x  x  x  x  x  x  x  x  x  x  yx  x  x  x  {x  |y  y  }y  yy  z  z  z  z  z  z  "z  z                  z  z  z  z  z  z  f{  d{  m{  t{  i{  r{  e{  s{  q{  p{  a{  x{  v{  c{  |  |  |  }  }  }  }  }  }  z}  }  {}  }  |}  }  }  }  }}  }  m  k  g  h  l            !  d  `  w  \  i  [  b  r  !g  ^  v  g  o                                                                                                                                          D  a    I  D  @  B  E    ?  V  v  y      e  Q  @    g  0  M  }  Z  Y  t  s  ]    ^  7  :  4  z  C  x  2  E  )    K  /  B  -  _  p  9  N  L  R  o      ;  G  6  3  h  ~  D  +  `  T  n  P                M      	                                                                v      a  ?  w      u      t  z  <  K  J  e  d  f          h  i                                                                 R  ?                                                                                                                                          D  I  =                  n  o  H  R  0  :  f  3  e  ^    .  J  F  m  l  O  `  g  o  6  a  p  1  T  c  P  r  N  S  L  V  2                            s  w  x  r                          [            P  P  P  P  P  P  P  P  P  P  P  P  P  P  P                  Q  R  R  R  R  0S  S  'V  V  V  V  U  V  V  V  V  V  U  V  V  U  U  X  |X  X  X  X  X  X  tX  X  zX  X  X  X  vX  X  X  {X  X  X  X  kY  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  Z  w[  [                                                                                                                                          [  c\  ]  ]  }]  ]  z]  ]  w]  ]  ]  ]  ~]  |]  ]  y]  ]  X^  Y^  S^  ^  ^  ^  ^  ^  ^  ^  ^  ^  D_  C_  o_  _  ,a  (a  Aa  ^a  qa  sa  Ra  Sa  ra  la  a  ta  Ta  za  [a  ea  ;a  ja  aa  Va  )b  'b  +b  +d  Md  [d  ]d  td  vd  rd  sd  }d  ud  fd  d  Nd  d  ^d  \d  Kd  Sd  `d  Pd  d  ?d  ld  kd  Yd  ed  wd  se  e  f  f  f  g  g  "g  i  i  i                  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  i  Jk  Mk  Kk  k  k  k  k  k  k  n  n  n  o  %o  n  7o  n  .o  	o  No  o  o  'o  o  ;o  o  n  
o                                                                                                                                          6o  so  n  n  -o  @o  0o  <o  5o  n  o  o  Co  o  n  n  9o  o  n  :o  o  o  o  o  !o  q  q  q  q  q  q  q  {q  q  q  q  Dr  Sr  r  r  r  Cs  Ms  Qs  Ls  bt  st  qt  ut  rt  gt  nt   u  u  u  }u  u  v  v  v  v  v  
v  v  v  w  |w  w  w  nw  w  ow  ~w  w  x  x  x  x  x  ~x  x  x  x  x  x  x  x  y  y  y  y  y  y  y                  y  y  y  y  +z  Jz  0z  /z  (z  &z  z  z  z  z  {  {  {  {  {  {  {  {  {  {  {  {  R  {  {  {  |  |  |  |  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  s                                                                                                                                                  $  ]  \                                                                                                  a  3  #  (  k  @  .    !      C  ,  A  >  F     2  *  -  <    :  1  5  B  &  '  8  $    0                                                                        =  h  i          	          
                         #       "        $  !    z  r  y  s      v    z                                                                                                                                                        y                  }                ~          -        X  }  z  ~        {                                                 >  ?  `  a  _          P  Q  0Q  P  Q  Q  P  P  Q  Q  P  
Q  R  R  R  R  HV  BV  LV  5V  AV  JV  IV  FV  XV                  ZV  @V  3V  =V  ,V  >V  8V  *V  :V  W  X  X  X  X  X  X  X  X  X  X  Z  Z  Z  Z  Z  [  Z  [  Z  [  [  [  [  g\  ]  ]  ]  ]  ]  ]  ]  ]  ]  ]  ]  ]  i^  ]^  `^  \^  }  ^  ^  ^  I_  _  a  a  ya  a  a  a  a                                                                                                                                          a  a  a  a  a  a  a  a  a  fa  a  -b  nd  pd  d  d  d  d  d  d  d  d  d  d  d  hd  d  d  ve  ze  ye  {e  e  e  f  f  f  f  f  f  f   j  j  j  i  i  j  i  i   j  i  i  i  j  j  i  'j  i  i  j  i  i  @j  j  i  i  j  i  i  	j  j  j  %j  j  i  &j  j  i  j  Qk  k  k  k  k  l   l  k  l  Ao  &o  ~o  o  o  o                  o  o  o  bo  Oo  o  Zo  o  vo  lo  o  Uo  ro  Ro  Po  Wo  o  o  ]o   o  ao  ko  }o  go  o  So  o  io  o  o  co  wo  jo  {o  q  q  q  q  q  q  q  q  q  q  q  q  q  q  q  q  q  r  r  Xs  Rs  ^s  _s  `s  ]s  [s  as  Zs  Ys                                                                                                                                          bs  t  t  t  t  t  }t  t  t  |t  yt  u  u  ~u  %v  v  v  v  v  #v  v  (v  v  v  v  v  v  w  w  w  w  x  x  x  x  x  x  x  x  x  x  x  y  y  y  y  y  y  vk  9z  z  z  z  {  {  {  {  {  {  {  {  {  |  |  |  |  }  }  }  }  }  }  ~  }  }  }  }  }  }  }  v                    d  g                                  O  S  R  P  N  Q  $  ;       )    	      
  '      +          *                        (    .          1  &                 0      /  b                                                                                                                                          V  c  d  w    s  X  T  [  R  a  Z  Q  ^  m  j  P  N  _  ]  o  l  z  n  \  e  O  {  u  b  g  i  Z                        	                                                >  M                             #  %  $  .            &  '                                ,  $         #      s  p  o  g  k  /  +  )  *  2  &  .                                                                                                                                                                                                                          |                      Z                &  )  (       '                                                      F  C  g  t  q  f  v  u  p  h  d  l                                   Q  Q  Q  Q  Q  Q  4S  S  pV  `V  nV                  sV  fV  cV  mV  rV  ^V  wV  W  W  X  X  X  X  X  X  X  X  [  [  [  ![  [  [  [  [  ([  [   [  [  [  ]  ]  ]  ]  ]  ]  ]  ]  ]  ]  ]  ]  ]  g^  h^  f^  o^  ^  ^  ^  ^  ^  K_  _  a  a  a  a  a  a  a  a  a                                                                                                                                          a  a  a  d  d  d  d  d  d  d  d  d  d  d  3e  e  |e  e  f  f  f  f  f  f  f  f  f  f  #g  4j  fj  Ij  gj  2j  hj  >j  ]j  mj  vj  [j  Qj  (j  Zj  ;j  ?j  Aj  jj  dj  Pj  Oj  Tj  oj  ij  `j  <j  ^j  Vj  Uj  Mj  Nj  Fj  Uk  Tk  Vk  k  k  k  k  k  l  l  l  o  o  o  o  o  o  o  ^o  o  o  o  o  o  p  o  o  o  o  o  o  o  o                  o  o  o  o  o  o  o  q  q  q  q  q  q  q  q  q  q  q  q  q  q  q  q  q  q  r  r  is  fs  gs  ls  es  ks  js  t  t  t  t  t  t  t  u  u  /v  -v  1v  =v  3v  <v  5v  2v  0v  v  v  w  w  w  w  w  w  w  w  w                                                                                                                                          w  x  x  x  x  x  x  x  x  x  x  x  x  y  Dz  Hz  Gz  z  z  z  z  z  {  {  {  {  {  {  {  {  {  {  {  {  {  {  {  {  |  |  |  |  |  ~  !~  ~  ~  ~   ~  ~  ~  ~  ~  ~  "~  ~  ~  ~  ~  ~  %~  $~  C  {  |  z      *  )  l                            U  V  W  V  E  k  M  S  a  X                  @  F  d  A  b  D  Q  G  c  >  [  q  N  n  u  U  g  `    f  ]  T  e  l  c  e  d                    y                          &  0  -  .  '  1  "  )  #  /  ,                                                                                                                                                                                                l  n      3  >  8  @  E  6  <  =  A  0  ?    6  .  5  2  9  7  4  v  y  {      3  5  6            '            z  8  <    #      F  -            %        4    $    )  9  5  *                          	                                               5  /  2  $    '  )                                      3        |  ~  {          z                                                                                                                                            }    %           )      "                          =  &Q  %Q  "Q  $Q   Q  )Q  R  V  V  V  V  V  V  ~V  V  V  V  X  X  X  X  -[  %[  2[  #[  ,[  '[  &[  /[  .[  {[  [  [  ]  l^  j^  _  _  a  a  a  a  a  a  a  a  a  d  d  d  d  d  d  e  e  e  e  f  j  j  j  j  j  j  j  j  j  j  j  j                  j  j  j  j  j  j  j  j  j  j  j  [k  k  	l  o  o  o  o  o  o  o  o  o  o  o  o  o  o  q  q  q  q  q  q  q  ss  ns  os  t  t  t  t  t  t  t  t  t  u  u  u  u  u  Cv  Hv  Iv  Gv  v  v  w  w  w  w  w                                                                                                                                          w  w  w  w  x  x  y  x  x  x  y  x  x  y  y  y  \z  [z  Vz  Xz  Tz  Zz  z  z  z  |  |  {   |  {  {  |  {  |  {  |  	|  |  |  {  {  |  {  {  |  
|  |  -~  <~  B~  3~  H  8~  *~  I~  @~  G~  )~  L~  0~  ;~  6~  D~  :~  E    ~  }      ,                  [  Z  \                  {                        w  |      z  x  W                        y  v        h                                                    5  3  <  >  A  R  7  B                                                                                                                                                                "                      O  p  r  q  o        o  N  M  S  P  L  G  C  @    ~  8                        d  V  G  |  X  \  v  I  P  Q  `  m    L  j  y  W  U  R  O  q  w  {  a  ^  c  g    N  Y                                                               A  D  J  I  E  C  %  +  ,  *  3  2  /  -  1  0                                          H                          3  A  g  6  .  /  1  8  0                                                                                                                                          E  B  C  >  7  @  =    -                  $  #  "  T    1Q  -Q  .Q  V  V  V  V  V  V  pY  <[  i\  j\  ]  m^  n^  a  a  a  a  a  a  a  a  a  a  d  e  d  d  e  e  d  e  e  f  f  f  j  j  j  j  j  j  j  j  j  j  j  ^k  k  l  p  p  p  p  p  p  p  o   p  o  &p  o  o  
p  r  q  q  r  q  vs                  t  t  t  t  t  t  t  t  u  u  \v  dv  Yv  Pv  Sv  Wv  Zv  v  v  v  w  w  x  y  y  y  	y  y  y  y  y  y  _z  |  )|  |   |  |  -|  |  &|  (|  "|  %|  0|  \~  P~  V~  c~  X~  b~  _~  Q~  `~  W~  S~          u                                                                                                                                                _  ^                                      $        i                                                S  K  O  L  F  P  Q  I  *  '  #  3  0  5  G  /  <  >  1  %  7  &  6  .  $  ;  =  :  B  u                 \  b  `  W  V  ^  e  g                  [  Z  a  ]  i  T  F  G  H  K  (  :  ;  >                                                                          ]        #  "  %                                                                                                                                                                    P  Q  R    A  <  :      	        
                  )  5  J  L  K                          \  S  O  J  [  K  Y  V  L  W  R  T  _  X  Z               %  +  *  )  (  L  U  4Q  5Q  R  R  S  V  V  V  V  V  V  X  X  X  Y  =[  >[  ?[  ]  p^                  _  a  e  e  e  	e  e  e  e  e  e  f  j  j  j  j  j  j  j  j  j  j  j  j  j  `k  k  l  p  'p   p  p  +p  !p  "p  #p  )p  p  $p  p  *p  r  
r  r  r  r  r  r  r  r  r  t  t  t  t  u  `v  w  w  w  w  y  y                                                                                                                                          !y  y  y  y  y  gz  hz  3|  <|  9|  ,|  ;|  |  |  v~  u~  x~  p~  w~  o~  z~  r~  t~  h~  K  J            x      d  a  c                                                       	              
    b  Z  [  W  a  \  X  ]  Y          P  H  J  @  S  V  T  K  U                  Q  B  R  W  C  w  v        	          m  x  s  j  o  {    R  Q  O  P  S    @  ?                                                  }        )  +  ,  (  &                                                                                                                                                      \  Y  ]  W          H  G  C          %    $    "     '  #            
      7                                    w          q    x        }  k  t  u  p  i    s  {    o  y      h          -  @  A  M  V  W  X  7S  V                  V  V  X  E[  ]  ]  ^  ^  _  _  a  e  e  e  e  e  f  f  f  j  j  j  j  j  j  j  j  <p  5p  /p  7p  4p  1p  Bp  8p  ?p  :p  9p  @p  ;p  3p  Ap  r  r  r  }s  |s  t  v  v  v  v  w  w  w  w  w  %y  #y  'y  (y  $y  )y                                                                                                                                          y  nz  lz  mz  z  I|  H|  J|  G|  E|  |  {~  ~~  ~  ~      y        h  i  "                 	                    c  f      `  j  ]  h  c  e  g  m          Y  V  W  U  X  Z    C  A                             (                       	    
                                    .  /          `  b  c  _      P  N  Y  L  K  S  2  4  1  ,  *  6  )  .  8  -                          @            	                                                                                                                                                                                                        0  .  [  `  ^  ]  Y    :Q  9Q  R  R  V  V  V  H[  G[  ]  ]  ^  a  e  k  j  k  j   k  Cp  Dp  Jp  Hp  Ip  Ep  Fp  r  r  r  ~s  u  jv  w  -y  1y  /y  T|  S|  |  ~  ~  ~  ~  ~  ~  M    0      *  &    #      '  .  !     )    %                  )         $    +  J  m  i  n  k    y  x  E  z  {            ^  [  ]  F  D  E    ?  ;  6  )  =  <  0  9  *  7  ,  @  1        5  :      d        X  V  9  =  F  D  B  A  :                                                                                                                                          ?            :  R  +      ,  #  (  )  $  !                                                z                1  N  e  d    N  V  V  V  qY  K[  L[  ]  ]  ^  !e   e  &e  "e  k  k  	k  l  Up  Vp  Wp  Rp  r  r  r  s  t  t  t  t  mv  v  5y  y  pz  qz  W|  \|  Y|  [|  Z|                  |  |  ~  O      k  4  5  3  ,  2  6  ,  (  &  *  %  q        ~                            `  b  G  L  P  J  K  O  G  E  H  I  F  ?    j  i    T  [  N  S  T  L  O  H  J                                                                                                                                          I  R  P      +  ;  V  U  F  H  ?  D  9  3  A  <  7  4  2  =  6                                      5  3  2  B  k      =Q  R  X  X  rY  M[  ]  /  O_  b  b  b  )e  %e  e  f  k  k  k  k  [p  Zp  "r  s  s  s  pv  w  g|  f|  ~  l  :  @  9  <  1  ;  >  0  2  .  3  v  t  s                            E      d  c    b  U  ]  W  ^         V  Y         R  X  P  J  M  K  U  Y  L  N                                                    8  7  6  C  O                                                                                                                                          q  p  n  o  V  V  N[  m\  -e  f  f  k  _p  ap  ]p  `p  #r  t  t  w  8y  y  y  j|  ~    m  C  8  7  5  K                    k  h  i    F  C  G      ^    Y  c  g  f  b  ^  `                   	            F  t  u  v  V  .e  e  k  k  k  k  bp  &r  r  w  w  9y  i|  k|  |  ~                  ~  ~  ~      F  G  H  y  z  |  {              n  m  o  q  s  I  r  _  h  n  m                  	  G  x  {  z  y  W  fp  o|  <        t  x  v  u  `  t  s  q  u        
                                                                                                                                            hp  ep  |  j  >  =  ?          K  s  t    a    d  f  g  $      H  b  k  'r  L          i  h  .    )r  K      y    uv  k  z    ip  jp    ~  I    x      X  R`  |  Z  T%  f%  W%  `%  l%  c%  Z%  i%  ]%  R%  d%  U%  ^%  j%  a%  X%  g%  [%  S%  e%  V%  _%  k%  b%  Y%  h%  \%  Q%  P%  m%  n%  p%  o%                    G    ? L  B  s  Q  I6  BI  D     < <x  Dg  b  3I   k  O  $ P  )m z  6 J %     ~ _   G n       Q  z4  Q  l  C7    I  `Q  3 jQ      0%  32  [  }   < Q  Q                                                                                                                                          4  Q  Q  Q  <  Q  J Q  Q  BS  Q    >i  -7 {_  R  &R  <R  R  WR  R  R  R  |  B  R    k      IU  n  ? T	 ? 3S       l  & h  s  J`  >  8   q  D  mS  tS   ~S        w  S   S  S  S  s  rW Y?  s  S  S  Il  IN  W  S  :   S  ? - S  w T  yp  +U  Wf  [m  mT  Sk t ]U  T  T  G    =  M                  & GU  L  /T  t  U  U       :@ RE  5D f   7V  f  2 f  f  MV  OV  x  V    S   W  V  V  f #6  O FW  A nl  p  BW  6  ~l W   X  T cC &X  K \X  X  a5  X  X  < X  [  CW  P xB   5  Y  h  6  Yn                                                                                                                                          > $Z  SU     Y  N l *m  Y    m qm  (  Y  En Z  cZ  6  I     7  Z  et  Z  o T% =   27   ^  R  v[  e  |[  z @  ]H   [  `a  4 Y  [  [  M  \  D \  s  \   (k I\  H  \  \  \  ]   7 ]  ]  F]   \  ]    -8  I I  s!   68  ;  .^  j      z^  D  S  N      S  q 	^  ^                   ^  ^  8  ^  >h    _    :  H  : :_  h #     q$ c_    nn r_  @  6 _  ]  _=  PR j p h&    ) 1`  f  w c9  =  96  W  ' qy  @>  `      `  I I Sz t  P  Z  da  $  Ba   n a  Q  V a  [  ?                                                                                                                                         _( a   ] a  29  ) ( #`  \a  e  c   b  p b  . lc  I :  8d  c        o  6.   @ W d  d  {  f:  :d  W:  Me  o  (J #J e  me  _e  ~0 e  @I 7K  e  @  ) e  e  _   4 f  1 1 Df  1 1 Kf  u gf  Q sf      = 12  1 S w  (   g  C !J +;  i  7     gg  bg  A  g  D  "h  Pn  <  h  3 m ]h                  o4 i  j   si  h  5 i   i  2=  :  <6 ;  g  ai  J B  6i  i  ;   c  P  i  Y6 *! Ej  7 j  ;  g  j   <  k  #	 `  5k  tk  ' n  :  X @7  !T  Z; k  > k  7l  $ H Qk Zl  &  yl  = D  = A I  I                                                                                                                                         < 6  <  2   1 $   7h  %m m m m  \m  |n  o  I @ rn 3  to Q          .  !     /> St  ? y  On  Z  K0 o  7  o  0> n   =@ UE    Do  \o  N=  to  p ;=  o  DA o  @ UA 9@ ? ? ?A Q  VA WA @A a Kp  ~p  p  p  p  p  p  p  A  =  q  q  wB +q  Eq  Z  Jq      \  eC Oq  b  B ,q  ZD 'J "J q   p  r                  B  r  Y  C  $r  A  V .r  @r  tI h  Ur  Wr  U>  D0 h  =o  r      +s  #H + H   (s  .s  s  s  : .j s  It  A  $J #f  6  I I I s  t  i  &J 9t   >      ( `t   Gt  s  vt    lt  07  tt    ,j  t  SI  J                                                                                                                                         _A yJ  F[    t   u      u   K [     Mu  Ju  gu  nu  O ?  M u  ]t  u  u  v  ,v  Qv  Ov  ov  vv  c v    7  i i v  v  v  v  o b  P }Q  w  &w  @w  d   R Xw  2 w  d h  w      v J h  x  x  x    .y  U x  4y  x  v     + ` & y     i  y  WX y  9{ <y  y  *n  &q >  y   y             Q  8           >     !  "  )  #  #    `$  }$     %  B&    ='  ='  I  .  3/  J   0  )1    1  2  (  3    	      Ju      Ku  0  k  Mu      u  !   vv   v nw   y A|  ,  |   c   D  d  F |"   !# %#   # ) 	  f* .   t/ 3 j  3 :8   9 9   : Z;   c< nK R  K 	L ^  L M s  M P   +Q S   T T   1U Y :  TZ Z   t[ K_ l  _ &f D  f Rj   k t .  tu w   Xx e{ 	  { O~   . . x    y       +    ; 5    d      y     H     "    :    2    M         (  s  )  > 0 d    W  4 [ J    r    V  %  W       FG  D                X          P                YW            ][f              a_                      jh            om  sq        wu      {y        Vg                                Zl            \n                              p                                                              ^t                                                        x                                                                                                                                                                                                  Xi  r`v  z  |  }  ~                                                                                                                                                                                                                                        k                                                                                                                                                                                                                                                      DEFGHIJKLMNOPQRST  UVWXYZ[              \]^_`abcdefghijkl  mnopqrs                                                                                                                                          @ABCDEFGHIJKLMNOPQRSTUVWXYZ\]^_`abcdefghijklmnopqrstu  [ceVX                  E    LK                                        J        K                                                                                                                                                                                                                                                                                                wx                                                                                          v                                                                                                                                                                                                                                                                                                                                                                                                                            w  x                  z      {      |      }      u              t              s              r              q                                                                bcdefghiponmlkj        vy                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              @BC  qrmnuvyzijE  ef                                                                @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz                  {|}~                      tuvwxyz{|}~@ABCDFIJMOPQRTUy                                                                                                                                                                                                                                                                                                                                                                                                                                    UV                        PQR    T                                                                    W                  S        O                                                                                                                                                                                              w                                                                                                                              h    Y                                            ]                                                                                                                                      S                                                                      n                                                                                                                                                              K              p                                                                                                              z                                                                    F            ~      h          h                                                                            j                            \                  ^  p                                  f                        H        E                                o  \                                                                                                                                                e                        E  }Xd  VM                    [              Y                                                            W                                                                    ES    x  Q                      l    k                                                                                    {                                                                              `                K                                                                                                      K                                                                                                          d                  i            g                                          h                                                                                                                      z                                                                                    B                                                                    f                            R                                                                                                    m                      n                                                                                o                          p                                          d                                                      `                t                          t                                                      x                                                                                Z                H                      }    }        J                                      G                                                  Q                                                                        x                k                                                                                                                                                                                                                                      I                                o                ~                                                        y                                                          {                                                                                                                        D      L                                        K                  S                                                                                                                                                  ]                                                a            R                                                                                                                                                                                                                                      V                                                                                                                                                                                                                                                                                                                        I                                                                              Y                                                                            I                                        r              k                                P            e  D    n          c                                    S                  yj    ]        ci                p                                                                                                                  j                                    M                                                                                                                                                                            d            o                                            fn            a          ]  ~          i                b        cG                                                                                                                                                            u                  r                                                                                                                                                                                                  Z                                                                  m                                                ]                                                                                                                                            M      W                                                                                                                                                                                                                                                                                                        J  ~              D        @                                                                                                                                                                                    F                                    N    s                                                                                                H                                  K          U        N                                                        _  Y                                                                                                  `                                                        t                                                              U                  D                            V                                  Y              [                                                              E          C                                                                                                                          P                                                                                                                                                                                                                                                                                                              g                                                                                                                            v          Q                          s    @  O                            zd                                                                                                                                                                                                                                                                                  ~                          np                                        S          ^    \      z                                            ]      d        bd              L                                      T                    |        U                    z                                          v                          pK                      T                  Q                  D                                                                                        C                        G                                                                            X                            Y                                                B                                                                                                                                                                                                                                                                                                            ]                                                E                                      y                                                                          L                                                                                                                        L                          M                  zW                                                                                                                                                                                                                                                                    R                                                          g                                                                                                                                                                                                                                                                                                                                                                    J                                                                                                                        V                      I                                                                              d        U              |            M              H                      I  }                                          P              G                                                                                                    U                                                                                                                        X                                                                                                          A            Z                                \                                                                                                                                                                                                                          \                                                                                                                        `                                                    E                                X                c            I                                                                                                                                                        kn  O                F                                    u        y          p                                                              x  J                                                                                                                                      o    j            _                                                                      A                      O            N                              U                                        y                        W              Y                                                            s                                                                                                                I                    C                                                  [                                                                                                                                                                                                                      XF                                  V              x                    {                                                                                                                                                                                                      @B  C    EVTWUFOM    BA@  C      O          XPrc    Y  DdF      @D  [  G\    EGF          A{AE^]                  W                                  KF  GH_    Q    ~    E`o      FG              Hk    R  TS            JKLMIPj  fiQa  h  NOH    eg      g                sN                      Ox    f  B  g  D[`h  d  G]  nCb^ZeEH@FcAi\_    a      o                        P    W    VJf  IQ]      KYPX  T[NWM    URZO\SLH                  pn    l        Y    [      c        @      cW    \bUYRV  g  Q  sf  XSO]PNZ`a  [^M_dL  Te            ^W    _    UXY  V]  SR  Q\ZT      V                q              r          gi            vw      uh    x_  lk  Ia  SR  JIK          Q^  YZ\[`o]^  J  qK    @    RLZ                  NTU    A  j  `_U  R  S    a      U  V  [  B}hGMN~k            ha    @    LZ  T                      zB  YWX  O  MN}b  Zk  F  DE    GC        lmn    POSQR                    c  h  dgfeb        o          ikjl        ABZ    @ABDC      O      \[U  H    VUVTWop                        lk    i  j        qn  m          C  D      E  y  UcV    L      ]^  Iq  mcb    P_  C  l`  KJXh          }o  E      WQd  cb  mX        n      Raed  r        WgfLMsYZ    o    D                  tu      p  p    dezF    F        X  h                Se    Y    Zq      Ofjyt  onuslzmixwvk  rq    {p  Y    S  YU  [XNQTPWZORV\    ~{g|[]upm  }_ahxtv\mDvsdunowlj  kq^  rfc  zbe  iV`        y                      OPy  IKMLEA  DIRC  FH    QMSJGGB@  N      HKxt}rCOZy  EBwJ|Ls~{@FGzv  ]Qu          D            N  Dy@          BC  AC    FB@GEDX            W          AA  w|v{z  s    ~B  tux}            y    N          j  qrj    uxq  Fnv{oFfsmy          zlrthwgGi  Hp      S    ~C  _  R          UQKTNP  S      ILJOH      MR    G  MG  DGST  JBLROFIHH  CEKA  k    TOU  N_    P@    E  BA  CD@Q  Fj  {}~  bz|  `  P    ^      `V  Ql  ~AY@XW  T    Z    mon          I    }|  _^][  y      wz  \[xW            Te    ZHIEF    |            IHGkgY  no        bf  dcea  `              }dv  `  {~|                  s  Y  [  Zr@XW    V    \A  U          T  Zg    X^  UY[]W}VQRS\                    oPS  RWNQPAT  XGJJ  OU    IJ  V  M  HL          Bg        iK                }l}  K~          e    N    n          T    {]c    _fW\U[d  Z`eV^    bhXawg    Y  YKWVMR  N  Q\[oJP  ZOL  X  }~      MOJL  N    PIK      x  SRrabq  cB[      h    \  _        tiS    Z]^      B`YL  B  i~p  gh  ]h  {      j  [q  _  `    ij                aC  _`^Z        ab  MN  O                j  ]  klo  nqpmk      L      R              goOHpSDKtfEdLPcQJ  MriTRnlIkGFjhqme  N  ogc  sb  l  pwVvdTfmqurknUhjite~          \bB[  `  PU  _\aQ[TR  cSW  XZ  Q  Y\]^        d      @L  kCD      xBOAqe[  P          @B  @M  r      GC  ADs  oE      B@CD@FAA  BEA  r    nzpvkyx|utwm  {orwql    xsUaXWZ\_  VrT  ][Y  _  ^c^  `b  `WK  VUXQ  RZS  \[T  Y  u          T      \  ]gC  Tlm  nrs    s    UutVa    ]e  EGFH}  ^  prysv  tuw    g  W  Xvxzw{ybc    fw  }  hgc  _    `bdasfe          JIkHGKF    I  KHJHIJ  m    ~fge  d]  d_  o  x        u    ig  NMLLMp\ty      |  ]  LK  q              N  L      ru      Y~Z}xjh  Dkij  ^    PQ  O  hi  a  K  s  wv      z                        d  hMb]ec\ilg`fad[_k    ^j              h      }{  yX|z~              s    on  lknpo    sHqpr  mtl  mqr        SR      TXA  ZV^[U  C  WB\]Y    u  Dx@Q  `  RaOO    P    b    @    S      VN  P  UTC  R    DMQ          Q      egkh  c  bl  jjmdikf  e    af`e^hdic_g  jbXf      Tr    DE  `        r  q      t{_    u        t  Wvwx          Sy]    x  |          u  nmo        ts  v  u        bF  ac`        UE  ViWT    O  Z\E[YX          qoNmpnl    mklnn  z~}  FXy  z  e      z      {        yu  wwxxv  GJKHgfdeI      jh    Z[  \]_aHGY`^S  psrtqtuos  sqpro    f  FG  U  Y@AC  {        |aFb    I}            qrskp        zz  y  iLjM  L]      b        uvts    t  kJ    zU      Q  {  mCnl^  vTL    wvul        }|{      Oorp  Nu  qPts    aWa_`KdLc  pw    xw  Qu@HI|      {          n  x  y                                    ~  |  {z  a}      f                      ~}  |    ~      z              kv  SxQ    R        ky  w    hz              U^dm|e`V~TbeI  c]a{dY  b  WX  q[_\dfcZ  }a            ko@QmDqeFSilG[HNsT  JOC^UrAP@]pNM  tEjB  KMRgL  P    Mh      \p  h  ln~  k  [  j_        rZ@qv  XimOfgAWYVo  }  GnF|ECDtzn    {tHyB  z  q  y~y      |  ~x  Px  yxv    }      w|{zuv~    t|  y{}  w                    yV    g    jihaJbAt      |                ur`atvu    Iy    W    v        vQ~  }            Z                z        E              u          F    Q          {          A@CBE        D    |                                f[}                        |g    yur    w{j  i  shxqt  R  o  xnl~w|  pmzvTS              L      kd  zjYgw}kn|\ml~Uyi  _phqfec]VJW{y  Xox`[a^    K  M              p  |liz  {bkno  j  d}~  ehf  Sm  gc                    QL      KOb      R  TNPU            J[  M    Z  M      x                  E    V      YX    ^  \]Zk    [B  EC  FDGlC  NdMLKce  u      r    F      G                v    uxsw  tq      V    Hg  ~y            z{rW      H  |s    _  I          }~  YX      JIO^J                    @          PMcSKNQ      LOR                  qd                  v        ybvwu{    xtzY    \  Z  R      [  SM  r        P            `nK  m    QR  fP      T      |    BA~  R    z  ag                  PC  GBE  @  AA  @F  D            WCuMNFXHSIVQO  J  P  DRUE  LT  GK  Y                    M  [\i^VLbJ[EeRA      }DQa`FX  _`cZKSfYamVX  GCjc]@lgI    kPHd\T  ^bGZYO_UWh]NMBP^  W  hU}i                O    V                D  @  J                          j                  ~              |          J          E                HGj                                    Q        N~D                      JH  ^F  X}_B]RGUd]  [@ZFoQamI^KYgDkaMCWh`e  S  fEPLN`_nO  b    TcljAVi  bR    \              A  L        WBl      X      ^{              Z  [  ^                        EAH      IpDJ@  G\CFeB    chi  bfe        gd  _QNW  VTO  r      cPqSpXRM      o  LV  UUh  YZTX  S      W            v          V    b    Y      d          e    pceqd        K  jYwBZ[    n            f  k    \eof  p                fgh        LlZ  _  qg          ij`  CH  r  hsi  q    joBA  C@  @A            AB@k  M  [    ]a~  IJ^  tkl  D  B    rr  D        @      vE      [YLQSLM  UbROQVZXZ  KxM\  TWEG^UNJYVHICOP[]PN  S\WR  ]FTKXD  v                  jzqKbeB  movhfguGpnsJ  uycIBMO@lk}r  ux|AFs~wi_  d  `N{ta        L          |wtv{I{s      d~xz  }}p    Ozmxo^H|wvnyqry~                      k                LC  U[WJMFGJV_E  @NBOY  DhHHEfZgaSb\ecITAG`FQCZiPKKX]                      D        e  RP  G[  UGDg    dXcNOIE  @QYBD^F\SHFJh  b_]faR`AEWV  TLKCA    JM        M                      AZ  IMDJCUV  H  D    BSKQ~WAGEBCOLT@F  G      FE  PNR                        @    a`F  _IJ  h^CRHKcjbW        iULYehTMPZdGQ[NESgVlXfOD  ]d\G                    }  n  wmqsuS}ou~E|    |vtDzwx    z~py  x{tsr{Py                    vDNMYKO  FRTC^  W  [`UI  L  H_aV\J  EAZB@  X  QP]G          I@AHCOBDFEDJG  FEB@  ANC      Q    SYWZR  VU[  TX  P    q  o  p  mns  r    x_ey\vsgwt^abcf  ]udh`    ]j`kh_\  ^bedg[  icfia  g    x  y  Wel  A    ^_Gb_  `a  XZURT    c      VSPW  QY        p  po        l  ^      wxyP  Lnv{QlrkuqMOz  jmst|p  N                    mNT  PLXJWiH[RlSV  Z  OFT    jkYMI[  Q    U      K  HIeOcYbXL`^  _J  c    \ZK]apM      dQ    C  Zpwyk  z}m~l  x  q|ovrnu~  N  {s  t          WQ    Igdpjlfnvmk  qho    cebri  JQ  USKILMHUVGVQOLPN    RRMSN  OPK  TSWXT  \b  `^      a]_  I  w  tuvl  mzk  j  i{l    jkA        D_yG            R  nbH}    fP    U    KL|gBedc`    x  [        ~S  ]^o\_RpQ  QkjVhi  laWs  t  YZf  r}qpnol    i  CD        f    b  aegcfgd    _]d  ea  b  \^c  `    I                    XWUTVgL  e    bf  eny    hcmt    sadu  rq`i      pw  TvsXVuSeuY  oqtrUxS        v        u~}{  zwxy|    _\]W[a`^  deJcyx~  mnmzYvj  E    ljkhhi      mkgj  fi[lh        S    ^Z  _  ]\ts^  Z\F      dxmkhlNsetp{uroZynwzqy[xwv|        i~E  `Z[a  bX}{z_|Y^\]mlW  k    sn_  qx  zwyu    ]  @bA|  D    i  f  eg  fZcXy\[dh  Yqmzjh  k  nlg  ^BEu@oF  D{ACGv  t    sj    n    n}]{o`        M  ~              i^_ropqIH|w        cd  Fjim  klnm{  rpq              `v      dcba  x  {z    fe            Bj    qs      |s  op    t                        \hi  nlkjemDf  g  |~}    kjhlmgi                            ECHIFGD    l  ksmro`q    a  bpn      t    wuv    MN  }O~LP  J    xo  KpY\    ~}w  noG  qm    o      q  p    J        xQ      qp  up      r    Kt  Rr      q  rs            ks    Lduc  y  Ssnxwvy                        uv  wt                  t        C  F  DEAB            @O  N  QOM  P    }  ~vzywfgex{|  h  @  {A  |z~}  U    T{    yztwuv      fn    o  x    uGB|x    z|~}{          L                |  zy}  ~{    O        P    F              v        wx              N  Q  M    LH  O  PJK          I    TX  V      S  URYW    j  Y  li  kFVE  C  DV  G      Z    W    []\XY        ~}      z}yq{|~rts    r      h        i        R  STr    A    CAB@B    mHI_^      Vrqp                                          }  |D  z  {y    AZ  X@W  \[Y        I  H  cDGF        ^  _[]Z\    jpIErqno            J      `    L        Hs    M@  s    G~        D]^  CB        JKL  a`P  sOI  KQR  u      L  A          VMW    G  XE  M            v  BC    @B  DGE\S  FCHA        V  O^    j            d  ]                aPPSGLFc  J    QHbbONKMIR_Q    R            ]  X  N  PUTWRQh  SY[  VO    iaY\              b  c  e            `h    dfg  vj  ]f          txQyw{z          OndN  L  PMuS          c  Tagedj  khibf    l      p      axr    wy    k    @          XYm  ~{    EFDW_GHI  sIOb  MK  LN    J        X      u      r  V  dTeUf    Za^`_        yxka  |}  W  SXTVR  U      z    \z{A|@}  t  LJKZSYRXVUTQPW                            Bl                  h]_ae  [Yj  `d\X  W  vbZ^k  ifgcgrB        jxtxe}  ubUwfvp  cqshgd  lim  ynok`b  a    pyurvl  tsw  q  nzrm  {o  c              ~        _  Yia]dg\e`Zhc^b[f          ntwovqm  surp  v    ~}          B@BAl    p        n              o                          p                        q              r                              s                                                                            t                                                                                              uo      j  CIu    M    `[_]^\    @ijnohkgm  @pz  |}        DO  Nba      BCAsmlnrq    d~yexPedc          D      opN~CAB{|  }k  z{lQ    ARS@B  Tf  A@hq    i      kl  sCU  h  g      C    BD          FGE  m  t  u  ED                  pomnq  |          wvF      v  ww  tv  yu{zxx              |  ]q            [GH]eWZca  IgLd\Y    IbDeV_FK`OM  XJ  ^NEf    r    \  jl  kinH  om  f  t  v      w  yNEGH  PLJ  MQF  O  \KI      _    c  Q    O      gJ  N  KPMGL|    }~wu  {  sx  r{}  v  ~[|~yxy}  |tz      LH  M  JK  I        A  DC@  B      a  txzwvusry    }~        ECDRN{  S    P  TUVO  hp  W  P|    R  QE    RiQ    rw    q    WTVSU  XYZ          S    JFIKHG    kl    F}  }  X[AJJvHKMNL    {        |zy}~~j            R                  wAb\daqt]k  V`  cewIUYWRo  ~svMf}^xuy|m{Tlp_ZSXTgn[  hzA                JvB}Q    ~  x|t    sr\F  z{u  w  y                    U                    x      ^`ey  ]hou  b  i  S@wrnj\aYofcsdzlck    Z_pvA[gmV  xqt                v      l`}hiwst]    Xup  nzrkdo  cajH~vf  ^eq  m  |  xyg{be  l      b      g  _u  ~      U  f  nE`  bL    _                `mq  X[Y    Z      ]aU^  WV  Tc\b_          m      r  stgfb  vu_c]  pawZXdniO  mB[RU{\SQNe`hx|  WkoTy  LrVjP^Yl}zq  w          M  I  @CEAG@DL    FUOF\J  TQDHBVSPWMK  {  NS@ERDA    MOQIPBRJGU  vHTKLVCN  ~                                      ap  h  ~    JP  KIGHL        VEFG    O  h  @B|    {      ~XZY  W      ikj                  AF  C  H  yGD  EB    I  LKHF~}EGIDM  J                                                je    ghm    i  l  f  d              k  d  z      akg_e`o    \hi_^l  b]c  n[mj    f      Y]Zag\pj_kfm^`nXldch[  bie        Co      a    ^        BEA  CDQON@PFM|    Zn    Gl    N        j|  m  I  J  N    MKL    P  UTER  SOR        Q                `                t    BA  v@nprqso          u      p|  wyqu  x{stzrvr  qw    st    ux        v      IKHJ  R  ]  HIKJ  Pn        W    V    CFE  DX    y{z              TS[        y                      o    C  A@BDIG  H    }|}    LU  L  qr    p  T  R  QXPYV  SWUO    _Y^    `Z  [    X]    \    D  F  EI    C    B  @G  A      H        PMEJ  Q  XG  OKNLF      Lx{  NM}O  K    y  |  z~wJ                      |~      E        ~    K      A  O@BC      L            @NMPQ  AV[XWZY  C  B@  A  @  MNgm                                                            z                                                                      {                                                                                                                                                                            RP  D  DZaTS    v    b      H  VUW  QR    FE\[      I  YZX          Gst]^  hfcged  J  LQSRUOKMTPN      [H  T  SU  N    d    HIJH  RBS\E  B                                                                                                                                              ji\]    vu  _      X  W      V  _b`ae^fcdV              @LNKMT    ow  l    k  `    [^Yl]  \_Z  hon  pmri  kgjqs            [aYbX]c`_^  W\    ZAC@EBFD  Z          J    E  A@CBDR  O  S  QP  T  \    CEVDU  a`^]bcF  _    \  QPOpn`H            I            UJ          yxc  ab      mn  CAEFL  HJB  I  KDGb@ac  uwv{  xtyz|  gf  deMNILJK    LH@      GM        FGHI  XYWVZXxYWFdeHG  |}            ~                                                                        ]              d    @Z      PO        |GdAT[CE  }        `              |~{    }    z      jgn[ilhekmf      p  zvy  ~w|r  oq}uxty{s                MeO  giNfjbh      GO~  PE    J  CBUMLKIN}DFH      e    RCA  SDBQP  OE          Uo  RSQ  T      h        l            j                  q  pr      l      VWTnSYXk\R[PZUm    Q    Rnqimljpkho  YHJVWUQGZTFIX  KL    M]\  [\Zfut@As      _a]`o^p  nsUT  S  q  suJtr        a^_M`[\J  K]L            O  PNpR_Q^c  ]HI  C]qqo  V  q  B^xvzD  yw  I    C[B@C      PA    mljbqeovnysuc  iwuhxzkrswutf  r  v      tsdgp  c    aWYe  Z\f[w    d  b^c`MX  g]  x_              xzr@~    |y    {wv}R      ZUgP  JOV  eTqcdNXtysowuhb}W~Kx  mkf  A  n{jz  @S[v|rlQA  pYiBC  YDDACQ  B  @@  CE  E  BADv              UEEK    tE_    Lz  Fyl`Y  Tc[XeU  _aWfX]bjgk^Zhj\  GdfiS  VI    H  J  s  cq  da  lhrbetympid`Co  ku      g  n  z  jBf@    DHACK  E  M          afOhNIdjNJ  K`gMeL_cbO^i  @Cmplnoijg  kh  QK  M      LN    JN  CDSRT_U^VruthsR  rpqw                                                                                                                                                                                                                                                                                                                                    S                                                  t                                                                                                Dxv    {  E  F  }zy|{~{  h    TP[  \      MK  IJFFNHL      G    nlm      wx  EGFPmlk                          V                                                                                XVYW          W          @            Y      EF  ~|}        IH  KJ    G}    |~    jki          GHOI        o    A  G  Lnoml      PJptqus  y      B          sprq      R]^_`  Q  NKPSLRO    M    fwvx~}z{|  HIS  kn  QRo    q[EG  FW          C    ft  QRDa      S  M  F  Qu  v    Xc  bd        V    UTTPA@}  {  ~|y@z    ]z  \J|K  Rp^OPHvi    CB    q  r                WD    XA  LMTQN  z  |wx{yt    gWe  [    f  YZU  [Y  XVZ  W          E  JFI^HGDBECF    @  AQN  OPrVUtsj    I`X                                                                                                          h  BbGBuRSi  tDCsAu                          `  IH  OJ  K    d  ~      }        i    f  \kjlga_i  ^]  `    \K  ^]_NLMRKQTSPO    jRMfJHI{k  C  DlXWgU  TYvwWvV  wlaY  m                                                                                                    PU  j`    W  VL  l    w      o      nqsrtpm  ocfdcUi  hg  bba  ed    ZR^[]\Y_b`a@  Xc  SMU    E    F]qm  `^]cas\Z  [_bx~Tqy[Z}|Y{Xz  }~  {x|  yzRVSm  Jv  jWkz                                                                                                                            jl  Wuejmf_dkN      fd    e      \b]          I[\          hvw  ^  nq  poghfe\  gWOP  eGrgih  `      TUV  Kc  xi^  aJ  {rd    A  izy  i  SRQh^  ]  L            t        |    {    }xvwsuy  tru      m`|j{z  ~      jm  ltos  qpn  k  CB  DAug                  X    WUT              J  Kv    IH    w    x    lo        V  p    o    msqkvjqr    nuc  t      g  z  `V    _      ~p      Z\_[`Y  W]X^      M      Z        \[    yPxwz  st                                                                                                                                                                                                                                  }~            o  k  p  l  m  n      z{~|  v  y}  E  Fw^      }  HY  Z[M          xOPsN    z{L      }  {  |x~zwyw  a  bdc  s  indgk  r  eosjcm  lqphbfNOa  ]^}`_ba|{  x|}                                                                                                                                                                                PQ  TG  QSpRmec  A    T      Jt        dHu  r  q  LJKI\          fvwd}u      xRe~          ]gy      A^|{z    M  }fN~  ihij    T  Sgjih                              s  e      t        CmtH                                      JJW  Y[_`cdghklopstwx{|        \M  O  QRST  }~    LMNICH]^ADAGFHIB    @ABCaUb            N                                                                                                                                                                                                                                                                            q                                                        u              v              H                                                                                                                |                                                                                                                            NKzH      G                                                                                                                  E  S                            r                                          G                                                                                                                                              }                                                                                                                                                                                                        {                                                                              _  T                                                          y                                                                        t                                                                        u                                                                                                          I      |c                                                                                                            `mb                                                                          k                          j                                      T  s                                                                                                                                          Bv                    e                                                                                                                                          l                                                                  n                                                                                                                                                                                                                                u                                                                                                                                                @                                                                                                                                            v                                                                      {                              m                                                B                    \                                                                                                                                                                                                          {                                                                                                                                                                                                                                                                                P                                                                                                                                                                                                                                                                                                                                                                                                                                                                              F                        c                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    f                                                                                                                            S                                                            b                                                                                                                                                                                                                                                                                                                                                @                b                                                                                                                                                              r                      ^                                                                                      \          C                                                                                                                                                                  |                                                                                                _      Yk                                                                                                                      D                                    J                                                      d                                                                      M                  W  CD                                                                          T                                                                                                                                                                                                ceo~        C                                                                                                                                                                                    fpu                                                  ]  H                @              v                                                                                                                                              wdg                                                                  K                S            J                                                                                                  _                                                                                                                                                        X                                                                              a                    }                                                                            B                yz                                                                                                                                                            ~          D|q                                                                                                              N                    c          In                                                                              Z{|                                                                                                                                                      A    r                                                                                                                                                                                                                                                                                          r                                                                                                                                                                                                    s                                    _                                                                                                                                                                                                                                                                                                                                                        |EnV                                                                                                      K                                                                                                                                                                                                                                                                          @                                                                                                                                                    N    h                          l                                                                                          jt                                                                                                                                                                                            A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        G                                a                                    Z                                                                                                                GfU                                                                                            C                                                                                                              d        ND                                                                  iK    |                                                                                                                                                        U        t                                                          l                                    c                                                                    `Xv                                                                                                JIx                                                                                UVQ                                    D          U        c                                                                                            k                                                                    Q      W    x                                  P                                                                                                                                        L                                                                                                                                                                @                                            A                                                        a                                                                                                                                                                                                                                                        |                                                                                                                                                                                                              B                                                                                                                                          C                                                                                                  y                D                        {                    n                                                                                                                                                                            y      ^                                          S                                                                                                                                                                                                                                                                                                                                                                  t                                                                                                                        E                        G                                                                                                                  P          H                                                                                                                                                                        [                                                                                                                                                                                                                                                      L                                                                                                                                                                                        K                                                                                                              i                                                                                                                                                                                                                                                      s                                                                                          Y                                                                                                                                                                                                                                                                                                    B                                                                                                                                                                                                                                                                                                                                                                                N      _                                    N            O                                                                    P                                                                                                                                                                                                                                          P                                                  s                                                                                                                                                                                      X                                                                          ^              Y                                        u                                                                                                                                                                                                                                                        p                            q                                                                                                                                                                                        w                            m                                                                                                                        ]                                                                                          A                                                                                                                                                                                      k                                                      }              M                          Q                                                                                                                                                                                                                                                                            hm                                              g                                                                                                                                                                                                                                                                                                l                                R                                                                                                                      p                                                                                                                                                                                                                                                                                                                          S                                              U                                                                                  V                                                                                                                                                                                                                          W                                  Y                                                                          [                                                                                              ]      O                                                                                                                                                                                                                                                                          {      B                                                                                                                                                                              P                                P                                      `        E      F                                                                                                  b                                    {                        `                        c                    i      G                                                                                                                              |e                  f                                                                                                  r              z                                                                                                                                            h                        w                                    g                                                                                                            Y                                                                                                                                                                  i                                                                                                                                                                                                                            Q                                                                                                                      _j                                                                                                                                                                              k                                                                                                                                                                                                          l                                N                                                                m                                            g                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                F                                                                                                                                                                                                                                                                                                                                            w                                                                                      Z                                                            T              Q                                                                                                                                                                                                                                                                                        np                                                                                o                                        @{                                                                                                                                          Y                                                                                            @    _                                                                                                                                                                                                                                                                                                                                          v                                                                                                                            G                        t                                                                                                                                                                                                  FOI                                                                      u                        \                                            Q    y                                                                  K                                                      X          _                                                                                                                        |              C                                                                                                                                        M                                        [                                    z                                                                          X                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          i                                    R                                                                                                                                                                                                                  n                                                                                                          ||                                                  g                                N                                                                                                    t                                                                                                                                                                                                                                                                                        {                                                                            SXy{                                                                                                                                            b                                                                        H                                                                                                                                                                          K                                                                                                                                                  @                                                              ^_Jp                                                                                                                g                                                                                  c                                                          H                                                                                                    ~                        C                                                                          H                                                                                                                                              JK                                                                                                                                                      Z                                                                                                                                                                  Y                                                                                      [                                                                                                                    F                                                                                                                                                        m|a                                                                                                                  `                                                  R                                                            O                                                                                              n                    m    d                                                        Sx                                                  ]                                Z                                                  P                b                                                                                            O                                                            R                                                                                                                                          k                                                                                                                                                                        k      Q                                                                              q                                                                                                                                              Lj                                                                      a                                                                                    D                                                                                                                                      i        b                                                                                                                                                      U                                                                                                                                                                            w                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }                                                                                                  f                                                            Y                                                                                                                                                                                                                X                                                                                                                                                                                                                                                                                                  T                                                                                                                                                                                            t                                                                                                                                                                                                                        t                    ~                    }                  oa                                                  RX                  hI                                                            M                                Iq                  n          CYf}o        F                              m        |                  e~Xw                                                                      m            F                F[  g                                                                  bkN                                      g                  `      u                      {              j^                                                              ~            h                          [                  ]Vb            O                      _                                      e    L                                                                                      [                                                                                                                                                                                            m                                                                                                                                                      s                                                                                        t                        K                                                                                                  Ui                                                                                                                                                                                                      v                                                                                                                                                                          h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {                                                                                                                                                                                                                                                                                                                                                                                                                                                E                                                                                                                                                                                                                                                                                                                            J                                                                                                                                                                                                                                                          Z                                                                                                                                                                                                                                          o                                                                                                                                          _                                                                                                                                                                                                                                                          S                                                                              I                                                                                                                                                                        y                                                      {          ~                                                                                F                                                                                                                                                    p                                                                                                                                                                                                                                                                                                                                                                @                                                          W                                                                                                                                                                                                                                                                                                                                                                            CDO                                                                                                                                                                                                                                                                                                                                                                                                                                                                      o                                              J                                                                                                                                                                                                                                                                                                                                                                                                              N                                                              `                                                                                                                                                                                                                                                                                                Q                                                                                                                          d                                                                                            a      d                                                [                                                                                                                                                                                                l                                                                                      s                                                                                          uq                                                                                                                        `                                                                  j                              L                                    R                                                                                                                                                                                                                                                                                                                                                                                                                T                                                                                                                                                                                                                                  C                                                                                                                                                                                                                                                                                                                                                                                                    b                                                                                                                            }                                                                                                                                                                                                                                                          Ww                                                                                                                                                                                                                                                                                                                                                                  mV@                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              G                                                                                                                                                                                                                                                                          I                                                                                                                L                                            `K                                                                                                                                                                          p                                                    C      G      T                                                                                                                                                                                                                                                                      I                                                                                                                                                                                              ^                                                                                          ^                        \                                  K                                                                                                                                                                                                            _      L                                                                                                                                        V                                                                                                                                      T                                                                                                                                                                              ^                                                  h                                                                                                                                                                                                                                                                                                                                            a                              _                                                  M  [                i                                                                                                      c                                                                                                                                                                                        g                                    i                                                                                                                                                                                                                          e                                                                                                                                                T              l                                                                                                    n]          s                          j                            mM                                                    ^                                                                                      Lu              t                                                  E                                                              jN          x                                          U                                                                                                                                    A                                                                                  \                                                                    M                                                                                                              feIB                                                                  z                                            [    M                              a                                                                                                                                                                K@FgZ                                                                            A                                                                                                                                                          LUo            }                                                                                                                    o                                              V                                                                                                                    ^l                                                                                S              k                                  S                          y                                                                                                            oxBZa                                                                                                                                                            O                                                                                                                                                        s                                                                                                                                                                                                            C                                                                                                                                                                                                                                KJ                                                                                                                                                                                                                                                  T                                                                          \                                E    F                                                `                                                                                                                        HG                                                                                                                                                                                                                                                                                                                                                                      q                                                                                                                                                      E                                                                                                                                                    p                                                                                                                                                                                                                                                                                                                    R                                                                                                                                                                                                                                                                                                                                                      P                                                                    }                                                                                                                                                                                                                                                                                                                                                                                                                                                                            i                                                                                                              A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            L`                                                                            X                                                                                                                                                                                                                                                                                                                                                                                                                                              q                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  p                                                                        s                    [                                                                                                                d                                                                                                                                            h                                                                                                                        A                                                        l                                                                                                                                                                                                                                                    Z                                                                                                                                        H                                      J                                                                                                                                                                                                                  l                                                                                                                                n                                @                                                                                                                                                                                                                                                                                                                                                                                                        j  |                A                                                    A                                                                                                                                                                                                                                                                                                                  bN                                                                                  f                                                                                                                                                                                                                                S                                                                                    @                                                                          A                        E                                                                                                                                                    s                                  B                                                                                                                      a                                                                                                                                                                                                                                                                                                                                                      C                                                                              D                                                                                                        N                                                                    EO                                                                                                                                                                          G                                                                                                                                                                                                                                                                                                          ^                                                                                                                    cW                                                                                            f                                                                                                                                                                                                                                                                                                  b                    g                                                                                                                                                                                                                                                                                                                        H            O                  ]                                                                                k                                                                                \      iW                                                                            U                                                                          s                                                                K                                      C                                                    F                                                            `  S                        N      @                                                            B  V    e  lJ    PR                                ZIG                                                x                                  `                N      V                          a]O                          @                                                                            }                                                                                                                            {        {  w                              C          e                                                                }            e                                            H                                            S              ]                                    __n]                                                                                                                                                          i                    U                            T    A                          zG                                                  V                                              f    G                                  O            M                                                                                                                                                                                                                                                                                                                                                                                                          N                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                rz                                                                                                    XF                            r                  B                                                      Y                            e                                                                                  Y                                                                  [                                                                                      \                                ~                              ^                                                                                                                        `                                                                                                                                                                                                                                      F                KX                    L  c                                  e              f                                                            Z                                  d                    l                                  gp                                                                                                                                                                                                                                                                  P                                                                                                                                                                                                                                                h                                                            t                                  Q                                                                                                                            w  dvi                                                              j                                                                                                    N                                                                          k                                                                                                                                                                                                      l                                                                        e]                mZB                                                                                                                  j                                                      n                                                                                                                            o                                                                                                                                                                                                                                                                                                                                                                                                                  r                                                                                                                                            q                                    U                                                                                                        q                                                                                    r                        t                                                                                                                                                                                      \                                                                                                                                                                                                                                                                                                                                                                                                                    w                                                                  U                                                      x                              |                                                      w                                                                                                                                  u                                              v                I                                                                                  y                                                                                                                                                                                                                                                                                                                                                                u                      R                                    E          _                                                                                                                                    w                                                                                                                                                                  V                                                                                                                                                                              @                                                                            x        z                                                                                                                                                                                                          K                                                                                                                                                                                                                                        ut                                                  G                                                                                                                                                                    H                                  w                                                                            R                                                                            z                                                BIG5HKSCS// outbufstart == ((void *)0)  ../iconv/skeleton.c (state->__count & 7) <= sizeof (state->__value) ../iconv/loop.c inptr - bytebuf > (state->__count & 7)  inend != &bytebuf[2]    inend - inptr > (state->__count & ~7)   inend - inptr <= sizeof (state->__value)    inend != &bytebuf[4]    outbuf == outerr    nstatus == __GCONV_FULL_OUTPUT  inend - *inptrp < 4 to_big5hkscs_single from_big5hkscs_single   gconv                
                                                   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ,                           #                           o8     <     \  
                    (                      H         oL  o   o.  o                                                                                      8 A0   aeabi &   6 	
"BIG5HKSCS.so     .shstrtab .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                                                  ,   o   8  8  $                6         \  \                 >         <  <                    F   o   .  .                  S   o   L  L  @                b   	          H                k   	   B       (               t                               o             P                 z         X  X                             #   #                             #  #  f                                             0             L                                                                                                                                               8                          8 8                            < <                        p        < 1                                m                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ELF          (    X  4   lq  4    (                  k k          o o o 8  <           o o o                         D   D         Qtd                          Rtdo o o                      GNU KfKVy         GNU                                   c5R                           
     o       t              F           "                                                             U               ,                             {   t      i           __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses gconv_init strcmp gconv _dl_mcount_wrapper_check __assert_fail __pointer_chk_guard libc.so.6 ld-linux-armhf.so.3 GLIBC_PRIVATE GLIBC_2.4                                    c	                      ii          o    o    8p     p   $p   (p   ,p   0p 	  4p 
  p   p   p   p   p   @-  -k  & & & & &0 0   R/k ,   @-808 0  00` S$00 0  S3/k k Xk $   @-@ @0  00`4 C1 ?0    R2/Xk Tk k 4   L @- D0  0  R4 0  S  
(0 0 0   k j     j j 4 @-  ,0  0  R  
 0  S   
3/@hi Pj 0   8@- @P P  P
  0 8 $( ,000  4 8 x  P	  0   8 $0(0,0  8d O-@|M ?<P$`  @0(  4P8`@	  < P  R  
/0 0)  T `P  V`@ 0    UP@h,,@  Uh0G  `(/(? 0B.B>0T0(P$`80  S  
>0_p`t	p0N  9BA Q  L   Q  
 0  S  
tp  X t 0tpp0p0tpp0 Z3  
   Z	 : X    R   Q  R
,  \ 
    \s 
t0pp    Yg 
   (  0, </ P
 P0 p0tp@  T 0  P @  TP  
   P  
    p	0</@  T0P0P0 	 Wo x@  00$ @ P4 0 P8P0</ P P<  
l@ T   U<  `@   `]BA Q  | ktB \   3Cqcl|@0l s0~ SAm0mXB)AAQ  L LBA Q  EP U
  U
P  UX  | Z  
p X0u :  0< |+|K|||[ @  	PD H@LP X`
  , 0   Z&  
  X  :p   R B> P  P  
 R  @ Z>  @`@v` V   P  
	 \ a@    R 
0X`P@  T 02
  p|PP&@@#@P   j  
`  VU (80  S  
 Rt `@p`B   R0  
0l0 S0b0 ZA : YN  * Bl0 0 Z@   p0 TS    Rl0@ Sp@ 9C @ P 
C0 @ P <)     R 
     R  
t0 X p0 t p0t 0  Sp0t  
  l0 Q 0c  `` `t  }  @p0@P `F |0p0tp  2  
,0p0     h,  Y 
    
  p     X05*`XXP`XpPR@
0	p@M,@  T{ 
 ` 
  0 p  q R {    R4  
0 Rt00u0` X:@0tp Z  \   [0t0 SK  C> Q  <0u@ 0 0@g  T    b @`0   0@@ @6  -0 Q\  
 SZ  u@ \:  u@L$q Q   \  
l R   aL &0 0  Sv@,@  T}  
 ` z  
 0,0v@ 0u@ Rf  ] R  e,L B#  0=05  b/0v \F  
g`@ b 	 Q  5   Q+  	 \ $  gA    R0  
0 0,@  T:  
 ` 7  
 0,0u@ 0x@ Z 	  0p0S 0 S  |4  $0~4  w/0vppp4  $0n,`  V  
   00 0F |Qp  0O
   YP  U0  ` 00 0   = @@ @4 80P5/| R^ R  f,L B#TT#00;DDD3  .0C R R  gL#00$@Ph0   pP0  U 0
 \` 0
 c R  Z  
   @    0   0 Z@0    PP`XpP	pP@`Xp@Qp0 p0(  
  S
,@  T 
` @  T 
tpp`   (  0 `,p </ P0  @  Tp0 `       S P  
  PB `C  Q  0 a3 Cr 0cd s0@q~ QA0ee0d,@0p0       P  p0\i (   \ \ p\ ]ALx\  ,Z  pY @  <    9  Y   Y    V  XZ DZ P[   0  Y 8Y DZ X 0X <Y dX X Y ,X W X 4X   <  PV hV W D    U K K Q dQ `R   Q DQ @R Q $Q  R   Q P Q J  P P Q 0P HP Q /  O HN O   G G    \F  W  ]ALL K M   L K L E $  |	  xD hD  K       C    #  C    PB  ?        ?    ?        C) @AP(   ! L  Lp  \8  
` @ c @l R $   R    Y  0cm p RP  U|C @ P! / 1  !01  w/02  "000 ,,,2  -0P `L"  B ```2  b/0ttt2  |"0b \	 \'  b \	 \7  ` \4b \;  <b \	Db \>  Lb \Tb \B  L`b@I YlB \B  @~ P@ A  `Ve@ @0  -   RL,@  T6  
 ` }
  0 p  f@ @<@ c.  4g@D` o.  +*@@ @H .  !@L k.B @ @P  /B `Xpddd4  l$0 `(80  S 
4p`0?$t 0	p ,P  9CA QZ     @   Q  
 0  S  
t  T  t 0tp``tp` Zk  
  Z  : T   0 ST    Q  S
  U  
0 p  W  
t`p0   (  00 `P </ PU  p  Wp`t$  3  Pp@l0 `` V<   W2  	 \@00C0C<A  Q  H    \C  Q2  h 3 Cr 0cd s0@q~ QA0ee0d  0`0 Zp` 0pP6  &0n6  ..0f P p  
p`tyC)AAQ	  $  L  ]Pp`tCA Q7     QPpP8 R@ R  *+L@ B#'00J' B.  yPp`pv R RV   L0k>C00PpdQp `*
<(  5 Z`p9  
` T/  :hhDp(p   @ L 8X,$ 0  HP0\  P0< 0 S  C> Q)  <0 P` 0 ZR  
` T* P0<$ p$`0 ` p
B@ @ PX R%  -~ \#@A0lv@ Qg  
 Se   Z\   @P@uP U7   P5  
Y Q#  a@D00  S  
 ,L B#	  0?C0  \%  
 #  
 0 0 Z 0 P0<$ pH	 Q  PZ Q  e@PA@ 0=0  \  
   
 0 0 0 P0<$ p	 Q^ Q  f@PAH0c>00 P0<$ p{  \
 
 0 0 0gCP Q<[ Q  g@LP0o>00h[ Qp[ Q	  *@P@AP0>00[ Q[ Q  @X 0k>C0wA[@I Y[ Q  P~ P@ A 0`i@PA\0?C0^@- 000000 @ >?00000N0000  <^%"\& %     	00;=[]0	0
00000000     `"f"g""4"B&@& 2 3 !
  &&%%%%%%%%%%%; 0!!!!0                      """"""*")"                '"("!! ""                       ""#""a"R"j"k""=""5"+","              +!0 o&m&j&  !          %                                                  !"#$%&'()*+,-./0123456789:              ABCDEFGHIJKLMNOPQRSTUVWXYZ        A0B0C0D0E0F0G0H0I0J0K0L0M0N0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0\0]0^0_0`0a0b0c0d0e0f0g0h0i0j0k0l0m0n0o0p0q0r0s0t0u0v0w0x0y0z0{0|0}0~0000000000000000000000                            000000000000000000000000000000000000000000000000000000000000000  00000000000000000000000                                                                                                                   !"#$%&'()*+,-./                              012345Q6789:;<=  >?@ABCDEFGHIJKLMNO                           %%%%%%%,%$%4%<%%%%%%%#%3%+%;%K% %/%(%7%?%%0%%%8%B%  `$a$b$c$d$e$f$g$h$i$j$k$l$m$n$o$p$q$r$s$`!a!b!c!d!e!f!g!h!i!  I33"3M33'3363Q3W33&3#3+3J3;33333333                {3  00!3!!22222122292~3}3|3R"a"+"."""" """5")"*"  NUZ?Ta(cY"uPz`c%nefh'Weqb[Y{b}}b|[^	cfHhOgN
OMOOIPV7YYZ	\`apafipOupuy}}cUz;SNNWx NXn82z(/AQpSTTVY_m-bpTS[poS\zNx&nVUk;YSfmtBVNKOSU0[q_ ffh8ll)m[tvNz4[`muv`iSQ  W0XDY[^(`cclopqYqq?s~v`[iXeZl%uQ.YeY__be*j'kksV,\l{QK\avharYNOxSi`)nOzNSNUO=OOsORS	VYZ[[yfggLklkpsyy<z{wf)VNO\bYr;uNOVJXX^_*``b`abb9e      AffhwmppLuvu}QRYT[]haimxWrlmWgRVT^bd<h8hkrsxkzkif[\}iMNc {+j  jh_orRUp`b;mnn[DN9Si:j*h\Qz[V("h1|Rt~NOQ[
RRR]U*XY[[[r^y^`acaacbegShh>kSkWl"ooEotuvwz{!|}6fQe(8N+T\]sLv<w\TXOOqSUhVWGY	[[\^~^_c:geeghh      _j0^kl}luHyc[ z }_w<N}P QY[/bbd:kruGypc	TTUThXjp'xugtS[PNENNOS8T[_%`Qe  =gBlrllxptvzz{}|f}e[rSE\]bbc nZ1oyZNNNOOPGQzqQQTS!SSSUX\7_J_/`P`m`cYeKjlrrwNWZNQ-\fmi@\fuisPh|PRGW]&e#k=k4tyyK{}_9T]N6PS:SrswwQa^UzzvP[G2NjQ\H\      czltazq|hp~QhlRTfSAyOPRDQSU-WsWQYb__u`vagaac:dleofBhnfu=z|L}}K~kJcf  RbdoAhP kzlTotzP}@#gN9P&PeP|Q8RcRUWXZ^aabrci)j}rr.sxoxy}wcuzUxCQSS{^&_nnssC}7 PNNPS|TVYd[]^'_8bEegVnr|N7gNNOHSIT>T/Z__`hjZtxw^NN|OOPPIQlQRRRSST      TUQWW}YT[][[]]]x^^^^_R`Labbc;efCffmg!hhi_l*mim/nn2uvlx?z|}}^}}T*RLauq?xM  ;[RRSTXboj_KQ;RJTV@zw`Ds	opu_`rdkNVdWXZZh`aff9hhmu:}nBNPOSUo]]]glstxPPW^+cPPQ gT^XY[i_Mbc=hskn}prx&xmye0}	dR(WPgjQBW*:XiT]Wx\OJRT>d(fggzV{"}/\h9{SQ7R      [bdd-gkvLcvRf	NPSq\`dce_hqs#u{~xefkNN:OO:RSSUVXYYYP[M\^+^_`c/e\[eeegbk  {klEsIyy|}+}^ifokN<OOPQW[[HacBf!knl>rtux:y3Pl_X+z[NSW1YZ[`nou[ {rPga\J~Q\hcfenq>y}nPR:\Sg|p5rL+[1_`;NS[Kb1gkrs.zkRQSjT[c9j} VShT      [1\]Oab2myyB}M~Frt/1KlNOOEQAS_bgAlncs&~SY[m]y.~|~XqQSO\%fwzQ_eoikm  ndov}]uQR@bffn^}rfRSsY^_U`dPQR SGSSTFU1UVhYY<Z[\\\\^^^p_bbbcwcff-fvf~ghj5jlm	nXn<q&qgquw]xyeyyz{|9}I]<Tsaf~
NNNWNQpRW4XX"[8^`dagVgDmrsuczr 1VW      bikqT~wrU;\8OOOU Z[[_Na/ceKfhixmm3uuw^yy3}:2NNRuXX\u=\N
cm%{bVS  9TW%^c4lpaw|pBT^t]i]pegncIgiozd[N,p]u/fQ6RRY_'`b?eteftfhhcknrruv|VXRYez-^`befgwMzM|>~
d_xRbcBdb-z{v}INHQCS`S[\\]&bGbdh4hlEmmg\oNq}qez{}      J~z9nxwMRU8o6qhQyU~|LVQX\cffZiruuyVyy| }D}4;a PuRSS	PUXOY=r[d\S``\cc?cc  def]iioqNuvz|}}aIXlpmPXa5 OtPGRsSo`Ic_g,nO^\e}RSvQcX[k[
\dQg\NY*YplQ>UXY`Sbg5Ui@(SOX[\/^_ `Ka4bfln .NS'Y,{Ln'pSSDU[Xbbblo"t8o8QS      SFOTjY1]zh7rH=j9NXSVfWbceNkm[npwz{}=[VX>_efjk7u$Pw0W_e`zf`luznE{\uzQ{  yz6Z@w-NN[_b<fglkw;Nj&p*sWNFQQU[^3^^_5_k__acfgnoRr:u:wt9xvwRWcvglss%mXiiuZXhciCO,og&}T?ipojWX,[,}*r
TNNO\PuPCRHT$X[^^^^_`b:cch@lxyz}GD      -lXdduenv{inT_dMDxQkX)YU\^m~u[pOko0uNQT5XWXY`\_e\g!n{vM%x:xR^WtY`PZQQ  Q RUTXXXWY[\]`b-dqgChhhvmonmopqS_uwyI{T{R{|q}0RciFv-0PRTX\admwzS\?S__myrcwy{krhajQz4iJ\[IpxVo\`felZAQTfHYQMNQXpzcKbi~wuWS`i]lN<\_Sy^esNeQ      Y?\NY_oyby[q+sqt^_{cdq|CN^KNWV`o}3]bdwgl>m6t4xFZuO^bcWeogvLr)MPWZh  sidqrXjyw)/OeRZSbgl}v{|6f or~Q{rx{H{ja^Qu`ukQbnzvOpbO{zVYX4O$RJSSS^,deg>lNlHrrsTuA~,{iq=cifjuvxC*SQS&TY^|_`Ibybbekluvxy}w^j8|P>\_gk5t	w      ;gz9Suf_<__buF{<ghYZ}~v,Oj_j7lothyhUy^cuy(-Tl_e\mp;OetNNW+YfZ[Q^^`vbwe  enfnm6r&{P\tDOdfkaj\SizWOoR_E^gyym_UblNirR;TtVXanbqnY||}e^NuOuQ@Xc^s^
_g&N=[s|PXVvx%Rw{OP	YGr{}MOR)Z_OWUcik+uBzRXUa
bfk?|#POSFT1XIY[\\)]^bgc>eeg      llp2x+~*JlONNPVRJWY=^__?bfgghQ!} ~2 T,SP\SXd4ggrfwFzRlk XL^TY,gQv  idxTWY'fgkTiU^ggR]hNOSb+glOm~Nban+osT*gE]{\[JnzY|l wR"Y!q_rw'aiZZQT}TfvY]rnMQh}}bxd!jY_[ksv}2Q(gvbgR$\;b~|OU`}S_NQY:r6%_wSy_}3VgS	aalRv      8/UQO*QRS[}^`ac	gggnm6s7s1uPyJYNYON?P|^Y[^ccdfJiimnq(uz I!
e}
~ab2k  ltmmeg<ma}=jqNuSP]ko-)RTe\Nghttux_szNceuRAmn	tYukx|zOnae\NNP!NQ[ehmsBvwz|o|uR}+PSgmq3t*W`tAXm/}^N6OOQR]`s<y4
bftkRRp^K`a#oIq>|}o      #,BTojp2RAZ^_g|iijmobrr{~KmQy2-PTqjk`gNNkh i~nxU                                                                                        _NN*N1N6N<N?NBNVNXNNNkN_NNNNNNNNNNNNNNNNNN	OZO0O[O]OWOGOvOOOO{OiOpOOoOOOQOOOOOOOOOOP(PP*P%PPOO!P)P,POOPPCPGPgUPPPHPZPVPlPxPPPPPP      PPPPPPPPPPPP	QQQQQQQ!Q:Q7Q<Q;Q?Q@QRQLQTQbQziQjQnQQQVQQQQQQQQQQQQQQQQQQQQQQQUQQ  QQQRRRR'R*R.R3R9RORDRKRLR^RTRjRtRiRsRR}RRRRqRRRRRRRRRRRRRRRRRRSS8uSSSSS#S/S1S3S8S@SFSESNISMSQ^SiSnSY{SwSSSSSSSSSS|SfqSSSST=T@T,T-T<T.T6T)TTNTTuTT_TqTwTpTT{TTvTTTTTTTTTTTT      TTTTTTTTUUTTTTT9U@UcULU.U\UEUVUWU8U3U]UUUTUU{U~UUUU|UUUUUUUUUUUUVUVUUVUNVPVq4V6V2V8V  kVdV/VlVjVVVVVVVVVVVVVVVVVVVVVVV WVW	WWWWWWWUW&W7W8WNW;W@WOWiWWWaWWWWWWWWWWWWWW
XWWXXXrX!XbXKXpXkRX=XyXXXXXXXXXXXXXXXXXXXXXXXXXXY
YYYh%Y,Y-Y2Y8Y>YzUYPYNYZYXYbY`YgYlYiY      xYYY^OOYYYYYYYY%ZZZZ	ZZ@ZlZIZ5Z6ZbZjZZZZZZZZZZZZZZ[[[2[Z*[6[>[C[E[@[Q[U[Z[[[e[i[p[s[u[x[ez[[  [[[[[[[[[[[[[[[[[\\\\\ \"\(\8\9\A\F\N\S\P\O\q[l\n\bNv\y\\\\Y\\\\\\\\\\\\\]\]]]\]]]]]"]]]]L]R]N]K]l]s]v]]]]]]]]]]]]]]]]]]]]]^^^^^6^7^D^C^@^N^W^T^_^b^d^G^u^v^z^^^^^^^^      ^^^^^^^^^^^^^^^^_	_]_\____)_-_8_A_H_L_N_/_Q_V_W_Y_a_m_s_w_____________________`_!```  ``)``1```+`&``:`Z`A`j`w`_`J`F`M`c`C`d`B`l`k`Y``````````````````_````Maaa`` a``a!a``aaGa>a(a'aJa?a<a,a4a=aBaDasawaXaYaZakataoaeaqa_a]aSauaaaaaaaaaaaaaaaaaaaayaaaaaaaaaa bb	bbbbb      b!b*b.b0b2b3bAbNb^bcb[b`bhb|bbb~bbbbbbbbbbbbbdbbbbbbbbcbb'cccbbPc>cMcdOcccccvcccccckc  iccccccccccd4ddd&d6ded(ddgdodvdNd*eddddddddddddddd	ddbdd,edddd edeee$e#e+e4e5e7e6e8eKuHeVeUeMeXe^e]erexeeeeeeeeeeeeeeeeeerg
ffesg5f6f4ffOfDfIfAf^f]fdfgfhf_fbfpfffffffffffff      fffff?ffffffggg&g'g8.g?g6gAg8g7gFg^g`gYgcgdggpgg|gjggggggggggggggggggggggjhFh)h@hMh2hNh  h+hYhchwhhhhhhhhhjhthhhhih~hihih"i&ihihhhh6iiihh%ihhh(i*ii#i!ihyiwi\ixikiTi~ini9iti=iYi0iai^i]iijiiiiiiiii[iiiii.jiiiiiiijji
kiiijijiji
jjj#jjDjjrj6jxjGjbjYjfjHj8j"jjjjjjj      jjjjjjjjjjjjjjkjkk1k8k7kv9kGkCkIkPkYkTk[k_kakxkykkkkkkkkkkkkkkkkkkkkkkkkkk  llll$l#l^lUlbljllllll~lhlsllllllllllllllllllmM6m+m=m8mm5m3mmmcmmdmZmymYmmmommn
nmmmmmmmmmmmmmmmmm-nnn.nnrn_n>n#nkn+nvnMnnCn:nNn$nnn8nnnnnnnnnnnnnnnnnAooLpnnn?on1on2on  >oonozoxooooo[oomoo|oXoooofoooooooooooooooo	ppopppopptoppp0p>p2pQpcpppppppppppp  p	qpqqeqUqqfqbqLqVqlqqqqqqqqqqqqqqqqqqqqqrrr(r-r,r0r2r;r<r?r@rFrKrXrtr~rrrrrrrrrrrrrrrrrrrrPs
ssss4s/s)s%s>sNsOsWsjshspsxsus{szsssssssssttot%ts2t:tUt?t_tYtAt\titptctjtvt~ttttttts      ttttttttttuuuuuuuuu&u,u<uDuMuJuIu[uFuZuiudugukumuxuvuuutuuuuuuuuuuuuuuuuuuuuuuuuu  uvuuuuvv	vv'v v!v"v$v4v0v;vGvHvFv\vXvavbvhvivjvgvlvpvrvvvxv|vvvvvvvvvvvvvvvvvvvvvvvv/vwww)w$ww%w&ww7w8wGwZwhwkw[weww~wywwwwwwwwwwwwwwwwwwwwwxx&y x*yExxtxx|xxxxxxxxxxxxxxxx      xxxxyyyy,y+y@y`yWy_yZyUySyzyyyyyKyyyyyyyyyyyzzzz zzy1z;z>z7zCzWzIzazbzizpzyz}zzzzzzzzz  zzzzzzzzzzzzzzzzzz{{
{{3{{{{5{({6{P{z{{M{{L{E{u{e{t{g{p{q{l{n{{{{{{{{{{]{{{{{{{{{{||{{`| |||{{||{#|'|*||7|+|=|L|C|T|O|@|P|X|_|d|V|e|l|u||||||||||||||||||||||;|||||}      }}}
}E}K}.}2}?}5}F}s}V}N}r}h}n}O}c}}}[}}}}}}}}}}}}=~}}}}}}}}}}}}}~
~#~!~~1~~	~~"~F~f~;~5~9~C~7~  2~:~g~]~V~^~Y~Z~y~j~i~|~{~~}}~~~~~~~~~~~~~8:ELMNPQUTX_`higxq!(?;JFRXZ_bhsrpvy}Q	)#/K      F>SQqneft_
)+83@YX]Z_d  bhjk.qwx~	5421@9PE/+#|su" 8m*<ZwkniF,oy5b!,@cXH      AKUmw~
"0?MUNT_gq#   	
4?7;%)`_xLNtWhnYScj"!169';DBRY^bk~u}r
C%*+AD;68L`^      fdmjotw~%6A[RFH|mlb   3&+>(ALONIV[Zk_lot}:A?HLNPUblxz|b
Ngmqs	B504J      GILPHYd`*cUvr|
&3;9EB>LIFNW\  bcd!'659OPQRI>VX^hovr}Hb20JVXceisr,^WEIdH?KPZD.      "#:5;\`|nV6+5!:ARD[`b^j)puw}Z|~  o!(./BLOKw\^]_frlM$*09=>DFHBI\`dfhRkqy|zOz8$!7=FOKkop      qts	!$ ,.=>BIEPKQRLU+7EB@C  >UM[W_bedikj"#%'()*./2DCOMNQXt:	
.%$!0G2F>Z`gvx	*&#DA?>FH      ]^dQPYrozuy}a  v!,>JRTc_`afgljwrv/XiYdtQq  ~HOp1fhfE_(NNN OO9OVOOOOOO@P"POPFPpPBPPPPJQdQQQQRRRRR SS$SrSSSSTTTTUYWeWWWW  XXYSY[Y]YcYYYV[[/u[[\\\\']S]B]m]]]]!_4_g___]````` a`a7a0aabbc`dddNe ff;f	f.ff$fefWfYfsffffffg)fggRhghDhhhiii0jkjFjsj~jjjk?l\llollmmommmmmmm9n\n'n<nnooopp(pppqq\qFqGqqqr      r$swssssssts&t*t)t.tbtttuouvvvvvFwR!xNxdxzx0yyyzzz{H}\}}}}R~GbHSY  k !7y"Sv#$%g&'
:@<NYQ9gwx'%!(pW1EH)3;CMOQUWe*+',Nur pk-    p!q!r!s!t!u!v!w!x!y!  p!q!r!s!t!u!v!w!x!y!`!a!b!c!d!e!f!g!h!i!12!!!5"~HOp1fhfE_(NNN OO9OVOOOOOO@P"POPFPpPBPPPPJQ  dQQQQRRRRR SS$SrSSSSTTTTUYWeWWWWXXYSY[Y]YcYYYV[[/u[[\\\\']S]B]m]]]]!_4_g___]````` a`a7a0aabbc`dddNe ff;f	f.ff$fefWfYfsffffffg)fggRhghDhhhiii0jkjFjsj~jjjk?l\llollmmom      mmmmmm9n\n'n<nnooopp(pppqq\qFqGqqqrr$swssssssts&t*t)t.tbtttuouvvvvvFwR!xNxdxzx0y  yyzzz{H}\}}}}R~GbHSYk !7y"Sv#$%g&'
:@<NYQ9gwx'%!(pW1EH)3;CMOQUWe*+',N      ur pk-                                                                                                                                F                            @ABCDEGHIJKLMNOPQRSTUVWXYZ[\]^_`pqrstuwxyz{|}~  v  ]      \\a  ef    gh          dc                                      ~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TUVWXYZ[\]            @ABCDEFGHI                                                                                                                                                                                                                                                                                      |                          a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    @ABCDEFGHIJKLMNOPQRS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  @ABV  XYZqrstuvwxyzkl            `                                                                                  JKTU    @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~        E[RS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        e                  i            `      c                  ak    jd      l                    f        n                          _m    b      g          h                                                                      ~                              rs                        opq    u                                                                    t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            O  s^  N    u                      h                    O          T  v          V  R          h                                                              T        \      ]      ji    S                        l          Ym    w              edt      W  i                                Cj      k  l              x                  `                                            Lmf                A          ZC    n  ]C                                                g              p      o  r      q                        D            N                    W        ar    s                  M                  C      o  U          v              q    {    |              w  ul  `                                t  z    x                                                            y              U                          T          {      P                                  b        B              X      C          @A              lD  }        E        H  F  m          GI          |K      J          VMN          L                  QPO    R          S                D                      U    TWV    XY  Z[~[e    Z  \          }            ]      S_`Za          T            b  c    ~    f  e  gh`i  jk              n  lm  yopq~      ustrv          w          xy    y                          z    {}          }  ~    M        o          n            Y                                                h                      O            U                                  n                      c                                                w  w      J            N    u    E                                                  M                                  k      x                                    C      \                  P    m              T            Kp                                                                        ~X      }                            Q        yFo          f            bp    @jE    i                he      gD@f                  N    i                                z      C                                                                                                    a                                  B      @    ]    P              DC  iA                                  E                N    FG        LK      N              M    J          S  O              H      I                                                SB    Y        XO          P      U          R          [    VW        TZ          Q                                              `e  a  \    fP  h  A^                        b[  c_              igri  d            c                          mk                          p          j  n    l      ko                                    r  w      ut              Q                        q  sR    v                                      }  {  |  ~                  \                  X  x  y                                                                                      d                                            X                                                                              d  l          c                        }                                                    y                    \    n                                      V      B                                R                                                            ^                                        C_                                                                                W    u                                          |        x                                                                          g                                          Y      h                          U              o              m                                                                    n                                      d                                            mp  s                                            [O  g                  Vv                                            t_  z                D            z      @        D      A@          D    J          W    d        B          E    W      i          F                              G    o  n                  KL  I                W  H  P                                  p              Q              O              R  P    NP        M                          VW                SK        k    U                                              X      w      Y  T                                                                        }              ZQ                                                                [_\    ^              ]      k          da                    `    b    c                                ef                            hg                  i                                    l        d  j      m              n  q    o  p                    qr    Es  tuyF        Gvw    w          x  y  z    {  }          ~        F  v  G            @X      qG              {      Q  e          h        x                    Q@    JR                          q                                                A            KsA            r    W                  j    w                R                                                                                            Z            x                                                                                                    s                                      R                                                                                                                                                                                                                                                                                                              B        HI            b  J        F      sz                                                          t    A                X                  y                                                        N  KcH    L                          X    M  {                x                      Nf                p        L            f    @      CD  B  _FEA        GH    I      LJ  KM  N  U  O    PM        QT  U  |VO    o                W      X  ^        Y      J  e    Z      g    [    \  ]    _      `a  b    SR      c`      F  Vjd    e  e      f          ihga  mk  j      lk]      po        n  q            rz    s              O    tJ          S  K            E                uuYZ    z        w                    y      O    x    v    |                              {    |      v    }      }                                                      P                ~  p              b                                                  I        x  Y              {                                        f                y      S              z            D                                                                                        QT                            dS          c            |      J                                                    e                                                                                                                                  ^            @  A              B      CYD  EF                [G              H                  K    I  L    J        M                      }        N  QZ  OV        Pc            }RSWTR    e                                              Z        c    S]d_fb  a  [YU    XS  `q    g                    @hm  i    nA            E\  k        wl    g                                              j          U                        p}                      Jq  so                  {                      ~                x    P        v    |        {      uz    r      t  @    |      |Ty    T[wd          f  }          ~                          `        K      g                                              h                                                      r                                              g                                                    E                                                                                                T          Q              P          dB    o            h          i                        ^                  F    C        [                                                                                                x          U                          q  ~      s            U              h          G  ~                        |    k              l                      af  zV                  {                                                U|    {                                V                              f      t            c                E  W          W          N                      A        i            q                                      g                          b            \      A            @                              B    C  j    D          F    G            H  gXI  Jf]\            L    K        LN      ]  M            NO  {DQ        p  SVU        R  T        W                      Z    m  XY[\      a    Y  t^  n  f        `            f    ]  cb                      }    ge      d    _                ki  gms                u      A      t^  _        M    po      q  n    v  l    j  rh                  `  h                                I            x    Z            z            }        j    i    {j  y          |~  Kj              V            O                                            ~                          [                            B                            d        _      I                            X                          o            A                                                                                k                      ^                  |            Oy    T                    |        P        Y                                                                  \              l                                                                                    W                  ~                    M                                          k          @                                              h                                    @        w                    K  G          F        E    B          DC                          I  E            L    HJ              M                              QN                O                      R      S            T  U                            ~        WVY\            \      [  ]      V  ^    `        _  a      b  c~      c                    de        fg    ih  w    }c  j              lB  k          m          n          op      q  srti  u    Ekv    a        Bw        x        y              z                      |{    ~      }                                                            C                                                      Xi          `                                        ]r                                        D                      B                  v                                                              @            Ag  D                j                                            m                                          k^            F          h                                                l              Y    _Q  \              CZ                              O            @                                    A    U    t                                      B  i                    W                [D~    CYE                  a              k            n  QH    `                F  I                                              XG                  N                                  p                                          a                                    n    M      J                                                                          H    B            Y                    R    A                                                      Q          @                                          N    I              R            KH      k      E  D  M      GFL    C  K          O    P                            U  TV          Y            b  S  L      W            QZ    X                          ][    ^    a      ZG                \  `  _  J  M      d      h    f      N  O  b  c      g  e      m    m  ji  ln            P            o  q                      p                                  r                                s                    D                                  Q      F            u            t                                  RxY{v      z        y_b                            }      G                        ~  |                                  w              B                  T                  S                                                                R                            VW                            U                                                                    F                o                n                              M                          Y  R                                      z        W        C                      Z                                                                                            u              v                            S        q                                                                                        ]                        [                  \                                    _                                            K    T                                                              ]      L              PQ                                                                        b                      l      _                                                                                                                  `                aX          d      b                    c          ]              f                        e                                                      g    ih      j      i                                                            l    k                                                        l                                      m                                                                                                          Z      @  ZA    B  C        D  FGE      rIH                n  KJL            MON      Q  P      r  [  R      Y  S  p    T    cRb\      j  U              V  [    YXEW                \Z{      L  ^l_  ]`  a  o    f  cb            E    i      de  hgD    a`  ^    j          k    l          n  m          u          vp  r    t]    us      oq  a      x    w        y      z      |      {                        s              }~                                                                                                                                                                                  oS    pI  Fc          H            sq  r              t                                  M    u    ~  m  v                        X                                                                                      ^                                                        v                                                  r                                                                                                                    u                                                                              m          Z                                                                                  x      um                    C  j          v        {                          y                                        z            d                    {                          V      O    q                                                      m                                          A                        @                  C                B                D            b    FE            G                              IH      |                        JV          _F            S    P  OcL    N    j_MK  I        [                              Q        Rh    \T        S                          T                U    W      X  H    Y          Z[    G              \  H          b    ]                d  `  a  `^      _                                  H              b      c              Bdet      gf                              i        l      jmke  m    s    o      n            n                  pq          r  n        t            u    v            w                    y{xz            A                  |E      q~                M                }                    v      G    [            ^|                                          J      }        y                                                M      }                                                                                                Z                    \                                          z                                                    U                                                                                                                                                                                                                        H                          eS    l                                                            W                      f                                    n      I  @  g      C  [    R      B  hA      fa                  F  Ga  I              H    IgDJ      Eo  MQ          L        U  i    R      O          P    NK  G          W                      T          V      S          pX    e  a[              _Zbfj  \  d  Y]  ^              ]                  g    chj  m    i                  l              k              n      uov            r                    t  qwp    c        D    k    s    {  ~  |z  `      }    x      @q  J          DU                      y          J                        [        \    Z                                                                                                                                                                                                                                                                                                                                                                                                  r    u        l                      r                                  Q      A`                          H                              K                                                            |      sV  l                    k                                                            ^                                                                              E        W            ]                  I                    b    m  n            x                  _          w                      E                                            E\            e                              r                                    E  ]                  B              A            t  D  Cor                  T          HI            G  F    J      B        N  OK        L  M        p      U  Q          G    P    SR      cV            W    V  X    Z  ^    [Y^\  ]        d_      `      a          cbe        fg    b    h      L          v          ijP  k    lm    n  op  q  r        s    Cw  M                  tqu          w  vD            x                                            zy|    {  }      ~            F                                                                                H        m  c    F        |                                            c                            p                                s                                                                                  t        `  r                                                                                                                                                                                    e                            p                        H                                G                                                                                          t                                                    K                                              N                  f                                                        ~      uW                    `                              H  @                                                                U                                                            @          B              C                          n  J                  P            Q  D          NF  H          RG    K        LO              E  E  IFdO                  VT            m              S        UW        X            [Y            Z      M                          \a    `      A      bh    ]_              ^    PA    d              c                      e                            f                          g  s      i|            j              k                l                                            qr            m  \                          na        opz      tw          s                          u  v  x  `  ua          {        ^      |                }    ~g                          I                          w                                                                                  X            I                                                                                  Z                                                                                                                                                                              I  a                                                        y                                                    O          s        p      X    q      t        \                                          U                                                                                                        T                                                                            J                ]                                                                                                            A  @      C    B  D    P  E    F            G  v  H    eI  J      K      K    `L  o            M        O  Ne  P    Q    R            S    T  UV                                  p              W  XY              GZ                        [      \                ]        v  u  `    _  P    ^L    a  b          c        K            i  d    f        e        h  i              g  ]          f      r  mw          llkF  lbY              j          o  pn    _    F      s    a    U  v        r  wtuq          N                  b      z  x    k      y  z          _      {      ~      |  @      }              dy                            u      w              T                                                                                    x            c                      ]                  Q                                                                                                                                                                                                                                                                                                                                  J                          L                                                                      ^                        e                        L  v        n  M      \  fGd          G      o            ^                  q                    w                                                                                                                                                                                          q          N                                z                                                                                                                                                                H        H                                x                                                    H                                              @DA  B      C        J      E          G    IF                          L  R  K          M        N    QP  O    SR        U  TV        W              Y                XgZ    []                        ^            _\  `  aOR                      b          ]c              f                            edyg        r  i      h  q          kmj      l  pnP  o            r    y        S      s        Au  t    x`    w  v{    z    yQ|                }        ~      D                                                                                                            h                      CJ_                H    I  v                }                                          R  q                      t            r      A                      Ti          N          x    V^  B          k    y  K              JI                      W                                      M                        @                                x      Y                                S                s              X            s                                                                                    A                                                  Uz                              |          V            y  _                                                      X                                                              d        B  j    t                                                          b                                          n                                    S                                                        z                    g      e      _                L                                      K                                                                N                                  s        e        e|              K                              @B      AC    d    B      ^    E        DF                      ^      t              K      bG      H                      L  J                      I                                          O                            Z        MN  L                P                  V      Y              XL        QRU        W        ZT    S                                                  ^      _                `    ]\      [            d                  b                ca    e            f    h                    g            si    l  j  k              m          o        p  q        truw  v                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            xM      y  zJ      [  {  |  }~              t}                  {                                                                                                                                                                                                                h                j                      ~                          @w              A          z                G  @  K        u        B                                    YW        G                              J            _          d                k                                                      I        P                                        r      v    x          C                                                            f                                                                                                                              B                C            {          a        z                              j            o        p                        z{              ^                              @  BA                                                                                                        C        D  E        F                        HG  I                                            H    Q            J  K  Z                    O        L        M{  a      `  NO      P        RS  UQ    T          V  W                            XY      Z    \      [  ^a      ]_`    b                                                                                                                              cd                    e    ]      nfg        y              h            w                m        l    j  k  i    w                    no    pq          s    r      x  t      v                Ru              x                                y                    z              }  |~  {                                                                                                                                                                                                    [                                                    @                  E                                                                                                T                S        @                                                                    D    B  A                                              C                                    L  N    D              E                                    I                        ~                                      F                k                                        h              V                  L                                                                                                                                                                                                                                                                                                                          P                                                                                                                                      DC              E    L@A      B            HQ    JG  F              K                        H  G          {                    L                  M        N  I          O        S  TR          QW  P  U                V      Y          X                        [            \  ]    h          Z    ^                                                      J_`    a                                                                                                                                                                            b    c      d    e            f    gh        ki[  j            l            m    np    q                    o                        sotuvK  w        xzy  {        |    }            ~                                          C                              l                                                @                          V                                                                                                                            s                                                                                                                                                                                                                                                                                                                                                                                                                                                                            X^u}~I  IWVij{C|D^OPQRSTUVWXFGH`abcdefghijklmnopqrstuvwxym_nOQMobp`                                                                                                                                                                                                   PU            	 
                        ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~                                                                        \   N            }    L                                                                  ~                                                              CP932// outbufstart == ((void *)0)  ../iconv/skeleton.c (state->__count & 7) <= sizeof (state->__value) ../iconv/loop.c inptr - bytebuf > (state->__count & 7)  inend != &bytebuf[2]    inend - inptr > (state->__count & ~7)   inend - inptr <= sizeof (state->__value)    inend != &bytebuf[4]    outbuf == outerr    nstatus == __GCONV_FULL_OUTPUT  inend - *inptrp < 4 to_cp932_single from_cp932_single   gconv                
                                                   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ,                          D$     o          o          k o8     <     \  
                p    (                      H         oL  o   o.  o                                           o                                           8p A0   aeabi &   6 	
"CP932.so    8	) .shstrtab .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                                                  ,   o   8  8  $                6         \  \                 >         <  <                    F   o   .  .                  S   o   L  L  @                b   	          H                k   	   B       (               t                               o             P                 z         X  X                            D$  D$                             L$  L$  \G                         k k                   0         k k L                         o o                            o o                            o o                            o o                           p  p 8                          8p 8p                            <p <p                        p        <p 1                                mp                                 }p                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ELF          (      4   Q  4    (                  @ @          N N N X  \            O  O  O                         D   D         Qtd                          RtdN N N                    GNU 5x=0)6@%G         GNU                                   c5R                           
     N       t              F           "                                                                                                                     U               ,                             {   8  8#    i           __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses gconv_init strcmp gconv _dl_mcount_wrapper_check __assert_fail __pointer_chk_guard __jisx0212_to_ucs_idx __jisx0212_to_ucs __jis0208_to_ucs __jisx0201_to_ucs4 libJIS.so libc.so.6 ld-linux-armhf.so.3 $ORIGIN GLIBC_PRIVATE GLIBC_2.4                                         c	   8                 ii   F      N    N    HP     P   $P   (P   ,P   0P 	  4P 
  8P   <P   @P   DP   P   P   P   P   P   @-  -$K  $$ $ $ $ $0 0   R/J 8   @-808 0  00` S$00 0  S3/J J J $   @-@ @0  00`4 C1 ?0    R2/J J DJ D   L @- D0  0  R4 0  S  
(0 0 0  LJ I     J J 4 @-  ,0  0  R  
 0  S   
3/@H I @   8@- @P P  P
  0 8 $( ,000  4 8 x  P	  0   8 $0(0,0  888 O-|M@ <`$p @L0   P<`@p@(	  <0P  S(  
p?0 0+(  T `  \@  0   Vhp4p4  \h0w  
pp D$p  
p  W 080  S 
 $ t  Pp <   P0
  
0lp@$`   0 S0f0 U :	 [
 *$lp A0  0 U p0 \ S   Q l0 Spp$ ,C6Rt :*C B  R[   Q 
    R  
t0 Y  t  
p0t 0  Sp0t : 
pg  0 W,  0`0c @ 80 t  ``  0@ `80 ((- A.A  S$`,  
pt 8  LC6T  *      P"  
  0  S  
t  Y  t 0u 
tp  tp  U6  
   Ue : Y^  0 SH  5@   P  S
4  X 
 @  Ts 
ptp8  @  Th 
  n  0  0  4
 </ P
 P 8p t  
 U8@ p  \    p  WP P  
   P  
H    @0</p  WP 0 0 a  TB   xp(  '0/0 p 00p< @0(</ P p  
l \+   W  0 p80   S p,Y U 
  Y :pXX
Xp  p0@8 DT`,   U  p Wi  Px 
 P 
 P c Q   W  
 Pz  G^?A    P  
p  P  
j \0  
  @ U  
  YO :  @ P Q0 P4`  V  
p  W  
  0  U  pT`pr  JC@D T 	JC T  	  S  	^pl   @@g_@Dp m@l LC)@DAT     <C	0C^ l   @0b!0p m0l LC@D T $p @ Tp[
  WY
`@  T  | P4  
 P  ^pi  P  : P   @^pGp  Pm   ph \0{4  \Z  
   P  
  0   rT`pp p  \ 0
  @|T`8`k   PQ< p8@p8@p0 Y| p0 0t0  t 0t <t<0w8p  |p t8   
4@ p 0p 0 0pf0@pT`p8 L`    P p#Rp0 p0%  
  S
4  Xl  
   Xg  
t`p@    0  0$ @4`
 </ PY    Xp0 b     S Pd  
  P<0 @80 4  -00` p80 *C  R%   S  ^ dB! A `_ Bqe dh<C@%0C^ cd"#  B0`!0re0d,C) BAR  u00  P  p0,C B RyAA`4@0p0      $pp  WQ 
 P$  c @l R <  R2 $`p  V  $`0cm p R`  V|$ @ \p     \	  
 t`$    R Y8:$ t`B  p U  W   \ t pB R QH   Rr 
u   W, N u  P?  R 
H \ 
 R3 f QA  P& 
 R @^?A   /   R 
v   R- 
B \  
   Q
f 0  Q   @0` b 0  8 0 80 VD p 0 c R   U   	       0   0 U0    + 0   0 0  b/0 p U P  $@0 p0 S0 S @ |H ,   P!  4@ x   $   L?        \.  - , -    6   ) |( )   t( ( ) T1 & \& X' & <& 8' & & ' % % & % % & $ $ ,%   P$ # % $ # $   `          " /  d  |  ! 4! 4   0     ( 	    '         W    ]AL\   <     (  |     \ (       Y  p   t0  t 0t <t<0)p0 U`! 5-Bttt1  @!01  w/01  d!01  b/01  -04@  T"  
p   
      8 R  
 R   R  : R   B^ @"zR  L    R   |  4@  T
p 
 00 08,w0 W:  
D$0f @ l S (   S  P  W  H C 0p S  
 0 4@  T
p 
 0u0, 0uxxx3  #0q3  w/0i3  #0a f Rv@_ r ] R^   PM   @,! RlF  
m RD   Q?   @L ^ D"   R      R   R/  L@  `    R%  
 R  
w  RA R
 M$L  !  R  
 RvI4@  T]
p Z
D$v@w  8  ,p$ P   @^ @" Bi R  ,    Rw   P
 @^ w@" , ^i v @%   R`h0p   @0` 0XP  U,   `0`0`````` `0  I(  p `p@< @0(;/|hhh6  p&0@8p @D6  .0\p   
  
4  \M
   P
  0     Y*T`6L`  PJ  
v PG  
0 c P>  _ p ] PV   WE  `G a! VH ^  
m V\   P:  `G LLp^p p  W	  T`pP0p0 PP0T`p PC  ` L`  gP    P8  
 P7  
w PA pW
  Pp ST`4  \
   P/
   W  pG^ !Ai Q  D`   Pp3D p1 W
 G^p p $p ! pp8pp @ 0@80  S  
8)89 0,B>@ B0 pp`t`8 D0H@, 4pP  C6PT  *   \#  
 0  S  
t  U   t0  
t0p0t0p V  
  V  : U;   0 S,
  5@   \  S
  W  
 @  T  
t,p    0  0, `p
 </ P  @  TptH@   @Pp`0  
C @ P  D@ Pp`@0 l   T,  S"  T00C0B Ua  
   \H O  :l;0tt+\084 ,0LP@^ TX pD p G W R %   Wh 
  U^  Q  W 
 W  
 W  c RR  Q  
 W  -A? B'Xp /p  W  
   W@ 
 Q   
 pH@0 U  
p \Hp*,0p8D0  @0  ,  ,0p8D0@0  P   
P  Q  
  
0   0 U  p0 0t0  t 0t <t<0Pp` @p0h,0p8D0@Pp`0Z@Pp`,0S
C P-  - S  d @^@,L  d_ @|e d 00 p 0,  P,   
pt<CH0C^ d ! A0`q!0e0dC) @AP   Pp` 0pt@C @ P(  8@  W  
 W   W  : W  pGA!/ Q   pp  W? p>,i '5T k.p  W
.Pp 
/  p0@p?  /0??  ..07/ q  W  
/ W  
   PP
P  QM
 0 	  PF
Pp  WC
q ppc W3  p_z] ZO   Q?  A! ZbW  
m ZU   [5  dGA
p!
 Q  
p Q
 QB   qjpp  W9  
 W 8  
 W B
,0p8D0  P
P  [
  0    p Q  Aq" Bi R  \ p  W H p Q
A q'|ppp  4   0     @-p!q!r!s!t!u!v!w!x!y!`!a!b!c!d!e!f!g!h!i!12!!!pNPQS$STYWX[\S]_` aNe;fef)hkjjmm(puvv0yz}}b !"v#$%&'();MQ*+,r-                                                                                                                                                                                                                                                                                                                                     000000 @ >?00000N0000  <^%"\& %     	00;=[]0	0
00000000   `"f"g""4"B&@& 2 3 !
  &&%%%%%%%%%%%; 0!!!!0                      """"""*")"                '"("!! ""                       ""#""a"R"j"k""=""5"+","              +!0 o&m&j&  !          %                                            !"#$%&'()*+,-./0123456789:            ABCDEFGHIJKLMNOPQRSTUVWXYZ        A0B0C0D0E0F0G0H0I0J0K0L0M0N0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0\0]0^0_0`0a0b0c0d0e0f0g0h0i0j0k0l0m0n0o0p0q0r0s0t0u0v0w0x0y0z0{0|0}0~0000000000000000000000                      00000000000000000000000000000000000000000000000000000000000000000000000000000000000000                                                                                                             !"#$%&'()*+,-./                              012345Q6789:;<=>?@ABCDEFGHIJKLMNO                           %%%%%%%,%$%4%<%%%%%%%#%3%+%;%K% %/%(%7%?%%0%%%8%B%                                                                                                                            `$a$b$c$d$e$f$g$h$i$j$k$l$m$n$o$p$q$r$s$`!a!b!c!d!e!f!g!h!i!  I33"3M33'3363Q3W33&3#3+3J3;33333333                {300!3!!22222122292~3}3|3R"a"+"."""" """5")"*"    ''%%((++,,//--00"B77    668855::;;==<  >>$DGGEE    FFDE&FHHIIGJJLLKK)I(HMMOONNJ+KWW    VV-MYY[[ZZ\\]]__^^aa``/Olliiffkkhhjjqqttsuuwwvv                                                                                                                                                            &&CCUUggppmmoonn                                                9                                                                                                                                                                                                                                                                                                                                                                                                                                  0                                /265  3                                                                                                                                                                                                                                                                                                                                            89a  bcd  g  ilv  ejqrst{xuzwy|                                                                                                    BCDEFGHIJKL  MN  rstuvwxyz{|  }~                                                            ~                                                                                                                                                                                                                                                                                                                                                                                                                                                                 o                                                                                                                                    stuvwxyz{|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            !"#  $  %          &    '(    )  *  +,-    .        /01  2          3      4  5    6        78                9:      ;        <        =      >?  @        A            B          C        D      EF  GHI    J        KLM  N      /OPQRST        UVWX    YZ[  \                                  ]^  `abcde  f  g    hi  jklmnop_    q          r  s  tu    vwxyz{  |}~!  "#$%&'()  *+,  -.                        /    0  1  23456789  :;<=>?@        A  BC                D  E        FGHIJ    KL  MNOPQ  RSTUVW  XYZ  [  \]  ^      v        _`a  bcd  e  fghi  j  k      lm  no  pq    r  s    tu                w  xyz      {    |}~!"#  $  %&  '()*+              ,    -.      /0    1  2  34  5    678  9:  ;    <=>    ?@ABC      D  EQ  0F    G    H  I  JKL  MNOP  R    STUVWX    Y      Z[    \]  ^  _`ab  cd    efg  hi  jk        l      mn                    o    pq    rs  t      u    vw  x    y  z  {|}    ~    !    "  #$%  &  '    (  )    *    1+  ,-./      012          34567                8    9        :;  <=            >    ?          @AB  CD  EFG  H          I  JKL        M  N  O  P  Q      RSTUV  WX        YZ[\    ]^    _`abcd  e  fgh    i  j  k  lm  nopqrst  u      vwxyz      {|  2  }~!  "  #  $%&'(  3)  *+,-./  01  2    3456  87          9:    ;  <  =        >?@  A      B    C    DE          F        GH    I    J  K    L  MN  O  PQRST  U  V    W    X    Y    Z[\  ]  ^_`ab  c              d        e            f    g        hijk  l    mn        op  q    rs                          t    u  v  wxyz  {|    }        ~!  "#  $%5&'    ()          *    +  ,  -./012  3      45678    9:    ;<                                =      >  ?@          A        BCDEF    GHI    JKL      M                                      NO      P  QR    STU  V    W  XY  Z  [\      ]  ^_`  ab  c  d                                          efg  hi    jk  lmno    p        qr    s    t                      u  v  wx  y  z{  |    }~!    "#  $  %    &        '                        (        )          *  +,    -./012    3                                4    56789  :;<  =>?@A  B    C  DEF      G                H  IJKL  M  NO  P  QR  S                      TUV  WX            Y      Z[    \]^      _`ab  cde    f  g  h          i    j    klmpqno        rstuv  wxyz{    }  ~  |    !"        #$    %&'    (  )    *+,  -  ./0123  456    78          9:;      <=      >?@            6              A  BCDE  FGHIJ  KLM  N  OPQR  S  TU          V            W`  X  YZ  [\]^_    abc  d                  e        f            gh    i  j    k          lm~  n  op  q      r    s      tuv  wxy  z{  |}!"                      #  $%&      '(        )  *        +      ,              -./  01  2        3  4  5    67                    8    9  :;<      =>?@  AB  CD    E  F        G9HIJ      K  L          MN        P      Q  O  R    ST  UVWXY  Z  [\        ]    ^                    _`    ab      cde  g      hij  klmn  op          q      r  s        tu  vw  xyz{|    }~!    "#$  %  &'                ()*      +  ,-        .      /  0      1234  5      6  78      9  :;    <=  >    ?          @AB      CDE      FG  HI  J  K            L  M            NOP    QR              S    TU  VWX    Y  Z                            [\]^    _      `        a              b      c  de      f                  g    hi    j                      k        l  m    n    op  qrs  t        u        v        wxy  z    {  |}~    !  "  #      $              %  &      '    (    )      *            +,        -    ./            0                    1  3  4  5      6    7          8        2    9            :              ;<      =  >  ?        @      AB            CDEFG  HIJKLM  NOP        QR    STUVWXY  Z    [\      ]  ^    _`abc  d    :  ef  g        h    i        j          kl  m  n  o  pqr  st    uv                        wx  y    z{  |}~    !"    #$    %&'(                  )*  +      ,-                  .  /012    3  4        567  8                  9  :            ;        =        <                    >?@  A;              B        C        D    E            GH  IJ    F          K    L        M      N  O    PQ    R  S  W    U<  T      V        XYZ[  \        ]  ^  _            `a      bc  de    f  g        hijk      l  m    no          p      q    r  t  s    tu            v      w    xz  y        {|      }  ~!            "#      $      %      &      '  ()  *    +,            .      -  /  0        1          4  2    35    67    89  :        ;  <=>?@  A    B          C    D                        E  FGH  IJ      K  L          MNO      P  RQ  STUVW      XY  Z      [                \  ]^_`  a  bc    defgh  ijkl    mn    opqr    st  u    v  w  x  y  z    {|}  ~    !"#$  %&  '(  )*  +    ,    -.  /  2    013456      >7              8  9:;  <    =>?@A      B  CD        EFGHIJKLM  N    OP                Q    R    S  TUVWX  Y    Z  [      \  ]                  ^    _`ab    c  def      g  h  i  j                    kl  m?n  opq    rstu    vw  xyz{          |}~    !"      #  $%&'(    )*    +,    -./01  2                34567    8    9:  ;<=>?@AB  CD  E@F          GH      IJ    KLM  N      O  PQR                  ST          U  VW    XY  Z[\]^        _  `  ab  cd  ef  gh      i  jkl              mn  o    pqr    st        u            vwxy  z{  ~|  }    !"  #            $  %&    '    ()      *+,-    .  /0            1    2  345  6  7  89:;<    =>        ?              @A    B        C  D              EFGH                    I  J              K  LM  NOP      Q  RSTU                    V    WX        YZ  [\    ]^_    `  a    b  c                        de  f            gh    i  j  klmn  o    pqr  stu  v    w                xy  z{    |  }~!  "#  $  %&    '(    )    *+  ,-    ./0123                  4  5  6  7        89:;<      =      >    ?      @  A        BCD  EF                          GH      I  JK  L        M  N  O  PQ  RS    TU      V          WX                    Y    Z  [\]^        _`ab  cde  f              g        hi      j  k            l  m            nop      qrs  tu  v  wx  y  z    {            |}~    !    "#$%&  '(  )  *            +,  -.  /  0  12    3  45    6    789        :      ;<  =  >  ?@A    B  C    D  E  F    GHI      J    KL      AMN  O      PQ      R      S              T    U      V  W  X      Y    Z  [  \  ]  ^_      `  abc            d  e  fg    hi    j  kl        m            no  pq      r    stu  v  wx  y  z{|}          ~!"#$%&'()*+,-  .0  /  B    123    45  7  6        89:  ;<=>  C@AB      DEGHIJL  CFK        MNO  PQ      RSTU  VW    X            Y    Z[  \      ]  ^_`a    b    c  de        f      g  h            i  jk  l      m?      n  o    p      q  r  st  u              v        w        xyz    {    |}        ~!        "#$%      &    '    (        )*+  ,  -./0                        1234  567    9:;<  =>      ?    @A  B    C    D        EFGH  8        F                            J    K      LM          ONPQ  RSTU        V  WXY    Z  [  I\  ]^  _                    `    abcde  f  ghij    klm  n                  op  qr  st  uvw    xy      z              {  |}  ~!"#$%  &'      (  )  *+,-./    01    234        5  6789:    ;<                          =  >?  @  A        B    C      D      E          F  G  HIJK  LMNOPQ  RSTU                  V    W  X  Y          Z      [\]    ^  _`        ab  cd        e  f    g      hi            j    k        lm  no  p          qrst              u  vw    x  yz{      |      }  ~  !"#  $%        &'()    *  +,-    ./    0          1  2    3I          45                  67  8  9:  ;  <    =                >?@A    B        C  DEF  G            HIJ      K  ML    N      O  PQR      ST    J  U    V    W      XYZ              [\        ]^_`  a        bcd      e      f  g  h    i    jk    l        mno  p          q  r  s    t  u  v    w  x  y  z    {|    }        ~!  "#                    $    %    &'  ()      *+,-./  0123    45    6  7        8    9        :  ;    <=        >  ?        @  A          B    C  DE    F      GHIJ      K        L        MNO      P  Q        RST  UV    W              XY  Z[  \  ]    ^_`          6  a  b  c  d  e  fgh        ijkl          mnopq    r                        stu        v  w      x  yz{|}~  !"    #    $%&'  ()*                              +    ,    -  ./  01        2              345    78  9    :  ;<                                        =      >?  @  AB      CD              E          F      G            HIJKLM                            N  O          P  QR    S  T      UV  W  XY      Z    [  \]^_  `  a  bcLdeKf      g      h                          ijk        l      m  nop          qr    stu  v  wxyz  {    |}~    !"      #            $            %  &                    '      (      )      *        +        ,-  ./        0    1234  56789:                                          ;<=          >  ?  @    A    BC  DE      F  G  HI              J    KLS  MNO    P      QR                            T  UVW    XYZ[\  ]^      _      `                ab  c  de    fgh  ijkl  m    n        op  qrst        uvw    xy        z        {|}  ~                        !    "          #$    %    &    '  ()  *      +,-      .            /    0    1    M          2    3    4  5    6          78      9:;<  A        =>            ?@        BC          D  E        FG        H    I      JK                  LMNOP  Q                R            STU  V    W.                          X        Y  Z[\]  ^    _          `                                      a              bcdef    gh    i                    j  k                l  m  nop          q              r      stu  vw    x  y    z  {  |  }  ~    !                          "          #      $  %    &        '        ()      *  +                    ,-./          0      123  4        56      78  9:  ;                                    <    =>          ?@A              B      C    D  E  F        G        H  I    J  KLMNO  P      QRS  T  UV  WXYZ[      \  ]    ^_  `      ab  cde  f      g      hi      j            k                  l      mn  o  p              q    r  s  t    u          vwx        y    z                    {|    }~!      "  #$  %    &  '        ()    *+  ,    -  .  /01    23  4    56  7      8              9:  ;      <=        >?@A        BCDEF  GHI      JKL      MN  OPQ        R  S    T  UVW      X  YZ[  \    ]^    _`  a          b  c  d  ef  g      hi  jklm    no    p    q      r  s  t  uv  w            xy  z{|}  ~!"#  $%  &            '                ()              *+  ,-./012345    6        7  89  :;      <  =      >?      @  A  B  CDEF  GHIJ                    KL    MNO  P        QRST          UVW  X  YZ[\    ]^_`a    bcde    f      g  h    i                jk  l    m    n      o  pq  rs  t  uvw    x  y    z{|    }  P  ~              !  "#      $%  &'()    *    +,-./0    1  23456      7  89:        ;<    =>?@AB  C    D      EFGH      I  J        KL                    M    N  OPQRS      TUV        W  X  YZ[\    ]      ^  _`a        b    cdef    ghij  k    lm  no    p  qrstuvw  x      y      z{|    }~!"      $%&'()#*              +  ,        -    ./    0123  4        5Q6    78        9    :;<R=>  ?@ABCDE  F    G                H    I  J  KLMN        O    P    Q  RS    T    UV    W  X  Y    Z      [\  ]      ^  _`  a  bcd    e    f      ghi        jklm  no    p    qr    s    tuv    w      xy    z  {|}~!"  #$      %  &'(        )    *+      ,            -.        /01      2      3  4      5    6  789    :      ;      <        =            >?    @    A  BCD  EF  G  HIJ  K      L    M              NO    P    QR    S                T    UVW            XY  Z    [  \                  ]^  _`      a  b      c                  de  fg  hi      j  k  l                m    n                o  p    q  r      tuv  s  w    x  yz  {|}~          !"#        $%&'  (  )*+,      .      /01    -  2  3          45  78    9:    ;6        <        =    >            ?  @  ABC        DE  FG    TH    IJ        KLM    NOPQR      ST  UV  WX        YZ  [          \          ]^_  `            ab  c  defg  h    ij      k        lmn    op  q      rs  t  u    vwx      y    z{    |    }~!"#  $%&    '            (    )        *+      ,-./    0    1  2  34          5      6  789  :;  <=>  ?@AB    C        DE  F    GH  IJ  K  L  M  N          O  P    QRSTU    VW        XYZ          [\    ]            ^      _  `    abc          defg  h        i    Yjklm  n    o    p  qr        s              t            u    v  wxyz{|}~!  "          #  $%&      '  (  )                *      +,  -.  /012  3                      4    5    678  9:;<      =          >  ?@A  BC    DEFG    H  IJK            L  MN  OPQ              RS            TUVWXY  Z  [  \]^_  `  a  bcde        f  g      h    ijk  l        m  no  pqr            s      t    vwxu  yz{|}~!  "  #  $    %&  '  (        )    *+        ,-        .    /          01  2        3    45  6789    :  ;<=    >?    @ABCDE  F        G  H  I            J            KLMN    OPQRSTU  V    W      XYZ          [\]^_`a    bc  d    e  fghi      jk  l        m    nop    q  rst  uv  w  xyz    {      |}  ~!\      "#    $%&'(      )*+,-    ./0      ]12    4  56  789    :  ;<    =>        3        ?        @A    B  C      DEF    GH    IJK  L  M    N    OPQ      R  S  T    U    V  WX    Y  Z  [\    ]        ^  _  `    abc  def  g  hij                                                                                                                                                                                                                                                                                                                  lkmno      pq  r        stu        vwx  y  z{|}  ~  !            "#$%      &'()*      +,      -    ./  0  1    2      3        4  56  7    8      9:                ;      <  =  >  ?  @  AB  C          DEFG  HI  JKLMNOPQ    RSTU    V  W        X  Y  Z    [\]  ^_`ab      c                                      d  e  f          g  hi          j    k    l                mn        op  q            rs                    t      uv    w  xyz{    |                  }~!"#  $  %&  '      (  )                    *+,  -  .  /    0    1      2    3    4      5  6              78    9:    ;  <              =>      ?@A    BC        D        EGHI    J    KF      L  M  NO    P              Q    RS      T    V  W  XU  YZ      [  \]  ^_`  a    bc    defgh  ijklmn      o  pq  rst  uv          w        xyz              {|}~      !    "#  $        %    &  '  (  )    *    +      ,  -./0  12    3  45  6    7  8  9  :;<    =>  ?@ABCDEFGH    IJKLM          N                  OP    Q  RSTU  V  W  X      YZ    [\  ]^_`ab                      defg  hi            jklmnop  qr      stu  v      wxy>cz{|                  _                          }        ~    !  "#  $  %&      '      ()*  +,-./        0123L                          456        7  8    9:;  <          =                ?@          ABC  D      E    F    GH  I    J      K                                M            N                  OPQR    ST  UV      WXYZ[      \]^_  `a  bcde  fg      h  i                    jkl            m          n  opq      r  s  t      uvwxy    z{|  }  ~          !                    "    #    $%&'      (    *+,    -.    /        0  1  2        3  4  56789    :;  <    )=>?              @      A      BCDEF  GH  IJKLMNOP      Q    R                STU  VWX    YZ[\]    ^  _    `  a  bc  d  efta      g  hij  klmn  o        p  qr  s            u  v    wx      y  z    {          |    }  ~  !"    #$      %&  '()    *+,    -    .        /  0                  1  2  3  45  6f7      8                9:;<=>  ?@ABCD      E  F    G        HIJ  K                        m  L      M    N  O  P  Q        R    STU  V  W  XYZ[\]          ^_`  ab          cd  e  f  gh  i    jk  l                      nop    qrst  uvwxy      z    {|  }  ~      !        "#  $%        &'()*+    ,  -        .            /      0  1  23          4  56          7          89:;<=>  ?@    A    B  C  DEF        GH  I      J      KLM  N    O          PQR      STU    V        WX    YZ  [    \  ]^_          `a  b    cd    ef    g  h  i  jd  klm  npqr  sotuv  wx        y        z{  |}    ~    !"      #$%  &'()*    +  ,-./0123      4          5        6  7  8                              9:;<  =>          ?  @                A    BCD        EFGHI  JKL      MN            O            PQRS  T        U    V      WXY    Z[  \]^  _  `        abc          def    g  hi    j  klmn    o      p    q      r    stu  vwx        y  z{  |}      ~!"#        $  %  &    '(  )*    +,      -        .  /012      3                                      45678                9  :  ;  <      =  >  ?  @      A  B  CD  E      FGHIJ      KL  MNO      PQ  R    ST    UV  W  X  YZ[      \]  ^_`a    bc  d  ef        ghi  jkl  mno  pq    r  stu  vwx      y  z{    |}  ~    !"    #  $    %  &'()    *+,-.    /0          1  2  345    6  7  89    ?:    ;        <=>              @    A          B      C      DEFGH  I    N    JKL    M  O      P            Q      RST    UVfW  XY        Z[\  ]^      _  `a                                                                                                                                                                                                                                                                                                              bc    de        fghi  jk  lm  norp  q      st  u  vwx          y  z{  |  }          ~!  "  #  $%      &  '(    )        *+  ,-./  0      21    34  5    6    7  89  :  g;  <=  >?  @  A  B      C  D      E                                                                                                                                                F  G  HI      h              J  K  L    M      N    OP      Q              RST        U      VW    X    Y  Z  [  \]o    ^      _`ab  c  d  e    fgh  i        jk  l  m    npqr            s    t    uvw  x      y    z  {            |}~!    "#              $  %&'()      *    +,      -./0      1        234567        8    9:  ;<=        >?@        AB    C      DEF      GH  IJ    K        L  MNO  P  Q        RS      TU  VWX    Y  Z  [            \                ]      d^  _`          abc  e  f    gh      ij  klm  nop  q  rst  uvw      xyz{|    }~!"      #  $%&'(  )      *+  ,                                                                                                          -./  012            345    678  9      :;  <  =>?@                  A  BC  D  EF    GHI  J  KL  M    N  OP        QRT  UVS  WXY      Z  [\    ]    ^_  `  ab    cd    ef    g  hij  kl      m  nop  q        rst  u            vwxyz          {}      ~!"  #$    |        -    %  &'(  )*l+    ,        /    01      2.          345    678  9        :    ;    <n=>?@  A  B  C  EF  D  G  H      IJK  L  MN  OP  QR          S      TUV    W  XYZ[          \]  ^    _        `  abc          de  fg  h  i  jklm  n        o    p    q  r  stuvwxyz    {|}  ~!"  #    $%  &'()    *+  ,-  ./0123      4  5  67  89    :;<=  >?  @  ABCD  E      FG        HIJK  L      MNO    PQRSTU  V  WX  YZ[\]  ^_`a          bcde  fg  hijk        lmn      opqrs  tuvw          xyz    {|    }  ~!    "#      $%  &'    (    )    *      +,-./0  12345  6789    :;<=>  ?  @  ABC    DE  FGH  IJ  KL  MN  O          PQ    RS  T        U        V  W    XY      Z[\]^_`abc      defg                        hij        klm  nop  q  r        st  u  vw  xyz{  |}~      !  "#$%&          '  ()*  +    ,  -.  /    0    1  23  45;  6        789    :            <  =>?@ABCDE      F    G    HIJ  K  LM                            OPNQR  S      TUV    WX      YZ[    \]^        _                        `a  bcde    f  h  g    ij    k  l  m          n      op  qrs        t  u  vwxyz                  |{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }~        !    "    #$%&  q          '()*+,  -.          /  0    123          4567    89:;  <=  >?@A  BC                                                                                                          DE    F  GHI      J    KL      MNOPQR  S                  T  U  VWX      Y          Z    [  \]^_  `abc  d    e    fgh  i    jklm      nop  q            r    s      uvwxy            z      {|        }          ~!"#                $%&    '()    *            +,          t      -.    /    u01  v    23456    7  89  :      ;  <=>?@  AB        C              DEFGH    IJ  K          LM    NOPQ  RST  U  VW  X  YZ[\]^_`  ab  c    def  jgh  ik    l                m  nopq  r          s  t  vwx  yu  z  {  |  }(~        !"#$  %&'      )          *  +    ,  -./0123          45  67    89                                                                                                              :  ;<=    >  ?@  AB      C    DE  F      G                                  HI  JKL  M      N  O                P    QR        STUV  WXYZ[    \]    ^      _`abc      defg  hi    jkl  mn    o  pq  rs  tuv                                                                                                            w  xzy          z          {|}~      !"  #  $    %  &            '(    )*+,            -    ./0  1  23    4    56  789          :;  <=    >            ?  @  ABC    D      EF      G  HIJ            LM  K    NOPQ    R    ST      U                                                                                                                                        V  WXY  Z  [\]  ^  _  `ab  c  d  e          fghijk{  lm  n  opq  rs  tuv    wx  y  z{|}~!"  #$  %&'(  )  *      +  ,-.    /    01  2  345  6  789          :    ;<      =>?  @    A    B  C  DE  F  GHIJK    |LM  NOP          QR    STUV  WXY  Z[\]      ^    _`          abcd  efg      hi  jk  lmn        op      qr    st      u  v  w  x  yz      {|    }~!"    #  $%  &      '  ()*  +,-.  /    0123456    7    89:    ;    <  =>?@A      BCD  EF  GH  IPJKL    M      RNOQ    S  T  U    VW    X                                                                                                                                                                                                                  Y            Z  [  \                ^      ]        _      `a    bcd                  ef  ghi          jkm  nolp  q            rs            tvuw      xyz    {        |}    ~!  "        #$  %  &    '(    )*  +,-.              /            01  2  3  4    56    7  8  9  :;              <=>?  @      ABC        DE  F  G  HI  JK          L      N        O    M      P  QRS    TU    VWX                                                                                                                                                                                YZ[  \]^_`  a      bc    de    f  g        h  i  jklm    nop                q  r    s~  t      u      v  w      xyz{|}  ~!    "    #$      %        &'()*+,  -./      01      2      34    5  67  8    9  :;<=>  ?  @ABCD            EFGHI  J    KL    MN  OPQRST  U    V    W                                XYZ[  \]^        _  `ab  cE                                                                                                                                                                                                                                                                                                                                                                    r                                                                                                  478=DGHNOSUVWXZ[^`bceijkmopswxy}  *)                                                                                                                                    C            	 
                        ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~                                      Bp\ Cml    n4        1  k        D"!$*#)!.2143@?BA  PRQTXS,cbedr0N"!$*#)A.2143@?BACPRQTXSLcbedrPsEUC-JP-MS// outbufstart == ((void *)0)  ../iconv/skeleton.c (state->__count & 7) <= sizeof (state->__value) ../iconv/loop.c inptr - bytebuf > (state->__count & 7)  inend != &bytebuf[3]    inend - inptr > (state->__count & ~7)   inend - inptr <= sizeof (state->__value)    inend != &bytebuf[4]    outbuf == outerr    nstatus == __GCONV_FULL_OUTPUT  inend - *inptrp < 4 to_eucjp_ms_single  from_eucjp_ms_single    gconv                   
                                      	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         X                          0          p*     N          N          @ o8     |     \  
   P            P    (                 0     h         o  o   o  o                                            O                                                           HP A0   aeabi &   6 	
"EUC-JP-MS.so    ]. .shstrtab .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                                                  ,   o   8  8  $                6         \  \                 >         |  |  P                 F   o       $                S   o       @                b   	      0  0  h                k   	   B       (               t                               o             P                 z             T%                          p*  p*                             x*  x*                           @ @                   0         @ @ \                         N N                            N N                            N N                             O  O                           P  P H                          HP HP                            LP LP                        p        LP 1                                }P                                 P                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ELF          (    X  4   l  4    (                                8  <                                      D   D         Qtd                          Rtd                        GNU D\;cg,e7         GNU                                   c5R                           
            t              F           "                                                             U               ,                             {     %    i           __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses gconv_init strcmp gconv _dl_mcount_wrapper_check __pointer_chk_guard __assert_fail libc.so.6 ld-linux-armhf.so.3 GLIBC_PRIVATE GLIBC_2.4                                    c	                      ii                  8        $   (   ,   0 	  4 
                 @-  -  : : : : :0 0   R/ ,   @-808 0  00` S$00 0  S3/  X $   @-@ @0  00`4 C1 ?0    R2/X T  4   L @- D0  0  R4 0  S  
(0 0 0           4 @-  ,0  0  R  
 0  S   
3/@h P 0       /8@- @P P  P  p0 8 $ (0,000  4 8 r  P  0  8$0(000,  8 O-@|M ?<P$`  @04 H <P@`@(	  < Pp  R(p  
`/0 0p'(p  T @  Yp  0   ThP`0P0`  Wh0 H p.> 0H`i.Bi>C B0C8 04$p80  S/ 
@ppt	0 @   t  t0p p [A  
 [ : Z   Q  Q  TA  V@ @  @P@@    Pe  P  Ub  0P  U  
 @  Tx 
ptP  @  To 
    0 0P4  </ P
 P p 0 
 [t0@P    UM  P  U  
   P  
    @	0</P  U0 00[ 	 T  0xP( 0% P (P< @0</ P   
lP UP   \  p  p ph TE  
   Zg  ,A BT A"AB0t3b @ @1 t B0  t 0C 0t  0t TAL  \UACAA  \!  P   P/  
 PX    Q   
 Z-  t   0  St t 0t00  P0P  URP@Pp:A4eL  \eAWAA,L  \  8@AA   P  Q5
    Z P@PPA @ PfAA  Q  
   Q  
C   Q  
  Q  
  Q  
  Q  
AP22s:P Ue
  \c
`  Y  | [ 

 \P	@.  ) L )   D9	\ 0 0  P0T X,`   P 0P*  @} Q-    RG  
 ` D  
 0P0 0 [  
 Z*,`8  
`D
``aad`  P  :LL
  Q" @
  P  @ [,`   [! / Q$    R  
 `   
 00P 0 d 0 @	 P  R  
 `   ,` PP  U
  @|8 0`A	 V     [  ````F} V  R
  
 0`0 P 0`  ? Q  `aA  Q    R
  
 0`0P 0`~h \ D` )@   P    S  
   Ql|  P  @P@PV@R P pK  
`  V3 4@80  Sf 
H` \t pppW   \0  
0l`   0 S0l0 [8 :
 Yp  * Ll`0 0 [   p0 QS    Plp` Q  0t0 p  0 p  RJ  
 0 f Rq H a0 pp pt 0@  H@ p\`    P  S$  
  R=
  :
 0`0P 0` 00P 0 6 Q  
0 Q  
0 Q  

0 Q  
0 QS@Pq (PlPi<Pf,Pc  S  HP p` `V0 |  Q   X` ,`p t0 P   
0@ P p  PTP	@@TT  Q H  `h0p  0  Y @` 0V
 VTH 0 c RZ  [  H	       0   0 [0    ;@3 Q (3A0V.C0 A  A    $    QY    \V  0  \Q  
 @  TA  
 t pp  H 4  0p 0 </ P  @  Tp %  p  0 R Pa W 
H@  f   `   R    R   W  U`fm p RP  UJ  @ 0
0@ p  00 000; P"  
0 Z51r!LA2 Bs0  t#c A B t  0C000t0 @  t00t0t@  Q
   R   
 Zt     Rt0t  4@ p80  S 
 0 0i.B BPi>C, 0C tLP$	P	ppD0  0v  D (   ` \  D             `      8 u u   3    $      | h T @ ,  to        P  L  lR      (      d 4 ` X C8  d  h ,          h  0  ^  dg  ]  ]  NA  } } ~ } } |~   } d} \~   >  lB8} $} ~    ) A -$  a'   | { K=  C{ 0t0  tPp00pp0 [B  
0 [  :@ T     R1 R;  1 B0VC0 A  @A   $     Qd  @  Ta    Yt  
 @  T  
tPpp    04 P </ P  @  TpptPL Z  
 0p0 [pp 0
 $ Q  B$2A QU,BC B  8:B SQ  D@0  Q_  
 Q*  04,  @0 Tj  3r!Btq2 BC0  t CcAAt  0C000t0 @  t00Pt0x P  Q
   R   
@ T@  t     Rt0t  tPc
 $ l0 p UY   RO  	 U00C0:Bt3eA Qe,BW BB3,A Q   ,@:B0C0  Q0  Sb P pptP<
  $ pptP
 $ 
 $ <B0C Sf,B B3 R8  
0 R1  
C0 R*  
3 R#  
3 R  
3 R  
8BS*2/2n:.LLL5  T%0\\\5  ..0p50|50|50x50t50p50l [p 
@P TLP	P5  :%5   0P TX \00 $0,@  ` d D  \0   L} PJ    RA  
 ?  
 0@  [1  
 YL*
 ,D$0 $@0 @?  \   P0P0PPPPPP P0  (  `p P`@p< @0(8/|
 ,$0D 
 ,$0D    [h   / P[  0@	 X   [_  $H} X0    R
 
 0 @? PD  a@ x P>  
P)L  \    Q  
 Pg  
 Pb  
 Pc  
 PZ  

 PJ  
 P$  0 LP{0H	 \  
 $ `  \)  *d   \"    Q*  
  R
 
 0 @[  R
 
 0 @Q
 ,$0D W@	   P L0   P     P    `    P 	9  .0H [ 	  0 p0 S0 S 0*@
@@:  b/0H` \ ```H    \	  
0t@@ @  0 S   Z$ :t@ L0 @` [    V    Pt@  T   0D} St  0@  T
 ` 
  u0     p0g S H@0a0  0p  ppp;  -0g;  b/0_,A; B RU,AC B;*A R  iAA0  Q,  
 Q04,  w;  w/0=<  +05:+A <e B Re,AW B`,A8<, B R  D,A i.BA B0  Q0  Sxxx<  @,0u0 Qu  u0/ SJ  0 C	 P$  w  Ql  v @} Q  0@  T.
 ` +
 0   yu0  $uw0 A	 R8  0p  W
  
  x0   f? Sz a<C4X- S  
`-  ).B   Rk   Ti 
- Se 
- S_ 
  Sp 
  Sj 

  Sm 
  S  
0p  W
  
  v0   8
-43c01 RL  *> 0   R,    T)  
0@  T
 ` 
  x0   x  Q&  
`0fpHl
 S    S"  
 Q  C 0 S@
@0@ x0>  w/0p>  .0h?  /0`?/0 S(   / (((?  -0P<A0C Sf,A B|T? Q8  
0 Q1  
C0 Q6  
t? Q'  
|? Q  
? Q  
8AS*2/2e:?/0 S  ?/0 0 |?0y?0u?/0 S  / ?0i30e30a30]3#0 S  3#0 0 Pt#v0Rddd3  \#0TTT3  L#0  Q  T` 	P )   P  \     Q
       P  P Q  P`   P P  x  X i	F`@ P
  T  iH@L  \  4,,  Q   L`      PT   ] Q  Q*    PN*n!v0s!v0p0@  T
 ` 
  v0   d!v0b\!v0_T!v0\ 1 !0 S  00P S  0!0 0 i)A0-B R  0 0 S  0 0 0 00 S  00S}*x  { { { 7  #  A t| T{ |   { 4{ | /  C8    y  lR__       ) $     @-                                                                                                             	
 !"#$%&'()*,-./0123456789:;<=>?@ABCEFGIJKLNOPQRSTUVWXYZ[\]^_`abcdefghijlmnopqrstuvwxyz{|}~ 	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPRSTUVWXYZ[\]^_`bcdefghijklmnopqrstuvwxyz{|}~ 	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	
P@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~          	 
               ! " # $ ' ( ) * + , - . / 1 4 6 7 8 9 : < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~                                                                                                                                  !!!!!!!
!!!!!!!!!!!!!!!!!!!!! !"!#!$!%!&!'!(!)!*!+!,!-!.!/!0!1!2!3!4!5!6!7!8!9!:!;!<!=!>!?!@!A!B!C!D!E!F!G!H!I!J!K!L!M!N!O!P!Q!R!S!T!U!V!W!X!Y!Z![!\!]!^!_!l!m!n!o!z!{!|!}!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! """"""""	"
"""""""""""""""!"""$"&","-"/"0"1"2"3"8"9":";"<">"?"@"A"B"C"D"E"F"G"I"J"K"M"N"O"P"Q"S"T"U"V"W"X"Y"Z"["\"]"^"_"b"c"h"i"j"k"l"m"p"q"r"s"t"u"v"w"x"y"z"{"|"}"~"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" #########	#
##################### #!#"###$#%#&#'#(#)#*#+#,#-#.#/#0#1#2#3#4#5#6#7#8#9#:#;#<#=#>#?#@#A#B#C#D#E#F#G#H#I#J#K#L#M#N#O#P#Q#R#S#T#U#V#W#X#Y#Z#[#\#]#^#_#`#a#b#c#d#e#f#g#h#i#j#k#l#m#n#o#p#q#r#s#t#u#v#w#x#y#z#{#|#}#~################################################################################################################################## $$$$$$$$$	$
$$$$$$$$$$$$$$$$$$$$$$ $!$"$#$$$%$&$'$($)$*$+$,$-$.$/$0$1$2$3$4$5$6$7$8$9$:$;$<$=$>$?$@$A$B$C$D$E$F$G$H$I$J$K$L$M$N$O$P$Q$R$S$T$U$V$W$X$Y$Z$[$\$]$^$_$j$k$l$m$n$o$p$q$r$s$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$L%M%N%O%t%u%v%w%x%y%z%{%|%}%~%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% &&&&&&&
&&&&&&&&&&&&&&&&&&&&&& &!&"&#&$&%&&&'&(&)&*&+&,&-&.&/&0&1&2&3&4&5&6&7&8&9&:&;&<&=&>&?&A&................................................................................................................. /////////	/
////////////////////// /!/"/#/$/%/&/'/(/)/*/+/,/-/.///0/1/2/3/4/5/6/7/8/9/:/;/</=/>/?/@/A/B/C/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z/[/\/]/^/_/`/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/{/|/}/~//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////0000000 0*0+0,0-0.0/000102030405060708090:0;0<0=0?0@0000000000000000 11111*1+1,1-1.1/101112131415161718191:1;1<1=1>1?1@1A1B1C1D1E1F1G1H1I1J1K1L1M1N1O1P1Q1R1S1T1U1V1W1X1Y1Z1[1\1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z1{1|1}1~1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 222222222	2
2222222222222222222222*2+2,2-2.2/2022232425262728292:2;2<2=2>2?2@2A2B2C2D2E2F2G2H2I2J2K2L2M2N2O2P2Q2R2S2T2U2V2W2X2Y2Z2[2\2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2q2r2s2t2u2v2w2x2y2z2{2|2}2~222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222 333333333	3
3333333333333333333333 3!3"3#3$3%3&3'3(3)3*3+3,3-3.3/303132333435363738393:3;3<3=3>3?3@3A3B3C3D3E3F3G3H3I3J3K3L3M3N3O3P3Q3R3S3T3U3V3W3X3Y3Z3[3\3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}3~33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 444444444	4
4444444444444444444444 4!4"4#4$4%4&4'4(4)4*4+4,4-4.4/404142434445464748494:4;4<4=4>4?4@4A4B4C4D4E4F4H4I4J4K4L4M4N4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4\4]4^4_4`4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4t4u4v4w4x4y4z4{4|4}4~4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444 555555555	5
5555555555555555555555 5!5"5#5$5%5&5'5(5)5*5+5,5-5.5/505152535455565758595:5;5<5=5>5?5@5A5B5C5D5E5F5G5H5I5J5K5L5M5N5O5P5Q5R5S5T5U5V5W5X5Y5Z5[5\5]5^5_5`5a5b5c5d5e5f5g5h5i5j5k5l5m5n5o5p5q5r5s5t5u5v5w5x5y5z5{5|5}5~555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555 666666666	6
66666666666666666666 6!6"6#6$6%6&6'6(6)6*6+6,6-6.6/606162636465666768696:6;6<6=6>6?6@6A6B6C6D6E6F6G6H6I6J6K6L6M6N6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6\6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6w6x6y6z6{6|6}6~6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666 777777777	7
7777777777777777777777 7!7"7#7$7%7&7'7(7)7*7+7,7-7.7/707172737475767778797:7;7<7=7>7?7@7A7B7C7D7E7F7G7H7I7J7K7L7M7N7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7\7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}7~7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777 888888888	8
8888888888888888888888 8!8"8#8$8%8&8'8(8)8*8+8,8-8.8/808182838485868788898:8;8<8=8>8?8@8A8B8C8D8E8F8G8H8I8J8K8L8M8N8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8\8]8^8_8`8a8b8c8d8e8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}8~8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888 999999999	9
999999999999999999999 9!9"9#9$9%9&9'9(9)9*9+9,9-9.9/909192939495969798999:9;9<9=9>9?9@9A9B9C9D9E9F9G9H9I9J9K9L9M9N9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9\9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}9~9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 :::::::::	:
:::::::::::::::::::::: :!:":#:$:%:&:':(:):*:+:,:-:.:/:0:1:2:3:4:5:6:7:8:9:::;:<:=:>:?:@:A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:\:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:t:u:v:w:x:y:z:{:|:}:~:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ;;;;;;;;;	;
;;;;;;;;;;;;;;;;;;;;;; ;!;";#;$;%;&;';(;);*;+;,;-;.;/;0;1;2;3;4;5;6;7;8;9;:;;;<;=;>;?;@;A;B;C;D;E;F;G;H;I;J;K;L;M;O;P;Q;R;S;T;U;V;W;X;Y;Z;[;\;];^;_;`;a;b;c;d;e;f;g;h;i;j;k;l;m;n;o;p;q;r;s;t;u;v;w;x;y;z;{;|;};~;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; <<<<<<<<<	<
<<<<<<<<<<<<<<<<<<<<<< <!<"<#<$<%<&<'<(<)<*<+<,<-<.</<0<1<2<3<4<5<6<7<8<9<:<;<<<=<><?<@<A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z<[<\<]<^<_<`<a<b<c<d<e<f<g<h<i<j<k<l<m<o<p<q<r<s<t<u<v<w<x<y<z<{<|<}<~<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< =========	=
====================== =!="=#=$=%=&='=(=)=*=+=,=-=.=/=0=1=2=3=4=5=6=7=8=9=:=;=<===>=?=@=A=B=C=D=E=F=G=H=I=J=K=L=M=N=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=\=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=r=s=t=u=v=w=x=y=z={=|=}=~================================================================================================================================== >>>>>>>>>	>
>>>>>>>>>>>>>>>>>>>>>> >!>">#>$>%>&>'>(>)>*>+>,>->.>/>0>1>2>3>4>5>6>7>8>9>:>;><>=>>>?>@>A>B>C>D>E>F>G>H>I>J>K>L>M>N>O>P>Q>R>S>T>U>V>W>X>Y>Z>[>\>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}>~>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ?????????	?
?????????????????????? ?!?"?#?$?%?&?'?(?)?*?+?,?-?.?/?0?1?2?3?4?5?6?7?8?9?:?;?<?=?>???@?A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?\?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}?~?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? @@@@@@@@@	@
@@@@@@@@@@@@@@@@@@@@@@ @!@"@#@$@%@&@'@(@)@*@+@,@-@.@/@0@1@2@3@4@5@6@7@8@9@:@;@<@=@>@?@@@A@B@C@D@E@F@G@H@I@J@K@L@M@N@O@P@Q@R@S@T@U@W@X@Y@Z@[@\@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}@~@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ AAAAAAAAA	A
AAAAAAAAAAAAAAAAAAAAAA A!A"A#A$A%A&A'A(A)A*A+A,A-A.A/A0A1A2A3A4A5A6A7A8A9A:A;A<A=A>A?A@AAABACADAEAFAGAHAIAJAKALAMANAOAPAQARASATAUAVAWAXAYAZA[A\A]A^A`AaAbAcAdAeAfAgAhAiAjAkAlAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}A~AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA BBBBBBBBB	B
BBBBBBBBBBBBBBBBBBBBBB B!B"B#B$B%B&B'B(B)B*B+B,B-B.B/B0B1B2B3B4B5B6B7B8B9B:B;B<B=B>B?B@BABBBCBDBEBFBGBHBIBJBKBLBMBNBOBPBQBRBSBTBUBVBWBXBYBZB[B\B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}B~BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB CCCCCCCCC	C
CCCCCCCCCCCCCCCCCCCCCC C!C"C#C$C%C&C'C(C)C*C+C,C-C.C/C0C1C2C3C4C5C6C8C9C:C;C<C=C>C?C@CACBCCCDCECFCGCHCICJCKCLCMCNCOCPCQCRCSCTCUCVCWCXCYCZC[C\C]C^C_C`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}C~CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC DDDDDDDDD	D
DDDDDDDDDDDDDDDDDDDDDD D!D"D#D$D%D&D'D(D)D*D+D,D-D.D/D0D1D2D3D4D5D6D7D8D9D:D;D<D=D>D?D@DADBDCDDDEDFDGDHDIDJDKDLDMDNDODPDQDRDSDTDUDVDWDXDYDZD[D\D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}D~DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD EEEEEEEEE	E
EEEEEEEEEEEEEEEEEEEEEE E!E"E#E$E%E&E'E(E)E*E+E,E-E.E/E0E1E2E3E4E5E6E7E8E9E:E;E<E=E>E?E@EAEBECEDEEEFEGEHEIEJEKELEMENEOEPEQERESETEUEVEWEXEYEZE[E\E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}E~EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE FFFFFFFFF	F
FFFFFFFFFFFFFFFFFFFFFF F!F"F#F$F%F&F'F(F)F*F+F,F-F.F/F0F1F2F3F4F5F6F7F8F9F:F;F<F=F>F?F@FAFBFCFDFEFFFGFHFIFJFKFMFNFOFPFQFRFSFTFUFVFWFXFYFZF[F\F]F^F_F`FbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}F~FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF GGGGGGGGG	G
GGGGGGGGGGGGGGGGGGGGGG G!G"G$G%G&G'G(G*G+G,G-G.G/G0G1G2G3G4G5G6G7G8G9G:G;G<G=G>G?G@GAGBGCGDGEGFGGGHGIGJGKGLGMGNGOGPGQGRGSGTGUGVGWGXGYGZG[G\G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G}G~GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG HHHHHHHHH	H
HHHHHHHHHHHHHHHHHHHHHH H!H"H#H$H%H&H'H(H)H*H+H,H-H.H/H0H1H2H3H4H5H6H7H8H9H:H;H<H=H>H?H@HAHBHCHDHEHFHGHHHIHJHKHLHMHNHOHPHQHRHSHTHUHVHWHXHYHZH[H\H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}H~HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH IIIIIIIII	I
IIIIIIIIIIIIIIIIIIIIII I!I"I#I$I%I&I'I(I)I*I+I,I-I.I/I0I1I2I3I4I5I6I7I8I9I:I;I<I=I>I?I@IAIBICIDIEIFIHIIIJIKILIMINIOIPIQIRISITIUIVIWIXIYIZI[I\I]I^I_I`IaIbIcIdIeIfIgIhIiIjIkIlImInIoIpIqIrIsItIuIvIwIxIyI{I|I~IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII JJJJJJJJJ	J
JJJJJJJJJJJJJJJJJJJJJJ J!J"J#J$J%J&J'J(J)J*J+J,J-J.J/J0J1J2J3J4J5J6J7J8J9J:J;J<J=J>J?J@JAJBJCJDJEJFJGJHJIJJJKJLJMJNJOJPJQJRJSJTJUJVJWJXJYJZJ[J\J]J^J_J`JaJbJcJdJeJfJgJhJiJjJkJlJmJnJoJpJqJrJsJtJuJvJwJxJyJzJ{J|J}J~JJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ KKKKKKKKK	K
KKKKKKKKKKKKKKKKKKKKKK K!K"K#K$K%K&K'K(K)K*K+K,K-K.K/K0K1K2K3K4K5K6K7K8K9K:K;K<K=K>K?K@KAKBKCKDKEKFKGKHKIKJKKKLKMKNKOKPKQKRKSKTKUKVKWKXKYKZK[K\K]K^K_K`KaKbKcKdKeKfKgKhKiKjKkKlKmKnKoKpKqKrKsKtKuKvKwKxKyKzK{K|K}K~KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK LLLLLLLLL	L
LLLLLLLLLLLLLLLLLLLLLL L!L"L#L$L%L&L'L(L)L*L+L,L-L.L/L0L1L2L3L4L5L6L7L8L9L:L;L<L=L>L?L@LALBLCLDLELFLGLHLILJLKLLLMLNLOLPLQLRLSLTLULVLWLXLYLZL[L\L]L^L_L`LaLbLcLdLeLfLgLhLiLjLkLlLmLnLoLpLqLrLsLtLuLvLxLyLzL{L|L}L~LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL MMMMMMMMM	M
MMMMMMMMMMMMMMM M!M"M#M$M%M&M'M(M)M*M+M,M-M.M/M0M1M2M3M4M5M6M7M8M9M:M;M<M=M>M?M@MAMBMCMDMEMFMGMHMIMJMKMLMMMNMOMPMQMRMSMTMUMVMWMXMYMZM[M\M]M^M_M`MaMbMcMdMeMfMgMhMiMjMkMlMmMnMoMpMqMrMsMtMuMvMwMxMyMzM{M|M}M~MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM                l !"#$%'()*-./03456789:<=>?@ABDEFGHIJKLMNOPQRSVWXYZ[\]^_`abc-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxz{|}~ 	
"%&*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	
                     !"#$%&'()*+,-./2EFGHSXglmnopqrstuvwxyz{|}~ _`abcdefghijklmnopqrstuvwxyz{|}~NNNNNNNN N!N#N&N)N.N/N1N3N5N7N<N@NANBNDNFNJNQNUNWNZN[NbNcNdNeNgNhNjNkNlNmNnNoNrNtNuNvNwNxNyNzN{N|N}NNNNNNNNNN  NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN OOOOOOOOOOOOOOOOO!O#O(O)O,O-O.O1O3O5O7O9O;O>O?O@OAOBODOEOGOHOIOJOKOLOROTOVOaObOfOhOjOkOmOnOqOrOuOwOxOyOzO}OOOOOOOOOOOOOOOOOOOOOOO  OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO PPPPPPPPP	P
P  PPPPPPPPPPP P"P#P$P'P+P/P0P1P2P3P4P5P6P7P8P9P;P=P?P@PAPBPDPEPFPIPJPKPMPPPQPRPSPTPVPWPXPYP[P]P^P_P`PaPbPcPdPfPgPhPiPjPkPmPnPoPpPqPrPsPtPuPxPyPzP|P}PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP  PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP QQQQQQQ  	Q
QQQQQQQQQQQQQQQQQQQQ Q"Q#Q$Q%Q&Q'Q(Q)Q*Q+Q,Q-Q.Q/Q0Q1Q2Q3Q4Q5Q6Q7Q8Q9Q:Q;Q<Q=Q>QBQGQJQLQNQOQPQRQSQWQXQYQ[Q]Q^Q_Q`QaQcQdQfQgQiQjQoQrQzQ~QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ  QQQQQQQQQQQQQQQQQQQQQRR	RRRRRRRRRRR!R"R#R%R&R'R*R,R/R1R2R4R5R<R>RDRERFRGRHRIRKRNRORRRSRURWRXR  YRZR[R]R_R`RbRcRdRfRhRkRlRmRnRpRqRsRtRuRvRwRxRyRzR{R|R~RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRSSSSS	S
SSSS  SSSSSSSSS"S$S%S'S(S)S+S,S-S/S0S1S2S3S4S5S6S7S8S<S=S@SBSDSFSKSLSMSPSTSXSYS[S]SeShSjSlSmSrSvSyS{S|S}S~SSSSSSSSS  SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS TTTTTTTTTT"T$T%T*T0T3T6T7T:T=T?TATBTDTETGTITLTMTNTOTQTZT]T^T_T`TaTcTeTgTiTjTkTlTmTnToTpTtTyTzT~TTTTTTTTTTTTTTTTTTT  TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT UUUUUU
UUUUUUUUUUUUUUUUU!U%U&U  (U)U+U-U2U4U5U6U8U9U:U;U=U@UBUEUGUHUKULUMUNUOUQURUSUTUWUXUYUZU[U]U^U_U`UbUcUhUiUkUoUpUqUrUsUtUyUzU}UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVV  VV
VVVVVVVVVVVVVVV V!V"V%V&V(V)V*V+V.V/V0V3V5V7V8V:V<V=V>V@VAVBVCVDVEVFVGVHVIVJVKVOVPVQVRVSVUVVVZV[V]V^V_V`VaV  cVeVfVgVmVnVoVpVrVsVtVuVwVxVyVzV}V~VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV WWWWWWWWWWWW  WWWWWWWWWWWW W!W"W$W%W&W'W+W1W2W4W5W6W7W8W<W=W?WAWCWDWEWFWHWIWKWRWSWTWUWVWXWYWbWcWeWgWlWnWpWqWrWtWuWxWyWzW}W~WWW  WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXXXXX	X
XXXXXXXXXXXXXXXX"X#X%X&X'X(X)X+X,X-X.X/X1X2X3X4X6X7X8X9X:X;X<X=X  >X?X@XAXBXCXEXFXGXHXIXJXKXNXOXPXRXSXUXVXWXYXZX[X\X]X_X`XaXbXcXdXfXgXhXiXjXmXnXoXpXqXrXsXtXuXvXwXxXyXzX{X|X}XXXXXXXXXX  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX YYYYYY	Y
YYYYYYYYYYYYY Y!Y"Y#Y&Y(Y,Y0Y2Y3Y5Y6Y;Y  =Y>Y?Y@YCYEYFYJYLYMYPYRYSYYY[Y\Y]Y^Y_YaYcYdYfYgYhYiYjYkYlYmYnYoYpYqYrYuYwYzY{Y|Y~YYYYYYYYYYYYYYYYYYYYYYY  YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY ZZ
ZZZZZZZZZZZZZZZZ!Z"Z$Z&Z'Z(Z*Z+Z,Z-Z.Z/Z0Z3Z5Z7Z8Z9Z:Z;Z=Z>Z?ZAZBZCZDZEZGZHZKZLZMZNZOZPZQZRZSZTZVZWZXZYZ[Z\Z]Z^Z_Z`Z  aZcZdZeZfZhZiZkZlZmZnZoZpZqZrZsZxZyZ{Z|Z}Z~ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ  ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ [[[[[[[[[
[[[[[[[[[[[[[[[[[[[[ [!["[#[$[%[&['[([)[*[+[,[-[.[/[0[1[3[5[6[8[9[:[;[<[=[>[?[A[B[C[D[E[F[G[  H[I[J[K[L[M[N[O[R[V[^[`[a[g[h[k[m[n[o[r[t[v[w[x[y[{[|[~[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[  [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ \\\\\\\\\\\\\\\\\\ \!\#\&\(\)\*\+\-\.\/\0\2\3\5\6\7\C\D\F\G\L\M\R\S\T\V\W\X\Z\[\\\]\_\b\d\g\h\i\j\k\l\m\p\r\s\t\u\v\w\x\{\|\}\~\\\\\\\\\\\\\\\\\\\\\\\\\  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ ]  ]]]]	]
]]]]]]]]]]]]]]]]] ]!]"]#]%](]*]+],]/]0]1]2]3]5]6]7]8]9]:];]<]?]@]A]B]C]D]E]F]H]I]M]N]O]P]Q]R]S]T]U]V]W]Y]Z]\]^]_]`]a]b]c]d]e]f]g]h]j]m]n]p]q]r]s]u]v]w]x]y]z]{]|]}]~]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]  ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]  ]]]]]]]]] ^^^	^
^^^^^^^^^ ^!^"^#^$^%^(^)^*^+^,^/^0^2^3^4^5^6^9^:^>^?^@^A^C^F^G^H^I^J^K^M^N^O^P^Q^R^S^V^W^X^Y^Z^\^]^_^`^c^d^e^f^g^h^i^j^k^l^m^n^o^p^q^u^w^y^~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^___	_____________!_"_#_$_  (_+_,_._0_2_3_4_5_6_7_8_;_=_>_?_A_B_C_D_E_F_G_H_I_J_K_L_M_N_O_Q_T_Y_Z_[_\_^___`_c_e_g_h_k_n_o_r_t_u_v_x_z_}_~________________________________________________________________________`  `	```````````"`#`$`,`-`.`0`1`2`3`4`6`7`8`9`:`=`>`@`D`E`F`G`H`I`J`L`N`O`Q`S`T`V`W`X`[`\`^`_```a`e`f`n`q`r`t`u`w`~``  ``````````````````````````````````````````````````````````````````````````aaaaa
aaaaaaaaaaaaaaaa!a"a%a(a)a*a,a-a.a/a0a1a2a3a4a5a6a7a8a9a:a;a<a=a>a@aAaBaCaDaEaFa  GaIaKaMaOaPaRaSaTaVaWaXaYaZa[a\a^a_a`aaacadaeafaiajakalamanaoaqarasatavaxayaza{a|a}a~aaaaaaaaaaaaaaaaaaaaa  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbb	bbbbbbb b#b&b'b(b)b+b-b/b0b1b2b5b6b8b9b:b;b<bBbDbEbFbJb  ObPbUbVbWbYbZb\b]b^b_b`babbbdbebhbqbrbtbubwbxbzb{b}bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb  bbbbbbbbbbbbbbbbbbb ccccc
cccccccccccccc&c'c)c,c-c.c0c1c3c4c5c6c7c8c;c<c>c?c@cAcDcGcHcJcQcRcScTcVcWcXcYcZc[c\c]c`cdcecfchcjckclcocpcrcsctcucxcyc|c}c~ccccccccccccccccccccccccccccccccccc  cccccccccccccccccccccccccccccccccccccccccddddd	d
ddddddddddddd"d#d$d  %d'd(d)d+d.d/d0d1d2d3d5d6d7d8d9d;d<d>d@dBdCdIdKdLdMdNdOdPdQdSdUdVdWdYdZd[d\d]d_d`dadbdcdddedfdhdjdkdldndodpdqdrdsdtdudvdwd{d|d}d~ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd  dddddddddddddddddddddddddddddddddeeeeeeee
eeeeeeeeeeeeeeeeeeee e!e  "e#e$e&e'e(e)e*e,e-e0e1e2e3e7e:e<e=e@eAeBeCeDeFeGeJeKeMeNePeReSeTeWeXeZe\e_e`eaedeeegeheiejemeneoeqeseuevexeyeze{e|e}e~eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee  eeeeeeeeeeefffff	fffffffffffff!f"f#f$f&f)f*f+f,f.f0f2f3f7f8f9f:f;f=f?f@fBfDfEfFfGfHfIfJfMfNfPfQfXf  Yf[f\f]f^f`fbfcfefgfifjfkflfmfqfrfsfufxfyf{f|f}fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggg  gggggggggggggggg g!g"g#g$g%g'g)g.g0g2g3g6g7g8g9g;g<g>g?gAgDgEgGgJgKgMgRgTgUgWgXgYgZg[g]gbgcgdgfgggkglgngqgtgvg  xgygzg{g}gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggghhhhhhhhhhhhhhhhh h"h#h$h%h&h'h(h+h,h-h.h/h0h1h4h5h6h:h;h?hGhKhMhOhRhVhWhXhYhZh[h  \h]h^h_hjhlhmhnhohphqhrhshuhxhyhzh{h|h}h~hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh  hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiii	i
iiiiiiiiiiiiiiii!i"i#i%i&i'i(i)i*i+i,i.i/i1i2i3i5i6i7i8i:i;i<i>i@iAiCiDiEiFiGiHiIiJiKiLiMiNiOiPiQiRiSiUiViXiYi[i\i_i  aibidieigihiiijilimioipirisitiuivizi{i}i~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii  iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii jjjjjjjjj	jjjjjjjjjjjjjjjjjjj j"j#j$j%j&j'j)j+j,j-j.j0j2j3j4j6j7j8j9j:j;j<j?j@jAjBjCjEjFjHjIjJjKjLjMjNjOjQjRjSjTjUjVjWjZj  \j]j^j_j`jbjcjdjfjgjhjijjjkjljmjnjojpjrjsjtjujvjwjxjzj{j}j~jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj  jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj kkkkkkkkk	k
kkkkkkkkkkkkkkkkkkkkkk%k&k(k)k*k+k,k-k.k  /k0k1k3k4k5k6k8k;k<k=k?k@kAkBkDkEkHkJkKkMkNkOkPkQkRkSkTkUkVkWkXkZk[k\k]k^k_k`kakhkikkklkmknkokpkqkrksktkukvkwkxkzk}k~kkkkk  kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk llllll	l
lllllllll l#l%l+l,l-l1l3l6l7l9l:l;l<l>l?lClDlElHlKlLlMlNlOlQlRlSlVlXl  YlZlblclelflglklllmlnlolqlslulwlxlzl{l|llllllllllllllllllllllllllllllllllllllllllll  lllllllllllllll mmmmmm	m
mmmmmmmmmmmmm m!m"m#m$m&m(m)m,m-m/m0m4m6m7m8m:m?m@mBmDmImLmPmUmVmWmXm[m]m_mambmdmemgmhmkmlmmmpmqmrmsmumvmymzm{m}m~mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm  mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm nnnnnnnn	nnnnnnnnnnnn"n&n'n(n*n,n.n0n1n3n5n  6n7n9n;n<n=n>n?n@nAnBnEnFnGnHnInJnKnLnOnPnQnRnUnWnYnZn\n]n^n`nanbncndnenfngnhninjnlnmnonpnqnrnsntnunvnwnxnynzn{n|n}nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn  nnnnnnnnnnnnnn ooooooo
oooooooooooooooooo!o"o#o%o&o'o(o,o.o0o2o4o5o7o8o9o:o;o<o=o?o@oAoBo  CoDoEoHoIoJoLoNoOoPoQoRoSoToUoVoWoYoZo[o]o_o`oaocodoeogohoiojokolooopoqosouovowoyo{o}o~oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo  oooooooooooooooooooooooo ppppppppp	p
ppppppppppppppppppp p!p"p$p%p&p'p(p)p*p  +p,p-p.p/p0p1p2p3p4p6p7p8p:p;p<p=p>p?p@pApBpCpDpEpFpGpHpIpJpKpMpNpPpQpRpSpTpUpVpWpXpYpZp[p\p]p_p`papbpcpdpepfpgphpipjpnpqprpsptpwpypzp{p}ppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp  ppppppppppppppppppppppp qqqqqqqqqqqqqqqqqqqqqqq q!q"q#q$q%q'q(q)q*q+q,q-q.q2q3q4q  5q7q8q9q:q;q<q=q>q?q@qAqBqCqDqFqGqHqIqKqMqOqPqQqRqSqTqUqVqWqXqYqZq[q]q_q`qaqbqcqeqiqjqkqlqmqoqpqqqtquqvqwqyq{q|q~qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq  qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq rrrrrrrr	r
rrrrrrrrrrrrrrrrr  rrrr r!r"r#r$r%r&r'r)r+r-r.r/r2r3r4r:r<r>r@rArBrCrDrErFrIrJrKrNrOrPrQrSrTrUrWrXrZr\r^r`rcrdrerhrjrkrlrmrprqrsrtrvrwrxr{r|r}rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr     	
 !"#$% 000  00 ^ &     000	0
0000000000   6"'"("""*")""7"""%" "#"+"."a"L"H"=""`"n"o"d"e""5"4"B&@& 2 3 ! 0  !&&%%%%%%%%%; !!!!0  &'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcd  efghijklmnopqrstuvwxyz{|}~p!q!r!s!t!u!v!w!x!y!fghijk$$$$$$$$$$$$$$$$$$$$t$u$v$w$x$y$z${$|$}$~$$$$$$$$$$`$a$b$c$d$e$f$g$h$i$ m 2!2"2#2$2%2&2'2(2)2no`!a!b!c!d!e!f!g!h!i!j!k!pq    	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]   	
 !"#$  %&'()*+,-./0123456789:;<=>?@ABCDEA0B0C0D0E0F0G0H0I0J0K0L0M0N0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0\0]0^0_0`0a0b0c0d0e0f0g0h0i0j0k0l0m0n0o0p0q0r0s0t0u0v0w0x0y0z0{0|0}0~0000000000000000000000rstuvwxyz{|  FGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000}~     569:?@=>ABCD;<78134  	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCD  EFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcde !"#$%&'()*+,-./012345Q6789:;<=>?@ABCDEFGHIJKLMNO    % 5 !	!!!!!""#"R"f"g""P%Q%R%S%T%U%V%W%X%Y%Z%[%\%]%^%_%`%a%b%c%d%e%f%g%h%i%j%k%l%m%n%o%p%q%r%s%%%%%%%%  %%%%%%%%%%%%%%%%%	&"000    +  M  k    Q?DHa1111	1
1111111111111111111111 1!1"1#1$1%1&1'1(1)1  !0"0#0$0%0&0'0(0)02333333333330!!12 00000000IJKLMNOPQRTUVWYZ[\]^_`a  bcdefhijk>0////////////0  %%%%%%%%%	%
%%%%%%%%%%%%%%%%%%%%%% %!%"%#%$%%%&%'%(%)%*%+%,%-%.%/%0%1%2%3%4%5%6%7%8%9%:%;%<%=%>%?%@%A%B%C%D%E%F%G%H%I%J%K%	
  rrrrrrrrrrrrrrrrr sssssss	sssssssssssss s#s$s&s's(s-s/s0s2s3s5s6s:s;s<s=s@sAsBsCsDsEsFsGsHs  IsJsKsLsNsOsQsSsTsUsVsXsYsZs[s\s]s^s_sasbscsdsesfsgshsisjsksnspsqs 	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]  rssstsusvswsxsyszs{s|s}ssssssssssssssssssssssssssssssssssssssssssssssssssss  sssssssssssssssssssssssssssssssss^_`abcdefghijklmnopqrstuvwxyz{|}~  ssssssss ttttttttttttttttttttttt t!t#t$t't)t+t-t/t1t2t7t8t9t:t;t=t>t?t@tBtCtDtEtFtGtHtItJtKtLtMt  NtOtPtQtRtStTtVtXt]t`tatbtctdtetftgthtitjtktltntotqtrtstttutxtytzt 	
  {t|t}ttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt  ttttttttttttttttttttttttttttttttt !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvw  ttttttttt uuuuuuuu	u
uuuuuuuuuuuuu u!u"u#u$u&u'u*u.u4u6u9u<u=u?uAuBuCuDuFuGuIuJuMuPuQuRuSuUuVuWuXu  ]u^u_u`uaubucuduguhuiukulumunuoupuqusuuuvuwuzu{u|u}u~uuuuuuuxyz{|}~  uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuvvvv  v	vvvvvvvvvvvvvv!v#v'v(v,v.v/v1v2v6v7v9v:v;v=vAvBvDv 	
 !"#$%&'()*+,-./0123  EvFvGvHvIvJvKvNvOvPvQvRvSvUvWvXvYvZv[v]v_v`vavbvdvevfvgvhvivjvlvmvnvpvqvrvsvtvuvvvwvyvzv|vvvvvvvvvvvvvvvvvvv  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvJU?W(cT	UTvLv<w~x1r(l[O	cf\HhfvQVeqPeYaoLcRbS'T{kQu]bvb]W8b8r}vg~vFdpO%bzes,dsb,gHrnbb4OtJSR~.^hi~hxQP$SeR  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv wwwww
wwwwwwwwwwwwwwwww!w#w$w%w'w*w+w  ,w.w0w1w2w3w4w9w;w=w>w?wBwDwEwFwHwIwJwKwLwMwNwOwRwSwTwUwVwWwXwYw\wO!Xq[bbfyrogx`QSSPrY`qTY,g({)]~-ulf<;k{|_x=kkk^^u]e
__X[,AbOS^SMhj_ha+R*vl_eon[HduQQgNy|p  ]w^w_w`wdwgwiwjwmwnwowpwqwrwswtwuwvwwwxwzw{w|wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww  wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwuv^sdblZSRd{/O^6$nlsUc\STeWN^ek?|`dsPgMb"lw)i_!Sk``p1Nld|ifISV{OQKmB\mcS,6gx=d[\]bgz dcI Nfs  wwwwwwwwwwwwwwxxxxxx
xxxxxxxxxx x!x"x$x(x*x+x.x/x1x2x3x5x6x=x?xAxBxCxDxFxHxIxJxKxMxOxQxSxTxXxYxZx  [x\x^x_x`xaxbxcxdxexfxgxhxixoxpxqxrxsxtxuxvxxxyxzx{x}x~xxxxxx:W\8^PS^eEu1U!Pbg2Vno]5Tpfobdc{_o\hf_lHldyWYjbHTXNz`obyTucS`l_p;O:\depEQQk][bltu zay{N~wNRQqjSndZi  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  xxxxxxxxxxxxxxxxxxxxxx yyyyyyy	y
yyy@xPwdYc]z=i O9U2Nuzb^^R9Tpvc$W%f?iUm~"3b~u(xHatdk:RP!kjqVSNNQ||O{zgd]Pv|mQgX[[xddc+c-dT{)vSb'YFTykP4b&^kN7_.  yyyyyyyyyyyyyyyyy y!y"y#y%y&y'y(y)y*y+y,y-y.y/y0y1y2y3y5y6y7y8y9y=y?yByCyDyEyGyJyKyLyMyNyOyPyQyRyTyUyXyYyaycy  dyfyiyjykylynypyqyrysytyuyvyyy{y|y}y~yyyyyyyyyyyyyyy `=b9NUSce.lFO`m9_S_!cZQach RccHP\wy[0R;z`Sv__vlop{vI{wQ$XNOnLe{rmZb^0W,{^_cnxpxQ[W5uCO8u^``YmkxSQRc
T9rxvS  yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy  yyyyyyyyyyyyyyzzzzz	z
zzzzzzzzzzzzzNvSv-["NNQcaRhOk`Qm\QbeaFucwkrr5XywL\g@^!nYzw;keXQQ[X(TrfeVvAcTY:YW5g5AR`X\EO%Zv`S|bOi`?Q3\u1mN  zz!z"z$z%z&z'z(z)z*z+z,z-z.z/z0z1z2z4z5z6z8z:z>z@zAzBzCzDzEzGzHzIzJzKzLzMzNzOzPzRzSzTzUzVzXzYzZz[z\z]z^z_z`zazbzczdzezfzgzhz  izjzkzlzmznzozqzrzszuz{z|z}z~zzzzzzzzzzzzzzzzzzz0SZO{OON ls^ju
jwA~QpS)rmlJWe?b2YN~>e^aU*S T^l9Z)TlR~_Wq~l|KYN_$a|0N\g\up"QIYQ[O&T+Yweu[vbbE^l&{OOg  zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz  zzzzzzzz {{{{{	{{{{{{{{{{{{{{!{"{#{'{){-{nmmy_+ubOe/Q^PtoRKYPN6ry[DYTvVV9eivnr^uFggzvaybecQR8~\/n`g{v|dP?zJTTLkdb=urRi[<h*NT~9hf^  /{0{2{4{5{6{7{9{;{={?{@{A{B{C{D{F{H{J{M{N{S{U{W{Y{\{^{_{a{c{d{e{f{g{h{i{j{k{l{m{o{p{s{t{v{x{z{|{}{{{{{{{{{{{{{{{  {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{W?h];eRm`OlQ[_]^lb!qQRlrWg-YT{0Old[YS7Ee~V.RtPR[cVNb*`hsQ[Q{P`Lp/IQ^pt-WExR_h<xvBhg5=RnhVgT  {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{ ||||||||	|
||||||||||||  ||||| |!|"|#|$|%|(|)|+|,|-|.|/|0|1|2|3|4|5|6|7|9|:|;|<|=|>|B|i[wm&lN[ca+Tm[QUUdMcea`
qWlIl/Ymg*XVjk}YSimuTUw8hyTUOTvlmkd:?Vu_rh`TN*jaR`pTpy?*m[_~UO4s<TSPT|TNN_ZtXktr|Vn  C|D|E|F|G|H|I|J|K|L|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|[|\|]|^|_|`|a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|u|v|w|x|y|z|~||||||||||  |||||||||||||||||||||||||||||||||'_N,UbNl7bTNS>sn;uRSi_ `mOW"ksShbc`$Uubqm[{^RLaxW'|vQ`LqCfL^M`pp%c_b`Vk`gaIS`ff?yOpGl~dfZZBQmmA;mOkpb`'xyQ>WW:gxu=zy{  ||||||||||||||||||||||||||||||||||||||||||||||| }}}}}}}}}	}}}}}}}  }}}}}}}}}}}}}}}!}#}$}%}&}(})}*},}-}.}0}1}2}3}4}5}6}eo!Y~		TghM|S%`urlsSZ~$cQ
]bQc[OmyBR`Nm[[e_EY~~	Vg9YsO[RZ>2uGP<zNg~Z|kvZW\:{Nq|QpxY'hgxwxbac{OjRQPit1.{N  7}8}9}:};}<}=}>}?}@}A}B}C}D}E}F}G}H}I}J}K}L}M}N}O}P}Q}R}S}T}U}V}W}X}Y}Z}[}\}]}^}_}`}a}b}c}d}e}f}g}h}i}j}k}l}m}o}p}q}r}s}t}u}v}  x}y}z}{}|}}}~}}}}}}}}}}}}}}}}}}}}}}}}}}}eP0QRonnm^PY\Fm_luhhVY SqMIiy&qNGmZVdwOrz4~RYeuSzccvyW6*bRThpgwckwzm~YbLuPNuJ\]K{eN%m_'}&N(sKfypxm  }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}  }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}=\RFbQ[wvfN`||~NfofYXle\_uVzzQpzcvz~sENxp]NRSQeeT1\ubruE\y@\Tw>NlZbnc]wQ/OS`pgRPcCZ&P7wwS~d+ebcP5rQ~GWQT\  }}}}} ~~~~~~~~~	~
~~~~~~~~~~~~~~~~~~~~~~ ~!~"~#~$~%~&~'~(~)~*~+~,~-~.~/~0~1~2~3~4~5~6~7~8~9~  :~<~=~>~?~@~B~C~D~E~F~H~I~J~K~L~M~N~O~P~Q~R~S~T~U~V~W~X~Y~Z~[~\~]~OzZmUTaST _cwiQha
R*XRNWxw^wa|[bbNpbp`wWghxyXTS4nKQ;R[CUWs`QW-TzzP`T[cbScb[gTzw^8YWcWWw{O_[>k!SP{rFhw6weQNv\zuNYAP  ^~_~`~a~b~c~d~e~f~g~h~i~j~k~l~m~n~o~p~q~r~s~t~u~v~w~x~y~z~{~|~}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ~~~~~~~~
79;<=>?@ACFGHIJKLMNORS'andWfFcVbib^WbU!JfUegVjZhb{pQo0capntir^gjm^cRbrlOYjpmRPNm~x/}!QWd{|lh^iQShr{ryotNg<yTTh=NSR>xS)RPOO  VY[\]^`cdefgklmopsuvwxz{|}  uz|lRtTOTp^`m^[e8K`p~|Qh|o$N~fNdJPuq[foNdc^eRpRs3tgx4NmQATbs6OQupu\SNn	tikxYuR$vAmgmQKT<{z  	
!#$+,-./0249:<>@ADEGHINOPQSUVW  Y[\]^_`abcdefghklmnoprstuvwxyz{|}WbG|iZd{oKbS^pcdSOx2B^oyU_F.btTOee\a\Q/l_sn~\cj[nuSqNceubn&ONl~W;#{=m~YsxlVTWpNVS	wnfba+o  ~    !"#$%&'()*+-.034579:;<=?)+vl_+skwoSQ=^8HNsghv	dql	wZAk'f[YZNjv0sh_[/wa|%_s|yl[B^h w~QMQR)Zbcwy:n^YmplbvOe`f#T}T,xd  @ABCDEGIMNORVWX[\]^_abcdfhjklorsuvwx  yd!jxidTb+gXl o[L_rgbarNYkXfU^RUa(gvfwgrFzbTPTZ~lCNvYHYWS7uV c|`mbTQZY*Pl<\b`O?S{n+bt^xd{c_Z?\OcB}[nUJMm`grQ[  	
 $%&').2:<=?  @ABCEFHJLMNPQRSTUVWY[\]^`abcdefgibl[rmb~SmQ_tYR`sYfPu*ca|T'k%kUTvPljU,r^`6tbcLr_Cn>m eXovxvTu$RSSN^e*bT(RplxTWTjMiOlUv0xbpom_h|x{gOgcxoWx9ybbR5tk  jklmquvwx{|   
 !"#$%&)*.027;=dU>uv9SuPA\l{OPGrothydwb+TXRNjWs^QtO\aWlFZ4xD|VRQbNaW4gWnffm1fpg:khbYNQoglvQhGYgkfu]PeHyAyw\^NO/TQYxhVl_}llc  >?ABDEHJKLMNSUVWXY]bpqrstuvyz~  p`=murfbCS~{N&~NMR\ocEm4XL] kIkg[TTX7:_bGj9re`ehwTNO]d\OzRN/`zONy4tRdy[lR{"l>PSndtf0l`w^<twzyNtBlVKl:SfH\q n   	
 !"#)*+,-./02345679:;>?@ABCDEGHI  JKLMNOPRSTUVX]^_`bdefghjnoprtwy{|S6ZSWCglhQubr8RR:p8vtSJinx6qqQgtXeVvpb~`pXNN_NRY~TbNeb8cqn[~Qcg9Qz[YsN]leQ%o.J^tm1_dm(n^X[	NS  }~   OceQhU'NdkbZ_trmhPx@g9Rl~PeU^q[{RfsIgq\ R}qkUdaUUlGb.X$OFUOLf
N\hNczpR\T~bYJfDd\Qam>y7x3u{T8Om Z~^yl[vZuNanXu%urrGS~  	
 "#$%&'()*-./0123456>?@ABDEFGKLMNOPQRSTU  WXZ[\]_`abcefgijklmnopqsuvwx|}wviR#W^1Yren8\qASwbeN[SwON\vY_:yXNgNbR/fUlVNOpl^C`[6eKb[[c.US&v}Q,ghkbSmufNNp[qffr  ^\/gh_gbzX^pe1o    U`7RTdp)u^hbS=r4lawz.TwzUxgped6V`ySN{k[UV:O<Or]~g8`[dXdUeO }|PQXn[x{}~x\WzB_yY[_c{hU)t"}@bLXN[yYTX   	
 !"#$%&(*+,-./012345679:;=>?@  ABCDEFGHIJKLRSUVWXY[\]_`acdefghijmscKbSl^*Y`plMWJd*+vn[Wjumo-fWkxcSpdlXX*dXhU|Pmpcmn~ChmvWYyr~uhTR"cD|USOfV`mCRI\)YmkX0uul`Fcag:w4^S,Tp  moprstuvwx  @l^\PN^:cGPhnwTd_zvhEcR{~uwPb4YQyzV_m`\WTTQMnVc* To\bXb15@n|-iYb>UcT<mZtjkYL/_~ns}8Np[x=cZfv`[IZNUjlsNgQ_eg_YZ   $&'(*+,-/0235689:<=@ABCDEFJKMOPQRTUVXZ[\]^_abfghijklmoqrsu  wxyz]_qSEhV/U`:NMo~YO*O>\~*gsTOuUOMO-n	\pakSv)ne~;T3z
}UtcmzbegScl]\TLNalK\eh>T4TkfkNBcHSOO^W
bdfirRR`fqgRxwpf;V8T!zr     	 # zo`^`Y`qpnPlrj-^`NZUm|b~w~#Sf\OrNSYTc(HQN~T$T7m&_Z>fis.sSz[wP~vSv{DXnaNey`TNy]ajPTa']xJRTV m[mSf  $%&'()*+,-./01345678:;=>?ABCFGHIJKNOPQRSUVXZ[\]^_`fgjmoqstuvxyz  {|\][!hxU{HeTiNGkNOSc:deQhxSall"Q\#ke__OEfe)s`tQRWb_Lx^Og'`YDQQSylqOO=gUy~Xb ZV{_WSe^\ud`n}Z~~iU[`es     	 "#$&'(),-./12357	cv)w~tf[tz@Rq_e[o]k[l
Sb&-@T+NYr]YmTN	qT	pmv%Nx\^ plDYc<wMos0XqSxUf_0q[k.Y/yhglboOum3'lNu{Q7h>opYvt  89:;<=>?@BCEFGHIJKLMNOPQRSTUVWXYZ[\]`abcdeghijklmnopqrstuvwxyz|  }~Gd'\ez#YT o 0iNV67rQ_NucNSfKYm NX;ScO
Oc7YWyNul[Y]_iP]YNwNzbfy\Ny_8uNak_INvn
_~5kVk4YTm[n9\_    	
pS1jtZp^($%gGbvq_lx fTbcOu^
Tlm8l`R(u}^O`_$\1url8nI	gSSQOS|^mNvi^aYOO>|	annN1ZN\y[sWTGU\_a2kr   !"#$%&'()*+,-./0123456789:;<=?@ABCDEFGIJKLMNOPQRSTUVWXYZ[\]^  _`abcdefghijklmnopqrstuvwxz{|}~tm[km3
nQCQWScVXTW?sn?a(`bf~\|g`N ShAQt]UfU[S8xBg=hT~p[}Q(WTef^Clm|QgeojV vvpq#bRl<`Xaf`NbU#n-gg    (whiTMNpXde[z:P[wky|lve-]U\8h`Sbz[n~jzp_3o _cmVgN^&N4vb-f~blugqiFQSnbTYmsewu'xOgu/cG5#cAw_rN`tebck?e   	
 !"#  $%'()*+,-./0123456789:;<=>?@ABCDE'^ug/e1TwAlKN~Lvikgb<PO@WcbkSe~_ccn^\6Rzfyz(punlz-Nv_w~yNOhT]2m|t^Tv[<fs*h1g*szpnqbw1V;NWgR.Q{  FGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdeghijkmnopqrstuvwxyz{|}~  	OOl]y{b*rbNxldZ{ih^YdXri%X`W QIcbSSLh"tLDU@w|pJmyQTDYnm\[+}N}|nP[nW[h*[~;`~pOYcyRSeVy;~~4V gj
\u(f]POgZP\OPW^  89:;<=>?@BCDEHJKMNOPQRSTVWXY[\]^_`cdefghilmnopqrtuvw{|}~  NN@QN^ESNNN2l[iV(Ny?NSGN-Y;rnSlVk~w6NN\NiNN[[lUVNSSSSSe]SS&S.S>S\fScSRRR-R3R?R@RLR^RaR\R}RRRRRQTNNNNNNNNON"OdON%O'O	O+O^OgO8eZO]O     	
_OWO2O=OvOtOOOOO~O{OO|OOOOOOOOOOOOO)PLPO,PP.P-POPP%P(P~PCPUPHPNPlP{PPPPPPQPPPPQQN=lXOeOOFlt|nQ]QYRSSQYUQNVQNnNy4[QQQQ   QRW_ehijlnoqrxyz{|}~  QQQQ  !%'*+./2356iSzS"!1*=<BIT_glrt    !$%&'(+-0234678;<>  ?CEFLMNOPSTUVWXZ[\]^_`abcdeghjknq"#1/9CFRBYRRRRTRRRSqw^QQ/S_Zu]LWWW~XXXX)W,W*W3W9W.W/W\W;WBWiWWkWW|W{WhWmWvWsWWWWWWWWWWWWWWWWWWWWW  suwxyz{}~  XXWW XXXDX XeXlXXXXXay}	Q[\<41^/OGC_@`-:3fe   	
 !"#  $%&'()*+,-./0123456789:;<=>?@ABCDhiljmnx|}{X8&\QZYszx<Fiv1mu89:  EFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdej  V;YHhd^zwCr{y')<^_<YAY7UYZYXYS"\%\,\4\Lbjbbbbbbb"cb9cKcCcccqczcccmccciccccccccccRdccEdAddd dd&d!d^ddmdd  #$%'()*+,0123479:=?@CEFHIJKLNTUVYZ\]^_`adfgijklopqrsvwxyz{|~  zdddddddddd	e%e.e__u__SSSSSSTTTKTRTSTTTVTCT!TWTYT#T2TTTwTqTdTTTTvTfTTTTTTTTTTTrTTTTTTTTTTTTTTTUT UTUT"U#UUU'U*UgUUUIUmUAUUU?UPU<U   	
   !$%&'()*+,-.02345678:;<=>?@ABD7UVUuUvUwU3U0U\UUUUUUUUU~UUU{UUUUUUUUUVUUUUUUUUUUUUUUUUVVVV$V#VU V'V-VXV9VWV,VMVbVYV\VLVTVVdVqVkV{V|VVVVVVVVVVVVW
W	WW^^^^1^;^<^  EGHQSTUVXY[\_`fghkmsz{|  7^D^T^[^^^a^\z\\\\\\\\\\\\\\\\\\\\\\\\]]']&].]$]]]]X]>]4]=]l][]o]]]k]K]J]i]t]]]]s]]s_w____________ba_rrrrrrrrrrrrrrrrsrsr   	
 !"#$  %&'()*+,-./0123456789:;<=>?@ABCDErss!s
ssss"s9s%s,s8s1sPsMsWs`slsos~s%Y$YYcghijkltw}^^^^^^^^^^S^^^^^____`_`___``___`5`&````)`+`
`?`!`x`y`{`z`B`  FGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrsuvwxyz{|}~  j`}````````````````` a&aa#a` aa+aJauaaaaaaa_
,N?rb5lTl\lJllllllhliltlvllllllllllllllllllll     	9m'mmCmHmmmmm+mMm.m5mmOmRmTm3mmommm^mmm\m`m|mcmnmmmnmmnmmmnmnm+nnnNnknn_nnSnTn2n%nDnnnnn-onnnnnnnnnnnnboFoGo$oon/o6oKoto*o	o)ooooxoro|ozoo  
 !"#$%&'()*+,-./0123456789:;<=?@ABCDEFGHI  JKLMNOPQRSTUVWXYZ[\]^_`abcdefghikoooooooooop#pp9p5pOp^p[[[[[[/u4d[[0[G&!56-/DQRPhXb[ft}P_W_V_X_;\TP\Y\q[c\f\*_)_-_t<_;n\YYYYYY  lmnopqrstuvwxyz{|}~  YYYYYYYYYYZZYZYYYZ	Z2Z4ZZ#ZZ@ZgZJZUZ<ZbZuZZZwZzZZZZZZZZZZZZZZ	[[[2[7[@[\\Z[e[s[Q[S[b[uwxz}~~~~~~   	
   !"#$%&'()*+,-.~~~~~~~~~~~~~~~~~~~~~~~~~!"#$%&'*+,-/01235z^u]>usssssssssssssss|
tssssst*t[t&t%t(t0t.t,t  /0123456789:;<=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijlmno  pqrstuvwxyz{|}~ ttAt\tWtUtYtwtmt~ttttttttttttttLgSg^gHgigggjgsgggugggggwg|gg	hg
hgghggggg hggghgg2h3h`hahNhbhDhdhhhUhfhAhgh@h>hJhIh)hhhthwhhkhhnihi ih  '3=CHKUZ`ntuwxyz{|}~  $ihiiWihiqi9i`iBi]iikiiixi4iiiiiificiyiiiiiiiiiiiiiii/jijjejiDj>jjPj[j5jjyj=j(jXj|jjjjjj7sRskkkkkkkkkkkkmqrsuvxwyz|~   #$%&'()+,-/0789:>ACJNOQRSVW  XYZ\]^`cefkmnopqsxyz{|}~bbbb"b!b%b$b,btttuuu4eeee
ffrgff fpff4f1f6f5f_fTfAfOfVfafWfwffffffffff236;=@EFHIGMUYnrr]rfror~rrrrrrrc2cc    
 ?ddkkkkkllllllll!l)l$l*l2l5eUekeMrRrVr0rbR
gggZ6,2HLStYZq`i|}mgMXZn&g  !"#$%&'()+,./134567:;<=?@ABCDEFGHIJKLMNOPQTUWXZ\]_cdfghjklmnopq  ruwxyz{}~$k7k9kCkFkYkk@_keQeeeeeeeeepppppppppppqqq/q1qsq\qhqEqrqJqxqzqqqqqqqqqqr(rlpqfqq>b=bCbHbIb;y@yFyIy[y\ySyZybyWy`yoygyzyyyyyy__     	
<`]`Z`g`A`Y`c``aa]aaaaabllmww x	xxxxe-xxx9x:x;xx<x%x,x#x)xNxmxVxWx&xPxGxLxjxxxxxxxxxxxxxxxxyxy$yy4yvwwvwww"ww-w&w5w8wPwQwGwCwZwhw   !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLM  NOPQRSTUVWXYZ[\]^_`abcdefghijklmnbwewww}wwwwwwwww:u@uNuKuHu[uruyuuXa_Hhtqy~vv2  opqrst   	
"*+),124678<>?B5DEFILNORSTVWXY[^_]abdefghijkloqrs:wwyyyyzG]zzzz  	
 !"#$%&'()*+,-/0123456789:;<=>?@ABCDEFGHI  JKLMNOPQRSVWXYZ[\]^_`abdfsxy{~9z7zQzpzvvvvvtt,u "()*+,216879:>ABDFGHIKLNQUWZ[\^cfghijklqmsuuuuuuuuuuuuuuuuuuuuuuuvuuuv vvvv
v%vvvv    v<v"v v@v-v0v?v5vCv>v3vMv^vTv\vVvkvovzxzyzzzzzzzzzzzdir}!
4+6Af{uvvw "%&')(15CFMRiqx   	
 !"#$%&'()*+,-./012345678  9:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYMTlnz|{
	#;%.>H41)7?"}~{`pLnSc|dYe  Z[\]^_`abcdefghijkr   
!9<6BDEzz{{{{
{+{{G{8{*{{.{1{ {%{${3{>{{X{Z{E{u{L{]{`{n{{{b{r{q{{{{{{{{{{{{{{{{{{{{{{|{{|||  	
 !"$%&'()*+,-.013456789:=>?@FJKLNPRSUVWXYZ  [\]^_`abcdefghijklmnopqrstuvwxyz{|*|&|8|A|@|D!"#-/(+8;34>DIKOZ_h~^||Ie||||||||||||||||nf|w}}}G~~sgmGIJPNOd  |}~  bapio}~rtyU~Yi	,.#/:@95=1IABQRJpv|otxe   	
   !"#$%&'()*+,-./0123456789:;>&S*-0>w>j>k#z  <=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz  {}~|XECGIHMQ.UT#;~",/97=>D   	
 !  "#$%&'()*+,-./0123456789:;<=>?@AB456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~  CDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~        	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLM  	
$'.04;<@MPRSTVY]_`abenortuvwxyz{|}  NOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~     	
!#$%&'()*+-.01 	  234568:<?@ABCEFGHIJKLMNORSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwx  yz{|}~,y
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefg   !#$'().      .s4G4..566..n9999s:9N;n<<.  .V@_A.7C...  CC.CDaFLF  #G)G|GG.GIzI}IIIIIIIII  LLLLwLLMMMMMMMMhijklmnopqrstuvwxyz{|}~             	 
                        ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~                                                                                                                                 ! !!!!!!!!!	!
!!!!!!!!!!!!!!!!!!!!!! !!!"!#!$!%!&!'!(!)!*!+!,!-!.!/!0!1!2!3!4!5!6!7!8!9!:!;!<!=!>!?!@!A!B!C!D!E!F!G!H!I!J!K!L!M!N!O!P!Q!R!S!T!U!V!W!X!Y!Z![!\!]!^!_!`!a!b!c!d!e!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!u!v!w!x!y!z!{!|!}!~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" """""""""	"
"""""""""""""""""""""" @A"!"""#"$"%"&"'"(")"*"+","-B"."/"0"1"2"3"4"5"6"7"8"9":";"<"=">"?"@"A"B"C"D"E"F"G"H"I"J"K"L"M"N"O"P"Q"R"S"T"U"V"W"X"Y"Z"["\"]"^"_"`"a"b"c"d"e"f"g"h"i"j"k"l"m"n"o"p"q"r"s"t"u"v"w"x"y"z"{"|"}"~"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""# #########	#
###################### #!#"###$#%#&#'#(#)#*#+#,#-#.#/#0#1#2#3#4#5#6#7#8#9#:#;#<#=#>#?#@#A#B#C#D#E#F#G#H#I#J#K#L#M#N#O#P#Q#R#S#T#U#V#W#X#Y#Z#[#\#]#^#_#`#a#b#c#d#e#f#g#h#i#j#k#l#m#n#o#p#q#r#s#t#u#v#w#x#y#z#{#|#}#~#################################################################################################################################$ $$$$$$$$$	$
$$$$$$$$$$$$$$$$$$$$$$ $!$"$#$$$%$&$'$($)$*$+$,$-$.$/$0$1$2$3$4$5$6$7$8$9$:$;$<$=$>$?$@$A$B$C$D$E$F$G$H$I$J$K$L$M$N$O$P$Q$R$S$T$U$V$W$X$Y$Z$[$\$]$^$_$`$a$b$c$d$e$f$g$h$i$j$k$l$m$n$o$p$q$r$s$t$u$v$w$x$y$z${$|$}$~$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$% %%%%%%%%%	%
%%%%%%%%%%%%%%%%%%%%%% %!%"%#%$%%%&%'%(%)%*%+%,%-%.%/%0%1%2%3%4%5%6%7%8%9%:%;%<%=%>%?%@%A%B%C%D%E%F%G%H%I%J%K%L%M%N%O%P%Q%R%S%T%U%V%W%X%Y%Z%[%\%]%^%_%`%a%b%c%d%e%f%g%h%i%j%k%l%m%n%o%p%q%r%s%t%u%v%w%x%y%z%{%|%}%~%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%& &&&&&&&&&	&
&&&&&&&&&&&&&&&&&&&&&& &!&"&#&$&%&&&'&(&)&*&+&,&-&.&/&0&1&2&3&4&5&6&7&8&9&:&;&<&=&>&?&@&A&B&C&D&E&F&G&H&I&J&K&L&M&N&O&P&Q&R&S&T&U&V&W&X&Y&Z&[&\&]&^&_&`&a&b&c&d&e&f&g&h&i&j&k&l&m&n&o&p&q&r&s&t&u&v&w&x&y&z&{&|&}&~&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&' '''''''''	'
'''''''''''''''''''''' '!'"'#'$'%'&'''(')'*'+','-'.'/'0'1'2'3'4'5'6'7'8'9':';'<'='>'?'@'A'B'C'D'E'F'G'H'I'J'K'L'M'N'O'P'Q'R'S'T'U'V'W'X'Y'Z'['\']'^'_'`'a'b'c'd'e'f'g'h'i'j'k'l'm'n'o'p'q'r's't'u'v'w'x'y'z'{'|'}'~'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''( (((((((((	(
(((((((((((((((((((((( (!("(#($(%(&('((()(*(+(,(-(.(/(0(1(2(3(4(5(6(7(8(9(:(;(<(=(>(?(@(A(B(C(D(E(F(G(H(I(J(K(L(M(N(O(P(Q(R(S(T(U(V(W(X(Y(Z([(\(](^(_(`(a(b(c(d(e(f(g(h(i(j(k(l(m(n(o(p(q(r(s(t(u(v(w(x(y(z({(|(}(~((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((() )))))))))	)
)))))))))))))))))))))) )!)")#)$)%)&)')()))*)+),)-).)/)0)1)2)3)4)5)6)7)8)9):);)<)=)>)?)@)A)B)C)D)E)F)G)H)I)J)K)L)M)N)O)P)Q)R)S)T)U)V)W)X)Y)Z)[)\)])^)_)`)a)b)c)d)e)f)g)h)i)j)k)l)m)n)o)p)q)r)s)t)u)v)w)x)y)z){)|)})~)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))* *********	*
********************** *!*"*#*$*%*&*'*(*)***+*,*-*.*/*0*1*2*3*4*5*6*7*8*9*:*;*<*=*>*?*@*A*B*C*D*E*F*G*H*I*J*K*L*M*N*O*P*Q*R*S*T*U*V*W*X*Y*Z*[*\*]*^*_*`*a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*{*|*}*~*********************************************************************************************************************************+ +++++++++	+
++++++++++++++++++++++ +!+"+#+$+%+&+'+(+)+*+++,+-+.+/+0+1+2+3+4+5+6+7+8+9+:+;+<+=+>+?+@+A+B+C+D+E+F+G+H+I+J+K+L+M+N+O+P+Q+R+S+T+U+V+W+X+Y+Z+[+\+]+^+_+`+a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+r+s+t+u+v+w+x+y+z+{+|+}+~+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++, ,,,,,,,,,	,
,,,,,,,,,,,,,,,,,,,,,, ,!,",#,$,%,&,',(,),*,+,,,-,.,/,0,1,2,3,4,5,6,7,8,9,:,;,<,=,>,?,@,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,[,\,],^,_,`,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,{,|,},~,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,- ---------	-
---------------------- -!-"-#-$-%-&-'-(-)-*-+-,---.-/-0-1-2-3-4-5-6-7-8-9-:-;-<-=->-?-@-A-B-C-D-E-F-G-H-I-J-K-L-M-N-O-P-Q-R-S-T-U-V-W-X-Y-Z-[-\-]-^-_-`-a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z-{-|-}-~---------------------------------------------------------------------------------------------------------------------------------. .........	.
...................... .!.".#.$.%.&.'.(.).*.+.,.-.../.0.1.2.3.4.5.6.7.8.9.:.;.<.=.>.?.@.A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.Y.Z.[.\.].^._.`.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.{.|.}.~................................................................................................................................./ /////////	/
////////////////////// /!/"/#/$/%/&/'/(/)/*/+/,/-/.///0/1/2/3/4/5/6/7/8/9/:/;/</=/>/?/@/A/B/C/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z/[/\/]/^/_/`/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/{/|/}/~/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////0 000000000	0
0000000000000000000000 0!0"0#0$0%0&0'0(0)0*0+0,0-0.0/000102030405060708090:0;0<0=0>0?0@0A0B0C0D0E0F0G0H0I0J0K0L0M0N0O0P0Q0R0S0T0U0V0W0X0Y0Z0[0\0]0^0_0`0a0b0c0d0e0f0g0h0i0j0k0l0m0n0o0p0q0r0s0t0u0v0w0x0y0z0{0|0}0~0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 111111111	1
1111111111111111111111 1!1"1#1$1%1&1'1(1)1*1+1,1-1.1/101112131415161718191:1;1<1=1>1?1@1A1B1C1D1E1F1G1H1I1J1K1L1M1N1O1P1Q1R1S1T1U1V1W1X1Y1Z1[1\1]1^1_1`1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z1{1|1}1~1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111112 222222222	2
2222222222222222222222 2!2"2#2$2%2&2'2(2)2*2+2,2-2.2/202122232425262728292:2;2<2=2>2?2@2A2B2C2D2E2F2G2H2I2J2K2L2M2N2O2P2Q2R2S2T2U2V2W2X2Y2Z2[2\2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2q2r2s2t2u2v2w2x2y2z2{2|2}2~2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222223 333333333	3
3333333333333333333333 3!3"3#3$3%3&3'3(3)3*3+3,3-3.3/303132333435363738393:3;3<3=3>3?3@3A3B3C3D3E3F3G3H3I3J3K3L3M3N3O3P3Q3R3S3T3U3V3W3X3Y3Z3[3\3]3^3_3`3a3b3c3d3e3f3g3h3i3j3k3l3m3n3o3p3q3r3s3t3u3v3w3x3y3z3{3|3}3~3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333334 444444444	4
4444444444444444444444 4!4"4#4$4%4&4'4(4)4*4+4,4-4.4/404142434445464748494:4;4<4=4>4?4@4A4B4C4D4E4F4G4H4I4J4K4L4M4N4O4P4Q4R4S4T4U4V4W4X4Y4Z4[4\4]4^4_4`4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x4y4z4{4|4}4~4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444445 555555555	5
5555555555555555555555 5!5"5#5$5%5&5'5(5)5*5+5,5-5.5/505152535455565758595:5;5<5=5>5?5@5A5B5C5D5E5F5G5H5I5J5K5L5M5N5O5P5Q5R5S5T5U5V5W5X5Y5Z5[5\5]5^5_5`5a5b5c5d5e5f5g5h5i5j5k5l5m5n5o5p5q5r5s5t5u5v5w5x5y5z5{5|5}5~5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555556 666666666	6
6666666666666666666666 6!6"6#6$6%6&6'6(6)6*6+6,6-6.6/606162636465666768696:6;6<6=6>6?6@6A6B6C6D6E6F6G6H6I6J6K6L6M6N6O6P6Q6R6S6T6U6V6W6X6Y6Z6[6\6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6w6x6y6z6{6|6}6~6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666667 777777777	7
7777777777777777777777 7!7"7#7$7%7&7'7(7)7*7+7,7-7.7/707172737475767778797:7;7<7=7>7?7@7A7B7C7D7E7F7G7H7I7J7K7L7M7N7O7P7Q7R7S7T7U7V7W7X7Y7Z7[7\7]7^7_7`7a7b7c7d7e7f7g7h7i7j7k7l7m7n7o7p7q7r7s7t7u7v7w7x7y7z7{7|7}7~7777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777778 888888888	8
8888888888888888888888 8!8"8#8$8%8&8'8(8)8*8+8,8-8.8/808182838485868788898:8;8<8=8>8?8@8A8B8C8D8E8F8G8H8I8J8K8L8M8N8O8P8Q8R8S8T8U8V8W8X8Y8Z8[8\8]8^8_8`8a8b8c8d8e8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}8~8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888889 999999999	9
9999999999999999999999 9!9"9#9$9%9&9'9(9)9*9+9,9-9.9/909192939495969798999:9;9<9=9>9?9@9A9B9C9D9E9F9G9H9I9J9K9L9M9N9O9P9Q9R9S9T9U9V9W9X9Y9Z9[9\9]9^9_9`9a9b9c9d9e9f9g9h9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9y9z9{9|9}9~999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999: :::::::::	:
:::::::::::::::::::::: :!:":#:$:%:&:':(:):*:+:,:-:.:/:0:1:2:3:4:5:6:7:8:9:::;:<:=:>:?:@:A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z:[:\:]:^:_:`:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:}:~:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::; ;;;;;;;;;	;
;;;;;;;;;;;;;;;;;;;;;; ;!;";#;$;%;&;';(;);*;+;,;-;.;/;0;1;2;3;4;5;6;7;8;9;:;;;<;=;>;?;@;A;B;C;D;E;F;G;H;I;J;K;L;M;N;O;P;Q;R;S;T;U;V;W;X;Y;Z;[;\;];^;_;`;a;b;c;d;e;f;g;h;i;j;k;l;m;n;o;p;q;r;s;t;u;v;w;x;y;z;{;|;};~;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;< <<<<<<<<<	<
<<<<<<<<<<<<<<<<<<<<<< <!<"<#<$<%<&<'<(<)<*<+<,<-<.</<0<1<2<3<4<5<6<7<8<9<:<;<<<=<><?<@<A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z<[<\<]<^<_<`<a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y<z<{<|<}<~<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<= =========	=
====================== ="=#=$=%=&='=(=)=*=+=,=-=.=/=0=1=2=3=4=5=6=7=8=9=:=;=<===>=?=@=A=B=C=D=E=F=G=H=I=J=K=L=M=N=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=\=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=r=s=t=u=v=w=x=y=z={=|=}=~=================================================================================================================================> >>>>>>>>>	>
>>>>>>>>>>>>>>>>>>>>>> >!>">#>$>%>&>'>(>)>*>+>,>->.>/>0>1>2>3>4>5>6>7>8>9>:>;><>=>>>?>@>A>B>C>D>E>F>G>H>I>J>K>L>M>N>O>P>Q>R>S>T>U>V>W>X>Y>Z>[>\>]>^>_>`>a>b>c>d>e>f>g>h>i>j>k>l>m>n>o>p>q>r>s>t>u>v>w>x>y>z>{>|>}>~>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\>>CD>>>>>>>>>>E>>? ????????F?	?
?????????????????????? ?!?"?#?$?%?&?'?(?)?*?+?,?-?.?/?0?1?2?3?4?5?6?7?8?9?:?;?<?=?>???@?A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?\?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?q?r?s?t?u?v?w?x?y?z?{?|?}?~??????????????????????????????????????????????????????????????????????????????????????G???H??????????????????????Y??????????????????@ @@@@@@@@@	@
@@@@@@@@@@@@@@@@@@@@@@ @!@"@#@$@%@&@'@(@)@*@+@,@-@.@/@0@1@2@3@4@5@6@7@8@9@:@;@<@=@>@?@@@A@B@C@D@E@F@GIJKL@H@I@J@K@L@M@N@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@\@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@z@{@|@}@~@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@@@N@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@@@@@@@@@@@@QR@@@@@@@@@A AAAAAAAAA	A
AAAAAAAAAAAAAAAAAAAAAA A!A"A#A$A%A&A'A(A)A*A+A,A-A.A/A0A1A2A3A4A5A6A7A8A9A:A;A<A=A>A?A@AAABACADAEAFAGAHSAIAJAKALAMANAOAPAQARASATAUAVAWAXAYAZA[A\A]A^A_A`AaAbAcAdAeAfAgAhAiAjAkAlAmAnAoApAqArAsAtAuAvAwAxAyAzA{A|A}A~AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB BBBBBBBBB	B
BBBBBBBBBBBBBBBBBBBBBB B!B"B#B$B%B&B'B(B)B*B+B,B-B.B/B0B1B2B3B4B5B6B7B8B9B:B;B<B=B>B?B@BABBBCBDBEBFBGBHBIBJBKBLBMBNBOBPBQBRBSBTBUBVBWBXBYBZB[B\B]B^B_B`BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByBzB{B|B}B~BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBC CCCCCCCCC	C
CCCCCCCCCCCCCCCCCCCCCC C!C"C#C$C%C&C'C(C)C*C+C,C-C.C/C0C1C2C3C4C5C6C7C8C9C:C;C<C=C>C?C@CACBCCCDCECFCGCHCICJCKCLCMCNCOCPCQCRCSCTCUCVCWCXCYTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwCZC[C\C]C^C_C`CaCbCcCdCeCfxyz{|}~CgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyCzC{C|C}C~CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCD DDDDDDDDD	D
DDDDDDDDDDDDDDDDDDDDDD D!D"D#D$D%D&D'D(D)D*D+D,D-D.D/D0D1D2D3D4D5D6D7D8D9D:D;D<D=D>D?D@DADBDCDDDEDFDGDHDIDJDKDLDMDNDODPDQDRDSDTDUDVDWDXDYDZD[D\D]D^D_D`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyDzD{D|D}D~DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDE EEEEEEEEE	E
EEEEEEEEEEEEEEEEEEEEEE E!E"E#E$E%E&E'E(E)E*E+E,E-E.E/E0E1E2E3E4E5E6E7E8E9E:E;E<E=E>E?E@EAEBECEDEEEFEGEHEIEJEKELEMENEOEPEQERESETEUEVEWEXEYEZE[E\E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtEuEvEwExEyEzE{E|E}E~EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEF FFFFFFFFF	F
FFFFFFFFFFFFFFFFFFFFFF F!F"F#F$F%F&F'F(F)F*F+F,F-F.F/F0F1F2F3F4F5F6F7F8F9F:F;F<F=F>F?F@FAFBFCFDFEFFFGFHFIFJFKFLFMFNFOFPFQFRFSFTFUFVFWFXFYFZF[F\F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFrFsFtFuFvFwFxFyFzF{F|F}F~FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFG GGGGGGGGG	G
GGGGGGGGGGGGGGGGGGGGGG G!G"G#G$G%G&G'G(G)G*G+G,G-G.G/G0G1G2G3G4G5G6G7G8G9G:G;G<G=G>G?G@GAGBGCGDGEGFGGGHGIGJGKGLGMGNGOGPGQGRGSGTGUGVGWGXGYGZG[G\G]G^G_G`GaGbGcGdGeGfGgGhGiGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyGzG{G|G}G~GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGH HHHHHHHHH	H
HHHHHHHHHHHHHHHHHHHHHH H!H"H#H$H%H&H'H(H)H*H+H,H-H.H/H0H1H2H3H4H5H6H7H8H9H:H;H<H=H>H?H@HAHBHCHDHEHFHGHHHIHJHKHLHMHNHOHPHQHRHSHTHUHVHWHXHYHZH[H\H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}H~HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHI IIIIIIIII	I
IIIIIIIIIIIIIIIIIIIIII I!I"I#I$I%I&I'I(I)I*I+I,I-I.I/I0I1I2I3I4I5I6I7I8I9I:I;I<I=I>I?I@IAIBICIDIEIFIGIHIIIJIKILIMINIOIPIQIRISITIUIVIWIXIYIZI[I\I]I^I_I`IaIbIcIdIeIfIgIhIiIjIkIlImInIoIpIqIrIsItIuIvIwIxIyIzI{I|I}I~IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJ JJJJJJJJJ	J
JJJJJJJJJJJJJJJJJJJJJJ J!J"J#J$J%J&J'J(J)J*J+J,J-J.J/J0J1J2J3J4J5J6J7J8J9J:J;J<J=J>J?J@JAJBJCJDJEJFJGJHJIJJJKJLJMJNJOJPJQJRJSJTJUJVJWJXJYJZJ[J\J]J^J_J`JaJbJcJdJeJfJgJhJiJjJkJlJmJnJoJpJqJrJsJtJuJvJwJxJyJzJ{J|J}J~JJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJK KKKKKKKKK	K
KKKKKKKKKKKKKKKKKKKKKK K!K"K#K$K%K&K'K(K)K*K+K,K-K.K/K0K1K2K3K4K5K6K7K8K9K:K;K<K=K>K?K@KAKBKCKDKEKFKGKHKIKJKKKLKMKNKOKPKQKRKSKTKUKVKWKXKYKZK[K\K]K^K_K`KaKbKcKdKeKfKgKhKiKjKkKlKmKnKoKpKqKrKsKtKuKvKwKxKyKzK{K|K}K~KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKL LLLLLLLLL	L
LLLLLLLLLLLLLLLLLLLLLL L!L"L#L$L%L&L'L(L)L*L+L,L-L.L/L0L1L2L3L4L5L6L7L8L9L:L;L<L=L>L?L@PLALBTLCLDLEWLFLGX]LHLILJLKLLLMLNLOLPLQ^LRLSLTLULVLWLXLYLZL[L\L]L^L_L`kLaLbnLcLdLeqLfLgLhLisLjLktuLlLmLnyLoLpLqLrLsLtLuLvLwLxLyLzL{L|L}L~LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLM MMMMMMMMM	M
MMMMMMMMMMMMMMMMMMMMMM M!M"M#M$M%M&M'M(M)M*M+M,M-M.M/M0M1M2M3M4M5M6M7M8M9M:M;M<M=M>M?M@MAMBMCMDMEMFMGMHMIMJMKMLMMMNMOMPMQMRMSMTMUMVMWMXMYMZM[M\M]M^M_M`MaMbMcMdMeMfMgMhMiMjMkMlMmMnMoMpMqMrMsMtMuMvMwMxMyMzM{M|M}M~MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMeMMMMMMM@ABCDEFGHMMMMMMMMMMMMMMMMMMMMMMMMMMMMMabfgMMMMMMM`cdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN NNNNNNNNN	N
NNNNNNNNNNNNNNNNNNNNNN N!N"N#N$N%N&N'N(N)N*N+N,N-N.N/N0N1N2N3N4N5N6N7N8N9N:N;N<N=N>N?N@NANBNCNDNENFNGNHNINJNKNLNMNNNONPNQNRNSNTNUNVNWNXNYNZN[N\N]N^N_N`NaNbNcNdNeNfNgNhNiNjNkNlNmNnNoNpNqNrNsNtNuNvNwNxNyNzN{N|N}N~NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNZNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNO OOOOOOOOO	O
OOOOOOOOOOOOOOOOOOOOOO O!O"O#O$O%O&O'O(O)O*O+O,O-O.O/O0O1O2O3O4O5O6O7O8O9O:O;O<O=O>O?O@OAOBOCODOEIOFOGOHOIOJOKOLOMONOOOPOQOROSOTOUOVOWOXOYOZO[O\O]O^O_O`OaObOcOdOeOfOgOhOiOjOkOlOmOnOoOpOqOrOsOtOuOvOwOxOyOzO{O|O}O~OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOP PPPPPPPPP	P
PPPPPPPPPPPPPPPPPPPPPP P!P"P#P$P%P&P'P(P)P*P+P,P-P.P/JKP0P1P2P3P4P5P6P7P8P9P:P;LMNP<P=OP>P?P@PAPBPCPDPEPFPGPHPIPJPKPLPMPNPOPPPQPRPSPTPUPVPWPXPYPZP[P\P]P^P_PP`PaPbPcPdPePfPgPhQPiPjRSPkPlTPmPnPoPpPqPrPsPtPuPvPwPxPyPzP{P|P}P~PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPVPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPQ QQQQQQQQUQ	Q
QQQQQQQQQQQQQQQQQQQQQQ Q!Q"Q#Q$Q%Q&Q'Q(Q)Q*Q+Q,Q-Q.Q/Q0Q1Q2Q3Q4Q5Q6Q7Q8Q9Q:Q;Q<Q=Q>Q?Q@QAQBQCQDQEQFQGQHQIQJQKQLQMQNQOQPQQQRQSQTQUQVQWQXQYQZQ[Q\Q]Q^Q_Q`QaQbQcQdQeQfQgQhQiQjQkQlQmQnQoQpQqQrQsQtQuQvQwQxQyQzQ{Q|Q}Q~QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQR RRRRRRRRR	R
RRRRRRRRRRRRRRRRRRRRRR R!R"R#R$R%R&R'R(R)R*R+R,R-R.R/R0R1R2ZR3R4R5R6R7R8R9R:R;R<R=R>R?R@RARBRCRDRERFRGRHRIRJRKRLRMRNRORPRQRRRSRTRURVRWRXRYRZR[R\R]R^R_R`RaRbRcRdReRfRgRhRiRjRkRlRmRnRoRpRqRrRsRtRuRvRwRxRyRzR{R|R}R~RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR\RRRRRRRRRRR[RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRS SSSSSSSSS	S
SSSSSSSSSSSSSSSSSSSSSS S!S"S#S$S%S&S'S(S)S*S+S,S-S.S/S0S1S2S3S4S5S6S7S8S9S:S;S<S=S>S?S@SASBSCSDSESFSGSHSISJSKSLSMSNSOSPSQSRSSSTSUSVSWSXSYSZS[S\S]S^S_S`SaSbScSdSeSfSgShSiSjSkSlSmSnSoSpSqSrSsStSuSvSwSxSySzS{S|S}S~SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSST TTTTTTTTT	T
TTTTTTTTTTTTTTTTTTTTTT T!T"T#T$T%T&T'T(T)T*T+T,T-T.T/T0T1T2T3T4T5T6T7T8T9T:T;T<T=T>T?T@TATBTCTDTETFTGTHTITJTKTLTMTNTOTPTQTRTSTTTUTVTWTXTYTZT[T\T]T^T_T`TaTbTcTdTeTfTgThTiTjTkTlTmTnToTpTqTrTsTtTuTvTwTxTyTzT{T|T}T~TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTU UUUUUUUUU	U
UUUUUUUUUUUUUUUUUUUUUU U!U"U#U$U%U&U'U(U)U*U+U,U-U.U/U0U1U2U3U4U5U6U7U8U9U:U;U<U=U>U?U@UAUBUCUDUEUFUGUHUIUJUKULUMUNUOUPUQURUSUTUUUVUWUXUYUZU[U\U]U^U_U`UaUbUcUdUeUfUgUhUiUjUkUlUmUnUoUpUqUrUsUtUuUvUwUxUyUzU{U|U}U~UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU`UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU_UV VVVVVVVVV	V
VVVVVVVVVVVVVVVVVVVVVV V!V"V#V$V%V&V'V(V)V*V+V,V-V.V/V0V1V2V3V4V5V6V7V8V9V:V;V<V=V>V?V@VAVBVCVDVEVFVGVHVIVJVKVLVMVNVOVPVQVRVSVTVUVVVWVXVYVZV[V\V]V^beV_V`VaVbVcVdVeVfVgVhViVjVkVlcVmVnVoVpVqVrVsVtVuVvVwVxVyVzV{V|V}V~VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVdW WWWWWWWWW	W
WWWWWWWWWWWWWWWWWWWWWW W!W"W#W$W%W&W'W(W)W*W+W,W-W.W/W0W1W2W3W4W5W6W7W8W9W:W;W<W=W>W?W@WAWBWCWDWEWFWGWHWIWJWKWLWMWNWOWPWQWRWSWTWUWVWWWXWYWZW[W\W]W^W_W`WaWbWcWdWeWfWgWhWiWjWkWlWmWnWoWpWqWrWsWtWuWvWwWxWyWzW{W|W}W~WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWhWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWX XXXXXXXXX	X
XXXXXXXXXXXXXXXXXXXXXX X!X"X#X$X%X&X'X(X)X*X+X,X-X.X/X0X1X2X3X4X5X6X7X8X9X:X;X<X=X>X?X@XAXBXCXDXEXFXGXHXIXJXKXLXMXNXOXPXQXRXSXTXUXVXWXXXYXZX[X\X]X^X_X`XaXbXcXdXeXfXgXhXiXjXkXlXmXnXoXpXqXrXsXtXuXvXwXxXyXzX{X|X}X~XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiXXXXXXXY YYYYYYYYY	Y
YYYYYYYYYYYYYYYYYYYYYY Y!Y"Y#Y$Y%Y&Y'Y(Y)Y*Y+Y,Y-Y.Y/Y0Y1Y2Y3Y4Y5Y6Y7Y8Y9Y:Y;Y<Y=Y>Y?Y@YAYBYCYDYEYFYGYHYIYJYKYLYMYNYOYPYQYRYSYTYUYVYWYXYYYZY[Y\Y]Y^Y_Y`YaYbYcYdYeYfYgYhYijYjYkYlYmYnYoYpYqYrYsYtYuYvYwYxYyYzY{Y|Y}Y~YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYZ ZZZZZZZZZ	Z
ZZZZZZZZZZZZZZZZZZZZZZ Z!Z"Z#Z$Z%Z&Z'Z(Z)Z*Z+Z,Z-Z.Z/Z0Z1Z2Z3Z4Z5Z6Z7Z8Z9Z:Z;Z<Z=Z>Z?Z@ZAZBZCZDZEZFZGZHZIZJZKZLZMZNZOZPZQZRZSZTZUZVZWZXZYZZZ[Z\Z]Z^Z_Z`ZaZbZcZdZeZfZgZhZiZjZkZlZmZnZoZpZqZrZsZtZuZvZwZxZyZzZ{Z|Z}Z~ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ[ [[[[[[[[[	[
[[[[[[[[[[[[[[[[[[[[[[ [!["[#[$[%[&['[([)[*[+[,[-[.[/[0[1[2[3[4[5[6[7[8[9[:[;[<[=[>[?[@[A[B[C[D[E[F[G[H[I[J[K[L[M[N[O[P[Q[R[S[T[U[V[W[X[Y[Z[[[\[][^[_[`[a[b[c[d[e[f[g[h[i[j[k[l[m[n[o[p[q[r[s[t[u[v[w[x[y[z[{[|[}[~[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[\ \\\\\\\\\	\
\\\\\\\\\\\\\\\\\\\\\\ \!\"\#\$\%\&\'\(\)\*\+\,\-\.\/\0\1\2\3\4\5\6\7\8\9\:\;\<\=\>\?\@\A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z\[\\\]\^\_\`\a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z\{\|\}\~\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\] ]]]]]]]]]	]
]]]]]]]]]]]]]]]]]]]]]] ]!]"]#]$]%]&]'](])]*]+],]-].]/]0]1]2]3]4]5]6]7]8]9]:];]<]=]>]?]@]A]B]C]D]E]F]G]H]I]J]K]L]M]N]O]P]Q]R]S]T]U]V]W]X]Y]Z][]\]]]^]_]`]a]b]c]d]e]f]g]h]i]j]k]l]m]n]o]p]q]r]s]t]u]v]w]x]y]z]{]|]}]~]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]p]]]]]]]]]]]]]]]]]]]]]]]]]^ ^^^^^^^^^	^
^^^^^^^^^^^^^^^^^^^^^^ ^!^"^#^$^%^&^'^(^)^*^+^,^-^.^/^0^1^2^3^4^5^6^7^8^9^:^;^<^=^>^?^@^A^B^C^D^E^F^G^H^I^J^K^L^M^N^O^P^Q^R^S^T^U^V^W^X^Y^Z^[^\^]^^^_^`^a^b^c^d^e^f^g^h^i^j^k^l^m^n^o^p^q^r^s^t^u^v^w^x^y^z^{^|^}^~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^_ _________	_
______________________ _!_"_#_$_%_&_'_(_)_*_+_,_-_._/_0_1_2_3_4_5_6_7_8_9_:_;_<_=_>_?_@_A_B_C_D_E_F_G_H_I_J_K_L_M_N_O_P_Q_R_S_T_U_V_W_X_Y_Z_[_\_]_^___`_a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z_{_|_}_~_______________________________________________________________r__________________________________________________________________` `````````	`
`````````````````````` `!`"`#`$`%`&`'`(`)`*`+`,`-`.`/`0`1x`2`3`4`5w`6`7`8`9`:`;`<`=`>`?`@`A`B`C`D`E`F`G`H`I`J`K`L`M`N`O`P`Q`R`S`T`U`V`W`X`Y`Z`[`\`]`^`_``z`a`b`c`d`e`f`g`h`i`j`k`l`m`n`o`p`q`r`s`t`u`v`w`x`y`z`{`|`}`~`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````a aaaaaaaaa	a
aaaaaaaaaaaaaaaaaaaaaa a!a"a#a$a%a&a'a(a)a*a+a,a-a.a/a0a1a2a3a4a5a6a7a8a9a:a;a<a=a>a?a@aAaBaCaDaEaFaGaHaIaJaKaLaMaNaOaPaQaRaSaTaUaVaWaX{aYaZa[a\a]a^a_a`aaabacadaeafagahaiajakalamanaoapaqarasatauavawaxayaza{a|a}a~aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab bbbbbbbbb	b
bbbbbbbbbbbbbbbbbbbbbb b!b"b#b$b%b&b'b(b)b*b+b,b-b.b/b0b1b2b3b4b5b6b7b8b9b:b;b<b=b>b?b@bAbBbCbDbEbFbGbHbIbJbKbLbMbNbObPbQbRbSbTbUbVbWbXbYbZb[b\b]b^b_b`babbbcbdbebfbgbhbibjbkblbmbnbobpbqbrbsbtbubvbwbxbybzb{b|b}b~bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb}bbbbbbbbbbbbbbbbbbbb|bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc ccccccccc	c
cccccccccccccccccccccc c!c"c#c$c%c&c'c(c)c*c+c,c-c.c/c0c1c2c3c4c5c6c7c8c9c:c;c<c=c>c?c@cAcBcCcDcEcFcGcHcIcJcKcLcMcNcOcPcQcRcScTcUcVcWcXcYcZc[c\c]c^c_c`cacbcccdcecfcgchcicjckclcmcncocpcqcrcsctcucvcwcxcyczc{c|c}c~cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccd ddddddddd	d
dddddddddddddddddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_d`dadbdcdddedfdgdhdidjdkdldmdndodpdqdrdsdtdudvdwdxdydzd{d|d}d~ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddde eeeeeeeee	e
eeeeeeeeeeeeeeeeeeeeee e!e"e#e$e%e&e'e(e)e*e+e,e-e.e/e0e1e2e3e4e5e6e7e8e9e:e;e<e=e>e?e@eAeBeCeDeEeFeGeHeIeJeKeLeMeNeOePeQeReSeTeUeVeWeXeYeZe[e\e]e^e_e`eaebecedeeefegeheiejekelemeneoepeqereseteuevewexeyeze{e|e}e~eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef fffffffff	f
ffffffffffffffffffffff f!f"f#f$f%f&f'f(f)f*f+f,f-f.f/f0f1f2f3f4f5f6f7f8f9f:f;f<f=f>f?f@fAfBfCfDfEfFfGfHfIfJfKfLfMfNfOfPfQfRfSfTfUfVfWfXfYfZf[f\f]f^f_f`fafbfcfdfefffgfhfifjfkflfmfnfofpfqfrfsftfufvfwfxfyfzf{f|f}f~fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffg ggggggggg	g
gggggggggggggggggggggg g!g"g#g$g%g&g'g(g)g*g+g,g-g.g/g0g1g2g3g4g5g6g7g8g9g:g;g<g=g>g?g@gAgBgCgDgEgFgGgHgIgJgKgLgMgNgOgPgQgRgSgTgUgVgWgXgYgZg[g\g]g^g_g`gagbgcgdgegfggghgigjgkglgmgngogpgqgrgsgtgugvgwgxgygzg{g|g}g~gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggh hhhhhhhhh	h
hhhhhhhhhhhhhhhhhhhhhh h!h"h#h$h%h&h'h(h)h*h+h,h-h.h/h0h1h2h3h4h5h6h7h8h9h:h;h<h=h>h?h@hAhBhChDhEhFhGhHhIhJhKhLhMhNhOhPhQhRhShThUhVhWhXhYhZh[h\h]h^h_h`hahbhchdhehfhghhhihjhkhlhmhnhohphqhrhshthuhvhwhxhyhzh{h|h}h~hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhi iiiiiiiii	i
iiiiiiiiiiiiiiiiiiiiii i!i"i#i$i%i&i'i(i)i*i+i,i-i.i/i0i1i2i3i4i5i6i7i8i9i:i;i<i=i>i?i@iAiBiCiDiEiFiGiHiIiJiKiLiMiNiOiPiQiRiSiTiUiViWiXiYiZi[i\i]i^i_i`iaibicidieifigihiiijikiliminioipiqirisitiuiviwixiyizi{i|i}i~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiij jjjjjjjjj	j
jjjjjjjjjjjjjjjjjjjjjj j!j"j#j$j%j&j'j(j)j*j+j,j-j.j/j0j1j2j3j4j5j6j7j8j9j:j;j<j=j>j?j@jAjBjCjDjEjFjGjHjIjJjKjLjMjNjOjPjQjRjSjTjUjVjWjXjYjZj[j\j]j^j_j`jajb@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~jcjdjejfjgjhjijjjkjljmjnjojpYafgm~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~e                     eX[]^_eeeeeeeeeeeeee      eeeee  eeeeeee  eeee    eeee    eeeeeeee  eeeeeee  eeeeeeeeeeeeeeee    eeeeeeeeeeeeee  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvw wwwwwwwww	w
wwwwwwwwwwwwwwwwwwwwww w!w"w#w$w%w&w'w(w)w*w+w,w-w.w/w0w1w2w3w4w5w6w7w8w9w:w;w<w=w>w?w@wAwBwCwDwEwFwGwHwIwJwKwLwMwNwOwPwQwRwSwTwUwVwWwXwYwZw[w\w]w^w_w`wawbwcwdwewfwgwhwiwjwkwlwmwnwowpwqwrwswtwuwvwwwxwywzw{w|w}w~wwwwwwwwwwwwwwwww@ABCwDwEFwwwGwwwwwwHIJwKLwwMNOwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwx xxxxxxxxx	x
xxxxxxxxxxxxxxxxxxxxxx x!x"x#x$x%x&x'x(x)x*x+x,x-x.x/x0x1x2x3x4x5x6x7x8x9x:x;x<x=x>x?x@xAxBxCxDxExFxGxHxIxJxKxLxMxNxOxPxQxRxSxTxUxVxWxXxYxZx[x\x]x^x_x`xaxbxcxdxexfxgxhxixjxkxlxmxnxoxpxqxrxsxtxuxvxwxxxyxzx{x|x}x~xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy yyyyyyyyy	y
yyyyyyyyyyyyyyyyyyyyyy y!y"y#y$y%y&y'y(y)y*y+y,y-y.y/y0y1y2y3y4y5y6y7y8y9y:y;y<y=y>y?y@yAyByCyDyEyFyGyHyIyJyKyLyMyNyOyPyQyRySyTyUyVyWyXyYyZy[y\y]y^y_y`yaybycydyeyfygyhyiyjykylymynyoypyqyrysytyuyvywyxyyyzy{y|y}y~yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyz zzzzzzzzz	z
zzzzzzzzzzzzzzzzzzzzzz z!z"z#z$z%z&z'z(z)z*z+z,z-z.z/z0z1z2z3z4z5z6z7z8z9z:z;z<z=z>z?z@zAzBzCzDzEzFzGzHzIzJzKzLzMzNzOzPzQzRzSzTzUzVzWzXzYzZz[z\z]z^z_z`zazbzczdzezfzgzhzizjzkzlzmznzozpzqzrzsztzuzvzwzxzyzzz{z|z}z~zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz{ {{{{{{{{{	{
{{{{{{{{{{{{{{{{{{{{{{ {!{"{#{${%{&{'{({){*{+{,{-{.{/{0{1{2{3{4{5{6{7{8{9{:{;{<{={>{?{@{A{B{C{D{E{F{G{H{I{J{K{L{M{N{O{P{Q{R{S{T{U{V{W{X{Y{Z{[{\{]{^{_{`{a{b{c{d{e{f{g{h{i{j{k{l{m{n{o{p{q{r{s{t{u{v{w{x{y{z{{{|{}{~{{{{{{{{{{{{{{{{{{{{{{{{{{{U{{{{{hijklmnopq{rstu{vwxyz{|}~{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{| |||||||||	|
|||||||||||||||||||||| |!|"|#|$|%|&|'|(|)|*|+|,|-|.|/|0|1|2|3|4|5|6|7|8|9|:|;|<|=|>|?|@|A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|[|\|]|^|_|`|a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|{|||}|~|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||VW||||||||||||||||||||||||||  GB18030//   Q  R  S  l  v    outbufstart == ((void *)0)  ../iconv/skeleton.c (state->__count & 7) <= sizeof (state->__value) ../iconv/loop.c inptr - bytebuf > (state->__count & 7)  inend != &bytebuf[4]    inend - inptr > (state->__count & ~7)   inend - inptr <= sizeof (state->__value)    outbuf == outerr    nstatus == __GCONV_FULL_OUTPUT  inend - *inptrp < 4 to_gb18030_single   from_gb18030_single gconv                
                                                   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ,                          T,                         D o8     <     \  
                    (                      H         oL  o   o.  o                                           