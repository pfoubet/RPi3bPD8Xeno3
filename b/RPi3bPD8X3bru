 state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_last_accepting_cpos);
				yy_current_state = (yy_last_accepting_state);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap( ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	register char *source = (yytext_ptr);
	register int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), (size_t) num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart(yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
	register yy_state_type yy_current_state;
	register char *yy_cp;
    
	yy_current_state = (yy_start);
	yy_current_state += YY_AT_BOL();

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 166 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
	register int yy_is_jam;
    	register char *yy_cp = (yy_c_buf_p);

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 166 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 165);

	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (yy_c_buf_p) - (yytext_ptr);
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart(yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap( ) )
						return EOF;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer(yyin,YY_BUF_SIZE );
	}

	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
	yy_load_buffer_state( );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state( );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer(b,file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree((void *) b->yy_ch_buf  );

	yyfree((void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;
    
	yy_flush_buffer(b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state( );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state( );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state( );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
	int num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
								  
		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
				
		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		int grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * 
 * @return the newly allocated buffer state object. 
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer(b  );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * 
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
{
    
	return yy_scan_bytes(yystr,strlen(yystr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = _yybytes_len + 2;
	buf = (char *) yyalloc(n  );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer(buf,n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg )
{
    	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
int yyget_lineno  (void)
{
        
    return yylineno;
}

/** Get the input stream.
 * 
 */
FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 * 
 */
FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 * 
 */
int yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 * 
 */

char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param line_number
 * 
 */
void yyset_lineno (int  line_number )
{
    
    yylineno = line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * 
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  in_str )
{
        yyin = in_str ;
}

void yyset_out (FILE *  out_str )
{
        yyout = out_str ;
}

int yyget_debug  (void)
{
        return yy_flex_debug;
}

void yyset_debug (int  bdebug )
{
        yy_flex_debug = bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    (yy_buffer_stack) = 0;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = (char *) 0;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (void)
{
    
    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer(YY_CURRENT_BUFFER  );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state();
	}

	/* Destroy the stack itself. */
	yyfree((yy_buffer_stack) );
	(yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * s )
{
	register int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
	return (void *) malloc( size );
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
}

void yyfree (void * ptr )
{
	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 260 "dtc-lexer.l"



static void push_input_file(const char *filename)
{
	assert(filename);

	srcfile_push(filename);

	yyin = current_srcfile->f;

	yypush_buffer_state(yy_create_buffer(yyin,YY_BUF_SIZE));
}


static bool pop_input_file(void)
{
	if (srcfile_pop() == 0)
		return false;

	yypop_buffer_state();
	yyin = current_srcfile->f;

	return true;
}

static void lexical_error(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	srcpos_verror(&yylloc, "Lexical error", fmt, ap);
	va_end(ap);

	treesource_error = true;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     cmd_scripts/genksyms/parse.tab.o := gcc -Wp,-MD,scripts/genksyms/.parse.tab.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89    -Iscripts/genksyms -c -o scripts/genksyms/parse.tab.o scripts/genksyms/parse.tab.c

source_scripts/genksyms/parse.tab.o := scripts/genksyms/parse.tab.c

deps_scripts/genksyms/parse.tab.o := \
  /usr/include/stdc-predef.h \
  /usr/include/assert.h \
  /usr/include/features.h \
  /usr/include/arm-linux-gnueabihf/sys/cdefs.h \
  /usr/include/arm-linux-gnueabihf/bits/wordsize.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs-hard.h \
  /usr/include/stdlib.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h \
  /usr/include/arm-linux-gnueabihf/bits/waitflags.h \
  /usr/include/arm-linux-gnueabihf/bits/waitstatus.h \
  /usr/include/endian.h \
  /usr/include/arm-linux-gnueabihf/bits/endian.h \
  /usr/include/arm-linux-gnueabihf/bits/byteswap.h \
  /usr/include/arm-linux-gnueabihf/bits/types.h \
  /usr/include/arm-linux-gnueabihf/bits/typesizes.h \
  /usr/include/arm-linux-gnueabihf/bits/byteswap-16.h \
  /usr/include/arm-linux-gnueabihf/sys/types.h \
  /usr/include/time.h \
  /usr/include/arm-linux-gnueabihf/sys/select.h \
  /usr/include/arm-linux-gnueabihf/bits/select.h \
  /usr/include/arm-linux-gnueabihf/bits/sigset.h \
  /usr/include/arm-linux-gnueabihf/bits/time.h \
  /usr/include/arm-linux-gnueabihf/sys/sysmacros.h \
  /usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h \
  /usr/include/alloca.h \
  /usr/include/arm-linux-gnueabihf/bits/stdlib-bsearch.h \
  /usr/include/arm-linux-gnueabihf/bits/stdlib-float.h \
  /usr/include/string.h \
  /usr/include/xlocale.h \
  /usr/include/arm-linux-gnueabihf/bits/string.h \
  /usr/include/arm-linux-gnueabihf/bits/string2.h \
  scripts/genksyms/genksyms.h \
  /usr/include/stdio.h \
  /usr/include/libio.h \
  /usr/include/_G_config.h \
  /usr/include/wchar.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio_lim.h \
  /usr/include/arm-linux-gnueabihf/bits/sys_errlist.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio.h \

scripts/genksyms/parse.tab.o: $(deps_scripts/genksyms/parse.tab.o)

$(deps_scripts/genksyms/parse.tab.o):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ELF          (             M     4     (     Rã
  
p@-é 0 ã`Ñç@ áP á0ÁçŸå  áşÿÿë`Äçp€½è  á Ÿåşÿÿê      á Ÿåşÿÿê     áà-å"Ä áĞMâ"8 áràïæ|ÀïæŸå Àås0ïæàå", áşÿÿëĞâğä    0@-é,ĞMâ(ÀâPâ é @ á  å0å è è  áşÿÿë •è „è,Ğâ0€½è0@-é @ áĞMâPâ å  á ”èşÿÿë •è „èĞâ0€½è  Rãp@-é @ áĞMâ` á    áşÿÿë   áPâ `å å  á ”èşÿÿë •è 0 ã 0å „è  á ”èşÿÿë •è „èĞâp€½è0@-é @ áĞMâPâ å  á ”èşÿÿë •è „èĞâ0€½è ãñÿÿê ãïÿÿê ãíÿÿê8@-é @Qâ P á    ê@”å  Tã  
  Ôå  Rãùÿÿ ”åDŸå  áşÿÿë ”å  á4Ÿåşÿÿë@”å  Tãñÿÿ ã0 á Ÿå  ãşÿÿë  á ã8@½èˆÿÿêp   |   \   8@-é  ã 0 á P á@ ád Ÿå ãşÿÿë  á ãzÿÿë  Tã  8€½è@”å  Tã  
  Ôå  Rãùÿÿ ”å(Ÿå  áşÿÿë ”å  áŸåşÿÿë@”å  Tãñÿÿ8€½è„   œ   ¬   8@-é @Qâ P á    ê@”å  Tã  
  Ôå  Rãùÿÿ ”åDŸå  áşÿÿë ”å  á4Ÿåşÿÿë@”å  Tãñÿÿ ã0 á Ÿå  ãşÿÿë  á ã8@½èCÿÿêp   |   ¸   <@Ÿå -é ãà-åĞMâÀâ 0”å  ã  ŸåÀåşÿÿë  ”åå åşÿÿë  ãşÿÿë    Ğ   @-é Àaâ  å0å0bàƒàAâà0å‚à Qá€å€½˜  Ÿåİÿÿëà   ğC-éĞMâÀâ ` á ŒèP á@åpå  Tã    ê@”å  Tã  
 0”å Sãùÿÿ€”å”å  áÜŸå  áşÿÿë  á  á	0 áÈŸåşÿÿë@”å  Tãîÿÿ Uã0 ‘ @ “  š€Gâ @ ã ¸å@„â  á4 áÿ8â<ƒá" á"<ƒáÿâƒá åìşÿë0dà SãğÿÿŠ  Sã  
€‡à Øä  áPŸåşÿÿë0hà0‡à  Sã÷ÿÿÊ0àá0…à@„â  Sã@„  Tá  Ğâğƒ½è ŸåŸå¿  ã0Ÿåşÿÿëp        0  @      ğA-é € á PåĞMâ  Uã` á  Úpå @ ã  ê@„â Tá  
  á‡àşÿÿë  Pã÷ÿÿ  áĞâğ½è P ã  áşÿÿëpâ `å ˜è@ á €â å  áşÿÿë —è ˆè  áĞâğ½è8@-é@ á ‘åP á0à Pá  :  á  áşÿÿë 0”åPƒà P„å8€½è  ŸåTÿÿëà   0å  åà-å0bà ãĞMâ  á    á åâ0 ãáÿÿë  å4 áÿ8â<ƒá" á"<ƒáÿ â  ƒáĞâğä ŸåŸå Ÿå0ŸåşÿÿëX  @  æ     ğO-é @ á   ã,ĞMâ á  áP á  áşÿÿë”å € ã ` á ”å 0 á Sá«  * Óä€ˆâ  Rãùÿÿşÿÿë0”å ã€ƒà€„å p á  á*ÿÿë ãp†o  ¥0 á@°â0â0å  áºÿÿë0@â SãñŸ—b  êŒ  H  €  \  °  °  °  °  T    á,Ğâğ½è8Ÿåüşÿë  [ãéÿÿ,2Ÿå ã0  ã 0“å Ÿåşÿÿëâÿÿê0–å  Sã  
2ŸåŸå ã<  ã 0“åşÿÿë  á”ÿÿë € á  á‘ÿÿë  ™å™å à‚à Rá 0 “0 ƒ Qá0ƒ“  Sãe   0Òç  Sã  
Àâ Rá 0 “0 ƒ Qá0ƒ“  Sã0 áY   0ÓåÀŒâ  Sãóÿÿ  áşÿÿë0å Xã 0 “0‚  Sã   áF   0 ã  Xã0å 0å$0åÀâ,  0â€å€å€å “è
  áşÿÿë  á  áşÿÿëŸÿÿê	 á  á  á0 áwÿÿë  á  áşÿÿë–ÿÿê  áè Ÿå¤şÿë
  áşÿÿë á € á   á
  áşÿÿë0 á  Pã'    Úå/ Rã  
0ˆâ ‡àşÿÿë †å}ÿÿê Úå  Rãøÿÿ
öÿÿê  á €å œèÀåşÿÿë  å0 á ”å„âÿÿë  á ã”şÿëÀå€å0â œè ƒèÃÿÿê  á ã‹şÿë´ÿÿê0 Ÿåuşÿë  á( Ÿårşÿë á
  á Ÿånşÿë      @  °  t  à   ğ  „  p@-é0 á<PŸå@ á ` á  á0Ÿåşÿÿë  á0 á  á Ÿåşÿÿë  á  á0 áŸåp@½èşÿÿê´  ¤  ¸  À  ğO-é À áĞMâ` áP á ‘å å,œå  á@ å0å2ÿ/á šå0•å â  á ’   ‘3ÿ/á0•å  á ã3ÿ/á0å@“å  Tã¶ 
€å p ã 0Ôå  Sã$  ”åŸå	  áşÿÿë	 á  Pã  áp ™şÿë0•å”å  á  á3ÿ/á 0•å  á”å3ÿ/á 0•å	 á  á3ÿ/á0šå ã  
0”å Sãb Ê0„â  á “èÀ•å<ÿ/á0•å  á ã3ÿ/á@”å  TãÔÿÿšå! á!ââp‡áÿâa 
0å@“å  Tã    ê@”å  Tã  
 0Ôå  Sãùÿÿ  á  å á  á0åœÿÿë@”å  Tãóÿÿ6Ÿå 0“å  Sã0 
@å<0”å  SãF  
0•å  á  ã3ÿ/á0•å  áàŸå   ã3ÿ/á0•å  á ã3ÿ/á<p”å  Wã@  0  ê0—å€“å  áşÿÿë á0•å   á  á3ÿ/á0•å  á ã3ÿ/áp—å  Wã   
0—å “åşÿÿë 0—å“å € á  á-şÿë0•å  ã  á  á3ÿ/áˆâ 0•å  á3ÿ/á 0•å	 á  á3ÿ/á0šå£0 á Xã 0 Ó0Â  SãÓÿÿ
0•å  á ã3ÿ/áÎÿÿê0•å  á  ã3ÿ/á@å80”å  Sãs  
0•å  á  ã3ÿ/á0•å  á¸Ÿå   ã3ÿ/á0•å  á ã3ÿ/á80”å  Sã^  
”tŸå á å°™å  [ãÜ  
  á @ ã0šå “å 0Ğå  Sã€   
şÿÿë € á0šå@„â@„à “åşÿÿë šå  Zã  „à @€âíÿÿ  áşÿÿë €Pâ 
@ˆà  á0›å ›åjà0“å ’å
  á ÀÓå  å  ›å  \ã0  åè#Ÿåşÿÿë
  áşÿÿë°›å  [ã €â  Šàêÿÿ
@hà°Dâ [ã   Ó  Ã@å ™å å¾ıÿëÀ•å  ã @ á  á<ÿ/áå À•å  á<ÿ/á  •å á  á2ÿ/á0å “å¢0
à ã    á0•å  á á3ÿ/á0•å  á ã3ÿ/á  áşÿÿë™å  Yã¤ÿÿ å å0•å  á,’å3ÿ/á@å@0”å  Sãi  
0•å  á  ã3ÿ/á0•å  áäŸå   ã3ÿ/á0•å  á ã3ÿ/á@p”å  Wãš  
 á @ ã0™å “å 0Ğå  Sã€   
şÿÿë € á0™å@„â@„à “åşÿÿë™å  Yã  „à @€âíÿÿ  áşÿÿë °Pâ  
T‚Ÿå@‹à á0—å —åià0“å ’å	  á ÀÓå  å  —å  \ã0  å"Ÿåşÿÿë	  áşÿÿëp—å  Wã €â ‰àêÿÿ	kà@Aâ Tã á p Óp ÃèŸå åKıÿë0•å  ã € á  á3ÿ/á	 á 0•å  á3ÿ/á 0•å á  á3ÿ/á0šå£0à ãK    á0•å  á á3ÿ/á0•å ã  á3ÿ/á  áşÿÿë å0•å  á,’å3ÿ/á å0•å  á,’åĞâğO½èÿ/á0•å  á ã3ÿ/á—şÿê0•å  á ã3ÿ/álÿÿê  áşÿÿë €Pâ9  
  á°å °àãOÿÿê0•å  á3ÿ/á0å  á“å 0•åâ3ÿ/á´Ÿå å @•åıÿë  á  á4ÿ/á0šå ã0å “å  
 Rã  Êå0•å  á‘å3ÿ/á0•å  á ã3ÿ/á|şÿêp ásşÿê0•å  á ã3ÿ/á®ÿÿê  áşÿÿë °Pâ	  
 á @àã“ÿÿê0•å  á ã3ÿ/á0å “åàÿÿê  ŸåcüÿëĞ      Ø  ä  Ì      $  ğ  ğO-é À ã,æŸåÔĞMâ€ á0 á` á á åxÀå|Àå€ÀåÀå”Àå˜ÀåœÀå Àå¤Àå ç Pá` 0ƒâP Sãùÿÿ  Vãn 
 ˜å 0Ğå  Sã0â 
0åœ0â(0å å	 ã¼ûÿë P˜å 0 ã Uá¨@â¨0å¬0å°0å  
 På  á ”èşÿÿëP•å  Uãøÿÿh¥Ÿå 0šå  Sã0PÒ  ÚX•Ÿå p ã0Pâ å  á ”èşÿÿë •èp‡â 0šå Wá „èõÿÿº0˜å ”è,0å¨0åpå á$0å„0âœ€å ƒèÿ ã(  ã  áşÿÿë0–å‰â  á ‚â Êã
à ‡à ˆàÄ á ´ áÿ¸â ¼‹áÿÈâ0å<Œá Ì‹á Àå"Ìƒá
4 áÿ8â –å´ á
<ƒá*<ƒáÿ¸âl å*¤ áà–å¼‹áÿ¬
âd å"$ á!¼‹á
0ƒáhå	¤ á! áÿ,â Œáÿâÿ¨
â‹á	¬Šá´ á´ å)$ áÿ,â)¬Šáÿ¸â Šá¼‹á.$ áÿ,â.¼‹á Ä á°‹á` å –å  åÿÌâ¸0åü3ŸåÀ€á ã¬Àå°åtå¼ åpàåÀ°å¨0å	  
, å\ å 4 áÿ8â <ƒá  á <ƒáÿâ0ƒáÄ0å ã  
4 áÿ8â<ƒá( á(<ƒáÿâ0ƒáX€åÈ0å  ã  
4 áÿ8â<ƒá'$ á'<ƒáÿ,â0ƒáTpåÌ0åT3Ÿå 0“å  Sãª  Út áÿxâ|‡á,$ á,‡áÿ,âpápSàDÀå«  J 3Ÿå €“å  Xã¬ÀÅg  Ú4 áÿ8â<ƒá,ä á,<ƒáÿìâàƒáààx`â4 áÿ8â<ƒá.$ á å.<ƒá  ãÿ,â @å å@ƒáxå|å  á –èPàåLÀå¬@åşÿÿëÀ ã –è  á Àåşÿÿë •è$0å„0å„0â †è “è è  á –èşÿÿë •è0 ã 0å †è  á –èşÿÿë •è0å †è “è è  á –èşÿÿë •è(0å †è “è è  á –èşÿÿë •è €å †è  á –èşÿÿë •è †èxPå|@åpå  á á  ã0 áşÿÿë PãL  
  áşÿÿë  Pã  
şÿÿë  åşÿÿë  á Ÿå-ûÿëœŸå+ûÿë  á0å `åœ0âˆŸå(0åÔüÿëêşÿê  WãR  Êx`â0å @å0å  á –èşÿÿëÀ ã –è  á Àåşÿÿë •è$0å„0å„0â †è “è è  á –èşÿÿë •è0 ã 0å †è  á –èşÿÿë •è0å †è “è è  á –èşÿÿë •è(0å †è “è è  á –èşÿÿë •è †èxPå|@å¯ÿÿêœ0Ÿå €“å  Xã_ÿÿÊÈÿÿêxPå|@å –èşÿÿëÔĞâğ½è€ Ÿå  ’å  RãOÿÿÊtŸå$ áÿ(â,‚á  ‘å, á,,‚áÿâ ‚áTŸåHÀåşÿÿë0–å0å@ÿÿê á< ŸåÎúÿë¬Àå€ á?ÿÿê            Ğşí        €  ¤  P           T  ,  œÆŸåğA-é à ãĞMâ€ á0 á P áp á áàåàåàå œç Páp 0ƒâP Sãùÿÿ  Wã‘ 
)  ã0 á ãDŸåşÿÿë  á<Ÿå;üÿë  á4Ÿå8üÿë  ã0 á ã$Ÿåşÿÿë  áŸåØùÿë ã  ã0 áŸåşÿÿë&ŸåŸå0 á  áşÿÿëô%ŸåøŸå0 á  áşÿÿëà%ŸåèŸå0 á  áşÿÿëÌ%ŸåØŸå0 á  áşÿÿë ã  ã0 áÀŸåşÿÿë¤%Ÿå¸Ÿå0 á  áşÿÿë%Ÿå¨Ÿå0 á  áşÿÿë|%Ÿå˜Ÿå0 á  áşÿÿëh%ŸåˆŸå0 á  áşÿÿë ã  ã0 ápŸåşÿÿë@%ŸåhŸå0 á  áşÿÿë,%ŸåXŸå0 á  áşÿÿë%ŸåHŸå0 á  áşÿÿë%Ÿå8Ÿå0 á  áşÿÿë ã  ã0 á ŸåşÿÿëÜ$ŸåŸå0 á  áşÿÿëÈ$ŸåŸå0 á  áşÿÿë´$ŸåøŸå0 á  áşÿÿë $ŸåèŸå0 á  áşÿÿë  ã0 á ãĞŸåşÿÿë  á —ålùÿë0 á ã  ã´Ÿåşÿÿë  á—ådùÿë0—å ãÀ   ãÉ    ãã    ã„Ÿå  áşÿÿë  áxŸå®ûÿëtŸå ã*  ã0 áşÿÿë `˜å  VãW  
@–å  Tã    ê@”å  Tã  
 0Ôå  Sãùÿÿ ”å,Ÿå  áşÿÿë ”å  áŸåşÿÿë@”å  Tãñÿÿ –åŸå  áşÿÿë –åüŸå  áşÿÿë –åğŸå  áşÿÿë –åäŸå  áşÿÿë  –åÈŸå  áşÿÿë  –å¼Ÿå  áşÿÿë  –å°Ÿå  áşÿÿë  –å¤Ÿå  áşÿÿë –åˆŸå  áşÿÿë –å|Ÿå  áşÿÿë –åpŸå  áşÿÿë –ådŸå  áşÿÿë –åHŸå  áşÿÿë –å<Ÿå  áşÿÿë –å0Ÿå  áşÿÿë –å  á Ÿåşÿÿë`–å  Vã§ÿÿcŸå 0–å  Sã @ Ã  Ú0 áüŸå ã  ãşÿÿë 0–å@„â SáöÿÿÊ0 á ã  ãĞŸåşÿÿë  áÈŸå8ûÿë ˜å€â 0Ğå  Sã{  
  ã0 á ã¤Ÿåşÿÿë  á	 ãÓøÿë  áŸå(ûÿë  áˆŸå%ûÿë@åpåp„à Tá
  *  áşÿÿë  ádŸå ` á`†â  á@„àşÿÿë Táôÿÿ:  áDŸåûÿë  á<Ÿåûÿë82Ÿå  “å  Rã  Úˆ1Ÿå  á 0å Ÿåşÿÿë2Ÿå  “å  Rã  Ú  áŸåşÿÿë  áŸåüúÿë ˜èşÿÿëĞâğ½è0 á ã  ãäŸåşÿÿë  á˜å˜øÿë0—å ã5ÿÿ
 ã  ã0 á¼Ÿåşÿÿëü Ÿå´Ÿå0 á  áşÿÿëè Ÿå¤Ÿå0 á  áşÿÿëÔ Ÿå”Ÿå0 á  áşÿÿëÀ Ÿå  á0 á|Ÿåşÿÿë0—å  ãÿÿ
0 á ã  ã`ŸåşÿÿëŒ Ÿå  á0 áPŸåşÿÿëx Ÿå  á0 á@Ÿåşÿÿëd Ÿå  á0 á0ŸåşÿÿëP Ÿå  á$Ÿå0 áşÿÿëÿÿê på0 áŸå  áÉúÿë}ÿÿê á Ÿåùÿë    È  ô       íşĞ  ´  ,  h  ¤  à    ,  h  ¤  à    ,  h  ¤  à    ,  h  ¤  à    $     d
  p
  p   |   œ
  ¼
  Ü
  ü
        0  @  P  \  „  l  x      ”      È  Ø  @  X  p  °  ğ  ,	  d	  |	  ¸	  ô	  0
  l   ,  ğO-é  ãCßMâşÿÿë ã  ã 0 á ` áŒ âşÿÿë @ á  áşÿÿë  Pã“   Tãj ÚŒ å¨&Ÿå” å 4 áÿ8â <ƒá  á <ƒáÿâ0ƒá SáŒ0å‚  ã  ã0 á âşÿÿë @ á  áşÿÿë  Pã‚   TãW Úpå˜på4 áÿ8â<ƒá' á'<ƒáÿ|âpƒá Wãpå` š  áşÿÿë 0Pâx0åY 
Œ å4 áÿ8â $ áÿ(âxàå ,‚á Ä á<ƒá' á ,‚áÿÌâ'<ƒáÿâĞ§Íá ‚á0ƒá@GâPâ påœ å è  áşÿÿë  Pã6  ã  á0 á  áşÿÿë p á  áşÿÿë  Pã/ @TàP…àîÿÿx0åğ§Íá@å€“åp“åà“åÄ áÿÈâP“å “åÌŒá(” á á(ÌŒáÿœ	âÿ â	Œá€á'Ä á4 á  á'€á á$ áÿ8âÿÌâÿâÿ(â<ƒáÀ€á. áá
,‚á.<ƒá¬€å¤på%„ á*t áÿ â%á*,‚áÿŒâÿ|â 0ƒá	 Tá¨Påá° å ‚á´àå„0å# š Tá š Tá! : Rãx0å$  š à“å¸àå áÿ â€á.4 á.€áÿ<â0€á0ƒà Táõ  :x å Rã€à0€ààåèåä0åÿ  šx å$å¼å$ áÿ(â,‚á!4 á!,‚áÿ<â0‚á0ƒà Táù  :@  ã0€à| å  êƒà  ã0ƒààåèåä0å| åx å p ã	‚àÀ‚à  áìåôåÔÀåÜÀåğ0åØ0å€`ålpå  êşÿÿë  ál åşÿÿël åğ åôâø â0 ãøÿë !åø0åÀ å áÿ âÈ0åT åË İå| á4 áÿ8âD åÃ İå40å< áÊ İå ` ãüå0`åd åÂ İåĞCÍáÌåL0å4 áÏ İå<0åH`åP`å 0 ã  á@„áP…á@„áP…á\åĞ%ÍáØÍáÌ€İåÁå8`åØ£ÍáÄÀå €áÇ İå(Ä á Šá°‹á  ‚á
@ áÄ İåP áX`å@`åÀåØ¥Íáá 0 ã0ƒá Šá°‹á
  á0 áĞ¤Íá``å Ä á Šá°‹á
@ áP áĞ¦ÍáÀåÌ áÍ€İå  á ÀåÅ İå Šá°‹á
  á0 áĞ Íá(È áÀåå È á Šá°‹á
@ áP á$ÀåØ¡ÍáÈ áÎ€İå  áÆ İåÀå Šá°‹á
  á0 á(Ì áØ ÍáÀå å Ì á  á,Àå(åÄ áĞ‚Íá Šá°‹áØBÍáÀå€ˆá‰áĞÍá@„á	P…á  á0 á
 €ááÀ’áÌâøÍáğ ÌátÿÿÔ â€`ålpåøÿë Pã1  |0åàâL!ŸåÔ â3øÿë @ áÔ âøÿë	 Pã*  x åşÿÿë  áşÿÿë  á á„ åşÿÿëCßâğ½è  áşÿÿë  Pã  
ø ŸåR÷ÿë  áşÿÿë  Pã  
ä ŸåL÷ÿëà ŸåJ÷ÿëÜ ŸåH÷ÿëØ ŸååE÷ÿëşÿÿë  åşÿÿë  áÀ Ÿå?÷ÿë¼ Ÿå=÷ÿë á´ Ÿå:÷ÿë  á¬ Ÿå7÷ÿë¨ Ÿå5÷ÿë¤ Ÿå3÷ÿë  Ÿå1÷ÿëşÿÿë  åşÿÿë  áŒ Ÿå+÷ÿëˆ Ÿå)÷ÿëşÿÿë  åşÿÿë  át Ÿå#÷ÿë Rãx0å@  ƒ  “0ƒà| åÿÿêT Ÿå÷ÿëP Ÿå÷ÿëL Ÿå÷ÿëíşĞt    ¤  4  À    4  ğ  ì  (  x  Ô  `  è  „  „  ü  P  ¬                                 $            $   X         (   x                                                           asm_emit_data   flat_read_word  	.string	"%s"
  	.balign	%d, 0
 	.byte 0x%02x; .byte 0x%02x; .byte 0x%02x; .byte 0x%02x
    	/* FDT_PROP */
    	.globl	%s
 %s:
    	/* FDT_END_NODE */
    	.globl	%s_end
 %s_end:
    	/* FDT_BEGIN_NODE */
  FATAL ERROR:    Premature end of data parsing flat device tree
 %s	= . + %d
    	.byte	0x%hhx
  off == d.len    scripts/dtc/flattree.c  ((inb->ptr - inb->base) % sizeof(val)) == 0 Path "%s" is not valid as a child of "%s"
  Warning: Flat tree input has subnodes preceding a property.
    String offset %d overruns string table
 Premature FDT_END in device tree blob
  Warning: NOP tag found in flat tree version <16
    Invalid opcode word %08x in device tree blob
   	.globl	%s_%s
  dt  %s_%s:
 _%s_%s:
    /   name    __symbols__ __fixups__  malloc() failed
    %s:%s:%d    __local_fixups__    fixup   Unknown device tree blob version %d
    Warning: blob size %d >= minimum size %d
   Error writing device tree blob: %s
 Short write on device tree blob
    /* autogenerated by dtc, do not edit */

   blob_start  header  	/* magic */
   	/* totalsize */
   	.byte	((_%s_blob_abs_end - _%s_blob_start) >> 24) & 0xff
  	.byte	((_%s_blob_abs_end - _%s_blob_start) >> 16) & 0xff
  	.byte	((_%s_blob_abs_end - _%s_blob_start) >> 8) & 0xff
   	.byte	(_%s_blob_abs_end - _%s_blob_start) & 0xff
  	/* off_dt_struct */
   	.byte	((_%s_struct_start - _%s_blob_start) >> 24) & 0xff
  	.byte	((_%s_struct_start - _%s_blob_start) >> 16) & 0xff
  	.byte	((_%s_struct_start - _%s_blob_start) >> 8) & 0xff
   	.byte	(_%s_struct_start - _%s_blob_start) & 0xff
  	/* off_dt_strings */
  	.byte	((_%s_strings_start - _%s_blob_start) >> 24) & 0xff
 	.byte	((_%s_strings_start - _%s_blob_start) >> 16) & 0xff
 	.byte	((_%s_strings_start - _%s_blob_start) >> 8) & 0xff
  	.byte	(_%s_strings_start - _%s_blob_start) & 0xff
 	/* off_mem_rsvmap */
  	.byte	((_%s_reserve_map - _%s_blob_start) >> 24) & 0xff
   	.byte	((_%s_reserve_map - _%s_blob_start) >> 16) & 0xff
   	.byte	((_%s_reserve_map - _%s_blob_start) >> 8) & 0xff
    	.byte	(_%s_reserve_map - _%s_blob_start) & 0xff
   	/* version */
 	/* last_comp_version */
   	/* boot_cpuid_phys */
 	/* size_dt_strings */
 	.byte	((_%s_strings_end - _%s_strings_start) >> 24) & 0xff
    	.byte	((_%s_strings_end - _%s_strings_start) >> 16) & 0xff
    	.byte	((_%s_strings_end - _%s_strings_start) >> 8) & 0xff
 	.byte	(_%s_strings_end - _%s_strings_start) & 0xff
    	/* size_dt_struct */
  	.byte	((_%s_struct_end - _%s_struct_start) >> 24) & 0xff
  	.byte	((_%s_struct_end - _%s_struct_start) >> 16) & 0xff
  	.byte	((_%s_struct_end - _%s_struct_start) >> 8) & 0xff
   	.byte	(_%s_struct_end - _%s_struct_start) & 0xff
  reserve_map /* Memory reserve map from source file */
  	.byte	((0x%08x) >> 24) & 0xff
 	.byte	((0x%08x) >> 16) & 0xff
 	.byte	((0x%08x) >> 8) & 0xff
  	.byte	(0x%08x) & 0xff
 	.long	0, 0
	.long	0, 0
    struct_start    	/* FDT_END */
 struct_end  strings_start   strings_end blob_end    	.string "%s"
  	.space	%d - (_%s_blob_end - _%s_blob_start), 0
    	.space	%d, 0
  blob_abs_end    Error reading DT blob magic number: %s
 EOF reading DT blob magic number
   Mysterious short read reading magic number
 Blob has incorrect magic number
    Error reading DT blob size: %s
 EOF reading DT blob size
   Mysterious short read reading blob size
    DT blob size (%d) is too small
 EOF before reading %d bytes of DT blob
 Error reading DT blob: %s
  Mem Reserve structure offset exceeds total size
    DT structure offset exceeds total size
 String table offset exceeds total size
 String table extends past total size
   Structure block extends past total size
    Device tree blob doesn't begin with FDT_BEGIN_NODE (begins with 0x%08x)
        Device tree blob doesn't end with FDT_END
   GCC: (Raspbian 4.9.2-10) 4.9.2 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .rel.text .rel.data .bss .rodata .rodata.str1.4 .comment .note.GNU-stack .ARM.attributes                                ñÿ                                                               D        @             D          "   D           P             T          1   T   @                     ”          ?   ”   @     M   Ô   0     \     h     l   l  0     z   œ       Œ   ¤          ¬       °   ´  ˆ        0            <         Â   <  Œ        ¼            È         Ó   È  ˆ        D            P         æ   P  L        ”            œ         ê   œ  @        Ø            Ü         ÷   Ü  L                   (           (  ”       ¼  D        ü                      /     €        p            €         >  €  4       $            H            ”	            ´	         M  ´	  \         
            
         d  
  Ô       À            ä                         T            ø            ü            ô&                                     x           ‘                        ª      P     ¸  P        Ä  l                                                  Ğ                        	                            
 İ             å             ö                                                     1             8             A             F             M             [             b             i             t             |             ‹             ˜             ¢             ª             ¸             ¿             È             Í             â  ä  p    í             ü                                       !             (             9             B             L             W             _             g             m  T  ¨    w  ü  H    „             š                           ¥             ¹             Ë             Ò              flattree.c $a asm_emit_string $d asm_emit_align asm_emit_cell bin_emit_data bin_emit_align bin_emit_string bin_emit_cell bin_emit_property bin_emit_endnode bin_emit_beginnode asm_emit_property asm_emit_endnode asm_emit_beginnode die flat_realign asm_emit_data stringtable_insert flat_read_chunk.isra.4 flat_read_word unflatten_tree emit_label.constprop.7 flatten_tree.part.3 __PRETTY_FUNCTION__.6780 __PRETTY_FUNCTION__.6975 version_table bin_emitter asm_emitter null_re.6886 fprintf data_append_data data_append_align strlen data_append_byte data_append_cell fwrite vfprintf exit stderr __assert_fail strcmp memcpy build_node xstrdup build_property add_property add_child strncmp data_grow_for malloc snprintf free symbol_fixup_support dt_to_blob data_append_re memset data_merge data_append_zeroes ferror __errno_location strerror data_free reservenum minsize padsize quiet dt_to_asm dt_from_blob srcfile_relative_open fread feof build_reserve_entry add_reserve_entry fclose build_boot_info   (   N  <   N  @   G  L   N  P   G  „   N     G  À   O  ğ   P     Q  <  O  X  R  ˆ  S  ì  N  ü  N    T  0  G  4  G  8  G  X  T  ˜  N  ¨  N  ¼  G  À  G  Ä  G     N    N  0  T  D  G  H  G  L  G  x  T  ˆ  U    V  ”  W  ˜  G  Ø  G  4  N  H  N  Ä  N    X    G    G    G    G     G  $  ?  d  Y  „  Q  ¤  O  à  Z  ü  G  l  X  p  G  t  G  |  ?     [  Ğ  \  $    (    ,    0    4    8    <    @    D    x  T     T  $  \  x  ]  „  ^  ¨  _  À  Q  Ô  `  ø  \  $	  a  ”	  G  ˜	  W  œ	  G   	  G  ¤	  G  ¨	  G  ¬	  G  °	  G  Ğ	  N  ä	  N  ü	  N   
  G  
  G  
  G  
  G  ¨
  Y    Q  X  Q  l  Q  „  Q     b  è  c  ğ  Q  œ  d  4  Q  L  Q  h  b  ´  c  ¼  Q  d  d  Ä  b  „  b  À  G  Ä  e  È  G  Ì  G  Ğ  G  Ô  G  Ø  G  Ü  G  à  G  ¤  g  à  g  0  h  Œ  O     P  È  i  ä  j    i  $  i  <  j  d  T  t  k  €  l  ˆ  m  à  O  ô  P    i  8  j  X  i  x  i  °  n  ø  N       $  o  (    0  p  4  q  8  G  <  G  @    D  r  H  W  L  G  P  G  ´  T  à  T     T    N  (  N  <  N  P  N  d  T  x  N  Œ  N     N  ´  N  È  T  Ü  N  ğ  N    N    N  ,  T  @  N  T  N  h  N  |  N    T  °  T  è  N    T  L  N  \  N  x  N  ˆ  N  ˜  N  ¨  N  ¸  N  È  N  Ø  N  è  N  ø  N    N    N  (  N  8  N  H  N  X  N  h  N  œ  T  À  T  ô  T  4  Q  P  N  ”  N  °  N  Ä  n  à  T    T     N  4  N  H  N  \  N  |  T    N  ¤  N  ¸  N  Ì  N  ø    ü  G     G    G    G    G    G    G    G     G  $  G  (  G  ,  G  0  G  4  G  8  G  <  G  @  G  D  G  H  G  L  G  P  G  T  G  X  G  \  G  `  G  d  G  h  G  l  G  p  G  t  G  x  G  |  G  €  G  „  G  ˆ  G  Œ  G    o  ”  G  ˜  G  œ  G     G  ¤  G  ¨  G  ¬  G  °  G  ´  p  ¸  G  ¼  q  À  G  Ä  G  È  G  Ì  G  Ğ  G  Ô  G  Ø  G  Ü  G  à  G  ä  G  è  G  ì  G  ğ  G  ô    ø  G     u      v  ,   k  „   v     k  Ø   b  D!  w  `!  v  l!  k  X#  x  d#  y  È%  d  Ğ%  z  à%  {  ğ%  w  &  w  8&  l  @&  m  ˆ&  l  &  m  ¨&  l  °&  m  ø&  G  ü&  G   '  G  '  G  '  G  '  G  '  G  '  G  '  G  '  G   '  G  $'  G  ('  G  ,'  G  0'  G  4'  G  8'  G  <'  G  @'  G  P     T     X     \     `     d     h     l     p     t   	  x   %  |     €     „                                                          4   D'                    	   @       0C   
              )             x'  ˆ                  %   	   @       0M  p               /              (                    4              (                     <      2        (  ¤                K      0       Ä6                    T              ä6                     d     p        ä6  1                                7  t                                Œ7  À     N         	              L?  â                                                                 ELF          (            ¨     4     (  	 <@Ÿå -é ãà-åĞMâÀâ 0”å  ã  ŸåÀåşÿÿë  ”åå åşÿÿë  ãşÿÿë        ğO-élĞMâ ` áşÿÿë PPâc  
   ã  áşÿÿë˜‘Ÿå€â p á  áşÿÿë  Pã  
 Ğå. Rã  
@€â á  áşÿÿë â  á   á  ãşÿÿë  PãD  º 0å:â	Sã  
	Sã(  

  áşÿÿë  áşÿÿë  Pãåÿÿ  áşÿÿë  álĞâğ½è Ğå  RãÙÿÿ
. RãŞÿÿ Ğå  RãÔÿÿ
Úÿÿê
  áÜŸåşÿÿë °Pâ  
  áşÿÿë á< å @ á  áşÿÿë ˜è  áşÿÿë  á  áşÿÿë  áşÿÿëÖÿÿê
  á°ÿÿë ° á  áşÿÿë  á  áşÿÿë  á  áşÿÿëÊÿÿêşÿÿë @™å  åşÿÿëPŸå
  á 0 á  áşÿÿëÀÿÿêşÿÿë  åşÿÿë
 á   á( Ÿå‚ÿÿëşÿÿë  åşÿÿë á   á Ÿå{ÿÿë    @   D   0      @-é‡ÿÿëŸåşÿÿë @ áşÿÿë á@½è   á   ãşÿÿêd   FATAL ERROR:    Couldn't opendir() "%s": %s
    stat(%s): %s
   rb  WARNING: Cannot open %s: %s
         GCC: (Raspbian 4.9.2-10) 4.9.2 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .rel.text .data .bss .rodata.str1.4 .comment .note.GNU-stack .ARM.attributes                                ñÿ                                          
                     L        D          
   L             L   Ø                
   $            P                                                                                              '              0              5              <              D              O              W              a              j              o              x              ~              †              •              ¤              ±              ¸              Â              Ì              İ              æ              î   $  0     ù              
              fstree.c $a die $d read_fstree fwrite vfprintf exit stderr opendir build_node readdir join_path __lxstat free closedir fopen xstrdup data_copy_file build_property add_property fclose name_node add_child __errno_location strerror fprintf dt_from_fs guess_boot_cpuid build_boot_info   (     8     @     D     H     X     l     €     ¤     ¸     à     è     ø     4    D    X    d     p  !  x  "      œ  #  ¨  $  °  %  ¼  &  Ğ  '  Ø  %  à  &  ô  %  ü  &                       0  #  8  )  L  *  P                                                         4   T                    	   @       x  0  
            %             ˆ                     +             ˆ                     0      2       ˆ  h                 ?      0       ğ                    H                                   X     p          1                                A  h                                ¬  °              	              \                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           cmd_scripts/genksyms/lex.lex.o := gcc -Wp,-MD,scripts/genksyms/.lex.lex.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89    -Iscripts/genksyms -c -o scripts/genksyms/lex.lex.o scripts/genksyms/lex.lex.c

source_scripts/genksyms/lex.lex.o := scripts/genksyms/lex.lex.c

deps_scripts/genksyms/lex.lex.o := \
  /usr/include/stdc-predef.h \
  /usr/include/stdio.h \
  /usr/include/features.h \
  /usr/include/arm-linux-gnueabihf/sys/cdefs.h \
  /usr/include/arm-linux-gnueabihf/bits/wordsize.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs-hard.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h \
  /usr/include/arm-linux-gnueabihf/bits/types.h \
  /usr/include/arm-linux-gnueabihf/bits/typesizes.h \
  /usr/include/libio.h \
  /usr/include/_G_config.h \
  /usr/include/wchar.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio_lim.h \
  /usr/include/arm-linux-gnueabihf/bits/sys_errlist.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio.h \
  /usr/include/string.h \
  /usr/include/xlocale.h \
  /usr/include/arm-linux-gnueabihf/bits/string.h \
  /usr/include/arm-linux-gnueabihf/bits/string2.h \
  /usr/include/stdlib.h \
  /usr/include/errno.h \
  /usr/include/arm-linux-gnueabihf/bits/errno.h \
  /usr/include/linux/errno.h \
  /usr/include/arm-linux-gnueabihf/asm/errno.h \
  /usr/include/asm-generic/errno.h \
  /usr/include/asm-generic/errno-base.h \
  /usr/include/arm-linux-gnueabihf/bits/waitflags.h \
  /usr/include/arm-linux-gnueabihf/bits/waitstatus.h \
  /usr/include/endian.h \
  /usr/include/arm-linux-gnueabihf/bits/endian.h \
  /usr/include/arm-linux-gnueabihf/bits/byteswap.h \
  /usr/include/arm-linux-gnueabihf/bits/byteswap-16.h \
  /usr/include/arm-linux-gnueabihf/sys/types.h \
  /usr/include/time.h \
  /usr/include/arm-linux-gnueabihf/sys/select.h \
  /usr/include/arm-linux-gnueabihf/bits/select.h \
  /usr/include/arm-linux-gnueabihf/bits/sigset.h \
  /usr/include/arm-linux-gnueabihf/bits/time.h \
  /usr/include/arm-linux-gnueabihf/sys/sysmacros.h \
  /usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h \
  /usr/include/alloca.h \
  /usr/include/arm-linux-gnueabihf/bits/stdlib-bsearch.h \
  /usr/include/arm-linux-gnueabihf/bits/stdlib-float.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include-fixed/limits.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include-fixed/syslimits.h \
  /usr/include/limits.h \
  /usr/include/arm-linux-gnueabihf/bits/posix1_lim.h \
  /usr/include/arm-linux-gnueabihf/bits/local_lim.h \
  /usr/include/linux/limits.h \
  /usr/include/arm-linux-gnueabihf/bits/posix2_lim.h \
  /usr/include/ctype.h \
  scripts/genksyms/genksyms.h \
  scripts/genksyms/parse.tab.h \
  /usr/include/unistd.h \
  /usr/include/arm-linux-gnueabihf/bits/posix_opt.h \
  /usr/include/arm-linux-gnueabihf/bits/environments.h \
  /usr/include/arm-linux-gnueabihf/bits/confname.h \
  /usr/include/getopt.h \
  scripts/genksyms/keywords.hash.c \

scripts/genksyms/lex.lex.o: $(deps_scripts/genksyms/lex.lex.o)

$(deps_scripts/genksyms/lex.lex.o):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #!/bin/bash

# objdiff - a small script for validating that a commit or series of commits
# didn't change object code.
#
# Copyright 2014, Jason Cooper <jason@lakedaemon.net>
#
# Licensed under the terms of the GNU GPL version 2

# usage example:
#
# $ git checkout COMMIT_A
# $ <your fancy build command here>
# $ ./scripts/objdiff record path/to/*.o
#
# $ git checkout COMMIT_B
# $ <your fancy build command here>
# $ ./scripts/objdiff record path/to/*.o
#
# $ ./scripts/objdiff diff COMMIT_A COMMIT_B
# $

# And to clean up (everything is in .tmp_objdiff/*)
# $ ./scripts/objdiff clean all
#
# Note: 'make mrproper' will also remove .tmp_objdiff

SRCTREE=$(cd $(git rev-parse --show-toplevel 2>/dev/null); pwd)

if [ -z "$SRCTREE" ]; then
	echo >&2 "ERROR: Not a git repository."
	exit 1
fi

TMPD=$SRCTREE/.tmp_objdiff

usage() {
	echo >&2 "Usage: $0 <command> <args>"
	echo >&2 "  record    <list of object files or directories>"
	echo >&2 "  diff      <commitA> <commitB>"
	echo >&2 "  clean     all | <commit>"
	exit 1
}

get_output_dir() {
	dir=${1%/*}

	if [ "$dir" = "$1" ]; then
		dir=.
	fi

	dir=$(cd $dir; pwd)

	echo $TMPD/$CMT${dir#$SRCTREE}
}

do_objdump() {
	dir=$(get_output_dir $1)
	base=${1##*/}
	dis=$dir/${base%.o}.dis

	[ ! -d "$dir" ] && mkdir -p $dir

	# remove addresses for a cleaner diff
	# http://dummdida.tumblr.com/post/60924060451/binary-diff-between-libc-from-scientificlinux-and
	$OBJDUMP -D $1 | sed "s/^[[:space:]]\+[0-9a-f]\+//" > $dis
}

dorecord() {
	[ $# -eq 0 ] && usage

	FILES="$*"

	CMT="`git rev-parse --short HEAD`"

	OBJDUMP="${CROSS_COMPILE}objdump"

	for d in $FILES; do
		if [ -d "$d" ]; then
			for f in $(find $d -name '*.o')
			do
				do_objdump $f
			done
		else
			do_objdump $d
		fi
	done
}

dodiff() {
	[ $# -ne 2 ] && [ $# -ne 0 ] && usage

	if [ $# -eq 0 ]; then
		SRC="`git rev-parse --short HEAD^`"
		DST="`git rev-parse --short HEAD`"
	else
		SRC="`git rev-parse --short $1`"
		DST="`git rev-parse --short $2`"
	fi

	DIFF="`which colordiff`"

	if [ ${#DIFF} -eq 0 ] || [ ! -x "$DIFF" ]; then
		DIFF="`which diff`"
	fi

	SRCD="$TMPD/$SRC"
	DSTD="$TMPD/$DST"

	if [ ! -d "$SRCD" ]; then
		echo >&2 "ERROR: $SRCD doesn't exist"
		exit 1
	fi

	if [ ! -d "$DSTD" ]; then
		echo >&2 "ERROR: $DSTD doesn't exist"
		exit 1
	fi

	$DIFF -Nurd $SRCD $DSTD
}

doclean() {
	[ $# -eq 0 ] && usage
	[ $# -gt 1 ] && usage

	if [ "x$1" = "xall" ]; then
		rm -rf $TMPD/*
	else
		CMT="`git rev-parse --short $1`"

		if [ -d "$TMPD/$CMT" ]; then
			rm -rf $TMPD/$CMT
		else
			echo >&2 "$CMT not found"
		fi
	fi
}

[ $# -eq 0 ] &&	usage

case "$1" in
	record)
		shift
		dorecord $*
		;;
	diff)
		shift
		dodiff $*
		;;
	clean)
		shift
		doclean $*
		;;
	*)
		echo >&2 "Unrecognized command '$1'"
		exit 1
		;;
esac
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ELF          (    $ 4   <4   4    (     pÜ  Ü Ü                4   4  4                 4  4 4                          è  è                     X  <                  è   è            P  P P D   D         Qåtd                          /lib/ld-linux-armhf.so.3             GNU                        GNU 1¹&6Q6›OW:	¹Ä€ìNä$            BIĞ2Aö‚ @@ D%                       
                                 3Ä÷|‹sx‹‡ÿ}í?~–|•ÅK.N=ö?ùÿ¼8ò‹#ù¤ûnÁ³÷!Ï	ıfII"³¢÷^–“	¬ù=­98èDêvş)Œ                ±                  X!                    :                                          ¨              –              ©              q   `!      )              #                 h!      H              \              j   l!      †                            O              V              x              A   d!       libc.so.6 exit fopen optind abort fgetc __errno_location getopt stdout fclose malloc raise __ctype_b_loc optarg stderr fwrite opterr strcmp strerror __libc_start_main vfprintf __gmon_start__ GLIBC_2.4                                      ii   À       D!   X!   `! 
  d!   h!   l!    !   !   !   !   !   !   !   !    !   $!   (!   ,! 	  0!   4!   8!   <!   @!   @-éò ë€½èà-åàŸåààğ¾åL  ÆâÊŒâLû¼å ÆâÊŒâDû¼å ÆâÊŒâ<û¼å ÆâÊŒâ4û¼å ÆâÊŒâ,û¼å ÆâÊŒâ$û¼å ÆâÊŒâû¼å ÆâÊŒâû¼å ÆâÊŒâû¼å ÆâÊŒâû¼å ÆâÊŒâüú¼å ÆâÊŒâôú¼å ÆâÊŒâìú¼å ÆâÊŒâäú¼å ÆâÊŒâÜú¼å ÆâÊŒâÔú¼å ÆâÊŒâÌú¼åğO-éP á@JŸå@:Ÿå@zŸå@ŠŸå ‘åĞMâ ` á   ã „å  ƒå  á á *ŸåÚÿÿë pã  
h0@â SãñŸ—  ê      (      4 Ğ9Ÿå`Fâ 0“å Vá$  
Ø ë 0—å0„åßÿÿê 0—å 0ˆåÜÿÿê —å Ÿå	  áœÿÿë  Pã0 0ˆÔÿÿ
	  á„Ÿå•ÿÿë  Pã0 0ˆÍÿÿ
	  álŸåÿÿë  Pã0 0ˆÆÿÿ
	  áTŸå‡ÿÿë  Pãİÿÿ0 ã0ˆå¾ÿÿê1•ç8Ÿå  á0„å€ÿÿë iŸå PPâ. 
ÿÿëP Pã(   á™ÿÿë10@â  á SãñŸ—\  ê      ”åÜŸåŒ ë  á ë „å  á› ë „å p á  ágÿÿë  Pã € á$ „å `    ê ”å€ €à^ÿÿë  Pãˆç 
`†â Váöÿÿ2 Yã" 
3 Yã   á‚ ë0¸Ÿå 0 ã0å p á   á0”å å Rá/  * á ` ã"  ê$0›å  á††àÀ“ç`†âÀåo ëÿ0 ã á“  àS ëÀå$0›å	 Ìç0“ç  á	0ƒà0åc ëÿ0 ã á“  àG ë$›å0å Ãå0‘ç  á	ƒàX ëÿ0 ã á“  à< ë Éå0”å VáÙÿÿ:0å0ƒâ0åÎÿÿê”å„Ÿå5 ë  á5ÿÿëP7Ÿå0“å0Câ SãñŸ—À  ê@ °
 ô	 ¤	 `”åà”å$P”å À ã \á› 
 0 ã Sá•  
•çƒ ƒà€à Ğç ÑåÑå Pá Qs  
Ÿå ëÌ¦Ÿå 0 ã0å0”å å Rá3 *± á € ã0”å Xáx  * šå  Qãˆp c  
$0šåˆp á ‡àÀ“ç´Ÿå0Œà`ÜçPÓåàÓå À ã  êÀŒâ \á €âa  
0Ğå  ĞåĞå Rá S0  0  Yá 0 0  Sãïÿÿ
 \áS  
€ˆâÙÿÿê ”å€”å$”å p ã
 Wá¶  
 ` ã VáT  
™ç† †à0àPÑçàÓåÀÓåŸå   ã  ê €â Pãâg 
0Ñå  Ñå°Ñå Rá S0  0  [á 0 0  Sãïÿÿ
`†ââÿÿê`”åà”å$P”å À ã \á 
 0 ã Sá,  
•çƒ ƒà€à Ğç ÑåÑåp€áp‘á
  
ÿ Rãÿ P     ÿ Qã      Rã  TŸå¥ ë0ƒâçÿÿê0ƒâ~ÿÿê$ ”åp‡à0à ’ç0„àp‚àâ° ×á ×å „å¸Ãá* Ãå«ÿÿêà QãğÿÿŸå ë0å0ƒâ0åyÿÿêÀŒâËÿÿêÀŒâbÿÿêp‡â£ÿÿê0•å ã  ãÌŸåbşÿëˆ4Ÿå •åÀŸå  “å ` ãtşÿë(P…â`å  ê Uå ë Uå ë Uå ë`†â 0”åP…â Váôÿÿ:& ë   ã]şÿë ´Ÿå  ã0 ã0„å0”å Yá-ÿÿ*	q á ` ã  ê$0›å  á†€†à “ço ë`†â Šà @âp0ïæ0Âå0Âå0Êç0”å Váğÿÿ:‰âèÿÿê  áa ë¬£Ÿå   ã å 0 á å0å0”å å Ráÿÿ* á  ã  ê$ šå  á‰`‰àp’çO ëÿ0 ã åå°‡à‰â“  à0 ëp ïæ Ëå Ëå Çç ”å Yáìÿÿ:0å0ƒâ0åáÿÿêw ë 0 ã0å0”å å Rá´ÿÿ* € ã1 á0å°”å Xá=  *è2Ÿå åˆˆà$0“åãŸå À ã “ç  á	0Šà	pÚç`ÓåPÓå  êÀŒâ \ã €â  
0Ğå  ĞåĞå Rá S0  0  Qá 0 0  Sãïÿÿ
R á0ˆâ Sáu ïæ  *‰â	0Šà	pÚçÀÓå`Óå P ã  êP…â Uãàâ  
0Şå  ŞåŞå Rá S0  0  Qá 0 0  Sãïÿÿ
P€áu ïæ~ ë€ˆâ¾ÿÿê0å0ƒâ0å³ÿÿê( ëÜ‘Ÿå ` ã0”åĞQŸå VáLÿÿ*Q á p ã0”å Wá"  *  ™å  Pã  
$ ™å‡0‡àÔŸåà’ç À ã à Şç€ÒåàÒå  êÀŒâ  \áâ  
0Ñå  Ñå°Ñå
 Rá S0  0  [á 0 0  Sãïÿÿ
  á  €âp‡âp ïæJ ëÙÿÿê`†âÑÿÿê÷  ëŸå p ã0”å Wá5ÿÿ*a á P ãà”å ^á  š$ ˜å…À…à 0 ã ’ç  áÀ‚à…â€  ã  ê Uá0ƒâ  *ÜçP…â  Qã  ‚	 Uá¢  áõÿÿ( ëçÿÿêp‡âàÿÿêÕ  ë€Ÿå p ã0”å Wáÿÿ*a á P ã  ê$ ˜å…0…àP…â ’ç Òç ë0”å Uáöÿÿ:p‡âîÿÿê–åp Ÿåp  ëkıÿë@–å  åVıÿë á   áp Ÿåh  ël Ÿåf  ëaıÿë  åMıÿë  áX Ÿå`  ët! h! l! P! ° X! ¸ À È Ğ Ø  ø h œ! à L Ì   Ü \ t  ° ã à ãä  á -å -åÀŸåÀ-å Ÿå0Ÿå%ıÿëEıÿë¼ x X 0Ÿå Ÿå0à “ç  Rãÿ/ ıÿê„ P   0Ÿå Ÿå0`à Sãÿ/‘0Ÿå  Sãÿ/ÿ/á[! X!     $Ÿå$ Ÿå`àA á¡àÁ°áÿ/0Ÿå  Sãÿ/ÿ/áX! X!     @-é@Ÿå 0Ôå  Sã€½ßÿÿë0 ã 0Äå€½èp! @-é$ Ÿå 0å  Sã  @½èàÿÿê0Ÿå  Sãúÿÿ
3ÿ/áøÿÿê       -é$Ÿåà-åĞMâ0â  ‘å  áå0åúüÿë  ãæüÿë`! @-é0Ÿå Ÿå “åíÿÿët!  øC-é P á  ê×üÿë 0å p á¶ “á:âs0ÿæ  Sã  
  áİüÿë pã @ á!  
# Pã€` ïÿÿ  áÕüÿë pã @ á  

 Pãøÿÿ` ãæÿÿêl€Ÿå` á  ê1†à ˜åƒ0„à  Rã0`CâLŸå	    áÂüÿë pã @ á
  
  —å€0 á³ ’áãîÿÿ  áøƒ½è0Ÿå Ÿå“åµÿÿë™å Ÿå²ÿÿët! ô 8@-éü@Ÿå ”å  Pã0  
ğŸå‡üÿë  Pã 0 á „å.  
 ã  ãÔ Ÿå‚üÿë0”å ã  ãÄ Ÿå}üÿëÀPŸå0”å ã  ã´ Ÿåwüÿë ”å ”å¨Ÿå‹üÿë0”å ã  ã Ÿånüÿë  •å ”åˆŸå‚üÿë0”å ã  ãx Ÿåeüÿë ã  ã0”åh Ÿå`üÿë  •å ”å\Ÿå8@½èsüÿêT0Ÿå 0“å0„åĞÿÿêqüÿë@”å  å\üÿë á   á0 Ÿånÿÿët!  ( , P! H L x Œ ” ´ d!  @-é   áL@ŸåL0Ÿå”å ”å“1ÌàÁ? áÌ0càƒ0ƒàQá    Qã(Ÿ(ŸJüÿë0”å0ƒâ0„å€½èŸåDüÿëøÿÿêt! «ªª*ğ ü ä 8@-é ãÈ@ŸåÈPŸå  ã0”åÀ Ÿåüÿë  •å¸Ÿå ”å2üÿë°0Ÿå •å¬Ÿå ”å!“ç,üÿë ”åœŸå ”å(üÿë ”å ”åŒŸå$üÿë0•å Sã  
  •åxŸå ”åüÿë  ã0”åh Ÿå ã üÿë0”å4 Ÿå  Sã8€½ ’å8@½èüÿê  ”å ”å<Ÿåüÿë ”å4Ÿå  •å	üÿëæÿÿêt! P!   Ì 8 H X ” ¨ l €  Qâÿ/t  : Pák  š ál  
?oá/oá0Bà0sâƒ0ƒ   ãñ   áPá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ 
Pá ¢à
@ 
Pá ¢à
@ 	Pá ¢à	@ 	Pá ¢à	@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@  Pá ¢à @  Pá ¢à @   áÿ/á     ÿ/á/oá bâ0 áÿ/á  Pã  à  ê  Qãúÿÿ
@-é€ÿÿë@½è’ àAàÿ/á@-é  ãUûÿë€½èøC-é p áL`ŸåLPŸå`àPà`eà€ á áBûÿëFa°áøƒ½PEâ @ ã@„â0µå  á á	  á3ÿ/á Tá÷ÿÿøƒ½è” Œ ÿ/á@-é€½è      „ ” ¨ ¼      ª ª  ªªª  ª ªªU ªªªUUUUUÿUÿUUÿÿÿUUÿUÿÿÿUÿÿÿ
Usage: %s [options] <filename>

Valid options:
    -h          : display this usage information
    -n <name>   : specify logo name (default: linux_logo)
    -o <output> : output to file <output> instead of stdout
    -t <type>   : specify logo type, one of
                      mono    : monochrome black/white
                      vga16   : 16 colors VGA text palette
                      clut224 : 224 colors (default)
                      gray256 : 256 levels grayscale

    %s: end of file
    w   Cannot create file %s: %s
  /*
  *  DO NOT EDIT THIS FILE!
  *
  *  It was automatically generated from %s
  *  Linux logo %s
   */

   #include <linux/linux_logo.h>

 static unsigned char %s_data[] __initdata = {
  , 0x%02x    ,
	0x%02x   	0x%02x 
};

   const struct linux_logo %s __initconst = {
 	.type		= %s,
  	.width		= %d,
 	.height		= %d,
    	.clutsize	= %d,
   	.clut		= %s_clut,
 	.data		= %s_data
  };

    hn:o:t: mono    vga16   clut224 gray256 r   Cannot open file %s: %s
    %s is not a PNM file
   %s: Binary PNM is not supported
Use pnmnoraw(1) to convert it to ASCII PNM
 Image must use the 16 console colors only
Use ppmquant(1) -map clut_vga16.ppm to reduce the number of colors
   Image has more than %d colors
Use ppmquant(1) to reduce the number of colors
   static unsigned char %s_clut[] __initdata = {
  Image must be monochrome
   Image must be grayscale
    LINUX_LOGO_MONO LINUX_LOGO_VGA16    LINUX_LOGO_CLUT224  LINUX_LOGO_GRAY256  linux_logo  Hòÿ                                                                                                                                                                                                                                                                                                ì              Œ    À                        õşÿo”    ¼    L 
   Ê                   ô     ˆ                Ô    0         şÿÿo´ ÿÿÿo   ğÿÿo†                                                           ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜             Ğ    GCC: (Raspbian 4.9.2-10) 4.9.2 GCC: (Raspbian 4.8.4-1) 4.8.4 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.exidx .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .comment .ARM.attributes                     4           P           p           ”           L           ¼           †           ´           Ô      	           
     Œ           ˜           x           À           È           Ü           ä                                                            ô            H!           X!                                               ñÿJ   P        M   $        J   Ü        J   T        J   È        J   H!        P            ñÿM   `        ™   `       J   |        M   Œ        M   À        ¦            ñÿM   ”        M   Ä        ï            ñÿM   L        û   L 4     J   |        M   €        ÿ   €      J   ”        M   œ          œ ì     J   €        M   ˆ          ˆ <    J           M   Ä          Ä p     J            M   4        '  4     J           M   x        J   Ğ        M           J   ô        M           J   ”	        M   ¤	        J   È        J   Ì        4  Ì      ?  à 0     J   P!        J  P!      S  T!      J           J   t!        ]  t!      i  x!      r  |!        €!      Š  „!        ˆ!      œ  Œ!      §  !      ³  ”!      Á  ˜!      Ë  œ!      Õ           ñÿà          M   „        í  „       J   ¨        M   ´          ´       J   à        J   L!        M   ì          ì       J           +  p!      J            :          M           a         J   D        J             m           J   p!        Œ           ñÿM   <        —  <        ¯            ñÿµ           ñÿM   H        Á           ñÿM   X        J   ´        M   ¼        Õ           ñÿJ   ä        Í  ä       J            Û                       ñÿç           ø                        ô        M   ˜        J   ¨        M   ¬        *  ¼      :             K  <      Y             k              ‡  H!        ’  X!                     ±  <$       ¼  X!       Ã  À       É  X!      Û  <$       ç  `!      ù               H    "   H!       &             8             U             i              x  < ì   ‚  L!                   ¨             ¸  È      Ç             Ù             ì  X d     ü               <$         $       $             5  <$       =  H    " K  d!      ]  X!       i             {  x ¬
    €             ”  (      ¥              ¹  h!      Ë  X!      ×              ñ  l!                     Œ        /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crt1.o $d $a /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crti.o call_weak_fn /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crtn.o pnmtologo.c die usage get_number write_header write_hex write_footer logo_types clut_vga16 logoname logo_type programname filename is_plain_pbm outputname out write_hex_cnt logo_width logo_height logo_clutsize logo_data logo_clut crtstuff.c __JCR_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.9004 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry _udivsi3.o .udivsi3_skip_div0_test shift _dvmd_lnx.o elf-init.oS __FRAME_END__ __JCR_END__ __init_array_end _DYNAMIC __init_array_start _GLOBAL_OFFSET_TABLE_ __libc_csu_fini raise@@GLIBC_2.4 __aeabi_uidiv strcmp@@GLIBC_2.4 _ITM_deregisterTMCloneTable data_start __bss_start__ fopen@@GLIBC_2.4 _bss_end__ _edata _fini optind@@GLIBC_2.4 __bss_end__ stderr@@GLIBC_2.4 fwrite@@GLIBC_2.4 __aeabi_ldiv0 __data_start malloc@@GLIBC_2.4 __libc_start_main@@GLIBC_2.4 strerror@@GLIBC_2.4 __gmon_start__ __udivsi3 __dso_handle __ctype_b_loc@@GLIBC_2.4 exit@@GLIBC_2.4 _IO_stdin_used getopt@@GLIBC_2.4 fprintf@@GLIBC_2.4 __libc_csu_init __errno_location@@GLIBC_2.4 _end _start fgetc@@GLIBC_2.4 __end__ __aeabi_idiv0 stdout@@GLIBC_2.4 __bss_start fclose@@GLIBC_2.4 main vfprintf@@GLIBC_2.4 __aeabi_uidivmod _Jv_RegisterClasses opterr@@GLIBC_2.4 __TMC_END__ _ITM_registerTMCloneTable optarg@@GLIBC_2.4 abort@@GLIBC_2.4 _init                                                    4 4                    #         P P                     1         p p  $                  D   öÿÿo   ” ”  ¸                N         L L  p              V         ¼ ¼  Ê                  ^   ÿÿÿo   † †  .                k   şÿÿo   ´ ´                   z   	      Ô Ô  0                ƒ   	   B      ˆ               Œ         Œ Œ                    ‡         ˜ ˜  à                 ’         x x  H                 ˜         À À                             È È                   ¦     p‚   Ü Ü                   ±         ä ä                    »                                  Ç                                Ó                                Ø              è                á         ô  ô   T                 æ         H! H!                    ì         X! X!  ä                 ñ      0       X!  =                 ú     p        •!  1                                Æ!  
                               Ğ"  P     …         	               .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #
# Generated files
#
conmakehash
kallsyms
pnmtologo
unifdef
ihex2fw
recordmcount
docproc
sortextable
asn1_compiler
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # ==========================================================================
# Signing modules
# ==========================================================================

PHONY := __modsign
__modsign:

include scripts/Kbuild.include

__modules := $(sort $(shell grep -h '\.ko$$' /dev/null $(wildcard $(MODVERDIR)/*.mod)))
modules := $(patsubst %.o,%.ko,$(wildcard $(__modules:.ko=.o)))

PHONY += $(modules)
__modsign: $(modules)
	@:

quiet_cmd_sign_ko = SIGN [M] $(2)/$(notdir $@)
        cmd_sign_ko = $(mod_sign_cmd) $(2)/$(notdir $@)

# Modules built outside the kernel source tree go into extra by default
INSTALL_MOD_DIR ?= extra
ext-mod-dir = $(INSTALL_MOD_DIR)$(subst $(patsubst %/,%,$(KBUILD_EXTMOD)),,$(@D))

modinst_dir = $(if $(KBUILD_EXTMOD),$(ext-mod-dir),kernel/$(@D))

$(modules):
	$(call cmd,sign_ko,$(MODLIB)/$(modinst_dir))

# Declare the contents of the .PHONY variable as phony.  We keep that
# information in a variable se we can use it in if_changed and friends.

.PHONY: $(PHONY)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # ==========================================================================
# Installing dtb files
#
# Installs all dtb files listed in $(dtb-y) either in the
# INSTALL_DTBS_PATH directory or the default location:
#
#   $INSTALL_PATH/dtbs/$KERNELRELEASE
#
# Traverse through subdirectories listed in $(dts-dirs).
# ==========================================================================

src := $(obj)

PHONY := __dtbs_install
__dtbs_install:

export dtbinst-root ?= $(obj)

include include/config/auto.conf
include scripts/Kbuild.include
include $(src)/Makefile

PHONY += __dtbs_install_prep
__dtbs_install_prep:
ifeq ("$(dtbinst-root)", "$(obj)")
	$(Q)if [ -d $(INSTALL_DTBS_PATH).old ]; then rm -rf $(INSTALL_DTBS_PATH).old; fi
	$(Q)if [ -d $(INSTALL_DTBS_PATH) ]; then mv $(INSTALL_DTBS_PATH) $(INSTALL_DTBS_PATH).old; fi
	$(Q)mkdir -p $(INSTALL_DTBS_PATH)
endif

dtbinst-files	:= $(dtb-y)
dtbinst-dirs	:= $(dts-dirs)

# Helper targets for Installing DTBs into the boot directory
quiet_cmd_dtb_install =	INSTALL $<
      cmd_dtb_install =	mkdir -p $(2); cp $< $(2)

install-dir = $(patsubst $(dtbinst-root)%,$(INSTALL_DTBS_PATH)%,$(obj))

$(dtbinst-files) $(dtbinst-dirs): | __dtbs_install_prep

$(dtbinst-files): %.dtb: $(obj)/%.dtb
	$(call cmd,dtb_install,$(install-dir))

$(dtbinst-dirs):
	$(Q)$(MAKE) $(dtbinst)=$(obj)/$@

PHONY += $(dtbinst-files) $(dtbinst-dirs)
__dtbs_install: $(dtbinst-files) $(dtbinst-dirs)

.PHONY: $(PHONY)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #! /usr/bin/perl
#
# checkversion find uses of LINUX_VERSION_CODE or KERNEL_VERSION
# without including <linux/version.h>, or cases of
# including <linux/version.h> that don't need it.
# Copyright (C) 2003, Randy Dunlap <rdunlap@xenotime.net>

use strict;

$| = 1;

my $debugging;

foreach my $file (@ARGV) {
    next if $file =~ "include/linux/version\.h";
    # Open this file.
    open( my $f, '<', $file )
      or die "Can't open $file: $!\n";

    # Initialize variables.
    my ($fInComment, $fInString, $fUseVersion);
    my $iLinuxVersion = 0;

    while (<$f>) {
	# Strip comments.
	$fInComment && (s+^.*?\*/+ +o ? ($fInComment = 0) : next);
	m+/\*+o && (s+/\*.*?\*/+ +go, (s+/\*.*$+ +o && ($fInComment = 1)));

	# Pick up definitions.
	if ( m/^\s*#/o ) {
	    $iLinuxVersion      = $. if m/^\s*#\s*include\s*"linux\/version\.h"/o;
	}

	# Strip strings.
	$fInString && (s+^.*?"+ +o ? ($fInString = 0) : next);
	m+"+o && (s+".*?"+ +go, (s+".*$+ +o && ($fInString = 1)));

	# Pick up definitions.
	if ( m/^\s*#/o ) {
	    $iLinuxVersion      = $. if m/^\s*#\s*include\s*<linux\/version\.h>/o;
	}

	# Look for uses: LINUX_VERSION_CODE, KERNEL_VERSION, UTS_RELEASE
	if (($_ =~ /LINUX_VERSION_CODE/) || ($_ =~ /\WKERNEL_VERSION/)) {
	    $fUseVersion = 1;
            last if $iLinuxVersion;
        }
    }

    # Report used version IDs without include?
    if ($fUseVersion && ! $iLinuxVersion) {
	print "$file: $.: need linux/version.h\n";
    }

    # Report superfluous includes.
    if ($iLinuxVersion && ! $fUseVersion) {
	print "$file: $iLinuxVersion linux/version.h not needed.\n";
    }

    # debug: report OK results:
    if ($debugging) {
        if ($iLinuxVersion && $fUseVersion) {
	    print "$file: version use is OK ($iLinuxVersion)\n";
        }
        if (! $iLinuxVersion && ! $fUseVersion) {
	    print "$file: version use is OK (none)\n";
        }
    }

    close($f);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
#line 3 "scripts/genksyms/lex.lex.c_shipped"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 35
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;
#endif /* ! C99 */

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! FLEXINT_H */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined (__STDC__)

#define YY_USE_CONST

#endif	/* defined (__STDC__) */
#endif	/* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin  )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE 16384
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

    #define YY_LESS_LINENO(n)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */
    
	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart (FILE *input_file  );
void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
void yy_delete_buffer (YY_BUFFER_STATE b  );
void yy_flush_buffer (YY_BUFFER_STATE b  );
void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state (void );

static void yyensure_buffer_stack (void );
static void yy_load_buffer_state (void );
static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );

#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );

void *yyalloc (yy_size_t  );
void *yyrealloc (void *,yy_size_t  );
void yyfree (void *  );

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer(yyin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer(yyin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define yywrap(n) 1
#define YY_SKIP_YYWRAP

typedef unsigned char YY_CHAR;

FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;

typedef int yy_state_type;

extern int yylineno;

int yylineno = 1;

extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state (void );
static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
static int yy_get_next_buffer (void );
static void yy_fatal_error (yyconst char msg[]  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (size_t) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;

#define YY_NUM_RULES 13
#define YY_END_OF_BUFFER 14
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static yyconst flex_int16_t yy_accept[73] =
    {   0,
        0,    0,   14,   12,    4,    3,   12,    7,   12,   12,
       12,   12,   12,    9,    9,   12,   12,    7,   12,   12,
        4,    0,    5,    0,    7,    8,    0,    6,    0,    0,
       10,   10,    9,    0,    0,    9,    9,    0,    9,    0,
        0,    0,    0,    2,    0,    0,   11,    0,   10,    0,
       10,    9,    9,    0,    0,    0,   10,   10,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        1,    0
    } ;

static yyconst flex_int32_t yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        4,    4,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    5,    6,    7,    8,    9,   10,    1,
        1,    8,   11,    1,   12,   13,    8,   14,   15,   15,
       15,   15,   15,   15,   15,   16,   16,    1,    1,   17,
       18,   19,    1,    1,   20,   20,   20,   20,   21,   22,
        7,    7,    7,    7,    7,   23,    7,    7,    7,    7,
        7,    7,    7,    7,   24,    7,    7,   25,    7,    7,
        1,   26,    1,    8,    7,    1,   20,   20,   20,   20,

       21,   22,    7,    7,    7,    7,    7,   27,    7,    7,
        7,    7,    7,    7,    7,    7,   24,    7,    7,   25,
        7,    7,    1,   28,    1,    8,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst flex_int32_t yy_meta[29] =
    {   0,
        1,    1,    2,    1,    1,    1,    3,    1,    1,    1,
        4,    4,    5,    6,    6,    6,    1,    1,    1,    7,
        8,    7,    3,    3,    3,    1,    3,    1
    } ;

static yyconst flex_int16_t yy_base[85] =
    {   0,
        0,  145,  150,  266,   27,  266,   25,    0,  131,   23,
       23,   16,   23,   39,   31,   25,   39,   60,   22,   65,
       57,   43,  266,    0,    0,  266,   61,  266,    0,  128,
       74,    0,  113,   59,   62,  113,   52,    0,    0,   72,
       66,  110,  100,  266,   73,   74,  266,   70,  266,   90,
      103,  266,   84,  129,  108,  113,  143,  266,  107,   66,
      118,  137,  168,  120,   80,   91,  145,  143,   83,   41,
      266,  266,  190,  196,  204,  212,  220,  228,  232,  237,
      238,  243,  249,  257
    } ;

static yyconst flex_int16_t yy_def[85] =
    {   0,
       72,    1,   72,   72,   72,   72,   73,   74,   72,   72,
       75,   72,   72,   72,   14,   72,   72,   74,   72,   76,
       72,   73,   72,   77,   74,   72,   75,   72,   78,   72,
       72,   31,   14,   79,   80,   72,   72,   81,   15,   73,
       75,   76,   76,   72,   73,   75,   72,   82,   72,   72,
       72,   72,   81,   76,   54,   72,   72,   72,   76,   54,
       76,   76,   76,   54,   83,   76,   63,   83,   84,   84,
       72,    0,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72
    } ;

static yyconst flex_int16_t yy_nxt[295] =
    {   0,
        4,    5,    6,    5,    7,    4,    8,    9,   10,   11,
        9,   12,   13,   14,   15,   15,   16,    9,   17,    8,
        8,    8,   18,    8,    8,    4,    8,   19,   21,   23,
       21,   26,   28,   26,   26,   30,   31,   31,   31,   26,
       26,   26,   26,   71,   39,   39,   39,   23,   29,   26,
       24,   32,   33,   33,   34,   72,   26,   26,   21,   35,
       21,   36,   37,   38,   40,   36,   43,   44,   24,   41,
       28,   32,   50,   50,   52,   28,   23,   23,   52,   35,
       56,   56,   44,   28,   42,   71,   29,   31,   31,   31,
       42,   29,   59,   44,   48,   49,   49,   24,   24,   29,

       49,   43,   44,   51,   51,   51,   36,   37,   59,   44,
       36,   65,   44,   54,   55,   55,   51,   51,   51,   59,
       44,   64,   64,   64,   58,   58,   57,   57,   57,   58,
       59,   44,   42,   64,   64,   64,   52,   72,   59,   44,
       47,   66,   60,   60,   42,   44,   59,   69,   26,   72,
       20,   61,   62,   63,   72,   61,   57,   57,   57,   66,
       72,   72,   72,   66,   49,   49,   72,   61,   62,   49,
       44,   61,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   67,   67,   67,   72,   72,   72,   67,   67,   67,
       22,   22,   22,   22,   22,   22,   22,   22,   25,   72,

       72,   25,   25,   25,   27,   27,   27,   27,   27,   27,
       27,   27,   42,   42,   42,   42,   42,   42,   42,   42,
       45,   72,   45,   45,   45,   45,   45,   45,   46,   72,
       46,   46,   46,   46,   46,   46,   34,   34,   72,   34,
       51,   72,   51,   53,   53,   53,   57,   72,   57,   68,
       68,   68,   68,   68,   68,   68,   68,   70,   70,   70,
       70,   70,   70,   70,   70,    3,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72

    } ;

static yyconst flex_int16_t yy_chk[295] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    5,    7,
        5,   10,   11,   12,   12,   13,   13,   13,   13,   19,
       10,   16,   16,   70,   15,   15,   15,   22,   11,   19,
        7,   14,   14,   14,   14,   15,   17,   17,   21,   14,
       21,   14,   14,   14,   18,   14,   20,   20,   22,   18,
       27,   34,   35,   35,   37,   41,   40,   45,   37,   34,
       48,   48,   65,   46,   65,   69,   27,   31,   31,   31,
       60,   41,   66,   66,   31,   31,   31,   40,   45,   46,

       31,   43,   43,   50,   50,   50,   53,   53,   59,   59,
       53,   59,   42,   43,   43,   43,   51,   51,   51,   61,
       61,   55,   55,   55,   51,   51,   56,   56,   56,   51,
       54,   54,   55,   64,   64,   64,   36,   33,   62,   62,
       30,   61,   54,   54,   64,   68,   67,   68,    9,    3,
        2,   54,   54,   54,    0,   54,   57,   57,   57,   62,
        0,    0,    0,   62,   57,   57,    0,   67,   67,   57,
       63,   67,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   63,   63,   63,    0,    0,    0,   63,   63,   63,
       73,   73,   73,   73,   73,   73,   73,   73,   74,    0,

        0,   74,   74,   74,   75,   75,   75,   75,   75,   75,
       75,   75,   76,   76,   76,   76,   76,   76,   76,   76,
       77,    0,   77,   77,   77,   77,   77,   77,   78,    0,
       78,   78,   78,   78,   78,   78,   79,   79,    0,   79,
       80,    0,   80,   81,   81,   81,   82,    0,   82,   83,
       83,   83,   83,   83,   83,   83,   83,   84,   84,   84,
       84,   84,   84,   84,   84,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72

    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
/* Lexical analysis for genksyms.
   Copyright 1996, 1997 Linux International.

   New implementation contributed by Richard Henderson <rth@tamu.edu>
   Based on original work by Bjorn Ekwall <bj0rn@blox.se>

   Taken from Linux modutils 2.4.22.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2 of the License, or (at your
   option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "genksyms.h"
#include "parse.tab.h"

/* We've got a two-level lexer here.  We let flex do basic tokenization
   and then we categorize those basic tokens in the second stage.  */
#define YY_DECL		static int yylex1(void)

/* We don't do multiple input files.  */
#define YY_NO_INPUT 1

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals (void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy (void );

int yyget_debug (void );

void yyset_debug (int debug_flag  );

YY_EXTRA_TYPE yyget_extra (void );

void yyset_extra (YY_EXTRA_TYPE user_defined  );

FILE *yyget_in (void );

void yyset_in  (FILE * in_str  );

FILE *yyget_out (void );

void yyset_out  (FILE * out_str  );

int yyget_leng (void );

char *yyget_text (void );

int yyget_lineno (void );

void yyset_lineno (int line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap (void );
#else
extern int yywrap (void );
#endif
#endif

    static void yyunput (int c,char *buf_ptr  );
    
#ifndef yytext_ptr
static void yy_flex_strncpy (char *,yyconst char *,int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * );
#endif

#ifndef YY_NO_INPUT

#ifdef __cplusplus
static int yyinput (void );
#else
static int input (void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		int n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (void);

#define YY_DECL int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
				(yytext[yyleng - 1] == '\n'); \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;
    
 /* Keep track of our location in the original source files.  */

	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer(yyin,YY_BUF_SIZE );
		}

		yy_load_buffer_state( );
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);
		yy_current_state += YY_AT_BOL();
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 73 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 266 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = (yy_hold_char);
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			goto yy_find_action;

case 1:
/* rule 1 can match eol */
YY_RULE_SETUP
return FILENAME;
	YY_BREAK
case 2:
/* rule 2 can match eol */
YY_RULE_SETUP
cur_line++;
	YY_BREAK
case 3:
/* rule 3 can match eol */
YY_RULE_SETUP
cur_line++;
	YY_BREAK
/* Ignore all other whitespace.  */
case 4:
YY_RULE_SETUP
;
	YY_BREAK
case 5:
/* rule 5 can match eol */
YY_RULE_SETUP
return STRING;
	YY_BREAK
case 6:
/* rule 6 can match eol */
YY_RULE_SETUP
return CHAR;
	YY_BREAK
case 7:
YY_RULE_SETUP
return IDENT;
	YY_BREAK
/* The Pedant requires that the other C multi-character tokens be
    recognized as tokens.  We don't actually use them since we don't
    parse expressions, but we do want whitespace to be arranged
    around them properly.  */
case 8:
YY_RULE_SETUP
return OTHER;
	YY_BREAK
case 9:
YY_RULE_SETUP
return INT;
	YY_BREAK
case 10:
YY_RULE_SETUP
return REAL;
	YY_BREAK
case 11:
YY_RULE_SETUP
return DOTS;
	YY_BREAK
/* All other tokens are single characters.  */
case 12:
YY_RULE_SETUP
return yytext[0];
	YY_BREAK
case 13:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_c_buf_p);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap( ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	register char *source = (yytext_ptr);
	register int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), (size_t) num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart(yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
	register yy_state_type yy_current_state;
	register char *yy_cp;
    
	yy_current_state = (yy_start);
	yy_current_state += YY_AT_BOL();

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 73 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
	register int yy_is_jam;
    	register char *yy_cp = (yy_c_buf_p);

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 73 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 72);

	return yy_is_jam ? 0 : yy_current_state;
}

    static void yyunput (int c, register char * yy_bp )
{
	register char *yy_cp;
    
    yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = (yy_n_chars) + 2;
		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		register char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (yy_c_buf_p) - (yytext_ptr);
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart(yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap( ) )
						return EOF;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer(yyin,YY_BUF_SIZE );
	}

	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
	yy_load_buffer_state( );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state( );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer(b,file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree((void *) b->yy_ch_buf  );

	yyfree((void *) b  );
}

#ifndef __cplusplus
extern int isatty (int );
#endif /* __cplusplus */
    
/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;
    
	yy_flush_buffer(b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state( );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state( );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state( );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
	int num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
								  
		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
				
		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		int grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * 
 * @return the newly allocated buffer state object. 
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer(b  );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * 
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
{
    
	return yy_scan_bytes(yystr,strlen(yystr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = _yybytes_len + 2;
	buf = (char *) yyalloc(n  );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer(buf,n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg )
{
    	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
int yyget_lineno  (void)
{
        
    return yylineno;
}

/** Get the input stream.
 * 
 */
FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 * 
 */
FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 * 
 */
int yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 * 
 */

char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param line_number
 * 
 */
void yyset_lineno (int  line_number )
{
    
    yylineno = line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * 
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  in_str )
{
        yyin = in_str ;
}

void yyset_out (FILE *  out_str )
{
        yyout = out_str ;
}

int yyget_debug  (void)
{
        return yy_flex_debug;
}

void yyset_debug (int  bdebug )
{
        yy_flex_debug = bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    (yy_buffer_stack) = 0;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = (char *) 0;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (void)
{
    
    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer(YY_CURRENT_BUFFER  );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state();
	}

	/* Destroy the stack itself. */
	yyfree((yy_buffer_stack) );
	(yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * s )
{
	register int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
	return (void *) malloc( size );
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
}

void yyfree (void * ptr )
{
	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

/* Bring in the keyword recognizer.  */

#include "keywords.hash.c"

/* Macros to append to our phrase collection list.  */

/*
 * We mark any token, that that equals to a known enumerator, as
 * SYM_ENUM_CONST. The parser will change this for struct and union tags later,
 * the only problem is struct and union members:
 *    enum e { a, b }; struct s { int a, b; }
 * but in this case, the only effect will be, that the ABI checksums become
 * more volatile, which is acceptable. Also, such collisions are quite rare,
 * so far it was only observed in include/linux/telephony.h.
 */
#define _APP(T,L)	do {						   \
			  cur_node = next_node;				   \
			  next_node = xmalloc(sizeof(*next_node));	   \
			  next_node->next = cur_node;			   \
			  cur_node->string = memcpy(xmalloc(L+1), T, L+1); \
			  cur_node->tag =				   \
			    find_symbol(cur_node->string, SYM_ENUM_CONST, 1)?\
			    SYM_ENUM_CONST : SYM_NORMAL ;		   \
			  cur_node->in_source_file = in_source_file;       \
			} while (0)

#define APP		_APP(yytext, yyleng)

/* The second stage lexer.  Here we incorporate knowledge of the state
   of the parser to tailor the tokens that are returned.  */

int
yylex(void)
{
  static enum {
    ST_NOTSTARTED, ST_NORMAL, ST_ATTRIBUTE, ST_ASM, ST_TYPEOF, ST_TYPEOF_1,
    ST_BRACKET, ST_BRACE, ST_EXPRESSION,
    ST_TABLE_1, ST_TABLE_2, ST_TABLE_3, ST_TABLE_4,
    ST_TABLE_5, ST_TABLE_6
  } lexstate = ST_NOTSTARTED;

  static int suppress_type_lookup, dont_want_brace_phrase;
  static struct string_list *next_node;

  int token, count = 0;
  struct string_list *cur_node;

  if (lexstate == ST_NOTSTARTED)
    {
      next_node = xmalloc(sizeof(*next_node));
      next_node->next = NULL;
      lexstate = ST_NORMAL;
    }

repeat:
  token = yylex1();

  if (token == 0)
    return 0;
  else if (token == FILENAME)
    {
      char *file, *e;

      /* Save the filename and line number for later error messages.  */

      if (cur_filename)
	free(cur_filename);

      file = strchr(yytext, '\"')+1;
      e = strchr(file, '\"');
      *e = '\0';
      cur_filename = memcpy(xmalloc(e-file+1), file, e-file+1);
      cur_line = atoi(yytext+2);

      if (!source_file) {
        source_file = xstrdup(cur_filename);
        in_source_file = 1;
      } else {
        in_source_file = (strcmp(cur_filename, source_file) == 0);
      }

      goto repeat;
    }

  switch (lexstate)
    {
    case ST_NORMAL:
      switch (token)
	{
	case IDENT:
	  APP;
	  {
	    const struct resword *r = is_reserved_word(yytext, yyleng);
	    if (r)
	      {
		switch (token = r->token)
		  {
		  case ATTRIBUTE_KEYW:
		    lexstate = ST_ATTRIBUTE;
		    count = 0;
		    goto repeat;
		  case ASM_KEYW:
		    lexstate = ST_ASM;
		    count = 0;
		    goto repeat;
		  case TYPEOF_KEYW:
		    lexstate = ST_TYPEOF;
		    count = 0;
		    goto repeat;

		  case STRUCT_KEYW:
		  case UNION_KEYW:
		  case ENUM_KEYW:
		    dont_want_brace_phrase = 3;
		    suppress_type_lookup = 2;
		    goto fini;

		  case EXPORT_SYMBOL_KEYW:
		      goto fini;
		  }
	      }
	    if (!suppress_type_lookup)
	      {
		if (find_symbol(yytext, SYM_TYPEDEF, 1))
		  token = TYPE;
	      }
	  }
	  break;

	case '[':
	  APP;
	  lexstate = ST_BRACKET;
	  count = 1;
	  goto repeat;

	case '{':
	  APP;
	  if (dont_want_brace_phrase)
	    break;
	  lexstate = ST_BRACE;
	  count = 1;
	  goto repeat;

	case '=': case ':':
	  APP;
	  lexstate = ST_EXPRESSION;
	  break;

	case DOTS:
	default:
	  APP;
	  break;
	}
      break;

    case ST_ATTRIBUTE:
      APP;
      switch (token)
	{
	case '(':
	  ++count;
	  goto repeat;
	case ')':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = ATTRIBUTE_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_ASM:
      APP;
      switch (token)
	{
	case '(':
	  ++count;
	  goto repeat;
	case ')':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = ASM_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_TYPEOF:
      switch (token)
	{
	case '(':
	  if ( ++count == 1 )
	    lexstate = ST_TYPEOF_1;
	  else
	    APP;
	  goto repeat;
	case ')':
	  APP;
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = TYPEOF_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  APP;
	  goto repeat;
	}
      break;

    case ST_TYPEOF_1:
      if (token == IDENT)
	{
	  if (is_reserved_word(yytext, yyleng)
	      || find_symbol(yytext, SYM_TYPEDEF, 1))
	    {
	      yyless(0);
	      unput('(');
	      lexstate = ST_NORMAL;
	      token = TYPEOF_KEYW;
	      break;
	    }
	  _APP("(", 1);
	}
	APP;
	lexstate = ST_TYPEOF;
	goto repeat;

    case ST_BRACKET:
      APP;
      switch (token)
	{
	case '[':
	  ++count;
	  goto repeat;
	case ']':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = BRACKET_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_BRACE:
      APP;
      switch (token)
	{
	case '{':
	  ++count;
	  goto repeat;
	case '}':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = BRACE_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_EXPRESSION:
      switch (token)
	{
	case '(': case '[': case '{':
	  ++count;
	  APP;
	  goto repeat;
	case '}':
	  /* is this the last line of an enum declaration? */
	  if (count == 0)
	    {
	      /* Put back the token we just read so's we can find it again
		 after registering the expression.  */
	      unput(token);

	      lexstate = ST_NORMAL;
	      token = EXPRESSION_PHRASE;
	      break;
	    }
	  /* FALLTHRU */
	case ')': case ']':
	  --count;
	  APP;
	  goto repeat;
	case ',': case ';':
	  if (count == 0)
	    {
	      /* Put back the token we just read so's we can find it again
		 after registering the expression.  */
	      unput(token);

	      lexstate = ST_NORMAL;
	      token = EXPRESSION_PHRASE;
	      break;
	    }
	  APP;
	  goto repeat;
	default:
	  APP;
	  goto repeat;
	}
      break;

    case ST_TABLE_1:
      goto repeat;

    case ST_TABLE_2:
      if (token == IDENT && yyleng == 1 && yytext[0] == 'X')
	{
	  token = EXPORT_SYMBOL_KEYW;
	  lexstate = ST_TABLE_5;
	  APP;
	  break;
	}
      lexstate = ST_TABLE_6;
      /* FALLTHRU */

    case ST_TABLE_6:
      switch (token)
	{
	case '{': case '[': case '(':
	  ++count;
	  break;
	case '}': case ']': case ')':
	  --count;
	  break;
	case ',':
	  if (count == 0)
	    lexstate = ST_TABLE_2;
	  break;
	};
      goto repeat;

    case ST_TABLE_3:
      goto repeat;

    case ST_TABLE_4:
      if (token == ';')
	lexstate = ST_NORMAL;
      goto repeat;

    case ST_TABLE_5:
      switch (token)
	{
	case ',':
	  token = ';';
	  lexstate = ST_TABLE_2;
	  APP;
	  break;
	default:
	  APP;
	  break;
	}
      break;

    default:
      exit(1);
    }
fini:

  if (suppress_type_lookup > 0)
    --suppress_type_lookup;
  if (dont_want_brace_phrase > 0)
    --dont_want_brace_phrase;

  yylval = &next_node->next;

  return token;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
#line 3 "scripts/genksyms/lex.lex.c_shipped"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 35
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;
#endif /* ! C99 */

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! FLEXINT_H */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined (__STDC__)

#define YY_USE_CONST

#endif	/* defined (__STDC__) */
#endif	/* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin  )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE 16384
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

    #define YY_LESS_LINENO(n)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */
    
	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart (FILE *input_file  );
void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
void yy_delete_buffer (YY_BUFFER_STATE b  );
void yy_flush_buffer (YY_BUFFER_STATE b  );
void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state (void );

static void yyensure_buffer_stack (void );
static void yy_load_buffer_state (void );
static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );

#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );

void *yyalloc (yy_size_t  );
void *yyrealloc (void *,yy_size_t  );
void yyfree (void *  );

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer(yyin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer(yyin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define yywrap(n) 1
#define YY_SKIP_YYWRAP

typedef unsigned char YY_CHAR;

FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;

typedef int yy_state_type;

extern int yylineno;

int yylineno = 1;

extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state (void );
static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
static int yy_get_next_buffer (void );
static void yy_fatal_error (yyconst char msg[]  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (size_t) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;

#define YY_NUM_RULES 13
#define YY_END_OF_BUFFER 14
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static yyconst flex_int16_t yy_accept[73] =
    {   0,
        0,    0,   14,   12,    4,    3,   12,    7,   12,   12,
       12,   12,   12,    9,    9,   12,   12,    7,   12,   12,
        4,    0,    5,    0,    7,    8,    0,    6,    0,    0,
       10,   10,    9,    0,    0,    9,    9,    0,    9,    0,
        0,    0,    0,    2,    0,    0,   11,    0,   10,    0,
       10,    9,    9,    0,    0,    0,   10,   10,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        1,    0
    } ;

static yyconst flex_int32_t yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        4,    4,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    5,    6,    7,    8,    9,   10,    1,
        1,    8,   11,    1,   12,   13,    8,   14,   15,   15,
       15,   15,   15,   15,   15,   16,   16,    1,    1,   17,
       18,   19,    1,    1,   20,   20,   20,   20,   21,   22,
        7,    7,    7,    7,    7,   23,    7,    7,    7,    7,
        7,    7,    7,    7,   24,    7,    7,   25,    7,    7,
        1,   26,    1,    8,    7,    1,   20,   20,   20,   20,

       21,   22,    7,    7,    7,    7,    7,   27,    7,    7,
        7,    7,    7,    7,    7,    7,   24,    7,    7,   25,
        7,    7,    1,   28,    1,    8,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst flex_int32_t yy_meta[29] =
    {   0,
        1,    1,    2,    1,    1,    1,    3,    1,    1,    1,
        4,    4,    5,    6,    6,    6,    1,    1,    1,    7,
        8,    7,    3,    3,    3,    1,    3,    1
    } ;

static yyconst flex_int16_t yy_base[85] =
    {   0,
        0,  145,  150,  266,   27,  266,   25,    0,  131,   23,
       23,   16,   23,   39,   31,   25,   39,   60,   22,   65,
       57,   43,  266,    0,    0,  266,   61,  266,    0,  128,
       74,    0,  113,   59,   62,  113,   52,    0,    0,   72,
       66,  110,  100,  266,   73,   74,  266,   70,  266,   90,
      103,  266,   84,  129,  108,  113,  143,  266,  107,   66,
      118,  137,  168,  120,   80,   91,  145,  143,   83,   41,
      266,  266,  190,  196,  204,  212,  220,  228,  232,  237,
      238,  243,  249,  257
    } ;

static yyconst flex_int16_t yy_def[85] =
    {   0,
       72,    1,   72,   72,   72,   72,   73,   74,   72,   72,
       75,   72,   72,   72,   14,   72,   72,   74,   72,   76,
       72,   73,   72,   77,   74,   72,   75,   72,   78,   72,
       72,   31,   14,   79,   80,   72,   72,   81,   15,   73,
       75,   76,   76,   72,   73,   75,   72,   82,   72,   72,
       72,   72,   81,   76,   54,   72,   72,   72,   76,   54,
       76,   76,   76,   54,   83,   76,   63,   83,   84,   84,
       72,    0,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72
    } ;

static yyconst flex_int16_t yy_nxt[295] =
    {   0,
        4,    5,    6,    5,    7,    4,    8,    9,   10,   11,
        9,   12,   13,   14,   15,   15,   16,    9,   17,    8,
        8,    8,   18,    8,    8,    4,    8,   19,   21,   23,
       21,   26,   28,   26,   26,   30,   31,   31,   31,   26,
       26,   26,   26,   71,   39,   39,   39,   23,   29,   26,
       24,   32,   33,   33,   34,   72,   26,   26,   21,   35,
       21,   36,   37,   38,   40,   36,   43,   44,   24,   41,
       28,   32,   50,   50,   52,   28,   23,   23,   52,   35,
       56,   56,   44,   28,   42,   71,   29,   31,   31,   31,
       42,   29,   59,   44,   48,   49,   49,   24,   24,   29,

       49,   43,   44,   51,   51,   51,   36,   37,   59,   44,
       36,   65,   44,   54,   55,   55,   51,   51,   51,   59,
       44,   64,   64,   64,   58,   58,   57,   57,   57,   58,
       59,   44,   42,   64,   64,   64,   52,   72,   59,   44,
       47,   66,   60,   60,   42,   44,   59,   69,   26,   72,
       20,   61,   62,   63,   72,   61,   57,   57,   57,   66,
       72,   72,   72,   66,   49,   49,   72,   61,   62,   49,
       44,   61,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   67,   67,   67,   72,   72,   72,   67,   67,   67,
       22,   22,   22,   22,   22,   22,   22,   22,   25,   72,

       72,   25,   25,   25,   27,   27,   27,   27,   27,   27,
       27,   27,   42,   42,   42,   42,   42,   42,   42,   42,
       45,   72,   45,   45,   45,   45,   45,   45,   46,   72,
       46,   46,   46,   46,   46,   46,   34,   34,   72,   34,
       51,   72,   51,   53,   53,   53,   57,   72,   57,   68,
       68,   68,   68,   68,   68,   68,   68,   70,   70,   70,
       70,   70,   70,   70,   70,    3,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72

    } ;

static yyconst flex_int16_t yy_chk[295] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    5,    7,
        5,   10,   11,   12,   12,   13,   13,   13,   13,   19,
       10,   16,   16,   70,   15,   15,   15,   22,   11,   19,
        7,   14,   14,   14,   14,   15,   17,   17,   21,   14,
       21,   14,   14,   14,   18,   14,   20,   20,   22,   18,
       27,   34,   35,   35,   37,   41,   40,   45,   37,   34,
       48,   48,   65,   46,   65,   69,   27,   31,   31,   31,
       60,   41,   66,   66,   31,   31,   31,   40,   45,   46,

       31,   43,   43,   50,   50,   50,   53,   53,   59,   59,
       53,   59,   42,   43,   43,   43,   51,   51,   51,   61,
       61,   55,   55,   55,   51,   51,   56,   56,   56,   51,
       54,   54,   55,   64,   64,   64,   36,   33,   62,   62,
       30,   61,   54,   54,   64,   68,   67,   68,    9,    3,
        2,   54,   54,   54,    0,   54,   57,   57,   57,   62,
        0,    0,    0,   62,   57,   57,    0,   67,   67,   57,
       63,   67,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   63,   63,   63,    0,    0,    0,   63,   63,   63,
       73,   73,   73,   73,   73,   73,   73,   73,   74,    0,

        0,   74,   74,   74,   75,   75,   75,   75,   75,   75,
       75,   75,   76,   76,   76,   76,   76,   76,   76,   76,
       77,    0,   77,   77,   77,   77,   77,   77,   78,    0,
       78,   78,   78,   78,   78,   78,   79,   79,    0,   79,
       80,    0,   80,   81,   81,   81,   82,    0,   82,   83,
       83,   83,   83,   83,   83,   83,   83,   84,   84,   84,
       84,   84,   84,   84,   84,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72

    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
/* Lexical analysis for genksyms.
   Copyright 1996, 1997 Linux International.

   New implementation contributed by Richard Henderson <rth@tamu.edu>
   Based on original work by Bjorn Ekwall <bj0rn@blox.se>

   Taken from Linux modutils 2.4.22.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2 of the License, or (at your
   option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "genksyms.h"
#include "parse.tab.h"

/* We've got a two-level lexer here.  We let flex do basic tokenization
   and then we categorize those basic tokens in the second stage.  */
#define YY_DECL		static int yylex1(void)

/* We don't do multiple input files.  */
#define YY_NO_INPUT 1

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals (void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy (void );

int yyget_debug (void );

void yyset_debug (int debug_flag  );

YY_EXTRA_TYPE yyget_extra (void );

void yyset_extra (YY_EXTRA_TYPE user_defined  );

FILE *yyget_in (void );

void yyset_in  (FILE * in_str  );

FILE *yyget_out (void );

void yyset_out  (FILE * out_str  );

int yyget_leng (void );

char *yyget_text (void );

int yyget_lineno (void );

void yyset_lineno (int line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap (void );
#else
extern int yywrap (void );
#endif
#endif

    static void yyunput (int c,char *buf_ptr  );
    
#ifndef yytext_ptr
static void yy_flex_strncpy (char *,yyconst char *,int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * );
#endif

#ifndef YY_NO_INPUT

#ifdef __cplusplus
static int yyinput (void );
#else
static int input (void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		int n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (void);

#define YY_DECL int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
				(yytext[yyleng - 1] == '\n'); \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;
    
 /* Keep track of our location in the original source files.  */

	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer(yyin,YY_BUF_SIZE );
		}

		yy_load_buffer_state( );
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);
		yy_current_state += YY_AT_BOL();
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 73 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 266 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = (yy_hold_char);
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			goto yy_find_action;

case 1:
/* rule 1 can match eol */
YY_RULE_SETUP
return FILENAME;
	YY_BREAK
case 2:
/* rule 2 can match eol */
YY_RULE_SETUP
cur_line++;
	YY_BREAK
case 3:
/* rule 3 can match eol */
YY_RULE_SETUP
cur_line++;
	YY_BREAK
/* Ignore all other whitespace.  */
case 4:
YY_RULE_SETUP
;
	YY_BREAK
case 5:
/* rule 5 can match eol */
YY_RULE_SETUP
return STRING;
	YY_BREAK
case 6:
/* rule 6 can match eol */
YY_RULE_SETUP
return CHAR;
	YY_BREAK
case 7:
YY_RULE_SETUP
return IDENT;
	YY_BREAK
/* The Pedant requires that the other C multi-character tokens be
    recognized as tokens.  We don't actually use them since we don't
    parse expressions, but we do want whitespace to be arranged
    around them properly.  */
case 8:
YY_RULE_SETUP
return OTHER;
	YY_BREAK
case 9:
YY_RULE_SETUP
return INT;
	YY_BREAK
case 10:
YY_RULE_SETUP
return REAL;
	YY_BREAK
case 11:
YY_RULE_SETUP
return DOTS;
	YY_BREAK
/* All other tokens are single characters.  */
case 12:
YY_RULE_SETUP
return yytext[0];
	YY_BREAK
case 13:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_c_buf_p);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap( ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	register char *source = (yytext_ptr);
	register int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), (size_t) num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart(yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
	register yy_state_type yy_current_state;
	register char *yy_cp;
    
	yy_current_state = (yy_start);
	yy_current_state += YY_AT_BOL();

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 73 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
	register int yy_is_jam;
    	register char *yy_cp = (yy_c_buf_p);

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 73 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 72);

	return yy_is_jam ? 0 : yy_current_state;
}

    static void yyunput (int c, register char * yy_bp )
{
	register char *yy_cp;
    
    yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = (yy_n_chars) + 2;
		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		register char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (yy_c_buf_p) - (yytext_ptr);
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart(yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap( ) )
						return EOF;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer(yyin,YY_BUF_SIZE );
	}

	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
	yy_load_buffer_state( );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state( );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer(b,file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree((void *) b->yy_ch_buf  );

	yyfree((void *) b  );
}

#ifndef __cplusplus
extern int isatty (int );
#endif /* __cplusplus */
    
/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;
    
	yy_flush_buffer(b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state( );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state( );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state( );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
	int num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
								  
		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
				
		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		int grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * 
 * @return the newly allocated buffer state object. 
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer(b  );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * 
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
{
    
	return yy_scan_bytes(yystr,strlen(yystr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = _yybytes_len + 2;
	buf = (char *) yyalloc(n  );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer(buf,n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg )
{
    	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
int yyget_lineno  (void)
{
        
    return yylineno;
}

/** Get the input stream.
 * 
 */
FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 * 
 */
FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 * 
 */
int yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 * 
 */

char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param line_number
 * 
 */
void yyset_lineno (int  line_number )
{
    
    yylineno = line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * 
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  in_str )
{
        yyin = in_str ;
}

void yyset_out (FILE *  out_str )
{
        yyout = out_str ;
}

int yyget_debug  (void)
{
        return yy_flex_debug;
}

void yyset_debug (int  bdebug )
{
        yy_flex_debug = bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    (yy_buffer_stack) = 0;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = (char *) 0;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (void)
{
    
    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer(YY_CURRENT_BUFFER  );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state();
	}

	/* Destroy the stack itself. */
	yyfree((yy_buffer_stack) );
	(yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * s )
{
	register int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
	return (void *) malloc( size );
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
}

void yyfree (void * ptr )
{
	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

/* Bring in the keyword recognizer.  */

#include "keywords.hash.c"

/* Macros to append to our phrase collection list.  */

/*
 * We mark any token, that that equals to a known enumerator, as
 * SYM_ENUM_CONST. The parser will change this for struct and union tags later,
 * the only problem is struct and union members:
 *    enum e { a, b }; struct s { int a, b; }
 * but in this case, the only effect will be, that the ABI checksums become
 * more volatile, which is acceptable. Also, such collisions are quite rare,
 * so far it was only observed in include/linux/telephony.h.
 */
#define _APP(T,L)	do {						   \
			  cur_node = next_node;				   \
			  next_node = xmalloc(sizeof(*next_node));	   \
			  next_node->next = cur_node;			   \
			  cur_node->string = memcpy(xmalloc(L+1), T, L+1); \
			  cur_node->tag =				   \
			    find_symbol(cur_node->string, SYM_ENUM_CONST, 1)?\
			    SYM_ENUM_CONST : SYM_NORMAL ;		   \
			  cur_node->in_source_file = in_source_file;       \
			} while (0)

#define APP		_APP(yytext, yyleng)

/* The second stage lexer.  Here we incorporate knowledge of the state
   of the parser to tailor the tokens that are returned.  */

int
yylex(void)
{
  static enum {
    ST_NOTSTARTED, ST_NORMAL, ST_ATTRIBUTE, ST_ASM, ST_TYPEOF, ST_TYPEOF_1,
    ST_BRACKET, ST_BRACE, ST_EXPRESSION,
    ST_TABLE_1, ST_TABLE_2, ST_TABLE_3, ST_TABLE_4,
    ST_TABLE_5, ST_TABLE_6
  } lexstate = ST_NOTSTARTED;

  static int suppress_type_lookup, dont_want_brace_phrase;
  static struct string_list *next_node;

  int token, count = 0;
  struct string_list *cur_node;

  if (lexstate == ST_NOTSTARTED)
    {
      next_node = xmalloc(sizeof(*next_node));
      next_node->next = NULL;
      lexstate = ST_NORMAL;
    }

repeat:
  token = yylex1();

  if (token == 0)
    return 0;
  else if (token == FILENAME)
    {
      char *file, *e;

      /* Save the filename and line number for later error messages.  */

      if (cur_filename)
	free(cur_filename);

      file = strchr(yytext, '\"')+1;
      e = strchr(file, '\"');
      *e = '\0';
      cur_filename = memcpy(xmalloc(e-file+1), file, e-file+1);
      cur_line = atoi(yytext+2);

      if (!source_file) {
        source_file = xstrdup(cur_filename);
        in_source_file = 1;
      } else {
        in_source_file = (strcmp(cur_filename, source_file) == 0);
      }

      goto repeat;
    }

  switch (lexstate)
    {
    case ST_NORMAL:
      switch (token)
	{
	case IDENT:
	  APP;
	  {
	    const struct resword *r = is_reserved_word(yytext, yyleng);
	    if (r)
	      {
		switch (token = r->token)
		  {
		  case ATTRIBUTE_KEYW:
		    lexstate = ST_ATTRIBUTE;
		    count = 0;
		    goto repeat;
		  case ASM_KEYW:
		    lexstate = ST_ASM;
		    count = 0;
		    goto repeat;
		  case TYPEOF_KEYW:
		    lexstate = ST_TYPEOF;
		    count = 0;
		    goto repeat;

		  case STRUCT_KEYW:
		  case UNION_KEYW:
		  case ENUM_KEYW:
		    dont_want_brace_phrase = 3;
		    suppress_type_lookup = 2;
		    goto fini;

		  case EXPORT_SYMBOL_KEYW:
		      goto fini;
		  }
	      }
	    if (!suppress_type_lookup)
	      {
		if (find_symbol(yytext, SYM_TYPEDEF, 1))
		  token = TYPE;
	      }
	  }
	  break;

	case '[':
	  APP;
	  lexstate = ST_BRACKET;
	  count = 1;
	  goto repeat;

	case '{':
	  APP;
	  if (dont_want_brace_phrase)
	    break;
	  lexstate = ST_BRACE;
	  count = 1;
	  goto repeat;

	case '=': case ':':
	  APP;
	  lexstate = ST_EXPRESSION;
	  break;

	case DOTS:
	default:
	  APP;
	  break;
	}
      break;

    case ST_ATTRIBUTE:
      APP;
      switch (token)
	{
	case '(':
	  ++count;
	  goto repeat;
	case ')':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = ATTRIBUTE_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_ASM:
      APP;
      switch (token)
	{
	case '(':
	  ++count;
	  goto repeat;
	case ')':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = ASM_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_TYPEOF:
      switch (token)
	{
	case '(':
	  if ( ++count == 1 )
	    lexstate = ST_TYPEOF_1;
	  else
	    APP;
	  goto repeat;
	case ')':
	  APP;
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = TYPEOF_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  APP;
	  goto repeat;
	}
      break;

    case ST_TYPEOF_1:
      if (token == IDENT)
	{
	  if (is_reserved_word(yytext, yyleng)
	      || find_symbol(yytext, SYM_TYPEDEF, 1))
	    {
	      yyless(0);
	      unput('(');
	      lexstate = ST_NORMAL;
	      token = TYPEOF_KEYW;
	      break;
	    }
	  _APP("(", 1);
	}
	APP;
	lexstate = ST_TYPEOF;
	goto repeat;

    case ST_BRACKET:
      APP;
      switch (token)
	{
	case '[':
	  ++count;
	  goto repeat;
	case ']':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = BRACKET_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_BRACE:
      APP;
      switch (token)
	{
	case '{':
	  ++count;
	  goto repeat;
	case '}':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = BRACE_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_EXPRESSION:
      switch (token)
	{
	case '(': case '[': case '{':
	  ++count;
	  APP;
	  goto repeat;
	case '}':
	  /* is this the last line of an enum declaration? */
	  if (count == 0)
	    {
	      /* Put back the token we just read so's we can find it again
		 after registering the expression.  */
	      unput(token);

	      lexstate = ST_NORMAL;
	      token = EXPRESSION_PHRASE;
	      break;
	    }
	  /* FALLTHRU */
	case ')': case ']':
	  --count;
	  APP;
	  goto repeat;
	case ',': case ';':
	  if (count == 0)
	    {
	      /* Put back the token we just read so's we can find it again
		 after registering the expression.  */
	      unput(token);

	      lexstate = ST_NORMAL;
	      token = EXPRESSION_PHRASE;
	      break;
	    }
	  APP;
	  goto repeat;
	default:
	  APP;
	  goto repeat;
	}
      break;

    case ST_TABLE_1:
      goto repeat;

    case ST_TABLE_2:
      if (token == IDENT && yyleng == 1 && yytext[0] == 'X')
	{
	  token = EXPORT_SYMBOL_KEYW;
	  lexstate = ST_TABLE_5;
	  APP;
	  break;
	}
      lexstate = ST_TABLE_6;
      /* FALLTHRU */

    case ST_TABLE_6:
      switch (token)
	{
	case '{': case '[': case '(':
	  ++count;
	  break;
	case '}': case ']': case ')':
	  --count;
	  break;
	case ',':
	  if (count == 0)
	    lexstate = ST_TABLE_2;
	  break;
	};
      goto repeat;

    case ST_TABLE_3:
      goto repeat;

    case ST_TABLE_4:
      if (token == ';')
	lexstate = ST_NORMAL;
      goto repeat;

    case ST_TABLE_5:
      switch (token)
	{
	case ',':
	  token = ';';
	  lexstate = ST_TABLE_2;
	  APP;
	  break;
	default:
	  APP;
	  break;
	}
      break;

    default:
      exit(1);
    }
fini:

  if (suppress_type_lookup > 0)
    --suppress_type_lookup;
  if (dont_want_brace_phrase > 0)
    --dont_want_brace_phrase;

  yylval = &next_node->next;

  return token;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ELF          (    X 4   ˜4   4    (     p                      4   4  4                 4  4 4                          ¬  ¬                     ğ  0                 è   è            P  P P D   D         Qåtd                          /lib/ld-linux-armhf.so.3             GNU                        GNU ”¯’Xtózt\¤º=ĞmÅ¸2             Bˆ`%ã  h@€     !l H „P € @                   	                                    º•“1¸‚ÿÇ<†ğ–|}í?~–|Çà=.N=ö?ùÿ¼ûn$u‚8ò‹½îÊò ”-RÕr~»“^–“ŸÖ½{œ|fUaÎ‚‘Í?¯‘u‚¸+k<­9…º–|êvş                İ                             K                            Ø              -                            %              Æ              •              >              R              w   ğ!                    Y              £              D              ¿              ·                            3   ø!      ~                            i              –              p              9              ‡               libc.so.6 exit strncmp puts putchar realloc abort stdin feof fgets strlen memset memcmp __isoc99_fscanf memcpy malloc stderr strtoull fwrite strchr fprintf qsort __ctype_toupper_loc memmove strcmp __libc_start_main free __gmon_start__ GLIBC_2.7 GLIBC_2.4                                              ii   ì      ii   ö       h!   ğ!   ø!    !   !   !   !   !   !   !   !    !   $!   (!   ,!   0! 	  4!   8!   <!   @!   D!   H!   L! 
  P!   T!   X!   \!   `!   d!   @-é< ë€½èà-åàŸåààğ¾å@  ÆâÊŒâ@ú¼å ÆâÊŒâ8ú¼å ÆâÊŒâ0ú¼å ÆâÊŒâ(ú¼å ÆâÊŒâ ú¼å ÆâÊŒâú¼å ÆâÊŒâú¼å ÆâÊŒâú¼å ÆâÊŒâ ú¼å ÆâÊŒâøù¼å ÆâÊŒâğù¼å ÆâÊŒâèù¼å ÆâÊŒâàù¼å ÆâÊŒâØù¼å ÆâÊŒâĞù¼å ÆâÊŒâÈù¼å ÆâÊŒâÀù¼å ÆâÊŒâ¸ù¼å ÆâÊŒâ°ù¼å ÆâÊŒâ¨ù¼å ÆâÊŒâ ù¼å ÆâÊŒâ˜ù¼å ÆâÊŒâù¼å ÆâÊŒâˆù¼å ÆâÊŒâ€ù¼å ÆâÊŒâxù¼å@-é ã0Ÿå Ÿåv  ã 0“åÅÿÿë  ãÕÿÿëğ! °  PãğO-é € áĞMâ1  ÚÌvŸåP á` ã  ê¼FŸå0 ã0‡å`†â Vá)  
@µå¤Ÿå  á“ÿÿë  Pãóÿÿ
  áŸåÿÿë  Pã0 0‡tFŸîÿÿ
  átŸå  ãÍÿÿë  Pã  0Ôå" Sã6 
' Sã/ 
 0Çå<FŸåàÿÿêDŸå  á  ã¿ÿÿë Pâ/  „â  ã´ÿÿëFŸåğÇáÔÿÿê(  FŸå6Ÿå`”åP”å €“åìuŸå  ê(0”å Sá
  Š'<ƒâ0ƒâ  áƒƒà(0‡å áuÿÿë  Pã ‡å 
 P á††à  á…à
 ë  Pã0”P”`”ƒ ƒ P”‚!… `ƒ`„0‚  áyÿÿë  Pãßÿÿ
0”å  Sã p5Ÿå  á á  ã„ÿÿë ”å@5Ÿå  Zãş  
 “åLeŸå á å   ãP á å8…ŸåĞ"Ãápâ åø ÍáĞ¡GáØ Íá 0—å [á  Zƒâ  :  Ôå  Rã  
Óå Qáƒ0”å  Sã™  àŸåØ Áá [á Z  :Ğ!Áá [á Zˆ  šÄ4Ÿåâ Qáóÿÿ0åP…â Uáp‡âİÿÿPå  ã, ã˜ŸåP„åCÿÿëŸå  ã, ã?ÿÿë  UãÌ  
0å… …àlDŸåläŸå á€ƒàÀ ã0‘å  Sã 0   
 ‘å Òç0ƒâ‚ ÄçÀÎç ‘å Sá÷ÿÿ:â  Qáğÿÿ$4ŸåTŸå¤Ÿå0åÿ0 ã0å0åÀså  \ã0åé  üŸåüŸå0 á ±å  RáÀ Á0ƒâ  ÁSãøÿÿ1šç  Sãâ  
pİåå°å € ãL4 á  ã  ÁåşÁÅåÿ1Åå`›å ›å VãÊ  ÚFâşÁÕå€à   á 0 á  ê SáÂ  
@ á0ƒâ àÔå ^áøÿÿ ÓåÿáÕå Yáôÿÿ 0ÒåÀòå Qá4ƒàÁšçÀLâÁŠç÷ÿÿ á 0 áÀ á„âpÌä0là`†à  á  á¬şÿë VãIâ À á•  š”  ÚşÕå „à0 á  ê  Sá  
@ á0ƒâ  Ôå RáøÿÿàÔåÿ!Õå ^áôÿÿ0 ááÿÿêĞ!Æá [á Zy  
Ø"Æá [á Zo  
˜¢Ÿå˜Ÿå  êºå  Qã  
	  á}şÿë  Pãøÿÿgÿÿê	  á«şÿë Pâ  J  ‰à`Ÿåsşÿë  Pã^ÿÿ
0å Uá  
0åGâàåƒÀƒà ¹èŒÁàà á ®è ™è è0œåœå Sã0CÂ À  Ú 0Ñå ñå  Qá4ƒà!˜ç ‚â!ˆç÷ÿÿ0å0ƒâ0å?ÿÿê…À…à0åŒÁƒàéÿÿê Ôå' RãÌşÿ0ÔåÊşÿê Ôå" RãÇşÿùÿÿê’şÿë 1Ÿå Ÿå ã 0“å  ãYşÿë  ãişÿë
 á, ãXŸåtşÿë
 áPŸå, ãpşÿë`1ŸådŸå ã 0“å  ãIşÿë  ãYşÿë  Vãåşÿ
†à†àqŸåá…à áÀ áA€ ã  êÀŒâ \áÛşÿ
Ğ ÌáØÇá Sá  R÷ÿÿ:ĞÉá Sá  R0œ• €Ã•ñÿÿê	  á–åşÿë  PãŠÿÿ
üşÿê	  á–åşÿë  Pã€ÿÿ
öşÿê Yã ›åIÂ‹å€À  Ú 0Ğå ğå Pá4ƒà!šç ‚â!Šç÷ÿÿ0å€ˆâ Xá°‹â+ÿÿ0åPEâ0Câ sã0å
ÿÿh ë   ãĞâğ½è " œ ¬ À Ô ø! ô x! 0% Ø! 0# 0" 0# ,% ğØÿÿŒ H ô ğ! ä ü  ° ã à ãä  á -å -åÀŸåÀ-å Ÿå0Ÿåğıÿëşÿë|   0Ÿå Ÿå0à “ç  Rãÿ/ëıÿêP t   0Ÿå Ÿå0`à Sãÿ/‘0Ÿå  Sãÿ/ÿ/áó! ğ!     $Ÿå$ Ÿå`àA á¡àÁ°áÿ/0Ÿå  Sãÿ/ÿ/áğ! ğ!     @-é@Ÿå 0Ôå  Sã€½ßÿÿë0 ã 0Äå€½èü! @-é$ Ÿå 0å  Sã  @½èàÿÿê0Ÿå  Sãúÿÿ
3ÿ/áøÿÿê      øC-é PQâ@ á  
hŸåhpŸå`@â € ã0öå  áƒÙçƒ ‰à Qá  À×ç \ã Ä€ˆ@„  
×çéÿÿë €ˆà @„àPUâíÿÿ 0 ã  á 0Äåøƒ½è€ áùÿÿê0# 0" øC-é$på  Wã  
€ á á ` á @å P ã  ê”å_ıÿë 0Pâ  
 Uá@„â	  
  á ”åWıÿëP…â 0Pâ  áñÿÿø€Äá  áøƒ½è0 ã  áøƒ½èğÄá  áøƒ½èğA-éÜMâ@â  áP á @å0Dâ4Ÿå ` áFıÿë Pã
  
 pã  
  á  á} ãGıÿë  PãH  
  àãÜâğ½è  ádıÿë€ Pãh  ŠèaŸå 0Öå  Sã!  p á  áÔŸå'ıÿëĞ Åá  Pã  ø Æá  áTıÿë€€â€…å €â>ıÿë  Pã ` á …å\  
 á  á €â'ıÿëİå„áŸåÀ ãĞ Åá  á àåÀå Æå ÿÿë   ãÜâğ½è İå Ráp„ÙÿÿÙÿÿêHŸå ã è  á“ÿÿë  PãÙÿÿ
#ıÿë`İå 0å1“çA Sã  
U Sã¾ÿÿ
 0×å$ Sã!  
0İåN Vã$ SÊÿÿ¶ÿÿêğ0Ÿåğ Ÿå ã 0“å  ãıÿë  àã¯ÿÿê  áÔŸåâüÿë  Pã¼ÿÿ
  áÄŸåİüÿë  Pã·ÿÿ
  á´ŸåØüÿë  Pã²ÿÿ
  á¤ŸåÓüÿë  Pã­ÿÿ
™ÿÿê” Ÿå×åıÿë  PãØÿÿ
0×å  Sã. SÔÿÿÿÿêT0Ÿå€ ã  á À“å 0 á å  áTŸåöüÿë…ÿÿê,0ŸåH Ÿå ã 0“å?  ãÑüÿë  ãáüÿë(  " À Ø! x! ğ! 8 È ä     T $ 8@-é @ áXPŸå Õå  Qã  
L Ÿå  á üÿëD Ÿå¹üÿë Õå  Qã   á0 Ÿå8@½è—üÿê á$ Ÿå”üÿëòÿÿê  á Ÿå8@½èüÿê " d €  t ˆ ğO-éİMâĞMâôŸåŸüÿëğŸåüÿëìŸå›üÿëèŸå™üÿëäŸå—üÿëàŸå•üÿëÜŸå“üÿëØ’ŸåØŸåüÿëÔŸåüÿëĞŸåÇÿÿë0™å  Sã$  
‘üÿë @ ãP á	` á p á  ê
 Rà0Ãà Ÿådüÿë0™åP…â Sá@„â  š0™å  —åƒà‘å Ñå!’çA Rã	  
Ô ƒáØ Æá Sá
 Réÿÿ* Zà0ËàLŸåNüÿëèÿÿêÔ ƒá@ŸåJüÿëäÿÿê
  ãƒüÿë0Ÿå›ÿÿë™å(ŸåBüÿë
  ã|üÿë ™åôAŸåÿ €â  á  áXüÿë €Pâh  
üŸåŒÿÿë0”å  Sã&  
 P ã0”åp á` áÿ ã&$ 0ƒàqˆ“åÈŸå(üÿë0™å0ƒà “å  Rã @ 	  
0“å¨ŸåÓçüÿë0™å@„â0ƒà “å RáõÿÿŠ
  ãRüÿë0™å™å ƒà`†â ’å Qá ‚âp‡àP…âÜÿÿŠ
  ãFüÿëPŸå^ÿÿë0™åÿ0ƒâ#4°áPH @   
 Ÿåµåÿûÿë0™å@„âÿ0ƒâ#Tá÷ÿÿ:
  ã4üÿë  áÿûÿëŸåJÿÿë aŸå|PâüpŸå€ áœ†â @ ãöå  á  á@¨åXşÿë áØ Ÿåæûÿë  áüÿë	 Váp‡â  „à@€âğÿÿ
  ãüÿë° Ÿå1ÿÿëGNâ@„âµå  ŸåÖûÿë Uáúÿÿ
  ãüÿëİâĞâğ½è€0Ÿå€ Ÿå ã 0“å5  ãáûÿë  ãñûÿë˜ ° È Ü ô ü   " ( 0 H |  ¤ \ p è   ø ( /" 0# @ P h ğ! ° 0@â Sã  Ú0Ñå_ Sã  
   ãÿ/á0Ñå_ Sãúÿÿp@-é`âP á @ áˆŸå  á  ãªûÿë  Pã  
  ápŸå  ã¤ûÿë  Pã  
  á\Ÿå  ãûÿë  Pã  
P…â Dâ  …à@Ÿå  ã–ûÿë  Pã  
 Dâ  …à(Ÿå  ãûÿëoá  áp€½è  ãp€½èt | „ Œ ” Ğ ÁáğA-éĞ@Àá Uá T  Š=  :`åP‘å  Öå ÀÕåß âßÀâW BâWÀLâ/oáÏoá¢" á¬Â á Rá  
 làğ½èp á € á á å«ÿÿë á @ á —å§ÿÿë  Tá  
 `àğ½è  ãğ½è0Öå`†â_ Sã  0 á óå_ Rãüÿÿ
 Õå0fàP…â_ Rã    áòå_ Qãüÿÿ
 eà Sá  
 bàğ½è0ÕåP…â_ Sã 0 ñÿÿ
0˜å —å `àğ½è  àãğ½è   ãîÿÿêøC-é p áL`ŸåLPŸå`àPà`eà€ á áûÿëFa°áøƒ½PEâ @ ã@„â0µå  á á	  á3ÿ/á Tá÷ÿÿøƒ½èÔ Ì ÿ/á@-é€½è  H \ è ø ( P       Usage: kallsyms [--all-symbols] [--symbol-prefix=<prefix char>] [--page-offset=<CONFIG_PAGE_OFFSET>] < in.map > out.S
  %llx %c %499s
  Read error or end of file.
 Symbol %s too long for kallsyms (%zu vs %d).
Please increase KSYM_NAME_LEN both in kernel and kallsyms.c
   _text   __kernel_syscall_via_break  __kernel_syscall_via_epc    __kernel_sigtramp   __gp    axtd    kallsyms failure: unable to allocate required amount of memory
 .globl %c%s
    .globl %s
  	ALGN   %c%s:
  %s:
    #include <asm/types.h>  #if BITS_PER_LONG == 64 #define PTR .quad   #define ALGN .align 8   #else   #define PTR .long   #define ALGN .align 4   #endif  	.section .rodata, "a"  kallsyms_addresses  kallsyms_num_syms   	PTR	%d
    	PTR	_text + %#llx
 	PTR	_text - %#llx
 	PTR	%#llx
 kallsyms failure: unable to allocate required memory
   kallsyms_names  kallsyms_markers    	.byte 0x%02x   , 0x%02x    kallsyms_token_table    	.asciz	"%s"
   kallsyms_token_index    	.short	%d
 start_  stop_   end_    _start  _end    --all-symbols   --absolute-percpu   --symbol-prefix=    --page-offset=  out of memory
  _veneer No valid symbol.
   _SDA_BASE_  _SDA2_BASE_ __per_cpu_start __per_cpu_end   _stext  _etext  _sinittext  _einittext  _stext_l1   _etext_l1   _stext_l2   _etext_l2   ¸ïÿ                                                                                           H                ˜    €                        õşÿo”    D    t 
                      ô     Ğ            È    °             şÿÿo€ ÿÿÿo   ğÿÿoD                                                           ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤                 H P                 X d                 p |                 ˆ ”                 ( 8 ÿÿÿÿÿÿÿÿ        GCC: (Raspbian 4.9.2-10) 4.9.2 GCC: (Raspbian 4.8.4-1) 4.8.4 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.exidx .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .comment .ARM.attributes                     4           P           p           ”           t           D           D           €           °      	     È      
     ˜           ¤           ğ           €           ˆ                       ¨                                                            ô            p!           ğ!                                               ñÿJ   P        M   X        J            J   ˆ        J   ˆ        J   p!        P            ñÿM   ”        ™   ”       J   °        M   ˜        M   €        ¦            ñÿM            M   „        ï            ñÿM   €        ú   € ˆ     J            M              „     M   ğ          ğ ,     J           !  Œ     J   ä        M           -   €     J   „        M   œ        :  œ x    J   ¤        M           D   à     J   à        M   ô        o  ô $    M           J           J   Œ          Œ $     J   x!        ”  x! `        Ø!      J   °        J    "        ­   "      À  "      Æ  "      Ğ  "      Ö  "      â  "      ò   "        ("                 ñÿ          M   ¸        '  ¸       J   Ü        M   è        <  è       J           J   t!        M            O          J   D        e  ü!      J            t          M   H        ›  H       J   x        J             §           J   ü!        Æ           ñÿM           J   t        M   |                   ñÿJ   ¨        Ò  ¨       J            à                       ñÿì           ı                        ô        M   ¤        J   ´        M   ¸        /  |      ?  0"      N             `              |  p!        ‡             ™  ğ!       §             Â             Õ             å             ö               0%         ğ!                    ,  €       2  0%       >             Q  ğ!      c             u  0#      €  p!                                 ¯             Ì             ë              ú  t!                                '  0%      4  ˆ      C             U             g             z  ø!      ‹   d     ›             ­  0%       ²             Å  X       Ì             à  0%       è  ğ!       ô   <    ù                             ğ!      *              D             W             h  ˜        /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crt1.o $d $a /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crti.o call_weak_fn /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crtn.o kallsyms.c expand_symbol check_symbol_range usage read_symbol output_label write_src may_be_linker_script_provide_symbol.isra.2 compare_symbols special_symbols.5761 text_ranges percpu_range symbol_prefix_char _text table_cnt table all_symbols absolute_percpu kernel_start_addr table_size crtstuff.c __JCR_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.9004 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry elf-init.oS __FRAME_END__ __JCR_END__ __init_array_end _DYNAMIC __init_array_start _GLOBAL_OFFSET_TABLE_ __libc_csu_fini best_table_len strcmp@@GLIBC_2.4 _ITM_deregisterTMCloneTable data_start printf@@GLIBC_2.4 __bss_start__ __isoc99_fscanf@@GLIBC_2.7 memmove@@GLIBC_2.4 free@@GLIBC_2.4 fgets@@GLIBC_2.4 memcpy@@GLIBC_2.4 _bss_end__ _edata memcmp@@GLIBC_2.4 _fini __bss_end__ realloc@@GLIBC_2.4 stderr@@GLIBC_2.4 fwrite@@GLIBC_2.4 best_table __data_start puts@@GLIBC_2.4 malloc@@GLIBC_2.4 __libc_start_main@@GLIBC_2.4 __ctype_toupper_loc@@GLIBC_2.4 __gmon_start__ __dso_handle exit@@GLIBC_2.4 feof@@GLIBC_2.4 token_profit _IO_stdin_used strlen@@GLIBC_2.4 strchr@@GLIBC_2.4 fprintf@@GLIBC_2.4 stdin@@GLIBC_2.4 __libc_csu_init memset@@GLIBC_2.4 _end putchar@@GLIBC_2.4 _start strtoull@@GLIBC_2.4 __end__ __bss_start main _Jv_RegisterClasses qsort@@GLIBC_2.4 __TMC_END__ _ITM_registerTMCloneTable strncmp@@GLIBC_2.4 abort@@GLIBC_2.4 _init                                                    4 4                    #         P P                     1         p p  $                  D   öÿÿo   ” ”  à                N         t t  Ğ              V         D D                    ^   ÿÿÿo   D D  :                k   şÿÿo   € €  0                z   	      ° °                  ƒ   	   B   È È  Ğ               Œ         ˜ ˜                    ‡         ¤ ¤  L                ’         ğ ğ                   ˜         € €                             ˆ ˆ                   ¦     p‚                         ±         ¨ ¨                    »                                  Ç                                Ó                                Ø              è                á         ô  ô   x                 æ         p! p!  €                  ì         ğ! ğ!  @                ñ      0       ğ!  =                 ú     p        -"  1                                ^"  
                               h#  À
     x         	              (.  n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ELF          (    $ 4   <4   4    (     pÜ  Ü Ü                4   4  4                 4  4 4                          è  è                     X  <                  è   è            P  P P D   D         Qåtd                          /lib/ld-linux-armhf.so.3             GNU                        GNU 1¹&6Q6›OW:	¹Ä€ìNä$            BIĞ2Aö‚ @@ D%                       
                                 3Ä÷|‹sx‹‡ÿ}í?~–|•ÅK.N=ö?ùÿ¼8ò‹#ù¤ûnÁ³÷!Ï	ıfII"³¢÷^–“	¬ù=­98èDêvş)Œ                ±                  X!                    :                                          ¨              –              ©              q   `!      )              #                 h!      H              \              j   l!      †                            O              V              x              A   d!       libc.so.6 exit fopen optind abort fgetc __errno_location getopt stdout fclose malloc raise __ctype_b_loc optarg stderr fwrite opterr strcmp strerror __libc_start_main vfprintf __gmon_start__ GLIBC_2.4                                      ii   À       D!   X!   `! 
  d!   h!   l!    !   !   !   !   !   !   !   !    !   $!   (!   ,! 	  0!   4!   8!   <!   @!   @-éò ë€½èà-åàŸåààğ¾åL  ÆâÊŒâLû¼å ÆâÊŒâDû¼å ÆâÊŒâ<û¼å ÆâÊŒâ4û¼å ÆâÊŒâ,û¼å ÆâÊŒâ$û¼å ÆâÊŒâû¼å ÆâÊŒâû¼å ÆâÊŒâû¼å ÆâÊŒâû¼å ÆâÊŒâüú¼å ÆâÊŒâôú¼å ÆâÊŒâìú¼å ÆâÊŒâäú¼å ÆâÊŒâÜú¼å ÆâÊŒâÔú¼å ÆâÊŒâÌú¼åğO-éP á@JŸå@:Ÿå@zŸå@ŠŸå ‘åĞMâ ` á   ã „å  ƒå  á á *ŸåÚÿÿë pã  
h0@â SãñŸ—  ê      (      4 Ğ9Ÿå`Fâ 0“å Vá$  
Ø ë 0—å0„åßÿÿê 0—å 0ˆåÜÿÿê —å Ÿå	  áœÿÿë  Pã0 0ˆÔÿÿ
	  á„Ÿå•ÿÿë  Pã0 0ˆÍÿÿ
	  álŸåÿÿë  Pã0 0ˆÆÿÿ
	  áTŸå‡ÿÿë  Pãİÿÿ0 ã0ˆå¾ÿÿê1•ç8Ÿå  á0„å€ÿÿë iŸå PPâ. 
ÿÿëP Pã(   á™ÿÿë10@â  á SãñŸ—\  ê      ”åÜŸåŒ ë  á ë „å  á› ë „å p á  ágÿÿë  Pã € á$ „å `    ê ”å€ €à^ÿÿë  Pãˆç 
`†â Váöÿÿ2 Yã" 
3 Yã   á‚ ë0¸Ÿå 0 ã0å p á   á0”å å Rá/  * á ` ã"  ê$0›å  á††àÀ“ç`†âÀåo ëÿ0 ã á“  àS ëÀå$0›å	 Ìç0“ç  á	0ƒà0åc ëÿ0 ã á“  àG ë$›å0å Ãå0‘ç  á	ƒàX ëÿ0 ã á“  à< ë Éå0”å VáÙÿÿ:0å0ƒâ0åÎÿÿê”å„Ÿå5 ë  á5ÿÿëP7Ÿå0“å0Câ SãñŸ—À  ê@ °
 ô	 ¤	 `”åà”å$P”å À ã \á› 
 0 ã Sá•  
•çƒ ƒà€à Ğç ÑåÑå Pá Qs  
Ÿå ëÌ¦Ÿå 0 ã0å0”å å Rá3 *± á € ã0”å Xáx  * šå  Qãˆp c  
$0šåˆp á ‡àÀ“ç´Ÿå0Œà`ÜçPÓåàÓå À ã  êÀŒâ \á €âa  
0Ğå  ĞåĞå Rá S0  0  Yá 0 0  Sãïÿÿ
 \áS  
€ˆâÙÿÿê ”å€”å$”å p ã
 Wá¶  
 ` ã VáT  
™ç† †à0àPÑçàÓåÀÓåŸå   ã  ê €â Pãâg 
0Ñå  Ñå°Ñå Rá S0  0  [á 0 0  Sãïÿÿ
`†ââÿÿê`”åà”å$P”å À ã \á 
 0 ã Sá,  
•çƒ ƒà€à Ğç ÑåÑåp€áp‘á
  
ÿ Rãÿ P     ÿ Qã      Rã  TŸå¥ ë0ƒâçÿÿê0ƒâ~ÿÿê$ ”åp‡à0à ’ç0„àp‚àâ° ×á ×å „å¸Ãá* Ãå«ÿÿêà QãğÿÿŸå ë0å0ƒâ0åyÿÿêÀŒâËÿÿêÀŒâbÿÿêp‡â£ÿÿê0•å ã  ãÌŸåbşÿëˆ4Ÿå •åÀŸå  “å ` ãtşÿë(P…â`å  ê Uå ë Uå ë Uå ë`†â 0”åP…â Váôÿÿ:& ë   ã]şÿë ´Ÿå  ã0 ã0„å0”å Yá-ÿÿ*	q á ` ã  ê$0›å  á†€†à “ço ë`†â Šà @âp0ïæ0Âå0Âå0Êç0”å Váğÿÿ:‰âèÿÿê  áa ë¬£Ÿå   ã å 0 á å0å0”å å Ráÿÿ* á  ã  ê$ šå  á‰`‰àp’çO ëÿ0 ã åå°‡à‰â“  à0 ëp ïæ Ëå Ëå Çç ”å Yáìÿÿ:0å0ƒâ0åáÿÿêw ë 0 ã0å0”å å Rá´ÿÿ* € ã1 á0å°”å Xá=  *è2Ÿå åˆˆà$0“åãŸå À ã “ç  á	0Šà	pÚç`ÓåPÓå  êÀŒâ \ã €â  
0Ğå  ĞåĞå Rá S0  0  Qá 0 0  Sãïÿÿ
R á0ˆâ Sáu ïæ  *‰â	0Šà	pÚçÀÓå`Óå P ã  êP…â Uãàâ  
0Şå  ŞåŞå Rá S0  0  Qá 0 0  Sãïÿÿ
P€áu ïæ~ ë€ˆâ¾ÿÿê0å0ƒâ0å³ÿÿê( ëÜ‘Ÿå ` ã0”åĞQŸå VáLÿÿ*Q á p ã0”å Wá"  *  ™å  Pã  
$ ™å‡0‡àÔŸåà’ç À ã à Şç€ÒåàÒå  êÀŒâ  \áâ  
0Ñå  Ñå°Ñå
 Rá S0  0  [á 0 0  Sãïÿÿ
  á  €âp‡âp ïæJ ëÙÿÿê`†âÑÿÿê÷  ëŸå p ã0”å Wá5ÿÿ*a á P ãà”å ^á  š$ ˜å…À…à 0 ã ’ç  áÀ‚à…â€  ã  ê Uá0ƒâ  *ÜçP…â  Qã  ‚	 Uá¢  áõÿÿ( ëçÿÿêp‡âàÿÿêÕ  ë€Ÿå p ã0”å Wáÿÿ*a á P ã  ê$ ˜å…0…àP…â ’ç Òç ë0”å Uáöÿÿ:p‡âîÿÿê–åp Ÿåp  ëkıÿë@–å  åVıÿë á   áp Ÿåh  ël Ÿåf  ëaıÿë  åMıÿë  áX Ÿå`  ët! h! l! P! ° X! ¸ À È Ğ Ø  ø h œ! à L Ì   Ü \ t  ° ã à ãä  á -å -åÀŸåÀ-å Ÿå0Ÿå%ıÿëEıÿë¼ x X 0Ÿå Ÿå0à “ç  Rãÿ/ ıÿê„ P   0Ÿå Ÿå0`à Sãÿ/‘0Ÿå  Sãÿ/ÿ/á[! X!     $Ÿå$ Ÿå`àA á¡àÁ°áÿ/0Ÿå  Sãÿ/ÿ/áX! X!     @-é@Ÿå 0Ôå  Sã€½ßÿÿë0 ã 0Äå€½èp! @-é$ Ÿå 0å  Sã  @½èàÿÿê0Ÿå  Sãúÿÿ
3ÿ/áøÿÿê       -é$Ÿåà-åĞMâ0â  ‘å  áå0åúüÿë  ãæüÿë`! @-é0Ÿå Ÿå “åíÿÿët!  øC-é P á  ê×üÿë 0å p á¶ “á:âs0ÿæ  Sã  
  áİüÿë pã @ á!  
# Pã€` ïÿÿ  áÕüÿë pã @ á  

 Pãøÿÿ` ãæÿÿêl€Ÿå` á  ê1†à ˜åƒ0„à  Rã0`CâLŸå	    áÂüÿë pã @ á
  
  —å€0 á³ ’áãîÿÿ  áøƒ½è0Ÿå Ÿå“åµÿÿë™å Ÿå²ÿÿët! ô 8@-éü@Ÿå ”å  Pã0  
ğŸå‡üÿë  Pã 0 á „å.  
 ã  ãÔ Ÿå‚üÿë0”å ã  ãÄ Ÿå}üÿëÀPŸå0”å ã  ã´ Ÿåwüÿë ”å ”å¨Ÿå‹üÿë0”å ã  ã Ÿånüÿë  •å ”åˆŸå‚üÿë0”å ã  ãx Ÿåeüÿë ã  ã0”åh Ÿå`üÿë  •å ”å\Ÿå8@½èsüÿêT0Ÿå 0“å0„åĞÿÿêqüÿë@”å  å\üÿë á   á0 Ÿånÿÿët!  ( , P! H L x Œ ” ´ d!  @-é   áL@ŸåL0Ÿå”å ”å“1ÌàÁ? áÌ0càƒ0ƒàQá    Qã(Ÿ(ŸJüÿë0”å0ƒâ0„å€½èŸåDüÿëøÿÿêt! «ªª*ğ ü ä 8@-é ãÈ@ŸåÈPŸå  ã0”åÀ Ÿåüÿë  •å¸Ÿå ”å2üÿë°0Ÿå •å¬Ÿå ”å!“ç,üÿë ”åœŸå ”å(üÿë ”å ”åŒŸå$üÿë0•å Sã  
  •åxŸå ”åüÿë  ã0”åh Ÿå ã üÿë0”å4 Ÿå  Sã8€½ ’å8@½èüÿê  ”å ”å<Ÿåüÿë ”å4Ÿå  •å	üÿëæÿÿêt! P!   Ì 8 H X ” ¨ l €  Qâÿ/t  : Pák  š ál  
?oá/oá0Bà0sâƒ0ƒ   ãñ   áPá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ 
Pá ¢à
@ 
Pá ¢à
@ 	Pá ¢à	@ 	Pá ¢à	@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@ Pá ¢à@  Pá ¢à @  Pá ¢à @   áÿ/á     ÿ/á/oá bâ0 áÿ/á  Pã  à  ê  Qãúÿÿ
@-é€ÿÿë@½è’ àAàÿ/á@-é  ãUûÿë€½èøC-é p áL`ŸåLPŸå`àPà`eà€ á áBûÿëFa°áøƒ½PEâ @ ã@„â0µå  á á	  á3ÿ/á Tá÷ÿÿøƒ½è” Œ ÿ/á@-é€½è      „ ” ¨ ¼      ª ª  ªªª  ª ªªU ªªªUUUUUÿUÿUUÿÿÿUUÿUÿÿÿUÿÿÿ
Usage: %s [options] <filename>

Valid options:
    -h          : display this usage information
    -n <name>   : specify logo name (default: linux_logo)
    -o <output> : output to file <output> instead of stdout
    -t <type>   : specify logo type, one of
                      mono    : monochrome black/white
                      vga16   : 16 colors VGA text palette
                      clut224 : 224 colors (default)
                      gray256 : 256 levels grayscale

    %s: end of file
    w   Cannot create file %s: %s
  /*
  *  DO NOT EDIT THIS FILE!
  *
  *  It was automatically generated from %s
  *  Linux logo %s
   */

   #include <linux/linux_logo.h>

 static unsigned char %s_data[] __initdata = {
  , 0x%02x    ,
	0x%02x   	0x%02x 
};

   const struct linux_logo %s __initconst = {
 	.type		= %s,
  	.width		= %d,
 	.height		= %d,
    	.clutsize	= %d,
   	.clut		= %s_clut,
 	.data		= %s_data
  };

    hn:o:t: mono    vga16   clut224 gray256 r   Cannot open file %s: %s
    %s is not a PNM file
   %s: Binary PNM is not supported
Use pnmnoraw(1) to convert it to ASCII PNM
 Image must use the 16 console colors only
Use ppmquant(1) -map clut_vga16.ppm to reduce the number of colors
   Image has more than %d colors
Use ppmquant(1) to reduce the number of colors
   static unsigned char %s_clut[] __initdata = {
  Image must be monochrome
   Image must be grayscale
    LINUX_LOGO_MONO LINUX_LOGO_VGA16    LINUX_LOGO_CLUT224  LINUX_LOGO_GRAY256  linux_logo  Hòÿ                                                                                                                                                                                                                                                                                                ì              Œ    À                        õşÿo”    ¼    L 
   Ê                   ô     ˆ                Ô    0         şÿÿo´ ÿÿÿo   ğÿÿo†                                                           ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜ ˜             Ğ    GCC: (Raspbian 4.9.2-10) 4.9.2 GCC: (Raspbian 4.8.4-1) 4.8.4 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.exidx .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .comment .ARM.attributes                     4           P           p           ”           L           ¼           †           ´           Ô      	           
     Œ           ˜           x           À           È           Ü           ä                                                            ô            H!           X!                                               ñÿJ   P        M   $        J   Ü        J   T        J   È        J   H!        P            ñÿM   `        ™   `       J   |        M   Œ        M   À        ¦            ñÿM   ”        M   Ä        ï            ñÿM   L        û   L 4     J   |        M   €        ÿ   €      J   ”        M   œ          œ ì     J   €        M   ˆ          ˆ <    J           M   Ä          Ä p     J            M   4        '  4     J           M   x        J   Ğ        M           J   ô        M           J   ”	        M   ¤	        J   È        J   Ì        4  Ì      ?  à 0     J   P!        J  P!      S  T!      J           J   t!        ]  t!      i  x!      r  |!        €!      Š  „!        ˆ!      œ  Œ!      §  !      ³  ”!      Á  ˜!      Ë  œ!      Õ           ñÿà          M   „        í  „       J   ¨        M   ´          ´       J   à        J   L!        M   ì          ì       J           +  p!      J            :          M           a         J   D        J             m           J   p!        Œ           ñÿM   <        —  <        ¯            ñÿµ           ñÿM   H        Á           ñÿM   X        J   ´        M   ¼        Õ           ñÿJ   ä        Í  ä       J            Û                       ñÿç           ø                        ô        M   ˜        J   ¨        M   ¬        *  ¼      :             K  <      Y             k              ‡  H!        ’  X!                     ±  <$       ¼  X!       Ã  À       É  X!      Û  <$       ç  `!      ù               H    "   H!       &             8             U             i              x  < ì   ‚  L!                   ¨             ¸  È      Ç             Ù             ì  X d     ü               <$         $       $             5  <$       =  H    " K  d!      ]  X!       i             {  x ¬
    €             ”  (      ¥              ¹  h!      Ë  X!      ×              ñ  l!                     Œ        /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crt1.o $d $a /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crti.o call_weak_fn /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crtn.o pnmtologo.c die usage get_number write_header write_hex write_footer logo_types clut_vga16 logoname logo_type programname filename is_plain_pbm outputname out write_hex_cnt logo_width logo_height logo_clutsize logo_data logo_clut crtstuff.c __JCR_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.9004 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry _udivsi3.o .udivsi3_skip_div0_test shift _dvmd_lnx.o elf-init.oS __FRAME_END__ __JCR_END__ __init_array_end _DYNAMIC __init_array_start _GLOBAL_OFFSET_TABLE_ __libc_csu_fini raise@@GLIBC_2.4 __aeabi_uidiv strcmp@@GLIBC_2.4 _ITM_deregisterTMCloneTable data_start __bss_start__ fopen@@GLIBC_2.4 _bss_end__ _edata _fini optind@@GLIBC_2.4 __bss_end__ stderr@@GLIBC_2.4 fwrite@@GLIBC_2.4 __aeabi_ldiv0 __data_start malloc@@GLIBC_2.4 __libc_start_main@@GLIBC_2.4 strerror@@GLIBC_2.4 __gmon_start__ __udivsi3 __dso_handle __ctype_b_loc@@GLIBC_2.4 exit@@GLIBC_2.4 _IO_stdin_used getopt@@GLIBC_2.4 fprintf@@GLIBC_2.4 __libc_csu_init __errno_location@@GLIBC_2.4 _end _start fgetc@@GLIBC_2.4 __end__ __aeabi_idiv0 stdout@@GLIBC_2.4 __bss_start fclose@@GLIBC_2.4 main vfprintf@@GLIBC_2.4 __aeabi_uidivmod _Jv_RegisterClasses opterr@@GLIBC_2.4 __TMC_END__ _ITM_registerTMCloneTable optarg@@GLIBC_2.4 abort@@GLIBC_2.4 _init                                                    4 4                    #         P P                     1         p p  $                  D   öÿÿo   ” ”  ¸                N         L L  p              V         ¼ ¼  Ê                  ^   ÿÿÿo   † †  .                k   şÿÿo   ´ ´                   z   	      Ô Ô  0                ƒ   	   B      ˆ               Œ         Œ Œ                    ‡         ˜ ˜  à                 ’         x x  H                 ˜         À À                             È È                   ¦     p‚   Ü Ü                   ±         ä ä                    »                                  Ç                                Ó                                Ø              è                á         ô  ô   T                 æ         H! H!                    ì         X! X!  ä                 ñ      0       X!  =                 ú     p        •!  1                                Æ!  
                               Ğ"  P     …         	               .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       cmd_scripts/mod/mk_elfconfig := gcc -Wp,-MD,scripts/mod/.mk_elfconfig.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89     -o scripts/mod/mk_elfconfig scripts/mod/mk_elfconfig.c  

source_scripts/mod/mk_elfconfig := scripts/mod/mk_elfconfig.c

deps_scripts/mod/mk_elfconfig := \
  /usr/include/stdc-predef.h \
  /usr/include/stdio.h \
  /usr/include/features.h \
  /usr/include/arm-linux-gnueabihf/sys/cdefs.h \
  /usr/include/arm-linux-gnueabihf/bits/wordsize.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs-hard.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h \
  /usr/include/arm-linux-gnueabihf/bits/types.h \
  /usr/include/arm-linux-gnueabihf/bits/typesizes.h \
  /usr/include/libio.h \
  /usr/include/_G_config.h \
  /usr/include/wchar.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio_lim.h \
  /usr/include/arm-linux-gnueabihf/bits/sys_errlist.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio.h \
  /usr/include/stdlib.h \
  /usr/include/arm-linux-gnueabihf/bits/waitflags.h \
  /usr/include/arm-linux-gnueabihf/bits/waitstatus.h \
  /usr/include/endian.h \
  /usr/include/arm-linux-gnueabihf/bits/endian.h \
  /usr/include/arm-linux-gnueabihf/bits/byteswap.h \
  /usr/include/arm-linux-gnueabihf/bits/byteswap-16.h \
  /usr/include/arm-linux-gnueabihf/sys/types.h \
  /usr/include/time.h \
  /usr/include/arm-linux-gnueabihf/sys/select.h \
  /usr/include/arm-linux-gnueabihf/bits/select.h \
  /usr/include/arm-linux-gnueabihf/bits/sigset.h \
  /usr/include/arm-linux-gnueabihf/bits/time.h \
  /usr/include/arm-linux-gnueabihf/sys/sysmacros.h \
  /usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h \
  /usr/include/alloca.h \
  /usr/include/arm-linux-gnueabihf/bits/stdlib-bsearch.h \
  /usr/include/arm-linux-gnueabihf/bits/stdlib-float.h \
  /usr/include/string.h \
  /usr/include/xlocale.h \
  /usr/include/arm-linux-gnueabihf/bits/string.h \
  /usr/include/arm-linux-gnueabihf/bits/string2.h \
  /usr/include/elf.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdint.h \
  /usr/include/stdint.h \
  /usr/include/arm-linux-gnueabihf/bits/wchar.h \
  /usr/include/arm-linux-gnueabihf/bits/auxv.h \

scripts/mod/mk_elfconfig: $(deps_scripts/mod/mk_elfconfig)

$(deps_scripts/mod/mk_elfconfig):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /* C global declaration parser for genksyms.
   Copyright 1996, 1997 Linux International.

   New implementation contributed by Richard Henderson <rth@tamu.edu>
   Based on original work by Bjorn Ekwall <bj0rn@blox.se>

   This file is part of the Linux modutils.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2 of the License, or (at your
   option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */


%{

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "genksyms.h"

static int is_typedef;
static int is_extern;
static char *current_name;
static struct string_list *decl_spec;

static void yyerror(const char *);

static inline void
remove_node(struct string_list **p)
{
  struct string_list *node = *p;
  *p = node->next;
  free_node(node);
}

static inline void
remove_list(struct string_list **pb, struct string_list **pe)
{
  struct string_list *b = *pb, *e = *pe;
  *pb = e;
  free_list(b, e);
}

/* Record definition of a struct/union/enum */
static void record_compound(struct string_list **keyw,
		       struct string_list **ident,
		       struct string_list **body,
		       enum symbol_type type)
{
	struct string_list *b = *body, *i = *ident, *r;

	if (i->in_source_file) {
		remove_node(keyw);
		(*ident)->tag = type;
		remove_list(body, ident);
		return;
	}
	r = copy_node(i); r->tag = type;
	r->next = (*keyw)->next; *body = r; (*keyw)->next = NULL;
	add_symbol(i->string, type, b, is_extern);
}

%}

%token ASM_KEYW
%token ATTRIBUTE_KEYW
%token AUTO_KEYW
%token BOOL_KEYW
%token CHAR_KEYW
%token CONST_KEYW
%token DOUBLE_KEYW
%token ENUM_KEYW
%token EXTERN_KEYW
%token EXTENSION_KEYW
%token FLOAT_KEYW
%token INLINE_KEYW
%token INT_KEYW
%token LONG_KEYW
%token REGISTER_KEYW
%token RESTRICT_KEYW
%token SHORT_KEYW
%token SIGNED_KEYW
%token STATIC_KEYW
%token STRUCT_KEYW
%token TYPEDEF_KEYW
%token UNION_KEYW
%token UNSIGNED_KEYW
%token VOID_KEYW
%token VOLATILE_KEYW
%token TYPEOF_KEYW

%token EXPORT_SYMBOL_KEYW

%token ASM_PHRASE
%token ATTRIBUTE_PHRASE
%token TYPEOF_PHRASE
%token BRACE_PHRASE
%token BRACKET_PHRASE
%token EXPRESSION_PHRASE

%token CHAR
%token DOTS
%token IDENT
%token INT
%token REAL
%token STRING
%token TYPE
%token OTHER
%token FILENAME

%%

declaration_seq:
	declaration
	| declaration_seq declaration
	;

declaration:
	{ is_typedef = 0; is_extern = 0; current_name = NULL; decl_spec = NULL; }
	declaration1
	{ free_list(*$2, NULL); *$2 = NULL; }
	;

declaration1:
	EXTENSION_KEYW TYPEDEF_KEYW { is_typedef = 1; } simple_declaration
		{ $$ = $4; }
	| TYPEDEF_KEYW { is_typedef = 1; } simple_declaration
		{ $$ = $3; }
	| simple_declaration
	| function_definition
	| asm_definition
	| export_definition
	| error ';'				{ $$ = $2; }
	| error '}'				{ $$ = $2; }
	;

simple_declaration:
	decl_specifier_seq_opt init_declarator_list_opt ';'
		{ if (current_name) {
		    struct string_list *decl = (*$3)->next;
		    (*$3)->next = NULL;
		    add_symbol(current_name,
			       is_typedef ? SYM_TYPEDEF : SYM_NORMAL,
			       decl, is_extern);
		    current_name = NULL;
		  }
		  $$ = $3;
		}
	;

init_declarator_list_opt:
	/* empty */				{ $$ = NULL; }
	| init_declarator_list
	;

init_declarator_list:
	init_declarator
		{ struct string_list *decl = *$1;
		  *$1 = NULL;
		  add_symbol(current_name,
			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
		  current_name = NULL;
		  $$ = $1;
		}
	| init_declarator_list ',' init_declarator
		{ struct string_list *decl = *$3;
		  *$3 = NULL;
		  free_list(*$2, NULL);
		  *$2 = decl_spec;
		  add_symbol(current_name,
			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
		  current_name = NULL;
		  $$ = $3;
		}
	;

init_declarator:
	declarator asm_phrase_opt attribute_opt initializer_opt
		{ $$ = $4 ? $4 : $3 ? $3 : $2 ? $2 : $1; }
	;

/* Hang on to the specifiers so that we can reuse them.  */
decl_specifier_seq_opt:
	/* empty */				{ decl_spec = NULL; }
	| decl_specifier_seq
	;

decl_specifier_seq:
	decl_specifier				{ decl_spec = *$1; }
	| decl_specifier_seq decl_specifier	{ decl_spec = *$2; }
	;

decl_specifier:
	storage_class_specifier
		{ /* Version 2 checksumming ignores storage class, as that
		     is really irrelevant to the linkage.  */
		  remove_node($1);
		  $$ = $1;
		}
	| type_specifier
	;

storage_class_specifier:
	AUTO_KEYW
	| REGISTER_KEYW
	| STATIC_KEYW
	| EXTERN_KEYW	{ is_extern = 1; $$ = $1; }
	| INLINE_KEYW	{ is_extern = 0; $$ = $1; }
	;

type_specifier:
	simple_type_specifier
	| cvar_qualifier
	| TYPEOF_KEYW '(' parameter_declaration ')'
	| TYPEOF_PHRASE

	/* References to s/u/e's defined elsewhere.  Rearrange things
	   so that it is easier to expand the definition fully later.  */
	| STRUCT_KEYW IDENT
		{ remove_node($1); (*$2)->tag = SYM_STRUCT; $$ = $2; }
	| UNION_KEYW IDENT
		{ remove_node($1); (*$2)->tag = SYM_UNION; $$ = $2; }
	| ENUM_KEYW IDENT
		{ remove_node($1); (*$2)->tag = SYM_ENUM; $$ = $2; }

	/* Full definitions of an s/u/e.  Record it.  */
	| STRUCT_KEYW IDENT class_body
		{ record_compound($1, $2, $3, SYM_STRUCT); $$ = $3; }
	| UNION_KEYW IDENT class_body
		{ record_compound($1, $2, $3, SYM_UNION); $$ = $3; }
	| ENUM_KEYW IDENT enum_body
		{ record_compound($1, $2, $3, SYM_ENUM); $$ = $3; }
	/*
	 * Anonymous enum definition. Tell add_symbol() to restart its counter.
	 */
	| ENUM_KEYW enum_body
		{ add_symbol(NULL, SYM_ENUM, NULL, 0); $$ = $2; }
	/* Anonymous s/u definitions.  Nothing needs doing.  */
	| STRUCT_KEYW class_body			{ $$ = $2; }
	| UNION_KEYW class_body				{ $$ = $2; }
	;

simple_type_specifier:
	CHAR_KEYW
	| SHORT_KEYW
	| INT_KEYW
	| LONG_KEYW
	| SIGNED_KEYW
	| UNSIGNED_KEYW
	| FLOAT_KEYW
	| DOUBLE_KEYW
	| VOID_KEYW
	| BOOL_KEYW
	| TYPE			{ (*$1)->tag = SYM_TYPEDEF; $$ = $1; }
	;

ptr_operator:
	'*' cvar_qualifier_seq_opt
		{ $$ = $2 ? $2 : $1; }
	;

cvar_qualifier_seq_opt:
	/* empty */					{ $$ = NULL; }
	| cvar_qualifier_seq
	;

cvar_qualifier_seq:
	cvar_qualifier
	| cvar_qualifier_seq cvar_qualifier		{ $$ = $2; }
	;

cvar_qualifier:
	CONST_KEYW | VOLATILE_KEYW | ATTRIBUTE_PHRASE
	| RESTRICT_KEYW
		{ /* restrict has no effect in prototypes so ignore it */
		  remove_node($1);
		  $$ = $1;
		}
	;

declarator:
	ptr_operator declarator			{ $$ = $2; }
	| direct_declarator
	;

direct_declarator:
	IDENT
		{ if (current_name != NULL) {
		    error_with_pos("unexpected second declaration name");
		    YYERROR;
		  } else {
		    current_name = (*$1)->string;
		    $$ = $1;
		  }
		}
	| direct_declarator '(' parameter_declaration_clause ')'
		{ $$ = $4; }
	| direct_declarator '(' error ')'
		{ $$ = $4; }
	| direct_declarator BRACKET_PHRASE
		{ $$ = $2; }
	| '(' declarator ')'
		{ $$ = $3; }
	| '(' error ')'
		{ $$ = $3; }
	;

/* Nested declarators differ from regular declarators in that they do
   not record the symbols they find in the global symbol table.  */
nested_declarator:
	ptr_operator nested_declarator		{ $$ = $2; }
	| direct_nested_declarator
	;

direct_nested_declarator:
	IDENT
	| TYPE
	| direct_nested_declarator '(' parameter_declaration_clause ')'
		{ $$ = $4; }
	| direct_nested_declarator '(' error ')'
		{ $$ = $4; }
	| direct_nested_declarator BRACKET_PHRASE
		{ $$ = $2; }
	| '(' nested_declarator ')'
		{ $$ = $3; }
	| '(' error ')'
		{ $$ = $3; }
	;

parameter_declaration_clause:
	parameter_declaration_list_opt DOTS		{ $$ = $2; }
	| parameter_declaration_list_opt
	| parameter_declaration_list ',' DOTS		{ $$ = $3; }
	;

parameter_declaration_list_opt:
	/* empty */					{ $$ = NULL; }
	| parameter_declaration_list
	;

parameter_declaration_list:
	parameter_declaration
	| parameter_declaration_list ',' parameter_declaration
		{ $$ = $3; }
	;

parameter_declaration:
	decl_specifier_seq m_abstract_declarator
		{ $$ = $2 ? $2 : $1; }
	;

m_abstract_declarator:
	ptr_operator m_abstract_declarator
		{ $$ = $2 ? $2 : $1; }
	| direct_m_abstract_declarator
	;

direct_m_abstract_declarator:
	/* empty */					{ $$ = NULL; }
	| IDENT
		{ /* For version 2 checksums, we don't want to remember
		     private parameter names.  */
		  remove_node($1);
		  $$ = $1;
		}
	/* This wasn't really a typedef name but an identifier that
	   shadows one.  */
	| TYPE
		{ remove_node($1);
		  $$ = $1;
		}
	| direct_m_abstract_declarator '(' parameter_declaration_clause ')'
		{ $$ = $4; }
	| direct_m_abstract_declarator '(' error ')'
		{ $$ = $4; }
	| direct_m_abstract_declarator BRACKET_PHRASE
		{ $$ = $2; }
	| '(' m_abstract_declarator ')'
		{ $$ = $3; }
	| '(' error ')'
		{ $$ = $3; }
	;

function_definition:
	decl_specifier_seq_opt declarator BRACE_PHRASE
		{ struct string_list *decl = *$2;
		  *$2 = NULL;
		  add_symbol(current_name, SYM_NORMAL, decl, is_extern);
		  $$ = $3;
		}
	;

initializer_opt:
	/* empty */					{ $$ = NULL; }
	| initializer
	;

/* We never care about the contents of an initializer.  */
initializer:
	'=' EXPRESSION_PHRASE
		{ remove_list($2, &(*$1)->next); $$ = $2; }
	;

class_body:
	'{' member_specification_opt '}'		{ $$ = $3; }
	| '{' error '}'					{ $$ = $3; }
	;

member_specification_opt:
	/* empty */					{ $$ = NULL; }
	| member_specification
	;

member_specification:
	member_declaration
	| member_specification member_declaration	{ $$ = $2; }
	;

member_declaration:
	decl_specifier_seq_opt member_declarator_list_opt ';'
		{ $$ = $3; }
	| error ';'
		{ $$ = $2; }
	;

member_declarator_list_opt:
	/* empty */					{ $$ = NULL; }
	| member_declarator_list
	;

member_declarator_list:
	member_declarator
	| member_declarator_list ',' member_declarator	{ $$ = $3; }
	;

member_declarator:
	nested_declarator attribute_opt			{ $$ = $2 ? $2 : $1; }
	| IDENT member_bitfield_declarator		{ $$ = $2; }
	| member_bitfield_declarator
	;

member_bitfield_declarator:
	':' EXPRESSION_PHRASE				{ $$ = $2; }
	;

attribute_opt:
	/* empty */					{ $$ = NULL; }
	| attribute_opt ATTRIBUTE_PHRASE
	;

enum_body:
	'{' enumerator_list '}'				{ $$ = $3; }
	| '{' enumerator_list ',' '}'			{ $$ = $4; }
	 ;

enumerator_list:
	enumerator
	| enumerator_list ',' enumerator

enumerator:
	IDENT
		{
			const char *name = strdup((*$1)->string);
			add_symbol(name, SYM_ENUM_CONST, NULL, 0);
		}
	| IDENT '=' EXPRESSION_PHRASE
		{
			const char *name = strdup((*$1)->string);
			struct string_list *expr = copy_list_range(*$3, *$2);
			add_symbol(name, SYM_ENUM_CONST, expr, 0);
		}

asm_definition:
	ASM_PHRASE ';'					{ $$ = $2; }
	;

asm_phrase_opt:
	/* empty */					{ $$ = NULL; }
	| ASM_PHRASE
	;

export_definition:
	EXPORT_SYMBOL_KEYW '(' IDENT ')' ';'
		{ export_symbol((*$3)->string); $$ = $5; }
	;


%%

static void
yyerror(const char *e)
{
  error_with_pos("%s", e);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /* Generate kernel symbol version hashes.
   Copyright 1996, 1997 Linux International.

   New implementation contributed by Richard Henderson <rth@tamu.edu>
   Based on original work by Bjorn Ekwall <bj0rn@blox.se>

   This file is part of the Linux modutils.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2 of the License, or (at your
   option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef MODUTILS_GENKSYMS_H
#define MODUTILS_GENKSYMS_H 1

#include <stdio.h>

enum symbol_type {
	SYM_NORMAL, SYM_TYPEDEF, SYM_ENUM, SYM_STRUCT, SYM_UNION,
	SYM_ENUM_CONST
};

enum symbol_status {
	STATUS_UNCHANGED, STATUS_DEFINED, STATUS_MODIFIED
};

struct string_list {
	struct string_list *next;
	enum symbol_type tag;
	int in_source_file;
	char *string;
};

struct symbol {
	struct symbol *hash_next;
	const char *name;
	enum symbol_type type;
	struct string_list *defn;
	struct symbol *expansion_trail;
	struct symbol *visited;
	int is_extern;
	int is_declared;
	enum symbol_status status;
	int is_override;
};

typedef struct string_list **yystype;
#define YYSTYPE yystype

extern int cur_line;
extern char *cur_filename, *source_file;
extern int in_source_file;

struct symbol *find_symbol(const char *name, enum symbol_type ns, int exact);
struct symbol *add_symbol(const char *name, enum symbol_type type,
			  struct string_list *defn, int is_extern);
void export_symbol(const char *);

void free_node(struct string_list *list);
void free_list(struct string_list *s, struct string_list *e);
struct string_list *copy_node(struct string_list *);
struct string_list *copy_list_range(struct string_list *start,
				    struct string_list *end);

int yylex(void);
int yyparse(void);

void error_with_pos(const char *, ...);

/*----------------------------------------------------------------------*/
#define xmalloc(size) ({ void *__ptr = malloc(size);		\
	if(!__ptr && size != 0) {				\
		fprintf(stderr, "out of memory\n");		\
		exit(1);					\
	}							\
	__ptr; })
#define xstrdup(str)  ({ char *__str = strdup(str);		\
	if (!__str) {						\
		fprintf(stderr, "out of memory\n");		\
		exit(1);					\
	}							\
	__str; })

#endif				/* genksyms.h */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ELF          (            ä     4     (  	 <@Ÿå -é ãà-åĞMâÀâ 0”å  ã  ŸåÀåşÿÿë  ”åå åşÿÿë  ãşÿÿë        p@-éĞMâ0â é@å`å  Tã  
 ”åP”åşÿÿë  áşÿÿë @Uâøÿÿ  Vã  
  áĞâp@½èşÿÿêĞâp€½èğ@-é$ĞMâÀâ8@å Œè  Tã P áàå  
p á œè`â „à Tá †è  ª„@ á Táüÿÿº  á áşÿÿë  Pã  
på å –è …è  á$Ğâğ€½è œè …è  á$Ğâğ€½è á  Ÿå®ÿÿë   p@-éĞMâ 0 ã0å0å0å0â @ áP á  å` á éşÿÿë á ”å  áşÿÿë  á P„åĞâp€½èğC-éĞMâ0‚â 0å0â À ãP áÀåÀåÀå` á é € áÀåşÿÿë0å à˜å Uá˜å  Ú@‰àpiâ  êà‡à Ää0å Uá  Ú Öç0ƒâ0å\ Pãõÿÿ  áâşÿÿëñÿÿê   ã0â  á Éç 0ˆåĞâğƒ½èğG-é 0 á P á   ã ƒäĞMâ p á€ á á ƒå …å @ á  ê	 Tá  * yã	 d: 
0    …è  á 0å •èşÿÿëÀ •è
  á ã0 á ‡àşÿÿë @ á  áşÿÿë  Pã	  @”à  *  áşÿÿë  Pãâÿÿ
  á …èĞâğ‡½èşÿÿë  åşÿÿë  á Ÿå8ÿÿë Ÿå6ÿÿë,   P   ğ@-éĞMâ@â4På ` á „è  á ”è Påşÿÿëpå å0å  á €àşÿÿëP…àPå ”è †è  áĞâğ€½èğC-éĞMâPâ@@å8€å …è ` á •è  á @åşÿÿë ˜ååpå „à‰à  ‰à bàşÿÿë ˜å<å  ‰à  áşÿÿë0˜åp‡à  Sã  
“åàƒå0“å  Sãùÿÿpå •è †è  áĞâğƒ½èp@-é0ĞMâÀâD@å@àå`â Œè P á œè  á@èH@åşÿÿë –è$Àâ Œè, å  Rã    ê  á0’å  Sãûÿÿ ‚â @‚å œè  Tã …è  
 å0”å0ƒà0„å@”å  Tãùÿÿ 0 ãH0å<0â “éşÿÿë  á0Ğâp€½è, âéÿÿêğO-éDĞMâÀâp`å Œè Vã @ áhàålPåV  
F  Ú  Vã3  
@ VãN   á   ã< áÿ˜â€‚á‰á%< á€ˆá€ˆá. á ‚áu€ïæÿ|â% ál á.¼ á‰á%8 á(t á€Šáq`ïæ	°‹á‹ás ïæ& á ° ãå áğ¡ÍáåĞ!ÍáØ`Íá@0â"¼ á¤ á`†á	p‡á
€†á‡á  ãğcá å 0å œè8àå<Påşÿÿë  áDĞâğ½è4 áÿ8â<ƒá.$ á.<ƒáÿ,â@â0ƒá  ã0!å è œè0àåşÿÿë  áDĞâğ½è Vã	  @0â  ãàcå å 0å œèşÿÿë  áDĞâğ½è á< Ÿåeşÿë~0ÿæ~ïæ@ â#4 á4ƒá ã¸0báå  å œè¾âÍáşÿÿë  áDĞâğ½èt   ğO-édĞMâˆå à™å€™åÀ™ål á`å ` ã`åØ`ÍáD€å@àå`†áG€İå™å@ áä áC`İåÿXâLåp‡á  ã`å	p‡á`„áä áğbÍáØ`Íá\ áÿ¸âp…á`†áØ@ÍáøbÍáĞbÍá@å@å`†áĞAÍá€ áB İå@„á` áD@İå
” áHÀåJ€İå¬ á$´ á
@†á  áE@İå	p‡á  ãP…áğÍáˆ á`ŠáF İåKÀİåP…á° á$˜ á P ã
D á	p‹á€ á*\ á †áÀå°‡áÀå
@ áO İåØbÍáP á ° ã
`†áp‡á” á€ˆá‰áØaÍáğEÍá4Àâ`†áL€İå	p‡áà ã Œè(´ á¬ áM€İå
`†áp‡á œè(X áğaÍáN`İåH áĞÍá&¼ á€ˆá‰á¤ áPPâ Šá	°‹á @è @ áø¥Íáşÿÿë  ádĞâğ½èp@-é ĞMâÀâ0`å à ã P ã Œè @ á œè `å @éşÿÿë  á Ğâp€½èĞ@-é ĞMâÀâĞcÍá@à ã Œè @ á œèğ`Íáàåşÿÿë  á ĞâĞ€½è0@-éĞMâÀâà ã(Pâ Œè @ á œè @èşÿÿë  áĞâ0€½èğ@-éĞMâ@â0På ` á „è  á ”è Påşÿÿëpå å  á €à  ãşÿÿëP…àPå ”è †è  áĞâğ€½è0@-éĞMâP á(Àåàâ @lâÀŒàÀLâÀàÀeà è @ á è Àåşÿÿë  áĞâ0€½èğ@-é$ĞMâ@â P á  ã „è8på<`åşÿÿë àPâ  
 ”èÀâ@å 0 ã Œè å på RáP é0å  
  ê  á0’å  Sãûÿÿ ‚â à‚å œè …è  á$Ğâğ€½è â÷ÿÿê  Ÿåhıÿë   ĞMâ0â éé  Pã  
 Pã  Ú  Üå  Rã  
@âŒà0 á  ê óå  Rã  
 Sáúÿÿ  Œà Påoá  áĞâÿ/á  áĞâÿ/áFATAL ERROR:    realloc() failed (len=%d)
  Error reading file into data: %s    Overflow reading file into data
    Invalid literal size (%d)
  malloc() failed
     GCC: (Raspbian 4.9.2-10) 4.9.2 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .rel.text .data .bss .rodata.str1.4 .comment .note.GNU-stack .ARM.attributes                                ñÿ                                                               L        D             L             D            H            $            ,            ¤            ¨            \
            `
                                                                                                           "              '              .   L   \     8              =   ¨         K              S   H  T     a              h   œ  °     €                 L  à     Ÿ              ¥              ¬              ±              Â              Ë   ,  \     Ü   ˆ        ò              ú   (  ¼       ä  Ä      ¨  Ğ    (  x  <     9  ´  8     J  ì  4     [   	  \     n             u  |	  H     ‡  Ä	  œ     —               `
  t      data.c $a die $d fwrite vfprintf exit stderr data_free free data_grow_for realloc data_copy_mem memcpy data_copy_escape_string get_escape_char data_copy_file fread ferror feof __errno_location strerror data_append_data data_insert_at_marker memmove data_merge data_append_integer data_append_re data_append_cell data_append_addr data_append_byte data_append_zeroes memset data_append_align data_add_marker malloc data_is_one_string    (     8     @     D     H     t     |     œ     ü     D    x    ˆ    Ô    (  !  ¬    Ä  #  Ğ  $  è  %    &    '  $    (    P    h    °    Ğ  *  ä    X  (  Ì    Ø  (    (  L  (  ”  (  ¤    h  (  ¤  ,  Ü  ,  	  (  D	    \	  2  ´	  1  ä	  5  \
                                                         4   Ô
                    	   @       Œ  X  
            %                                  +                                  0      2         ¤                 ?      0       ¬                    H              Ì                     X     p        Ì  1                                ı  h                                h  p              	              Ø  ±                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ELF          (    ˆ 4   €¸   4    (     p@‘  @‘ @‘                4   4  4                 4  4 4                          L‘  L‘           L‘  L‘ L‘ ¨  tB           X‘  X‘ X‘ è   è            P  P P D   D         Qåtd                          /lib/ld-linux-armhf.so.3             GNU                        GNU ‘gâb›êäåt‹¿ù²ÁRf%            ®ÔÀ@áâ‚ @@ˆ( ` B±,d	€H   0 Â                            
                                                         "   #       $   %               &       '   =­9 #ù¤l²Í/t}‹s¸+k†ğ–|vµÚ´V1ıÇà=/N=öÿì„8ò‹º•“ûn?ùÿ¼Fu(Œ}í»“®Õ'ÕÎnE?~–|…º–|u‚—©ºÚ•ÅKÊUË ³¢÷/t7vı!Ï	ı_–“íŞ“cŞ$gUaù,X¾êvş                !              ¥              j                            ‘                                                      á                           /              ñ              (              ³   ø’      Ú              V                           Ô              „   “      7              \              º              {                            Q              —                            
             c              ¬   “      ‹              Æ                            ê              C              J              =    “                   Í               libc.so.6 exit _IO_putc fopen __strdup perror realloc abort stdin strtol isatty feof fgetc strlen ungetc __errno_location clearerr stdout fputc fputs memcpy fclose malloc optarg stderr getopt_long fileno fwrite fread strchr _IO_getc strcmp __libc_start_main ferror vfprintf snprintf free __gmon_start__ GLIBC_2.4                                                         ii   0      Ø’   ø’    “ %  “   “   L’ "  P’ #  T’   X’   \’   `’ 
  d’   h’ 	  l’   p’   t’   x’ '  |’   €’   „’   ˆ’   Œ’   ’   ”’   ˜’   œ’    ’   ¤’   ¨’   ¬’ &  °’   ´’   ¸’    ¼’ !  À’   Ä’   È’   Ì’ $  Ğ’   Ô’   @-é× ë€½èà-åàŸåààğ¾åÈ‰  ÆâÊŒâÈù¼å ÆâÊŒâÀù¼å ÆâÊŒâ¸ù¼å ÆâÊŒâ°ù¼å ÆâÊŒâ¨ù¼å ÆâÊŒâ ù¼å ÆâÊŒâ˜ù¼å ÆâÊŒâù¼å ÆâÊŒâˆù¼å ÆâÊŒâ€ù¼å ÆâÊŒâxù¼å ÆâÊŒâpù¼å ÆâÊŒâhù¼å ÆâÊŒâ`ù¼å ÆâÊŒâXù¼å ÆâÊŒâPù¼å ÆâÊŒâHù¼å ÆâÊŒâ@ù¼å ÆâÊŒâ8ù¼å ÆâÊŒâ0ù¼å ÆâÊŒâ(ù¼å ÆâÊŒâ ù¼å ÆâÊŒâù¼å ÆâÊŒâù¼å ÆâÊŒâù¼å ÆâÊŒâ ù¼å ÆâÊŒâøø¼å ÆâÊŒâğø¼å ÆâÊŒâèø¼å ÆâÊŒâàø¼å ÆâÊŒâØø¼å ÆâÊŒâĞø¼å ÆâÊŒâÈø¼å ÆâÊŒâÀø¼å ÆâÊŒâ¸ø¼åğO-éÄĞMâ ` áP á âüŸå°  ã ÿÿë @ ãğtŸåğ¤Ÿåğ´Ÿå€ á ã 0 ã 0å  á áØ$Ÿå0â±ÿÿë pãr  
D @â3 Pã ñŸ—f  ê  ( ( ( ( ( ( ( ( ( ( ( ( ( ( (   ( è ( ( ( ( ( ( ( ( ( ( ( ( ( Ø ( ( ( ´ ( ( ( ( ( ( ( ¬   t d ( ( ( \ ‡å¼ÿÿêà#Ÿå 0šå0‚å¸ÿÿê  šåĞŸå8‡åFÿÿë´3Ÿå @Pâ±ÿÿ  “åSÿÿë  ã  ê 0 ã0‡åªÿÿê ‡å¨ÿÿêˆ3Ÿå”Ÿå ã 0“å%. ãLÿÿë   ãÄĞâğ½è(0—å0ƒâ(0‡å›ÿÿê ã  ã 0›å\Ÿå@ÿÿë•ÿÿê  šåPŸå<‡å#ÿÿë(3Ÿå €PâÿÿÛÿÿê0‡å‹ÿÿê3Ÿå Ÿå ã 0“å%. ã/ÿÿë  ãáÿÿêì’ŸåğŸåŸå(0™å#Ÿå Sã8à™å Àå   Ó  Ã Sã 0 Ó0 Ã  ^ã,À‰å  å 0‚åJ  ø ë<0™åœ"Ÿå  Sã  
@0’å  Sã´RŸ#  (0™å|Ÿå  Sã2   ™å  â  ¾ÿÿêŸå ã	  ã0 áÿÿë0”åƒ•ç  Pã   á ”å@ÿÿë   ã áøşÿë0”å  Sã    á”å8 ë
  ã áïşÿë ”å 0 ã@ ‰å0„å@@™å tãØÿÿ
$0”å  Sãâÿÿ
Üÿÿê ã  ã0 áüŸåâşÿëèÿÿê áÜşÿë á#  ãÙşÿëÙÿÿê$ ‘åekŸí, ‘å*îÌŸå: ãç{¸î{'î {íïşÿëÁÿÿê  ã  áâşÿë `Pâ  áK  Â ë  Pã÷ÿÿ
på P á  Wã  `å|Ÿå  áşÿë  Pã` )  
  á³ ë °Pâp   
p›å  Wã  0›åDŸå  á0åşÿë0å  Pã#  
 0 ã   ê ° á 0‹å  áŸ ë0 á  Pãøÿÿ •åËşÿë  Pã"  
  å  á0 á•å ë$`€å •å‚şÿë  á€şÿëÄÿÿê p ãåÿÿê  á{şÿë  áyşÿë  á… ë PPâ` ¹ÿÿ
Ëÿÿê  áqşÿë  áoşÿë  á{ ëp ã °PâÒÿÿÚÿÿê°şÿë`ÿÿê00Ÿåh Ÿå ã 0“å  ãvşÿë  ã†şÿë   á      0?Ø]  Ó “ ø’ ´b ä’ ¼{ `` D` Ìv ¬Ó „Ó ¨Y Øb l_ äb Äb Ğb ˜^    á ° ã à ãä  á -å -åÀŸåÀ-å Ÿå0Ÿå[şÿë–şÿë˜Y  
 4Y 0Ÿå Ÿå0à “ç  Rãÿ/Sşÿêl‚ ˜   0Ÿå Ÿå0`à Sãÿ/‘0Ÿå  Sãÿ/ÿ/á÷’ ô’     $Ÿå$ Ÿå`àA á¡àÁ°áÿ/0Ÿå  Sãÿ/ÿ/áô’ ô’     @-é@Ÿå 0Ôå  Sã€½ßÿÿë0 ã 0Äå€½è“ @-é$ Ÿå 0å  Sã  @½èàÿÿê0Ÿå  Sãúÿÿ
3ÿ/áøÿÿêT‘     $ Ÿå$ Ÿå$0Ÿå  ’å Ÿå  Rã    å 0“åŸå&şÿê¤Ó ø’ ä’ ˆ^ ^  -éĞMâÀå  \ã  
 å0â  Pã0å  
â   á   ê  á 0’å  Sãûÿÿ À‚å0±å À á  Sã  
  áòÿÿê  áĞâĞâÿ/á8@-é P á  ãéıÿë @Pâ	  
  á	şÿë  Pã  
 0 ã „å0„å 0„å  á8€½è0Ÿå Ÿå ã 0“å  ãÑıÿë  ãáıÿëø’ ˜^ 0 Ÿå€‚à å  Rã  
  Ÿå0 áŸå  åáıÿê0Ÿå  á “åşÿê¨Y ø’ ¨^   QãøI-é p á°â0  
  ‘å  RãÀ à &  
 Àœåàâ  \ãûÿÿá á0â0ÃãĞMà`à@ á0Fâå ä  ’å  Rãûÿÿ Tá|€Ÿ  
P”ä0•åƒ˜ç  Pã  
 á•ıÿë#  ã á’ıÿë á •åÔıÿë   ã áŒıÿë VáíÿÿĞKâø‰½èĞMâ@ á`â åãÿÿê 0 á ã  ã Ÿåıÿëòÿÿê¨Y °^ øO-é àĞå  ^ãA  
QŸå @ á Ààã0,ààôås0ïæ1…à  ^ã00“å,Ä#à÷ÿÿ0àá: á#: áÔÀŸåAœç  Tã-  
` ã€ áa á  á#pâ° á  á`â  ê @”å  Tã!  
P”å Uã    Š5 á# ã      ã     [ã0   Š  Wã 0     Vã0 0  Ráæÿÿ	  á”å"ıÿë  Pãáÿÿ0”å  SãŞÿÿ
  Zã  
 [áø½  áø½è0 áÉÿÿê¨Y “ @-é @ á åıÿë  á@½èıÿê Páp@-é @ á` áp€½ P”å ”åıÿë  áıÿë Vá@ á÷ÿÿp€½è8@-é P á  ã!ıÿë @Pâ  
 •åAıÿë  Pã  
0•å „å0„å  á8€½è0Ÿå Ÿå ã 0“å  ã
ıÿë  ãıÿëø’ ˜^ p@-éŞMâCoâ @ á`†â 0 ãPâ 0å0å0åPå  á&ıÿë pã 0 á*  
  Sã  

 Sã!  
 å Rá/  *À‚âÀå 0Âåïÿÿê å Ráìÿÿ
 0 ã 0Âå İåPå# Rã  
  áÀÿÿëŞâp€½è İå Ÿåƒç Qá  
0ƒâ Sãùÿÿx0ŸåxŸå  “åğüÿë  ãâüÿë0å Sá  
 áìüÿë å Ráßÿÿ   ãåÿÿê â  á0å å¡ÿÿëŞâp€½è0Ÿå  Ÿå ã 0“å  ã¹üÿë  ãÉüÿë¨Y ø’ È^ ¸^  Páø@-é  
 @ á` áÿÿë @”å Vá p á  
 P á  á†ÿÿë  …å @”å P á Váøÿÿ 0 ã 0€å  áø€½è p ãûÿÿê -é0@-éĞMâP@Ÿå0”å  Sã  
DPŸå~şÿë0â  áå  •å0åÂüÿë •å
  ã†üÿë0”å0ƒâ0„åĞâ0@½èĞâÿ/á Ó ø’ ğO-é4ĞMâ Qã° á   á å0åŒ  
 Qãï  
 PÚå  Uã÷  
|Ÿå
 á  àã0"àPñås0ïæ1€à  Uã00“å"$#à÷ÿÿPàáZ á%: á0åDUŸå0å1•ç  Sã0åä  
p ã á{ á@ á#€âpâ  ê @”å  Tã0  
`”å Vã    Š6 á# ã      ã     [ã0   Š  Xã 0     Wã0 0  Ráæÿÿ
  á”åüÿë  PãáÿÿX0å  SãX  
tŸå € á0å Sá0a… œ  
`å  ê Sá˜  
` á 0–å  Sãùÿÿ$0—å0Câ$0‡å   ê€ á(  ã&üÿë @Pâ 
0tŸå åX0å/oá¢" á „å å(0—å •ç „å å  Sã 0 ã „é „å €„å „å A…ç0„å0„å$0„å  
Ğ3Ÿå‹1ƒà “å  Rã
0 
0 , —ÀŸ  , —¸Ÿüÿë0å  Sãl  å, —å9şÿëœŸå ã  ã,0—åñûÿë$0—å  á0ƒâ$0‡å4Ğâğ½è  Rã@ á\sŸåo  
  ã —å¶şÿë  á  ã-ÿÿë0 ã0‡å ‡åfÿÿê [áŠ  
 ”å  Rã‚  $ ”åsŸå  Rã  
  —å  Rã  
SŸå»ıÿë	  ã 0•å ãüŸåÊûÿë  á
 áùıÿë 0•åèŸå ã  ãÂûÿë0 ã0„å  áĞÿÿê0Fâ Sã&  Š0”å  Sã#  
 “å  Rã    “å Òå} Qã   Òå  Rã   €“å  Xã  
0˜å  Sã   ˜åpŸå„ûÿë  Pã   0˜å  Sã  
 “å  Rã  0“å  Óå{ Rã  €Óå  Xã€ € _ÿÿê€ ã]ÿÿê 0”å 0†å$0—å0Câ$0‡åiÿÿê ã  ã,0—åüŸå‡ûÿëŒÿÿêĞqŸå  ã —åTşÿë 0 ã  Zã0‡å0‡åÿÿ
  áÿÿêPåÿÿê€åTÿÿê0—å âàƒâ ã¨!Ÿåà‡å—ûÿë —å  PãL  
€å á¶şÿë p á„Ÿåıÿë @ á|Ÿå|ıÿë ` átŸåyıÿë P á âvıÿëÀ á á  á0 áè  áSıÿë åŞşÿê@Ÿå
 á¶şÿë  ábÿÿêp”å0å  Sã  W.  
—å “å Qákÿÿ€ á  ê —å0˜å Ráeÿÿ —å˜åûÿë  Pã`ÿÿ p—å €˜å  Xã  Wñÿÿ  Xã  WXÿÿ0”å  Sã  $0”å  Sã	  
ıÿë  á
 á\ıÿëp0Ÿå” Ÿå ã 0“å  ã$ûÿë0 ã0„å  á2ÿÿê â6ıÿë å¥şÿê€åâÿÿê00ŸåX Ÿå ã 0“å  ãûÿë  ã$ûÿë¨Y “  Ó @_ T_ t_ ø’ _ _ $_ l_ Ü^ à^ $ ä^ ,_ è^ ˜^ à-åĞMâ À ã ÀåzşÿëĞâğäğO-é@ á °â$ĞMâå, å  Qã]  
 0‘å  Sãá  
  á` ã  ’å`†â  Rãûÿÿa á †â ÂãĞMàâ`‰à Fâå0ä 0“å  Sãûÿÿ YáB  
D£ŸåDSŸåp™ä€—å XãñŸ—9  ê( ¼ È È È ¼ 0—å á  á   ã(0åHıÿë(0å ÀPâs  
0œå  Sãš  
00šå  Sã^  Ø‚Ÿå0—åƒ1ˆà“å  Ñå  Rã  
0$à ñås0ïæ1ˆà  Rã00“å$D#à÷ÿÿ 0$â—ås0ïæ  Ñå1ˆà00“å  Rã$D#à  
0$à ñås0ïæ1ˆà  Rã00“å$D#à÷ÿÿ 0$âs0ïæˆà00˜å$D#à	 Vá¾ÿÿ,0å0“å  Sã{  
  á ĞKâğ½è0—å á  á   ã(0åıÿëå  Qãh  
0 šå(0å  Rã  +   ĞåäŸå  Qãßÿÿ
0$àğås0ïæ1…à  Qã00“å$D#à÷ÿÿÖÿÿê00šå  Sã  —å¤Ÿå  Ñå  RãÎÿÿ
0$à ñås0ïæ1…à  Rã00“å$D#à÷ÿÿÅÿÿê, šåpŸå —å~úÿëìÿÿê —å, šå\Ÿå‚!…à0—å ’åDŸåuúÿë˜ÿÿê  á, šå4Ÿåpúÿë —åÍÿÿêˆ…à  á˜å Ÿå8Àå®ıÿë0—åƒ1…à “å^üÿë € á —å[üÿë4 åø ŸåXüÿë0 åğ ŸåUüÿë( åè ŸåRüÿë8Àå(0å4å0 åÀå(Àå  å  á-üÿë(Àå—å0 á   á —å Àå©ıÿë À á0œå  Sãdÿÿ40šå á0Œå  á4ÀŠå&ÿÿë @ á„ÿÿê40šå á0€å4 Šåÿÿë @ á}ÿÿêX0Ÿå,Àå  àã“å Œâ ƒå Àå  á Œå ĞKâğ½èĞMââ`‰â ‰å*ÿÿê Ó ¨Y x_ œ_ |_ ”_ $_ ˜_ ä’   ãğO-é  áĞMâ  áyüÿë @Pâ\  
€QŸå00•å  SãS   àã„å  á4@…åóşÿë4@•å tã 0àá0å2  
HŸåHqŸåH±Ÿå à ã  êÎûÿë  •å81Ÿå  Rã0   á  —å(Ÿå	0 á÷ùÿë”å ”åüÿë ”å Qã)  
 0•åà ã  Sã0˜0ƒ0ˆ   ã vã „å@ á  
 0”å`”å  Sãöÿÿ
  ^ã  ã ãÀ Ÿå¬ ŸåÚÿÿ
 0—å¼ùÿëáÿÿê ^á  
0Ÿå
  ã “åîùÿë00•åx Ÿå  Sã  „Ÿå	  á0å‘åx ŸåĞâğO½èùÿê 0šå  ãd Ÿå¥ùÿëĞÿÿê,0’å ã  ãP ŸåŸùÿëìÿÿê, •åDŸå	  á¸ùÿë¦ÿÿê	 á4 ŸåĞâğO½èøüÿê Ó ø’ ¤_ ¬_ à_ ` ä’ ,` ` t_ Ğ_ ´_ p@-é	  ãDPŸå @ á` á 0•å8 Ÿå ãùÿë Tá  Šò Ôà  •å Ÿå—ùÿë Váùÿÿ* •å
  ãp@½è¬ùÿêø’ Äv Ğv , Ÿå0 á5 Qã@-é @ áŸÕŸÅ!’ç…ùÿë á)  ã@½èœùÿê c Ôv àv 8@-é  Pã@0Ÿå@ Ÿå    0“å  Sã8€½0PŸå@ á,Ÿå  •åqùÿë á  •åßÿÿë •å
  ã8@½è…ùÿê¬Ó ìv ø’ x_ ğG-é á P‘å@ á ` áp•å€ á  Wã  ’å    áüÿë  –å\0Ÿå á  ’å 0“å  €å€€å  „å À–å •å
  á pŒåğG½è-şÿê 0å  á 0“å 0†åôûÿë 0™å  ”å á€ƒå 0„åğG½èôûÿêDÓ ğO-éİMâˆ}ŸåĞMâ 0—å  Sã xŸå 0 ã á0å 0åh=Ÿå@â àã` áj_â  ƒåÈ0 ãPå0å0å°Äá1Câƒ0 á †à Tá :Pfà(-ŸååÅP á QáP…â Š0ƒâ ‚â Sá0 !0åƒ€ á ˆà€  á €âúøÿë  Pâ 
°ˆâ…@ á°Ëã  á áQ á°ŠàÛøÿëå  á  á×øÿë0â Vá  
  áÌøÿë 0—å@DâPEâ  Sã@ŠàP‹àä  €Hâ€Šà Tá *
` á°å Yãõ 
d,Ÿå‰0 á³€’áx ¿æŒ zã>B  
@<Ÿå  “å pãO 
  PãU Ú4<ŸåKPã  ƒ°  —å³Ğµ° £  Rã] ,Ÿå Šà Zá  ŠŸåŠ  áò ‘á Zá¶ 
	 ƒàìŸåT¬Òå  ZãÍ  

0ƒà  —åÓå  Rã0hâ1•ç0åW 0Jâ€ SãñŸ—  ê|0 \0 Ô- ¤( Ô- ¤( ¬( ¬( ¬( ¬( ¤( ¤( è. p- ¬( t( x. @. „/ ¬( ä- ä- °- ¬( ¬( ¬( ¬( D0 (. ¬( ¬( ¬( ¬( ø- Ä/ ”/ Ğ. ¸. (1 1 ¤( ¤( ¬( ¬( ¬( ¬( ¬( ¬( ¬( ¬( ¬( ¬( ˜0 ˜- p- ¬( ¬( ¤( ¬( ¬( ¬( °- ¤( ¬( Ä0 ¤( ¤( ¤( ¤( ¤( ¤( ¬( ¬( ¬( ¤( ¤( ¤( ¤( ¤( ¤( ¬( ¤( p- ¬( ¬( ¤( ˜- ˜- ¬( p- °- °- ¤( ¤( ¤( ¤( ¤( ô/ p- ¬( h/ ¤( ¤( p- ¬( ¬( ¤( ¤( ¤( p- ¬( ¬( ¤( ˜- ¤( ¬( ¤( p- ¬( ¤( ¤( ¬( ¬(  0 (/ ¤( p- ¬( °0 ´™Ÿå 0•å ° ã™å  “å °ƒåQà  ™å 0™åıÿë°‰å 0•å0å 0—åX™Ÿå  Sãt9Ÿåâ  
 ƒàx€¿æà®ZåQEàˆ@Dà6 JâX9ŸåŠ  áğ Ôáú0“á8Ÿå å0ƒà Sá …åP…â  Š Ÿåƒ0 áó‘á Qá 
9Ÿåú“á@„âèşÿê9Ÿå€HâŸå  “å å€Šàøÿë Tá# *
` á°å 0—å  Sãÿÿ
Ø8ŸåÜŸå	  á  “å øÿëÿÿê˜(Ÿå  ’å rã   
KRã0 #Ñ5 å  PãÎ  
 å PãR  
l¸Ÿåt¨Ÿå  êX(Ÿå‰0 á³€’áx€¿æŒ xã	ŠàlŸå0ˆâ  
 Sáƒ  á  Š48Ÿåò0“á Sã  
 Tá  
YåZşÿë 0—åPEâ  Sãòtáæÿÿ
  á á*şÿëâÿÿê8Ÿåò0“á  SãîÿÿÚŸå  —å á ‘å  Pã…åP…âË 0 ã0å«ÿÿêP ãœ7Ÿå  “å rã  
KRã #  :ÀŸå8şÿë 0—å  Sã‹   Vá„wŸ  
ò0Tà Ÿå0‡àSå-şÿë Váøÿÿ0â Vá  
  ár÷ÿë  áİâĞâğ½è,7Ÿå0ƒàÓåãÿÿê  Rã–  ÚPŸåşÿë 'Ÿå0àã 0‚å¤ÿÿê 0—å  Sã“   ëà6Ÿå  Pã  ƒå©şÿÊ °—å À ãÈ6Ÿå [á ÀƒåÈ6Ÿªşÿ
Ü6ŸåüŸå ã 0“å  ã° áa÷ÿë¤6Ÿå¡şÿê0å´6ŸåØ&ŸåØŸå  “åw÷ÿë 6Ÿå á  “åäıÿë6Ÿå
  ã “åŠ÷ÿë0å‘şÿêx6Ÿå¤–ŸåŠÀ á  “åœŸå¼0™á JâÀåd÷ÿë  Xãœşÿ
„&ŸåÀåCŸ‰â ° ã¼ ’á Bâ‰à06Ÿå°‹â  á  “å\ŸåU÷ÿë6ŸåÑùá  “åÂıÿë6Ÿå
  ã “åh÷ÿë Xáïÿÿ„şÿê0åè5ŸåŸå &Ÿå  “åD÷ÿë0åĞ%Ÿå
0ƒàx€¿æà®Så  ’åQEà
 á¬ıÿë°5Ÿå
  ãˆ@Dà “åQ÷ÿë 0™å  Sã
ÿÿ
  á á‰ıÿëÿÿê€5Ÿå ã  ã 0“å´Ÿå÷ÿëïıÿê  á á~ıÿëoÿÿê(5Ÿå$%Ÿå”Ÿå 0“åŸå0ƒâ 0‚åbúÿë*ÿÿê@Ÿåò‘á  Yã  iÒHşÿÚ0å  Sã0C0 0—å  Sã 5ŸåÔŸå àã 0“å  å0…åP…âñşÿêğ$Ÿåó’áîşÿêÿÿP ã`ÿÿê 0 ã0åËşÿê¼4Ÿå ã  ã 0“åüŸåÚöÿëdÿÿê 0•å  Sã0å00¾şÿê 0•å  “å  á  ’å  ƒå˜ùÿë 0•å0åµşÿêT4Ÿå  ã ƒå±şÿê  •å@4Ÿå  ’å ƒå¬şÿê0å  “å  á  ’å  ƒå†ùÿë 0•å  ã0å 0“å ƒå şÿê 4Ÿå •å   ãå  ƒåšşÿê 0•å  Sã0å–şÿ0å  Sã0å’şÿ0å  Sã0å00Œşÿê 0•å ° ã¨“Ÿå  “å °ƒå0å á å  “åiùÿë0å ™å™å å  ƒåtşÿê0 ã èEıÿë 0•å0åvşÿê0 ã è?ıÿë 0•å0åpşÿê@“Ÿå ™å  Pãjşÿ
 0•å™å ° ã 0“åQà   “å °ƒå 0™åvûÿë°‰å^şÿê0å 0“å “å›öÿë  •å0å “å  á  ’å·ùÿë ã 0 ã   á	  áeûÿëPşÿê è  ’å  “å ’å ƒå1ùÿëGşÿê¤2Ÿå   ã ƒåEşÿê0å  “å  á  ’å  ƒåùÿë 0•å  ã0å 0“å ƒå9şÿê0å  “å  á  ’å  ƒåùÿë 0•å  ã0å 0“å ƒå-şÿê å02Ÿå  ã  å €å “å 0“å9ûÿë 0•å0å"şÿê 0•å 0“å “å]öÿë   ã0 á ã.ûÿëşÿêä1Ÿå •å  ãå  ƒåşÿê 0•å  ã  “åöøÿë 0•å   ã  ƒåşÿê¬1Ÿå   ã ƒå  ƒå ƒå ƒåşÿê 0•å  ã0å 0“å ƒåşıÿê0å 0“å “åüÿë÷ıÿêd1Ÿå “å  RãD  
¸Ÿålùÿë 0—åx€¿æ  SãQEàˆ@DàB  ğÔá !Ÿå‰0 á³€’á*şÿê   ã 0 á   á ã÷úÿë 0•å0åàıÿê0 ã è©üÿë 0•å0åÚıÿêø0ŸåL!ŸåŸå  “åöÿëä0Ÿå
 á  “åuüÿëÔ0Ÿå
  ã “åöÿëïşÿêŸåŸåBùÿëP ã9şÿê P ã7şÿê˜0ŸåÌŸå0å˜0Ÿåì Ÿå  “åñõÿë0å„ Ÿå	0ƒà  ’åSå\üÿëp0Ÿå
  ã “åöÿë!şÿê
` áP ã"şÿê  •å å  ’å ’å ƒåªıÿê  á á3üÿë¸ÿÿê¬Ó ¨Ó °Ó '  @e  c   äg DÓ ˜ƒ @u ¤u ø’ w (w x ìk ´Ó ,x Lx ôw Pw hw x_ 8q „w ¬s ¬w Üw øv <_ äw <w ¸w xw x Ğ0ŸåÌ ŸåÌŸå “å0“åğO-é1“ç°å €‘å   á Xá  å0“å €àğ½(œ0Ÿåœ`Ÿå ’å’å~Fâf^ƒâ@ áÀ á0Øä  Sã p ŸÒp0Ÿå€  áò0“á  Sã      êò —áH Pã€  á@ÜÅò0–áÁ„à0ƒàƒ0 áóà•á  ^áôÿÿ, Ÿå Xáó ’áãÿÿ0Ÿå ƒåƒåğ½èTÓ ¸Ó P~ „ P‚  ‡ <0Ÿåà-å “å“å0àŸå Á‘ç œåÀœå  å ‘ç ƒåÀƒå ‘åƒå  Òå  ÃåğäTÓ ¸Ó @-é   á0ŸåŸå  “å`õÿë  ãRõÿëø’ x ğA-é¸@Ÿå ”å`”å0”å ÀÔåQƒà ÀÆåq“ç —åà‚â Vá  *0”å€—å0ƒâÀ‚à Rá0ˆâ0‚à
  *àCâ |å0 áàNâ Îå p•å —å Rá÷ÿÿ:€—åà‚â0là`†à Váà€„å€‡å  :$ Ÿå0 á Få ‚å så  Äå0„åğ½è ŸåÄÿÿëTÓ ¸Ó | p@-é @Ÿå`”å  Vã  
$0”å ”åCâ Qáp€½ˆPƒâ  áa á áòôÿë  Pã „å  
 `Fâ€à0â   ã €ç$P„å å ƒä ƒä ƒä ƒä ƒä  ƒåp€½è  ãîôÿë  Pã0  „å `€`„$0„p€½ Ÿå–ÿÿëTÓ œ 8@-é P áp@ŸåÎÿÿë0”å  Sã  
 ”å“çƒà Qá8€½  Qã  
”å àÔåÀ”å àÁåá“çå1“çÀƒå P€åiÿÿë0 ã(0„å8€½è  Uã8€½ ”å  áõÿÿêTÓ   Pãÿ/P Ÿå@-é0’å  Sã  
 ’å“ç Pá  ƒ0å @ á  Sã    á@½è”ôÿê å’ôÿë  á@½èôÿêTÓ   Pãÿ/ åLŸå 0 ãà-åÀ ã0€å 0Âåàå ‘å0Îå Ráàå,0€åà€åÀ€åğ0‘å1’ç Páğàä/ÿÿêTÓ ø@-é @ áP áªôÿë ` á  á p–åŞÿÿë\ Ÿå ã P„å0’å(„å  Sã  
 ’å1“ç Tá  
  ã 0 ã  „å$0„å  Uâ  
 ôÿë®ôÿë  Pã   Ó  Ã „å p†åø€½èTÓ p@-é ` á0  ãP áiôÿë @Pâ  
P„å …âdôÿë  Pã „å  
0 ã  á á0„åËÿÿë  áp€½è  Ÿå	ÿÿëĞ ø@-é P áX@Ÿå0”å  Sã  
 ”å“ç  Pã  
 áºÿÿëø@½èçşÿê7ÿÿë ”å ãÀ ”éÕÿÿë á  Vã†ç   ®ÿÿëø@½èÛşÿêTÓ   Pãÿ/p@-é P át@Ÿå%ÿÿë0”å  Sã  
 ”å“ç á  PãÀƒà  
 ”å àÔåâÀƒà àÀåa“ç”åà‚â †å1“çà„åƒå PŒå½şÿë0 ã(0„åp€½è”åÁ á÷ÿÿêTÓ ø@-éX`ŸåP–å  Uãø€½@–å•çq…à  Pã  
Jÿÿë  Tã 0 ã1…çø€½0å@Dâ  Sã@†åø€½¡şÿë0 ã(0†åø€½èø€½èTÓ  Qã  šø@-épAâ@Ğç  Tã  €à`Qå  Vã   P á0  ãğóÿë @Pâ  
0 ãp„åP„åP„å`„å `„åp„å`„å(`„å,`„å0„åşşÿë  áø€½è  áø€½è   ãø€½è   ãÿ/á  Ÿå‰şÿëü ø@-épâ @ á  áP áÑóÿë `Pâ  
  Uã0 ÁàƒÀ FÂ  ÚÀÓä SáÀâåûÿÿ †à 0 ã0Âå á0Æç  áÀÿÿë 0Pâ  
  ã ƒåø€½è Ÿåişÿë Ÿågşÿë( T @-é @ áÃóÿë  á  á@½èÕÿÿê0Ÿå  “åÿ/áğ’ 0Ÿå “åÿ/áTÓ 0Ÿå, “åÿ/áTÓ 0Ÿå  “åÿ/á¼Ó 0Ÿå  “åÿ/á¸Ó 0Ÿå  ƒåÿ/áğ’ 0Ÿå ƒåÿ/áTÓ 0Ÿå, ƒåÿ/áTÓ 0Ÿå0 “åÿ/áTÓ 0Ÿå0 ƒåÿ/áTÓ ø@-éh`ŸåP–å  Uã  
@–å•ç  Pã p   
·şÿëq…ç_ÿÿë@–å1•ç  Sâøÿÿ  áWóÿë   ã †å †å$ †å †å4 †å  †å †å, †åø€½èTÓ fóÿêVóÿêIóÿêğO-é$ĞMâ”ŸŸå8@™å  TãK 
¯ŸåP?ŸåÎJâf¾ƒâ€ á 0 ã 0å40™å  Sã`?Ÿåm  
` “ép™å Ùå  ™åpå Çå1•ç0“å €à€  áà™å²0šá@™å_ŸåğnŸåòP•áÖç  Uã à @   êò œáH PãˆÀ€  á@ÑÅ²0šás0±æƒ0 áóP›á PáôÿÿÔ.Ÿå`^Ÿåp‡âó ’áP>Ÿå€  á²0“ás¿æ Qá ×áÿÿ¤>ŸåP á@‰å²0“áà‰ås0¿æ  SãœŸå0™€.ŸP™åƒ0  €åó0’ aàtŸåP‰å  å  Õå  ã Åå  Éå SãñŸ—ó êC ØA = = ˜A dA 4A A Ô@ ¤@ t@ ä? P? è> > p= >Ÿå  “å  Rã‡ Ú >ŸåP™å`™å 0“å0ƒà!•ç0Så
0Câ?oá£2 á0‚åX=ŸåT-Ÿå 0“å0ƒâ 0‚å–ÿÿê ` ã  á$Ğâğ½è  “å0 ã  Rã”-ŸåP™å 0‚40‚å0™å  Sã=Ÿx-Ÿ 0“0‚,0™å  Sãü<Ÿ`-Ÿ 0“,0‚  Uã  
L=Ÿå`“å1•ç  Sã  
ÀågıÿëÀåtÿÿêÀå´ıÿë ™å ã` ™éRşÿëÀå…çòÿÿê0™å  Ùå á0å =Ÿåà™å 0“å  ÅåA‘ç0cà0Câ0å,0”å  á  Sã1‚à0å á¼<Ÿåä 
0“å ”å ™å` á ‚à  Rá. *0ƒâ0†à Pá˜<Ÿå 0“å& Š(p”å  Wã   cà PãP 
P áÀåP‰åõüÿëd<ŸåÀå 0“å0å@<Ÿå€  á°0“ágÿÿê@<Ÿå  “å  Rã
  Ú4<Ÿå™å 0“å0ƒà ™å0Så!’ç
0Câ?oá£2 á0‚å<Ÿå  ãÀå  “åô;Ÿå “å,0™ånòÿë` ™éÀåÿÿêØ;Ÿå 0“å  Sã ÚÌ+Ÿå ™å™å  ’å0‚à ‘ç0Så
0Câ?oá£2 á0å `Òå  Vãvÿÿ
80™å0Câ SãñŸ—Ÿ êäH TG |F ¤E 8H ÌD ôC xC ¸; $C ¸; hC 8K 8C D;Ÿå  “å  RãIo Ó  Ú4;Ÿå™åIo ã 0“å0ƒà ™å0Så!’ç
0Câ?oá£2 á0‚å80™å0Câ SãñŸ—{ êäH TG |F ¤E ,H ÌD ôC xC ¸; $C ¸; hC 8K 8C ´:Ÿå  “å  Rã¶ Ú¨:Ÿå™å`jŸå 0“å0ƒà ™å0SåÛÿÿê„:Ÿå  “å  Rã¨ Úx:Ÿå™å,jŸå 0“å0ƒà ™å0SåÏÿÿêT:Ÿå  “å  Rãš ÚH:Ÿå™åøiŸå 0“å0ƒà ™å0SåÃÿÿê$:Ÿå  “å  RãŒ Ú:Ÿå™åèiŸå 0“å0ƒà ™å0Så·ÿÿêô9Ÿå  “å  Rã~ Úè9Ÿå™å”iŸå 0“å0ƒà ™å0Så«ÿÿêÄ9Ÿå  “å  RãJo Ó«ÿÿÚ´9Ÿå™åJo ã 0“å0ƒà ™å0Såÿÿê9Ÿå  “å  Rãc Ú„9ŸåP™å`™å 0“å0ƒà!•ç0Så
0Câ?oá£2 á0‚å|şÿêP9Ÿå  “å  Rã
  ÚD9Ÿå™å 0“å0ƒà ™å0Så!’ç
0Câ?oá£2 á0‚å¨XŸå  •å  Pã  
ÀåŸñÿëÀåü8Ÿå" ãÀå  “åÉñÿë" ãähŸå@€â  áÄñÿë  ã 0dà ƒâ Àå  á0å å§ñÿë0å å sãÀåoá§r á p   WãM   áÀå†ñÿë 0–å á
  ãHŸåhŸå  …å ƒâoñÿëè7Ÿå ”åÀå  Qã  ƒå 
  –åÀåcñÿë88ŸåÀåoá  á  ƒå,şÿê  Ùå0™å  Åå(Ÿåƒ0 áP™å³0’áXşÿêà7Ÿå Vám 
0 ã80‰å[ Vã^ 
÷ Ê) Vãû 
, VãW  0å  Sã
0 80‰şÿê; Vã0 80‰şÿê; Vã% 
Û Ú] Vã  
H Ú{ VãH 
} Vã   0å  SãÒ 
  ãÀå<@™åVñÿë 0åÀå0Câ 0å 0Pâ (7Ÿå(Ÿå ã 0“å  ãDñÿë  ãTñÿë  ãÀå<@™åDñÿëÀå 0Pâğÿÿ
'Ÿå @ƒåÀå p’å 'ŸåP‡â  á<0‚å8ñÿë wãÀå?oá£2 á 0   SãàÿÿÜ6Ÿå  áÀå “åñÿë ã  ã „å£óÿë°6ŸåÀå 0“å0„å  Pã     { Vã „å 
} VãÄıÿ 0å0Sâ 0åÀıÿ0 ã80‰åD ™å@0™åN ãÄ ê  ãÀå<@™åñÿëÀå 0Pâºÿÿ
@&Ÿå @ƒåÀå p’å(&ŸåP‡â  á<0‚åñÿë wãÀå?oá£2 á 0   Sãªÿÿ6Ÿå  áÀå “åáğÿë ã  ã „åmóÿëØ5ŸåÀå 0“å0„å  Pã     [ Vã „åÑ 
] Vãıÿ 0å0Sâ 0åŠıÿ0 ã80‰åD ™å@0™å(EŸå ê( Vã 
) Vã›   ãÀå<@™åÔğÿëÀå 0Pâ€ÿÿ
X%Ÿå @ƒåÀå `’å@%ŸåP†â  á<0‚åÈğÿë vãÀå?oá£2 á 0   Sãpÿÿ5Ÿå  áÀå “å§ğÿë ã  ã „å3óÿëğ4ŸåÀå 0“å0„å 0å  Pã     0Sâ 0å „åTıÿ0 ã80‰åD ™å@0™åTDŸåX ê  ãÀå<@™å¢ğÿëÀå 0PâNÿÿ
$Ÿå @ƒåÀå p’åx$ŸåP‡â  á<0‚å–ğÿë wãÀå?oá£2 á 0   Sã>ÿÿT4Ÿå  áÀå “åuğÿë ã  ã „åóÿë(4ŸåÀå 0“å0„å  Pã     ( Vã „åe 
) Vã"ıÿ 0å0Sâ 0åıÿ0 ã80‰åD ™å@0™å€CŸå" ê  ãÀå<@™ålğÿëÀå 0Pâÿÿ
¸#Ÿå @ƒåÀå p’å #ŸåP‡â  á<0‚å`ğÿë wãÀå?oá£2 á 0   Sãÿÿ|3Ÿå  áÀå “å?ğÿë ã  ã „åËòÿëP3ŸåÀå 0“å0„å  Pã     ( Vã „å/ 
) Vãìüÿ 0å0Sâ 0åèüÿ0 ã80‰åD ™å@0™å¬BŸåì  êØ2Ÿå Vá 
  ãÀå<@™å3ğÿëÀå 0Pâßşÿ
Ô"Ÿå @ƒåÀå `’å¼"ŸåP†â  á<0‚å'ğÿë vãÀå?oá£2 á 0   SãÏşÿ˜2Ÿå  áÀå “åğÿë  ã ã „å’òÿël2Ÿå  ã8 ‰å 0“å  Pã     0„å „åÀå´üÿê[ VãÌ 
Ä Ú{ Vã ÀåE 
2Ÿå Vá   ã<p™å ğÿë Àå 0Pâ¬şÿ
"Ÿå pƒå Àå P’åğ!Ÿå@…â  á<0‚åôïÿë uã Àå?oá£2 á 0   SãœşÿÌ1Ÿå  á Àå “åÓïÿë ã  ã ‡å_òÿë¤!Ÿåœ1Ÿå ’åœ!Ÿå P’å  “å0Aâ ‡å  Pã      Sã ‡å] Š  Õå Õåà…à(ÁŸå$1Ÿåà^å 0ƒà Œà ;Óå +ÒåàŒà KŞå0‚à0ƒà@ƒàd TãL Š„Aˆà ”å 0Ñå  SáG â …â–ïÿë  Pã L”å Àå<Dâ0Câ SãñŸ— êØV ÄV hV hV hV hV hV ´V hV hV hV hV hV hV hV hV hV hV hV ´V hV ´V hV hV hV  V ìV „ 
  ä’  “ “ ¤Ó œÓ !        ´Ó ( ¬ #  *  &  '  P~   ø ø’ ˜^ %  )  "  Ø t P‚  ‡ TÓ  Ó ¼Ó ¸Ó , Vã@ áä 
0 ã  ã80‰å<P™åoïÿë8 å 0Pâşÿ
<å Pƒå<0‚å `‘å@†â  áeïÿë vã?oá£2 á 0   Sãşÿl0å  á;@ ã “åEïÿë ã  ã …åÑñÿë˜åD ™å@0™å ‘å…å  Pã      …å  Rã  Ú BâD ‰å  Sã0CÂ@0‰Å(1å< ™å` á  á  ƒå$Ğâğ½è 0å  Sã´ 
  ãÀå<@™å8ïÿëÀå 0Pâäıÿ
!åÀå `’å,!åP†â @ƒå  á<0‚å,ïÿë vãÀå?oá£2 á 0   SãÔıÿT1å  áÀå “åïÿë ã  ã „å—ñÿë€1åÿÿêÔåÉùÿë( Vã¾ûÿ 0å0ƒâ 0åºûÿê  ãïÿë  Pã0 < ‰ @€80‰«ûÿ¸ıÿê  càpBâ  Wã å  Ú Fâ ƒàÓä  Sáâåûÿÿ0åA“ç á,0”å Sã 0 0‰0„ 
0”å0Câ0gà  Sã9  Ê  áp á  ê0”å åÀåƒ á  Qã£ƒĞ„åâÕîÿëÀå å  Pã „å  
0åP€àP‰å @“å á0”å0Câ0bà  Sã  Ê0å  Sã	  
”å ”åP™å  QãP`àŞÿÿ` á†ååyùÿë0å0“åğ ğç “å0”å  „å åA’çô"å á0‚å  ã, „åüÿê  ãÄîÿëP áp á ”å
Sã@ ±J £  Rã?  Àå ååÊîÿë ååÀå ` á  €å  ê0å`3å åÀå “åˆîÿë0åÀåå  Pã2 
 0–åÀå Sã ˜3å †å “åÉîÿë¨3åÀå “å0“å“ç ‘å0™å ã €à  áÀå„îÿëØ3åÀå  Pã  á ‰åÚÿÿ
 “å0“å1“ç ƒå´ ê{ Vãcÿÿ
} Vã  
] Vãûÿ 0å0Câ 0åûÿê` ™é€ûÿê 0 ã` áp áP á@ á  ê
 Pã§ 
T4å@“é0å‚à!’ç ’å ‚à ‚à@„â Tá Bå‹ 
 ™åÀåGîÿë$åÀå pãêÿÿ ’åÀå å@å8îÿëP á åp á0åÀå  PãË ’å ’å@ á1’çw ê: Vã  
= Vã\    ã<P™å=îÿë@ á%å 0Pâèüÿ
å Pƒå<0‚å p‘å`‡â  á2îÿë wã?oá£2 á 0   SãÛüÿ85å  á “åîÿë  ã ã …åŸğÿë`5å  ã8 ‰å 0“åD ™å0…å@0™å  Pã      …åÊşÿê[ VãÙşÿ  ãÀå<@™åîÿë 0åÀå0ƒâ 0å 0PâÖşÿºüÿêÀ5å @“å TãüÿÌ5å P“å 0ÕåX Sãˆüÿ0 ã  ã80‰å<`™åıíÿë &å 0PâE 
 `ƒå  ã<0‚åöíÿë 0Pâ? 
°ÀÕá  á ã°ÀÃá0†åiğÿë8åD ™å@0™å ‘åGO ã†å  Pã      †å•şÿê  ã<P™åàíÿë@ áx&å 0Pâ‹üÿ
|å p‘å Pƒå`‡â  á<0‚åÕíÿë wã?oá£2 á 0   Sã~üÿ¬6å  á “å¶íÿë ã  ãoşÿê 0å0ƒâ Sã 0å0 80‰„şÿhúÿê  ã<@™å½íÿë Àå 0Pâiüÿ
'å @ƒå Àå p’å'åP‡â  á<0‚å±íÿë wã Àå?oá£2 á 0   SãYüÿ@7å  á Àå “åíÿë ã  ã „åğÿëlå@0™åx'å ‘å Àå„å  Pã       Sã „å  'å0 ã80‚å0 ã 0å7úÿê  ã<P™åŒíÿëÄ'å 0Pâ¬ÿÿ7üÿê) Vã+üÿ
, VãDşÿ
( VãEşÿjÿÿê  –å£íÿëÀå  Pã+üÿ
 8å  ã  „å  ƒåúÿê` ™é"úÿê`hå7ûÿêDhå5ûÿêlhå3ûÿêphå1ûÿêthå/ûÿê<8å  “åûÿê “å0“å1“ç ƒå  Wã 
0™å ™å  ã A“ç !ƒà0 ã` á,0„å0”åp‡à Wá0”•v  Š  ãÃç 0’å   ã¤Hå0“å Vã0ƒàp‰å Ãå 0’åÌå0“å 0„å1   ™å0‰å Bâ  ã¢?‚à(‰åÃ0 á0ƒâ+úÿê  ã Àå<@™å9íÿë Àå 0Pâåûÿ
)å @ƒå Àå `’å,)åP†â  á<0‚å-íÿë vã Àå?oá£2 á 0   SãÕûÿP9å  áÀå “åíÿë  ã ã  å „å—ïÿë  ã„9å8 ‰åıÿêŒ9å P“å9å @“å0Eâ SãÔ  Š  Ôå0„àèå Ôå ààSåø9å ƒà ;Şåêå +Òåà Ñå0‚à0ƒà0ƒàd SãÂ  Šƒ1ˆà “å 0Ñå  Sá½  â „âÀåÏìÿëÀå  Pã¶   0Ùå   ã(  ã0Äç,:åhJå 0“å0‰å ÀÓå  ÃåD:å ÀÉå “åT:å  ƒå÷ÿë0 ã80‰åD ™å@0™åıÿêÁ‡à ”å åÀåÊìÿë åÀå „å 0’å0“å  Sã|ÿÿÔ
å÷ÿë 0‘å@ áP áp á  Tã@‰å@ƒå bÿÿ
 ™å0™å   ã` á A“ç !ƒàeÿÿê’åà’å0 áP á!çp á@„â ’å ‚à Âç1ççÿÿêH;åHå á 0“å  ã¨ìÿë  á¸ìÿë`KåD ™åLkå  Rã@0–Xıÿ ã  á  áïÿëD –å@0–å  PãKOıÿê0 ã80‰å 0 ã 0å@ùÿê0 ã@0‰å  ãIıÿê0 ã80‰å 0 ã 0å7ùÿê0 ã80‰å 0 ã 0å2ùÿêD ™å@0™å9ıÿêÌ;å  áôKå “å=÷ÿë0 ã80‰åD ™å@0™å/ıÿêå,÷ÿëD ’å@ á*ıÿê@ áÊÿÿê(å%÷ÿë<å åÀå 0“åPƒà8<åPƒåÎöÿëL<åÀå€ á±0“á  SãX, ‚P‚ñ šáà‚âà áşà›á Pá  
ñàœá áñ šá ‚â€  áğ ›á  ^á÷ÿÿ ‚â¤å‚  áò ‘áH PãS  
¨,å  Pã  ’å å'ùÿ
p…âp‰å@  ê ™åÀåí÷ÿë0™å ™å™åÀå !ƒà A“ç0 ã` ááşÿê ã  á  áÀå²îÿëÀå  Pã.    ãÀå<@™å0ìÿëÀå 0PâÜúÿ
@-å @ƒå  ãÀå<0‚å'ìÿëÀå 0PâÓúÿ
(  ã° Ãá ã0„å  ãÀå˜îÿë|=åÀå 0“å0„å  Pã      „åÜûÿê  á Vã  á p á  
 åÀåpƒàpålöÿëÀå 0”å0å ×åºøÿêÔ=å @“åà=å P“åÿÿê 0—å0“åPƒàeùÿêø-å  ’å åÔøÿêøC-é p áL`ŸåLPŸå`àPà`eà€ á á¿ëÿëFa°áøƒ½PEâ @ ã@„â0µå  á á	  á3ÿ/á Tá÷ÿÿøƒ½è8 ü7 ÿ/á@-é€½è          t   pc e   xc s   €c u   ˆc E   c     –0w,aîºQ	™Ämôjp5¥cé£•d2ˆÛ¤¸ÜyéÕàˆÙÒ—+L¶	½|±~-¸ç‘¿d·ò °jHq¹óŞA¾„}ÔÚëäİmQµÔôÇ…ÓƒV˜lÀ¨kdzùbıìÉeŠO\Ùlcc=úõÈ n;^iLäA`Õrqg¢Ñä<GÔKı…Òkµ
¥ú¨µ5l˜²BÖÉ»Û@ù¼¬ãlØ2u\ßEÏÖÜY=Ñ«¬0Ù&: ŞQ€Q×ÈaĞ¿µô´!#Ä³V™•ºÏ¥½¸¸(ˆ_²ÙÆ$é±‡|o/LhX«aÁ=-f¶AÜvqÛ¼ Ò˜*Õï‰…±qµ¶¥ä¿Ÿ3Ô¸è¢Éx4ù ¨	–˜á»j-=m—ld‘\cæôQkkbalØ0e…N bòí•l{¥Áô‚WÄõÆÙ°ePé·ê¸¾‹|ˆ¹üßİbI-Úó|ÓŒeLÔûXa²MÎQµ:t ¼£â0»ÔA¥ßJ×•Ø=mÄÑ¤ûôÖÓjéiCüÙn4Fˆg­Ğ¸`Ús-Då3_L
ªÉ|İ<qPªA'¾† É%µhW³…o 	Ôf¹ŸäaÎùŞ^˜ÉÙ)"˜Ğ°´¨×Ç=³Y´.;\½·­lºÀ ƒ¸í¶³¿šâ¶šÒ±t9GÕê¯wÒ&ÛƒÜscã„;d”>jm¨ZjzÏäÿ	“'® 
±}D“ğÒ£‡hòşÂi]Wb÷Ëge€q6lçknvÔşà+Ó‰ZzÚÌJİgoß¹ùùï¾C¾·Õ°`è£ÖÖ~“Ñ¡ÄÂØ8RòßOñg»ÑgW¼¦İµ?K6²HÚ+ØL
¯öJ6`zAÃï`ßUßg¨ïn1y¾iFŒ³aËƒf¼ Òo%6âhR•wÌG»¹"/&U¾;ºÅ(½²’Z´+j³\§ÿ×Â1ÏĞµ‹Ù,®Ş[°Âd›&òcìœ£ju
“m©	œ?6ë…grW ‚J¿•z¸â®+±{8¶›Ò’¾Õå·ïÜ|!ßÛÔÒÓ†BâÔñø³İhnƒÚÍ¾[&¹öáw°owG·æZˆpjÿÊ;f\ÿei®bøÓÿkaEÏlxâ
 îÒ×TƒNÂ³9a&g§÷`ĞMGiIÛwn>JjÑ®ÜZÖÙfß@ğ;Ø7S®¼©Å»ŞÏ²Géÿµ0ò½½ŠÂºÊ0“³S¦£´$6Ğº“×Í)WŞT¿gÙ#.zf³¸JaÄh]”+o*7¾´¡ÃßZï-c        s   c         d    c         w   ,c         q   4c         D   <c        r   Hc        T   Tc         p   `c         V   hc         h                   <stdin> %s:%d:  out of memory
  %s %s   (nil)   Token too long
 Unknown type %c
    %d  (   +    modversion is unchanged
   ignoring     modversion change
 UNKNOWN redefinition of %s  Defn for %s %s == < Defn for type%d %s == < extern  >
  %s  expand undefined %s %s  {   }   %s %s   error   warning export undefined symbol %s  Export %s == <  %s: %s: modversion changed because of changes in    ,    (became defined)   %s__crc_%s = 0x%08lx ;
 genksyms version 2.5.60
    Usage:
genksyms [-adDTwqhV] > /path/to/.tmp_obj.ver

  -s, --symbol-prefix   Select symbol prefix
  -d, --debug           Increment the debug level (repeatable)
  -D, --dump            Dump expanded symbol defs (for debugging only)
  -r, --reference file  Read reference symbols from a file
  -T, --dump-types file Dump expanded types into file
  -p, --preserve        Preserve reference modversions or fail
  -w, --warnings        Enable warnings
  -q, --quiet           Disable warnings (default)
  -h, --help            Print this message
  -V, --version         Print the release version
    s:dwqVDr:T:ph   override    extern  override    Hash table occupancy %d/%d = %g
    symbol-prefix   debug   warnings    quiet   dump    reference   dump-types  preserve    version help    typedef enum    struct  union   enum constant   `x ¤_ hx tx €x x œx ¨x ´x Àx Ìx Øx äx ôx  y y y $y 4y Dy Py \y hy ty „y y  y ¬y ¼y Èy Üy èy üy z z ,z @z Hz Pz Xz \z dz lz tz |z ˆz Œz z ”z ˜z œz  z ¤z ¨z ¬z ´z Äz Ğz Ôz äz èz ìz  { { 4{ D{ \{ p{ €{ ˜{ ¨{ À{ Ğ{ è{ ü{ Ø} |  | 4| P| p| | ¬| Ä| Ü| ü| }  } ,} 8} T} l} €} œ} ´} È} ä} ô}  ~ ~ ~ ,~ <~     tÿ tÿÏ tÿtÿ( tÿtÿtÿtÿtÿåÿtÿ, tÿtÿtÿtÿtÿtÿtÿtÿtÿêÿtÿîÿtÿtÿtÿ÷ÿ  tÿtÿtÿtÿtÿ* Øtÿtÿtÿtÿtÿtÿtÿtÿtÿtÿ. + tÿtÿ/ k tÿØ/ tÿØ> tÿtÿ ıÿ9 8 tÿ* # õÿtÿtÿ5 0 tÿØtÿ3  ;  tÿtÿ* tÿ„: < F Q tÿıÿtÿtÿ* tÿtÿtÿtÿtÿı G tÿìÿtÿtÿtÿS tÿ f " tÿ _ ^ tÿtÿtÿa tÿq tÿtÿ ) tÿ tÿc tÿtÿtÿtÿèÿb e m h tÿtÿtÿtÿtÿi tÿn tÿtÿu tÿ*tÿ p tÿx tÿtÿWtÿtÿy tÿtÿtÿtÿtÿ²tÿtÿƒ ‰ tÿtÿtÿŠ  tÿtÿtÿtÿtÿtÿtÿ   012/5-34.	
 !"#$%&'()*+,< < P      ' W A & 9  ™  &  & o & q ¡ "  4 . 3    4 & M o 4 q " 0 ] 0 & 6 f & * : " * ~  0 1 2 0 & 2 W @ 9 & 0 " E * 0  2  ! 0 0 2 & - 5 0 * › M & & & 0 * 2 - . ~  0 0 2 2 ™ . / - . 4 4 & ¡ - / 3 . # 1  1 ª ª     	 
  1           1      5 #    - / -  - & % 1  * 1 / - . 1 0 # 2  1 5 1     	 
  1           1      1 1    1  ` R › & m 2 r * ÿÿÿÿ- . ÿÿ0 ÿÿ2  ÿÿ5 i     	 
                        ÿÿÿÿÿÿÿÿÿÿ& ÿÿÿÿÿÿ* ÿÿÿÿ- ÿÿ 0 ÿÿ2     	 
  ÿÿ          ÿÿ     ÿÿÿÿ   ÿÿÿÿÿÿÿÿ% ÿÿÿÿÿÿÿÿ* ÿÿÿÿÿÿ ÿÿÿÿ1     	 
  ÿÿ          ÿÿ     ÿÿÿÿ   ÿÿÿÿÿÿÿÿ% ÿÿÿÿÿÿÿÿ* ÿÿÿÿÿÿ ÿÿÿÿ1     	 
  ÿÿ          ÿÿ     ÿÿÿÿ   ÿÿÿÿÿÿÿÿ% ÿÿÿÿÿÿÿÿ* ÿÿÿÿÿÿÿÿÿÿÿÿ1     	 
  ÿÿ          ÿÿ     ÿÿÿÿ   ÿÿÿÿÿÿÿÿÿÿ& ÿÿÿÿÿÿ* ÿÿÿÿÿÿÿÿÿÿ0 ÿÿ2     	 
  ÿÿ          ÿÿ     ÿÿÿÿ   ÿÿÿÿÿÿÿÿ% ÿÿÿÿÿÿÿÿ*     	 
  ÿÿ          ÿÿ     ÿÿÿÿ   ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ*   W X q œ & 
 ’ £ H  ^ 2 T ; ®  6 Z J ” : – ³ e  3  ¤ !  7 F j q 7 q £ÿf † < | N W “  V ˜ n   ~ £ÿA o ? A H [ U m ™   a n @ b A 5 c o = A “ > p ¡ n q U | ? J o  A 0 1  Ÿ ~ @ A A W h i k l 3 7 Y W _ ` g x  ‚ O ƒ W ¶   	 
    „           …      p • ! " š › k b ¢ êÿ© § £ # ¨ ª êÿ•ÿ« êÿ´ êÿy ¬ êÿ°   	 
    ±           ·      ¸ ¹ ! " º  ‡ z ¯ êÿ‘ I — #     êÿ”ÿ  êÿ  êÿ   êÿ   	 
                        ! "           êÿ      #     êÿ  ‰ êÿ  êÿ  	 
                           ! "         ªÿ        #       ­     ªÿ  	 
                           ! "         ªÿ        #       ²     ªÿ  	 
                           ! "         ªÿ        #             ªÿ  	 
                           ! "           |       }           ~   A   	 
                           ! "         µ         #   	 
                           ! "                   #     7.>5  4 01A/2  36?   @$8
!"' +% ,&-  D :  ‚C* }( q  m	)]    9;< BƒeyG  { pjLM   yK rswi n‚^8 ]Z\# IH=f  TWX€|~v L xJuP o  _ [b „z gFES RQ  tdc  hUYONa`                    | | }   ‡ ‡ ‰ ‰ ‹ Œ     ” ¢ £ § ¯ ¼ Â Ã Ç È Ì Ò Ö × Ø Ù Ú Ş ß à á å ç é í ï ñ ö ù ú ş ÿ  $%)2468:ABFGHJLNPUVW[\`afkmqrz~€‚„†‹”•šŸ ¤¥©ª®°µ¶º»¿ÀÁÅÉÊÎÏÓÔ×Üäèéí  7 ÿ8ÿ78ÿÿ9:ÿÿ;=ÿÿ<=ÿ=ÿUÿdÿfÿ-ÿ.ÿA>-ÿÿ?ÿ@ÿ?/@ÿKe`VÿÿBÿCÿBCÿDÿEÿÿÿÿÿÿFÿJÿ0R1ÿ ÿ&ÿ&ÿ
&ÿ&Xÿ&Xÿ
&aÿ
aÿXÿXÿÿÿÿÿÿÿÿ	ÿÿÿ*ÿ2HÿÿIÿJÿIJÿÿÿÿÿGKÿLÿ&ÿL0O1ÿL01ÿL"ÿ0K1ÿ01ÿGMÿNÿ&ÿ*ÿN0O1ÿN01ÿN"ÿ0M1ÿ01ÿP%ÿPÿQ/%ÿÿQÿRÿQ/RÿBSÿGSÿTÿÿ&ÿ*ÿT0O1ÿT01ÿT"ÿ0S1ÿ01ÿAK!ÿÿWÿ3#ÿ4Y.ÿ4.ÿÿZÿ[ÿZ[ÿA\-ÿ-ÿÿ]ÿ^ÿ]/^ÿM`ÿ&_ÿ_ÿ5#ÿÿ`ÿ4b.ÿ4b/.ÿcÿb/cÿ&ÿ&3#ÿ-ÿÿÿ0&1-ÿ        	          " % ) * , . 2 7 8 : < ? A C E G I K M O Q V X [ ^ a e i m p s v x z | ~ € ‚ „ † ˆ Š Œ   ’ ” — ™ ›  Ÿ ¢ ¤ ¦ « ° ³ · » ¾ À Â Ä É Î Ñ Õ Ù Ü Ş â ã å ç ë î ñ ó ô ö ø ı 	 "$'+./137:=?BCFJOQUW[^_a   67798;:<:::::::=>>??@AABBCCDDDDDEEEEEEEEEEEEEFFFFFFFFFFFGHHIIJJJJKKLLLLLLMMNNNNNNNOOOPPQQRSSTTTTTTTTUVVWXXYYZZ[[\\]]^^^_``aabbccdeef   tÿtÿ¾ tÿtÿtÿtÿÓÿtÿtÿ`  Äÿáÿtÿtÿtÿ²ÿtÿtÿÉÿùÿtÿ¤ÿtÿuÿtÿtÿÅÿÙÿtÿtÿtÿtÿóÿtÿtÿo tÿtÿ' W T “ tÿj tÿtÿtÿ  ÿÿ   $ M 9 % B C D P ' ( ) * + E \ ] , { G r s Š ‹ Œ  €  - ¥ ¦ 8 Q R S t u v w ˆ 4 K L . d /    789 8	
 *:=ABCDEFJUdf-.&4a&4X<&X00-&02>?@GKLCa&bc;XAYZ[=AXBR&KHIJ-/K!e"03./=-.&*05GMN\]^_.[K&*0GST1111J@`OPQR#.c_&M#M`"0-/*SS"0-3VW11%/11O^11O#%R1111 Stack now    %d token %s (  nterm %s (  Deleting    Starting parse
 Stack size increased to %lu
    Entering state %d
  Reading a token:    Now at end of input.
   Next token is   Shifting    Reducing stack by rule %d (line %lu):
     $%d =    unexpected second declaration name  -> $$ = syntax error    Error: discarding   Error: popping  memory exhausted    Cleanup: discarding lookahead   Cleanup: popping    $end    $undefined  ASM_KEYW    ATTRIBUTE_KEYW  AUTO_KEYW   BOOL_KEYW   CHAR_KEYW   CONST_KEYW  DOUBLE_KEYW ENUM_KEYW   EXTERN_KEYW EXTENSION_KEYW  FLOAT_KEYW  INLINE_KEYW INT_KEYW    LONG_KEYW   REGISTER_KEYW   RESTRICT_KEYW   SHORT_KEYW  SIGNED_KEYW STATIC_KEYW STRUCT_KEYW TYPEDEF_KEYW    UNION_KEYW  UNSIGNED_KEYW   VOID_KEYW   VOLATILE_KEYW   TYPEOF_KEYW EXPORT_SYMBOL_KEYW  ASM_PHRASE  ATTRIBUTE_PHRASE    TYPEOF_PHRASE   BRACE_PHRASE    BRACKET_PHRASE  EXPRESSION_PHRASE   CHAR    DOTS    IDENT   INT REAL    STRING  TYPE    OTHER   FILENAME    ';' '}' ',' '(' ')' '*' '=' '{' ':' $accept declaration_seq declaration $@1 declaration1    $@2 $@3 simple_declaration  init_declarator_list_opt    init_declarator_list    init_declarator decl_specifier_seq_opt  decl_specifier_seq  decl_specifier  storage_class_specifier type_specifier  simple_type_specifier   ptr_operator    cvar_qualifier_seq_opt  cvar_qualifier_seq  cvar_qualifier  direct_declarator   nested_declarator   direct_nested_declarator    parameter_declaration_clause    parameter_declaration_list_opt  parameter_declaration_list  parameter_declaration   m_abstract_declarator   direct_m_abstract_declarator    function_definition initializer_opt initializer class_body  member_specification_opt    member_specification    member_declaration  member_declarator_list_opt  member_declarator_list  member_declarator   member_bitfield_declarator  attribute_opt   enum_body   enumerator_list enumerator  asm_definition  asm_phrase_opt  export_definition                                                                                                                      	   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            	 	                     
 
 	     	 	   	                 
   
 	 	       
 
                                H  H H H H I J H H K H H H  H H J H L H I H M J H K H N H H   O P H H Q  I K L L H I K H R H H H H Q L 6 H H H L 6 L L L 6 S L ? S T T H   H H H H H H H H H H H H                                                                                               ‘ – 
 
   ƒ     '   ' <  A 9 + 
    
= 
  € J   q ; > q 4     H B n d 
I J 
F 
Z g 
T  l q  
k B v ‰ ¨ x P [ ‘  S ) 

¾ Ä Ì Ô Ü ä è í î ó ù                                    
         
   F                            " # # % ) ( - % " 0 0 A . A E     < ) B B    ( - .  + + 2 2 2 5 5 ; ; 5 ; * + + + 3 3 3 = = 7 7 7 3 3 8 8 8 3 6 6 7 @ @ @ $ ! > >  = 6 6 @ D C D 	   6 6 6   6 9 9 9 >       > 9 9   C C 9 ? C                   ? ? ?       ? ? ? I I I I I I I I J     J J J K K K K K K K K L L L L L L L L M   M M M M M M N   N N N N N N O O   O P   P Q Q Q R   R S S S S S S S S T T T T T T T T H H H H H H H H H H H H H H H H H H H H H H H H H H H H H            	 
  	       	                          G ' ' '       ! ! " H    #  $ % & ( $ + ,  )    2 2 4    4 # 8 8 ,  * G     *  ; , 0 1 1    1 + , 3 3 3 $ % ; , $ A , 6 7 7 3 3 3 ; , @ @ @ : : 9 9 9 : ; , * @ @ @ 4 H ; , / B < < * , ; E  H  = > ? H = 9 9 9 B H H H B 1 1 H = > 1 , = H H H H H H H H H C C C H H H C C C          H H            * * * * * * * * - H - - - - - - . H . . . . . . " " H " 3 H 3 5 5 5 9 H 9 D D D D D D D D F F F F F F F F  H H H H H H H H H H H H H H H H H H H H H H H H H H H H   eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee eeeeeeeee eeeeeeeeeeeeee e e7eee
 
(
e
 
eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\`     \`     \`     \   \`     `   \`     h   \`     \`     p   \`     |   „   ”       ¬   \`     ´   ¸   À   €c   È   Ø   ä       \`           ,   \`     8   D   X   xc 	  h   Ğb 
  \`     €   Œ   ˆc   \`     \`     ¨   ´   ¼   \`     \`     È   \`     Ô   Ü   \`     ä   ğ   ø   \`     \`      ‘   ‘   \`     ‘   \`     ‘   \`     \`     (‘   \`     \`     \`     \`     0‘   pc   \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     \`     8‘   %s
 flex scanner push-back overflow out of dynamic memory in yyensure_buffer_stack()    out of dynamic memory in yy_create_buffer() out of dynamic memory in yy_scan_buffer()   out of dynamic memory in yy_scan_bytes()    bad buffer in yy_scan_bytes()   fatal flex scanner internal error--end of buffer missed fatal error - scanner input buffer overflow input in flex scanner failed    out of dynamic memory in yy_get_next_buffer()   fatal flex scanner internal error--no action found  asm __asm   __asm__ __typeof__  __const __attribute__   __const__   __signed__  static  int char    const   __restrict__    restrict    EXPORT_SYMBOL_GPL_FUTURE    __inline__  __volatile__    EXPORT_SYMBOL   _restrict   __attribute EXPORT_SYMBOL_GPL   __extension__   EXPORT_UNUSED_SYMBOL    __signed    EXPORT_UNUSED_SYMBOL_GPL    __inline    auto    __volatile  unsigned    short   inline  volatile    long    _Bool   register    void    double  __typeof    signed  typeof  float   H~ÿ       x P              \    œY    L‘          P‘       õşÿo”    p    ğ 
   :                  @’               D        (         şÿÿoü ÿÿÿo   ğÿÿoª                                                 X‘         h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h                @Ó \`    GCC: (Raspbian 4.9.2-10) 4.9.2 GCC: (Raspbian 4.8.4-1) 4.8.4 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.exidx .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .comment .ARM.attributes                     4           P           p           ”           ğ           p           ª           ü                 	     D      
     \           h            
           œY           ¤Y           @‘           H‘           L‘           P‘           T‘           X‘           @’           Ü’           ø’                                               ñÿJ   P        M   ˆ        J   @‘        J   ¸        J   ¤Y        J   Ü’        P            ñÿM   Ä        ™   Ä       J   à        M   \        M   œY        ¦            ñÿM   d        M    Y        ï            ñÿM   °        ú   ° @     J   Ü        M   ğ        	  ğ p       ` h     J   À        M   È          È D     J            M           -   ø     J   ü        M           J   $        M   ,        J   Ü        M   ä        8  ä L    J            M   0        J   ô        M   ü        B  ü      J   ´        M   ü        O   ì    J   °        M   È        J   à         M   !        J   ¬"        M    
        J   Œ
        M   \        J   0        J   ¨Y        b  ¨Y 0     o  ØY      J   ä’        x  è’        @Ó      ‘  ì’      J   ˆ^        J   “        œ  “  @    £  Ó      ±  Ó      ¸  Ó      Ì  Ó      Ş   Ó      ì  $Ó      ò  (Ó      ı  ,Ó        0Ó        4Ó      &  8Ó      5  <Ó      M   „        E           ñÿP  T‘       M   è        ]  è       J           M           r         J   D        J   à’        M   P        …  P       J   t        ›  “      J   P‘        ª  P‘       M   x        Ñ  x       J   ¨        J   L‘        İ  L‘       J   “        ü           ñÿM   Ü"          Ü" `     J   0#        M   <#          <# @     J   p#        M   |#        .  |# `     J   Ì#        M   Ü#        @  Ü# œ     J   t$        M   x$        J   p&        M   t(        J   2        J    c        P   c      X  @e v    _  ¸f ,    k  äg     s  ìk     {  ôo »     „  °p …     ‰  8q 
    ‘  Dr g    —  ¬s 
      ¸t …     £  @u b     «  ¤u b     µ  v »     J   Äv        J   DÓ        ¼  DÓ      Æ  HÓ      Ñ  LÓ      Ş  PÓ      è           ñÿM    2        ò   2 ğ     J   x3        M   3          3 L     J   Ô3        M   Ü3          Ü3 (     J   ü3        M   4        ,  4 Ğ     J   È4        M   Ô4        4  Ô4 ´     J   €5        M   ˆ5        J   6        M   6        J   l6        M   p6        J   Ğ6        M   Ô6        J  Ô6 ˆ     J   X7        M   \7        J   ´7        M   ¸7        J    8        M   $8        J   °8        M   ´8        J   9        M   9        J   ´9        M   ¸9        J   <:        M   D:        J   l:        M   p:        J   |:        M   €:        J   Œ:        M   :        J   œ:        M    :        J   ¬:        M   °:        J   ¼:        M   À:        J   Ì:        M   Ğ:        J   Ü:        M   à:        J   ì:        M   ğ:        J   ü:        M    ;        J   t;        M   x;        J   Ü<        M   =        J   ¬?        M   ä?        J   <@        M   t@        J   DJ        M   8K        J   P~        Y  P~      _  P‚ ’     i  ä‚ ª     p  ƒ t     x  „ ª     €  °„ N    ‡   ‡ N      P‰      Ÿ  PŠ (    J   ğ’        J   x        J   TÓ        ­  TÓ      ¶  XÓ      Æ  \Ó      Ú  `Ó      å  dÓ      ı  hÓ        lÓ        tÓ      ,  xÓ      @  |Ó      \  ˆÓ      d  ŒÓ      r  Ó        ”Ó        ˜Ó      ·           ñÿM   4Y        J   Y        M   ˜Y        E           ñÿJ   H‘        Ã  H‘       J   T‘        Ñ  T‘                    ñÿİ  P‘        î  X‘       ÷  L‘        
  @’       M   h        J   x        M   |           ˆ5 „     4  ˜Y      D  ¸7 l     N  ¨Ó      V             h  €:      r             „                 Ü’        «             ½  ä’      Æ  ô’       Ô             å  ¬Ó      í             ı                          !  ÀÓ       ,  ô’       3   (    ?  x$ (    G  pÓ      L             `  œY       f  ÀÓ       r  à:      ~  ¸Ó      …  |;                   ¢  \7 \     ³  ! Ø    Á             Ó  ğ’      Ü  „Ó      ê  ø’      ü                          "   l     1   :      <  x;      D  €;      K  °:      X             i  œÓ      u  9 œ     „  ü        Ü’       œ             ®  €Ó      ´             Ñ  D:      à  H 8     ê  À:      ó  ¸9 Œ     	              	  `:      	             4	  à’      A	             Q	  :      \	             l	  ¤Y      {	  $8      	  °Ó      –	             ¨	             º	             Í	  6 d     Ş	   “      ï	             
  4Y d     
             -
             A
             U
  ´8 h     h
  ÀÓ       m
  ¼Ó      t
  ˆ       {
  € d     …
             –
             ¨
  ÀÓ       °
  “      Â
  ô’       Î
             à
  ,      ê
   
 d    ï
   Ó      ş
  „; °                   p6 d     (             9              M             a  ´Ó      h  ¤Ó      u  p:      ~  ô’      Š              ¤  “      ¶             È  ğ:      Ô  Ğ:      Ş             ï                0 `       \          ; x      /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crt1.o $d $a /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crti.o call_weak_fn /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crtn.o genksyms.c print_location concat_list mk_node print_type_name print_list read_node __add_symbol expand_and_crc_sym symbol_types crctab32 end.6546 visited_symbols mod_prefix symtab flag_warnings errors last_enum_expr.6341 enum_counter.6340 flag_preserve nsyms flag_debug debugfile flag_dump_defs expansion_trail flag_reference flag_dump_types crtstuff.c __JCR_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.9004 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry parse.tab.c yy_stack_print yy_symbol_print.isra.1 yydestruct.isra.3 record_compound yytname yypact yytranslate yycheck yytable yydefact yyr2 yyrline yyrhs yyprhs yyr1 yypgoto yydefgoto yystos is_extern is_typedef current_name decl_spec lex.lex.c yy_get_previous_state yy_load_buffer_state yy_fatal_error yyunput yyensure_buffer_stack yy_init_buffer yy_ec yy_accept yy_def yy_meta yy_base yy_chk yy_nxt asso_values.6687 wordlist.6698 yy_start yy_buffer_stack yy_buffer_stack_top yy_c_buf_p yy_last_accepting_state yy_last_accepting_cpos yy_n_chars yy_hold_char yy_buffer_stack_max yy_did_buffer_switch_on_eof yy_init lexstate.6729 next_node.6732 dont_want_brace_phrase.6731 suppress_type_lookup.6730 elf-init.oS __FRAME_END__ __JCR_END__ __init_array_end _DYNAMIC __init_array_start _GLOBAL_OFFSET_TABLE_ yy_switch_to_buffer __libc_csu_fini yyrestart yynerrs strcmp@@GLIBC_2.4 yyget_out strtol@@GLIBC_2.4 _ITM_deregisterTMCloneTable data_start printf@@GLIBC_2.4 cur_line __bss_start__ fopen@@GLIBC_2.4 yydebug free@@GLIBC_2.4 ferror@@GLIBC_2.4 memcpy@@GLIBC_2.4 _bss_end__ _edata find_symbol yyparse yyin _IO_getc@@GLIBC_2.4 _fini __bss_end__ yyget_debug yytext yyrealloc realloc@@GLIBC_2.4 yy_create_buffer export_symbol perror@@GLIBC_2.4 yylineno yy_flex_debug stderr@@GLIBC_2.4 _IO_putc@@GLIBC_2.4 fwrite@@GLIBC_2.4 error_with_pos yyget_text yyalloc yyfree yyset_lineno fread@@GLIBC_2.4 source_file yy_scan_buffer add_symbol __data_start malloc@@GLIBC_2.4 yyout __libc_start_main@@GLIBC_2.4 yy_scan_string free_list yyset_in yy_scan_bytes __gmon_start__ yyget_lineno getopt_long@@GLIBC_2.4 __dso_handle exit@@GLIBC_2.4 yyget_leng feof@@GLIBC_2.4 _IO_stdin_used yypush_buffer_state yychar strlen@@GLIBC_2.4 strchr@@GLIBC_2.4 fprintf@@GLIBC_2.4 yy_delete_buffer stdin@@GLIBC_2.4 ungetc@@GLIBC_2.4 __libc_csu_init __errno_location@@GLIBC_2.4 snprintf@@GLIBC_2.4 __strdup@@GLIBC_2.4 yypop_buffer_state _end yyleng _start copy_node fgetc@@GLIBC_2.4 fileno@@GLIBC_2.4 __end__ stdout@@GLIBC_2.4 __bss_start fclose@@GLIBC_2.4 free_node main in_source_file yylex vfprintf@@GLIBC_2.4 yy_flush_buffer fputc@@GLIBC_2.4 _Jv_RegisterClasses clearerr@@GLIBC_2.4 yylval cur_filename yyget_in __TMC_END__ _ITM_registerTMCloneTable optarg@@GLIBC_2.4 isatty@@GLIBC_2.4 yyset_debug yyset_out fputs@@GLIBC_2.4 abort@@GLIBC_2.4 copy_list_range _init yylex_destroy                                                  4 4                    #         P P                     1         p p  $                  D   öÿÿo   ” ”  \               N         ğ ğ  €              V         p p  :                 ^   ÿÿÿo   ª ª  P                k   şÿÿo   ü ü                   z   	         (                ƒ   	   B   D D                Œ         \ \                    ‡         h h  ¸                ’          
  
  |O                 ˜         œY œY                             ¤Y ¤Y  œ7                 ¦     p‚   @‘ @‘                   ±         H‘ H‘                    »         L‘ L‘                    Ç         P‘ P‘                    Ó         T‘ T‘                    Ø         X‘ X‘  è                á         @’ @’  œ                 æ         Ü’ Ü’                    ì         ø’ ô’  È@                 ñ      0       ô’  =                 ú     p        1“  1                                b“  
                               l”  ğ             	              \¬  $                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /* Lexical analysis for genksyms.
   Copyright 1996, 1997 Linux International.

   New implementation contributed by Richard Henderson <rth@tamu.edu>
   Based on original work by Bjorn Ekwall <bj0rn@blox.se>

   Taken from Linux modutils 2.4.22.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2 of the License, or (at your
   option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */


%{

#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "genksyms.h"
#include "parse.tab.h"

/* We've got a two-level lexer here.  We let flex do basic tokenization
   and then we categorize those basic tokens in the second stage.  */
#define YY_DECL		static int yylex1(void)

%}

IDENT			[A-Za-z_\$][A-Za-z0-9_\$]*

O_INT			0[0-7]*
D_INT			[1-9][0-9]*
X_INT			0[Xx][0-9A-Fa-f]+
I_SUF			[Uu]|[Ll]|[Uu][Ll]|[Ll][Uu]
INT			({O_INT}|{D_INT}|{X_INT}){I_SUF}?

FRAC			([0-9]*\.[0-9]+)|([0-9]+\.)
EXP			[Ee][+-]?[0-9]+
F_SUF			[FfLl]
REAL			({FRAC}{EXP}?{F_SUF}?)|([0-9]+{EXP}{F_SUF}?)

STRING			L?\"([^\\\"]*\\.)*[^\\\"]*\"
CHAR			L?\'([^\\\']*\\.)*[^\\\']*\'

MC_TOKEN		([~%^&*+=|<>/-]=)|(&&)|("||")|(->)|(<<)|(>>)

/* We don't do multiple input files.  */
%option noyywrap

%option noinput

%%


 /* Keep track of our location in the original source files.  */
^#[ \t]+{INT}[ \t]+\"[^\"\n]+\".*\n	return FILENAME;
^#.*\n					cur_line++;
\n					cur_line++;

 /* Ignore all other whitespace.  */
[ \t\f\v\r]+				;


{STRING}				return STRING;
{CHAR}					return CHAR;
{IDENT}					return IDENT;

 /* The Pedant requires that the other C multi-character tokens be
    recognized as tokens.  We don't actually use them since we don't
    parse expressions, but we do want whitespace to be arranged
    around them properly.  */
{MC_TOKEN}				return OTHER;
{INT}					return INT;
{REAL}					return REAL;

"..."					return DOTS;

 /* All other tokens are single characters.  */
.					return yytext[0];


%%

/* Bring in the keyword recognizer.  */

#include "keywords.hash.c"


/* Macros to append to our phrase collection list.  */

/*
 * We mark any token, that that equals to a known enumerator, as
 * SYM_ENUM_CONST. The parser will change this for struct and union tags later,
 * the only problem is struct and union members:
 *    enum e { a, b }; struct s { int a, b; }
 * but in this case, the only effect will be, that the ABI checksums become
 * more volatile, which is acceptable. Also, such collisions are quite rare,
 * so far it was only observed in include/linux/telephony.h.
 */
#define _APP(T,L)	do {						   \
			  cur_node = next_node;				   \
			  next_node = xmalloc(sizeof(*next_node));	   \
			  next_node->next = cur_node;			   \
			  cur_node->string = memcpy(xmalloc(L+1), T, L+1); \
			  cur_node->tag =				   \
			    find_symbol(cur_node->string, SYM_ENUM_CONST, 1)?\
			    SYM_ENUM_CONST : SYM_NORMAL ;		   \
			  cur_node->in_source_file = in_source_file;       \
			} while (0)

#define APP		_APP(yytext, yyleng)


/* The second stage lexer.  Here we incorporate knowledge of the state
   of the parser to tailor the tokens that are returned.  */

int
yylex(void)
{
  static enum {
    ST_NOTSTARTED, ST_NORMAL, ST_ATTRIBUTE, ST_ASM, ST_TYPEOF, ST_TYPEOF_1,
    ST_BRACKET, ST_BRACE, ST_EXPRESSION,
    ST_TABLE_1, ST_TABLE_2, ST_TABLE_3, ST_TABLE_4,
    ST_TABLE_5, ST_TABLE_6
  } lexstate = ST_NOTSTARTED;

  static int suppress_type_lookup, dont_want_brace_phrase;
  static struct string_list *next_node;

  int token, count = 0;
  struct string_list *cur_node;

  if (lexstate == ST_NOTSTARTED)
    {
      next_node = xmalloc(sizeof(*next_node));
      next_node->next = NULL;
      lexstate = ST_NORMAL;
    }

repeat:
  token = yylex1();

  if (token == 0)
    return 0;
  else if (token == FILENAME)
    {
      char *file, *e;

      /* Save the filename and line number for later error messages.  */

      if (cur_filename)
	free(cur_filename);

      file = strchr(yytext, '\"')+1;
      e = strchr(file, '\"');
      *e = '\0';
      cur_filename = memcpy(xmalloc(e-file+1), file, e-file+1);
      cur_line = atoi(yytext+2);

      if (!source_file) {
        source_file = xstrdup(cur_filename);
        in_source_file = 1;
      } else {
        in_source_file = (strcmp(cur_filename, source_file) == 0);
      }

      goto repeat;
    }

  switch (lexstate)
    {
    case ST_NORMAL:
      switch (token)
	{
	case IDENT:
	  APP;
	  {
	    const struct resword *r = is_reserved_word(yytext, yyleng);
	    if (r)
	      {
		switch (token = r->token)
		  {
		  case ATTRIBUTE_KEYW:
		    lexstate = ST_ATTRIBUTE;
		    count = 0;
		    goto repeat;
		  case ASM_KEYW:
		    lexstate = ST_ASM;
		    count = 0;
		    goto repeat;
		  case TYPEOF_KEYW:
		    lexstate = ST_TYPEOF;
		    count = 0;
		    goto repeat;

		  case STRUCT_KEYW:
		  case UNION_KEYW:
		  case ENUM_KEYW:
		    dont_want_brace_phrase = 3;
		    suppress_type_lookup = 2;
		    goto fini;

		  case EXPORT_SYMBOL_KEYW:
		      goto fini;
		  }
	      }
	    if (!suppress_type_lookup)
	      {
		if (find_symbol(yytext, SYM_TYPEDEF, 1))
		  token = TYPE;
	      }
	  }
	  break;

	case '[':
	  APP;
	  lexstate = ST_BRACKET;
	  count = 1;
	  goto repeat;

	case '{':
	  APP;
	  if (dont_want_brace_phrase)
	    break;
	  lexstate = ST_BRACE;
	  count = 1;
	  goto repeat;

	case '=': case ':':
	  APP;
	  lexstate = ST_EXPRESSION;
	  break;

	case DOTS:
	default:
	  APP;
	  break;
	}
      break;

    case ST_ATTRIBUTE:
      APP;
      switch (token)
	{
	case '(':
	  ++count;
	  goto repeat;
	case ')':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = ATTRIBUTE_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_ASM:
      APP;
      switch (token)
	{
	case '(':
	  ++count;
	  goto repeat;
	case ')':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = ASM_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_TYPEOF:
      switch (token)
	{
	case '(':
	  if ( ++count == 1 )
	    lexstate = ST_TYPEOF_1;
	  else
	    APP;
	  goto repeat;
	case ')':
	  APP;
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = TYPEOF_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  APP;
	  goto repeat;
	}
      break;

    case ST_TYPEOF_1:
      if (token == IDENT)
	{
	  if (is_reserved_word(yytext, yyleng)
	      || find_symbol(yytext, SYM_TYPEDEF, 1))
	    {
	      yyless(0);
	      unput('(');
	      lexstate = ST_NORMAL;
	      token = TYPEOF_KEYW;
	      break;
	    }
	  _APP("(", 1);
	}
	APP;
	lexstate = ST_TYPEOF;
	goto repeat;

    case ST_BRACKET:
      APP;
      switch (token)
	{
	case '[':
	  ++count;
	  goto repeat;
	case ']':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = BRACKET_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_BRACE:
      APP;
      switch (token)
	{
	case '{':
	  ++count;
	  goto repeat;
	case '}':
	  if (--count == 0)
	    {
	      lexstate = ST_NORMAL;
	      token = BRACE_PHRASE;
	      break;
	    }
	  goto repeat;
	default:
	  goto repeat;
	}
      break;

    case ST_EXPRESSION:
      switch (token)
	{
	case '(': case '[': case '{':
	  ++count;
	  APP;
	  goto repeat;
	case '}':
	  /* is this the last line of an enum declaration? */
	  if (count == 0)
	    {
	      /* Put back the token we just read so's we can find it again
		 after registering the expression.  */
	      unput(token);

	      lexstate = ST_NORMAL;
	      token = EXPRESSION_PHRASE;
	      break;
	    }
	  /* FALLTHRU */
	case ')': case ']':
	  --count;
	  APP;
	  goto repeat;
	case ',': case ';':
	  if (count == 0)
	    {
	      /* Put back the token we just read so's we can find it again
		 after registering the expression.  */
	      unput(token);

	      lexstate = ST_NORMAL;
	      token = EXPRESSION_PHRASE;
	      break;
	    }
	  APP;
	  goto repeat;
	default:
	  APP;
	  goto repeat;
	}
      break;

    case ST_TABLE_1:
      goto repeat;

    case ST_TABLE_2:
      if (token == IDENT && yyleng == 1 && yytext[0] == 'X')
	{
	  token = EXPORT_SYMBOL_KEYW;
	  lexstate = ST_TABLE_5;
	  APP;
	  break;
	}
      lexstate = ST_TABLE_6;
      /* FALLTHRU */

    case ST_TABLE_6:
      switch (token)
	{
	case '{': case '[': case '(':
	  ++count;
	  break;
	case '}': case ']': case ')':
	  --count;
	  break;
	case ',':
	  if (count == 0)
	    lexstate = ST_TABLE_2;
	  break;
	};
      goto repeat;

    case ST_TABLE_3:
      goto repeat;

    case ST_TABLE_4:
      if (token == ';')
	lexstate = ST_NORMAL;
      goto repeat;

    case ST_TABLE_5:
      switch (token)
	{
	case ',':
	  token = ';';
	  lexstate = ST_TABLE_2;
	  APP;
	  break;
	default:
	  APP;
	  break;
	}
      break;

    default:
      exit(1);
    }
fini:

  if (suppress_type_lookup > 0)
    --suppress_type_lookup;
  if (dont_want_brace_phrase > 0)
    --dont_want_brace_phrase;

  yylval = &next_node->next;

  return token;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          %language=ANSI-C
%define hash-function-name is_reserved_hash
%define lookup-function-name is_reserved_word
%{
struct resword;
static const struct resword *is_reserved_word(register const char *str, register unsigned int len);
%}
struct resword { const char *name; int token; }
%%
EXPORT_SYMBOL, EXPORT_SYMBOL_KEYW
EXPORT_SYMBOL_GPL, EXPORT_SYMBOL_KEYW
EXPORT_SYMBOL_GPL_FUTURE, EXPORT_SYMBOL_KEYW
EXPORT_UNUSED_SYMBOL, EXPORT_SYMBOL_KEYW
EXPORT_UNUSED_SYMBOL_GPL, EXPORT_SYMBOL_KEYW
__asm, ASM_KEYW
__asm__, ASM_KEYW
__attribute, ATTRIBUTE_KEYW
__attribute__, ATTRIBUTE_KEYW
__const, CONST_KEYW
__const__, CONST_KEYW
__extension__, EXTENSION_KEYW
__inline, INLINE_KEYW
__inline__, INLINE_KEYW
__signed, SIGNED_KEYW
__signed__, SIGNED_KEYW
__typeof, TYPEOF_KEYW
__typeof__, TYPEOF_KEYW
__volatile, VOLATILE_KEYW
__volatile__, VOLATILE_KEYW
# According to rth, c99 defines _Bool, __restrict, __restrict__, restrict.  KAO
_Bool, BOOL_KEYW
_restrict, RESTRICT_KEYW
__restrict__, RESTRICT_KEYW
restrict, RESTRICT_KEYW
asm, ASM_KEYW
# attribute commented out in modutils 2.4.2.  People are using 'attribute' as a
# field name which breaks the genksyms parser.  It is not a gcc keyword anyway.
# KAO.
#   attribute, ATTRIBUTE_KEYW
auto, AUTO_KEYW
char, CHAR_KEYW
const, CONST_KEYW
double, DOUBLE_KEYW
enum, ENUM_KEYW
extern, EXTERN_KEYW
float, FLOAT_KEYW
inline, INLINE_KEYW
int, INT_KEYW
long, LONG_KEYW
register, REGISTER_KEYW
short, SHORT_KEYW
signed, SIGNED_KEYW
static, STATIC_KEYW
struct, STRUCT_KEYW
typedef, TYPEDEF_KEYW
typeof, TYPEOF_KEYW
union, UNION_KEYW
unsigned, UNSIGNED_KEYW
void, VOID_KEYW
volatile, VOLATILE_KEYW
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ELF          (            d     4     ( 
   GCC: (Raspbian 4.9.2-10) 4.9.2 A.   aeabi $   7-A 
A	" .symtab .strtab .shstrtab .text .data .bss .comment .note.GNU-stack .ARM.attributes                             ñÿ                                                                                     empty.c                                                         4                      !             4                      '             4                      ,      0       4                     5              T                      E     p        T   /                                ƒ   U                                Ø   €   	            	              X  	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *.hash.c
*.lex.c
*.tab.c
*.tab.h
genksyms
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /* A Bison parser, made by GNU Bison 2.5.1.  */

/* Bison interface for Yacc-like parsers in C
   
      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
   
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.
   
   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */


/* Tokens.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
   /* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */
   enum yytokentype {
     ASM_KEYW = 258,
     ATTRIBUTE_KEYW = 259,
     AUTO_KEYW = 260,
     BOOL_KEYW = 261,
     CHAR_KEYW = 262,
     CONST_KEYW = 263,
     DOUBLE_KEYW = 264,
     ENUM_KEYW = 265,
     EXTERN_KEYW = 266,
     EXTENSION_KEYW = 267,
     FLOAT_KEYW = 268,
     INLINE_KEYW = 269,
     INT_KEYW = 270,
     LONG_KEYW = 271,
     REGISTER_KEYW = 272,
     RESTRICT_KEYW = 273,
     SHORT_KEYW = 274,
     SIGNED_KEYW = 275,
     STATIC_KEYW = 276,
     STRUCT_KEYW = 277,
     TYPEDEF_KEYW = 278,
     UNION_KEYW = 279,
     UNSIGNED_KEYW = 280,
     VOID_KEYW = 281,
     VOLATILE_KEYW = 282,
     TYPEOF_KEYW = 283,
     EXPORT_SYMBOL_KEYW = 284,
     ASM_PHRASE = 285,
     ATTRIBUTE_PHRASE = 286,
     TYPEOF_PHRASE = 287,
     BRACE_PHRASE = 288,
     BRACKET_PHRASE = 289,
     EXPRESSION_PHRASE = 290,
     CHAR = 291,
     DOTS = 292,
     IDENT = 293,
     INT = 294,
     REAL = 295,
     STRING = 296,
     TYPE = 297,
     OTHER = 298,
     FILENAME = 299
   };
#endif



#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
#endif

extern YYSTYPE yylval;


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               cmd_scripts/mod/empty.o := gcc -Wp,-MD,scripts/mod/.empty.o.d  -nostdinc -isystem /usr/lib/gcc/arm-linux-gnueabihf/4.9/include -I./arch/arm/include -Iarch/arm/include/generated/uapi -Iarch/arm/include/generated  -Iinclude -I./arch/arm/include/uapi -Iarch/arm/include/generated/uapi -I./include/uapi -Iinclude/generated/uapi -include ./include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-bcm2709/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -funwind-tables -marm -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Iarch/arm/xenomai/include -Iinclude/xenomai -fno-delete-null-pointer-checks -O2 --param=allow-store-data-races=0 -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -pg -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(empty)"  -D"KBUILD_MODNAME=KBUILD_STR(empty)" -c -o scripts/mod/.tmp_empty.o scripts/mod/empty.c

source_scripts/mod/empty.o := scripts/mod/empty.c

deps_scripts/mod/empty.o := \

scripts/mod/empty.o: $(deps_scripts/mod/empty.o)

$(deps_scripts/mod/empty.o):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ELF          (            Ğ†     4     (   à-å 0‘å  ê Sã Àå0 á  š àĞå   áÀCâ  ^ã €âõÿÿ ‚â Sã0Câ 0å  á  š ÀÒå ‚â  \ãöÿÿ
ğä   ãğä  Pãp@-éP   
 ` á0@Ÿå P ã  êP”å Uã  
  ”å áşÿÿë@„â  Pãöÿÿ  áp€½è    @-é/ ã @ áşÿÿë4Ÿå  Pã@€  áşÿÿë  Pã  
  áŸåşÿÿëoá  á€½è  ã€½è       8@-é P á ÀĞå. \ãP€@Ğ  á@ şÿÿëˆ0Ÿå  Tã“  à  
|àŸåÀ á á   ãBƒà#2 áƒ0ƒàƒ1Bà ‚â€àÀñå  \ãöÿÿL0ŸåL Ÿå“  à  á9€â J’ç  Tã    ê @”å  Tã  
 „â áşÿÿë  Pã÷ÿÿ  á8€½è¯#«ªªªkNÆA    ğA-é @ áĞMâ  áp á€ á` áşÿÿë  Wã€ P á  
â@gà@„à@!å  áyÿÿë @ á  Tã  
 á  á  áşÿÿëâ  Pã  á  0Ôç= Sã  
jÿÿë @Pâñÿÿ   ãĞâğ½è …â  „àĞâğ½èø@-é ` áPAâ@µå  Tâ/  
şÿÿë ÀÔå á* \ã 0 á Câ  á  
0Ôç* Sã%  
şÿÿë  Pãîÿÿ  ãø€½è Ôç  áp„â* Rã!  
 tã  Väÿÿ
şÿÿë @ á  áşÿÿë á 0 á  Tã  SÀ  À   á Tá0 ¡0Œ³ `à  Sã  †àÒÿÿşÿÿë  Pãàÿÿ
@µå  TâÏÿÿø€½è á  áşÿÿë  PãÆÿÿÖÿÿêCâ  áşÿÿë @ á á  áşÿÿë p á  áşÿÿë  Wã¹ÿÿ
Éÿÿêp@-é @ áHPŸå` á 0”å •å  Sã  á	  
şÿÿë0´å( Ÿå  Sã ã  ãóÿÿ
 0–åşÿÿëğÿÿê
  ãp@½èşÿÿê       p@-é P áŸå™ÿÿë  Pã$  
  ãşÿÿë 0Õå_  ã. Sã @ á ` á Ää Àå  
  Sã0  
 …â0ÄäP á0Òä. Sã  Sùÿÿ. SãP… 0 ã 0Äå  á˜Ÿåşÿÿë  Pã  
Œ0Ÿå´Óá Óå  “å´Äá  „å Äå  áp€½è  ã  áp@½èşÿÿê0ÕåP…â. Sã  Sİÿÿãÿÿê  á@Ÿåşÿÿë  Pã80Ÿ80Ÿ´ Ó°0Ó  “´ Ä  „°0Ä  áp€½è0Æå×ÿÿê0          (   0   8   ğO-éĞMâ`å°å VáL  *4qŸå@ áP á  á  á € ã 0àã 0å¾0Úáƒâqÿæş Qã$  š Sá
0f 4™C2 1‘0 ™å™å1ƒà €àƒ1‘ç€à ™åÀ‘å á0ƒà €àşÿÿë  Pã   ™å 0šåÀ‘à  
0Ñç  Sã
  
$ Sã  
0šå Sá  Š  å0cà Sá 05
€ 1  * Šâ ZáÒÿÿ:  áĞâğ½è Rá
€  Šâ ZáÊÿÿ:öÿÿê@ ŸåÜåÀåşÿÿë  Pãäÿÿ
Àå0Üå  Sã. Sßÿÿ Šâ Zá»ÿÿ:çÿÿê € ãåÿÿêÿÿ  <   ğA-é¾àÒá<âs0ÿæş Sã,  Š`åèNâ@å Vá1  *ÈPŸå  á € ãp ã  ê ‚â Rá  *¾0ÒáÌƒâ|Àÿæş \ã8C’  š Sá0f 4ÀC2 1œ ^áïÿÿ0Òå0â Sãëÿÿ
0’å Sá  
ÀSàÀc@ \á€ ± ‚âp ± Ráãÿÿ: Wã     ğ½è(0Ÿå`å ^á0f 4ÀC2 áœÌÿÿê  áğ½è   ãğ½èÿÿ   -é ã@-é  ã,@ŸåĞMâ( Ÿå 0”åşÿÿë0â  ”åå  á0åşÿÿë  ãşÿÿë    D   p@-é P áL  ãşÿÿë @Pâ  
  ãL  ãşÿÿë  áşÿÿë `Pâ  
şÿÿë Pã P á  š @â  †àPŸåşÿÿë  PãP† 0  EH0„80Ÿå àã`„åø/å„å  „åøOå  áp€½è ŸåŸåşÿÿë ŸåŸåşÿÿë    ø  L   x      ğA-éP áp á € áşÿÿë ` á €âşÿÿë @Pâ  
0 á À ãÀƒä0ƒâÀ„å áÀƒä †âÀƒä „âÀƒä Àƒåşÿÿë0Ôåâ p„å0ÃãáÄå  áğ½è ŸåŸåşÿÿëL   ¤   ğA-é@ á p áP áşÿÿë à×åp Ÿå  ^ã’ à  
d`Ÿå á À ã–ƒà#2 áƒ0ƒàƒ1LàÀŒâ#‚ààñå  ^ãöÿÿ8`Ÿå8€Ÿå  á–à  ãk á9e†â&k á!˜ç»ÿÿëˆçP€å@€åğ½è¯#«ªªªkNÆA    ğC-é p á\ĞMâ@ á  áŸåP áşÿÿë `Pâ  
şÿÿë  á  á  ãşÿÿë  Pã  º,€å 0”å Xá  
  áşÿÿë  á¼Ÿåşÿÿë `Pâ$  
0 á  —å ã  ”åşÿÿë 0”å Pá    áşÿÿë\Ğâğƒ½è  áşÿÿë Pâ  
0 á  á ãşÿÿë 0”å Pá  
	  áşÿÿëŞÿÿê   á —å	  áşÿÿë  Pãöÿÿ	  áşÿÿë  áşÿÿëäÿÿê  áşÿÿë  ãşÿÿë ŸåŸåşÿÿëÌ   à   L   Ğ    -é ã@-é	  ã4@ŸåĞMâ0 Ÿå 0”åşÿÿë0â  ”åå  á0åşÿÿëĞâ@½èĞâÿ/á    ä   ğO-é,ĞMâ@ áPpå á   á¾×á` á<âs0ÿæş SãA’  št3Ÿå Qá1  
00”å ”ådƒŸå1ƒà`Ÿåƒ1‚ààP“å!’çô?å  å”å ‚à0ƒâ  PãPàô?åP`†8   á  á§ıÿë  Pã»  ¾0×á,ƒâr ÿæş Rã8C’
  Š,”å ”å Qá¯  :1ƒàƒ1‚à0“å ã  
,Ğâğ½èÄ"Ÿå Sáñÿÿ0”å4 ”åpcàGr á1’çëÿÿê0”å4 ”å0càC2 á’çÇÿÿê @™å  Tã  
ğå  Qã›  
  áşÿÿë  Qã  
  á0 ádŸåTåşÿÿë  á0 áTŸåTåşÿÿë °™åT å á  áşÿë™å ÀPâ 0”  œ(2Ÿ0ƒ  —å 0å  Rã  M  
 à”å  \ãààh  
 Üå â RãB  
ğÁŸåğ1Ÿå  Pã]  
 ĞåäŸåäŸå â Bâ/oá¢" á RãÀ!Ÿå  ¼!Ÿå  0å 0ååàåé å0 á¤Ÿå
 áT åPåP`†âşÿÿë á  á9ıÿë  PãŒÿÿ¾0×á,ƒâr ÿæş Rã8C’  š8!Ÿå Sá  0”å4 ”å0càC2 á1’ç,”å ”å Qá9  :1ƒàƒ1‚à0“å ãuÿÿ
 !Ÿå 0™åŸå På  ’åPåPåT åşÿÿëkÿÿêìÀŸåì0Ÿå»ÿÿê  á  á$Àåşÿë$Àå  Pã    \ã  
 Üå¬àŸå â Bâ/oá¢" á  Rã¨ÿÿ
 Rã  ”ÀŸå”0Ÿå„ ŸåœŸå±ÿÿê  å—ÿÿêpÀŸåˆ0Ÿåh Ÿå€Ÿåªÿÿê\ÀŸåt0Ÿå›ÿÿêPÀŸåh0Ÿå  á á<àŸå¡ÿÿêX Ÿåşÿÿë  å0 á  ™åH ŸåTåşÿÿë@ Ÿåşÿÿëÿÿ  ø      À     ğ   ü          0      °    €  ğ  Ô  ¾ÀÓáğO-é4ĞMâìŒâX@å~àÿæş ^ãÈL’  šèæŸå \á,  
0P‘åà‘åÁŒàQ…àŒÁç…áàP‘åàåÀŒàp…àÀÕç  \ã  
¬¶Ÿå  á€ á P á áön‹â  á á®üÿë  Pã  
P0›å  Sã  
  áP‹â¦üÿë  Pã   0›å  Sã  
  á ‹âüÿë  Pã
  
R¿‹â [áçÿÿ4Ğâğ½èÀ‘å4à‘åÀlàLÂ áÁçÌÿÿêDa›å  Vã  
 å@å  á á  á
0 á6ÿ/á4Ğâğ½è  á šå  á.ıÿë `PâZ 
  ˜å 0–åÈŸå0‚à  á  ã(0åşÿÿë  PãÛÿÿ
¾0Ùá,ƒâr ÿæş Rã8C’  šˆ%Ÿå Sá  
0˜å ˜å1ƒààƒ1’ç!‚à  ™åp’å ˜å0ƒà  Pãp‚àšå& 
 €˜å €ˆà  áDŸåYüÿë  Pã&   á4Ÿåşÿÿë  Pã    á$ŸåOüÿë  Pãg    áŸåJüÿë  Pã  
  áüŸåEüÿë  Pãj    áğŸå@üÿë  Pã  
  áàŸå;üÿë  PãŸÿÿ  áĞŸå6üÿë  Pãšÿÿ  áÀŸå1üÿë  Pã   Vã 0šå   ã  à  
 Öå  â @âoá  á  Yãˆ¤ŸåÙ„”Ÿå  šåAôïåo à¡ àâ  Zãôï	å|ÿÿ
  Pã÷  
PÄŸåPäŸå PãL¤ŸåL”Ÿå` ` 
  	  , å  Qãè  
 Qã(ŸåŸå”Ÿå¤Ÿå     0å(0åD é0å,0å å0åpå€å å áèŸå  áşÿÿëğ0›å	 SãñŸ—á  ê,  p  0  ô  œ  œ  D  Ø  ¤  œ  ( å¤Ÿå  ãşÿÿë  Pã‘ÿÿDÿÿê0˜å4 ˜å	0càC2 á1’çkÿÿê( åô‹âÕûÿë  Pãÿÿ
8ÿÿê  á2üÿëXSŸå ° á  á.üÿë(0å  áDŸå @ á  •å0å@å@å  å€åå€åşÿÿë  áşÿÿë  áşÿÿë •å
  ã4ĞâğO½èşÿÿêøŸåşÿÿë  áüÿëàRŸå  áäŸå @ á0 á  •åèşÿÿë  áşÿÿëëÿÿê  áüÿë¬RŸå @ á  áüÿë(0å¨Ÿå  á p á  •å 0å,0åpåpåé0 á€åå€å åşÿÿë  áşÿÿë  áşÿÿëĞÿÿê  áìûÿë@RŸå @ á  áèûÿë(0å  á<Ÿå p á  •å 0å,0åpåpåé€åå€å å0 áãÿÿê  áÖûÿëèQŸå @ á  áÒûÿë, å(0åèŸå p á  •å 0åé0åpå€åå€å €å  á0 áÍÿÿê  áÀûÿëQŸå( å¤Ÿå
0 á @ á  •åèşÿÿëô ‹âûÿë  áşÿÿë•ÿÿê  á±ûÿëTQŸå( å
0 áhŸå @ á  •å@å  å é€åşÿÿë  áşÿÿë…ÿÿê  á¡ûÿëQŸå( å
0 á,Ÿå @ á  •åèßÿÿê	  á  á8üÿë Pâ  
  ™åÑşÿê  áœŸå-ûÿë  PãÓşÿ
( åèŸå  ãşÿÿë  PãÍşÿŠşÿêÔ0Ÿå(0å«şÿêÈ€ŸåÂşÿêˆŸåÀ Ÿåÿÿê| Ÿå´`Ÿå, åÿÿê  áHŸåûÿë  Pããşÿ
( å”Ÿåûÿë  PãŞşÿ
sşÿêLPŸåOÿÿêÿÿ  D   |  ¤  ”  ¼  0   È  à  Ğ  ì      ø        ü   ¸  ¨          ¬
  Ä	  Ü  l  Ô  0  Œ     ğ      ,  ğC-éĞMâP á` á p á‰úÿë @Pâ"  
0Ôå ãP„  0”å•å€“å  áiúÿëxÀŸåxàŸå0 á  á	 á  Pã      å\ Ÿåşÿÿë0Ôå0Ãã0Äå •åYúÿë0Ôå`„å0Ãã  â  á‚0ƒá0Ãã0ÄåĞâğƒ½è  á á  ádüÿë @ áêÿÿêü   d  h   -é ã@-é  ã4@ŸåĞMâ0 Ÿå 0”åşÿÿë0â  ”åå  á0åşÿÿëĞâ@½èĞâÿ/á         Pãÿ/@-é  ŸåşÿÿëL   0@-éP ádĞMâ  ãşÿÿë @Pâ  º  ã á âşÿÿë 0Pâ  
  áşÿÿë   ãdĞâ0€½è4å0å @å  ã …å0 ãşÿÿë P á  áşÿÿë uã  ïÿÿ
dĞâ0€½èğO-élĞMâ @ á å  ã<  ã, âşÿÿë  á,âşÿÿë `Pâ 
,0å0`å3 Sã0å  š?Ÿå  –å Rá  
lĞâğ½è –å0å°sÖá Sá0†à0å40å²3Öá¢ :  Wã p’È.ŸåXpå Sá00“  Wã\0å 0à00m  
\0å å Wã1ƒàƒ1‚à€“å 0àã0å0åc  
  ã
 á  á  ê8°šå0å Sá :(@šåTŸå@ˆà@†à  áşÿÿë  Pã!  <šåÀ†àPÀåTå Uã:  
 Uã  8 šå<šåå€à†à  †àdå` å‰â Yá( Šâ?  
,Pšå UãÜÿÿ(@šåØŸå@ˆà@†à  áşÿÿë  Pã  å¼Ÿåşÿÿë  á´Ÿåşÿÿë  Pã°”ÍÛÿÿ
  á Ÿåşÿÿë  Pã²”ÍÕÿÿ
  áŒŸåşÿÿë  Pã´”ÍÏÿÿ
  áxŸåşÿÿë  Pã¶”ÍÉÿÿ
  ádŸåşÿÿë  Pã¸”Í UãÄÿÿ@šå0å8Àšåà< šåƒà  Œà‘åå‰â  †àÀ†à†à YáLå< å8Àå( Šâ¿ÿÿ80å  Sã. 
0å sã  
±ƒà0å‹¡ƒà0å šå Rá På  á$ûÿë @ á  áZùÿë¸<Ÿå  Pã0  
  á0å0 ã0„åè?å˜,Ÿå 0 ãP åTå’ùÿëP å  Rã?oá£2 á 0   Sã P áÏ   Pã  /  ê0ÕåP Sã  0ÕåL Sã  0Õå  Sã    ã0 á „åP åTå ,Ÿåwùÿë PPâ  
 0ÕåG Sãêÿÿ
  áŸåşÿÿë  Pãîÿÿ
  áôŸåşÿÿë  Pãéÿÿ
  áäŸåşÿÿë  Pãäÿÿ
  áÔŸåşÿÿë  Pãßÿÿ
  áÄŸåşÿÿë  PãÚÿÿ
 0 ã0„å8`å<0å VáB  *L€å –å	pˆà	0Øç  Sã  
. Sã	  
À‡â P ã  ê. ^ã¡  
  áàÜäP…â  ^ãøÿÿ ”åùøÿë  Pãd  
H0”å  Sãa  ¾PÖá<…âs0ÿæş SãÖ  Š8Eâ´$İá RáŠ  
¶$İá Ráû  
¸¤İá Zá      áøŸå  ãşÿÿë  Pã×  
  UãŠ  
à:Ÿå  á Uá­  ÔŸå
  ãşÿÿë  PãÖ  0 á  á  á,âşÿÿë<0å`†â Sá¼ÿÿŠ åÈøÿë  Pã  
:Ÿå0“å  SãØ  
X0å4 å  SãP áÓ  
 ° ã` á á@åå
  ê0–å Sãè  
	 Sã& 
X0å°‹â [á(`†âÂ  *4å\0åpeà à1ƒà ’åƒ1à Pã€“å‘ç00åéÿÿ ’å ãæÿÿà€ƒà  áèŸå	ùÿë  Pãßÿÿ  áØ	Ÿå	 áşÿÿëÚÿÿê  á€Ÿå	  ãşÿÿë  Pã—ÿÿ¾PÖá<…âs0ÿæş Sã8E’  šH9Ÿå Uá0   80å` å0càC2 á1’ç\å4 å1ƒààƒ’ç!‚à00å°’åXŸå°€à°ƒà  á  ãşÿÿë  Pã   ‡ÿÿ
  á4Ÿå  ãşÿÿë  Pã]  
  á Ÿå  ãşÿÿë  Pãm    ãyÿÿê …â  ‡à Ÿåşÿÿë  Pã\ÿÿ
P‡à 0Õç. Sã  S 0  0ÊUÿÿêPÖå%¢ á0Jâ SãxÿÿŠ  áÀŸåşÿÿë  Pãsÿÿ
  á°Ÿåşÿÿë  Pãnÿÿ
00å²1Óá Sã¤ 
 SãÏ 
 Sã+ S  Pâ Uãbÿÿ
	0Øç. Sãß 
P á  áJâ ”åoá¡ á!úÿë „åVÿÿêDŸå
  ãşÿÿë  Pã-  
4Ÿå  áşÿÿë,Ÿå  Pã0 0„  áşÿÿë  Pã0 0„Dÿÿê7Ÿå Uá0   80å` å0càC2 á1’ç°$İá Rá   &ÿÿ
²$İá Ráÿÿ  ã!ÿÿê°‡â  áøÿëÀ–å  Pã. 
  ãÀ€å €åÿÿê˜Ÿå á ”åşÿÿë#ÿÿê
  á
 ‡â áxıÿëÌÿÿê  ápŸå  ãşÿÿë  Pã3   ãÿÿê@åTåP åL'Ÿå 0 ã*øÿë Pâ 
00å å0càP åşÿÿë å,„â  ãşÿÿë0 å,åşÿÿë0åä?å  Sãİıÿ
  ã ”åôŸåÃùÿë „ålĞâğ½è\ å4Àå0@å!‚à€œç‚!ŒàÀŒà ’åˆŸå ‚â€‚à€„à  ápœå œå+øÿë  Pãÿÿp„à
@‡à Wáÿÿ* ‡â  ê €å	  á,â  âMûÿëp‡â Táøşÿš À—å80å Àå —å$ å"$ á—å2ƒà(å¾ Óá,‚âr ÿæş Rãîÿÿš
 Wáçÿÿ$Ÿå á0åÀåşÿÿëÀå0å  PãŞÿÿ åğ/å  RãŒÀ ˆ%ŸğÏ×ÿÿê\ å4Àå0€å!‚à œç‚!Œà@Œà ’å0”å ‚â p‚àpˆàxŸå  á ”å0åê÷ÿë  PãÅşÿ0å
 ˆà€Šà ZáÀşÿ*0Šâ0å  ê( ^ãF  
 ^ã.  
8 å "‚à¾Òáâqÿæş Qã  šå Zá¸  
0 á på	  á,â  âûúÿë Šâ
 Xá¦şÿš0å 0šå   ã²áÑá 0å šå ^ã( å$ å" áİÿÿà”å4Àår ïæáà RãáŒààåàƒàèÿÿ
 Rã‘ç”  
 Rã  
 Rã(Ğÿÿêà”å4Àår ïæáà RãáŒààåàƒàv  
 RãÅÿÿ°!Ñá‘ç Rãâ(å8 å¿ÿÿà(å "‚à¼ÿÿêr ïæ Bâ2 RãñŸ—Åÿÿê%  ø$  D#  D#  D#  D#  D#  D#  D#  %  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  %  %  %  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  D#  %  8 å "‚à( å€ÿÿê ”åà”åànà8 åàà "‚à4  ã!à(åvÿÿêÔ2Ÿåì?å  Sã  
03Ÿå @“åşÿÿë  åşÿÿë åŸå 0 á  áşÿÿëlĞâğ½è
  á  á áÀååøÿëÀå Ğå ‚ã Àå¾PÖáÅşÿê0åà?å  Sãèşÿ
 åÀöÿë  Pãäşÿßşÿê‘ç8 å(å "‚àMÿÿê  á Ÿå  ãşÿÿë  Pã    Ëıÿêqÿæ(å@ÿÿê?#Áã! á( å<ÿÿê\Ÿå á å0åşÿÿë0å å  Pã=ÿÿåğå  Qãƒ0 ÀŸğ?6ÿÿê  á(Ÿå	  ãşÿÿë  Pã¿ıÿ
  áŸå	  ãşÿÿë  Pã¹ıÿ
  á Ÿå  ãşÿÿë  Pã³ıÿ
  áìŸå  ãşÿÿë  Pã­ıÿ
  áØŸå  ãşÿÿë  Pã§ıÿ
  áÄŸå  ãşÿÿë  Pã¡ıÿ
@şÿê åröÿë  Pã^ıÿ ŸååşÿÿëZıÿê  áŸå
  ãşÿÿë  Pã’ıÿ
  á|Ÿå
  ãşÿÿë  PãŒıÿ
  áTŸå  ãşÿÿë  Pã†ıÿ
  á@Ÿå  ãşÿÿë  Pã şÿıÿê  áşÿÿë_0 ã 0Àå P áşÿÿë Õå 0å1“ç0Åå Öå*¢ áşÿê å0åü Ÿåşÿÿëåô Ÿåşÿÿë åşÿÿë  ãşÿÿëåÜ Ÿåşÿÿëå  áĞ Ÿå40 ãşÿÿëELFÿÿ  Ô  @  X  d  x  ˆ     ø  ø  \  d  €         òÿ        4  ø  °  ¼  Ğ  È  @  P  È  Ô  à  $  à  ğ  ¸  ¬      ¨  ø  h  t  €  Œ  ˜  ¤     °  ¼  ¼  Ì  ¸     øO-é @å Tá'  *P„âp á   á Ÿå `ŸåPà € ã° ã  êşÿÿë0Uås¯æq¿æ á  å± ’á
ã  
 Sã T€ˆâ ‰â@ 3 @ #  * Xá 0Éå  Š @šå á ° ã@„â Wá @ŠåP…â  š  [ãâÿÿ0Uåéÿÿê   ãø½è @Éå  Ÿåø½è  ÿ  ğO-éĞMâ@ á  ãâåşÿÿë 0Pâ 0ån  
@âÌ±Ÿå1 á0å â å åşÿÿë  Pâa  
	 ãşÿÿë pPâb  
P‡â Çå  á	 ãşÿÿë `Pâ[  
@†â Æå  á	 ãşÿÿë  PãE  
€â ÀåB  
  á	 ãşÿÿë  Pã À
  áâ  ãşÿÿë0×å  Sã   áD  
0Öå  SãA  
0å 0Óå  Sã=  øoå  Vã    ê `–å  Vã  
 –å áşÿÿë  Pã÷ÿÿ  ámõÿë á   á  áûÿëå   á  á0Òå0Ãã0á0ƒã0Âå`õÿë @ á  á†õÿë  Pã  
0 ã €å0€å¬ÿÿê  áiõÿë  Pã0   áè?+÷ÿë0 ã ` á0€åÜÿÿê € ã¿ÿÿê  á á  ás÷ÿë0Ğå0ƒã0Àåæÿÿê  ååşÿÿëĞâğ½è  ååşÿÿë Ÿåşÿÿëø  à  şÿÿêp@-éP á é` á @ ábà Qá  º 0å ƒà á  áşÿÿë0”åPƒàP„åp€½è}…âƒà€å  åşÿÿë ”å 0 á  „åîÿÿê -é} ã@-éßMâ‚Ïâ @ á0 á"å â Àåşÿÿëâ   á  áşÿÿëßâ@½èĞâÿ/á      ğO-é 0 ãÚMâ‰Ÿå™Ÿå,ĞMâ` á @ áP á  á° áp ã0å0å0å0å 0å$0å  á áÌ(Ÿåşÿÿë pãX  
I @â. Pã ñŸ—R  ê¬  ¼  ¼  ¼  ¼  ¼  ¼  ¼  ¼  ¼     ˜  ¼  ¼  ¼  ¼  ¼  ¼  ¼  ¼  ¼  ¼  ¼  ¼    ¼  ¼  ¼  h  ¼  ¼  ¼  \  ¼  ¼  ¼  T  L  @  ¼  ¼  ¼  4  ¼  ¼  ¼  ,  (pˆåÄÿÿêì7Ÿå°ƒåÁÿÿê 0™å0å¾ÿÿêìå¼ÿÿêäåºÿÿê 0™å0å·ÿÿê  ã$pˆåşÿÿë  Pãä 
 0™å `€å0€å ` á­ÿÿêàå«ÿÿê  ™å©ÿÿê€7Ÿå °ƒå¦ÿÿê 0™å$pˆå0å¢ÿÿê  ãşÿÿë0åp á  Sã  
  á ãşÿÿë0å  Sã  
  á  ãşÿÿë  Vã  
 —å  ãşÿÿë `—å  áşÿÿë pVâ÷ÿÿgŸå 0–å Tá  Ú ƒâ•ç  †åşÿÿë 0–å TáøÿÿÊ  Zã$  
 0ÚåĞfŸå- Sã P–å‰ 

  áÀŸåşÿÿë PPâ    ê( âşÿÿë @Pâ  
(0â Dâ  ƒà”Ÿåşÿÿë  Pã(0@ƒ  D( âşÿÿë( â ã  áşÿÿë  Pãêÿÿ 0–å Sá  
  áşÿÿë,¶Ÿåø_å  Uã@–Ÿ@†Ÿ( 
0•å  Sãj  
 P•å  UãùÿÿøOå  Tã 
`â0†â0å  ê @”å  Tã 
0”å  Sãùÿÿ  áìŸå 0åşÿÿë  áàŸåşÿÿë  áØŸåşÿÿë  á¸Ÿåşÿÿë  áÄŸåşÿÿë  á Ÿåşÿÿë  á°Ÿåşÿÿë  á¨Ÿåşÿÿë  á Ÿåşÿÿë0”å  Sã- 0”å  Sã  
  á€Ÿåşÿÿë  áxŸåşÿÿë  ápŸåşÿÿë$0›å  Sã 
`Ÿå”å  ãşÿÿë  Pã    áHŸåşÿÿëp”å  Wã]  
à¤Ÿå  ã
  ê å Tá  
å0å ‡å‡å0‡å p—å  WãP  
€‡â  áşÿÿë  Pãïÿÿè?å  Sãôÿÿ
0×å ãñÿÿ(0šå á  SãÈŸå ”å¹  
şÿÿëéÿÿê@•å  Tã  ÿÿê
  áşÿÿë0–å  Pã	     Sã#  
 Sã!  
 @”å  Tãƒÿÿ
 „âşÿÿë `Pâøÿÿ
0–å Uáõÿÿ
 •å/ ã
  áşÿÿë0•å  Pã €  Sãp†áÿÿ
  áşÿÿëp†â0–å  Pã  
 Sãİ  
 SãÕ  
 SãÎ  
Ä#ŸåÙÿÿê
 á0 áğŸåşÿÿëØÿÿê SãÙ  
 SãÕ  
 SãÑ  
”#ŸåÌÿÿê áä?å  SãO  øå	P…á  Wã  
 —åşÿÿë ‡å p—å  Wãùÿÿ  áHŸåşÿÿë  á€Ÿåşÿÿë  áxŸåşÿÿë  ápŸåşÿÿë  áhŸåşÿÿëp”å  Wã€    
—å  Qã  
0‘å  Sã   ‘åå
  á/ ãşÿÿë$3ŸåĞ"Ÿå Ÿå  Pã €  Xã    á
0 áşÿÿë € ã p—å  Wãæÿÿ  áğŸåşÿÿë  á áşÿÿë,0Ôå  Sã  
  ápŸåşÿÿë  áÄŸå, „âşÿÿë ”å( â´Ÿåşÿÿë  áå( âşÿÿëÿÿê  á0Ÿåşÿÿë  áŒŸåşÿÿë  á`Ÿåşÿÿë  áxŸåşÿÿëp”å  Wã    êdŸå‡â ”åşÿÿë p—å  Wã  
0—å  Sãùÿÿ
0—å  Sãòÿÿ
  á0Ÿå —å0‡âşÿÿëğÿÿê  áÔŸåşÿÿëˆÿÿêşÿÿë ã.ÿÿê P ã0å  Sã#  
( â  ã  ãşÿÿëäaŸåäŸåz†â@¶å  Tã  
$0›å  Sã  
0Ôå ã
  0”å ”å( â0“å¬Ÿå 0åÀ”å0„âŒÁ˜çÀåşÿÿë @”å  Tãëÿÿ Váæÿÿ( â å€âşÿÿëôå  Qã  
Ğ0Ÿå 0“å  Sã  
  áÚâ,Ğâğ½è  á@Ÿåşÿÿëàşÿê  á4ŸåşÿÿëÍşÿê0Úå  Sã‡şÿ
qşÿêŸåşÿÿëìÿÿêˆ Ÿå
 á0 áŸåşÿÿët Ÿå Ÿå
 á0 áşÿÿëûşÿê\ Ÿå
 á0 áä ŸåşÿÿëL ŸåîÿÿêD Ÿåñÿÿê< Ÿåõÿÿê
 áÄ ŸåşÿÿëÀ ŸåÀŸåşÿÿëø      (              Ì   d  ü   d  |  ˜  ¸  Ø    ,  h  œ  Ü  ø    (  H  D    ˜  8  `    p  l  x  ˜  d     Ì  è  üÿÿÿ       ü  „  ¤  h  ü  ¬  @  L     |      Œ     ¤     ¸     Ô     ğ      h  p  Ü  ä      4  <  L  X                                                                  h  p                                                                                                                                                              |  „    ˜     ¨  °  ¼                                                      È  Ğ                                                                          p                                                                                                                                                                 |  „    ˜     ¨  °  ¼                                                      È  Ğ                                                                          h                                                                                                                                                                 „    ˜     ¨  °  ¼                                                          4  <  L  X                                                                  Ü  ä                                                                                                                                                             |  „    ˜     ¨  °  ¼                                                      È  Ğ                                                                          Ü  ä                                                                                                                                                             |  „    ˜     ¨  °  ¼                                                      p                                                                              h                                                                                                                                                                 |  „    ˜     ¨  °  ¼                                                      ä                                                                              Ü                                                                                                                                                                 |  „    ˜     ¨  °  ¼                                                      h  p                                                                          Ü  ä                                                                                                                                                             |  „    ˜     ¨  °  ¼                                                      Ü  ä                                                                          h  p                                                                                                                                                             |  „    ˜     ¨  °  ¼                                                      ğ      ,  @  T  l                                                      h                                                                                                                                                                                                                                                     €                                                                              h  Ü                                                                                                                                                             |  „    ˜     ¨  °  ¼                                                      ¬                                                                              Œ                                                                              ”  ¤  ´  À  4  <  L  X  Ğ  Ü  è  ø                             	                                                                                       h  t  „  ”         È  Ğ      \      4  D  P      h  p      ”  ¤  ´  À  4  <  L  X  Ğ  Ü  è  ø             $      °  ¼  Ä  Ğ  Ü  ğ           (  0  8  D  L  X  p      vmlinux vmlinux.o   ,   rodata  const   data    data        axtd    FATAL:  modpost: Memory allocation failure: %s.
    malloc(sizeof(*mod))    strdup(modname) .o  malloc(sizeof(*s) + strlen(name) + 1)   r   malloc(b->pos)  w   WARNING:    (unknown)       variable    ()  function    (unknown reference) %s(%s+0x%lx): Section mismatch in reference from the %s %s%s to the %s %s:%s%s
 section_index is outside elf->num_sections!
    The relocation at %s+0x%lx references
section "%s" which is not in the list of
authorized sections.  If you're adding a new section
and/or if this reference is valid, add "%s" to the
list of authorized sections to jump to on fault.
This can be achieved by adding "%s" to 
OTHER_TEXT_SECTIONS in scripts/mod/modpost.c.
  The relocation at %s+0x%lx references
section "%s" which is black-listed.
Something is seriously wrong and should be fixed.
You might get more information about where this is
coming from by using scripts/check_extable.sh %s
    extable_entry size hasn't been discovered!
 The relocation at %s+0x%lx references
section "%s" which is not executable, IOW
it is not possible for the kernel to fault
at that address.  Something is seriously wrong
and should be fixed.
 The relocation at %s+0x%lx references
section "%s" which is not executable, IOW
the kernel will fault if it ever tries to
jump to it.  Something is seriously wrong
and should be fixed.
   reference___initcall    .init.text  __param __param_ops_    %s(%s+0x%llx): Section mismatch in reference from the %s %s%s to the %s %s:%s%s
    The function %s%s() references
the %s %s%s%s.
This is often because %s lacks a %s
annotation or the annotation of %s is wrong.
 The variable %s references
the %s %s%s%s
If the reference is valid then annotate the
variable with __init* or __refdata (see linux/init.h) or name the variable:
   The function %s() references a %s in an exit section.
Often the %s %s%s has valid usage outside the exit section
and the fix is to remove the %sannotation of %s.
  The variable %s references
the %s %s%s%s
If the reference is valid then annotate the
variable with __exit* (see linux/init.h) or name the variable:
    The %s %s%s%s references
a %s %s%s%s.
If %s is only used by %s then
annotate %s with a matching annotation.
    The %s %s%s%s references
a %s %s%s%s.
This is often seen when error handling in the init function
uses functionality in the exit path.
The fix is often to remove the %sannotation of
%s%s so it may be used outside an exit section.
  The %s %s%s%s references
a %s %s%s%s.
This is often seen when error handling in the exit function
uses functionality in the init path.
The fix is often to remove the %sannotation of
%s%s so it may be used outside an init section.
  The symbol %s is exported and annotated %s
Fix this by removing the %sannotation of %s or drop the export.
 There's a special handler for this mismatch type, we should never get here. .ko %s: '%s' exported twice. Previous export was in %s%s
   ERROR:  %s: %s (ignored)
   section header offset=%lu in file '%s' is bigger than filesize=%lu
 %s is truncated. sechdrs[i].sh_offset=%lu > sizeof(*hrd)=%zu
   %s has NOBITS .modinfo
 __ksymtab   __ksymtab_unused    __ksymtab_gpl   __ksymtab_unused_gpl    __ksymtab_gpl_future    %s has no symtab?
  %s: SYMTAB_SHNDX has bad sh_link: %u!=%u
   license modpost: missing MODULE_LICENSE() in %s
see include/linux/module.h for more information
    GPL v2  GPL and additional rights   Dual BSD/GPL    Dual MIT/GPL    Dual MPL/GPL    ___ksymtab+ ___ksymtab_unused+  ___ksymtab_gpl+ ___ksymtab_unused_gpl+  ___ksymtab_gpl_future+  __crc_  __gnu_lto_  "%s" [%s] is COMMON symbol
 __this_module   _GLOBAL_OFFSET_TABLE_   _restgpr_   _savegpr_   _rest32gpr_ _save32gpr_ _restvr_    _savevr_    _restgpr0_  _savegpr0_  __ksymtab_  init_module cleanup_module  version %s (%s): unexpected non-allocatable section.
Did you forget to use "ax"/"aw" in a .S file?
Note that for example <linux/init.h> contains
section definitions for use in .S files.

 __ex_table  module_layout   0123456789  .modinfo    parse error in symbol dump file
    ,   malloc(sizeof(*extsym_iter))    i:I:e:mnsST:o:awM:K:    Can't open filenames file %s: %m    
   modpost: GPL-incompatible module %s%s uses GPL-only symbol '%s'
    modpost: GPL-incompatible module %s%s uses GPL-only symbol marked UNUSED '%s'
  modpost: GPL-incompatible module %s%s uses future GPL-only symbol '%s'
 modpost: module %s%s uses symbol '%s' marked UNUSED
    #include <linux/module.h>
  #include <linux/vermagic.h>
    #include <linux/compiler.h>
    MODULE_INFO(vermagic, VERMAGIC_STRING);
    __visible struct module __this_module
  __attribute__((section(".gnu.linkonce.this_module"))) = {
  	.name = KBUILD_MODNAME,
   	.init = init_module,
  #ifdef CONFIG_MODULE_UNLOAD
	.exit = cleanup_module,
#endif
    	.arch = MODULE_ARCH_INIT,
 };
 
MODULE_INFO(intree, "Y");
 drivers/staging 
MODULE_INFO(staging, "Y");
    "%s" [%s.ko] undefined!
    static const struct modversion_info ____versions[]
 __used
 __attribute__((section("__versions"))) = {
 "%s" [%s.ko] has no CRC!
   	{ %#8x, __VMLINUX_SYMBOL_STR(%s) },
   static const char __module_depends[]
   __attribute__((section(".modinfo"))) =
 "depends=   ";
 %s%s    MODULE_INFO(srcversion, "%s");
 %s.mod.c    modpost: Found %d section mismatch(es).
To see full details build your kernel with:
'make CONFIG_DEBUG_SECTION_MISMATCH=y'
 0x%08x	%s	%s	%s
    .text   .text.unlikely  .sched.text .kprobes.text   .init.* .meminit.*  *driver *_template  *_timer *_sht   *_ops   *_probe *_probe_one *_console   .data   .data.rel   .exit.* .memexit.*  .pci_fixup_early    .pci_fixup_header   .pci_fixup_final    .pci_fixup_enable   .pci_fixup_resume   .pci_fixup_resume_early .pci_fixup_suspend  __ksymtab*  .altinstr_replacement   .meminit.text   .exit.text  .memexit.text   .ref.text   .head.text  .spinlock.text  .fixup  .entry.text .exception.text .text.* *.constprop.*   __init_begin    _sinittext  _einittext  .head.text* .init.setup .init.rodata    .meminit.rodata .init.data  .meminit.data   .comment*   .debug* .cranges    .zdebug*    .GCC-command-line   .GCC.command.line   .mdebug*    .pdr    .stab*  .note*  .got*   .toc*   .xt.prop    .xt.lit .arcextmap* .gnu.linkonce.arcext*   .gnu.lto*   EXPORT_SYMBOL   EXPORT_UNUSED_SYMBOL    EXPORT_SYMBOL_GPL   EXPORT_UNUSED_SYMBOL_GPL    EXPORT_SYMBOL_GPL_FUTURE     GCC: (Raspbian 4.9.2-10) 4.9.2 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .rel.text .data .bss .rel.text.startup .rel.rodata .rodata.str1.4 .comment .note.GNU-stack .ARM.attributes                              ñÿ                                                               h        h   P     $   ´             ¸          '   ¸   T     $                        2     Ä     $   À            Ğ         >   Ğ  ¨     O   x  (    U      `     $   ø                      h      ,    $               ,         w   ,  \    $   €            ˆ         ˆ   ˆ       $   „            ˆ         $   Ì            Ô         Ÿ   Ô  ¸     $   x            Œ         ª   Œ       $   	            	         ·   	        $   ¬	            ¼	         Â   ¼	  0    $   Ü
            ì
         $   8            @         Û   @  ô    $   ğ            4         ô   4  ˜    $   ¸            à         $   H            Ì           Ì  Ğ     $               œ         $   è            ğ         $                          Œ  ,    $   ,$            ø$         $   è'            ¸(         $   |)            „)         )  „)      $   „+            Œ+                                     $   p             ,         $   	                       $              3      0     ?  0        R  D   `    _  ¤       r  ¼       €  È         Ğ         à       «  ì  @     ¹  ,       Ç  4  H     $              Ú           ï                       	 $             	 $                                            .         A         V         c         o         |         †          –                                      
               ¦             ­             µ             ¼             Ä             Ë             Õ             Ü             á             ç             î             ô             û                          	               ˆ  L                               $             +             4             ;             A             H             Q             X             ^             e  ì
  T     j             {             ƒ  œ  T     Š  ğ       ”    „                  £             ©             ®             Á             È             ß             ï             ö                                       $  ¸(  Ì     2             @             H  Œ+       U  +  h     _             g             o  ø+  L     z             „      à	    ‰                          –             ¦             ®             µ             ¼              modpost.c $a next_string export_no $d is_vmlinux find_symbol get_next_modinfo match print_section_list sec2annotation find_elf_symbol2 find_elf_symbol.part.4 new_module alloc_symbol new_symbol write_if_changed.isra.18 extable_mismatch_handler check_section_mismatch sym_add_exported read_symbols read_dump export_list init_exit_sections sectioncheck init_data_sections data_sections head_sections linker_symbols init_sections text_sections optim_symbols section_white_list sec_mismatch_verbose vmlinux_section_warnings symbolhash modules sec_mismatch_count extable_entry_size ignore_missing_files have_vmlinux modversions all_versions line.7606 external_module warn_unresolved strcmp strrchr strlen strncmp memcmp __strndup strstr free fputs fwrite fputc stderr malloc calloc strchr fatal vfprintf exit memset __strdup memcpy fopen fileno __fxstat fclose fread perror warn __aeabi_uidivmod fprintf merror do_nofail grab_file open close mmap handle_moddevtable strspn maybe_frob_rcs_version get_src_version munmap __errno_location strerror __ctype_toupper_loc get_next_line __ctype_b_loc strtoul release_file buf_write strncpy realloc buf_printf vsnprintf main getopt fgets add_moddevtable sprintf optarg optind stdin   œ   m  ´   L  Ä   n  Ø   m  ì   m    \    \  ,  o  ¬  m  Ì    ì  o  0  p    o  ¼  m  ğ  o  ü  o  8  q  \  p  t  r  „  s    t  Ä  u  ä  v  ô  w  ø  x  ü  \    y  |  s  ¸  z  Ü  s    L    \    \     \  $  \  (  \  ¸  m  H  {  „  \  ¨  v  À  }  È  ~  Ì  x  Ğ  \  à  y  ô    ü  €    o  $  m  h  |  t  |  x  \  |    €  \  „  \  ˆ  \  œ  o  ¨  y  ä    	  |  	  \  	  \  ,	  o  ¸	    Ø	  ‚  ä	  ƒ  ô	  „  
  …   
  ‚  <
  v  P
  …  `
  y  x
  †  Œ
  t   
  q  °
  t  ¸
  …  Ä
  ‡  Ì
  ~  Ø
  |  Ü
  \  à
  \  ä
  \  è
  \    v  $  }  8  x  <  \  |  ‰  ˜  |  ¬  |  €  ˆ    Š  Ì  |  ä  |  ì  |  ô    ø    ü  \     \    \    \    \    \    \    \    x     \  $  \  (  \  ,  \  0  \  ”  p     m  ¤  ˆ  ¸    ¼    À    Ä    È    Ì    Ğ    Ô    Ø    Ü    ì  p  t  Š  |  t  „  t  ˜  w     |  È  Š  Ğ  t  ,  Š  4  t  <  t    Š  (  t  `  Š  h  t  Ô  p  L  L  P  \  T  L  X  \  \  L  `  L  d  L  h  L  l  L  p  L  t    x    |  \  €  \  „  \  ˆ  \  Œ  \    \  ”  x  ˜  \  œ  \     \  ¤  \  ¨  \  ¬  \  °  \  ´  \  ¸  \  ¼  \  À  \  Ä  \  È  L  8  ˆ    \  ”  \  ˜  \  ¼  v  Ô  }  è  x  ì  \     |    \      0  „  @    h    t    ¨    ´    ¤  m     m  4  |  @  m  X  m  p  m  ˆ  m     m    m     m  4  m  H  m  \  m  0  p  \  p  x  ‘  d  ˆ  x  p  ô  p    p  (  p  H  ’  Œ  m     m     p  (   m  @   m  Ğ   ˆ  ø   p  <!  “  L!  ”  X!  •  X"  m  ,$    0$    4$    8$    <$    @$    D$    H$    L$    P$    T$    X$    \$    `$    d$    h$    l$    p$    t$    x$    |$    €$    „$    ˆ$    Œ$    $    ”$    ˜$    œ$     $    ¤$    ¨$    ¬$    °$    ´$    ¸$    ¼$    À$    Ä$    È$    Ì$    Ğ$    Ô$    Ø$    Ü$    à$    ä$    è$    ì$    ğ$    ô$    H%  –  P%  —  d%  Š  à%  p   &  m  \&  p  t&  p  Œ&  p  ¤&  p  ¼&  p  Ô&  p  ü&  ˆ  '  p  ('  p  @'  p  X'  p  l'  €  |'  ˜  ¨'  |  ´'  |  ¼'  ‡  Ä'  ~  Ğ'  |  ä'  |  ğ'  \  ô'  \  ø'  \  ü'  \   (  \  (  \  (  \  (    (  \  (  \  (  \  (  \   (  \  $(  \  ((  \  0(  \  4(    8(  L  <(  \  @(  \  D(  \  H(  \  L(  \  P(  \  T(  \  X(  \  \(  \  `(  \  d(  \  h(  \  l(  \  p(  \  t(  \  x(  x  |(  \  €(  \  „(  \  ˆ(  \  Œ(  \  (  \  ”(  \  ˜(  \  œ(  \   (  \  ¤(  \  ¨(  \  ¬(  \  °(  \  ´(  \  ì(  š  |)    œ)    È)  ™  Ø)  {  ô)  {  *  {  0*  {  H*  ›  œ*  m  d+  •  x+  •  €+  |  „+    ˆ+  \  Œ+  •  À+    ä+  Ÿ   ,  ¡  0,    T   £  p   G  t   G  x   G  |   G  €   G  „   G  ˆ   G  Œ   G     G  ”   G  ˜   G  œ   G      G  ¤   G  ¨   G  ¬   G  °   G  ´   G  ¸   G  ¼   G  À   G  Ä   G  È   G  Ì   G  Ğ   G  Ô   G  Ø   G  Ü   G  à   G  ä   G  è   G  ì   G  ğ   G  ô   G  ø   G  ü   G     G    G    G    G    G    G    G    G     G  $  G  (  G  p  y  À  ~  Ü  D  ô  D    D    t  <  =  p  ‚  „  o     m  ¸  =  È  ¤  ä  …  X     d     p     |     ˆ     ”           ¬     ¸     Ü     è     ô       p  $     t    °  ˆ  Ì  
       $  n  D  
  „  ˆ  Ğ  
  ì     ø                    \  n  „           ¬  ¥  Ä     Ô     ä  ¦  ô  )                 (     H  ˆ  €          ˜  ‹  À         @  )  x     ˆ     ¤  ˆ  ¼  |  Ğ  ˆ  è  |  	  |  	  |  	     	  §  $	  \  (	    ,	  ¨  0	  ©  4	  \  8	  \  <	  \  @	  \  D	  \  H	  \  L	  \  P	  \  T	  \  X	  \  \	  \  `	  \  d	  \  h	  \  l	  \  p	  \  t	  \  x	  \  |	  \  €	  \  „	  \  ˆ	  \  Œ	  \  	  \  ”	  \  ˜	  \  œ	  \   	  \  ¤	  \  ¨	  \  ¬	  \  °	    ´	  L  ¸	  \  ¼	  \  À	  \  Ä	  \  È	  \  Ì	  \  Ğ	  \  Ô	  \  Ø	  \  Ü	  \      \     \     \     \      \  (   \  0   \  4   \  8   \  <   \  D   \  H   \  L   \  P   \  ”   \  ˜   \  8  \  <  \  @  \  D  \  H  \  L  \  P  \  T  \  Œ  \    \  Ü  \  €  \  „  \  ˆ  \  Œ  \    \  ”  \  ˜  \  œ  \  Ô  \  Ø  \  $  \  È  \  Ì  \  Ğ  \  Ô  \  Ø  \  Ü  \  à  \    \     \  $  \  (  \  l  \  p  \    \    \    \    \     \  $  \  (  \  ,  \  d  \  h  \  ´  \  ¸  \  X  \  \  \  `  \  d  \  h  \  l  \  p  \  t  \  ¬  \  ü  \     \  ¤  \  ¨  \  ¬  \  °  \  ´  \  ¸  \  ¼  \  ô  \  D  \  è  \  ì  \  ğ  \  ô  \  ø  \  ü  \   	  \  	  \  <	  \  @	  \  Œ	  \  	  \  0
  \  4
  \  8
  \  <
  \  @
  \  D
  \  H
  \  L
  \  „
  \  ˆ
  \  Ô
  \  Ø
  \  x  \  |  \  €  \  „  \  ˆ  \  Œ  \    \  ”  \  Ì  \  Ğ  \  Ô  \  Ø  \  Ü  \  à  \  ä  \    \    \  d  \  h  \    \    \    \    \    \    \     \  $  \  \  \  ¬  \  ü  \     \    \    \    \    \    \    \    \     \  $  \  (  \  ,  \  0  \  4  \     .  ¤  \  ¨  \  ¬  \  °  \  ´  \  ¼  \  À  \  È  \  Ğ  \  Ô  \  Ø  \  à  \  ä  \  ì  \  ğ  \  ô  \  ø  \  ü  \     \    \    \    \    \    \    \    \     \  $  \  ,  \  4  \  8  \  <  \  @  \  D  \  H  \  L  \  P  \  T  \  X  \  \  \  `  \  d  \  h  \  l  \  p  \  t  \                                                       4   D,                    	   @       p  x              %             x,                    +             €,  $                  4             €,  à	                 0   	   @       €{                 F             `6  |                 B   	   @        €  0              N      2       ÜF  ğ                ]      0       Ì_                    f              ì_                     v     p        ì_  1                                `  †                                ¤`   
     m         	              Dk  Â                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ELF          (    H 4   ü    4    (     pt  t t                4   4  4                 4  4 4                          €  €           €  € € L  `          Œ  Œ Œ è   è            P  P P D   D         Qåtd                          /lib/ld-linux-armhf.so.3             GNU                        GNU ,:S”)İK#…bŞË2o®°n,              Ò@H„Û  €À$D¦                       	                                 »•“|‹s}í?~–|íŞ“.N=ö?ùÿ¼ûn9ò‹!Ï	ıgII"{œ|fUaÍ?¯ÿì„¹+kêvş                ‡               f                            *                            6              u              m              =              X   Ğ      C              J              %              0   Ø                                  n              _               libc.so.6 exit fopen strncmp perror puts abort stdin strtol fgets fclose __ctype_b_loc stderr fwrite strchr fprintf __libc_start_main __gmon_start__ GLIBC_2.4                                    ii   –       À   Ğ 
  Ø   €   „   ˆ   Œ 	     ”   ˜   œ       ¤   ¨   ¬   °   ´   ¸   ¼   @-é£ ë€½èà-åàŸåààğ¾ål  ÆâÊŒâlı¼å ÆâÊŒâdı¼å ÆâÊŒâ\ı¼å ÆâÊŒâTı¼å ÆâÊŒâLı¼å ÆâÊŒâDı¼å ÆâÊŒâ<ı¼å ÆâÊŒâ4ı¼å ÆâÊŒâ,ı¼å ÆâÊŒâ$ı¼å ÆâÊŒâı¼å ÆâÊŒâı¼å ÆâÊŒâı¼å ÆâÊŒâı¼å ÆâÊŒâüü¼å ÆâÊŒâôü¼åğO-éØMâ$ĞMâ @â Pãå Š0å“å 0Ùå- SãT  0Ùå  SãQ  Ø4ŸåØ”Ÿå p“åÔDŸå   ã[„â0 á £å Sáüÿÿ  â ` ã
  á ã  á¹ÿÿë €Pâ  

  á
 ãÌÿÿë  Pã 
åB  
 `Àå  Úå 
å
  á  Rã	 R   ğå  Rã	 Rûÿÿ
 
å  Rã# R     âÿÿ
â•ÿÿë é Rá ° á  Ó  ê ‚â 
å Òå  Qã	 Qùÿÿ
- Qã(  
ÿ [ã  šÏ  ê  á‘ ë âZ ë Pâùÿÿª0å  ê0ƒâ0
å  Óå  Rã	 Rùÿÿ
# Rã  R¾ÿÿ
´#Ÿå´Ÿå  ’å	  á“ÿÿë¸ÿÿê	  á Ÿåqÿÿë pPâ«ÿÿ	  ásÿÿëB  ãƒÿÿëx3Ÿå€Ÿå	  á  “å„ÿÿë·ÿÿêà‚â  á   ãâà
åYÿÿë å ` á å Pá—  
ÿ [ã 
å›  Š  VãËÿÿ
 [áÿ VÓ  Ú  ê €â 
å  Ğå  Rã	 Rùÿÿ
Ÿå  ãlÿÿë  Pã   [á  Ê  á á°‹âH ë Váùÿÿª0å0ƒâ0
å¸ÿÿê â ë å Òå  Qã	 Q € á   ‚â 
å Òå  Qã	 Qùÿÿ
- Qã~   ‚â â 
åù  ë0á‚  J  hàkà Rá‡   [á€kĞ—ÿÿÊ  á‹à°‹â! ë Váùÿÿªÿÿê  á5ÿÿë` á0´å Uá`†àûÿÿ0åBŸå, ã“åŸåÿÿë ”åŸåÿÿëp áP á @ ã0â Sã@„âìŸìŸúşÿëÜŸåµå÷şÿëÿ TãôÿÿÔŸåÿÿëĞŸå áğşÿë  Vã%  Ú   ã¼QŸåœ‘Ÿå
@ á
° á€Fâ1—ç [á  ±°‹²  º1‰à ³å@„â  RãûÿÿÚ° ã   ã4dà0ƒàtŸåƒ0 á³•áÖşÿë
 Xá2  
Ê? á£. á0Šà0â0bà Sã0Ÿ0ŸËşÿë Šâ Záßÿÿ   ãáşÿëğ0Ÿå  ‘å Ÿå  “åâşÿë@  ãÚşÿëÔ0Ÿå
  áŸå  “åÛşÿëA  ãÓşÿë¸Ÿå	  á0 á  ‘åèŸåÓşÿëA  ãËşÿë˜Ÿå	  á0 á  ‘åÌŸåËşÿëA  ãÃşÿëx0Ÿå	  á¸Ÿå  “åÄşÿëA  ã¼şÿë„ Ÿå®şÿëÒÿÿêPŸå `å	  á  ‘å0 áˆŸå¸şÿëA  ã°şÿë,Ÿåè`å	  á  ‘å0 ádŸå®şÿëA  ã¦şÿëØ ¨ Ü Ğ x ô ø | à ˜ < d h @ D à l °  ( \ „ Ø    ° ã à ãä  á -å -åÀŸåÀ-å Ÿå0Ÿåzşÿë‘şÿël Ì  0Ÿå Ÿå0à “ç  Rãÿ/rşÿêà L   0Ÿå Ÿå0`à Sãÿ/‘0Ÿå  Sãÿ/ÿ/áÏ Ì     $Ÿå$ Ÿå`àA á¡àÁ°áÿ/0Ÿå  Sãÿ/ÿ/áÌ Ì     @-é@Ÿå 0Ôå  Sã€½ßÿÿë0 ã 0Äå€½èÜ @-é$ Ÿå 0å  Sã  @½èàÿÿê0Ÿå  Sãúÿÿ
3ÿ/áøÿÿêˆ     8@-é @å 0Ôå  Sã	 S  0ôå  Sã	 Sûÿÿ
U Sã&  0Ôå+ Sã#   P á0şÿë Ôå‚  á 0å² “á
ã  
 Ôå‚  á² “á
ã  
 Ôå‚  á² “á
ã  
 Ôå‚  á² “á
ã  
 Ôå‚  á²“áâqÿæ  Qã  0„â 0…å „â  ã8@½èóıÿê  àã8€½è¨0Ÿå Qáÿ/Áp@-éœPŸå a•ç  Vã ä Ñ@ŸÕ  Ú ä áÀ`à€@ŸåŒ  á0„à² ”á Ráp€½ÀŒàÁLâŒÀ„à  ê² óá Ráp€½ Sáúÿÿş Vã  Ê0`à0ƒà`†âƒ0 á a…ç³„áp€½è$0Ÿå$ Ÿå ã 0“å*  ãÖıÿëA  ããıÿëşÿ  à à Ğ | øC-é p áL`ŸåLPŸå`àPà`eà€ á á®ıÿëFa°áøƒ½PEâ @ ã@„â0µå  á á	  á3ÿ/á Tá÷ÿÿøƒ½èd \ ÿ/á@-é€½è  ERROR: Only 255 unicodes/glyph permitted!
  stdin   Usage: 
        %s chartable [hashsize] [hashstep] [maxhashlevel]
  r   %s: Warning: line too long
 Bad input line: %s
 %s: Glyph number (0x%x) larger than font length
    %s: Bad end of range (0x%x)
    idem    %s: Corresponding to a range of font positions, there should be a Unicode range
    %s: Bad Unicode range corresponding to font position range 0x%x-0x%x
   %s: Unicode range U+%x-U+%x not of the same length as font position range 0x%x-0x%x
    %s: trailing junk (%s) ignored
 /*
 * Do not edit this file; it was automatically generated by
 *
 * conmakehash %s > [this file]
 *
 */

#include <linux/types.h>

u8 dfont_unicount[%d] = 
{
	    %3d 
}; 
u16 dfont_unitable[%d] = 
{
	  ,
	 ,   0x%04x  Ôùÿ       8               ì    p    €          „       õşÿo”    l    < 
                       t    €            l    T             şÿÿo4 ÿÿÿo   ğÿÿo                                                 Œ         ø ø ø ø ø ø ø ø ø ø ø ø ø ø ø ø             GCC: (Raspbian 4.9.2-10) 4.9.2 GCC: (Raspbian 4.8.4-1) 4.8.4 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.exidx .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .comment .ARM.attributes                     4           P           p           ”           <           l                      4           T      	     l      
     ì           ø           Ì           p           x           t           |           €           „           ˆ           Œ           t           Ä           Ğ                                               ñÿJ   P        M   H        J   t        J   x        J   x        J   Ä        P            ñÿM   „        ™   „       J            M   ì        M   p        ¦            ñÿM   ô        M   t        ï            ñÿM   p        ı   p Ô       D Ä     J   ô        M   Ì        J   è
        J   |                   ñÿ  ˆ       M   ¨        (  ¨       J   Ì        M   Ø        =  Ø       J           J   È        M           P         J   4        f  Ü      J   „        u  „       M   8        œ  8       J   h        J   €        ¨  €       J   Ü        Ç           ñÿM           J   d        M   l                   ñÿJ   |        Ó  |       J   ˆ        á  ˆ                    ñÿí  „        ş  Œ         €          t       M   ø        J           M           0  l      @             R              n  Ä        y             ‹  Ì       ™             ª             »  à       Æ  Ì       Í  p       Ó  à       ß             ñ  Ğ                     à  ş     Ä       +             ;             X              g  È      t                            x      ¬  à      µ             Ç             Ú  Ø      ë   d     û  à          H         à         Ì                    -  Ì |    2              F  Ì      R              l                            ì        /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crt1.o $d $a /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crti.o call_weak_fn /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crtn.o conmakehash.c getunicode addpair crtstuff.c __JCR_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.9004 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry elf-init.oS __FRAME_END__ __JCR_END__ __init_array_end _DYNAMIC __init_array_start _GLOBAL_OFFSET_TABLE_ __libc_csu_fini strtol@@GLIBC_2.4 _ITM_deregisterTMCloneTable data_start printf@@GLIBC_2.4 __bss_start__ fopen@@GLIBC_2.4 fgets@@GLIBC_2.4 _bss_end__ _edata _fini __bss_end__ perror@@GLIBC_2.4 stderr@@GLIBC_2.4 fwrite@@GLIBC_2.4 unitable __data_start puts@@GLIBC_2.4 __libc_start_main@@GLIBC_2.4 __gmon_start__ __dso_handle __ctype_b_loc@@GLIBC_2.4 exit@@GLIBC_2.4 _IO_stdin_used unicount strchr@@GLIBC_2.4 fprintf@@GLIBC_2.4 stdin@@GLIBC_2.4 __libc_csu_init _end _start __end__ __bss_start fclose@@GLIBC_2.4 main _Jv_RegisterClasses __TMC_END__ _ITM_registerTMCloneTable strncmp@@GLIBC_2.4 abort@@GLIBC_2.4 _init                                                    4 4                    #         P P                     1         p p  $                  D   öÿÿo   ” ”  ¨                N         < <  0              V         l l                     ^   ÿÿÿo      &                k   şÿÿo   4 4                   z   	      T T                  ƒ   	   B   l l  €               Œ         ì ì                    ‡         ø ø  Ô                 ’         Ì Ì  ¤                 ˜         p p                             x x  ü                 ¦     p‚   t t                   ±         | |                    »         € €                    Ç         „ „                    Ó         ˆ ˆ                    Ø         Œ Œ  è                á         t t  P                 æ         Ä Ä                    ì         Ğ Ì                  ñ      0       Ì  =                 ú     p        	  1                                :  
                               D        Y         	              d  –                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ELF          (            À     4     (   ğO-éĞMâ PRâ @ áå ` Ã  Ú`†â	  ã áşÿÿë Váùÿÿ0å,`“å  Vã    ê`–å  Vã	  
 0Öå  Sãùÿÿ –å  ápŸåşÿÿë`–å  Vãõÿÿ0å “å  Rã  
 0Òå  Sã@ D	Ÿå ã  ã0 áşÿÿë0å°“å  [ã¨  
 `Ûå  Vã¢    Uã  º`†â	  ã áşÿÿë Uáùÿÿª`›å  Vã    ê`–å  Vã	  
 0Öå  Sãùÿÿ –å  áÀŸåşÿÿë`–å  Vãõÿÿ ›å áşÿÿë0›å ›å  Sã 0å å ›åz  
 Úşÿÿë0å  å ` ã`å ápƒà €å  êdŸåşÿÿë  Pãš  
 Yá  
Ùä?oá£2 á  á² ˜á‚( á¢/“áñÿÿ
  Sã`† Yáóÿÿ  Zã0åoá¨‚ áí  
  ã	À áå  ê šå  Zã  
 0šå Sãùÿÿ0šå  Sã  Ú à Rå  RãÀŒ šå ã‰  Zãğÿÿ0 á°Ÿå ã  ãÀåşÿÿë0WåÀå  Sã € €  Xã  
 0åÏoá0fà Sá¬Â á À Ó  \ãÉ   0å ã0  0   Yã    Yãm  ›å€›å[  ã á ‰à	p á`›åşÿÿë  Vã  
 –å0ià Rá  
  ×å  á Ÿåp‡âşÿÿë ZáB  š   ã áşÿÿë  Vãóÿÿ
 –å0ià Ráïÿÿ 0–å SãG  
`–åäÿÿê]  ã áşÿÿë¬Ÿå ã  ã0 áşÿÿë°›å  [ãVÿÿ0å`“å  Vãp…    ê`–å  Vã  
 0Öå  Sãùÿÿ á
  ãşÿÿë á  á  áÿÿë`–å  Vãòÿÿ  Uã ` Ã  Ú`†â	  ã áşÿÿë Váùÿÿ0 áŸå ã  ãĞâğO½èşÿÿê0å0ƒâ0å`ÿÿê  Vã  Çÿÿê`–å  VãÄÿÿ
 0–å Sãùÿÿ0–å SáG   á¸Ÿå –åşÿÿëñÿÿê  áˆŸå –åşÿÿë²ÿÿêp›å›å<  ã á	€‡à  á`›åşÿÿë  Vã	  
 –å
0gà Rá  Ê –å Qã  
`–å  Vãõÿÿ Àšå  á Šâ4 áÿ8â<ƒá,$ á,<ƒáÿ,â ƒá ŸåÀåşÿÿë
 Xá
  š á   ãşÿÿëàÿÿê Rá1   áĞŸå –åşÿÿëâÿÿê  Vã    ê`–å  Vã  
 0–å Sãùÿÿ0–å	 Sá  –å  á¤Ÿåşÿÿë`–å  Vãòÿÿ á>  ãşÿÿërÿÿê0å  å  Zã€ ã ` ãpƒàÿÿ
 á
À á$ÿÿê  á\Ÿåşÿÿë¿şÿê›å ›å`›å	0Šà0Så  Sã  
õ  ê`–å  Vã
  
0–å  SãÒ   0–å Sãöÿÿ  áäŸå –åşÿÿëñÿÿê"  ã á€Iâşÿÿë  Xã ` ÃÜ  Ú p ã PåPÚç\ UãñŸ—¬  ê`  ì  ì  ì  ì  ì  ì  X  P  H  @  8  0  (  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì     ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ì  ¬  TŸå ã  ã0 áp‡àşÿÿë Xá–ÿÿÊ"  ã á Påşÿÿë  Vã  Õşÿê`–å  VãÒşÿ
 0–å Sãùÿÿ0–å YáW    áäŸå –åşÿÿëñÿÿêäŸåáÿÿêàŸåßÿÿêÜŸåİÿÿêØŸåÛÿÿêÔŸåÙÿÿêĞŸå×ÿÿêÌŸåÕÿÿêÈŸåÓÿÿêÄŸå ã  ã0 áşÿÿë  Vãp‡  
0–åp‡â Wá  ª  ê`–å  Vã  
0–å Sá  Ê  –å Rãöÿÿ Wá/   –å  áŸåşÿÿë`–å  Vãğÿÿ á"  ãşÿÿëµÿÿêşÿÿë…0 á å³0‘á	ã  
  á áp‡âşÿÿëªÿÿê  á  áŸåşÿÿëp‡â¤ÿÿê"  ã á€Iâşÿÿë  Xã5ÿÿÊ á"  ãşÿÿë¦ÿÿêÔ ŸåÔŸå½  ãĞ0ŸåşÿÿëÀ ŸåÀŸå„  ãÀ0Ÿåşÿÿë¼ Ÿå¬Ÿår  ã¬0Ÿåşÿÿë á"  ãşÿÿëfşÿêœ ŸåˆŸåF  ãˆ0Ÿåşÿÿët ŸåtŸå¡  ã€0Ÿåşÿÿë| Ÿå`Ÿå“  ãl0Ÿåşÿÿë       ,   4      (     Ì   ø      ˆ   Œ   „   €   |   x   t   p   l      ¨   ´   P   ,       ”   8      Ô   8@-é 0 ãX@ŸåXPŸå 0„å 0ÅåşÿÿëL0ŸåL ŸåL Ÿå 0“å “å0€å ‚åşÿÿë  Pã   0Õå  Sã    ”å8€½è Ÿåşÿÿë Ÿåşÿÿë                      (  ğC-é€ á 0 áĞMâ P á ã Ÿå  ãşÿÿë ˜å  Yã  
@™å  Tã    ê@”å  Tã	  
  Ôå  Rãùÿÿ ”å  áLŸåşÿÿë@”å  TãõÿÿØ`ÉáĞ Éá  áğ`Íá,Ÿåşÿÿë™å  Yãåÿÿ  á˜å   ãĞâğC½èıÿêL     X  <@Ÿå -é ãà-åĞMâÀâ 0”å  ã  ŸåÀåşÿÿë  ”åå åşÿÿë  ãşÿÿë        write_propval_string    write_propval_cells write_propval_bytes FATAL ERROR:    %s:     %s {
   / {
    ;
  	
  =  str[val.len-1] == '\0'  scripts/dtc/treesource.c    \a  \b  \t  \n  \v  \f  \r  \\  \"  ",  m->offset == (i+1)  \x%02hhx    m->offset == val.len     %s:    m->offset == ((char *)cp - val.val) 0x%x    %02hhx  };
 Unable to parse input tree
 Syntax error parsing input tree
    /dts-v1/;

 /memreserve/	0x%016llx 0x%016llx;
   GCC: (Raspbian 4.9.2-10) 4.9.2 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .rel.text .data .bss .rel.text.unlikely .rodata .rodata.str1.4 .comment .note.GNU-stack .ARM.attributes                             ñÿ                                                                             L        D                               T
       8            ¬            à	            T
            ¼
            Ø
            ˆ                                     /            H           a   ,                                                 
              	               z                            Š                            –              œ              ¤              ª              ¸              ¿              Í   T
  „     Ü              é              ñ          òÿÿ          òÿ                           '             ,  Ø
  ¼      treesource.c $a die $d write_tree_source_node __PRETTY_FUNCTION__.6701 __PRETTY_FUNCTION__.6734 __PRETTY_FUNCTION__.6755 fwrite vfprintf exit stderr fputc fprintf fputs __ctype_b_loc strchr __assert_fail dt_from_source srcfile_push yyparse the_boot_info treesource_error current_srcfile yylloc yyin dt_to_source    (      l   !  ¨     Ü        !  4  "  X  #  €  $  D    Ä     ğ  !       <     P    ˜     Ğ     ô    D  !  X  !  |     à  !  ô       !  T  !  l     ¤  !  ü  !       8    <    @    D    H    L    P    T    X    \    `    d    h    l    p    t    x    |    €    „    ˆ    Œ        ”    ˜    œ         ¤    ¨    ¬    °    ´    ¸    ¼    À    Ä    È    Ì    Ğ    Ô    Ø    Ü    à    ä    è    ì    ğ    ô    ø    ü                                          $    (    ,    0    4    8    <    @    D    H    L    P    T    X    \    `    d    h    l    p    t    x    |    €    „    ˆ    Œ        ”    ˜    œ         ¤    ¨    À    Ø       !  p    Ì  !  ä     ì  #  	     $	  !  <	     P	     h	  %  |	  %  	  %  œ	     ´	  %  È	  %  Ü	  %  à	    ä	    è	    ì	    ğ	    ô	    ø	    ü	     
    
    
    
    
    
    
    
     
    $
    (
    ,
    0
    4
    8
    <
    @
    D
    H
    L
    P
    l
  '  Œ
  (  °
    ¸
    ¼
  )  À
  *  Ä
  +  È
  ,  Ì
  -  Ğ
    Ô
    ø
    <  !  `  !  ˆ    Œ        (     8     @     D     H                                                          4   ”                    	   @       Ğ  È              %             È                     +             È                     4             È  L                  0   	   @       ˜  (               C               @                  K      2       T  |                Z      0       Ğ                    c              ğ                     s     p        ğ  1                                !  ƒ                                ¤  ğ              	              ”  9                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /* Generate kernel symbol version hashes.
   Copyright 1996, 1997 Linux International.

   New implementation contributed by Richard Henderson <rth@tamu.edu>
   Based on original work by Bjorn Ekwall <bj0rn@blox.se>

   This file was part of the Linux modutils 2.4.22: moved back into the
   kernel sources by Rusty Russell/Kai Germaschewski.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2 of the License, or (at your
   option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <stdarg.h>
#ifdef __GNU_LIBRARY__
#include <getopt.h>
#endif				/* __GNU_LIBRARY__ */

#include "genksyms.h"
/*----------------------------------------------------------------------*/

#define HASH_BUCKETS  4096

static struct symbol *symtab[HASH_BUCKETS];
static FILE *debugfile;

int cur_line = 1;
char *cur_filename, *source_file;
int in_source_file;

static int flag_debug, flag_dump_defs, flag_reference, flag_dump_types,
	   flag_preserve, flag_warnings;
static const char *mod_prefix = "";

static int errors;
static int nsyms;

static struct symbol *expansion_trail;
static struct symbol *visited_symbols;

static const struct {
	int n;
	const char *name;
} symbol_types[] = {
	[SYM_NORMAL]     = { 0, NULL},
	[SYM_TYPEDEF]    = {'t', "typedef"},
	[SYM_ENUM]       = {'e', "enum"},
	[SYM_STRUCT]     = {'s', "struct"},
	[SYM_UNION]      = {'u', "union"},
	[SYM_ENUM_CONST] = {'E', "enum constant"},
};

static int equal_list(struct string_list *a, struct string_list *b);
static void print_list(FILE * f, struct string_list *list);
static struct string_list *concat_list(struct string_list *start, ...);
static struct string_list *mk_node(const char *string);
static void print_location(void);
static void print_type_name(enum symbol_type type, const char *name);

/*----------------------------------------------------------------------*/

static const unsigned int crctab32[] = {
	0x00000000U, 0x77073096U, 0xee0e612cU, 0x990951baU, 0x076dc419U,
	0x706af48fU, 0xe963a535U, 0x9e6495a3U, 0x0edb8832U, 0x79dcb8a4U,
	0xe0d5e91eU, 0x97d2d988U, 0x09b64c2bU, 0x7eb17cbdU, 0xe7b82d07U,
	0x90bf1d91U, 0x1db71064U, 0x6ab020f2U, 0xf3b97148U, 0x84be41deU,
	0x1adad47dU, 0x6ddde4ebU, 0xf4d4b551U, 0x83d385c7U, 0x136c9856U,
	0x646ba8c0U, 0xfd62f97aU, 0x8a65c9ecU, 0x14015c4fU, 0x63066cd9U,
	0xfa0f3d63U, 0x8d080df5U, 0x3b6e20c8U, 0x4c69105eU, 0xd56041e4U,
	0xa2677172U, 0x3c03e4d1U, 0x4b04d447U, 0xd20d85fdU, 0xa50ab56bU,
	0x35b5a8faU, 0x42b2986cU, 0xdbbbc9d6U, 0xacbcf940U, 0x32d86ce3U,
	0x45df5c75U, 0xdcd60dcfU, 0xabd13d59U, 0x26d930acU, 0x51de003aU,
	0xc8d75180U, 0xbfd06116U, 0x21b4f4b5U, 0x56b3c423U, 0xcfba9599U,
	0xb8bda50fU, 0x2802b89eU, 0x5f058808U, 0xc60cd9b2U, 0xb10be924U,
	0x2f6f7c87U, 0x58684c11U, 0xc1611dabU, 0xb6662d3dU, 0x76dc4190U,
	0x01db7106U, 0x98d220bcU, 0xefd5102aU, 0x71b18589U, 0x06b6b51fU,
	0x9fbfe4a5U, 0xe8b8d433U, 0x7807c9a2U, 0x0f00f934U, 0x9609a88eU,
	0xe10e9818U, 0x7f6a0dbbU, 0x086d3d2dU, 0x91646c97U, 0xe6635c01U,
	0x6b6b51f4U, 0x1c6c6162U, 0x856530d8U, 0xf262004eU, 0x6c0695edU,
	0x1b01a57bU, 0x8208f4c1U, 0xf50fc457U, 0x65b0d9c6U, 0x12b7e950U,
	0x8bbeb8eaU, 0xfcb9887cU, 0x62dd1ddfU, 0x15da2d49U, 0x8cd37cf3U,
	0xfbd44c65U, 0x4db26158U, 0x3ab551ceU, 0xa3bc0074U, 0xd4bb30e2U,
	0x4adfa541U, 0x3dd895d7U, 0xa4d1c46dU, 0xd3d6f4fbU, 0x4369e96aU,
	0x346ed9fcU, 0xad678846U, 0xda60b8d0U, 0x44042d73U, 0x33031de5U,
	0xaa0a4c5fU, 0xdd0d7cc9U, 0x5005713cU, 0x270241aaU, 0xbe0b1010U,
	0xc90c2086U, 0x5768b525U, 0x206f85b3U, 0xb966d409U, 0xce61e49fU,
	0x5edef90eU, 0x29d9c998U, 0xb0d09822U, 0xc7d7a8b4U, 0x59b33d17U,
	0x2eb40d81U, 0xb7bd5c3bU, 0xc0ba6cadU, 0xedb88320U, 0x9abfb3b6U,
	0x03b6e20cU, 0x74b1d29aU, 0xead54739U, 0x9dd277afU, 0x04db2615U,
	0x73dc1683U, 0xe3630b12U, 0x94643b84U, 0x0d6d6a3eU, 0x7a6a5aa8U,
	0xe40ecf0bU, 0x9309ff9dU, 0x0a00ae27U, 0x7d079eb1U, 0xf00f9344U,
	0x8708a3d2U, 0x1e01f268U, 0x6906c2feU, 0xf762575dU, 0x806567cbU,
	0x196c3671U, 0x6e6b06e7U, 0xfed41b76U, 0x89d32be0U, 0x10da7a5aU,
	0x67dd4accU, 0xf9b9df6fU, 0x8ebeeff9U, 0x17b7be43U, 0x60b08ed5U,
	0xd6d6a3e8U, 0xa1d1937eU, 0x38d8c2c4U, 0x4fdff252U, 0xd1bb67f1U,
	0xa6bc5767U, 0x3fb506ddU, 0x48b2364bU, 0xd80d2bdaU, 0xaf0a1b4cU,
	0x36034af6U, 0x41047a60U, 0xdf60efc3U, 0xa867df55U, 0x316e8eefU,
	0x4669be79U, 0xcb61b38cU, 0xbc66831aU, 0x256fd2a0U, 0x5268e236U,
	0xcc0c7795U, 0xbb0b4703U, 0x220216b9U, 0x5505262fU, 0xc5ba3bbeU,
	0xb2bd0b28U, 0x2bb45a92U, 0x5cb36a04U, 0xc2d7ffa7U, 0xb5d0cf31U,
	0x2cd99e8bU, 0x5bdeae1dU, 0x9b64c2b0U, 0xec63f226U, 0x756aa39cU,
	0x026d930aU, 0x9c0906a9U, 0xeb0e363fU, 0x72076785U, 0x05005713U,
	0x95bf4a82U, 0xe2b87a14U, 0x7bb12baeU, 0x0cb61b38U, 0x92d28e9bU,
	0xe5d5be0dU, 0x7cdcefb7U, 0x0bdbdf21U, 0x86d3d2d4U, 0xf1d4e242U,
	0x68ddb3f8U, 0x1fda836eU, 0x81be16cdU, 0xf6b9265bU, 0x6fb077e1U,
	0x18b74777U, 0x88085ae6U, 0xff0f6a70U, 0x66063bcaU, 0x11010b5cU,
	0x8f659effU, 0xf862ae69U, 0x616bffd3U, 0x166ccf45U, 0xa00ae278U,
	0xd70dd2eeU, 0x4e048354U, 0x3903b3c2U, 0xa7672661U, 0xd06016f7U,
	0x4969474dU, 0x3e6e77dbU, 0xaed16a4aU, 0xd9d65adcU, 0x40df0b66U,
	0x37d83bf0U, 0xa9bcae53U, 0xdebb9ec5U, 0x47b2cf7fU, 0x30b5ffe9U,
	0xbdbdf21cU, 0xcabac28aU, 0x53b39330U, 0x24b4a3a6U, 0xbad03605U,
	0xcdd70693U, 0x54de5729U, 0x23d967bfU, 0xb3667a2eU, 0xc4614ab8U,
	0x5d681b02U, 0x2a6f2b94U, 0xb40bbe37U, 0xc30c8ea1U, 0x5a05df1bU,
	0x2d02ef8dU
};

static unsigned long partial_crc32_one(unsigned char c, unsigned long crc)
{
	return crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);
}

static unsigned long partial_crc32(const char *s, unsigned long crc)
{
	while (*s)
		crc = partial_crc32_one(*s++, crc);
	return crc;
}

static unsigned long crc32(const char *s)
{
	return partial_crc32(s, 0xffffffff) ^ 0xffffffff;
}

/*----------------------------------------------------------------------*/

static enum symbol_type map_to_ns(enum symbol_type t)
{
	switch (t) {
	case SYM_ENUM_CONST:
	case SYM_NORMAL:
	case SYM_TYPEDEF:
		return SYM_NORMAL;
	case SYM_ENUM:
	case SYM_STRUCT:
	case SYM_UNION:
		return SYM_STRUCT;
	}
	return t;
}

struct symbol *find_symbol(const char *name, enum symbol_type ns, int exact)
{
	unsigned long h = crc32(name) % HASH_BUCKETS;
	struct symbol *sym;

	for (sym = symtab[h]; sym; sym = sym->hash_next)
		if (map_to_ns(sym->type) == map_to_ns(ns) &&
		    strcmp(name, sym->name) == 0 &&
		    sym->is_declared)
			break;

	if (exact && sym && sym->type != ns)
		return NULL;
	return sym;
}

static int is_unknown_symbol(struct symbol *sym)
{
	struct string_list *defn;

	return ((sym->type == SYM_STRUCT ||
		 sym->type == SYM_UNION ||
		 sym->type == SYM_ENUM) &&
		(defn = sym->defn)  && defn->tag == SYM_NORMAL &&
			strcmp(defn->string, "}") == 0 &&
		(defn = defn->next) && defn->tag == SYM_NORMAL &&
			strcmp(defn->string, "UNKNOWN") == 0 &&
		(defn = defn->next) && defn->tag == SYM_NORMAL &&
			strcmp(defn->string, "{") == 0);
}

static struct symbol *__add_symbol(const char *name, enum symbol_type type,
			    struct string_list *defn, int is_extern,
			    int is_reference)
{
	unsigned long h;
	struct symbol *sym;
	enum symbol_status status = STATUS_UNCHANGED;
	/* The parser adds symbols in the order their declaration completes,
	 * so it is safe to store the value of the previous enum constant in
	 * a static variable.
	 */
	static int enum_counter;
	static struct string_list *last_enum_expr;

	if (type == SYM_ENUM_CONST) {
		if (defn) {
			free_list(last_enum_expr, NULL);
			last_enum_expr = copy_list_range(defn, NULL);
			enum_counter = 1;
		} else {
			struct string_list *expr;
			char buf[20];

			snprintf(buf, sizeof(buf), "%d", enum_counter++);
			if (last_enum_expr) {
				expr = copy_list_range(last_enum_expr, NULL);
				defn = concat_list(mk_node("("),
						   expr,
						   mk_node(")"),
						   mk_node("+"),
						   mk_node(buf), NULL);
			} else {
				defn = mk_node(buf);
			}
		}
	} else if (type == SYM_ENUM) {
		free_list(last_enum_expr, NULL);
		last_enum_expr = NULL;
		enum_counter = 0;
		if (!name)
			/* Anonymous enum definition, nothing more to do */
			return NULL;
	}

	h = crc32(name) % HASH_BUCKETS;
	for (sym = symtab[h]; sym; sym = sym->hash_next) {
		if (map_to_ns(sym->type) == map_to_ns(type) &&
		    strcmp(name, sym->name) == 0) {
			if (is_reference)
				/* fall through */ ;
			else if (sym->type == type &&
				 equal_list(sym->defn, defn)) {
				if (!sym->is_declared && sym->is_override) {
					print_location();
					print_type_name(type, name);
					fprintf(stderr, " modversion is "
						"unchanged\n");
				}
				sym->is_declared = 1;
				return sym;
			} else if (!sym->is_declared) {
				if (sym->is_override && flag_preserve) {
					print_location();
					fprintf(stderr, "ignoring ");
					print_type_name(type, name);
					fprintf(stderr, " modversion change\n");
					sym->is_declared = 1;
					return sym;
				} else {
					status = is_unknown_symbol(sym) ?
						STATUS_DEFINED : STATUS_MODIFIED;
				}
			} else {
				error_with_pos("redefinition of %s", name);
				return sym;
			}
			break;
		}
	}

	if (sym) {
		struct symbol **psym;

		for (psym = &symtab[h]; *psym; psym = &(*psym)->hash_next) {
			if (*psym == sym) {
				*psym = sym->hash_next;
				break;
			}
		}
		--nsyms;
	}

	sym = xmalloc(sizeof(*sym));
	sym->name = name;
	sym->type = type;
	sym->defn = defn;
	sym->expansion_trail = NULL;
	sym->visited = NULL;
	sym->is_extern = is_extern;

	sym->hash_next = symtab[h];
	symtab[h] = sym;

	sym->is_declared = !is_reference;
	sym->status = status;
	sym->is_override = 0;

	if (flag_debug) {
		if (symbol_types[type].name)
			fprintf(debugfile, "Defn for %s %s == <",
				symbol_types[type].name, name);
		else
			fprintf(debugfile, "Defn for type%d %s == <",
				type, name);
		if (is_extern)
			fputs("extern ", debugfile);
		print_list(debugfile, defn);
		fputs(">\n", debugfile);
	}

	++nsyms;
	return sym;
}

struct symbol *add_symbol(const char *name, enum symbol_type type,
			  struct string_list *defn, int is_extern)
{
	return __add_symbol(name, type, defn, is_extern, 0);
}

static struct symbol *add_reference_symbol(const char *name, enum symbol_type type,
				    struct string_list *defn, int is_extern)
{
	return __add_symbol(name, type, defn, is_extern, 1);
}

/*----------------------------------------------------------------------*/

void free_node(struct string_list *node)
{
	free(node->string);
	free(node);
}

void free_list(struct string_list *s, struct string_list *e)
{
	while (s != e) {
		struct string_list *next = s->next;
		free_node(s);
		s = next;
	}
}

static struct string_list *mk_node(const char *string)
{
	struct string_list *newnode;

	newnode = xmalloc(sizeof(*newnode));
	newnode->string = xstrdup(string);
	newnode->tag = SYM_NORMAL;
	newnode->next = NULL;

	return newnode;
}

static struct string_list *concat_list(struct string_list *start, ...)
{
	va_list ap;
	struct string_list *n, *n2;

	if (!start)
		return NULL;
	for (va_start(ap, start); (n = va_arg(ap, struct string_list *));) {
		for (n2 = n; n2->next; n2 = n2->next)
			;
		n2->next = start;
		start = n;
	}
	va_end(ap);
	return start;
}

struct string_list *copy_node(struct string_list *node)
{
	struct string_list *newnode;

	newnode = xmalloc(sizeof(*newnode));
	newnode->string = xstrdup(node->string);
	newnode->tag = node->tag;

	return newnode;
}

struct string_list *copy_list_range(struct string_list *start,
				    struct string_list *end)
{
	struct string_list *res, *n;

	if (start == end)
		return NULL;
	n = res = copy_node(start);
	for (start = start->next; start != end; start = start->next) {
		n->next = copy_node(start);
		n = n->next;
	}
	n->next = NULL;
	return res;
}

static int equal_list(struct string_list *a, struct string_list *b)
{
	while (a && b) {
		if (a->tag != b->tag || strcmp(a->string, b->string))
			return 0;
		a = a->next;
		b = b->next;
	}

	return !a && !b;
}

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

static struct string_list *read_node(FILE *f)
{
	char buffer[256];
	struct string_list node = {
		.string = buffer,
		.tag = SYM_NORMAL };
	int c;

	while ((c = fgetc(f)) != EOF) {
		if (c == ' ') {
			if (node.string == buffer)
				continue;
			break;
		} else if (c == '\n') {
			if (node.string == buffer)
				return NULL;
			ungetc(c, f);
			break;
		}
		if (node.string >= buffer + sizeof(buffer) - 1) {
			fprintf(stderr, "Token too long\n");
			exit(1);
		}
		*node.string++ = c;
	}
	if (node.string == buffer)
		return NULL;
	*node.string = 0;
	node.string = buffer;

	if (node.string[1] == '#') {
		size_t n;

		for (n = 0; n < ARRAY_SIZE(symbol_types); n++) {
			if (node.string[0] == symbol_types[n].n) {
				node.tag = n;
				node.string += 2;
				return copy_node(&node);
			}
		}
		fprintf(stderr, "Unknown type %c\n", node.string[0]);
		exit(1);
	}
	return copy_node(&node);
}

static void read_reference(FILE *f)
{
	while (!feof(f)) {
		struct string_list *defn = NULL;
		struct string_list *sym, *def;
		int is_extern = 0, is_override = 0;
		struct symbol *subsym;

		sym = read_node(f);
		if (sym && sym->tag == SYM_NORMAL &&
		    !strcmp(sym->string, "override")) {
			is_override = 1;
			free_node(sym);
			sym = read_node(f);
		}
		if (!sym)
			continue;
		def = read_node(f);
		if (def && def->tag == SYM_NORMAL &&
		    !strcmp(def->string, "extern")) {
			is_extern = 1;
			free_node(def);
			def = read_node(f);
		}
		while (def) {
			def->next = defn;
			defn = def;
			def = read_node(f);
		}
		subsym = add_reference_symbol(xstrdup(sym->string), sym->tag,
					      defn, is_extern);
		subsym->is_override = is_override;
		free_node(sym);
	}
}

static void print_node(FILE * f, struct string_list *list)
{
	if (symbol_types[list->tag].n) {
		putc(symbol_types[list->tag].n, f);
		putc('#', f);
	}
	fputs(list->string, f);
}

static void print_list(FILE * f, struct string_list *list)
{
	struct string_list **e, **b;
	struct string_list *tmp, **tmp2;
	int elem = 1;

	if (list == NULL) {
		fputs("(nil)", f);
		return;
	}

	tmp = list;
	while ((tmp = tmp->next) != NULL)
		elem++;

	b = alloca(elem * sizeof(*e));
	e = b + elem;
	tmp2 = e - 1;

	(*tmp2--) = list;
	while ((list = list->next) != NULL)
		*(tmp2--) = list;

	while (b != e) {
		print_node(f, *b++);
		putc(' ', f);
	}
}

static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
{
	struct string_list *list = sym->defn;
	struct string_list **e, **b;
	struct string_list *tmp, **tmp2;
	int elem = 1;

	if (!list)
		return crc;

	tmp = list;
	while ((tmp = tmp->next) != NULL)
		elem++;

	b = alloca(elem * sizeof(*e));
	e = b + elem;
	tmp2 = e - 1;

	*(tmp2--) = list;
	while ((list = list->next) != NULL)
		*(tmp2--) = list;

	while (b != e) {
		struct string_list *cur;
		struct symbol *subsym;

		cur = *(b++);
		switch (cur->tag) {
		case SYM_NORMAL:
			if (flag_dump_defs)
				fprintf(debugfile, "%s ", cur->string);
			crc = partial_crc32(cur->string, crc);
			crc = partial_crc32_one(' ', crc);
			break;

		case SYM_ENUM_CONST:
		case SYM_TYPEDEF:
			subsym = find_symbol(cur->string, cur->tag, 0);
			/* FIXME: Bad reference files can segfault here. */
			if (subsym->expansion_trail) {
				if (flag_dump_defs)
					fprintf(debugfile, "%s ", cur->string);
				crc = partial_crc32(cur->string, crc);
				crc = partial_crc32_one(' ', crc);
			} else {
				subsym->expansion_trail = expansion_trail;
				expansion_trail = subsym;
				crc = expand_and_crc_sym(subsym, crc);
			}
			break;

		case SYM_STRUCT:
		case SYM_UNION:
		case SYM_ENUM:
			subsym = find_symbol(cur->string, cur->tag, 0);
			if (!subsym) {
				struct string_list *n;

				error_with_pos("expand undefined %s %s",
					       symbol_types[cur->tag].name,
					       cur->string);
				n = concat_list(mk_node
						(symbol_types[cur->tag].name),
						mk_node(cur->string),
						mk_node("{"),
						mk_node("UNKNOWN"),
						mk_node("}"), NULL);
				subsym =
				    add_symbol(cur->string, cur->tag, n, 0);
			}
			if (subsym->expansion_trail) {
				if (flag_dump_defs) {
					fprintf(debugfile, "%s %s ",
						symbol_types[cur->tag].name,
						cur->string);
				}

				crc = partial_crc32(symbol_types[cur->tag].name,
						    crc);
				crc = partial_crc32_one(' ', crc);
				crc = partial_crc32(cur->string, crc);
				crc = partial_crc32_one(' ', crc);
			} else {
				subsym->expansion_trail = expansion_trail;
				expansion_trail = subsym;
				crc = expand_and_crc_sym(subsym, crc);
			}
			break;
		}
	}

	{
		static struct symbol **end = &visited_symbols;

		if (!sym->visited) {
			*end = sym;
			end = &sym->visited;
			sym->visited = (struct symbol *)-1L;
		}
	}

	return crc;
}

void export_symbol(const char *name)
{
	struct symbol *sym;

	sym = find_symbol(name, SYM_NORMAL, 0);
	if (!sym)
		error_with_pos("export undefined symbol %s", name);
	else {
		unsigned long crc;
		int has_changed = 0;

		if (flag_dump_defs)
			fprintf(debugfile, "Export %s == <", name);

		expansion_trail = (struct symbol *)-1L;

		sym->expansion_trail = expansion_trail;
		expansion_trail = sym;
		crc = expand_and_crc_sym(sym, 0xffffffff) ^ 0xffffffff;

		sym = expansion_trail;
		while (sym != (struct symbol *)-1L) {
			struct symbol *n = sym->expansion_trail;

			if (sym->status != STATUS_UNCHANGED) {
				if (!has_changed) {
					print_location();
					fprintf(stderr, "%s: %s: modversion "
						"changed because of changes "
						"in ", flag_preserve ? "error" :
						       "warning", name);
				} else
					fprintf(stderr, ", ");
				print_type_name(sym->type, sym->name);
				if (sym->status == STATUS_DEFINED)
					fprintf(stderr, " (became defined)");
				has_changed = 1;
				if (flag_preserve)
					errors++;
			}
			sym->expansion_trail = 0;
			sym = n;
		}
		if (has_changed)
			fprintf(stderr, "\n");

		if (flag_dump_defs)
			fputs(">\n", debugfile);

		/* Used as a linker script. */
		printf("%s__crc_%s = 0x%08lx ;\n", mod_prefix, name, crc);
	}
}

/*----------------------------------------------------------------------*/

static void print_location(void)
{
	fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>", cur_line);
}

static void print_type_name(enum symbol_type type, const char *name)
{
	if (symbol_types[type].name)
		fprintf(stderr, "%s %s", symbol_types[type].name, name);
	else
		fprintf(stderr, "%s", name);
}

void error_with_pos(const char *fmt, ...)
{
	va_list args;

	if (flag_warnings) {
		print_location();

		va_start(args, fmt);
		vfprintf(stderr, fmt, args);
		va_end(args);
		putc('\n', stderr);

		errors++;
	}
}

static void genksyms_usage(void)
{
	fputs("Usage:\n" "genksyms [-adDTwqhV] > /path/to/.tmp_obj.ver\n" "\n"
#ifdef __GNU_LIBRARY__
	      "  -s, --symbol-prefix   Select symbol prefix\n"
	      "  -d, --debug           Increment the debug level (repeatable)\n"
	      "  -D, --dump            Dump expanded symbol defs (for debugging only)\n"
	      "  -r, --reference file  Read reference symbols from a file\n"
	      "  -T, --dump-types file Dump expanded types into file\n"
	      "  -p, --preserve        Preserve reference modversions or fail\n"
	      "  -w, --warnings        Enable warnings\n"
	      "  -q, --quiet           Disable warnings (default)\n"
	      "  -h, --help            Print this message\n"
	      "  -V, --version         Print the release version\n"
#else				/* __GNU_LIBRARY__ */
	      "  -s                    Select symbol prefix\n"
	      "  -d                    Increment the debug level (repeatable)\n"
	      "  -D                    Dump expanded symbol defs (for debugging only)\n"
	      "  -r file               Read reference symbols from a file\n"
	      "  -T file               Dump expanded types into file\n"
	      "  -p                    Preserve reference modversions or fail\n"
	      "  -w                    Enable warnings\n"
	      "  -q                    Disable warnings (default)\n"
	      "  -h                    Print this message\n"
	      "  -V                    Print the release version\n"
#endif				/* __GNU_LIBRARY__ */
	      , stderr);
}

int main(int argc, char **argv)
{
	FILE *dumpfile = NULL, *ref_file = NULL;
	int o;

#ifdef __GNU_LIBRARY__
	struct option long_opts[] = {
		{"symbol-prefix", 1, 0, 's'},
		{"debug", 0, 0, 'd'},
		{"warnings", 0, 0, 'w'},
		{"quiet", 0, 0, 'q'},
		{"dump", 0, 0, 'D'},
		{"reference", 1, 0, 'r'},
		{"dump-types", 1, 0, 'T'},
		{"preserve", 0, 0, 'p'},
		{"version", 0, 0, 'V'},
		{"help", 0, 0, 'h'},
		{0, 0, 0, 0}
	};

	while ((o = getopt_long(argc, argv, "s:dwqVDr:T:ph",
				&long_opts[0], NULL)) != EOF)
#else				/* __GNU_LIBRARY__ */
	while ((o = getopt(argc, argv, "s:dwqVDr:T:ph")) != EOF)
#endif				/* __GNU_LIBRARY__ */
		switch (o) {
		case 's':
			mod_prefix = optarg;
			break;
		case 'd':
			flag_debug++;
			break;
		case 'w':
			flag_warnings = 1;
			break;
		case 'q':
			flag_warnings = 0;
			break;
		case 'V':
			fputs("genksyms version 2.5.60\n", stderr);
			break;
		case 'D':
			flag_dump_defs = 1;
			break;
		case 'r':
			flag_reference = 1;
			ref_file = fopen(optarg, "r");
			if (!ref_file) {
				perror(optarg);
				return 1;
			}
			break;
		case 'T':
			flag_dump_types = 1;
			dumpfile = fopen(optarg, "w");
			if (!dumpfile) {
				perror(optarg);
				return 1;
			}
			break;
		case 'p':
			flag_preserve = 1;
			break;
		case 'h':
			genksyms_usage();
			return 0;
		default:
			genksyms_usage();
			return 1;
		}
	{
		extern int yydebug;
		extern int yy_flex_debug;

		yydebug = (flag_debug > 1);
		yy_flex_debug = (flag_debug > 2);

		debugfile = stderr;
		/* setlinebuf(debugfile); */
	}

	if (flag_reference) {
		read_reference(ref_file);
		fclose(ref_file);
	}

	yyparse();

	if (flag_dump_types && visited_symbols) {
		while (visited_symbols != (struct symbol *)-1L) {
			struct symbol *sym = visited_symbols;

			if (sym->is_override)
				fputs("override ", dumpfile);
			if (symbol_types[sym->type].n) {
				putc(symbol_types[sym->type].n, dumpfile);
				putc('#', dumpfile);
			}
			fputs(sym->name, dumpfile);
			putc(' ', dumpfile);
			if (sym->is_extern)
				fputs("extern ", dumpfile);
			print_list(dumpfile, sym->defn);
			putc('\n', dumpfile);

			visited_symbols = sym->visited;
			sym->visited = NULL;
		}
	}

	if (flag_debug) {
		fprintf(debugfile, "Hash table occupancy %d/%d = %g\n",
			nsyms, HASH_BUCKETS,
			(double)nsyms / (double)HASH_BUCKETS);
	}

	return errors != 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /* ANSI-C code produced by gperf version 3.0.4 */
/* Command-line: gperf -t --output-file scripts/genksyms/keywords.hash.c_shipped -a -C -E -g -k '1,3,$' -p -t scripts/genksyms/keywords.gperf  */

#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
/* The character set is not based on ISO-646.  */
#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
#endif

#line 4 "scripts/genksyms/keywords.gperf"

struct resword;
static const struct resword *is_reserved_word(register const char *str, register unsigned int len);
#line 8 "scripts/genksyms/keywords.gperf"
struct resword { const char *name; int token; };
/* maximum key range = 98, duplicates = 0 */

#ifdef __GNUC__
__inline
#else
#ifdef __cplusplus
inline
#endif
#endif
static unsigned int
is_reserved_hash (register const char *str, register unsigned int len)
{
  static const unsigned char asso_values[] =
    {
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101,   0,
      101, 101, 101, 101, 101, 101,  15, 101, 101, 101,
        0, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101,   0, 101,   0, 101,   5,
       25,  20,  55,  30, 101,  15, 101, 101,  10,   0,
       10,  40,  10, 101,  10,   5,   0,  10,  15, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101
    };
  return len + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[0]] + asso_values[(unsigned char)str[len - 1]];
}

#ifdef __GNUC__
__inline
#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
__attribute__ ((__gnu_inline__))
#endif
#endif
const struct resword *
is_reserved_word (register const char *str, register unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 46,
      MIN_WORD_LENGTH = 3,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 3,
      MAX_HASH_VALUE = 100
    };

  static const struct resword wordlist[] =
    {
      {""}, {""}, {""},
#line 35 "scripts/genksyms/keywords.gperf"
      {"asm", ASM_KEYW},
      {""},
#line 15 "scripts/genksyms/keywords.gperf"
      {"__asm", ASM_KEYW},
      {""},
#line 16 "scripts/genksyms/keywords.gperf"
      {"__asm__", ASM_KEYW},
      {""}, {""},
#line 27 "scripts/genksyms/keywords.gperf"
      {"__typeof__", TYPEOF_KEYW},
      {""},
#line 19 "scripts/genksyms/keywords.gperf"
      {"__const", CONST_KEYW},
#line 18 "scripts/genksyms/keywords.gperf"
      {"__attribute__", ATTRIBUTE_KEYW},
#line 20 "scripts/genksyms/keywords.gperf"
      {"__const__", CONST_KEYW},
#line 25 "scripts/genksyms/keywords.gperf"
      {"__signed__", SIGNED_KEYW},
#line 53 "scripts/genksyms/keywords.gperf"
      {"static", STATIC_KEYW},
      {""},
#line 48 "scripts/genksyms/keywords.gperf"
      {"int", INT_KEYW},
#line 41 "scripts/genksyms/keywords.gperf"
      {"char", CHAR_KEYW},
#line 42 "scripts/genksyms/keywords.gperf"
      {"const", CONST_KEYW},
#line 54 "scripts/genksyms/keywords.gperf"
      {"struct", STRUCT_KEYW},
#line 33 "scripts/genksyms/keywords.gperf"
      {"__restrict__", RESTRICT_KEYW},
#line 34 "scripts/genksyms/keywords.gperf"
      {"restrict", RESTRICT_KEYW},
#line 12 "scripts/genksyms/keywords.gperf"
      {"EXPORT_SYMBOL_GPL_FUTURE", EXPORT_SYMBOL_KEYW},
#line 23 "scripts/genksyms/keywords.gperf"
      {"__inline__", INLINE_KEYW},
      {""},
#line 29 "scripts/genksyms/keywords.gperf"
      {"__volatile__", VOLATILE_KEYW},
#line 10 "scripts/genksyms/keywords.gperf"
      {"EXPORT_SYMBOL", EXPORT_SYMBOL_KEYW},
#line 32 "scripts/genksyms/keywords.gperf"
      {"_restrict", RESTRICT_KEYW},
      {""},
#line 17 "scripts/genksyms/keywords.gperf"
      {"__attribute", ATTRIBUTE_KEYW},
#line 11 "scripts/genksyms/keywords.gperf"
      {"EXPORT_SYMBOL_GPL", EXPORT_SYMBOL_KEYW},
#line 21 "scripts/genksyms/keywords.gperf"
      {"__extension__", EXTENSION_KEYW},
#line 44 "scripts/genksyms/keywords.gperf"
      {"enum", ENUM_KEYW},
#line 13 "scripts/genksyms/keywords.gperf"
      {"EXPORT_UNUSED_SYMBOL", EXPORT_SYMBOL_KEYW},
#line 45 "scripts/genksyms/keywords.gperf"
      {"extern", EXTERN_KEYW},
      {""},
#line 24 "scripts/genksyms/keywords.gperf"
      {"__signed", SIGNED_KEYW},
#line 14 "scripts/genksyms/keywords.gperf"
      {"EXPORT_UNUSED_SYMBOL_GPL", EXPORT_SYMBOL_KEYW},
#line 57 "scripts/genksyms/keywords.gperf"
      {"union", UNION_KEYW},
      {""}, {""},
#line 22 "scripts/genksyms/keywords.gperf"
      {"__inline", INLINE_KEYW},
#line 40 "scripts/genksyms/keywords.gperf"
      {"auto", AUTO_KEYW},
#line 28 "scripts/genksyms/keywords.gperf"
      {"__volatile", VOLATILE_KEYW},
      {""}, {""},
#line 58 "scripts/genksyms/keywords.gperf"
      {"unsigned", UNSIGNED_KEYW},
      {""},
#line 51 "scripts/genksyms/keywords.gperf"
      {"short", SHORT_KEYW},
#line 47 "scripts/genksyms/keywords.gperf"
      {"inline", INLINE_KEYW},
      {""},
#line 60 "scripts/genksyms/keywords.gperf"
      {"volatile", VOLATILE_KEYW},
#line 49 "scripts/genksyms/keywords.gperf"
      {"long", LONG_KEYW},
#line 31 "scripts/genksyms/keywords.gperf"
      {"_Bool", BOOL_KEYW},
      {""}, {""},
#line 50 "scripts/genksyms/keywords.gperf"
      {"register", REGISTER_KEYW},
#line 59 "scripts/genksyms/keywords.gperf"
      {"void", VOID_KEYW},
      {""},
#line 43 "scripts/genksyms/keywords.gperf"
      {"double", DOUBLE_KEYW},
      {""},
#line 26 "scripts/genksyms/keywords.gperf"
      {"__typeof", TYPEOF_KEYW},
      {""}, {""},
#line 52 "scripts/genksyms/keywords.gperf"
      {"signed", SIGNED_KEYW},
      {""}, {""}, {""}, {""},
#line 56 "scripts/genksyms/keywords.gperf"
      {"typeof", TYPEOF_KEYW},
#line 55 "scripts/genksyms/keywords.gperf"
      {"typedef", TYPEDEF_KEYW},
      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
#line 46 "scripts/genksyms/keywords.gperf"
      {"float", FLOAT_KEYW}
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = is_reserved_hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= 0)
        {
          register const char *s = wordlist[key].name;

          if (*str == *s && !strcmp (str + 1, s + 1))
            return &wordlist[key];
        }
    }
  return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
hostprogs-y	:= genksyms
always		:= $(hostprogs-y)

genksyms-objs	:= genksyms.o parse.tab.o lex.lex.o

# -I needed for generated C source (shipped source)
HOSTCFLAGS_parse.tab.o := -I$(src)
HOSTCFLAGS_lex.lex.o := -I$(src)

# dependencies on generated files need to be listed explicitly
$(obj)/lex.lex.o: $(obj)/keywords.hash.c $(obj)/parse.tab.h

clean-files	:= keywords.hash.c lex.lex.c parse.tab.c parse.tab.h
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /* ANSI-C code produced by gperf version 3.0.4 */
/* Command-line: gperf -t --output-file scripts/genksyms/keywords.hash.c_shipped -a -C -E -g -k '1,3,$' -p -t scripts/genksyms/keywords.gperf  */

#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
/* The character set is not based on ISO-646.  */
#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
#endif

#line 4 "scripts/genksyms/keywords.gperf"

struct resword;
static const struct resword *is_reserved_word(register const char *str, register unsigned int len);
#line 8 "scripts/genksyms/keywords.gperf"
struct resword { const char *name; int token; };
/* maximum key range = 98, duplicates = 0 */

#ifdef __GNUC__
__inline
#else
#ifdef __cplusplus
inline
#endif
#endif
static unsigned int
is_reserved_hash (register const char *str, register unsigned int len)
{
  static const unsigned char asso_values[] =
    {
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101,   0,
      101, 101, 101, 101, 101, 101,  15, 101, 101, 101,
        0, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101,   0, 101,   0, 101,   5,
       25,  20,  55,  30, 101,  15, 101, 101,  10,   0,
       10,  40,  10, 101,  10,   5,   0,  10,  15, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
      101, 101, 101, 101, 101, 101
    };
  return len + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[0]] + asso_values[(unsigned char)str[len - 1]];
}

#ifdef __GNUC__
__inline
#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
__attribute__ ((__gnu_inline__))
#endif
#endif
const struct resword *
is_reserved_word (register const char *str, register unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 46,
      MIN_WORD_LENGTH = 3,
      MAX_WORD_LENGTH = 24,
      MIN_HASH_VALUE = 3,
      MAX_HASH_VALUE = 100
    };

  static const struct resword wordlist[] =
    {
      {""}, {""}, {""},
#line 35 "scripts/genksyms/keywords.gperf"
      {"asm", ASM_KEYW},
      {""},
#line 15 "scripts/genksyms/keywords.gperf"
      {"__asm", ASM_KEYW},
      {""},
#line 16 "scripts/genksyms/keywords.gperf"
      {"__asm__", ASM_KEYW},
      {""}, {""},
#line 27 "scripts/genksyms/keywords.gperf"
      {"__typeof__", TYPEOF_KEYW},
      {""},
#line 19 "scripts/genksyms/keywords.gperf"
      {"__const", CONST_KEYW},
#line 18 "scripts/genksyms/keywords.gperf"
      {"__attribute__", ATTRIBUTE_KEYW},
#line 20 "scripts/genksyms/keywords.gperf"
      {"__const__", CONST_KEYW},
#line 25 "scripts/genksyms/keywords.gperf"
      {"__signed__", SIGNED_KEYW},
#line 53 "scripts/genksyms/keywords.gperf"
      {"static", STATIC_KEYW},
      {""},
#line 48 "scripts/genksyms/keywords.gperf"
      {"int", INT_KEYW},
#line 41 "scripts/genksyms/keywords.gperf"
      {"char", CHAR_KEYW},
#line 42 "scripts/genksyms/keywords.gperf"
      {"const", CONST_KEYW},
#line 54 "scripts/genksyms/keywords.gperf"
      {"struct", STRUCT_KEYW},
#line 33 "scripts/genksyms/keywords.gperf"
      {"__restrict__", RESTRICT_KEYW},
#line 34 "scripts/genksyms/keywords.gperf"
      {"restrict", RESTRICT_KEYW},
#line 12 "scripts/genksyms/keywords.gperf"
      {"EXPORT_SYMBOL_GPL_FUTURE", EXPORT_SYMBOL_KEYW},
#line 23 "scripts/genksyms/keywords.gperf"
      {"__inline__", INLINE_KEYW},
      {""},
#line 29 "scripts/genksyms/keywords.gperf"
      {"__volatile__", VOLATILE_KEYW},
#line 10 "scripts/genksyms/keywords.gperf"
      {"EXPORT_SYMBOL", EXPORT_SYMBOL_KEYW},
#line 32 "scripts/genksyms/keywords.gperf"
      {"_restrict", RESTRICT_KEYW},
      {""},
#line 17 "scripts/genksyms/keywords.gperf"
      {"__attribute", ATTRIBUTE_KEYW},
#line 11 "scripts/genksyms/keywords.gperf"
      {"EXPORT_SYMBOL_GPL", EXPORT_SYMBOL_KEYW},
#line 21 "scripts/genksyms/keywords.gperf"
      {"__extension__", EXTENSION_KEYW},
#line 44 "scripts/genksyms/keywords.gperf"
      {"enum", ENUM_KEYW},
#line 13 "scripts/genksyms/keywords.gperf"
      {"EXPORT_UNUSED_SYMBOL", EXPORT_SYMBOL_KEYW},
#line 45 "scripts/genksyms/keywords.gperf"
      {"extern", EXTERN_KEYW},
      {""},
#line 24 "scripts/genksyms/keywords.gperf"
      {"__signed", SIGNED_KEYW},
#line 14 "scripts/genksyms/keywords.gperf"
      {"EXPORT_UNUSED_SYMBOL_GPL", EXPORT_SYMBOL_KEYW},
#line 57 "scripts/genksyms/keywords.gperf"
      {"union", UNION_KEYW},
      {""}, {""},
#line 22 "scripts/genksyms/keywords.gperf"
      {"__inline", INLINE_KEYW},
#line 40 "scripts/genksyms/keywords.gperf"
      {"auto", AUTO_KEYW},
#line 28 "scripts/genksyms/keywords.gperf"
      {"__volatile", VOLATILE_KEYW},
      {""}, {""},
#line 58 "scripts/genksyms/keywords.gperf"
      {"unsigned", UNSIGNED_KEYW},
      {""},
#line 51 "scripts/genksyms/keywords.gperf"
      {"short", SHORT_KEYW},
#line 47 "scripts/genksyms/keywords.gperf"
      {"inline", INLINE_KEYW},
      {""},
#line 60 "scripts/genksyms/keywords.gperf"
      {"volatile", VOLATILE_KEYW},
#line 49 "scripts/genksyms/keywords.gperf"
      {"long", LONG_KEYW},
#line 31 "scripts/genksyms/keywords.gperf"
      {"_Bool", BOOL_KEYW},
      {""}, {""},
#line 50 "scripts/genksyms/keywords.gperf"
      {"register", REGISTER_KEYW},
#line 59 "scripts/genksyms/keywords.gperf"
      {"void", VOID_KEYW},
      {""},
#line 43 "scripts/genksyms/keywords.gperf"
      {"double", DOUBLE_KEYW},
      {""},
#line 26 "scripts/genksyms/keywords.gperf"
      {"__typeof", TYPEOF_KEYW},
      {""}, {""},
#line 52 "scripts/genksyms/keywords.gperf"
      {"signed", SIGNED_KEYW},
      {""}, {""}, {""}, {""},
#line 56 "scripts/genksyms/keywords.gperf"
      {"typeof", TYPEOF_KEYW},
#line 55 "scripts/genksyms/keywords.gperf"
      {"typedef", TYPEDEF_KEYW},
      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
      {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""},
#line 46 "scripts/genksyms/keywords.gperf"
      {"float", FLOAT_KEYW}
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = is_reserved_hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= 0)
        {
          register const char *s = wordlist[key].name;

          if (*str == *s && !strcmp (str + 1, s + 1))
            return &wordlist[key];
        }
    }
  return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /* A Bison parser, made by GNU Bison 2.5.1.  */

/* Bison interface for Yacc-like parsers in C
   
      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
   
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.
   
   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */


/* Tokens.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
   /* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */
   enum yytokentype {
     ASM_KEYW = 258,
     ATTRIBUTE_KEYW = 259,
     AUTO_KEYW = 260,
     BOOL_KEYW = 261,
     CHAR_KEYW = 262,
     CONST_KEYW = 263,
     DOUBLE_KEYW = 264,
     ENUM_KEYW = 265,
     EXTERN_KEYW = 266,
     EXTENSION_KEYW = 267,
     FLOAT_KEYW = 268,
     INLINE_KEYW = 269,
     INT_KEYW = 270,
     LONG_KEYW = 271,
     REGISTER_KEYW = 272,
     RESTRICT_KEYW = 273,
     SHORT_KEYW = 274,
     SIGNED_KEYW = 275,
     STATIC_KEYW = 276,
     STRUCT_KEYW = 277,
     TYPEDEF_KEYW = 278,
     UNION_KEYW = 279,
     UNSIGNED_KEYW = 280,
     VOID_KEYW = 281,
     VOLATILE_KEYW = 282,
     TYPEOF_KEYW = 283,
     EXPORT_SYMBOL_KEYW = 284,
     ASM_PHRASE = 285,
     ATTRIBUTE_PHRASE = 286,
     TYPEOF_PHRASE = 287,
     BRACE_PHRASE = 288,
     BRACKET_PHRASE = 289,
     EXPRESSION_PHRASE = 290,
     CHAR = 291,
     DOTS = 292,
     IDENT = 293,
     INT = 294,
     REAL = 295,
     STRING = 296,
     TYPE = 297,
     OTHER = 298,
     FILENAME = 299
   };
#endif



#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
#endif

extern YYSTYPE yylval;


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # ==========================================================================
# Generating modules.builtin
# ==========================================================================

src := $(obj)

PHONY := __modbuiltin
__modbuiltin:

-include include/config/auto.conf
# tristate.conf sets tristate variables to uppercase 'Y' or 'M'
# That way, we get the list of built-in modules in obj-Y
-include include/config/tristate.conf

include scripts/Kbuild.include

ifneq ($(KBUILD_SRC),)
# Create output directory if not already present
_dummy := $(shell [ -d $(obj) ] || mkdir -p $(obj))
endif

# The filename Kbuild has precedence over Makefile
kbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
kbuild-file := $(if $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)
include $(kbuild-file)

include scripts/Makefile.lib
__subdir-Y     := $(patsubst %/,%,$(filter %/, $(obj-Y)))
subdir-Y       += $(__subdir-Y)
subdir-ym      := $(sort $(subdir-y) $(subdir-Y) $(subdir-m))
subdir-ym      := $(addprefix $(obj)/,$(subdir-ym))
obj-Y          := $(addprefix $(obj)/,$(obj-Y))

modbuiltin-subdirs := $(patsubst %,%/modules.builtin, $(subdir-ym))
modbuiltin-mods    := $(filter %.ko, $(obj-Y:.o=.ko))
modbuiltin-target  := $(obj)/modules.builtin

__modbuiltin: $(modbuiltin-target) $(subdir-ym)
	@:

$(modbuiltin-target): $(subdir-ym) FORCE
	$(Q)(for m in $(modbuiltin-mods); do echo kernel/$$m; done;	\
	cat /dev/null $(modbuiltin-subdirs)) > $@

PHONY += FORCE

FORCE:

# Descending
# ---------------------------------------------------------------------------

PHONY += $(subdir-ym)
$(subdir-ym):
	$(Q)$(MAKE) $(modbuiltin)=$@


# Declare the contents of the .PHONY variable as phony.  We keep that
# information in a variable se we can use it in if_changed and friends.

.PHONY: $(PHONY)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #!/bin/sh
# Disassemble the Code: line in Linux oopses
# usage: decodecode < oops.file
#
# options: set env. variable AFLAGS=options to pass options to "as";
# e.g., to decode an i386 oops on an x86_64 system, use:
# AFLAGS=--32 decodecode < 386.oops

cleanup() {
	rm -f $T $T.s $T.o $T.oo $T.aa $T.dis
	exit 1
}

die() {
	echo "$@"
	exit 1
}

trap cleanup EXIT

T=`mktemp` || die "cannot create temp file"
code=

while read i ; do

case "$i" in
*Code:*)
	code=$i
	;;
esac

done

if [ -z "$code" ]; then
	rm $T
	exit
fi

echo $code
code=`echo $code | sed -e 's/.*Code: //'`

width=`expr index "$code" ' '`
width=$((($width-1)/2))
case $width in
1) type=byte ;;
2) type=2byte ;;
4) type=4byte ;;
esac

disas() {
	${CROSS_COMPILE}as $AFLAGS -o $1.o $1.s > /dev/null 2>&1

	if [ "$ARCH" = "arm" ]; then
		if [ $width -eq 2 ]; then
			OBJDUMPFLAGS="-M force-thumb"
		fi

		${CROSS_COMPILE}strip $1.o
	fi

	${CROSS_COMPILE}objdump $OBJDUMPFLAGS -S $1.o | \
		grep -v "/tmp\|Disassembly\|\.text\|^$" > $1.dis 2>&1
}

marker=`expr index "$code" "\<"`
if [ $marker -eq 0 ]; then
	marker=`expr index "$code" "\("`
fi

touch $T.oo
if [ $marker -ne 0 ]; then
	echo All code >> $T.oo
	echo ======== >> $T.oo
	beforemark=`echo "$code"`
	echo -n "	.$type 0x" > $T.s
	echo $beforemark | sed -e 's/ /,0x/g; s/[<>()]//g' >> $T.s
	disas $T
	cat $T.dis >> $T.oo
	rm -f $T.o $T.s $T.dis

# and fix code at-and-after marker
	code=`echo "$code" | cut -c$((${marker} + 1))-`
fi
echo Code starting with the faulting instruction  > $T.aa
echo =========================================== >> $T.aa
code=`echo $code | sed -e 's/ [<(]/ /;s/[>)] / /;s/ /,0x/g; s/[>)]$//'`
echo -n "	.$type 0x" > $T.s
echo $code >> $T.s
disas $T
cat $T.dis >> $T.aa

# (lines of whole $T.oo) - (lines of $T.aa, i.e. "Code starting") + 3,
# i.e. the title + the "===..=" line (sed is counting from 1, 0 address is
# special)
faultlinenum=$(( $(wc -l $T.oo  | cut -d" " -f1) - \
		 $(wc -l $T.aa  | cut -d" " -f1) + 3))

faultline=`cat $T.dis | head -1 | cut -d":" -f2-`
faultline=`echo "$faultline" | sed -e 's/\[/\\\[/g; s/\]/\\\]/g'`

cat $T.oo | sed -e "${faultlinenum}s/^\(.*:\)\(.*\)/\1\*\2\t\t<-- trapping instruction/"
echo
cat $T.aa
cleanup
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ELF          >     @     @       è1          @ 8 	 @         @       @ @     @ @     ø      ø                   8      8@     8@                                          @       @     d       d                     .      .`     .`                                (.      (.`     (.`     Ğ      Ğ                   T      T@     T@     D       D              Påtd   P      P@     P@     Ä       Ä              Qåtd                                                  Råtd   .      .`     .`     ğ      ğ             /lib64/ld-linux-x86-64.so.2          GNU                       GNU wÚLqM Ï'Á]¯»á]vÛ
GL                         9ò‹                            w                      %                      *                      l                      „                      1                      8                      }                      –                       \                      U                                            r                                                                  e                      @                      N     À0`             libc.so.6 exit __longjmp_chk perror mmap memset memcmp _setjmp __fprintf_chk stderr munmap __fxstat fwrite close open qsort strcmp __libc_start_main __gmon_start__ GLIBC_2.3.4 GLIBC_2.11 GLIBC_2.2.5                                    ti	   ¥      ‘‘–   ±      ui	   ¼       ø/`        	           À0`                   0`                    0`                   (0`                   00`                   80`                   @0`                   H0`                   P0`                   X0`        	           `0`        
           h0`                   p0`                   x0`                   €0`                   ˆ0`                   0`                   ˜0`                   HƒìH‹m(  H…Àtè›   HƒÄÃ      ÿ5b(  ÿ%d(  @ ÿ%b(  h    éàÿÿÿÿ%Z(  h   éĞÿÿÿÿ%R(  h   éÀÿÿÿÿ%J(  h   é°ÿÿÿÿ%B(  h   é ÿÿÿÿ%:(  h   éÿÿÿÿ%2(  h   é€ÿÿÿÿ%*(  h   épÿÿÿÿ%"(  h   é`ÿÿÿÿ%(  h	   éPÿÿÿÿ%(  h
   é@ÿÿÿÿ%
(  h   é0ÿÿÿÿ%(  h   é ÿÿÿÿ%ú'  h   éÿÿÿÿ%ò'  h   é ÿÿÿÿ%ê'  h   éğşÿÿÿ%â'  h   éàşÿÿAWAVAUATUSHìÈ   ƒÿš  HFÇD$X    H‰$GşHDÆH‰D$H‹$¿ 1` H‹ H‰D$èÿÿÿƒø„”  ƒø„Ù  …À„  H‹=’'  H‹L$º(@ ¾   1Àèlÿÿÿ¿   èBÿÿÿM…äH‹\$x„¢
  Hƒ|$  „‰  H‹D$ HhH‰ïÿ'  Hƒ|$0 H‰„$¸   „T  I|$ÿo'  L‹t$0L$I~ÿ\'  L‹|$`L,M…ÿ„z
  L‰÷HƒÇ ÿ='  L‰ï‰ÆAÿ×H‹¼$   H…ÿtHc”$°   1öèáıÿÿL‹t$ E1íIƒÆ ë IƒÅL‰÷ÿû&  H¹«ªªªªªªªH÷áHÁêI9Õƒ”  H‰ïÿØ&  KTm HØL<ĞA¶Gƒà<u¸L‰ÿÿ¯&  Hcø¾5@ Lçè¿ıÿÿ…Àu›H‹„$¸   L‰ıIHØH)ÅH¸«ªªªªªªªHÁıH¯èÿf&  ‰Á·ÀfÁ fùş ‡Ş  -   H‹l$p‰ÀHÁàHÅH}ÿD&  I‰ÄIÿ7&  IÄH}ÿ*&  I)Ä1ÿJ4#ÿû%  è®  fD  Hƒ$H‹D$H9$…ëıÿÿ1Àƒ|$X •ÀHÄÈ   []A\A]A^A_ÃH‹|$1À¾   Ç^'  ÿÿÿÿHÇG'      ÇE'     èıÿÿ…À‰Ã‰:'  ˆ4	  º 2` ‰Æ¿   èÇüÿÿ…Àˆ	  ‹‘&  % ğ  = €  …	  H‹5’&  E1ÉA‰Ø1ÿ¹   º   èüÿÿHƒøÿH‰Ã„ø  ¶HH‰Ã&  €ù„1  €ù…Õ   HÇ%  @@ HÇ%  `@ HÇ%  ğ@ HÇİ$  @@ HÇÊ$  p@ HÇÏ$  ğ@ º   H‰Ş¿m@ èÍûÿÿ…À…R  H{ÿ³$  fƒø…>  €{…4  HkH‰ïÿ’$  fƒø>tp‡Ü   fƒø„ê   @ vTfƒøtTfƒø(„Ô   H‰ïÿ]$  L‹D$·Èº@ ëƒD$XéDşÿÿL‹D$º¨@ H‹=û#  ¾   1Àèßûÿÿè
  fƒøu¶HÇD$`À@ ¶K€ù„«  €ù„›   L‹D$º®@ ë·HÇî#  À@ HÇÛ#  à@ HÇà#  p@ HÇµ#  Ğ@ HÇ¢#  ğ@ HÇ§#  €@ éÓşÿÿf=· t†  f=½ f…,ÿÿÿHÇD$`    éqÿÿÿH‹E#  º   ¾   ¿ˆ@ èûÿÿ1Àé€ıÿÿH{4ÿX#  fƒø@…)  H{:ÿD#  fƒø@…  H{(ÿ@#  HØH{<H‰D$pÿ#  D·àE…ä„   H{>ÿ#  ·À=ÿÿ  „z  H‹t$p‰ÀHÁàH|ÿó"  HØE…äH‰D$P„Ø  H‹l$pD‰d$\E1ÿHÇ„$        Ç„$°       E1íHÇ„$       HÇD$0    HÇD$     HÇD$@    H‰\$xënL‰÷ÿ|"  ƒø„´   H‹D$ ¿ğ@ ¹   H‰Şó¦¿ø@ ¹   H‰ŞIDÄH‰D$ ó¦L‰÷LEd$@ÿ8"  ƒø„°   AƒÅHƒÅ@D;l$\„júÿÿL‰d$@H‰ïLuI‰ìÿ"  HcØH\$P¿å@ ¹   H‰Şó¦L‰÷’Â—À)Ğ¾À…ÀH‹D$0EDıHDÅH‰D$0ÿÈ!  ƒø	…:ÿÿÿH},ÿµ!  D9ø…9ÿÿÿH}ÿª!  HD$xH} H‰„$   ÿ“!  ‰„$°   éÿÿÿH}ÿ}!  HD$xH‰„$    é4ÿÿÿH{(ÿQ!  fƒø4…"  H{.ÿ=!  fƒø(…  H{ ÿ1!  ‰ÀH{0HØH‰D$hÿ!  D·àE…ä„à  H{2ÿş   ·À=ÿÿ  „]  ‰ÀH‹L$hHkÀ(H|ÿâ   ‰ÀHØE…äH‰D$H„Í  H‹l$hD‰¤$¨   E1ÿHÇ„$˜       Ç„$¬       E1íHÇ„$ˆ       HÇD$(    HÇD$    HÇD$8    H‰œ$€   ëqL‰÷ÿk   ƒø„·   H‹D$¿ğ@ ¹   H‰Şó¦¿ø@ ¹   H‰ŞIDÄH‰D$ó¦L‰÷LEd$8ÿ'   ƒø„¸   AƒÅHƒÅ(D;¬$¨   „å   L‰d$8H‰ïLuI‰ìÿó  HcØH\$H¿å@ ¹   H‰Şó¦L‰÷’Â—À)Ğ¾À…ÀH‹D$(EDıHDÅH‰D$(ÿ´  ƒø	…7ÿÿÿH}ÿ¡  D9ø…6ÿÿÿH}ÿ  ‰ÀH„$€   H}H‰„$ˆ   ÿr  ‰„$¬   éÿÿÿH}ÿ\  ‰ÀH„$€   H‰„$˜   é'ÿÿÿH‹L$ºğ@ H‹=ô  ¾   1ÀèØöÿÿè  M…äH‹œ$€   „  Hƒ|$ „÷  H‹D$HhH‰ïÿô  Hƒ|$( ‰„$´   „Ã  I|$ÿÖ  L‹t$(A‰ÄIÜI~ÿÁ  L‹|$`A‰ÅIİM…ÿ„º  L‰÷HƒÇÿ   L‰ï‰ÆAÿ×H‹¼$ˆ   H…ÿtHc”$¬   1öèLõÿÿL‹t$E1íIƒÆë
fD  IƒÅL‰÷ÿ[  ÁèI9Åƒ
ÿÿÿH‰ïÿF  A‰ÇL‰èIßHÁàIÇA¶Wƒâ€úuÁL‰ÿÿ   Hcø¾5@ Lçè0õÿÿ…Àu¤‹„$´   L‰ıIHØH)Åÿê  ·Ğf HÁıf=ş ‡†   ê   ‰ÕHkí(Hl$hH}ÿÂ  IA‰Åÿµ  A‰ÄH}Mìÿ¥  ‰À1ÿI)ÄJ4#ÿ|  é|÷ÿÿƒè]fƒø‡ùÿÿféáùÿÿ=ÿÿ  …÷ÿÿH‹„$    ‰íH<¨ÿ\  é÷ÿÿúÿÿ  …tÿÿÿH‹„$˜   ‰íH<¨ÿ7  ‰ÂéYÿÿÿH‹D$hHxÿ!  A‰Äé	üÿÿH‹D$pHx ÿ  A‰ÄééùÿÿH‹L$ºÌ@ é¸ıÿÿH‹|$(HƒÇÿä  Áè¹ @ º   ‰ÆL‰ïè}óÿÿé0şÿÿH‹|$0HƒÇ ÿÁ  HÁè¹@@ º   HcğL‰ïèPóÿÿénõÿÿH‹D$hHxÿŒ  éûÿÿH‹D$pHx(ÿx  érùÿÿH‹L$ºr@ é)ıÿÿH‹|$èÚóÿÿè5  H‹L$º<@ éıÿÿÇÔ     H‹L$ºT@ éòüÿÿH‹L$ºĞ@ éãüÿÿH‹L$º@ éÔüÿÿH‹L$º @ éÅüÿÿ1íI‰Ñ^H‰âHƒäğPTIÇÀp@ HÇÁ @ HÇÇÀ@ èÇòÿÿôfD  ¸·0` UH-°0` HƒøH‰åw]Ã¸    H…Àtô]¿°0` ÿà€    ¸°0` UH-°0` HÁøH‰åH‰ÂHÁê?HĞHÑøu]Ãº    H…Òtô]H‰Æ¿°0` ÿâ€    €=!   uUH‰åè~ÿÿÿ]Æ  óÃ@ Hƒ=X   t¸    H…ÀtU¿ .` H‰åÿĞ]é{ÿÿÿ ésÿÿÿ ¶¶W¶OÁâÁà	Ğ¶WÁá	Ğ¶WÁâ	Ğ¶WHÁà Áâ	Ê¶O	Ê¶OÁá	ÊH	ĞÃff.„     ¶¶WÁàÁâ	Ğ¶W	Ğ¶WÁâ	ĞÃ¶¶GÁâ	ĞÃ ¶G¶W¶OÁâÁà	Ğ¶WÁá	Ğ¶WÁâ	Ğ¶WHÁà Áâ	Ê¶	Ê¶OÁá	ÊH	ĞÃff.„     ¶G¶WÁàÁâ	Ğ¶	Ğ¶WÁâ	ĞÃ¶W¶Áâ	ĞÃ H‰øHÁè ‰Â·ÀÁêˆF‰ÑˆV‰Â‰øfÁê·ÿÁèˆVfÁé‰ÂˆF‰øfÁêfÁèˆˆVˆF@ˆ~Ã„     ‰ø·ÿÁè@ˆ~‰ÂˆF‰øfÁêfÁèˆˆFÃffffff.„     ‰ø@ˆ~fÁèˆÃ H‰øHÁè ‰Â·ÀˆFfÁèÁêˆF‰ø·ÿÁèˆV@ˆ>fÁêˆFfÁïfÁèˆV@ˆ~ˆFÃffffff.„     ‰ø·ÿÁè@ˆ>fÁïˆFfÁè@ˆ~ˆFÃf@ˆ>fÁï@ˆ~Ã@ UH‰õSHƒìÿñ  ‰ÃH‰ïÿæ  1É9Ãºÿÿÿÿ—ÁCÑHƒÄ[‰Ğ]Ãfffff.„     UH‰õSHƒìÿ¹  H‰ÃH‰ïÿ­  1ÉH9Ãºÿÿÿÿ—ÁCÑHƒÄ[‰Ğ]Ãfff.„     UH‰õSHƒìÿq  ‰ÃH‰ïÿf  1É9ÃºÿÿÿÿŸÁMÑHƒÄ[‰Ğ]Ãfffff.„     AWA‰÷AVAUATUSH‰ûHƒì…ö’   FÿH‰ıÁèLd‡fD  H‰ïL‹5î  A‰İÿı  ‰êH‰îHƒÅ)Ú<AÿÖL9åu×AÁÿ¹€@ º   Ic÷H‰ßè~îÿÿfD  H‰ßH‹-¦  ÿ¸  ‰ÚH‰ŞHƒÃD)ê)Ğ‰ÇÿÕL9ãuÙHƒÄ[]A\A]A^A_ÃF…ö¹€@ º   DHøHƒÄ[]A\A]AÁÿA^Ic÷A_éîÿÿD  ‹ò  …Àt‹=ì  é+îÿÿ HƒìH‹=Í  H‹5f  èîÿÿ‹=Ç  HƒÄéîÿÿfHƒìè·ÿÿÿ¾   ¿ 1` èhîÿÿ„     AWA‰ÿAVI‰öAUI‰ÕATL%ø  UH-ø  SL)å1ÛHÁıHƒìèMíÿÿH…ít„     L‰êL‰öD‰ÿAÿÜHƒÃH9ëuêHƒÄ[]A\A]A^A_Ãff.„     óÃ  HƒìHƒÄÃ         usage: sortextable vmlinux...
  unrecognized ELF data encoding %d: %s
  unrecognized ET_EXEC file: %s
  no main_extable_sort_needed symbol in  file: %s
        internal error: %s
 not a regular file: %s
 Could not mmap file: %s
 ELF unrecognized ET_EXEC file %s
 unrecognized e_machine %d %s
 unrecognized ELF class %d %s
 no .strtab in  file: %s
 __ex_table .symtab .strtab no .symtab in  file: %s
 no __ex_table in  file: %s
 main_extable_sort_needed   ;Ä      Pëÿÿ  pìÿÿ`  °øÿÿà    ùÿÿ8  ğùÿÿP  úÿÿh   úÿÿ€  púÿÿ˜  úÿÿ°   úÿÿÈ  ğúÿÿà   ûÿÿø  0ûÿÿ  €ûÿÿ(   ûÿÿ@  °ûÿÿX  ğûÿÿ€  0üÿÿ¨  püÿÿĞ  Pıÿÿ0  ıÿÿH  °ıÿÿ°   şÿÿø             zR x      È÷ÿÿ*                  zR x  $      8êÿÿ    FJw€ ?;*3$"       D   `øÿÿE              \   ˜øÿÿ              t    øÿÿ              Œ   ˜øÿÿE              ¤   Ğøÿÿ              ¼   Øøÿÿ              Ô   ĞøÿÿH              ì   ùÿÿ!                 ùÿÿ                ùÿÿA              4  Pùÿÿ              L  Xùÿÿ           $   d  Pùÿÿ2    A†DƒD dAC $   Œ  hùÿÿ4    A†DƒD fAC $   ´  €ùÿÿ2    A†DƒD dAC \   Ü  ˜ùÿÿÛ    BEB B(ŒA0†A8ƒG@
8A0A(B BBBAW8A0A(B BFE   <  úÿÿ>    \]    T  @úÿÿ    D    L   l  éÿÿ@   BBB B(ŒA0†A8ƒG€L
8A0A(B BBBA   D   ¼  øùÿÿe    BEE E(ŒH0†H8ƒM@l8A0A(B BBB       úÿÿ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           À@      @                                  €@            t@            .`                          .`                   õşÿo    ˜@            ˆ@            À@     
       È                                            0`            ˜                           è@            ¸@            0       	              şÿÿo    x@     ÿÿÿo           ğÿÿo    P@                                                                                                             (.`                     ¶@     Æ@     Ö@     æ@     ö@     @     @     &@     6@     F@     V@     f@     v@     †@     –@     ¦@     ¶@                     GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss .comment                                                                                   8@     8                                    #             T@     T                                     1             t@     t      $                              D   öÿÿo       ˜@     ˜      $                             N             À@     À      È                          V             ˆ@     ˆ      È                              ^   ÿÿÿo       P@     P      &                            k   şÿÿo       x@     x      @                            z             ¸@     ¸      0                            „             è@     è      ˜                                       €@     €                                    ‰              @                                         ”             À@     À      ²                             š             t@     t      	                                            €@     €      Î                             ¨             P@     P      Ä                              ¶             @           L                             À             .`     .                                    Ì             .`     .                                    Ø              .`      .                                    İ             (.`     (.      Ğ                           æ             ø/`     ø/                                   ë              0`      0                                    ô              0`      0                                    ú             À0`     °0      à                              ÿ      0               °0      +                                                   Û0                                                         h9      8
         J                 	                       C      E                                                           8@                   T@                   t@                   ˜@                   À@                   ˆ@                   P@                   x@                  	 ¸@                  
 è@                   €@                    @                   À@                   t@                   €@                   P@                   @                   .`                   .`                    .`                   (.`                   ø/`                    0`                    0`                   À0`                                       ñÿ                     ğ@     E            @@                 `@                 p@     E       "     À@            &     à@            +     ğ@     H       0     @@     !       4     p@            9     €@     A       >     Ğ@            B     ğ@            G      @     2       Z      1`            \     @@     4       o     1`            r     €@     2       ‰     À@     Û            è0`            Ÿ      @     >       §     ˜2`            ³     œ2`            º     2`            Ä      2`            Ç     à@            Ñ      1`     È       Ø     ø0`            Û     à0`            Ş     ğ0`            á    ñÿ                ì      .`             ù     0@                 `@             !     @             7    È0`            F    .`             m    À@             y    .`             á    ñÿ                ˜    ` @             ¦     .`                  ñÿ                ²     .`             Ã    (.`             Ì     .`             ß     0`             õ    p@                                  !      0`             ,                     ?    °0`             F    t@             L                     ^                     r                     …                     ¤                     ¸                     Í     0`             Ú                     î                      ı   ¨0`             
    €@                 @     e       )                     ?     2`             D     @             K    °0`             W                     k    À@     @      p                     Š                     œ                     °                      Ä                     Ö                     ê   °0`             ö                                           +    €@             1    À0`             sortextable.c r8be rbe r2be r8le rle r2le w8be wbe w2be w8le wle w2le compare_extable_32 r compare_extable_64 r8 compare_relative_table sort_relative_table w cleanup mmap_failed fd_map ehdr_curr sb fail_file jmpenv r2 w2 w8 crtstuff.c __JCR_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.6973 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry __FRAME_END__ __JCR_END__ __init_array_end _DYNAMIC __init_array_start _GLOBAL_OFFSET_TABLE_ __libc_csu_fini _ITM_deregisterTMCloneTable data_start qsort@@GLIBC_2.2.5 _edata _fini mmap@@GLIBC_2.2.5 memset@@GLIBC_2.2.5 close@@GLIBC_2.2.5 __libc_start_main@@GLIBC_2.2.5 memcmp@@GLIBC_2.2.5 _setjmp@@GLIBC_2.2.5 __data_start strcmp@@GLIBC_2.2.5 __gmon_start__ __dso_handle _IO_stdin_used __libc_csu_init __fxstat@@GLIBC_2.2.5 _end _start __bss_start munmap@@GLIBC_2.2.5 main __longjmp_chk@@GLIBC_2.11 open@@GLIBC_2.2.5 perror@@GLIBC_2.2.5 _Jv_RegisterClasses exit@@GLIBC_2.2.5 fwrite@@GLIBC_2.2.5 __TMC_END__ __fprintf_chk@@GLIBC_2.3.4 _ITM_registerTMCloneTable _init stderr@@GLIBC_2.2.5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #!/bin/sh
# Generates a small Makefile used in the root of the output
# directory, to allow make to be started from there.
# The Makefile also allow for more convinient build of external modules

# Usage
# $1 - Kernel src directory
# $2 - Output directory
# $3 - version
# $4 - patchlevel


test ! -r $2/Makefile -o -O $2/Makefile || exit 0
# Only overwrite automatically generated Makefiles
# (so we do not overwrite kernel Makefile)
if test -e $2/Makefile && ! grep -q Automatically $2/Makefile
then
	exit 0
fi
if [ "${quiet}" != "silent_" ]; then
	echo "  GEN     $2/Makefile"
fi

cat << EOF > $2/Makefile
# Automatically generated by $0: don't edit

VERSION = $3
PATCHLEVEL = $4

lastword = \$(word \$(words \$(1)),\$(1))
makedir := \$(dir \$(call lastword,\$(MAKEFILE_LIST)))

ifeq ("\$(origin V)", "command line")
VERBOSE := \$(V)
endif
ifneq (\$(VERBOSE),1)
Q := @
endif

MAKEARGS := -C $1
MAKEARGS += O=\$(if \$(patsubst /%,,\$(makedir)),\$(CURDIR)/)\$(patsubst %/,%,\$(makedir))

MAKEFLAGS += --no-print-directory

.PHONY: __sub-make \$(MAKECMDGOALS)

__sub-make:
	\$(Q)\$(MAKE) \$(MAKEARGS) \$(MAKECMDGOALS)

\$(filter-out __sub-make, \$(MAKECMDGOALS)): __sub-make
	@:
EOF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #!/bin/bash
# (c) 2014, Sasha Levin <sasha.levin@oracle.com>
#set -x

if [[ $# != 2 ]]; then
	echo "Usage:"
	echo "	$0 [vmlinux] [base path]"
	exit 1
fi

vmlinux=$1
basepath=$2
declare -A cache

parse_symbol() {
	# The structure of symbol at this point is:
	#   [name]+[offset]/[total length]
	#
	# For example:
	#   do_basic_setup+0x9c/0xbf


	# Strip the symbol name so that we could look it up
	local name=${symbol%+*}

	# Use 'nm vmlinux' to figure out the base address of said symbol.
	# It's actually faster to call it every time than to load it
	# all into bash.
	if [[ "${cache[$name]+isset}" == "isset" ]]; then
		local base_addr=${cache[$name]}
	else
		local base_addr=$(nm "$vmlinux" | grep -i ' t ' | awk "/ $name\$/ {print \$1}" | head -n1)
		cache["$name"]="$base_addr"
	fi
	# Let's start doing the math to get the exact address into the
	# symbol. First, strip out the symbol total length.
	local expr=${symbol%/*}

	# Now, replace the symbol name with the base address we found
	# before.
	expr=${expr/$name/0x$base_addr}

	# Evaluate it to find the actual address
	expr=$((expr))
	local address=$(printf "%x\n" "$expr")

	# Pass it to addr2line to get filename and line number
        # Could get more than one result
	if [[ "${cache[$address]+isset}" == "isset" ]]; then
		local code=${cache[$address]}
	else
		local code=$(addr2line -i -e "$vmlinux" "$address")
		cache[$address]=$code
	fi

	# addr2line doesn't return a proper error code if it fails, so
	# we detect it using the value it prints so that we could preserve
	# the offset/size into the function and bail out
	if [[ $code == "??:0" ]]; then
		return
	fi

	# Strip out the base of the path
	code=${code//$basepath/""}

	# In the case of inlines, move everything to same line
	code=${code//$'\n'/' '}

	# Replace old address with pretty line numbers
	symbol="$name ($code)"
}

decode_code() {
	local scripts=`dirname "${BASH_SOURCE[0]}"`

	echo "$1" | $scripts/decodecode
}

handle_line() {
	local words

	# Tokenize
	read -a words <<<"$1"

	# Remove hex numbers. Do it ourselves until it happens in the
	# kernel

	# We need to know the index of the last element before we
	# remove elements because arrays are sparse
	local last=$(( ${#words[@]} - 1 ))

	for i in "${!words[@]}"; do
		# Remove the address
		if [[ ${words[$i]} =~ \[\<([^]]+)\>\] ]]; then
			unset words[$i]
		fi

		# Format timestamps with tabs
		if [[ ${words[$i]} == \[ && ${words[$i+1]} == *\] ]]; then
			unset words[$i]
			words[$i+1]=$(printf "[%13s\n" "${words[$i+1]}")
		fi
	done

	# The symbol is the last element, process it
	symbol=${words[$last]}
	unset words[$last]
	parse_symbol # modifies $symbol

	# Add up the line number to the symbol
	echo "${words[@]}" "$symbol"
}

while read line; do
	# Let's see if we have an address in the line
	if [[ $line =~ \[\<([^]]+)\>\]  ]]; then
		# Translate address to line numbers
		handle_line "$line"
	# Is it a code line?
	elif [[ $line == *Code:* ]]; then
                decode_code "$line"
        else
		# Nothing special in this line, show it as is
		echo "$line"
	fi
done
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Copyright (c) 2002 - 2011 Tony Finch <dot@dotat.at>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * unifdef - remove ifdef'ed lines
 *
 * This code was derived from software contributed to Berkeley by Dave Yost.
 * It was rewritten to support ANSI C by Tony Finch. The original version
 * of unifdef carried the 4-clause BSD copyright licence. None of its code
 * remains in this version (though some of the names remain) so it now
 * carries a more liberal licence.
 *
 *  Wishlist:
 *      provide an option which will append the name of the
 *        appropriate symbol after #else's and #endif's
 *      provide an option which will check symbols after
 *        #else's and #endif's to see that they match their
 *        corresponding #ifdef or #ifndef
 *
 *   These require better buffer handling, which would also make
 *   it possible to handle all "dodgy" directives correctly.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

const char copyright[] =
    "@(#) $Version: unifdef-2.5 $\n"
    "@(#) $Author: Tony Finch (dot@dotat.at) $\n"
    "@(#) $URL: http://dotat.at/prog/unifdef $\n"
;

/* types of input lines: */
typedef enum {
	LT_TRUEI,		/* a true #if with ignore flag */
	LT_FALSEI,		/* a false #if with ignore flag */
	LT_IF,			/* an unknown #if */
	LT_TRUE,		/* a true #if */
	LT_FALSE,		/* a false #if */
	LT_ELIF,		/* an unknown #elif */
	LT_ELTRUE,		/* a true #elif */
	LT_ELFALSE,		/* a false #elif */
	LT_ELSE,		/* #else */
	LT_ENDIF,		/* #endif */
	LT_DODGY,		/* flag: directive is not on one line */
	LT_DODGY_LAST = LT_DODGY + LT_ENDIF,
	LT_PLAIN,		/* ordinary line */
	LT_EOF,			/* end of file */
	LT_ERROR,		/* unevaluable #if */
	LT_COUNT
} Linetype;

static char const * const linetype_name[] = {
	"TRUEI", "FALSEI", "IF", "TRUE", "FALSE",
	"ELIF", "ELTRUE", "ELFALSE", "ELSE", "ENDIF",
	"DODGY TRUEI", "DODGY FALSEI",
	"DODGY IF", "DODGY TRUE", "DODGY FALSE",
	"DODGY ELIF", "DODGY ELTRUE", "DODGY ELFALSE",
	"DODGY ELSE", "DODGY ENDIF",
	"PLAIN", "EOF", "ERROR"
};

/* state of #if processing */
typedef enum {
	IS_OUTSIDE,
	IS_FALSE_PREFIX,	/* false #if followed by false #elifs */
	IS_TRUE_PREFIX,		/* first non-false #(el)if is true */
	IS_PASS_MIDDLE,		/* first non-false #(el)if is unknown */
	IS_FALSE_MIDDLE,	/* a false #elif after a pass state */
	IS_TRUE_MIDDLE,		/* a true #elif after a pass state */
	IS_PASS_ELSE,		/* an else after a pass state */
	IS_FALSE_ELSE,		/* an else after a true state */
	IS_TRUE_ELSE,		/* an else after only false states */
	IS_FALSE_TRAILER,	/* #elifs after a true are false */
	IS_COUNT
} Ifstate;

static char const * const ifstate_name[] = {
	"OUTSIDE", "FALSE_PREFIX", "TRUE_PREFIX",
	"PASS_MIDDLE", "FALSE_MIDDLE", "TRUE_MIDDLE",
	"PASS_ELSE", "FALSE_ELSE", "TRUE_ELSE",
	"FALSE_TRAILER"
};

/* state of comment parser */
typedef enum {
	NO_COMMENT = false,	/* outside a comment */
	C_COMMENT,		/* in a comment like this one */
	CXX_COMMENT,		/* between // and end of line */
	STARTING_COMMENT,	/* just after slash-backslash-newline */
	FINISHING_COMMENT,	/* star-backslash-newline in a C comment */
	CHAR_LITERAL,		/* inside '' */
	STRING_LITERAL		/* inside "" */
} Comment_state;

static char const * const comment_name[] = {
	"NO", "C", "CXX", "STARTING", "FINISHING", "CHAR", "STRING"
};

/* state of preprocessor line parser */
typedef enum {
	LS_START,		/* only space and comments on this line */
	LS_HASH,		/* only space, comments, and a hash */
	LS_DIRTY		/* this line can't be a preprocessor line */
} Line_state;

static char const * const linestate_name[] = {
	"START", "HASH", "DIRTY"
};

/*
 * Minimum translation limits from ISO/IEC 9899:1999 5.2.4.1
 */
#define	MAXDEPTH        64			/* maximum #if nesting */
#define	MAXLINE         4096			/* maximum length of line */
#define	MAXSYMS         4096			/* maximum number of symbols */

/*
 * Sometimes when editing a keyword the replacement text is longer, so
 * we leave some space at the end of the tline buffer to accommodate this.
 */
#define	EDITSLOP        10

/*
 * For temporary filenames
 */
#define TEMPLATE        "unifdef.XXXXXX"

/*
 * Globals.
 */

static bool             compblank;		/* -B: compress blank lines */
static bool             lnblank;		/* -b: blank deleted lines */
static bool             complement;		/* -c: do the complement */
static bool             debugging;		/* -d: debugging reports */
static bool             iocccok;		/* -e: fewer IOCCC errors */
static bool             strictlogic;		/* -K: keep ambiguous #ifs */
static bool             killconsts;		/* -k: eval constant #ifs */
static bool             lnnum;			/* -n: add #line directives */
static bool             symlist;		/* -s: output symbol list */
static bool             symdepth;		/* -S: output symbol depth */
static bool             text;			/* -t: this is a text file */

static const char      *symname[MAXSYMS];	/* symbol name */
static const char      *value[MAXSYMS];		/* -Dsym=value */
static bool             ignore[MAXSYMS];	/* -iDsym or -iUsym */
static int              nsyms;			/* number of symbols */

static FILE            *input;			/* input file pointer */
static const char      *filename;		/* input file name */
static int              linenum;		/* current line number */
static FILE            *output;			/* output file pointer */
static const char      *ofilename;		/* output file name */
static bool             overwriting;		/* output overwrites input */
static char             tempname[FILENAME_MAX];	/* used when overwriting */

static char             tline[MAXLINE+EDITSLOP];/* input buffer plus space */
static char            *keyword;		/* used for editing #elif's */

static const char      *newline;		/* input file format */
static const char       newline_unix[] = "\n";
static const char       newline_crlf[] = "\r\n";

static Comment_state    incomment;		/* comment parser state */
static Line_state       linestate;		/* #if line parser state */
static Ifstate          ifstate[MAXDEPTH];	/* #if processor state */
static bool             ignoring[MAXDEPTH];	/* ignore comments state */
static int              stifline[MAXDEPTH];	/* start of current #if */
static int              depth;			/* current #if nesting */
static int              delcount;		/* count of deleted lines */
static unsigned         blankcount;		/* count of blank lines */
static unsigned         blankmax;		/* maximum recent blankcount */
static bool             constexpr;		/* constant #if expression */
static bool             zerosyms = true;	/* to format symdepth output */
static bool             firstsym;		/* ditto */

static int              exitstat;		/* program exit status */

static void             addsym(bool, bool, char *);
static void             closeout(void);
static void             debug(const char *, ...);
static void             done(void);
static void             error(const char *);
static int              findsym(const char *);
static void             flushline(bool);
static Linetype         parseline(void);
static Linetype         ifeval(const char **);
static void             ignoreoff(void);
static void             ignoreon(void);
static void             keywordedit(const char *);
static void             nest(void);
static void             process(void);
static const char      *skipargs(const char *);
static const char      *skipcomment(const char *);
static const char      *skipsym(const char *);
static void             state(Ifstate);
static int              strlcmp(const char *, const char *, size_t);
static void             unnest(void);
static void             usage(void);
static void             version(void);

#define endsym(c) (!isalnum((unsigned char)c) && c != '_')

/*
 * The main program.
 */
int
main(int argc, char *argv[])
{
	int opt;

	while ((opt = getopt(argc, argv, "i:D:U:I:o:bBcdeKklnsStV")) != -1)
		switch (opt) {
		case 'i': /* treat stuff controlled by these symbols as text */
			/*
			 * For strict backwards-compatibility the U or D
			 * should be immediately after the -i but it doesn't
			 * matter much if we relax that requirement.
			 */
			opt = *optarg++;
			if (opt == 'D')
				addsym(true, true, optarg);
			else if (opt == 'U')
				addsym(true, false, optarg);
			else
				usage();
			break;
		case 'D': /* define a symbol */
			addsym(false, true, optarg);
			break;
		case 'U': /* undef a symbol */
			addsym(false, false, optarg);
			break;
		case 'I': /* no-op for compatibility with cpp */
			break;
		case 'b': /* blank deleted lines instead of omitting them */
		case 'l': /* backwards compatibility */
			lnblank = true;
			break;
		case 'B': /* compress blank lines around removed section */
			compblank = true;
			break;
		case 'c': /* treat -D as -U and vice versa */
			complement = true;
			break;
		case 'd':
			debugging = true;
			break;
		case 'e': /* fewer errors from dodgy lines */
			iocccok = true;
			break;
		case 'K': /* keep ambiguous #ifs */
			strictlogic = true;
			break;
		case 'k': /* process constant #ifs */
			killconsts = true;
			break;
		case 'n': /* add #line directive after deleted lines */
			lnnum = true;
			break;
		case 'o': /* output to a file */
			ofilename = optarg;
			break;
		case 's': /* only output list of symbols that control #ifs */
			symlist = true;
			break;
		case 'S': /* list symbols with their nesting depth */
			symlist = symdepth = true;
			break;
		case 't': /* don't parse C comments */
			text = true;
			break;
		case 'V': /* print version */
			version();
		default:
			usage();
		}
	argc -= optind;
	argv += optind;
	if (compblank && lnblank)
		errx(2, "-B and -b are mutually exclusive");
	if (argc > 1) {
		errx(2, "can only do one file");
	} else if (argc == 1 && strcmp(*argv, "-") != 0) {
		filename = *argv;
		input = fopen(filename, "rb");
		if (input == NULL)
			err(2, "can't open %s", filename);
	} else {
		filename = "[stdin]";
		input = stdin;
	}
	if (ofilename == NULL) {
		ofilename = "[stdout]";
		output = stdout;
	} else {
		struct stat ist, ost;
		if (stat(ofilename, &ost) == 0 &&
		    fstat(fileno(input), &ist) == 0)
			overwriting = (ist.st_dev == ost.st_dev
				    && ist.st_ino == ost.st_ino);
		if (overwriting) {
			const char *dirsep;
			int ofd;

			dirsep = strrchr(ofilename, '/');
			if (dirsep != NULL)
				snprintf(tempname, sizeof(tempname),
				    "%.*s/" TEMPLATE,
				    (int)(dirsep - ofilename), ofilename);
			else
				snprintf(tempname, sizeof(tempname),
				    TEMPLATE);
			ofd = mkstemp(tempname);
			if (ofd != -1)
				output = fdopen(ofd, "wb+");
			if (output == NULL)
				err(2, "can't create temporary file");
			fchmod(ofd, ist.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO));
		} else {
			output = fopen(ofilename, "wb");
			if (output == NULL)
				err(2, "can't open %s", ofilename);
		}
	}
	process();
	abort(); /* bug */
}

static void
version(void)
{
	const char *c = copyright;
	for (;;) {
		while (*++c != '$')
			if (*c == '\0')
				exit(0);
		while (*++c != '$')
			putc(*c, stderr);
		putc('\n', stderr);
	}
}

static void
usage(void)
{
	fprintf(stderr, "usage: unifdef [-bBcdeKknsStV] [-Ipath]"
	    " [-Dsym[=val]] [-Usym] [-iDsym[=val]] [-iUsym] ... [file]\n");
	exit(2);
}

/*
 * A state transition function alters the global #if processing state
 * in a particular way. The table below is indexed by the current
 * processing state and the type of the current line.
 *
 * Nesting is handled by keeping a stack of states; some transition
 * functions increase or decrease the depth. They also maintain the
 * ignore state on a stack. In some complicated cases they have to
 * alter the preprocessor directive, as follows.
 *
 * When we have processed a group that starts off with a known-false
 * #if/#elif sequence (which has therefore been deleted) followed by a
 * #elif that we don't understand and therefore must keep, we edit the
 * latter into a #if to keep the nesting correct. We use strncpy() to
 * overwrite the 4 byte token "elif" with "if  " without a '\0' byte.
 *
 * When we find a true #elif in a group, the following block will
 * always be kept and the rest of the sequence after the next #elif or
 * #else will be discarded. We edit the #elif into a #else and the
 * following directive to #endif since this has the desired behaviour.
 *
 * "Dodgy" directives are split across multiple lines, the most common
 * example being a multi-line comment hanging off the right of the
 * directive. We can handle them correctly only if there is no change
 * from printing to dropping (or vice versa) caused by that directive.
 * If the directive is the first of a group we have a choice between
 * failing with an error, or passing it through unchanged instead of
 * evaluating it. The latter is not the default to avoid questions from
 * users about unifdef unexpectedly leaving behind preprocessor directives.
 */
typedef void state_fn(void);

/* report an error */
static void Eelif (void) { error("Inappropriate #elif"); }
static void Eelse (void) { error("Inappropriate #else"); }
static void Eendif(void) { error("Inappropriate #endif"); }
static void Eeof  (void) { error("Premature EOF"); }
static void Eioccc(void) { error("Obfuscated preprocessor control line"); }
/* plain line handling */
static void print (void) { flushline(true); }
static void drop  (void) { flushline(false); }
/* output lacks group's start line */
static void Strue (void) { drop();  ignoreoff(); state(IS_TRUE_PREFIX); }
static void Sfalse(void) { drop();  ignoreoff(); state(IS_FALSE_PREFIX); }
static void Selse (void) { drop();               state(IS_TRUE_ELSE); }
/* print/pass this block */
static void Pelif (void) { print(); ignoreoff(); state(IS_PASS_MIDDLE); }
static void Pelse (void) { print();              state(IS_PASS_ELSE); }
static void Pendif(void) { print(); unnest(); }
/* discard this block */
static void Dfalse(void) { drop();  ignoreoff(); state(IS_FALSE_TRAILER); }
static void Delif (void) { drop();  ignoreoff(); state(IS_FALSE_MIDDLE); }
static void Delse (void) { drop();               state(IS_FALSE_ELSE); }
static void Dendif(void) { drop();  unnest(); }
/* first line of group */
static void Fdrop (void) { nest();  Dfalse(); }
static void Fpass (void) { nest();  Pelif(); }
static void Ftrue (void) { nest();  Strue(); }
static void Ffalse(void) { nest();  Sfalse(); }
/* variable pedantry for obfuscated lines */
static void Oiffy (void) { if (!iocccok) Eioccc(); Fpass(); ignoreon(); }
static void Oif   (void) { if (!iocccok) Eioccc(); Fpass(); }
static void Oelif (void) { if (!iocccok) Eioccc(); Pelif(); }
/* ignore comments in this block */
static void Idrop (void) { Fdrop();  ignoreon(); }
static void Itrue (void) { Ftrue();  ignoreon(); }
static void Ifalse(void) { Ffalse(); ignoreon(); }
/* modify this line */
static void Mpass (void) { strncpy(keyword, "if  ", 4); Pelif(); }
static void Mtrue (void) { keywordedit("else");  state(IS_TRUE_MIDDLE); }
static void Melif (void) { keywordedit("endif"); state(IS_FALSE_TRAILER); }
static void Melse (void) { keywordedit("endif"); state(IS_FALSE_ELSE); }

static state_fn * const trans_table[IS_COUNT][LT_COUNT] = {
/* IS_OUTSIDE */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Eendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Eendif,
  print, done,  abort },
/* IS_FALSE_PREFIX */
{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Mpass, Strue, Sfalse,Selse, Dendif,
  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Mpass, Eioccc,Eioccc,Eioccc,Eioccc,
  drop,  Eeof,  abort },
/* IS_TRUE_PREFIX */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Dfalse,Dfalse,Dfalse,Delse, Dendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eioccc,Eioccc,Eioccc,Eioccc,Eioccc,
  print, Eeof,  abort },
/* IS_PASS_MIDDLE */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Pelif, Mtrue, Delif, Pelse, Pendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Pelif, Oelif, Oelif, Pelse, Pendif,
  print, Eeof,  abort },
/* IS_FALSE_MIDDLE */
{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Pelif, Mtrue, Delif, Pelse, Pendif,
  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eioccc,Eioccc,Eioccc,Eioccc,Eioccc,
  drop,  Eeof,  abort },
/* IS_TRUE_MIDDLE */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Melif, Melif, Melif, Melse, Pendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eioccc,Eioccc,Eioccc,Eioccc,Pendif,
  print, Eeof,  abort },
/* IS_PASS_ELSE */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Pendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Pendif,
  print, Eeof,  abort },
/* IS_FALSE_ELSE */
{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eelif, Eelif, Eelif, Eelse, Dendif,
  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eelif, Eelif, Eelif, Eelse, Eioccc,
  drop,  Eeof,  abort },
/* IS_TRUE_ELSE */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Dendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Eioccc,
  print, Eeof,  abort },
/* IS_FALSE_TRAILER */
{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Dfalse,Dfalse,Dfalse,Delse, Dendif,
  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Dfalse,Dfalse,Dfalse,Delse, Eioccc,
  drop,  Eeof,  abort }
/*TRUEI  FALSEI IF     TRUE   FALSE  ELIF   ELTRUE ELFALSE ELSE  ENDIF
  TRUEI  FALSEI IF     TRUE   FALSE  ELIF   ELTRUE ELFALSE ELSE  ENDIF (DODGY)
  PLAIN  EOF    ERROR */
};

/*
 * State machine utility functions
 */
static void
ignoreoff(void)
{
	if (depth == 0)
		abort(); /* bug */
	ignoring[depth] = ignoring[depth-1];
}
static void
ignoreon(void)
{
	ignoring[depth] = true;
}
static void
keywordedit(const char *replacement)
{
	snprintf(keyword, tline + sizeof(tline) - keyword,
	    "%s%s", replacement, newline);
	print();
}
static void
nest(void)
{
	if (depth > MAXDEPTH-1)
		abort(); /* bug */
	if (depth == MAXDEPTH-1)
		error("Too many levels of nesting");
	depth += 1;
	stifline[depth] = linenum;
}
static void
unnest(void)
{
	if (depth == 0)
		abort(); /* bug */
	depth -= 1;
}
static void
state(Ifstate is)
{
	ifstate[depth] = is;
}

/*
 * Write a line to the output or not, according to command line options.
 */
static void
flushline(bool keep)
{
	if (symlist)
		return;
	if (keep ^ complement) {
		bool blankline = tline[strspn(tline, " \t\r\n")] == '\0';
		if (blankline && compblank && blankcount != blankmax) {
			delcount += 1;
			blankcount += 1;
		} else {
			if (lnnum && delcount > 0)
				printf("#line %d%s", linenum, newline);
			fputs(tline, output);
			delcount = 0;
			blankmax = blankcount = blankline ? blankcount + 1 : 0;
		}
	} else {
		if (lnblank)
			fputs(newline, output);
		exitstat = 1;
		delcount += 1;
		blankcount = 0;
	}
	if (debugging)
		fflush(output);
}

/*
 * The driver for the state machine.
 */
static void
process(void)
{
	/* When compressing blank lines, act as if the file
	   is preceded by a large number of blank lines. */
	blankmax = blankcount = 1000;
	for (;;) {
		Linetype lineval = parseline();
		trans_table[ifstate[depth]][lineval]();
		debug("process line %d %s -> %s depth %d",
		    linenum, linetype_name[lineval],
		    ifstate_name[ifstate[depth]], depth);
	}
}

/*
 * Flush the output and handle errors.
 */
static void
closeout(void)
{
	if (symdepth && !zerosyms)
		printf("\n");
	if (fclose(output) == EOF) {
		warn("couldn't write to %s", ofilename);
		if (overwriting) {
			unlink(tempname);
			errx(2, "%s unchanged", filename);
		} else {
			exit(2);
		}
	}
}

/*
 * Clean up and exit.
 */
static void
done(void)
{
	if (incomment)
		error("EOF in comment");
	closeout();
	if (overwriting && rename(tempname, ofilename) == -1) {
		warn("couldn't rename temporary file");
		unlink(tempname);
		errx(2, "%s unchanged", ofilename);
	}
	exit(exitstat);
}

/*
 * Parse a line and determine its type. We keep the preprocessor line
 * parser state between calls in the global variable linestate, with
 * help from skipcomment().
 */
static Linetype
parseline(void)
{
	const char *cp;
	int cursym;
	int kwlen;
	Linetype retval;
	Comment_state wascomment;

	linenum++;
	if (fgets(tline, MAXLINE, input) == NULL)
		return (LT_EOF);
	if (newline == NULL) {
		if (strrchr(tline, '\n') == strrchr(tline, '\r') + 1)
			newline = newline_crlf;
		else
			newline = newline_unix;
	}
	retval = LT_PLAIN;
	wascomment = incomment;
	cp = skipcomment(tline);
	if (linestate == LS_START) {
		if (*cp == '#') {
			linestate = LS_HASH;
			firstsym = true;
			cp = skipcomment(cp + 1);
		} else if (*cp != '\0')
			linestate = LS_DIRTY;
	}
	if (!incomment && linestate == LS_HASH) {
		keyword = tline + (cp - tline);
		cp = skipsym(cp);
		kwlen = cp - keyword;
		/* no way can we deal with a continuation inside a keyword */
		if (strncmp(cp, "\\\r\n", 3) == 0 ||
		    strncmp(cp, "\\\n", 2) == 0)
			Eioccc();
		if (strlcmp("ifdef", keyword, kwlen) == 0 ||
		    strlcmp("ifndef", keyword, kwlen) == 0) {
			cp = skipcomment(cp);
			if ((cursym = findsym(cp)) < 0)
				retval = LT_IF;
			else {
				retval = (keyword[2] == 'n')
				    ? LT_FALSE : LT_TRUE;
				if (value[cursym] == NULL)
					retval = (retval == LT_TRUE)
					    ? LT_FALSE : LT_TRUE;
				if (ignore[cursym])
					retval = (retval == LT_TRUE)
					    ? LT_TRUEI : LT_FALSEI;
			}
			cp = skipsym(cp);
		} else if (strlcmp("if", keyword, kwlen) == 0)
			retval = ifeval(&cp);
		else if (strlcmp("elif", keyword, kwlen) == 0)
			retval = ifeval(&cp) - LT_IF + LT_ELIF;
		else if (strlcmp("else", keyword, kwlen) == 0)
			retval = LT_ELSE;
		else if (strlcmp("endif", keyword, kwlen) == 0)
			retval = LT_ENDIF;
		else {
			linestate = LS_DIRTY;
			retval = LT_PLAIN;
		}
		cp = skipcomment(cp);
		if (*cp != '\0') {
			linestate = LS_DIRTY;
			if (retval == LT_TRUE || retval == LT_FALSE ||
			    retval == LT_TRUEI || retval == LT_FALSEI)
				retval = LT_IF;
			if (retval == LT_ELTRUE || retval == LT_ELFALSE)
				retval = LT_ELIF;
		}
		if (retval != LT_PLAIN && (wascomment || incomment)) {
			retval += LT_DODGY;
			if (incomment)
				linestate = LS_DIRTY;
		}
		/* skipcomment normally changes the state, except
		   if the last line of the file lacks a newline, or
		   if there is too much whitespace in a directive */
		if (linestate == LS_HASH) {
			size_t len = cp - tline;
			if (fgets(tline + len, MAXLINE - len, input) == NULL) {
				/* append the missing newline */
				strcpy(tline + len, newline);
				cp += strlen(newline);
				linestate = LS_START;
			} else {
				linestate = LS_DIRTY;
			}
		}
	}
	if (linestate == LS_DIRTY) {
		while (*cp != '\0')
			cp = skipcomment(cp + 1);
	}
	debug("parser line %d state %s comment %s line", linenum,
	    comment_name[incomment], linestate_name[linestate]);
	return (retval);
}

/*
 * These are the binary operators that are supported by the expression
 * evaluator.
 */
static Linetype op_strict(int *p, int v, Linetype at, Linetype bt) {
	if(at == LT_IF || bt == LT_IF) return (LT_IF);
	return (*p = v, v ? LT_TRUE : LT_FALSE);
}
static Linetype op_lt(int *p, Linetype at, int a, Linetype bt, int b) {
	return op_strict(p, a < b, at, bt);
}
static Linetype op_gt(int *p, Linetype at, int a, Linetype bt, int b) {
	return op_strict(p, a > b, at, bt);
}
static Linetype op_le(int *p, Linetype at, int a, Linetype bt, int b) {
	return op_strict(p, a <= b, at, bt);
}
static Linetype op_ge(int *p, Linetype at, int a, Linetype bt, int b) {
	return op_strict(p, a >= b, at, bt);
}
static Linetype op_eq(int *p, Linetype at, int a, Linetype bt, int b) {
	return op_strict(p, a == b, at, bt);
}
static Linetype op_ne(int *p, Linetype at, int a, Linetype bt, int b) {
	return op_strict(p, a != b, at, bt);
}
static Linetype op_or(int *p, Linetype at, int a, Linetype bt, int b) {
	if (!strictlogic && (at == LT_TRUE || bt == LT_TRUE))
		return (*p = 1, LT_TRUE);
	return op_strict(p, a || b, at, bt);
}
static Linetype op_and(int *p, Linetype at, int a, Linetype bt, int b) {
	if (!strictlogic && (at == LT_FALSE || bt == LT_FALSE))
		return (*p = 0, LT_FALSE);
	return op_strict(p, a && b, at, bt);
}

/*
 * An evaluation function takes three arguments, as follows: (1) a pointer to
 * an element of the precedence table which lists the operators at the current
 * level of precedence; (2) a pointer to an integer which will receive the
 * value of the expression; and (3) a pointer to a char* that points to the
 * expression to be evaluated and that is updated to the end of the expression
 * when evaluation is complete. The function returns LT_FALSE if the value of
 * the expression is zero, LT_TRUE if it is non-zero, LT_IF if the expression
 * depends on an unknown symbol, or LT_ERROR if there is a parse failure.
 */
struct ops;

typedef Linetype eval_fn(const struct ops *, int *, const char **);

static eval_fn eval_table, eval_unary;

/*
 * The precedence table. Expressions involving binary operators are evaluated
 * in a table-driven way by eval_table. When it evaluates a subexpression it
 * calls the inner function with its first argument pointing to the next
 * element of the table. Innermost expressions have special non-table-driven
 * handling.
 */
static const struct ops {
	eval_fn *inner;
	struct op {
		const char *str;
		Linetype (*fn)(int *, Linetype, int, Linetype, int);
	} op[5];
} eval_ops[] = {
	{ eval_table, { { "||", op_or } } },
	{ eval_table, { { "&&", op_and } } },
	{ eval_table, { { "==", op_eq },
			{ "!=", op_ne } } },
	{ eval_unary, { { "<=", op_le },
			{ ">=", op_ge },
			{ "<", op_lt },
			{ ">", op_gt } } }
};

/*
 * Function for evaluating the innermost parts of expressions,
 * viz. !expr (expr) number defined(symbol) symbol
 * We reset the constexpr flag in the last two cases.
 */
static Linetype
eval_unary(const struct ops *ops, int *valp, const char **cpp)
{
	const char *cp;
	char *ep;
	int sym;
	bool defparen;
	Linetype lt;

	cp = skipcomment(*cpp);
	if (*cp == '!') {
		debug("eval%d !", ops - eval_ops);
		cp++;
		lt = eval_unary(ops, valp, &cp);
		if (lt == LT_ERROR)
			return (LT_ERROR);
		if (lt != LT_IF) {
			*valp = !*valp;
			lt = *valp ? LT_TRUE : LT_FALSE;
		}
	} else if (*cp == '(') {
		cp++;
		debug("eval%d (", ops - eval_ops);
		lt = eval_table(eval_ops, valp, &cp);
		if (lt == LT_ERROR)
			return (LT_ERROR);
		cp = skipcomment(cp);
		if (*cp++ != ')')
			return (LT_ERROR);
	} else if (isdigit((unsigned char)*cp)) {
		debug("eval%d number", ops - eval_ops);
		*valp = strtol(cp, &ep, 0);
		if (ep == cp)
			return (LT_ERROR);
		lt = *valp ? LT_TRUE : LT_FALSE;
		cp = skipsym(cp);
	} else if (strncmp(cp, "defined", 7) == 0 && endsym(cp[7])) {
		cp = skipcomment(cp+7);
		debug("eval%d defined", ops - eval_ops);
		if (*cp == '(') {
			cp = skipcomment(cp+1);
			defparen = true;
		} else {
			defparen = false;
		}
		sym = findsym(cp);
		if (sym < 0) {
			lt = LT_IF;
		} else {
			*valp = (value[sym] != NULL);
			lt = *valp ? LT_TRUE : LT_FALSE;
		}
		cp = skipsym(cp);
		cp = skipcomment(cp);
		if (defparen && *cp++ != ')')
			return (LT_ERROR);
		constexpr = false;
	} else if (!endsym(*cp)) {
		debug("eval%d symbol", ops - eval_ops);
		sym = findsym(cp);
		cp = skipsym(cp);
		if (sym < 0) {
			lt = LT_IF;
			cp = skipargs(cp);
		} else if (value[sym] == NULL) {
			*valp = 0;
			lt = LT_FALSE;
		} else {
			*valp = strtol(value[sym], &ep, 0);
			if (*ep != '\0' || ep == value[sym])
				return (LT_ERROR);
			lt = *valp ? LT_TRUE : LT_FALSE;
			cp = skipargs(cp);
		}
		constexpr = false;
	} else {
		debug("eval%d bad expr", ops - eval_ops);
		return (LT_ERROR);
	}

	*cpp = cp;
	debug("eval%d = %d", ops - eval_ops, *valp);
	return (lt);
}

/*
 * Table-driven evaluation of binary operators.
 */
static Linetype
eval_table(const struct ops *ops, int *valp, const char **cpp)
{
	const struct op *op;
	const char *cp;
	int val;
	Linetype lt, rt;

	debug("eval%d", ops - eval_ops);
	cp = *cpp;
	lt = ops->inner(ops+1, valp, &cp);
	if (lt == LT_ERROR)
		return (LT_ERROR);
	for (;;) {
		cp = skipcomment(cp);
		for (op = ops->op; op->str != NULL; op++)
			if (strncmp(cp, op->str, strlen(op->str)) == 0)
				break;
		if (op->str == NULL)
			break;
		cp += strlen(op->str);
		debug("eval%d %s", ops - eval_ops, op->str);
		rt = ops->inner(ops+1, &val, &cp);
		if (rt == LT_ERROR)
			return (LT_ERROR);
		lt = op->fn(valp, lt, *valp, rt, val);
	}

	*cpp = cp;
	debug("eval%d = %d", ops - eval_ops, *valp);
	debug("eval%d lt = %s", ops - eval_ops, linetype_name[lt]);
	return (lt);
}

/*
 * Evaluate the expression on a #if or #elif line. If we can work out
 * the result we return LT_TRUE or LT_FALSE accordingly, otherwise we
 * return just a generic LT_IF.
 */
static Linetype
ifeval(const char **cpp)
{
	int ret;
	int val = 0;

	debug("eval %s", *cpp);
	constexpr = killconsts ? false : true;
	ret = eval_table(eval_ops, &val, cpp);
	debug("eval = %d", val);
	return (constexpr ? LT_IF : ret == LT_ERROR ? LT_IF : ret);
}

/*
 * Skip over comments, strings, and character literals and stop at the
 * next character position that is not whitespace. Between calls we keep
 * the comment state in the global variable incomment, and we also adjust
 * the global variable linestate when we see a newline.
 * XXX: doesn't cope with the buffer splitting inside a state transition.
 */
static const char *
skipcomment(const char *cp)
{
	if (text || ignoring[depth]) {
		for (; isspace((unsigned char)*cp); cp++)
			if (*cp == '\n')
				linestate = LS_START;
		return (cp);
	}
	while (*cp != '\0')
		/* don't reset to LS_START after a line continuation */
		if (strncmp(cp, "\\\r\n", 3) == 0)
			cp += 3;
		else if (strncmp(cp, "\\\n", 2) == 0)
			cp += 2;
		else switch (incomment) {
		case NO_COMMENT:
			if (strncmp(cp, "/\\\r\n", 4) == 0) {
				incomment = STARTING_COMMENT;
				cp += 4;
			} else if (strncmp(cp, "/\\\n", 3) == 0) {
				incomment = STARTING_COMMENT;
				cp += 3;
			} else if (strncmp(cp, "/*", 2) == 0) {
				incomment = C_COMMENT;
				cp += 2;
			} else if (strncmp(cp, "//", 2) == 0) {
				incomment = CXX_COMMENT;
				cp += 2;
			} else if (strncmp(cp, "\'", 1) == 0) {
				incomment = CHAR_LITERAL;
				linestate = LS_DIRTY;
				cp += 1;
			} else if (strncmp(cp, "\"", 1) == 0) {
				incomment = STRING_LITERAL;
				linestate = LS_DIRTY;
				cp += 1;
			} else if (strncmp(cp, "\n", 1) == 0) {
				linestate = LS_START;
				cp += 1;
			} else if (strchr(" \r\t", *cp) != NULL) {
				cp += 1;
			} else
				return (cp);
			continue;
		case CXX_COMMENT:
			if (strncmp(cp, "\n", 1) == 0) {
				incomment = NO_COMMENT;
				linestate = LS_START;
			}
			cp += 1;
			continue;
		case CHAR_LITERAL:
		case STRING_LITERAL:
			if ((incomment == CHAR_LITERAL && cp[0] == '\'') ||
			    (incomment == STRING_LITERAL && cp[0] == '\"')) {
				incomment = NO_COMMENT;
				cp += 1;
			} else if (cp[0] == '\\') {
				if (cp[1] == '\0')
					cp += 1;
				else
					cp += 2;
			} else if (strncmp(cp, "\n", 1) == 0) {
				if (incomment == CHAR_LITERAL)
					error("unterminated char literal");
				else
					error("unterminated string literal");
			} else
				cp += 1;
			continue;
		case C_COMMENT:
			if (strncmp(cp, "*\\\r\n", 4) == 0) {
				incomment = FINISHING_COMMENT;
				cp += 4;
			} else if (strncmp(cp, "*\\\n", 3) == 0) {
				incomment = FINISHING_COMMENT;
				cp += 3;
			} else if (strncmp(cp, "*/", 2) == 0) {
				incomment = NO_COMMENT;
				cp += 2;
			} else
				cp += 1;
			continue;
		case STARTING_COMMENT:
			if (*cp == '*') {
				incomment = C_COMMENT;
				cp += 1;
			} else if (*cp == '/') {
				incomment = CXX_COMMENT;
				cp += 1;
			} else {
				incomment = NO_COMMENT;
				linestate = LS_DIRTY;
			}
			continue;
		case FINISHING_COMMENT:
			if (*cp == '/') {
				incomment = NO_COMMENT;
				cp += 1;
			} else
				incomment = C_COMMENT;
			continue;
		default:
			abort(); /* bug */
		}
	return (cp);
}

/*
 * Skip macro arguments.
 */
static const char *
skipargs(const char *cp)
{
	const char *ocp = cp;
	int level = 0;
	cp = skipcomment(cp);
	if (*cp != '(')
		return (cp);
	do {
		if (*cp == '(')
			level++;
		if (*cp == ')')
			level--;
		cp = skipcomment(cp+1);
	} while (level != 0 && *cp != '\0');
	if (level == 0)
		return (cp);
	else
	/* Rewind and re-detect the syntax error later. */
		return (ocp);
}

/*
 * Skip over an identifier.
 */
static const char *
skipsym(const char *cp)
{
	while (!endsym(*cp))
		++cp;
	return (cp);
}

/*
 * Look for the symbol in the symbol table. If it is found, we return
 * the symbol table index, else we return -1.
 */
static int
findsym(const char *str)
{
	const char *cp;
	int symind;

	cp = skipsym(str);
	if (cp == str)
		return (-1);
	if (symlist) {
		if (symdepth && firstsym)
			printf("%s%3d", zerosyms ? "" : "\n", depth);
		firstsym = zerosyms = false;
		printf("%s%.*s%s",
		    symdepth ? " " : "",
		    (int)(cp-str), str,
		    symdepth ? "" : "\n");
		/* we don't care about the value of the symbol */
		return (0);
	}
	for (symind = 0; symind < nsyms; ++symind) {
		if (strlcmp(symname[symind], str, cp-str) == 0) {
			debug("findsym %s %s", symname[symind],
			    value[symind] ? value[symind] : "");
			return (symind);
		}
	}
	return (-1);
}

/*
 * Add a symbol to the symbol table.
 */
static void
addsym(bool ignorethis, bool definethis, char *sym)
{
	int symind;
	char *val;

	symind = findsym(sym);
	if (symind < 0) {
		if (nsyms >= MAXSYMS)
			errx(2, "too many symbols");
		symind = nsyms++;
	}
	symname[symind] = sym;
	ignore[symind] = ignorethis;
	val = sym + (skipsym(sym) - sym);
	if (definethis) {
		if (*val == '=') {
			value[symind] = val+1;
			*val = '\0';
		} else if (*val == '\0')
			value[symind] = "1";
		else
			usage();
	} else {
		if (*val != '\0')
			usage();
		value[symind] = NULL;
	}
	debug("addsym %s=%s", symname[symind],
	    value[symind] ? value[symind] : "undef");
}

/*
 * Compare s with n characters of t.
 * The same as strncmp() except that it checks that s[n] == '\0'.
 */
static int
strlcmp(const char *s, const char *t, size_t n)
{
	while (n-- && *t != '\0')
		if (*s != *t)
			return ((unsigned char)*s - (unsigned char)*t);
		else
			++s, ++t;
	return ((unsigned char)*s);
}

/*
 * Diagnostics.
 */
static void
debug(const char *msg, ...)
{
	va_list ap;

	if (debugging) {
		va_start(ap, msg);
		vwarnx(msg, ap);
		va_end(ap);
	}
}

static void
error(const char *msg)
{
	if (depth == 0)
		warnx("%s: %d: %s", filename, linenum, msg);
	else
		warnx("%s: %d: %s (#if line %d depth %d)",
		    filename, linenum, msg, stifline[depth], depth);
	closeout();
	errx(2, "output may be truncated");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #!/bin/sh
# Test for gcc 'asm goto' support
# Copyright (C) 2010, Jason Baron <jbaron@redhat.com>

cat << "END" | $@ -x c - -c -o /dev/null >/dev/null 2>&1 && echo "y"
int main(void)
{
#if defined(__arm__) || defined(__aarch64__)
	/*
	 * Not related to asm goto, but used by jump label
	 * and broken on some ARM GCC versions (see GCC Bug 48637).
	 */
	static struct { int dummy; int state; } tp;
	asm (".long %c0" :: "i" (&tp.state));
#endif

entry:
	asm goto ("" :::: entry);
	return 0;
}
END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #!/bin/sh

echo "int foo(void) { char X[200]; return 3; }" | $* -S -x c -c -O0 -fstack-protector - -o - 2> /dev/null | grep -q "%gs"
if [ "$?" -eq "0" ] ; then
	echo y
else
	echo n
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ###
# scripts contains sources for various helper programs used throughout
# the kernel for the build process.
# ---------------------------------------------------------------------------
# kallsyms:      Find all symbols in vmlinux
# pnmttologo:    Convert pnm files to logo files
# conmakehash:   Create chartable
# conmakehash:	 Create arrays for initializing the kernel console tables
# docproc:       Used in Documentation/DocBook

HOST_EXTRACFLAGS += -I$(srctree)/tools/include

hostprogs-$(CONFIG_KALLSYMS)     += kallsyms
hostprogs-$(CONFIG_LOGO)         += pnmtologo
hostprogs-$(CONFIG_VT)           += conmakehash
hostprogs-$(BUILD_C_RECORDMCOUNT) += recordmcount
hostprogs-$(CONFIG_BUILDTIME_EXTABLE_SORT) += sortextable
hostprogs-$(CONFIG_ASN1)	 += asn1_compiler

HOSTCFLAGS_sortextable.o = -I$(srctree)/tools/include
HOSTCFLAGS_asn1_compiler.o = -I$(srctree)/include

always		:= $(hostprogs-y) $(hostprogs-m)

# The following hostprogs-y programs are only build on demand
hostprogs-y += unifdef docproc

# These targets are used internally to avoid "is up to date" messages
PHONY += build_unifdef build_docproc
build_unifdef: $(obj)/unifdef
	@:
build_docproc: $(obj)/docproc
	@:

subdir-$(CONFIG_MODVERSIONS) += genksyms
subdir-y                     += mod
subdir-$(CONFIG_SECURITY_SELINUX) += selinux
subdir-$(CONFIG_DTC)         += dtc
subdir-$(CONFIG_GDB_SCRIPTS) += gdb

# Let clean descend into subdirs
subdir-	+= basic kconfig package
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #!/usr/bin/perl -w
#
# Clean a text file -- or directory of text files -- of stealth whitespace.
# WARNING: this can be a highly destructive operation.  Use with caution.
#

use bytes;
use File::Basename;

# Default options
$max_width = 79;

# Clean up space-tab sequences, either by removing spaces or
# replacing them with tabs.
sub clean_space_tabs($)
{
    no bytes;			# Tab alignment depends on characters

    my($li) = @_;
    my($lo) = '';
    my $pos = 0;
    my $nsp = 0;
    my($i, $c);

    for ($i = 0; $i < length($li); $i++) {
	$c = substr($li, $i, 1);
	if ($c eq "\t") {
	    my $npos = ($pos+$nsp+8) & ~7;
	    my $ntab = ($npos >> 3) - ($pos >> 3);
	    $lo .= "\t" x $ntab;
	    $pos = $npos;
	    $nsp = 0;
	} elsif ($c eq "\n" || $c eq "\r") {
	    $lo .= " " x $nsp;
	    $pos += $nsp;
	    $nsp = 0;
	    $lo .= $c;
	    $pos = 0;
	} elsif ($c eq " ") {
	    $nsp++;
	} else {
	    $lo .= " " x $nsp;
	    $pos += $nsp;
	    $nsp = 0;
	    $lo .= $c;
	    $pos++;
	}
    }
    $lo .= " " x $nsp;
    return $lo;
}

# Compute the visual width of a string
sub strwidth($) {
    no bytes;			# Tab alignment depends on characters

    my($li) = @_;
    my($c, $i);
    my $pos = 0;
    my $mlen = 0;

    for ($i = 0; $i < length($li); $i++) {
	$c = substr($li,$i,1);
	if ($c eq "\t") {
	    $pos = ($pos+8) & ~7;
	} elsif ($c eq "\n") {
	    $mlen = $pos if ($pos > $mlen);
	    $pos = 0;
	} else {
	    $pos++;
	}
    }

    $mlen = $pos if ($pos > $mlen);
    return $mlen;
}

$name = basename($0);

@files = ();

while (defined($a = shift(@ARGV))) {
    if ($a =~ /^-/) {
	if ($a eq '-width' || $a eq '-w') {
	    $max_width = shift(@ARGV)+0;
	} else {
	    print STDERR "Usage: $name [-width #] files...\n";
	    exit 1;
	}
    } else {
	push(@files, $a);
    }
}

foreach $f ( @files ) {
    print STDERR "$name: $f\n";

    if (! -f $f) {
	print STDERR "$f: not a file\n";
	next;
    }

    if (!open(FILE, '+<', $f)) {
	print STDERR "$name: Cannot open file: $f: $!\n";
	next;
    }

    binmode FILE;

    # First, verify that it is not a binary file; consider any file
    # with a zero byte to be a binary file.  Is there any better, or
    # additional, heuristic that should be applied?
    $is_binary = 0;

    while (read(FILE, $data, 65536) > 0) {
	if ($data =~ /\0/) {
	    $is_binary = 1;
	    last;
	}
    }

    if ($is_binary) {
	print STDERR "$name: $f: binary file\n";
	next;
    }

    seek(FILE, 0, 0);

    $in_bytes = 0;
    $out_bytes = 0;
    $blank_bytes = 0;

    @blanks = ();
    @lines  = ();
    $lineno = 0;

    while ( defined($line = <FILE>) ) {
	$lineno++;
	$in_bytes += length($line);
	$line =~ s/[ \t\r]*$//;		# Remove trailing spaces
	$line = clean_space_tabs($line);

	if ( $line eq "\n" ) {
	    push(@blanks, $line);
	    $blank_bytes += length($line);
	} else {
	    push(@lines, @blanks);
	    $out_bytes += $blank_bytes;
	    push(@lines, $line);
	    $out_bytes += length($line);
	    @blanks = ();
	    $blank_bytes = 0;
	}

	$l_width = strwidth($line);
	if ($max_width && $l_width > $max_width) {
	    print STDERR
		"$f:$lineno: line exceeds $max_width characters ($l_width)\n";
	}
    }

    # Any blanks at the end of the file are discarded

    if ($in_bytes != $out_bytes) {
	# Only write to the file if changed
	seek(FILE, 0, 0);
	print FILE @lines;

	if ( !defined($where = tell(FILE)) ||
	     !truncate(FILE, $where) ) {
	    die "$name: Failed to truncate modified file: $f: $!\n";
	}
    }

    close(FILE);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # ==========================================================================
# Installing firmware
#
# We don't include the .config, so all firmware files are in $(fw-shipped-)
# rather than in $(fw-shipped-y) or $(fw-shipped-m).
# ==========================================================================

INSTALL := install
src := $(obj)

# For modules_install installing firmware, we want to see .config
# But for firmware_install, we don't care, but don't want to require it.
-include $(objtree)/.config

include scripts/Kbuild.include
include $(src)/Makefile

include scripts/Makefile.host

mod-fw := $(fw-shipped-m)
# If CONFIG_FIRMWARE_IN_KERNEL isn't set, then install the
# firmware for in-kernel drivers too.
ifndef CONFIG_FIRMWARE_IN_KERNEL
mod-fw += $(fw-shipped-y)
endif

ifneq ($(KBUILD_SRC),)
# Create output directory if not already present
_dummy := $(shell [ -d $(obj) ] || mkdir -p $(obj))

firmware-dirs := $(sort $(addprefix $(objtree)/$(obj)/,$(dir $(fw-external-y) $(fw-shipped-all))))
# Create directories for firmware in subdirectories
_dummy := $(foreach d,$(firmware-dirs), $(shell [ -d $(d) ] || mkdir -p $(d)))
endif

installed-mod-fw := $(addprefix $(INSTALL_FW_PATH)/,$(mod-fw))

installed-fw := $(addprefix $(INSTALL_FW_PATH)/,$(fw-shipped-all))

quiet_cmd_install = INSTALL $(subst $(srctree)/,,$@)
      cmd_install = mkdir -p $(@D); $(INSTALL) -m0644 $< $@

$(installed-fw): $(INSTALL_FW_PATH)/%: $(obj)/%
	$(call cmd,install)

PHONY +=  __fw_install __fw_modinst FORCE

.PHONY: $(PHONY)

__fw_install: $(installed-fw)

__fw_modinst: $(installed-mod-fw)
	@:

__fw_modbuild: $(addprefix $(obj)/,$(mod-fw))
	@:

FORCE:

# Read all saved command lines and dependencies for the $(targets) we
# may be building using $(if_changed{,_dep}). As an optimization, we
# don't need to read them if the target does not exist; we will rebuild
# anyway in that case.

targets := $(wildcard $(sort $(targets)))
cmd_files := $(wildcard $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))

ifneq ($(cmd_files),)
  include $(cmd_files)
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #!/usr/bin/env perl
# ----------------------------------------------------------------------
# knlinfo by Phil Elwell for Raspberry Pi
#
# (c) 2014,2015 Raspberry Pi (Trading) Limited <info@raspberrypi.org>
#
# Licensed under the terms of the GNU General Public License.
# ----------------------------------------------------------------------

use strict;
use integer;

use Fcntl ":seek";

my $trailer_magic = 'RPTL';

my %atom_formats =
(
    'DTOK' => \&format_bool,
    'KVer' => \&format_string,
    '283x' => \&format_bool,
);

if (@ARGV != 1)
{
	print ("Usage: knlinfo <kernel image>\n");
	exit(1);
}

my $kernel_file = $ARGV[0];


my ($atoms, $pos) = read_trailer($kernel_file);

exit(1) if (!$atoms);

printf("Kernel trailer found at %d/0x%x:\n", $pos, $pos);

foreach my $atom (@$atoms)
{
    printf("  %s: %s\n", $atom->[0], format_atom($atom));
}

exit(0);

sub read_trailer
{
	my ($kernel_file) = @_;
	my $fh;

	if (!open($fh, '<', $kernel_file))
	{
		print ("* Failed to open '$kernel_file'\n");
		return undef;
	}

	if (!seek($fh, -12, SEEK_END))
	{
		print ("* seek error in '$kernel_file'\n");
		return undef;
	}

	my $last_bytes;
	sysread($fh, $last_bytes, 12);

	my ($trailer_len, $data_len, $magic) = unpack('VVa4', $last_bytes);

	if (($magic ne $trailer_magic) || ($data_len != 4))
	{
		print ("* no trailer\n");
		return undef;
	}
	if (!seek($fh, -12, SEEK_END))
	{
		print ("* seek error in '$kernel_file'\n");
		return undef;
	}

	$trailer_len -= 12;

	while ($trailer_len > 0)
	{
		if ($trailer_len < 8)
		{
			print ("* truncated atom header in trailer\n");
			return undef;
		}
		if (!seek($fh, -8, SEEK_CUR))
		{
			print ("* seek error in '$kernel_file'\n");
			return undef;
		}
		$trailer_len -= 8;

		my $atom_hdr;
		sysread($fh, $atom_hdr, 8);
		my ($atom_len, $atom_type) = unpack('Va4', $atom_hdr);

		if ($trailer_len < $atom_len)
		{
			print ("* truncated atom data in trailer\n");
			return undef;
		}

		my $rounded_len = (($atom_len + 3) & ~3);
		if (!seek($fh, -(8 + $rounded_len), SEEK_CUR))
		{
			print ("* seek error in '$kernel_file'\n");
			return undef;
		}
		$trailer_len -= $rounded_len;

		my $atom_data;
		sysread($fh, $atom_data, $atom_len);

		if (!seek($fh, -$atom_len, SEEK_CUR))
		{
			print ("* seek error in '$kernel_file'\n");
			return undef;
		}

		push @$atoms, [ $atom_type, $atom_data ];
	}

 	if (($$atoms[-1][0] eq "\x00\x00\x00\x00") &&
	    ($$atoms[-1][1] eq ""))
	{
		pop @$atoms;
	}
	else
	{
		print ("* end marker missing from trailer\n");
	}

	return ($atoms, tell($fh));
}

sub format_atom
{
    my ($atom) = @_;

    my $format_func = $atom_formats{$atom->[0]} || \&format_hex;
    return $format_func->($atom->[1]);
}

sub format_bool
{
    my ($data) = @_;
    return unpack('V', $data) ? 'true' : 'false';
}

sub format_int
{
    my ($data) = @_;
    return unpack('V', $data);
}

sub format_string
{
    my ($data) = @_;
    return '"'.$data.'"';
}

sub format_hex
{
    my ($data) = @_;
    return unpack('H*', $data);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #!/usr/bin/awk -f
# extract linker version number from stdin and turn into single number
	{
	gsub(".*\\)", "");
	split($1,a, ".");
	print a[1]*10000000 + a[2]*100000 + a[3]*10000 + a[4]*100 + a[5];
	exit
	}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #!/usr/bin/python
#
# diffconfig - a tool to compare .config files.
#
# originally written in 2006 by Matt Mackall
#  (at least, this was in his bloatwatch source code)
# last worked on 2008 by Tim Bird
#

import sys, os

def usage():
    print("""Usage: diffconfig [-h] [-m] [<config1> <config2>]

Diffconfig is a simple utility for comparing two .config files.
Using standard diff to compare .config files often includes extraneous and
distracting information.  This utility produces sorted output with only the
changes in configuration values between the two files.

Added and removed items are shown with a leading plus or minus, respectively.
Changed items show the old and new values on a single line.

If -m is specified, then output will be in "merge" style, which has the
changed and new values in kernel config option format.

If no config files are specified, .config and .config.old are used.

Example usage:
 $ diffconfig .config config-with-some-changes
-EXT2_FS_XATTR  n
 CRAMFS  n -> y
 EXT2_FS  y -> n
 LOG_BUF_SHIFT  14 -> 16
 PRINTK_TIME  n -> y
""")
    sys.exit(0)

# returns a dictionary of name/value pairs for config items in the file
def readconfig(config_file):
    d = {}
    for line in config_file:
        line = line[:-1]
        if line[:7] == "CONFIG_":
            name, val = line[7:].split("=", 1)
            d[name] = val
        if line[-11:] == " is not set":
            d[line[9:-11]] = "n"
    return d

def print_config(op, config, value, new_value):
    global merge_style

    if merge_style:
        if new_value:
            if new_value=="n":
                print("# CONFIG_%s is not set" % config)
            else:
                print("CONFIG_%s=%s" % (config, new_value))
    else:
        if op=="-":
            print("-%s %s" % (config, value))
        elif op=="+":
            print("+%s %s" % (config, new_value))
        else:
            print(" %s %s -> %s" % (config, value, new_value))

def main():
    global merge_style

    # parse command line args
    if ("-h" in sys.argv or "--help" in sys.argv):
        usage()

    merge_style = 0
    if "-m" in sys.argv:
        merge_style = 1
        sys.argv.remove("-m")

    argc = len(sys.argv)
    if not (argc==1 or argc == 3):
        print("Error: incorrect number of arguments or unrecognized option")
        usage()

    if argc == 1:
        # if no filenames given, assume .config and .config.old
        build_dir=""
        if "KBUILD_OUTPUT" in os.environ:
            build_dir = os.environ["KBUILD_OUTPUT"]+"/"
        configa_filename = build_dir + ".config.old"
        configb_filename = build_dir + ".config"
    else:
        configa_filename = sys.argv[1]
        configb_filename = sys.argv[2]

    try:
        a = readconfig(open(configa_filename))
        b = readconfig(open(configb_filename))
    except (IOError):
        e = sys.exc_info()[1]
        print("I/O error[%s]: %s\n" % (e.args[0],e.args[1]))
        usage()

    # print items in a but not b (accumulate, sort and print)
    old = []
    for config in a:
        if config not in b:
            old.append(config)
    old.sort()
    for config in old:
        print_config("-", config, a[config], None)
        del a[config]

    # print items that changed (accumulate, sort, and print)
    changed = []
    for config in a:
        if a[config] != b[config]:
            changed.append(config)
        else:
            del b[config]
    changed.sort()
    for config in changed:
        print_config("->", config, a[config], b[config])
        del b[config]

    # now print items in b but not in a
    # (items from b that were in a were removed above)
    new = sorted(b.keys())
    for config in new:
        print_config("+", config, None, b[config])

main()
                                                                                                                                                                                                                                                                                                                                    #! /bin/sh
# Script to apply kernel patches.
#   usage: patch-kernel [ sourcedir [ patchdir [ stopversion ] [ -acxx ] ] ]
#     The source directory defaults to /usr/src/linux, and the patch
#     directory defaults to the current directory.
# e.g.
#   scripts/patch-kernel . ..
#      Update the kernel tree in the current directory using patches in the
#      directory above to the latest Linus kernel
#   scripts/patch-kernel . .. -ac
#      Get the latest Linux kernel and patch it with the latest ac patch
#   scripts/patch-kernel . .. 2.4.9
#      Gets standard kernel 2.4.9
#   scripts/patch-kernel . .. 2.4.9 -ac
#      Gets 2.4.9 with latest ac patches
#   scripts/patch-kernel . .. 2.4.9 -ac11
#      Gets 2.4.9 with ac patch ac11
#   Note: It uses the patches relative to the Linus kernels, not the
#   ac to ac relative patches
#
# It determines the current kernel version from the top-level Makefile.
# It then looks for patches for the next sublevel in the patch directory.
# This is applied using "patch -p1 -s" from within the kernel directory.
# A check is then made for "*.rej" files to see if the patch was
# successful.  If it is, then all of the "*.orig" files are removed.
#
#       Nick Holloway <Nick.Holloway@alfie.demon.co.uk>, 2nd January 1995.
#
# Added support for handling multiple types of compression. What includes
# gzip, bzip, bzip2, zip, compress, and plaintext.
#
#       Adam Sulmicki <adam@cfar.umd.edu>, 1st January 1997.
#
# Added ability to stop at a given version number
# Put the full version number (i.e. 2.3.31) as the last parameter
#       Dave Gilbert <linux@treblig.org>, 11th December 1999.

# Fixed previous patch so that if we are already at the correct version
# not to patch up.
#
# Added -ac option, use -ac or -ac9 (say) to stop at a particular version
#       Dave Gilbert <linux@treblig.org>, 29th September 2001.
#
# Add support for (use of) EXTRAVERSION (to support 2.6.8.x, e.g.);
# update usage message;
# fix some whitespace damage;
# be smarter about stopping when current version is larger than requested;
#	Randy Dunlap <rdunlap@xenotime.net>, 2004-AUG-18.
#
# Add better support for (non-incremental) 2.6.x.y patches;
# If an ending version number if not specified, the script automatically
# increments the SUBLEVEL (x in 2.6.x.y) until no more patch files are found;
# however, EXTRAVERSION (y in 2.6.x.y) is never automatically incremented
# but must be specified fully.
#
# patch-kernel does not normally support reverse patching, but does so when
# applying EXTRAVERSION (x.y) patches, so that moving from 2.6.11.y to 2.6.11.z
# is easy and handled by the script (reverse 2.6.11.y and apply 2.6.11.z).
#	Randy Dunlap <rdunlap@xenotime.net>, 2005-APR-08.

PNAME=patch-kernel

# Set directories from arguments, or use defaults.
sourcedir=${1-/usr/src/linux}
patchdir=${2-.}
stopvers=${3-default}

if [ "$1" = -h -o "$1" = --help -o ! -r "$sourcedir/Makefile" ]; then
cat << USAGE
usage: $PNAME [-h] [ sourcedir [ patchdir [ stopversion ] [ -acxx ] ] ]
  source directory defaults to /usr/src/linux,
  patch directory defaults to the current directory,
  stopversion defaults to <all in patchdir>.
USAGE
exit 1
fi

# See if we have any -ac options
for PARM in $*
do
  case $PARM in
	  -ac*)
		  gotac=$PARM;

	esac;
done

# ---------------------------------------------------------------------------
# arg1 is filename
noFile () {
	echo "cannot find patch file: ${patch}"
	exit 1
}

# ---------------------------------------------------------------------------
backwards () {
	echo "$PNAME does not support reverse patching"
	exit 1
}

# ---------------------------------------------------------------------------
# Find a file, first parameter is basename of file
# it tries many compression mechanisms and sets variables to say how to get it
findFile () {
  filebase=$1;

  if [ -r ${filebase}.gz ]; then
		ext=".gz"
		name="gzip"
		uncomp="gunzip -dc"
  elif [ -r ${filebase}.bz  ]; then
		ext=".bz"
		name="bzip"
		uncomp="bunzip -dc"
  elif [ -r ${filebase}.bz2 ]; then
		ext=".bz2"
		name="bzip2"
		uncomp="bunzip2 -dc"
  elif [ -r ${filebase}.xz ]; then
                ext=".xz"
                name="xz"
                uncomp="xz -dc"
  elif [ -r ${filebase}.zip ]; then
		ext=".zip"
		name="zip"
		uncomp="unzip -d"
  elif [ -r ${filebase}.Z ]; then
		ext=".Z"
		name="uncompress"
		uncomp="uncompress -c"
  elif [ -r ${filebase} ]; then
		ext=""
		name="plaintext"
		uncomp="cat"
  else
	return 1;
  fi

  return 0;
}

# ---------------------------------------------------------------------------
# Apply a patch and check it goes in cleanly
# First param is patch name (e.g. patch-2.4.9-ac5) - without path or extension

applyPatch () {
  echo -n "Applying $1 (${name})... "
  if $uncomp ${patchdir}/$1${ext} | patch -p1 -s -N -E -d $sourcedir
  then
    echo "done."
  else
    echo "failed.  Clean up yourself."
    return 1;
  fi
  if [ "`find $sourcedir/ '(' -name '*.rej' -o -name '.*.rej' ')' -print`" ]
  then
    echo "Aborting.  Reject files found."
    return 1;
  fi
  # Remove backup files
  find $sourcedir/ '(' -name '*.orig' -o -name '.*.orig' ')' -exec rm -f {} \;

  return 0;
}

# ---------------------------------------------------------------------------
# arg1 is patch filename
reversePatch () {
	echo -n "Reversing $1 (${name}) ... "
	if $uncomp ${patchdir}/"$1"${ext} | patch -p1 -Rs -N -E -d $sourcedir
	then
		echo "done."
	else
		echo "failed.  Clean it up."
		exit 1
	fi
	if [ "`find $sourcedir/ '(' -name '*.rej' -o -name '.*.rej' ')' -print`" ]
	then
		echo "Aborting.  Reject files found."
		return 1
	fi
	# Remove backup files
	find $sourcedir/ '(' -name '*.orig' -o -name '.*.orig' ')' -exec rm -f {} \;

	return 0
}

# set current VERSION, PATCHLEVEL, SUBLEVEL, EXTRAVERSION
# force $TMPFILEs below to be in local directory: a slash character prevents
# the dot command from using the search path.
TMPFILE=`mktemp ./.tmpver.XXXXXX` || { echo "cannot make temp file" ; exit 1; }
grep -E "^(VERSION|PATCHLEVEL|SUBLEVEL|EXTRAVERSION)" $sourcedir/Makefile > $TMPFILE
tr -d [:blank:] < $TMPFILE > $TMPFILE.1
. $TMPFILE.1
rm -f $TMPFILE*
if [ -z "$VERSION" -o -z "$PATCHLEVEL" -o -z "$SUBLEVEL" ]
then
    echo "unable to determine current kernel version" >&2
    exit 1
fi

NAME=`grep ^NAME $sourcedir/Makefile`
NAME=${NAME##*=}

echo "Current kernel version is $VERSION.$PATCHLEVEL.$SUBLEVEL${EXTRAVERSION} ($NAME)"

# strip EXTRAVERSION to just a number (drop leading '.' and trailing additions)
EXTRAVER=
if [ x$EXTRAVERSION != "x" ]
then
	EXTRAVER=${EXTRAVERSION#.}
	EXTRAVER=${EXTRAVER%%[[:punct:]]*}
	#echo "$PNAME: changing EXTRAVERSION from $EXTRAVERSION to $EXTRAVER"
fi

#echo "stopvers=$stopvers"
if [ $stopvers != "default" ]; then
	STOPSUBLEVEL=`echo $stopvers | cut -d. -f3`
	STOPEXTRA=`echo $stopvers | cut -d. -f4`
	STOPFULLVERSION=${stopvers%%.$STOPEXTRA}
	#echo "#___STOPSUBLEVEL=/$STOPSUBLEVEL/, STOPEXTRA=/$STOPEXTRA/"
else
	STOPSUBLEVEL=9999
	STOPEXTRA=9999
fi

# This all assumes a 2.6.x[.y] kernel tree.
# Don't allow backwards/reverse patching.
if [ $STOPSUBLEVEL -lt $SUBLEVEL ]; then
	backwards
fi

if [ x$EXTRAVER != "x" ]; then
	CURRENTFULLVERSION="$VERSION.$PATCHLEVEL.$SUBLEVEL.$EXTRAVER"
else
	CURRENTFULLVERSION="$VERSION.$PATCHLEVEL.$SUBLEVEL"
fi

if [ x$EXTRAVER != "x" ]; then
	echo "backing up to: $VERSION.$PATCHLEVEL.$SUBLEVEL"
	patch="patch-${CURRENTFULLVERSION}"
	findFile $patchdir/${patch} || noFile ${patch}
	reversePatch ${patch} || exit 1
fi

# now current is 2.6.x, with no EXTRA applied,
# so update to target SUBLEVEL (2.6.SUBLEVEL)
# and then to target EXTRAVER (2.6.SUB.EXTRAVER) if requested.
# If not ending sublevel is specified, it is incremented until
# no further sublevels are found.

if [ $STOPSUBLEVEL -gt $SUBLEVEL ]; then
while :				# incrementing SUBLEVEL (s in v.p.s)
do
    CURRENTFULLVERSION="$VERSION.$PATCHLEVEL.$SUBLEVEL"
    EXTRAVER=
    if [ x$STOPFULLVERSION = x$CURRENTFULLVERSION ]; then
        echo "Stopping at $CURRENTFULLVERSION base as requested."
        break
    fi

    SUBLEVEL=$(($SUBLEVEL + 1))
    FULLVERSION="$VERSION.$PATCHLEVEL.$SUBLEVEL"
    #echo "#___ trying $FULLVERSION ___"

    if [ $(($SUBLEVEL)) -gt $(($STOPSUBLEVEL)) ]; then
	echo "Stopping since sublevel ($SUBLEVEL) is beyond stop-sublevel ($STOPSUBLEVEL)"
	exit 1
    fi

    patch=patch-$FULLVERSION
    # See if the file exists and find extension
    findFile $patchdir/${patch} || noFile ${patch}

    # Apply the patch and check all is OK
    applyPatch $patch || break
done
#echo "#___sublevel all done"
fi

# There is no incremental searching for extraversion...
if [ "$STOPEXTRA" != "" ]; then
while :				# just to allow break
do
# apply STOPEXTRA directly (not incrementally) (x in v.p.s.x)
	FULLVERSION="$VERSION.$PATCHLEVEL.$SUBLEVEL.$STOPEXTRA"
	#echo "#... trying $FULLVERSION ..."
	patch=patch-$FULLVERSION

	# See if the file exists and find extension
	findFile $patchdir/${patch} || noFile ${patch}

	# Apply the patch and check all is OK
	applyPatch $patch || break
	#echo "#___extraver all done"
	break
done
fi

if [ x$gotac != x ]; then
  # Out great user wants the -ac patches
	# They could have done -ac (get latest) or -acxx where xx=version they want
	if [ $gotac = "-ac" ]; then
	  # They want the latest version
		HIGHESTPATCH=0
		for PATCHNAMES in $patchdir/patch-${CURRENTFULLVERSION}-ac*\.*
		do
			ACVALUE=`echo $PATCHNAMES | sed -e 's/^.*patch-[0-9.]*-ac\([0-9]*\).*/\1/'`
			# Check it is actually a recognised patch type
			findFile $patchdir/patch-${CURRENTFULLVERSION}-ac${ACVALUE} || break

		  if [ $ACVALUE -gt $HIGHESTPATCH ]; then
			  HIGHESTPATCH=$ACVALUE
		  fi
		done

		if [ $HIGHESTPATCH -ne 0 ]; then
			findFile $patchdir/patch-${CURRENTFULLVERSION}-ac${HIGHESTPATCH} || break
			applyPatch patch-${CURRENTFULLVERSION}-ac${HIGHESTPATCH}
		else
		  echo "No -ac patches found"
		fi
	else
	  # They want an exact version
		findFile $patchdir/patch-${CURRENTFULLVERSION}${gotac} || {
		  echo "Sorry, I couldn't find the $gotac patch for $CURRENTFULLVERSION.  Hohum."
			exit 1
		}
		applyPatch patch-${CURRENTFULLVERSION}${gotac}
	fi
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #!/bin/sh
#
# This scripts adds local version information from the version
# control systems git, mercurial (hg) and subversion (svn).
#
# If something goes wrong, send a mail the kernel build mailinglist
# (see MAINTAINERS) and CC Nico Schottelius
# <nico-linuxsetlocalversion -at- schottelius.org>.
#
#

usage() {
	echo "Usage: $0 [--save-scmversion] [srctree]" >&2
	exit 1
}

scm_only=false
srctree=.
if test "$1" = "--save-scmversion"; then
	scm_only=true
	shift
fi
if test $# -gt 0; then
	srctree=$1
	shift
fi
if test $# -gt 0 -o ! -d "$srctree"; then
	usage
fi

scm_version()
{
	local short
	short=false

	cd "$srctree"
	if test -e .scmversion; then
		cat .scmversion
		return
	fi
	if test "$1" = "--short"; then
		short=true
	fi

	# Check for git and a git repo.
	if test -z "$(git rev-parse --show-cdup 2>/dev/null)" &&
	   head=`git rev-parse --verify --short HEAD 2>/dev/null`; then

		# If we are at a tagged commit (like "v2.6.30-rc6"), we ignore
		# it, because this version is defined in the top level Makefile.
		if [ -z "`git describe --exact-match 2>/dev/null`" ]; then

			# If only the short version is requested, don't bother
			# running further git commands
			if $short; then
				echo "+"
				return
			fi
			# If we are past a tagged commit (like
			# "v2.6.30-rc5-302-g72357d5"), we pretty print it.
			if atag="`git describe 2>/dev/null`"; then
				echo "$atag" | awk -F- '{printf("-%05d-%s", $(NF-1),$(NF))}'

			# If we don't have a tag at all we print -g{commitish}.
			else
				printf '%s%s' -g $head
			fi
		fi

		# Is this git on svn?
		if git config --get svn-remote.svn.url >/dev/null; then
			printf -- '-svn%s' "`git svn find-rev $head`"
		fi

		# Check for uncommitted changes
		if git diff-index --name-only HEAD | grep -qv "^scripts/package"; then
			printf '%s' -dirty
		fi

		# All done with git
		return
	fi

	# Check for mercurial and a mercurial repo.
	if test -d .hg && hgid=`hg id 2>/dev/null`; then
		# Do we have an tagged version?  If so, latesttagdistance == 1
		if [ "`hg log -r . --template '{latesttagdistance}'`" == "1" ]; then
			id=`hg log -r . --template '{latesttag}'`
			printf '%s%s' -hg "$id"
		else
			tag=`printf '%s' "$hgid" | cut -d' ' -f2`
			if [ -z "$tag" -o "$tag" = tip ]; then
				id=`printf '%s' "$hgid" | sed 's/[+ ].*//'`
				printf '%s%s' -hg "$id"
			fi
		fi

		# Are there uncommitted changes?
		# These are represented by + after the changeset id.
		case "$hgid" in
			*+|*+\ *) printf '%s' -dirty ;;
		esac

		# All done with mercurial
		return
	fi

	# Check for svn and a svn repo.
	if rev=`LANG= LC_ALL= LC_MESSAGES=C svn info 2>/dev/null | grep '^Last Changed Rev'`; then
		rev=`echo $rev | awk '{print $NF}'`
		printf -- '-svn%s' "$rev"

		# All done with svn
		return
	fi
}

collect_files()
{
	local file res

	for file; do
		case "$file" in
		*\~*)
			continue
			;;
		esac
		if test -e "$file"; then
			res="$res$(cat "$file")"
		fi
	done
	echo "$res"
}

if $scm_only; then
	if test ! -e .scmversion; then
		res=$(scm_version)
		echo "$res" >.scmversion
	fi
	exit
fi

if test -e include/config/auto.conf; then
	. include/config/auto.conf
else
	echo "Error: kernelrelease not valid - run 'make prepare' to update it"
	exit 1
fi

# localversion* files in the build and source directory
res="$(collect_files localversion*)"
if test ! "$srctree" -ef .; then
	res="$res$(collect_files "$srctree"/localversion*)"
fi

# CONFIG_LOCALVERSION and LOCALVERSION (if set)
res="${res}${CONFIG_LOCALVERSION}${LOCALVERSION}"

# scm version string if not at a tagged commit
if test "$CONFIG_LOCALVERSION_AUTO" = "y"; then
	# full scm version string
	res="$res$(scm_version)"
else
	# append a plus sign if the repository is not in a clean
	# annotated or signed tagged state (as git describe only
	# looks at signed or annotated tags - git tag -a/-s) and
	# LOCALVERSION= is not specified
	if test "${LOCALVERSION+set}" != "set"; then
		scm=$(scm_version --short)
		res="$res${scm:++}"
	fi
fi

echo "$res"
                                                                                                                          #!/bin/sh
#
# This is a wrapper for xz to compress the kernel image using appropriate
# compression options depending on the architecture.
#
# Author: Lasse Collin <lasse.collin@tukaani.org>
#
# This file has been put into the public domain.
# You can do whatever you want with this file.
#

BCJ=
LZMA2OPTS=

case $SRCARCH in
	x86)            BCJ=--x86 ;;
	powerpc)        BCJ=--powerpc ;;
	ia64)           BCJ=--ia64; LZMA2OPTS=pb=4 ;;
	arm)            BCJ=--arm ;;
	sparc)          BCJ=--sparc ;;
esac

exec xz --check=crc32 $BCJ --lzma2=$LZMA2OPTS,dict=32MiB
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #!/usr/bin/perl

#
# Takes a (sorted) output of readprofile and turns it into a list suitable for
# linker scripts
#
# usage:
#	 readprofile | sort -rn | perl profile2linkerlist.pl > functionlist
#
use strict;

while (<>) {
  my $line = $_;

  $_ =~ /\W*[0-9]+\W*([a-zA-Z\_0-9]+)\W*[0-9]+/;

  print "*(.text.$1)\n"
      unless ($line =~ /unknown/) || ($line =~ /total/);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #!/bin/sh
# Run headers_$1 command for all suitable architectures

# Stop on error
set -e

do_command()
{
	if [ -f ${srctree}/arch/$2/include/asm/Kbuild ]; then
		make ARCH=$2 KBUILD_HEADERS=$1 headers_$1
	else
		printf "Ignoring arch: %s\n" ${arch}
	fi
}

archs=${HDR_ARCH_LIST:-$(ls ${srctree}/arch)}

for arch in ${archs}; do
	case ${arch} in
	um)        # no userspace export
		;;
	*)
		if [ -d ${srctree}/arch/${arch} ]; then
			do_command $1 ${arch}
		fi
		;;
	esac
done
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
checker-help:
	@echo  '  coccicheck      - Check with Coccinelle.'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # ==========================================================================
# Installing headers
#
# header-y  - list files to be installed. They are preprocessed
#             to remove __KERNEL__ section of the file
# genhdr-y  - Same as header-y but in a generated/ directory
#
# ==========================================================================

# generated header directory
gen := $(if $(gen),$(gen),$(subst include/,include/generated/,$(obj)))

kbuild-file := $(srctree)/$(obj)/Kbuild
include $(kbuild-file)

# called may set destination dir (when installing to asm/)
_dst := $(if $(destination-y),$(destination-y),$(if $(dst),$(dst),$(obj)))

old-kbuild-file := $(srctree)/$(subst uapi/,,$(obj))/Kbuild
ifneq ($(wildcard $(old-kbuild-file)),)
include $(old-kbuild-file)
endif

include scripts/Kbuild.include

installdir    := $(INSTALL_HDR_PATH)/$(subst uapi/,,$(_dst))

header-y      := $(sort $(header-y))
subdirs       := $(patsubst %/,%,$(filter %/, $(header-y)))
header-y      := $(filter-out %/, $(header-y))

# files used to track state of install/check
install-file  := $(installdir)/.install
check-file    := $(installdir)/.check

# generic-y list all files an architecture uses from asm-generic
# Use this to build a list of headers which require a wrapper
wrapper-files := $(filter $(header-y), $(generic-y))

srcdir        := $(srctree)/$(obj)
gendir        := $(objtree)/$(gen)

oldsrcdir     := $(srctree)/$(subst /uapi,,$(obj))

# all headers files for this dir
header-y      := $(filter-out $(generic-y), $(header-y))
all-files     := $(header-y) $(genhdr-y) $(wrapper-files)
output-files  := $(addprefix $(installdir)/, $(all-files))

input-files1  := $(foreach hdr, $(header-y), \
		   $(if $(wildcard $(srcdir)/$(hdr)), \
			$(wildcard $(srcdir)/$(hdr))) \
		   )
input-files1-name := $(notdir $(input-files1))
input-files2  := $(foreach hdr, $(header-y), \
		   $(if  $(wildcard $(srcdir)/$(hdr)),, \
			$(if $(wildcard $(oldsrcdir)/$(hdr)), \
				$(wildcard $(oldsrcdir)/$(hdr)), \
				$(error Missing UAPI file $(srcdir)/$(hdr))) \
		   ))
input-files2-name := $(notdir $(input-files2))
input-files3  := $(foreach hdr, $(genhdr-y), \
		   $(if	$(wildcard $(gendir)/$(hdr)), \
			$(wildcard $(gendir)/$(hdr)), \
			$(error Missing generated UAPI file $(gendir)/$(hdr)) \
		   ))
input-files3-name := $(notdir $(input-files3))

# Work out what needs to be removed
oldheaders    := $(patsubst $(installdir)/%,%,$(wildcard $(installdir)/*.h))
unwanted      := $(filter-out $(all-files),$(oldheaders))

# Prefix unwanted with full paths to $(INSTALL_HDR_PATH)
unwanted-file := $(addprefix $(installdir)/, $(unwanted))

printdir = $(patsubst $(INSTALL_HDR_PATH)/%/,%,$(dir $@))

quiet_cmd_install = INSTALL $(printdir) ($(words $(all-files))\
                            file$(if $(word 2, $(all-files)),s))
      cmd_install = \
        $(CONFIG_SHELL) $< $(installdir) $(srcdir) $(input-files1-name); \
        $(CONFIG_SHELL) $< $(installdir) $(oldsrcdir) $(input-files2-name); \
        $(CONFIG_SHELL) $< $(installdir) $(gendir) $(input-files3-name); \
        for F in $(wrapper-files); do                                   \
                echo "\#include <asm-generic/$$F>" > $(installdir)/$$F;    \
        done;                                                           \
        touch $@

quiet_cmd_remove = REMOVE  $(unwanted)
      cmd_remove = rm -f $(unwanted-file)

quiet_cmd_check = CHECK   $(printdir) ($(words $(all-files)) files)
# Headers list can be pretty long, xargs helps to avoid
# the "Argument list too long" error.
      cmd_check = for f in $(all-files); do                          \
                  echo "$(installdir)/$${f}"; done                      \
                  | xargs                                            \
                  $(PERL) $< $(INSTALL_HDR_PATH)/include $(SRCARCH); \
	          touch $@

PHONY += __headersinst __headerscheck

ifndef HDRCHECK
# Rules for installing headers
__headersinst: $(subdirs) $(install-file)
	@:

targets += $(install-file)
$(install-file): scripts/headers_install.sh $(input-files1) $(input-files2) $(input-files3) FORCE
	$(if $(unwanted),$(call cmd,remove),)
	$(if $(wildcard $(dir $@)),,$(shell mkdir -p $(dir $@)))
	$(call if_changed,install)

else
__headerscheck: $(subdirs) $(check-file)
	@:

targets += $(check-file)
$(check-file): scripts/headers_check.pl $(output-files) FORCE
	$(call if_changed,check)

endif

# Recursion
.PHONY: $(subdirs)
$(subdirs):
	$(Q)$(MAKE) $(hdr-inst)=$(obj)/$@ dst=$(_dst)/$@

targets := $(wildcard $(sort $(targets)))
cmd_files := $(wildcard \
             $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))

ifneq ($(cmd_files),)
	include $(cmd_files)
endif

.PHONY: $(PHONY)
PHONY += FORCE
FORCE: ;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #!/bin/sh

if [ $# -lt 2 ]
then
	echo "Usage: headers_install.sh OUTDIR SRCDIR [FILES...]"
	echo
	echo "Prepares kernel header files for use by user space, by removing"
	echo "all compiler.h definitions and #includes, removing any"
	echo "#ifdef __KERNEL__ sections, and putting __underscores__ around"
	echo "asm/inline/volatile keywords."
	echo
	echo "OUTDIR: directory to write each userspace header FILE to."
	echo "SRCDIR: source directory where files are picked."
	echo "FILES:  list of header files to operate on."

	exit 1
fi

# Grab arguments

OUTDIR="$1"
shift
SRCDIR="$1"
shift

# Iterate through files listed on command line

FILE=
trap 'rm -f "$OUTDIR/$FILE" "$OUTDIR/$FILE.sed"' EXIT
for i in "$@"
do
	FILE="$(basename "$i")"
	sed -r \
		-e 's/([ \t(])(__user|__force|__iomem)[ \t]/\1/g' \
		-e 's/__attribute_const__([ \t]|$)/\1/g' \
		-e 's@^#include <linux/compiler.h>@@' \
		-e 's/(^|[^a-zA-Z0-9])__packed([^a-zA-Z0-9_]|$)/\1__attribute__((packed))\2/g' \
		-e 's/(^|[ \t(])(inline|asm|volatile)([ \t(]|$)/\1__\2__\3/g' \
		-e 's@#(ifndef|define|endif[ \t]*/[*])[ \t]*_UAPI@#\1 @' \
		"$SRCDIR/$i" > "$OUTDIR/$FILE.sed" || exit 1
	scripts/unifdef -U__KERNEL__ -D__EXPORTED_HEADERS__ "$OUTDIR/$FILE.sed" \
		> "$OUTDIR/$FILE"
	[ $? -gt 1 ] && exit 1
	rm -f "$OUTDIR/$FILE.sed"
done
trap - EXIT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 if [ ! -f .version ]
then
    echo 1
else
    expr 0`cat .version` + 1
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #!/usr/bin/perl -w
# (c) 2007, Joe Perches <joe@perches.com>
#           created from checkpatch.pl
#
# Print selected MAINTAINERS information for
# the files modified in a patch or for a file
#
# usage: perl scripts/get_maintainer.pl [OPTIONS] <patch>
#        perl scripts/get_maintainer.pl [OPTIONS] -f <file>
#
# Licensed under the terms of the GNU GPL License version 2

use strict;

my $P = $0;
my $V = '0.26';

use Getopt::Long qw(:config no_auto_abbrev);

my $lk_path = "./";
my $email = 1;
my $email_usename = 1;
my $email_maintainer = 1;
my $email_reviewer = 1;
my $email_list = 1;
my $email_subscriber_list = 0;
my $email_git_penguin_chiefs = 0;
my $email_git = 0;
my $email_git_all_signature_types = 0;
my $email_git_blame = 0;
my $email_git_blame_signatures = 1;
my $email_git_fallback = 1;
my $email_git_min_signatures = 1;
my $email_git_max_maintainers = 5;
my $email_git_min_percent = 5;
my $email_git_since = "1-year-ago";
my $email_hg_since = "-365";
my $interactive = 0;
my $email_remove_duplicates = 1;
my $email_use_mailmap = 1;
my $output_multiline = 1;
my $output_separator = ", ";
my $output_roles = 0;
my $output_rolestats = 1;
my $scm = 0;
my $web = 0;
my $subsystem = 0;
my $status = 0;
my $keywords = 1;
my $sections = 0;
my $file_emails = 0;
my $from_filename = 0;
my $pattern_depth = 0;
my $version = 0;
my $help = 0;

my $vcs_used = 0;

my $exit = 0;

my %commit_author_hash;
my %commit_signer_hash;

my @penguin_chief = ();
push(@penguin_chief, "Linus Torvalds:torvalds\@linux-foundation.org");
#Andrew wants in on most everything - 2009/01/14
#push(@penguin_chief, "Andrew Morton:akpm\@linux-foundation.org");

my @penguin_chief_names = ();
foreach my $chief (@penguin_chief) {
    if ($chief =~ m/^(.*):(.*)/) {
	my $chief_name = $1;
	my $chief_addr = $2;
	push(@penguin_chief_names, $chief_name);
    }
}
my $penguin_chiefs = "\(" . join("|", @penguin_chief_names) . "\)";

# Signature types of people who are either
# 	a) responsible for the code in question, or
# 	b) familiar enough with it to give relevant feedback
my @signature_tags = ();
push(@signature_tags, "Signed-off-by:");
push(@signature_tags, "Reviewed-by:");
push(@signature_tags, "Acked-by:");

my $signature_pattern = "\(" . join("|", @signature_tags) . "\)";

# rfc822 email address - preloaded methods go here.
my $rfc822_lwsp = "(?:(?:\\r\\n)?[ \\t])";
my $rfc822_char = '[\\000-\\377]';

# VCS command support: class-like functions and strings

my %VCS_cmds;

my %VCS_cmds_git = (
    "execute_cmd" => \&git_execute_cmd,
    "available" => '(which("git") ne "") && (-e ".git")',
    "find_signers_cmd" =>
	"git log --no-color --follow --since=\$email_git_since " .
	    '--numstat --no-merges ' .
	    '--format="GitCommit: %H%n' .
		      'GitAuthor: %an <%ae>%n' .
		      'GitDate: %aD%n' .
		      'GitSubject: %s%n' .
		      '%b%n"' .
	    " -- \$file",
    "find_commit_signers_cmd" =>
	"git log --no-color " .
	    '--numstat ' .
	    '--format="GitCommit: %H%n' .
		      'GitAuthor: %an <%ae>%n' .
		      'GitDate: %aD%n' .
		      'GitSubject: %s%n' .
		      '%b%n"' .
	    " -1 \$commit",
    "find_commit_author_cmd" =>
	"git log --no-color " .
	    '--numstat ' .
	    '--format="GitCommit: %H%n' .
		      'GitAuthor: %an <%ae>%n' .
		      'GitDate: %aD%n' .
		      'GitSubject: %s%n"' .
	    " -1 \$commit",
    "blame_range_cmd" => "git blame -l -L \$diff_start,+\$diff_length \$file",
    "blame_file_cmd" => "git blame -l \$file",
    "commit_pattern" => "^GitCommit: ([0-9a-f]{40,40})",
    "blame_commit_pattern" => "^([0-9a-f]+) ",
    "author_pattern" => "^GitAuthor: (.*)",
    "subject_pattern" => "^GitSubject: (.*)",
    "stat_pattern" => "^(\\d+)\\t(\\d+)\\t\$file\$",
);

my %VCS_cmds_hg = (
    "execute_cmd" => \&hg_execute_cmd,
    "available" => '(which("hg") ne "") && (-d ".hg")',
    "find_signers_cmd" =>
	"hg log --date=\$email_hg_since " .
	    "--template='HgCommit: {node}\\n" .
	                "HgAuthor: {author}\\n" .
			"HgSubject: {desc}\\n'" .
	    " -- \$file",
    "find_commit_signers_cmd" =>
	"hg log " .
	    "--template='HgSubject: {desc}\\n'" .
	    " -r \$commit",
    "find_commit_author_cmd" =>
	"hg log " .
	    "--template='HgCommit: {node}\\n" .
		        "HgAuthor: {author}\\n" .
			"HgSubject: {desc|firstline}\\n'" .
	    " -r \$commit",
    "blame_range_cmd" => "",		# not supported
    "blame_file_cmd" => "hg blame -n \$file",
    "commit_pattern" => "^HgCommit: ([0-9a-f]{40,40})",
    "blame_commit_pattern" => "^([ 0-9a-f]+):",
    "author_pattern" => "^HgAuthor: (.*)",
    "subject_pattern" => "^HgSubject: (.*)",
    "stat_pattern" => "^(\\d+)\t(\\d+)\t\$file\$",
);

my $conf = which_conf(".get_maintainer.conf");
if (-f $conf) {
    my @conf_args;
    open(my $conffile, '<', "$conf")
	or warn "$P: Can't find a readable .get_maintainer.conf file $!\n";

    while (<$conffile>) {
	my $line = $_;

	$line =~ s/\s*\n?$//g;
	$line =~ s/^\s*//g;
	$line =~ s/\s+/ /g;

	next if ($line =~ m/^\s*#/);
	next if ($line =~ m/^\s*$/);

	my @words = split(" ", $line);
	foreach my $word (@words) {
	    last if ($word =~ m/^#/);
	    push (@conf_args, $word);
	}
    }
    close($conffile);
    unshift(@ARGV, @conf_args) if @conf_args;
}

if (!GetOptions(
		'email!' => \$email,
		'git!' => \$email_git,
		'git-all-signature-types!' => \$email_git_all_signature_types,
		'git-blame!' => \$email_git_blame,
		'git-blame-signatures!' => \$email_git_blame_signatures,
		'git-fallback!' => \$email_git_fallback,
		'git-chief-penguins!' => \$email_git_penguin_chiefs,
		'git-min-signatures=i' => \$email_git_min_signatures,
		'git-max-maintainers=i' => \$email_git_max_maintainers,
		'git-min-percent=i' => \$email_git_min_percent,
		'git-since=s' => \$email_git_since,
		'hg-since=s' => \$email_hg_since,
		'i|interactive!' => \$interactive,
		'remove-duplicates!' => \$email_remove_duplicates,
		'mailmap!' => \$email_use_mailmap,
		'm!' => \$email_maintainer,
		'r!' => \$email_reviewer,
		'n!' => \$email_usename,
		'l!' => \$email_list,
		's!' => \$email_subscriber_list,
		'multiline!' => \$output_multiline,
		'roles!' => \$output_roles,
		'rolestats!' => \$output_rolestats,
		'separator=s' => \$output_separator,
		'subsystem!' => \$subsystem,
		'status!' => \$status,
		'scm!' => \$scm,
		'web!' => \$web,
		'pattern-depth=i' => \$pattern_depth,
		'k|keywords!' => \$keywords,
		'sections!' => \$sections,
		'fe|file-emails!' => \$file_emails,
		'f|file' => \$from_filename,
		'v|version' => \$version,
		'h|help|usage' => \$help,
		)) {
    die "$P: invalid argument - use --help if necessary\n";
}

if ($help != 0) {
    usage();
    exit 0;
}

if ($version != 0) {
    print("${P} ${V}\n");
    exit 0;
}

if (-t STDIN && !@ARGV) {
    # We're talking to a terminal, but have no command line arguments.
    die "$P: missing patchfile or -f file - use --help if necessary\n";
}

$output_multiline = 0 if ($output_separator ne ", ");
$output_rolestats = 1 if ($interactive);
$output_roles = 1 if ($output_rolestats);

if ($sections) {
    $email = 0;
    $email_list = 0;
    $scm = 0;
    $status = 0;
    $subsystem = 0;
    $web = 0;
    $keywords = 0;
    $interactive = 0;
} else {
    my $selections = $email + $scm + $status + $subsystem + $web;
    if ($selections == 0) {
	die "$P:  Missing required option: email, scm, status, subsystem or web\n";
    }
}

if ($email &&
    ($email_maintainer + $email_reviewer +
     $email_list + $email_subscriber_list +
     $email_git + $email_git_penguin_chiefs + $email_git_blame) == 0) {
    die "$P: Please select at least 1 email option\n";
}

if (!top_of_kernel_tree($lk_path)) {
    die "$P: The current directory does not appear to be "
	. "a linux kernel source tree.\n";
}

## Read MAINTAINERS for type/value pairs

my @typevalue = ();
my %keyword_hash;

open (my $maint, '<', "${lk_path}MAINTAINERS")
    or die "$P: Can't open MAINTAINERS: $!\n";
while (<$maint>) {
    my $line = $_;

    if ($line =~ m/^(\C):\s*(.*)/) {
	my $type = $1;
	my $value = $2;

	##Filename pattern matching
	if ($type eq "F" || $type eq "X") {
	    $value =~ s@\.@\\\.@g;       ##Convert . to \.
	    $value =~ s/\*/\.\*/g;       ##Convert * to .*
	    $value =~ s/\?/\./g;         ##Convert ? to .
	    ##if pattern is a directory and it lacks a trailing slash, add one
	    if ((-d $value)) {
		$value =~ s@([^/])$@$1/@;
	    }
	} elsif ($type eq "K") {
	    $keyword_hash{@typevalue} = $value;
	}
	push(@typevalue, "$type:$value");
    } elsif (!/^(\s)*$/) {
	$line =~ s/\n$//g;
	push(@typevalue, $line);
    }
}
close($maint);


#
# Read mail address map
#

my $mailmap;

read_mailmap();

sub read_mailmap {
    $mailmap = {
	names => {},
	addresses => {}
    };

    return if (!$email_use_mailmap || !(-f "${lk_path}.mailmap"));

    open(my $mailmap_file, '<', "${lk_path}.mailmap")
	or warn "$P: Can't open .mailmap: $!\n";

    while (<$mailmap_file>) {
	s/#.*$//; #strip comments
	s/^\s+|\s+$//g; #trim

	next if (/^\s*$/); #skip empty lines
	#entries have one of the following formats:
	# name1 <mail1>
	# <mail1> <mail2>
	# name1 <mail1> <mail2>
	# name1 <mail1> name2 <mail2>
	# (see man git-shortlog)

	if (/^([^<]+)<([^>]+)>$/) {
	    my $real_name = $1;
	    my $address = $2;

	    $real_name =~ s/\s+$//;
	    ($real_name, $address) = parse_email("$real_name <$address>");
	    $mailmap->{names}->{$address} = $real_name;

	} elsif (/^<([^>]+)>\s*<([^>]+)>$/) {
	    my $real_address = $1;
	    my $wrong_address = $2;

	    $mailmap->{addresses}->{$wrong_address} = $real_address;

	} elsif (/^(.+)<([^>]+)>\s*<([^>]+)>$/) {
	    my $real_name = $1;
	    my $real_address = $2;
	    my $wrong_address = $3;

	    $real_name =~ s/\s+$//;
	    ($real_name, $real_address) =
		parse_email("$real_name <$real_address>");
	    $mailmap->{names}->{$wrong_address} = $real_name;
	    $mailmap->{addresses}->{$wrong_address} = $real_address;

	} elsif (/^(.+)<([^>]+)>\s*(.+)\s*<([^>]+)>$/) {
	    my $real_name = $1;
	    my $real_address = $2;
	    my $wrong_name = $3;
	    my $wrong_address = $4;

	    $real_name =~ s/\s+$//;
	    ($real_name, $real_address) =
		parse_email("$real_name <$real_address>");

	    $wrong_name =~ s/\s+$//;
	    ($wrong_name, $wrong_address) =
		parse_email("$wrong_name <$wrong_address>");

	    my $wrong_email = format_email($wrong_name, $wrong_address, 1);
	    $mailmap->{names}->{$wrong_email} = $real_name;
	    $mailmap->{addresses}->{$wrong_email} = $real_address;
	}
    }
    close($mailmap_file);
}

## use the filenames on the command line or find the filenames in the patchfiles

my @files = ();
my @range = ();
my @keyword_tvi = ();
my @file_emails = ();

if (!@ARGV) {
    push(@ARGV, "&STDIN");
}

foreach my $file (@ARGV) {
    if ($file ne "&STDIN") {
	##if $file is a directory and it lacks a trailing slash, add one
	if ((-d $file)) {
	    $file =~ s@([^/])$@$1/@;
	} elsif (!(-f $file)) {
	    die "$P: file '${file}' not found\n";
	}
    }
    if ($from_filename) {
	push(@files, $file);
	if ($file ne "MAINTAINERS" && -f $file && ($keywords || $file_emails)) {
	    open(my $f, '<', $file)
		or die "$P: Can't open $file: $!\n";
	    my $text = do { local($/) ; <$f> };
	    close($f);
	    if ($keywords) {
		foreach my $line (keys %keyword_hash) {
		    if ($text =~ m/$keyword_hash{$line}/x) {
			push(@keyword_tvi, $line);
		    }
		}
	    }
	    if ($file_emails) {
		my @poss_addr = $text =~ m$[A-Za-zÃ€-Ã¿\"\' \,\.\+-]*\s*[\,]*\s*[\(\<\{]{0,1}[A-Za-z0-9_\.\+-]+\@[A-Za-z0-9\.-]+\.[A-Za-z0-9]+[\)\>\}]{0,1}$g;
		push(@file_emails, clean_file_emails(@poss_addr));
	    }
	}
    } else {
	my $file_cnt = @files;
	my $lastfile;

	open(my $patch, "< $file")
	    or die "$P: Can't open $file: $!\n";

	# We can check arbitrary information before the patch
	# like the commit message, mail headers, etc...
	# This allows us to match arbitrary keywords against any part
	# of a git format-patch generated file (subject tags, etc...)

	my $patch_prefix = "";			#Parsing the intro

	while (<$patch>) {
	    my $patch_line = $_;
	    if (m/^\+\+\+\s+(\S+)/ or m/^---\s+(\S+)/) {
		my $filename = $1;
		$filename =~ s@^[^/]*/@@;
		$filename =~ s@\n@@;
		$lastfile = $filename;
		push(@files, $filename);
		$patch_prefix = "^[+-].*";	#Now parsing the actual patch
	    } elsif (m/^\@\@ -(\d+),(\d+)/) {
		if ($email_git_blame) {
		    push(@range, "$lastfile:$1:$2");
		}
	    } elsif ($keywords) {
		foreach my $line (keys %keyword_hash) {
		    if ($patch_line =~ m/${patch_prefix}$keyword_hash{$line}/x) {
			push(@keyword_tvi, $line);
		    }
		}
	    }
	}
	close($patch);

	if ($file_cnt == @files) {
	    warn "$P: file '${file}' doesn't appear to be a patch.  "
		. "Add -f to options?\n";
	}
	@files = sort_and_uniq(@files);
    }
}

@file_emails = uniq(@file_emails);

my %email_hash_name;
my %email_hash_address;
my @email_to = ();
my %hash_list_to;
my @list_to = ();
my @scm = ();
my @web = ();
my @subsystem = ();
my @status = ();
my %deduplicate_name_hash = ();
my %deduplicate_address_hash = ();

my @maintainers = get_maintainers();

if (@maintainers) {
    @maintainers = merge_email(@maintainers);
    output(@maintainers);
}

if ($scm) {
    @scm = uniq(@scm);
    output(@scm);
}

if ($status) {
    @status = uniq(@status);
    output(@status);
}

if ($subsystem) {
    @subsystem = uniq(@subsystem);
    output(@subsystem);
}

if ($web) {
    @web = uniq(@web);
    output(@web);
}

exit($exit);

sub range_is_maintained {
    my ($start, $end) = @_;

    for (my $i = $start; $i < $end; $i++) {
	my $line = $typevalue[$i];
	if ($line =~ m/^(\C):\s*(.*)/) {
	    my $type = $1;
	    my $value = $2;
	    if ($type eq 'S') {
		if ($value =~ /(maintain|support)/i) {
		    return 1;
		}
	    }
	}
    }
    return 0;
}

sub range_has_maintainer {
    my ($start, $end) = @_;

    for (my $i = $start; $i < $end; $i++) {
	my $line = $typevalue[$i];
	if ($line =~ m/^(\C):\s*(.*)/) {
	    my $type = $1;
	    my $value = $2;
	    if ($type eq 'M') {
		return 1;
	    }
	}
    }
    return 0;
}

sub get_maintainers {
    %email_hash_name = ();
    %email_hash_address = ();
    %commit_author_hash = ();
    %commit_signer_hash = ();
    @email_to = ();
    %hash_list_to = ();
    @list_to = ();
    @scm = ();
    @web = ();
    @subsystem = ();
    @status = ();
    %deduplicate_name_hash = ();
    %deduplicate_address_hash = ();
    if ($email_git_all_signature_types) {
	$signature_pattern = "(.+?)[Bb][Yy]:";
    } else {
	$signature_pattern = "\(" . join("|", @signature_tags) . "\)";
    }

    # Find responsible parties

    my %exact_pattern_match_hash = ();

    foreach my $file (@files) {

	my %hash;
	my $tvi = find_first_section();
	while ($tvi < @typevalue) {
	    my $start = find_starting_index($tvi);
	    my $end = find_ending_index($tvi);
	    my $exclude = 0;
	    my $i;

	    #Do not match excluded file patterns

	    for ($i = $start; $i < $end; $i++) {
		my $line = $typevalue[$i];
		if ($line =~ m/^(\C):\s*(.*)/) {
		    my $type = $1;
		    my $value = $2;
		    if ($type eq 'X') {
			if (file_match_pattern($file, $value)) {
			    $exclude = 1;
			    last;
			}
		    }
		}
	    }

	    if (!$exclude) {
		for ($i = $start; $i < $end; $i++) {
		    my $line = $typevalue[$i];
		    if ($line =~ m/^(\C):\s*(.*)/) {
			my $type = $1;
			my $value = $2;
			if ($type eq 'F') {
			    if (file_match_pattern($file, $value)) {
				my $value_pd = ($value =~ tr@/@@);
				my $file_pd = ($file  =~ tr@/@@);
				$value_pd++ if (substr($value,-1,1) ne "/");
				$value_pd = -1 if ($value =~ /^\.\*/);
				if ($value_pd >= $file_pd &&
				    range_is_maintained($start, $end) &&
				    range_has_maintainer($start, $end)) {
				    $exact_pattern_match_hash{$file} = 1;
				}
				if ($pattern_depth == 0 ||
				    (($file_pd - $value_pd) < $pattern_depth)) {
				    $hash{$tvi} = $value_pd;
				}
			    }
			} elsif ($type eq 'N') {
			    if ($file =~ m/$value/x) {
				$hash{$tvi} = 0;
			    }
			}
		    }
		}
	    }
	    $tvi = $end + 1;
	}

	foreach my $line (sort {$hash{$b} <=> $hash{$a}} keys %hash) {
	    add_categories($line);
	    if ($sections) {
		my $i;
		my $start = find_starting_index($line);
		my $end = find_ending_index($line);
		for ($i = $start; $i < $end; $i++) {
		    my $line = $typevalue[$i];
		    if ($line =~ /^[FX]:/) {		##Restore file patterns
			$line =~ s/([^\\])\.([^\*])/$1\?$2/g;
			$line =~ s/([^\\])\.$/$1\?/g;	##Convert . back to ?
			$line =~ s/\\\./\./g;       	##Convert \. to .
			$line =~ s/\.\*/\*/g;       	##Convert .* to *
		    }
		    $line =~ s/^([A-Z]):/$1:\t/g;
		    print("$line\n");
		}
		print("\n");
	    }
	}
    }

    if ($keywords) {
	@keyword_tvi = sort_and_uniq(@keyword_tvi);
	foreach my $line (@keyword_tvi) {
	    add_categories($line);
	}
    }

    foreach my $email (@email_to, @list_to) {
	$email->[0] = deduplicate_email($email->[0]);
    }

    foreach my $file (@files) {
	if ($email &&
	    ($email_git || ($email_git_fallback &&
			    !$exact_pattern_match_hash{$file}))) {
	    vcs_file_signoffs($file);
	}
	if ($email && $email_git_blame) {
	    vcs_file_blame($file);
	}
    }

    if ($email) {
	foreach my $chief (@penguin_chief) {
	    if ($chief =~ m/^(.*):(.*)/) {
		my $email_address;

		$email_address = format_email($1, $2, $email_usename);
		if ($email_git_penguin_chiefs) {
		    push(@email_to, [$email_address, 'chief penguin']);
		} else {
		    @email_to = grep($_->[0] !~ /${email_address}/, @email_to);
		}
	    }
	}

	foreach my $email (@file_emails) {
	    my ($name, $address) = parse_email($email);

	    my $tmp_email = format_email($name, $address, $email_usename);
	    push_email_address($tmp_email, '');
	    add_role($tmp_email, 'in file');
	}
    }

    my @to = ();
    if ($email || $email_list) {
	if ($email) {
	    @to = (@to, @email_to);
	}
	if ($email_list) {
	    @to = (@to, @list_to);
	}
    }

    if ($interactive) {
	@to = interactive_get_maintainers(\@to);
    }

    return @to;
}

sub file_match_pattern {
    my ($file, $pattern) = @_;
    if (substr($pattern, -1) eq "/") {
	if ($file =~ m@^$pattern@) {
	    return 1;
	}
    } else {
	if ($file =~ m@^$pattern@) {
	    my $s1 = ($file =~ tr@/@@);
	    my $s2 = ($pattern =~ tr@/@@);
	    if ($s1 == $s2) {
		return 1;
	    }
	}
    }
    return 0;
}

sub usage {
    print <<EOT;
usage: $P [options] patchfile
       $P [options] -f file|directory
version: $V

MAINTAINER field selection options:
  --email => print email address(es) if any
    --git => include recent git \*-by: signers
    --git-all-signature-types => include signers regardless of signature type
        or use only ${signature_pattern} signers (default: $email_git_all_signature_types)
    --git-fallback => use git when no exact MAINTAINERS pattern (default: $email_git_fallback)
    --git-chief-penguins => include ${penguin_chiefs}
    --git-min-signatures => number of signatures required (default: $email_git_min_signatures)
    --git-max-maintainers => maximum maintainers to add (default: $email_git_max_maintainers)
    --git-min-percent => minimum percentage of commits required (default: $email_git_min_percent)
    --git-blame => use git blame to find modified commits for patch or file
    --git-since => git history to use (default: $email_git_since)
    --hg-since => hg history to use (default: $email_hg_since)
    --interactive => display a menu (mostly useful if used with the --git option)
    --m => include maintainer(s) if any
    --r => include reviewer(s) if any
    --n => include name 'Full Name <addr\@domain.tld>'
    --l => include list(s) if any
    --s => include subscriber only list(s) if any
    --remove-duplicates => minimize duplicate email names/addresses
    --roles => show roles (status:subsystem, git-signer, list, etc...)
    --rolestats => show roles and statistics (commits/total_commits, %)
    --file-emails => add email addresses found in -f file (default: 0 (off))
  --scm => print SCM tree(s) if any
  --status => print status if any
  --subsystem => print subsystem name if any
  --web => print website(s) if any

Output type options:
  --separator [, ] => separator for multiple entries on 1 line
    using --separator also sets --nomultiline if --separator is not [, ]
  --multiline => print 1 entry per line

Other options:
  --pattern-depth => Number of pattern directory traversals (default: 0 (all))
  --keywords => scan patch for keywords (default: $keywords)
  --sections => print all of the subsystem sections with pattern matches
  --mailmap => use .mailmap file (default: $email_use_mailmap)
  --version => show version
  --help => show this help information

Default options:
  [--email --nogit --git-fallback --m --n --l --multiline -pattern-depth=0
   --remove-duplicates --rolestats]

Notes:
  Using "-f directory" may give unexpected results:
      Used with "--git", git signators for _all_ files in and below
          directory are examined as git recurses directories.
          Any specified X: (exclude) pattern matches are _not_ ignored.
      Used with "--nogit", directory is used as a pattern match,
          no individual file within the directory or subdirectory
          is matched.
      Used with "--git-blame", does not iterate all files in directory
  Using "--git-blame" is slow and may add old committers and authors
      that are no longer active maintainers to the output.
  Using "--roles" or "--rolestats" with git send-email --cc-cmd or any
      other automated tools that expect only ["name"] <email address>
      may not work because of additional output after <email address>.
  Using "--rolestats" and "--git-blame" shows the #/total=% commits,
      not the percentage of the entire file authored.  # of commits is
      not a good measure of amount of code authored.  1 major commit may
      contain a thousand lines, 5 trivial commits may modify a single line.
  If git is not installed, but mercurial (hg) is installed and an .hg
      repository exists, the following options apply to mercurial:
          --git,
          --git-min-signatures, --git-max-maintainers, --git-min-percent, and
          --git-blame
      Use --hg-since not --git-since to control date selection
  File ".get_maintainer.conf", if it exists in the linux kernel source root
      directory, can change whatever get_maintainer defaults are desired.
      Entries in this file can be any command line argument.
      This file is prepended to any additional command line arguments.
      Multiple lines and # comments are allowed.
EOT
}

sub top_of_kernel_tree {
    my ($lk_path) = @_;

    if ($lk_path ne "" && substr($lk_path,length($lk_path)-1,1) ne "/") {
	$lk_path .= "/";
    }
    if (   (-f "${lk_path}COPYING")
	&& (-f "${lk_path}CREDITS")
	&& (-f "${lk_path}Kbuild")
	&& (-f "${lk_path}MAINTAINERS")
	&& (-f "${lk_path}Makefile")
	&& (-f "${lk_path}README")
	&& (-d "${lk_path}Documentation")
	&& (-d "${lk_path}arch")
	&& (-d "${lk_path}include")
	&& (-d "${lk_path}drivers")
	&& (-d "${lk_path}fs")
	&& (-d "${lk_path}init")
	&& (-d "${lk_path}ipc")
	&& (-d "${lk_path}kernel")
	&& (-d "${lk_path}lib")
	&& (-d "${lk_path}scripts")) {
	return 1;
    }
    return 0;
}

sub parse_email {
    my ($formatted_email) = @_;

    my $name = "";
    my $address = "";

    if ($formatted_email =~ /^([^<]+)<(.+\@.*)>.*$/) {
	$name = $1;
	$address = $2;
    } elsif ($formatted_email =~ /^\s*<(.+\@\S*)>.*$/) {
	$address = $1;
    } elsif ($formatted_email =~ /^(.+\@\S*).*$/) {
	$address = $1;
    }

    $name =~ s/^\s+|\s+$//g;
    $name =~ s/^\"|\"$//g;
    $address =~ s/^\s+|\s+$//g;

    if ($name =~ /[^\w \-]/i) {  	 ##has "must quote" chars
	$name =~ s/(?<!\\)"/\\"/g;       ##escape quotes
	$name = "\"$name\"";
    }

    return ($name, $address);
}

sub format_email {
    my ($name, $address, $usename) = @_;

    my $formatted_email;

    $name =~ s/^\s+|\s+$//g;
    $name =~ s/^\"|\"$//g;
    $address =~ s/^\s+|\s+$//g;

    if ($name =~ /[^\w \-]/i) {          ##has "must quote" chars
	$name =~ s/(?<!\\)"/\\"/g;       ##escape quotes
	$name = "\"$name\"";
    }

    if ($usename) {
	if ("$name" eq "") {
	    $formatted_email = "$address";
	} else {
	    $formatted_email = "$name <$address>";
	}
    } else {
	$formatted_email = $address;
    }

    return $formatted_email;
}

sub find_first_section {
    my $index = 0;

    while ($index < @typevalue) {
	my $tv = $typevalue[$index];
	if (($tv =~ m/^(\C):\s*(.*)/)) {
	    last;
	}
	$index++;
    }

    return $index;
}

sub find_starting_index {
    my ($index) = @_;

    while ($index > 0) {
	my $tv = $typevalue[$index];
	if (!($tv =~ m/^(\C):\s*(.*)/)) {
	    last;
	}
	$index--;
    }

    return $index;
}

sub find_ending_index {
    my ($index) = @_;

    while ($index < @typevalue) {
	my $tv = $typevalue[$index];
	if (!($tv =~ m/^(\C):\s*(.*)/)) {
	    last;
	}
	$index++;
    }

    return $index;
}

sub get_maintainer_role {
    my ($index) = @_;

    my $i;
    my $start = find_starting_index($index);
    my $end = find_ending_index($index);

    my $role = "unknown";
    my $subsystem = $typevalue[$start];
    if (length($subsystem) > 20) {
	$subsystem = substr($subsystem, 0, 17);
	$subsystem =~ s/\s*$//;
	$subsystem = $subsystem . "...";
    }

    for ($i = $start + 1; $i < $end; $i++) {
	my $tv = $typevalue[$i];
	if ($tv =~ m/^(\C):\s*(.*)/) {
	    my $ptype = $1;
	    my $pvalue = $2;
	    if ($ptype eq "S") {
		$role = $pvalue;
	    }
	}
    }

    $role = lc($role);
    if      ($role eq "supported") {
	$role = "supporter";
    } elsif ($role eq "maintained") {
	$role = "maintainer";
    } elsif ($role eq "odd fixes") {
	$role = "odd fixer";
    } elsif ($role eq "orphan") {
	$role = "orphan minder";
    } elsif ($role eq "obsolete") {
	$role = "obsolete minder";
    } elsif ($role eq "buried alive in reporters") {
	$role = "chief penguin";
    }

    return $role . ":" . $subsystem;
}

sub get_list_role {
    my ($index) = @_;

    my $i;
    my $start = find_starting_index($index);
    my $end = find_ending_index($index);

    my $subsystem = $typevalue[$start];
    if (length($subsystem) > 20) {
	$subsystem = substr($subsystem, 0, 17);
	$subsystem =~ s/\s*$//;
	$subsystem = $subsystem . "...";
    }

    if ($subsystem eq "THE REST") {
	$subsystem = "";
    }

    return $subsystem;
}

sub add_categories {
    my ($index) = @_;

    my $i;
    my $start = find_starting_index($index);
    my $end = find_ending_index($index);

    push(@subsystem, $typevalue[$start]);

    for ($i = $start + 1; $i < $end; $i++) {
	my $tv = $typevalue[$i];
	if ($tv =~ m/^(\C):\s*(.*)/) {
	    my $ptype = $1;
	    my $pvalue = $2;
	    if ($ptype eq "L") {
		my $list_address = $pvalue;
		my $list_additional = "";
		my $list_role = get_list_role($i);

		if ($list_role ne "") {
		    $list_role = ":" . $list_role;
		}
		if ($list_address =~ m/([^\s]+)\s+(.*)$/) {
		    $list_address = $1;
		    $list_additional = $2;
		}
		if ($list_additional =~ m/subscribers-only/) {
		    if ($email_subscriber_list) {
			if (!$hash_list_to{lc($list_address)}) {
			    $hash_list_to{lc($list_address)} = 1;
			    push(@list_to, [$list_address,
					    "subscriber list${list_role}"]);
			}
		    }
		} else {
		    if ($email_list) {
			if (!$hash_list_to{lc($list_address)}) {
			    $hash_list_to{lc($list_address)} = 1;
			    if ($list_additional =~ m/moderated/) {
				push(@list_to, [$list_address,
						"moderated list${list_role}"]);
			    } else {
				push(@list_to, [$list_address,
						"open list${list_role}"]);
			    }
			}
		    }
		}
	    } elsif ($ptype eq "M") {
		my ($name, $address) = parse_email($pvalue);
		if ($name eq "") {
		    if ($i > 0) {
			my $tv = $typevalue[$i - 1];
			if ($tv =~ m/^(\C):\s*(.*)/) {
			    if ($1 eq "P") {
				$name = $2;
				$pvalue = format_email($name, $address, $email_usename);
			    }
			}
		    }
		}
		if ($email_maintainer) {
		    my $role = get_maintainer_role($i);
		    push_email_addresses($pvalue, $role);
		}
	    } elsif ($ptype eq "R") {
		my ($name, $address) = parse_email($pvalue);
		if ($name eq "") {
		    if ($i > 0) {
			my $tv = $typevalue[$i - 1];
			if ($tv =~ m/^(\C):\s*(.*)/) {
			    if ($1 eq "P") {
				$name = $2;
				$pvalue = format_email($name, $address, $email_usename);
			    }
			}
		    }
		}
		if ($email_reviewer) {
		    push_email_addresses($pvalue, 'reviewer');
		}
	    } elsif ($ptype eq "T") {
		push(@scm, $pvalue);
	    } elsif ($ptype eq "W") {
		push(@web, $pvalue);
	    } elsif ($ptype eq "S") {
		push(@status, $pvalue);
	    }
	}
    }
}

sub email_inuse {
    my ($name, $address) = @_;

    return 1 if (($name eq "") && ($address eq ""));
    return 1 if (($name ne "") && exists($email_hash_name{lc($name)}));
    return 1 if (($address ne "") && exists($email_hash_address{lc($address)}));

    return 0;
}

sub push_email_address {
    my ($line, $role) = @_;

    my ($name, $address) = parse_email($line);

    if ($address eq "") {
	return 0;
    }

    if (!$email_remove_duplicates) {
	push(@email_to, [format_email($name, $address, $email_usename), $role]);
    } elsif (!email_inuse($name, $address)) {
	push(@email_to, [format_email($name, $address, $email_usename), $role]);
	$email_hash_name{lc($name)}++ if ($name ne "");
	$email_hash_address{lc($address)}++;
    }

    return 1;
}

sub push_email_addresses {
    my ($address, $role) = @_;

    my @address_list = ();

    if (rfc822_valid($address)) {
	push_email_address($address, $role);
    } elsif (@address_list = rfc822_validlist($address)) {
	my $array_count = shift(@address_list);
	while (my $entry = shift(@address_list)) {
	    push_email_address($entry, $role);
	}
    } else {
	if (!push_email_address($address, $role)) {
	    warn("Invalid MAINTAINERS address: '" . $address . "'\n");
	}
    }
}

sub add_role {
    my ($line, $role) = @_;

    my ($name, $address) = parse_email($line);
    my $email = format_email($name, $address, $email_usename);

    foreach my $entry (@email_to) {
	if ($email_remove_duplicates) {
	    my ($entry_name, $entry_address) = parse_email($entry->[0]);
	    if (($name eq $entry_name || $address eq $entry_address)
		&& ($role eq "" || !($entry->[1] =~ m/$role/))
	    ) {
		if ($entry->[1] eq "") {
		    $entry->[1] = "$role";
		} else {
		    $entry->[1] = "$entry->[1],$role";
		}
	    }
	} else {
	    if ($email eq $entry->[0]
		&& ($role eq "" || !($entry->[1] =~ m/$role/))
	    ) {
		if ($entry->[1] eq "") {
		    $entry->[1] = "$role";
		} else {
		    $entry->[1] = "$entry->[1],$role";
		}
	    }
	}
    }
}

sub which {
    my ($bin) = @_;

    foreach my $path (split(/:/, $ENV{PATH})) {
	if (-e "$path/$bin") {
	    return "$path/$bin";
	}
    }

    return "";
}

sub which_conf {
    my ($conf) = @_;

    foreach my $path (split(/:/, ".:$ENV{HOME}:.scripts")) {
	if (-e "$path/$conf") {
	    return "$path/$conf";
	}
    }

    return "";
}

sub mailmap_email {
    my ($line) = @_;

    my ($name, $address) = parse_email($line);
    my $email = format_email($name, $address, 1);
    my $real_name = $name;
    my $real_address = $address;

    if (exists $mailmap->{names}->{$email} ||
	exists $mailmap->{addresses}->{$email}) {
	if (exists $mailmap->{names}->{$email}) {
	    $real_name = $mailmap->{names}->{$email};
	}
	if (exists $mailmap->{addresses}->{$email}) {
	    $real_address = $mailmap->{addresses}->{$email};
	}
    } else {
	if (exists $mailmap->{names}->{$address}) {
	    $real_name = $mailmap->{names}->{$address};
	}
	if (exists $mailmap->{addresses}->{$address}) {
	    $real_address = $mailmap->{addresses}->{$address};
	}
    }
    return format_email($real_name, $real_address, 1);
}

sub mailmap {
    my (@addresses) = @_;

    my @mapped_emails = ();
    foreach my $line (@addresses) {
	push(@mapped_emails, mailmap_email($line));
    }
    merge_by_realname(@mapped_emails) if ($email_use_mailmap);
    return @mapped_emails;
}

sub merge_by_realname {
    my %address_map;
    my (@emails) = @_;

    foreach my $email (@emails) {
	my ($name, $address) = parse_email($email);
	if (exists $address_map{$name}) {
	    $address = $address_map{$name};
	    $email = format_email($name, $address, 1);
	} else {
	    $address_map{$name} = $address;
	}
    }
}

sub git_execute_cmd {
    my ($cmd) = @_;
    my @lines = ();

    my $output = `$cmd`;
    $output =~ s/^\s*//gm;
    @lines = split("\n", $output);

    return @lines;
}

sub hg_execute_cmd {
    my ($cmd) = @_;
    my @lines = ();

    my $output = `$cmd`;
    @lines = split("\n", $output);

    return @lines;
}

sub extract_formatted_signatures {
    my (@signature_lines) = @_;

    my @type = @signature_lines;

    s/\s*(.*):.*/$1/ for (@type);

    # cut -f2- -d":"
    s/\s*.*:\s*(.+)\s*/$1/ for (@signature_lines);

## Reformat email addresses (with names) to avoid badly written signatures

    foreach my $signer (@signature_lines) {
	$signer = deduplicate_email($signer);
    }

    return (\@type, \@signature_lines);
}

sub vcs_find_signers {
    my ($cmd, $file) = @_;
    my $commits;
    my @lines = ();
    my @signatures = ();
    my @authors = ();
    my @stats = ();

    @lines = &{$VCS_cmds{"execute_cmd"}}($cmd);

    my $pattern = $VCS_cmds{"commit_pattern"};
    my $author_pattern = $VCS_cmds{"author_pattern"};
    my $stat_pattern = $VCS_cmds{"stat_pattern"};

    $stat_pattern =~ s/(\$\w+)/$1/eeg;		#interpolate $stat_pattern

    $commits = grep(/$pattern/, @lines);	# of commits

    @authors = grep(/$author_pattern/, @lines);
    @signatures = grep(/^[ \t]*${signature_pattern}.*\@.*$/, @lines);
    @stats = grep(/$stat_pattern/, @lines);

#    print("stats: <@stats>\n");

    return (0, \@signatures, \@authors, \@stats) if !@signatures;

    save_commits_by_author(@lines) if ($interactive);
    save_commits_by_signer(@lines) if ($interactive);

    if (!$email_git_penguin_chiefs) {
	@signatures = grep(!/${penguin_chiefs}/i, @signatures);
    }

    my ($author_ref, $authors_ref) = extract_formatted_signatures(@authors);
    my ($types_ref, $signers_ref) = extract_formatted_signatures(@signatures);

    return ($commits, $signers_ref, $authors_ref, \@stats);
}

sub vcs_find_author {
    my ($cmd) = @_;
    my @lines = ();

    @lines = &{$VCS_cmds{"execute_cmd"}}($cmd);

    if (!$email_git_penguin_chiefs) {
	@lines = grep(!/${penguin_chiefs}/i, @lines);
    }

    return @lines if !@lines;

    my @authors = ();
    foreach my $line (@lines) {
	if ($line =~ m/$VCS_cmds{"author_pattern"}/) {
	    my $author = $1;
	    my ($name, $address) = parse_email($author);
	    $author = format_email($name, $address, 1);
	    push(@authors, $author);
	}
    }

    save_commits_by_author(@lines) if ($interactive);
    save_commits_by_signer(@lines) if ($interactive);

    return @authors;
}

sub vcs_save_commits {
    my ($cmd) = @_;
    my @lines = ();
    my @commits = ();

    @lines = &{$VCS_cmds{"execute_cmd"}}($cmd);

    foreach my $line (@lines) {
	if ($line =~ m/$VCS_cmds{"blame_commit_pattern"}/) {
	    push(@commits, $1);
	}
    }

    return @commits;
}

sub vcs_blame {
    my ($file) = @_;
    my $cmd;
    my @commits = ();

    return @commits if (!(-f $file));

    if (@range && $VCS_cmds{"blame_range_cmd"} eq "") {
	my @all_commits = ();

	$cmd = $VCS_cmds{"blame_file_cmd"};
	$cmd =~ s/(\$\w+)/$1/eeg;		#interpolate $cmd
	@all_commits = vcs_save_commits($cmd);

	foreach my $file_range_diff (@range) {
	    next if (!($file_range_diff =~ m/(.+):(.+):(.+)/));
	    my $diff_file = $1;
	    my $diff_start = $2;
	    my $diff_length = $3;
	    next if ("$file" ne "$diff_file");
	    for (my $i = $diff_start; $i < $diff_start + $diff_length; $i++) {
		push(@commits, $all_commits[$i]);
	    }
	}
    } elsif (@range) {
	foreach my $file_range_diff (@range) {
	    next if (!($file_range_diff =~ m/(.+):(.+):(.+)/));
	    my $diff_file = $1;
	    my $diff_start = $2;
	    my $diff_length = $3;
	    next if ("$file" ne "$diff_file");
	    $cmd = $VCS_cmds{"blame_range_cmd"};
	    $cmd =~ s/(\$\w+)/$1/eeg;		#interpolate $cmd
	    push(@commits, vcs_save_commits($cmd));
	}
    } else {
	$cmd = $VCS_cmds{"blame_file_cmd"};
	$cmd =~ s/(\$\w+)/$1/eeg;		#interpolate $cmd
	@commits = vcs_save_commits($cmd);
    }

    foreach my $commit (@commits) {
	$commit =~ s/^\^//g;
    }

    return @commits;
}

my $printed_novcs = 0;
sub vcs_exists {
    %VCS_cmds = %VCS_cmds_git;
    return 1 if eval $VCS_cmds{"available"};
    %VCS_cmds = %VCS_cmds_hg;
    return 2 if eval $VCS_cmds{"available"};
    %VCS_cmds = ();
    if (!$printed_novcs) {
	warn("$P: No supported VCS found.  Add --nogit to options?\n");
	warn("Using a git repository produces better results.\n");
	warn("Try Linus Torvalds' latest git repository using:\n");
	warn("git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n");
	$printed_novcs = 1;
    }
    return 0;
}

sub vcs_is_git {
    vcs_exists();
    return $vcs_used == 1;
}

sub vcs_is_hg {
    return $vcs_used == 2;
}

sub interactive_get_maintainers {
    my ($list_ref) = @_;
    my @list = @$list_ref;

    vcs_exists();

    my %selected;
    my %authored;
    my %signed;
    my $count = 0;
    my $maintained = 0;
    foreach my $entry (@list) {
	$maintained = 1 if ($entry->[1] =~ /^(maintainer|supporter)/i);
	$selected{$count} = 1;
	$authored{$count} = 0;
	$signed{$count} = 0;
	$count++;
    }

    #menu loop
    my $done = 0;
    my $print_options = 0;
    my $redraw = 1;
    while (!$done) {
	$count = 0;
	if ($redraw) {
	    printf STDERR "\n%1s %2s %-65s",
			  "*", "#", "email/list and role:stats";
	    if ($email_git ||
		($email_git_fallback && !$maintained) ||
		$email_git_blame) {
		print STDERR "auth sign";
	    }
	    print STDERR "\n";
	    foreach my $entry (@list) {
		my $email = $entry->[0];
		my $role = $entry->[1];
		my $sel = "";
		$sel = "*" if ($selected{$count});
		my $commit_author = $commit_author_hash{$email};
		my $commit_signer = $commit_signer_hash{$email};
		my $authored = 0;
		my $signed = 0;
		$authored++ for (@{$commit_author});
		$signed++ for (@{$commit_signer});
		printf STDERR "%1s %2d %-65s", $sel, $count + 1, $email;
		printf STDERR "%4d %4d", $authored, $signed
		    if ($authored > 0 || $signed > 0);
		printf STDERR "\n     %s\n", $role;
		if ($authored{$count}) {
		    my $commit_author = $commit_author_hash{$email};
		    foreach my $ref (@{$commit_author}) {
			print STDERR "     Author: @{$ref}[1]\n";
		    }
		}
		if ($signed{$count}) {
		    my $commit_signer = $commit_signer_hash{$email};
		    foreach my $ref (@{$commit_signer}) {
			print STDERR "     @{$ref}[2]: @{$ref}[1]\n";
		    }
		}

		$count++;
	    }
	}
	my $date_ref = \$email_git_since;
	$date_ref = \$email_hg_since if (vcs_is_hg());
	if ($print_options) {
	    $print_options = 0;
	    if (vcs_exists()) {
		print STDERR <<EOT

Version Control options:
g  use git history      [$email_git]
gf use git-fallback     [$email_git_fallback]
b  use git blame        [$email_git_blame]
bs use blame signatures [$email_git_blame_signatures]
c# minimum commits      [$email_git_min_signatures]
%# min percent          [$email_git_min_percent]
d# history to use       [$$date_ref]
x# max maintainers      [$email_git_max_maintainers]
t  all signature types  [$email_git_all_signature_types]
m  use .mailmap         [$email_use_mailmap]
EOT
	    }
	    print STDERR <<EOT

Additional options:
0  toggle all
tm toggle maintainers
tg toggle git entries
tl toggle open list entries
ts toggle subscriber list entries
f  emails in file       [$file_emails]
k  keywords in file     [$keywords]
r  remove duplicates    [$email_remove_duplicates]
p# pattern match depth  [$pattern_depth]
EOT
	}
	print STDERR
"\n#(toggle), A#(author), S#(signed) *(all), ^(none), O(options), Y(approve): ";

	my $input = <STDIN>;
	chomp($input);

	$redraw = 1;
	my $rerun = 0;
	my @wish = split(/[, ]+/, $input);
	foreach my $nr (@wish) {
	    $nr = lc($nr);
	    my $sel = substr($nr, 0, 1);
	    my $str = substr($nr, 1);
	    my $val = 0;
	    $val = $1 if $str =~ /^(\d+)$/;

	    if ($sel eq "y") {
		$interactive = 0;
		$done = 1;
		$output_rolestats = 0;
		$output_roles = 0;
		last;
	    } elsif ($nr =~ /^\d+$/ && $nr > 0 && $nr <= $count) {
		$selected{$nr - 1} = !$selected{$nr - 1};
	    } elsif ($sel eq "*" || $sel eq '^') {
		my $toggle = 0;
		$toggle = 1 if ($sel eq '*');
		for (my $i = 0; $i < $count; $i++) {
		    $selected{$i} = $toggle;
		}
	    } elsif ($sel eq "0") {
		for (my $i = 0; $i < $count; $i++) {
		    $selected{$i} = !$selected{$i};
		}
	    } elsif ($sel eq "t") {
		if (lc($str) eq "m") {
		    for (my $i = 0; $i < $count; $i++) {
			$selected{$i} = !$selected{$i}
			    if ($list[$i]->[1] =~ /^(maintainer|supporter)/i);
		    }
		} elsif (lc($str) eq "g") {
		    for (my $i = 0; $i < $count; $i++) {
			$selected{$i} = !$selected{$i}
			    if ($list[$i]->[1] =~ /^(author|commit|signer)/i);
		    }
		} elsif (lc($str) eq "l") {
		    for (my $i = 0; $i < $count; $i++) {
			$selected{$i} = !$selected{$i}
			    if ($list[$i]->[1] =~ /^(open list)/i);
		    }
		} elsif (lc($str) eq "s") {
		    for (my $i = 0; $i < $count; $i++) {
			$selected{$i} = !$selected{$i}
			    if ($list[$i]->[1] =~ /^(subscriber list)/i);
		    }
		}
	    } elsif ($sel eq "a") {
		if ($val > 0 && $val <= $count) {
		    $authored{$val - 1} = !$authored{$val - 1};
		} elsif ($str eq '*' || $str eq '^') {
		    my $toggle = 0;
		    $toggle = 1 if ($str eq '*');
		    for (my $i = 0; $i < $count; $i++) {
			$authored{$i} = $toggle;
		    }
		}
	    } elsif ($sel eq "s") {
		if ($val > 0 && $val <= $count) {
		    $signed{$val - 1} = !$signed{$val - 1};
		} elsif ($str eq '*' || $str eq '^') {
		    my $toggle = 0;
		    $toggle = 1 if ($str eq '*');
		    for (my $i = 0; $i < $count; $i++) {
			$signed{$i} = $toggle;
		    }
		}
	    } elsif ($sel eq "o") {
		$print_options = 1;
		$redraw = 1;
	    } elsif ($sel eq "g") {
		if ($str eq "f") {
		    bool_invert(\$email_git_fallback);
		} else {
		    bool_invert(\$email_git);
		}
		$rerun = 1;
	    } elsif ($sel eq "b") {
		if ($str eq "s") {
		    bool_invert(\$email_git_blame_signatures);
		} else {
		    bool_invert(\$email_git_blame);
		}
		$rerun = 1;
	    } elsif ($sel eq "c") {
		if ($val > 0) {
		    $email_git_min_signatures = $val;
		    $rerun = 1;
		}
	    } elsif ($sel eq "x") {
		if ($val > 0) {
		    $email_git_max_maintainers = $val;
		    $rerun = 1;
		}
	    } elsif ($sel eq "%") {
		if ($str ne "" && $val >= 0) {
		    $email_git_min_percent = $val;
		    $rerun = 1;
		}
	    } elsif ($sel eq "d") {
		if (vcs_is_git()) {
		    $email_git_since = $str;
		} elsif (vcs_is_hg()) {
		    $email_hg_since = $str;
		}
		$rerun = 1;
	    } elsif ($sel eq "t") {
		bool_invert(\$email_git_all_signature_types);
		$rerun = 1;
	    } elsif ($sel eq "f") {
		bool_invert(\$file_emails);
		$rerun = 1;
	    } elsif ($sel eq "r") {
		bool_invert(\$email_remove_duplicates);
		$rerun = 1;
	    } elsif ($sel eq "m") {
		bool_invert(\$email_use_mailmap);
		read_mailmap();
		$rerun = 1;
	    } elsif ($sel eq "k") {
		bool_invert(\$keywords);
		$rerun = 1;
	    } elsif ($sel eq "p") {
		if ($str ne "" && $val >= 0) {
		    $pattern_depth = $val;
		    $rerun = 1;
		}
	    } elsif ($sel eq "h" || $sel eq "?") {
		print STDERR <<EOT

Interactive mode allows you to select the various maintainers, submitters,
commit signers and mailing lists that could be CC'd on a patch.

Any *'d entry is selected.

If you have git or hg installed, you can choose to summarize the commit
history of files in the patch.  Also, each line of the current file can
be matched to its commit author and that commits signers with blame.

Various knobs exist to control the length of time for active commit
tracking, the maximum number of commit authors and signers to add,
and such.

Enter selections at the prompt until you are satisfied that the selected
maintainers are appropriate.  You may enter multiple selections separated
by either commas or spaces.

EOT
	    } else {
		print STDERR "invalid option: '$nr'\n";
		$redraw = 0;
	    }
	}
	if ($rerun) {
	    print STDERR "git-blame can be very slow, please have patience..."
		if ($email_git_blame);
	    goto &get_maintainers;
	}
    }

    #drop not selected entries
    $count = 0;
    my @new_emailto = ();
    foreach my $entry (@list) {
	if ($selected{$count}) {
	    push(@new_emailto, $list[$count]);
	}
	$count++;
    }
    return @new_emailto;
}

sub bool_invert {
    my ($bool_ref) = @_;

    if ($$bool_ref) {
	$$bool_ref = 0;
    } else {
	$$bool_ref = 1;
    }
}

sub deduplicate_email {
    my ($email) = @_;

    my $matched = 0;
    my ($name, $address) = parse_email($email);
    $email = format_email($name, $address, 1);
    $email = mailmap_email($email);

    return $email if (!$email_remove_duplicates);

    ($name, $address) = parse_email($email);

    if ($name ne "" && $deduplicate_name_hash{lc($name)}) {
	$name = $deduplicate_name_hash{lc($name)}->[0];
	$address = $deduplicate_name_hash{lc($name)}->[1];
	$matched = 1;
    } elsif ($deduplicate_address_hash{lc($address)}) {
	$name = $deduplicate_address_hash{lc($address)}->[0];
	$address = $deduplicate_address_hash{lc($address)}->[1];
	$matched = 1;
    }
    if (!$matched) {
	$deduplicate_name_hash{lc($name)} = [ $name, $address ];
	$deduplicate_address_hash{lc($address)} = [ $name, $address ];
    }
    $email = format_email($name, $address, 1);
    $email = mailmap_email($email);
    return $email;
}

sub save_commits_by_author {
    my (@lines) = @_;

    my @authors = ();
    my @commits = ();
    my @subjects = ();

    foreach my $line (@lines) {
	if ($line =~ m/$VCS_cmds{"author_pattern"}/) {
	    my $author = $1;
	    $author = deduplicate_email($author);
	    push(@authors, $author);
	}
	push(@commits, $1) if ($line =~ m/$VCS_cmds{"commit_pattern"}/);
	push(@subjects, $1) if ($line =~ m/$VCS_cmds{"subject_pattern"}/);
    }

    for (my $i = 0; $i < @authors; $i++) {
	my $exists = 0;
	foreach my $ref(@{$commit_author_hash{$authors[$i]}}) {
	    if (@{$ref}[0] eq $commits[$i] &&
		@{$ref}[1] eq $subjects[$i]) {
		$exists = 1;
		last;
	    }
	}
	if (!$exists) {
	    push(@{$commit_author_hash{$authors[$i]}},
		 [ ($commits[$i], $subjects[$i]) ]);
	}
    }
}

sub save_commits_by_signer {
    my (@lines) = @_;

    my $commit = "";
    my $subject = "";

    foreach my $line (@lines) {
	$commit = $1 if ($line =~ m/$VCS_cmds{"commit_pattern"}/);
	$subject = $1 if ($line =~ m/$VCS_cmds{"subject_pattern"}/);
	if ($line =~ /^[ \t]*${signature_pattern}.*\@.*$/) {
	    my @signatures = ($line);
	    my ($types_ref, $signers_ref) = extract_formatted_signatures(@signatures);
	    my @types = @$types_ref;
	    my @signers = @$signers_ref;

	    my $type = $types[0];
	    my $signer = $signers[0];

	    $signer = deduplicate_email($signer);

	    my $exists = 0;
	    foreach my $ref(@{$commit_signer_hash{$signer}}) {
		if (@{$ref}[0] eq $commit &&
		    @{$ref}[1] eq $subject &&
		    @{$ref}[2] eq $type) {
		    $exists = 1;
		    last;
		}
	    }
	    if (!$exists) {
		push(@{$commit_signer_hash{$signer}},
		     [ ($commit, $subject, $type) ]);
	    }
	}
    }
}

sub vcs_assign {
    my ($role, $divisor, @lines) = @_;

    my %hash;
    my $count = 0;

    return if (@lines <= 0);

    if ($divisor <= 0) {
	warn("Bad divisor in " . (caller(0))[3] . ": $divisor\n");
	$divisor = 1;
    }

    @lines = mailmap(@lines);

    return if (@lines <= 0);

    @lines = sort(@lines);

    # uniq -c
    $hash{$_}++ for @lines;

    # sort -rn
    foreach my $line (sort {$hash{$b} <=> $hash{$a}} keys %hash) {
	my $sign_offs = $hash{$line};
	my $percent = $sign_offs * 100 / $divisor;

	$percent = 100 if ($percent > 100);
	$count++;
	last if ($sign_offs < $email_git_min_signatures ||
		 $count > $email_git_max_maintainers ||
		 $percent < $email_git_min_percent);
	push_email_address($line, '');
	if ($output_rolestats) {
	    my $fmt_percent = sprintf("%.0f", $percent);
	    add_role($line, "$role:$sign_offs/$divisor=$fmt_percent%");
	} else {
	    add_role($line, $role);
	}
    }
}

sub vcs_file_signoffs {
    my ($file) = @_;

    my $authors_ref;
    my $signers_ref;
    my $stats_ref;
    my @authors = ();
    my @signers = ();
    my @stats = ();
    my $commits;

    $vcs_used = vcs_exists();
    return if (!$vcs_used);

    my $cmd = $VCS_cmds{"find_signers_cmd"};
    $cmd =~ s/(\$\w+)/$1/eeg;		# interpolate $cmd

    ($commits, $signers_ref, $authors_ref, $stats_ref) = vcs_find_signers($cmd, $file);

    @signers = @{$signers_ref} if defined $signers_ref;
    @authors = @{$authors_ref} if defined $authors_ref;
    @stats = @{$stats_ref} if defined $stats_ref;

#    print("commits: <$commits>\nsigners:<@signers>\nauthors: <@authors>\nstats: <@stats>\n");

    foreach my $signer (@signers) {
	$signer = deduplicate_email($signer);
    }

    vcs_assign("commit_signer", $commits, @signers);
    vcs_assign("authored", $commits, @authors);
    if ($#authors == $#stats) {
	my $stat_pattern = $VCS_cmds{"stat_pattern"};
	$stat_pattern =~ s/(\$\w+)/$1/eeg;	#interpolate $stat_pattern

	my $added = 0;
	my $deleted = 0;
	for (my $i = 0; $i <= $#stats; $i++) {
	    if ($stats[$i] =~ /$stat_pattern/) {
		$added += $1;
		$deleted += $2;
	    }
	}
	my @tmp_authors = uniq(@authors);
	foreach my $author (@tmp_authors) {
	    $author = deduplicate_email($author);
	}
	@tmp_authors = uniq(@tmp_authors);
	my @list_added = ();
	my @list_deleted = ();
	foreach my $author (@tmp_authors) {
	    my $auth_added = 0;
	    my $auth_deleted = 0;
	    for (my $i = 0; $i <= $#stats; $i++) {
		if ($author eq deduplicate_email($authors[$i]) &&
		    $stats[$i] =~ /$stat_pattern/) {
		    $auth_added += $1;
		    $auth_deleted += $2;
		}
	    }
	    for (my $i = 0; $i < $auth_added; $i++) {
		push(@list_added, $author);
	    }
	    for (my $i = 0; $i < $auth_deleted; $i++) {
		push(@list_deleted, $author);
	    }
	}
	vcs_assign("added_lines", $added, @list_added);
	vcs_assign("removed_lines", $deleted, @list_deleted);
    }
}

sub vcs_file_blame {
    my ($file) = @_;

    my @signers = ();
    my @all_commits = ();
    my @commits = ();
    my $total_commits;
    my $total_lines;

    $vcs_used = vcs_exists();
    return if (!$vcs_used);

    @all_commits = vcs_blame($file);
    @commits = uniq(@all_commits);
    $total_commits = @commits;
    $total_lines = @all_commits;

    if ($email_git_blame_signatures) {
	if (vcs_is_hg()) {
	    my $commit_count;
	    my $commit_authors_ref;
	    my $commit_signers_ref;
	    my $stats_ref;
	    my @commit_authors = ();
	    my @commit_signers = ();
	    my $commit = join(" -r ", @commits);
	    my $cmd;

	    $cmd = $VCS_cmds{"find_commit_signers_cmd"};
	    $cmd =~ s/(\$\w+)/$1/eeg;	#substitute variables in $cmd

	    ($commit_count, $commit_signers_ref, $commit_authors_ref, $stats_ref) = vcs_find_signers($cmd, $file);
	    @commit_authors = @{$commit_authors_ref} if defined $commit_authors_ref;
	    @commit_signers = @{$commit_signers_ref} if defined $commit_signers_ref;

	    push(@signers, @commit_signers);
	} else {
	    foreach my $commit (@commits) {
		my $commit_count;
		my $commit_authors_ref;
		my $commit_signers_ref;
		my $stats_ref;
		my @commit_authors = ();
		my @commit_signers = ();
		my $cmd;

		$cmd = $VCS_cmds{"find_commit_signers_cmd"};
		$cmd =~ s/(\$\w+)/$1/eeg;	#substitute variables in $cmd

		($commit_count, $commit_signers_ref, $commit_authors_ref, $stats_ref) = vcs_find_signers($cmd, $file);
		@commit_authors = @{$commit_authors_ref} if defined $commit_authors_ref;
		@commit_signers = @{$commit_signers_ref} if defined $commit_signers_ref;

		push(@signers, @commit_signers);
	    }
	}
    }

    if ($from_filename) {
	if ($output_rolestats) {
	    my @blame_signers;
	    if (vcs_is_hg()) {{		# Double brace for last exit
		my $commit_count;
		my @commit_signers = ();
		@commits = uniq(@commits);
		@commits = sort(@commits);
		my $commit = join(" -r ", @commits);
		my $cmd;

		$cmd = $VCS_cmds{"find_commit_author_cmd"};
		$cmd =~ s/(\$\w+)/$1/eeg;	#substitute variables in $cmd

		my @lines = ();

		@lines = &{$VCS_cmds{"execute_cmd"}}($cmd);

		if (!$email_git_penguin_chiefs) {
		    @lines = grep(!/${penguin_chiefs}/i, @lines);
		}

		last if !@lines;

		my @authors = ();
		foreach my $line (@lines) {
		    if ($line =~ m/$VCS_cmds{"author_pattern"}/) {
			my $author = $1;
			$author = deduplicate_email($author);
			push(@authors, $author);
		    }
		}

		save_commits_by_author(@lines) if ($interactive);
		save_commits_by_signer(@lines) if ($interactive);

		push(@signers, @authors);
	    }}
	    else {
		foreach my $commit (@commits) {
		    my $i;
		    my $cmd = $VCS_cmds{"find_commit_author_cmd"};
		    $cmd =~ s/(\$\w+)/$1/eeg;	#interpolate $cmd
		    my @author = vcs_find_author($cmd);
		    next if !@author;

		    my $formatted_author = deduplicate_email($author[0]);

		    my $count = grep(/$commit/, @all_commits);
		    for ($i = 0; $i < $count ; $i++) {
			push(@blame_signers, $formatted_author);
		    }
		}
	    }
	    if (@blame_signers) {
		vcs_assign("authored lines", $total_lines, @blame_signers);
	    }
	}
	foreach my $signer (@signers) {
	    $signer = deduplicate_email($signer);
	}
	vcs_assign("commits", $total_commits, @signers);
    } else {
	foreach my $signer (@signers) {
	    $signer = deduplicate_email($signer);
	}
	vcs_assign("modified commits", $total_commits, @signers);
    }
}

sub uniq {
    my (@parms) = @_;

    my %saw;
    @parms = grep(!$saw{$_}++, @parms);
    return @parms;
}

sub sort_and_uniq {
    my (@parms) = @_;

    my %saw;
    @parms = sort @parms;
    @parms = grep(!$saw{$_}++, @parms);
    return @parms;
}

sub clean_file_emails {
    my (@file_emails) = @_;
    my @fmt_emails = ();

    foreach my $email (@file_emails) {
	$email =~ s/[\(\<\{]{0,1}([A-Za-z0-9_\.\+-]+\@[A-Za-z0-9\.-]+)[\)\>\}]{0,1}/\<$1\>/g;
	my ($name, $address) = parse_email($email);
	if ($name eq '"[,\.]"') {
	    $name = "";
	}

	my @nw = split(/[^A-Za-zÃ€-Ã¿\'\,\.\+-]/, $name);
	if (@nw > 2) {
	    my $first = $nw[@nw - 3];
	    my $middle = $nw[@nw - 2];
	    my $last = $nw[@nw - 1];

	    if (((length($first) == 1 && $first =~ m/[A-Za-z]/) ||
		 (length($first) == 2 && substr($first, -1) eq ".")) ||
		(length($middle) == 1 ||
		 (length($middle) == 2 && substr($middle, -1) eq "."))) {
		$name = "$first $middle $last";
	    } else {
		$name = "$middle $last";
	    }
	}

	if (substr($name, -1) =~ /[,\.]/) {
	    $name = substr($name, 0, length($name) - 1);
	} elsif (substr($name, -2) =~ /[,\.]"/) {
	    $name = substr($name, 0, length($name) - 2) . '"';
	}

	if (substr($name, 0, 1) =~ /[,\.]/) {
	    $name = substr($name, 1, length($name) - 1);
	} elsif (substr($name, 0, 2) =~ /"[,\.]/) {
	    $name = '"' . substr($name, 2, length($name) - 2);
	}

	my $fmt_email = format_email($name, $address, $email_usename);
	push(@fmt_emails, $fmt_email);
    }
    return @fmt_emails;
}

sub merge_email {
    my @lines;
    my %saw;

    for (@_) {
	my ($address, $role) = @$_;
	if (!$saw{$address}) {
	    if ($output_roles) {
		push(@lines, "$address ($role)");
	    } else {
		push(@lines, $address);
	    }
	    $saw{$address} = 1;
	}
    }

    return @lines;
}

sub output {
    my (@parms) = @_;

    if ($output_multiline) {
	foreach my $line (@parms) {
	    print("${line}\n");
	}
    } else {
	print(join($output_separator, @parms));
	print("\n");
    }
}

my $rfc822re;

sub make_rfc822re {
#   Basic lexical tokens are specials, domain_literal, quoted_string, atom, and
#   comment.  We must allow for rfc822_lwsp (or comments) after each of these.
#   This regexp will only work on addresses which have had comments stripped
#   and replaced with rfc822_lwsp.

    my $specials = '()<>@,;:\\\\".\\[\\]';
    my $controls = '\\000-\\037\\177';

    my $dtext = "[^\\[\\]\\r\\\\]";
    my $domain_literal = "\\[(?:$dtext|\\\\.)*\\]$rfc822_lwsp*";

    my $quoted_string = "\"(?:[^\\\"\\r\\\\]|\\\\.|$rfc822_lwsp)*\"$rfc822_lwsp*";

#   Use zero-width assertion to spot the limit of an atom.  A simple
#   $rfc822_lwsp* causes the regexp engine to hang occasionally.
    my $atom = "[^$specials $controls]+(?:$rfc822_lwsp+|\\Z|(?=[\\[\"$specials]))";
    my $word = "(?:$atom|$quoted_string)";
    my $localpart = "$word(?:\\.$rfc822_lwsp*$word)*";

    my $sub_domain = "(?:$atom|$domain_literal)";
    my $domain = "$sub_domain(?:\\.$rfc822_lwsp*$sub_domain)*";

    my $addr_spec = "$localpart\@$rfc822_lwsp*$domain";

    my $phrase = "$word*";
    my $route = "(?:\@$domain(?:,\@$rfc822_lwsp*$domain)*:$rfc822_lwsp*)";
    my $route_addr = "\\<$rfc822_lwsp*$route?$addr_spec\\>$rfc822_lwsp*";
    my $mailbox = "(?:$addr_spec|$phrase$route_addr)";

    my $group = "$phrase:$rfc822_lwsp*(?:$mailbox(?:,\\s*$mailbox)*)?;\\s*";
    my $address = "(?:$mailbox|$group)";

    return "$rfc822_lwsp*$address";
}

sub rfc822_strip_comments {
    my $s = shift;
#   Recursively remove comments, and replace with a single space.  The simpler
#   regexps in the Email Addressing FAQ are imperfect - they will miss escaped
#   chars in atoms, for example.

    while ($s =~ s/^((?:[^"\\]|\\.)*
                    (?:"(?:[^"\\]|\\.)*"(?:[^"\\]|\\.)*)*)
                    \((?:[^()\\]|\\.)*\)/$1 /osx) {}
    return $s;
}

#   valid: returns true if the parameter is an RFC822 valid address
#
sub rfc822_valid {
    my $s = rfc822_strip_comments(shift);

    if (!$rfc822re) {
        $rfc822re = make_rfc822re();
    }

    return $s =~ m/^$rfc822re$/so && $s =~ m/^$rfc822_char*$/;
}

#   validlist: In scalar context, returns true if the parameter is an RFC822
#              valid list of addresses.
#
#              In list context, returns an empty list on failure (an invalid
#              address was found); otherwise a list whose first element is the
#              number of addresses found and whose remaining elements are the
#              addresses.  This is needed to disambiguate failure (invalid)
#              from success with no addresses found, because an empty string is
#              a valid list.

sub rfc822_validlist {
    my $s = rfc822_strip_comments(shift);

    if (!$rfc822re) {
        $rfc822re = make_rfc822re();
    }
    # * null list items are valid according to the RFC
    # * the '1' business is to aid in distinguishing failure from no results

    my @r;
    if ($s =~ m/^(?:$rfc822re)?(?:,(?:$rfc822re)?)*$/so &&
	$s =~ m/^$rfc822_char*$/) {
        while ($s =~ m/(?:^|,$rfc822_lwsp*)($rfc822re)/gos) {
            push(@r, $1);
        }
        return wantarray ? (scalar(@r), @r) : 1;
    }
    return wantarray ? () : 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #!/bin/bash

#
# Build U-Boot image when `mkimage' tool is available.
#

MKIMAGE=$(type -path "${CROSS_COMPILE}mkimage")

if [ -z "${MKIMAGE}" ]; then
	MKIMAGE=$(type -path mkimage)
	if [ -z "${MKIMAGE}" ]; then
		# Doesn't exist
		echo '"mkimage" command not found - U-Boot images will not be built' >&2
		exit 1;
	fi
fi

# Call "mkimage" to create U-Boot image
${MKIMAGE} "$@"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #! /usr/bin/perl
#
# Detect cycles in the header file dependency graph
# Vegard Nossum <vegardno@ifi.uio.no>
#

use strict;
use warnings;

use Getopt::Long;

my $opt_all;
my @opt_include;
my $opt_graph;

&Getopt::Long::Configure(qw(bundling pass_through));
&GetOptions(
	help	=> \&help,
	version	=> \&version,

	all	=> \$opt_all,
	"I=s"	=> \@opt_include,
	graph	=> \$opt_graph,
);

push @opt_include, 'include';
my %deps = ();
my %linenos = ();

my @headers = grep { strip($_) } @ARGV;

parse_all(@headers);

if($opt_graph) {
	graph();
} else {
	detect_cycles(@headers);
}


sub help {
	print "Usage: $0 [options] file...\n";
	print "\n";
	print "Options:\n";
	print "  --all\n";
	print "  --graph\n";
	print "\n";
	print "  -I includedir\n";
	print "\n";
	print "To make nice graphs, try:\n";
	print "  $0 --graph include/linux/kernel.h | dot -Tpng -o graph.png\n";
	exit;
}

sub version {
	print "headerdep version 2\n";
	exit;
}

# Get a file name that is relative to our include paths
sub strip {
	my $filename = shift;

	for my $i (@opt_include) {
		my $stripped = $filename;
		$stripped =~ s/^$i\///;

		return $stripped if $stripped ne $filename;
	}

	return $filename;
}

# Search for the file name in the list of include paths
sub search {
	my $filename = shift;
	return $filename if -f $filename;

	for my $i (@opt_include) {
		my $path = "$i/$filename";
		return $path if -f $path;
	}
	return;
}

sub parse_all {
	# Parse all the headers.
	my @queue = @_;
	while(@queue) {
		my $header = pop @queue;
		next if exists $deps{$header};

		$deps{$header} = [] unless exists $deps{$header};

		my $path = search($header);
		next unless $path;

		open(my $file, '<', $path) or die($!);
		chomp(my @lines = <$file>);
		close($file);

		for my $i (0 .. $#lines) {
			my $line = $lines[$i];
			if(my($dep) = ($line =~ m/^#\s*include\s*<(.*?)>/)) {
				push @queue, $dep;
				push @{$deps{$header}}, [$i + 1, $dep];
			}
		}
	}
}

sub print_cycle {
	# $cycle[n] includes $cycle[n + 1];
	# $cycle[-1] will be the culprit
	my $cycle = shift;

	# Adjust the line numbers
	for my $i (0 .. $#$cycle - 1) {
		$cycle->[$i]->[0] = $cycle->[$i + 1]->[0];
	}
	$cycle->[-1]->[0] = 0;

	my $first = shift @$cycle;
	my $last = pop @$cycle;

	my $msg = "In file included";
	printf "%s from %s,\n", $msg, $last->[1] if defined $last;

	for my $header (reverse @$cycle) {
		printf "%s from %s:%d%s\n",
			" " x length $msg,
			$header->[1], $header->[0],
			$header->[1] eq $last->[1] ? ' <-- here' : '';
	}

	printf "%s:%d: warning: recursive header inclusion\n",
		$first->[1], $first->[0];
}

# Find and print the smallest cycle starting in the specified node.
sub detect_cycles {
	my @queue = map { [[0, $_]] } @_;
	while(@queue) {
		my $top = pop @queue;
		my $name = $top->[-1]->[1];

		for my $dep (@{$deps{$name}}) {
			my $chain = [@$top, [$dep->[0], $dep->[1]]];

			# If the dep already exists in the chain, we have a
			# cycle...
			if(grep { $_->[1] eq $dep->[1] } @$top) {
				print_cycle($chain);
				next if $opt_all;
				return;
			}

			push @queue, $chain;
		}
	}
}

sub mangle {
	$_ = shift;
	s/\//__/g;
	s/\./_/g;
	s/-/_/g;
	$_;
}

# Output dependency graph in GraphViz language.
sub graph {
	print "digraph {\n";

	print "\t/* vertices */\n";
	for my $header (keys %deps) {
		printf "\t%s [label=\"%s\"];\n",
			mangle($header), $header;
	}

	print "\n";

	print "\t/* edges */\n";
	for my $header (keys %deps) {
		for my $dep (@{$deps{$header}}) {
			printf "\t%s -> %s;\n",
				mangle($header), mangle($dep->[1]);
		}
	}

	print "}\n";
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #!/usr/bin/perl -w
#
# Clean a patch file -- or directory of patch files -- of stealth whitespace.
# WARNING: this can be a highly destructive operation.  Use with caution.
#

use bytes;
use File::Basename;

# Default options
$max_width = 79;

# Clean up space-tab sequences, either by removing spaces or
# replacing them with tabs.
sub clean_space_tabs($)
{
    no bytes;			# Tab alignment depends on characters

    my($li) = @_;
    my($lo) = '';
    my $pos = 0;
    my $nsp = 0;
    my($i, $c);

    for ($i = 0; $i < length($li); $i++) {
	$c = substr($li, $i, 1);
	if ($c eq "\t") {
	    my $npos = ($pos+$nsp+8) & ~7;
	    my $ntab = ($npos >> 3) - ($pos >> 3);
	    $lo .= "\t" x $ntab;
	    $pos = $npos;
	    $nsp = 0;
	} elsif ($c eq "\n" || $c eq "\r") {
	    $lo .= " " x $nsp;
	    $pos += $nsp;
	    $nsp = 0;
	    $lo .= $c;
	    $pos = 0;
	} elsif ($c eq " ") {
	    $nsp++;
	} else {
	    $lo .= " " x $nsp;
	    $pos += $nsp;
	    $nsp = 0;
	    $lo .= $c;
	    $pos++;
	}
    }
    $lo .= " " x $nsp;
    return $lo;
}

# Compute the visual width of a string
sub strwidth($) {
    no bytes;			# Tab alignment depends on characters

    my($li) = @_;
    my($c, $i);
    my $pos = 0;
    my $mlen = 0;

    for ($i = 0; $i < length($li); $i++) {
	$c = substr($li,$i,1);
	if ($c eq "\t") {
	    $pos = ($pos+8) & ~7;
	} elsif ($c eq "\n") {
	    $mlen = $pos if ($pos > $mlen);
	    $pos = 0;
	} else {
	    $pos++;
	}
    }

    $mlen = $pos if ($pos > $mlen);
    return $mlen;
}

$name = basename($0);

@files = ();

while (defined($a = shift(@ARGV))) {
    if ($a =~ /^-/) {
	if ($a eq '-width' || $a eq '-w') {
	    $max_width = shift(@ARGV)+0;
	} else {
	    print STDERR "Usage: $name [-width #] files...\n";
	    exit 1;
	}
    } else {
	push(@files, $a);
    }
}

foreach $f ( @files ) {
    print STDERR "$name: $f\n";

    if (! -f $f) {
	print STDERR "$f: not a file\n";
	next;
    }

    if (!open(FILE, '+<', $f)) {
	print STDERR "$name: Cannot open file: $f: $!\n";
	next;
    }

    binmode FILE;

    # First, verify that it is not a binary file; consider any file
    # with a zero byte to be a binary file.  Is there any better, or
    # additional, heuristic that should be applied?
    $is_binary = 0;

    while (read(FILE, $data, 65536) > 0) {
	if ($data =~ /\0/) {
	    $is_binary = 1;
	    last;
	}
    }

    if ($is_binary) {
	print STDERR "$name: $f: binary file\n";
	next;
    }

    seek(FILE, 0, 0);

    $in_bytes = 0;
    $out_bytes = 0;
    $lineno = 0;

    @lines  = ();

    $in_hunk = 0;
    $err = 0;

    while ( defined($line = <FILE>) ) {
	$lineno++;
	$in_bytes += length($line);

	if (!$in_hunk) {
	    if ($line =~
		/^\@\@\s+\-([0-9]+),([0-9]+)\s+\+([0-9]+),([0-9]+)\s\@\@/) {
		$minus_lines = $2;
		$plus_lines = $4;
		if ($minus_lines || $plus_lines) {
		    $in_hunk = 1;
		    @hunk_lines = ($line);
		}
	    } else {
		push(@lines, $line);
		$out_bytes += length($line);
	    }
	} else {
	    # We're in a hunk

	    if ($line =~ /^\+/) {
		$plus_lines--;

		$text = substr($line, 1);
		$text =~ s/[ \t\r]*$//;		# Remove trailing spaces
		$text = clean_space_tabs($text);

		$l_width = strwidth($text);
		if ($max_width && $l_width > $max_width) {
		    print STDERR
			"$f:$lineno: adds line exceeds $max_width ",
			"characters ($l_width)\n";
		}

		push(@hunk_lines, '+'.$text);
	    } elsif ($line =~ /^\-/) {
		$minus_lines--;
		push(@hunk_lines, $line);
	    } elsif ($line =~ /^ /) {
		$plus_lines--;
		$minus_lines--;
		push(@hunk_lines, $line);
	    } else {
		print STDERR "$name: $f: malformed patch\n";
		$err = 1;
		last;
	    }

	    if ($plus_lines < 0 || $minus_lines < 0) {
		print STDERR "$name: $f: malformed patch\n";
		$err = 1;
		last;
	    } elsif ($plus_lines == 0 && $minus_lines == 0) {
		# End of a hunk.  Process this hunk.
		my $i;
		my $l;
		my @h = ();
		my $adj = 0;
		my $done = 0;

		for ($i = scalar(@hunk_lines)-1; $i > 0; $i--) {
		    $l = $hunk_lines[$i];
		    if (!$done && $l eq "+\n") {
			$adj++; # Skip this line
		    } elsif ($l =~ /^[ +]/) {
			$done = 1;
			unshift(@h, $l);
		    } else {
			unshift(@h, $l);
		    }
		}

		$l = $hunk_lines[0];  # Hunk header
		undef @hunk_lines;    # Free memory

		if ($adj) {
		    die unless
			($l =~ /^\@\@\s+\-([0-9]+),([0-9]+)\s+\+([0-9]+),([0-9]+)\s\@\@(.*)$/);
		    my $mstart = $1;
		    my $mlin = $2;
		    my $pstart = $3;
		    my $plin = $4;
		    my $tail = $5; # doesn't include the final newline

		    $l = sprintf("@@ -%d,%d +%d,%d @@%s\n",
				 $mstart, $mlin, $pstart, $plin-$adj,
				 $tail);
		}
		unshift(@h, $l);

		# Transfer to the output array
		foreach $l (@h) {
		    $out_bytes += length($l);
		    push(@lines, $l);
		}

		$in_hunk = 0;
	    }
	}
    }

    if ($in_hunk) {
	print STDERR "$name: $f: malformed patch\n";
	$err = 1;
    }

    if (!$err) {
	if ($in_bytes != $out_bytes) {
	    # Only write to the file if changed
	    seek(FILE, 0, 0);
	    print FILE @lines;

	    if ( !defined($where = tell(FILE)) ||
		 !truncate(FILE, $where) ) {
		die "$name: Failed to truncate modified file: $f: $!\n";
	    }
	}
    }

    close(FILE);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #!/bin/sh
# ----------------------------------------------------------------------
# extract-ikconfig - Extract the .config file from a kernel image
#
# This will only work when the kernel was compiled with CONFIG_IKCONFIG.
#
# The obscure use of the "tr" filter is to work around older versions of
# "grep" that report the byte offset of the line instead of the pattern.
#
# (c) 2009,2010 Dick Streefland <dick@streefland.net>
# Licensed under the terms of the GNU General Public License.
# ----------------------------------------------------------------------

cf1='IKCFG_ST\037\213\010'
cf2='0123456789'

dump_config()
{
	if	pos=`tr "$cf1\n$cf2" "\n$cf2=" < "$1" | grep -abo "^$cf2"`
	then
		pos=${pos%%:*}
		tail -c+$(($pos+8)) "$1" | zcat > $tmp1 2> /dev/null
		if	[ $? != 1 ]
		then	# exit status must be 0 or 2 (trailing garbage warning)
			cat $tmp1
			exit 0
		fi
	fi
}

try_decompress()
{
	for	pos in `tr "$1\n$2" "\n$2=" < "$img" | grep -abo "^$2"`
	do
		pos=${pos%%:*}
		tail -c+$pos "$img" | $3 > $tmp2 2> /dev/null
		dump_config $tmp2
	done
}

# Check invocation:
me=${0##*/}
img=$1
if	[ $# -ne 1 -o ! -s "$img" ]
then
	echo "Usage: $me <kernel-image>" >&2
	exit 2
fi

# Prepare temp files:
tmp1=/tmp/ikconfig$$.1
tmp2=/tmp/ikconfig$$.2
trap "rm -f $tmp1 $tmp2" 0

# Initial attempt for uncompressed images or objects:
dump_config "$img"

# That didn't work, so retry after decompression.
try_decompress '\037\213\010' xy    gunzip
try_decompress '\3757zXZ\000' abcde unxz
try_decompress 'BZh'          xy    bunzip2
try_decompress '\135\0\0\0'   xxx   unlzma
try_decompress '\211\114\132' xy    'lzop -d'
try_decompress '\002\041\114\030' xyy 'lz4 -d -l'

# Bail out:
echo "$me: Cannot find kernel config." >&2
exit 1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # ==========================================================================
#
# make W=... settings
#
# W=1 - warnings that may be relevant and does not occur too often
# W=2 - warnings that occur quite often but may still be relevant
# W=3 - the more obscure warnings, can most likely be ignored
#
# $(call cc-option, -W...) handles gcc -W.. options which
# are not supported by all versions of the compiler
# ==========================================================================

ifeq ("$(origin W)", "command line")
  export KBUILD_ENABLE_EXTRA_GCC_CHECKS := $(W)
endif

ifdef KBUILD_ENABLE_EXTRA_GCC_CHECKS
warning-  := $(empty)

warning-1 := -Wextra -Wunused -Wno-unused-parameter
warning-1 += -Wmissing-declarations
warning-1 += -Wmissing-format-attribute
warning-1 += $(call cc-option, -Wmissing-prototypes)
warning-1 += -Wold-style-definition
warning-1 += $(call cc-option, -Wmissing-include-dirs)
warning-1 += $(call cc-option, -Wunused-but-set-variable)
warning-1 += $(call cc-disable-warning, missing-field-initializers)

warning-2 := -Waggregate-return
warning-2 += -Wcast-align
warning-2 += -Wdisabled-optimization
warning-2 += -Wnested-externs
warning-2 += -Wshadow
warning-2 += $(call cc-option, -Wlogical-op)
warning-2 += $(call cc-option, -Wmissing-field-initializers)

warning-3 := -Wbad-function-cast
warning-3 += -Wcast-qual
warning-3 += -Wconversion
warning-3 += -Wpacked
warning-3 += -Wpadded
warning-3 += -Wpointer-arith
warning-3 += -Wredundant-decls
warning-3 += -Wswitch-default
warning-3 += $(call cc-option, -Wpacked-bitfield-compat)
warning-3 += $(call cc-option, -Wvla)

warning := $(warning-$(findstring 1, $(KBUILD_ENABLE_EXTRA_GCC_CHECKS)))
warning += $(warning-$(findstring 2, $(KBUILD_ENABLE_EXTRA_GCC_CHECKS)))
warning += $(warning-$(findstring 3, $(KBUILD_ENABLE_EXTRA_GCC_CHECKS)))

ifeq ("$(strip $(warning))","")
        $(error W=$(KBUILD_ENABLE_EXTRA_GCC_CHECKS) is unknown)
endif

KBUILD_CFLAGS += $(warning)
else

ifeq ($(COMPILER),clang)
KBUILD_CFLAGS += $(call cc-disable-warning, initializer-overrides)
KBUILD_CFLAGS += $(call cc-disable-warning, unused-value)
KBUILD_CFLAGS += $(call cc-disable-warning, format)
KBUILD_CFLAGS += $(call cc-disable-warning, unknown-warning-option)
KBUILD_CFLAGS += $(call cc-disable-warning, sign-compare)
KBUILD_CFLAGS += $(call cc-disable-warning, format-zero-length)
KBUILD_CFLAGS += $(call cc-disable-warning, uninitialized)
endif
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #!/usr/bin/perl -w
#
# Sign a module file using the given key.
#

my $USAGE =
"Usage: scripts/sign-file [-v] <hash algo> <key> <x509> <module> [<dest>]\n" .
"       scripts/sign-file [-v] -s <raw sig> <hash algo> <x509> <module> [<dest>]\n";

use strict;
use FileHandle;
use IPC::Open2;
use Getopt::Std;

my %opts;
getopts('vs:', \%opts) or die $USAGE;
my $verbose = $opts{'v'};
my $signature_file = $opts{'s'};

die $USAGE if ($#ARGV > 4);
die $USAGE if (!$signature_file && $#ARGV < 3 || $signature_file && $#ARGV < 2);

my $dgst = shift @ARGV;
my $private_key;
if (!$signature_file) {
	$private_key = shift @ARGV;
}
my $x509 = shift @ARGV;
my $module = shift @ARGV;
my ($dest, $keep_orig);
if (@ARGV) {
	$dest = $ARGV[0];
	$keep_orig = 1;
} else {
	$dest = $module . "~";
}

die "Can't read private key\n" if (!$signature_file && !-r $private_key);
die "Can't read signature file\n" if ($signature_file && !-r $signature_file);
die "Can't read X.509 certificate\n" unless (-r $x509);
die "Can't read module\n" unless (-r $module);

#
# Function to read the contents of a file into a variable.
#
sub read_file($)
{
    my ($file) = @_;
    my $contents;
    my $len;

    open(FD, "<$file") || die $file;
    binmode FD;
    my @st = stat(FD);
    die $file if (!@st);
    $len = read(FD, $contents, $st[7]) || die $file;
    close(FD) || die $file;
    die "$file: Wanted length ", $st[7], ", got ", $len, "\n"
	if ($len != $st[7]);
    return $contents;
}

###############################################################################
#
# First of all, we have to parse the X.509 certificate to find certain details
# about it.
#
# We read the DER-encoded X509 certificate and parse it to extract the Subject
# name and Subject Key Identifier.  Theis provides the data we need to build
# the certificate identifier.
#
# The signer's name part of the identifier is fabricated from the commonName,
# the organizationName or the emailAddress components of the X.509 subject
# name.
#
# The subject key ID is used to select which of that signer's certificates
# we're intending to use to sign the module.
#
###############################################################################
my $x509_certificate = read_file($x509);

my $UNIV = 0 << 6;
my $APPL = 1 << 6;
my $CONT = 2 << 6;
my $PRIV = 3 << 6;

my $CONS = 0x20;

my $BOOLEAN	= 0x01;
my $INTEGER	= 0x02;
my $BIT_STRING	= 0x03;
my $OCTET_STRING = 0x04;
my $NULL	= 0x05;
my $OBJ_ID	= 0x06;
my $UTF8String	= 0x0c;
my $SEQUENCE	= 0x10;
my $SET		= 0x11;
my $UTCTime	= 0x17;
my $GeneralizedTime = 0x18;

my %OIDs = (
    pack("CCC", 85, 4, 3)	=> "commonName",
    pack("CCC", 85, 4, 6)	=> "countryName",
    pack("CCC", 85, 4, 10)	=> "organizationName",
    pack("CCC", 85, 4, 11)	=> "organizationUnitName",
    pack("CCCCCCCCC", 42, 134, 72, 134, 247, 13, 1, 1, 1) => "rsaEncryption",
    pack("CCCCCCCCC", 42, 134, 72, 134, 247, 13, 1, 1, 5) => "sha1WithRSAEncryption",
    pack("CCCCCCCCC", 42, 134, 72, 134, 247, 13, 1, 9, 1) => "emailAddress",
    pack("CCC", 85, 29, 35)	=> "authorityKeyIdentifier",
    pack("CCC", 85, 29, 14)	=> "subjectKeyIdentifier",
    pack("CCC", 85, 29, 19)	=> "basicConstraints"
);

###############################################################################
#
# Extract an ASN.1 element from a string and return information about it.
#
###############################################################################
sub asn1_extract($$@)
{
    my ($cursor, $expected_tag, $optional) = @_;

    return [ -1 ]
	if ($cursor->[1] == 0 && $optional);

    die $x509, ": ", $cursor->[0], ": ASN.1 data underrun (elem ", $cursor->[1], ")\n"
	if ($cursor->[1] < 2);

    my ($tag, $len) = unpack("CC", substr(${$cursor->[2]}, $cursor->[0], 2));

    if ($expected_tag != -1 && $tag != $expected_tag) {
	return [ -1 ]
	    if ($optional);
	die $x509, ": ", $cursor->[0], ": ASN.1 unexpected tag (", $tag,
	" not ", $expected_tag, ")\n";
    }

    $cursor->[0] += 2;
    $cursor->[1] -= 2;

    die $x509, ": ", $cursor->[0], ": ASN.1 long tag\n"
	if (($tag & 0x1f) == 0x1f);
    die $x509, ": ", $cursor->[0], ": ASN.1 indefinite length\n"
	if ($len == 0x80);

    if ($len > 0x80) {
	my $l = $len - 0x80;
	die $x509, ": ", $cursor->[0], ": ASN.1 data underrun (len len $l)\n"
	    if ($cursor->[1] < $l);

	if ($l == 0x1) {
	    $len = unpack("C", substr(${$cursor->[2]}, $cursor->[0], 1));
	} elsif ($l == 0x2) {
	    $len = unpack("n", substr(${$cursor->[2]}, $cursor->[0], 2));
	} elsif ($l == 0x3) {
	    $len = unpack("C", substr(${$cursor->[2]}, $cursor->[0], 1)) << 16;
	    $len = unpack("n", substr(${$cursor->[2]}, $cursor->[0] + 1, 2));
	} elsif ($l == 0x4) {
	    $len = unpack("N", substr(${$cursor->[2]}, $cursor->[0], 4));
	} else {
	    die $x509, ": ", $cursor->[0], ": ASN.1 element too long (", $l, ")\n";
	}

	$cursor->[0] += $l;
	$cursor->[1] -= $l;
    }

    die $x509, ": ", $cursor->[0], ": ASN.1 data underrun (", $len, ")\n"
	if ($cursor->[1] < $len);

    my $ret = [ $tag, [ $cursor->[0], $len, $cursor->[2] ] ];
    $cursor->[0] += $len;
    $cursor->[1] -= $len;

    return $ret;
}

###############################################################################
#
# Retrieve the data referred to by a cursor
#
###############################################################################
sub asn1_retrieve($)
{
    my ($cursor) = @_;
    my ($offset, $len, $data) = @$cursor;
    return substr($$data, $offset, $len);
}

###############################################################################
#
# Roughly parse the X.509 certificate
#
###############################################################################
my $cursor = [ 0, length($x509_certificate), \$x509_certificate ];

my $cert = asn1_extract($cursor, $UNIV | $CONS | $SEQUENCE);
my $tbs = asn1_extract($cert->[1], $UNIV | $CONS | $SEQUENCE);
my $version = asn1_extract($tbs->[1], $CONT | $CONS | 0, 1);
my $serial_number = asn1_extract($tbs->[1], $UNIV | $INTEGER);
my $sig_type = asn1_extract($tbs->[1], $UNIV | $CONS | $SEQUENCE);
my $issuer = asn1_extract($tbs->[1], $UNIV | $CONS | $SEQUENCE);
my $validity = asn1_extract($tbs->[1], $UNIV | $CONS | $SEQUENCE);
my $subject = asn1_extract($tbs->[1], $UNIV | $CONS | $SEQUENCE);
my $key = asn1_extract($tbs->[1], $UNIV | $CONS | $SEQUENCE);
my $issuer_uid = asn1_extract($tbs->[1], $CONT | $CONS | 1, 1);
my $subject_uid = asn1_extract($tbs->[1], $CONT | $CONS | 2, 1);
my $extension_list = asn1_extract($tbs->[1], $CONT | $CONS | 3, 1);

my $subject_key_id = ();
my $authority_key_id = ();

#
# Parse the extension list
#
if ($extension_list->[0] != -1) {
    my $extensions = asn1_extract($extension_list->[1], $UNIV | $CONS | $SEQUENCE);

    while ($extensions->[1]->[1] > 0) {
	my $ext = asn1_extract($extensions->[1], $UNIV | $CONS | $SEQUENCE);
	my $x_oid = asn1_extract($ext->[1], $UNIV | $OBJ_ID);
	my $x_crit = asn1_extract($ext->[1], $UNIV | $BOOLEAN, 1);
	my $x_val = asn1_extract($ext->[1], $UNIV | $OCTET_STRING);

	my $raw_oid = asn1_retrieve($x_oid->[1]);
	next if (!exists($OIDs{$raw_oid}));
	my $x_type = $OIDs{$raw_oid};

	my $raw_value = asn1_retrieve($x_val->[1]);

	if ($x_type eq "subjectKeyIdentifier") {
	    my $vcursor = [ 0, length($raw_value), \$raw_value ];

	    $subject_key_id = asn1_extract($vcursor, $UNIV | $OCTET_STRING);
	}
    }
}

###############################################################################
#
# Determine what we're going to use as the signer's name.  In order of
# preference, take one of: commonName, organizationName or emailAddress.
#
###############################################################################
my $org = "";
my $cn = "";
my $email = "";

while ($subject->[1]->[1] > 0) {
    my $rdn = asn1_extract($subject->[1], $UNIV | $CONS | $SET);
    my $attr = asn1_extract($rdn->[1], $UNIV | $CONS | $SEQUENCE);
    my $n_oid = asn1_extract($attr->[1], $UNIV | $OBJ_ID);
    my $n_val = asn1_extract($attr->[1], -1);

    my $raw_oid = asn1_retrieve($n_oid->[1]);
    next if (!exists($OIDs{$raw_oid}));
    my $n_type = $OIDs{$raw_oid};

    my $raw_value = asn1_retrieve($n_val->[1]);

    if ($n_type eq "organizationName") {
	$org = $raw_value;
    } elsif ($n_type eq "commonName") {
	$cn = $raw_value;
    } elsif ($n_type eq "emailAddress") {
	$email = $raw_value;
    }
}

my $signers_name = $email;

if ($org && $cn) {
    # Don't use the organizationName if the commonName repeats it
    if (length($org) <= length($cn) &&
	substr($cn, 0, length($org)) eq $org) {
	$signers_name = $cn;
	goto got_id_name;
    }

    # Or a signifcant chunk of it
    if (length($org) >= 7 &&
	length($cn) >= 7 &&
	substr($cn, 0, 7) eq substr($org, 0, 7)) {
	$signers_name = $cn;
	goto got_id_name;
    }

    $signers_name = $org . ": " . $cn;
} elsif ($org) {
    $signers_name = $org;
} elsif ($cn) {
    $signers_name = $cn;
}

got_id_name:

die $x509, ": ", "X.509: Couldn't find the Subject Key Identifier extension\n"
    if (!$subject_key_id);

my $key_identifier = asn1_retrieve($subject_key_id->[1]);

###############################################################################
#
# Create and attach the module signature
#
###############################################################################

#
# Signature parameters
#
my $algo = 1;		# Public-key crypto algorithm: RSA
my $hash = 0;		# Digest algorithm
my $id_type = 1;	# Identifier type: X.509

#
# Digest the data
#
my $prologue;
if ($dgst eq "sha1") {
    $prologue = pack("C*",
		     0x30, 0x21, 0x30, 0x09, 0x06, 0x05,
		     0x2B, 0x0E, 0x03, 0x02, 0x1A,
		     0x05, 0x00, 0x04, 0x14);
    $hash = 2;
} elsif ($dgst eq "sha224") {
    $prologue = pack("C*",
		     0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09,
		     0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04,
		     0x05, 0x00, 0x04, 0x1C);
    $hash = 7;
} elsif ($dgst eq "sha256") {
    $prologue = pack("C*",
		     0x30, 0x31, 0x30, 0x0d, 0x06, 0x09,
		     0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
		     0x05, 0x00, 0x04, 0x20);
    $hash = 4;
} elsif ($dgst eq "sha384") {
    $prologue = pack("C*",
		     0x30, 0x41, 0x30, 0x0d, 0x06, 0x09,
		     0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02,
		     0x05, 0x00, 0x04, 0x30);
    $hash = 5;
} elsif ($dgst eq "sha512") {
    $prologue = pack("C*",
		     0x30, 0x51, 0x30, 0x0d, 0x06, 0x09,
		     0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03,
		     0x05, 0x00, 0x04, 0x40);
    $hash = 6;
} else {
    die "Unknown hash algorithm: $dgst\n";
}

my $signature;
if ($signature_file) {
	$signature = read_file($signature_file);
} else {
	#
	# Generate the digest and read from openssl's stdout
	#
	my $digest;
	$digest = readpipe("openssl dgst -$dgst -binary $module") || die "openssl dgst";

	#
	# Generate the binary signature, which will be just the integer that
	# comprises the signature with no metadata attached.
	#
	my $pid;
	$pid = open2(*read_from, *write_to,
		     "openssl rsautl -sign -inkey $private_key -keyform PEM") ||
	    die "openssl rsautl";
	binmode write_to;
	print write_to $prologue . $digest || die "pipe to openssl rsautl";
	close(write_to) || die "pipe to openssl rsautl";

	binmode read_from;
	read(read_from, $signature, 4096) || die "pipe from openssl rsautl";
	close(read_from) || die "pipe from openssl rsautl";
	waitpid($pid, 0) || die;
	die "openssl rsautl died: $?" if ($? >> 8);
}
$signature = pack("n", length($signature)) . $signature,

#
# Build the signed binary
#
my $unsigned_module = read_file($module);

my $magic_number = "~Module signature appended~\n";

my $info = pack("CCCCCxxxN",
		$algo, $hash, $id_type,
		length($signers_name),
		length($key_identifier),
		length($signature));

if ($verbose) {
    print "Size of unsigned module: ", length($unsigned_module), "\n";
    print "Size of signer's name  : ", length($signers_name), "\n";
    print "Size of key identifier : ", length($key_identifier), "\n";
    print "Size of signature      : ", length($signature), "\n";
    print "Size of information    : ", length($info), "\n";
    print "Size of magic number   : ", length($magic_number), "\n";
    print "Signer's name          : '", $signers_name, "'\n";
    print "Digest                 : $dgst\n";
}

open(FD, ">$dest") || die $dest;
binmode FD;
print FD
    $unsigned_module,
    $signers_name,
    $key_identifier,
    $signature,
    $info,
    $magic_number
    ;
close FD || die $dest;

if (!$keep_orig) {
    rename($dest, $module) || die $module;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * sortextable.c: Sort the kernel's exception table
 *
 * Copyright 2011 - 2012 Cavium, Inc.
 *
 * Based on code taken from recortmcount.c which is:
 *
 * Copyright 2009 John F. Reiser <jreiser@BitWagon.com>.  All rights reserved.
 * Licensed under the GNU General Public License, version 2 (GPLv2).
 *
 * Restructured to fit Linux format, as well as other updates:
 *  Copyright 2010 Steven Rostedt <srostedt@redhat.com>, Red Hat Inc.
 */

/*
 * Strategy: alter the vmlinux file in-place.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <getopt.h>
#include <elf.h>
#include <fcntl.h>
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <tools/be_byteshift.h>
#include <tools/le_byteshift.h>

#ifndef EM_ARCOMPACT
#define EM_ARCOMPACT	93
#endif

#ifndef EM_XTENSA
#define EM_XTENSA	94
#endif

#ifndef EM_AARCH64
#define EM_AARCH64	183
#endif

#ifndef EM_MICROBLAZE
#define EM_MICROBLAZE	189
#endif

static int fd_map;	/* File descriptor for file being modified. */
static int mmap_failed; /* Boolean flag. */
static void *ehdr_curr; /* current ElfXX_Ehdr *  for resource cleanup */
static struct stat sb;	/* Remember .st_size, etc. */
static jmp_buf jmpenv;	/* setjmp/longjmp per-file error escape */

/* setjmp() return values */
enum {
	SJ_SETJMP = 0,  /* hardwired first return */
	SJ_FAIL,
	SJ_SUCCEED
};

/* Per-file resource cleanup when multiple files. */
static void
cleanup(void)
{
	if (!mmap_failed)
		munmap(ehdr_curr, sb.st_size);
	close(fd_map);
}

static void __attribute__((noreturn))
fail_file(void)
{
	cleanup();
	longjmp(jmpenv, SJ_FAIL);
}

/*
 * Get the whole file as a programming convenience in order to avoid
 * malloc+lseek+read+free of many pieces.  If successful, then mmap
 * avoids copying unused pieces; else just read the whole file.
 * Open for both read and write.
 */
static void *mmap_file(char const *fname)
{
	void *addr;

	fd_map = open(fname, O_RDWR);
	if (fd_map < 0 || fstat(fd_map, &sb) < 0) {
		perror(fname);
		fail_file();
	}
	if (!S_ISREG(sb.st_mode)) {
		fprintf(stderr, "not a regular file: %s\n", fname);
		fail_file();
	}
	addr = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_SHARED,
		    fd_map, 0);
	if (addr == MAP_FAILED) {
		mmap_failed = 1;
		fprintf(stderr, "Could not mmap file: %s\n", fname);
		fail_file();
	}
	return addr;
}

static uint64_t r8be(const uint64_t *x)
{
	return get_unaligned_be64(x);
}
static uint32_t rbe(const uint32_t *x)
{
	return get_unaligned_be32(x);
}
static uint16_t r2be(const uint16_t *x)
{
	return get_unaligned_be16(x);
}
static uint64_t r8le(const uint64_t *x)
{
	return get_unaligned_le64(x);
}
static uint32_t rle(const uint32_t *x)
{
	return get_unaligned_le32(x);
}
static uint16_t r2le(const uint16_t *x)
{
	return get_unaligned_le16(x);
}

static void w8be(uint64_t val, uint64_t *x)
{
	put_unaligned_be64(val, x);
}
static void wbe(uint32_t val, uint32_t *x)
{
	put_unaligned_be32(val, x);
}
static void w2be(uint16_t val, uint16_t *x)
{
	put_unaligned_be16(val, x);
}
static void w8le(uint64_t val, uint64_t *x)
{
	put_unaligned_le64(val, x);
}
static void wle(uint32_t val, uint32_t *x)
{
	put_unaligned_le32(val, x);
}
static void w2le(uint16_t val, uint16_t *x)
{
	put_unaligned_le16(val, x);
}

static uint64_t (*r8)(const uint64_t *);
static uint32_t (*r)(const uint32_t *);
static uint16_t (*r2)(const uint16_t *);
static void (*w8)(uint64_t, uint64_t *);
static void (*w)(uint32_t, uint32_t *);
static void (*w2)(uint16_t, uint16_t *);

typedef void (*table_sort_t)(char *, int);

/*
 * Move reserved section indices SHN_LORESERVE..SHN_HIRESERVE out of
 * the way to -256..-1, to avoid conflicting with real section
 * indices.
 */
#define SPECIAL(i) ((i) - (SHN_HIRESERVE + 1))

static inline int is_shndx_special(unsigned int i)
{
	return i != SHN_XINDEX && i >= SHN_LORESERVE && i <= SHN_HIRESERVE;
}

/* Accessor for sym->st_shndx, hides ugliness of "64k sections" */
static inline unsigned int get_secindex(unsigned int shndx,
					unsigned int sym_offs,
					const Elf32_Word *symtab_shndx_start)
{
	if (is_shndx_special(shndx))
		return SPECIAL(shndx);
	if (shndx != SHN_XINDEX)
		return shndx;
	return r(&symtab_shndx_start[sym_offs]);
}

/* 32 bit and 64 bit are very similar */
#include "sortextable.h"
#define SORTEXTABLE_64
#include "sortextable.h"

static int compare_relative_table(const void *a, const void *b)
{
	int32_t av = (int32_t)r(a);
	int32_t bv = (int32_t)r(b);

	if (av < bv)
		return -1;
	if (av > bv)
		return 1;
	return 0;
}

static void sort_relative_table(char *extab_image, int image_size)
{
	int i;

	/*
	 * Do the same thing the runtime sort does, first normalize to
	 * being relative to the start of the section.
	 */
	i = 0;
	while (i < image_size) {
		uint32_t *loc = (uint32_t *)(extab_image + i);
		w(r(loc) + i, loc);
		i += 4;
	}

	qsort(extab_image, image_size / 8, 8, compare_relative_table);

	/* Now denormalize. */
	i = 0;
	while (i < image_size) {
		uint32_t *loc = (uint32_t *)(extab_image + i);
		w(r(loc) - i, loc);
		i += 4;
	}
}

static void
do_file(char const *const fname)
{
	table_sort_t custom_sort;
	Elf32_Ehdr *ehdr = mmap_file(fname);

	ehdr_curr = ehdr;
	switch (ehdr->e_ident[EI_DATA]) {
	default:
		fprintf(stderr, "unrecognized ELF data encoding %d: %s\n",
			ehdr->e_ident[EI_DATA], fname);
		fail_file();
		break;
	case ELFDATA2LSB:
		r = rle;
		r2 = r2le;
		r8 = r8le;
		w = wle;
		w2 = w2le;
		w8 = w8le;
		break;
	case ELFDATA2MSB:
		r = rbe;
		r2 = r2be;
		r8 = r8be;
		w = wbe;
		w2 = w2be;
		w8 = w8be;
		break;
	}  /* end switch */
	if (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0
	||  r2(&ehdr->e_type) != ET_EXEC
	||  ehdr->e_ident[EI_VERSION] != EV_CURRENT) {
		fprintf(stderr, "unrecognized ET_EXEC file %s\n", fname);
		fail_file();
	}

	custom_sort = NULL;
	switch (r2(&ehdr->e_machine)) {
	default:
		fprintf(stderr, "unrecognized e_machine %d %s\n",
			r2(&ehdr->e_machine), fname);
		fail_file();
		break;
	case EM_386:
	case EM_X86_64:
	case EM_S390:
		custom_sort = sort_relative_table;
		break;
	case EM_ARCOMPACT:
	case EM_ARM:
	case EM_AARCH64:
	case EM_MICROBLAZE:
	case EM_MIPS:
	case EM_XTENSA:
		break;
	}  /* end switch */

	switch (ehdr->e_ident[EI_CLASS]) {
	default:
		fprintf(stderr, "unrecognized ELF class %d %s\n",
			ehdr->e_ident[EI_CLASS], fname);
		fail_file();
		break;
	case ELFCLASS32:
		if (r2(&ehdr->e_ehsize) != sizeof(Elf32_Ehdr)
		||  r2(&ehdr->e_shentsize) != sizeof(Elf32_Shdr)) {
			fprintf(stderr,
				"unrecognized ET_EXEC file: %s\n", fname);
			fail_file();
		}
		do32(ehdr, fname, custom_sort);
		break;
	case ELFCLASS64: {
		Elf64_Ehdr *const ghdr = (Elf64_Ehdr *)ehdr;
		if (r2(&ghdr->e_ehsize) != sizeof(Elf64_Ehdr)
		||  r2(&ghdr->e_shentsize) != sizeof(Elf64_Shdr)) {
			fprintf(stderr,
				"unrecognized ET_EXEC file: %s\n", fname);
			fail_file();
		}
		do64(ghdr, fname, custom_sort);
		break;
	}
	}  /* end switch */

	cleanup();
}

int
main(int argc, char *argv[])
{
	int n_error = 0;  /* gcc-4.3.0 false positive complaint */
	int i;

	if (argc < 2) {
		fprintf(stderr, "usage: sortextable vmlinux...\n");
		return 0;
	}

	/* Process each file in turn, allowing deep failure. */
	for (i = 1; i < argc; i++) {
		char *file = argv[i];
		int const sjval = setjmp(jmpenv);

		switch (sjval) {
		default:
			fprintf(stderr, "internal error: %s\n", file);
			exit(1);
			break;
		case SJ_SETJMP:    /* normal sequence */
			/* Avoid problems if early cleanup() */
			fd_map = -1;
			ehdr_curr = NULL;
			mmap_failed = 1;
			do_file(file);
			break;
		case SJ_FAIL:    /* error in do_file or below */
			++n_error;
			break;
		case SJ_SUCCEED:    /* premature success */
			/* do nothing */
			break;
		}  /* end switch */
	}
	return !!n_error;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                         #!/usr/bin/perl -w
# (c) 2008, Steven Rostedt <srostedt@redhat.com>
# Licensed under the terms of the GNU GPL License version 2
#
# recordmcount.pl - makes a section called __mcount_loc that holds
#                   all the offsets to the calls to mcount.
#
#
# What we want to end up with this is that each object file will have a
# section called __mcount_loc that will hold the list of pointers to mcount
# callers. After final linking, the vmlinux will have within .init.data the
# list of all callers to mcount between __start_mcount_loc and __stop_mcount_loc.
# Later on boot up, the kernel will read this list, save the locations and turn
# them into nops. When tracing or profiling is later enabled, these locations
# will then be converted back to pointers to some function.
#
# This is no easy feat. This script is called just after the original
# object is compiled and before it is linked.
#
# When parse this object file using 'objdump', the references to the call
# sites are offsets from the section that the call site is in. Hence, all
# functions in a section that has a call site to mcount, will have the
# offset from the beginning of the section and not the beginning of the
# function.
#
# But where this section will reside finally in vmlinx is undetermined at
# this point. So we can't use this kind of offsets to record the final
# address of this call site.
#
# The trick is to change the call offset referring the start of a section to
# referring a function symbol in this section. During the link step, 'ld' will
# compute the final address according to the information we record.
#
# e.g.
#
#  .section ".sched.text", "ax"
#        [...]
#  func1:
#        [...]
#        call mcount  (offset: 0x10)
#        [...]
#        ret
#  .globl fun2
#  func2:             (offset: 0x20)
#        [...]
#        [...]
#        ret
#  func3:
#        [...]
#        call mcount (offset: 0x30)
#        [...]
#
# Both relocation offsets for the mcounts in the above example will be
# offset from .sched.text. If we choose global symbol func2 as a reference and
# make another file called tmp.s with the new offsets:
#
#  .section __mcount_loc
#  .quad  func2 - 0x10
#  .quad  func2 + 0x10
#
# We can then compile this tmp.s into tmp.o, and link it back to the original
# object.
#
# In our algorithm, we will choose the first global function we meet in this
# section as the reference. But this gets hard if there is no global functions
# in this section. In such a case we have to select a local one. E.g. func1:
#
#  .section ".sched.text", "ax"
#  func1:
#        [...]
#        call mcount  (offset: 0x10)
#        [...]
#        ret
#  func2:
#        [...]
#        call mcount (offset: 0x20)
#        [...]
#  .section "other.section"
#
# If we make the tmp.s the same as above, when we link together with
# the original object, we will end up with two symbols for func1:
# one local, one global.  After final compile, we will end up with
# an undefined reference to func1 or a wrong reference to another global
# func1 in other files.
#
# Since local objects can reference local variables, we need to find
# a way to make tmp.o reference the local objects of the original object
# file after it is linked together. To do this, we convert func1
# into a global symbol before linking tmp.o. Then after we link tmp.o
# we will only have a single symbol for func1 that is global.
# We can convert func1 back into a local symbol and we are done.
#
# Here are the steps we take:
#
# 1) Record all the local and weak symbols by using 'nm'
# 2) Use objdump to find all the call site offsets and sections for
#    mcount.
# 3) Compile the list into its own object.
# 4) Do we have to deal with local functions? If not, go to step 8.
# 5) Make an object that converts these local functions to global symbols
#    with objcopy.
# 6) Link together this new object with the list object.
# 7) Convert the local functions back to local symbols and rename
#    the result as the original object.
# 8) Link the object with the list object.
# 9) Move the result back to the original object.
#

use strict;

my $P = $0;
$P =~ s@.*/@@g;

my $V = '0.1';

if ($#ARGV != 11) {
	print "usage: $P arch endian bits objdump objcopy cc ld nm rm mv is_module inputfile\n";
	print "version: $V\n";
	exit(1);
}

my ($arch, $endian, $bits, $objdump, $objcopy, $cc,
    $ld, $nm, $rm, $mv, $is_module, $inputfile) = @ARGV;

# This file refers to mcount and shouldn't be ftraced, so lets' ignore it
if ($inputfile =~ m,kernel/trace/ftrace\.o$,) {
    exit(0);
}

# Acceptable sections to record.
my %text_sections = (
     ".text" => 1,
     ".ref.text" => 1,
     ".sched.text" => 1,
     ".spinlock.text" => 1,
     ".irqentry.text" => 1,
     ".kprobes.text" => 1,
     ".text.unlikely" => 1,
);

# Note: we are nice to C-programmers here, thus we skip the '||='-idiom.
$objdump = 'objdump' if (!$objdump);
$objcopy = 'objcopy' if (!$objcopy);
$cc = 'gcc' if (!$cc);
$ld = 'ld' if (!$ld);
$nm = 'nm' if (!$nm);
$rm = 'rm' if (!$rm);
$mv = 'mv' if (!$mv);

#print STDERR "running: $P '$arch' '$objdump' '$objcopy' '$cc' '$ld' " .
#    "'$nm' '$rm' '$mv' '$inputfile'\n";

my %locals;		# List of local (static) functions
my %weak;		# List of weak functions
my %convert;		# List of local functions used that needs conversion

my $type;
my $local_regex;	# Match a local function (return function)
my $weak_regex; 	# Match a weak function (return function)
my $section_regex;	# Find the start of a section
my $function_regex;	# Find the name of a function
			#    (return offset and func name)
my $mcount_regex;	# Find the call site to mcount (return offset)
my $mcount_adjust;	# Address adjustment to mcount offset
my $alignment;		# The .align value to use for $mcount_section
my $section_type;	# Section header plus possible alignment command
my $can_use_local = 0; 	# If we can use local function references

# Shut up recordmcount if user has older objcopy
my $quiet_recordmcount = ".tmp_quiet_recordmcount";
my $print_warning = 1;
$print_warning = 0 if ( -f $quiet_recordmcount);

##
# check_objcopy - whether objcopy supports --globalize-symbols
#
#  --globalize-symbols came out in 2.17, we must test the version
#  of objcopy, and if it is less than 2.17, then we can not
#  record local functions.
sub check_objcopy
{
    open (IN, "$objcopy --version |") or die "error running $objcopy";
    while (<IN>) {
	if (/objcopy.*\s(\d+)\.(\d+)/) {
	    $can_use_local = 1 if ($1 > 2 || ($1 == 2 && $2 >= 17));
	    last;
	}
    }
    close (IN);

    if (!$can_use_local && $print_warning) {
	print STDERR "WARNING: could not find objcopy version or version " .
	    "is less than 2.17.\n" .
	    "\tLocal function references are disabled.\n";
	open (QUIET, ">$quiet_recordmcount");
	printf QUIET "Disables the warning from recordmcount.pl\n";
	close QUIET;
    }
}

if ($arch =~ /(x86(_64)?)|(i386)/) {
    if ($bits == 64) {
	$arch = "x86_64";
    } else {
	$arch = "i386";
    }
}

#
# We base the defaults off of i386, the other archs may
# feel free to change them in the below if statements.
#
$local_regex = "^[0-9a-fA-F]+\\s+t\\s+(\\S+)";
$weak_regex = "^[0-9a-fA-F]+\\s+([wW])\\s+(\\S+)";
$section_regex = "Disassembly of section\\s+(\\S+):";
$function_regex = "^([0-9a-fA-F]+)\\s+<(.*?)>:";
$mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s(mcount|__fentry__)\$";
$section_type = '@progbits';
$mcount_adjust = 0;
$type = ".long";

if ($arch eq "x86_64") {
    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s(mcount|__fentry__)([+-]0x[0-9a-zA-Z]+)?\$";
    $type = ".quad";
    $alignment = 8;
    $mcount_adjust = -1;

    # force flags for this arch
    $ld .= " -m elf_x86_64";
    $objdump .= " -M x86-64";
    $objcopy .= " -O elf64-x86-64";
    $cc .= " -m64";

} elsif ($arch eq "i386") {
    $alignment = 4;
    $mcount_adjust = -1;

    # force flags for this arch
    $ld .= " -m elf_i386";
    $objdump .= " -M i386";
    $objcopy .= " -O elf32-i386";
    $cc .= " -m32";

} elsif ($arch eq "s390" && $bits == 64) {
    if ($cc =~ /-DCC_USING_HOTPATCH/) {
	$mcount_regex = "^\\s*([0-9a-fA-F]+):\\s*c0 04 00 00 00 00\\s*brcl\\s*0,[0-9a-f]+ <([^\+]*)>\$";
	$mcount_adjust = 0;
    } else {
	$mcount_regex = "^\\s*([0-9a-fA-F]+):\\s*R_390_(PC|PLT)32DBL\\s+_mcount\\+0x2\$";
	$mcount_adjust = -14;
    }
    $alignment = 8;
    $type = ".quad";
    $ld .= " -m elf64_s390";
    $cc .= " -m64";

} elsif ($arch eq "sh") {
    $alignment = 2;

    # force flags for this arch
    $ld .= " -m shlelf_linux";
    $objcopy .= " -O elf32-sh-linux";

} elsif ($arch eq "powerpc") {
    $local_regex = "^[0-9a-fA-F]+\\s+t\\s+(\\.?\\S+)";
    # See comment in the sparc64 section for why we use '\w'.
    $function_regex = "^([0-9a-fA-F]+)\\s+<(\\.?\\w*?)>:";
    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s\\.?_mcount\$";

    if ($bits == 64) {
	$type = ".quad";
    }

} elsif ($arch eq "arm") {
    $alignment = 2;
    $section_type = '%progbits';
    $mcount_regex = "^\\s*([0-9a-fA-F]+):\\s*R_ARM_(CALL|PC24|THM_CALL)" .
			"\\s+(__gnu_mcount_nc|mcount)\$";

} elsif ($arch eq "arm64") {
    $alignment = 3;
    $section_type = '%progbits';
    $mcount_regex = "^\\s*([0-9a-fA-F]+):\\s*R_AARCH64_CALL26\\s+_mcount\$";
    $type = ".quad";
} elsif ($arch eq "ia64") {
    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s_mcount\$";
    $type = "data8";

    if ($is_module eq "0") {
        $cc .= " -mconstant-gp";
    }
} elsif ($arch eq "sparc64") {
    # In the objdump output there are giblets like:
    # 0000000000000000 <igmp_net_exit-0x18>:
    # As there's some data blobs that get emitted into the
    # text section before the first instructions and the first
    # real symbols.  We don't want to match that, so to combat
    # this we use '\w' so we'll match just plain symbol names,
    # and not those that also include hex offsets inside of the
    # '<>' brackets.  Actually the generic function_regex setting
    # could safely use this too.
    $function_regex = "^([0-9a-fA-F]+)\\s+<(\\w*?)>:";

    # Sparc64 calls '_mcount' instead of plain 'mcount'.
    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s_mcount\$";

    $alignment = 8;
    $type = ".xword";
    $ld .= " -m elf64_sparc";
    $cc .= " -m64";
    $objcopy .= " -O elf64-sparc";
} elsif ($arch eq "mips") {
    # To enable module support, we need to enable the -mlong-calls option
    # of gcc for module, after using this option, we can not get the real
    # offset of the calling to _mcount, but the offset of the lui
    # instruction or the addiu one. herein, we record the address of the
    # first one, and then we can replace this instruction by a branch
    # instruction to jump over the profiling function to filter the
    # indicated functions, or swith back to the lui instruction to trace
    # them, which means dynamic tracing.
    #
    #       c:	3c030000 	lui	v1,0x0
    #			c: R_MIPS_HI16	_mcount
    #			c: R_MIPS_NONE	*ABS*
    #			c: R_MIPS_NONE	*ABS*
    #      10:	64630000 	daddiu	v1,v1,0
    #			10: R_MIPS_LO16	_mcount
    #			10: R_MIPS_NONE	*ABS*
    #			10: R_MIPS_NONE	*ABS*
    #      14:	03e0082d 	move	at,ra
    #      18:	0060f809 	jalr	v1
    #
    # for the kernel:
    #
    #     10:   03e0082d        move    at,ra
    #	  14:   0c000000        jal     0 <loongson_halt>
    #                    14: R_MIPS_26   _mcount
    #                    14: R_MIPS_NONE *ABS*
    #                    14: R_MIPS_NONE *ABS*
    #	 18:   00020021        nop
    if ($is_module eq "0") {
	    $mcount_regex = "^\\s*([0-9a-fA-F]+): R_MIPS_26\\s+_mcount\$";
    } else {
	    $mcount_regex = "^\\s*([0-9a-fA-F]+): R_MIPS_HI16\\s+_mcount\$";
    }
    $objdump .= " -Melf-trad".$endian."mips ";

    if ($endian eq "big") {
	    $endian = " -EB ";
	    $ld .= " -melf".$bits."btsmip";
    } else {
	    $endian = " -EL ";
	    $ld .= " -melf".$bits."ltsmip";
    }

    $cc .= " -mno-abicalls -fno-pic -mabi=" . $bits . $endian;
    $ld .= $endian;

    if ($bits == 64) {
	    $function_regex =
		"^([0-9a-fA-F]+)\\s+<(.|[^\$]L.*?|\$[^L].*?|[^\$][^L].*?)>:";
	    $type = ".dword";
    }
} elsif ($arch eq "microblaze") {
    # Microblaze calls '_mcount' instead of plain 'mcount'.
    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s_mcount\$";
} elsif ($arch eq "blackfin") {
    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s__mcount\$";
    $mcount_adjust = -4;
} elsif ($arch eq "tilegx" || $arch eq "tile") {
    # Default to the newer TILE-Gx architecture if only "tile" is given.
    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s__mcount\$";
    $type = ".quad";
    $alignment = 8;
} else {
    die "Arch $arch is not supported with CONFIG_FTRACE_MCOUNT_RECORD";
}

my $text_found = 0;
my $read_function = 0;
my $opened = 0;
my $mcount_section = "__mcount_loc";

my $dirname;
my $filename;
my $prefix;
my $ext;

if ($inputfile =~ m,^(.*)/([^/]*)$,) {
    $dirname = $1;
    $filename = $2;
} else {
    $dirname = ".";
    $filename = $inputfile;
}

if ($filename =~ m,^(.*)(\.\S),) {
    $prefix = $1;
    $ext = $2;
} else {
    $prefix = $filename;
    $ext = "";
}

my $mcount_s = $dirname . "/.tmp_mc_" . $prefix . ".s";
my $mcount_o = $dirname . "/.tmp_mc_" . $prefix . ".o";

check_objcopy();

#
# Step 1: find all the local (static functions) and weak symbols.
#         't' is local, 'w/W' is weak
#
open (IN, "$nm $inputfile|") || die "error running $nm";
while (<IN>) {
    if (/$local_regex/) {
	$locals{$1} = 1;
    } elsif (/$weak_regex/) {
	$weak{$2} = $1;
    }
}
close(IN);

my @offsets;		# Array of offsets of mcount callers
my $ref_func;		# reference function to use for offsets
my $offset = 0;		# offset of ref_func to section beginning

##
# update_funcs - print out the current mcount callers
#
#  Go through the list of offsets to callers and write them to
#  the output file in a format that can be read by an assembler.
#
sub update_funcs
{
    return unless ($ref_func and @offsets);

    # Sanity check on weak function. A weak function may be overwritten by
    # another function of the same name, making all these offsets incorrect.
    if (defined $weak{$ref_func}) {
	die "$inputfile: ERROR: referencing weak function" .
	    " $ref_func for mcount\n";
    }

    # is this function static? If so, note this fact.
    if (defined $locals{$ref_func}) {

	# only use locals if objcopy supports globalize-symbols
	if (!$can_use_local) {
	    return;
	}
	$convert{$ref_func} = 1;
    }

    # Loop through all the mcount caller offsets and print a reference
    # to the caller based from the ref_func.
    if (!$opened) {
	open(FILE, ">$mcount_s") || die "can't create $mcount_s\n";
	$opened = 1;
	print FILE "\t.section $mcount_section,\"a\",$section_type\n";
	print FILE "\t.align $alignment\n" if (defined($alignment));
    }
    foreach my $cur_offset (@offsets) {
	printf FILE "\t%s %s + %d\n", $type, $ref_func, $cur_offset - $offset;
    }
}

#
# Step 2: find the sections and mcount call sites
#
open(IN, "$objdump -hdr $inputfile|") || die "error running $objdump";

my $text;


# read headers first
my $read_headers = 1;

while (<IN>) {

    if ($read_headers && /$mcount_section/) {
	#
	# Somehow the make process can execute this script on an
	# object twice. If it does, we would duplicate the mcount
	# section and it will cause the function tracer self test
	# to fail. Check if the mcount section exists, and if it does,
	# warn and exit.
	#
	print STDERR "ERROR: $mcount_section already in $inputfile\n" .
	    "\tThis may be an indication that your build is corrupted.\n" .
	    "\tDelete $inputfile and try again. If the same object file\n" .
	    "\tstill causes an issue, then disable CONFIG_DYNAMIC_FTRACE.\n";
	exit(-1);
    }

    # is it a section?
    if (/$section_regex/) {
	$read_headers = 0;

	# Only record text sections that we know are safe
	$read_function = defined($text_sections{$1});
	# print out any recorded offsets
	update_funcs();

	# reset all markers and arrays
	$text_found = 0;
	undef($ref_func);
	undef(@offsets);

    # section found, now is this a start of a function?
    } elsif ($read_function && /$function_regex/) {
	$text_found = 1;
	$text = $2;

	# if this is either a local function or a weak function
	# keep looking for functions that are global that
	# we can use safely.
	if (!defined($locals{$text}) && !defined($weak{$text})) {
	    $ref_func = $text;
	    $read_function = 0;
	    $offset = hex $1;
	} else {
	    # if we already have a function, and this is weak, skip it
	    if (!defined($ref_func) && !defined($weak{$text}) &&
		 # PPC64 can have symbols that start with .L and
		 # gcc considers these special. Don't use them!
		 $text !~ /^\.L/) {
		$ref_func = $text;
		$offset = hex $1;
	    }
	}
    }
    # is this a call site to mcount? If so, record it to print later
    if ($text_found && /$mcount_regex/) {
	push(@offsets, (hex $1) + $mcount_adjust);
    }
}

# dump out anymore offsets that may have been found
update_funcs();

# If we did not find any mcount callers, we are done (do nothing).
if (!$opened) {
    exit(0);
}

close(FILE);

#
# Step 3: Compile the file that holds the list of call sites to mcount.
#
`$cc -o $mcount_o -c $mcount_s`;

my @converts = keys %convert;

#
# Step 4: Do we have sections that started with local functions?
#
if ($#converts >= 0) {
    my $globallist = "";
    my $locallist = "";

    foreach my $con (@converts) {
	$globallist .= " --globalize-symbol $con";
	$locallist .= " --localize-symbol $con";
    }

    my $globalobj = $dirname . "/.tmp_gl_" . $filename;
    my $globalmix = $dirname . "/.tmp_mx_" . $filename;

    #
    # Step 5: set up each local function as a global
    #
    `$objcopy $globallist $inputfile $globalobj`;

    #
    # Step 6: Link the global version to our list.
    #
    `$ld -r $globalobj $mcount_o -o $globalmix`;

    #
    # Step 7: Convert the local functions back into local symbols
    #
    `$objcopy $locallist $globalmix $inputfile`;

    # Remove the temp files
    `$rm $globalobj $globalmix`;

} else {

    my $mix = $dirname . "/.tmp_mx_" . $filename;

    #
    # Step 8: Link the object with our list of call sites object.
    #
    `$ld -r $inputfile $mcount_o -o $mix`;

    #
    # Step 9: Move the result back to the original object.
    #
    `$mv $mix $inputfile`;
}

# Clean up the temp files
`$rm $mcount_o $mcount_s`;

exit(0);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * recordmcount.h
 *
 * This code was taken out of recordmcount.c written by
 * Copyright 2009 John F. Reiser <jreiser@BitWagon.com>.  All rights reserved.
 *
 * The original code had the same algorithms for both 32bit
 * and 64bit ELF files, but the code was duplicated to support
 * the difference in structures that were used. This
 * file creates a macro of everything that is different between
 * the 64 and 32 bit code, such that by including this header
 * twice we can create both sets of functions by including this
 * header once with RECORD_MCOUNT_64 undefined, and again with
 * it defined.
 *
 * This conversion to macros was done by:
 * Copyright 2010 Steven Rostedt <srostedt@redhat.com>, Red Hat Inc.
 *
 * Licensed under the GNU General Public License, version 2 (GPLv2).
 */
#undef append_func
#undef is_fake_mcount
#undef fn_is_fake_mcount
#undef MIPS_is_fake_mcount
#undef mcount_adjust
#undef sift_rel_mcount
#undef nop_mcount
#undef find_secsym_ndx
#undef __has_rel_mcount
#undef has_rel_mcount
#undef tot_relsize
#undef get_mcountsym
#undef get_sym_str_and_relp
#undef do_func
#undef Elf_Addr
#undef Elf_Ehdr
#undef Elf_Shdr
#undef Elf_Rel
#undef Elf_Rela
#undef Elf_Sym
#undef ELF_R_SYM
#undef Elf_r_sym
#undef ELF_R_INFO
#undef Elf_r_info
#undef ELF_ST_BIND
#undef ELF_ST_TYPE
#undef fn_ELF_R_SYM
#undef fn_ELF_R_INFO
#undef uint_t
#undef _w
#undef _align
#undef _size

#ifdef RECORD_MCOUNT_64
# define append_func		append64
# define sift_rel_mcount	sift64_rel_mcount
# define nop_mcount		nop_mcount_64
# define find_secsym_ndx	find64_secsym_ndx
# define __has_rel_mcount	__has64_rel_mcount
# define has_rel_mcount		has64_rel_mcount
# define tot_relsize		tot64_relsize
# define get_sym_str_and_relp	get_sym_str_and_relp_64
# define do_func		do64
# define get_mcountsym		get_mcountsym_64
# define is_fake_mcount		is_fake_mcount64
# define fn_is_fake_mcount	fn_is_fake_mcount64
# define MIPS_is_fake_mcount	MIPS64_is_fake_mcount
# define mcount_adjust		mcount_adjust_64
# define Elf_Addr		Elf64_Addr
# define Elf_Ehdr		Elf64_Ehdr
# define Elf_Shdr		Elf64_Shdr
# define Elf_Rel		Elf64_Rel
# define Elf_Rela		Elf64_Rela
# define Elf_Sym		Elf64_Sym
# define ELF_R_SYM		ELF64_R_SYM
# define Elf_r_sym		Elf64_r_sym
# define ELF_R_INFO		ELF64_R_INFO
# define Elf_r_info		Elf64_r_info
# define ELF_ST_BIND		ELF64_ST_BIND
# define ELF_ST_TYPE		ELF64_ST_TYPE
# define fn_ELF_R_SYM		fn_ELF64_R_SYM
# define fn_ELF_R_INFO		fn_ELF64_R_INFO
# define uint_t			uint64_t
# define _w			w8
# define _align			7u
# define _size			8
#else
# define append_func		append32
# define sift_rel_mcount	sift32_rel_mcount
# define nop_mcount		nop_mcount_32
# define find_secsym_ndx	find32_secsym_ndx
# define __has_rel_mcount	__has32_rel_mcount
# define has_rel_mcount		has32_rel_mcount
# define tot_relsize		tot32_relsize
# define get_sym_str_and_relp	get_sym_str_and_relp_32
# define do_func		do32
# define get_mcountsym		get_mcountsym_32
# define is_fake_mcount		is_fake_mcount32
# define fn_is_fake_mcount	fn_is_fake_mcount32
# define MIPS_is_fake_mcount	MIPS32_is_fake_mcount
# define mcount_adjust		mcount_adjust_32
# define Elf_Addr		Elf32_Addr
# define Elf_Ehdr		Elf32_Ehdr
# define Elf_Shdr		Elf32_Shdr
# define Elf_Rel		Elf32_Rel
# define Elf_Rela		Elf32_Rela
# define Elf_Sym		Elf32_Sym
# define ELF_R_SYM		ELF32_R_SYM
# define Elf_r_sym		Elf32_r_sym
# define ELF_R_INFO		ELF32_R_INFO
# define Elf_r_info		Elf32_r_info
# define ELF_ST_BIND		ELF32_ST_BIND
# define ELF_ST_TYPE		ELF32_ST_TYPE
# define fn_ELF_R_SYM		fn_ELF32_R_SYM
# define fn_ELF_R_INFO		fn_ELF32_R_INFO
# define uint_t			uint32_t
# define _w			w
# define _align			3u
# define _size			4
#endif

/* Functions and pointers that do_file() may override for specific e_machine. */
static int fn_is_fake_mcount(Elf_Rel const *rp)
{
	return 0;
}
static int (*is_fake_mcount)(Elf_Rel const *rp) = fn_is_fake_mcount;

static uint_t fn_ELF_R_SYM(Elf_Rel const *rp)
{
	return ELF_R_SYM(_w(rp->r_info));
}
static uint_t (*Elf_r_sym)(Elf_Rel const *rp) = fn_ELF_R_SYM;

static void fn_ELF_R_INFO(Elf_Rel *const rp, unsigned sym, unsigned type)
{
	rp->r_info = _w(ELF_R_INFO(sym, type));
}
static void (*Elf_r_info)(Elf_Rel *const rp, unsigned sym, unsigned type) = fn_ELF_R_INFO;

static int mcount_adjust = 0;

/*
 * MIPS mcount long call has 2 _mcount symbols, only the position of the 1st
 * _mcount symbol is needed for dynamic function tracer, with it, to disable
 * tracing(ftrace_make_nop), the instruction in the position is replaced with
 * the "b label" instruction, to enable tracing(ftrace_make_call), replace the
 * instruction back. So, here, we set the 2nd one as fake and filter it.
 *
 * c:	3c030000	lui	v1,0x0		<-->	b	label
 *		c: R_MIPS_HI16	_mcount
 *		c: R_MIPS_NONE	*ABS*
 *		c: R_MIPS_NONE	*ABS*
 * 10:	64630000	daddiu	v1,v1,0
 *		10: R_MIPS_LO16	_mcount
 *		10: R_MIPS_NONE	*ABS*
 *		10: R_MIPS_NONE	*ABS*
 * 14:	03e0082d	move	at,ra
 * 18:	0060f809	jalr	v1
 * label:
 */
#define MIPS_FAKEMCOUNT_OFFSET	4

static int MIPS_is_fake_mcount(Elf_Rel const *rp)
{
	static Elf_Addr old_r_offset = ~(Elf_Addr)0;
	Elf_Addr current_r_offset = _w(rp->r_offset);
	int is_fake;

	is_fake = (old_r_offset != ~(Elf_Addr)0) &&
		(current_r_offset - old_r_offset == MIPS_FAKEMCOUNT_OFFSET);
	old_r_offset = current_r_offset;

	return is_fake;
}

/* Append the new shstrtab, Elf_Shdr[], __mcount_loc and its relocations. */
static void append_func(Elf_Ehdr *const ehdr,
			Elf_Shdr *const shstr,
			uint_t const *const mloc0,
			uint_t const *const mlocp,
			Elf_Rel const *const mrel0,
			Elf_Rel const *const mrelp,
			unsigned int const rel_entsize,
			unsigned int const symsec_sh_link)
{
	/* Begin constructing output file */
	Elf_Shdr mcsec;
	char const *mc_name = (sizeof(Elf_Rela) == rel_entsize)
		? ".rela__mcount_loc"
		:  ".rel__mcount_loc";
	unsigned const old_shnum = w2(ehdr->e_shnum);
	uint_t const old_shoff = _w(ehdr->e_shoff);
	uint_t const old_shstr_sh_size   = _w(shstr->sh_size);
	uint_t const old_shstr_sh_offset = _w(shstr->sh_offset);
	uint_t t = 1 + strlen(mc_name) + _w(shstr->sh_size);
	uint_t new_e_shoff;

	shstr->sh_size = _w(t);
	shstr->sh_offset = _w(sb.st_size);
	t += sb.st_size;
	t += (_align & -t);  /* word-byte align */
	new_e_shoff = t;

	/* body for new shstrtab */
	ulseek(fd_map, sb.st_size, SEEK_SET);
	uwrite(fd_map, old_shstr_sh_offset + (void *)ehdr, old_shstr_sh_size);
	uwrite(fd_map, mc_name, 1 + strlen(mc_name));

	/* old(modified) Elf_Shdr table, word-byte aligned */
	ulseek(fd_map, t, SEEK_SET);
	t += sizeof(Elf_Shdr) * old_shnum;
	uwrite(fd_map, old_shoff + (void *)ehdr,
	       sizeof(Elf_Shdr) * old_shnum);

	/* new sections __mcount_loc and .rel__mcount_loc */
	t += 2*sizeof(mcsec);
	mcsec.sh_name = w((sizeof(Elf_Rela) == rel_entsize) + strlen(".rel")
		+ old_shstr_sh_size);
	mcsec.sh_type = w(SHT_PROGBITS);
	mcsec.sh_flags = _w(SHF_ALLOC);
	mcsec.sh_addr = 0;
	mcsec.sh_offset = _w(t);
	mcsec.sh_size = _w((void *)mlocp - (void *)mloc0);
	mcsec.sh_link = 0;
	mcsec.sh_info = 0;
	mcsec.sh_addralign = _w(_size);
	mcsec.sh_entsize = _w(_size);
	uwrite(fd_map, &mcsec, sizeof(mcsec));

	mcsec.sh_name = w(old_shstr_sh_size);
	mcsec.sh_type = (sizeof(Elf_Rela) == rel_entsize)
		? w(SHT_RELA)
		: w(SHT_REL);
	mcsec.sh_flags = 0;
	mcsec.sh_addr = 0;
	mcsec.sh_offset = _w((void *)mlocp - (void *)mloc0 + t);
	mcsec.sh_size   = _w((void *)mrelp - (void *)mrel0);
	mcsec.sh_link = w(symsec_sh_link);
	mcsec.sh_info = w(old_shnum);
	mcsec.sh_addralign = _w(_size);
	mcsec.sh_entsize = _w(rel_entsize);
	uwrite(fd_map, &mcsec, sizeof(mcsec));

	uwrite(fd_map, mloc0, (void *)mlocp - (void *)mloc0);
	uwrite(fd_map, mrel0, (void *)mrelp - (void *)mrel0);

	ehdr->e_shoff = _w(new_e_shoff);
	ehdr->e_shnum = w2(2 + w2(ehdr->e_shnum));  /* {.rel,}__mcount_loc */
	ulseek(fd_map, 0, SEEK_SET);
	uwrite(fd_map, ehdr, sizeof(*ehdr));
}

static unsigned get_mcountsym(Elf_Sym const *const sym0,
			      Elf_Rel const *relp,
			      char const *const str0)
{
	unsigned mcountsym = 0;

	Elf_Sym const *const symp =
		&sym0[Elf_r_sym(relp)];
	char const *symname = &str0[w(symp->st_name)];
	char const *mcount = gpfx == '_' ? "_mcount" : "mcount";
	char const *fentry = "__fentry__";

	if (symname[0] == '.')
		++symname;  /* ppc64 hack */
	if (strcmp(mcount, symname) == 0 ||
	    (altmcount && strcmp(altmcount, symname) == 0) ||
	    (strcmp(fentry, symname) == 0))
		mcountsym = Elf_r_sym(relp);

	return mcountsym;
}

static void get_sym_str_and_relp(Elf_Shdr const *const relhdr,
				 Elf_Ehdr const *const ehdr,
				 Elf_Sym const **sym0,
				 char const **str0,
				 Elf_Rel const **relp)
{
	Elf_Shdr *const shdr0 = (Elf_Shdr *)(_w(ehdr->e_shoff)
		+ (void *)ehdr);
	unsigned const symsec_sh_link = w(relhdr->sh_link);
	Elf_Shdr const *const symsec = &shdr0[symsec_sh_link];
	Elf_Shdr const *const strsec = &shdr0[w(symsec->sh_link)];
	Elf_Rel const *const rel0 = (Elf_Rel const *)(_w(relhdr->sh_offset)
		+ (void *)ehdr);

	*sym0 = (Elf_Sym const *)(_w(symsec->sh_offset)
				  + (void *)ehdr);

	*str0 = (char const *)(_w(strsec->sh_offset)
			       + (void *)ehdr);

	*relp = rel0;
}

/*
 * Look at the relocations in order to find the calls to mcount.
 * Accumulate the section offsets that are found, and their relocation info,
 * onto the end of the existing arrays.
 */
static uint_t *sift_rel_mcount(uint_t *mlocp,
			       unsigned const offbase,
			       Elf_Rel **const mrelpp,
			       Elf_Shdr const *const relhdr,
			       Elf_Ehdr const *const ehdr,
			       unsigned const recsym,
			       uint_t const recval,
			       unsigned const reltype)
{
	uint_t *const mloc0 = mlocp;
	Elf_Rel *mrelp = *mrelpp;
	Elf_Sym const *sym0;
	char const *str0;
	Elf_Rel const *relp;
	unsigned rel_entsize = _w(relhdr->sh_entsize);
	unsigned const nrel = _w(relhdr->sh_size) / rel_entsize;
	unsigned mcountsym = 0;
	unsigned t;

	get_sym_str_and_relp(relhdr, ehdr, &sym0, &str0, &relp);

	for (t = nrel; t; --t) {
		if (!mcountsym)
			mcountsym = get_mcountsym(sym0, relp, str0);

		if (mcountsym == Elf_r_sym(relp) && !is_fake_mcount(relp)) {
			uint_t const addend =
				_w(_w(relp->r_offset) - recval + mcount_adjust);
			mrelp->r_offset = _w(offbase
				+ ((void *)mlocp - (void *)mloc0));
			Elf_r_info(mrelp, recsym, reltype);
			if (rel_entsize == sizeof(Elf_Rela)) {
				((Elf_Rela *)mrelp)->r_addend = addend;
				*mlocp++ = 0;
			} else
				*mlocp++ = addend;

			mrelp = (Elf_Rel *)(rel_entsize + (void *)mrelp);
		}
		relp = (Elf_Rel const *)(rel_entsize + (void *)relp);
	}
	*mrelpp = mrelp;
	return mlocp;
}

/*
 * Read the relocation table again, but this time its called on sections
 * that are not going to be traced. The mcount calls here will be converted
 * into nops.
 */
static void nop_mcount(Elf_Shdr const *const relhdr,
		       Elf_Ehdr const *const ehdr,
		       const char *const txtname)
{
	Elf_Shdr *const shdr0 = (Elf_Shdr *)(_w(ehdr->e_shoff)
		+ (void *)ehdr);
	Elf_Sym const *sym0;
	char const *str0;
	Elf_Rel const *relp;
	Elf_Shdr const *const shdr = &shdr0[w(relhdr->sh_info)];
	unsigned rel_entsize = _w(relhdr->sh_entsize);
	unsigned const nrel = _w(relhdr->sh_size) / rel_entsize;
	unsigned mcountsym = 0;
	unsigned t;
	int once = 0;

	get_sym_str_and_relp(relhdr, ehdr, &sym0, &str0, &relp);

	for (t = nrel; t; --t) {
		int ret = -1;

		if (!mcountsym)
			mcountsym = get_mcountsym(sym0, relp, str0);

		if (mcountsym == Elf_r_sym(relp) && !is_fake_mcount(relp)) {
			if (make_nop)
				ret = make_nop((void *)ehdr, _w(shdr->sh_offset) + _w(relp->r_offset));
			if (warn_on_notrace_sect && !once) {
				printf("Section %s has mcount callers being ignored\n",
				       txtname);
				once = 1;
				/* just warn? */
				if (!make_nop)
					return;
			}
		}

		/*
		 * If we successfully removed the mcount, mark the relocation
		 * as a nop (don't do anything with it).
		 */
		if (!ret) {
			Elf_Rel rel;
			rel = *(Elf_Rel *)relp;
			Elf_r_info(&rel, Elf_r_sym(relp), rel_type_nop);
			ulseek(fd_map, (void *)relp - (void *)ehdr, SEEK_SET);
			uwrite(fd_map, &rel, sizeof(rel));
		}
		relp = (Elf_Rel const *)(rel_entsize + (void *)relp);
	}
}


/*
 * Find a symbol in the given section, to be used as the base for relocating
 * the table of offsets of calls to mcount.  A local or global symbol suffices,
 * but avoid a Weak symbol because it may be overridden; the change in value
 * would invalidate the relocations of the offsets of the calls to mcount.
 * Often the found symbol will be the unnamed local symbol generated by
 * GNU 'as' for the start of each section.  For example:
 *    Num:    Value  Size Type    Bind   Vis      Ndx Name
 *      2: 00000000     0 SECTION LOCAL  DEFAULT    1
 */
static unsigned find_secsym_ndx(unsigned const txtndx,
				char const *const txtname,
				uint_t *const recvalp,
				Elf_Shdr const *const symhdr,
				Elf_Ehdr const *const ehdr)
{
	Elf_Sym const *const sym0 = (Elf_Sym const *)(_w(symhdr->sh_offset)
		+ (void *)ehdr);
	unsigned const nsym = _w(symhdr->sh_size) / _w(symhdr->sh_entsize);
	Elf_Sym const *symp;
	unsigned t;

	for (symp = sym0, t = nsym; t; --t, ++symp) {
		unsigned int const st_bind = ELF_ST_BIND(symp->st_info);

		if (txtndx == w2(symp->st_shndx)
			/* avoid STB_WEAK */
		    && (STB_LOCAL == st_bind || STB_GLOBAL == st_bind)) {
			/* function symbols on ARM have quirks, avoid them */
			if (w2(ehdr->e_machine) == EM_ARM
			    && ELF_ST_TYPE(symp->st_info) == STT_FUNC)
				continue;

			*recvalp = _w(symp->st_value);
			return symp - sym0;
		}
	}
	fprintf(stderr, "Cannot find symbol for section %d: %s.\n",
		txtndx, txtname);
	fail_file();
}


/* Evade ISO C restriction: no declaration after statement in has_rel_mcount. */
static char const *
__has_rel_mcount(Elf_Shdr const *const relhdr,  /* is SHT_REL or SHT_RELA */
		 Elf_Shdr const *const shdr0,
		 char const *const shstrtab,
		 char const *const fname)
{
	/* .sh_info depends on .sh_type == SHT_REL[,A] */
	Elf_Shdr const *const txthdr = &shdr0[w(relhdr->sh_info)];
	char const *const txtname = &shstrtab[w(txthdr->sh_name)];

	if (strcmp("__mcount_loc", txtname) == 0) {
		fprintf(stderr, "warning: __mcount_loc already exists: %s\n",
			fname);
		succeed_file();
	}
	if (w(txthdr->sh_type) != SHT_PROGBITS ||
	    !(_w(txthdr->sh_flags) & SHF_EXECINSTR))
		return NULL;
	return txtname;
}

static char const *has_rel_mcount(Elf_Shdr const *const relhdr,
				  Elf_Shdr const *const shdr0,
				  char const *const shstrtab,
				  char const *const fname)
{
	if (w(relhdr->sh_type) != SHT_REL && w(relhdr->sh_type) != SHT_RELA)
		return NULL;
	return __has_rel_mcount(relhdr, shdr0, shstrtab, fname);
}


static unsigned tot_relsize(Elf_Shdr const *const shdr0,
			    unsigned nhdr,
			    const char *const shstrtab,
			    const char *const fname)
{
	unsigned totrelsz = 0;
	Elf_Shdr const *shdrp = shdr0;
	char const *txtname;

	for (; nhdr; --nhdr, ++shdrp) {
		txtname = has_rel_mcount(shdrp, shdr0, shstrtab, fname);
		if (txtname && is_mcounted_section_name(txtname))
			totrelsz += _w(shdrp->sh_size);
	}
	return totrelsz;
}


/* Overall supervision for Elf32 ET_REL file. */
static void
do_func(Elf_Ehdr *const ehdr, char const *const fname, unsigned const reltype)
{
	Elf_Shdr *const shdr0 = (Elf_Shdr *)(_w(ehdr->e_shoff)
		+ (void *)ehdr);
	unsigned const nhdr = w2(ehdr->e_shnum);
	Elf_Shdr *const shstr = &shdr0[w2(ehdr->e_shstrndx)];
	char const *const shstrtab = (char const *)(_w(shstr->sh_offset)
		+ (void *)ehdr);

	Elf_Shdr const *relhdr;
	unsigned k;

	/* Upper bound on space: assume all relevant relocs are for mcount. */
	unsigned const totrelsz = tot_relsize(shdr0, nhdr, shstrtab, fname);
	Elf_Rel *const mrel0 = umalloc(totrelsz);
	Elf_Rel *      mrelp = mrel0;

	/* 2*sizeof(address) <= sizeof(Elf_Rel) */
	uint_t *const mloc0 = umalloc(totrelsz>>1);
	uint_t *      mlocp = mloc0;

	unsigned rel_entsize = 0;
	unsigned symsec_sh_link = 0;

	for (relhdr = shdr0, k = nhdr; k; --k, ++relhdr) {
		char const *const txtname = has_rel_mcount(relhdr, shdr0,
			shstrtab, fname);
		if (txtname && is_mcounted_section_name(txtname)) {
			uint_t recval = 0;
			unsigned const recsym = find_secsym_ndx(
				w(relhdr->sh_info), txtname, &recval,
				&shdr0[symsec_sh_link = w(relhdr->sh_link)],
				ehdr);

			rel_entsize = _w(relhdr->sh_entsize);
			mlocp = sift_rel_mcount(mlocp,
				(void *)mlocp - (void *)mloc0, &mrelp,
				relhdr, ehdr, recsym, recval, reltype);
		} else if (txtname && (warn_on_notrace_sect || make_nop)) {
			/*
			 * This section is ignored by ftrace, but still
			 * has mcount calls. Convert them to nops now.
			 */
			nop_mcount(relhdr, ehdr, txtname);
		}
	}
	if (mloc0 != mlocp) {
		append_func(ehdr, shstr, mloc0, mlocp, mrel0, mrelp,
			    rel_entsize, symsec_sh_link);
	}
	free(mrel0);
	free(mloc0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #!/usr/bin/python
#
# show_deltas: Read list of printk messages instrumented with
# time data, and format with time deltas.
#
# Also, you can show the times relative to a fixed point.
#
# Copyright 2003 Sony Corporation
#
# GPL 2.0 applies.

import sys
import string

def usage():
	print ("""usage: show_delta [<options>] <filename>

This program parses the output from a set of printk message lines which
have time data prefixed because the CONFIG_PRINTK_TIME option is set, or
the kernel command line option "time" is specified. When run with no
options, the time information is converted to show the time delta between
each printk line and the next.  When run with the '-b' option, all times
are relative to a single (base) point in time.

Options:
  -h            Show this usage help.
  -b <base>	Specify a base for time references.
		<base> can be a number or a string.
		If it is a string, the first message line
		which matches (at the beginning of the
		line) is used as the time reference.

ex: $ dmesg >timefile
    $ show_delta -b NET4 timefile

will show times relative to the line in the kernel output
starting with "NET4".
""")
	sys.exit(1)

# returns a tuple containing the seconds and text for each message line
# seconds is returned as a float
# raise an exception if no timing data was found
def get_time(line):
	if line[0]!="[":
		raise ValueError

	# split on closing bracket
	(time_str, rest) = string.split(line[1:],']',1)
	time = string.atof(time_str)

	#print "time=", time
	return (time, rest)


# average line looks like:
# [    0.084282] VFS: Mounted root (romfs filesystem) readonly
# time data is expressed in seconds.useconds,
# convert_line adds a delta for each line
last_time = 0.0
def convert_line(line, base_time):
	global last_time

	try:
		(time, rest) = get_time(line)
	except:
		# if any problem parsing time, don't convert anything
		return line

	if base_time:
		# show time from base
		delta = time - base_time
	else:
		# just show time from last line
		delta = time - last_time
		last_time = time

	return ("[%5.6f < %5.6f >]" % (time, delta)) + rest

def main():
	base_str = ""
	filein = ""
	for arg in sys.argv[1:]:
		if arg=="-b":
			base_str = sys.argv[sys.argv.index("-b")+1]
		elif arg=="-h":
			usage()
		else:
			filein = arg

	if not filein:
		usage()

	try:
		lines = open(filein,"r").readlines()
	except:
		print ("Problem opening file: %s" % filein)
		sys.exit(1)

	if base_str:
		print ('base= "%s"' % base_str)
		# assume a numeric base.  If that fails, try searching
		# for a matching line.
		try:
			base_time = float(base_str)
		except:
			# search for line matching <base> string
			found = 0
			for line in lines:
				try:
					(time, rest) = get_time(line)
				except:
					continue
				if string.find(rest, base_str)==1:
					base_time = time
					found = 1
					# stop at first match
					break
			if not found:
				print ('Couldn\'t find line matching base pattern "%s"' % base_str)
				sys.exit(1)
	else:
		base_time = 0.0

	for line in lines:
		print (convert_line(line, base_time),)

main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /* Generate assembler source containing symbol information
 *
 * Copyright 2002       by Kai Germaschewski
 *
 * This software may be used and distributed according to the terms
 * of the GNU General Public License, incorporated herein by reference.
 *
 * Usage: nm -n vmlinux | scripts/kallsyms [--all-symbols] > symbols.S
 *
 *      Table compression uses all the unused char codes on the symbols and
 *  maps these to the most used substrings (tokens). For instance, it might
 *  map char code 0xF7 to represent "write_" and then in every symbol where
 *  "write_" appears it can be replaced by 0xF7, saving 5 bytes.
 *      The used codes themselves are also placed in the table so that the
 *  decompresion can work without "special cases".
 *      Applied to kernel symbols, this usually produces a compression ratio
 *  of about 50%.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
#endif

#define KSYM_NAME_LEN		128

struct sym_entry {
	unsigned long long addr;
	unsigned int len;
	unsigned int start_pos;
	unsigned char *sym;
};

struct addr_range {
	const char *start_sym, *end_sym;
	unsigned long long start, end;
};

static unsigned long long _text;
static struct addr_range text_ranges[] = {
	{ "_stext",     "_etext"     },
	{ "_sinittext", "_einittext" },
	{ "_stext_l1",  "_etext_l1"  },	/* Blackfin on-chip L1 inst SRAM */
	{ "_stext_l2",  "_etext_l2"  },	/* Blackfin on-chip L2 SRAM */
};
#define text_range_text     (&text_ranges[0])
#define text_range_inittext (&text_ranges[1])

static struct addr_range percpu_range = {
	"__per_cpu_start", "__per_cpu_end", -1ULL, 0
};

static struct sym_entry *table;
static unsigned int table_size, table_cnt;
static int all_symbols = 0;
static int absolute_percpu = 0;
static char symbol_prefix_char = '\0';
static unsigned long long kernel_start_addr = 0;

int token_profit[0x10000];

/* the table that holds the result of the compression */
unsigned char best_table[256][2];
unsigned char best_table_len[256];


static void usage(void)
{
	fprintf(stderr, "Usage: kallsyms [--all-symbols] "
			"[--symbol-prefix=<prefix char>] "
			"[--page-offset=<CONFIG_PAGE_OFFSET>] "
			"< in.map > out.S\n");
	exit(1);
}

/*
 * This ignores the intensely annoying "mapping symbols" found
 * in ARM ELF files: $a, $t and $d.
 */
static inline int is_arm_mapping_symbol(const char *str)
{
	return str[0] == '$' && strchr("axtd", str[1])
	       && (str[2] == '\0' || str[2] == '.');
}

static int check_symbol_range(const char *sym, unsigned long long addr,
			      struct addr_range *ranges, int entries)
{
	size_t i;
	struct addr_range *ar;

	for (i = 0; i < entries; ++i) {
		ar = &ranges[i];

		if (strcmp(sym, ar->start_sym) == 0) {
			ar->start = addr;
			return 0;
		} else if (strcmp(sym, ar->end_sym) == 0) {
			ar->end = addr;
			return 0;
		}
	}

	return 1;
}

static int read_symbol(FILE *in, struct sym_entry *s)
{
	char str[500];
	char *sym, stype;
	int rc;

	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &stype, str);
	if (rc != 3) {
		if (rc != EOF && fgets(str, 500, in) == NULL)
			fprintf(stderr, "Read error or end of file.\n");
		return -1;
	}
	if (strlen(str) > KSYM_NAME_LEN) {
		fprintf(stderr, "Symbol %s too long for kallsyms (%zu vs %d).\n"
				"Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n",
			str, strlen(str), KSYM_NAME_LEN);
		return -1;
	}

	sym = str;
	/* skip prefix char */
	if (symbol_prefix_char && str[0] == symbol_prefix_char)
		sym++;

	/* Ignore most absolute/undefined (?) symbols. */
	if (strcmp(sym, "_text") == 0)
		_text = s->addr;
	else if (check_symbol_range(sym, s->addr, text_ranges,
				    ARRAY_SIZE(text_ranges)) == 0)
		/* nothing to do */;
	else if (toupper(stype) == 'A')
	{
		/* Keep these useful absolute symbols */
		if (strcmp(sym, "__kernel_syscall_via_break") &&
		    strcmp(sym, "__kernel_syscall_via_epc") &&
		    strcmp(sym, "__kernel_sigtramp") &&
		    strcmp(sym, "__gp"))
			return -1;

	}
	else if (toupper(stype) == 'U' ||
		 is_arm_mapping_symbol(sym))
		return -1;
	/* exclude also MIPS ELF local symbols ($L123 instead of .L123) */
	else if (str[0] == '$')
		return -1;
	/* exclude debugging symbols */
	else if (stype == 'N')
		return -1;

	/* include the type field in the symbol name, so that it gets
	 * compressed together */
	s->len = strlen(str) + 1;
	s->sym = malloc(s->len + 1);
	if (!s->sym) {
		fprintf(stderr, "kallsyms failure: "
			"unable to allocate required amount of memory\n");
		exit(EXIT_FAILURE);
	}
	strcpy((char *)s->sym + 1, str);
	s->sym[0] = stype;

	/* Record if we've found __per_cpu_start/end. */
	check_symbol_range(sym, s->addr, &percpu_range, 1);

	return 0;
}

static int symbol_in_range(struct sym_entry *s, struct addr_range *ranges,
			   int entries)
{
	size_t i;
	struct addr_range *ar;

	for (i = 0; i < entries; ++i) {
		ar = &ranges[i];

		if (s->addr >= ar->start && s->addr <= ar->end)
			return 1;
	}

	return 0;
}

static int symbol_valid(struct sym_entry *s)
{
	/* Symbols which vary between passes.  Passes 1 and 2 must have
	 * identical symbol lists.  The kallsyms_* symbols below are only added
	 * after pass 1, they would be included in pass 2 when --all-symbols is
	 * specified so exclude them to get a stable symbol list.
	 */
	static char *special_symbols[] = {
		"kallsyms_addresses",
		"kallsyms_num_syms",
		"kallsyms_names",
		"kallsyms_markers",
		"kallsyms_token_table",
		"kallsyms_token_index",

	/* Exclude linker generated symbols which vary between passes */
		"_SDA_BASE_",		/* ppc */
		"_SDA2_BASE_",		/* ppc */
		NULL };

	static char *special_suffixes[] = {
		"_veneer",		/* arm */
		NULL };

	int i;
	char *sym_name = (char *)s->sym + 1;


	if (s->addr < kernel_start_addr)
		return 0;

	/* skip prefix char */
	if (symbol_prefix_char && *sym_name == symbol_prefix_char)
		sym_name++;


	/* if --all-symbols is not specified, then symbols outside the text
	 * and inittext sections are discarded */
	if (!all_symbols) {
		if (symbol_in_range(s, text_ranges,
				    ARRAY_SIZE(text_ranges)) == 0)
			return 0;
		/* Corner case.  Discard any symbols with the same value as
		 * _etext _einittext; they can move between pass 1 and 2 when
		 * the kallsyms data are added.  If these symbols move then
		 * they may get dropped in pass 2, which breaks the kallsyms
		 * rules.
		 */
		if ((s->addr == text_range_text->end &&
				strcmp(sym_name,
				       text_range_text->end_sym)) ||
		    (s->addr == text_range_inittext->end &&
				strcmp(sym_name,
				       text_range_inittext->end_sym)))
			return 0;
	}

	/* Exclude symbols which vary between passes. */
	for (i = 0; special_symbols[i]; i++)
		if (strcmp(sym_name, special_symbols[i]) == 0)
			return 0;

	for (i = 0; special_suffixes[i]; i++) {
		int l = strlen(sym_name) - strlen(special_suffixes[i]);

		if (l >= 0 && strcmp(sym_name + l, special_suffixes[i]) == 0)
			return 0;
	}

	return 1;
}

static void read_map(FILE *in)
{
	while (!feof(in)) {
		if (table_cnt >= table_size) {
			table_size += 10000;
			table = realloc(table, sizeof(*table) * table_size);
			if (!table) {
				fprintf(stderr, "out of memory\n");
				exit (1);
			}
		}
		if (read_symbol(in, &table[table_cnt]) == 0) {
			table[table_cnt].start_pos = table_cnt;
			table_cnt++;
		}
	}
}

static void output_label(char *label)
{
	if (symbol_prefix_char)
		printf(".globl %c%s\n", symbol_prefix_char, label);
	else
		printf(".globl %s\n", label);
	printf("\tALGN\n");
	if (symbol_prefix_char)
		printf("%c%s:\n", symbol_prefix_char, label);
	else
		printf("%s:\n", label);
}

/* uncompress a compressed symbol. When this function is called, the best table
 * might still be compressed itself, so the function needs to be recursive */
static int expand_symbol(unsigned char *data, int len, char *result)
{
	int c, rlen, total=0;

	while (len) {
		c = *data;
		/* if the table holds a single char that is the same as the one
		 * we are looking for, then end the search */
		if (best_table[c][0]==c && best_table_len[c]==1) {
			*result++ = c;
			total++;
		} else {
			/* if not, recurse and expand */
			rlen = expand_symbol(best_table[c], best_table_len[c], result);
			total += rlen;
			result += rlen;
		}
		data++;
		len--;
	}
	*result=0;

	return total;
}

static int symbol_absolute(struct sym_entry *s)
{
	return toupper(s->sym[0]) == 'A';
}

static void write_src(void)
{
	unsigned int i, k, off;
	unsigned int best_idx[256];
	unsigned int *markers;
	char buf[KSYM_NAME_LEN];

	printf("#include <asm/types.h>\n");
	printf("#if BITS_PER_LONG == 64\n");
	printf("#define PTR .quad\n");
	printf("#define ALGN .align 8\n");
	printf("#else\n");
	printf("#define PTR .long\n");
	printf("#define ALGN .align 4\n");
	printf("#endif\n");

	printf("\t.section .rodata, \"a\"\n");

	/* Provide proper symbols relocatability by their '_text'
	 * relativeness.  The symbol names cannot be used to construct
	 * normal symbol references as the list of symbols contains
	 * symbols that are declared static and are private to their
	 * .o files.  This prevents .tmp_kallsyms.o or any other
	 * object from referencing them.
	 */
	output_label("kallsyms_addresses");
	for (i = 0; i < table_cnt; i++) {
		if (!symbol_absolute(&table[i])) {
			if (_text <= table[i].addr)
				printf("\tPTR\t_text + %#llx\n",
					table[i].addr - _text);
			else
				printf("\tPTR\t_text - %#llx\n",
					_text - table[i].addr);
		} else {
			printf("\tPTR\t%#llx\n", table[i].addr);
		}
	}
	printf("\n");

	output_label("kallsyms_num_syms");
	printf("\tPTR\t%d\n", table_cnt);
	printf("\n");

	/* table of offset markers, that give the offset in the compressed stream
	 * every 256 symbols */
	markers = malloc(sizeof(unsigned int) * ((table_cnt + 255) / 256));
	if (!markers) {
		fprintf(stderr, "kallsyms failure: "
			"unable to allocate required memory\n");
		exit(EXIT_FAILURE);
	}

	output_label("kallsyms_names");
	off = 0;
	for (i = 0; i < table_cnt; i++) {
		if ((i & 0xFF) == 0)
			markers[i >> 8] = off;

		printf("\t.byte 0x%02x", table[i].len);
		for (k = 0; k < table[i].len; k++)
			printf(", 0x%02x", table[i].sym[k]);
		printf("\n");

		off += table[i].len + 1;
	}
	printf("\n");

	output_label("kallsyms_markers");
	for (i = 0; i < ((table_cnt + 255) >> 8); i++)
		printf("\tPTR\t%d\n", markers[i]);
	printf("\n");

	free(markers);

	output_label("kallsyms_token_table");
	off = 0;
	for (i = 0; i < 256; i++) {
		best_idx[i] = off;
		expand_symbol(best_table[i], best_table_len[i], buf);
		printf("\t.asciz\t\"%s\"\n", buf);
		off += strlen(buf) + 1;
	}
	printf("\n");

	output_label("kallsyms_token_index");
	for (i = 0; i < 256; i++)
		printf("\t.short\t%d\n", best_idx[i]);
	printf("\n");
}


/* table lookup compression functions */

/* count all the possible tokens in a symbol */
static void learn_symbol(unsigned char *symbol, int len)
{
	int i;

	for (i = 0; i < len - 1; i++)
		token_profit[ symbol[i] + (symbol[i + 1] << 8) ]++;
}

/* decrease the count for all the possible tokens in a symbol */
static void forget_symbol(unsigned char *symbol, int len)
{
	int i;

	for (i = 0; i < len - 1; i++)
		token_profit[ symbol[i] + (symbol[i + 1] << 8) ]--;
}

/* remove all the invalid symbols from the table and do the initial token count */
static void build_initial_tok_table(void)
{
	unsigned int i, pos;

	pos = 0;
	for (i = 0; i < table_cnt; i++) {
		if ( symbol_valid(&table[i]) ) {
			if (pos != i)
				table[pos] = table[i];
			learn_symbol(table[pos].sym, table[pos].len);
			pos++;
		}
	}
	table_cnt = pos;
}

static void *find_token(unsigned char *str, int len, unsigned char *token)
{
	int i;

	for (i = 0; i < len - 1; i++) {
		if (str[i] == token[0] && str[i+1] == token[1])
			return &str[i];
	}
	return NULL;
}

/* replace a given token in all the valid symbols. Use the sampled symbols
 * to update the counts */
static void compress_symbols(unsigned char *str, int idx)
{
	unsigned int i, len, size;
	unsigned char *p1, *p2;

	for (i = 0; i < table_cnt; i++) {

		len = table[i].len;
		p1 = table[i].sym;

		/* find the token on the symbol */
		p2 = find_token(p1, len, str);
		if (!p2) continue;

		/* decrease the counts for this symbol's tokens */
		forget_symbol(table[i].sym, len);

		size = len;

		do {
			*p2 = idx;
			p2++;
			size -= (p2 - p1);
			memmove(p2, p2 + 1, size);
			p1 = p2;
			len--;

			if (size < 2) break;

			/* find the token on the symbol */
			p2 = find_token(p1, size, str);

		} while (p2);

		table[i].len = len;

		/* increase the counts for this symbol's new tokens */
		learn_symbol(table[i].sym, len);
	}
}

/* search the token with the maximum profit */
static int find_best_token(void)
{
	int i, best, bestprofit;

	bestprofit=-10000;
	best = 0;

	for (i = 0; i < 0x10000; i++) {
		if (token_profit[i] > bestprofit) {
			best = i;
			bestprofit = token_profit[i];
		}
	}
	return best;
}

/* this is the core of the algorithm: calculate the "best" table */
static void optimize_result(void)
{
	int i, best;

	/* using the '\0' symbol last allows compress_symbols to use standard
	 * fast string functions */
	for (i = 255; i >= 0; i--) {

		/* if this table slot is empty (it is not used by an actual
		 * original char code */
		if (!best_table_len[i]) {

			/* find the token with the breates profit value */
			best = find_best_token();
			if (token_profit[best] == 0)
				break;

			/* place it in the "best" table */
			best_table_len[i] = 2;
			best_table[i][0] = best & 0xFF;
			best_table[i][1] = (best >> 8) & 0xFF;

			/* replace this token in all the valid symbols */
			compress_symbols(best_table[i], i);
		}
	}
}

/* start by placing the symbols that are actually used on the table */
static void insert_real_symbols_in_table(void)
{
	unsigned int i, j, c;

	memset(best_table, 0, sizeof(best_table));
	memset(best_table_len, 0, sizeof(best_table_len));

	for (i = 0; i < table_cnt; i++) {
		for (j = 0; j < table[i].len; j++) {
			c = table[i].sym[j];
			best_table[c][0]=c;
			best_table_len[c]=1;
		}
	}
}

static void optimize_token_table(void)
{
	build_initial_tok_table();

	insert_real_symbols_in_table();

	/* When valid symbol is not registered, exit to error */
	if (!table_cnt) {
		fprintf(stderr, "No valid symbol.\n");
		exit(1);
	}

	optimize_result();
}

/* guess for "linker script provide" symbol */
static int may_be_linker_script_provide_symbol(const struct sym_entry *se)
{
	const char *symbol = (char *)se->sym + 1;
	int len = se->len - 1;

	if (len < 8)
		return 0;

	if (symbol[0] != '_' || symbol[1] != '_')
		return 0;

	/* __start_XXXXX */
	if (!memcmp(symbol + 2, "start_", 6))
		return 1;

	/* __stop_XXXXX */
	if (!memcmp(symbol + 2, "stop_", 5))
		return 1;

	/* __end_XXXXX */
	if (!memcmp(symbol + 2, "end_", 4))
		return 1;

	/* __XXXXX_start */
	if (!memcmp(symbol + len - 6, "_start", 6))
		return 1;

	/* __XXXXX_end */
	if (!memcmp(symbol + len - 4, "_end", 4))
		return 1;

	return 0;
}

static int prefix_underscores_count(const char *str)
{
	const char *tail = str;

	while (*tail == '_')
		tail++;

	return tail - str;
}

static int compare_symbols(const void *a, const void *b)
{
	const struct sym_entry *sa;
	const struct sym_entry *sb;
	int wa, wb;

	sa = a;
	sb = b;

	/* sort by address first */
	if (sa->addr > sb->addr)
		return 1;
	if (sa->addr < sb->addr)
		return -1;

	/* sort by "weakness" type */
	wa = (sa->sym[0] == 'w') || (sa->sym[0] == 'W');
	wb = (sb->sym[0] == 'w') || (sb->sym[0] == 'W');
	if (wa != wb)
		return wa - wb;

	/* sort by "linker script provide" type */
	wa = may_be_linker_script_provide_symbol(sa);
	wb = may_be_linker_script_provide_symbol(sb);
	if (wa != wb)
		return wa - wb;

	/* sort by the number of prefix underscores */
	wa = prefix_underscores_count((const char *)sa->sym + 1);
	wb = prefix_underscores_count((const char *)sb->sym + 1);
	if (wa != wb)
		return wa - wb;

	/* sort by initial order, so that other symbols are left undisturbed */
	return sa->start_pos - sb->start_pos;
}

static void sort_symbols(void)
{
	qsort(table, table_cnt, sizeof(struct sym_entry), compare_symbols);
}

static void make_percpus_absolute(void)
{
	unsigned int i;

	for (i = 0; i < table_cnt; i++)
		if (symbol_in_range(&table[i], &percpu_range, 1))
			table[i].sym[0] = 'A';
}

int main(int argc, char **argv)
{
	if (argc >= 2) {
		int i;
		for (i = 1; i < argc; i++) {
			if(strcmp(argv[i], "--all-symbols") == 0)
				all_symbols = 1;
			else if (strcmp(argv[i], "--absolute-percpu") == 0)
				absolute_percpu = 1;
			else if (strncmp(argv[i], "--symbol-prefix=", 16) == 0) {
				char *p = &argv[i][16];
				/* skip quote */
				if ((*p == '"' && *(p+2) == '"') || (*p == '\'' && *(p+2) == '\''))
					p++;
				symbol_prefix_char = *p;
			} else if (strncmp(argv[i], "--page-offset=", 14) == 0) {
				const char *p = &argv[i][14];
				kernel_start_addr = strtoull(p, NULL, 16);
			} else
				usage();
		}
	} else if (argc != 1)
		usage();

	read_map(stdin);
	if (absolute_percpu)
		make_percpus_absolute();
	sort_symbols();
	optimize_token_table();
	write_src();

	return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #!/bin/bash

#
# This script requires at least spatch
# version 1.0.0-rc11.
#

SPATCH="`which ${SPATCH:=spatch}`"

trap kill_running SIGTERM SIGINT
declare -a SPATCH_PID

# The verbosity may be set by the environmental parameter V=
# as for example with 'make V=1 coccicheck'

if [ -n "$V" -a "$V" != "0" ]; then
	VERBOSE="$V"
else
	VERBOSE=0
fi

if [ -z "$J" ]; then
	NPROC=$(getconf _NPROCESSORS_ONLN)
else
	NPROC="$J"
fi

FLAGS="$SPFLAGS --very-quiet"

# spatch only allows include directories with the syntax "-I include"
# while gcc also allows "-Iinclude" and "-include include"
COCCIINCLUDE=${LINUXINCLUDE//-I/-I }
COCCIINCLUDE=${COCCIINCLUDE//-include/-I}

if [ "$C" = "1" -o "$C" = "2" ]; then
    ONLINE=1

    # Take only the last argument, which is the C file to test
    shift $(( $# - 1 ))
    OPTIONS="$COCCIINCLUDE $1"
else
    ONLINE=0
    if [ "$KBUILD_EXTMOD" = "" ] ; then
        OPTIONS="--dir $srctree $COCCIINCLUDE"
    else
        OPTIONS="--dir $KBUILD_EXTMOD $COCCIINCLUDE"
    fi
fi

if [ "$KBUILD_EXTMOD" != "" ] ; then
    OPTIONS="--patch $srctree $OPTIONS"
fi

if [ ! -x "$SPATCH" ]; then
    echo 'spatch is part of the Coccinelle project and is available at http://coccinelle.lip6.fr/'
    exit 1
fi

if [ "$MODE" = "" ] ; then
    if [ "$ONLINE" = "0" ] ; then
	echo 'You have not explicitly specified the mode to use. Using default "report" mode.'
	echo 'Available modes are the following: patch, report, context, org'
	echo 'You can specify the mode with "make coccicheck MODE=<mode>"'
	echo 'Note however that some modes are not implemented by some semantic patches.'
    fi
    MODE="report"
fi

if [ "$MODE" = "chain" ] ; then
    if [ "$ONLINE" = "0" ] ; then
	echo 'You have selected the "chain" mode.'
	echo 'All available modes will be tried (in that order): patch, report, context, org'
    fi
elif [ "$MODE" = "report" -o "$MODE" = "org" ] ; then
    FLAGS="$FLAGS --no-show-diff"
fi

if [ "$ONLINE" = "0" ] ; then
    echo ''
    echo 'Please check for false positives in the output before submitting a patch.'
    echo 'When using "patch" mode, carefully review the patch before submitting it.'
    echo ''
fi

run_cmd() {
	local i
	if [ $VERBOSE -ne 0 ] ; then
		echo "Running ($NPROC in parallel): $@"
	fi
	for i in $(seq 0 $(( NPROC - 1)) ); do
		eval "$@ --max $NPROC --index $i &"
		SPATCH_PID[$i]=$!
		if [ $VERBOSE -eq 2 ] ; then
			echo "${SPATCH_PID[$i]} running"
		fi
	done
	wait
}

kill_running() {
	for i in $(seq $(( NPROC - 1 )) ); do
		if [ $VERBOSE -eq 2 ] ; then
			echo "Killing ${SPATCH_PID[$i]}"
		fi
		kill ${SPATCH_PID[$i]} 2>/dev/null
	done
}

coccinelle () {
    COCCI="$1"

    OPT=`grep "Option" $COCCI | cut -d':' -f2`

#   The option '--parse-cocci' can be used to syntactically check the SmPL files.
#
#    $SPATCH -D $MODE $FLAGS -parse_cocci $COCCI $OPT > /dev/null

    if [ $VERBOSE -ne 0 -a $ONLINE -eq 0 ] ; then

	FILE=`echo $COCCI | sed "s|$srctree/||"`

	echo "Processing `basename $COCCI`"
	echo "with option(s) \"$OPT\""
	echo ''
	echo 'Message example to submit a patch:'

	sed -ne 's|^///||p' $COCCI

	if [ "$MODE" = "patch" ] ; then
	    echo ' The semantic patch that makes this change is available'
	elif [ "$MODE" = "report" ] ; then
	    echo ' The semantic patch that makes this report is available'
	elif [ "$MODE" = "context" ] ; then
	    echo ' The semantic patch that spots this code is available'
	elif [ "$MODE" = "org" ] ; then
	    echo ' The semantic patch that makes this Org report is available'
	else
	    echo ' The semantic patch that makes this output is available'
	fi
	echo " in $FILE."
	echo ''
	echo ' More information about semantic patching is available at'
	echo ' http://coccinelle.lip6.fr/'
	echo ''

	if [ "`sed -ne 's|^//#||p' $COCCI`" ] ; then
	    echo 'Semantic patch information:'
	    sed -ne 's|^//#||p' $COCCI
	    echo ''
	fi
    fi

    if [ "$MODE" = "chain" ] ; then
	run_cmd $SPATCH -D patch   \
		$FLAGS --cocci-file $COCCI $OPT $OPTIONS               || \
	run_cmd $SPATCH -D report  \
		$FLAGS --cocci-file $COCCI $OPT $OPTIONS --no-show-diff || \
	run_cmd $SPATCH -D context \
		$FLAGS --cocci-file $COCCI $OPT $OPTIONS               || \
	run_cmd $SPATCH -D org     \
		$FLAGS --cocci-file $COCCI $OPT $OPTIONS --no-show-diff || exit 1
    elif [ "$MODE" = "rep+ctxt" ] ; then
	run_cmd $SPATCH -D report  \
		$FLAGS --cocci-file $COCCI $OPT $OPTIONS --no-show-diff && \
	run_cmd $SPATCH -D context \
		$FLAGS --cocci-file $COCCI $OPT $OPTIONS || exit 1
    else
	run_cmd $SPATCH -D $MODE   $FLAGS --cocci-file $COCCI $OPT $OPTIONS || exit 1
    fi

}

if [ "$COCCI" = "" ] ; then
    for f in `find $srctree/scripts/coccinelle/ -name '*.cocci' -type f | sort`; do
	coccinelle $f
    done
else
    coccinelle $COCCI
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         cmd_scripts/basic/fixdep := gcc -Wp,-MD,scripts/basic/.fixdep.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89     -o scripts/basic/fixdep scripts/basic/fixdep.c  

source_scripts/basic/fixdep := scripts/basic/fixdep.c

deps_scripts/basic/fixdep := \
    $(wildcard include/config/his/driver.h) \
    $(wildcard include/config/my/option.h) \
    $(wildcard include/config/.h) \
    $(wildcard include/config/foo.h) \
    $(wildcard include/config/boom.h) \
  /usr/include/stdc-predef.h \
  /usr/include/arm-linux-gnueabihf/sys/types.h \
  /usr/include/features.h \
  /usr/include/arm-linux-gnueabihf/sys/cdefs.h \
  /usr/include/arm-linux-gnueabihf/bits/wordsize.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs-hard.h \
  /usr/include/arm-linux-gnueabihf/bits/types.h \
  /usr/include/arm-linux-gnueabihf/bits/typesizes.h \
  /usr/include/time.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h \
  /usr/include/endian.h \
  /usr/include/arm-linux-gnueabihf/bits/endian.h \
  /usr/include/arm-linux-gnueabihf/bits/byteswap.h \
  /usr/include/arm-linux-gnueabihf/bits/byteswap-16.h \
  /usr/include/arm-linux-gnueabihf/sys/select.h \
  /usr/include/arm-linux-gnueabihf/bits/select.h \
  /usr/include/arm-linux-gnueabihf/bits/sigset.h \
  /usr/include/arm-linux-gnueabihf/bits/time.h \
  /usr/include/arm-linux-gnueabihf/sys/sysmacros.h \
  /usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h \
  /usr/include/arm-linux-gnueabihf/sys/stat.h \
  /usr/include/arm-linux-gnueabihf/bits/stat.h \
  /usr/include/arm-linux-gnueabihf/sys/mman.h \
  /usr/include/arm-linux-gnueabihf/bits/mman.h \
  /usr/include/arm-linux-gnueabihf/bits/mman-linux.h \
  /usr/include/unistd.h \
  /usr/include/arm-linux-gnueabihf/bits/posix_opt.h \
  /usr/include/arm-linux-gnueabihf/bits/environments.h \
  /usr/include/arm-linux-gnueabihf/bits/confname.h \
  /usr/include/getopt.h \
  /usr/include/fcntl.h \
  /usr/include/arm-linux-gnueabihf/bits/fcntl.h \
  /usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h \
  /usr/include/string.h \
  /usr/include/xlocale.h \
  /usr/include/arm-linux-gnueabihf/bits/string.h \
  /usr/include/arm-linux-gnueabihf/bits/string2.h \
  /usr/include/stdlib.h \
  /usr/include/arm-linux-gnueabihf/bits/waitflags.h \
  /usr/include/arm-linux-gnueabihf/bits/waitstatus.h \
  /usr/include/alloca.h \
  /usr/include/arm-linux-gnueabihf/bits/stdlib-bsearch.h \
  /usr/include/arm-linux-gnueabihf/bits/stdlib-float.h \
  /usr/include/stdio.h \
  /usr/include/libio.h \
  /usr/include/_G_config.h \
  /usr/include/wchar.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio_lim.h \
  /usr/include/arm-linux-gnueabihf/bits/sys_errlist.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include-fixed/limits.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include-fixed/syslimits.h \
  /usr/include/limits.h \
  /usr/include/arm-linux-gnueabihf/bits/posix1_lim.h \
  /usr/include/arm-linux-gnueabihf/bits/local_lim.h \
  /usr/include/linux/limits.h \
  /usr/include/arm-linux-gnueabihf/bits/posix2_lim.h \
  /usr/include/ctype.h \
  /usr/include/arpa/inet.h \
  /usr/include/netinet/in.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdint.h \
  /usr/include/stdint.h \
  /usr/include/arm-linux-gnueabihf/bits/wchar.h \
  /usr/include/arm-linux-gnueabihf/sys/socket.h \
  /usr/include/arm-linux-gnueabihf/sys/uio.h \
  /usr/include/arm-linux-gnueabihf/bits/uio.h \
  /usr/include/arm-linux-gnueabihf/bits/socket.h \
  /usr/include/arm-linux-gnueabihf/bits/socket_type.h \
  /usr/include/arm-linux-gnueabihf/bits/sockaddr.h \
  /usr/include/arm-linux-gnueabihf/asm/socket.h \
  /usr/include/asm-generic/socket.h \
  /usr/include/arm-linux-gnueabihf/asm/sockios.h \
  /usr/include/asm-generic/sockios.h \
  /usr/include/arm-linux-gnueabihf/bits/in.h \

scripts/basic/fixdep: $(deps_scripts/basic/fixdep)

$(deps_scripts/basic/fixdep):
                                                                        cmd_scripts/basic/bin2c := gcc -Wp,-MD,scripts/basic/.bin2c.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89     -o scripts/basic/bin2c scripts/basic/bin2c.c  

source_scripts/basic/bin2c := scripts/basic/bin2c.c

deps_scripts/basic/bin2c := \
  /usr/include/stdc-predef.h \
  /usr/include/stdio.h \
  /usr/include/features.h \
  /usr/include/arm-linux-gnueabihf/sys/cdefs.h \
  /usr/include/arm-linux-gnueabihf/bits/wordsize.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs.h \
  /usr/include/arm-linux-gnueabihf/gnu/stubs-hard.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h \
  /usr/include/arm-linux-gnueabihf/bits/types.h \
  /usr/include/arm-linux-gnueabihf/bits/typesizes.h \
  /usr/include/libio.h \
  /usr/include/_G_config.h \
  /usr/include/wchar.h \
  /usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio_lim.h \
  /usr/include/arm-linux-gnueabihf/bits/sys_errlist.h \
  /usr/include/arm-linux-gnueabihf/bits/stdio.h \

scripts/basic/bin2c: $(deps_scripts/basic/bin2c)

$(deps_scripts/basic/bin2c):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ELF          (            w    4     (   <0Ÿåà-å “å “å0àŸå Á‘ç œåÀœå  å ‘ç ƒåÀƒå ‘åƒå  Òå Ãåğä         Pá  
 @â Pã ñŸ—  ê”   Œ   „   |   |   œ    Qã	  
 Qã  
 Qã  
 Qã  
  Qã    àÿ/á  ãÿ/á  áÿ/á   ãÿ/á  àãÿ/á<0Ÿå<Ÿåà-åĞMâ “å ‘å  Rã0“å ’  Ÿ  å0ƒâ  áŸåşÿÿëĞâğä               p@-é	  ãDPŸå @ á` á 0•å8 Ÿå ãşÿÿë Tá  Šò Ôà  •å Ÿåşÿÿë Váùÿÿ* •å
  ãp@½èşÿÿê            -é00Ÿåà-åĞMâ 0“åâ  Sãå  
 å3ÿ/áĞâàäĞâÿ/á     -é0@-éĞMâT@ŸåTPŸåÀâ$0”å  ”å  •åDŸåÀåşÿÿëå å  •åşÿÿë •å
  ãşÿÿë(0”å0ƒâ(0„åĞâ0@½èĞâÿ/á        $    -é  å@-éĞMâD@Ÿå$0åÀâ ’å  ”å4ŸåÀåşÿÿëå å  ”åşÿÿë ”å
  ãşÿÿëĞâ@½èĞâÿ/á    $    -élŸål Ÿå@-éĞMâÀ‘å 0’å\@Ÿå  \ã0ƒâ 0‚å  ”å œH Ÿ0‘åDŸåşÿÿë0â  áå  ”å0åşÿÿë ”å
  ãşÿÿëĞâ@½èĞâÿ/á                4    -é\0Ÿå@-éĞMâ “åP@Ÿå  Rã0“å ’D Ÿ  ”å@Ÿåşÿÿë0â  áå  ”å0åşÿÿë ”å
  ãşÿÿëĞâ@½èĞâÿ/á            4   0‘åğ@-é0CâĞMâ@ á ` áP á SãñŸ—  êØ  Ø  d     d   0Òåm Sã+  
n Sã
  
ÄPŸåÄ Ÿåşÿÿë¼ Ÿå0”å¸Ÿå På  Pã     áşÿÿëĞâğ€½è 0Òå0 Sã”pŸ  
„ Ÿåşÿÿë0”åx Ÿå påPåxŸå  Pã     áşÿÿëĞâğ€½èP ŸåşÿÿëH Ÿå0”åPŸå På  Pã     áşÿÿëĞâğ€½è4PŸåÔÿÿê Òå0ŸåpŸåß âX Rãp İÿÿê<   H   T   P   h   |   @   @-é   á0ŸåŸå  “åşÿÿë  ãşÿÿë       p@-é ` á@ á"  ã áşÿÿë  ê\ Ÿå ã  ã0 áşÿÿë@…â  á" ãşÿÿë PPâ  
 Uàòÿÿ
0 á  á$Ÿåşÿÿëíÿÿê á  áşÿÿë á"  ãp@½èşÿÿêœ   ”   8@-é  ãP á  ã @ áşÿÿë Ÿå,0’å,@‚å  Sã@ƒ 0„åP„å8€½è    ğG-é` á\@Ÿå  á0p”å40”åP‡à Uá  ª8€”å ˆà	 á  áşÿÿë 0 ã0P„å0Èçğ‡½è …â Êã
 á8 ”åşÿÿë4 „å € á8 „åîÿÿê    ğA-éP á 0“å@ á ‚â Rá € á` á  Š 0‘å€Ãç   ãğ½èp„â  ‘å‡p á áşÿÿë  Pã  † 0  p…òÿÿ  àãğ½èø@-é @ á 0åP áp“å  áşÿÿë  •å0”å@”å`’å@dà@`à  áşÿÿë •éOoá¤B á0bà `àoá  á  Tá  Š  :  á áø@½èşÿÿê  ãø€½è  àãø€½è8@-é P á$ Ÿå@ áşÿÿë0Ÿå á  á  “åşÿÿë Ÿå8@½èşÿÿê        ¨   , Ÿå0 á# Qã@-é @ áŸÕŸÅ!’çşÿÿë á)  ã@½èşÿÿê    ¬   ¸   ¨ÀŸåp@-é@ á 0Ÿå œå  Pã    QãP á  ; Tã  
A Tã  
5 Tãp€½ 0•ål ŸålŸå$ “å  å(0“å ’åşÿÿëX0Ÿå  •å<“å Rá’@ ƒ<ƒp€½è0`Ÿå   á4Ÿå  –åşÿÿë  –å áÇÿÿë –å
  ãşÿÿëİÿÿê    Ä       Ô       Ğ   À‘åp@-éÀLâ \ãĞMâ@ á ` áP á  Š  Òån Rã  
` ŸåşÿÿëXÀŸå0”åTŸå På  Pã       áşÿÿëĞâp€½è  Sãûÿÿ$ Ÿåşÿÿë Ÿå0”åŸå  Pã     áĞâp@½èşÿÿêH       0‘å Sãÿ/ 0Òån Sãÿ/ğ@-é ` áĞMâD ŸåP á@ áşÿÿë4pŸå  Pã p şÿÿë àÕå0”å  áŸå Àå  áÁÜç ÀåşÿÿëĞâğ€½èH   H  p@-é @Ÿå `”å  Vã  
D0”å ”åCâ Qáp€½ˆPƒâ  áa á áşÿÿë  Pã  „å  
 `Fâ€à0â   ã €çDP„å å ƒä ƒä ƒä ƒä ƒä  ƒåp€½è  ãşÿÿë  Pã0   „å `€`„D0„p€½ Ÿåªşÿë    T   Sá0@-éĞMâ  
,Bâ BâàÀŸå Rã!ŒY?Œâ ƒà`"’•Ì Ÿ…Ì Ÿå
şÿëÈ Ÿå   ã 0’å0ƒâ 0‚åĞâ0€½è°@Ÿå°0Ÿå<”å 0“å$‘å Qá   
,Bâ€0Ÿå BâYƒâ Rã à  Š!ƒà| Ÿå`R’å  áğıÿë<0”ålŸå$ “å  ‘å(0“å ’å PåXŸåşÿÿëÛÿÿêD Ÿå, Ÿåãıÿë<0”å8ŸåPŸå$ “å  ‘å(0“å ’åğÿÿê  ãÓÿÿê    ˆ                °      Ô  @-é  ãşÿÿë  Pã  
0Ÿå   ã ã8 ƒå4ƒå0 ƒå  Àå€½èşÿÿë    p@-é ` á â@ áşÿÿë PPâ  
0Ÿå á  á8Pƒåşÿÿë 0 ã0Åçp€½èşÿÿë    ğA-é 0 á p á` áà Ÿå ã  ãşÿÿëÔ€Ÿå  Öå  Rã
 R)  
 †â P ã ÀÒå@ áP…â  \ã
 \ ‚âøÿÿ  ã0 á ã” Ÿåşÿÿë á   ãşÿÿë  á á  ã0 áşÿÿë Pã  
h Ÿå ã!  ã 0˜åşÿÿë
  ã áşÿÿë 0Ôå`„â  Sã×ÿÿ0 á8 Ÿå ã  ãğA½èşÿÿê ã  ã0 á Ÿå@ áşÿÿëëÿÿê      4    ,  @0Ÿå0@-éP á0“åAßMâ @ á ã0“å  á  Ÿåşÿÿë 0•å  á á   ã3ÿ/áAßâ0€½è    8  p@-é P á  á@ áşÿÿë Pâ  
  á0 á  ãşÿÿë Pãp€½0Ÿå Ÿå ã 0“å!  ãp@½èşÿÿêşÿÿë      ğA-é p á°€Ÿå` á  Öå  Rã
 R"  
 †â P ã ÀÒå@ áP…â  \ã
 \ ‚âøÿÿ á#  ãşÿÿë á   ãşÿÿë  á á  ã0 áşÿÿë Pã  
D Ÿå ã!  ã 0˜åşÿÿë
  ã áşÿÿë 0Ôå`„â  SãÙÿÿğ½è á#  ã@ áşÿÿëòÿÿê      8@-é P áp@ŸåÅşÿë 0”å  Sã  
 ”å“çƒà Qá8€½  Qã  
”åàÔåÀ”å àÁåá“çå1“çÀƒå P€åRüÿë0 ãH0„å8€½è  Uã8€½ ”å  áõÿÿê      Pãÿ/P Ÿå@-é 0’å  Sã  
 ’å“ç Pá  ƒ0å @ á  Sã    á@½èşÿÿê åşÿÿë  á@½èşÿÿê      Pãÿ/ åLŸå 0 ãà-åÀ ã0€å 0Âåàå  ‘å0Îå Ráàå,0€åà€åÀ€åğ0‘å1’ç Páğàäüÿê    ø@-é @ áp áşÿÿë P á  á `•åşÿÿëD Ÿå  ã p„å 0’å( „å  Sã  
 ’å1“ç Tá  
  ã 0 ã  „å$0„å 0 ã0„å `…åø€½è    p@-é ` á0  ãP áşÿÿë @Pâ  
P„å …âşÿÿë  Pã „å  
0 ã  á á0„åÑÿÿë  áp€½è  Ÿåıÿëh  ø@-é P áX@Ÿå 0”å  Sã  
 ”å“ç  Pã  
 áÀÿÿëø@½èÖûÿê4şÿë ”å ãÀ ”èşÿÿë á  Vã†ç   ´ÿÿëø@½èÊûÿê    ğO-é$ĞMâd^ŸåL0•å  Sã  P •å0 ã  RãP0…L0…å0•å<.Ÿå  Sã8>Ÿ 0“0‚T0•å$.Ÿå  Sã$>Ÿ 0“T0‚ 0•å.Ÿå  SãK 
 ’å1“ç  SãG 
©ûÿëø½Ÿå Õå@•åP•åìŸåìŸå+Î‹â 0 ã 0å` áp á  Æå ‹ààÌ*åà áñœá  Qã`†Â  Ú  Öåôÿÿê  aâ¤Ÿå‚  ágàò á p‰å ˆå Öå`…å 0ÆåÅå Bâ& RãñŸ—1 êŒ  Œ  ¨  ¸  Ì  |  ¨  ¨  ¬  ´  è  ¼  `  h  p  x  ¨  ¨  ğ  ¨  Ü  ¨  l  ¼  ğ  (  D  Œ  Ä  h  È  ğ  è  `        À  Ğ  Ğ  0•åĞŸå  Sã •å“ÄŸşÿÿëÀ<Ÿå  ãP …å  “å´Ÿå0’å0ƒâ0‚å$Ğâğ½è  ãP …å@•å Õå á¤ÿÿêˆŸåõÿÿê `˜å p™å Fâ Rã&  Š Fâ Rãà×ç×…  “0‹à‹€HïÓåHÑ… ×å  †€À‹àHÏÜå 0Œà0ƒàH Sã  Ê,ŒŸåB áˆà°?å  Sã  ºŸå €à0Ğç Sá
   ‡âŠâşÿÿë  Pã  0Úç  Sã  ¨?å ã)   á áøıÿëĞ;Ÿå8 •åÌŸå  ƒåÁÿÿê¼+Ÿå8•å0 ã ‚åP0…åC ãºÿÿêŒ+Ÿå@•å Õå ’å ‘å ‚â åP•å^ÿÿêh;Ÿå `“å  Vã¸ 
tKŸå –å  ”å  ƒå `å  Vã  
 •åşÿÿë 0•å+Ÿå  Sã   ’“şÿÿë –åşÿÿë  ”åşÿÿë `„åŸå–ÿÿê Õå0 á  ã Cä gà p‰å  ˆå VåFå ˜å  ™å0…å ÅåFüÿëØ:Ÿå8 •åÜ
Ÿå  ƒå$Ğâğ½è  ™å ˜å0åÀå;üÿë@•å ÕåP•åÀå0å$ÿÿê¤
Ÿåøûÿë Õå0 á  ã Cä gà p‰å  ˆå VåFå ˜å  ™åAâ €âÛÿÿê  ™å ˜å0åÀå €âAâáÿÿê  ™å å  Ğå Ráˆ 
0åÀå ãØÿÿêÕå0 áø)Ÿå@ áCä  ã gà  ˆå p‰å`VåDå ’åäÉŸå  ã ‘å8à•å  ‚àP …å0…å`Åå å àŒåC ã?ÿÿê0åœ9Ÿå ãÀå à“å´	Ÿå å ‚à å¶ÿÿê ˜å  Qã  
  ™å Aâà€à Ğç	 Pã  P  
	  ê ~å Bâ	 Pã  P    Rã  ˆå áöÿÿ  ã  ™å0åÀåÚûÿë\ •åÀå  Rãä(ŸåàŸ0åX ’@’\   @‘ ÒåP’å»şÿêÜ8ŸåÜŸå  “å0’å0ƒâ0‚åÿÿê Õå`•åP•å±şÿê ãP…å@•å Õå«şÿê  ™å •åB •è àÚå Õåàå  Âåá‘çàåå@â Ráâ  *@Ÿåpå å`‡â €â  à  Qáà  *`åpAâàpå ápGâàÇå à–å@å Pá÷ÿÿŠpå@„â`à ‚à Rá Šàp…åpåÆ  * ŸåUûÿë `˜å p™å Fâ RãĞ  Š Fâ Rã  ×å×…à “ À‹à‹€HÏÜåHïÑ…×çà†€‹à0ŒàHÑå0ƒàH Sã¿  Ê ‡ŸåB áˆà°?å  Sã¹  ºŒŸå à0Ñç  Sá´   ‡âŠâşÿÿë  Pã¯  0Úç  Sã¬  H7Ÿå¨å	  ã 0“å ã0…å0“åP …å0…åÕşÿ
4'Ÿåû>Hâ0ƒà¬å 0‚å™şÿê•å  •å Õå  áå ™å  Æå !šçaàAâå,’å Šà  Qã¬Ÿå å ‘’  ‚ ”Ÿ‘!š€  à’å, ‚ •å@à  Tá@åˆ  *âà Pá ™ås Š(@’å  aà  Tã¤   Pã2 
@åp á` á Vá`…åP •å#şÿšGâ Fâàñå"‚à  ^ãá‹à Ìê  Qá ‚à‚  áò œáôÿÿşÿê8ŸåWşÿê4ŸåUşÿê0ŸåSşÿê  ™å0åÀå 0Òå 0åpüÿë ãP…å@•å ÕåÀå0åóıÿê ãDşÿêğŸåBşÿêG ã@şÿê à˜å  ^ã   Ó	  Ú  ™å   ãà‚àÒä	 Qã À € € Ráøÿÿ\@•åX …å  Tã<Ÿå+  
  Tá! Ê @dà Tã  Ú` á`Fâ|Ÿå ã0åÀåßúÿë VãÀå0åõÿÿÊ	 Dâ Âã Dâ @bà0åÀå á<Ÿå•şÿêÀûÿë •å ãP •èşÿÿë„ç°ıÿêİå@Bâ@…åBå  ‰å Rå ãP…å Åå°ıÿêôŸå„úÿë„$Ÿå Òå@’åP’å©ıÿê”4Ÿå	  ãP …å 0“å0…å0“å0…å*şÿê •åşÿÿë  áğıÿê p™åå8$Ÿå`‡à0Ÿå WáP ’å`å  * GâàFâğå"‚à  Qã‹ Ì‘ Pá ‚à‚  áò œáôÿÿ‚àŒàòÑá  Qã‘ıÿÚ`†â`…å‹ıÿê $Ÿå8•å	0 ã ‚åP0…åøŸåËıÿê @â  Pã å  Ú Nâ àà Ñä Qá âåûÿÿ å  ’å,’å Qã0…0‚†  
’å åAâ`à  Qã+  Êpå`åpå@ á  êà”å0åÀå á  Qã®Ğ„åâşÿÿëÀå0å  Pã „å  
 @—å å €à”å …åAâbà  Qã  Ê  Zã  
”å ”å`•å  Qã``ààÿÿ„å(Ÿåúÿë
0 á0“åğ ğç`åpå0åÀååşÿÿëå0å
Qã  ±* £`åpå
` áÀå å @ á 0€åp á  ê  ”å Rãp   0„å0åD2ŸåÀå “åşÿÿë42ŸåÀå@“è0å •åÀå0åşÿÿë
–ç0å  á‘å¢ŸåàşÿÿëÀå0å  Pã …åâÿÿº@šè`åpå’ç å  
¡‚àA’ç   ã å å”å  ‚à Rá”•!  Š0Áç šå å …å Pã ‘åŒŸå €à0Àå  šå å  ‰å=    áP •åH0…å Bâ…å¢/‚àÂ  á# ‚âùüÿê å  Rã  
  •å•å   ãA’ç¡‚à  ã å, „å×ÿÿêÀ‚à ”å0åÀå åşÿÿë åÀå0å „å šå‘å  QãÏÿÿTŸåšùÿë •å0åÀåşÿÿë•å  •å0 ã0å •å¡‚àA’çÀå0å¹ÿÿêÜ Ÿå8 ‘å0 ã  ‚åP0åC ãıÿêü Ÿåƒùÿëø Ÿåùÿë
@ á  á   á å Pã  
p á å`‡à Vá`åP‘åªüÿš GâàFâ ğåà  Rã!‹  Ì*’ Pá à‚  áòœáôÿÿœüÿê ”åp á ‘å
`‚àrşÿê                        Ì  ¸              ø  d              ü  ø  ˜  "  !      ì  Ä  H  ”  t      Pãÿ/p@-é P át@Ÿåfúÿë 0”å  Sã  
 ”å“ç á  PãÀƒà  
 ”åàÔåâÀƒà àÀåa“ç”åà‚â †å1“çà„åƒå PŒåğ÷ÿë0 ãH0„åp€½è”åÁ á÷ÿÿê    ø@-éX`Ÿå P–å  Uãø€½@–å•çq…à  Pã  
şÿÿë  Tã 0 ã1…çø€½0å@Dâ  Sã@†åø€½Ô÷ÿë0 ãH0†åø€½èø€½è     Qã  šø@-épAâ@Ğç  Tã  €à`Qå  Vã   P á0  ãşÿÿë @Pâ  
0 ãp„åP„åP„å`„å `„åp„å`„å(`„å,`„å0„åşÿÿë  áø€½è  áø€½è   ãø€½è   ãÿ/á  ŸåŞøÿëø  ø@-épâ @ á  áP áşÿÿë `Pâ  
  Uã0 ÁàƒÀ FÂ  ÚÀÓä SáÀâåûÿÿ †à 0 ã0Âå á0Æç  áşÿÿë 0Pâ  
  ã ƒåø€½è Ÿå¾øÿë Ÿå¼øÿë(  T  @-é @ áşÿÿë  á  á@½èşÿÿê0Ÿå “åÿ/á    0Ÿå “åÿ/á    0ŸåT “åÿ/á    0Ÿå  “åÿ/á    0Ÿå  “åÿ/á    0Ÿå ƒåÿ/á    0Ÿå ƒåÿ/á    0ŸåT ƒåÿ/á    0Ÿå` “åÿ/á    0Ÿå` ƒåÿ/á    ø@-éh`Ÿå P–å  Uã  
@–å•ç  Pã p   
şÿÿëq…çşÿÿë@–å1•ç  Sâøÿÿ  áşÿÿë   ã  †å †åD †å †åL †åP †å †åT †åø€½è    şÿÿêşÿÿêşÿÿê@-éúÿë0Ÿå   ã ãPƒå\ ƒåX ƒå€½è    @-éÚMâĞMâxŸå @ áşÿÿë  Tã?oá£2 á 0   Sã  
 0Ôå/ Sã  
L Ÿåşÿÿë  Pâ  
0â0å8Ÿå0 á åşÿÿë åŸåşÿÿëÚâĞâ€½è   ãÚâĞâ€½èx  |  „  0Ÿå “åÿ/á    0Ÿå0“å  Sã “ Ÿÿ/á          PãøC-é¸Ÿå¸qŸå p ´Ÿåşÿÿë PPâf  
0 á¤Ÿå ã  ãşÿÿë˜1Ÿå @“å  Tã	  
 0”å ”å  Sã  á|Ÿ|Ÿşÿÿë @”å  TãõÿÿlŸåşÿÿëhaŸåhŸå  Pã       áşÿÿëT1Ÿå @“å  Tã   
0”å  Sã  
<Ÿå< “å  Rã	  
0’å Sã    êÀ’å \ã  
  ’å  Rãùÿÿ 0 ã0“åğ ğç ’å  Rã  
 0’å0Câ Sã  š@”å  Tã  
0”å  Sãâÿÿ  ã0 á ã¼ Ÿåşÿÿë  áşÿÿë á€ Ÿåşÿÿë   ãøƒ½è’å  Yãêÿÿ
 ™åşÿÿë ™å„Ÿå  Pã 0 0   áşÿÿëT ŸåşÿÿëhŸå  Pã       áşÿÿë ã  ã0 áH ŸåşÿÿëÓÿÿê  ãøƒ½èÄ  Œ  ´  È      ğ  ø  Ü  ˜         <     0  D  P  @-é @ á@  ãşÿÿë  Pã  
 0 ã@  ã „å 0Àå0„å  „å  á€½èşÿÿë@-é @ á å  Pã   
şÿÿë 0 ã0„å 0„å€½è  Qãÿ/ø@-é P ápå` á  áşÿÿë @ á  áşÿÿë 0•å  „à@€â Tá  Š  á áø@½èşÿÿê á  áşÿÿë @…å á p á …å  áø@½èşÿÿê -é@-é'ÜMâ$ĞMâ',â0â'Ìâ, ‚â0ÀŒâ0å @ á0 á  ’å å$ŸåÀåşÿÿë  áåşÿÿë'Üâ$Ğâ@½èĞâÿ/á'   åÿ/á@-éşÿÿë  Pã€½şÿÿë@-éşÿÿë  Pã€½şÿÿë0Ÿå  ƒåÿ/á    @-é Ÿåşÿÿë0Ÿå  Pã  €½è`  X  @-é Ÿåşÿÿë0Ÿå  Pã  €½èÜ  ˜  ,0Ÿåh“åd “å  Qãd ƒåÿ/  ’â    â    Ráÿ/ÿ/á    0 Ÿåh’åd0’å  Qã €àd ‚åÿ/ 0“â0   â    Sáÿ/ÿ/á    0Ÿåd “å  â  ÿ/á    0Ÿåh ƒåÿ/á    <0å  Sã    ê 0“å  Sã  
 “å Rãùÿÿ “å  Rã    ê80‘å8â0 ’å  Rã  
’å  Qãöÿÿ80å6Ãã€0Ãã8ƒã80€åÿ/á 0 ã0“åğ ğç@-é ã @ á  ãşÿÿë 0Pâ  
  ã ƒè€½èşÿÿë8@-é P á@ á  ã ãşÿÿë 0Pâ  
 Pƒå@ƒå8€½èşÿÿëp@-é ` áP á  ã ã@ áşÿÿë 0Pâ  
 `ƒåPƒå@ƒåp€½èşÿÿë@-é @Pâ  
 0”å0Câ SãñŸ—	  ê *   *  Ø)  ä)  ä)  ä)  ì)   ”åîÿÿë „å  á€½èL0Ÿå ”å Ráùÿÿ@0Ÿå  “åşÿÿë  Pâôÿÿ
 á  ã@½èşÿÿê ”åÜÿÿë „å ”åÙÿÿë „å  á€½è       p@-é ` áP á  ã ã@ áşÿÿë 0Pâ  
 `ƒåPƒå@ƒåp€½èşÿÿë  Pã  á  
  Qãÿ/  á  ãşÿÿê  áÿ/á  Pã  á  
  Qãÿ/  á  ãşÿÿê  áÿ/á  Pã8@-é @ á  
  ãşÿÿë PPâ1  
  ”å”å ”å À”å0 áÀLâ £è \ãñŸ—  êh+  h+  Œ+  ¤+  ¤+  h+  T+   •å| Ÿåşÿÿë  áşÿÿë @ ã  á8€½è0”å@ á0…å  á8€½è ”åşÿÿë …å ”åşÿÿë@ á …å  á8€½è ”åşÿÿë@ á …å  á8€½è ”é@ á  á …é8€½èşÿÿëp  @-é @Pâ€½ ”å0Aâ Sã  Š  ã3 áX ã  
  ê ã  
@”å  Tã  
 ”å0Aâ Sã3 á
  ŠX ã   ãñÿÿ
 ”åşÿÿë ”åşÿÿë  á@½èşÿÿê Ÿåşÿÿë  á@½èşÿÿê€½è„  p@-é @Pâ  
 0”å Sã  
 Sã   ”åõÿÿë „å ”åòÿÿë0”å P“å Uã „å6  
 På Uã  
  áp€½è ”åæÿÿë „å ”åãÿÿë0”å P“å Uã „å  
 På Uãğÿÿ`åÄ Ÿå Vá  
P ‚â Váéÿÿ  áşÿÿë ”åşÿÿë 0 ã` „è0„åáÿÿê`åˆ Ÿå Váóÿÿ
P ‚â VáÚÿÿşÿÿë0”å “è „è  áşÿÿëÓÿÿê`“åP Ÿå Vá
  
P ‚â VáØÿÿáÿÿê`“å0 Ÿå Váİÿÿ
P ‚â VáÁÿÿ  áşÿÿë0”å “è „è  áşÿÿë¼ÿÿêX   8@-é 0å  Sã8€½  ‘å  Rã8€½ P á  “å@ á@â Qã  š  ’å  Rá  
Bâ Qã  š  á‘ÿÿë  …å  ”åÿÿë  „å8€½è  á áT  ë 0•å  ”å  “åëÿÿê  á á  áL  ë 0•åëÿÿêp@-éĞMâ 0å à‘åÀ á Sá å å  
   ãĞâp€½è0Câ SãñŸ—øÿÿê/  /  ü.  Ô.  Ô.  „.  ¼.  0å ‘å `àoá  áìÿÿêå0œå Qáçÿÿ0å œå `àoá  áâÿÿê‘å åÕÿÿëŞÿÿêşÿÿëpPŸå å  åşÿÿë ál`•å  å âşÿÿë å 0å Sã  
 @ ãşÿÿë  åşÿÿël`…å  áÉÿÿê 0å  “å Rãôÿÿ@“å0å@dàOoá¤B áïÿÿê    ø@-é ` áp á@ á À—å  á á àœå ^á  
 0”å ƒâ P“å Uá	  ïÿÿë @”å@„âğÿÿêŒâ  áéÿÿë p—åp‡âêÿÿê ^ã U  
  á á•ÿÿë  Pãø€½ˆ Ÿå  —ål0’å0ƒâl0‚åşÿÿë  ”åşÿÿë Vã  
 Vãø€½\ Ÿåşÿÿë  ‡åP Ÿåşÿÿë  „åø€½è œå“å Ráãÿÿ0ŸåP Aâ  Rá RŞÿÿø€½è Ÿåşÿÿë  ‡å Ÿåşÿÿë  „åø€½è    ¨   X   øC-é P á` á@ á À–å  á á àœå ^á  
 0”å ƒâ p“å Wá	  ïÿÿë @”å@„âğÿÿêŒâ  áéÿÿë `–å`†âêÿÿê Sáøƒ½0Nâ Sã}  š UãO  
 Uãøƒ½ P–å p”å  á áEÿÿë  Pã‰   0•å Câ Sã Røƒ½ˆ À—å Lâ \ã Røƒ½ˆ Sã•å  
 \ã —å˜  
 Qáøƒ½ ‘å Bâ Pãøƒ½ˆàLâ Câïoáoá®â á  á á•   \ã SÇ  
 \ã       Pãº   \ã SÒ  
 Rãøƒ½ Sã£  
 Sãøƒ½  ^ã¼   \ãøƒ½ •å4Ÿå RáÓ  
P Câ  RáÉ  
 ÀCâ Ráøƒ½ —å RáÑ  
  Ráøƒ½  ãÌ#Ÿåşÿÿë P áE  ê P–å p”å  á á÷şÿë  Pã)   0•å Câ Sã Røƒ½ˆ  —åBâ Rã Qøƒ½ˆ Sã•9  
 Rã —åE  
  Qáøƒ½ ‘åÀ@â \ãøƒ½ˆ PãR  
 SãE  
 Rãøƒ½ —å  ’å Rã Søƒ½Ÿåşÿÿë P á  ê  á á  á_ÿÿë|ÿÿê  áşÿÿë P á  Uãøƒ½  –åşÿÿë  ”åşÿÿëØŸåşÿÿëÔ"Ÿål0’å0ƒâl0‚å  †å P„åøƒ½è  áşÿÿë P á  Uãøƒ½  –åşÿÿë  ”åşÿÿëŒŸåìÿÿê •å åÀAâ Qã \øƒ½ˆå½ÿÿê  ‘å Bâ Rã Pøƒ½ˆ‘åhÿÿê Àå \ãøƒ½ å´ÿÿê  ’å Pãøƒ½ ’åaÿÿê0•å 0“å Sã Røƒ½ºÿÿê‚Ÿå—å Yáhÿÿˆÿÿê Sãøƒ½ Rãøƒ½ •åà1Ÿå Rá`  
  Câ  RáV  
PÀCâ Ráøƒ½ —å Rá^  
  Ráøƒ½  ã¤!Ÿåşÿÿë P á©ÿÿê \ãøƒ½ —å •å8Àå ãøƒ½8À’å ãøƒ½  Rá9  
  áşÿÿë P á«ÿÿê€—åTŸå  Xá  
P @â  Xá@ÿÿXÿÿê4Ÿå€•å  Xá;ÿÿSÿÿê0•å —å8 “å ã=ÿÿ
8 ’å ã:ÿÿ
 Rá  
  ãşÿÿë P áÿÿê€•åè Ÿå  Xáäÿÿ  áşÿÿë P áˆÿÿê —å Rá+  
 0Câ Ráøƒ½6ÿÿê0—åP Bâ  Sá#  
  Bâ Sáøƒ½  ã Ÿåşÿÿë P áuÿÿê€ Ÿåşÿÿë P áqÿÿê —å Rá  
P0Câ Ráøƒ½©ÿÿê0—å  Bâ  Sá  
P Bâ Sáøƒ½  ã< Ÿåşÿÿë P áLÿÿê  ã  Ÿåşÿÿë P áGÿÿê  ã Ÿåşÿÿë P áTÿÿê¨   X          ğA-é ` áp á€ á@ á à˜å  á á 0å  á Sá  
 À”å0Œâ Pœå Uá	  íÿÿë @”å@„âïÿÿê â0 áçÿÿë €˜å€ˆâéÿÿê  á áéıÿë  Pãğ½ —å  Qã  
  á  ˜åşÿÿë  ‡å  ”åşÿÿë Vã
  
 Vãğ½8 Ÿåşÿÿë  ˆå, Ÿåşÿÿë  „åğ½è  ˜åïÿÿê Ÿåşÿÿë  ˆå Ÿåşÿÿë  „åğ½èX   ¨   @-é @Pâ
  
 0”å Sã  : Sã  š Sã  0”å0“å Sã	  
  á€½è ”åşÿÿë „å ”åşÿÿë „å  á€½è ”å0Ÿå Rá   0   „0„íÿÿêX   ğG-é @Pâ p  ` € x  
 0”å Câ Rã  Š Sã  
 Sã.  
 Sã  
0 á  áğ‡½èP”å 0•å0Câ SãñŸ—öÿÿêP9  p9  x9  œ9  œ9  8  9   ”åşÿÿë „å ”åşÿÿë 0”å Sã „åâÿÿ ”å0å Sãâÿÿ0”å°QŸå Sá  
P Eâ SáL  
PP…â SáØÿÿ 0 ã  ã0„å  „å0 áÓÿÿê ”å0å SãÎÿÿ0”å`QŸå Sáñÿÿ
P Eâ SáA  
PP…â SáÄÿÿ0 ã 0„åşÿÿë 0 ã0„å0 á „å½ÿÿê`•åqŸå Vá7  
 0Gâ Vá;  
P0Gâ Vá²ÿÿ  áşÿÿë0 ãˆ …è0 á­ÿÿê €„å  ã•åşÿÿë „å p…å`…åšÿÿê „åöÿÿê •å  áşÿÿë  áşÿÿë  Zã
  

@ áÿÿê  áşÿÿë  •å0 á Rã      …å‘ÿÿê 0 ãÿÿêåh Ÿåşÿÿë  ã 0 ã0„å$ „è0 á†ÿÿêåH ŸåşÿÿëPP…âôÿÿê  áşÿÿëP`Fâ0 ãH …è0 ázÿÿê  áşÿÿë0 ãH …è0 átÿÿêX   ¨   œ  Ô   0‘åp@-é@ á `“åĞMâ  VáP áp  
  ’å `’å  Váu  
 Sá.  
  “å Pã-  
 Pã)    á áéÿÿë  ”åşÿÿë  á  ãşÿÿëşÿÿë å  •åşÿÿëâ 0 ã0!å â0â å  ã×şÿëPå  Uã  
 åZüÿë å åWüÿëPå å0å  Sã  
  “å Rã9  
 åşÿÿë åşÿÿë  áşÿÿëĞâp€½è  á á½ÿÿë  ”åşÿÿë  á  ãşÿÿëşÿÿë å  •åşÿÿëâ 0 ã0!å â0â å  ã«şÿëPå  Uã  
 å.üÿë å å+üÿëPå å0å  Sã  
  “å RãÓÿÿ “å˜0Ÿå RáÏÿÿ  ”åşÿÿëˆ Ÿåşÿÿë„ Ÿål0’å0ƒâl0‚å  „åÅÿÿê`“åd0Ÿå VáÁÿÿ  ”åşÿÿëP †âğÿÿêƒâ„ÿÿë ”å  áâ  áÿÿëĞâp€½è ‚â{ÿÿë  •å  á ‚â ávÿÿë 0”å  •åÿÿê¨   X       ğ@-éĞMâ 0Pâ å	  
p@Ÿå P ã` álp”å  “ålP„å @â Rã  šlp„å  áĞâğ€½èâ  áõüÿë0åâ  á  “åVÿÿël –å0å  Rã  áîÿÿ
×ûÿë 0 á ååÿÿê    8@-é @PâP á  
 0”å0Câ SãñŸ—  ê˜=  ˜=  „=  d=  d=  ´=  P=  @”å dàoá  á8€½è0”å Uá  
@”å dàoá  á8€½è@”å  Tããÿÿ  á8€½è ”å áşÿÿë  Pã  
  ã8€½è   ã8€½è ”å áşÿÿë  â  8€½è8@-é @ áP á  Tã&  
 0”å0Câ SãñŸ—  ê<>   >  X>  >   >  (>  0”å Sá  
   ã8€½è ”å  eàoá  á8€½è ”å áşÿÿë  Pã8€½@”åáÿÿê0”å Sáîÿÿ80Ÿå ”å  Câ Pá P     8€½è  á8€½è0”å Ÿå `àoá  á8€½è¨   X   ø@-é 0Pâ` áP áJ  
 À“åÀLâ \ãñŸ—  ê,?  |?  Ô?   @   @  ?  ?    UáL  
  @â UáP @â[  
  UáM  
   ãø€½è  á“å  áø@½èşÿÿê “å ã  á@ áşÿÿë ã  á p á ”åşÿÿë$1Ÿå Uá  
P0Câ Uá<  
 Vã0  
  áø€½è “å ã  á@ áşÿÿë ã  á p á ”åşÿÿëÔ0Ÿå Uá+  
P0Câ Uáëÿÿ   á á  ãşÿÿë @ áåÿÿê0“å Vã` `   Sã´ÿÿ  áşÿÿë Vãø€½  ê Vãt Ÿå¸ÿÿ
  Uá  
  @â Uá  
P @â  Uá¸ÿÿ  áø@½èşÿÿê á  ãø@½èşÿÿê  áşÿÿë  áø@½è  ãşÿÿê   á á  ãşÿÿë @ á¼ÿÿêø@½èşÿÿê¨   ø@-é @ á På` á Uã'  
 Uã  şÿÿë p á  áşÿÿë  Wã   á p   
  Pã  
 á  áşÿÿë p á  áşÿÿë á P á[ûÿë  Pã  
  áşÿÿë P ã  áø€½è  áşÿÿë P”å Uã  
@”å 0”å Sãûÿÿ  áø@½èşÿÿê åşÿÿë á P á ”åşÿÿë  Uã  
  Pãçÿÿ
 á   áø@½è  ãşÿÿê P áàÿÿêğA-é @Pâ ĞMâP á` á  
 p”å  á á€ á§ïÿë  Pã  Ú  á  ãd"Ÿå5ÿ/á p”å0Gâ SãñŸ—…  êtB  °B  ìB  C  XC  ˆC  ÌC  øA    á  ã$"Ÿå5ÿ/á”å  á ‘å5ÿ/á  á  ã"Ÿå5ÿ/á”å  á ‘å5ÿ/á  á  ãì!Ÿå5ÿ/á  á ”å}ïÿë  Pã  Ú  á  ãÌ!Ÿå5ÿ/á Ğâğ½è ”å á  á0 ãşÿÿë  á  ã¤!Ÿå5ÿ/á ”å á  á0 ãşÿÿëåÿÿê ”å á  á0 ãşÿÿë  á  ãl!Ÿå5ÿ/á ”å á  á0 ãşÿÿëÖÿÿê  á  ãH!Ÿå5ÿ/á ”å á  á0 ãşÿÿëÌÿÿê”å ‘å  Rã     !Ÿ5ÿ/á!Ÿå  á  ã5ÿ/á”å  á ‘å5ÿ/á»ÿÿê”å ‘å  Rã     Ğ Ÿ5ÿ/á  á  ãÈ Ÿåíÿÿê”å  á ‘å5ÿ/á0”å  Sã¨ÿÿ
  á  ã  Ÿå5ÿ/á ”å á  á0 ãşÿÿëÿÿê”å ‘å  Rã     \ Ÿ5ÿ/á•ÿÿê  á  áXŸåşÿÿë  á  á  ã5ÿ/áŒÿÿê  á á8 Ÿå5ÿ/áÿÿê  @  D  H  `  ,  4       $  (  <  L    ø@-éT4ŸåP“å  Uãø€½@•å ` á  Tã<tŸåY  
80”å ãå  
,Ÿå ã  ã0 áşÿÿë0”å0Câ SãñŸ—ò  êH  ìG  ÔG  ¼G  ĞD  ôŸå ã	  ã0 áşÿÿë<@”å  Tã  !  ê @”å  Tã  
À”å Uáùÿÿ ”å0Bâ SãñŸ—¾  êtG  H  DG  ØF  ÀF  °F  <E  ŒŸå ã  ã0 áşÿÿë ”åxŸå  á 0 ãşÿÿë
  ã áşÿÿë @”å  Tãàÿÿ @•å  Tã  
  áşÿÿë @â à„à 0Ôç
 Sã     ã  Îå @•å @â à„à 0Ôç
 Sãøÿÿ
  á  áŸåşÿÿë0•å  Sã,  
P á@•å  Tã¥ÿÿ@•å  Tãõÿÿ
0”å Sã¥  
 Sã
  ÄŸå ã  ã0 áşÿÿë  á”å²ïÿë
  ã áşÿÿë0”å  Sãâÿÿ
  “å Rã–  
 ã
  ã0 áxŸåşÿÿë 0 ã ”å\Ÿå  áşÿÿë
  ã áşÿÿë0•å  SãÒÿÿ 0•å  SãÏÿÿP•å  Uão  ø€½è,Ÿå ã	  ã¡ÿÿê ã  ã0 áŸåşÿÿë†ÿÿê ã
  ã0 á Ÿåşÿÿë 0 ã ”åØŸå  áşÿÿë0”å  Sã•ÿÿ
  “å Rã$  
0 á ã  ãÄŸåşÿÿë ”åœŸå  á 0 ãşÿÿë‡ÿÿê  ã0 á ãœŸåşÿÿë  á”åeïÿë á
  ãşÿÿë_ÿÿê0 á ã	  ãpŸåşÿÿë  á”åYïÿë0”å  Sãpÿÿ
  “å RãÚÿÿ0“å Sá×ÿÿiÿÿê ã  ã0 á,ŸåşÿÿëCÿÿê ã
  ã0 áŸåşÿÿë=ÿÿê ã  ã0 áŸåşÿÿë7ÿÿê ã
  ã0 áğ Ÿåşÿÿë1ÿÿê  áäŸåşÿÿë1ÿÿê  áØŸå ”åşÿÿëÿÿêÌ Ÿå ã	  ã0 áşÿÿë 0•å  Sã_ÿÿP•å  Uãÿÿ
0•å  Sãöÿÿ
0“å Sãóÿÿíÿÿê ã  ã0 á| Ÿåşÿÿëÿÿêt Ÿå ã	  ãZÿÿê0“å SáeÿÿDÿÿê    ¨   d  ”  ô        4  P  è  Ô  È  H     ¼  ¬     ˆ  |    p  <  ´  (    á 0 ã Ÿåşÿÿê      á 0 ã Ÿåşÿÿê    0å Sã  
  áÿ/á80å  ã  
40å Sã0 öÿÿ
0Ÿå 0“å  Sã0 0   áÿ/á     Pã0Ÿ• ƒ • Ÿ…ÿ/áø  \  < å  Pãÿ/0å Sã    ê0å Sãÿ/  å  Pãùÿÿÿ/áÿ/á< å  Pãÿ/0å Sã    ê0å Sãÿ/  å  Pãùÿÿÿ/áÿ/á å Rã  
40å  Sã  
 Bâ Rã  š   ãÿ/á80å  ã40å  
 Sã  
| Ÿå  ’å  Rã    Sã    áÿ/á Qãíÿÿ
LÀå \áêÿÿ*8 å¢" á Sã      Rã   Qá   ƒ  “ Qá   3ÿ/á  Sãíÿÿèÿÿê Aâoá  áÿ/á    8@-é0å0Câ SãñŸ—l  êøK  øK  (K  ¬K  ¤K   @Ñå- TãP@ÑPşÿÿët0¯æs0¿æƒ0 á  å³ ’á âp ÿæ  Pã8€½0 Tã 0ÕåS  
 á  ês0¿æƒ0 á³ ’á âp ÿæ  Pã8€½0ñåÿ0âs0¯æôÿÿ  ã8€½è @Ñå0 TãE  
Pâşÿÿët@ïæ 0åt@¯æt@¿æ„@ á´ “á
 âp ÿæ  Pã8€½@Õä  Tãôÿÿêÿÿê 0ÑåM0Câ, SãñŸ—.  ê¤K  ¤K  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ¤K  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ¤K  ¤K  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ÈL  ¤K    Sã©ÿÿ
   ã8€½è0Ñåß0âX Sã@Ñ³ÿÿê@-é0Bâ Sã  š  Rã  
   ã€½èşÿÿë€½è  ã€½è0å0Câ Sã  Š0å Sã  
  : Sã  @ Ÿåÿ/á åÿ/á@-é0@Ÿå  ”åşÿÿë ”å$0Ÿå$ Ÿå ‘å  Pã    €½è Ÿåÿ/á      `  d  ø@-é @PâS  
` ã P ã ”å0Aâ SãñŸ—H  êøM   N  HN  dN  ¨N  äN  ÜM   ”åşÿÿë0”å0“å“V%à  áø€½è ”åşÿÿë p á ”åşÿÿë Pá  1–P%à  áø€½è ”åşÿÿë p á ”åşÿÿë Pá  !–P%à  áø€½è@”å†0 á  TãP…à `fâÒÿÿ  ê ”åşÿÿë ”åşÿÿë ”åşÿÿë p á ”åşÿÿë  á  áşÿÿë  PãÔÿÿ†P…à  áø€½è ”åşÿÿë ”åşÿÿë ”åşÿÿë p á ”åşÿÿë  á  áşÿÿë  PãîÿÿÂÿÿê Ÿåşÿÿë  áø€½èP ã¼ÿÿêh  8@-é P á<@å  Tã  3  ê @”å  Tã  
0”å Sãùÿÿ ”åşÿÿë  Pã „åôÿÿ
 ”å  Rã  
 0’å0Câ Sã$  š 0 ã40“åğ ğç<0•å  Sã    ê 0“å  Sã  
 “å Rãùÿÿ0“å  Sã  
 “å  Pã8€½4 å  Rã  
  ê “å  Pã  
4 å  Rã8€½0“å  Sãöÿÿ  á8€½è 0 ã0“åğ ğç0’å4 “å  RãÄÿÿ
õÿÿê8€½è8€½èp@-é ` á<@å  Tãe  
 P ã0”å  Sã  
 ”åşÿÿë  Uá P 1 „å @”å  Tãôÿÿ UãF  
40–å8 –å Sá  
<0–å+‚ã  Sã4P†å8 †å  
 “å 0“å  Rã’‚  Sã÷ÿÿ8 –å  ãp€½@ –å  Pã    
şÿÿë Pã  D0–å  Sá  
8 –å<0–å+‚ã  SãD †å8 †å  
 “å 0“å  Rã’‚  Sã÷ÿÿH –å  Pã  
şÿÿë Pã  
L0–å  Sáp€½<0–å8 –å  Sã+‚ãL †å8 †åp€½ “å 0“å  Rã’‚  Sã÷ÿÿp€½è0–å SãP ´ÿÿd0Ÿå P“å  UãP P ®ÿÿê –å Pã  
 Pã    ÛÿÿêP á¥ÿÿê80–å  ã  
4 –å PãÓÿÿ
0Ÿå  “å  Pã    Íÿÿê    @-é @Pâ    ê @”å  Tã	  
0”å Sãùÿÿ ”åşÿÿë  Pã „åôÿÿ
  á€½è   ã€½è@-é @Pâ    ê @”å  Tã	  
0”å Sãùÿÿ ”åşÿÿë  Pã „åôÿÿ
  á€½è   ã€½è  Pãÿ/8 å€ ãÿ/ 8ŸåğO-é á0à SáLĞMâ @ á  <0å&Âã  Sã8 €å   0 ã0“åğ ğç 0“å  Sãùÿÿ
 “å Rãùÿÿ0“å  Sã    
  “å Bâ Rã   ƒ “•şÿÿë8 ”åp„â0”å —è€À‚ã0Câ` á è8À„å SãñŸ—á  êÄS  ÄS  hS  hS  hS  @7Ÿå“å‘“å  ã<Â€0ƒ80„  á ÿÿë0”å€„å Sã„å  
0Câ SãñŸ—µ  êV  V  ÔS  ÔS  ÔS  ä6Ÿåd€“åh“åçÿÿê40”å  Sã  
80”å¬ƒãã8 „åÁ  < ”å~ÿÿë  Pã  
0å  Sã  
  “å Bâ RãÖ  š80”å  á#2 á Yã 0 0  Sã€„å„å 0”å Sã§  
 SãP ™  < ”åvÿÿë  Pâ•  
  á ”å  ãşÿÿë0šå € á á “å á‘ ë0 á  XáÙà   á}  ª”åPâ Qã  áğŸğŸşÿÿë  áşÿÿë8P”å „å  á á  ãşÿÿë  Pã  
<0”å…ã  Sã8„å  
 “å 0“å  Rã’‚  Sã÷ÿÿ5Ÿå `“å Vá 
8P”å ã á+  
<0”å  Sã  ^  ê 0“å  Sã[  
 “å Rãùÿÿ “å  Pã  
 å  Rã  
ã  
40’å  Sã80’<ƒ80‚8”ã  
8’å<0’åã  Sã8‚å  
 “å 0“å  Rã’‚  Sã÷ÿÿ8”å å  Pãàÿÿ
ãÁ8„ã  
  áşÿÿëLĞâğ½è8P”å4”å  ã0 á  
 Qã=  
  Qã  
<…ãã80„å1  L ”å  Rã<ƒ80„ ãµ  
D ”å  Zã    RãP   Yá 1 Yãm  
8P”å  á%2 á Yã 0 0dÿÿê0šå á “å
 ë0 á Pá	Óà   áxÿÿº8P”åÿÿê 0 ã0“åğ ğç ”å 0 ã „å0„åLĞâğ½è
P ãXÿÿê#2 á Yã 0 0€”åHÿÿê0”åL ”å Qá 1 !Íÿÿê<0”å  Sã    ê 0“å  SãŠ  
 “å Rãùÿÿ0“å  Sã  
  “å Bâ Rã¹  š 0 ã0“åğ ğç “å80”å  Zã¼  
<ƒã
  á80„åşÿÿë8P”å€šå  á%2 á Yã 0 0ÿÿê@”åH ”åşÿÿëğRŸå ã
  ã 0•å ° áàŸåşÿÿë
0 á  á  •åĞŸåşÿÿëÌŸå ”å  •åşÿÿë
0 á  •å@ ”å¬Ÿåşÿÿë  ã 0•å ã Ÿåşÿÿë  áşÿÿëL ”åÿÿê0”å Sãl  
 Sã€„„ûşÿ8P”å0 ã ã€„å  á0„åÿÿ
<0”å  Sã  )  ê 0“å  Sã&  
 “å Rãùÿÿ€“å  Xã	    ê  áÕıÿë40•å€˜å  Sã80• 
  Xã  
P˜å  Uãóÿÿ
 àá80”å¨
â ”å
 àá 
à  Rã8 „å  
40’å  Sã    áşÿÿë  Pã   á „0”å „åÆşÿê 0 ã0“åğ ğç< ”å,şÿë PPâ  
80”å •å<ƒã80„åşÿÿë•å	 PáJ  :L ”å;ÿÿê 0 ã0“åğ ğçLŸåLáŸåÀ°å  \ã  
0œå Sã  
8 œå<0œå+‚ã  Sã8 Œå  
 “å 0“å  Rã’‚  Sã÷ÿÿ Àœå  \ãëÿÿ Páæÿÿè0Ÿå –å8P”å  ƒåÍşÿê8P”å  ã  
4”å Yã%2 0  „şÿ
°0Ÿå 0“å  Sã  %2 á0â  á ã{şÿê0 ã€„å0„åŸşÿê0“å0“å Sá%2 0  0    ámşÿê  á#2 á Yã 0 0gşÿê •åşÿÿëL ”å  áíşÿê       Ä  Ì          €      Œ  À  üÿÿÿĞ›      8@-é P á@ áşÿÿë0•å Sã
@   
 Sã@  •å  á  ã8@½èşÿÿêˆŸåˆ Ÿå@-é0±å  Sã  
 “å Rã8 “€ Â8 ƒ 0“å  Sã÷ÿÿ  QáòÿÿPŸåd ‘åh ‘å0‚â  Pãd0å  
  ’â   0“â0  Rá   
0ÿ/á0Ÿå  “å  Pã€½@½èşÿÿêüÿÿÿĞ›          p@-é @ á`åP á Vá  
şÿÿë  Pãp€½8 ”åã  <0”åA+‚ã  Sã8 „å  
 “å 0“å  RãÀ’ÀŒÀ‚  Sã÷ÿÿ8 ”å0Eâ?oá£2 á¢2à   VáP„å   
şÿÿë  ãp€½è<0”å  Sã    ê 0“å  Sã  
 “å Rãùÿÿ “å  Rã  
 0’å0Câ Sã  š 0 ã@ƒåğ ğç 0 ã0“åğ ğç ’å8’å<0’åã  Sã@‚å8‚å  óÿÿê 0“å  Sãğÿÿ
 “å Rãùÿÿ0“å  SãĞÿÿ
 “å4’å  Qã8’8‚0“å  SãöÿÿÆÿÿê8@-é P á@å Tã  
  : Tã    á  ãşÿÿë 0”â0   Sá  š  á ãşÿÿë0Tâ0   Sá  š  á ãşÿÿë0Tâ0   SáêÿÿŠ@ ã  á8€½è áşÿÿë  á8€½è @ ã  á8€½è@ ã  á8€½è PãğO-é p áĞMâÓ  
!0 ã á2 ã 0åPTŸå°Gâ  á0 áDdŸåPå
° á   ã  á€ ãP áp á@»å  Tã  
 ”å Rã	  
8”å4Ÿå0à  Sã   RãF  
 Bâ RãC  š @”å  Tãïÿÿ [áêÿÿ  åPåşÿÿë Zã
p á  å´Ÿ  
0±å  Sã    êã
  &‚ã8 ƒå 0“å  Sã
  
 “å Rãùÿÿ
8 “å ãòÿÿ  ãòÿÿ 0“å  Sãôÿÿ Váçÿÿ € ã ã@µå  Tã    ê @”å  Tã  
0”å Sãùÿÿ
80”å¨âöÿÿ ãôÿÿ
  áşÿÿë Wã/  
  áşÿÿë @”å  ã  Tãíÿÿ VáäÿÿĞâğ½è WãñŸ—  ê_  ô_  „_  ¤_  6â0„   
€„åã8„å  ã¬ÿÿê 0 ã0„åşÿÿë”2Ÿå ”å Rã“0ÁàÀ? áÁ2càd ã‘à 0càJ  
 Yá€„Å8”å ãéÿÿ
  ã˜ÿÿê0 ã0„åäÿÿê0”å Sã
  ¼ÿÿ< ”å  Zã  5  ê  šå  Zã2  
0šå Sãùÿÿ0šå  Sã°   
°“å  [ã  
 ° ã  ê “å  Rã  
0“å°‹â  Sãøÿÿşÿÿë áşÿÿë šå  Pã  
 å  Rã  
 À ã  ê åÀŒâ  Rã
  
80’å Qá€0Ãã8ƒã‚€‚ „80‚å å  Pãğÿÿ80”å  ã€0Ãã8ƒã80„å‚ÿÿê 0 ã0“åğ ğç Uá „Å³ÿÿÊ  å …à Sá0 ³0„µ­ÿÿê Ÿåşÿÿë  Pã'ÿÿ
 0Ğå  SãP @ "ÿÿ
â
  ãşÿÿëd Pã 0 á  Š å0…ä@„â 0Ğå: Sã  
 Tã  
 0Ğå  Sãîÿÿ Tã"  
 Tã  
 Tãÿÿå	0 á©/‰àd SãÂ  á  å	 bà áÿÿÚşÿÿë"0 ã 0€åp Ÿåşÿÿë  ãşÿÿë Tã €â  
  Pãáÿÿãÿÿê0å åå á0ƒà  åd SãñşÿÚéÿÿê0å å áƒà  å	0 áõÿÿêüÿÿÿĞ›  €  …ëQÔ  ø@-é @ á0åP á0Câ SãñŸ—  êDc  Dc  èb  b  ˆb  ø@½èşÿÿêşÿÿë  Pãø€½< ”åçûÿë @Pâi  
  ã  á  ãşÿÿë0”å ` áp á “å ãşÿë  Vá0×àS  ª   ãø€½èşÿÿë  Pãø€½< ”åÑûÿë @PâS  

  ã  á  ãşÿÿë0”å ` áp á “å
 ãìıÿë  Vá0×àéÿÿº0”å
 ã<  ê 0ÑåM0Câ, SãñŸ—áÿÿê$d  d  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  d  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  $d  d  àb  àb  àb  àb  àb  àb  àb  àb  àb  àb  d   ãø@½èşÿÿê  ãø@½èşÿÿê ãø@½èşÿÿê0”å ã “å§ıÿë Pá0Ñà  £   ³ø€½è  ãø€½è0åğA-é0Câ Sã1  Š 0ÑåM0Câ, SãñŸ—d  ê f  f  f  f  f  f  f  f  f  f  f  f  ôe  f  f  f  f  f  f  f  f  f  f  f  f  f  f  f  f  f  f  f   f  f  f  f  f  f  f  f  f  f  f  f  ôe  P á @ áşÿÿë `Pâ'  
8 ”åã  <0”åA+‚ã  Sã8 „å  
 “å 0“å  RãÀ’ÀŒÀ‚  Sã÷ÿÿ  áşÿÿë0”åp”å Sã€€â  
  Wã  
  á áşÿÿë  Pã	  
  áşÿÿë  Pã%  
 „å áşÿÿë  áşÿÿëşÿÿë  áğ½è ãğA½èşÿÿê ãğA½èşÿÿê  ãğA½èşÿÿê ` ã  áğ½è 0Õå0 Sã  0Õåß0âX SãÙÿÿ
 ˆâşÿÿë 0Pâ  
  á0 ãx  ãÀä0„å ÃåÚÿÿêşÿÿëğA-é P áŒqŸåcúÿë  —åşÿÿë€1Ÿå< •åh@“åa“åÖúÿë0•å €Pâ	  
 Câ Rã8  š˜å  Qã  
  ‘å Bâ Rã9  šL•å Tá  !  1 Rã  
0Câ SãñŸ—B  êg  g  g  g  g    áğ½è  Rã.  
 Rãì Ÿå  ğ½è8 •å  ã    —å ’å  Rã  0Câ SãñŸ—*  êôg  ôg  g  g  g   Sã  
0Câ SãñŸ—  êüg  üg  g  g  g   ˜åşÿÿë ˜å Pá  :@ á0•åÅÿÿê€‘å  XãÂÿÿ
  áşÿÿë`˜å0•å½ÿÿê8 Ÿåğ½è ˜åşÿÿë0•å @ á¶ÿÿê Ÿåğ½è Ÿåğ½è Ÿåğ½è          `  d  <   øO-é `Qâp á P á,  
  áşÿÿë€•å  Xã  á"  
  áşÿÿë°•å
 ã   á  áşÿÿë  Yã @ á  
	  áşÿÿë Šâ  Šà  Tã  á@dşÿÿë  „à
@€à Tá   Š á  áşÿÿë  Vãø½0–å  Sãø½  á	  ádŸåøO½èşÿÿê á  áşÿÿëóÿÿê€å  Xã	  
  áşÿÿë°•å
 ã á   á  áşÿÿë @ áÙÿÿê áøO½èşÿÿê  áŸåşÿÿëÚÿÿêì  è  4 åL å  Rá   “  ƒÿ/áø@-é pPâ` áT  
 ×å  Qã  TQŸåT1ŸåA“ç  Tã  2  ê á0  0   Sã   @”å  Tã*  
 ”å  Pãùÿÿ
 áşÿÿë  Pãõÿÿ  Vã80”åíÿÿ ã0  0   Sãíÿÿ
  áø€½è ×å  Rã  n Qã)  
y Qã-  
m Qã'  
¼0Ÿå¼ÀŸå ‡â  ê á ğå0#à  Rãœàùÿÿœ ŸåœPŸå’‚à¢& á•àPeàÇÿÿê  áşÿÿë p áP  ãşÿÿë @Pâ  
  ãP  ãşÿÿëL0Ÿå8 ”å   ã“ç`€áAƒç‚ „è8`„å „å  áø€½è4 Ÿåø€½è0 Ÿåø€½èP áçÿÿê$ Ÿåø€½èşÿÿë•      Å“ UpHÒõ&  X      ¨   À0Ÿå0@-é P áAßMâ   ãp Ãå  á$ ãşÿÿë @Pâ   
 á eà ŸåşÿÿëşÿÿëÀ„âà á å   ê Îä  ÜåP áÀŒâ‚0 á³0‘á£1 á0â_ Rã0ƒ  Sãóÿÿ á 0Îå  áşÿÿë @ áşÿÿë  áşÿÿë  á  ŸåşÿÿëÙÿÿê á Ÿåşÿÿë ŸåAßâ0€½è    p   @-éXĞMâP ŸåÇÿÿë @ áH Ÿåşÿÿë  Pâ    
0 á4Ÿå4 Ÿåşÿÿë  ã(Ÿå  áşÿÿë0Ÿå  Pã    XĞâ€½èğ  |  „  p  8@-é PPâ6  
 ÀÕå  \ã  Ğ ŸåĞ0ŸåA“ç  Tã  
0”å á  Sâ  
şÿÿë  Pã  80”å ã  
 @”å  Tãòÿÿ  á8€½è Õå  Rã  n \ã  
y \ã  
m \ã  
…â`0Ÿå` Ÿå  êÀ á ñå0#à  RãàùÿÿDŸåD Ÿå‘#à¡& áà bàÒÿÿê0 Ÿå8€½è, Ÿå8€½è( Ÿå8€½è  á8€½è•      Å“ UpHÒõ&  X      ¨   ğO-éĞMâ 0 ã @Pâå0åá 
şÿÿë 0Pâ0å½ 
¨8Ÿå0å0åX ã`ƒâS á   ã€ …ãŒÈŸåƒ± áˆxŸå0å„ˆŸåàá†a á   á @ƒå$ ƒå( ƒå„å@·å  Tã  
À”å \ã  
8 ”åÀLâ€ã	  à ã € \ã8 „å  Š „à å  Pã   
şÿÿë „à €å €å @”å  Tãèÿÿ WáãÿÿøwŸå ` ã @ ã`å åşÿÿë pã  

 Pãâ  á0â.  ïåÿë  PãÓ  º@„â   ãâ  á0âçåÿë  PãË  º  Tã`åÍ  
 tãË  
å  Öå|Ÿå$0‘å# Rã0ƒâ$0å  
şÿÿë  Pã @ XŸå@ şÿÿë  Pã    
şÿÿë   á á  áşÿÿë  PãL  
 0Öå
 Sã SÈÿÿ
Ÿå¦äÿëÅÿÿêÀåÿë  Pã¤  º@„âÂÿÿêşÿÿë€†â  Pã @ äŸå@ şÿÿë  Pã    
şÿÿë   á  á áşÿÿë  Pã¯ÿÿ°Ÿåşÿÿë  Pã	    
şÿÿë €â  †à  ãşÿÿë  Pã£ÿÿ
 0 ã0Àä€Ÿå
  ãşÿÿë  Pãœÿÿ0å`Ÿå  Sãê  şÿÿë  Pã	    
şÿÿë €â  †àşÿÿë Pâ 
8 ™å áï  0™å0Câ Sã‚  Š0å ‚á0ƒâ  ãƒ1‰àƒå8 ‰åz  êğŸåşÿÿë  Pã     
şÿÿë  †à= ãşÿÿë €Pâtÿÿ
@ˆâ  ã  á Èå
 ãşÿÿë  Pã  
 På Àå Rã@0åŸå  Sã  şÿÿë  Pã     
şÿÿë  †àşÿÿë Pâê  
80™å á¦  0™å0Câ SãñŸ—M  ês  Èr  ”q  ”q  s  Lq  şÿÿë  Pã     
şÿÿë  †à  ãşÿÿë0å  á  Sãåÿÿ8 å0 ã á0€åŠ   Øå" Zãp  
  Zã
  
şÿÿë á  å  ê ñå  Zã  
Š0 á³0’á
ãøÿÿ
0 ã0‰å	  á áşÿÿë  Pã0œ   Sã"ÿÿ
 á ™å€Ÿåşãÿëÿÿê0å   ã@ƒà Då`å  áşÿÿë åşÿÿëT4Ÿå  “å  Pã  
şÿÿë   ãĞâğ½è å80™å ã‚!‰à0ƒá‚å80‰å8 ™å  ãÿÿ
<0™å  Sã    ê 0“å  Sã  
 “å Rãùÿÿ@“å  Tã  
 0”å0Câ Sã @ ƒ@”•0åƒ á ‰àšå Qã[  
 QãQ  
0ƒâƒ!„à ’å  Qáƒ1„à  1ƒåàşÿê 0 ã0“åğ ğç0Øåm Sãx  
y SãËÿÿ
n Sã0å°ÿÿ0ƒâ8 ™åƒ1‰à  ã ‚áƒå8 ‰åÇÿÿê0Øåğÿÿê0Øå" SãÂÿÿ@ˆâ€ á 0Øå  Sã  h  ê0øå  Sãe  
" Sã\ Sùÿÿ" Sã  á¥  

  áşÿÿë€ˆâ á   á
  áşÿÿëêÿÿêÌŸå™åãÿëTÿÿêşÿÿë  Pã	    
şÿÿë €â  †à  ãşÿÿë0å  á  Sãÿÿ8 å0 ã á0€åÿÿ
tŸå™åxãÿë8 ™å
ÿÿê€„à ˜å  Pã  0åˆå0ƒâ¨ÿÿê€„à ˜å Pãy  
0å0ƒâ¡ÿÿê  áşÿÿë å80™å‚!‰à0ƒá ‚å80‰åxÿÿêŸå™å[ãÿëšå ˜ååÿÿêä1Ÿå  “å  Pã   
şÿÿë  ãĞâğ½è åd åhå0‚â  Qãd0€åişÿ
  ’â   0“â0  Rácşÿ
1ÿ/áaşÿê å80™å ã‚!‰à0ƒá‚å80‰åSÿÿê0å SãVşÿ
hŸå4ãÿëSşÿê`Ÿåşÿÿë\AŸå  Pã @   áşÿÿë 0Pâ0å1Ÿå0şÿd “åh“å  á0å  Qã0‚âd0€å  
  ’â   0“â0  Rá   
1ÿ/áü0Ÿå 0“å  Sã»ÿÿ
<P“å  Uã  ¼ÿÿê P•å  Uã¹ÿÿ
0•å Sãùÿÿ •åşÿÿë  Pãõÿÿ
0•å  “å Rãñÿÿ0“å “åMıÿë @ áşÿÿë 0Pâ0åéÿÿ
ˆŸå  ã   ãşÿÿë áäâÿëãıÿê 0 ã 0Èååşÿê™å` Ÿåíâÿë8”å0åÁá8„å0ƒâšå ˜åÿÿê    ø  üÿÿÿĞ›  H   |    @        ´  d  `  X      ô  Œ  ğO-éAİMâ,ĞMâ€Ÿåşÿÿë|2Ÿå ã  Pã  şÿÿëlŸåşÿÿë  Pãm  `¢Ÿå`’Ÿå`â å@ºå  Tã!  
0”å Sã  
  áşÿÿë80”å
ã  €”å  Xã  
ãh  
ã0”å0Câj  
 SãñŸ—  êXw  Xw  $w  $w  $w    áşÿÿë”åşÿÿë  Pãh   @”å  TãİÿÿÄ1Ÿå Zá×ÿÿ8  ê ”å 0”å Ráôÿÿ
 pØå€ˆâ  WãV  
şÿÿëdPâÀ á  å1Òç_ Sã/0 0ÌäpØä  Wãøÿÿ°àÙá0Ùå  á`Ÿåi/ ã°àÌá0Ìåşÿÿë pã-  şÿÿë 0å SãB    á/€ ã p ã  ê ‹â €Ëå/ ãşÿÿë á  á °Pâ  ã  
 pËåşÿÿë  Pãòÿÿ
  áğŸåşÿÿë  Pãíÿÿ
0 ã0åÜ Ÿåşÿÿë  Pã   åAİâ,Ğâğ½è  ãAİâ,Ğâğ½è  á Ÿåi/ ãşÿÿë pã  
şÿÿë @”å  TãŠÿÿ«ÿÿêã±ÿÿ @”å  Tã„ÿÿ¥ÿÿê Sã«ÿÿŠ0”å  Sã¨ÿÿ @”å  Tã{ÿÿœÿÿêdPâÀ á°ÿÿê€”åŸÿÿê0 ã0å0Ÿå ZámÿÿÎÿÿêÜ  ˜  Ø  üÿÿÿè  Ğ›  A  í  ì  ğG-é  ãğqŸå @ ád —åh0—åd‡å Sá Rs    á  ãşÿÿë €Pâ€ H  ¼QŸå¼aŸå¼¡Ÿå á@¹å  Tã  
0”å Sã  
  áşÿÿë8 ”å”1Ÿå0à  Sã  ã7  ã  
„>å0ƒâ„>
å @”å  Tãëÿÿ YáæÿÿP‘Ÿå@µå  Tã  
0”å Sã  
8 ”åã  
  ã0Câ  4”å  Qã  „å(Âã  Qã8 „ Sã"  š @”å  Tãêÿÿ Váåÿÿ(0—å  Sã0 ,  
d —åh—å0ƒà  Qãd0‡å  
  ’â   0“â0  Rá   
1ÿ/á  áğ‡½èãÇÿÿ
0”å0Câ Sã  Š ”å0”å Rá¿ÿÿÁÿÿê  á”åşÿÿë  Pã×ÿÿ80”å„.å8Ãã€0Ãã ‚â80„å„.	åÏÿÿê ”å”åşÿÿë  Pã¯ÿÿ
«ÿÿê 0Ÿå„>å 0“â0 Íÿÿê3ÿ/á‰ÿÿê    üÿÿÿĞ›  ø    ğC-éAßMâ p áşÿÿëP€â  áşÿÿë @PâB  
 0 ã 0Äå  á$ ãşÿÿë `Pâ5  
 á gà  áşÿÿëşÿÿëÀ†â á  å   ê Áä  Üåp áÀŒâ‚0 á³0á£1 á0â_ Rã0ƒ  Sãóÿÿ  á 0Áåşÿÿë `Pâ  
şÿÿë  áşÿÿë € áşÿÿë ` á  áşÿÿë  á  áşÿÿë	`†à`†â `†à Uá  : á  áşÿÿëÌÿÿê4€Ÿåïÿÿê  á áşÿÿëP á @ áóÿÿê á  áşÿÿë  áAßâğƒ½èşÿÿë<   ğA-é P áşÿÿëxpŸå `—å  Vã € á  
@ á  ê @”å  Tã  
  á”åşÿÿë  Pã÷ÿÿ  áşÿÿë  áğ½è  ãşÿÿë 0Pâ  
   ã 0‡å ƒå  á ƒå€ƒå `ƒåğ½èşÿÿë    @-é @ áşÿÿë` Ÿå  Pã ‚å  
  ãşÿÿë 0Pâ  
DŸå   ã  ƒå ƒå  á 0åşÿÿë,0Ÿå  ã €å  ƒå€½è á Ÿåşÿÿë  ãşÿÿëşÿÿë            ô  øC-éşÿÿë ` á  ãşÿÿë PPâZ  
hqŸåhAŸå   ã 0—å ”å Sá  …å …å —1“0å –åşÿÿë41Ÿå  Pã ‡å?  
,‘Ÿå ãşÿÿëşÿÿë €™å 0”å P„å@˜å 0…å  Tã  
P˜å  á”åşÿÿë  Pã  
@”å  Tã÷ÿÿ0 ã€†å `‰å0†åøƒ½è —å¼0Ÿå  Rã  
’å “å0 á° Ÿåşÿÿë 0™å@“å  Tã	    ê ”å á BâŒ Ÿåşÿÿë@”å  Tã  
 0™åP”å“å  áşÿÿë  Pãğÿÿ ”å á ‚âP Ÿåşÿÿë  ãşÿÿë “å@ŸåŞÿÿê0“å —å  Sã0 Ÿå“$Ÿ0–åşÿÿë  ãşÿÿëşÿÿë            (	  t	      	  ø@-é P áşÿÿëÀ á €â 0Üå  Sã  
" Sã\ S+  
 Œâ  ê" Sã\ S&  
À á0Òä  Sãøÿÿşÿÿë @Pâ0  
À`Ÿå"0 ã°0Äá  Õå  Rã  
" Rã\ R       
À…â   ã  ê" Sã\ S  
p á0Üä ‚â  Sã÷ÿÿ á  áşÿÿë  áşÿÿëX0Ÿå°0Óá°0„á  áø€½è €âÀŒâÊÿÿêp á á  áşÿÿë  áşÿÿë°0Öá  ã áP‡à°0„á  áşÿÿëÑÿÿêşÿÿë	  ”	  ğA-é@ á‘å ` á Qãp áP á  
 Qãğ½  Qã  
  áşÿÿë À—å á0 á   á  áğA½èÿ/á  áşÿÿëşÿÿë À—å á0 á € á  á  á<ÿ/á  áğA½èşÿÿêğ½èøC-éşÿÿë¸Ÿåşÿÿë\ıÿë  Pã  
  ãøƒ½è Ÿå Ÿåşÿÿë `Pâøÿÿ
”ŸåŒŸåşÿÿë pPâ[  
„ŸåxŸåşÿÿë €Pâ  áP  
pŸåãâÿë  áhŸåàâÿë  á`Ÿåİâÿë\QŸå\‘Ÿå@µå  Tã  
0”å  á Sã  
şÿÿë80”åã  
À”å á  \ã$!Ÿå0 ã  á
  
¦ÿÿë  á á!Ÿå0 ã¡ÿÿë  á áü Ÿå 0 ãœÿÿë @”å  Tãâÿÿ	 Uáİÿÿ  áşÿÿë  áşÿÿë  áşÿÿëÈ ŸåşÿÿëÄ0Ÿå  Pã   Œ Ÿåşÿÿë  Pã±ÿÿ¨ Ÿåşÿÿë¤0Ÿå  Pã   ` Ÿåşÿÿë  Pã§ÿÿˆ Ÿåşÿÿë„0Ÿå  Pã   0 Ÿåşÿÿë  â  øƒ½èşÿÿë  áşÿÿë  ãøƒ½è  áşÿÿë”ÿÿêØ	  ø	  Ä  
  
  L  T  \  üÿÿÿĞ›  H  P  X  (
  ˜	  <
  ¸	  Ü  ˜   0Ğå  SãZ  
ğC-é4ĞMâ  á  ã âşÿÿë  PãT  XŸåX‘Ÿå p á P á ` á@¸å  Tã%  
0”å Sã  
80”åÀâ  à”å  ã ^â0â â  
 Àåşÿÿë  Pã   Uá  á  ºp‡â‡‡à áşÿÿë  Pã)  
 ` á  áşÿÿë…0…à åå!†àP…â ‚éA†ç @”å  TãÙÿÿ	 XáÔÿÿ  Vã@   
  á á  ãˆ0Ÿåşÿÿë …â €à  áşÿÿë @Pâ  
  Uã  „ 0   
–ç0ƒâ‚ä  Ráúÿÿ 0 ã1„ç   ê @ á  áşÿÿë âşÿÿë  á4Ğâğƒ½è   ãÿ/á   ã4Ğâğƒ½èüÿÿÿĞ›      80åğO-é â4ĞMâ p á’  
ã#   ãh   ãV  
 â á-àÿë<@—å  Tã  e  ê @”å  Tãb  
0”å Sãùÿÿ ”å  Rã  	  ê80‘å:ƒã0ƒã80å ’å  Rã  
’å  Qãõÿÿ80—å  á:ƒã0ƒã80‡å‰ ë80—å0Ãã80‡å  Pã 
 ”å  Rã  
0’å  Sã  
  ê0’å  Sã  
8“åÁã8ƒå ’å  Rãöÿÿ  Pã 
80å  ã  
<0å  Sã  -  ê 0“å  Sã*  
 “å Rãùÿÿ “å  Rã  
 0’å0Câ Sã š0`à?oá£2 á˜Ÿå, ‘å  ’å  Rã, å  ‚  ê:ƒã0ƒã80€åO ë8 —å Âã8 ‡å  Pã0`à?oá£2 á 0   Sã   4Ğâğ½è â áÆßÿë<0—å  Sã   0 ã0“åğ ğç 0“å  Sãùÿÿ
 “å Rãùÿÿ0“å  Sã    
  “å Bâ Rã   ƒ “•şÿÿëÔ#Ÿå,0’å 0“å  Sã,0‚å    ƒ  Pã0`à?oá£2 á 0 Õÿÿê  ã € L  ”3Ÿå,P“å  Uã  ˆ3ŸåˆŸå ã 0“å&  ãşÿÿë  á4Ğâğ½è P•å  Uãóÿÿ
0•å SáùÿÿL³ŸåP“Ÿå` á   ã0•å@•å  SãÀ À“  Tã80–å<@–0 ã  
<@–å  Tã	  
 ”å  Zã  
  ê0”å  Sã7   @”å  Tãùÿÿ Xá5  
0•å  Sã=  
–åà”å 0”åàNâ  Qã	  ^ã “å$0”å´BŸ•Àœåá„¬âŸ…ğê•  \ã	À   ›å@èÀå”ŸåşÿÿëP•å  Uã9  
`•åÉÿÿê â áPßÿë<0—å  Sã  ˆÿÿê 0“å  Sã…ÿÿ
 “å Rãùÿÿ€“å  Xã¢ÿÿ
 0˜å0Câ Sã € ƒ€˜•œÿÿê Xá  áÉÿÿ 0”å  ›åŸå “å$0”åÀåşÿÿë0•åÀå  SãÁÿÿ0•å  Sã  
à–åœå 0”å  ^ã	à   Qã	  “å  ›å$0”åå àå´ŸåşÿÿëP•å  UãÅÿÿ€1Ÿå, “å0â Ráp1Ÿå~ÿÿ å  Rã, ƒåP‚yÿÿê  áBÿÿê80–å ã1  
à–åœå$0šå  ^ã	à   Qã	  “å  ›å(0šåå àå4Ÿåşÿÿë£ÿÿê ”å  á  Rã  
0’å  Sãôşÿ 0 ã  áÿÿêP”å  Uãùÿÿ
0•å  Sãöÿÿ
  á  êP•å  Uãêÿÿ
 •å  Pãçÿÿ
]  ë 0Pâöÿÿ
  áÔşÿê0’å Wá÷şÿ  á0 ã÷şÿê  ã  
à–åœå$0šå  ^ã	à   Qã	  “å  ›å(0šåå àåhŸåşÿÿëoÿÿêà–åœå 0”å  ^ã	à   Qã	  “å  ›å$0”åå àå0Ÿåşÿÿë`ÿÿê        D    ø  P
  ˆ
  X
  °
  Ğ
  ø
     @-é @Pâ!  
 ”å0Aâ SãñŸ—  ê@‹  @‹  0‹  ‹  ‹  X‹  ‹   ”å@½èşÿÿê ”åşÿÿë  Pã€½ ”å@½èşÿÿê@”å  Tãæÿÿ  ê ”åàÿÿë  Pã€½@”åöÿÿê Ÿåşÿÿë   ã€½èl  p@-é P áĞMâ  á âŞÿëH •åÏÿÿë `Pâ	  
œ Ÿå  á,0’å 0“å  Sã,0‚å    ƒĞâp€½è<@•å  Tã  ñÿÿê @”å  Tãîÿÿ
0”å0Câ Sãøÿÿš ”å@åµÿÿë  Pã  0”å Sãğÿÿ80•å ãíÿÿ0”å  á0å©ÿÿë  Pã æÿÿ
 ` áÖÿÿê    8@-é P á(  ã@ áşÿÿë  Pã  
|Ÿå| Ÿå 0 á À ãÀƒä ‘å0ƒâ ’å TáÀƒäÀƒäÀƒäÀƒäÀƒäÀƒä Àƒå0 €é €å$ €å
  
< ”å  Rã< „    ê  á 0’å  Sãûÿÿ  ‚å8€½è8€½èşÿÿë        8@-é 0 áP á  ã áşÿÿë ã @ á  áşÿÿëşÿÿë „å8€½èD0Ÿåà-åcßMâ  ã  á€.Cåşÿÿë  ã( ŸåşÿÿëÀ ã‚â8 åÀ€å*‚ã8 €åáÿÿëcßâğäø  „  0Ÿå€>Så  Sãÿ/åÿÿêø  ğG-é` á4qŸå á  á|Nå € á”åşÿÿë P á
  á…å@…å÷æÿë  Vã …å  
şÿÿë 0Öåƒ0 á  å  á³0’á
ã'  Ü Ÿå0”å Tá  S  
  áÈŸå
İÿë|Nå Xã  
P„å`…å  áğ‡½è@”å  Tã  
0”å  Sâùÿÿ
şÿÿë0•å  Sã á À á  á  ã0   
  \ã  
şÿÿë 0 á@”å0…å  Tãëÿÿ|Nåâÿÿê  á@ŸåçÜÿë 0Öå  ™åƒ0 á³0’á
ã  
0öåƒ0 á³0’á
ãúÿÿ|NåÇÿÿêø      °  ”   å  Pãÿ/ 0å0Câ Sã •   ƒÿ/á @â Pã0Ÿ• ƒğ
• Ÿ…ÿ/áø  P
   -é$ å@-éĞMâD@Ÿå(0åÀâ ’å  ”å4ŸåÀåşÿÿëå å  ”åşÿÿë ”å
  ãşÿÿëĞâ@½èĞâÿ/á    $   0Ÿå Ÿå Ÿåƒâ@‚å|> å<0‚åÿ/á        ø  ÿ/á Ÿå0Ÿå|å €â@ ƒå< ƒåÿ/áø      0Ÿå< “å@ ƒå ’å< ƒåÿ/á    8@-é@0Ÿå|^å@•ådæÿë  Tã  
  Pã  
 á   á  ãşÿÿë @ á@…å8€½è @ á@…å8€½èø  t0Ÿå|å ‘å0’å  Sáÿ/  Sã ‚ÿ/ ’åPÀŸå  Rã   Sãà-åĞMâ<ÀŸ•<0Ÿ…1Œ ;• Pã(ÀŸ•( Ÿ… Œ •  å  áŸåşÿÿëĞâğäø    ø  \  Ä  0 á   ã(ÿÿê<0Ÿå@-é|Nå”å  Qã  
  Pã  
   á  ãşÿÿë  á„å€½è  á„å€½èø  0 á  á  ãÿÿêp@-é P á  á@ áşÿÿë0 á  ã   á  áp@½èÿÿêø@-é @ á0  ãşÿÿë ÀPâ"  
ˆàŸåˆ Ÿå0 á   ã@å|pŸå ƒä  å0ƒâ<`åPå Tá ƒä@Àå ƒä|Îå ƒä ƒä ƒä ƒä ƒä ƒä ƒä  ƒå@Œå`Œå(PŒå$ Œå Àå  
 á	  ãø@½èşÿÿêø€½èşÿÿë        ø   @âğA-é Pã ñŸ—  ê8“  “  \’  @’  ğ½è¬1Ÿå|>å “å80’å6ƒã80‚åğ½è1Ÿå@ á|nåP–å8 •å<0•å*‚ã  Sã8 …å	  
 “å Rã  7  êÀ“å \ã4  
 0“å  Sãùÿÿ á  ãşÿÿë ã4qŸå € á  áşÿÿëşÿÿë —å ˆå  ãşÿÿë 0 á  áPƒå 0‡åşÿÿë Pâ8  
  áğA½èvşÿêì Ÿå 0’å  Sã   
Ô Ÿå|.å ’å Sáğ½Ì ŸåğA½è×ÛÿêÄ@Ÿå°PŸå 0”å  Sã  
 “å|>å¬ Ÿå0“å“åÌÛÿë|>å0“å 0„åğ½è “å  Rã  
 0’å0Câ Sã  š 0 ã0“åğ ğçP0Ÿå|>å0“å 0‚åğ½è0’å á@“å  áşÿÿë  Pãğ½  á  á0ŸåğA½èşÿÿê  á  á ŸåğA½èşÿÿêø          D      ü  h    ğO-éMŞMâœoŸåĞMâ 0–å  Sã! ŒŸå 0 ã€ á0å 0å|?Ÿå @â àã° á^â  ƒåÈ0 ãPå0å0å°€Äá1Câƒ0 á ‹à Tá6 :pkà</ŸååÇp á Qáp‡âÂ Š0ƒâ ‚â Sá0 !0åƒ á ‰à€  á €âşÿÿë  Pâ¶ 
‡@ á  á áşÿÿë0‰â0Ãã0Šàq á  á  áåşÿÿë  â [á 0 á  
 å  áşÿÿë0å  –å@DâpGâ  Rã@ŠàPƒàû  Iâ	Šà	 Tá® *
° á0å Xã— 
l.Ÿåˆ0 á³p’áw¿æZ yã\®Ÿ  
H>Ÿå  “å pã{ 
  Pã Ú@>Ÿå PáÀ Ã0>ŸÕ,®ŸÅ  ƒĞ  Ñ 0–åLÉPÕ  Sã‡ >Ÿå‰à Yá  Š.Ÿå‰0 áó’á Yáâ 
0Šà˜“Så  Yãä  
	0Šà  –åØrSå  Rã0gâ1•ç0åƒ 
0Iâk SãñŸ—©  ê,Ÿ  ø¦  Ü¦  Ğ¦  È˜  È˜  È˜  È˜  È˜  È˜  È˜  È˜  È˜  È˜  È˜  È˜  È˜  È˜  À¦  ´¦  `¦    ¦  t  È˜  È˜  È˜  È˜  È˜  È˜  È˜  x          °Ÿ  §  È˜  È˜  Ğ—  Ô  h  à¢  ü  Ø¤  È˜  È˜  È˜  È˜  È˜  È˜  È˜     ,¢  t£  l¢  È˜  È˜  l¡  PŸ  È˜  È˜  È˜  È˜  È˜  8Ÿ  Ä  ü  Ì¡  È˜  È˜  È˜  È˜  È˜  ¡  À   È˜  ”¥  €¥  È˜  È˜  È˜  È˜  D¥  È˜  È˜  È˜  8¥  È˜  \£  È˜  È˜  È  È  È  È˜  È˜  Ô  h  ü¥  `   Ÿ  È  §  È¢  D£  à¥  P¡  Ô  Àå  áÀåşÿÿëÀå0@â Sã   á å.  Šà@â ^ã 0 á0Ü…Ğ+Ÿ…  0‚€  ÜåH?Ó…¼+Ÿ•0 “0€Üç €‚à ‚àHØåH/Òå0à ƒàH Rã  Ê‚Šà°/å  Rã  ºDŸå0à Ñç  Rá   Œâ  áƒâÀå0åşÿÿëÀå  Pã   å0å0Óç  Sã  ¨?å ãÛ  á$Ÿå˜Úÿë åşÿÿë 0–åìŠŸå  Sã 	 Šàwp¿æØÚåQEà‡@Dà$IâğŸå‰ áğ Ôáù0‘áĞ
ŸåÀå0ƒà  SáÀ…åP…â€  šÈ:Ÿåù€“á@„âÎşÿê0å˜;Ÿå å°Ÿå  “åşÿÿë Iâ Šà Tá0å« *
° á0å 0–å  Sãùşÿ
\;Ÿå|Ÿå  á  “åşÿÿëóşÿê<:Ÿå 0“å sã   
8*Ÿå Sá ƒ(*Ÿ• ‚LR• å  Rãâ  
 å Rãa  
 ášŸå zŸå0 á  êì)Ÿåˆ0 á³0’ás0¿æZ sã€Šà  áü	Ÿåƒâ  
	 QáÀ á  ŠÄ9Ÿåü“á´9Ÿå Qã  
 Tá  
ØåXÛÿë 0–åPEâ  Sãò€táäÿÿ
  á á²Ùÿëàÿÿêü—á  QãïÿÿÚ”	Ÿå À–å€ á  å  \ã …åP…âO 0 ã0å¤ÿÿê€ ã,9Ÿå 0“å sã  
,)Ÿå Sá ƒ"  šH	Ÿå@)Ÿå5Ûÿë 0–å  Sã   [áü¨Ÿ  
ò0Tà  á 	Ÿå0ŠàPEâÓå(Ûÿë [áöÿÿ 0â [á  
  áşÿÿë  áMŞâĞâğ½è´Ÿåƒ0 áó á PáyÿÿsAâó€‘áxÿÿêŒ¨Ÿå0ŠàLSåØÿÿê  Sã˜  Ú (Ÿå¨ŸåÛÿë\(Ÿå0àã á 0‚å”ÿÿê 0–å  Sã–  şÿÿë88Ÿå  Pã  ƒå}şÿÊ À–å à ã 8Ÿå \á àƒå ¨Ÿşÿ
9ŸåPŸå ã  ã 0“åàå ¨ŸåşÿÿëÀåwşÿêì8Ÿå,(ŸåÜŸå  “åÀåşÿÿëÔ8ŸåÀå  “å áÓÚÿëÀ8Ÿå
  ã “åşÿÿëÀåfşÿê¨8Ÿåì‡Ÿå‰À á  “åäŸå¼0˜á IâÀåşÿÿë  Wãpşÿ
Àå&>ˆâÀƒà 0 ã¸!\á@å@ á€ˆàï€ˆâX8Ÿå@„â  á  “å˜Ÿåşÿÿë@8ŸåÑøá  “å¯Úÿë08Ÿå
  ã “åşÿÿë Wáïÿÿ@åUşÿê8Ÿå ã  ã 0“åTŸåşÿÿëÖıÿê  á áÙÿëyÿÿêä7Ÿå	Šà4'Ÿå  “åÌŸåşÿÿëÌ7ŸåØÙåwp¿æ  “å	 áÚÿë´7Ÿå
  ãQEà “åşÿÿë 0˜å‡@Dà  Sãìşÿ
  á áöØÿëèşÿêt6Ÿåp&ŸåÔŸå 0“å0ƒâ 0‚åÙØÿë áÿÿê’/‚âó€’á  Xã hÒşÿÚ0å  Sã0C0 0–å  Sãu \6Ÿå Ÿå àã 0“å  å0…åP…âÙşÿêÿÿ€ ã^ÿÿê0å0å¼şÿê 0 ã0å¹şÿêè6Ÿå ã  ã 0“å8Ÿåşÿÿëaÿÿêˆ6Ÿå°†Ÿå|>å  á0å0ƒâ@0ˆå< ˆå©şÿê0å  ãå   ãÓûÿëx6Ÿå`1“å ã şÿ
l†ŸåäŸå0˜å ˜å  Sã“\Ÿşÿÿë—şÿê 0•å0å”şÿê6Ÿå|>å0“å  Sãj 
  ã ƒå6Ÿå`1“å ã‰şÿ
†ŸåŒŸå0˜å ˜å  Sã“ Ÿşÿÿë€şÿê   ãşÿÿë   ã0 á  ãå¨ûÿëÌ5Ÿå`1“å ãuşÿ
À…Ÿå@Ÿå0˜å ˜å  Sã“°Ÿşÿÿëlşÿê  ãå  •åşÿÿë åfşÿêŸåØØÿëcşÿê   ã0 áå  ãûÿë]şÿê •åè$Ÿåè4Ÿå ‘è²Úÿë  PãVşÿ
D…Ÿå<%Ÿå<0˜å`!’å@0ˆå0“å ã<0ˆåMşÿ
0˜å ˜å  Sã¨Ÿå“ŸşÿÿëEşÿê  ã åşÿÿë å  á  ãşÿÿëà4Ÿå`1“å ã:şÿ
Ô„ŸåhŸå0˜å ˜å  Sã“ÄŸşÿÿë1şÿê é  ã  ã\ûÿë0å “å  Pã   
şÿÿëˆ4Ÿå`1“å ã$şÿ
|„ŸåŸå0˜å ˜å  Sã“0åhŸ0“åşÿÿëşÿê  ãå  •åşÿÿë åşÿê0å “åşÿÿë(4Ÿå`1“å ãşÿ
„Ÿå¸Ÿå0˜å ˜å  Sã“0åŸ0“åşÿÿëşÿê   ãşÿÿë   ã0 á  ãå)ûÿëĞ3Ÿå`1“å ãöıÿ
ÄƒŸådŸå0˜å ˜å  Sã“´Ÿşÿÿëíıÿêœ3Ÿå`1“å ã  
ƒŸå4Ÿå0˜å ˜å  Sã“€Ÿ0åşÿÿë åşÿÿëİıÿê  •å ãşÿÿë å  •åşÿÿëÖıÿê@3Ÿå@ƒŸå`1“å ã  
0˜åØŸå  Sã ˜å“$Ÿşÿÿë   ãşÿÿë åşÿÿëØ2Ÿå|>å  á0å0ƒâ< ˆå@0ˆå¾ıÿê •å"ŸåA? ã ‘èÚÿë  Pã·ıÿ
È‚ŸåÀ"Ÿå<0˜å`!’å@0ˆå0“å ã<0ˆå®ıÿ
0˜å ˜å  SãLŸå“˜Ÿşÿÿë¦ıÿê0å “å0@â Sãÿÿš 0–åwp¿æ  SãQEà‡@Dàn ğ€Ôál!Ÿåˆ0 á³’á×ıÿê0å“å  Qãğÿÿ åşÿÿë å  á  ãşÿÿë2Ÿå`1“å ãˆıÿ
‚ŸåÀŸå0˜å ˜å  Sã“üŸşÿÿëıÿê  ãå  •åşÿÿë åyıÿê ã åşÿÿë80å:ƒã80€åşÿÿë  ã0 á  á  ãœúÿëœ1Ÿå`1“å ãiıÿ
ŸåHŸå0˜å ˜å  Sã“€Ÿşÿÿë`ıÿê  ãå  •åşÿÿë åZıÿêå   ã 0•å  ã„úÿëTıÿê!Ÿå41Ÿå|.å`1“å ’å ã80’å<ƒã80‚åJıÿ
ŸåĞ Ÿå0˜å ˜å  Sã“ŸşÿÿëAıÿê            '  ,  ø  "  Ğ      ¼  H!  ¬!  Ä  ä    Ì      ğ    ¸    $  ˜  @  h  ´     ¨  ø  x    @  t      0  œ  ˆ  h  p  \  $    L    à        ğ  Œ  ø  €     ø  è  Ô  À  d  ¨            ¬      Ü  Ğ   4      8   •åh åh0å ‘èPÙÿë  Pãôüÿ
D€åL å<0˜å`!’å@0ˆå0“å ã<0ˆåëüÿ
0˜å ˜å  Sã¨ å“tşÿÿëãüÿê  •åşÿÿëàüÿê åşÿÿë 0å`1“å ãÚüÿ
¬€åà å0˜å ˜å  Sã“¼şÿÿëÑüÿêü0å  •å|>å  ƒåÌüÿêè0åè€å`1“å ã  
0˜å$å  Sã ˜å“şÿÿëbÙÿë 0 ã  ã\0ˆåX0ˆåP ˆå¹üÿê  •å  ãşÿÿë å  •åşÿÿë²üÿê  •åşÿÿë å®üÿê  ã åşÿÿë80å<ƒã80€åşÿÿë|1å`1“å ã£üÿ
ˆå°å0˜å ˜å  Sã“˜0åşÿÿë™üÿê  ã åşÿÿë80å<ƒã80€åşÿÿëĞ1å`1“å ãüÿ
Üå å0˜å ˜å  Sã“ì0åşÿÿë„üÿê åöÖÿëüÿê(ååòÖÿë}üÿê4åïÖÿëzüÿê0å@å@å 0“åàèÖÿësüÿêPååäÖÿëoüÿê  ã •åşÿÿë åjüÿêå å  ãşÿÿë0å  ã   á  ãùÿë”2å`1“å ã]üÿ
 ‚å å0˜å ˜å  Sã“°şÿÿëTüÿê¬2å´"å¼å  “åşÿÿëÀ2å	 á  “åï×ÿëĞ2å
  ã “åşÿÿë{ıÿêğåEÖÿë€ ãµüÿê € ã³üÿê0å 3åå#å  “åşÿÿë0å#å0ƒà  ’åÓåØ×ÿë,3å
  ã “åşÿÿëüÿê
° á€ ãŸüÿê  á á?ÖÿëŒşÿê¬å •åşÿÿë"üÿêhå¹Öÿë“ıÿêğO-é p áPåĞMâ  Uã`åÌ 
  Vã  
80–å ãØ  0—å  Sã€“€— •åşÿÿë @ á  áşÿÿë  Pã    
  Tã  
  á  á  ãşÿÿëşÿÿë0•å  Sã<@“@•  á …å  ê0”å Sáã  
 @”å  Tãùÿÿ P•å  Uãàÿÿ@—å  Tã`  
  áşÿÿë @”å  TãúÿÿP—å  UãX  
$ˆŸå  VãI  
80–å ãF  
0•å  SãC  
8 “å  ã@  •å  ‚ã  Qã8 ƒå|^åâ 
<@“å  Tã    ê @”å  Tã  
0”å Sãà  
0”å Sáöÿÿ
 ”å Rãóÿÿ0“å0“å Sáïÿÿ
  áŒŸåÖÿë @”å  Tãìÿÿ@–å Tã 
  ã á   ãşÿÿë<0–å  Sã  Ö  ê 0“å  SãÓ  
 “å Rãùÿÿ“å  Qã@ƒ    ê á ‘å  Rãûÿÿ@â  ã  ãşÿÿë  „å0•å0€å•å  Qã  
0•å  Sã­  
0“å  Sãª  
 P•å  Uã§ÿÿ  VãM  
80–å	ã.   –å  Rã˜ 
 ã  
0—å  Sã  
<@–å  Tã    ê Sã¯  
 Sã¢  
 @”å  Tã  
0”å Sãõÿÿ0”å  Sã  
  “å Bâ Rã 0 ƒ0“• –å Bâ RãÄ  Š “å Rãêÿÿš  á “åŸå»Õÿë @”å  Tãæÿÿ80–å9ƒã80†åã  0—å  Sã  
@“åäŸåHP–åşÿÿë  Tãj 
  Pãd 
 á   á  ãşÿÿë @ á  Uã_ 
  Tã  
 á  á  ãşÿÿë P áHP†åĞâğ½è0–åtEŸå  Sã  0 á|å  ê 0“å  Sã  
 “å  Rãùÿÿ
 ’å  Pãöÿÿ
şÿÿëP—å  Uã    áşÿÿëP—å  Uã € áÿÿ’ÿÿê –åşÿÿë P•å  Uãóÿÿ
0•å|^å  Sãøÿÿ
0“å  Sãõÿÿòÿÿê ”åşÿÿë å	  áşÿÿë å Pâ   
  Rã  
  ãşÿÿë  á  áåşÿÿë •å  Rã 0 á å  
 ’å Rã  
şÿÿë 0 á å ”å0„å Rãûşÿ ”å  Rã  
 0’å0Câ Sãz  š 0 ãH0“åğ ğç  á<ŸåBÕÿëÿÿê0 á   ê0 á  “åpƒå  Rãúÿÿ  •å  ƒå …å …åP áòşÿê 0 ã0“åğ ğç0–å0Câ Sã  š ”å 0’å SãTÿÿ0–å0Câ  ê0–å0Câ Sã  š  á´ŸåÕÿëP”å  á0•å “éÇçÿë  Pã  
0•å  á “éÁçÿë  Pã=ÿÿ  áxŸåÕÿë9ÿÿê ”å ’å Qã\   Sã0’å2ÿÿŠ  á “é±çÿë  Pã-ÿÿ  á<Ÿå –åşÔÿë(ÿÿê  á,Ÿå –åùÔÿë#ÿÿê0•å0“å Sãàşÿ
#Ÿå  ã áşÿÿë •å Pâ  
  Rã	    
  á	 áşÿÿë   á0•å …å<@“å  Tã  Ìşÿê @”å  TãÉşÿ
0”å Sáùÿÿ	  áşÿÿë ”å  Pã    
  Rã  
  á  ãşÿÿë „åìÿÿê°’å •åH ›åşÿÿë å åşÿÿë0å  Sã   á„  
  Pã  
 á  ãşÿÿë 0 á  Zã
  
  Sã  

 á  á  ãşÿÿë   áH ‹å]şÿê  Zãöÿÿ  áùÿÿê  áôŸå –å©Ôÿëzÿÿê  Vãÿÿ
0å ã  Sã   “Ì!Ÿåşÿÿëşÿÿëşÿÿë @—å  Tã  á/  
¤¡Ÿå € ã0”å á  SãP“P”  áPåşÿÿë  Pã  
  á áşÿÿë  Pã1  h!Ÿå ã  áşÿÿë åşÿÿëşÿÿë å	  áşÿÿëâ å âşÿÿë åşÿÿë å  Pã  
 0å Sã  
şÿÿë  Xã  
 —å  ˜å 0 ã‡å  ‡å 0ˆå@–å —å  Qã   
  Rã  
  ãşÿÿë  áP—å@†å  Uãşÿrşÿê0å
 Sáäÿÿşÿÿë  áşÿÿë 0”åp„å  Sã€ áßÿÿ
@ áµÿÿê  á|Ÿåşÿÿë0•åşÿê  álŸåşÿÿë80–åaşÿê  Uã¡şÿP á¤şÿê @ á™şÿê 0 á~ÿÿê  á<ŸåşÿÿëZşÿêø  p  l     D  À  ğ    ,  ¨   Ü  X   $  œ  À  ğG-éşÿÿëHQŸå€>Uå  Sã   Úöÿë8AŸå8Ÿå   ã0 áÀ„â,Ÿå  ã@Àˆå|Nå<@ˆåêöÿëQŸå „åŸåşÿÿë  Pã  1Ÿ  ƒşÿÿë 0•å  Sã5  ô`Ÿå 0–å  Sã-  
”å  ã   ã™åşÿÿë@”åĞ`ŸåĞpŸå ‰å ”åşÿÿë „åœ Ÿåşÿÿë@¶å  Tã  
0”å Sã  
  áşÿÿë  Pã 0•0ƒ 0… @”å  Tãóÿÿ Váîÿÿ 0•å  Sã  h0˜åd ˜å “â   Pã    Qã  ãd ˆåğ‡½ğG½èÿ/á8 Ÿåşÿÿë  †åÍÿÿê  ãşÿÿëø                           üÿÿÿĞ›  `   å  â  ÿ/á8@-é0å  Sã(  
 @ á å  Pã  
şÿÿë  Pã!  
P”å  Uã  
  áşÿÿë0”å0“å  Sã  0”å0“å  Sã  
@”å  Tã    ê @”å  Tã  
  áşÿÿë  Pãøÿÿ
80•å8ƒã80…å8€½è@”å ”åşÿÿë  Pã „å     ã8€½è  ã8€½èø@-é¼Ÿåşÿÿë `PâP  
şÿÿë¬1Ÿå@“å  Tã  C  ê0”å  Sã4  
@ áP”å  Uã@  
80•å ãõÿÿ  áşÿÿë80•åãğÿÿ
4•åL •å<Ãã Qá80…åêÿÿš  áşÿÿë p á  áşÿÿë  á  áşÿÿë  Pãàÿÿ
80•å  ã>  
<0•å  Sã  &  ê 0“å  Sã#  
 “å Rãùÿÿ “å  Rã  
 0’å0Câ Sã  š   ãşÿÿë 0 ã80“åğ ğç 0”å  SãÇÿÿ@”å  Tã  
 0”å  SãÁÿÿ@”å  Tãùÿÿ  áşÿÿë   ãø€½è  áşÿÿë´ÿÿê  ãø€½è 0 ã0“åğ ğçp’å  áşÿÿë80—å#4 á0#â  Uá      Pã  
0•å Sã  0•å Sãÿÿ
 á  á Ÿå 0 ãªòÿë˜ÿÿêÄ      H  @-é@å  Tã    ê @”å  Tã  
  áşÿÿë  Pãøÿÿ
   ã€½è  ã€½èğO-éÚMâĞMâ 0 ã PPâ0Íå  
 0Õå  Sã  HŸåşÿÿëjâ`†â PPâ8SŸpâ4Ÿå  á0 á  áşÿÿë$Ÿåşÿÿë  Pã  
 0Ğå  Sã  :â0ƒâ0åşÿÿëüŸå  á 0 á
â €âşÿÿë
â €âàŸåşÿÿë € á  Xãj  
Ğ’Ÿå  áÌŸå†Õÿëd0™å  Sãš  
¼2Ÿå@“å  Tã  $  ê0”å  Sã  
@ á ”å  ZãK  
8Àšå°âõÿÿ
  áşÿÿë80šåãğÿÿ
<Ãã80Šå
 á0 á  á\"ŸåFòÿë0”å  Sãéÿÿ 0”å  Sãæÿÿ@”å  Tã  
 0”å  Sãàÿÿ@”å  Tãùÿÿ  áşÿÿë0å0Så  Sã  
  áşÿÿë á  ‡àşÿÿëğ!Ÿå áÀÒå 0 á  ’åÀÃå  ƒå  áşÿÿë0å á Câşÿÿë  Pã    ã´Ÿå   ãşÿÿë áaÒÿëd0™åh ™å @ ã Rá S     d@‰å  
2ÿ/á  áÚâĞâğ½è  áşÿÿë  Pã¨ÿÿ
0”å  SãE  
 “å  áHŸåşÿÿë ÿÿê  ãÚâĞâğ½è:â0ƒâ  á0å  á 0 ãøŸå0Båşÿÿë € áƒÿÿê:â0ƒâ`Câ  á  ã áşÿÿë  Pã  :â 0ƒâ 0“å:â	Sã  
  á/ ãşÿÿë €PâSÿÿ
0eà@ƒâpâ á  á  áşÿÿëØå0â   ã0ƒà Qá CåPˆEÿÿD Ÿåşÿÿë PPâ<PŸ@ÿÿêşÿÿëbÿÿêpâ á  áşÿÿëL0Ÿå°0Óá°0Àáğÿÿê ”å  Rã ’¶ÿÿê`  X  0  8  P  Ä      L      H  ˆ  l  `  ,  ğO-é<ĞMâ 0Qâ0å ` á å  
@“åP á  Tã  
  áşÿÿë  á,Ÿå 0 á  áşÿÿë0•å  á SãŸå%Ÿ•%Ÿ…1‚ +•şÿÿë0å0“å0Câ Sã( š0å<“å  Yã–  
0™å  Sãh  
ØŸå  ã   ãşÿÿë™å  ã @ á   ãşÿÿë á   á  áşÿÿë0™åp“å 4Ÿå WáV  
 P ã€â@ á  áşÿÿëpˆä|4Ÿå@„â  Uã       PãP p—å Wá‰  
 Tãğÿÿ0å  Uã  S0  0   á‡    á0Ÿå  ãşÿÿë@ ã  á  áşÿÿë å€„â0âp ãƒàå  ê“å  ã   ãşÿÿëìŸå  á 0 ã  å  áşÿÿë ›å  Pã  
å  Yã‘  
şÿÿë	  á¸Ÿå 0 á  áşÿÿë@Dâ  á¤Ÿåşÿÿë tãp‡â  
°8å Uá 0 0
  Sã  
 –åşÿÿë0å ƒå0›å  SãÕÿÿ›å  Qã‘Òÿÿêå ™å  Yãÿÿ0å<@“å  Tã#  
0”åP á	 Sã  €  ê0•å	 Sã}  
 P•å  Uãùÿÿ   ã á  ê @”å  Tã  
0”å Sãùÿÿ  Qã  á[  ÔŸåşÿÿë ”åÌŸå  á 0 ãşÿÿë @”å ã  Tãîÿÿ  Qã]  @åH0”å  Sã  
  ã”Ÿå   ãşÿÿë  á  áşÿÿëH ”åtŸå  á 0 ãşÿÿë  áXŸåşÿÿë  á\Ÿå<ĞâğO½èşÿÿê0å  Uã  S ° ° °  
  ãşÿÿë 0Pâ0åz  
 ™åşÿÿë  Pã)  
 å0™å0‚å å 0’å Rá(  
0åå0“å  á0“å0ƒâ0å0åå0å ƒè 0‚å¤Ÿå  ã   ãşÿÿë@Dâ  á  áşÿÿë0å 0“â0   áWÿÿê	  áŒŸå  ãşÿÿë  á ›åfÿÿêxŸåşÿÿë¢ÿÿê0å åPƒå 0’å RáÖÿÿ å 0 ã0‚å0å “å×ÿÿê  á Ÿåşÿÿëÿÿê0Ÿå  ã   ãşÿÿë0•å$ “å(0“å ’å  á  áşÿÿë0•å  Sã  
  “å Rã  
  ãìŸå   ãşÿÿë  á  áşÿÿë 0 ã •å´Ÿå  áşÿÿë  áœŸåşÿÿë0å<@“å  Tã`ÿÿxÿÿê “å 0Ÿå Ráçÿÿ0å<@“åõÿÿê0å< “åÙäÿë @PâÑşÿ
  átŸåşÿÿë ”åHŸå  á 0 ãşÿÿë  á,ŸåşÿÿëÅşÿêşÿÿë  ¤  ø  \  ¼      È  Ø  ä  ø  ğ      ü      4    $  ¨   °  0å  Sã  
 “åÿ/á å  Pã ÿ/á  Ÿåÿ/á    , Ÿå Páÿ/0å  Sã  
0“å Sãÿ/ å Páöÿÿÿ/á      å  â  ÿ/á  å0Ÿå  Pã  ÿ/á<   ğ@-éĞMâPâ@ á p á  á` áşÿÿë  Tã  
 ”å  Qã    
  
\şÿë´å  á  Qã  áùÿÿ •è ‡è  áĞâğ€½èŸå  ã   ãşÿÿë  á  áşÿÿëòÿÿê4  p@-éP á å @ á  Qã`å  
 –å  Rã  
ˆ Ÿåşÿÿë€ Ÿå€Ÿå0–å  Pã     áşÿÿë ”åh Ÿå  Qã   ã   ãşÿÿëTŸå   á  áşÿÿë  á á   ãp@½è&şÿê  á  ã,Ÿåşÿÿë Ÿå   á  áşÿÿë  Vãp€½ïÿÿêH   H  <      Ğ"             d      d                                                                    `      `                                                                                                                                               <       <                                           €                                                  @-é[  ã ŸåŸå0Ÿåşÿÿë$  0  \  @-é ã0Ÿå Ÿå  ã 0“åşÿÿë  ãşÿÿë    ô  @-é ã0Ÿå Ÿå  ã 0“åşÿÿë  ãşÿÿë    ô  ì  ô  ü        (  4  @  L  X  d  t  |  ˆ    ˜  ¤  °  ¼  Ä  Ğ  Ü  ä  ğ  ü        (  8  H  P  X  `  h  p  x  €  ˆ  ”     ¬  ¼  Ğ  Ü  ô      (  8  L  p  `  p  |  ˆ  œ  ¬  ¼  È  Ğ  Ø  ä  `  ô         $  X  0  @  L  T  Ü  d  ä  t  P  „  ˆ  Œ  ”  Œ  œ      xfwrite if int endif default tristate endchoice def_tristate def_bool defconfig_list on optional option endmenu mainmenu menuconfig modules allnoconfig_y menu select comment env range choice bool source visible hex config boolean string help prompt depends    `  ¼  ˆ  p  Ä  ˆ  ˆ  ˆ  ˆ  ˆ  Ğ  Ô  Ü  ˆ  ˆ  ˆ  ˆ  ˆ  ˆ  ä                                                                                                                                                                                       ! " # # $ % &            ! " # # $ % & õÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿ ôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿ óÿ' ( óÿóÿ) óÿóÿóÿóÿóÿóÿóÿóÿóÿóÿ òÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿ * * + * * * * * * * * * * * * *  ğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿ ïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿ îÿîÿîÿîÿîÿîÿîÿîÿîÿîÿîÿîÿ, îÿîÿîÿ - - íÿ- - - - - - - - - - - - -  ìÿ. / ìÿìÿìÿìÿìÿìÿìÿìÿìÿìÿìÿìÿìÿ 0 ëÿëÿ0 0 0 0 0 0 0 0 0 0 0 0 0  1 1 2 1 êÿ1 1 êÿ1 1 1 1 1 1 êÿ1  éÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿ èÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿ 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3  æÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿ åÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿ äÿäÿäÿäÿäÿäÿäÿäÿäÿäÿäÿäÿäÿ5 äÿäÿ ãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿ 6 6 âÿ6 6 6 6 6 6 6 6 6 6 6 6 6  áÿáÿáÿáÿáÿáÿ7 áÿáÿáÿáÿáÿáÿáÿáÿáÿ àÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿ ßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿ ŞÿŞÿŞÿŞÿŞÿŞÿŞÿŞÿŞÿŞÿ8 9 9 ŞÿŞÿŞÿ İÿİÿİÿİÿİÿİÿİÿİÿİÿİÿ9 9 9 İÿİÿİÿ ÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿ ÛÿÛÿ: ÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿ ÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿ;  Ùÿ' ( ÙÿÙÿ) ÙÿÙÿÙÿÙÿÙÿÙÿÙÿÙÿÙÿÙÿ ØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿ * * + * * * * * * * * * * * * *  * * + * * * * * * * * * * * * *  ÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿ ÔÿÔÿÔÿÔÿÔÿÔÿÔÿÔÿÔÿÔÿÔÿÔÿ, ÔÿÔÿÔÿ - - Óÿ- - - - - - - - - - - - -  Òÿ. / ÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿ 0 ÑÿÑÿ0 0 0 0 0 0 0 0 0 0 0 0 0  ĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿ 1 1 2 1 Ïÿ1 1 Ïÿ1 1 1 1 1 1 Ïÿ1  ÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿ ÍÿÍÿ4 ÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿ ÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿ ËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿ 6 6 Êÿ6 6 6 6 6 6 6 6 6 6 6 6 6  ÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿ ÈÿÈÿÈÿÈÿÈÿÈÿÈÿÈÿÈÿÈÿ< 9 9 ÈÿÈÿÈÿ ÇÿÇÿÇÿÇÿÇÿÇÿÇÿÇÿÇÿÇÿ9 9 9 ÇÿÇÿÇÿ ÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿ ÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿ ÄÿÄÿÄÿÄÿÄÿÄÿÄÿÄÿÄÿÄÿ9 9 9 ÄÿÄÿÄÿ                                                                                                                           	   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "                                              	    
    IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII     II 
-I IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIÿÿÿÿ            ÿÿÿÿ                                    ÿÿÿÿ                        ÿÿÿÿ                                               ÿÿÿÿ            ÿÿÿÿ            (           5           >             ÿÿÿÿ            ÿÿÿÿ            M            P            ÿÿÿÿ            ÿÿÿÿ            Y            `            h            ÿÿÿÿ            q   
         ÿÿÿÿ            |             „             ’            ÿÿÿÿ            —                        ¦             ÿÿÿÿ            ª            °            ÿÿÿÿ            ÿÿÿÿ            ·           ÿÿÿÿ            ¼            Ã            Ë           ÿÿÿÿ            ÿÿÿÿ            Ï   	         Ö           ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            Ş           ÿÿÿÿ            ÿÿÿÿ            å            ÿÿÿÿ            ê            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ñ            P
  ”  œ  ¨  °  ´  arch/$ARCH/defconfig    P  X  `  h  p  x  €  ˆ  Œ   * ¦ÿ` ¦ÿo ¦ÿ ¦ÿ¦ÿK ¦ÿR * h * n k * s } üÿy ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¢ ¦ÿ£ ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ‹ ¦ÿ¦ÿŠ ¦ÿ ¦ÿ ¦ÿ˜ ¦ÿ¤ § ¨ ¦ÿ¦ÿüÿüÿM îÿ¦ÿ± ¹ ! G Ã ÷ ì şÿì « ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ) ¦ÿüÿüÿŠ a a ¦ÿ¦ÿº » Â * * üÿÄ a ¦ÿÛ ¦ÿ¦ÿ¦ÿ¦ÿÒ ¦ÿ¦ÿÌ * * Ç ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿŞ ¦ÿß ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ× ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿüÿŞ ä Ş ûÿŞ a # å ¦ÿ¦ÿŞ è Ş üÿ¦ÿ‡ é ¦ÿ¦ÿê ë Ş ğ ¦ÿ¦ÿí ¦ÿï óÿ¦ÿ¦ÿ¦ÿ¦ÿô * ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ   	
 !"#  C D 
 ] ^ L  L   Q  Q  h "     !    Z [    !  N # P     f      	 
               N  P  E …  …  œ         !      	 
   –               ¤ d M N  P M N  P    !     s      	 
                            	 
                    !             	 
   ¹                    	 
                           	 
            	 
  !        	 
            —  ™ š › "     ¡ % £ L ÿÿO t ÿÿÿÿÿÿÿÿ¬   
 X Y 6 ’ “ w  z ¤ ]  8  : œ ^ >  Z [ ƒ A B  ‘ C Z [ „  D ˆ áÿa  š áÿáÿáÿáÿáÿáÿáÿáÿb 4 áÿáÿc áÿd e f g h áÿi  j Š ­ \  k  ® ¬  	  ßÿa Z [ ßÿßÿßÿßÿßÿßÿßÿßÿb ¦ ßÿßÿc ßÿd e f g h ßÿi  j ³ — { ~ k ‡ } ‚  ‹  Z [ ûÿ 7 ¡         A B           9 ;  = üÿ ?           @ G           H I  ´ Z [ 4   «ÿa R S «ÿ«ÿ«ÿ«ÿ«ÿ«ÿ«ÿ«ÿT ¾ «ÿ«ÿc «ÿ«ÿ«ÿ«ÿ«ÿ«ÿ«ÿU a j V W ÌÿÌÿŒ ÌÿÌÿÌÿÌÿb _ ÌÿÌÿc r s t u ` ” • –  j › Ÿ a £ v ´ÿ´ÿ´ÿ´ÿ´ÿ´ÿ´ÿ´ÿ  ¤ ´ÿ´ÿc         [ j     Œ     ¨ ¯   ± µ ¶ ·   » § ¼ © ª « ¹ ½ 5 3   ° K ² y   … ¢         ¸    h  cd     u        ""7AF]O	X
 iJ e v f   st   lg       X  KS3T  p  C      a   / ('#$ &%  a ;<8:9B65GIEHDj_ ^PRNQMZ[YoqrnmV j jjj   W?j j `  )b  j1. > k\*+,  0=@-2                  g g g i i k m n o p q r v z z z z z z z z ~  €  ‚ ƒ ‡ ˆ  – œ ¤ ® ° ± ² ³ ´ µ ¸ À Æ Ğ Ö Ü ß á ì í ò û  %+57<DLOQRSX_fksvxyz}…Œ“™ ¢£¤§¯±²µ¼¾ÃÄÇÈÉÍÎÑÒÕÖ×ØÙÚÛŞßâã  % ÿQ&ÿ&ÿ?'ÿ'ÿÿ')ÿ'7ÿ'Cÿ'Pÿ'ÿ'(ÿ'ÿÿÿÿÿÿÿÿÿÿ=ÿGÿ,ÿ.ÿEÿÿÿ
ÿ+/ÿÿ-/ÿÿ/0ÿ/1ÿ/Kÿ/Iÿ/*ÿ/ÿNÿORÿSRÿRÿTTRÿ2ÿÿ23ÿÿ"OÿUÿ48ÿPÿ5:6ÿÿ89ÿ8Kÿ8Iÿ8ÿ8*ÿORÿNÿÿRÿÿ:)ÿSQÿPÿ;><ÿÿ>)ÿ>Cÿ>7ÿOQÿOÿ@LJÿPÿADBÿÿD)ÿDCÿD7ÿOÿ	OÿFJÿÿHÿÿJKÿJÿJ*ÿSÿÿLMÿLÿRÿÿORÿÿÿÿÿÿÿQÿÿSÿTÿT"TÿTTÿSÿ#SÿS SÿS!Sÿÿÿÿÿ               $ ( * , . 0 2 4 6 8 : < > @ B D H K O R V Y Z ] ` c f i l p u z  … ‰ Š   ’ – ™ › Ÿ   £ ¦ © ¬ ¯ ´ ¸ » À Á Ä È Ê Î Ï Ò Õ Ø Ü à ä æ ê ë î ñ ô ø ü ÿ 	"$&),/1458:>BFIMQSUV   $%%&&''''''''(((((((())))))**+,-.///////000001223345678888889999::;<=>>>>?@ABCDDDDEFGHIJJJJKLLLMNNOOPPPQQRRSSSSSSSTTUU ¦ÿ¦ÿ¦ÿ ºÿ¦ÿ¦ÿ¦ÿ¦ÿó ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿĞÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿìÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿÎ Í ¼ÿ¦ÿ¦ÿ© ÿÿ ùÿv ¾ÿ§ÿ¦ÿÿÿ   ! " l # $ % & J m n  º ' ( | ) L x M * € + N  , - ‰ . P / 0 1 o p Q q O † ˜ ™ 2  ¥ E F <  %&'?QO 	
()+,-.457;=@ACEFGP'&QOOUO#ST//8:>LDJSS !Q"*01HIK*9IK)6P)7<CPJM)7BCP*KSSTTONOST2ONRSRRRRTRRSR"3O There is no help available for this option. <none>  %s:%d: %s
  Stack now    %d %s:%d:warning:  %s:%d:      _MODULE CONFIG_ 0x  #define %s%s%s 1
   #define %s%s %s%s
  #define %s%s %s
    %s
 %.*s    \"  #
#     
#  token %s (  nterm %s (  Deleting    %s  %s:%d: missing end statement for this entry
    # %s%s is not set
  %s%s=%s
    len != 0    scripts/kconfig/lkc.h   %s%s=%c
    out of dynamic memory in zconfensure_buffer_stack() <token> unexpected '%s' within %s block '%s' in different file than '%s'    %s:%d: location of the '%s'
    Out of memory.
 /*
 Error in writing or end of file.
    */
     *  
Automatically generated file; DO NOT EDIT.
%s
 out of dynamic memory in zconf_create_buffer()  flex scanner push-back overflow %s:%d:warning: multi-line strings not supported
                
   flex scanner jammed fatal flex scanner internal error--end of buffer missed fatal error - scanner input buffer overflow input in flex scanner failed    out of dynamic memory in yy_get_next_buffer()   fatal flex scanner internal error--no action found  out of dynamic memory in zconf_scan_buffer()    out of dynamic memory in zconf_scan_bytes() bad buffer in zconf_scan_bytes()    r   srctree %s/%s   .kconfig.d  include/config/auto.conf    ..config.tmp    w   deps_config := \
   KCONFIG_AUTOCONFIG  	%s \
  	%s
    
%s: \
	$(deps_config)

    
$(deps_config): ;
 ifneq "$(%s)" "%s"
 %s: FORCE
  endif
  .config KCONFIG_CONFIG  can't copy type %d
 how to free type %d?
   boolean symbol %s tested for 'm'? test forced to 'n'
   boolean symbol %s tested for 'm'? test forced to 'y'
   y   (   <choice>    !   =   !=   ||      &&      ^  [       ]   <unknown type %d>   )   
choice
    
config %s
   boolean
    tristate
   string
     integer
    hex
    ???
    prompt      default     #choice value
      select      range       menu    unknown prop %d!
   help
%s
  
comment    
menu   
endmenu
    if       depends   ??? n   m   expr_calc_value: %d?
   warning: (  ) selects %s which has unmet direct dependencies (  )
  %lld    0x%llx  KCONFIG_PROBABILITY \
   [=%s]  using defaults found in %s  is not set  override: reassigning to symbol %s  symbol value '%s' invalid for %s    invalid string found    unexpected data %s creates inconsistent choice state    override: %s changes choice state   include/config  .h  ../..   can't find file %s
 %s:%d: can't open file "%s"
    %s:%d: recursive inclusion detected. Inclusion path:
  current file : '%s'
   included from: '%s:%d'
   \   "   include/generated/autoconf.h    include/config/tristate.conf    include/config/auto.conf.cmd    .tmpconfig  .tmpconfig_tristate .tmpconfig.h    KCONFIG_AUTOHEADER  KCONFIG_TRISTATE    unknown %s:%d:error: recursive dependency detected!
    %s:%d:	symbol %s %s value contains %s
  %s:%d:	symbol %s depends on %s
 %s:%d:	choice %s contains symbol %s
    %s:%d:	symbol %s is part of choice %s
  %s:%d:	symbol %s is selected by %s
 unexpected recursive dependency error
  Oops! How to check %d?
 UNAME_RELEASE   leading whitespace ignored  prompt redefined    ignoring type redefinition of '%s' from '%s' to '%s'    symbol '%s' redefines option 'modules' already defined by symbol '%s'   trying to redefine defconfig symbol redefining environment symbol from %s   environment variable %s undefined   Starting parse
 Stack size increased to %lu
    Entering state %d
  Reading a token:    Now at end of input.
   Next token is   Shifting    Reducing stack by rule %d (line %lu):
     $%d =    unexpected end statement    unknown statement "%s"  unexpected option "%s"  invalid statement   unknown option "%s" invalid option  %s:%d:config %s
    %s:%d:endconfig
    %s:%d:menuconfig %s
    warning: menuconfig statement without prompt    %s:%d:type(%u)
 %s:%d:prompt
   %s:%d:default(%u)
  %s:%d:select
   %s:%d:range
    warning: ignoring unknown option %s %s:%d:choice
   %s:%d:endchoice
    %s:%d:optional
 %s:%d:default
  %s:%d:if
   %s:%d:endif
    %s:%d:menu
 %s:%d:endmenu
  %s:%d:source %s
    %s:%d:comment
  %s:%d:help
 %s:%d:depends on
   -> $$ = syntax error    Error: discarding   Error: popping  memory exhausted    Cleanup: discarding lookahead   Cleanup: popping    choice value must have a prompt defaults for choice values not supported    choice value used outside its choice group  config symbol defined without type  choice must have a prompt   default for config symbol '%s' must be a single symbol  '%s': number is invalid config symbol '%s' uses select, but is not boolean or tristate  '%s' has wrong type. 'select' only accept arguments of boolean and tristate type    range is only allowed for int or hex symbols    range is invalid    Linux Kernel Configuration  ZCONF_DEBUG /   %s%s    KCONFIG_OVERWRITECONFIG %s.tmpconfig.%d 
#
# %s
#
  configuration written to %s .old    Symbol: %s [=%s]
   Type  : %s
 Range :     Prompt: %s
   Location:
    %*c-> %s     (%s [=%s])   Selects:    Selected by:  

    Defined at %s:%d
   Depends on:   No matches found.
  %s%s:

 prompt  comment menu    default choice  select  range   env symbol  boolean tristate    integer hex string  endmenu endchoice   if  endif   depends visible $end    error   $undefined  T_MAINMENU  T_MENU  T_ENDMENU   T_SOURCE    T_CHOICE    T_ENDCHOICE T_COMMENT   T_CONFIG    T_MENUCONFIG    T_HELP  T_HELPTEXT  T_IF    T_ENDIF T_DEPENDS   T_OPTIONAL  T_PROMPT    T_TYPE  T_DEFAULT   T_SELECT    T_RANGE T_VISIBLE   T_OPTION    T_ON    T_WORD  T_WORD_QUOTE    T_UNEQUAL   T_CLOSE_PAREN   T_OPEN_PAREN    T_EOL   T_OR    T_AND   T_EQUAL T_NOT   $accept input   start   stmt_list   option_name common_stmt option_error    config_entry_start  config_stmt menuconfig_entry_start  menuconfig_stmt config_option_list  config_option   symbol_option   symbol_option_list  symbol_option_arg   choice_entry    choice_end  choice_stmt choice_option_list  choice_option   choice_block    if_entry    if_end  if_stmt if_block    mainmenu_stmt   menu_entry  menu_end    menu_stmt   menu_block  source_stmt comment_stmt    help_start  help    depends_list    visibility_list prompt_stmt_opt end nl  if_expr expr    word_opt     GCC: (Raspbian 4.9.2-10) 4.9.2 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .rel.text .rel.data .bss .rel.text.unlikely .rel.rodata .rodata.str1.4 .comment .note.GNU-stack .ARM.attributes                             ñÿ                                                               L     (   D             L          +   L   €     (   d             |          =   Ì   T     (                         H      `     (   t            €         W   €  @     (   ¼            À         d   À  t     (   (            4         q   4  d     (               ˜         {   ˜  Œ     (               $         ‡   $  x     (   Œ            œ         ’   œ  8    (   Ä            Ø         (   ¸            Ô         ¦   Ô  (     (   ô            ü         µ   ü  ˆ     (   |            „         É   „  <     (   ¼            À         Ú   À  p     (   ,            0         è   0  d     ñ   ”  „     ş     @     (   L            X           X  @     (   Œ            ˜         3  ˜  È     (   H            `         >  `  ¤     (   ø                                     S      $     (                	         c  	  x     (   t	            |	         y  |	  ´     (   (
            0
         ’  0
  $    (   0            $          ©  $   ,     (   H             T         ¹  T  <     (   Œ                     Ä    D     (   Ğ            P          Ñ  P   ,     (   t             Ô         á  Ô      (   Ì            à         ö  à  P     (   (            0           0  \     (   „            Œ         5  Œ  È     (   L            T         (   Ô            Ø         (   8            <         (   œ                      K     p     (                        (   h            l         (   Ô            Ø         (   ğ            Œ         (   L            È         (   T             X          (   ¼             À          (   X!            \!         (   à!            è!         (   "            "         (    "            $"         (   0"            4"         (   @"            D"         (   P"            T"         (   `"            d"         (   p"            t"         (   €"            „"         (   "            ”"         (    "            ¤"         (   #            #         (   L#            P#         (   Ü#            è#         (   ô#            ø#         (   $            $         (   à%             &         (   `'            d'         (    '            ¤'         (   À'            È'         (   ä'            ì'         (    (            $(         (   \(            `(         (   t(            x(         (   „(            ˆ(         ]  œ)  ¬     (   ¼)            Ø)         (   @*            H*         (   +            4+         (   ¼+            À+         (   \,            `,         l  `,  d    (   À-            Ä-         ~  Œ/       ’  `.  ,    (    .            ¼.         (   ˆ/            Œ/         (    0            ¬0         š  ¬0  ”    (   06            @6         ¯  @6  ü     (   47            <7         (   ¼7            À7         (   (8            D8         (   4:            D:         ¿  D:  <    (   t<            €<         (   =            =         (   4=            P=         (   ü=            >         (   ¤>            ¬>         (   Ô>            ğ>         (   €@            „@         (   ØA            øA         (   (D            `D         (   ¼D            ĞD         (    E            <E         (   ÀH             I         (   0I            4I         (   DI         Ô  $h          HI         (   ”I            ˜I         (   °I            ¸I         (   øJ            üJ         (   K            (K         (   L            ÀL         ë  èL  0     (   ˆM            ˜M         (   ÀM            ÜM         (   üN             O           P  è    (   ôQ            øQ           øQ  L     9  DR  L     (   TS            hS         (   °S            ÄS         T  àZ  <     (   ¬Z            àZ         (   ¬[            ¼[         (   t_            „_         (   @b            Tb         (   tb            ˆb         (   Xc            d         (   „d            8e         (   øf            g         (   Xg            lg         (   „g            ˜g         (   h            $h         (   <i            Di         (   Ôj            øj         f  øj  Ğ     (   Àk            Èk         (   (l            8l         (   (m            Lm         (   ğp            q         (   (v            lv         x  lv  ¸    (   w            $w         (    y            $y         (   ${            8{         (   l|            p|         (   ü|             }         (   t}            „}         (               ,         (   P€            X€         Š  X€  Œ     (   ¬‚            ø‚         (   „„            „         ¤  l‹  Ğ     (   œŠ            ÌŠ         ·  ÌŠ        (   ìŠ            ‹         (   h‹            l‹         (   8Œ            <Œ         (   ÜŒ            äŒ         Ë  äŒ  4     Û    T     (   d            l         (   €            „         ì  „  T    (   È            Ø         (                         (   |            „         (   ¤            °         (   Ğ            Ø         (   ğ            ô         (   @            D         (   À            Ô         (   $‘            (‘         (   ’            ’         (   ,’            <’         (   ô“            ”         (    –            Ğ—         (   À£            Ø¤         (   T±            ±         (   è²            ³         (   °µ            ¼µ         (   t¹            ¬¹         ú  ¬¹  ¼    (   ¿            h¿         (   ”¿            ˜¿         (   Ì¿            Ğ¿         (   ô¿            ø¿         (   €À            „À         (   <Á                       (              	      \      \       *  d  ù     D  `  P     O  °      V  Ì
       \  Ì  z     f  H       w  H      …  Ø           $     ›  ,  ~    ¢  ¬  #    ®  Ğ  F    ¶    F    ¾  `  ¿     Ç     w     Ì  ˜  î     Ô  ˆ  X    Ú  à  î     á  Ğ   w     æ  H!  d     î  ¬!  d     ø  "  ¿     ÿ  Ğ"  ,     (                         !  H       4  P       H  X                    
 (             
 (              Z           j          ~          ‰          ”          ¡          ­           »  $        Ç  (        Õ  ,        ß  0        é  4        ô  8        ù  <          @          D        )  H        E  L        M  P        V  X        ^  \        g  d        x  h          l        š  p        ©  p      ·  t       Ä  x       Ğ  |                                                 Ş         òÿè             ğ             ÷             ş                                   òÿ                          $             -             4             :             A             H             P             W             ^             e             j             q         òÿ|             Š                          ¥         òÿ²             »     0    òÿÄ  T  „     Û  Ø  d     ï             ô  <  d                      \     ,  l  l     9  Ø  ğ    B             J             Q             Z             a             f             l         òÿv         òÿ€         òÿŒ  È       £  X   h     ¹  À   œ     Ë  \!  Œ     Ü  è!       î  "       ş  "       
	  $"       	  4"       %	  D"       3	  T"       C	  d"       O	  t"       \	  „"       k	  ”"       z	  ¤"  x     ‹	  #       –	   #       £	  $#       ­	  (#  (     ½	  P#  ˜     É	             Ï	             ×	  è#       ä	  ø#        ò	  $      
             
         òÿ
         òÿ
   &  <     '
  \&  (     0
  „&  x     ;
             B
  ü&  h     M
             W
  d'       _
  l'       g
  €'       o
             v
  ”'       
  ¤'  $     ¤
  È'  $     ½
  ì'  8     Ò
  $(  <     ç
  `(       ø
  x(         ˆ(  €     (  )  ,     :  4)  0     I  d)  8     X         òÿd  H*  8     t  €*  (     ƒ  ¨*  (     ‘  Ğ*  ğ     ›  À+        ¥  Ä-  œ     ·  <7  „     Ç  À7  „    Ö  €<       ê  =  Ä     ÿ  Ô=  Ø       ¬>  Ø    &  „@  ü     >  €A  à    I  `D  À    S   I       _  4I       o  HI  P     |         òÿˆ  ˜I        –  ¸I  <     ª  ôI  <     »  0J  Ì     Õ  üJ  ì    æ             ô  M  €     	  R  P      ˜M  h    (   O      ;             C             L             S     Ô›   òÿ_  [        s  ¼[  `    Š  ]  ¨     ¤             ´  Ä]      Í             Ò             Ù             à  Tb      ø  \d                     pf  ´    +             3  Di       D  \i  œ    O             W  Èk  p     q             y  8l      ‚  Lm   	    “             œ             ¤             ®         òÿÁ             Ç             Û             à             æ             ì  $y      ö  8{  8      p|          }  „     )  „}  ¨    8  ,  ,    P  ä€      d  ø‚  ˜    r             z             ‚             ˆ               „  <    Ÿ  <Œ  ¨     ª             °  l       ¹  Ø  $     É  ü  $     Ü     d     æ  „  ,     ñ  °          ´  $       Ø         ô  P     )  D       7  Ô       G  à  H     [  (‘       i  8‘  ,     y  d‘  ´     ˆ  ’  ü    ˜  ”  ,    £         òÿ­  @¨  P	    »  ±  „    Æ  ³       Ö  $³  Ä     æ  è³  Ô    û  ¼µ  @     	  üµ  °                              "  h¿  $     2  Œ¿       E  ˜¿  8     Z  Ğ¿       h  à¿       v  ø¿  Œ     ˆ  „À  Ì     š  ø   P     §  X   P     ±     P     ¼  ¨   P     Ç  ğ       Ô  `        å          ñ  T        ú            `        zconf.tab.c $a zconf_load_buffer_state $d expr_compare_type zconferror yy_stack_print conf_message conf_warning prop_warn zconf_error zconfprint header_print_symbol yy_fatal_error print_quoted_string dep_stack_insert append_string add_byte sym_rel_comp conf_default_message_callback yy_symbol_print.isra.8 yydestruct kconfig_print_symbol xfwrite.part.11 tristate_print_symbol zconfensure_buffer_stack zconf_endtoken.isra.15 xmalloc.part.17 new_string alloc_string xcalloc.part.18 header_print_comment conf_write_heading.isra.12.constprop.34 expr_print_file_helper kconfig_print_comment zconf_init_buffer menu_check_dep expr_eliminate_yn __expr_eliminate_eq expr_eq expr_eliminate_dups1 expr_extract_eq expr_eliminate_dups2 expr_print_gstr_helper menu_validate_number.isra.21 sym_calc_visibility sym_get_default_prop.isra.26 sym_get_range_prop.isra.27 sym_get_range_val conf_expand_value conf_split_config conf_write_symbol.isra.24 sym_check_sym_deps sym_check_expr_deps sym_add_default sym_init.part.22 menu_add_prop get_symbol_str yytname __PRETTY_FUNCTION__.6057 kconf_id_strings_contents CSWTCH.443 yy_nxt yy_ec yy_accept asso_values.6223 wordlist.6274 CSWTCH.578 CSWTCH.636 yypact yytranslate yycheck yytable yydefact yyr2 yyrline yyrhs yyprhs yyr1 yypgoto yydefgoto yystos nohelp_text conf_message_callback kconfig_printer_cb tristate_printer_cb header_printer_cb yy_buffer_stack yy_buffer_stack_top yy_n_chars yy_c_buf_p yy_hold_char current_pos conf_filename conf_lineno conf_warnings check_top text_size text_asize text current_menu last_entry_ptr yy_buffer_stack_max yy_did_buffer_switch_on_eof yy_init yy_start last_ts first_ts sym_change_count conf_changed_callback trans_count res_value.7975 fullname.7988 conf_unsaved inited.8856 current_entry zconftext fprintf stderr fwrite fputc vfprintf zconfnerrs getenv exit _IO_putc strchr fputs memset memcpy realloc strlen strcmp printf puts stdout zconfdebug __assert_fail __ctype_toupper_loc malloc current_file snprintf rootmenu zconf_switch_to_buffer zconf_delete_buffer free zconf_flush_buffer __errno_location zconf_create_buffer zconfrestart zconflex strncmp fclose clearerr fileno read stdin zconfleng zconflval current_buf zconfpush_buffer_state zconfpop_buffer_state zconf_scan_buffer zconf_scan_bytes zconf_scan_string zconfget_lineno zconfget_in zconfget_out zconfget_leng zconfget_text zconfset_lineno zconfset_in zconfset_out zconfget_debug zconfset_debug zconflex_destroy zconfalloc zconfrealloc zconffree zconf_starthelp zconf_fopen fopen sprintf zconf_lineno zconf_curname file_write_dep rename file_list sym_env_list str_new str_free str_append strcat str_printf vsnprintf str_get xmalloc xcalloc calloc conf_set_message_callback conf_get_configname conf_get_autoconfig_name sym_set_change_count sym_add_change_count conf_get_changed conf_set_changed_callback set_all_choice_values expr_alloc_symbol expr_alloc_one expr_alloc_two modules_sym expr_alloc_comp expr_alloc_and expr_alloc_or expr_copy expr_free expr_eliminate_eq expr_trans_bool expr_transform expr_eliminate_dups expr_contains_symbol expr_depends_symbol expr_trans_compare expr_simplify_unmet_dep expr_print zconfdump expr_fprint expr_gstr_print sym_get_type modules_val sym_type_name sym_get_choice_prop sym_get_env_prop sym_tristate_within_range sym_string_valid __ctype_b_loc sym_get_string_value sym_calc_value expr_calc_value sym_choice_default strtoll __strdup memcmp symbol_hash sym_clear_all_valid sym_set_tristate_value sym_toggle_tristate_value __aeabi_idivmod conf_set_all_new_symbols rand strtol perror sym_string_within_range sym_set_string_value strcpy sym_get_string_default strrchr sym_is_changable sym_lookup strncat conf_get_default_confname __xstat sym_find conf_read_simple _IO_getc memmove dcgettext sym_defconfig_list chdir __ctype_tolower_loc open mkdir close conf_read sym_expand_string_value file_lookup zconf_initscan zconf_nextfile sym_escape_string_value conf_write_autoconf sym_re_search regcomp regexec qsort regfree sym_check_deps prop_alloc uname sym_init prop_get_symbol prop_get_type_name menu_warn _menu_init menu_end_entry menu_add_menu menu_end_menu menu_add_dep menu_set_type menu_add_prompt menu_add_visibility menu_add_expr menu_add_symbol menu_add_entry menu_add_option zconfparse zconfchar menu_finalize conf_parse menu_has_prompt menu_is_visible conf_write_defconfig menu_is_empty conf_write getpid stpcpy menu_get_prompt menu_get_root_menu menu_get_parent_menu menu_has_help menu_get_help get_relations_str menu_get_ext_help symbol_empty symbol_no symbol_mod symbol_yes conf_defname zconf_flex_debug zconflineno zconfout zconfin cdebug    D     H   Ê d     h     l     p     t     x       Ë       Ì   §   § @  Í X  Ë p  Î t  Ì x  § |  § ¼    ì  Ë ü  Ï   Î (    ,  Ì 0  § `  Ë p  Ï |  Î   Ì ”  § Ø  Ë ğ  Ï ü  Î       Ğ   Ì   §    § T  Ë l  Ï x  Î Œ      Ì ”  § ˜  § Ä    È    Ì    Ğ    Ô    ô  Ñ   Ë 4  Ñ X  Ë h  Ñ ˆ  Ë ¸  § ¼  § À  § Ä  § È  § Ì  § Ğ  § è  Ë ğ  Ò ô  Ì ø  §   Ó (  Í 8  Ô X  Ë h  Õ x  Ó |  § €  § ˜  Ö ¼    ô  ×   Ø ,    t  Ø ¬  Ù Ì  Ù   Ú (  Û <  Ï H  Ü L  § P  İ T  § x  Ë ˆ  Î Œ  ‡   § ”  § ô  Ë (  Ë @  Î H  Ş L  § P  Ì T  § X    \  § ”  Ñ ¸  Ë Ğ  Ñ ô  Ë ø  § ü  §  	  § 4	  Ñ D	  à h	  Ë t	  § x	  § ´	  Ø  
  á (
    ,
  § ô
  Ë 0  ‡ 4  § 8  § <  Ğ @    D  â H  § L  Ì P  § \  á ˆ  M  Œ       á ¼  × Ì  M  Ğ    ğ  Í <  Í H  Î \  Í x  Í „  Î ¬  Í Ä  Í Ì  § Ğ  Ì Ô  § Ø  § Ü  §   ã (  ä ,  § @  Ù X  Í |  Í €  A  „  Ì ˆ  § Ø  Î ä  Î ø  Í   Í    Î D  Î L  Ì P  § Ô       ç (  ç 4  ç 8    œ    ¬  é ¼  è        á 4  á h  § ´  ê Ô    ğ    ô    ø    ü                                          $    (    ,    0    4    8    <    @    D    H    L    P    T    X    \    `    d    h    l    p    t    x    |    €    „    ˆ    ¤  Û |  í 0  î L  æ T  å \  ç   í „  ê ø  î (  Ø °  é   ï ,  ğ H  ñ <  Ø t  ë L    P  ò T  İ X  ‡ \  Ê `  ó d  ‡ h  § l  § p  â |  ‡ €  ‡ „  ô Œ  õ ”  § ˜  § œ  § °  § ´  § ¸  § ¼  § À  § Ä  § T     €   æ ¼     ô   á ,!  å X!  § p!  á ¸!  ø à!  § ä!  § ğ!  Ù  "  ù "     "    0"    @"  ó P"  Ê `"    p"    €"    "     "    Ì"  æ Ô"  ÷ ì"  ç #    #  á  #  Ø $#  ç L#    d#   #  Ñ °#   ¼#   Ü#  § à#  § ä#  § ô#    $    $  § 0$   L$  Í x$  Ë Œ$  Ñ ¨$  Ë P%  Í X%  î d%   €%  Ñ œ%  Ë ¤%  Ñ ¼%  Ë Ğ%  Í à%  § ä%  § è%  § ì%  § ğ%   ô%  § ø%  § ü%  §  &  § &  § &   &  § &  § &  § &  § &  § ,&  á X&  M  p&  ç  &  Ù ¬&  Ù Ğ&   Ü&  Ø ø&   <'   H'   p'  á |'  M  „'   '  V   '    ¬'  Ñ À'  § Ä'  § Ğ'  Ñ ä'  § è'  §  (    \(    t(    „(    )   0)  V  H)   `)  V  |)   ˜)  V  ¼)    À)    Ä)    È)    Ì)    Ğ)    Ô)    *  % *  ' @*    D*  ( `*   |*  V  œ*  ' Ä*  ' ä*  á +    +     +    $+    (+    ,+    0+    <+  Û D+  ç l+  , x+  , +  , ¸+  M  ¼+  § ,,  - 4,  - @,  ç H,  Û T,  ç \,  § -  - -  - H-  ç \-  ç ¤-  ç ¸-  ç À-     .    ¤.    ¨.    ¬.    °.    ´.    ¸.    /  , /  , 0/  . H/  - P/  - ˆ/    $0  - ,0  - D0  % P0  % ˆ0  % ”0  %  0    ¤0    ¨0    `2  ) 3  % 43  , H3  - P3  - X3  % |3  , 3  - ˜3  - ˆ4  ) È4  ) 45  ) T5  %  5  ) °5  % ü5  ) 6  ) $6  ) 06    46    86    <6    Ô6  ' à6  - ø6  % 7  % 7  % (7  % 47    87    €7  / Œ7  / ¼7    (8    ,8    08    48    88    <8    @8    H8  0 T8  0 ø8  % <9  ç \9  & €9  ç ˆ9  ç  9  ç Ğ9  Û ô9  Û :  ç  :  ç 4:    8:    <:  § @:  §  :  , ¬:  & °:  0 ¼:  , $;  - ,;  - 4;  - P;  , \;  & `;  0 l;  , ä;  - ì;  % <  - t<    x<    |<    =    4=    8=    <=    @=    D=    H=    L=     =  2 Ä=  2 ü=     >    >    >    >    >    D>  3 ¤>    ¨>    Ô>    Ø>    Ü>    à>    ä>    è>    ì>    (?  ) <?  4 P?  4 Œ?  4  ?  4 È?  ' ğ?  % 4@  , D@  & L@  , \@  & l@  ' |@  % €@    ¤@  , °@  , Ô@  ' à@  1 ü@  - A  - 8A  , @A  5 PA  5 tA  ' ØA    ÜA    àA    äA    èA    ìA    ğA    ôA    „B  6 ¨B  6 ÀB  6 äB  6 C  6 ÄC  6 üC   (D  § ,D  § 0D  § 4D  § 8D  § <D  § @D  § DD  § HD  § LD  § PD  § TD  § XD  § \D  § ¤D  Í ¼D    ÀD    ÄD    ÈD    ÌD    àD  Í  E    $E    (E    ,E    0E    4E    8E    LE  Í `E  6 lE  Î ŒE  Ù ĞE  Ë  F  Í 8F  Î dF  Í xF  6 „F  Î ĞF  Í èF  Í üF  6 (G  Í <G  6 TG  Í lG  Î „G  Í ÌG  Í äG  Í üG  Í H  Í $H  Ë 8H  Ë PH  Í ˜H  Í ÀH  ä ÄH    ÈH  § ÌH  § ĞH  § ÔH  _  ØH  § ÜH  § àH  § äH  § èH  § ìH  § ğH  § ôH  § øH  § üH  §  I  § I  § I  § I  § I  § I  § I  § I  § ,I  6 0I  _  @I  6 DI  ì  ”I  ; °I  ‡ ´I  § øJ  ; K    K    K     K    $K    <K  A ¼K  A L    L    L    L    L     L    $L    (L    ,L    0L    4L    8L    <L    @L    DL    HL    LL    PL    TL    XL    \L    `L    dL    hL    lL    pL    tL    xL    |L    €L    „L    ˆL    ŒL    L    ”L    ˜L    œL     L    ¤L    ¨L    ¬L    °L    ´L    ¸L    ¼L    M  @ \M  C ˆM  § ŒM  ( M  § ”M  § ÀM    ÄM    ÈM    ÌM    ĞM    ÔM    ØM    àM  C üM  D N  D $N  D 0N  D hN  C pN  C xN  B „N  B N  Ú ¬N  C ´N  C ¼N  B ÈN  B ÔN  Ú èN  Û üN  § 4O  D 8P  D ÀP  D  Q  D ôQ  ; $R  D pR  D  S  C TS    XS    \S    `S    dS    °S    ´S    ¸S    ¼S    ÀS    |T  F ÄT   ÌT  G äT  H V  $ ˜W  C ÄW  5 àW  Í ôW  6 X  Ë X  6 ,X  Í 4X  - Y  E \Y  D œZ  D °Z    ´Z  § ¸Z  § ¼Z  ( ÀZ  Ì ÄZ  § ÈZ  _  ÌZ  § ĞZ  § ÔZ  I ØZ  I ÜZ  ; ìZ  C [  F ¨[  C ¬[  I °[  I ´[    ¸[  ( Ô[  ? D\  J D]  K `]  K |]  K  ]  K t^  J 4_  C D_  $ t_    x_    |_    €_    ¬_  O x`  O €`  M ,a  Ñ Ta  P Ìa  é Üa  Q äa  Ò @b  I Db  I Pb  § tb    xb    |b    €b    „b    Œb  @ b  @ ¸b  F èb  @ c  F Xc    \c    `c    dc    hc    lc    pc    tc    xc    |c    €c    „c    ˆc    Œc    c    ”c    ˜c    œc     c    ¤c    ¨c    ¬c    °c    ´c    ¸c    ¼c    Àc    Äc    Èc    Ìc    Ğc    Ôc    Øc    Üc    àc    äc    èc    ìc    ğc    ôc    øc    üc     d    d    d    d  ?  d  ? ,d  ? „d    ˆd    Œd    d    ”d    ˜d    œd     d    ¤d    ¨d    ¬d    °d    ´d    ¸d    ¼d    Àd    Äd    Èd    Ìd    Ğd    Ôd    Ød    Üd    àd    äd    èd    ìd    ğd    ôd    ød    üd     e    e    e    e    e    e    e    e     e    $e    (e    ,e    0e    4e    @e  R e  Ù ¸e  Ú Èe  á Üe  T äe  ç èe  J üe  K f  K f  K Df  á lf  M  „f  C øf    üf     g    g    g    Xg    \g    `g    dg    hg    „g    ˆg    Œg    g    ”g    œg  D Èg  C äg  D h  ( h    h  § h  § h  §  h  § <h  B Th  Ù hh  V |h  Ù ”h  Ù °h   Øh   äh   üh  Ù i  V (i   4i   <i  § @i  § Ài  Ú `j  G lj  á €j  Ö Ğj  M  Øj  I ìj    ğj    ôj    k  Ô 0k  Y 4k  A „k  X Œk  C ”k  B  k   °k   Àk    Äk    àk  Ñ ük   l  [ (l  ‡ ,l  § 0l  § 4l    tl  Ú ,m  I @m    Dm    Hm    hm  
 n  ç Ln  ^ Ìn  Ñ àn  Ñ ğn  Ù  o  H <o  Ñ To  Ñ do  Ù to  H „o  Ñ ”o  Ù ¤o  Ô Ào  í Üo  Ñ ìo  Ù øo  \ Dp  Ñ Tp  Ù `p  Ô €p  Ô ¬p  Ñ ¼p  Ù Äp  \ ğp    ôp    øp    üp     q    q    q  Ñ q  Ù $q  X `q  A œq  @ àq  ç èq  î üq  C \s  Ù ps  _ ˆs  Ñ ˜s  Ù ¨s  X $t  G lt  C ôt  Ñ u  
 ˜u  D Äu  
 àu  ` (v    ,v    0v  I 4v  I 8v  § <v  § @v  § Dv  § Hv  ( Lv  § Pv  § Tv  § Xv  § \v  § `v  a dv  § hv  § |v  Ñ v  ] ˜v  b Ğv  C w    w    w    w     w    (w  B 0w  Ú xw  c Àw  d Ìw  é øw  Ô x  [ (x  e @x  b xx  d „x  f  y  § y  § y  § y  I y  § y  I  y  § Ty  ] y  C Äz  R øz  Ú ${    ({  I ,{  I 0{    D{  Ù P{  á l{  Ô „{  Y ˆ{  A Ô{  \ à{  C è{  B ğ{  Ù ü{  Ù |  Ù (|   @|  Ø X|   h|  M  l|  § x|  h ¬|  Ú ¼|  ç Ì|  á ø|  M  ü|   }  
  }  á D}  i d}  Û l}  Ò p}  M  t}    x}  õ |}  â €}  § ˆ}  i ”}  á Ğ}  
 ì}  ê ğ}  å ~  Ú h~  Û ~  Û °~  Ú Ì~  Û Ô~  Ò    Û   Ò   M        õ   â   §    § $  § (  § 4  Ù |  á è  Y ğ  Ù  €  Y (€  Ù D€  Y L€  M  P€  § T€  § Œ€  B °€  B ´€  l Ü€  ç è€  J ğ€      $   8   Œ  C ü  î ‚  î ‚  î ‚  Ñ ,‚   <‚  Ñ T‚   d‚  Ñ |‚   Œ‚  î ”‚  î ¤‚  î ¬‚  § °‚  § ´‚  § ¸‚  § ¼‚  § À‚    Ä‚    È‚    Ì‚  I Ğ‚  I Ô‚    Ø‚    Ü‚    à‚  § ä‚  § è‚  § ì‚  § ğ‚  § ô‚  § ƒ  o xƒ  p œƒ  Ø °ƒ  C  „  q „  á X„  ç `„  r „„  I ˆ„  I Œ„  3  ¼†  s $‡  Í ˆ  Ë °ˆ  Ë ‰  Ë ˆ‰  Ë XŠ  Ë ”Š  Ë œŠ     Š  Ì ¤Š  § ¨Š  § ¬Š  ‡ °Š  § ´Š  § ¸Š  § ¼Š  § ÀŠ  § ÄŠ  § ÈŠ  § ìŠ    ğŠ    ôŠ    øŠ    üŠ     ‹    ‹    ‹  s ‹  s ,‹  s \‹  Û h‹  § 8Œ    LŒ  á ØŒ  M  ÜŒ  â àŒ    øŒ  t   X   % 0  u <  X d    h  § €    ¤  t È  A <  , h  ' È    Ì  ä Ğ  § Ô  §   ‡   § L  Ë \  Ï h  Î |  Ì €  § ¤  ä ¨    ¬    Ğ    Ô    ğ    $  ' @    ´  y À    Ä  § È  ‡ Ì  § Ğ  § ‘  ' $‘    H‘  % p‘  á  ’  ƒ ’  M  ’    ’  â ’    ,’    0’    4’    8’    ´’  t È’  X Ì’  % Ü’  & ğ’  Ñ À“  Ú Ü“  y ğ“  y ô“    ø“   ü“  a  ”  § ”  ( ”  § ”  § ”  § Ä”  á Ü”  × ü”  × •  ç  –    $–    (–    ,–    0–    4–    8–    <–    @–    D–    H–    L–    P–    T–    X–    \–    `–    d–    h–    l–    p–    t–    x–    |–    €–    „–    ˆ–    Œ–    –    ”–    ˜–    œ–     –    ¤–    ¨–    ¬–    °–    ´–    ¸–    ¼–    À–    Ä–    È–    Ì–    Ğ–    Ô–    Ø–    Ü–    à–    ä–    è–    ì–    ğ–    ô–    ø–    ü–     —    —    —    —    —    —    —    —     —    $—    (—    ,—    0—    4—    8—    <—    @—    D—    H—    L—    P—    T—    X—    \—    `—    d—    h—    l—    p—    t—    x—    |—    €—    „—    ˆ—    Œ—    —    ”—    ˜—    œ—     —    ¤—    ¨—    ¬—    °—    ´—    ¸—    ¼—    À—    Ä—    È—    Ì—    Ü—  Ù „˜  í Ä˜  ç @™  Ë |™  Ë ›  ç „›  ì Ğ›  Í ğ›  Ë œ  Î @œ  Ë „œ  Ë ¤œ  Î Ìœ  Í øœ  Ë $  Î ô  Í `  Û ¼  Û È  „ Ÿ  Û  Ÿ  ) ¨Ÿ  Û ¸Ÿ  X ÈŸ  ƒ øŸ  Û      X   Û l   ) €    ¸   Û Ä   „ ¡  Û @¡  Û H¡  k X¡  X d¡  ç ˜¡  Û  ¡  „ ¨¡  ~ $¢  Û €¢  X ¢  ƒ À¢  Û Ô¢  ' è¢  X ø¢  „ <£  Û P£  ' ¸£  Û À£  Ş Ä£  Ğ È£  ‡ Ğ£  ‡ Ô£  ‡ Ü£  ‡ à£  ‡ ä£  § è£  ‡ ì£  ‡ ğ£  § ô£  § ø£  ‡ ü£  §  ¤  ô ¤  § ¤  § ¤  § ¤  § ¤  § ¤  ‡ ¤  §  ¤  § $¤  § (¤  § ,¤  § 0¤  § 4¤  § 8¤  § <¤  § @¤  § L¤  § P¤  § T¤  § X¤  § \¤  § `¤  § d¤  § l¤  § p¤  § t¤  § x¤  § „¤  § ˆ¤  § Œ¤    ¤  § ”¤  § ˜¤  § œ¤  §  ¤  § ¤¤  § ¨¤  ‡ ¬¤  § °¤  § ´¤    ¸¤    ¼¤  § À¤  § Ä¤  § È¤  § Ì¤  § Ğ¤  Ì Ô¤  § 0¥  Û <¥   H¥  ~ x¥  Û À¥  Û è¥  X ô¥  ç  ¦  % ¦  X $¦  „ X¦  Û h¦  X x¦  „ ¬¦  Û §  & (§  ) l§  Û „§  Ë ¤§  Î Ø§  Ë  ¨  Î ,¨  … „¨  0 ¨  , ´¨  ' ¸¨  1 ©  ˆ ğ©  ƒ Lª  & |«  % œ«  ' À«  ' ¬   (¬  % D¬   x¬  0 „¬  , ¤¬  ' ´¬  1 Ø¬  / l®  ) ®  ' Ì®  , ğ®  ' ¯  % ¯  , 8¯  ' \¯  ' °¯  4 ´¯  0 ¸¯  1 ğ¯  2 °  3 °  4 $°  0 (°  1 4°  , D°  . L°  - h°  - ¬°  ' Ô°  - Ü°  ˆ ±  y ±  y L±  y T±    X±  § \±  § `±    d±  § h±  § l±  § p±  § t±  § x±    |±  § €±    „±  § ˆ±  § Œ±  § ”±  j ä±  Ñ ø±  † (²  ` @²  h L²  ˆ l²  s Ô²  \ ä²  Ò è²    ì²  ä ğ²    ô²  § ø²  Ğ ü²  §  ³  Ş ³  ( ³  I ³  I ³  § D³  D `³  C ¤³  ‹ È³  D ğ³   ü³  J @´  C l´  B x´  U „´  Ú ä´  E (µ  î 8µ  ‹ \µ  E °µ  § ´µ  ä ¸µ    àµ  ‹ (¶  Ñ P¶   X¶  Ñ |¶   ”¶   ¤¶   ·  C |·  î ”·  Ù  ·   Ä·   Ô·   ì·  ` 4¸  ‹ X¸  Ë ¸   ´¸  [ à¸  V ¹  × ,¹  Ñ <¹  J P¹   t¹  § x¹  § |¹  § €¹  § „¹  § ˆ¹  § Œ¹    ¹    ”¹  ä ˜¹    œ¹  §  ¹  § ¤¹  § ¨¹  § Ü¹  B ğ¹   º   Tº  ` hº  ` xº    º  ‹  »  ` »   <»  ` T»   p»  B „»   ”»   À»  Ù h¼   |¼  6 ´¼  ` À¼   Ô¼  6 à¼   ô¼   ½  á ,½  ‹ ½  `  ½   Ä½  ` Ø½   ¾   ,¾  ` H¾   p¾  ` |¾   ¾  6 œ¾   ì¾    ¿  6 ¿   ¿  M  ¿  § ¿  §  ¿  ‡ $¿  § (¿  § ,¿  ä 0¿  § 4¿  § 8¿  § <¿  § @¿  § D¿  ì  H¿  § L¿  § P¿  § T¿  § X¿  § \¿  § `¿    d¿  § ”¿  ä Ì¿  ä ô¿  § À   lÀ  ` xÀ   €À  § °À  Ñ ÌÀ   èÀ  ` øÀ   Á  ` ,Á   <Á  § @Á  § DÁ  § HÁ  § LÁ  ‡     4     §    § \   § d   § ¬   § ´   § ü   §   § H  =  L  b  P  D  T  b  X  !  \  Y     ß    §    §     ‡ <   Í D   Ò H   Ì L   § h   Í p   Ò t   Ì x   §     §    §    §    §    §    §    §    §     § $   § (   § ,   § 0   § 4   § 8   § <   § @   § D   § H   § L   § P   § T   § X   § \   § `   § d   § h   § l   § p   § t   § x   § |   § €   § „   § ˆ   § Œ   §    § ”   § ˜   § œ   §     § ¤   § ¨   § ¬   § °   § ´   § ¸   § ¼   § À   § Ä   § È   § Ì   § Ğ   § Ô   § Ø   § Ü   § à   § ä   § è   § ì   § ğ   § ô   § ø   § ü   §    §   §   §   §   §   §   §   §    § $  § (  § ,  § 0  § 4  § 8  § <  § @  § D  § H  § L  § P  § T  § `  § d  § h  § l  § p  § t  § x  § |  § €  § „  § ˆ  § Œ  §   § ”  § ˜  § œ  §    § ¤  § ¨  § ¬  § Ø  § Ü  § à  § ä  § è  § ì  §   §   §   §   §   §   §    § $  § (  §                                                      4   PÁ                    	   @       ; X7              )             „Á  d                 %   	   @       hr x               /             èÂ  €                 8             èÂ  |                  4   	   @       àr `               K             dÃ  ü"                 G   	   @       @s È              S      2       `æ  ¨                b      0       ş                    k              (ş                     {     p        (ş  1                                Yş  ‹                                äş   *     Ê        	              ) 	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ELF          (    t 4   ¬„  4    (     pT/ T/ T/                4   4  4                 4  4 4                          `/ `/           0  0  0 |  ì²           0 0 0 è   è            P  P P D   D         Qåtd                          /lib/ld-linux-armhf.so.3             GNU                        GNU ‰ô	jqhÖ3U¤' zÏ!rC         	   ¤àè„`’( Ì€ !€  "`‡„Œ` «LÒ†ˆ‚(’AÂtFğÀ ¤ ‘d  	 €ˆ @                                                                             !   "   #       $   %   '   (       *   +   ,   -           .       /   0   1   2   4   5       8   :           ;       <           =   ?       @   D   F       H   J   L   N   éüH>Bw)‘}í8ò‹êvş±°¨”Ä,ÔÎnEÍ?¯,2@ıfUal²Í/tò¾G>cŞ$<­9)Œ #ù¤­p¯	~’óæõ/N=ö|‹s²¢÷E>¯3Ä÷—©ºÚu‚w×›|^–“‡ğ–|±JEKŸÖ½/t¹+kşì„{œ|SÕr~fII"ÿÇ<×”“‡K…æ7ÃòzAM|íŞ“Û/‚_t;Å!Ï	ıÆà=»“7vı>~–|>ùÿ¼ù,X¾$u‚Ï89[š;•ÅK9èD®`‡ÿ¡Š]aù¼¯vµÚ®Õ'0¸‚½îÊÂ‡ÿ»•“ÄoI>ë=|Ê–“}0`ûnıÒï
µ¥„æ1ïé¼                F              \              	             œ              }  ˆ4      Ÿ             Û             ³                          E                            ¢   4      d              +             n             Ì              E             $  ”4      î              T              6             Ù              $             ?              v  ˜4                   M   €4      &              7             @                                         ·              ÷             1             ?             m              2             Ç             Y             Á             L             ¦             ï                          Å              ÿ                          >             ”              à              ˜                           >                          
             ÿ              ?             =             S             g             /              ¨                           „             ç              †              °              º             ~              :                            9              Ó                                                       t               libc.so.6 fflush strcpy exit sprintf _IO_putc setlocale srand fopen strncmp optind strrchr regexec __strdup perror dcgettext regfree putchar mkdir realloc abort stdin strtoll getpid __assert_fail strtol isatty fgets calloc strlen memset __errno_location chdir read memcmp clearerr vsnprintf stdout fputc fputs memcpy fclose malloc strcat raise __ctype_b_loc getenv regcomp optarg stderr getopt_long strncat fileno fwrite gettimeofday rename strchr qsort __ctype_toupper_loc __ctype_tolower_loc __xstat memmove uname bindtextdomain _IO_getc strcmp __libc_start_main stpcpy vfprintf __gmon_start__ GLIBC_2.4                                                                                                 ii   U      $2   €4   ˆ4   4   ”4   ˜4    1   1 <  1   1 .  1 $  1   1 -  1    1 "  $1    (1 J  ,1   01 @  41 8  81   <1 /  @1 N  D1 2  H1   L1   P1 9  T1 %  X1 ,  \1   `1   d1 *  h1 F  l1 ?  p1 H  t1 +  x1 =  |1 &  €1   „1   ˆ1   Œ1 '  1   ”1   ˜1   œ1 A   1 (  ¤1 D  ¨1 5  ¬1 3  °1 E  ´1 I  ¸1 6  ¼1   À1 7  Ä1   È1 K  Ì1 B  Ğ1 C  Ô1 4  Ø1 G  Ü1 1  à1 >  ä1   è1 ;  ì1   ğ1 	  ô1 L  ø1   ü1 M   2 )  2 0  2   2   2 #  2 
  2   2 :   2 !  @-é¾ ë€½èà-åàŸåààğ¾å,"  Æâ"ÊŒâ,ò¼å Æâ"ÊŒâ$ò¼å Æâ"ÊŒâò¼å Æâ"ÊŒâò¼å Æâ"ÊŒâò¼å Æâ"ÊŒâò¼å Æâ"ÊŒâüñ¼å Æâ"ÊŒâôñ¼å Æâ"ÊŒâìñ¼å Æâ"ÊŒâäñ¼å Æâ"ÊŒâÜñ¼å Æâ"ÊŒâÔñ¼å Æâ"ÊŒâÌñ¼å Æâ"ÊŒâÄñ¼å Æâ"ÊŒâ¼ñ¼å Æâ"ÊŒâ´ñ¼å Æâ"ÊŒâ¬ñ¼å Æâ"ÊŒâ¤ñ¼å Æâ"ÊŒâœñ¼å Æâ"ÊŒâ”ñ¼å Æâ"ÊŒâŒñ¼å Æâ"ÊŒâ„ñ¼å Æâ"ÊŒâ|ñ¼å Æâ"ÊŒâtñ¼å Æâ"ÊŒâlñ¼å Æâ"ÊŒâdñ¼å Æâ"ÊŒâ\ñ¼å Æâ"ÊŒâTñ¼å Æâ"ÊŒâLñ¼å Æâ"ÊŒâDñ¼å Æâ"ÊŒâ<ñ¼å Æâ"ÊŒâ4ñ¼å Æâ"ÊŒâ,ñ¼å Æâ"ÊŒâ$ñ¼å Æâ"ÊŒâñ¼å Æâ"ÊŒâñ¼å Æâ"ÊŒâñ¼å Æâ"ÊŒâñ¼å Æâ"ÊŒâüğ¼å Æâ"ÊŒâôğ¼å Æâ"ÊŒâìğ¼å Æâ"ÊŒâäğ¼å Æâ"ÊŒâÜğ¼å Æâ"ÊŒâÔğ¼å Æâ"ÊŒâÌğ¼å Æâ"ÊŒâÄğ¼å Æâ"ÊŒâ¼ğ¼å Æâ"ÊŒâ´ğ¼å Æâ"ÊŒâ¬ğ¼å Æâ"ÊŒâ¤ğ¼å Æâ"ÊŒâœğ¼å Æâ"ÊŒâ”ğ¼å Æâ"ÊŒâŒğ¼å Æâ"ÊŒâ„ğ¼å Æâ"ÊŒâ|ğ¼å Æâ"ÊŒâtğ¼å Æâ"ÊŒâlğ¼å Æâ"ÊŒâdğ¼å Æâ"ÊŒâ\ğ¼å Æâ"ÊŒâTğ¼å Æâ"ÊŒâLğ¼å Æâ"ÊŒâDğ¼å Æâ"ÊŒâ<ğ¼å Æâ"ÊŒâ4ğ¼å Æâ"ÊŒâ,ğ¼å Æâ"ÊŒâ$ğ¼å Æâ"ÊŒâğ¼å Æâ"ÊŒâğ¼å Æâ"ÊŒâğ¼å Æâ"ÊŒâğ¼å Æâ!ÊŒâüÿ¼å Æâ!ÊŒâôÿ¼å Æâ!ÊŒâìÿ¼å@-é  ã8Ÿå   ãOÿÿë*ÿÿë,Ÿå  ã   ãJÿÿë%ÿÿëŸå  ã   ãEÿÿë ÿÿë  ãÿÿë8ğ Dğ lğ @-é[  ã ŸåŸå0Ÿåáÿÿë, 8 xö @-é ã0Ÿå Ÿå  ã 0“åGÿÿë  ã{ÿÿëˆ4 ü @-é ã0Ÿå Ÿå  ã 0“å<ÿÿë  ãpÿÿëˆ4 ü ğO-é` álĞMâÜŸå € á  ã  –åÿÿëÌŸåÌŸå¨ÿÿëÄŸåÿÿë   ãªÿÿë  Pã;     ã¬UŸå  ã° á„ …å @ ã @å  á á%Ÿå5ŸåHÿÿë pã6  
s Pã(  
	 Pã€ …å  Ê Pã   ª Pã ‹ìÿÿ
 Pãêÿÿ á âÿÿëpå0åp‡â<Ÿå“w'àÿÿë 0Pâ  
 0Óå  SãA   5Ÿå Ÿå  á  “å<ÿÿë  á7ÿÿëÔÿÿê? PãÒÿÿ
  áŸ ë  ã'ÿÿëğ4Ÿå “åËÿÿê  áØ ëÈÿÿê  ãjÿÿë  Pã¿ÿÿ
  ãfÿÿë  â  »ÿÿê¸4Ÿå 0“å Xá 
–çG1 ë0•å€dŸå  Sã"  €0–å Sã-  Š  ã„Ÿå3 áà  Qã«  ø ã¬  ã   
  Yãö  
	  á# ë  Pã  
LŸå  ã   ã©şÿë	 áƒşÿë  ãóşÿë  áâ{şÿë0å 0Óå  Sã p µÿÿê¤ ë â  á p á  ã©şÿë  Pãä  €0–å SãÔÿÿš0•å  Sã"  €0•å SãñŸ—  ê  ¸ ¸ ü ğ  ” Œ ” ¨ ¸ ¸   ã ë  Pãûÿÿ0•å  Sã!  €0•å	 Sã†  

 Sã  
   ã2 ë  Pã     ãlĞâğ½è¢ ë  PãK  @#Ÿå„•å€0•å ‚å SãñŸ—æÿÿê  ¸ ¸ ü ğ  ” Œ ” œ ¸ ¸ Œ ë  Pã  
   ãï1 ë  Pã
  
À2ŸåØŸå  ã   ã @“åIşÿë  á  á şÿë  ã’şÿë›$ ë  PãÑÿÿ
ˆ2Ÿå   ã Ÿå)  ê   ãË ë¾ÿÿê2Ÿå  áˆ0…åe ë0 ã€0…åDbŸå @ ã  ê€0–å
0Câ Sã±ÿÿš\ŸåŒ@…å ëŒ0•å  Sãõÿÿªÿÿê  ã´ ë§ÿÿê  ã± ë¤ÿÿê  ã® ë¡ÿÿê ŸåEşÿë  Pã¯ÿÿ
 0Ğå  Sã¬ÿÿ
Ü1ŸåŸå   ã  ã @“åşÿë  á  ágşÿë  ãœÿÿê   ãq" ëuÿÿêÔŸå0şÿë @Pâqÿÿ
 0Ôå  Sã%  
1 Sã   
  á  ãn ë  Pãgÿÿ
l1ŸåœŸå   ã  ã P“åôıÿë  á  á  áJşÿë  ã<şÿë	  á1 ë  Pãzÿÿ
,1Ÿå`Ÿå  ã   ã @“åäıÿë	  á  á  á:şÿë  ãoÿÿê0Ôå  SãÛÿÿ€0•å0Câ SãñŸ—  ê ˜ ˆ € D AŸå  á  ã? ë  Pã8ÿÿ
ğ Ÿå  ã: ë  Pã3ÿÿ
œ0Ÿå   ãØŸåÊÿÿêÔ@ŸåïÿÿêĞ@ŸåíÿÿêÌ@ŸåëÿÿêÈ@ŸåéÿÿêÊ ë  áÿÿê  á´Ÿå  ã³ıÿë –åıÿëÒşÿêD0Ÿå  á˜Ÿå  ã @“åªıÿë  á  á  á şÿë  ãòıÿë Øñ Ğñ  4 p$ 82 ìñ ˆ4 üñ ˜4 €4   Èò 02 Øó ô ¸F Œó ¤ó üò ó @ô ¼ñ <ó Hó ¬ñ œñ |ñ Œñ ò ,ò  ° ã à ãä  á -å -åÀŸåÀ-å Ÿå0Ÿå­ıÿëşÿëì  ¨ë 0Ÿå Ÿå0à “ç  Rãÿ/«ıÿê4 0  0Ÿå Ÿå0`à Sãÿ/‘0Ÿå  Sãÿ/ÿ/á4 |4     $Ÿå$ Ÿå`àA á¡àÁ°áÿ/0Ÿå  Sãÿ/ÿ/á|4 |4     @-é@Ÿå 0Ôå  Sã€½ßÿÿë0 ã 0Äå€½èœ4 @-é$ Ÿå 0å  Sã  @½èàÿÿê0Ÿå  Sãúÿÿ
3ÿ/áøÿÿê0     @-é  át Ÿåıÿëp Ÿåbıÿël Ÿå`ıÿëh Ÿå^ıÿëd Ÿå\ıÿë` ŸåZıÿë\ ŸåXıÿëX ŸåVıÿëT ŸåTıÿëP ŸåRıÿëL ŸåPıÿëH ŸåNıÿëD ŸåLıÿë@ ŸåJıÿë< Ÿå@½èGıÿêì Dì hì ”ì èì <í í ğí $î hî ´î  ï Pï  ï èï @-éĞMâ @ á â­ ëâ  áC3 ë âù ë  á ŸåÚüÿë â² ëĞâ€½è0ğ 0Ÿå Ÿå ã 0“å"  ãıÿêˆ4 œğ ø@-é7ıÿë@Ÿå  á å ` áP á0Òäƒ0 á³0‘á
ãùÿÿ  á4ıÿë Uá p á  
 áP Ÿå ‡âÄüÿë  Wãø€½ Gâ –å0Ôç „àƒ0 á³0‘á
ãø€½   ã Bä 0Òå –åƒ0 á³0‘á
ãøÿÿø€½è 4 ğG-é ` á á5 ë80–å € áâ+  
AŸå
p ã   ã  á pÄå Äå) ë PPâ'  
€0”å  Sã  
 Sã  Š80–åã-  Ğ0Ÿå 0“å  Sã/  
Ä0Ÿå  “åüÿë¼0Ÿå¬ Ÿå€ ã  “å‘üÿë  Pã#  
„0”å  Sã  
  ãğ‡½è€Hâ Xã  š á€ Ÿårüÿë  ãğ‡½ètŸå  ã‘üÿëlüÿëÎÿÿê	  áºüÿë pÄåPÄå  áğ‡½è	  á´üÿë  ãğ‡½è
  ãïüÿë  ãğ‡½è	  á¬üÿë
  áğ‡½è‚ÿÿëÙÿÿê%ıÿë 4 02 ”4 4    Àğ øC-é ` áTrŸå@åP‚Ÿå á0–å  ã   ã“åP˜åhüÿëPEâ á,"Ÿå 0 á(Ÿå>üÿë”å  Qã  
Ÿå9üÿë[  ã —åoüÿëP”å Uã]  
X  : Uã1  Y  ã ™åfüÿë  á  ãù ë  Pãk   Uã)    á ãò ë  Pã  
´Ÿåüÿë  áT2 ë  Pã)   Ÿåüÿë  á  ë  á  áoÿÿë  PãX  
Cÿÿë|!Ÿå 0ÒåN Sã@  
  Š? Sã  
M Sã6  
  Sã»ÿÿ á  á5 ë  PãG    áÿÿë³ÿÿê  UãÎÿÿ  á ãÈ ë  Pã4   UãÎÿÿ  á*2 ë  PãÕÿÿ
 ŸåïûÿëÒÿÿêm Sã  
+  šn Sã  
y Sãœÿÿ0ÒåĞ Ÿå  Sã  
e Sã–ÿÿ0Òås Sã“ÿÿ0Òå  SãÿÿP ãÒÿÿê ™åN  ãüÿëØÿÿê ™åM  ãüÿë£ÿÿê0Òå  SãƒÿÿP ãÅÿÿêPÒåd0Ÿå  UãÁÿÿ
o Uã{ÿÿPÓå  Uã¼ÿÿ
wÿÿêH ŸåÀûÿëÇÿÿêY SãÕÿÿ
qÿÿê4 Ÿåºûÿëÿÿê   ãøƒ½è”4 02  Èğ Ğğ àğ èğ  4 äğ Üğ Øğ ğO-é$ĞMâ P á´. ë  Pãq  
0•å`•å  Sã  
0“å Sã  
 Sã  &Ÿå€0’å
Câ Sã Qh  š  á²1 ë Pâ  
  ã   ã´ûÿëàEŸå*  ã  å”å åå0 á åÄŸå†ûÿë  VãQ  
8–åâ_  0–å0Câ Sã4  Šp•åEŸåˆ¥Ÿå0•å  ã   ã“å€”å˜ûÿë€Hât%Ÿå á 0 álŸånûÿë—ådŸåkûÿë  áò ë € á  áï ë  Pã  
DŸå áaûÿë  á á¹şÿë  Pã  
 0ÚåµŸå
 Sã0  
? Sã  0Ûå
 Sã.  
èŸåÆûÿëà„Ÿå  ‹à@å á  á¥ ë  PãÎÿÿ
  ê  áõşÿë¸DŸå0”åP•å0ƒâ  Uã0„å  
  áÿÿë P•å  Uãúÿÿ  Vã  
€DŸå0”å0Câ0„å$Ğâğ½èP•å  Uãïÿÿùÿÿêˆ0’å Uá“ÿÿ
  á$ĞâğO½è# ê  Xãªÿÿ
Õÿÿê  á:şÿë¦ÿÿê€•å  á80˜å0å° ë pPâÇ  0˜å  SãT  
 SãD  
ôCŸåì3Ÿå0å  áp”å,1 ë  ãpGâ  ã  á   ã-ûÿë áÈ#Ÿå 0 áĞŸåûÿë0å°˜å Ãå •å	 ZáÌ  
	p á  ê
  ãŠûÿë  šå  Zã8  

  á. ë  Pãøÿÿ
0šå  Sã¥  
 [áxŸå”åp‡â”  
   ãéúÿë
  á1 ë  ã  á   ãûÿë á   áDŸåßúÿë0šå“å  Qã  
0ŸåÙúÿë0šå8 “åâØÿÿŸå  ãöúÿëÑúÿëÓÿÿêàBŸå  á@”åé0 ë  ã@Dâ  á  áëúÿë áÀ"Ÿå 0 áÈŸåÂúÿë0–å SãŠÿÿwÿÿêÄŸå  ã
  áŞúÿë”åŒ"ŸåAâ¶úÿë Wãz  
 áœŸå±úÿë  áæ0 ë  Pãv  ˆŸå«úÿë0å€0“å  Sã  
 Sã!  Š0åã   0”å  Sã†  
T2Ÿå  “å¥úÿëL2ŸåŸå€ ã  “å©úÿë  Pãz  
Æıÿë0å pÓå? Wãr  
  WãZ  
ùúÿë‡p á 0å·0“áãuÿÿ
¼Ÿå  ã
  ãúÿë p á•å  Yã  lÿÿê ™å  Yãiÿÿ
0™å  Sãùÿÿ
	  áƒ- ë  Pãõÿÿ
pWâóÿÿ0å 0Óå  Sã  
XŸåâúÿëP1Ÿå  ƒà0På? SãB  
 ™å ã— ëp™å  WãŸÿÿ
0”å0ƒâ  á0„å°şÿë0”å p—å0Câ  Wã0„åõÿÿ“ÿÿê>  ãTúÿë áhÿÿê  áÿıÿë  á5 ë0˜å Sãˆÿÿš4ÿÿêÀ”å
  áÀå0åb0 ë0å  ã  á  ádúÿëÀå*  ã á 0 áĞ Ÿå:úÿë>ÿÿêÈ Ÿåˆúÿë²ÿÿê?  ãÄúÿë…ÿÿê	p á­ÿÿêŸå  ã
  áQúÿëT0ŸåX Ÿå
 á“å
p áAâ&úÿëpÿÿê	  á;ıÿëÿÿêp Ÿå	 áúÿë	p á™ÿÿê  á3ıÿëÿÿêCıÿë‚ÿÿêæúÿë 4 02 ìğ  Èğ Ğğ Hñ üğ ñ ñ ñ  ñ (ñ <ñ Dñ ”4 4 ñ 4ñ | p@-é @ á- ë  Pãp€½P”å  Uã  
80•åã  
@”å  Tãp€½  áïÿÿë @”å  Tãúÿÿp€½è  á ë  Pã  80•å ãïÿÿ
0•å SãìÿÿŒ`Ÿå€0–å
 Sã  
 Sãæÿÿ
Œ –å0€â  PãŒ0†å  
  á0 ëˆ †å)şÿëÜÿÿê0•å  SãÙÿÿ
80•å  ãÖÿÿ8 Ÿåúÿë00Ÿå •å  Pã     ŸåÆùÿëÌÿÿêŸå  ãæùÿëÁùÿëåÿÿê 4 Pñ Xñ `ñ <0Ÿåà-å “å “å0àŸå Á‘ç œåÀœå  å ‘ç ƒåÀƒå ‘åƒå  Òå Ãåğä45 øF  Pá  
 @â Pã ñŸ—  êœ( ”( Œ( „( „( ¤(  Qã	  
 Qã  
 Qã  
 Qã  
  Qã    àÿ/á  ãÿ/á  áÿ/á   ãÿ/á  àãÿ/á<0Ÿå<Ÿåà-åĞMâ “å ‘å  Rã0“å ’  Ÿ  å0ƒâ  áŸåøùÿëĞâğä45 ˆ4    p@-é	  ãDPŸå @ á` á 0•å8 Ÿå ã§ùÿë Tá  Šò Ôà  •å Ÿåãùÿë Váùÿÿ* •å
  ãp@½èúÿêˆ4 , 8  -é00Ÿåà-åĞMâ 0“åâ  Sãå  
 å3ÿ/áĞâàäĞâÿ/á3  -é0@-éĞMâT@ŸåTPŸåÀâ$0”å  ”å  •åDŸåÀå¾ùÿëå å  •åŞùÿë •å
  ãŞùÿë(0”å0ƒâ(0„åĞâ0@½èĞâÿ/á45 ˆ4 <  -é  å@-éĞMâD@Ÿå$0åÀâ ’å  ”å4ŸåÀå¡ùÿëå å  ”åÁùÿë ”å
  ãÁùÿëĞâ@½èĞâÿ/áˆ4 <  -élŸål Ÿå@-éĞMâÀ‘å 0’å\@Ÿå  \ã0ƒâ 0‚å  ”å œH Ÿ0‘åDŸåƒùÿë0â  áå  ”å0å¡ùÿë ”å
  ã¡ùÿëĞâ@½èĞâÿ/á45 Øâ ˆ4  L  -é\0Ÿå@-éĞMâ “åP@Ÿå  Rã0“å ’D Ÿ  ”å@Ÿådùÿë0â  áå  ”å0å‚ùÿë ”å
  ã‚ùÿëĞâ@½èĞâÿ/á45 ˆ4  L 0‘åğ@-é0CâĞMâ@ á ` áP á SãñŸ—  êà+ à+ l, (, l,  0Òåm Sã+  
n Sã
  
ÄPŸåÄ Ÿåùÿë¼ Ÿå0”å¸Ÿå På  Pã     á4ùÿëĞâğ€½è 0Òå0 Sã”pŸ  
„ Ÿåüøÿë0”åx Ÿå påPåxŸå  Pã     á#ùÿëĞâğ€½èP ŸåïøÿëH Ÿå0”åPŸå På  Pã     áùÿëĞâğ€½è4PŸåÔÿÿê Òå0ŸåpŸåß âX Rãp İÿÿê Pñ ` \ t ˆ T @-é   á0ŸåŸå  “åÿøÿë  ãñøÿëˆ4 l p@-é ` á@ á"  ã á°øÿë  ê\ Ÿå ã  ã0 á­øÿë@…â  á" ãåøÿë PPâ  
 Uàòÿÿ
0 á  á$Ÿåãøÿëíÿÿê á  á!ùÿë á"  ãp@½è–øÿê¤ œ 8@-é  ãP á  ã @ áâøÿë Ÿå,0’å,@‚å  Sã@ƒ 0„åP„å8€½è45 ğG-é` á\@Ÿå  á0p”å40”åP‡à Uá  ª8€”å ˆà	 á  áSøÿë 0 ã0P„å0Èçğ‡½è …â Êã
 á8 ”å\øÿë4 „å € á8 „åîÿÿê45 ğA-éP á 0“å@ á ‚â Rá € á` á  Š 0‘å€Ãç   ãğ½èp„â  ‘å‡p á áEøÿë  Pã  † 0  p…òÿÿ  àãğ½èø@-é @ á 0åP áp“å  á…øÿë  •å0”å@”å`’å@dà@`à  á}øÿë •éOoá¤B á0bà `àoá  á  Tá  Š  :  á áø@½èô÷ÿê  ãø€½è  àãø€½è8@-é P á$ Ÿå@ áñ÷ÿë0Ÿå á  á  “åøÿë Ÿå8@½è:øÿê¨ ”4 ° , Ÿå0 á# Qã@-é @ áŸÕŸÅ!’ç[øÿë á)  ã@½è~øÿêõ ´ À ¨ÀŸåp@-é@ á 0Ÿå œå  Pã    QãP á  ; Tã  
A Tã  
5 Tãp€½ 0•ål ŸålŸå$ “å  å(0“å ’å<øÿëX0Ÿå  •å<“å Rá’@ ƒ<ƒp€½è0`Ÿå   á4Ÿå  –å/øÿë  –å áÇÿÿë –å
  ãPøÿëİÿÿêìF Ì ˆ4 Ü 45 Ø À‘åp@-éÀLâ \ãĞMâ@ á ` áP á  Š  Òån Rã  
` Ÿåä÷ÿëXÀŸå0”åTŸå På  Pã       áøÿëĞâp€½è  Sãûÿÿ$ ŸåÕ÷ÿë Ÿå0”åŸå  Pã     áĞâp@½èü÷ÿêPñ    0‘å Sãÿ/ 0Òån Sãÿ/ğ@-é ` áĞMâD ŸåP á@ á¼÷ÿë4pŸå  Pã p Ç÷ÿë àÕå0”å  áŸå Àå  áÁÜç Àåß÷ÿëĞâğ€½èPñ P p@-é @Ÿå `”å  Vã  
D0”å ”åCâ Qáp€½ˆPƒâ  áa á áu÷ÿë  Pã  „å  
 `Fâ€à0â   ã €çDP„å å ƒä ƒä ƒä ƒä ƒä  ƒåp€½è  ã÷ÿë  Pã0   „å `€`„D0„p€½ Ÿåªşÿë45 \  Sá0@-éĞMâ  
,Bâ BâàÀŸå Rã!ŒY?Œâ ƒà`"’•Ì Ÿ…Ì Ÿå
şÿëÈ Ÿå   ã 0’å0ƒâ 0‚åĞâ0€½è°@Ÿå°0Ÿå<”å 0“å$‘å Qá   
,Bâ€0Ÿå BâYƒâ Rã à  Š!ƒà| Ÿå`R’å  áğıÿë<0”ålŸå$ “å  ‘å(0“å ’å PåXŸå|÷ÿëÛÿÿêD Ÿå, Ÿåãıÿë<0”å8ŸåPŸå$ “å  ‘å(0“å ’åğÿÿê  ãÓÿÿêõ  ˜ Øâ 45 ğF ¸ ˆ4 Ü @-é  ã8÷ÿë  Pã  
0Ÿå   ã ã8 ƒå4ƒå0 ƒå  Àå€½èÆ÷ÿë45 p@-é ` á â@ á'÷ÿë PPâ  
0Ÿå á  á8Pƒåáöÿë 0 ã0Åçp€½èµ÷ÿë45 ğA-é 0 á p á` áà Ÿå ã  ãûöÿëÔ€Ÿå  Öå  Rã
 R)  
 †â P ã ÀÒå@ áP…â  \ã
 \ ‚âøÿÿ  ã0 á ã” Ÿåèöÿë á   ãN÷ÿë  á á  ã0 áàöÿë Pã  
h Ÿå ã!  ã 0˜åÙöÿë
  ã á?÷ÿë 0Ôå`„â  Sã×ÿÿ0 á8 Ÿå ã  ãğA½èÌöÿê ã  ã0 á Ÿå@ áÆöÿëëÿÿê ˆ4 <  4 @0Ÿå0@-éP á0“åAßMâ @ á ã0“å  á  Ÿåıöÿë 0•å  á á   ã3ÿ/áAßâ0€½è¸F @ p@-é P á  á@ áàöÿë Pâ  
  á0 á  ã¡öÿë Pãp€½0Ÿå Ÿå ã 0“å!  ãp@½è˜öÿê?÷ÿëˆ4  ğA-é p á°€Ÿå` á  Öå  Rã
 R"  
 †â P ã ÀÒå@ áP…â  \ã
 \ ‚âøÿÿ á#  ãêöÿë á   ãçöÿë  á á  ã0 áyöÿë Pã  
D Ÿå ã!  ã 0˜åröÿë
  ã áØöÿë 0Ôå`„â  SãÙÿÿğ½è á#  ã@ áÏöÿëòÿÿêˆ4  8@-é P áp@ŸåÅşÿë 0”å  Sã  
 ”å“çƒà Qá8€½  Qã  
”åàÔåÀ”å àÁåá“çå1“çÀƒå P€åRüÿë0 ãH0„å8€½è  Uã8€½ ”å  áõÿÿê45   Pãÿ/P Ÿå@-é 0’å  Sã  
 ’å“ç Pá  ƒ0å @ á  Sã    á@½èöÿê å öÿë  á@½èıõÿê45   Pãÿ/ åLŸå 0 ãà-åÀ ã0€å 0Âåàå  ‘å0Îå Ráàå,0€åà€åÀ€åğ0‘å1’ç Páğàäüÿê45 ø@-é @ áp áQöÿë P á  á `•åŞÿÿëD Ÿå  ã p„å 0’å( „å  Sã  
 ’å1“ç Tá  
  ã 0 ã  „å$0„å 0 ã0„å `…åø€½è45 p@-é ` á0  ãP áöÿë @Pâ  
P„å …âöÿë  Pã „å  
0 ã  á á0„åÑÿÿë  áp€½è  Ÿåıÿëp ø@-é P áX@Ÿå 0”å  Sã  
 ”å“ç  Pã  
 áÀÿÿëø@½èÖûÿê4şÿë ”å ãÀ ”èÕÿÿë á  Vã†ç   ´ÿÿëø@½èÊûÿê45 ğO-é$ĞMâd^ŸåL0•å  Sã  P •å0 ã  RãP0…L0…å0•å<.Ÿå  Sã8>Ÿ 0“0‚T0•å$.Ÿå  Sã$>Ÿ 0“T0‚ 0•å.Ÿå  SãK 
 ’å1“ç  SãG 
©ûÿëø½Ÿå Õå@•åP•åìŸåìŸå+Î‹â 0 ã 0å` áp á  Æå ‹ààÌ*åà áñœá  Qã`†Â  Ú  Öåôÿÿê  aâ¤Ÿå‚  ágàò á p‰å ˆå Öå`…å 0ÆåÅå Bâ& RãñŸ—1 ê”> ”> °> À> Ô> „? °> °: ´A ¼A ğ: ÄA hA pA xA €A °: °> ø: °> ä; °> t< Ä< ø< 0= L= ”: ÌA p= Ğ= ø= ğ< h@ < < È; Ø: Ø: 0•åĞŸå  Sã •å“ÄŸõÿëÀ<Ÿå  ãP …å  “å´Ÿå0’å0ƒâ0‚å$Ğâğ½è  ãP …å@•å Õå á¤ÿÿêˆŸåõÿÿê `˜å p™å Fâ Rã&  Š Fâ Rãà×ç×…  “0‹à‹€HïÓåHÑ… ×å  †€À‹àHÏÜå 0Œà0ƒàH Sã  Ê,ŒŸåB áˆà°?å  Sã  ºŸå €à0Ğç Sá
   ‡âŠâŸõÿë  Pã  0Úç  Sã  ¨?å ã)   á áøıÿëĞ;Ÿå8 •åÌŸå  ƒåÁÿÿê¼+Ÿå8•å0 ã ‚åP0…åC ãºÿÿêŒ+Ÿå@•å Õå ’å ‘å ‚â åP•å^ÿÿêh;Ÿå `“å  Vã¸ 
tKŸå –å  ”å  ƒå `å  Vã  
 •åHõÿë 0•å+Ÿå  Sã   ’“¡şÿë –å~şÿë  ”å³ôÿë `„åŸå–ÿÿê Õå0 á  ã Cä gà p‰å  ˆå VåFå ˜å  ™å0…å ÅåFüÿëØ:Ÿå8 •åÜ
Ÿå  ƒå$Ğâğ½è  ™å ˜å0åÀå;üÿë@•å ÕåP•åÀå0å$ÿÿê¤
Ÿåøûÿë Õå0 á  ã Cä gà p‰å  ˆå VåFå ˜å  ™åAâ €âÛÿÿê  ™å ˜å0åÀå €âAâáÿÿê  ™å å  Ğå Ráˆ 
0åÀå ãØÿÿêÕå0 áø)Ÿå@ áCä  ã gà  ˆå p‰å`VåDå ’åäÉŸå  ã ‘å8à•å  ‚àP …å0…å`Åå å àŒåC ã?ÿÿê0åœ9Ÿå ãÀå à“å´	Ÿå å ‚à å¶ÿÿê ˜å  Qã  
  ™å Aâà€à Ğç	 Pã  P  
	  ê ~å Bâ	 Pã  P    Rã  ˆå áöÿÿ  ã  ™å0åÀåÚûÿë\ •åÀå  Rãä(ŸåàŸ0åX ’@’\   @‘ ÒåP’å»şÿêÜ8ŸåÜŸå  “å0’å0ƒâ0‚åÿÿê Õå`•åP•å±şÿê ãP…å@•å Õå«şÿê  ™å •åB •è àÚå Õåàå  Âåá‘çàåå@â Ráâ  *@Ÿåpå å`‡â €â  à  Qáà  *`åpAâàpå ápGâàÇå à–å@å Pá÷ÿÿŠpå@„â`à ‚à Rá Šàp…åpåÆ  * ŸåUûÿë `˜å p™å Fâ RãĞ  Š Fâ Rã  ×å×…à “ À‹à‹€HÏÜåHïÑ…×çà†€‹à0ŒàHÑå0ƒàH Sã¿  Ê ‡ŸåB áˆà°?å  Sã¹  ºŒŸå à0Ñç  Sá´   ‡âŠâ|ôÿë  Pã¯  0Úç  Sã¬  H7Ÿå¨å	  ã 0“å ã0…å0“åP …å0…åÕşÿ
4'Ÿåû>Hâ0ƒà¬å 0‚å™şÿê•å  •å Õå  áå ™å  Æå !šçaàAâå,’å Šà  Qã¬Ÿå å ‘’  ‚ ”Ÿ‘!š€  à’å, ‚ •å@à  Tá@åˆ  *âà Pá ™ås Š(@’å  aà  Tã¤   Pã2 
@åp á` á Vá`…åP •å#şÿšGâ Fâàñå"‚à  ^ãá‹à Ìê  Qá ‚à‚  áò œáôÿÿşÿê8ŸåWşÿê4ŸåUşÿê0ŸåSşÿê  ™å0åÀå 0Òå 0åpüÿë ãP…å@•å ÕåÀå0åóıÿê ãDşÿêğŸåBşÿêG ã@şÿê à˜å  ^ã   Ó	  Ú  ™å   ãà‚àÒä	 Qã À € € Ráøÿÿ\@•åX …å  Tã<Ÿå+  
  Tá! Ê @dà Tã  Ú` á`Fâ|Ÿå ã0åÀåßúÿë VãÀå0åõÿÿÊ	 Dâ Âã Dâ @bà0åÀå á<Ÿå•şÿêÀûÿë •å ãP •èaıÿë„ç°ıÿêİå@Bâ@…åBå  ‰å Rå ãP…å Åå°ıÿêôŸå„úÿë„$Ÿå Òå@’åP’å©ıÿê”4Ÿå	  ãP …å 0“å0…å0“å0…å*şÿê •å–óÿë  áğıÿê p™åå8$Ÿå`‡à0Ÿå WáP ’å`å  * GâàFâğå"‚à  Qã‹ Ì‘ Pá ‚à‚  áò œáôÿÿ‚àŒàòÑá  Qã‘ıÿÚ`†â`…å‹ıÿê $Ÿå8•å	0 ã ‚åP0…åøŸåËıÿê @â  Pã å  Ú Nâ àà Ñä Qá âåûÿÿ å  ’å,’å Qã0…0‚†  
’å åAâ`à  Qã+  Êpå`åpå@ á  êà”å0åÀå á  Qã®Ğ„åâØòÿëÀå0å  Pã „å  
 @—å å €à”å …åAâbà  Qã  Ê  Zã  
”å ”å`•å  Qã``ààÿÿ„å(Ÿåúÿë
0 á0“åğ ğç`åpå0åÀååóÿëå0å
Qã  ±* £`åpå
` áÀå å @ á 0€åp á  ê  ”å Rãp   0„å0åD2ŸåÀå “å óÿë42ŸåÀå@“è0å •åÀå0åóÿë
–ç0å  á‘å¢ŸåàoòÿëÀå0å  Pã …åâÿÿº@šè`åpå’ç å  
¡‚àA’ç   ã å å”å  ‚à Rá”•!  Š0Áç šå å …å Pã ‘åŒŸå €à0Àå  šå å  ‰å=    áP •åH0…å Bâ…å¢/‚àÂ  á# ‚âùüÿê å  Rã  
  •å•å   ãA’ç¡‚à  ã å, „å×ÿÿêÀ‚à ”å0åÀå åSòÿë åÀå0å „å šå‘å  QãÏÿÿTŸåšùÿë •å0åÀå|üÿë•å  •å0 ã0å •å¡‚àA’çÀå0å¹ÿÿêÜ Ÿå8 ‘å0 ã  ‚åP0åC ãıÿêü Ÿåƒùÿëø Ÿåùÿë
@ á  á   á å Pã  
p á å`‡à Vá`åP‘åªüÿš GâàFâ ğåà  Rã!‹  Ì*’ Pá à‚  áòœáôÿÿœüÿê ”åp á ‘å
`‚àrşÿê45 4 ”4 õ øF ´F è À  ğF      €ö ôF   Üâ     ô   "  !      ô È L ˜ x    Pãÿ/p@-é P át@Ÿåfúÿë 0”å  Sã  
 ”å“ç á  PãÀƒà  
 ”åàÔåâÀƒà àÀåa“ç”åà‚â †å1“çà„åƒå PŒåğ÷ÿë0 ãH0„åp€½è”åÁ á÷ÿÿê45 ø@-éX`Ÿå P–å  Uãø€½@–å•çq…à  Pã  
”ûÿë  Tã 0 ã1…çø€½0å@Dâ  Sã@†åø€½Ô÷ÿë0 ãH0†åø€½èø€½è45  Qã  šø@-épAâ@Ğç  Tã  €à`Qå  Vã   P á0  ãÒñÿë @Pâ  
0 ãp„åP„åP„å`„å `„åp„å`„å(`„å,`„å0„åHûÿë  áø€½è  áø€½è   ãø€½è   ãÿ/á  ŸåŞøÿëü ø@-épâ @ á  áP á³ñÿë `Pâ  
  Uã0 ÁàƒÀ FÂ  ÚÀÓä SáÀâåûÿÿ †à 0 ã0Âå á0Æç  áÀÿÿë 0Pâ  
  ã ƒåø€½è Ÿå¾øÿë Ÿå¼øÿë, X @-é @ á´ñÿë  á  á@½èÕÿÿê0Ÿå “åÿ/á3 0Ÿå “åÿ/á45 0ŸåT “åÿ/á45 0Ÿå  “åÿ/á´F 0Ÿå  “åÿ/áøF 0Ÿå ƒåÿ/á3 0Ÿå ƒåÿ/á45 0ŸåT ƒåÿ/á45 0Ÿå` “åÿ/á45 0Ÿå` ƒåÿ/á45 ø@-éh`Ÿå P–å  Uã  
@–å•ç  Pã p   
ûÿëq…ç_ÿÿë@–å1•ç  Sâøÿÿ  áñÿë   ã  †å †åD †å †åL †åP †å †åT †åø€½è45 Hñÿêñÿêñÿê@-éúÿë0Ÿå   ã ãPƒå\ ƒåX ƒå€½è45 @-éÚMâĞMâxŸå @ áåğÿë  Tã?oá£2 á 0   Sã  
 0Ôå/ Sã  
L Ÿå%ñÿë  Pâ  
0â0å8Ÿå0 á åzñÿë åŸåÏğÿëÚâĞâ€½è   ãÚâĞâ€½èĞ+ | „ 0Ÿå “åÿ/á45 0Ÿå0“å  Sã “ Ÿÿ/á45    PãøC-é¸Ÿå¸qŸå p ´Ÿå²ğÿë PPâf  
0 á¤Ÿå ã  ãäğÿë˜1Ÿå @“å  Tã	  
 0”å ”å  Sã  á|Ÿ|Ÿñÿë @”å  TãõÿÿlŸåæğÿëhaŸåhŸå  Pã       áñÿëT1Ÿå @“å  Tã   
0”å  Sã  
<Ÿå< “å  Rã	  
0’å Sã    êÀ’å \ã  
  ’å  Rãùÿÿ 0 ã0“åğ ğç ’å  Rã  
 0’å0Câ Sã  š@”å  Tã  
0”å  Sãâÿÿ  ã0 á ã¼ Ÿå£ğÿë  áşğÿë á€ ŸåÈğÿë   ãøƒ½è’å  Yãêÿÿ
 ™å©ğÿë ™å„Ÿå  Pã 0 0   áÒğÿëT Ÿå ğÿëhŸå  Pã       áÊğÿë ã  ã0 áH ŸåƒğÿëÓÿÿê  ãøƒ½è4 Œ ´ Ä äâ ì ô Ø ˜ ü Ôâ   , @ L @-é @ á@  ã„ğÿë  Pã  
 0 ã@  ã „å 0Àå0„å  „å  á€½èñÿë@-é @ á å  Pã   
.ğÿë 0 ã0„å 0„å€½è  Qãÿ/ø@-é P ápå` á  áˆğÿë @ á  á…ğÿë 0•å  „à@€â Tá  Š  á áø@½èFğÿê á  á+ğÿë @…å á p á …å  áø@½è<ğÿê -é@-é'ÜMâ$ĞMâ',â0â'Ìâ, ‚â0ÀŒâ0å @ á0 á  ’å å$ŸåÀåğÿë  áåÍÿÿë'Üâ$Ğâ@½èĞâÿ/á'   åÿ/á@-é3ğÿë  Pã€½Éğÿë@-éÎïÿë  Pã€½Ïğÿë0Ÿå  ƒåÿ/á3 @-é Ÿåğÿë0Ÿå  Pã  €½è\ T @-é Ÿåğÿë0Ÿå  Pã  €½èØ ˜ ,0Ÿåh“åd “å  Qãd ƒåÿ/  ’â    â    Ráÿ/ÿ/á45 0 Ÿåh’åd0’å  Qã €àd ‚åÿ/ 0“â0   â    Sáÿ/ÿ/á45 0Ÿåd “å  â  ÿ/á45 0Ÿåh ƒåÿ/á45 <0å  Sã    ê 0“å  Sã  
 “å Rãùÿÿ “å  Rã    ê80‘å8â0 ’å  Rã  
’å  Qãöÿÿ80å6Ãã€0Ãã8ƒã80€åÿ/á 0 ã0“åğ ğç@-é ã @ á  ãiïÿë 0Pâ  
  ã ƒè€½ègğÿë8@-é P á@ á  ã ã]ïÿë 0Pâ  
 Pƒå@ƒå8€½è[ğÿëp@-é ` áP á  ã ã@ áPïÿë 0Pâ  
 `ƒåPƒå@ƒåp€½èMğÿë@-é @Pâ  
 0”å0Câ SãñŸ—	  ê(R (R àQ ìQ ìQ ìQ ôQ  ”åîÿÿë „å  á€½èL0Ÿå ”å Ráùÿÿ@0Ÿå  “å¿ÿÿë  Pâôÿÿ
 á  ã@½èĞÿÿê ”åÜÿÿë „å ”åÙÿÿë „å  á€½è 3 àâ p@-é ` áP á  ã ã@ áïÿë 0Pâ  
 `ƒåPƒå@ƒåp€½èğÿë  Pã  á  
  Qãÿ/  á  ã°ÿÿê  áÿ/á  Pã  á  
  Qãÿ/  á  ã¦ÿÿê  áÿ/á  Pã8@-é @ á  
  ãVïÿë PPâ1  
  ”å”å ”å À”å0 áÀLâ £è \ãñŸ—  êpS pS ”S ¬S ¬S pS \S  •å| Ÿåìîÿë  áùîÿë @ ã  á8€½è0”å@ á0…å  á8€½è ”å×ÿÿë …å ”åÔÿÿë@ á …å  á8€½è ”åÎÿÿë@ á …å  á8€½è ”é@ á  á …é8€½èºïÿël @-é @Pâ€½ ”å0Aâ Sã  Š  ã3 áX ã  
  ê ã  
@”å  Tã  
 ”å0Aâ Sã3 á
  ŠX ã   ãñÿÿ
 ”åãÿÿë ”åáÿÿë  á@½èºîÿê Ÿå©îÿë  á@½èµîÿê€½è€ p@-é @Pâ  
 0”å Sã  
 Sã   ”åõÿÿë „å ”åòÿÿë0”å P“å Uã „å6  
 På Uã  
  áp€½è ”åæÿÿë „å ”åãÿÿë0”å P“å Uã „å  
 På Uãğÿÿ`åÄ Ÿå Vá  
P ‚â Váéÿÿ  áªÿÿë ”å¨ÿÿë 0 ã` „è0„åáÿÿê`åˆ Ÿå Váóÿÿ
P ‚â VáÚÿÿxîÿë0”å “è „è  ásîÿëÓÿÿê`“åP Ÿå Vá
  
P ‚â VáØÿÿáÿÿê`“å0 Ÿå Váİÿÿ
P ‚â VáÁÿÿ  áaîÿë0”å “è „è  á\îÿë¼ÿÿêp3 8@-é 0å  Sã8€½  ‘å  Rã8€½ P á  “å@ á@â Qã  š  ’å  Rá  
Bâ Qã  š  á‘ÿÿë  …å  ”åÿÿë  „å8€½è  á áT  ë 0•å  ”å  “åëÿÿê  á á  áL  ë 0•åëÿÿêp@-éĞMâ 0å à‘åÀ á Sá å å  
   ãĞâp€½è0Câ SãñŸ—øÿÿêW W W ÜV ÜV ŒV ÄV 0å ‘å `àoá  áìÿÿêå0œå Qáçÿÿ0å œå `àoá  áâÿÿê‘å åÕÿÿëŞÿÿêïşÿëpPŸå å  åëşÿë ál`•å  å â£ÿÿë å 0å Sã  
 @ ãÿÿë  åÿÿël`…å  áÉÿÿê 0å  “å Rãôÿÿ@“å0å@dàOoá¤B áïÿÿê45 ø@-é ` áp á@ á À—å  á á àœå ^á  
 0”å ƒâ P“å Uá	  ïÿÿë @”å@„âğÿÿêŒâ  áéÿÿë p—åp‡âêÿÿê ^ã U  
  á á•ÿÿë  Pãø€½ˆ Ÿå  —ål0’å0ƒâl0‚ååşÿë  ”åãşÿë Vã  
 Vãø€½\ Ÿå/şÿë  ‡åP Ÿå,şÿë  „åø€½è œå“å Ráãÿÿ0ŸåP Aâ  Rá RŞÿÿø€½è Ÿåşÿë  ‡å Ÿåşÿë  „åø€½è45 À3 p3 øC-é P á` á@ á À–å  á á àœå ^á  
 0”å ƒâ p“å Wá	  ïÿÿë @”å@„âğÿÿêŒâ  áéÿÿë `–å`†âêÿÿê Sáøƒ½0Nâ Sã}  š UãO  
 Uãøƒ½ P–å p”å  á áEÿÿë  Pã‰   0•å Câ Sã Røƒ½ˆ À—å Lâ \ã Røƒ½ˆ Sã•å  
 \ã —å˜  
 Qáøƒ½ ‘å Bâ Pãøƒ½ˆàLâ Câïoáoá®â á  á á•   \ã SÇ  
 \ã       Pãº   \ã SÒ  
 Rãøƒ½ Sã£  
 Sãøƒ½  ^ã¼   \ãøƒ½ •å4Ÿå RáÓ  
P Câ  RáÉ  
 ÀCâ Ráøƒ½ —å RáÑ  
  Ráøƒ½  ãÌ#Ÿåøıÿë P áE  ê P–å p”å  á á÷şÿë  Pã)   0•å Câ Sã Røƒ½ˆ  —åBâ Rã Qøƒ½ˆ Sã•9  
 Rã —åE  
  Qáøƒ½ ‘åÀ@â \ãøƒ½ˆ PãR  
 SãE  
 Rãøƒ½ —å  ’å Rã Søƒ½Ÿå|ıÿë P á  ê  á á  á_ÿÿë|ÿÿê  áåıÿë P á  Uãøƒ½  –åşÿë  ”åşÿëØŸåjıÿëÔ"Ÿål0’å0ƒâl0‚å  †å P„åøƒ½è  áÓıÿë P á  Uãøƒ½  –å
şÿë  ”åşÿëŒŸåìÿÿê •å åÀAâ Qã \øƒ½ˆå½ÿÿê  ‘å Bâ Rã Pøƒ½ˆ‘åhÿÿê Àå \ãøƒ½ å´ÿÿê  ’å Pãøƒ½ ’åaÿÿê0•å 0“å Sã Røƒ½ºÿÿê‚Ÿå—å Yáhÿÿˆÿÿê Sãøƒ½ Rãøƒ½ •åà1Ÿå Rá`  
  Câ  RáV  
PÀCâ Ráøƒ½ —å Rá^  
  Ráøƒ½  ã¤!Ÿånıÿë P á©ÿÿê \ãøƒ½ —å •å8Àå ãøƒ½8À’å ãøƒ½  Rá9  
  á^ıÿë P á«ÿÿê€—åTŸå  Xá  
P @â  Xá@ÿÿXÿÿê4Ÿå€•å  Xá;ÿÿSÿÿê0•å —å8 “å ã=ÿÿ
8 ’å ã:ÿÿ
 Rá  
  ãCıÿë P áÿÿê€•åè Ÿå  Xáäÿÿ  áëüÿë P áˆÿÿê —å Rá+  
 0Câ Ráøƒ½6ÿÿê0—åP Bâ  Sá#  
  Bâ Sáøƒ½  ã Ÿå(ıÿë P áuÿÿê€ ŸåÔüÿë P áqÿÿê —å Rá  
P0Câ Ráøƒ½©ÿÿê0—å  Bâ  Sá  
P Bâ Sáøƒ½  ã< Ÿåıÿë P áLÿÿê  ã  Ÿåıÿë P áGÿÿê  ã Ÿåıÿë P áTÿÿêÀ3 p3 45  3 ğA-é ` áp á€ á@ á à˜å  á á 0å  á Sá  
 À”å0Œâ Pœå Uá	  íÿÿë @”å@„âïÿÿê â0 áçÿÿë €˜å€ˆâéÿÿê  á áéıÿë  Pãğ½ —å  Qã  
  á  ˜å¢üÿë  ‡å  ”å6ıÿë Vã
  
 Vãğ½8 Ÿå‚üÿë  ˆå, Ÿåüÿë  „åğ½è  ˜åïÿÿê Ÿåyüÿë  ˆå Ÿåvüÿë  „åğ½èp3 À3 @-é @Pâ
  
 0”å Sã  : Sã  š Sã  0”å0“å Sã	  
  á€½è ”åíÿÿë „å ”åêÿÿë „å  á€½è ”å0Ÿå Rá   0   „0„íÿÿêp3 ğG-é @Pâ p  ` € x  
 0”å Câ Rã  Š Sã  
 Sã.  
 Sã  
0 á  áğ‡½èP”å 0•å0Câ SãñŸ—öÿÿêXa xa €a ¤a ¤a ` a  ”åÜÿÿë „å ”åÙÿÿë 0”å Sã „åâÿÿ ”å0å Sãâÿÿ0”å°QŸå Sá  
P Eâ SáL  
PP…â SáØÿÿ 0 ã  ã0„å  „å0 áÓÿÿê ”å0å SãÎÿÿ0”å`QŸå Sáñÿÿ
P Eâ SáA  
PP…â SáÄÿÿ0 ã 0„åüÿë 0 ã0„å0 á „å½ÿÿê`•åqŸå Vá7  
 0Gâ Vá;  
P0Gâ Vá²ÿÿ  á{ëÿë0 ãˆ …è0 á­ÿÿê €„å  ã•åôûÿë „å p…å`…åšÿÿê „åöÿÿê •å  ájëÿë  áhëÿë  Zã
  

@ áÿÿê  ábëÿë  •å0 á Rã      …å‘ÿÿê 0 ãÿÿêåh ŸåGëÿë  ã 0 ã0„å$ „è0 á†ÿÿêåH Ÿå>ëÿëPP…âôÿÿê  áIëÿëP`Fâ0 ãH …è0 ázÿÿê  áBëÿë0 ãH …è0 átÿÿêp3 À3 ˜ Ğ  0‘åp@-é@ á `“åĞMâ  VáP áp  
  ’å `’å  Váu  
 Sá.  
  “å Pã-  
 Pã)    á áéÿÿë  ”å
üÿë  á  ã ûÿëBÿÿë å  •åüÿëâ 0 ã0!å â0â å  ã×şÿëPå  Uã  
 åZüÿë å åWüÿëPå å0å  Sã  
  “å Rã9  
 å%üÿë å#üÿë  á!üÿëĞâp€½è  á á½ÿÿë  ”åŞûÿë  á  ãtûÿëÿÿë å  •å×ûÿëâ 0 ã0!å â0â å  ã«şÿëPå  Uã  
 å.üÿë å å+üÿëPå å0å  Sã  
  “å RãÓÿÿ “å˜0Ÿå RáÏÿÿ  ”åõûÿëˆ ŸåEûÿë„ Ÿål0’å0ƒâl0‚å  „åÅÿÿê`“åd0Ÿå VáÁÿÿ  ”åçûÿëP †âğÿÿêƒâ„ÿÿë ”å  áâ  áÿÿëĞâp€½è ‚â{ÿÿë  •å  á ‚â ávÿÿë 0”å  •åÿÿêÀ3 p3 45 ğ@-éĞMâ 0Pâ å	  
p@Ÿå P ã` álp”å  “ålP„å @â Rã  šlp„å  áĞâğ€½èâ  áõüÿë0åâ  á  “åVÿÿël –å0å  Rã  áîÿÿ
×ûÿë 0 á ååÿÿê45 8@-é @PâP á  
 0”å0Câ SãñŸ—  ê e  e Œe le le ¼e Xe @”å dàoá  á8€½è0”å Uá  
@”å dàoá  á8€½è@”å  Tããÿÿ  á8€½è ”å áÚÿÿë  Pã  
  ã8€½è   ã8€½è ”å áÑÿÿë  â  8€½è8@-é @ áP á  Tã&  
 0”å0Câ SãñŸ—  êDf (f `f f (f 0f 0”å Sá  
   ã8€½è ”å  eàoá  á8€½è ”å áâÿÿë  Pã8€½@”åáÿÿê0”å Sáîÿÿ80Ÿå ”å  Câ Pá P     8€½è  á8€½è0”å Ÿå `àoá  á8€½èÀ3 p3 ø@-é 0Pâ` áP áJ  
 À“åÀLâ \ãñŸ—  ê4g „g Üg h h g  g   UáL  
  @â UáP @â[  
  UáM  
   ãø€½è  á“å  áø@½èÆúÿê “å ã  á@ áÚÿÿë ã  á p á ”åÕÿÿë$1Ÿå Uá  
P0Câ Uá<  
 Vã0  
  áø€½è “å ã  á@ áÆÿÿë ã  á p á ”åÁÿÿëÔ0Ÿå Uá+  
P0Câ Uáëÿÿ   á á  ãeúÿë @ áåÿÿê0“å Vã` `   Sã´ÿÿ  áDúÿë Vãø€½  ê Vãt Ÿå¸ÿÿ
  Uá  
  @â Uá  
P @â  Uá¸ÿÿ  áø@½è¥úÿê á  ãø@½è:úÿê  áŸúÿë  áø@½è  ã4úÿê   á á  ã<úÿë @ á¼ÿÿêø@½è!úÿêÀ3 ø@-é @ á På` á Uã'  
 Uã  ‰úÿë p á  á†úÿë  Wã   á p   
  Pã  
 á  á"úÿë p á  áæşÿë á P á[ûÿë  Pã  
  á¯úÿë P ã  áø€½è  áªúÿë P”å Uã  
@”å 0”å Sãûÿÿ  áø@½èdúÿê åÏÿÿë á P á ”åËÿÿë  Uã  
  Pãçÿÿ
 á   áø@½è  ãúùÿê P áàÿÿêğA-é @Pâ ĞMâP á` á  
 p”å  á á€ á§ïÿë  Pã  Ú  á  ãd"Ÿå5ÿ/á p”å0Gâ SãñŸ—…  ê|j ¸j ôj k `k k Ôk  j   á  ã$"Ÿå5ÿ/á”å  á ‘å5ÿ/á  á  ã"Ÿå5ÿ/á”å  á ‘å5ÿ/á  á  ãì!Ÿå5ÿ/á  á ”å}ïÿë  Pã  Ú  á  ãÌ!Ÿå5ÿ/á Ğâğ½è ”å á  á0 ã½ÿÿë  á  ã¤!Ÿå5ÿ/á ”å á  á0 ã´ÿÿëåÿÿê ”å á  á0 ã®ÿÿë  á  ãl!Ÿå5ÿ/á ”å á  á0 ã¥ÿÿëÖÿÿê  á  ãH!Ÿå5ÿ/á ”å á  á0 ã›ÿÿëÌÿÿê”å ‘å  Rã     !Ÿ5ÿ/á!Ÿå  á  ã5ÿ/á”å  á ‘å5ÿ/á»ÿÿê”å ‘å  Rã     Ğ Ÿ5ÿ/á  á  ãÈ Ÿåíÿÿê”å  á ‘å5ÿ/á0”å  Sã¨ÿÿ
  á  ã  Ÿå5ÿ/á ”å á  á0 ãmÿÿëÿÿê”å ‘å  Rã     \ Ÿ5ÿ/á•ÿÿê  á  áXŸågéÿë  á  á  ã5ÿ/áŒÿÿê  á á8 Ÿå5ÿ/áÿÿê < Ôğ @ Ä ( 0     $ 8 D  ø@-éT4ŸåP“å  Uãø€½@•å ` á  Tã<tŸåY  
80”å ãå  
,Ÿå ã  ã0 áÎèÿë0”å0Câ SãñŸ—ò  êp ôo Üo Äo Øl ôŸå ã	  ã0 á¿èÿë<@”å  Tã  !  ê @”å  Tã  
À”å Uáùÿÿ ”å0Bâ SãñŸ—¾  ê|o $p Lo àn Èn ¸n Dm ŒŸå ã  ã0 á¤èÿë ”åxŸå  á 0 ãÿÿë
  ã áéÿë @”å  Tãàÿÿ @•å  Tã  
  áÍèÿë @â à„à 0Ôç
 Sã     ã  Îå @•å @â à„à 0Ôç
 Sãøÿÿ
  á  áŸåÅèÿë0•å  Sã,  
P á@•å  Tã¥ÿÿ@•å  Tãõÿÿ
0”å Sã¥  
 Sã
  ÄŸå ã  ã0 áoèÿë  á”å²ïÿë
  ã áÒèÿë0”å  Sãâÿÿ
  “å Rã–  
 ã
  ã0 áxŸå^èÿë 0 ã ”å\Ÿå  áÀşÿë
  ã á¿èÿë0•å  SãÒÿÿ 0•å  SãÏÿÿP•å  Uão  ø€½è,Ÿå ã	  ã¡ÿÿê ã  ã0 áŸåCèÿë†ÿÿê ã
  ã0 á Ÿå=èÿë 0 ã ”åØŸå  áŸşÿë0”å  Sã•ÿÿ
  “å Rã$  
0 á ã  ãÄŸå-èÿë ”åœŸå  á 0 ãşÿë‡ÿÿê  ã0 á ãœŸå"èÿë  á”åeïÿë á
  ã…èÿë_ÿÿê0 á ã	  ãpŸåèÿë  á”åYïÿë0”å  Sãpÿÿ
  “å RãÚÿÿ0“å Sá×ÿÿiÿÿê ã  ã0 á,ŸåèÿëCÿÿê ã
  ã0 áŸåşçÿë=ÿÿê ã  ã0 áŸåøçÿë7ÿÿê ã
  ã0 áğ Ÿåòçÿë1ÿÿê  áäŸå0èÿë1ÿÿê  áØŸå ”å+èÿëÿÿêÌ Ÿå ã	  ã0 áãçÿë 0•å  Sã_ÿÿP•å  Uãÿÿ
0•å  Sãöÿÿ
0“å Sãóÿÿíÿÿê ã  ã0 á| ŸåÑçÿëÿÿêt Ÿå ã	  ãZÿÿê0“å SáeÿÿDÿÿê¸F À3 X ˆ è 85  ( D Ü È ¼ < ô °   ” | p ü d 0 ¨    á 0 ã Ÿåşÿê85   á 0 ã Ÿåşÿê, 0å Sã  
  áÿ/á80å  ã  
40å Sã0 öÿÿ
0Ÿå 0“å  Sã0 0   áÿ/áèF  Pã0Ÿ• ƒ • Ÿ…ÿ/á P < å  Pãÿ/0å Sã    ê0å Sãÿ/  å  Pãùÿÿÿ/áÿ/á< å  Pãÿ/0å Sã    ê0å Sãÿ/  å  Pãùÿÿÿ/áÿ/á å Rã  
40å  Sã  
 Bâ Rã  š   ãÿ/á80å  ã40å  
 Sã  
| Ÿå  ’å  Rã    Sã    áÿ/á Qãíÿÿ
LÀå \áêÿÿ*8 å¢" á Sã      Rã   Qá   ƒ  “ Qá   3ÿ/á  Sãíÿÿèÿÿê Aâoá  áÿ/áèF 8@-é0å0Câ SãñŸ—l  ê t  t 0s ´s ¬s  @Ñå- TãP@ÑPXçÿët0¯æs0¿æƒ0 á  å³ ’á âp ÿæ  Pã8€½0 Tã 0ÕåS  
 á  ês0¿æƒ0 á³ ’á âp ÿæ  Pã8€½0ñåÿ0âs0¯æôÿÿ  ã8€½è @Ñå0 TãE  
Pâ8çÿët@ïæ 0åt@¯æt@¿æ„@ á´ “á
 âp ÿæ  Pã8€½@Õä  Tãôÿÿêÿÿê 0ÑåM0Câ, SãñŸ—.  ê¬s ¬s Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt ¬s Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt ¬s ¬s Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt Ğt ¬s   Sã©ÿÿ
   ã8€½è0Ñåß0âX Sã@Ñ³ÿÿê@-é0Bâ Sã  š  Rã  
   ã€½è{ÿÿë€½è  ã€½è0å0Câ Sã  Š0å Sã  
  : Sã  @ Ÿåÿ/á åÿ/á@-é0@Ÿå  ”åK ë ”å$0Ÿå$ Ÿå ‘å  Pã    €½è Ÿåÿ/á àâ `. äì ø@-é @PâS  
` ã P ã ”å0Aâ SãñŸ—H  ê v (v Pv lv °v ìv äu  ”å* ë0”å0“å“V%à  áø€½è ”ååÿÿë p á ”åâÿÿë Pá  1–P%à  áø€½è ”åÛÿÿë p á ”åØÿÿë Pá  !–P%à  áø€½è@”å†0 á  TãP…à `fâÒÿÿ  ê ”å ë ”å ë ”å¦ÿÿë p á ”å£ÿÿë  á  áæÿë  PãÔÿÿ†P…à  áø€½è ”å÷  ë ”åõ  ë ”å•ÿÿë p á ”å’ÿÿë  á  á æÿë  PãîÿÿÂÿÿê Ÿåæÿë  áø€½èP ã¼ÿÿêT 8@-é P á<@å  Tã  3  ê @”å  Tã  
0”å Sãùÿÿ ”å—ÿÿë  Pã „åôÿÿ
 ”å  Rã  
 0’å0Câ Sã$  š 0 ã40“åğ ğç<0•å  Sã    ê 0“å  Sã  
 “å Rãùÿÿ0“å  Sã  
 “å  Pã8€½4 å  Rã  
  ê “å  Pã  
4 å  Rã8€½0“å  Sãöÿÿ  á8€½è 0 ã0“åğ ğç0’å4 “å  RãÄÿÿ
õÿÿê8€½è8€½èp@-é ` á<@å  Tãe  
 P ã0”å  Sã  
 ”åVÿÿë  Uá P 1 „å @”å  Tãôÿÿ UãF  
40–å8 –å Sá  
<0–å+‚ã  Sã4P†å8 †å  
 “å 0“å  Rã’‚  Sã÷ÿÿ8 –å  ãp€½@ –å  Pã    
4ÿÿë Pã  D0–å  Sá  
8 –å<0–å+‚ã  SãD †å8 †å  
 “å 0“å  Rã’‚  Sã÷ÿÿH –å  Pã  
ÿÿë Pã  
L0–å  Sáp€½<0–å8 –å  Sã+‚ãL †å8 †åp€½ “å 0“å  Rã’‚  Sã÷ÿÿp€½è0–å SãP ´ÿÿd0Ÿå P“å  UãP P ®ÿÿê –å Pã  
 Pã    ÛÿÿêP á¥ÿÿê80–å  ã  
4 –å PãÓÿÿ
0Ÿå  “å  Pã    ÍÿÿêèF @-é @Pâ    ê @”å  Tã	  
0”å Sãùÿÿ ”åÛşÿë  Pã „åôÿÿ
  á€½è   ã€½è@-é @Pâ    ê @”å  Tã	  
0”å Sãùÿÿ ”åÈşÿë  Pã „åôÿÿ
  á€½è   ã€½è  Pãÿ/8 å€ ãÿ/ 8ŸåğO-é á0à SáLĞMâ @ á  <0å&Âã  Sã8 €å   0 ã0“åğ ğç 0“å  Sãùÿÿ
 “å Rãùÿÿ0“å  Sã    
  “å Bâ Rã   ƒ “•Úÿÿë8 ”åp„â0”å —è€À‚ã0Câ` á è8À„å SãñŸ—á  êÌ{ Ì{ p{ p{ p{ @7Ÿå“å‘“å  ã<Â€0ƒ80„  á ÿÿë0”å€„å Sã„å  
0Câ SãñŸ—µ  ê ~  ~ Ü{ Ü{ Ü{ ä6Ÿåd€“åh“åçÿÿê40”å  Sã  
80”å¬ƒãã8 „åÁ  < ”å~ÿÿë  Pã  
0å  Sã  
  “å Bâ RãÖ  š80”å  á#2 á Yã 0 0  Sã€„å„å 0”å Sã§  
 SãP ™  < ”åvÿÿë  Pâ•  
  á ”å  ãáäÿë0šå € á á “å á‘ ë0 á  XáÙà   á}  ª”åPâ Qã  áğŸğŸ5åÿë  áåÿë8P”å „å  á á  ãäÿë  Pã  
<0”å…ã  Sã8„å  
 “å 0“å  Rã’‚  Sã÷ÿÿ5Ÿå `“å Vá 
8P”å ã á+  
<0”å  Sã  ^  ê 0“å  Sã[  
 “å Rãùÿÿ “å  Pã  
 å  Rã  
ã  
40’å  Sã80’<ƒ80‚8”ã  
8’å<0’åã  Sã8‚å  
 “å 0“å  Rã’‚  Sã÷ÿÿ8”å å  Pãàÿÿ
ãÁ8„ã  
  áôÿëLĞâğ½è8P”å4”å  ã0 á  
 Qã=  
  Qã  
<…ãã80„å1  L ”å  Rã<ƒ80„ ãµ  
D ”å  Zã    RãP   Yá 1 Yãm  
8P”å  á%2 á Yã 0 0dÿÿê0šå á “å
 ë0 á Pá	Óà   áxÿÿº8P”åÿÿê 0 ã0“åğ ğç ”å 0 ã „å0„åLĞâğ½è
P ãXÿÿê#2 á Yã 0 0€”åHÿÿê0”åL ”å Qá 1 !Íÿÿê<0”å  Sã    ê 0“å  SãŠ  
 “å Rãùÿÿ0“å  Sã  
  “å Bâ Rã¹  š 0 ã0“åğ ğç “å80”å  Zã¼  
<ƒã
  á80„å¼şÿë8P”å€šå  á%2 á Yã 0 0ÿÿê@”åH ”å.úÿëğRŸå ã
  ã 0•å ° áàŸåÿãÿë
0 á  á  •åĞŸåaúÿëÌŸå ”å  •å8äÿë
0 á  •å@ ”å¬ŸåXúÿë  ã 0•å ã Ÿåìãÿë  ááôÿëL ”åÿÿê0”å Sãl  
 Sã€„„ûşÿ8P”å0 ã ã€„å  á0„åÿÿ
<0”å  Sã  )  ê 0“å  Sã&  
 “å Rãùÿÿ€“å  Xã	    ê  áÕıÿë40•å€˜å  Sã80• 
  Xã  
P˜å  Uãóÿÿ
 àá80”å¨
â ”å
 àá 
à  Rã8 „å  
40’å  Sã    áyıÿë  Pã   á „0”å „åÆşÿê 0 ã0“åğ ğç< ”å,şÿë PPâ  
80”å •å<ƒã80„åıÿë•å	 PáJ  :L ”å;ÿÿê 0 ã0“åğ ğçLŸåLáŸåÀ°å  \ã  
0œå Sã  
8 œå<0œå+‚ã  Sã8 Œå  
 “å 0“å  Rã’‚  Sã÷ÿÿ Àœå  \ãëÿÿ Páæÿÿè0Ÿå –å8P”å  ƒåÍşÿê8P”å  ã  
4”å Yã%2 0  „şÿ
°0Ÿå 0“å  Sã  %2 á0â  á ã{şÿê0 ã€„å0„åŸşÿê0“å0“å Sá%2 0  0    ámşÿê  á#2 á Yã 0 0gşÿê •å½üÿëL ”å  áíşÿê   3 ¬ ´ àâ ˆ4 l 85 x |& üF Ğâ èF 8@-é P á@ áçıÿë0•å Sã
@   
 Sã@  •å  á  ã8@½è:ãÿêˆŸåˆ Ÿå@-é0±å  Sã  
 “å Rã8 “€ Â8 ƒ 0“å  Sã÷ÿÿ  QáòÿÿPŸåd ‘åh ‘å0‚â  Pãd0å  
  ’â   0“â0  Rá   
0ÿ/á0Ÿå  “å  Pã€½@½è¸ıÿêüF Ğâ 45 àâ p@-é @ á`åP á Vá  
•ûÿë  Pãp€½8 ”åã  <0”åA+‚ã  Sã8 „å  
 “å 0“å  RãÀ’ÀŒÀ‚  Sã÷ÿÿ8 ”å0Eâ?oá£2 á¢2à   VáP„å   
´ÿÿë  ãp€½è<0”å  Sã    ê 0“å  Sã  
 “å Rãùÿÿ “å  Rã  
 0’å0Câ Sã  š 0 ã@ƒåğ ğç 0 ã0“åğ ğç ’å8’å<0’åã  Sã@‚å8‚å  óÿÿê 0“å  Sãğÿÿ
 “å Rãùÿÿ0“å  SãĞÿÿ
 “å4’å  Qã8’8‚0“å  SãöÿÿÆÿÿê8@-é P á@å Tã  
  : Tã    á  ãœÿÿë 0”â0   Sá  š  á ã•ÿÿë0Tâ0   Sá  š  á ãÿÿë0Tâ0   SáêÿÿŠ@ ã  á8€½è á…ÿÿë  á8€½è @ ã  á8€½è@ ã  á8€½è PãğO-é p áĞMâÓ  
!0 ã á2 ã 0åPTŸå°Gâ  á0 áDdŸåPå
° á   ã  á€ ãP áp á@»å  Tã  
 ”å Rã	  
8”å4Ÿå0à  Sã   RãF  
 Bâ RãC  š @”å  Tãïÿÿ [áêÿÿ  åPå(ÿÿë Zã
p á  å´Ÿ  
0±å  Sã    êã
  &‚ã8 ƒå 0“å  Sã
  
 “å Rãùÿÿ
8 “å ãòÿÿ  ãòÿÿ 0“å  Sãôÿÿ Váçÿÿ € ã ã@µå  Tã    ê @”å  Tã  
0”å Sãùÿÿ
80”å¨âöÿÿ ãôÿÿ
  áÕüÿë Wã/  
  áOòÿë @”å  ã  Tãíÿÿ VáäÿÿĞâğ½è WãñŸ—  ê˜‡ ü‡ Œ‡ ¬‡ 6â0„   
€„åã8„å  ã¬ÿÿê 0 ã0„åfâÿë”2Ÿå ”å Rã“0ÁàÀ? áÁ2càd ã‘à 0càJ  
 Yá€„Å8”å ãéÿÿ
  ã˜ÿÿê0 ã0„åäÿÿê0”å Sã
  ¼ÿÿ< ”å  Zã  5  ê  šå  Zã2  
0šå Sãùÿÿ0šå  Sã°   
°“å  [ã  
 ° ã  ê “å  Rã  
0“å°‹â  Sãøÿÿ3âÿë áº ë šå  Pã  
 å  Rã  
 À ã  ê åÀŒâ  Rã
  
80’å Qá€0Ãã8ƒã‚€‚ „80‚å å  Pãğÿÿ80”å  ã€0Ãã8ƒã80„å‚ÿÿê 0 ã0“åğ ğç Uá „Å³ÿÿÊ  å …à Sá0 ³0„µ­ÿÿê Ÿå¾áÿë  Pã'ÿÿ
 0Ğå  SãP @ "ÿÿ
â
  ãcáÿëd Pã 0 á  Š å0…ä@„â 0Ğå: Sã  
 Tã  
 0Ğå  Sãîÿÿ Tã"  
 Tã  
 Tãÿÿå	0 á©/‰àd SãÂ  á  å	 bà áÿÿÚÉáÿë"0 ã 0€åp Ÿåwáÿë  ã´áÿë Tã €â  
  Pãáÿÿãÿÿê0å åå á0ƒà  åd SãñşÿÚéÿÿê0å å áƒà  å	0 áõÿÿêüF Ğâ €  …ëQ¼ ø@-é @ á0åP á0Câ SãñŸ—  êL‹ L‹ ğŠ ˜Š Š ø@½èúÿêúÿë  Pãø€½< ”åçûÿë @Pâi  
  ã  á  ãRáÿë0”å ` áp á “å ãşÿë  Vá0×àS  ª   ãø€½èúÿë  Pãø€½< ”åÑûÿë @PâS  

  ã  á  ã<áÿë0”å ` áp á “å
 ãìıÿë  Vá0×àéÿÿº0”å
 ã<  ê 0ÑåM0Câ, SãñŸ—áÿÿê,Œ  Œ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ Œ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ ,Œ  Œ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ èŠ Œ  ãø@½è…ùÿê  ãø@½è‚ùÿê ãø@½èùÿê0”å ã “å§ıÿë Pá0Ñà  £   ³ø€½è  ãø€½è0åğA-é0Câ Sã1  Š 0ÑåM0Câ, SãñŸ—d  ê                      ü                                                             ü P á @ áCÿÿë `Pâ'  
8 ”åã  <0”åA+‚ã  Sã8 „å  
 “å 0“å  RãÀ’ÀŒÀ‚  Sã÷ÿÿ  áÌàÿë0”åp”å Sã€€â  
  Wã  
  á áGàÿë  Pã	  
  áàÿë  Pã%  
 „å áŒàÿë  áQàÿëKıÿë  áğ½è ãğA½ènıÿê ãğA½èkıÿê  ãğA½èhıÿê ` ã  áğ½è 0Õå0 Sã  0Õåß0âX SãÙÿÿ
 ˆâ~àÿë 0Pâ  
  á0 ãx  ãÀä0„å ÃåÚÿÿêáÿëğA-é P áŒqŸåcúÿë  —åûÿë€1Ÿå< •åh@“åa“åÖúÿë0•å €Pâ	  
 Câ Rã8  š˜å  Qã  
  ‘å Bâ Rã9  šL•å Tá  !  1 Rã  
0Câ SãñŸ—B  ê       áğ½è  Rã.  
 Rãì Ÿå  ğ½è8 •å  ã    —å ’å  Rã  0Câ SãñŸ—*  êü ü     Sã  
0Câ SãñŸ—  ê      ˜å}ùÿë ˜å Pá  :@ á0•åÅÿÿê€‘å  XãÂÿÿ
  á°úÿë`˜å0•å½ÿÿê8 Ÿåğ½è ˜åkùÿë0•å @ á¶ÿÿê Ÿåc8e58376db865ff3fe356879283326c1  usr/bin/tree
395435fa9997747ba2edc60df59930ca  usr/share/doc/tree/README.gz
312b255ce10210cef109a19c7484ee05  usr/share/doc/tree/TODO
5c09d6a22c6bba530467ed3ef90e279c  usr/share/doc/tree/changelog.Debian.gz
9d40e0496166ea170603afe2a953815d  usr/share/doc/tree/changelog.gz
e51a3c84c3b33325acc683347bfb4d3f  usr/share/doc/tree/copyright
9b7471de88786eee0299fe21a85f012b  usr/share/man/man1/tree.1.gz
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ğ½è Ÿåğ½è Ÿåğ½èàâ 3  `. äì  øO-é `Qâp á P á,  
  á5ùÿë€•å  Xã  á"  
  áàÿë°•å
 ã   á  á@àÿë  Yã @ á  
	  áàÿë Šâ  Šà  Tã  á@dàÿë  „à
@€à Tá   Š á  ásïÿë  Vãø½0–å  Sãø½  á	  ádŸåøO½è‡ïÿê á  áfïÿëóÿÿê€å  Xã	  
  áñßÿë°•å
 ã á   á  áàÿë @ áÙÿÿê áøO½èUïÿê  áŸåRïÿëÚÿÿêĞ ğ 4 åL å  Rá   “  ƒÿ/áø@-é pPâ` áT  
 ×å  Qã  TQŸåT1ŸåA“ç  Tã  2  ê á0  0   Sã   @”å  Tã*  
 ”å  Pãùÿÿ
 áEßÿë  Pãõÿÿ  Vã80”åíÿÿ ã0  0   Sãíÿÿ
  áø€½è ×å  Rã  n Qã)  
y Qã-  
m Qã'  
¼0Ÿå¼ÀŸå ‡â  ê á ğå0#à  Rãœàùÿÿœ ŸåœPŸå’‚à¢& á•àPeàÇÿÿê  áªßÿë p áP  ãtßÿë @Pâ  
  ãP  ã¨ßÿëL0Ÿå8 ”å   ã“ç`€áAƒç‚ „è8`„å „å  áø€½è4 Ÿåø€½è0 Ÿåø€½èP áçÿÿê$ Ÿåø€½èôßÿë•   G Å“ UpHÒõ&  p3  3 À3 À0Ÿå0@-é P áAßMâ   ãp Ãå  á$ ãmßÿë @Pâ   
 á eà Ÿå©ßÿëZßÿëÀ„âà á å   ê Îä  ÜåP áÀŒâ‚0 á³0‘á£1 á0â_ Rã0ƒ  Sãóÿÿ á 0Îå  átÿÿë @ á¿ùÿë  á_øÿë  á  ŸåßÿëÙÿÿê á Ÿåßÿë ŸåAßâ0€½è45 ¤5 @-éXĞMâP ŸåÇÿÿë @ áH Ÿåßÿë  Pâ    
0 á4Ÿå4 Ÿågßÿë  ã(Ÿå  áîŞÿë0Ÿå  Pã    XĞâ€½è
 | „ ¤6 8@-é PPâ6  
 ÀÕå  \ã  Ğ ŸåĞ0ŸåA“ç  Tã  
0”å á  Sâ  
˜Şÿë  Pã  80”å ã  
 @”å  Tãòÿÿ  á8€½è Õå  Rã  n \ã  
y \ã  
m \ã  
…â`0Ÿå` Ÿå  êÀ á ñå0#à  RãàùÿÿDŸåD Ÿå‘#à¡& áà bàÒÿÿê0 Ÿå8€½è, Ÿå8€½è( Ÿå8€½è  á8€½è•   G Å“ UpHÒõ&  p3  3 À3 ğO-éĞMâ 0 ã @Pâå0åá 
xíÿë 0Pâ0å½ 
¨8Ÿå0å0åX ã`ƒâS á   ã€ …ãŒÈŸåƒ± áˆxŸå0å„ˆŸåàá†a á   á @ƒå$ ƒå( ƒå„å@·å  Tã  
À”å \ã  
8 ”åÀLâ€ã	  à ã € \ã8 „å  Š „à å  Pã   
EŞÿë „à €å €å @”å  Tãèÿÿ WáãÿÿøwŸå ` ã @ ã`å å@Şÿë pã  

 Pãâ  á0â.  ïåÿë  PãÓ  º@„â   ãâ  á0âçåÿë  PãË  º  Tã`åÍ  
 tãË  
å  Öå|Ÿå$0‘å# Rã0ƒâ$0å  
VŞÿë  Pã @ XŸå@ QŞÿë  Pã    
tŞÿë   á á  áŞÿë  PãL  
 0Öå
 Sã SÈÿÿ
Ÿå¦äÿëÅÿÿêÀåÿë  Pã¤  º@„âÂÿÿê:Şÿë€†â  Pã @ äŸå@ 4Şÿë  Pã    
WŞÿë   á  á áùİÿë  Pã¯ÿÿ°Ÿå(Şÿë  Pã	    
KŞÿë €â  †à  ãJŞÿë  Pã£ÿÿ
 0 ã0Àä€Ÿå
  ãŞÿë  Pãœÿÿ0å`Ÿå  Sãê  Şÿë  Pã	    
5Şÿë €â  †àÿÿë Pâ 
8 ™å áï  0™å0Câ Sã‚  Š0å ‚á0ƒâ  ãƒ1‰àƒå8 ‰åz  êğŸåøİÿë  Pã     
Şÿë  †à= ãŞÿë €Pâtÿÿ
@ˆâ  ã  á Èå
 ãŞÿë  Pã  
 På Àå Rã@0åŸå  Sã  Şİÿë  Pã     
Şÿë  †àÛşÿë Pâê  
80™å á¦  0™å0Câ SãñŸ—M  ê› Ğš œ™ œ™ › T™ Çİÿë  Pã     
êİÿë  †à  ãşÿë0å  á  Sãåÿÿ8 å0 ã á0€åŠ   Øå" Zãp  
  Zã
  
Ïİÿë á  å  ê ñå  Zã  
Š0 á³0’á
ãøÿÿ
0 ã0‰å	  á áVöÿë  Pã0œ   Sã"ÿÿ
 á ™å€Ÿåşãÿëÿÿê0å   ã@ƒà Då`å  áRİÿë åÚİÿëT4Ÿå  “å  Pã  
#øÿë   ãĞâğ½è å80™å ã‚!‰à0ƒá‚å80‰å8 ™å  ãÿÿ
<0™å  Sã    ê 0“å  Sã  
 “å Rãùÿÿ@“å  Tã  
 0”å0Câ Sã @ ƒ@”•0åƒ á ‰àšå Qã[  
 QãQ  
0ƒâƒ!„à ’å  Qáƒ1„à  1ƒåàşÿê 0 ã0“åğ ğç0Øåm Sãx  
y SãËÿÿ
n Sã0å°ÿÿ0ƒâ8 ™åƒ1‰à  ã ‚áƒå8 ‰åÇÿÿê0Øåğÿÿê0Øå" SãÂÿÿ@ˆâ€ á 0Øå  Sã  h  ê0øå  Sãe  
" Sã\ Sùÿÿ" Sã  á¥  

  áYİÿë€ˆâ á   á
  áëÜÿëêÿÿêÌŸå™åãÿëTÿÿê'İÿë  Pã	    
Jİÿë €â  †à  ãkıÿë0å  á  Sãÿÿ8 å0 ã á0€åÿÿ
tŸå™åxãÿë8 ™å
ÿÿê€„à ˜å  Pã  0åˆå0ƒâ¨ÿÿê€„à ˜å Pãy  
0å0ƒâ¡ÿÿê  á9İÿë å80™å‚!‰à0ƒá ‚å80‰åxÿÿêŸå™å[ãÿëšå ˜ååÿÿêä1Ÿå  “å  Pã   
‡÷ÿë  ãĞâğ½è åd åhå0‚â  Qãd0€åişÿ
  ’â   0“â0  Rácşÿ
1ÿ/áaşÿê å80™å ã‚!‰à0ƒá‚å80‰åSÿÿê0å SãVşÿ
hŸå4ãÿëSşÿê`ŸåÌÜÿë\AŸå  Pã @   áëÿë 0Pâ0å1Ÿå0şÿd “åh“å  á0å  Qã0‚âd0€å  
  ’â   0“â0  Rá   
1ÿ/áü0Ÿå 0“å  Sã»ÿÿ
<P“å  Uã  ¼ÿÿê P•å  Uã¹ÿÿ
0•å Sãùÿÿ •åşõÿë  Pãõÿÿ
0•å  “å Rãñÿÿ0“å “åMıÿë @ áaëÿë 0Pâ0åéÿÿ
ˆŸå  ã   ãgÜÿë áäâÿëãıÿê 0 ã 0Èååşÿê™å` Ÿåíâÿë8”å0åÁá8„å0ƒâšå ˜åÿÿê45 ,U üF Ğâ Pñ `  ô $  àâ    ˜  H  \ T üF Ø p  ğO-éAİMâ,ĞMâ€ŸåjÜÿë|2Ÿå ã  Pã  ­ıÿëlŸåEÜÿë  Pãm  `¢Ÿå`’Ÿå`â å@ºå  Tã!  
0”å Sã  
  áîöÿë80”å
ã  €”å  Xã  
ãh  
ã0”å0Câj  
 SãñŸ—  ê`Ÿ `Ÿ ,Ÿ ,Ÿ ,Ÿ   ázõÿë”åéÛÿë  Pãh   @”å  TãİÿÿÄ1Ÿå Zá×ÿÿ8  ê ”å 0”å Ráôÿÿ
 pØå€ˆâ  WãV  
7ÜÿëdPâÀ á  å1Òç_ Sã/0 0ÌäpØä  Wãøÿÿ°àÙá0Ùå  á`Ÿåi/ ã°àÌá0Ìå.Üÿë pã-  IÜÿë 0å SãB    á/€ ã p ã  ê ‹â €Ëå/ ã5Üÿë á  á °Pâ  ã  
 pËåìÛÿë  Pãòÿÿ
  áğŸå;Üÿë  Pãíÿÿ
0 ã0åÜ ŸåÛÛÿë  Pã   åAİâ,Ğâğ½è  ãAİâ,Ğâğ½è  á Ÿåi/ ã Üÿë pã  
cÜÿë @”å  TãŠÿÿ«ÿÿêã±ÿÿ @”å  Tã„ÿÿ¥ÿÿê Sã«ÿÿŠ0”å  Sã¨ÿÿ @”å  Tã{ÿÿœÿÿêdPâÀ á°ÿÿê€”åŸÿÿê0 ã0å0Ÿå ZámÿÿÎÿÿêØ ˜ ¼  üF Ì  Ğâ A  í  Ğ  ğG-é  ãğqŸå @ ád —åh0—åd‡å Sá Rs    á  ãüüÿë €Pâ€ H  ¼QŸå¼aŸå¼¡Ÿå á@¹å  Tã  
0”å Sã  
  á>öÿë8 ”å”1Ÿå0à  Sã  ã7  ã  
„>å0ƒâ„>
å @”å  Tãëÿÿ YáæÿÿP‘Ÿå@µå  Tã  
0”å Sã  
8 ”åã  
  ã0Câ  4”å  Qã  „å(Âã  Qã8 „ Sã"  š @”å  Tãêÿÿ Váåÿÿ(0—å  Sã0 ,  
d —åh—å0ƒà  Qãd0‡å  
  ’â   0“â0  Rá   
1ÿ/á  áğ‡½èãÇÿÿ
0”å0Câ Sã  Š ”å0”å Rá¿ÿÿÁÿÿê  á”åâùÿë  Pã×ÿÿ80”å„.å8Ãã€0Ãã ‚â80„å„.	åÏÿÿê ”å”å÷Úÿë  Pã¯ÿÿ
«ÿÿê 0Ÿå„>å 0“â0 Íÿÿê3ÿ/á‰ÿÿê45 üF Ğâ ,U   ğC-éAßMâ p á_ÛÿëP€â  á;Ûÿë @PâB  
 0 ã 0Äå  á$ ãXÛÿë `Pâ5  
 á gà  á”ÛÿëEÛÿëÀ†â á  å   ê Áä  Üåp áÀŒâ‚0 á³0á£1 á0â_ Rã0ƒ  Sãóÿÿ  á 0Áåüÿë `Pâ  
ªõÿë  áJôÿë € á4Ûÿë ` á  á1Ûÿë  á  á.Ûÿë	`†à`†â `†à Uá  : á  áğÚÿëÌÿÿê4€Ÿåïÿÿê  á áÒÚÿëP á @ áóÿÿê á  áäÚÿë  áAßâğƒ½èÛÿë ğA-é P á®ÿÿëxpŸå `—å  Vã € á  
@ á  ê @”å  Tã  
  á”åŠÚÿë  Pã÷ÿÿ  á›Úÿë  áğ½è  ãÜÚÿë 0Pâ  
   ã 0‡å ƒå  á ƒå€ƒå `ƒåğ½èjÛÿëäâ @-é @ áéÿë` Ÿå  Pã ‚å  
  ãÇÚÿë 0Pâ  
DŸå   ã  ƒå ƒå  á 0åÉÿÿë,0Ÿå  ã €å  ƒå€½è á ŸåbÚÿë  ãÒÚÿëLÛÿë45 Üâ ğF Ø  øC-é¸ÿÿë ` á  ãªÚÿë PPâZ  
hqŸåhAŸå   ã 0—å ”å Sá  …å …å —1“0å –å^éÿë41Ÿå  Pã ‡å?  
,‘Ÿå ã‡äÿëäÿë €™å 0”å P„å@˜å 0…å  Tã  
P˜å  á”å.Úÿë  Pã  
@”å  Tã÷ÿÿ0 ã€†å `‰å0†åøƒ½è —å¼0Ÿå  Rã  
’å “å0 á° Ÿå!Úÿë 0™å@“å  Tã	    ê ”å á BâŒ ŸåÚÿë@”å  Tã  
 0™åP”å“å  á	Úÿë  Pãğÿÿ ”å á ‚âP ŸåÚÿë  ãxÚÿë “å@ŸåŞÿÿê0“å —å  Sã0 Ÿå“$Ÿ0–åûÙÿë  ãkÚÿëåÚÿë45 Üâ ğF ! X!  ì  ø@-é P ácÚÿëÀ á €â 0Üå  Sã  
" Sã\ S+  
 Œâ  ê" Sã\ S&  
À á0Òä  Sãøÿÿ0Úÿë @Pâ0  
À`Ÿå"0 ã°0Äá  Õå  Rã  
" Rã\ R       
À…â   ã  ê" Sã\ S  
p á0Üä ‚â  Sã÷ÿÿ á  á{Úÿë  á4ÚÿëX0Ÿå°0Óá°0„á  áø€½è €âÀŒâÊÿÿêp á á  ámÚÿë  á&Úÿë°0Öá  ã áP‡à°0„á  ádÚÿëÑÿÿê•Úÿët! x! ğA-é@ á‘å ` á Qãp áP á  
 Qãğ½  Qã  
  á!óÿë À—å á0 á   á  áğA½èÿ/á  áóÿëœÿÿë À—å á0 á € á  á  á<ÿ/á  áğA½è“Ùÿêğ½èøC-é‹öÿë¸ŸåÈèÿë\ıÿë  Pã  
  ãøƒ½è Ÿå ŸåzÙÿë `Pâøÿÿ
”ŸåŒŸåuÙÿë pPâ[  
„ŸåxŸåpÙÿë €Pâ  áP  
pŸåãâÿë  áhŸåàâÿë  á`Ÿåİâÿë\QŸå\‘Ÿå@µå  Tã  
0”å  á Sã  
?ôÿë80”åã  
À”å á  \ã$!Ÿå0 ã  á
  
¦ÿÿë  á á!Ÿå0 ã¡ÿÿë  á áü Ÿå 0 ãœÿÿë @”å  Tãâÿÿ	 Uáİÿÿ  áÕÙÿë  áÓÙÿë  áÑÙÿëÈ Ÿå„ÙÿëÄ0Ÿå  Pã   Œ Ÿå–Ùÿë  Pã±ÿÿ¨ ŸåzÙÿë¤0Ÿå  Pã   ` ŸåŒÙÿë  Pã§ÿÿˆ ŸåpÙÿë„0Ÿå  Pã   0 Ÿå‚Ùÿë  â  øƒ½è±Ùÿë  á¯Ùÿë  ãøƒ½è  á«Ùÿë”ÿÿê¼! Ü! 4 è! ü! d4 l4 t4 üF Ğâ `4 h4 p4 " |!  " œ! Ø ˜  0Ğå  SãZ  
ğC-é4ĞMâ  á  ã â£Ùÿë  PãT  XŸåX‘Ÿå p á P á ` á@¸å  Tã%  
0”å Sã  
80”åÀâ  à”å  ã ^â0â â  
 ÀåÙÿë  Pã   Uá  á  ºp‡â‡‡à áûØÿë  Pã)  
 ` á  á¶óÿë…0…à åå!†àP…â ‚éA†ç @”å  TãÙÿÿ	 XáÔÿÿ  Vã@   
  á á  ãˆ0ŸåoÙÿë …â €à  áÙÿë @Pâ  
  Uã  „ 0   
–ç0ƒâ‚ä  Ráúÿÿ 0 ã1„ç   ê @ á  á´Øÿë âåØÿë  á4Ğâğƒ½è   ãÿ/á   ã4Ğâğƒ½èüF Ğâ œ. 80åğO-é â4ĞMâ p á’  
ã#   ãh   ãV  
 â á-àÿë<@—å  Tã  e  ê @”å  Tãb  
0”å Sãùÿÿ ”å  Rã  	  ê80‘å:ƒã0ƒã80å ’å  Rã  
’å  Qãõÿÿ80—å  á:ƒã0ƒã80‡å‰ ë80—å0Ãã80‡å  Pã 
 ”å  Rã  
0’å  Sã  
  ê0’å  Sã  
8“åÁã8ƒå ’å  Rãöÿÿ  Pã 
80å  ã  
<0å  Sã  -  ê 0“å  Sã*  
 “å Rãùÿÿ “å  Rã  
 0’å0Câ Sã š0`à?oá£2 á˜Ÿå, ‘å  ’å  Rã, å  ‚  ê:ƒã0ƒã80€åO ë8 —å Âã8 ‡å  Pã0`à?oá£2 á 0   Sã   4Ğâğ½è â áÆßÿë<0—å  Sã   0 ã0“åğ ğç 0“å  Sãùÿÿ
 “å Rãùÿÿ0“å  Sã    
  “å Bâ Rã   ƒ “•sÿÿëÔ#Ÿå,0’å 0“å  Sã,0‚å    ƒ  Pã0`à?oá£2 á 0 Õÿÿê  ã € L  ”3Ÿå,P“å  Uã  ˆ3ŸåˆŸå ã 0“å&  ã.Øÿë  á4Ğâğ½è P•å  Uãóÿÿ
0•å SáùÿÿL³ŸåP“Ÿå` á   ã0•å@•å  SãÀ À“  Tã80–å<@–0 ã  
<@–å  Tã	  
 ”å  Zã  
  ê0”å  Sã7   @”å  Tãùÿÿ Xá5  
0•å  Sã=  
–åà”å 0”åàNâ  Qã	  ^ã “å$0”å´BŸ•Àœåá„¬âŸ…ğê•  \ã	À   ›å@èÀå”Ÿå2ØÿëP•å  Uã9  
`•åÉÿÿê â áPßÿë<0—å  Sã  ˆÿÿê 0“å  Sã…ÿÿ
 “å Rãùÿÿ€“å  Xã¢ÿÿ
 0˜å0Câ Sã € ƒ€˜•œÿÿê Xá  áÉÿÿ 0”å  ›åŸå “å$0”åÀåØÿë0•åÀå  SãÁÿÿ0•å  Sã  
à–åœå 0”å  ^ã	à   Qã	  “å  ›å$0”åå àå´Ÿåø×ÿëP•å  UãÅÿÿ€1Ÿå, “å0â Ráp1Ÿå~ÿÿ å  Rã, ƒåP‚yÿÿê  áBÿÿê80–å ã1  
à–åœå$0šå  ^ã	à   Qã	  “å  ›å(0šåå àå4Ÿå××ÿë£ÿÿê ”å  á  Rã  
0’å  Sãôşÿ 0 ã  áÿÿêP”å  Uãùÿÿ
0•å  Sãöÿÿ
  á  êP•å  Uãêÿÿ
 •å  Pãçÿÿ
]  ë 0Pâöÿÿ
  áÔşÿê0’å Wá÷şÿ  á0 ã÷şÿê  ã  
à–åœå$0šå  ^ã	à   Qã	  “å  ›å(0šåå àåhŸå£×ÿëoÿÿêà–åœå 0”å  ^ã	à   Qã	  “å  ›å$0”åå àå0Ÿå”×ÿë`ÿÿê45 ˆ4 (#   4" l" <" ”" ´" Ü" # @-é @Pâ!  
 ”å0Aâ SãñŸ—  êH³ H³ 8³ ³ ³ `³ ³  ”å@½è^şÿê ”å\şÿë  Pã€½ ”å@½èWşÿê@”å  Tãæÿÿ  ê ”åàÿÿë  Pã€½@”åöÿÿê ŸåäÖÿë   ã€½èP# p@-é P áĞMâ  á âŞÿëH •åÏÿÿë `Pâ	  
œ Ÿå  á,0’å 0“å  Sã,0‚å    ƒĞâp€½è<@•å  Tã  ñÿÿê @”å  Tãîÿÿ
0”å0Câ Sãøÿÿš ”å@åµÿÿë  Pã  0”å Sãğÿÿ80•å ãíÿÿ0”å  á0å©ÿÿë  Pã æÿÿ
 ` áÖÿÿê45 8@-é P á(  ã@ áüÖÿë  Pã  
|Ÿå| Ÿå 0 á À ãÀƒä ‘å0ƒâ ’å TáÀƒäÀƒäÀƒäÀƒäÀƒäÀƒä Àƒå0 €é €å$ €å
  
< ”å  Rã< „    ê  á 0’å  Sãûÿÿ  ‚å8€½è8€½èr×ÿëğF 45 8@-é 0 áP á  ã áÏÿÿë ã @ á  á÷ÿëıæÿë „å8€½èD0Ÿåà-åcßMâ  ã  á€.CåÖÿë  ã( Ÿå÷ÿëÀ ã‚â8 åÀ€å*‚ã8 €åáÿÿëcßâğä,U h# 0Ÿå€>Så  Sãÿ/åÿÿê,U ğG-é` á4qŸå á  á|Nå € á”å¤ÿÿë P á
  á…å@…å÷æÿë  Vã …å  
µÖÿë 0Öåƒ0 á  å  á³0’á
ã'  Ü Ÿå0”å Tá  S  
  áÈŸå
İÿë|Nå Xã  
P„å`…å  áğ‡½è@”å  Tã  
0”å  Sâùÿÿ
#çÿë0•å  Sã á À á  á  ã0   
  \ã  
½æÿë 0 á@”å0…å  Tãëÿÿ|Nåâÿÿê  á@ŸåçÜÿë 0Öå  ™åƒ0 á³0’á
ã  
0öåƒ0 á³0’á
ãúÿÿ|NåÇÿÿê,U ¸F ”# x#  å  Pãÿ/ 0å0Câ Sã •   ƒÿ/á @â Pã0Ÿ• ƒğ
• Ÿ…ÿ/á 4"  -é$ å@-éĞMâD@Ÿå(0åÀâ ’å  ”å4ŸåÀåfÖÿëå å  ”å†Öÿë ”å
  ã†ÖÿëĞâ@½èĞâÿ/áˆ4 < 0Ÿå Ÿå Ÿåƒâ@‚å|> å<0‚åÿ/á¸F 45 ,U ÿ/á Ÿå0Ÿå|å €â@ ƒå< ƒåÿ/á,U 45 0Ÿå< “å@ ƒå ’å< ƒåÿ/á45 8@-é@0Ÿå|^å@•ådæÿë  Tã  
  Pã  
 á   á  ãNæÿë @ á@…å8€½è @ á@…å8€½è,U t0Ÿå|å ‘å0’å  Sáÿ/  Sã ‚ÿ/ ’åPÀŸå  Rã   Sãà-åĞMâ<ÀŸ•<0Ÿ…1Œ ;• Pã(ÀŸ•( Ÿ… Œ •  å  áŸå™ÿÿëĞâğä,U   P ¨# 0 á   ã(ÿÿê<0Ÿå@-é|Nå”å  Qã  
  Pã  
   á  ãæÿë  á„å€½è  á„å€½è,U 0 á  á  ãÿÿêp@-é P á  á@ áîåÿë0 á  ã   á  áp@½èÿÿêø@-é @ á0  ã³Õÿë ÀPâ"  
ˆàŸåˆ Ÿå0 á   ã@å|pŸå ƒä  å0ƒâ<`åPå Tá ƒä@Àå ƒä|Îå ƒä ƒä ƒä ƒä ƒä ƒä ƒä  ƒå@Œå`Œå(PŒå$ Œå Àå  
 á	  ãø@½èÌÿÿêø€½è&Öÿë45 ğF ,U  @âğA-é Pã ñŸ—  ê@» » dº Hº ğ½è¬1Ÿå|>å “å80’å6ƒã80‚åğ½è1Ÿå@ á|nåP–å8 •å<0•å*‚ã  Sã8 …å	  
 “å Rã  7  êÀ“å \ã4  
 0“å  Sãùÿÿ á  ã`şÿë ã4qŸå € á  á£õÿëåÿë —å ˆå  ã”åÿë 0 á  áPƒå 0‡åMÕÿë Pâ8  
  áğA½èvşÿêì Ÿå 0’å  Sã   
Ô Ÿå|.å ’å Sáğ½Ì ŸåğA½è×ÛÿêÄ@Ÿå°PŸå 0”å  Sã  
 “å|>å¬ Ÿå0“å“åÌÛÿë|>å0“å 0„åğ½è “å  Rã  
 0’å0Câ Sã  š 0 ã0“åğ ğçP0Ÿå|>å0“å 0‚åğ½è0’å á@“å  áÅÔÿë  Pãğ½  á  á0ŸåğA½èÏşÿê  á  á ŸåğA½èÊşÿê,U Ôâ üF ($ àâ à# L$ t$ ğO-éMŞMâœoŸåĞMâ 0–å  Sã! ŒŸå 0 ã€ á0å 0å|?Ÿå @â àã° á^â  ƒåÈ0 ãPå0å0å°€Äá1Câƒ0 á ‹à Tá6 :pkà</ŸååÇp á Qáp‡âÂ Š0ƒâ ‚â Sá0 !0åƒ á ‰à€  á €âŞÔÿë  Pâ¶ 
‡@ á  á á™Ôÿë0‰â0Ãã0Šàq á  á  áå‘Ôÿë  â [á 0 á  
 å  á„Ôÿë0å  –å@DâpGâ  Rã@ŠàPƒàû  Iâ	Šà	 Tá® *
° á0å Xã— 
l.Ÿåˆ0 á³p’áw¿æZ yã\®Ÿ  
H>Ÿå  “å pã{ 
  Pã Ú@>Ÿå PáÀ Ã0>ŸÕ,®ŸÅ  ƒĞ  Ñ 0–åLÉPÕ  Sã‡ >Ÿå‰à Yá  Š.Ÿå‰0 áó’á Yáâ 
0Šà˜“Så  Yãä  
	0Šà  –åØrSå  Rã0gâ1•ç0åƒ 
0Iâk SãñŸ—©  ê4Ç  Ï äÎ ØÎ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ÈÎ ¼Î hÎ ˜Æ Î |Æ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ €È (Æ È ¸Ç $Ï ĞÀ ĞÀ Ø¿ ÜÅ pÆ èÊ Æ àÌ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ (Æ 4Ê |Ë tÊ ĞÀ ĞÀ tÉ XÇ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ @Ç ÌÆ Æ ÔÉ ĞÀ ĞÀ ĞÀ ĞÀ ĞÀ É ÈÈ ĞÀ œÍ ˆÍ ĞÀ ĞÀ ĞÀ ĞÀ LÍ ĞÀ ĞÀ ĞÀ @Í ĞÀ dË ĞÀ ĞÀ ĞÅ ĞÅ ĞÅ ĞÀ ĞÀ ÜÅ pÆ Î hÈ Ç ĞÅ Ï ĞÊ LË èÍ XÉ ÜÅ Àå  áÀå9ÔÿëÀå0@â Sã   á å.  Š‹     ­Zûs7’şÙóW ¼[%éJ¤${s©8—l¨—Å¬$2$µ‰×Î®ÀÄz8f$1µµû}İ æAÊIöêR•²F£Ÿ_7ØÿğRüñÌä›B/WåñÇ¨‘z@ìÇâä«¯ş[ôÄ«ã“Wb¾ÓR=(q*?ª‚ÒTLh±…²ªxP	óÜl¥­È³,äZàÏE¡”°fQ>ÊB}-6¦±Ì°/Ñ¶,ô¼*•Ğ¥Yrd
±6‰^l˜«,Q…(WJ”ªX[aüñööN¼U™*d*ÆÕ<Õ±¸Ö±Ê¬gÓˆ]©œ3!ÚrI\L=âÒ€²,µÉ¾Jc¾ª°ø¯Â!â¡0îÎû²$æarÚx 7"•e³·ÿY4WM„Î˜üÊä¸Õ
DqÏGÎ•¨¬ZTé!ÓÀjñãpv5º›‰Áí;ñã`2ÜÎŞ}ÕåÊ`:q´ô:O5Hãn…ÌÊ®À$n.&gWØ38^gïpq9œİ^L§âr41LfÃ³»ëÁDŒï&ãÑô¢/ÄTcŠ)üŠ¤¬-3Q¥Ô©mnÿ*¶à0MÄJÂn
+RÄ°²ßÖ"S‘©É–|W¬nÄùµĞ‘™òP<¦Sš]ıòşFÇ‡b˜ÅıCñÅWb¦ *%Æ©Œ¡ÙiE^¿>>§Æ–´òf Äñ«“““ŞÉëã/…¸›Ü½ú¸ßìJÌ&âD¼|)^ÎèÈ“ş—ıcLO¯Äíàæ"*iğCOÀKÜ6+UV²İ&b(M¡•%‚VöRı‘%¹–eŸ‰LßİÆÓá4ú°8¥cñ÷dœ,–+fù§Â–ÕÃÓàìüò‡ÛéİOXò³[sM«?,†),#­wNh_qåWÌ¥UW“‹ËfïÌÏ”ºLU3lüğB§*“ëÖL/3©Î>Úfdì×æ²„WdÍÄğs=™DµHôõ èœR¨Üe{.ìÿ·Ç¼¶FV*Í[ŸtT¯uéyùCkÎêÖG^TY›¤j}”z­ë@Ã)®5¯xEìµÆÂŸÃ`Ú{ú9Šúó‚µ~~1=›Ç³áèŠÎ¼âaõ’¼§ÂİàG5¶.ï!†ã>’*V´'Qy¹Š4¢gF!',‡’,|g¥ãÑM
›ü…œ3•ÂqÉc–`O%[¼şãlt=šLiXeº0ÙÔÅƒ,´œÃ§@Ì*ãÁ)G|Âyg¹APù‘ü83‘,–ídlş¢Ä e?fşBŒÄÅ:£¾8Z!èÕ=Aq}	1eÏP–¯uŸjÚ¹ `c#ZÅT:ÓJ’´ÀTUdàá.G¢ˆ…Š/$× bœñ)G;ä;|Šh¹;—¦DÌªõ¹$èÈsµÉĞ!*éGÑé*^È*¥0H‘ÂnÖsC1”œ’D¯²§ÂßN¦cà}+g)ôÖG¼¾P8©‹#­f³‘‹Òg_òü¶}§ ç oØ#ÿxaï[Ğ“itSC·õ‚ÓO¢tš“6™M›-±ÅƒŒËJ¦µ@6|«¬-TN£“¦æ±¹±g»K0A/"Ê¼;4Ğ˜™ãš<sÄN9m{%ƒ[‚co²| )&±¦‹àˆÔ¯”}ã]§³áíÛš ²É8êŸŠŒMyƒ/}˜Y£eN"1X‚Ôç–ˆ•Nàß~ç> ç\-u–é8	°ü¾¿w rÃ›4”u´‚s@L0±u„ÌÄRÅğì$ÜöÄÖØ}Ÿ&óAÛT¶5	Çõ“èšÒaÛ”M–nº‹Òè’i»ª²>mDn˜SÓ¦sè4é.ÛşÒÓ.%6~6 V«ÎBx…-’ğåƒÑ	!)XV`Räpm>Ñ˜Dæu_›„°ĞOŒŠ8Z4»Ÿ¢i)~º±ÖõœÔPĞ5EâÓâ7Ywï	I†×¥vİNôÑ|"™§rã‚0û&g¶»$&Ñ$ä–t#âÂX¨Ğ<:şØ8ø&m@ÑVá¾%¨ãaGäQñ!ÛÄÌ[k¡pPÉ«ƒ¯Ê¥$”$d¬÷=#ÉÁú«rîE’²X¦}œèò½…%œq‘ì;÷V6'd¾ÔôbY$İÍ÷­)Õ®KÖ•-#`pŞ@’—Ä©U„RkÔYíÊ’æ°Ïù]Ä(™˜ÀÎú«LuÂ¼0+¨
	q:Ï¿ÿ/8U¿¨Âˆ ¯ã•,úr£û?û%ôÒÖ$ÿ@Ågæ}î £å£‚mÏ1üQÁŠ÷İõşzb?‘vuÀ6ÜlDE±T¸ÃÆ(É¨óx?èıíg§îèşıßíh
Yşx¨<œì#È¿ö r,-•dJjÁŸÂk>ÜQıpKõç¦¦şQ>ÓxO/	mb!")R–ôüF8¹ŠõBsmé­Äã^È¬†ºN¤‡®n¡xÅ2˜U srÔC5W¨%´¡ !&ÈØ€3°©ëØüÏyİæOÔüE-ş o™»Ê²u7œäa8Ş}ƒs„
Áú\CÄ\²1{>øuiÖâkeÂ“	›agñBEÕRt {U¡
T{¨†‘ †£¨oÊ +šS6¥­€ïÈ#Ä~lr&<ñÌ+Ìš¹r øĞ×ó¢G„0q…VYÌŒr°xÎ„|ÏÓ»·SÔÿçâv4»`ô=W„o ˆãƒÎ
c š9ú¨Ùõº”ŠF(ƒ<ÌóeAÿÉ'í¸õÂCFEĞ~Qg‡ÈcŞ-i‘ßS! Oó’£N•£ÑDZ³!»cù8™1CW³›kæ„L€ÁTRÈÇİ£êš.t! ¦ŒUë&:„²Ê;,9Œda'.W2fèàë½N±òÿ¾k»XÑ;?Üb…	1Ç¦àçÚ­ÔÊ–‘+Â  L:§ì¿> ·O]–ÌV5É6W¹=ëö2 ½^_ì¢ÏOî6ZÖcƒàZ®É9±kÏ&°õ©R–mm-gÀ‰J»ˆ<^í²|û[g†ëÂ 4(sxŒ‰›âhK;?D?T¦Tu…b›â	\'¦¢c>Ñ’­¹g¨¶úr“;ÓG>^kKpĞv¡R›¥Y‘Bßé¾­Zô ÎÂ5l¿‹?¸†U=ÁUıƒÔ)Iá°í|]¢ËÑeaª\Ôdß¶È6S¿—°m¶(ıë,Ã÷¤½)I×íş›p—ÎêWéPû’û\ìj«jÍ=_™°î%ª7Õ"B‚ırå1—êXøuj/ûÒX#AúÏ|.uıùŸØ>g J¹*ÃçØy§z
[êëYùÑ%“‡X0Oi:DµG±r?7d©¸âÉñññA0Ö-BI…"Æ[ÍN%:|EéüÑ¡ZW©-šã¨[A‹Ù”#âİVó^zûrY¡¡Ã« 3Ê¾³º© ×Ô ¢”~"›ËØÙ	!YWy‡R^ô¬îs_’†÷’Jôâ½PÚö\oÛ%˜¨PŸ*°åÓ"¢iØçŠRÛåR×‚¬A!ds ×È‘¨"¢Ïç9Â>Ì’vìNtŞ²Bº¡M!	ù5AÇNÄXÉ{à7D*ö6‡Â–…}‰RÑ‰`/ï	@„í:ô`Ú<\F6cXûıÑ¯ïÖ¨âş7laßZiù9ÎpD¾5sßzR†
„ı©Ie¡=l–œÜĞ¿í¹:8„§Ë®Qºk»jå‘VÃ©¾\‹ñÍ–es_¶MÄ*Ğ½KgÏÒb]fKÛd£éhò|;ä!š’6(ŠĞkóÀÒâ©|någÔŞÎ-i¾’(ƒ0Ÿn÷ âÏ’ìšÅçÉ	qÃ‡»œN†İ;o!Ó}í<ñ€Ö´^~õˆhç:]¦ïê±à\sË³Éƒµ€EPDˆs°Cušé]ºÅ0¸]BºP–‹Ü§^#âö¬ÛŒÃ¥œ‹ssó ˜9¤áVôè€ıG×Ê;íİµÜr;ºVwÛI>°ğ¥û¿Á”ıÿåŠH¼ÿæçÿ¡ùísöÃ¹¹oüˆÇJÈ]1Ûè>Îà¨D¹F"bN1â2lóNÉs4çŞNã«áÙt×£t»tiÚ‡.Ğ3,ÂÙöÙ’E´J–¨$–EcÚÜ·²”Ö,cºuEåíJ#érŞ!€+F ~—à÷­:è©!¾…ßÑ¬*¸ÚÜ"Es…°,d dÅJÆùºÀyöª]’ÓšäÙøO¯¿Ü¢¹ß•
Ñ¼ÖYõÄÍ ƒë¬) .P\PõKÖ5Ö”¡Z£<ù Så˜÷u•ôÍğôÇíqP§WÌ…*G•ÃÆµÜÉ8™c×¿ŞAÑĞ
Z„
Š^áÄ­êÿ¬¥¯½³çèe59wåy¥Ó²§ı²Ğ›ıWQ?EŸ{â ¥(Fİ9y–¦~€j•0Rä:W­Òå§›ë£ï§£Û#.wü§ZwXèéôÅˆÿµÏtAÉ¥[ì
2êLíâäïk²töï§Ë«Âô&¿•f®¶`ëƒø~¡y ³8­WÏÆî-De18/>Êÿ‹2Glà§K”ác“Fyaj|irëL2]úA‚e<ÑêÖ«HèŞñÄåÕ|ïĞaı’Û§´ æ—·Ñ=Ö½9:Z[raŠ¥Ì¼õ³F9Îd(¢uø÷?!˜«ßC‚^8®àîo —²=‡Şëà`›ŸD¡÷Å^Jrj5LÖÖ«ŞnXşãîÓÆTˆ]všîÕT<h)Î†m¹¡ÆşJ)×b2½³:Ët›g-Ö¸—fŠØSªéĞ¬ıRO½ÿH#|³«±z 6÷è¼–¢9^õ·»CüHÂ¶h9˜¬Pş¦³½åš7ÃéÙ®Gòã{<ERÒšSs¶²r©Äó}#ŸØ¢¶…dGuçù¢œÀòÂÀ+Ø˜égB(d )nì‹EUğ¯{|©hã·´9µ·òoòÔ/™FGªŒÎ‡Ú^¼˜º§%0;LÖ=şû¨_¿¿x-ì³ë˜üÅí_‡“ÑíÍÅílû}ıÅ‹3ŞÕîìÅ¨¬J×Ê­Ï`bØK¿Iií¾s%í:ñ)ÊM°¦è­Kÿzßï’¼L¦ôÃg¶D¾â#ÓÖá­Ê‘¸>ûÇÙìİø‚/tMÃUR¡›ÔØR½~6¼ÙY:p!*úG§n§¬áûo¼ÿÅS¿'ÿ$X-ƒ»ÙÕhµ~ğÌ«ïÖr-ûÀÒU_%ÕÙö)NC—…¤8‹‰‰Éúöş÷;¸Ğ¯’e_Y·ıÌ¡ ~ì£éÑ+Tú9Wà ò—±Êğ™ùh
#öoOßŸ|ùêø»L/ÊM?SıæënñÍ¶^‹©[ı’ÛÕ/;¨™³ Ç¥1sĞÖBïQÿæ›º©GiÇ-w-ñIDÔpè­Õ5•‚Vá›Ÿ™QdˆÇ!&_7VYİjHmDUµ8Íú’’© {çàÀ1Î'¯*Ñ½W€”½áa}·V·¸¢”[†Ò­)ˆ=j">ÿŒÂwFl¸¬—€£œT5Iÿâ£nñ¨vS„g©	¨Œ:{·)ÒÔEB¹¿Ü†Ş±é”î$‰ä¿Ì¸<¤çy•ÊM¤C3½şUEåŞ’E×âN“ãÀß)¸‰zÊeÆaw^-É)6°ÜÜ;À•:®RSÙtãi¾úâ‹VC·ïƒ8Çm*m\ƒÒ¶py¶y|¢wE ó2uâÀÿ–§’ôcF…¡tõ­zŠñµsVà¡—m¦åùˆbıc')æÚ?GÙ÷3aHfxºa àcÀôâB®§#d™ImÅşÉÁ!¥­¿ù‘¾ş‚!Ô‡ğ"\¢ÿÛËëPt+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Should do:
- Should be a better way code the various tree formats (XML/HTML/Unix) to
  share more code. Probably make a generic tree crawling routine that calls
  various function pointers to emit the file information based on the kind
  of tree we want.

- Make wide character support less of a hack.

- Fully support HTML colorization properly.

- Go over the -R option for HTML output and make it cleaner & less of a hack.
  Should do -R internally so we don't have to rebuild a command line or use
  something awful like system().  Should be doable by saving some state and
  recursing and also separating out parts of main.

- Should probably make it so that options like -p, -u, etc print out info for
  the top directory, if people think that would be desirable.

- Might be nice to prune files by things like type, mode, access/modify/change
  time, uid/gid, etc. ala find.

- Just incorporate the stat structure into _info, since we now need most of
  the structure anyway.

Maybe do:

- With the addition of TREE_COLORS, add some custom options to perhaps colorize
  metadata like the permissions, date, username, etc, and change the color of
  the tree lines and so on.

- Make tree look for a .comments file in a directory and append the text from
  that file to the output of the files and directories, so that the output
  looks like Slackware's README file, like:

  > tree -F --comments
  ...
  |-- kernels/             Precompiled Linux 2.6.37.6 kernel images.
  |   |
  |   |-- hugesmp.s        The default standard install kernel for Slackware.
  |   |                    This supports pretty much everything in the
  |   |                    2.6.37.6 kernel, and includes support for Speakup.
  |   |                    This kernel requires at least a Pentium-Pro processor.
  |   |
  |   `-- huge.s           A single-processor version of huge.s that will
  |                        function with older hardware such as a 486 with
  |                        128MB (64MB _might_ work) or more of RAM.
  |                        This kernel also supports Speakup.
  ...

  Might be particularly nice for the HTML output, where the comments could be
  made as mouse-over popups or the like.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              This is a Debian prepackaged version of tree, the directory tree lister.

It was downloaded from http://mama.indstate.edu/users/ice/tree/

The current maintainer of this package is Florian Ernst <florian@debian.org>,
the previous maintainers were
Joey Hess      (until 17 Feb 1997)
Scott K. Ellis (until 14 Jul 2004)


The following copyright applies to this package:

Main author: Steve Baker (ice@mama.indstate.edu)

Copyright (c) 1996 - 2014 by
Steve Baker, Thomas Moore, Francesc Rocher, Florian Sesser, Kyosuke Tokoro

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License with
 the Debian GNU/Linux distribution in file /usr/share/common-licenses/GPL;
 if not, write to the Free Software Foundation, Inc., 51 Franklin St,
 Fifth Floor, Boston, MA 02110-1301, USA.

On Debian systems, the complete text of the GNU General Public
License, version 2, can be found in /usr/share/common-licenses/GPL-2.


For strverscmp.c the following applies:
/* Compare strings while treating digits characters numerically.
   Copyright (C) 1997, 2002, 2005 Free Software Foundation, Inc.
   This file is part of the libiberty library.
   Contributed by Jean-FranÃ§ois Bignolles <bignolle@ecoledoc.ibp.fr>, 1997.

   Libiberty is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   Libiberty is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
   02110-1301 USA.  */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ‹     }XÛr¹}¿¢Ë‘”Éõ^R)çÁ‘ekE›”QZom*åg0˜˜Á,€Í­||N7@Šº­ËvIä Ñ—Ó§OÑ•Õ*hòZ•kM“‹ùÍÉtJ•±š*çÉ´!*kU4®•_|_ğÏá˜:å£)z«¼İ©×“òz{Ä´KÂE­k‡SÓöß¨QEmZ=ˆnjÕª-7dMŒ¸³?m(:*Mè¬Úà‰èµ¦;£×ä*|ìu7:ÀeZ{5×hŠÿ©¥#¥¯}ˆ¤ÊR—T8‹hBßuÎGXMî4•º0ü½X
¦-4ü…ßš´Ebj¨äßØx¬9¦`ƒ˜	×ºŞ–ÄwÕœ?¾ÑkIèÀÄcÒwº…]×/k2ñ ĞÙ±Ïk¸µÑ°q:§ûR·7«­S•ëaËD*UÓR~Nû>©]
6)3é\:DƒÔoh]ãnö™}G–£ß°ïÑj„»Må]C¨\®‰FLË©Ş,z©z01aA.ƒ±Z{ı†Ÿ¯cìŞŒÇjÔÈ´%ÊõH—ınú06…ó™1­^xÒ20òSxlR±3œòƒH¬´ r Ö¹U «#¡Æ«Ö­©Æ?~cYñ#¡–š,ô 7*F]èLk‹@9SX.5òß¸ÒT¦`©€bä·œÕâ6T×õ°ëÄ‘ÊYëÖœ·N»p]×•CÉjm;Àhá%Íù.t¦mUG]°ÒÒ>‚7vØ„7ôÏ£ÁàÌ+`/tí
äéD{~3›²Ü8ö¾s]rèi8•(†×pÿgíÒ0‡)SÚ½Ãy>#x‚³‘Næ§“	-½êjS ½hĞ åf¬‡Ú“	VmÔ'q_
mÔ¾E1wßTNÀ´k† ú¡@è°1ËÍhƒCkçWÙúûË9Em[ØõŞ”æ’:äˆÒèÃ‘D1S@¯¤·q nfµ°3O•/\Ó1w%ÓğHyÃ™øUÑTºCïM(Ü€ŒšõKÇgÃkc-ü^6èÊD{•êmd.³+¯bİªF‡ÑcCh.‚_ö|éu¨(8e‰û/pJµ@|¯­ZêÇgñ0âhp{¬Á"Eïƒ¬Â¦±íRÇœÁàdDŸÀ¼µY‰yÂó\X¯Ç4Â‰àŞó…×ÂÀæÌV²Ä¢å“«×n‰ÔM{fˆtEç¸‘ĞuÛ`‡`—šGò‡Ğy†|ÁM‡¡ó~Ñ9À„À#gUìae¾ÑJãú°5â\q¥Ş§4MuÊÑµxœšn|ÿ÷‘JPzs}ûa|v2`Â&Œã¦Caj:¼œŸ½·"zåË·h°+…	@¿‡|¦°Î„e³÷™HqE¡ |a_f½¦ò›Š~ú.§4W8$ØHú–æN:b?Ù2s˜Öh‡Øû–‹Ô&0†^­àúZyõâMáU¨å5Fptóì‰ër¬4%F˜À|ƒY ÛÂ¡k
¾½èÇËŠS7r;KØğôöz¶Ÿ›ø†ç^éâ3óSB¯b‡C6@Í…ÀÿÑût?}Fí•õpl µ§®3	»LfTÜàá³Ğ€Ì#t	ªà¯Áÿ•ø¥¶,à³‹\P°âô]bTşìt>Ï¬VêcR]g–O¹ô@x¦İcy8ÙŞÇ?¾cˆySD±²E[ñb™©b¦j×îğÁÿöTˆä¶ã1åQd„îq-ã;5}T…[„låIâ†q—¶ÀFweg
—ì¥
ñMWY%Áİ¦½È!¨g‹ü§`MÌLr"æª><8ôÛ³|¯ç8Ùv€Yd)ù§¬¢‹‘åß§=¦ü[9Ÿ*{åİH²TXÙ)_—óñ÷ÇBâ•à®sÌ|„2S5Ò¡QÎ;´‡PòAĞ…«Ï¸9‘Şz5µ“^ğ¬€"ş><Ş»½Œg–Îz!ã¥2^¦}¥uÌÜ–ñĞW£ÊNûÍc}/iõ~Òê¾Q‰Fy¤mG>3„Úæ¼qÚl-…™`Ñ)d(³áìÑ.sZå©–æa±YB½0ÇÎêéXª½wÎ´Ê,öÇ=×5”Z‰Âleİ)Q'ÈíáV¨ƒL1àbLU‹ºB*ƒßzxsøöèQ†d’%I¥Œ\,X‘9‘—*KÈ÷¬+¬Æt=¬Ä¡œaèV&¸ÄF-]pQÛ²/ŸtÕÂ»Ü—]àË×£ŸF¯™ºtË;¼>)æC·Øâ+ÁôÈ3¦Ù/n?·uí›E”6 Ëè3Zşİ«%^>,Î¢7ö^÷18æ;0˜%ÍŠ4Aÿì—'¸Ş¬£ÊdçüŠ.\;®ÛõLÖuŠõ³7KÄè…ÛÍctë «¶Ú»à5l¡+Ög³w_No¯¿ÌN~Eoj,8èx¬ ^}íéSğÅVd<"ô{³#óµò- ğ8ìï¡¨¨ZnòıdÛ‰%bk«´»E.³HJ–iş©ƒSD	ğÆ‡ÿüí¿Œ£Ó•çŠ¨È10Æ„†4ª¡Ó$§XœL&)L¬,Æ5kƒï]|0ëS*²"ä1™t™x\62Ş·yyØÚ²ÜZÏ±(VÜìñÙ<¿ƒ¹Çìiè³â­õÁÑ£'=¢ÀŠh ÃîË7nf×¬¥Y ğ°†´Ê®’»YqÃºuûDzKºÓZòŠÇl^m+ëW-,\UªĞ¦Y@Ñ$*Yâç_E9ıjÛaœd!©J!O'ŸH6]/Ç@ºıúu€>–›û¾^¸Ÿ8(tŠ“.[ªå×yo
…7]$,,‰†ö0–àÊÉ°1¯ÁÓîîI–èNÃ[æétÂšÏÈ¿ Ê0*Ï«#Î3V ™Yõ¶Uá:¿â„WaĞlòn!y»½9şƒRGg$ÌœkõfÛ÷Xé±V~™Ìß_^^ñÃÿÀ¹M/| T#_#û£Œœû>=G¨ç½yfç yâííÖìı¥‚yíÛE_I·èß{TŠE¿ù#K'›ÿ.ñ#äæzÃ×boÏäuõÜ8ß)¤œ¿ãn†ŒŒôËù¯àªÆê:š½µöù¡¹Ó\¸\Ø<éß¹
ô›ó/ˆ8¾zà0^óLc­|½å<ÉN¬ş*G1?c–q7g‰)r´Ly¼Üÿğ=-0¬°p—¦™)iB´s¹Íë~·#³ªº_#v>Ûà§¥Aˆ#y½Ô·ÅöÊVpÍ±¼¨9TYÒÇùåÅŞz'§fY%ÿzb˜°¿2ÛJÛòOl‡"«™½wÎ(~Ã(ÂìYCùMÉ°PAƒ[9ğ;¬^¨‡¿0Ë$ß?ØŠŞ1]ğšŒŒYÇ®N0h1ä6ù%Ê&¿ãƒIºt¥uÇú*ÑUü
p;wD'¡ŸxıD~_*‹¿9üüEş€©"7½Y’>#B¯şëÉ·Áÿ4ßuOô                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ‹     ½ZkoÛH²ı_Ñ›] öŒ$ó)JºÙAÇ=c'ËŞİ‹‹À È–Ä5ÅÖ²I;šÅıï÷T5)QÛ‘±¸@2MvWW:uª¨"—RØ cµİCQfºG©ü/Qæ™E‹¿Îdœ”³7o„øIüÅ^äùß„Nfó4/Ä4Ìc™%Ù¤%2%Ê¹.rÎÄUx/ÇI*Å<,¢)~-rù¯2ÉeŒ…„88I•–z ‚®xıC,ßn‹³TåI˜‰ÓVˆ÷cóã‡Xğ_Gå“_„ø»Œ[Â²Å×¨e{øgà;«/~¶Ëzó¦hÈyñ@İÈñ¬Şè›0›åeJf©™çI,ïâé]Xê.J%+”0B½:j’2‹ù`X0İ g¿	™Ñ¶âÓİÙ×ë›‹³ÿ¾~½½>9a!Fe’Æ¢Hf²eü³í·»éff÷š¶ıŒGÒ°œaA™†‘*sñ~R&’\ıë14¾y½S¯TÖN_å¼rª=ğú¯»Ë©öËNuGn<¿‰‹Ù\å…ŒÅm}>øU'*¼ÔÊâ?İC>u[\Ë¢Ì3 *kÿ!s%ä÷¤Ø²(µÀÃj^Ğ‘Ê5\˜#¢ÔáD’«t«²S™ñrë"¬îo‰0†ï§@¦ÒÉwñ®İ~W/XÈ|–daAwÀõX¯=¬Öˆ¥ò¤ºO‰¡àäwÏÄA¤2­Ry(°í;G
7·x×ãáÉÅEG\<„µ1Ãé,¼Wâ½Ê$ò"&³0I;‘šıÒ¾*tû¶ãØ‡Æ££x¶üF96S¹™„Wù°0J¼më·bœ+#Ü”¦øÿAE![›dKT™Å|gÔ‹-ïRrœK=…ob|ÎB +—°…ÒYü~|s~wuüƒPó¤ízİ t—Ù©ù"O&Ób Ça!ÅB†9¯°lT’æYÙíYn4ÍŠ\¥Ë'ÿéöO-À{ågZgXà_pŒnÿÍ@Ç¬ønØ•ÑfŞÎs5—yº	#ÏdÚ8'úÇ“aXR2âx›d°­ë{3ºO%Cª«L£8Û½ç3ëldû°RŒU>à_üŒS†)å1)¦B/føá^è¹Œ’0Q¨%Eù/—Ã»“¯—_¯‡Äò{İ ë·*ğ…©V ½ÏL‚UmD~,'ìqXm	”ÒívœäzŒ¿È!<P„mM­Rfµ‘×wüÀªŸF’ÑÓ!Ÿçe&—)¦8/ôT=Š·r6/o6’.‘º2sµªkõº–¿cUl›àw~P§Œ´ûrÔµ¾Õøš‡Ñ}H$Jx'Êp=ñx$â)’OQU“šıÌ{nÁo ÜN¿ã˜=z]?ŒÃñù`î@Ê½P.³î¨Ê8ÊVN1¹FÃUĞgrDu„í\TAµ›õ;îî*ØÀh0Æãp3•ªúUjrY¢™e™ad5ÆÕúb¡Ş’4
8¥â Œp	w–æ%GXóºŸ./¾ÜşƒÀ{rvyüy¸Yö¾$÷
eO‹a4-Ó?©Ìİ\5‰N¦y¢5ŸŠ2Ÿ,oÀ!æ;Aœ¯%„8~’qè¶ån“Ò'9GQ×âç¿Š¿ü{–èhP]ùßÖLğ>„{Ïšv¹
™fla÷®;ğz»Bø<Í<G.xºÕÈxÃ,Qrö•üÀGI‘.øãä;ÂReÛ1„Ï5$DBËY*noÎÚ=¬–…ùæúôôîäüøzxzCqæô–€'E¡¨R:E9Bìq=K~2+5Ä
Xµ˜Ío‘¡8L¤Òtttq6gÌ	f"*lZŒ@‚1‰ƒz£1m´Å'N7pûK>1E>*gbÉëp÷,Ìæ$(Àñ»v¯k€SÃ…ŸOÕd@`å‚Âşæ\BAĞ)Ñv›•G;ÉÚËÖV©AGÊ„ÊàÇ\=jiê(ıü9)øşÓï\Ôf*NÆ‰©îš\²TÆp¤vZ,i…™k™İ9?4dT“"—DštI–ñãæ¤;	°×q÷ú'èê;p}#.7€îtœ şE>®›’{g«rîÂ÷:¶OÊü[Ôh!Ğ–ÚHª´–†v¦`Šn`Àò;¨áÃ†ÇJêì0_Î9:®#FP«·ŸôÑgüÓD¸gy¿ UÅ¸mTŒıÄŠíW… Î¥B åìr®ı
çVÀ£gËfî‡¨U‚}„‡_¸Ïı I;Ñn1‚¬?äÍ´äjgÚ«'gà;ÚÿUø©é­o?Ôº‚àSó(eô("DÜŠN¡Ì¡¿ª_¢”‡"İÖ0^Ï±=gßvÌ
Ä¯ejÎ‹Òà#iÜíóÚ¯=ñ6ûÌIq®fr^5RIvy„#™ÆO€¶’9¸›M²±z2æÁ>¬aù 3K[ıßX½]>°_õ³ä;(,-Gø-H5àüæê²næatúïî	[»_‡1àFÂX;`k¿ Ò`å²"‹¹Z–t•Å¹#D;âDaµ¢Úsî¾F;¾ø5ÌŒÑ–5@ºAbnÊk¼ŞªŠù9JË¸†X@h±,|?Êy§¹…í¥Ğg‚æ¨}ŞllÏî÷×³xÚÌâi	ßÁhuÒŸ[‘umßî=ÉËÄÏ†gDpîú		€Ş™R(ÊËqaºq"MÔçeë½j9¨Ó@%iR,DŠ¢•
ÿ™Ìqöˆ`	/;î*‚¶;@ò¸;„¥õì(‚4(ğ—ôˆ9~‹ ¸hˆÊÓ¸„Áâ#Š©åÇn5êp^õQ†y.1¯ç41ÉM5ş	~Kˆ‚âP^Nb9N²¤îA¸h¹›'|àây™Ç-H<)şl[¾ç:{]«RŞ–øÖÎ¼üi×Í”4íT•)QX*O!FBÜ¿w*T¾i´Ìµpƒ‘ìàs[Lgê¬Öèj«öØ}×v»É‘7–FL 3jCçÓĞj³T‹ÊYG¼K5x·ka×_.üQÔæÕˆ¢}ÉÊJ³¹ÜûQàÊbÍ*2dÙ’ª(WHtA7é"Ao<…DMôô°¹·í}ûp:Ú…Á	NÑè
Ì¼„4M[Ûˆãl®7O¬¯ÄÖ1ÊÆk,vÏÜŞfGÑ)3¸•iàí1N‰Ksù-t¿|pªÇˆØ`/Blø$ŠÚnÇ[k_ºÛ}Š©r9æ­ŞÜÀ¦ysÕÛ‡ñ?K¤Çå'nº9\™âQâsYt'éÇ“Ù÷N&‹:‘ìÅ	%’'l…ÂL!ÖÉ½4…0ÈÔaFtˆ¦%ºçşâ¡,³ˆàZëü–øM
¡ÿÔtßï›2°yZ}OïªÁhUD7.5Ÿz¤®i ‡<ÖùÌºv/Ï^*8xÆØDë.ÏØ{pğ“l²æ	'pœÆÌL‹Kb¢3 lXehónÏ²«¡¢À”.GRË¤â­ûçÓ/§×Ç7_¯ÅÕéÍ1+>
ÕÛË$+¿¿m.l¡2»µ#Ã±ŠÊ5^mèf€£‘J ·»4\!MÛ’Àm>ëäy4YæŒINpó½ƒ®¾|ÕDúî¢İ qDo–5‹ûçªiÜÇ†^ù}¤)dµ àÕŞ(gs¹c¸m:ğnÇŞ†qí^ô*ro$5™EÆëÕÆÌ­”Cæ¼`û 7¨¦ëŸr5'sÊŒ^+àÃ.¢ì¨È[æ3èYÖµèËÕí:‘ú–ßkÕÜÜâ`"%ñ!èú}.øÛ«F/«†ı6M¨£¿4>– ñ[
M€ÄÌşô
BòiÇ„äô¶ÓÎi[Ô?ŸzW·ü¿ÔQ8gRÏ$i:.„#Ô	zÿƒ@¢[:¨ßŞŒÊIå’ÃJâ4Œù-½+ì·¡rÂ2ìà‰	’+OX0Ò„¦"™ó7½ô¾L“U†³êÔõ€¥:µË}†ƒné‰S?{æ+¶“ôrİ•:?Ò(Õòˆ¨íƒr¤…1u#€â½ÜïĞ_h1ªvŞáÖê‰¶åmÛûBŒTÖnHÔrª0îlÓdİÉ¯[N¬Êéíõ%ñOS@`5æ`êØ~°ên¦ô:îq¹C5?œ#”á¢i2›2ım"d©cv¬¢¤™¥š·›j.ë¤~uí—¯¯Æyf»€„ÉÁó¼uQ­|yqrúexjNÃútí”wˆ¢>´å¨mÖfø~ æ¯ôş•v©g„¿4£%EµÚo²X>“KÿÃeL½1ÅoczK7v{Vİ#Uâ·8MSˆ÷÷š~ŞÕDY€×ÒæÁxé¯òy|^mb“¯^Kó –yË®p?ëD‹/È:‹2Èõ~;ÿ©ü©g­ü›Ï–/lÙ©aH}Íª´L1æ¯æòÄôY Ú¿4©†®T/:+dŞ ˆ†ü&HÉù˜üÂÖ=s–'ğL¿bCÒøÚ.ÚàB§İ}Ö/u„¸Eâ¾~¤&¥f½C³r-¸ŸÅ¾.gZ˜omüh™³AšÛÂÎq6şx½M|9mÿY;?±0£¦ºŒúMÑ Æ<Ş_yÔæìeM®@Æ:—Ñom[ç=k]İmøPc×Êé<o_‚n9\©£&ÈíV÷×aú¥4E?ƒº}¡#NĞ·^ 8Ç½õSº/JôU?±Ø|˜€‘×ªvP#€w:Î¶¤b3¡k™I:g]9âW%âœ<şşŸø8ı€$B)êlsú2Ş}©Êê,Û–W¼i„6'çÇ_>ŸWSD·S?²Éì¿îÊdÛØÄ‚›&ÓtØİgÊEß€Ik˜ãoÍ×fh#ö1‘gØÍo¾`c—ÈÈ£LÚeãóA¾F3Be±FB#6ó¼S@âZz¯uın°ª„{ƒÈ¬8f#)HRnæÅ+ï{XÂUØ¼øaKèÕaÅCë–¼`‡y·ÆlNRhõ]]•°ÿkmúe#T³nï¾ ›gD*–«N•gúÔªóÈúYt¼ºù^JT±.¤#ú$t8¶™ø…)ßf£«*4ú}4ĞËÃş#ô*                                                                                                                                                                                                                                                     ‹     ZksÛF²ı_1¥Kj¯@Iv²Îº´º’%?äèáˆRâ»IÊCr, CÏ ’èº?~OwÏ€€lo%%|`^İ§OŸîá/Æëjµ;y6ÙùN©L–¥»Wm0~{î]»Tµ®LPxÑ8õô‰ÊÚë¼Á8ucfÎ•—v¹´õ|ÂãÏtaTfUîª¥7!¨÷g§J×…z;½8W®m–m£tPU›/èÿK‚½)ºY)SÚÊÖºÁd˜K)óĞx]×u¿°	KYæ°(L¡²,×ÁØ:˜:ØÆŞ5ö†6L_ÙyíñJ—ZÍ½YnªY©ç*8µÔQ^¨Òvso›6¨¼™k_ĞyiìÒz,¾Rn¦Şê sªcW›zfÊb¸¨°0[6dØşØŞêâ…ÕßÒ\“õd¼™=şüàóÃ“üû	Ì¸/K¼²Xbm®v63^¹;ãgä1ÌTj?7ªµÅöÜ0Ù¶c?ŠÅ›¼€xt|Xš8üÕÔE	£«=>ó÷¹)ÍRûÉÒOæînrã÷7{gew†v¹t¾œòUéøœS8‹ïÍÂm2=7ucê/ÎÁfäqe¼w Ş\4+÷S«ìTíª°4¹YSLÔxª¨şí`I±ZàO&ŸñÉÁ¼Ò¶äµú[YØ-ØÏø6MKß-,¡WıoYÒf—ò^·¡j	Sõü`îÜ¼4_p”e4Óoÿúclº?Š^ßb¼•¡Ğ‹©zœİŞÅÒ;8±‚.W°ÕW–6¨½fa<Ş/øí§x„€ÊTÎ¯Ö°5«‹€ŸŞ‹í Qµk”ùÔê’ Ó³¹€½çÇèÅdSßĞnZ«öØFkwìşãépjúádz|qq¹¯èy¦d U648#¹UM iœue+uæ ò•¸
ï'òş .B;1E§?£Á78Q‹#è›r¥
Ó˜¼Q×W¯²Uérà”&>Óu9³·mYk‰å½¹× Ñªg>æGÆYçÒ4-S»:ûl¼ÓØFaë¨‘ƒ—¶à-[7ˆ%€˜šÂE`J<ÁÂ:>× …!?ÁV€HB…BØ3½ÑSG°/fË¦8ZÈ½å'’g*ƒéŞ}ÿô™ç®®4›)r‡[¼æáôèäV8¹£p[ \îNL ÓÂ^¯úî—íÿÙşÒdÎÏ)li^ „VoËÆ.0B*–
ËÆá$;^×8àÙ gãMÂ‹"İ`X[çt½ ˆ½yò¼Ä±ÚeoàÀ•ı¬ùÁ~œè„k<}K]/ÅL¿½‡ÛuIHh0ÈhĞ¼°ïf)C¥±›ÿ›b)Œ«êÆ•6Çê[¬GS9Ê¦èÏ"ß2H(6ˆ†›j#­N` z +Ókz\ÎBïNOÎŠö¤Ğ9>¹üptqzq9U |C¨hx^½¿…M§ù¢Öå­„ó^e,6vPiĞ©w“Â¤€’ó—0O"kâ‡Ü¥ÁGHßÑâ¡…Ïç[ª¹ßRày18‹½Q¸rÎ lŠ=®ƒ×ÔwÖ»ºç34ÙxãêòåËx,°eãtÚ}ŒğZ¼A<$ù|gg
0„C†I7XÉêÄi©\Z NOÀ†påä™ÚİÙÙÙTmmœãºô6_ğz/ó[›¢éÓ{ö3Mù©uÄ‚äML‰ğ§ñ7 !äo|NIøñ–¤WÙ'Ùè‘«ïÊ¾v",ÕTğ²m¬ˆ¹sih6-©ä†õoòFç·¡ÔaG]Şè2%š-Ø%7Kñ3„z–í>%ÕD*Ë›n…8ÓïzKı~ƒ¿Xä÷;üÍ8‚~÷ ]Jµ¤§ÊÕDMIuIÔ®7À'à©t	5U#fú»#a‡sÑÎhK7†4GFÊŒUY—$³Ÿy&ËÆ…dQc‰¿‘ª73å¨ëï‘Î~jõ¿®y±¶¦¤Ìq(¢àh@çáléã7øÉõQ@†b¥.äÂÓc±3c³ŒTŞí›ÎOÌÕhVl¬âKTä[*ƒ¥3ÏèhØ¹éè…&í »;œ‘Ù*]¯à“O­ô·bÄR˜é¨•f%Àw9™R¢¯±>¦Qá QÓ•†‘LÜ"\Y	E™û.Âq:€ çŞy°[io%´‹6Æg…mÏÁ•¬ª+×"öc,ÓáXÌŒ)Öæ'»0áXlÉØ6HĞtëÉô6Ë–¾­MJ¥qkà<%Ÿ#à€ËFFZĞÂ3ï*"&Ğ1‰0Ùrö.Í¿ã¢$*];X/(u@ 6()¥OÙX^Às¼|(sÀ}áıBfgy>ØŞŠ}$¡•k*j˜™Ò-9mŠY˜·$ímqt`İ7ÈY"9¾é÷äpìvñÜ`U²3•fB°jLz(íÆ´,œ?+”÷z•”S"]¤o3«šŞB"ÏW¼Vœ•2#l/K½Rc[ALàÄÙ1ÇCP|?ãgeè¤¯V~˜<åµßy‡³"•	'¼QVH+U‚gL³|Ü@jRC	€Exé–½Â8¸ŒÇøª6° r-lœt;%#Šÿßşş‡DCßÈŞHOÆ(U#âÔ¹÷3$
;—,º$HVK|F–äTLIÔG1AÅ‹^Zr ¦á¦‚–Í7hü†¼f<5ü‰|î¨îatUKKÕÎ½ö5ñ£¦µbWãŸ4¨UlÁ± ¤†ÍlâÌ¼A)c%¡¿9¼œ¾¼’üÂ.PáÔI ¶£üó˜€Š²Sñ”IÙ`Üp±'¾ÚJÑÏLèôĞßeq¤W8IŠÇ,KSG§n±ôdò„÷6ÅqÒÔÉX˜ü–@qöâÃÑõå‡³Ã÷ı°zó.;wõ´qK47ÔN8¼¶˜ëÚšRíåô¾Ê‹oTqäå8ôéuƒ½>9Ş~}r<Ğ6É!7­-‹1ö,’cSXaI  'ÅÕpİ1sgI+¿/êç–
ÌzşØ(»½uF5 “\Êf‚‡£Ğ5Iz(ì³õ¹ˆ$8H(½i¼Ezã³>Wo¡ı³W^×ÇyA­™’à½w_„„)\>±7ËÉÌïón®@V…%iNçÒKå2@ç¡“ı˜ˆéÑÏÛdQçÄq5ÖÅc„úDß9[tñˆ|ˆI}ªFõY– K•œ¡Äßã%Î}Z¼^}¯ê¶º¡’c#]ò^5àñ»´™ÿ.n©k^°ò¢ÈÂ£(+[Q¿Üì:ƒ“ìÆ³#ÀcÒ‚éQÜÕ·®“*EKû %&¨MÄè%“
!ÏPÓpÖÌĞ>ğÀâñÂ»qÈœš‚¬çë~›:ñq?H¶õø½•ûıÁmÊŠd|Ø“›^¢5×9OÄ;ç!şlÖ+jÔøß­/$@O!D-—-‘LÕcj!6ª¬¤÷ôMB]?—|1®'nÚyÿÑ4İŞßÅg6c…$,÷f€”E)âìNÂ$½K‘u‚§¥au‘¿”¼Á¢~„bÖLIP2šcIL2÷ÃîôwvÕ‹’¨¦ˆØ-òfW-°MöWƒ³ùŞŞPŞ[.´$Ê  ~¢F$ÒıHÆşDâ¬È©›èVä3ØğXƒÁ¤ù™ª½‚ŞWÿ(]'/Œ¿EºZM^_ïO¾ºÑöHé&ŠnÆ÷~£ù²°ª¤7ğµÃ¥è	t"X¾Ó]¢kb³Å
 i4ö=R—#äw÷ÒT%Ul²Ì)½úş©ôÏÖbœğÖ63$SSSõXô+U+„µ.€Ç¨ª x(ÊlXlpÎ\Ë¾éiÆk 	¼â¤Zz>¼*W&³a¡= ˆŸV.´·¦ßÌUH=wÃVJ\¹[çÚ;ñzg÷Ù“ƒÚÎšÕ¤6“Ëıç|LSsÅCPÓí'Q9ÉšJı2'õXÍKv	w6ÒÅÂ‡QºdV.uèÑ­¤ëâT*u~àPjcr§9
ÿ ÿ¦‰¶$à±«:‰SŠºõDµl–M£"[Nâ‰ºK‘ÙlõÅ¹N{YKÄÚX	Æ…Ö8¶ø?×r…’¦¡ŠôäğüîJ@—ÈÏÅ£IÉ‡õ|Âù¯;‚‚Ö´€²´Ó}v£ÃóõãòÏt~x{2ï_^eoß­¿?yqöã;G‰Bì=5½È~üñ‡f»ñûiÆMÔõAfÓQá¥{#şÙ™ö_Xïû§ÏF=ıÚw\òSÕ–`f¦Û’:be»6]­wt;ÏAœÙzV?˜K=‡QÕ…”Èë%j—V”3W7Ù½±ó'¿åK ğh:U“_^^NO.Îƒ’Öàn7´ÒŸT¶Æ—|a–J5VÓ€$}DÕ6U=¡á¾)Qà¦ùëw§wOÉüûÇËÕ•\ĞD¦’şÁ)é>W@W‡E4q—zcµ²]«¾Ã$fìõ–Ã@Õ­»9ë\Cı£a‘Iü÷Û+Ö5§]ê,ñ¶7C,’/¹`Ix¢;›Ò“o…lv"”
©'š_Î—Î !ÍÙ&™ƒzÆtËA5übEÕ)ÍÜAøù"%}ÛVƒF|t8Õ’H¦–Ì…Çû=şo=±
(­bˆÚïúåö«ÃÓéË-º–-\=Ö¡]šÔJ¦ñ+=)	gã$ÉH`¤…@·µıƒP"ÍR²¹Ó¿$Ú€¹oR7sËäN„šĞ±C[`‹İYÍ3¾Â°+oå@à7w"9?ñ*¿Í¡ß‡W]K‘ó„ŠîJ]ÆÁé->¼ãk	¾CK±®m‘`€ -bv®Íb0•ñ›l©ùÑÎ§ıûT‹|[È·i¿ß%’êğxµ¿¼û…)—qï‰„›gšÍº¤Ev÷üi;["X[ê0é|ÙÀrá'á<ãf%‡¥ÍE~¦v÷À÷µ»öŒ§ÌŒ¸ó‡¬Dôyôš¢§ ûc‹rsı«ˆõ½&Y9büºµ…CpäDåkeA­Ô«.9¦ÊpÏŠæê’?ïoÒ'é¨}QÍB½>èà8oPn xŞ\šÙşú%©N‰õù><eCy¸Ò¶j+PÆ)£^WÂqÚÁğKÙ]ÄFImnä/Ó£=]_È;™tÇjÂŞŸÙéhPÀÁTg Oÿ„vv®°ıÉ¢©ÊÑæ Şƒ’şxxä‚¨'İÕÑU@q:³B"ƒİºŸHéò ?B: İB3Ò‰Ú‹¿DÙÿÙ
E'7$†íéx»ÃÎè®xÇB<LÛ,ğä-1iöÉ#Êq©²çW]¥Û‰ş¡ïD@[Û¹ ŞSuŞ³Ëºr\ßÍÅZ<v’HK®ëáÁDŸşËDiï’/‚â»š¨Òşv@ƒ¢FÄìÙ«î·I5IºoD£Êrk}Ú •*Í73]o’Z3«*ã$+ô®=ia<¦OÛSÎ§l{§LrêaĞóÛàéƒfó¯<6üQıî'¦¾ñ/u¼
ºl6ußi#SôrM\ƒøØ]ÃEzÆ¬FBBf×~Ä{Ô:-_0Rÿ›+¤A>m;ü«‚ŒÚïÓ®"¯éÚÙ9›Ù‡P½sıN¼› +¢Yoû$ĞYpÅ£¿ƒûƒo]K.ıêBZN´P”¾3·¥F¹¦.ö	ép¸ÇR;Øİ†x[9pÑaÿBEäİáùô$Ê§R¸ÿ8›,èšîæ¸§,æ+&ï-ñnÍødüõ£›Û‰ëàNÍ¶°P#ĞßÍ3¨±“>•ŸÕè&æâşXkÆ¾ç/ò‰wòã‡õ¯²²»‘Ó’{ştÕN„iEÒ$+ÍgJºãÍ4J‰™¯niÄàé!îˆv+ÅÈŠ SG‹Èu³+’>€âr½t£®(óyyÇ×æDÑ’£€Y"“ÉwÿÍØgœ)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /.
/usr
/usr/bin
/usr/bin/tree
/usr/share
/usr/share/man
/usr/share/man/man1
/usr/share/man/man1/tree.1.gz
/usr/share/doc
/usr/share/doc/tree
/usr/share/doc/tree/TODO
/usr/share/doc/tree/copyright
/usr/share/doc/tree/README.gz
/usr/share/doc/tree/changelog.Debian.gz
/usr/share/doc/tree/changelog.gz
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    à@â ^ã 0 á0Ü…Ğ+Ÿ…  0‚€  ÜåH?Ó…¼+Ÿ•0 “0€Üç €‚à ‚àHØåH/Òå0à ƒàH Rã  Ê‚Šà°/å  Rã  ºDŸå0à Ñç  Rá   Œâ  áƒâÀå0å]ÔÿëÀå  Pã   å0å0Óç  Sã  ¨?å ãÛ  á$Ÿå˜Úÿë å™Óÿë 0–åìŠŸå  Sã 	 Šàwp¿æØÚåQEà‡@Dà$IâğŸå‰ áğ Ôáù0‘áĞ
ŸåÀå0ƒà  SáÀ…åP…â€  šÈ:Ÿåù€“á@„âÎşÿê0å˜;Ÿå å°Ÿå  “åéÓÿë Iâ Šà Tá0å« *
° á0å 0–å  Sãùşÿ
\;Ÿå|Ÿå  á  “åÚÓÿëóşÿê<:Ÿå 0“å sã   
8*Ÿå Sá ƒ(*Ÿ• ‚LR• å  Rãâ  
 å Rãa  
 ášŸå zŸå0 á  êì)Ÿåˆ0 á³0’ás0¿æZ sã€Šà  áü	Ÿåƒâ  
	 QáÀ á  ŠÄ9Ÿåü“á´9Ÿå Qã  
 Tá  
ØåXÛÿë 0–åPEâ  Sãò€táäÿÿ
  á á²Ùÿëàÿÿêü—á  QãïÿÿÚ”	Ÿå À–å€ á  å  \ã …åP…âO 0 ã0å¤ÿÿê€ ã,9Ÿå 0“å sã  
,)Ÿå Sá ƒ"  šH	Ÿå@)Ÿå5Ûÿë 0–å  Sã   [áü¨Ÿ  
ò0Tà  á 	Ÿå0ŠàPEâÓå(Ûÿë [áöÿÿ 0â [á  
  áÓÿë  áMŞâĞâğ½è´Ÿåƒ0 áó á PáyÿÿsAâó€‘áxÿÿêŒ¨Ÿå0ŠàLSåØÿÿê  Sã˜  Ú (Ÿå¨ŸåÛÿë\(Ÿå0àã á 0‚å”ÿÿê 0–å  Sã–  Sİÿë88Ÿå  Pã  ƒå}şÿÊ À–å à ã 8Ÿå \á àƒå ¨Ÿşÿ
9ŸåPŸå ã  ã 0“åàå ¨ŸåÓÿëÀåwşÿêì8Ÿå,(ŸåÜŸå  “åÀå=ÓÿëÔ8ŸåÀå  “å áÓÚÿëÀ8Ÿå
  ã “å[ÓÿëÀåfşÿê¨8Ÿåì‡Ÿå‰À á  “åäŸå¼0˜á IâÀå)Óÿë  Wãpşÿ
Àå&>ˆâÀƒà 0 ã¸!\á@å@ á€ˆàï€ˆâX8Ÿå@„â  á  “å˜ŸåÓÿë@8ŸåÑøá  “å¯Úÿë08Ÿå
  ã “å7Óÿë Wáïÿÿ@åUşÿê8Ÿå ã  ã 0“åTŸåÄÒÿëÖıÿê  á áÙÿëyÿÿêä7Ÿå	Šà4'Ÿå  “åÌŸåûÒÿëÌ7ŸåØÙåwp¿æ  “å	 áÚÿë´7Ÿå
  ãQEà “åÓÿë 0˜å‡@Dà  Sãìşÿ
  á áöØÿëèşÿêt6Ÿåp&ŸåÔŸå 0“å0ƒâ 0‚åÙØÿë áÿÿê’/‚âó€’á  Xã hÒşÿÚ0å  Sã0C0 0–å  Sãu \6Ÿå Ÿå àã 0“å  å0…åP…âÙşÿêÿÿ€ ã^ÿÿê0å0å¼şÿê 0 ã0å¹şÿêè6Ÿå ã  ã 0“å8ŸåzÒÿëaÿÿêˆ6Ÿå°†Ÿå|>å  á0å0ƒâ@0ˆå< ˆå©şÿê0å  ãå   ãÓûÿëx6Ÿå`1“å ã şÿ
l†ŸåäŸå0˜å ˜å  Sã“\Ÿ#Òÿë—şÿê 0•å0å”şÿê6Ÿå|>å0“å  Sãj 
  ã ƒå6Ÿå`1“å ã‰şÿ
†ŸåŒŸå0˜å ˜å  Sã“ ŸÒÿë€şÿê   ã¥üÿë   ã0 á  ãå¨ûÿëÌ5Ÿå`1“å ãuşÿ
À…Ÿå@Ÿå0˜å ˜å  Sã“°ŸøÑÿëlşÿê  ãå  •åÈâÿë åfşÿêŸåØØÿëcşÿê   ã0 áå  ãûÿë]şÿê •åè$Ÿåè4Ÿå ‘è²Úÿë  PãVşÿ
D…Ÿå<%Ÿå<0˜å`!’å@0ˆå0“å ã<0ˆåMşÿ
0˜å ˜å  Sã¨Ÿå“ŸÑÑÿëEşÿê  ã ågòÿë å  á  ãZüÿëà4Ÿå`1“å ã:şÿ
Ô„ŸåhŸå0˜å ˜å  Sã“ÄŸ½Ñÿë1şÿê é  ã  ã\ûÿë0å “å  Pã   
üÿëˆ4Ÿå`1“å ã$şÿ
|„ŸåŸå0˜å ˜å  Sã“0åhŸ0“å¥Ñÿëşÿê  ãå  •åuâÿë åşÿê0å “åïûÿë(4Ÿå`1“å ãşÿ
„Ÿå¸Ÿå0˜å ˜å  Sã“0åŸ0“åÑÿëşÿê   ã&üÿë   ã0 á  ãå)ûÿëĞ3Ÿå`1“å ãöıÿ
ÄƒŸådŸå0˜å ˜å  Sã“´ŸyÑÿëíıÿêœ3Ÿå`1“å ã  
ƒŸå4Ÿå0˜å ˜å  Sã“€Ÿ0åkÑÿë å÷ÿëİıÿê  •å ãÿñÿë å  •åqÑÿëÖıÿê@3Ÿå@ƒŸå`1“å ã  
0˜åØŸå  Sã ˜å“$ŸUÑÿë   ãïûÿë å‘ûÿëØ2Ÿå|>å  á0å0ƒâ< ˆå@0ˆå¾ıÿê •å"ŸåA? ã ‘èÚÿë  Pã·ıÿ
È‚ŸåÀ"Ÿå<0˜å`!’å@0ˆå0“å ã<0ˆå®ıÿ
0˜å ˜å  SãLŸå“˜Ÿ2Ñÿë¦ıÿê0å “å0@â Sãÿÿš 0–åwp¿æ  SãQEà‡@Dàn ğ€Ôál!Ÿåˆ0 á³’á×ıÿê0å“å  Qãğÿÿ åµñÿë å  á  ã¨ûÿë2Ÿå`1“å ãˆıÿ
‚ŸåÀŸå0˜å ˜å  Sã“üŸÑÿëıÿê  ãå  •å¢áÿë åyıÿê ã å›ñÿë80å:ƒã80€å™ûÿë  ã0 á  á  ãœúÿëœ1Ÿå`1“å ãiıÿ
ŸåHŸå0˜å ˜å  Sã“€ŸìĞÿë`ıÿê  ãå  •åƒáÿë åZıÿêå   ã 0•å  ã„úÿëTıÿê!Ÿå41Ÿå|.å`1“å ’å ã80’å<ƒã80‚åJıÿ
ŸåĞ Ÿå0˜å ˜å  Sã“ŸÍĞÿëAıÿêìF Øâ èâ '  H
  "  ì õ  & d È ¨$ È$ 4 °' ôF Ô' ô' œ' ğ$ % ´ $% L% ˜$ „' Œ' Ü$ \& ğ% $' X%     ' €& l& L& T' @' '   0' ø& Ä& è&     Ô& p' ,U d' & Ü% Ì% ¸% ¤% €ö Œ% t% 3 45 &  À' Ø % ˆ4 &  •åh åh0å ‘èPÙÿë  Pãôüÿ
D€åL å<0˜å`!’å@0ˆå0“å ã<0ˆåëüÿ
0˜å ˜å  Sã¨ å“toĞÿëãüÿê  •åçúÿëàüÿê å©úÿë 0å`1“å ãÚüÿ
¬€åà å0˜å ˜å  Sã“¼]ĞÿëÑüÿêü0å  •å|>å  ƒåÌüÿêè0åè€å`1“å ã  
0˜å$å  Sã ˜å“KĞÿëbÙÿë 0 ã  ã\0ˆåX0ˆåP ˆå¹üÿê  •å  ãÛğÿë å  •åMĞÿë²üÿê  •åÀàÿë å®üÿê  ã åĞğÿë80å<ƒã80€åÎúÿë|1å`1“å ã£üÿ
ˆå°å0˜å ˜å  Sã“˜0å%Ğÿë™üÿê  ã å»ğÿë80å<ƒã80€å¹úÿëĞ1å`1“å ãüÿ
Üå å0˜å ˜å  Sã“ì0åĞÿë„üÿê åöÖÿëüÿê(ååòÖÿë}üÿê4åïÖÿëzüÿê0å@å@å 0“åàèÖÿësüÿêPååäÖÿëoüÿê  ã •å‡àÿë åjüÿêå å  ãÆàÿë0å  ã   á  ãùÿë”2å`1“å ã]üÿ
 ‚å å0˜å ˜å  Sã“°àÏÿëTüÿê¬2å´"å¼å  “åXĞÿëÀ2å	 á  “åï×ÿëĞ2å
  ã “åwĞÿë{ıÿêğåEÖÿë€ ãµüÿê € ã³üÿê0å 3åå#å  “åCĞÿë0å#å0ƒà  ’åÓåØ×ÿë,3å
  ã “å`Ğÿëüÿê
° á€ ãŸüÿê  á á?ÖÿëŒşÿê¬å •åyúÿë"üÿêhå¹Öÿë“ıÿêğO-é p áPåĞMâ  Uã`åÌ 
  Vã  
80–å ãØ  0—å  Sã€“€— •åÍãÿë @ á  áàÿë  Pã    
  Tã  
  á  á  ã*àÿëğäÿë0•å  Sã<@“@•  á …å  ê0”å Sáã  
 @”å  Tãùÿÿ P•å  Uãàÿÿ@—å  Tã`  
  áËÿÿë @”å  TãúÿÿP—å  UãX  
$ˆŸå  VãI  
80–å ãF  
0•å  SãC  
8 “å  ã@  •å  ‚ã  Qã8 ƒå|^åâ 
<@“å  Tã    ê @”å  Tã  
0”å Sãà  
0”å Sáöÿÿ
 ”å Rãóÿÿ0“å0“å Sáïÿÿ
  áŒŸåÖÿë @”å  Tãìÿÿ@–å Tã 
  ã á   ãĞùÿë<0–å  Sã  Ö  ê 0“å  SãÓ  
 “å Rãùÿÿ“å  Qã@ƒ    ê á ‘å  Rãûÿÿ@â  ã  ã¸ßÿë  „å0•å0€å•å  Qã  
0•å  Sã­  
0“å  Sãª  
 P•å  Uã§ÿÿ  VãM  
80–å	ã.   –å  Rã˜ 
 ã  
0—å  Sã  
<@–å  Tã    ê Sã¯  
 Sã¢  
 @”å  Tã  
0”å Sãõÿÿ0”å  Sã  
  “å Bâ Rã 0 ƒ0“• –å Bâ RãÄ  Š “å Rãêÿÿš  á “åŸå»Õÿë @”å  Tãæÿÿ80–å9ƒã80†åã  0—å  Sã  
@“åäŸåHP–åaßÿë  Tãj 
  Pãd 
 á   á  ãpßÿë @ á  Uã_ 
  Tã  
 á  á  ãgßÿë P áHP†åĞâğ½è0–åtEŸå  Sã  0 á|å  ê 0“å  Sã  
 “å  Rãùÿÿ
 ’å  Pãöÿÿ

ùÿëP—å  Uã    á6ßÿëP—å  Uã € áÿÿ’ÿÿê –åşøÿë P•å  Uãóÿÿ
0•å|^å  Sãøÿÿ
0“å  Sãõÿÿòÿÿê ”åĞâÿë å	  á‘ßÿë å Pâ   
  Rã  
  ã.ßÿë  á  áåñãÿë •å  Rã 0 á å  
 ’å Rã  
—âÿë 0 á å ”å0„å Rãûşÿ ”å  Rã  
 0’å0Câ Sãz  š 0 ãH0“åğ ğç  á<ŸåBÕÿëÿÿê0 á   ê0 á  “åpƒå  Rãúÿÿ  •å  ƒå …å …åP áòşÿê 0 ã0“åğ ğç0–å0Câ Sã  š ”å 0’å SãTÿÿ0–å0Câ  ê0–å0Câ Sã  š  á´ŸåÕÿëP”å  á0•å “éÇçÿë  Pã  
0•å  á “éÁçÿë  Pã=ÿÿ  áxŸåÕÿë9ÿÿê ”å ’å Qã\   Sã0’å2ÿÿŠ  á “é±çÿë  Pã-ÿÿ  á<Ÿå –åşÔÿë(ÿÿê  á,Ÿå –åùÔÿë#ÿÿê0•å0“å Sãàşÿ
#Ÿå  ã áõŞÿë •å Pâ  
  Rã	    
  á	 á³Şÿë   á0•å …å<@“å  Tã  Ìşÿê @”å  TãÉşÿ
0”å Sáùÿÿ	  áÿŞÿë ”å  Pã    
  Rã  
  á  ã›Şÿë „åìÿÿê°’å •åH ›å~Şÿë å åíŞÿë0å  Sã   á„  
  Pã  
 á  ã‰Şÿë 0 á  Zã
  
  Sã  

 á  á  ã€Şÿë   áH ‹å]şÿê  Zãöÿÿ  áùÿÿê  áôŸå –å©Ôÿëzÿÿê  Vãÿÿ
0å ã  Sã   “Ì!Ÿå½ãÿëâÿë0ãÿë @—å  Tã  á/  
¤¡Ÿå € ã0”å á  SãP“P”  áPåFãÿë  Pã  
  á árãÿë  Pã1  h!Ÿå ã  á¢ãÿë ååáÿëãÿë å	  á¥Şÿëâ å â^ßÿë åÛŞÿë å  Pã  
 0å Sã  
ÔŞÿë  Xã  
 —å  ˜å 0 ã‡å  ‡å 0ˆå@–å —å  Qã   
  Rã  
  ã,Şÿë  áP—å@†å  Uãşÿrşÿê0å
 Sáäÿÿ¹Şÿë  á×ıÿë 0”åp„å  Sã€ áßÿÿ
@ áµÿÿê  á|Ÿå…÷ÿë0•åşÿê  álŸå€÷ÿë80–åaşÿê  Uã¡şÿP á¤şÿê @ á™şÿê 0 á~ÿÿê  á<Ÿås÷ÿëZşÿê,U T( P)  3 (( ¤) Ô) ø( ) À3 À( p3 ( €( ¤( ğG-éÙòÿëHQŸå€>Uå  Sã   Úöÿë8AŸå8Ÿå   ã0 áÀ„â,Ÿå  ã@Àˆå|Nå<@ˆåêöÿëQŸå „åŸåÍÿë  Pã  1Ÿ  ƒ…øÿë 0•å  Sã5  ô`Ÿå 0–å  Sã-  
”å  ã   ã™åUÍÿë@”åĞ`ŸåĞpŸå ‰å ”å<òÿë „åœ Ÿå{ıÿë@¶å  Tã  
0”å Sã  
  á‡ôÿë  Pã 0•0ƒ 0… @”å  Tãóÿÿ Váîÿÿ 0•å  Sã  h0˜åd ˜å “â   Pã    Qã  ãd ˆåğ‡½ğG½èÿ/á8 ŸåWîÿë  †åÍÿÿê  ãtÍÿë,U ¸F 45 è) Øâ * ìF àâ üF Ğâ `.  å  â  ÿ/á8@-é0å  Sã(  
 @ á å  Pã  
“æÿë  Pã!  
P”å  Uã  
  áÊçÿë0”å0“å  Sã  0”å0“å  Sã  
@”å  Tã    ê @”å  Tã  
  áŞÿÿë  Pãøÿÿ
80•å8ƒã80…å8€½è@”å ”åræÿë  Pã „å     ã8€½è  ã8€½èø@-é¼ŸåÂÌÿë `PâP  
Æéÿë¬1Ÿå@“å  Tã  C  ê0”å  Sã4  
@ áP”å  Uã@  
80•å ãõÿÿ  á’çÿë80•åãğÿÿ
4•åL •å<Ãã Qá80…åêÿÿš  á)æÿë p á  á|ìÿë  á  á”Ìÿë  Pãàÿÿ
80•å  ã>  
<0•å  Sã  &  ê 0“å  Sã#  
 “å Rãùÿÿ “å  Rã  
 0’å0Câ Sã  š   ã…æÿë 0 ã80“åğ ğç 0”å  SãÇÿÿ@”å  Tã  
 0”å  SãÁÿÿ@”å  Tãùÿÿ  á
Íÿë   ãø€½è  áyÿÿë´ÿÿê  ãø€½è 0 ã0“åğ ğçp’å  ágæÿë80—å#4 á0#â  Uá      Pã  
0•å Sã  0•å Sãÿÿ
 á  á Ÿå 0 ãªòÿë˜ÿÿê4 ¸F `4 @-é@å  Tã    ê @”å  Tã  
  áOÿÿë  Pãøÿÿ
   ã€½è  ã€½èğO-éÚMâĞMâ 0 ã PPâ0Íå  
 0Õå  Sã  HŸåÌÿëjâ`†â PPâ8SŸpâ4Ÿå  á0 á  áÒÌÿë$ŸåsÌÿë  Pã  
 0Ğå  Sã  :â0ƒâ0å‹ÌÿëüŸå  á 0 á
â €âÁÌÿë
â €âàŸåÌÿë € á  Xãj  
Ğ’Ÿå  áÌŸå†Õÿëd0™å  Sãš  
¼2Ÿå@“å  Tã  $  ê0”å  Sã  
@ á ”å  ZãK  
8Àšå°âõÿÿ
  áŞæÿë80šåãğÿÿ
<Ãã80Šå
 á0 á  á\"ŸåFòÿë0”å  Sãéÿÿ 0”å  Sãæÿÿ@”å  Tã  
 0”å  Sãàÿÿ@”å  Tãùÿÿ  áuÌÿë0å0Så  Sã  
  áKÌÿë á  ‡àñËÿëğ!Ÿå áÀÒå 0 á  ’åÀÃå  ƒå  á0Ìÿë0å á Câ,Ìÿë  Pã    ã´Ÿå   ãäËÿë áaÒÿëd0™åh ™å @ ã Rá S     d@‰å  
2ÿ/á  áÚâĞâğ½è  áºşÿë  Pã¨ÿÿ
0”å  SãE  
 “å  áHŸå#Ìÿë ÿÿê  ãÚâĞâğ½è:â0ƒâ  á0å  á 0 ãøŸå0BåšËÿë € áƒÿÿê:â0ƒâ`Câ  á  ã áÄËÿë  Pã  :â 0ƒâ 0“å:â	Sã  
  á/ ã"Ìÿë €PâSÿÿ
0eà@ƒâpâ á  á  áËÿëØå0â   ã0ƒà Qá CåPˆEÿÿD Ÿå¾Ëÿë PPâ<PŸ@ÿÿêvèÿëbÿÿêpâ á  á…ËÿëL0Ÿå°0Óá°0Àáğÿÿê ”å  Rã ’¶ÿÿê\ T * * 4* 4 45 d4 ¸F `4 l* P* D* * ğO-é<ĞMâ 0Qâ0å ` á å  
@“åP á  Tã  
  áÍäÿë  á,Ÿå 0 á  áAÛÿë0•å  á SãŸå%Ÿ•%Ÿ…1‚ +•8Ûÿë0å0“å0Câ Sã( š0å<“å  Yã–  
0™å  Sãh  
ØŸå  ã   ãJËÿë™å  ã @ á   ãEËÿë á   á  áÛÿë0™åp“å 4Ÿå WáV  
 P ã€â@ á  áşÿëpˆä|4Ÿå@„â  Uã       PãP p—å Wá‰  
 Tãğÿÿ0å  Uã  S0  0   á‡    á0Ÿå  ãËÿë@ ã  á  áùÚÿë å€„â0âp ãƒàå  ê“å  ã   ãËÿëìŸå  á 0 ã  å  áèÚÿë ›å  Pã  
å  Yã‘  
häÿë	  á¸Ÿå 0 á  áÜÚÿë@Dâ  á¤ŸåºÚÿë tãp‡â  
°8å Uá 0 0
  Sã  
 –å@Ëÿë0å ƒå0›å  SãÕÿÿ›å  Qã‘Òÿÿêå ™å  Yãÿÿ0å<@“å  Tã#  
0”åP á	 Sã  €  ê0•å	 Sã}  
 P•å  Uãùÿÿ   ã á  ê @”å  Tã  
0”å Sãùÿÿ  Qã  á[  ÔŸå…Úÿë ”åÌŸå  á 0 ã?áÿë @”å ã  Tãîÿÿ  Qã]  @åH0”å  Sã  
  ã”Ÿå   ã²Êÿë  á  áoÚÿëH ”åtŸå  á 0 ã)áÿë  áXŸågÚÿë  á\Ÿå<ĞâğO½èbÚÿê0å  Uã  S ° ° °  
  ãÉÊÿë 0Pâ0åz  
 ™å|ıÿë  Pã)  
 å0™å0‚å å 0’å Rá(  
0åå0“å  á0“å0ƒâ0å0åå0å ƒè 0‚å¤Ÿå  ã   ã{Êÿë@Dâ  á  áUÚÿë0å 0“â0   áWÿÿê	  áŒŸå  ãnÊÿë  á ›åfÿÿêxŸåGÚÿë¢ÿÿê0å åPƒå 0’å RáÖÿÿ å 0 ã0‚å0å “å×ÿÿê  á ŸåÚÿëÿÿê0Ÿå  ã   ãTÊÿë0•å$ “å(0“å ’å  á  á+Úÿë0•å  Sã  
  “å Rã  
  ãìŸå   ãCÊÿë  á  á Úÿë 0 ã •å´Ÿå  áºàÿë  áœŸåøÙÿë0å<@“å  Tã`ÿÿxÿÿê “å 0Ÿå Ráçÿÿ0å<@“åõÿÿê0å< “åÙäÿë @PâÑşÿ
  átŸåÚÿë ”åHŸå  á 0 ãàÿë  á,ŸåÜÙÿëÅşÿêãÊÿët* ˆ*  P  * ¸F ¬* ¼* È* ô Ô* , à* @ğ  0 ğ* + À3 ”* 0å  Sã  
 “åÿ/á å  Pã ÿ/á  Ÿåÿ/á¸F , Ÿå Páÿ/0å  Sã  
0“å Sãÿ/ å Páöÿÿÿ/á¸F   å  â  ÿ/á  å0Ÿå  Pã  ÿ/á ğ@-éĞMâPâ@ á p á  á` áÙÿë  Tã  
 ”å  Qã    
  
\şÿë´å  á  Qã  áùÿÿ •è ‡è  áĞâğ€½èŸå  ã   ãÄÉÿë  á  áÙÿëòÿÿê+ p@-éP á å @ á  Qã`å  
 –å  Rã  
ˆ ŸåİÉÿë€ Ÿå€Ÿå0–å  Pã     áŠÙÿë ”åh Ÿå  Qã   ã   ã¥ÉÿëTŸå   á  áÙÿë  á á   ãp@½è&şÿê  á  ã,Ÿå˜Éÿë Ÿå   á  árÙÿë  Vãp€½ïÿÿêPñ (+  l ì   Qã  
À à aB Qâp  
 0°á 0`B Sáo  š áq  
/oáoá @à râ‚ ‚   ãñ   áSá   à?C Sá   à?C Sá   à>C Sá   à>C Sá   à=C Sá   à=C Sá   à<C Sá   à<C Sá   à;C Sá   à;C 
Sá   à:C 
Sá   à:C 	Sá   à9C 	Sá   à9C Sá   à8C Sá   à8C Sá   à7C Sá   à7C Sá   à6C Sá   à6C Sá   à5C Sá   à5C Sá   à4C Sá   à4C Sá   à3C Sá   à3C Sá   à2C Sá   à2C Sá   à1C Sá   à1C  Sá   à0C  Sá   à0C   \ã  `Bÿ/á  <á  `Bÿ/á   3Ì  €ÿ/á/oá bâ  \ã3 á  `Bÿ/á  PãàÃ ³  ê  Qãùÿÿ
@-éuÿÿë@½è’ àAàÿ/á@-é  ãÌÈÿë€½èøC-é p áL`ŸåLPŸå`àPà`eà€ á á¶ÈÿëFa°áøƒ½PEâ @ ã@„â0µå  á á	  á3ÿ/á Tá÷ÿÿøƒ½èDD <D ÿ/á@-é€½è  Usage: %s [-s] [option] <kconfig-file>
 [option] is _one_ of the following:   --listnewconfig         List new options    --oldaskconfig          Start a new configuration using a line-oriented program     --oldconfig             Update a configuration using a provided .config as base     --silentoldconfig       Same as oldconfig, but quietly, additionally update deps    --olddefconfig          Same as silentoldconfig but sets new symbols to their default value     --oldnoconfig           An alias of olddefconfig    --defconfig <file>      New config with default defined in <file>   --savedefconfig <file>  Save the minimal current configuration to <file>    --allnoconfig           New config where all options are answered with no   --allyesconfig          New config where all options are answered with yes      --allmodconfig          New config where all options are answered with mod      --alldefconfig          New config with all symbols set to default      --randconfig            New config with random answer to all options  
%s
    aborted!

  Console input/output is redirected.     Run 'make oldconfig' to update configuration.

 
Error in reading or end of file.
  (NEW)   %*s%s   (%s)    /n  /m  /y  /?  ]   %*c
%*c %s
%*c
 %*s%s
  %*c %s
 %*c  %d. %s  (%s)    (NEW)  %*schoice   [1]: 1  [1-%d   ]:  [%s]    CONFIG_ %s%s
   *
* Restart config...
*
    allno.config    allyes.config   allmod.config   alldef.config   allrandom.config    linux   /usr/share/locale   KCONFIG_SEED    KCONFIG_SEED=0x%X
  %s: Kconfig file missing
   ***
*** Configuration file "%s" not found!
***
*** Please run some configurator (e.g. "make oldconfig" or
*** "make menuconfig" or "make xconfig").
***
    ***
*** Can't find default configuration "%s"!
***
 KCONFIG_ALLCONFIG   *** Can't read seed configuration "%s"!
    all.config  *** KCONFIG_ALLCONFIG set, but no "%s" or "all.config" file found
  KCONFIG_NOSILENTUPDATE  
*** The configuration requires explicit update.

  
*** Error during writing of the configuration.

   
*** Error during update of the configuration.

    n*** Error while saving defconfig to: %s

  oldaskconfig    oldconfig   silentoldconfig savedefconfig   allnoconfig allyesconfig    allmodconfig    alldefconfig    randconfig  listnewconfig   olddefconfig    oldnoconfig Ä+ Ì+ Ô+ à+ ì+ ô+  , , , $, 0, <, L, T, `, h, p, |, ˆ, ”, œ, ¨, ´, ¼, È, Ô, Ü, ä, ô,  - -  - (- 0- 8- @- H- P- X- `- l- x- „- ˜- °- ”- ¬- ¼- Ğ- à- ğ- . P+ . (. 4. @. T. d. t. €. ˆ. . œ. @+ ¬. ¸.  . Ä. Ğ. 8+ Ü. ì. ø.  / ´+ / ¼+  / 0+ 0/ 4/ 8/ @/ ğ( H/     xfwrite if int endif default tristate endchoice def_tristate def_bool defconfig_list on optional option endmenu mainmenu menuconfig modules allnoconfig_y menu select comment env range choice bool source visible hex config boolean string help prompt depends    @+ ”+  P+ œ+      ¨+ ¬+ ´+       ¼+                                                                                                                                                                                      ! " # # $ % &            ! " # # $ % & õÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿõÿ ôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿôÿ óÿ' ( óÿóÿ) óÿóÿóÿóÿóÿóÿóÿóÿóÿóÿ òÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿòÿ * * + * * * * * * * * * * * * *  ğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿğÿ ïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿïÿ îÿîÿîÿîÿîÿîÿîÿîÿîÿîÿîÿîÿ, îÿîÿîÿ - - íÿ- - - - - - - - - - - - -  ìÿ. / ìÿìÿìÿìÿìÿìÿìÿìÿìÿìÿìÿìÿìÿ 0 ëÿëÿ0 0 0 0 0 0 0 0 0 0 0 0 0  1 1 2 1 êÿ1 1 êÿ1 1 1 1 1 1 êÿ1  éÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿéÿ èÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿèÿ 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3  æÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿæÿ åÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿåÿ äÿäÿäÿäÿäÿäÿäÿäÿäÿäÿäÿäÿäÿ5 äÿäÿ ãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿãÿ 6 6 âÿ6 6 6 6 6 6 6 6 6 6 6 6 6  áÿáÿáÿáÿáÿáÿ7 áÿáÿáÿáÿáÿáÿáÿáÿáÿ àÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿàÿ ßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿßÿ ŞÿŞÿŞÿŞÿŞÿŞÿŞÿŞÿŞÿŞÿ8 9 9 ŞÿŞÿŞÿ İÿİÿİÿİÿİÿİÿİÿİÿİÿİÿ9 9 9 İÿİÿİÿ ÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿÜÿ ÛÿÛÿ: ÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿÛÿ ÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿÚÿ;  Ùÿ' ( ÙÿÙÿ) ÙÿÙÿÙÿÙÿÙÿÙÿÙÿÙÿÙÿÙÿ ØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿØÿ * * + * * * * * * * * * * * * *  * * + * * * * * * * * * * * * *  ÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿÕÿ ÔÿÔÿÔÿÔÿÔÿÔÿÔÿÔÿÔÿÔÿÔÿÔÿ, ÔÿÔÿÔÿ - - Óÿ- - - - - - - - - - - - -  Òÿ. / ÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿÒÿ 0 ÑÿÑÿ0 0 0 0 0 0 0 0 0 0 0 0 0  ĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿĞÿ 1 1 2 1 Ïÿ1 1 Ïÿ1 1 1 1 1 1 Ïÿ1  ÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿÎÿ ÍÿÍÿ4 ÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿÍÿ ÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿÌÿ ËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿËÿ 6 6 Êÿ6 6 6 6 6 6 6 6 6 6 6 6 6  ÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿÉÿ ÈÿÈÿÈÿÈÿÈÿÈÿÈÿÈÿÈÿÈÿ< 9 9 ÈÿÈÿÈÿ ÇÿÇÿÇÿÇÿÇÿÇÿÇÿÇÿÇÿÇÿ9 9 9 ÇÿÇÿÇÿ ÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿÆÿ ÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿÅÿ ÄÿÄÿÄÿÄÿÄÿÄÿÄÿÄÿÄÿÄÿ9 9 9 ÄÿÄÿÄÿ                                                                                                                           	   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "                                              	    
    IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII     II 
-I IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIÿÿÿÿ            ÿÿÿÿ                                    ÿÿÿÿ                        ÿÿÿÿ                                               ÿÿÿÿ            ÿÿÿÿ            (           5           >             ÿÿÿÿ            ÿÿÿÿ            M            P            ÿÿÿÿ            ÿÿÿÿ            Y            `            h            ÿÿÿÿ            q   
         ÿÿÿÿ            |             „             ’            ÿÿÿÿ            —                        ¦             ÿÿÿÿ            ª            °            ÿÿÿÿ            ÿÿÿÿ            ·           ÿÿÿÿ            ¼            Ã            Ë           ÿÿÿÿ            ÿÿÿÿ            Ï   	         Ö           ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            Ş           ÿÿÿÿ            ÿÿÿÿ            å            ÿÿÿÿ            ê            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ñ            4" l+ t+ €+ ˆ+ Œ+ arch/$ARCH/defconfig    0+ 8+ @+ H+ P+ X+ `+ h+ ğ(  * ¦ÿ` ¦ÿo ¦ÿ ¦ÿ¦ÿK ¦ÿR * h * n k * s } üÿy ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¢ ¦ÿ£ ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ‹ ¦ÿ¦ÿŠ ¦ÿ ¦ÿ ¦ÿ˜ ¦ÿ¤ § ¨ ¦ÿ¦ÿüÿüÿM îÿ¦ÿ± ¹ ! G Ã ÷ ì şÿì « ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ) ¦ÿüÿüÿŠ a a ¦ÿ¦ÿº » Â * * üÿÄ a ¦ÿÛ ¦ÿ¦ÿ¦ÿ¦ÿÒ ¦ÿ¦ÿÌ * * Ç ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿŞ ¦ÿß ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ× ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿüÿŞ ä Ş ûÿŞ a # å ¦ÿ¦ÿŞ è Ş üÿ¦ÿ‡ é ¦ÿ¦ÿê ë Ş ğ ¦ÿ¦ÿí ¦ÿï óÿ¦ÿ¦ÿ¦ÿ¦ÿô * ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ   	
 !"#  C D 
 ] ^ L  L   Q  Q  h "     !    Z [    !  N # P     f      	 
               N  P  E …  …  œ         !      	 
   –               ¤ d M N  P M N  P    !     s      	 
                            	 
                    !             	 
   ¹                    	 
                           	 
            	 
  !        	 
            —  ™ š › "     ¡ % £ L ÿÿO t ÿÿÿÿÿÿÿÿ¬   
 X Y 6 ’ “ w  z ¤ ]  8  : œ ^ >  Z [ ƒ A B  ‘ C Z [ „  D ˆ áÿa  š áÿáÿáÿáÿáÿáÿáÿáÿb 4 áÿáÿc áÿd e f g h áÿi  j Š ­ \  k  ® ¬  	  ßÿa Z [ ßÿßÿßÿßÿßÿßÿßÿßÿb ¦ ßÿßÿc ßÿd e f g h ßÿi  j ³ — { ~ k ‡ } ‚  ‹  Z [ ûÿ 7 ¡         A B           9 ;  = üÿ ?           @ G           H I  ´ Z [ 4   «ÿa R S «ÿ«ÿ«ÿ«ÿ«ÿ«ÿ«ÿ«ÿT ¾ «ÿ«ÿc «ÿ«ÿ«ÿ«ÿ«ÿ«ÿ«ÿU a j V W ÌÿÌÿŒ ÌÿÌÿÌÿÌÿb _ ÌÿÌÿc r s t u ` ” • –  j › Ÿ a £ v ´ÿ´ÿ´ÿ´ÿ´ÿ´ÿ´ÿ´ÿ  ¤ ´ÿ´ÿc         [ j     Œ     ¨ ¯   ± µ ¶ ·   » § ¼ © ª « ¹ ½ 5 3   ° K ² y   … ¢         ¸    h  cd     u        ""7AF]O	X
 iJ e v f   st   lg       X  KS3T  p  C      a   / ('#$ &%  a ;<8:9B65GIEHDj_ ^PRNQMZ[YoqrnmV j jjj   W?j j `  )b  j1. > k\*+,  0=@-2                  g g g i i k m n o p q r v z z z z z z z z ~  €  ‚ ƒ ‡ ˆ  – œ ¤ ® ° ± ² ³ ´ µ ¸ À Æ Ğ Ö Ü ß á ì í ò û  %+57<DLOQRSX_fksvxyz}…Œ“™ ¢£¤§¯±²µ¼¾ÃÄÇÈÉÍÎÑÒÕÖ×ØÙÚÛŞßâã  % ÿQ&ÿ&ÿ?'ÿ'ÿÿ')ÿ'7ÿ'Cÿ'Pÿ'ÿ'(ÿ'ÿÿÿÿÿÿÿÿÿÿ=ÿGÿ,ÿ.ÿEÿÿÿ
ÿ+/ÿÿ-/ÿÿ/0ÿ/1ÿ/Kÿ/Iÿ/*ÿ/ÿNÿORÿSRÿRÿTTRÿ2ÿÿ23ÿÿ"OÿUÿ48ÿPÿ5:6ÿÿ89ÿ8Kÿ8Iÿ8ÿ8*ÿORÿNÿÿRÿÿ:)ÿSQÿPÿ;><ÿÿ>)ÿ>Cÿ>7ÿOQÿOÿ@LJÿPÿADBÿÿD)ÿDCÿD7ÿOÿ	OÿFJÿÿHÿÿJKÿJÿJ*ÿSÿÿLMÿLÿRÿÿORÿÿÿÿÿÿÿQÿÿSÿTÿT"TÿTTÿSÿ#SÿS SÿS!Sÿÿÿÿÿ               $ ( * , . 0 2 4 6 8 : < > @ B D H K O R V Y Z ] ` c f i l p u z  … ‰ Š   ’ – ™ › Ÿ   £ ¦ © ¬ ¯ ´ ¸ » À Á Ä È Ê Î Ï Ò Õ Ø Ü à ä æ ê ë î ñ ô ø ü ÿ 	"$&),/1458:>BFIMQSUV   $%%&&''''''''(((((((())))))**+,-.///////000001223345678888889999::;<=>>>>?@ABCDDDDEFGHIJJJJKLLLMNNOOPPPQQRRSSSSSSSTTUU ¦ÿ¦ÿ¦ÿ ºÿ¦ÿ¦ÿ¦ÿ¦ÿó ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿĞÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿìÿ¦ÿ¦ÿ¦ÿ¦ÿ¦ÿÎ Í ¼ÿ¦ÿ¦ÿ© ÿÿ ùÿv ¾ÿ§ÿ¦ÿÿÿ   ! " l # $ % & J m n  º ' ( | ) L x M * € + N  , - ‰ . P / 0 1 o p Q q O † ˜ ™ 2  ¥ E F <  %&'?QO 	
()+,-.457;=@ACEFGP'&QOOUO#ST//8:>LDJSS !Q"*01HIK*9IK)6P)7<CPJM)7BCP*KSSTTONOST2ONRSRRRRTRRSR"3O There is no help available for this option. <none>  %s:%d: %s
  Stack now    %d %s:%d:warning:  %s:%d:  _MODULE 0x  #define %s%s%s 1
   #define %s%s %s%s
  #define %s%s %s
    %.*s    \"  #
#     
#  token %s (  nterm %s (  Deleting    %s  %s:%d: missing end statement for this entry
    # %s%s is not set
  %s%s=%s
    len != 0    scripts/kconfig/lkc.h   %s%s=%c
    out of dynamic memory in zconfensure_buffer_stack() <token> unexpected '%s' within %s block '%s' in different file than '%s'    %s:%d: location of the '%s'
    Out of memory.
 /*
 Error in writing or end of file.
    */
     *  
Automatically generated file; DO NOT EDIT.
%s
 out of dynamic memory in zconf_create_buffer()  flex scanner push-back overflow %s:%d:warning: multi-line strings not supported
                flex scanner jammed fatal flex scanner internal error--end of buffer missed fatal error - scanner input buffer overflow input in flex scanner failed    out of dynamic memory in yy_get_next_buffer()   fatal flex scanner internal error--no action found  out of dynamic memory in zconf_scan_buffer()    out of dynamic memory in zconf_scan_bytes() bad buffer in zconf_scan_bytes()    srctree %s/%s   .kconfig.d  include/config/auto.conf    ..config.tmp    deps_config := \
   KCONFIG_AUTOCONFIG  	%s \
  	%s
    
%s: \
	$(deps_config)

    
$(deps_config): ;
 ifneq "$(%s)" "%s"
 %s: FORCE
  endif
  .config KCONFIG_CONFIG  can't copy type %d
 how to free type %d?
   boolean symbol %s tested for 'm'? test forced to 'n'
   boolean symbol %s tested for 'm'? test forced to 'y'
   y   (   <choice>    !   =   !=   ||      &&      ^  [   ]   <unknown type %d>   
choice
    
config %s
   boolean
    tristate
   string
     integer
    hex
    ???
    prompt      default     #choice value
      select      range       menu    unknown prop %d!
   help
%s
  
comment    
menu   
endmenu
    if       depends   ??? expr_calc_value: %d?
   warning: (  ) selects %s which has unmet direct dependencies (  %lld    0x%llx  KCONFIG_PROBABILITY  [=%s]  using defaults found in %s  is not set  override: reassigning to symbol %s  symbol value '%s' invalid for %s    invalid string found    unexpected data %s creates inconsistent choice state    override: %s changes choice state   include/config  .h  ../..   can't find file %s
 %s:%d: can't open file "%s"
    %s:%d: recursive inclusion detected. Inclusion path:
  current file : '%s'
   included from: '%s:%d'
   \   "   include/generated/autoconf.h    include/config/tristate.conf    include/config/auto.conf.cmd    .tmpconfig  .tmpconfig_tristate .tmpconfig.h    KCONFIG_AUTOHEADER  KCONFIG_TRISTATE    unknown %s:%d:error: recursive dependency detected!
    %s:%d:	symbol %s %s value contains %s
  %s:%d:	symbol %s depends on %s
 %s:%d:	choice %s contains symbol %s
    %s:%d:	symbol %s is part of choice %s
  %s:%d:	symbol %s is selected by %s
 unexpected recursive dependency error
  Oops! How to check %d?
 UNAME_RELEASE   leading whitespace ignored  prompt redefined    ignoring type redefinition of '%s' from '%s' to '%s'    symbol '%s' redefines option 'modules' already defined by symbol '%s'   trying to redefine defconfig symbol redefining environment symbol from %s   environment variable %s undefined   Starting parse
 Stack size increased to %lu
    Entering state %d
  Reading a token:    Now at end of input.
   Next token is   Shifting    Reducing stack by rule %d (line %lu):
     $%d =    unexpected end statement    unknown statement "%s"  unexpected option "%s"  invalid statement   unknown option "%s" invalid option  %s:%d:config %s
    %s:%d:endconfig
    %s:%d:menuconfig %s
    warning: menuconfig statement without prompt    %s:%d:type(%u)
 %s:%d:prompt
   %s:%d:default(%u)
  %s:%d:select
   %s:%d:range
    warning: ignoring unknown option %s %s:%d:choice
   %s:%d:endchoice
    %s:%d:optional
 %s:%d:default
  %s:%d:if
   %s:%d:endif
    %s:%d:menu
 %s:%d:endmenu
  %s:%d:source %s
    %s:%d:comment
  %s:%d:help
 %s:%d:depends on
   -> $$ = syntax error    Error: discarding   Error: popping  memory exhausted    Cleanup: discarding lookahead   Cleanup: popping    choice value must have a prompt defaults for choice values not supported    choice value used outside its choice group  config symbol defined without type  choice must have a prompt   default for config symbol '%s' must be a single symbol  '%s': number is invalid config symbol '%s' uses select, but is not boolean or tristate  '%s' has wrong type. 'select' only accept arguments of boolean and tristate type    range is only allowed for int or hex symbols    range is invalid    Linux Kernel Configuration  ZCONF_DEBUG /   %s%s    KCONFIG_OVERWRITECONFIG %s.tmpconfig.%d 
#
# %s
#
  configuration written to %s .old    Symbol: %s [=%s]
   Type  : %s
 Range :     Prompt: %s
   Location:
    %*c-> %s     (%s [=%s])   Selects:    Selected by:    Defined at %s:%d
   Depends on:   No matches found.
  %s%s:

 prompt  comment menu    default choice  select  range   env boolean tristate    integer hex string  endmenu endchoice   if  endif   depends visible $end    error   $undefined  T_MAINMENU  T_MENU  T_ENDMENU   T_SOURCE    T_CHOICE    T_ENDCHOICE T_COMMENT   T_CONFIG    T_MENUCONFIG    T_HELP  T_HELPTEXT  T_IF    T_ENDIF T_DEPENDS   T_OPTIONAL  T_PROMPT    T_TYPE  T_DEFAULT   T_SELECT    T_RANGE T_VISIBLE   T_OPTION    T_ON    T_WORD  T_WORD_QUOTE    T_UNEQUAL   T_CLOSE_PAREN   T_OPEN_PAREN    T_EOL   T_OR    T_AND   T_EQUAL T_NOT   $accept input   start   stmt_list   option_name common_stmt option_error    menuconfig_entry_start  menuconfig_stmt config_option_list  config_option   symbol_option   symbol_option_list  symbol_option_arg   choice_entry    choice_end  choice_stmt choice_option_list  choice_option   choice_block    if_entry    if_end  if_stmt if_block    mainmenu_stmt   menu_entry  menu_end    menu_block  source_stmt comment_stmt    help_start  help    depends_list    visibility_list prompt_stmt_opt end nl  if_expr expr    word_opt     êş                                                                                                                                                                       d <              ¬    ì     0          0       õşÿo”    	    $ 
   _                  ô0    H           d    4    0         şÿÿo ÿÿÿo   ğÿÿot                                                 0         ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸ ¸                   lô             |ô            ˆô            œô           ˜ô        	   ¨ô            ´ô            Äô            Ôô            äô            ğô         
    õ            õ                             /        äì     äì                                                                   `.     `.                                                                                                                                                                                          €                       h0 ”5 1 ”5 ¤+ Ü3    GCC: (Raspbian 4.9.2-10) 4.9.2 GCC: (Raspbian 4.8.4-1) 4.8.4 A0   aeabi &   6 	
" .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.exidx .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .comment .ARM.attributes                     4           P           p           ”           $           	           t                      4      	     d      
     ¬           ¸           8           ì           ì           T/           \/            0           0           0           0           ô0           (2           €4                                               ñÿJ   P        M   t        J   T/        J   ¤        J   ì        J   (2        P            ñÿM   °        ™   °       J   Ì        M   ¬        M   ì        ¦            ñÿM   ´        M   ì        ï            ñÿM   œ        ö   œ À     J            M   \          \ H     J            M   8          8 T     J   €        M   ¤          ¤       J   ¼        M   Ä        -  Ä ¤     J   d        M   h        @  h P    J            M   ¸        N  ¸     J            M   H         W  H  ¤    \  ì&     J   œ&        M   ì&        J   ø'        M           J   \        M   Œ        J            M   0        J   0        M   D        J   ø        J   02        g  02      s  42      z  82 à     J   ì        J    4        „   4 €     ‰  $5      “  (5        ,5      ¦  05      ³           ñÿM   (        ¿  ( L     J   L(        M   T(        ×  T( €     J   l(        M   „(        é  Ô( T     J   )        M   ()        ô  () `     J   |)        M   ˆ)          ˆ) @     J   Ä)        M   È)          È) t     J   0*        M   <*          <* d     J   ˜*        M    *        '   * Œ     J   +        M   ,+        3  ,+ x     J   ”+        M   ¤+        >  ¤+ 8    J   Ì+        M   à+        J   À,        M   Ü,        R  Ü, (     J   ü,        M   -        a  - ˆ     J   „-        M   Œ-        u  Œ- <     J   Ä-        M   È-        †  È- p     J   4.        M   8.        ”  8. d       œ. „     ª   / @     J   T/        M   `/        È  `/ @     J   ”/        M    /        ß   / È     J   P0        M   h0        ê  h0 ¤     J    1        M   Œ        ÿ  Œ $     J   ¤        M   1          1 x     J   |1        M   „1        %  „1 ´     J   02        M   82        >  82 $    J   83        M   °        U  ° ,     J   Ô        M   \3        e  \3 <     J   ”3        M   ˜3        p  ˜3 D     J   Ø3        M   Ü        }  Ü ,     J            M   Ü3          Ü3     J   Ô4        M   è4        ¢  è4 P     J   05        M   85        Ê  85 \     J   Œ5        M   ”5        á  ”5 È     J   T6        M   \6        J   Ü6        M   à6        J   @7        M   D7        J   ¤7        M   ¨7        ÷  ¨7 p     J   8        M   8        J   p8        M   t8        J   Ü8        M   à8        J   ø9        M   ”:        J   TG        M   ĞG        J   \H        M   `H        J   ÄH        M   ÈH        J   `I        M   dI        J   èI        M   ğI        J   J        M   J        J   (J        M   ,J        J   8J        M   <J        J   HJ        M   LJ        J   XJ        M   \J        J   hJ        M   lJ        J   xJ        M   |J        J   ˆJ        M   ŒJ        J   ˜J        M   œJ        J   ¨J        M   ¬J        J    K        M   $K        J   TK        M   XK        J   äK        M   ğK        J   üK        M    L        J   L        M    L        J   èM        M   (N        J   hO        M   lO        J   ¨O        M   ¬O        J   ÈO        M   ĞO        J   ìO        M   ôO        J   (P        M   ,P        J   dP        M   hP        J   |P        M   €P        J   ŒP        M   P        	  ¤Q ¬     J   ÄQ        M   àQ        J   HR        M   PR        J    S        M   <S        J   ÄS        M   ÈS        J   dT        M   hT          hT d    J   ÈU        M   ÌU        *  ”W      >  hV ,    J   ¨V        M   ÄV        J   W        M   ”W        J   ¨X        M   ´X        F  ´X ”    J   8^        M   H^        [  H^ ü     J   <_        M   D_        J   Ä_        M   È_        J   0`        M   L`        J   <b        M   Lb        k  Lb <    J   |d        M   ˆd        J   e        M   e        J   <e        M   Xe        J   f        M   f        J   ¬f        M   ´f        J   Üf        M   øf        J   ˆh        M   Œh        J   ài        M    j        J   0l        M   hl        J   Äl        M   Øl        J   (m        M   Dm        J   Èp        M   (q        J   8q        M   <q        J   Lq        €  ,      M   Pq        J   œq        M    q        J   ¸q        M   Àq        J    s        M   s        J   s        M   0s        J   t        M   Èt        —  ğt 0     J   u        M    u        J   Èu        M   äu        J   w        M   w        ´  x è    J   üy        M    z        È   z L     å  Lz L     J   \{        M   p{        J   ¸{        M   Ì{           è‚ <     J   ´‚        M   è‚        J   ´ƒ        M   Äƒ        J   |‡        M   Œ‡        J   HŠ        M   \Š        J   |Š        M   Š        J   `‹        M   Œ        J   ŒŒ        M   @        J            M           J   `        M   t        J   Œ        M            J           M   ,        J   D‘        M   L‘        J   Ü’        M    “           “ Ğ     J   È“        M   Ğ“        J   0”        M   @”        J   0•        M   T•        J   ø˜        M   ™        J   0        M   t        $  t ¸    J   Ÿ        M   ,Ÿ        J   ¡        M   ,¡        J   ,£        M   @£        J   t¤        M   x¤        J   ¥        M   ¥        J   |¥        M   Œ¥        J   §        M   4§        J   X¨        M   `¨        6  `¨ Œ     J   ´ª        M    «        J   Œ¬        M   ˜¬        P  t³ Ğ     J   ¤²        M   Ô²        c  Ô²       J   ô²        M   ³        J   p³        M   t³     