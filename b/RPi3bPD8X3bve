/*
 * include/linux/mfd/asic3.h
 *
 * Compaq ASIC3 headers.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Copyright 2001 Compaq Computer Corporation.
 * Copyright 2007-2008 OpenedHand Ltd.
 */

#ifndef __ASIC3_H__
#define __ASIC3_H__

#include <linux/types.h>

struct led_classdev;
struct asic3_led {
	const char	*name;
	const char	*default_trigger;
	struct led_classdev *cdev;
};

struct asic3_platform_data {
	u16 *gpio_config;
	unsigned int gpio_config_num;

	unsigned int irq_base;

	unsigned int gpio_base;

	unsigned int clock_rate;

	struct asic3_led *leds;
};

#define ASIC3_NUM_GPIO_BANKS	4
#define ASIC3_GPIOS_PER_BANK	16
#define ASIC3_NUM_GPIOS		64
#define ASIC3_NR_IRQS		ASIC3_NUM_GPIOS + 6

#define ASIC3_IRQ_LED0		64
#define ASIC3_IRQ_LED1		65
#define ASIC3_IRQ_LED2		66
#define ASIC3_IRQ_SPI		67
#define ASIC3_IRQ_SMBUS		68
#define ASIC3_IRQ_OWM		69

#define ASIC3_TO_GPIO(gpio) (NR_BUILTIN_GPIO + (gpio))

#define ASIC3_GPIO_BANK_A	0
#define ASIC3_GPIO_BANK_B	1
#define ASIC3_GPIO_BANK_C	2
#define ASIC3_GPIO_BANK_D	3

#define ASIC3_GPIO(bank, gpio) \
	((ASIC3_GPIOS_PER_BANK * ASIC3_GPIO_BANK_##bank) + (gpio))
#define ASIC3_GPIO_bit(gpio) (1 << (gpio & 0xf))
/* All offsets below are specified with this address bus shift */
#define ASIC3_DEFAULT_ADDR_SHIFT 2

#define ASIC3_OFFSET(base, reg) (ASIC3_##base##_BASE + ASIC3_##base##_##reg)
#define ASIC3_GPIO_OFFSET(base, reg) \
	(ASIC3_GPIO_##base##_BASE + ASIC3_GPIO_##reg)

#define ASIC3_GPIO_A_BASE      0x0000
#define ASIC3_GPIO_B_BASE      0x0100
#define ASIC3_GPIO_C_BASE      0x0200
#define ASIC3_GPIO_D_BASE      0x0300

#define ASIC3_GPIO_TO_BANK(gpio) ((gpio) >> 4)
#define ASIC3_GPIO_TO_BIT(gpio)  ((gpio) - \
				  (ASIC3_GPIOS_PER_BANK * ((gpio) >> 4)))
#define ASIC3_GPIO_TO_MASK(gpio) (1 << ASIC3_GPIO_TO_BIT(gpio))
#define ASIC3_GPIO_TO_BASE(gpio) (ASIC3_GPIO_A_BASE + (((gpio) >> 4) * 0x0100))
#define ASIC3_BANK_TO_BASE(bank) (ASIC3_GPIO_A_BASE + ((bank) * 0x100))

#define ASIC3_GPIO_MASK          0x00    /* R/W 0:don't mask */
#define ASIC3_GPIO_DIRECTION     0x04    /* R/W 0:input */
#define ASIC3_GPIO_OUT           0x08    /* R/W 0:output low */
#define ASIC3_GPIO_TRIGGER_TYPE  0x0c    /* R/W 0:level */
#define ASIC3_GPIO_EDGE_TRIGGER  0x10    /* R/W 0:falling */
#define ASIC3_GPIO_LEVEL_TRIGGER 0x14    /* R/W 0:low level detect */
#define ASIC3_GPIO_SLEEP_MASK    0x18    /* R/W 0:don't mask in sleep mode */
#define ASIC3_GPIO_SLEEP_OUT     0x1c    /* R/W level 0:low in sleep mode */
#define ASIC3_GPIO_BAT_FAULT_OUT 0x20    /* R/W level 0:low in batt_fault */
#define ASIC3_GPIO_INT_STATUS    0x24    /* R/W 0:none, 1:detect */
#define ASIC3_GPIO_ALT_FUNCTION  0x28	 /* R/W 1:LED register control */
#define ASIC3_GPIO_SLEEP_CONF    0x2c    /*
					  * R/W bit 1: autosleep
					  * 0: disable gposlpout in normal mode,
					  * enable gposlpout in sleep mode.
					  */
#define ASIC3_GPIO_STATUS        0x30    /* R   Pin status */

/*
 * ASIC3 GPIO config
 *
 * Bits 0..6   gpio number
 * Bits 7..13  Alternate function
 * Bit  14     Direction
 * Bit  15     Initial value
 *
 */
#define ASIC3_CONFIG_GPIO_PIN(config) ((config) & 0x7f)
#define ASIC3_CONFIG_GPIO_ALT(config)  (((config) & (0x7f << 7)) >> 7)
#define ASIC3_CONFIG_GPIO_DIR(config)  ((config & (1 << 14)) >> 14)
#define ASIC3_CONFIG_GPIO_INIT(config) ((config & (1 << 15)) >> 15)
#define ASIC3_CONFIG_GPIO(gpio, alt, dir, init) (((gpio) & 0x7f) \
	| (((alt) & 0x7f) << 7) | (((dir) & 0x1) << 14) \
	| (((init) & 0x1) << 15))
#define ASIC3_CONFIG_GPIO_DEFAULT(gpio, dir, init) \
	ASIC3_CONFIG_GPIO((gpio), 0, (dir), (init))
#define ASIC3_CONFIG_GPIO_DEFAULT_OUT(gpio, init) \
	ASIC3_CONFIG_GPIO((gpio), 0, 1, (init))

/*
 * Alternate functions
 */
#define ASIC3_GPIOA11_PWM0		ASIC3_CONFIG_GPIO(11, 1, 1, 0)
#define ASIC3_GPIOA12_PWM1		ASIC3_CONFIG_GPIO(12, 1, 1, 0)
#define ASIC3_GPIOA15_CONTROL_CX	ASIC3_CONFIG_GPIO(15, 1, 1, 0)
#define ASIC3_GPIOC0_LED0		ASIC3_CONFIG_GPIO(32, 1, 0, 0)
#define ASIC3_GPIOC1_LED1		ASIC3_CONFIG_GPIO(33, 1, 0, 0)
#define ASIC3_GPIOC2_LED2		ASIC3_CONFIG_GPIO(34, 1, 0, 0)
#define ASIC3_GPIOC3_SPI_RXD		ASIC3_CONFIG_GPIO(35, 1, 0, 0)
#define ASIC3_GPIOC4_CF_nCD		ASIC3_CONFIG_GPIO(36, 1, 0, 0)
#define ASIC3_GPIOC4_SPI_TXD		ASIC3_CONFIG_GPIO(36, 1, 1, 0)
#define ASIC3_GPIOC5_SPI_CLK		ASIC3_CONFIG_GPIO(37, 1, 1, 0)
#define ASIC3_GPIOC5_nCIOW		ASIC3_CONFIG_GPIO(37, 1, 1, 0)
#define ASIC3_GPIOC6_nCIOR		ASIC3_CONFIG_GPIO(38, 1, 1, 0)
#define ASIC3_GPIOC7_nPCE_1		ASIC3_CONFIG_GPIO(39, 1, 0, 0)
#define ASIC3_GPIOC8_nPCE_2		ASIC3_CONFIG_GPIO(40, 1, 0, 0)
#define ASIC3_GPIOC9_nPOE		ASIC3_CONFIG_GPIO(41, 1, 0, 0)
#define ASIC3_GPIOC10_nPWE		ASIC3_CONFIG_GPIO(42, 1, 0, 0)
#define ASIC3_GPIOC11_PSKTSEL		ASIC3_CONFIG_GPIO(43, 1, 0, 0)
#define ASIC3_GPIOC12_nPREG		ASIC3_CONFIG_GPIO(44, 1, 0, 0)
#define ASIC3_GPIOC13_nPWAIT		ASIC3_CONFIG_GPIO(45, 1, 1, 0)
#define ASIC3_GPIOC14_nPIOIS16		ASIC3_CONFIG_GPIO(46, 1, 1, 0)
#define ASIC3_GPIOC15_nPIOR		ASIC3_CONFIG_GPIO(47, 1, 0, 0)
#define ASIC3_GPIOD4_CF_nCD		ASIC3_CONFIG_GPIO(52, 1, 0, 0)
#define ASIC3_GPIOD11_nCIOIS16		ASIC3_CONFIG_GPIO(59, 1, 0, 0)
#define ASIC3_GPIOD12_nCWAIT		ASIC3_CONFIG_GPIO(60, 1, 0, 0)
#define ASIC3_GPIOD15_nPIOW		ASIC3_CONFIG_GPIO(63, 1, 0, 0)


#define ASIC3_SPI_Base		      0x0400
#define ASIC3_SPI_Control               0x0000
#define ASIC3_SPI_TxData                0x0004
#define ASIC3_SPI_RxData                0x0008
#define ASIC3_SPI_Int                   0x000c
#define ASIC3_SPI_Status                0x0010

#define SPI_CONTROL_SPR(clk)      ((clk) & 0x0f)  /* Clock rate */

#define ASIC3_PWM_0_Base                0x0500
#define ASIC3_PWM_1_Base                0x0600
#define ASIC3_PWM_TimeBase              0x0000
#define ASIC3_PWM_PeriodTime            0x0004
#define ASIC3_PWM_DutyTime              0x0008

#define PWM_TIMEBASE_VALUE(x)    ((x)&0xf)   /* Low 4 bits sets time base */
#define PWM_TIMEBASE_ENABLE     (1 << 4)   /* Enable clock */

#define ASIC3_NUM_LEDS                  3
#define ASIC3_LED_0_Base                0x0700
#define ASIC3_LED_1_Base                0x0800
#define ASIC3_LED_2_Base 		      0x0900
#define ASIC3_LED_TimeBase              0x0000    /* R/W  7 bits */
#define ASIC3_LED_PeriodTime            0x0004    /* R/W 12 bits */
#define ASIC3_LED_DutyTime              0x0008    /* R/W 12 bits */
#define ASIC3_LED_AutoStopCount         0x000c    /* R/W 16 bits */

/* LED TimeBase bits - match ASIC2 */
#define LED_TBS		0x0f /* Low 4 bits sets time base, max = 13 */
			     /* Note: max = 5 on hx4700	*/
			     /* 0: maximum time base */
			     /* 1: maximum time base / 2 */
			     /* n: maximum time base / 2^n */

#define LED_EN		(1 << 4) /* LED ON/OFF 0:off, 1:on */
#define LED_AUTOSTOP	(1 << 5) /* LED ON/OFF auto stop 0:disable, 1:enable */
#define LED_ALWAYS	(1 << 6) /* LED Interrupt Mask 0:No mask, 1:mask */

#define ASIC3_CLOCK_BASE	   0x0A00
#define ASIC3_CLOCK_CDEX           0x00
#define ASIC3_CLOCK_SEL            0x04

#define CLOCK_CDEX_SOURCE       (1 << 0)  /* 2 bits */
#define CLOCK_CDEX_SOURCE0      (1 << 0)
#define CLOCK_CDEX_SOURCE1      (1 << 1)
#define CLOCK_CDEX_SPI          (1 << 2)
#define CLOCK_CDEX_OWM          (1 << 3)
#define CLOCK_CDEX_PWM0         (1 << 4)
#define CLOCK_CDEX_PWM1         (1 << 5)
#define CLOCK_CDEX_LED0         (1 << 6)
#define CLOCK_CDEX_LED1         (1 << 7)
#define CLOCK_CDEX_LED2         (1 << 8)

/* Clocks settings: 1 for 24.576 MHz, 0 for 12.288Mhz */
#define CLOCK_CDEX_SD_HOST      (1 << 9)   /* R/W: SD host clock source */
#define CLOCK_CDEX_SD_BUS       (1 << 10)  /* R/W: SD bus clock source ctrl */
#define CLOCK_CDEX_SMBUS        (1 << 11)
#define CLOCK_CDEX_CONTROL_CX   (1 << 12)

#define CLOCK_CDEX_EX0          (1 << 13)  /* R/W: 32.768 kHz crystal */
#define CLOCK_CDEX_EX1          (1 << 14)  /* R/W: 24.576 MHz crystal */

#define CLOCK_SEL_SD_HCLK_SEL   (1 << 0)   /* R/W: SDIO host clock select */
#define CLOCK_SEL_SD_BCLK_SEL   (1 << 1)   /* R/W: SDIO bus clock select */

/* R/W: INT clock source control (32.768 kHz) */
#define CLOCK_SEL_CX            (1 << 2)


#define ASIC3_INTR_BASE		0x0B00

#define ASIC3_INTR_INT_MASK       0x00  /* Interrupt mask control */
#define ASIC3_INTR_P_INT_STAT     0x04  /* Peripheral interrupt status */
#define ASIC3_INTR_INT_CPS        0x08  /* Interrupt timer clock pre-scale */
#define ASIC3_INTR_INT_TBS        0x0c  /* Interrupt timer set */

#define ASIC3_INTMASK_GINTMASK    (1 << 0)  /* Global INTs mask 1:enable */
#define ASIC3_INTMASK_GINTEL      (1 << 1)  /* 1: rising edge, 0: hi level */
#define ASIC3_INTMASK_MASK0       (1 << 2)
#define ASIC3_INTMASK_MASK1       (1 << 3)
#define ASIC3_INTMASK_MASK2       (1 << 4)
#define ASIC3_INTMASK_MASK3       (1 << 5)
#define ASIC3_INTMASK_MASK4       (1 << 6)
#define ASIC3_INTMASK_MASK5       (1 << 7)

#define ASIC3_INTR_PERIPHERAL_A   (1 << 0)
#define ASIC3_INTR_PERIPHERAL_B   (1 << 1)
#define ASIC3_INTR_PERIPHERAL_C   (1 << 2)
#define ASIC3_INTR_PERIPHERAL_D   (1 << 3)
#define ASIC3_INTR_LED0           (1 << 4)
#define ASIC3_INTR_LED1           (1 << 5)
#define ASIC3_INTR_LED2           (1 << 6)
#define ASIC3_INTR_SPI            (1 << 7)
#define ASIC3_INTR_SMBUS          (1 << 8)
#define ASIC3_INTR_OWM            (1 << 9)

#define ASIC3_INTR_CPS(x)         ((x)&0x0f)    /* 4 bits, max 14 */
#define ASIC3_INTR_CPS_SET        (1 << 4)    /* Time base enable */


/* Basic control of the SD ASIC */
#define ASIC3_SDHWCTRL_BASE     0x0E00
#define ASIC3_SDHWCTRL_SDCONF     0x00

#define ASIC3_SDHWCTRL_SUSPEND    (1 << 0)  /* 1=suspend all SD operations */
#define ASIC3_SDHWCTRL_CLKSEL     (1 << 1)  /* 1=SDICK, 0=HCLK */
#define ASIC3_SDHWCTRL_PCLR       (1 << 2)  /* All registers of SDIO cleared */
#define ASIC3_SDHWCTRL_LEVCD      (1 << 3)  /* SD card detection: 0:low */

/* SD card write protection: 0=high */
#define ASIC3_SDHWCTRL_LEVWP      (1 << 4)
#define ASIC3_SDHWCTRL_SDLED      (1 << 5)  /* SD card LED signal 0=disable */

/* SD card power supply ctrl 1=enable */
#define ASIC3_SDHWCTRL_SDPWR      (1 << 6)

#define ASIC3_EXTCF_BASE        0x1100

#define ASIC3_EXTCF_SELECT        0x00
#define ASIC3_EXTCF_RESET         0x04

#define ASIC3_EXTCF_SMOD0	         (1 << 0)  /* slot number of mode 0 */
#define ASIC3_EXTCF_SMOD1	         (1 << 1)  /* slot number of mode 1 */
#define ASIC3_EXTCF_SMOD2	         (1 << 2)  /* slot number of mode 2 */
#define ASIC3_EXTCF_OWM_EN	         (1 << 4)  /* enable onewire module */
#define ASIC3_EXTCF_OWM_SMB	         (1 << 5)  /* OWM bus selection */
#define ASIC3_EXTCF_OWM_RESET            (1 << 6)  /* ?? used by OWM and CF */
#define ASIC3_EXTCF_CF0_SLEEP_MODE       (1 << 7)  /* CF0 sleep state */
#define ASIC3_EXTCF_CF1_SLEEP_MODE       (1 << 8)  /* CF1 sleep state */
#define ASIC3_EXTCF_CF0_PWAIT_EN         (1 << 10) /* CF0 PWAIT_n control */
#define ASIC3_EXTCF_CF1_PWAIT_EN         (1 << 11) /* CF1 PWAIT_n control */
#define ASIC3_EXTCF_CF0_BUF_EN           (1 << 12) /* CF0 buffer control */
#define ASIC3_EXTCF_CF1_BUF_EN           (1 << 13) /* CF1 buffer control */
#define ASIC3_EXTCF_SD_MEM_ENABLE        (1 << 14)
#define ASIC3_EXTCF_CF_SLEEP             (1 << 15) /* CF sleep mode control */

/*********************************************
 *  The Onewire interface (DS1WM) is handled
 *  by the ds1wm driver.
 *
 *********************************************/

#define ASIC3_OWM_BASE		0xC00

/*****************************************************************************
 *  The SD configuration registers are at a completely different location
 *  in memory.  They are divided into three sets of registers:
 *
 *  SD_CONFIG         Core configuration register
 *  SD_CTRL           Control registers for SD operations
 *  SDIO_CTRL         Control registers for SDIO operations
 *
 *****************************************************************************/
#define ASIC3_SD_CONFIG_BASE	0x0400 /* Assumes 32 bit addressing */
#define ASIC3_SD_CONFIG_SIZE	0x0200 /* Assumes 32 bit addressing */
#define ASIC3_SD_CTRL_BASE	0x1000
#define ASIC3_SDIO_CTRL_BASE	0x1200

#define ASIC3_MAP_SIZE_32BIT	0x2000
#define ASIC3_MAP_SIZE_16BIT	0x1000

/* Functions needed by leds-asic3 */

struct asic3;
extern void asic3_write_register(struct asic3 *asic, unsigned int reg, u32 val);
extern u32 asic3_read_register(struct asic3 *asic, unsigned int reg);

#endif /* __ASIC3_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * Kontron PLD driver definitions
 *
 * Copyright (c) 2010-2012 Kontron Europe GmbH
 * Author: Michael Brunner <michael.brunner@kontron.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License 2 as published
 * by the Free Software Foundation.
 */

#ifndef _LINUX_MFD_KEMPLD_H_
#define _LINUX_MFD_KEMPLD_H_

/* kempld register definitions */
#define KEMPLD_IOINDEX			0xa80
#define KEMPLD_IODATA			0xa81
#define KEMPLD_MUTEX_KEY		0x80
#define KEMPLD_VERSION			0x00
#define KEMPLD_VERSION_LSB		0x00
#define KEMPLD_VERSION_MSB		0x01
#define KEMPLD_VERSION_GET_MINOR(x)	(x & 0x1f)
#define KEMPLD_VERSION_GET_MAJOR(x)	((x >> 5) & 0x1f)
#define KEMPLD_VERSION_GET_NUMBER(x)	((x >> 10) & 0xf)
#define KEMPLD_VERSION_GET_TYPE(x)	((x >> 14) & 0x3)
#define KEMPLD_BUILDNR			0x02
#define KEMPLD_BUILDNR_LSB		0x02
#define KEMPLD_BUILDNR_MSB		0x03
#define KEMPLD_FEATURE			0x04
#define KEMPLD_FEATURE_LSB		0x04
#define KEMPLD_FEATURE_MSB		0x05
#define KEMPLD_FEATURE_BIT_I2C		(1 << 0)
#define KEMPLD_FEATURE_BIT_WATCHDOG	(1 << 1)
#define KEMPLD_FEATURE_BIT_GPIO		(1 << 2)
#define KEMPLD_FEATURE_MASK_UART	(7 << 3)
#define KEMPLD_FEATURE_BIT_NMI		(1 << 8)
#define KEMPLD_FEATURE_BIT_SMI		(1 << 9)
#define KEMPLD_FEATURE_BIT_SCI		(1 << 10)
#define KEMPLD_SPEC			0x06
#define KEMPLD_SPEC_GET_MINOR(x)	(x & 0x0f)
#define KEMPLD_SPEC_GET_MAJOR(x)	((x >> 4) & 0x0f)
#define KEMPLD_IRQ_GPIO			0x35
#define KEMPLD_IRQ_I2C			0x36
#define KEMPLD_CFG			0x37
#define KEMPLD_CFG_GPIO_I2C_MUX		(1 << 0)
#define KEMPLD_CFG_BIOS_WP		(1 << 7)

#define KEMPLD_CLK			33333333

#define	KEMPLD_TYPE_RELEASE		0x0
#define	KEMPLD_TYPE_DEBUG		0x1
#define	KEMPLD_TYPE_CUSTOM		0x2

#define KEMPLD_VERSION_LEN		10

/**
 * struct kempld_info - PLD device information structure
 * @major:	PLD major revision
 * @minor:	PLD minor revision
 * @buildnr:	PLD build number
 * @number:	PLD board specific index
 * @type:	PLD type
 * @spec_major:	PLD FW specification major revision
 * @spec_minor:	PLD FW specification minor revision
 * @version:	PLD version string
 */
struct kempld_info {
	unsigned int major;
	unsigned int minor;
	unsigned int buildnr;
	unsigned int number;
	unsigned int type;
	unsigned int spec_major;
	unsigned int spec_minor;
	char version[KEMPLD_VERSION_LEN];
};

/**
 * struct kempld_device_data - Internal representation of the PLD device
 * @io_base:		Pointer to the IO memory
 * @io_index:		Pointer to the IO index register
 * @io_data:		Pointer to the IO data register
 * @pld_clock:		PLD clock frequency
 * @feature_mask:	PLD feature mask
 * @dev:		Pointer to kernel device structure
 * @info:		KEMPLD info structure
 * @lock:		PLD mutex
 */
struct kempld_device_data {
	void __iomem		*io_base;
	void __iomem		*io_index;
	void __iomem		*io_data;
	u32			pld_clock;
	u32			feature_mask;
	struct device		*dev;
	struct kempld_info	info;
	struct mutex		lock;
};

/**
 * struct kempld_platform_data - PLD hardware configuration structure
 * @pld_clock:			PLD clock frequency
 * @gpio_base			GPIO base pin number
 * @ioresource:			IO addresses of the PLD
 * @get_mutex:			PLD specific get_mutex callback
 * @release_mutex:		PLD specific release_mutex callback
 * @get_info:			PLD specific get_info callback
 * @register_cells:		PLD specific register_cells callback
 */
struct kempld_platform_data {
	u32				pld_clock;
	int				gpio_base;
	struct resource			*ioresource;
	void (*get_hardware_mutex)	(struct kempld_device_data *);
	void (*release_hardware_mutex)	(struct kempld_device_data *);
	int (*get_info)			(struct kempld_device_data *);
	int (*register_cells)		(struct kempld_device_data *);
};

extern void kempld_get_mutex(struct kempld_device_data *pld);
extern void kempld_release_mutex(struct kempld_device_data *pld);
extern u8 kempld_read8(struct kempld_device_data *pld, u8 index);
extern void kempld_write8(struct kempld_device_data *pld, u8 index, u8 data);
extern u16 kempld_read16(struct kempld_device_data *pld, u8 index);
extern void kempld_write16(struct kempld_device_data *pld, u8 index, u16 data);
extern u32 kempld_read32(struct kempld_device_data *pld, u8 index);
extern void kempld_write32(struct kempld_device_data *pld, u8 index, u32 data);

#endif /* _LINUX_MFD_KEMPLD_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * SMSC ECE1099
 *
 * Copyright 2012 Texas Instruments Inc.
 *
 * Author: Sourav Poddar <sourav.poddar@ti.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under  the terms of the GNU General  Public License as published by the
 *  Free Software Foundation;  either version 2 of the License, or (at your
 *  option) any later version.
 *
 */

#ifndef __LINUX_MFD_SMSC_H
#define __LINUX_MFD_SMSC_H

#include <linux/regmap.h>

#define SMSC_ID_ECE1099			1
#define SMSC_NUM_CLIENTS		2

#define SMSC_BASE_ADDR			0x38
#define OMAP_GPIO_SMSC_IRQ		151

#define SMSC_MAXGPIO         32
#define SMSC_BANK(offs)      ((offs) >> 3)
#define SMSC_BIT(offs)       (1u << ((offs) & 0x7))

struct smsc {
	struct device *dev;
	struct i2c_client *i2c_clients[SMSC_NUM_CLIENTS];
	struct regmap *regmap;
	int clk;
	/* Stored chip id */
	int id;
};

struct smsc_gpio;
struct smsc_keypad;

static inline int smsc_read(struct device *child, unsigned int reg,
	unsigned int *dest)
{
	struct smsc     *smsc = dev_get_drvdata(child->parent);

	return regmap_read(smsc->regmap, reg, dest);
}

static inline int smsc_write(struct device *child, unsigned int reg,
	unsigned int value)
{
	struct smsc     *smsc = dev_get_drvdata(child->parent);

	return regmap_write(smsc->regmap, reg, value);
}

/* Registers for SMSC */
#define SMSC_RESET						0xF5
#define SMSC_GRP_INT						0xF9
#define SMSC_CLK_CTRL						0xFA
#define SMSC_WKUP_CTRL						0xFB
#define SMSC_DEV_ID						0xFC
#define SMSC_DEV_REV						0xFD
#define SMSC_VEN_ID_L						0xFE
#define SMSC_VEN_ID_H						0xFF

/* CLK VALUE */
#define SMSC_CLK_VALUE						0x13

/* Registers for function GPIO INPUT */
#define SMSC_GPIO_DATA_IN_START					0x00

/* Registers for function GPIO OUPUT */
#define SMSC_GPIO_DATA_OUT_START                                       0x05

/* Definitions for SMSC GPIO CONFIGURATION REGISTER*/
#define SMSC_GPIO_INPUT_LOW					0x01
#define SMSC_GPIO_INPUT_RISING					0x09
#define SMSC_GPIO_INPUT_FALLING					0x11
#define SMSC_GPIO_INPUT_BOTH_EDGE				0x19
#define SMSC_GPIO_OUTPUT_PP					0x21
#define SMSC_GPIO_OUTPUT_OP					0x31

#define GRP_INT_STAT						0xf9
#define	SMSC_GPI_INT						0x0f
#define SMSC_CFG_START						0x0A

/* Registers for SMSC GPIO INTERRUPT STATUS REGISTER*/
#define SMSC_GPIO_INT_STAT_START                                  0x32

/* Registers for SMSC GPIO INTERRUPT MASK REGISTER*/
#define SMSC_GPIO_INT_MASK_START                               0x37

/* Registers for SMSC function KEYPAD*/
#define SMSC_KP_OUT						0x40
#define SMSC_KP_IN						0x41
#define SMSC_KP_INT_STAT					0x42
#define SMSC_KP_INT_MASK					0x43

/* Definitions for keypad */
#define SMSC_KP_KSO           0x70
#define SMSC_KP_KSI           0x51
#define SMSC_KSO_ALL_LOW        0x20
#define SMSC_KP_SET_LOW_PWR        0x0B
#define SMSC_KP_SET_HIGH           0xFF
#define SMSC_KSO_EVAL           0x00

#endif /*  __LINUX_MFD_SMSC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * linux/mfd/tps65218.h
 *
 * Functions to access TPS65219 power management chip.
 *
 * Copyright (C) 2014 Texas Instruments Incorporated - http://www.ti.com/
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed "as is" WITHOUT ANY WARRANTY of any
 * kind, whether expressed or implied; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License version 2 for more details.
 */

#ifndef __LINUX_MFD_TPS65218_H
#define __LINUX_MFD_TPS65218_H

#include <linux/i2c.h>
#include <linux/regulator/driver.h>
#include <linux/regulator/machine.h>
#include <linux/bitops.h>

/* TPS chip id list */
#define TPS65218			0xF0

/* I2C ID for TPS65218 part */
#define TPS65218_I2C_ID			0x24

/* All register addresses */
#define TPS65218_REG_CHIPID		0x00
#define TPS65218_REG_INT1		0x01
#define TPS65218_REG_INT2		0x02
#define TPS65218_REG_INT_MASK1		0x03
#define TPS65218_REG_INT_MASK2		0x04
#define TPS65218_REG_STATUS		0x05
#define TPS65218_REG_CONTROL		0x06
#define TPS65218_REG_FLAG		0x07

#define TPS65218_REG_PASSWORD		0x10
#define TPS65218_REG_ENABLE1		0x11
#define TPS65218_REG_ENABLE2		0x12
#define TPS65218_REG_CONFIG1		0x13
#define TPS65218_REG_CONFIG2		0x14
#define TPS65218_REG_CONFIG3		0x15
#define TPS65218_REG_CONTROL_DCDC1	0x16
#define TPS65218_REG_CONTROL_DCDC2	0x17
#define TPS65218_REG_CONTROL_DCDC3	0x18
#define TPS65218_REG_CONTROL_DCDC4	0x19
#define TPS65218_REG_CONTRL_SLEW_RATE	0x1A
#define TPS65218_REG_CONTROL_LDO1	0x1B
#define TPS65218_REG_SEQ1		0x20
#define TPS65218_REG_SEQ2		0x21
#define TPS65218_REG_SEQ3		0x22
#define TPS65218_REG_SEQ4		0x23
#define TPS65218_REG_SEQ5		0x24
#define TPS65218_REG_SEQ6		0x25
#define TPS65218_REG_SEQ7		0x26

/* Register field definitions */
#define TPS65218_CHIPID_CHIP_MASK	0xF8
#define TPS65218_CHIPID_REV_MASK	0x07

#define TPS65218_INT1_VPRG		BIT(5)
#define TPS65218_INT1_AC		BIT(4)
#define TPS65218_INT1_PB		BIT(3)
#define TPS65218_INT1_HOT		BIT(2)
#define TPS65218_INT1_CC_AQC		BIT(1)
#define TPS65218_INT1_PRGC		BIT(0)

#define TPS65218_INT2_LS3_F		BIT(5)
#define TPS65218_INT2_LS2_F		BIT(4)
#define TPS65218_INT2_LS1_F		BIT(3)
#define TPS65218_INT2_LS3_I		BIT(2)
#define TPS65218_INT2_LS2_I		BIT(1)
#define TPS65218_INT2_LS1_I		BIT(0)

#define TPS65218_INT_MASK1_VPRG		BIT(5)
#define TPS65218_INT_MASK1_AC		BIT(4)
#define TPS65218_INT_MASK1_PB		BIT(3)
#define TPS65218_INT_MASK1_HOT		BIT(2)
#define TPS65218_INT_MASK1_CC_AQC	BIT(1)
#define TPS65218_INT_MASK1_PRGC		BIT(0)

#define TPS65218_INT_MASK2_LS3_F	BIT(5)
#define TPS65218_INT_MASK2_LS2_F	BIT(4)
#define TPS65218_INT_MASK2_LS1_F	BIT(3)
#define TPS65218_INT_MASK2_LS3_I	BIT(2)
#define TPS65218_INT_MASK2_LS2_I	BIT(1)
#define TPS65218_INT_MASK2_LS1_I	BIT(0)

#define TPS65218_STATUS_FSEAL		BIT(7)
#define TPS65218_STATUS_EE		BIT(6)
#define TPS65218_STATUS_AC_STATE	BIT(5)
#define TPS65218_STATUS_PB_STATE	BIT(4)
#define TPS65218_STATUS_STATE_MASK	0xC
#define TPS65218_STATUS_CC_STAT		0x3

#define TPS65218_CONTROL_OFFNPFO	BIT(1)
#define TPS65218_CONTROL_CC_AQ	BIT(0)

#define TPS65218_FLAG_GPO3_FLG		BIT(7)
#define TPS65218_FLAG_GPO2_FLG		BIT(6)
#define TPS65218_FLAG_GPO1_FLG		BIT(5)
#define TPS65218_FLAG_LDO1_FLG		BIT(4)
#define TPS65218_FLAG_DC4_FLG		BIT(3)
#define TPS65218_FLAG_DC3_FLG		BIT(2)
#define TPS65218_FLAG_DC2_FLG		BIT(1)
#define TPS65218_FLAG_DC1_FLG		BIT(0)

#define TPS65218_ENABLE1_DC6_EN		BIT(5)
#define TPS65218_ENABLE1_DC5_EN		BIT(4)
#define TPS65218_ENABLE1_DC4_EN		BIT(3)
#define TPS65218_ENABLE1_DC3_EN		BIT(2)
#define TPS65218_ENABLE1_DC2_EN		BIT(1)
#define TPS65218_ENABLE1_DC1_EN		BIT(0)

#define TPS65218_ENABLE2_GPIO3		BIT(6)
#define TPS65218_ENABLE2_GPIO2		BIT(5)
#define TPS65218_ENABLE2_GPIO1		BIT(4)
#define TPS65218_ENABLE2_LS3_EN		BIT(3)
#define TPS65218_ENABLE2_LS2_EN		BIT(2)
#define TPS65218_ENABLE2_LS1_EN		BIT(1)
#define TPS65218_ENABLE2_LDO1_EN	BIT(0)


#define TPS65218_CONFIG1_TRST		BIT(7)
#define TPS65218_CONFIG1_GPO2_BUF	BIT(6)
#define TPS65218_CONFIG1_IO1_SEL	BIT(5)
#define TPS65218_CONFIG1_PGDLY_MASK	0x18
#define TPS65218_CONFIG1_STRICT		BIT(2)
#define TPS65218_CONFIG1_UVLO_MASK	0x3

#define TPS65218_CONFIG2_DC12_RST	BIT(7)
#define TPS65218_CONFIG2_UVLOHYS	BIT(6)
#define TPS65218_CONFIG2_LS3ILIM_MASK	0xC
#define TPS65218_CONFIG2_LS2ILIM_MASK	0x3

#define TPS65218_CONFIG3_LS3NPFO	BIT(5)
#define TPS65218_CONFIG3_LS2NPFO	BIT(4)
#define TPS65218_CONFIG3_LS1NPFO	BIT(3)
#define TPS65218_CONFIG3_LS3DCHRG	BIT(2)
#define TPS65218_CONFIG3_LS2DCHRG	BIT(1)
#define TPS65218_CONFIG3_LS1DCHRG	BIT(0)

#define TPS65218_CONTROL_DCDC1_PFM	BIT(7)
#define TPS65218_CONTROL_DCDC1_MASK	0x7F

#define TPS65218_CONTROL_DCDC2_PFM	BIT(7)
#define TPS65218_CONTROL_DCDC2_MASK	0x3F

#define TPS65218_CONTROL_DCDC3_PFM	BIT(7)
#define TPS65218_CONTROL_DCDC3_MASK	0x3F

#define TPS65218_CONTROL_DCDC4_PFM	BIT(7)
#define TPS65218_CONTROL_DCDC4_MASK	0x3F

#define TPS65218_SLEW_RATE_GO		BIT(7)
#define TPS65218_SLEW_RATE_GODSBL	BIT(6)
#define TPS65218_SLEW_RATE_SLEW_MASK	0x7

#define TPS65218_CONTROL_LDO1_MASK	0x3F

#define TPS65218_SEQ1_DLY8		BIT(7)
#define TPS65218_SEQ1_DLY7		BIT(6)
#define TPS65218_SEQ1_DLY6		BIT(5)
#define TPS65218_SEQ1_DLY5		BIT(4)
#define TPS65218_SEQ1_DLY4		BIT(3)
#define TPS65218_SEQ1_DLY3		BIT(2)
#define TPS65218_SEQ1_DLY2		BIT(1)
#define TPS65218_SEQ1_DLY1		BIT(0)

#define TPS65218_SEQ2_DLYFCTR		BIT(7)
#define TPS65218_SEQ2_DLY9		BIT(0)

#define TPS65218_SEQ3_DC2_SEQ_MASK	0xF0
#define TPS65218_SEQ3_DC1_SEQ_MASK	0xF

#define TPS65218_SEQ4_DC4_SEQ_MASK	0xF0
#define TPS65218_SEQ4_DC3_SEQ_MASK	0xF

#define TPS65218_SEQ5_DC6_SEQ_MASK	0xF0
#define TPS65218_SEQ5_DC5_SEQ_MASK	0xF

#define TPS65218_SEQ6_LS1_SEQ_MASK	0xF0
#define TPS65218_SEQ6_LDO1_SEQ_MASK	0xF

#define TPS65218_SEQ7_GPO3_SEQ_MASK	0xF0
#define TPS65218_SEQ7_GPO1_SEQ_MASK	0xF
#define TPS65218_PROTECT_NONE		0
#define TPS65218_PROTECT_L1		1

enum tps65218_regulator_id {
	/* DCDC's */
	TPS65218_DCDC_1,
	TPS65218_DCDC_2,
	TPS65218_DCDC_3,
	TPS65218_DCDC_4,
	TPS65218_DCDC_5,
	TPS65218_DCDC_6,
	/* LDOs */
	TPS65218_LDO_1,
};

#define TPS65218_MAX_REG_ID		TPS65218_LDO_1

/* Number of step-down converters available */
#define TPS65218_NUM_DCDC		6
/* Number of LDO voltage regulators available */
#define TPS65218_NUM_LDO		1
/* Number of total regulators available */
#define TPS65218_NUM_REGULATOR		(TPS65218_NUM_DCDC + TPS65218_NUM_LDO)

/* Define the TPS65218 IRQ numbers */
enum tps65218_irqs {
	/* INT1 registers */
	TPS65218_PRGC_IRQ,
	TPS65218_CC_AQC_IRQ,
	TPS65218_HOT_IRQ,
	TPS65218_PB_IRQ,
	TPS65218_AC_IRQ,
	TPS65218_VPRG_IRQ,
	TPS65218_INVALID1_IRQ,
	TPS65218_INVALID2_IRQ,
	/* INT2 registers */
	TPS65218_LS1_I_IRQ,
	TPS65218_LS2_I_IRQ,
	TPS65218_LS3_I_IRQ,
	TPS65218_LS1_F_IRQ,
	TPS65218_LS2_F_IRQ,
	TPS65218_LS3_F_IRQ,
	TPS65218_INVALID3_IRQ,
	TPS65218_INVALID4_IRQ,
};

/**
 * struct tps_info - packages regulator constraints
 * @id:			Id of the regulator
 * @name:		Voltage regulator name
 * @min_uV:		minimum micro volts
 * @max_uV:		minimum micro volts
 *
 * This data is used to check the regualtor voltage limits while setting.
 */
struct tps_info {
	int id;
	const char *name;
	int min_uV;
	int max_uV;
};

/**
 * struct tps65218 - tps65218 sub-driver chip access routines
 *
 * Device data may be used to access the TPS65218 chip
 */

struct tps65218 {
	struct device *dev;
	unsigned int id;

	struct mutex tps_lock;		/* lock guarding the data structure */
	/* IRQ Data */
	int irq;
	u32 irq_mask;
	struct regmap_irq_chip_data *irq_data;
	struct regulator_desc desc[TPS65218_NUM_REGULATOR];
	struct tps_info *info[TPS65218_NUM_REGULATOR];
	struct regmap *regmap;
};

int tps65218_reg_read(struct tps65218 *tps, unsigned int reg,
					unsigned int *val);
int tps65218_reg_write(struct tps65218 *tps, unsigned int reg,
			unsigned int val, unsigned int level);
int tps65218_set_bits(struct tps65218 *tps, unsigned int reg,
		unsigned int mask, unsigned int val, unsigned int level);
int tps65218_clear_bits(struct tps65218 *tps, unsigned int reg,
		unsigned int mask, unsigned int level);

#endif /*  __LINUX_MFD_TPS65218_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * Copyright (C) ST-Ericsson SA 2010
 *
 * License Terms: GNU General Public License, version 2
 */

#ifndef __LINUX_MFD_TC3589x_H
#define __LINUX_MFD_TC3589x_H

struct device;

enum tx3589x_block {
	TC3589x_BLOCK_GPIO        = 1 << 0,
	TC3589x_BLOCK_KEYPAD      = 1 << 1,
};

#define TC3589x_RSTCTRL_IRQRST	(1 << 4)
#define TC3589x_RSTCTRL_TIMRST	(1 << 3)
#define TC3589x_RSTCTRL_ROTRST	(1 << 2)
#define TC3589x_RSTCTRL_KBDRST	(1 << 1)
#define TC3589x_RSTCTRL_GPIRST	(1 << 0)

/* Keyboard Configuration Registers */
#define TC3589x_KBDSETTLE_REG   0x01
#define TC3589x_KBDBOUNCE       0x02
#define TC3589x_KBDSIZE         0x03
#define TC3589x_KBCFG_LSB       0x04
#define TC3589x_KBCFG_MSB       0x05
#define TC3589x_KBDIC           0x08
#define TC3589x_KBDMSK          0x09
#define TC3589x_EVTCODE_FIFO    0x10
#define TC3589x_KBDMFS		0x8F

#define TC3589x_IRQST		0x91

#define TC3589x_MANFCODE_MAGIC	0x03
#define TC3589x_MANFCODE	0x80
#define TC3589x_VERSION		0x81
#define TC3589x_IOCFG		0xA7

#define TC3589x_CLKMODE		0x88
#define TC3589x_CLKCFG		0x89
#define TC3589x_CLKEN		0x8A

#define TC3589x_RSTCTRL		0x82
#define TC3589x_EXTRSTN		0x83
#define TC3589x_RSTINTCLR	0x84

/* Pull up/down configuration registers */
#define TC3589x_IOCFG           0xA7
#define TC3589x_IOPULLCFG0_LSB  0xAA
#define TC3589x_IOPULLCFG0_MSB  0xAB
#define TC3589x_IOPULLCFG1_LSB  0xAC
#define TC3589x_IOPULLCFG1_MSB  0xAD
#define TC3589x_IOPULLCFG2_LSB  0xAE

#define TC3589x_GPIOIS0		0xC9
#define TC3589x_GPIOIS1		0xCA
#define TC3589x_GPIOIS2		0xCB
#define TC3589x_GPIOIBE0	0xCC
#define TC3589x_GPIOIBE1	0xCD
#define TC3589x_GPIOIBE2	0xCE
#define TC3589x_GPIOIEV0	0xCF
#define TC3589x_GPIOIEV1	0xD0
#define TC3589x_GPIOIEV2	0xD1
#define TC3589x_GPIOIE0		0xD2
#define TC3589x_GPIOIE1		0xD3
#define TC3589x_GPIOIE2		0xD4
#define TC3589x_GPIORIS0	0xD6
#define TC3589x_GPIORIS1	0xD7
#define TC3589x_GPIORIS2	0xD8
#define TC3589x_GPIOMIS0	0xD9
#define TC3589x_GPIOMIS1	0xDA
#define TC3589x_GPIOMIS2	0xDB
#define TC3589x_GPIOIC0		0xDC
#define TC3589x_GPIOIC1		0xDD
#define TC3589x_GPIOIC2		0xDE

#define TC3589x_GPIODATA0	0xC0
#define TC3589x_GPIOMASK0	0xc1
#define TC3589x_GPIODATA1	0xC2
#define TC3589x_GPIOMASK1	0xc3
#define TC3589x_GPIODATA2	0xC4
#define TC3589x_GPIOMASK2	0xC5

#define TC3589x_GPIODIR0	0xC6
#define TC3589x_GPIODIR1	0xC7
#define TC3589x_GPIODIR2	0xC8

#define TC3589x_GPIOSYNC0	0xE6
#define TC3589x_GPIOSYNC1	0xE7
#define TC3589x_GPIOSYNC2	0xE8

#define TC3589x_GPIOWAKE0	0xE9
#define TC3589x_GPIOWAKE1	0xEA
#define TC3589x_GPIOWAKE2	0xEB

#define TC3589x_GPIOODM0	0xE0
#define TC3589x_GPIOODE0	0xE1
#define TC3589x_GPIOODM1	0xE2
#define TC3589x_GPIOODE1	0xE3
#define TC3589x_GPIOODM2	0xE4
#define TC3589x_GPIOODE2	0xE5

#define TC3589x_INT_GPIIRQ	0
#define TC3589x_INT_TI0IRQ	1
#define TC3589x_INT_TI1IRQ	2
#define TC3589x_INT_TI2IRQ	3
#define TC3589x_INT_ROTIRQ	5
#define TC3589x_INT_KBDIRQ	6
#define TC3589x_INT_PORIRQ	7

#define TC3589x_NR_INTERNAL_IRQS	8

struct tc3589x {
	struct mutex lock;
	struct device *dev;
	struct i2c_client *i2c;
	struct irq_domain *domain;

	int irq_base;
	int num_gpio;
	struct tc3589x_platform_data *pdata;
};

extern int tc3589x_reg_write(struct tc3589x *tc3589x, u8 reg, u8 data);
extern int tc3589x_reg_read(struct tc3589x *tc3589x, u8 reg);
extern int tc3589x_block_read(struct tc3589x *tc3589x, u8 reg, u8 length,
			      u8 *values);
extern int tc3589x_block_write(struct tc3589x *tc3589x, u8 reg, u8 length,
			       const u8 *values);
extern int tc3589x_set_bits(struct tc3589x *tc3589x, u8 reg, u8 mask, u8 val);

/*
 * Keypad related platform specific constants
 * These values may be modified for fine tuning
 */
#define TC_KPD_ROWS             0x8
#define TC_KPD_COLUMNS          0x8
#define TC_KPD_DEBOUNCE_PERIOD  0xA3
#define TC_KPD_SETTLE_TIME      0xA3


/**
 * struct tc3589x_platform_data - TC3589x platform data
 * @block: bitmask of blocks to enable (use TC3589x_BLOCK_*)
 */
struct tc3589x_platform_data {
	unsigned int block;
};

#endif
                                                                                                 /* MFD cell driver data for the DS1WM driver */

struct ds1wm_driver_data {
	int active_high;
	int clock_rate;
	/* in milliseconds, the amount of time to */
	/* sleep following a reset pulse. Zero    */
	/* should work if your bus devices recover*/
	/* time respects the 1-wire spec since the*/
	/* ds1wm implements the precise timings of*/
	/* a reset pulse/presence detect sequence.*/
	unsigned int reset_recover_delay;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * max77693.h - Driver for the Maxim 77693
 *
 *  Copyright (C) 2012 Samsung Electrnoics
 *  SangYoung Son <hello.son@samsung.com>
 *
 * This program is not provided / owned by Maxim Integrated Products.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * This driver is based on max8997.h
 *
 * MAX77693 has PMIC, Charger, Flash LED, Haptic, MUIC devices.
 * The devices share the same I2C bus and included in
 * this mfd driver.
 */

#ifndef __LINUX_MFD_MAX77693_H
#define __LINUX_MFD_MAX77693_H

/* MAX77693 regulator IDs */
enum max77693_regulators {
	MAX77693_ESAFEOUT1 = 0,
	MAX77693_ESAFEOUT2,
	MAX77693_CHARGER,
	MAX77693_REG_MAX,
};

struct max77693_reg_data {
	u8 addr;
	u8 data;
};

struct max77693_muic_platform_data {
	struct max77693_reg_data *init_data;
	int num_init_data;

	int detcable_delay_ms;

	/*
	 * Default usb/uart path whether UART/USB or AUX_UART/AUX_USB
	 * h/w path of COMP2/COMN1 on CONTROL1 register.
	 */
	int path_usb;
	int path_uart;
};

/* MAX77693 led flash */

/* triggers */
enum max77693_led_trigger {
	MAX77693_LED_TRIG_OFF,
	MAX77693_LED_TRIG_FLASH,
	MAX77693_LED_TRIG_TORCH,
	MAX77693_LED_TRIG_EXT,
	MAX77693_LED_TRIG_SOFT,
};

/* trigger types */
enum max77693_led_trigger_type {
	MAX77693_LED_TRIG_TYPE_EDGE,
	MAX77693_LED_TRIG_TYPE_LEVEL,
};

/* boost modes */
enum max77693_led_boost_mode {
	MAX77693_LED_BOOST_NONE,
	MAX77693_LED_BOOST_ADAPTIVE,
	MAX77693_LED_BOOST_FIXED,
};

/* MAX77693 */

struct max77693_platform_data {
	/* muic data */
	struct max77693_muic_platform_data *muic_data;
	struct max77693_led_platform_data *led_data;
};
#endif	/* __LINUX_MFD_MAX77693_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * This file contains the definitions for the T7L66XB
 *
 * (C) Copyright 2005 Ian Molton <spyro@f2s.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 */
#ifndef MFD_T7L66XB_H
#define MFD_T7L66XB_H

#include <linux/mfd/core.h>
#include <linux/mfd/tmio.h>

struct t7l66xb_platform_data {
	int (*enable)(struct platform_device *dev);
	int (*disable)(struct platform_device *dev);
	int (*suspend)(struct platform_device *dev);
	int (*resume)(struct platform_device *dev);

	int irq_base; /* The base for subdevice irqs */

	struct tmio_nand_data *nand_data;
};


#define IRQ_T7L66XB_MMC        (1)
#define IRQ_T7L66XB_NAND       (3)

#define T7L66XB_NR_IRQS	8

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * Copyright (C) 2007-2009 ST-Ericsson AB
 * License terms: GNU General Public License (GPL) version 2
 * AB3100 core access functions
 * Author: Linus Walleij <linus.walleij@stericsson.com>
 *
 */

#include <linux/regulator/machine.h>

struct device;

#ifndef MFD_AB3100_H
#define MFD_AB3100_H


#define AB3100_P1A	0xc0
#define AB3100_P1B	0xc1
#define AB3100_P1C	0xc2
#define AB3100_P1D	0xc3
#define AB3100_P1E	0xc4
#define AB3100_P1F	0xc5
#define AB3100_P1G	0xc6
#define AB3100_R2A	0xc7
#define AB3100_R2B	0xc8

/*
 * AB3100, EVENTA1, A2 and A3 event register flags
 * these are catenated into a single 32-bit flag in the code
 * for event notification broadcasts.
 */
#define AB3100_EVENTA1_ONSWA				(0x01<<16)
#define AB3100_EVENTA1_ONSWB				(0x02<<16)
#define AB3100_EVENTA1_ONSWC				(0x04<<16)
#define AB3100_EVENTA1_DCIO				(0x08<<16)
#define AB3100_EVENTA1_OVER_TEMP			(0x10<<16)
#define AB3100_EVENTA1_SIM_OFF				(0x20<<16)
#define AB3100_EVENTA1_VBUS				(0x40<<16)
#define AB3100_EVENTA1_VSET_USB				(0x80<<16)

#define AB3100_EVENTA2_READY_TX				(0x01<<8)
#define AB3100_EVENTA2_READY_RX				(0x02<<8)
#define AB3100_EVENTA2_OVERRUN_ERROR			(0x04<<8)
#define AB3100_EVENTA2_FRAMING_ERROR			(0x08<<8)
#define AB3100_EVENTA2_CHARG_OVERCURRENT		(0x10<<8)
#define AB3100_EVENTA2_MIDR				(0x20<<8)
#define AB3100_EVENTA2_BATTERY_REM			(0x40<<8)
#define AB3100_EVENTA2_ALARM				(0x80<<8)

#define AB3100_EVENTA3_ADC_TRIG5			(0x01)
#define AB3100_EVENTA3_ADC_TRIG4			(0x02)
#define AB3100_EVENTA3_ADC_TRIG3			(0x04)
#define AB3100_EVENTA3_ADC_TRIG2			(0x08)
#define AB3100_EVENTA3_ADC_TRIGVBAT			(0x10)
#define AB3100_EVENTA3_ADC_TRIGVTX			(0x20)
#define AB3100_EVENTA3_ADC_TRIG1			(0x40)
#define AB3100_EVENTA3_ADC_TRIG0			(0x80)

/* AB3100, STR register flags */
#define AB3100_STR_ONSWA				(0x01)
#define AB3100_STR_ONSWB				(0x02)
#define AB3100_STR_ONSWC				(0x04)
#define AB3100_STR_DCIO					(0x08)
#define AB3100_STR_BOOT_MODE				(0x10)
#define AB3100_STR_SIM_OFF				(0x20)
#define AB3100_STR_BATT_REMOVAL				(0x40)
#define AB3100_STR_VBUS					(0x80)

/*
 * AB3100 contains 8 regulators, one external regulator controller
 * and a buck converter, further the LDO E and buck converter can
 * have separate settings if they are in sleep mode, this is
 * modeled as a separate regulator.
 */
#define AB3100_NUM_REGULATORS				10

/**
 * struct ab3100
 * @access_mutex: lock out concurrent accesses to the AB3100 registers
 * @dev: pointer to the containing device
 * @i2c_client: I2C client for this chip
 * @testreg_client: secondary client for test registers
 * @chip_name: name of this chip variant
 * @chip_id: 8 bit chip ID for this chip variant
 * @event_subscribers: event subscribers are listed here
 * @startup_events: a copy of the first reading of the event registers
 * @startup_events_read: whether the first events have been read
 *
 * This struct is PRIVATE and devices using it should NOT
 * access ANY fields. It is used as a token for calling the
 * AB3100 functions.
 */
struct ab3100 {
	struct mutex access_mutex;
	struct device *dev;
	struct i2c_client *i2c_client;
	struct i2c_client *testreg_client;
	char chip_name[32];
	u8 chip_id;
	struct blocking_notifier_head event_subscribers;
	u8 startup_events[3];
	bool startup_events_read;
};

/**
 * struct ab3100_platform_data
 * Data supplied to initialize board connections to the AB3100
 * @reg_constraints: regulator constraints for target board
 *     the order of these constraints are: LDO A, C, D, E,
 *     F, G, H, K, EXT and BUCK.
 * @reg_initvals: initial values for the regulator registers
 *     plus two sleep settings for LDO E and the BUCK converter.
 *     exactly AB3100_NUM_REGULATORS+2 values must be sent in.
 *     Order: LDO A, C, E, E sleep, F, G, H, K, EXT, BUCK,
 *     BUCK sleep, LDO D. (LDO D need to be initialized last.)
 * @external_voltage: voltage level of the external regulator.
 */
struct ab3100_platform_data {
	struct regulator_init_data reg_constraints[AB3100_NUM_REGULATORS];
	u8 reg_initvals[AB3100_NUM_REGULATORS+2];
	int external_voltage;
};

int ab3100_event_register(struct ab3100 *ab3100,
			  struct notifier_block *nb);
int ab3100_event_unregister(struct ab3100 *ab3100,
			    struct notifier_block *nb);

#endif /*  MFD_AB3100_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * include/linux/mfd/intel_msic.h - Core interface for Intel MSIC
 *
 * Copyright (C) 2011, Intel Corporation
 * Author: Mika Westerberg <mika.westerberg@linux.intel.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef __LINUX_MFD_INTEL_MSIC_H__
#define __LINUX_MFD_INTEL_MSIC_H__

/* ID */
#define INTEL_MSIC_ID0			0x000	/* RO */
#define INTEL_MSIC_ID1			0x001	/* RO */

/* IRQ */
#define INTEL_MSIC_IRQLVL1		0x002
#define INTEL_MSIC_ADC1INT		0x003
#define INTEL_MSIC_CCINT		0x004
#define INTEL_MSIC_PWRSRCINT		0x005
#define INTEL_MSIC_PWRSRCINT1		0x006
#define INTEL_MSIC_CHRINT		0x007
#define INTEL_MSIC_CHRINT1		0x008
#define INTEL_MSIC_RTCIRQ		0x009
#define INTEL_MSIC_GPIO0LVIRQ		0x00a
#define INTEL_MSIC_GPIO1LVIRQ		0x00b
#define INTEL_MSIC_GPIOHVIRQ		0x00c
#define INTEL_MSIC_VRINT		0x00d
#define INTEL_MSIC_OCAUDIO		0x00e
#define INTEL_MSIC_ACCDET		0x00f
#define INTEL_MSIC_RESETIRQ1		0x010
#define INTEL_MSIC_RESETIRQ2		0x011
#define INTEL_MSIC_MADC1INT		0x012
#define INTEL_MSIC_MCCINT		0x013
#define INTEL_MSIC_MPWRSRCINT		0x014
#define INTEL_MSIC_MPWRSRCINT1		0x015
#define INTEL_MSIC_MCHRINT		0x016
#define INTEL_MSIC_MCHRINT1		0x017
#define INTEL_MSIC_RTCIRQMASK		0x018
#define INTEL_MSIC_GPIO0LVIRQMASK	0x019
#define INTEL_MSIC_GPIO1LVIRQMASK	0x01a
#define INTEL_MSIC_GPIOHVIRQMASK	0x01b
#define INTEL_MSIC_VRINTMASK		0x01c
#define INTEL_MSIC_OCAUDIOMASK		0x01d
#define INTEL_MSIC_ACCDETMASK		0x01e
#define INTEL_MSIC_RESETIRQ1MASK	0x01f
#define INTEL_MSIC_RESETIRQ2MASK	0x020
#define INTEL_MSIC_IRQLVL1MSK		0x021
#define INTEL_MSIC_PBCONFIG		0x03e
#define INTEL_MSIC_PBSTATUS		0x03f	/* RO */

/* GPIO */
#define INTEL_MSIC_GPIO0LV7CTLO		0x040
#define INTEL_MSIC_GPIO0LV6CTLO		0x041
#define INTEL_MSIC_GPIO0LV5CTLO		0x042
#define INTEL_MSIC_GPIO0LV4CTLO		0x043
#define INTEL_MSIC_GPIO0LV3CTLO		0x044
#define INTEL_MSIC_GPIO0LV2CTLO		0x045
#define INTEL_MSIC_GPIO0LV1CTLO		0x046
#define INTEL_MSIC_GPIO0LV0CTLO		0x047
#define INTEL_MSIC_GPIO1LV7CTLOS	0x048
#define INTEL_MSIC_GPIO1LV6CTLO		0x049
#define INTEL_MSIC_GPIO1LV5CTLO		0x04a
#define INTEL_MSIC_GPIO1LV4CTLO		0x04b
#define INTEL_MSIC_GPIO1LV3CTLO		0x04c
#define INTEL_MSIC_GPIO1LV2CTLO		0x04d
#define INTEL_MSIC_GPIO1LV1CTLO		0x04e
#define INTEL_MSIC_GPIO1LV0CTLO		0x04f
#define INTEL_MSIC_GPIO0LV7CTLI		0x050
#define INTEL_MSIC_GPIO0LV6CTLI		0x051
#define INTEL_MSIC_GPIO0LV5CTLI		0x052
#define INTEL_MSIC_GPIO0LV4CTLI		0x053
#define INTEL_MSIC_GPIO0LV3CTLI		0x054
#define INTEL_MSIC_GPIO0LV2CTLI		0x055
#define INTEL_MSIC_GPIO0LV1CTLI		0x056
#define INTEL_MSIC_GPIO0LV0CTLI		0x057
#define INTEL_MSIC_GPIO1LV7CTLIS	0x058
#define INTEL_MSIC_GPIO1LV6CTLI		0x059
#define INTEL_MSIC_GPIO1LV5CTLI		0x05a
#define INTEL_MSIC_GPIO1LV4CTLI		0x05b
#define INTEL_MSIC_GPIO1LV3CTLI		0x05c
#define INTEL_MSIC_GPIO1LV2CTLI		0x05d
#define INTEL_MSIC_GPIO1LV1CTLI		0x05e
#define INTEL_MSIC_GPIO1LV0CTLI		0x05f
#define INTEL_MSIC_PWM0CLKDIV1		0x061
#define INTEL_MSIC_PWM0CLKDIV0		0x062
#define INTEL_MSIC_PWM1CLKDIV1		0x063
#define INTEL_MSIC_PWM1CLKDIV0		0x064
#define INTEL_MSIC_PWM2CLKDIV1		0x065
#define INTEL_MSIC_PWM2CLKDIV0		0x066
#define INTEL_MSIC_PWM0DUTYCYCLE	0x067
#define INTEL_MSIC_PWM1DUTYCYCLE	0x068
#define INTEL_MSIC_PWM2DUTYCYCLE	0x069
#define INTEL_MSIC_GPIO0HV3CTLO		0x06d
#define INTEL_MSIC_GPIO0HV2CTLO		0x06e
#define INTEL_MSIC_GPIO0HV1CTLO		0x06f
#define INTEL_MSIC_GPIO0HV0CTLO		0x070
#define INTEL_MSIC_GPIO1HV3CTLO		0x071
#define INTEL_MSIC_GPIO1HV2CTLO		0x072
#define INTEL_MSIC_GPIO1HV1CTLO		0x073
#define INTEL_MSIC_GPIO1HV0CTLO		0x074
#define INTEL_MSIC_GPIO0HV3CTLI		0x075
#define INTEL_MSIC_GPIO0HV2CTLI		0x076
#define INTEL_MSIC_GPIO0HV1CTLI		0x077
#define INTEL_MSIC_GPIO0HV0CTLI		0x078
#define INTEL_MSIC_GPIO1HV3CTLI		0x079
#define INTEL_MSIC_GPIO1HV2CTLI		0x07a
#define INTEL_MSIC_GPIO1HV1CTLI		0x07b
#define INTEL_MSIC_GPIO1HV0CTLI		0x07c

/* SVID */
#define INTEL_MSIC_SVIDCTRL0		0x080
#define INTEL_MSIC_SVIDCTRL1		0x081
#define INTEL_MSIC_SVIDCTRL2		0x082
#define INTEL_MSIC_SVIDTXLASTPKT3	0x083	/* RO */
#define INTEL_MSIC_SVIDTXLASTPKT2	0x084	/* RO */
#define INTEL_MSIC_SVIDTXLASTPKT1	0x085	/* RO */
#define INTEL_MSIC_SVIDTXLASTPKT0	0x086	/* RO */
#define INTEL_MSIC_SVIDPKTOUTBYTE3	0x087
#define INTEL_MSIC_SVIDPKTOUTBYTE2	0x088
#define INTEL_MSIC_SVIDPKTOUTBYTE1	0x089
#define INTEL_MSIC_SVIDPKTOUTBYTE0	0x08a
#define INTEL_MSIC_SVIDRXVPDEBUG1	0x08b
#define INTEL_MSIC_SVIDRXVPDEBUG0	0x08c
#define INTEL_MSIC_SVIDRXLASTPKT3	0x08d	/* RO */
#define INTEL_MSIC_SVIDRXLASTPKT2	0x08e	/* RO */
#define INTEL_MSIC_SVIDRXLASTPKT1	0x08f	/* RO */
#define INTEL_MSIC_SVIDRXLASTPKT0	0x090	/* RO */
#define INTEL_MSIC_SVIDRXCHKSTATUS3	0x091	/* RO */
#define INTEL_MSIC_SVIDRXCHKSTATUS2	0x092	/* RO */
#define INTEL_MSIC_SVIDRXCHKSTATUS1	0x093	/* RO */
#define INTEL_MSIC_SVIDRXCHKSTATUS0	0x094	/* RO */

/* VREG */
#define INTEL_MSIC_VCCLATCH		0x0c0
#define INTEL_MSIC_VNNLATCH		0x0c1
#define INTEL_MSIC_VCCCNT		0x0c2
#define INTEL_MSIC_SMPSRAMP		0x0c3
#define INTEL_MSIC_VNNCNT		0x0c4
#define INTEL_MSIC_VNNAONCNT		0x0c5
#define INTEL_MSIC_VCC122AONCNT		0x0c6
#define INTEL_MSIC_V180AONCNT		0x0c7
#define INTEL_MSIC_V500CNT		0x0c8
#define INTEL_MSIC_VIHFCNT		0x0c9
#define INTEL_MSIC_LDORAMP1		0x0ca
#define INTEL_MSIC_LDORAMP2		0x0cb
#define INTEL_MSIC_VCC108AONCNT		0x0cc
#define INTEL_MSIC_VCC108ASCNT		0x0cd
#define INTEL_MSIC_VCC108CNT		0x0ce
#define INTEL_MSIC_VCCA100ASCNT		0x0cf
#define INTEL_MSIC_VCCA100CNT		0x0d0
#define INTEL_MSIC_VCC180AONCNT		0x0d1
#define INTEL_MSIC_VCC180CNT		0x0d2
#define INTEL_MSIC_VCC330CNT		0x0d3
#define INTEL_MSIC_VUSB330CNT		0x0d4
#define INTEL_MSIC_VCCSDIOCNT		0x0d5
#define INTEL_MSIC_VPROG1CNT		0x0d6
#define INTEL_MSIC_VPROG2CNT		0x0d7
#define INTEL_MSIC_VEMMCSCNT		0x0d8
#define INTEL_MSIC_VEMMC1CNT		0x0d9
#define INTEL_MSIC_VEMMC2CNT		0x0da
#define INTEL_MSIC_VAUDACNT		0x0db
#define INTEL_MSIC_VHSPCNT		0x0dc
#define INTEL_MSIC_VHSNCNT		0x0dd
#define INTEL_MSIC_VHDMICNT		0x0de
#define INTEL_MSIC_VOTGCNT		0x0df
#define INTEL_MSIC_V1P35CNT		0x0e0
#define INTEL_MSIC_V330AONCNT		0x0e1

/* RESET */
#define INTEL_MSIC_CHIPCNTRL		0x100	/* WO */
#define INTEL_MSIC_ERCONFIG		0x101

/* BURST */
#define INTEL_MSIC_BATCURRENTLIMIT12	0x102
#define INTEL_MSIC_BATTIMELIMIT12	0x103
#define INTEL_MSIC_BATTIMELIMIT3	0x104
#define INTEL_MSIC_BATTIMEDB		0x105
#define INTEL_MSIC_BRSTCONFIGOUTPUTS	0x106
#define INTEL_MSIC_BRSTCONFIGACTIONS	0x107
#define INTEL_MSIC_BURSTCONTROLSTATUS	0x108

/* RTC */
#define INTEL_MSIC_RTCB1		0x140	/* RO */
#define INTEL_MSIC_RTCB2		0x141	/* RO */
#define INTEL_MSIC_RTCB3		0x142	/* RO */
#define INTEL_MSIC_RTCB4		0x143	/* RO */
#define INTEL_MSIC_RTCOB1		0x144
#define INTEL_MSIC_RTCOB2		0x145
#define INTEL_MSIC_RTCOB3		0x146
#define INTEL_MSIC_RTCOB4		0x147
#define INTEL_MSIC_RTCAB1		0x148
#define INTEL_MSIC_RTCAB2		0x149
#define INTEL_MSIC_RTCAB3		0x14a
#define INTEL_MSIC_RTCAB4		0x14b
#define INTEL_MSIC_RTCWAB1		0x14c
#define INTEL_MSIC_RTCWAB2		0x14d
#define INTEL_MSIC_RTCWAB3		0x14e
#define INTEL_MSIC_RTCWAB4		0x14f
#define INTEL_MSIC_RTCSC1		0x150
#define INTEL_MSIC_RTCSC2		0x151
#define INTEL_MSIC_RTCSC3		0x152
#define INTEL_MSIC_RTCSC4		0x153
#define INTEL_MSIC_RTCSTATUS		0x154	/* RO */
#define INTEL_MSIC_RTCCONFIG1		0x155
#define INTEL_MSIC_RTCCONFIG2		0x156

/* CHARGER */
#define INTEL_MSIC_BDTIMER		0x180
#define INTEL_MSIC_BATTRMV		0x181
#define INTEL_MSIC_VBUSDET		0x182
#define INTEL_MSIC_VBUSDET1		0x183
#define INTEL_MSIC_ADPHVDET		0x184
#define INTEL_MSIC_ADPLVDET		0x185
#define INTEL_MSIC_ADPDETDBDM		0x186
#define INTEL_MSIC_LOWBATTDET		0x187
#define INTEL_MSIC_CHRCTRL		0x188
#define INTEL_MSIC_CHRCVOLTAGE		0x189
#define INTEL_MSIC_CHRCCURRENT		0x18a
#define INTEL_MSIC_SPCHARGER		0x18b
#define INTEL_MSIC_CHRTTIME		0x18c
#define INTEL_MSIC_CHRCTRL1		0x18d
#define INTEL_MSIC_PWRSRCLMT		0x18e
#define INTEL_MSIC_CHRSTWDT		0x18f
#define INTEL_MSIC_WDTWRITE		0x190	/* WO */
#define INTEL_MSIC_CHRSAFELMT		0x191
#define INTEL_MSIC_SPWRSRCINT		0x192	/* RO */
#define INTEL_MSIC_SPWRSRCINT1		0x193	/* RO */
#define INTEL_MSIC_CHRLEDPWM		0x194
#define INTEL_MSIC_CHRLEDCTRL		0x195

/* ADC */
#define INTEL_MSIC_ADC1CNTL1		0x1c0
#define INTEL_MSIC_ADC1CNTL2		0x1c1
#define INTEL_MSIC_ADC1CNTL3		0x1c2
#define INTEL_MSIC_ADC1OFFSETH		0x1c3	/* RO */
#define INTEL_MSIC_ADC1OFFSETL		0x1c4	/* RO */
#define INTEL_MSIC_ADC1ADDR0		0x1c5
#define INTEL_MSIC_ADC1ADDR1		0x1c6
#define INTEL_MSIC_ADC1ADDR2		0x1c7
#define INTEL_MSIC_ADC1ADDR3		0x1c8
#define INTEL_MSIC_ADC1ADDR4		0x1c9
#define INTEL_MSIC_ADC1ADDR5		0x1ca
#define INTEL_MSIC_ADC1ADDR6		0x1cb
#define INTEL_MSIC_ADC1ADDR7		0x1cc
#define INTEL_MSIC_ADC1ADDR8		0x1cd
#define INTEL_MSIC_ADC1ADDR9		0x1ce
#define INTEL_MSIC_ADC1ADDR10		0x1cf
#define INTEL_MSIC_ADC1ADDR11		0x1d0
#define INTEL_MSIC_ADC1ADDR12		0x1d1
#define INTEL_MSIC_ADC1ADDR13		0x1d2
#define INTEL_MSIC_ADC1ADDR14		0x1d3
#define INTEL_MSIC_ADC1SNS0H		0x1d4	/* RO */
#define INTEL_MSIC_ADC1SNS0L		0x1d5	/* RO */
#define INTEL_MSIC_ADC1SNS1H		0x1d6	/* RO */
#define INTEL_MSIC_ADC1SNS1L		0x1d7	/* RO */
#define INTEL_MSIC_ADC1SNS2H		0x1d8	/* RO */
#define INTEL_MSIC_ADC1SNS2L		0x1d9	/* RO */
#define INTEL_MSIC_ADC1SNS3H		0x1da	/* RO */
#define INTEL_MSIC_ADC1SNS3L		0x1db	/* RO */
#define INTEL_MSIC_ADC1SNS4H		0x1dc	/* RO */
#define INTEL_MSIC_ADC1SNS4L		0x1dd	/* RO */
#define INTEL_MSIC_ADC1SNS5H		0x1de	/* RO */
#define INTEL_MSIC_ADC1SNS5L		0x1df	/* RO */
#define INTEL_MSIC_ADC1SNS6H		0x1e0	/* RO */
#define INTEL_MSIC_ADC1SNS6L		0x1e1	/* RO */
#define INTEL_MSIC_ADC1SNS7H		0x1e2	/* RO */
#define INTEL_MSIC_ADC1SNS7L		0x1e3	/* RO */
#define INTEL_MSIC_ADC1SNS8H		0x1e4	/* RO */
#define INTEL_MSIC_ADC1SNS8L		0x1e5	/* RO */
#define INTEL_MSIC_ADC1SNS9H		0x1e6	/* RO */
#define INTEL_MSIC_ADC1SNS9L		0x1e7	/* RO */
#define INTEL_MSIC_ADC1SNS10H		0x1e8	/* RO */
#define INTEL_MSIC_ADC1SNS10L		0x1e9	/* RO */
#define INTEL_MSIC_ADC1SNS11H		0x1ea	/* RO */
#define INTEL_MSIC_ADC1SNS11L		0x1eb	/* RO */
#define INTEL_MSIC_ADC1SNS12H		0x1ec	/* RO */
#define INTEL_MSIC_ADC1SNS12L		0x1ed	/* RO */
#define INTEL_MSIC_ADC1SNS13H		0x1ee	/* RO */
#define INTEL_MSIC_ADC1SNS13L		0x1ef	/* RO */
#define INTEL_MSIC_ADC1SNS14H		0x1f0	/* RO */
#define INTEL_MSIC_ADC1SNS14L		0x1f1	/* RO */
#define INTEL_MSIC_ADC1BV0H		0x1f2	/* RO */
#define INTEL_MSIC_ADC1BV0L		0x1f3	/* RO */
#define INTEL_MSIC_ADC1BV1H		0x1f4	/* RO */
#define INTEL_MSIC_ADC1BV1L		0x1f5	/* RO */
#define INTEL_MSIC_ADC1BV2H		0x1f6	/* RO */
#define INTEL_MSIC_ADC1BV2L		0x1f7	/* RO */
#define INTEL_MSIC_ADC1BV3H		0x1f8	/* RO */
#define INTEL_MSIC_ADC1BV3L		0x1f9	/* RO */
#define INTEL_MSIC_ADC1BI0H		0x1fa	/* RO */
#define INTEL_MSIC_ADC1BI0L		0x1fb	/* RO */
#define INTEL_MSIC_ADC1BI1H		0x1fc	/* RO */
#define INTEL_MSIC_ADC1BI1L		0x1fd	/* RO */
#define INTEL_MSIC_ADC1BI2H		0x1fe	/* RO */
#define INTEL_MSIC_ADC1BI2L		0x1ff	/* RO */
#define INTEL_MSIC_ADC1BI3H		0x200	/* RO */
#define INTEL_MSIC_ADC1BI3L		0x201	/* RO */
#define INTEL_MSIC_CCCNTL		0x202
#define INTEL_MSIC_CCOFFSETH		0x203	/* RO */
#define INTEL_MSIC_CCOFFSETL		0x204	/* RO */
#define INTEL_MSIC_CCADCHA		0x205	/* RO */
#define INTEL_MSIC_CCADCLA		0x206	/* RO */

/* AUDIO */
#define INTEL_MSIC_AUDPLLCTRL		0x240
#define INTEL_MSIC_DMICBUF0123		0x241
#define INTEL_MSIC_DMICBUF45		0x242
#define INTEL_MSIC_DMICGPO		0x244
#define INTEL_MSIC_DMICMUX		0x245
#define INTEL_MSIC_DMICCLK		0x246
#define INTEL_MSIC_MICBIAS		0x247
#define INTEL_MSIC_ADCCONFIG		0x248
#define INTEL_MSIC_MICAMP1		0x249
#define INTEL_MSIC_MICAMP2		0x24a
#define INTEL_MSIC_NOISEMUX		0x24b
#define INTEL_MSIC_AUDIOMUX12		0x24c
#define INTEL_MSIC_AUDIOMUX34		0x24d
#define INTEL_MSIC_AUDIOSINC		0x24e
#define INTEL_MSIC_AUDIOTXEN		0x24f
#define INTEL_MSIC_HSEPRXCTRL		0x250
#define INTEL_MSIC_IHFRXCTRL		0x251
#define INTEL_MSIC_VOICETXVOL		0x252
#define INTEL_MSIC_SIDETONEVOL		0x253
#define INTEL_MSIC_MUSICSHARVOL		0x254
#define INTEL_MSIC_VOICETXCTRL		0x255
#define INTEL_MSIC_HSMIXER		0x256
#define INTEL_MSIC_DACCONFIG		0x257
#define INTEL_MSIC_SOFTMUTE		0x258
#define INTEL_MSIC_HSLVOLCTRL		0x259
#define INTEL_MSIC_HSRVOLCTRL		0x25a
#define INTEL_MSIC_IHFLVOLCTRL		0x25b
#define INTEL_MSIC_IHFRVOLCTRL		0x25c
#define INTEL_MSIC_DRIVEREN		0x25d
#define INTEL_MSIC_LINEOUTCTRL		0x25e
#define INTEL_MSIC_VIB1CTRL1		0x25f
#define INTEL_MSIC_VIB1CTRL2		0x260
#define INTEL_MSIC_VIB1CTRL3		0x261
#define INTEL_MSIC_VIB1SPIPCM_1		0x262
#define INTEL_MSIC_VIB1SPIPCM_2		0x263
#define INTEL_MSIC_VIB1CTRL5		0x264
#define INTEL_MSIC_VIB2CTRL1		0x265
#define INTEL_MSIC_VIB2CTRL2		0x266
#define INTEL_MSIC_VIB2CTRL3		0x267
#define INTEL_MSIC_VIB2SPIPCM_1		0x268
#define INTEL_MSIC_VIB2SPIPCM_2		0x269
#define INTEL_MSIC_VIB2CTRL5		0x26a
#define INTEL_MSIC_BTNCTRL1		0x26b
#define INTEL_MSIC_BTNCTRL2		0x26c
#define INTEL_MSIC_PCM1TXSLOT01		0x26d
#define INTEL_MSIC_PCM1TXSLOT23		0x26e
#define INTEL_MSIC_PCM1TXSLOT45		0x26f
#define INTEL_MSIC_PCM1RXSLOT0123	0x270
#define INTEL_MSIC_PCM1RXSLOT045	0x271
#define INTEL_MSIC_PCM2TXSLOT01		0x272
#define INTEL_MSIC_PCM2TXSLOT23		0x273
#define INTEL_MSIC_PCM2TXSLOT45		0x274
#define INTEL_MSIC_PCM2RXSLOT01		0x275
#define INTEL_MSIC_PCM2RXSLOT23		0x276
#define INTEL_MSIC_PCM2RXSLOT45		0x277
#define INTEL_MSIC_PCM1CTRL1		0x278
#define INTEL_MSIC_PCM1CTRL2		0x279
#define INTEL_MSIC_PCM1CTRL3		0x27a
#define INTEL_MSIC_PCM2CTRL1		0x27b
#define INTEL_MSIC_PCM2CTRL2		0x27c

/* HDMI */
#define INTEL_MSIC_HDMIPUEN		0x280
#define INTEL_MSIC_HDMISTATUS		0x281	/* RO */

/* Physical address of the start of the MSIC interrupt tree in SRAM */
#define INTEL_MSIC_IRQ_PHYS_BASE	0xffff7fc0

/**
 * struct intel_msic_gpio_pdata - platform data for the MSIC GPIO driver
 * @gpio_base: base number for the GPIOs
 */
struct intel_msic_gpio_pdata {
	unsigned	gpio_base;
};

/**
 * struct intel_msic_ocd_pdata - platform data for the MSIC OCD driver
 * @gpio: GPIO number used for OCD interrupts
 *
 * The MSIC MFD driver converts @gpio into an IRQ number and passes it to
 * the OCD driver as %IORESOURCE_IRQ.
 */
struct intel_msic_ocd_pdata {
	unsigned	gpio;
};

/* MSIC embedded blocks (subdevices) */
enum intel_msic_block {
	INTEL_MSIC_BLOCK_TOUCH,
	INTEL_MSIC_BLOCK_ADC,
	INTEL_MSIC_BLOCK_BATTERY,
	INTEL_MSIC_BLOCK_GPIO,
	INTEL_MSIC_BLOCK_AUDIO,
	INTEL_MSIC_BLOCK_HDMI,
	INTEL_MSIC_BLOCK_THERMAL,
	INTEL_MSIC_BLOCK_POWER_BTN,
	INTEL_MSIC_BLOCK_OCD,

	INTEL_MSIC_BLOCK_LAST,
};

/**
 * struct intel_msic_platform_data - platform data for the MSIC driver
 * @irq: array of interrupt numbers, one per device. If @irq is set to %0
 *	 for a given block, the corresponding platform device is not
 *	 created. For devices which don't have an interrupt, use %0xff
 *	 (this is same as in SFI spec).
 * @gpio: platform data for the MSIC GPIO driver
 * @ocd: platform data for the MSIC OCD driver
 *
 * Once the MSIC driver is initialized, the register interface is ready to
 * use. All the platform devices for subdevices are created after the
 * register interface is ready so that we can guarantee its availability to
 * the subdevice drivers.
 *
 * Interrupt numbers are passed to the subdevices via %IORESOURCE_IRQ
 * resources of the created platform device.
 */
struct intel_msic_platform_data {
	int				irq[INTEL_MSIC_BLOCK_LAST];
	struct intel_msic_gpio_pdata	*gpio;
	struct intel_msic_ocd_pdata	*ocd;
};

struct intel_msic;

extern int intel_msic_reg_read(unsigned short reg, u8 *val);
extern int intel_msic_reg_write(unsigned short reg, u8 val);
extern int intel_msic_reg_update(unsigned short reg, u8 val, u8 mask);
extern int intel_msic_bulk_read(unsigned short *reg, u8 *buf, size_t count);
extern int intel_msic_bulk_write(unsigned short *reg, u8 *buf, size_t count);

/*
 * pdev_to_intel_msic - gets an MSIC instance from the platform device
 * @pdev: platform device pointer
 *
 * The client drivers need to have pointer to the MSIC instance if they
 * want to call intel_msic_irq_read(). This macro can be used for
 * convenience to get the MSIC pointer from @pdev where needed. This is
 * _only_ valid for devices which are managed by the MSIC.
 */
#define pdev_to_intel_msic(pdev)	(dev_get_drvdata(pdev->dev.parent))

extern int intel_msic_irq_read(struct intel_msic *msic, unsigned short reg,
			       u8 *val);

#endif /* __LINUX_MFD_INTEL_MSIC_H__ */
        /*
 * Core driver interface for TI TPS65090 PMIC family
 *
 * Copyright (C) 2012 NVIDIA Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

#ifndef __LINUX_MFD_TPS65090_H
#define __LINUX_MFD_TPS65090_H

#include <linux/irq.h>
#include <linux/regmap.h>

/* TPS65090 IRQs */
enum {
	TPS65090_IRQ_INTERRUPT,
	TPS65090_IRQ_VAC_STATUS_CHANGE,
	TPS65090_IRQ_VSYS_STATUS_CHANGE,
	TPS65090_IRQ_BAT_STATUS_CHANGE,
	TPS65090_IRQ_CHARGING_STATUS_CHANGE,
	TPS65090_IRQ_CHARGING_COMPLETE,
	TPS65090_IRQ_OVERLOAD_DCDC1,
	TPS65090_IRQ_OVERLOAD_DCDC2,
	TPS65090_IRQ_OVERLOAD_DCDC3,
	TPS65090_IRQ_OVERLOAD_FET1,
	TPS65090_IRQ_OVERLOAD_FET2,
	TPS65090_IRQ_OVERLOAD_FET3,
	TPS65090_IRQ_OVERLOAD_FET4,
	TPS65090_IRQ_OVERLOAD_FET5,
	TPS65090_IRQ_OVERLOAD_FET6,
	TPS65090_IRQ_OVERLOAD_FET7,
};

/* TPS65090 Regulator ID */
enum {
	TPS65090_REGULATOR_DCDC1,
	TPS65090_REGULATOR_DCDC2,
	TPS65090_REGULATOR_DCDC3,
	TPS65090_REGULATOR_FET1,
	TPS65090_REGULATOR_FET2,
	TPS65090_REGULATOR_FET3,
	TPS65090_REGULATOR_FET4,
	TPS65090_REGULATOR_FET5,
	TPS65090_REGULATOR_FET6,
	TPS65090_REGULATOR_FET7,
	TPS65090_REGULATOR_LDO1,
	TPS65090_REGULATOR_LDO2,

	/* Last entry for maximum ID */
	TPS65090_REGULATOR_MAX,
};

/* Register addresses */
#define TPS65090_REG_INTR_STS	0x00
#define TPS65090_REG_INTR_STS2	0x01
#define TPS65090_REG_INTR_MASK	0x02
#define TPS65090_REG_INTR_MASK2	0x03
#define TPS65090_REG_CG_CTRL0	0x04
#define TPS65090_REG_CG_CTRL1	0x05
#define TPS65090_REG_CG_CTRL2	0x06
#define TPS65090_REG_CG_CTRL3	0x07
#define TPS65090_REG_CG_CTRL4	0x08
#define TPS65090_REG_CG_CTRL5	0x09
#define TPS65090_REG_CG_STATUS1	0x0a
#define TPS65090_REG_CG_STATUS2	0x0b

struct tps65090 {
	struct device		*dev;
	struct regmap		*rmap;
	struct regmap_irq_chip_data *irq_data;
};

/*
 * struct tps65090_regulator_plat_data
 *
 * @reg_init_data: The regulator init data.
 * @enable_ext_control: Enable extrenal control or not. Only available for
 *     DCDC1, DCDC2 and DCDC3.
 * @gpio: Gpio number if external control is enabled and controlled through
 *     gpio.
 * @overcurrent_wait_valid: True if the overcurrent_wait should be applied.
 * @overcurrent_wait: Value to set as the overcurrent wait time.  This is the
 *     actual bitfield value, not a time in ms (valid value are 0 - 3).
 */
struct tps65090_regulator_plat_data {
	struct regulator_init_data *reg_init_data;
	bool enable_ext_control;
	int gpio;
	bool overcurrent_wait_valid;
	int overcurrent_wait;
};

struct tps65090_platform_data {
	int irq_base;

	char **supplied_to;
	size_t num_supplicants;
	int enable_low_current_chrg;

	struct tps65090_regulator_plat_data *reg_pdata[TPS65090_REGULATOR_MAX];
};

/*
 * NOTE: the functions below are not intended for use outside
 * of the TPS65090 sub-device drivers
 */
static inline int tps65090_write(struct device *dev, int reg, uint8_t val)
{
	struct tps65090 *tps = dev_get_drvdata(dev);

	return regmap_write(tps->rmap, reg, val);
}

static inline int tps65090_read(struct device *dev, int reg, uint8_t *val)
{
	struct tps65090 *tps = dev_get_drvdata(dev);
	unsigned int temp_val;
	int ret;

	ret = regmap_read(tps->rmap, reg, &temp_val);
	if (!ret)
		*val = temp_val;
	return ret;
}

static inline int tps65090_set_bits(struct device *dev, int reg,
		uint8_t bit_num)
{
	struct tps65090 *tps = dev_get_drvdata(dev);

	return regmap_update_bits(tps->rmap, reg, BIT(bit_num), ~0u);
}

static inline int tps65090_clr_bits(struct device *dev, int reg,
		uint8_t bit_num)
{
	struct tps65090 *tps = dev_get_drvdata(dev);

	return regmap_update_bits(tps->rmap, reg, BIT(bit_num), 0u);
}

#endif /*__LINUX_MFD_TPS65090_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * linux/include/linux/mfd/aat2870.h
 *
 * Copyright (c) 2011, NVIDIA Corporation.
 * Author: Jin Park <jinyoungp@nvidia.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */

#ifndef __LINUX_MFD_AAT2870_H
#define __LINUX_MFD_AAT2870_H

#include <linux/debugfs.h>
#include <linux/i2c.h>

/* Register offsets */
#define AAT2870_BL_CH_EN	0x00
#define AAT2870_BLM		0x01
#define AAT2870_BLS		0x02
#define AAT2870_BL1		0x03
#define AAT2870_BL2		0x04
#define AAT2870_BL3		0x05
#define AAT2870_BL4		0x06
#define AAT2870_BL5		0x07
#define AAT2870_BL6		0x08
#define AAT2870_BL7		0x09
#define AAT2870_BL8		0x0A
#define AAT2870_FLR		0x0B
#define AAT2870_FM		0x0C
#define AAT2870_FS		0x0D
#define AAT2870_ALS_CFG0	0x0E
#define AAT2870_ALS_CFG1	0x0F
#define AAT2870_ALS_CFG2	0x10
#define AAT2870_AMB		0x11
#define AAT2870_ALS0		0x12
#define AAT2870_ALS1		0x13
#define AAT2870_ALS2		0x14
#define AAT2870_ALS3		0x15
#define AAT2870_ALS4		0x16
#define AAT2870_ALS5		0x17
#define AAT2870_ALS6		0x18
#define AAT2870_ALS7		0x19
#define AAT2870_ALS8		0x1A
#define AAT2870_ALS9		0x1B
#define AAT2870_ALSA		0x1C
#define AAT2870_ALSB		0x1D
#define AAT2870_ALSC		0x1E
#define AAT2870_ALSD		0x1F
#define AAT2870_ALSE		0x20
#define AAT2870_ALSF		0x21
#define AAT2870_SUB_SET		0x22
#define AAT2870_SUB_CTRL	0x23
#define AAT2870_LDO_AB		0x24
#define AAT2870_LDO_CD		0x25
#define AAT2870_LDO_EN		0x26
#define AAT2870_REG_NUM		0x27

/* Device IDs */
enum aat2870_id {
	AAT2870_ID_BL,
	AAT2870_ID_LDOA,
	AAT2870_ID_LDOB,
	AAT2870_ID_LDOC,
	AAT2870_ID_LDOD
};

/* Backlight channels */
#define AAT2870_BL_CH1		0x01
#define AAT2870_BL_CH2		0x02
#define AAT2870_BL_CH3		0x04
#define AAT2870_BL_CH4		0x08
#define AAT2870_BL_CH5		0x10
#define AAT2870_BL_CH6		0x20
#define AAT2870_BL_CH7		0x40
#define AAT2870_BL_CH8		0x80
#define AAT2870_BL_CH_ALL	0xFF

/* Backlight current magnitude (mA) */
enum aat2870_current {
	AAT2870_CURRENT_0_45 = 1,
	AAT2870_CURRENT_0_90,
	AAT2870_CURRENT_1_80,
	AAT2870_CURRENT_2_70,
	AAT2870_CURRENT_3_60,
	AAT2870_CURRENT_4_50,
	AAT2870_CURRENT_5_40,
	AAT2870_CURRENT_6_30,
	AAT2870_CURRENT_7_20,
	AAT2870_CURRENT_8_10,
	AAT2870_CURRENT_9_00,
	AAT2870_CURRENT_9_90,
	AAT2870_CURRENT_10_8,
	AAT2870_CURRENT_11_7,
	AAT2870_CURRENT_12_6,
	AAT2870_CURRENT_13_5,
	AAT2870_CURRENT_14_4,
	AAT2870_CURRENT_15_3,
	AAT2870_CURRENT_16_2,
	AAT2870_CURRENT_17_1,
	AAT2870_CURRENT_18_0,
	AAT2870_CURRENT_18_9,
	AAT2870_CURRENT_19_8,
	AAT2870_CURRENT_20_7,
	AAT2870_CURRENT_21_6,
	AAT2870_CURRENT_22_5,
	AAT2870_CURRENT_23_4,
	AAT2870_CURRENT_24_3,
	AAT2870_CURRENT_25_2,
	AAT2870_CURRENT_26_1,
	AAT2870_CURRENT_27_0,
	AAT2870_CURRENT_27_9
};

struct aat2870_register {
	bool readable;
	bool writeable;
	u8 value;
};

struct aat2870_data {
	struct device *dev;
	struct i2c_client *client;

	struct mutex io_lock;
	struct aat2870_register *reg_cache; /* register cache */
	int en_pin; /* enable GPIO pin (if < 0, ignore this value) */
	bool is_enable;

	/* init and uninit for platform specified */
	int (*init)(struct aat2870_data *aat2870);
	void (*uninit)(struct aat2870_data *aat2870);

	/* i2c io funcntions */
	int (*read)(struct aat2870_data *aat2870, u8 addr, u8 *val);
	int (*write)(struct aat2870_data *aat2870, u8 addr, u8 val);
	int (*update)(struct aat2870_data *aat2870, u8 addr, u8 mask, u8 val);

	/* for debugfs */
	struct dentry *dentry_root;
	struct dentry *dentry_reg;
};

struct aat2870_subdev_info {
	int id;
	const char *name;
	void *platform_data;
};

struct aat2870_platform_data {
	int en_pin; /* enable GPIO pin (if < 0, ignore this value) */

	struct aat2870_subdev_info *subdevs;
	int num_subdevs;

	/* init and uninit for platform specified */
	int (*init)(struct aat2870_data *aat2870);
	void (*uninit)(struct aat2870_data *aat2870);
};

struct aat2870_bl_platform_data {
	/* backlight channels, default is AAT2870_BL_CH_ALL */
	int channels;
	/* backlight current magnitude, default is AAT2870_CURRENT_27_9 */
	int max_current;
	/* maximum brightness, default is 255 */
	int max_brightness;
};

#endif /* __LINUX_MFD_AAT2870_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * DaVinci Voice Codec Core Interface for TI platforms
 *
 * Copyright (C) 2010 Texas Instruments, Inc
 *
 * Author: Miguel Aguilar <miguel.aguilar@ridgerun.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#ifndef __LINUX_MFD_DAVINCI_VOICECODEC_H_
#define __LINUX_MFD_DAVINCI_VOICECODEC_H_

#include <linux/kernel.h>
#include <linux/platform_device.h>
#include <linux/mfd/core.h>
#include <linux/platform_data/edma.h>

#include <mach/hardware.h>

struct regmap;

/*
 * Register values.
 */
#define DAVINCI_VC_PID			0x00
#define DAVINCI_VC_CTRL			0x04
#define DAVINCI_VC_INTEN		0x08
#define DAVINCI_VC_INTSTATUS		0x0c
#define DAVINCI_VC_INTCLR		0x10
#define DAVINCI_VC_EMUL_CTRL		0x14
#define DAVINCI_VC_RFIFO		0x20
#define DAVINCI_VC_WFIFO		0x24
#define DAVINCI_VC_FIFOSTAT		0x28
#define DAVINCI_VC_TST_CTRL		0x2C
#define DAVINCI_VC_REG05		0x94
#define DAVINCI_VC_REG09		0xA4
#define DAVINCI_VC_REG12		0xB0

/* DAVINCI_VC_CTRL bit fields */
#define DAVINCI_VC_CTRL_MASK		0x5500
#define DAVINCI_VC_CTRL_RSTADC		BIT(0)
#define DAVINCI_VC_CTRL_RSTDAC		BIT(1)
#define DAVINCI_VC_CTRL_RD_BITS_8	BIT(4)
#define DAVINCI_VC_CTRL_RD_UNSIGNED	BIT(5)
#define DAVINCI_VC_CTRL_WD_BITS_8	BIT(6)
#define DAVINCI_VC_CTRL_WD_UNSIGNED	BIT(7)
#define DAVINCI_VC_CTRL_RFIFOEN		BIT(8)
#define DAVINCI_VC_CTRL_RFIFOCL		BIT(9)
#define DAVINCI_VC_CTRL_RFIFOMD_WORD_1	BIT(10)
#define DAVINCI_VC_CTRL_WFIFOEN		BIT(12)
#define DAVINCI_VC_CTRL_WFIFOCL		BIT(13)
#define DAVINCI_VC_CTRL_WFIFOMD_WORD_1	BIT(14)

/* DAVINCI_VC_INT bit fields */
#define DAVINCI_VC_INT_MASK		0x3F
#define DAVINCI_VC_INT_RDRDY_MASK	BIT(0)
#define DAVINCI_VC_INT_RERROVF_MASK	BIT(1)
#define DAVINCI_VC_INT_RERRUDR_MASK	BIT(2)
#define DAVINCI_VC_INT_WDREQ_MASK	BIT(3)
#define DAVINCI_VC_INT_WERROVF_MASKBIT	BIT(4)
#define DAVINCI_VC_INT_WERRUDR_MASK	BIT(5)

/* DAVINCI_VC_REG05 bit fields */
#define DAVINCI_VC_REG05_PGA_GAIN	0x07

/* DAVINCI_VC_REG09 bit fields */
#define DAVINCI_VC_REG09_MUTE		0x40
#define DAVINCI_VC_REG09_DIG_ATTEN	0x3F

/* DAVINCI_VC_REG12 bit fields */
#define DAVINCI_VC_REG12_POWER_ALL_ON	0xFD
#define DAVINCI_VC_REG12_POWER_ALL_OFF	0x00

#define DAVINCI_VC_CELLS		2

enum davinci_vc_cells {
	DAVINCI_VC_VCIF_CELL,
	DAVINCI_VC_CQ93VC_CELL,
};

struct davinci_vcif {
	struct platform_device	*pdev;
	u32 dma_tx_channel;
	u32 dma_rx_channel;
	dma_addr_t dma_tx_addr;
	dma_addr_t dma_rx_addr;
};

struct davinci_vc;

struct davinci_vc {
	/* Device data */
	struct device *dev;
	struct platform_device *pdev;
	struct clk *clk;

	/* Memory resources */
	void __iomem *base;
	struct regmap *regmap;

	/* MFD cells */
	struct mfd_cell cells[DAVINCI_VC_CELLS];

	/* Client devices */
	struct davinci_vcif davinci_vcif;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 *  linux/drivers/mfd/lpc_ich.h
 *
 *  Copyright (c) 2012 Extreme Engineering Solution, Inc.
 *  Author: Aaron Sierra <asierra@xes-inc.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License 2 as published
 *  by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; see the file COPYING.  If not, write to
 *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */
#ifndef LPC_ICH_H
#define LPC_ICH_H

/* Watchdog resources */
#define ICH_RES_IO_TCO		0
#define ICH_RES_IO_SMI		1
#define ICH_RES_MEM_OFF		2
#define ICH_RES_MEM_GCS_PMC	0

/* GPIO resources */
#define ICH_RES_GPIO	0
#define ICH_RES_GPE0	1

/* GPIO compatibility */
enum {
	ICH_I3100_GPIO,
	ICH_V5_GPIO,
	ICH_V6_GPIO,
	ICH_V7_GPIO,
	ICH_V9_GPIO,
	ICH_V10CORP_GPIO,
	ICH_V10CONS_GPIO,
	AVOTON_GPIO,
};

struct lpc_ich_info {
	char name[32];
	unsigned int iTCO_version;
	unsigned int gpio_version;
	u8 use_gpio;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * max8997.h - Driver for the Maxim 8997/8966
 *
 *  Copyright (C) 2009-2010 Samsung Electrnoics
 *  MyungJoo Ham <myungjoo.ham@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * This driver is based on max8998.h
 *
 * MAX8997 has PMIC, MUIC, HAPTIC, RTC, FLASH, and Fuel Gauge devices.
 * Except Fuel Gauge, every device shares the same I2C bus and included in
 * this mfd driver. Although the fuel gauge is included in the chip, it is
 * excluded from the driver because a) it has a different I2C bus from
 * others and b) it can be enabled simply by using MAX17042 driver.
 */

#ifndef __LINUX_MFD_MAX8998_H
#define __LINUX_MFD_MAX8998_H

#include <linux/regulator/consumer.h>

/* MAX8997/8966 regulator IDs */
enum max8998_regulators {
	MAX8997_LDO1 = 0,
	MAX8997_LDO2,
	MAX8997_LDO3,
	MAX8997_LDO4,
	MAX8997_LDO5,
	MAX8997_LDO6,
	MAX8997_LDO7,
	MAX8997_LDO8,
	MAX8997_LDO9,
	MAX8997_LDO10,
	MAX8997_LDO11,
	MAX8997_LDO12,
	MAX8997_LDO13,
	MAX8997_LDO14,
	MAX8997_LDO15,
	MAX8997_LDO16,
	MAX8997_LDO17,
	MAX8997_LDO18,
	MAX8997_LDO21,
	MAX8997_BUCK1,
	MAX8997_BUCK2,
	MAX8997_BUCK3,
	MAX8997_BUCK4,
	MAX8997_BUCK5,
	MAX8997_BUCK6,
	MAX8997_BUCK7,
	MAX8997_EN32KHZ_AP,
	MAX8997_EN32KHZ_CP,
	MAX8997_ENVICHG,
	MAX8997_ESAFEOUT1,
	MAX8997_ESAFEOUT2,
	MAX8997_CHARGER_CV, /* control MBCCV of MBCCTRL3 */
	MAX8997_CHARGER, /* charger current, MBCCTRL4 */
	MAX8997_CHARGER_TOPOFF, /* MBCCTRL5 */

	MAX8997_REG_MAX,
};

struct max8997_regulator_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *reg_node;
};

struct max8997_muic_reg_data {
	u8 addr;
	u8 data;
};

/**
 * struct max8997_muic_platform_data
 * @init_data: array of max8997_muic_reg_data
 *	       used for initializing registers of MAX8997 MUIC device
 * @num_init_data: array size of init_data
 */
struct max8997_muic_platform_data {
	struct max8997_muic_reg_data *init_data;
	int num_init_data;

	/* Check cable state after certain delay */
	int detcable_delay_ms;

	/*
	 * Default usb/uart path whether UART/USB or AUX_UART/AUX_USB
	 * h/w path of COMP2/COMN1 on CONTROL1 register.
	 */
	int path_usb;
	int path_uart;
};

enum max8997_haptic_motor_type {
	MAX8997_HAPTIC_ERM,
	MAX8997_HAPTIC_LRA,
};

enum max8997_haptic_pulse_mode {
	MAX8997_EXTERNAL_MODE,
	MAX8997_INTERNAL_MODE,
};

enum max8997_haptic_pwm_divisor {
	MAX8997_PWM_DIVISOR_32,
	MAX8997_PWM_DIVISOR_64,
	MAX8997_PWM_DIVISOR_128,
	MAX8997_PWM_DIVISOR_256,
};

/**
 * max8997_haptic_platform_data
 * @pwm_channel_id: channel number of PWM device
 *		    valid for MAX8997_EXTERNAL_MODE
 * @pwm_period: period in nano second for PWM device
 *		valid for MAX8997_EXTERNAL_MODE
 * @type: motor type
 * @mode: pulse mode
 *     MAX8997_EXTERNAL_MODE: external PWM device is used to control motor
 *     MAX8997_INTERNAL_MODE: internal pulse generator is used to control motor
 * @pwm_divisor: divisor for external PWM device
 * @internal_mode_pattern: internal mode pattern for internal mode
 *     [0 - 3]: valid pattern number
 * @pattern_cycle: the number of cycles of the waveform
 *		   for the internal mode pattern
 *     [0 - 15]: available cycles
 * @pattern_signal_period: period of the waveform for the internal mode pattern
 *     [0 - 255]: available period
 */
struct max8997_haptic_platform_data {
	unsigned int pwm_channel_id;
	unsigned int pwm_period;

	enum max8997_haptic_motor_type type;
	enum max8997_haptic_pulse_mode mode;
	enum max8997_haptic_pwm_divisor pwm_divisor;

	unsigned int internal_mode_pattern;
	unsigned int pattern_cycle;
	unsigned int pattern_signal_period;
};

enum max8997_led_mode {
	MAX8997_NONE,
	MAX8997_FLASH_MODE,
	MAX8997_MOVIE_MODE,
	MAX8997_FLASH_PIN_CONTROL_MODE,
	MAX8997_MOVIE_PIN_CONTROL_MODE,
};

/**
 *  struct max8997_led_platform_data
 *  The number of LED devices for MAX8997 is two
 *  @mode: LED mode for each LED device
 *  @brightness: initial brightness for each LED device
 *	range:
 *	[0 - 31]: MAX8997_FLASH_MODE and MAX8997_FLASH_PIN_CONTROL_MODE
 *	[0 - 15]: MAX8997_MOVIE_MODE and MAX8997_MOVIE_PIN_CONTROL_MODE
 */
struct max8997_led_platform_data {
	enum max8997_led_mode mode[2];
	u8 brightness[2];
};

struct max8997_platform_data {
	/* IRQ */
	int ono;
	int wakeup;

	/* ---- PMIC ---- */
	struct max8997_regulator_data *regulators;
	int num_regulators;

	/*
	 * SET1~3 DVS GPIOs control Buck1, 2, and 5 simultaneously. Therefore,
	 * With buckx_gpiodvs enabled, the buckx cannot be controlled
	 * independently. To control buckx (of 1, 2, and 5) independently,
	 * disable buckx_gpiodvs and control with BUCKxDVS1 register.
	 *
	 * When buckx_gpiodvs and bucky_gpiodvs are both enabled, set_voltage
	 * on buckx will change the voltage of bucky at the same time.
	 *
	 */
	bool ignore_gpiodvs_side_effect;
	int buck125_gpios[3]; /* GPIO of [0]SET1, [1]SET2, [2]SET3 */
	int buck125_default_idx; /* Default value of SET1, 2, 3 */
	unsigned int buck1_voltage[8]; /* buckx_voltage in uV */
	bool buck1_gpiodvs;
	unsigned int buck2_voltage[8];
	bool buck2_gpiodvs;
	unsigned int buck5_voltage[8];
	bool buck5_gpiodvs;

	/* ---- Charger control ---- */
	/* eoc stands for 'end of charge' */
	int eoc_mA; /* 50 ~ 200mA by 10mA step */
	/* charge Full Timeout */
	int timeout; /* 0 (no timeout), 5, 6, 7 hours */

	/* ---- MUIC ---- */
	struct max8997_muic_platform_data *muic_pdata;

	/* ---- HAPTIC ---- */
	struct max8997_haptic_platform_data *haptic_pdata;

	/* RTC: Not implemented */
	/* ---- LED ---- */
	struct max8997_led_platform_data *led_pdata;
};

#endif /* __LINUX_MFD_MAX8998_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #ifndef __LINUX_PMIC_DA903X_H
#define __LINUX_PMIC_DA903X_H

/* Unified sub device IDs for DA9030/DA9034/DA9035 */
enum {
	DA9030_ID_LED_1,
	DA9030_ID_LED_2,
	DA9030_ID_LED_3,
	DA9030_ID_LED_4,
	DA9030_ID_LED_PC,
	DA9030_ID_VIBRA,
	DA9030_ID_WLED,
	DA9030_ID_BUCK1,
	DA9030_ID_BUCK2,
	DA9030_ID_LDO1,
	DA9030_ID_LDO2,
	DA9030_ID_LDO3,
	DA9030_ID_LDO4,
	DA9030_ID_LDO5,
	DA9030_ID_LDO6,
	DA9030_ID_LDO7,
	DA9030_ID_LDO8,
	DA9030_ID_LDO9,
	DA9030_ID_LDO10,
	DA9030_ID_LDO11,
	DA9030_ID_LDO12,
	DA9030_ID_LDO13,
	DA9030_ID_LDO14,
	DA9030_ID_LDO15,
	DA9030_ID_LDO16,
	DA9030_ID_LDO17,
	DA9030_ID_LDO18,
	DA9030_ID_LDO19,
	DA9030_ID_LDO_INT,	/* LDO Internal */
	DA9030_ID_BAT,		/* battery charger */

	DA9034_ID_LED_1,
	DA9034_ID_LED_2,
	DA9034_ID_VIBRA,
	DA9034_ID_WLED,
	DA9034_ID_TOUCH,

	DA9034_ID_BUCK1,
	DA9034_ID_BUCK2,
	DA9034_ID_LDO1,
	DA9034_ID_LDO2,
	DA9034_ID_LDO3,
	DA9034_ID_LDO4,
	DA9034_ID_LDO5,
	DA9034_ID_LDO6,
	DA9034_ID_LDO7,
	DA9034_ID_LDO8,
	DA9034_ID_LDO9,
	DA9034_ID_LDO10,
	DA9034_ID_LDO11,
	DA9034_ID_LDO12,
	DA9034_ID_LDO13,
	DA9034_ID_LDO14,
	DA9034_ID_LDO15,

	DA9035_ID_BUCK3,
};

/*
 * DA9030/DA9034 LEDs sub-devices uses generic "struct led_info"
 * as the platform_data
 */

/* DA9030 flags for "struct led_info"
 */
#define DA9030_LED_RATE_ON	(0 << 5)
#define DA9030_LED_RATE_052S	(1 << 5)
#define DA9030_LED_DUTY_1_16	(0 << 3)
#define DA9030_LED_DUTY_1_8	(1 << 3)
#define DA9030_LED_DUTY_1_4	(2 << 3)
#define DA9030_LED_DUTY_1_2	(3 << 3)

#define DA9030_VIBRA_MODE_1P3V	(0 << 1)
#define DA9030_VIBRA_MODE_2P7V	(1 << 1)
#define DA9030_VIBRA_FREQ_1HZ	(0 << 2)
#define DA9030_VIBRA_FREQ_2HZ	(1 << 2)
#define DA9030_VIBRA_FREQ_4HZ	(2 << 2)
#define DA9030_VIBRA_FREQ_8HZ	(3 << 2)
#define DA9030_VIBRA_DUTY_ON	(0 << 4)
#define DA9030_VIBRA_DUTY_75P	(1 << 4)
#define DA9030_VIBRA_DUTY_50P	(2 << 4)
#define DA9030_VIBRA_DUTY_25P	(3 << 4)

/* DA9034 flags for "struct led_info" */
#define DA9034_LED_RAMP		(1 << 7)

/* DA9034 touch screen platform data */
struct da9034_touch_pdata {
	int	interval_ms;	/* sampling interval while pen down */
	int	x_inverted;
	int	y_inverted;
};

struct da9034_backlight_pdata {
	int	output_current;	/* output current of WLED, from 0-31 (in mA) */
};

/* DA9030 battery charger data */
struct power_supply_info;

struct da9030_battery_info {
	/* battery parameters */
	struct power_supply_info *battery_info;

	/* current and voltage to use for battery charging */
	unsigned int charge_milliamp;
	unsigned int charge_millivolt;

	/* voltage thresholds (in millivolts) */
	int vbat_low;
	int vbat_crit;
	int vbat_charge_start;
	int vbat_charge_stop;
	int vbat_charge_restart;

	/* battery nominal minimal and maximal voltages in millivolts */
	int vcharge_min;
	int vcharge_max;

	/* Temperature thresholds. These are DA9030 register values
	   "as is" and should be measured for each battery type */
	int tbat_low;
	int tbat_high;
	int tbat_restart;


	/* battery monitor interval (seconds) */
	unsigned int batmon_interval;

	/* platform callbacks for battery low and critical events */
	void (*battery_low)(void);
	void (*battery_critical)(void);
};

struct da903x_subdev_info {
	int		id;
	const char	*name;
	void		*platform_data;
};

struct da903x_platform_data {
	int num_subdevs;
	struct da903x_subdev_info *subdevs;
};

/* bit definitions for DA9030 events */
#define DA9030_EVENT_ONKEY		(1 << 0)
#define	DA9030_EVENT_PWREN		(1 << 1)
#define	DA9030_EVENT_EXTON		(1 << 2)
#define	DA9030_EVENT_CHDET		(1 << 3)
#define	DA9030_EVENT_TBAT		(1 << 4)
#define	DA9030_EVENT_VBATMON		(1 << 5)
#define	DA9030_EVENT_VBATMON_TXON	(1 << 6)
#define	DA9030_EVENT_CHIOVER		(1 << 7)
#define	DA9030_EVENT_TCTO		(1 << 8)
#define	DA9030_EVENT_CCTO		(1 << 9)
#define	DA9030_EVENT_ADC_READY		(1 << 10)
#define	DA9030_EVENT_VBUS_4P4		(1 << 11)
#define	DA9030_EVENT_VBUS_4P0		(1 << 12)
#define	DA9030_EVENT_SESS_VALID		(1 << 13)
#define	DA9030_EVENT_SRP_DETECT		(1 << 14)
#define	DA9030_EVENT_WATCHDOG		(1 << 15)
#define	DA9030_EVENT_LDO15		(1 << 16)
#define	DA9030_EVENT_LDO16		(1 << 17)
#define	DA9030_EVENT_LDO17		(1 << 18)
#define	DA9030_EVENT_LDO18		(1 << 19)
#define	DA9030_EVENT_LDO19		(1 << 20)
#define	DA9030_EVENT_BUCK2		(1 << 21)

/* bit definitions for DA9034 events */
#define DA9034_EVENT_ONKEY		(1 << 0)
#define DA9034_EVENT_EXTON		(1 << 2)
#define DA9034_EVENT_CHDET		(1 << 3)
#define DA9034_EVENT_TBAT		(1 << 4)
#define DA9034_EVENT_VBATMON		(1 << 5)
#define DA9034_EVENT_REV_IOVER		(1 << 6)
#define DA9034_EVENT_CH_IOVER		(1 << 7)
#define DA9034_EVENT_CH_TCTO		(1 << 8)
#define DA9034_EVENT_CH_CCTO		(1 << 9)
#define DA9034_EVENT_USB_DEV		(1 << 10)
#define DA9034_EVENT_OTGCP_IOVER	(1 << 11)
#define DA9034_EVENT_VBUS_4P55		(1 << 12)
#define DA9034_EVENT_VBUS_3P8		(1 << 13)
#define DA9034_EVENT_SESS_1P8		(1 << 14)
#define DA9034_EVENT_SRP_READY		(1 << 15)
#define DA9034_EVENT_ADC_MAN		(1 << 16)
#define DA9034_EVENT_ADC_AUTO4		(1 << 17)
#define DA9034_EVENT_ADC_AUTO5		(1 << 18)
#define DA9034_EVENT_ADC_AUTO6		(1 << 19)
#define DA9034_EVENT_PEN_DOWN		(1 << 20)
#define DA9034_EVENT_TSI_READY		(1 << 21)
#define DA9034_EVENT_UART_TX		(1 << 22)
#define DA9034_EVENT_UART_RX		(1 << 23)
#define DA9034_EVENT_HEADSET		(1 << 25)
#define DA9034_EVENT_HOOKSWITCH		(1 << 26)
#define DA9034_EVENT_WATCHDOG		(1 << 27)

extern int da903x_register_notifier(struct device *dev,
		struct notifier_block *nb, unsigned int events);
extern int da903x_unregister_notifier(struct device *dev,
		struct notifier_block *nb, unsigned int events);

/* Status Query Interface */
#define DA9030_STATUS_ONKEY		(1 << 0)
#define DA9030_STATUS_PWREN1		(1 << 1)
#define DA9030_STATUS_EXTON		(1 << 2)
#define DA9030_STATUS_CHDET		(1 << 3)
#define DA9030_STATUS_TBAT		(1 << 4)
#define DA9030_STATUS_VBATMON		(1 << 5)
#define DA9030_STATUS_VBATMON_TXON	(1 << 6)
#define DA9030_STATUS_MCLKDET		(1 << 7)

#define DA9034_STATUS_ONKEY		(1 << 0)
#define DA9034_STATUS_EXTON		(1 << 2)
#define DA9034_STATUS_CHDET		(1 << 3)
#define DA9034_STATUS_TBAT		(1 << 4)
#define DA9034_STATUS_VBATMON		(1 << 5)
#define DA9034_STATUS_PEN_DOWN		(1 << 6)
#define DA9034_STATUS_MCLKDET		(1 << 7)
#define DA9034_STATUS_USB_DEV		(1 << 8)
#define DA9034_STATUS_HEADSET		(1 << 9)
#define DA9034_STATUS_HOOKSWITCH	(1 << 10)
#define DA9034_STATUS_REMCON		(1 << 11)
#define DA9034_STATUS_VBUS_VALID_4P55	(1 << 12)
#define DA9034_STATUS_VBUS_VALID_3P8	(1 << 13)
#define DA9034_STATUS_SESS_VALID_1P8	(1 << 14)
#define DA9034_STATUS_SRP_READY		(1 << 15)

extern int da903x_query_status(struct device *dev, unsigned int status);


/* NOTE: the functions below are not intended for use outside
 * of the DA903x sub-device drivers
 */
extern int da903x_write(struct device *dev, int reg, uint8_t val);
extern int da903x_writes(struct device *dev, int reg, int len, uint8_t *val);
extern int da903x_read(struct device *dev, int reg, uint8_t *val);
extern int da903x_reads(struct device *dev, int reg, int len, uint8_t *val);
extern int da903x_update(struct device *dev, int reg, uint8_t val, uint8_t mask);
extern int da903x_set_bits(struct device *dev, int reg, uint8_t bit_mask);
extern int da903x_clr_bits(struct device *dev, int reg, uint8_t bit_mask);
#endif /* __LINUX_PMIC_DA903X_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Core driver interface to access RICOH_RC5T583 power management chip.
 *
 * Copyright (c) 2011-2012, NVIDIA CORPORATION.  All rights reserved.
 * Author: Laxman dewangan <ldewangan@nvidia.com>
 *
 * Based on code
 *      Copyright (C) 2011 RICOH COMPANY,LTD
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __LINUX_MFD_RC5T583_H
#define __LINUX_MFD_RC5T583_H

#include <linux/mutex.h>
#include <linux/types.h>
#include <linux/regmap.h>

#define RC5T583_MAX_REGS		0xF8

/* Maximum number of main interrupts */
#define MAX_MAIN_INTERRUPT		5
#define RC5T583_MAX_GPEDGE_REG		2
#define RC5T583_MAX_INTERRUPT_EN_REGS	8
#define RC5T583_MAX_INTERRUPT_MASK_REGS	9

/* Interrupt enable register */
#define RC5T583_INT_EN_SYS1	0x19
#define RC5T583_INT_EN_SYS2	0x1D
#define RC5T583_INT_EN_DCDC	0x41
#define RC5T583_INT_EN_RTC	0xED
#define RC5T583_INT_EN_ADC1	0x90
#define RC5T583_INT_EN_ADC2	0x91
#define RC5T583_INT_EN_ADC3	0x92

/* Interrupt status registers (monitor regs in Ricoh)*/
#define RC5T583_INTC_INTPOL	0xAD
#define RC5T583_INTC_INTEN	0xAE
#define RC5T583_INTC_INTMON	0xAF

#define RC5T583_INT_MON_GRP	0xAF
#define RC5T583_INT_MON_SYS1	0x1B
#define RC5T583_INT_MON_SYS2	0x1F
#define RC5T583_INT_MON_DCDC	0x43
#define RC5T583_INT_MON_RTC	0xEE

/* Interrupt clearing registers */
#define RC5T583_INT_IR_SYS1	0x1A
#define RC5T583_INT_IR_SYS2	0x1E
#define RC5T583_INT_IR_DCDC	0x42
#define RC5T583_INT_IR_RTC	0xEE
#define RC5T583_INT_IR_ADCL	0x94
#define RC5T583_INT_IR_ADCH	0x95
#define RC5T583_INT_IR_ADCEND	0x96
#define RC5T583_INT_IR_GPIOR	0xA9
#define RC5T583_INT_IR_GPIOF	0xAA

/* Sleep sequence registers */
#define RC5T583_SLPSEQ1		0x21
#define RC5T583_SLPSEQ2		0x22
#define RC5T583_SLPSEQ3		0x23
#define RC5T583_SLPSEQ4		0x24
#define RC5T583_SLPSEQ5		0x25
#define RC5T583_SLPSEQ6		0x26
#define RC5T583_SLPSEQ7		0x27
#define RC5T583_SLPSEQ8		0x28
#define RC5T583_SLPSEQ9		0x29
#define RC5T583_SLPSEQ10	0x2A
#define RC5T583_SLPSEQ11	0x2B

/* Regulator registers */
#define RC5T583_REG_DC0CTL	0x30
#define RC5T583_REG_DC0DAC	0x31
#define RC5T583_REG_DC0LATCTL	0x32
#define RC5T583_REG_SR0CTL	0x33

#define RC5T583_REG_DC1CTL	0x34
#define RC5T583_REG_DC1DAC	0x35
#define RC5T583_REG_DC1LATCTL	0x36
#define RC5T583_REG_SR1CTL	0x37

#define RC5T583_REG_DC2CTL	0x38
#define RC5T583_REG_DC2DAC	0x39
#define RC5T583_REG_DC2LATCTL	0x3A
#define RC5T583_REG_SR2CTL	0x3B

#define RC5T583_REG_DC3CTL	0x3C
#define RC5T583_REG_DC3DAC	0x3D
#define RC5T583_REG_DC3LATCTL	0x3E
#define RC5T583_REG_SR3CTL	0x3F


#define RC5T583_REG_LDOEN1	0x50
#define RC5T583_REG_LDOEN2	0x51
#define RC5T583_REG_LDODIS1	0x52
#define RC5T583_REG_LDODIS2	0x53

#define RC5T583_REG_LDO0DAC	0x54
#define RC5T583_REG_LDO1DAC	0x55
#define RC5T583_REG_LDO2DAC	0x56
#define RC5T583_REG_LDO3DAC	0x57
#define RC5T583_REG_LDO4DAC	0x58
#define RC5T583_REG_LDO5DAC	0x59
#define RC5T583_REG_LDO6DAC	0x5A
#define RC5T583_REG_LDO7DAC	0x5B
#define RC5T583_REG_LDO8DAC	0x5C
#define RC5T583_REG_LDO9DAC	0x5D

#define RC5T583_REG_DC0DAC_DS	0x60
#define RC5T583_REG_DC1DAC_DS	0x61
#define RC5T583_REG_DC2DAC_DS	0x62
#define RC5T583_REG_DC3DAC_DS	0x63

#define RC5T583_REG_LDO0DAC_DS	0x64
#define RC5T583_REG_LDO1DAC_DS	0x65
#define RC5T583_REG_LDO2DAC_DS	0x66
#define RC5T583_REG_LDO3DAC_DS	0x67
#define RC5T583_REG_LDO4DAC_DS	0x68
#define RC5T583_REG_LDO5DAC_DS	0x69
#define RC5T583_REG_LDO6DAC_DS	0x6A
#define RC5T583_REG_LDO7DAC_DS	0x6B
#define RC5T583_REG_LDO8DAC_DS	0x6C
#define RC5T583_REG_LDO9DAC_DS	0x6D

/* GPIO register base address */
#define RC5T583_GPIO_IOSEL	0xA0
#define RC5T583_GPIO_PDEN	0xA1
#define RC5T583_GPIO_IOOUT	0xA2
#define RC5T583_GPIO_PGSEL	0xA3
#define RC5T583_GPIO_GPINV	0xA4
#define RC5T583_GPIO_GPDEB	0xA5
#define RC5T583_GPIO_GPEDGE1	0xA6
#define RC5T583_GPIO_GPEDGE2	0xA7
#define RC5T583_GPIO_EN_INT	0xA8
#define RC5T583_GPIO_MON_IOIN	0xAB
#define RC5T583_GPIO_GPOFUNC	0xAC

/* RTC registers */
#define RC5T583_RTC_SEC		0xE0
#define RC5T583_RTC_MIN		0xE1
#define RC5T583_RTC_HOUR	0xE2
#define RC5T583_RTC_WDAY	0xE3
#define RC5T583_RTC_DAY		0xE4
#define RC5T583_RTC_MONTH	0xE5
#define RC5T583_RTC_YEAR	0xE6
#define RC5T583_RTC_ADJ		0xE7
#define RC5T583_RTC_AW_MIN	0xE8
#define RC5T583_RTC_AW_HOUR	0xE9
#define RC5T583_RTC_AW_WEEK	0xEA
#define RC5T583_RTC_AD_MIN	0xEB
#define RC5T583_RTC_AD_HOUR	0xEC
#define RC5T583_RTC_CTL1	0xED
#define RC5T583_RTC_CTL2	0xEE
#define RC5T583_RTC_AY_MIN	0xF0
#define RC5T583_RTC_AY_HOUR	0xF1
#define RC5T583_RTC_AY_DAY	0xF2
#define RC5T583_RTC_AY_MONTH 0xF3
#define RC5T583_RTC_AY_YEAR	0xF4

/* RICOH_RC5T583 IRQ definitions */
enum {
	RC5T583_IRQ_ONKEY,
	RC5T583_IRQ_ACOK,
	RC5T583_IRQ_LIDOPEN,
	RC5T583_IRQ_PREOT,
	RC5T583_IRQ_CLKSTP,
	RC5T583_IRQ_ONKEY_OFF,
	RC5T583_IRQ_WD,
	RC5T583_IRQ_EN_PWRREQ1,
	RC5T583_IRQ_EN_PWRREQ2,
	RC5T583_IRQ_PRE_VINDET,

	RC5T583_IRQ_DC0LIM,
	RC5T583_IRQ_DC1LIM,
	RC5T583_IRQ_DC2LIM,
	RC5T583_IRQ_DC3LIM,

	RC5T583_IRQ_CTC,
	RC5T583_IRQ_YALE,
	RC5T583_IRQ_DALE,
	RC5T583_IRQ_WALE,

	RC5T583_IRQ_AIN1L,
	RC5T583_IRQ_AIN2L,
	RC5T583_IRQ_AIN3L,
	RC5T583_IRQ_VBATL,
	RC5T583_IRQ_VIN3L,
	RC5T583_IRQ_VIN8L,
	RC5T583_IRQ_AIN1H,
	RC5T583_IRQ_AIN2H,
	RC5T583_IRQ_AIN3H,
	RC5T583_IRQ_VBATH,
	RC5T583_IRQ_VIN3H,
	RC5T583_IRQ_VIN8H,
	RC5T583_IRQ_ADCEND,

	RC5T583_IRQ_GPIO0,
	RC5T583_IRQ_GPIO1,
	RC5T583_IRQ_GPIO2,
	RC5T583_IRQ_GPIO3,
	RC5T583_IRQ_GPIO4,
	RC5T583_IRQ_GPIO5,
	RC5T583_IRQ_GPIO6,
	RC5T583_IRQ_GPIO7,

	/* Should be last entry */
	RC5T583_MAX_IRQS,
};

/* Ricoh583 gpio definitions */
enum {
	RC5T583_GPIO0,
	RC5T583_GPIO1,
	RC5T583_GPIO2,
	RC5T583_GPIO3,
	RC5T583_GPIO4,
	RC5T583_GPIO5,
	RC5T583_GPIO6,
	RC5T583_GPIO7,

	/* Should be last entry */
	RC5T583_MAX_GPIO,
};

enum {
	RC5T583_DS_NONE,
	RC5T583_DS_DC0,
	RC5T583_DS_DC1,
	RC5T583_DS_DC2,
	RC5T583_DS_DC3,
	RC5T583_DS_LDO0,
	RC5T583_DS_LDO1,
	RC5T583_DS_LDO2,
	RC5T583_DS_LDO3,
	RC5T583_DS_LDO4,
	RC5T583_DS_LDO5,
	RC5T583_DS_LDO6,
	RC5T583_DS_LDO7,
	RC5T583_DS_LDO8,
	RC5T583_DS_LDO9,
	RC5T583_DS_PSO0,
	RC5T583_DS_PSO1,
	RC5T583_DS_PSO2,
	RC5T583_DS_PSO3,
	RC5T583_DS_PSO4,
	RC5T583_DS_PSO5,
	RC5T583_DS_PSO6,
	RC5T583_DS_PSO7,

	/* Should be last entry */
	RC5T583_DS_MAX,
};

/*
 * Ricoh pmic RC5T583 supports sleep through two external controls.
 * The output of gpios and regulator can be enable/disable through
 * this external signals.
 */
enum {
	RC5T583_EXT_PWRREQ1_CONTROL = 0x1,
	RC5T583_EXT_PWRREQ2_CONTROL = 0x2,
};

enum {
	RC5T583_REGULATOR_DC0,
	RC5T583_REGULATOR_DC1,
	RC5T583_REGULATOR_DC2,
	RC5T583_REGULATOR_DC3,
	RC5T583_REGULATOR_LDO0,
	RC5T583_REGULATOR_LDO1,
	RC5T583_REGULATOR_LDO2,
	RC5T583_REGULATOR_LDO3,
	RC5T583_REGULATOR_LDO4,
	RC5T583_REGULATOR_LDO5,
	RC5T583_REGULATOR_LDO6,
	RC5T583_REGULATOR_LDO7,
	RC5T583_REGULATOR_LDO8,
	RC5T583_REGULATOR_LDO9,

	/* Should be last entry */
	RC5T583_REGULATOR_MAX,
};

struct rc5t583 {
	struct device	*dev;
	struct regmap	*regmap;
	int		chip_irq;
	int		irq_base;
	struct mutex	irq_lock;
	unsigned long	group_irq_en[MAX_MAIN_INTERRUPT];

	/* For main interrupt bits in INTC */
	uint8_t		intc_inten_reg;

	/* For group interrupt bits and address */
	uint8_t		irq_en_reg[RC5T583_MAX_INTERRUPT_EN_REGS];

	/* For gpio edge */
	uint8_t		gpedge_reg[RC5T583_MAX_GPEDGE_REG];
};

/*
 * rc5t583_platform_data: Platform data for ricoh rc5t583 pmu.
 * The board specific data is provided through this structure.
 * @irq_base: Irq base number on which this device registers their interrupts.
 * @gpio_base: GPIO base from which gpio of this device will start.
 * @enable_shutdown: Enable shutdown through the input pin "shutdown".
 * @regulator_deepsleep_slot: The slot number on which device goes to sleep
 *		in device sleep mode.
 * @regulator_ext_pwr_control: External power request regulator control. The
 *		regulator output enable/disable is controlled by the external
 *		power request input state.
 * @reg_init_data: Regulator init data.
 */

struct rc5t583_platform_data {
	int		irq_base;
	int		gpio_base;
	bool		enable_shutdown;
	int		regulator_deepsleep_slot[RC5T583_REGULATOR_MAX];
	unsigned long	regulator_ext_pwr_control[RC5T583_REGULATOR_MAX];
	struct regulator_init_data *reg_init_data[RC5T583_REGULATOR_MAX];
};

static inline int rc5t583_write(struct device *dev, uint8_t reg, uint8_t val)
{
	struct rc5t583 *rc5t583 = dev_get_drvdata(dev);
	return regmap_write(rc5t583->regmap, reg, val);
}

static inline int rc5t583_read(struct device *dev, uint8_t reg, uint8_t *val)
{
	struct rc5t583 *rc5t583 = dev_get_drvdata(dev);
	unsigned int ival;
	int ret;
	ret = regmap_read(rc5t583->regmap, reg, &ival);
	if (!ret)
		*val = (uint8_t)ival;
	return ret;
}

static inline int rc5t583_set_bits(struct device *dev, unsigned int reg,
			unsigned int bit_mask)
{
	struct rc5t583 *rc5t583 = dev_get_drvdata(dev);
	return regmap_update_bits(rc5t583->regmap, reg, bit_mask, bit_mask);
}

static inline int rc5t583_clear_bits(struct device *dev, unsigned int reg,
			unsigned int bit_mask)
{
	struct rc5t583 *rc5t583 = dev_get_drvdata(dev);
	return regmap_update_bits(rc5t583->regmap, reg, bit_mask, 0);
}

static inline int rc5t583_update(struct device *dev, unsigned int reg,
		unsigned int val, unsigned int mask)
{
	struct rc5t583 *rc5t583 = dev_get_drvdata(dev);
	return regmap_update_bits(rc5t583->regmap, reg, mask, val);
}

int rc5t583_ext_power_req_config(struct device *dev, int deepsleep_id,
	int ext_pwr_req, int deepsleep_slot_nr);
int rc5t583_irq_init(struct rc5t583 *rc5t583, int irq, int irq_base);
int rc5t583_irq_exit(struct rc5t583 *rc5t583);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * sky81452.h	SKY81452 MFD driver
 *
 * Copyright 2014 Skyworks Solutions Inc.
 * Author : Gyungoh Yoo <jack.yoo@skyworksinc.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _SKY81452_H
#define _SKY81452_H

#include <linux/platform_data/sky81452-backlight.h>
#include <linux/regulator/machine.h>

struct sky81452_platform_data {
	struct sky81452_bl_platform_data *bl_pdata;
	struct regulator_init_data *regulator_init_data;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * rk808.h for Rockchip RK808
 *
 * Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
 *
 * Author: Chris Zhong <zyw@rock-chips.com>
 * Author: Zhang Qing <zhangqing@rock-chips.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */

#ifndef __LINUX_REGULATOR_rk808_H
#define __LINUX_REGULATOR_rk808_H

#include <linux/regulator/machine.h>
#include <linux/regmap.h>

/*
 * rk808 Global Register Map.
 */

#define RK808_DCDC1	0 /* (0+RK808_START) */
#define RK808_LDO1	4 /* (4+RK808_START) */
#define RK808_NUM_REGULATORS   14

enum rk808_reg {
	RK808_ID_DCDC1,
	RK808_ID_DCDC2,
	RK808_ID_DCDC3,
	RK808_ID_DCDC4,
	RK808_ID_LDO1,
	RK808_ID_LDO2,
	RK808_ID_LDO3,
	RK808_ID_LDO4,
	RK808_ID_LDO5,
	RK808_ID_LDO6,
	RK808_ID_LDO7,
	RK808_ID_LDO8,
	RK808_ID_SWITCH1,
	RK808_ID_SWITCH2,
};

#define RK808_SECONDS_REG	0x00
#define RK808_MINUTES_REG	0x01
#define RK808_HOURS_REG		0x02
#define RK808_DAYS_REG		0x03
#define RK808_MONTHS_REG	0x04
#define RK808_YEARS_REG		0x05
#define RK808_WEEKS_REG		0x06
#define RK808_ALARM_SECONDS_REG	0x08
#define RK808_ALARM_MINUTES_REG	0x09
#define RK808_ALARM_HOURS_REG	0x0a
#define RK808_ALARM_DAYS_REG	0x0b
#define RK808_ALARM_MONTHS_REG	0x0c
#define RK808_ALARM_YEARS_REG	0x0d
#define RK808_RTC_CTRL_REG	0x10
#define RK808_RTC_STATUS_REG	0x11
#define RK808_RTC_INT_REG	0x12
#define RK808_RTC_COMP_LSB_REG	0x13
#define RK808_RTC_COMP_MSB_REG	0x14
#define RK808_CLK32OUT_REG	0x20
#define RK808_VB_MON_REG	0x21
#define RK808_THERMAL_REG	0x22
#define RK808_DCDC_EN_REG	0x23
#define RK808_LDO_EN_REG	0x24
#define RK808_SLEEP_SET_OFF_REG1	0x25
#define RK808_SLEEP_SET_OFF_REG2	0x26
#define RK808_DCDC_UV_STS_REG	0x27
#define RK808_DCDC_UV_ACT_REG	0x28
#define RK808_LDO_UV_STS_REG	0x29
#define RK808_LDO_UV_ACT_REG	0x2a
#define RK808_DCDC_PG_REG	0x2b
#define RK808_LDO_PG_REG	0x2c
#define RK808_VOUT_MON_TDB_REG	0x2d
#define RK808_BUCK1_CONFIG_REG		0x2e
#define RK808_BUCK1_ON_VSEL_REG		0x2f
#define RK808_BUCK1_SLP_VSEL_REG	0x30
#define RK808_BUCK1_DVS_VSEL_REG	0x31
#define RK808_BUCK2_CONFIG_REG		0x32
#define RK808_BUCK2_ON_VSEL_REG		0x33
#define RK808_BUCK2_SLP_VSEL_REG	0x34
#define RK808_BUCK2_DVS_VSEL_REG	0x35
#define RK808_BUCK3_CONFIG_REG		0x36
#define RK808_BUCK4_CONFIG_REG		0x37
#define RK808_BUCK4_ON_VSEL_REG		0x38
#define RK808_BUCK4_SLP_VSEL_REG	0x39
#define RK808_BOOST_CONFIG_REG		0x3a
#define RK808_LDO1_ON_VSEL_REG		0x3b
#define RK808_LDO1_SLP_VSEL_REG		0x3c
#define RK808_LDO2_ON_VSEL_REG		0x3d
#define RK808_LDO2_SLP_VSEL_REG		0x3e
#define RK808_LDO3_ON_VSEL_REG		0x3f
#define RK808_LDO3_SLP_VSEL_REG		0x40
#define RK808_LDO4_ON_VSEL_REG		0x41
#define RK808_LDO4_SLP_VSEL_REG		0x42
#define RK808_LDO5_ON_VSEL_REG		0x43
#define RK808_LDO5_SLP_VSEL_REG		0x44
#define RK808_LDO6_ON_VSEL_REG		0x45
#define RK808_LDO6_SLP_VSEL_REG		0x46
#define RK808_LDO7_ON_VSEL_REG		0x47
#define RK808_LDO7_SLP_VSEL_REG		0x48
#define RK808_LDO8_ON_VSEL_REG		0x49
#define RK808_LDO8_SLP_VSEL_REG		0x4a
#define RK808_DEVCTRL_REG	0x4b
#define RK808_INT_STS_REG1	0x4c
#define RK808_INT_STS_MSK_REG1	0x4d
#define RK808_INT_STS_REG2	0x4e
#define RK808_INT_STS_MSK_REG2	0x4f
#define RK808_IO_POL_REG	0x50

/* IRQ Definitions */
#define RK808_IRQ_VOUT_LO	0
#define RK808_IRQ_VB_LO		1
#define RK808_IRQ_PWRON		2
#define RK808_IRQ_PWRON_LP	3
#define RK808_IRQ_HOTDIE	4
#define RK808_IRQ_RTC_ALARM	5
#define RK808_IRQ_RTC_PERIOD	6
#define RK808_IRQ_PLUG_IN_INT	7
#define RK808_IRQ_PLUG_OUT_INT	8
#define RK808_NUM_IRQ		9

#define RK808_IRQ_VOUT_LO_MSK		BIT(0)
#define RK808_IRQ_VB_LO_MSK		BIT(1)
#define RK808_IRQ_PWRON_MSK		BIT(2)
#define RK808_IRQ_PWRON_LP_MSK		BIT(3)
#define RK808_IRQ_HOTDIE_MSK		BIT(4)
#define RK808_IRQ_RTC_ALARM_MSK		BIT(5)
#define RK808_IRQ_RTC_PERIOD_MSK	BIT(6)
#define RK808_IRQ_PLUG_IN_INT_MSK	BIT(0)
#define RK808_IRQ_PLUG_OUT_INT_MSK	BIT(1)

#define RK808_VBAT_LOW_2V8	0x00
#define RK808_VBAT_LOW_2V9	0x01
#define RK808_VBAT_LOW_3V0	0x02
#define RK808_VBAT_LOW_3V1	0x03
#define RK808_VBAT_LOW_3V2	0x04
#define RK808_VBAT_LOW_3V3	0x05
#define RK808_VBAT_LOW_3V4	0x06
#define RK808_VBAT_LOW_3V5	0x07
#define VBAT_LOW_VOL_MASK	(0x07 << 0)
#define EN_VABT_LOW_SHUT_DOWN	(0x00 << 4)
#define EN_VBAT_LOW_IRQ		(0x1 << 4)
#define VBAT_LOW_ACT_MASK	(0x1 << 4)

#define BUCK_ILMIN_MASK		(7 << 0)
#define BOOST_ILMIN_MASK	(7 << 0)
#define BUCK1_RATE_MASK		(3 << 3)
#define BUCK2_RATE_MASK		(3 << 3)
#define MASK_ALL	0xff

#define BUCK_UV_ACT_MASK	0x0f
#define BUCK_UV_ACT_DISABLE	0

#define SWITCH2_EN	BIT(6)
#define SWITCH1_EN	BIT(5)
#define DEV_OFF_RST	BIT(3)

#define VB_LO_ACT		BIT(4)
#define VB_LO_SEL_3500MV	(7 << 0)

#define VOUT_LO_INT	BIT(0)
#define CLK32KOUT2_EN	BIT(0)

enum {
	BUCK_ILMIN_50MA,
	BUCK_ILMIN_100MA,
	BUCK_ILMIN_150MA,
	BUCK_ILMIN_200MA,
	BUCK_ILMIN_250MA,
	BUCK_ILMIN_300MA,
	BUCK_ILMIN_350MA,
	BUCK_ILMIN_400MA,
};

enum {
	BOOST_ILMIN_75MA,
	BOOST_ILMIN_100MA,
	BOOST_ILMIN_125MA,
	BOOST_ILMIN_150MA,
	BOOST_ILMIN_175MA,
	BOOST_ILMIN_200MA,
	BOOST_ILMIN_225MA,
	BOOST_ILMIN_250MA,
};

struct rk808 {
	struct i2c_client *i2c;
	struct regmap_irq_chip_data *irq_data;
	struct regmap *regmap;
};
#endif /* __LINUX_REGULATOR_rk808_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * include/media/si476x-core.h -- Common definitions for si476x core
 * device
 *
 * Copyright (C) 2012 Innovative Converged Devices(ICD)
 * Copyright (C) 2013 Andrey Smirnov
 *
 * Author: Andrey Smirnov <andrew.smirnov@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 */

#ifndef SI476X_CORE_H
#define SI476X_CORE_H

#include <linux/kfifo.h>
#include <linux/atomic.h>
#include <linux/i2c.h>
#include <linux/regmap.h>
#include <linux/mutex.h>
#include <linux/mfd/core.h>
#include <linux/videodev2.h>
#include <linux/regulator/consumer.h>

#include <linux/mfd/si476x-platform.h>
#include <linux/mfd/si476x-reports.h>

/* Command Timeouts */
#define SI476X_DEFAULT_TIMEOUT	100000
#define SI476X_TIMEOUT_TUNE	700000
#define SI476X_TIMEOUT_POWER_UP	330000
#define SI476X_STATUS_POLL_US	0

/* -------------------- si476x-i2c.c ----------------------- */

enum si476x_freq_supported_chips {
	SI476X_CHIP_SI4761 = 1,
	SI476X_CHIP_SI4764,
	SI476X_CHIP_SI4768,
};

enum si476x_part_revisions {
	SI476X_REVISION_A10 = 0,
	SI476X_REVISION_A20 = 1,
	SI476X_REVISION_A30 = 2,
};

enum si476x_mfd_cells {
	SI476X_RADIO_CELL = 0,
	SI476X_CODEC_CELL,
	SI476X_MFD_CELLS,
};

/**
 * enum si476x_power_state - possible power state of the si476x
 * device.
 *
 * @SI476X_POWER_DOWN: In this state all regulators are turned off
 * and the reset line is pulled low. The device is completely
 * inactive.
 * @SI476X_POWER_UP_FULL: In this state all the power regualtors are
 * turned on, reset line pulled high, IRQ line is enabled(polling is
 * active for polling use scenario) and device is turned on with
 * POWER_UP command. The device is ready to be used.
 * @SI476X_POWER_INCONSISTENT: This state indicates that previous
 * power down was inconsistent, meaning some of the regulators were
 * not turned down and thus use of the device, without power-cycling
 * is impossible.
 */
enum si476x_power_state {
	SI476X_POWER_DOWN		= 0,
	SI476X_POWER_UP_FULL		= 1,
	SI476X_POWER_INCONSISTENT	= 2,
};

/**
 * struct si476x_core - internal data structure representing the
 * underlying "core" device which all the MFD cell-devices use.
 *
 * @client: Actual I2C client used to transfer commands to the chip.
 * @chip_id: Last digit of the chip model(E.g. "1" for SI4761)
 * @cells: MFD cell devices created by this driver.
 * @cmd_lock: Mutex used to serialize all the requests to the core
 * device. This filed should not be used directly. Instead
 * si476x_core_lock()/si476x_core_unlock() should be used to get
 * exclusive access to the "core" device.
 * @users: Active users counter(Used by the radio cell)
 * @rds_read_queue: Wait queue used to wait for RDS data.
 * @rds_fifo: FIFO in which all the RDS data received from the chip is
 * placed.
 * @rds_fifo_drainer: Worker that drains on-chip RDS FIFO.
 * @rds_drainer_is_working: Flag used for launching only one instance
 * of the @rds_fifo_drainer.
 * @rds_drainer_status_lock: Lock used to guard access to the
 * @rds_drainer_is_working variable.
 * @command: Wait queue for wainting on the command comapletion.
 * @cts: Clear To Send flag set upon receiving first status with CTS
 * set.
 * @tuning: Wait queue used for wainting for tune/seek comand
 * completion.
 * @stc: Similar to @cts, but for the STC bit of the status value.
 * @power_up_parameters: Parameters used as argument for POWER_UP
 * command when the device is started.
 * @state: Current power state of the device.
 * @supplues: Structure containing handles to all power supplies used
 * by the device (NULL ones are ignored).
 * @gpio_reset: GPIO pin connectet to the RSTB pin of the chip.
 * @pinmux: Chip's configurable pins configuration.
 * @diversity_mode: Chips role when functioning in diversity mode.
 * @status_monitor: Polling worker used in polling use case scenarion
 * (when IRQ is not avalible).
 * @revision: Chip's running firmware revision number(Used for correct
 * command set support).
 */

struct si476x_core {
	struct i2c_client *client;
	struct regmap *regmap;
	int chip_id;
	struct mfd_cell cells[SI476X_MFD_CELLS];

	struct mutex cmd_lock; /* for serializing fm radio operations */
	atomic_t users;

	wait_queue_head_t  rds_read_queue;
	struct kfifo       rds_fifo;
	struct work_struct rds_fifo_drainer;
	bool               rds_drainer_is_working;
	struct mutex       rds_drainer_status_lock;

	wait_queue_head_t command;
	atomic_t          cts;

	wait_queue_head_t tuning;
	atomic_t          stc;

	struct si476x_power_up_args power_up_parameters;

	enum si476x_power_state power_state;

	struct regulator_bulk_data supplies[4];

	int gpio_reset;

	struct si476x_pinmux pinmux;
	enum si476x_phase_diversity_mode diversity_mode;

	atomic_t is_alive;

	struct delayed_work status_monitor;
#define SI476X_WORK_TO_CORE(w) container_of(to_delayed_work(w),	\
					    struct si476x_core,	\
					    status_monitor)

	int revision;

	int rds_fifo_depth;
};

static inline struct si476x_core *i2c_mfd_cell_to_core(struct device *dev)
{
	struct i2c_client *client = to_i2c_client(dev->parent);
	return i2c_get_clientdata(client);
}


/**
 * si476x_core_lock() - lock the core device to get an exclusive access
 * to it.
 */
static inline void si476x_core_lock(struct si476x_core *core)
{
	mutex_lock(&core->cmd_lock);
}

/**
 * si476x_core_unlock() - unlock the core device to relinquish an
 * exclusive access to it.
 */
static inline void si476x_core_unlock(struct si476x_core *core)
{
	mutex_unlock(&core->cmd_lock);
}

/* *_TUNE_FREQ family of commands accept frequency in multiples of
    10kHz */
static inline u16 hz_to_si476x(struct si476x_core *core, int freq)
{
	u16 result;

	switch (core->power_up_parameters.func) {
	default:
	case SI476X_FUNC_FM_RECEIVER:
		result = freq / 10000;
		break;
	case SI476X_FUNC_AM_RECEIVER:
		result = freq / 1000;
		break;
	}

	return result;
}

static inline int si476x_to_hz(struct si476x_core *core, u16 freq)
{
	int result;

	switch (core->power_up_parameters.func) {
	default:
	case SI476X_FUNC_FM_RECEIVER:
		result = freq * 10000;
		break;
	case SI476X_FUNC_AM_RECEIVER:
		result = freq * 1000;
		break;
	}

	return result;
}

/* Since the V4L2_TUNER_CAP_LOW flag is supplied, V4L2 subsystem
 * mesures frequency in 62.5 Hz units */

static inline int hz_to_v4l2(int freq)
{
	return (freq * 10) / 625;
}

static inline int v4l2_to_hz(int freq)
{
	return (freq * 625) / 10;
}

static inline u16 v4l2_to_si476x(struct si476x_core *core, int freq)
{
	return hz_to_si476x(core, v4l2_to_hz(freq));
}

static inline int si476x_to_v4l2(struct si476x_core *core, u16 freq)
{
	return hz_to_v4l2(si476x_to_hz(core, freq));
}



/**
 * struct si476x_func_info - structure containing result of the
 * FUNC_INFO command.
 *
 * @firmware.major: Firmware major number.
 * @firmware.minor[...]: Firmware minor numbers.
 * @patch_id:
 * @func: Mode tuner is working in.
 */
struct si476x_func_info {
	struct {
		u8 major, minor[2];
	} firmware;
	u16 patch_id;
	enum si476x_func func;
};

/**
 * struct si476x_power_down_args - structure used to pass parameters
 * to POWER_DOWN command
 *
 * @xosc: true - Power down, but leav oscillator running.
 *        false - Full power down.
 */
struct si476x_power_down_args {
	bool xosc;
};

/**
 * enum si476x_tunemode - enum representing possible tune modes for
 * the chip.
 * @SI476X_TM_VALIDATED_NORMAL_TUNE: Unconditionally stay on the new
 * channel after tune, tune status is valid.
 * @SI476X_TM_INVALIDATED_FAST_TUNE: Unconditionally stay in the new
 * channel after tune, tune status invalid.
 * @SI476X_TM_VALIDATED_AF_TUNE: Jump back to previous channel if
 * metric thresholds are not met.
 * @SI476X_TM_VALIDATED_AF_CHECK: Unconditionally jump back to the
 * previous channel.
 */
enum si476x_tunemode {
	SI476X_TM_VALIDATED_NORMAL_TUNE = 0,
	SI476X_TM_INVALIDATED_FAST_TUNE = 1,
	SI476X_TM_VALIDATED_AF_TUNE     = 2,
	SI476X_TM_VALIDATED_AF_CHECK    = 3,
};

/**
 * enum si476x_smoothmetrics - enum containing the possible setting fo
 * audio transitioning of the chip
 * @SI476X_SM_INITIALIZE_AUDIO: Initialize audio state to match this
 * new channel
 * @SI476X_SM_TRANSITION_AUDIO: Transition audio state from previous
 * channel values to the new values
 */
enum si476x_smoothmetrics {
	SI476X_SM_INITIALIZE_AUDIO = 0,
	SI476X_SM_TRANSITION_AUDIO = 1,
};

/**
 * struct si476x_rds_status_report - the structure representing the
 * response to 'FM_RD_STATUS' command
 * @rdstpptyint: Traffic program flag(TP) and/or program type(PTY)
 * code has changed.
 * @rdspiint: Program identification(PI) code has changed.
 * @rdssyncint: RDS synchronization has changed.
 * @rdsfifoint: RDS was received and the RDS FIFO has at least
 * 'FM_RDS_INTERRUPT_FIFO_COUNT' elements in it.
 * @tpptyvalid: TP flag and PTY code are valid falg.
 * @pivalid: PI code is valid flag.
 * @rdssync: RDS is currently synchronized.
 * @rdsfifolost: On or more RDS groups have been lost/discarded flag.
 * @tp: Current channel's TP flag.
 * @pty: Current channel's PTY code.
 * @pi: Current channel's PI code.
 * @rdsfifoused: Number of blocks remaining in the RDS FIFO (0 if
 * empty).
 */
struct si476x_rds_status_report {
	bool rdstpptyint, rdspiint, rdssyncint, rdsfifoint;
	bool tpptyvalid, pivalid, rdssync, rdsfifolost;
	bool tp;

	u8 pty;
	u16 pi;

	u8 rdsfifoused;
	u8 ble[4];

	struct v4l2_rds_data rds[4];
};

struct si476x_rsq_status_args {
	bool primary;
	bool rsqack;
	bool attune;
	bool cancel;
	bool stcack;
};

enum si476x_injside {
	SI476X_INJSIDE_AUTO	= 0,
	SI476X_INJSIDE_LOW	= 1,
	SI476X_INJSIDE_HIGH	= 2,
};

struct si476x_tune_freq_args {
	bool zifsr;
	bool hd;
	enum si476x_injside injside;
	int freq;
	enum si476x_tunemode tunemode;
	enum si476x_smoothmetrics smoothmetrics;
	int antcap;
};

int  si476x_core_stop(struct si476x_core *, bool);
int  si476x_core_start(struct si476x_core *, bool);
int  si476x_core_set_power_state(struct si476x_core *, enum si476x_power_state);
bool si476x_core_has_am(struct si476x_core *);
bool si476x_core_has_diversity(struct si476x_core *);
bool si476x_core_is_a_secondary_tuner(struct si476x_core *);
bool si476x_core_is_a_primary_tuner(struct si476x_core *);
bool si476x_core_is_in_am_receiver_mode(struct si476x_core *core);
bool si476x_core_is_powered_up(struct si476x_core *core);

enum si476x_i2c_type {
	SI476X_I2C_SEND,
	SI476X_I2C_RECV
};

int si476x_core_i2c_xfer(struct si476x_core *,
			 enum si476x_i2c_type,
			 char *, int);


/* -------------------- si476x-cmd.c ----------------------- */

int si476x_core_cmd_func_info(struct si476x_core *, struct si476x_func_info *);
int si476x_core_cmd_set_property(struct si476x_core *, u16, u16);
int si476x_core_cmd_get_property(struct si476x_core *, u16);
int si476x_core_cmd_dig_audio_pin_cfg(struct si476x_core *,
				      enum si476x_dclk_config,
				      enum si476x_dfs_config,
				      enum si476x_dout_config,
				      enum si476x_xout_config);
int si476x_core_cmd_zif_pin_cfg(struct si476x_core *,
				enum si476x_iqclk_config,
				enum si476x_iqfs_config,
				enum si476x_iout_config,
				enum si476x_qout_config);
int si476x_core_cmd_ic_link_gpo_ctl_pin_cfg(struct si476x_core *,
					    enum si476x_icin_config,
					    enum si476x_icip_config,
					    enum si476x_icon_config,
					    enum si476x_icop_config);
int si476x_core_cmd_ana_audio_pin_cfg(struct si476x_core *,
				      enum si476x_lrout_config);
int si476x_core_cmd_intb_pin_cfg(struct si476x_core *, enum si476x_intb_config,
				 enum si476x_a1_config);
int si476x_core_cmd_fm_seek_start(struct si476x_core *, bool, bool);
int si476x_core_cmd_am_seek_start(struct si476x_core *, bool, bool);
int si476x_core_cmd_fm_rds_status(struct si476x_core *, bool, bool, bool,
				  struct si476x_rds_status_report *);
int si476x_core_cmd_fm_rds_blockcount(struct si476x_core *, bool,
				      struct si476x_rds_blockcount_report *);
int si476x_core_cmd_fm_tune_freq(struct si476x_core *,
				 struct si476x_tune_freq_args *);
int si476x_core_cmd_am_tune_freq(struct si476x_core *,
				 struct si476x_tune_freq_args *);
int si476x_core_cmd_am_rsq_status(struct si476x_core *,
				  struct si476x_rsq_status_args *,
				  struct si476x_rsq_status_report *);
int si476x_core_cmd_fm_rsq_status(struct si476x_core *,
				  struct si476x_rsq_status_args *,
				  struct si476x_rsq_status_report *);
int si476x_core_cmd_power_up(struct si476x_core *,
			     struct si476x_power_up_args *);
int si476x_core_cmd_power_down(struct si476x_core *,
			       struct si476x_power_down_args *);
int si476x_core_cmd_fm_phase_div_status(struct si476x_core *);
int si476x_core_cmd_fm_phase_diversity(struct si476x_core *,
				       enum si476x_phase_diversity_mode);

int si476x_core_cmd_fm_acf_status(struct si476x_core *,
				  struct si476x_acf_status_report *);
int si476x_core_cmd_am_acf_status(struct si476x_core *,
				  struct si476x_acf_status_report *);
int si476x_core_cmd_agc_status(struct si476x_core *,
			       struct si476x_agc_status_report *);

enum si476x_power_grid_type {
	SI476X_POWER_GRID_50HZ = 0,
	SI476X_POWER_GRID_60HZ,
};

/* Properties  */

enum si476x_interrupt_flags {
	SI476X_STCIEN = (1 << 0),
	SI476X_ACFIEN = (1 << 1),
	SI476X_RDSIEN = (1 << 2),
	SI476X_RSQIEN = (1 << 3),

	SI476X_ERRIEN = (1 << 6),
	SI476X_CTSIEN = (1 << 7),

	SI476X_STCREP = (1 << 8),
	SI476X_ACFREP = (1 << 9),
	SI476X_RDSREP = (1 << 10),
	SI476X_RSQREP = (1 << 11),
};

enum si476x_rdsint_sources {
	SI476X_RDSTPPTY = (1 << 4),
	SI476X_RDSPI    = (1 << 3),
	SI476X_RDSSYNC	= (1 << 1),
	SI476X_RDSRECV	= (1 << 0),
};

enum si476x_status_response_bits {
	SI476X_CTS	  = (1 << 7),
	SI476X_ERR	  = (1 << 6),
	/* Status response for WB receiver */
	SI476X_WB_ASQ_INT = (1 << 4),
	SI476X_RSQ_INT    = (1 << 3),
	/* Status response for FM receiver */
	SI476X_FM_RDS_INT = (1 << 2),
	SI476X_ACF_INT    = (1 << 1),
	SI476X_STC_INT    = (1 << 0),
};

/* -------------------- si476x-prop.c ----------------------- */

enum si476x_common_receiver_properties {
	SI476X_PROP_INT_CTL_ENABLE			= 0x0000,
	SI476X_PROP_DIGITAL_IO_INPUT_SAMPLE_RATE	= 0x0200,
	SI476X_PROP_DIGITAL_IO_INPUT_FORMAT		= 0x0201,
	SI476X_PROP_DIGITAL_IO_OUTPUT_SAMPLE_RATE	= 0x0202,
	SI476X_PROP_DIGITAL_IO_OUTPUT_FORMAT		= 0x0203,

	SI476X_PROP_SEEK_BAND_BOTTOM			= 0x1100,
	SI476X_PROP_SEEK_BAND_TOP			= 0x1101,
	SI476X_PROP_SEEK_FREQUENCY_SPACING		= 0x1102,

	SI476X_PROP_VALID_MAX_TUNE_ERROR		= 0x2000,
	SI476X_PROP_VALID_SNR_THRESHOLD			= 0x2003,
	SI476X_PROP_VALID_RSSI_THRESHOLD		= 0x2004,
};

enum si476x_am_receiver_properties {
	SI476X_PROP_AUDIO_PWR_LINE_FILTER		= 0x0303,
};

enum si476x_fm_receiver_properties {
	SI476X_PROP_AUDIO_DEEMPHASIS			= 0x0302,

	SI476X_PROP_FM_RDS_INTERRUPT_SOURCE		= 0x4000,
	SI476X_PROP_FM_RDS_INTERRUPT_FIFO_COUNT		= 0x4001,
	SI476X_PROP_FM_RDS_CONFIG			= 0x4002,
};

enum si476x_prop_audio_pwr_line_filter_bits {
	SI476X_PROP_PWR_HARMONICS_MASK	= 0x001f,
	SI476X_PROP_PWR_GRID_MASK	= 0x0100,
	SI476X_PROP_PWR_ENABLE_MASK	= 0x0200,
	SI476X_PROP_PWR_GRID_50HZ	= 0x0000,
	SI476X_PROP_PWR_GRID_60HZ	= 0x0100,
};

enum si476x_prop_fm_rds_config_bits {
	SI476X_PROP_RDSEN_MASK	= 0x1,
	SI476X_PROP_RDSEN	= 0x1,
};


struct regmap *devm_regmap_init_si476x(struct si476x_core *);

#endif	/* SI476X_CORE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * MFD core driver for Ricoh RN5T618 PMIC
 *
 * Copyright (C) 2014 Beniamino Galvani <b.galvani@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __LINUX_MFD_RN5T618_H
#define __LINUX_MFD_RN5T618_H

#include <linux/regmap.h>

#define RN5T618_LSIVER			0x00
#define RN5T618_OTPVER			0x01
#define RN5T618_IODAC			0x02
#define RN5T618_VINDAC			0x03
#define RN5T618_CPUCNT			0x06
#define RN5T618_PSWR			0x07
#define RN5T618_PONHIS			0x09
#define RN5T618_POFFHIS			0x0a
#define RN5T618_WATCHDOG		0x0b
#define RN5T618_WATCHDOGCNT		0x0c
#define RN5T618_PWRFUNC			0x0d
#define RN5T618_SLPCNT			0x0e
#define RN5T618_REPCNT			0x0f
#define RN5T618_PWRONTIMSET		0x10
#define RN5T618_NOETIMSETCNT		0x11
#define RN5T618_PWRIREN			0x12
#define RN5T618_PWRIRQ			0x13
#define RN5T618_PWRMON			0x14
#define RN5T618_PWRIRSEL		0x15
#define RN5T618_DC1_SLOT		0x16
#define RN5T618_DC2_SLOT		0x17
#define RN5T618_DC3_SLOT		0x18
#define RN5T618_LDO1_SLOT		0x1b
#define RN5T618_LDO2_SLOT		0x1c
#define RN5T618_LDO3_SLOT		0x1d
#define RN5T618_LDO4_SLOT		0x1e
#define RN5T618_LDO5_SLOT		0x1f
#define RN5T618_PSO0_SLOT		0x25
#define RN5T618_PSO1_SLOT		0x26
#define RN5T618_PSO2_SLOT		0x27
#define RN5T618_PSO3_SLOT		0x28
#define RN5T618_LDORTC1_SLOT		0x2a
#define RN5T618_DC1CTL			0x2c
#define RN5T618_DC1CTL2			0x2d
#define RN5T618_DC2CTL			0x2e
#define RN5T618_DC2CTL2			0x2f
#define RN5T618_DC3CTL			0x30
#define RN5T618_DC3CTL2			0x31
#define RN5T618_DC1DAC			0x36
#define RN5T618_DC2DAC			0x37
#define RN5T618_DC3DAC			0x38
#define RN5T618_DC1DAC_SLP		0x3b
#define RN5T618_DC2DAC_SLP		0x3c
#define RN5T618_DC3DAC_SLP		0x3d
#define RN5T618_DCIREN			0x40
#define RN5T618_DCIRQ			0x41
#define RN5T618_DCIRMON			0x42
#define RN5T618_LDOEN1			0x44
#define RN5T618_LDOEN2			0x45
#define RN5T618_LDODIS			0x46
#define RN5T618_LDO1DAC			0x4c
#define RN5T618_LDO2DAC			0x4d
#define RN5T618_LDO3DAC			0x4e
#define RN5T618_LDO4DAC			0x4f
#define RN5T618_LDO5DAC			0x50
#define RN5T618_LDORTCDAC		0x56
#define RN5T618_LDORTC2DAC		0x57
#define RN5T618_LDO1DAC_SLP		0x58
#define RN5T618_LDO2DAC_SLP		0x59
#define RN5T618_LDO3DAC_SLP		0x5a
#define RN5T618_LDO4DAC_SLP		0x5b
#define RN5T618_LDO5DAC_SLP		0x5c
#define RN5T618_ADCCNT1			0x64
#define RN5T618_ADCCNT2			0x65
#define RN5T618_ADCCNT3			0x66
#define RN5T618_ILIMDATAH		0x68
#define RN5T618_ILIMDATAL		0x69
#define RN5T618_VBATDATAH		0x6a
#define RN5T618_VBATDATAL		0x6b
#define RN5T618_VADPDATAH		0x6c
#define RN5T618_VADPDATAL		0x6d
#define RN5T618_VUSBDATAH		0x6e
#define RN5T618_VUSBDATAL		0x6f
#define RN5T618_VSYSDATAH		0x70
#define RN5T618_VSYSDATAL		0x71
#define RN5T618_VTHMDATAH		0x72
#define RN5T618_VTHMDATAL		0x73
#define RN5T618_AIN1DATAH		0x74
#define RN5T618_AIN1DATAL		0x75
#define RN5T618_AIN0DATAH		0x76
#define RN5T618_AIN0DATAL		0x77
#define RN5T618_ILIMTHL			0x78
#define RN5T618_ILIMTHH			0x79
#define RN5T618_VBATTHL			0x7a
#define RN5T618_VBATTHH			0x7b
#define RN5T618_VADPTHL			0x7c
#define RN5T618_VADPTHH			0x7d
#define RN5T618_VUSBTHL			0x7e
#define RN5T618_VUSBTHH			0x7f
#define RN5T618_VSYSTHL			0x80
#define RN5T618_VSYSTHH			0x81
#define RN5T618_VTHMTHL			0x82
#define RN5T618_VTHMTHH			0x83
#define RN5T618_AIN1THL			0x84
#define RN5T618_AIN1THH			0x85
#define RN5T618_AIN0THL			0x86
#define RN5T618_AIN0THH			0x87
#define RN5T618_EN_ADCIR1		0x88
#define RN5T618_EN_ADCIR2		0x89
#define RN5T618_EN_ADCIR3		0x8a
#define RN5T618_IR_ADC1			0x8c
#define RN5T618_IR_ADC2			0x8d
#define RN5T618_IR_ADC3			0x8e
#define RN5T618_IOSEL			0x90
#define RN5T618_IOOUT			0x91
#define RN5T618_GPEDGE1			0x92
#define RN5T618_GPEDGE2			0x93
#define RN5T618_EN_GPIR			0x94
#define RN5T618_IR_GPR			0x95
#define RN5T618_IR_GPF			0x96
#define RN5T618_MON_IOIN		0x97
#define RN5T618_GPLED_FUNC		0x98
#define RN5T618_INTPOL			0x9c
#define RN5T618_INTEN			0x9d
#define RN5T618_INTMON			0x9e
#define RN5T618_PREVINDAC		0xb0
#define RN5T618_BATDAC			0xb1
#define RN5T618_CHGCTL1			0xb3
#define RN5T618_CHGCTL2			0xb4
#define RN5T618_VSYSSET			0xb5
#define RN5T618_REGISET1		0xb6
#define RN5T618_REGISET2		0xb7
#define RN5T618_CHGISET			0xb8
#define RN5T618_TIMSET			0xb9
#define RN5T618_BATSET1			0xba
#define RN5T618_BATSET2			0xbb
#define RN5T618_DIESET			0xbc
#define RN5T618_CHGSTATE		0xbd
#define RN5T618_CHGCTRL_IRFMASK		0xbe
#define RN5T618_CHGSTAT_IRFMASK1	0xbf
#define RN5T618_CHGSTAT_IRFMASK2	0xc0
#define RN5T618_CHGERR_IRFMASK		0xc1
#define RN5T618_CHGCTRL_IRR		0xc2
#define RN5T618_CHGSTAT_IRR1		0xc3
#define RN5T618_CHGSTAT_IRR2		0xc4
#define RN5T618_CHGERR_IRR		0xc5
#define RN5T618_CHGCTRL_MONI		0xc6
#define RN5T618_CHGSTAT_MONI1		0xc7
#define RN5T618_CHGSTAT_MONI2		0xc8
#define RN5T618_CHGERR_MONI		0xc9
#define RN5T618_CHGCTRL_DETMOD1		0xca
#define RN5T618_CHGCTRL_DETMOD2		0xcb
#define RN5T618_CHGSTAT_DETMOD1		0xcc
#define RN5T618_CHGSTAT_DETMOD2		0xcd
#define RN5T618_CHGSTAT_DETMOD3		0xce
#define RN5T618_CHGERR_DETMOD1		0xcf
#define RN5T618_CHGERR_DETMOD2		0xd0
#define RN5T618_CHGOSCCTL		0xd4
#define RN5T618_CHGOSCSCORESET1		0xd5
#define RN5T618_CHGOSCSCORESET2		0xd6
#define RN5T618_CHGOSCSCORESET3		0xd7
#define RN5T618_CHGOSCFREQSET1		0xd8
#define RN5T618_CHGOSCFREQSET2		0xd9
#define RN5T618_CONTROL			0xe0
#define RN5T618_SOC			0xe1
#define RN5T618_RE_CAP_H		0xe2
#define RN5T618_RE_CAP_L		0xe3
#define RN5T618_FA_CAP_H		0xe4
#define RN5T618_FA_CAP_L		0xe5
#define RN5T618_AGE			0xe6
#define RN5T618_TT_EMPTY_H		0xe7
#define RN5T618_TT_EMPTY_L		0xe8
#define RN5T618_TT_FULL_H		0xe9
#define RN5T618_TT_FULL_L		0xea
#define RN5T618_VOLTAGE_1		0xeb
#define RN5T618_VOLTAGE_0		0xec
#define RN5T618_TEMP_1			0xed
#define RN5T618_TEMP_0			0xee
#define RN5T618_CC_CTRL			0xef
#define RN5T618_CC_COUNT2		0xf0
#define RN5T618_CC_COUNT1		0xf1
#define RN5T618_CC_COUNT0		0xf2
#define RN5T618_CC_SUMREG3		0xf3
#define RN5T618_CC_SUMREG2		0xf4
#define RN5T618_CC_SUMREG1		0xf5
#define RN5T618_CC_SUMREG0		0xf6
#define RN5T618_CC_OFFREG1		0xf7
#define RN5T618_CC_OFFREG0		0xf8
#define RN5T618_CC_GAINREG1		0xf9
#define RN5T618_CC_GAINREG0		0xfa
#define RN5T618_CC_AVEREG1		0xfb
#define RN5T618_CC_AVEREG0		0xfc
#define RN5T618_MAX_REG			0xfc

#define RN5T618_REPCNT_REPWRON		BIT(0)
#define RN5T618_SLPCNT_SWPWROFF		BIT(0)
#define RN5T618_WATCHDOG_WDOGEN		BIT(2)
#define RN5T618_WATCHDOG_WDOGTIM_M	(BIT(0) | BIT(1))
#define RN5T618_WATCHDOG_WDOGTIM_S	0
#define RN5T618_PWRIRQ_IR_WDOG		BIT(6)

enum {
	RN5T618_DCDC1,
	RN5T618_DCDC2,
	RN5T618_DCDC3,
	RN5T618_LDO1,
	RN5T618_LDO2,
	RN5T618_LDO3,
	RN5T618_LDO4,
	RN5T618_LDO5,
	RN5T618_LDORTC1,
	RN5T618_LDORTC2,
	RN5T618_REG_NUM,
};

struct rn5t618 {
	struct regmap *regmap;
};

#endif /* __LINUX_MFD_RN5T618_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * max8998-private.h - Voltage regulator driver for the Maxim 8998
 *
 *  Copyright (C) 2009-2010 Samsung Electrnoics
 *  Kyungmin Park <kyungmin.park@samsung.com>
 *  Marek Szyprowski <m.szyprowski@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef __LINUX_MFD_MAX8998_PRIV_H
#define __LINUX_MFD_MAX8998_PRIV_H

#define MAX8998_NUM_IRQ_REGS	4

/* MAX 8998 registers */
enum {
	MAX8998_REG_IRQ1,
	MAX8998_REG_IRQ2,
	MAX8998_REG_IRQ3,
	MAX8998_REG_IRQ4,
	MAX8998_REG_IRQM1,
	MAX8998_REG_IRQM2,
	MAX8998_REG_IRQM3,
	MAX8998_REG_IRQM4,
	MAX8998_REG_STATUS1,
	MAX8998_REG_STATUS2,
	MAX8998_REG_STATUSM1,
	MAX8998_REG_STATUSM2,
	MAX8998_REG_CHGR1,
	MAX8998_REG_CHGR2,
	MAX8998_REG_LDO_ACTIVE_DISCHARGE1,
	MAX8998_REG_LDO_ACTIVE_DISCHARGE2,
	MAX8998_REG_BUCK_ACTIVE_DISCHARGE3,
	MAX8998_REG_ONOFF1,
	MAX8998_REG_ONOFF2,
	MAX8998_REG_ONOFF3,
	MAX8998_REG_ONOFF4,
	MAX8998_REG_BUCK1_VOLTAGE1,
	MAX8998_REG_BUCK1_VOLTAGE2,
	MAX8998_REG_BUCK1_VOLTAGE3,
	MAX8998_REG_BUCK1_VOLTAGE4,
	MAX8998_REG_BUCK2_VOLTAGE1,
	MAX8998_REG_BUCK2_VOLTAGE2,
	MAX8998_REG_BUCK3,
	MAX8998_REG_BUCK4,
	MAX8998_REG_LDO2_LDO3,
	MAX8998_REG_LDO4,
	MAX8998_REG_LDO5,
	MAX8998_REG_LDO6,
	MAX8998_REG_LDO7,
	MAX8998_REG_LDO8_LDO9,
	MAX8998_REG_LDO10_LDO11,
	MAX8998_REG_LDO12,
	MAX8998_REG_LDO13,
	MAX8998_REG_LDO14,
	MAX8998_REG_LDO15,
	MAX8998_REG_LDO16,
	MAX8998_REG_LDO17,
	MAX8998_REG_BKCHR,
	MAX8998_REG_LBCNFG1,
	MAX8998_REG_LBCNFG2,
};

/* IRQ definitions */
enum {
	MAX8998_IRQ_DCINF,
	MAX8998_IRQ_DCINR,
	MAX8998_IRQ_JIGF,
	MAX8998_IRQ_JIGR,
	MAX8998_IRQ_PWRONF,
	MAX8998_IRQ_PWRONR,

	MAX8998_IRQ_WTSREVNT,
	MAX8998_IRQ_SMPLEVNT,
	MAX8998_IRQ_ALARM1,
	MAX8998_IRQ_ALARM0,

	MAX8998_IRQ_ONKEY1S,
	MAX8998_IRQ_TOPOFFR,
	MAX8998_IRQ_DCINOVPR,
	MAX8998_IRQ_CHGRSTF,
	MAX8998_IRQ_DONER,
	MAX8998_IRQ_CHGFAULT,

	MAX8998_IRQ_LOBAT1,
	MAX8998_IRQ_LOBAT2,

	MAX8998_IRQ_NR,
};

/* MAX8998 various variants */
enum {
	TYPE_MAX8998 = 0, /* Default */
	TYPE_LP3974,	/* National version of MAX8998 */
	TYPE_LP3979,	/* Added AVS */
};

#define MAX8998_IRQ_DCINF_MASK		(1 << 2)
#define MAX8998_IRQ_DCINR_MASK		(1 << 3)
#define MAX8998_IRQ_JIGF_MASK		(1 << 4)
#define MAX8998_IRQ_JIGR_MASK		(1 << 5)
#define MAX8998_IRQ_PWRONF_MASK		(1 << 6)
#define MAX8998_IRQ_PWRONR_MASK		(1 << 7)

#define MAX8998_IRQ_WTSREVNT_MASK	(1 << 0)
#define MAX8998_IRQ_SMPLEVNT_MASK	(1 << 1)
#define MAX8998_IRQ_ALARM1_MASK		(1 << 2)
#define MAX8998_IRQ_ALARM0_MASK		(1 << 3)

#define MAX8998_IRQ_ONKEY1S_MASK	(1 << 0)
#define MAX8998_IRQ_TOPOFFR_MASK	(1 << 2)
#define MAX8998_IRQ_DCINOVPR_MASK	(1 << 3)
#define MAX8998_IRQ_CHGRSTF_MASK	(1 << 4)
#define MAX8998_IRQ_DONER_MASK		(1 << 5)
#define MAX8998_IRQ_CHGFAULT_MASK	(1 << 7)

#define MAX8998_IRQ_LOBAT1_MASK		(1 << 0)
#define MAX8998_IRQ_LOBAT2_MASK		(1 << 1)

#define MAX8998_ENRAMP                  (1 << 4)

struct irq_domain;

/**
 * struct max8998_dev - max8998 master device for sub-drivers
 * @dev: master device of the chip (can be used to access platform data)
 * @pdata: platform data for the driver and subdrivers
 * @i2c: i2c client private data for regulator
 * @rtc: i2c client private data for rtc
 * @iolock: mutex for serializing io access
 * @irqlock: mutex for buslock
 * @irq_base: base IRQ number for max8998, required for IRQs
 * @irq: generic IRQ number for max8998
 * @ono: power onoff IRQ number for max8998
 * @irq_masks_cur: currently active value
 * @irq_masks_cache: cached hardware value
 * @type: indicate which max8998 "variant" is used
 */
struct max8998_dev {
	struct device *dev;
	struct max8998_platform_data *pdata;
	struct i2c_client *i2c;
	struct i2c_client *rtc;
	struct mutex iolock;
	struct mutex irqlock;

	unsigned int irq_base;
	struct irq_domain *irq_domain;
	int irq;
	int ono;
	u8 irq_masks_cur[MAX8998_NUM_IRQ_REGS];
	u8 irq_masks_cache[MAX8998_NUM_IRQ_REGS];
	unsigned long type;
	bool wakeup;
};

int max8998_irq_init(struct max8998_dev *max8998);
void max8998_irq_exit(struct max8998_dev *max8998);
int max8998_irq_resume(struct max8998_dev *max8998);

extern int max8998_read_reg(struct i2c_client *i2c, u8 reg, u8 *dest);
extern int max8998_bulk_read(struct i2c_client *i2c, u8 reg, int count,
		u8 *buf);
extern int max8998_write_reg(struct i2c_client *i2c, u8 reg, u8 value);
extern int max8998_bulk_write(struct i2c_client *i2c, u8 reg, int count,
		u8 *buf);
extern int max8998_update_reg(struct i2c_client *i2c, u8 reg, u8 val, u8 mask);

#endif /*  __LINUX_MFD_MAX8998_PRIV_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Common variables for the Maxim MAX77843 driver
 *
 * Copyright (C) 2015 Samsung Electronics
 * Author: Jaewon Kim <jaewon02.kim@samsung.com>
 * Author: Beomho Seo <beomho.seo@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef __MAX77843_PRIVATE_H_
#define __MAX77843_PRIVATE_H_

#include <linux/i2c.h>
#include <linux/regmap.h>

#define I2C_ADDR_TOPSYS	(0xCC >> 1)
#define I2C_ADDR_CHG	(0xD2 >> 1)
#define I2C_ADDR_FG	(0x6C >> 1)
#define I2C_ADDR_MUIC	(0x4A >> 1)

/* Topsys, Haptic and LED registers */
enum max77843_sys_reg {
	MAX77843_SYS_REG_PMICID		= 0x00,
	MAX77843_SYS_REG_PMICREV	= 0x01,
	MAX77843_SYS_REG_MAINCTRL1	= 0x02,
	MAX77843_SYS_REG_INTSRC		= 0x22,
	MAX77843_SYS_REG_INTSRCMASK	= 0x23,
	MAX77843_SYS_REG_SYSINTSRC	= 0x24,
	MAX77843_SYS_REG_SYSINTMASK	= 0x26,
	MAX77843_SYS_REG_TOPSYS_STAT	= 0x28,
	MAX77843_SYS_REG_SAFEOUTCTRL	= 0xC6,

	MAX77843_SYS_REG_END,
};

enum max77843_haptic_reg {
	MAX77843_HAP_REG_MCONFIG	= 0x10,

	MAX77843_HAP_REG_END,
};

enum max77843_led_reg {
	MAX77843_LED_REG_LEDEN		= 0x30,
	MAX77843_LED_REG_LED0BRT	= 0x31,
	MAX77843_LED_REG_LED1BRT	= 0x32,
	MAX77843_LED_REG_LED2BRT	= 0x33,
	MAX77843_LED_REG_LED3BRT	= 0x34,
	MAX77843_LED_REG_LEDBLNK	= 0x38,
	MAX77843_LED_REG_LEDRAMP	= 0x36,

	MAX77843_LED_REG_END,
};

/* Charger registers */
enum max77843_charger_reg {
	MAX77843_CHG_REG_CHG_INT	= 0xB0,
	MAX77843_CHG_REG_CHG_INT_MASK	= 0xB1,
	MAX77843_CHG_REG_CHG_INT_OK	= 0xB2,
	MAX77843_CHG_REG_CHG_DTLS_00	= 0xB3,
	MAX77843_CHG_REG_CHG_DTLS_01	= 0xB4,
	MAX77843_CHG_REG_CHG_DTLS_02	= 0xB5,
	MAX77843_CHG_REG_CHG_CNFG_00	= 0xB7,
	MAX77843_CHG_REG_CHG_CNFG_01	= 0xB8,
	MAX77843_CHG_REG_CHG_CNFG_02	= 0xB9,
	MAX77843_CHG_REG_CHG_CNFG_03	= 0xBA,
	MAX77843_CHG_REG_CHG_CNFG_04	= 0xBB,
	MAX77843_CHG_REG_CHG_CNFG_06	= 0xBD,
	MAX77843_CHG_REG_CHG_CNFG_07	= 0xBE,
	MAX77843_CHG_REG_CHG_CNFG_09	= 0xC0,
	MAX77843_CHG_REG_CHG_CNFG_10	= 0xC1,
	MAX77843_CHG_REG_CHG_CNFG_11	= 0xC2,
	MAX77843_CHG_REG_CHG_CNFG_12	= 0xC3,

	MAX77843_CHG_REG_END,
};

/* Fuel gauge registers */
enum max77843_fuelgauge {
	MAX77843_FG_REG_STATUS		= 0x00,
	MAX77843_FG_REG_VALRT_TH	= 0x01,
	MAX77843_FG_REG_TALRT_TH	= 0x02,
	MAX77843_FG_REG_SALRT_TH	= 0x03,
	MAX77843_FG_RATE_AT_RATE	= 0x04,
	MAX77843_FG_REG_REMCAP_REP	= 0x05,
	MAX77843_FG_REG_SOCREP		= 0x06,
	MAX77843_FG_REG_AGE		= 0x07,
	MAX77843_FG_REG_TEMP		= 0x08,
	MAX77843_FG_REG_VCELL		= 0x09,
	MAX77843_FG_REG_CURRENT		= 0x0A,
	MAX77843_FG_REG_AVG_CURRENT	= 0x0B,
	MAX77843_FG_REG_SOCMIX		= 0x0D,
	MAX77843_FG_REG_SOCAV		= 0x0E,
	MAX77843_FG_REG_REMCAP_MIX	= 0x0F,
	MAX77843_FG_REG_FULLCAP		= 0x10,
	MAX77843_FG_REG_AVG_TEMP	= 0x16,
	MAX77843_FG_REG_CYCLES		= 0x17,
	MAX77843_FG_REG_AVG_VCELL	= 0x19,
	MAX77843_FG_REG_CONFIG		= 0x1D,
	MAX77843_FG_REG_REMCAP_AV	= 0x1F,
	MAX77843_FG_REG_FULLCAP_NOM	= 0x23,
	MAX77843_FG_REG_MISCCFG		= 0x2B,
	MAX77843_FG_REG_RCOMP		= 0x38,
	MAX77843_FG_REG_FSTAT		= 0x3D,
	MAX77843_FG_REG_DQACC		= 0x45,
	MAX77843_FG_REG_DPACC		= 0x46,
	MAX77843_FG_REG_OCV		= 0xEE,
	MAX77843_FG_REG_VFOCV		= 0xFB,
	MAX77843_FG_SOCVF		= 0xFF,

	MAX77843_FG_END,
};

/* MUIC registers */
enum max77843_muic_reg {
	MAX77843_MUIC_REG_ID		= 0x00,
	MAX77843_MUIC_REG_INT1		= 0x01,
	MAX77843_MUIC_REG_INT2		= 0x02,
	MAX77843_MUIC_REG_INT3		= 0x03,
	MAX77843_MUIC_REG_STATUS1	= 0x04,
	MAX77843_MUIC_REG_STATUS2	= 0x05,
	MAX77843_MUIC_REG_STATUS3	= 0x06,
	MAX77843_MUIC_REG_INTMASK1	= 0x07,
	MAX77843_MUIC_REG_INTMASK2	= 0x08,
	MAX77843_MUIC_REG_INTMASK3	= 0x09,
	MAX77843_MUIC_REG_CDETCTRL1	= 0x0A,
	MAX77843_MUIC_REG_CDETCTRL2	= 0x0B,
	MAX77843_MUIC_REG_CONTROL1	= 0x0C,
	MAX77843_MUIC_REG_CONTROL2	= 0x0D,
	MAX77843_MUIC_REG_CONTROL3	= 0x0E,
	MAX77843_MUIC_REG_CONTROL4	= 0x16,
	MAX77843_MUIC_REG_HVCONTROL1	= 0x17,
	MAX77843_MUIC_REG_HVCONTROL2	= 0x18,

	MAX77843_MUIC_REG_END,
};

enum max77843_irq {
	/* Topsys: SYSTEM */
	MAX77843_SYS_IRQ_SYSINTSRC_SYSUVLO_INT,
	MAX77843_SYS_IRQ_SYSINTSRC_SYSOVLO_INT,
	MAX77843_SYS_IRQ_SYSINTSRC_TSHDN_INT,
	MAX77843_SYS_IRQ_SYSINTSRC_TM_INT,

	/* Charger: CHG_INT */
	MAX77843_CHG_IRQ_CHG_INT_BYP_I,
	MAX77843_CHG_IRQ_CHG_INT_BATP_I,
	MAX77843_CHG_IRQ_CHG_INT_BAT_I,
	MAX77843_CHG_IRQ_CHG_INT_CHG_I,
	MAX77843_CHG_IRQ_CHG_INT_WCIN_I,
	MAX77843_CHG_IRQ_CHG_INT_CHGIN_I,
	MAX77843_CHG_IRQ_CHG_INT_AICL_I,

	MAX77843_IRQ_NUM,
};

enum max77843_irq_muic {
	/* MUIC: INT1 */
	MAX77843_MUIC_IRQ_INT1_ADC,
	MAX77843_MUIC_IRQ_INT1_ADCERROR,
	MAX77843_MUIC_IRQ_INT1_ADC1K,

	/* MUIC: INT2 */
	MAX77843_MUIC_IRQ_INT2_CHGTYP,
	MAX77843_MUIC_IRQ_INT2_CHGDETRUN,
	MAX77843_MUIC_IRQ_INT2_DCDTMR,
	MAX77843_MUIC_IRQ_INT2_DXOVP,
	MAX77843_MUIC_IRQ_INT2_VBVOLT,

	/* MUIC: INT3 */
	MAX77843_MUIC_IRQ_INT3_VBADC,
	MAX77843_MUIC_IRQ_INT3_VDNMON,
	MAX77843_MUIC_IRQ_INT3_DNRES,
	MAX77843_MUIC_IRQ_INT3_MPNACK,
	MAX77843_MUIC_IRQ_INT3_MRXBUFOW,
	MAX77843_MUIC_IRQ_INT3_MRXTRF,
	MAX77843_MUIC_IRQ_INT3_MRXPERR,
	MAX77843_MUIC_IRQ_INT3_MRXRDY,

	MAX77843_MUIC_IRQ_NUM,
};

/* MAX77843 interrupts */
#define MAX77843_SYS_IRQ_SYSUVLO_INT		BIT(0)
#define MAX77843_SYS_IRQ_SYSOVLO_INT		BIT(1)
#define MAX77843_SYS_IRQ_TSHDN_INT		BIT(2)
#define MAX77843_SYS_IRQ_TM_INT			BIT(3)

/* MAX77843 MAINCTRL1 register */
#define MAINCTRL1_BIASEN_SHIFT			7
#define MAX77843_MAINCTRL1_BIASEN_MASK		BIT(MAINCTRL1_BIASEN_SHIFT)

/* MAX77843 MCONFIG register */
#define MCONFIG_MODE_SHIFT			7
#define MCONFIG_MEN_SHIFT			6
#define MCONFIG_PDIV_SHIFT			0

#define MAX77843_MCONFIG_MODE_MASK		BIT(MCONFIG_MODE_SHIFT)
#define MAX77843_MCONFIG_MEN_MASK		BIT(MCONFIG_MEN_SHIFT)
#define MAX77843_MCONFIG_PDIV_MASK		(0x3 << MCONFIG_PDIV_SHIFT)

/* Max77843 charger insterrupts */
#define MAX77843_CHG_BYP_I			BIT(0)
#define MAX77843_CHG_BATP_I			BIT(2)
#define MAX77843_CHG_BAT_I			BIT(3)
#define MAX77843_CHG_CHG_I			BIT(4)
#define MAX77843_CHG_WCIN_I			BIT(5)
#define MAX77843_CHG_CHGIN_I			BIT(6)
#define MAX77843_CHG_AICL_I			BIT(7)

/* MAX77843 CHG_INT_OK register */
#define MAX77843_CHG_BYP_OK			BIT(0)
#define MAX77843_CHG_BATP_OK			BIT(2)
#define MAX77843_CHG_BAT_OK			BIT(3)
#define MAX77843_CHG_CHG_OK			BIT(4)
#define MAX77843_CHG_WCIN_OK			BIT(5)
#define MAX77843_CHG_CHGIN_OK			BIT(6)
#define MAX77843_CHG_AICL_OK			BIT(7)

/* MAX77843 CHG_DETAILS_00 register */
#define MAX77843_CHG_BAT_DTLS			BIT(0)

/* MAX77843 CHG_DETAILS_01 register */
#define MAX77843_CHG_DTLS_MASK			0x0f
#define MAX77843_CHG_PQ_MODE			0x00
#define MAX77843_CHG_CC_MODE			0x01
#define MAX77843_CHG_CV_MODE			0x02
#define MAX77843_CHG_TO_MODE			0x03
#define MAX77843_CHG_DO_MODE			0x04
#define MAX77843_CHG_HT_MODE			0x05
#define MAX77843_CHG_TF_MODE			0x06
#define MAX77843_CHG_TS_MODE			0x07
#define MAX77843_CHG_OFF_MODE			0x08

#define MAX77843_CHG_BAT_DTLS_MASK		0xf0
#define MAX77843_CHG_NO_BAT			(0x00 << 4)
#define MAX77843_CHG_LOW_VOLT_BAT		(0x01 << 4)
#define MAX77843_CHG_LONG_BAT_TIME		(0x02 << 4)
#define MAX77843_CHG_OK_BAT			(0x03 << 4)
#define MAX77843_CHG_OK_LOW_VOLT_BAT		(0x04 << 4)
#define MAX77843_CHG_OVER_VOLT_BAT		(0x05 << 4)
#define MAX77843_CHG_OVER_CURRENT_BAT		(0x06 << 4)

/* MAX77843 CHG_CNFG_00 register */
#define MAX77843_CHG_DISABLE			0x00
#define MAX77843_CHG_ENABLE			0x05
#define MAX77843_CHG_MASK			0x01
#define MAX77843_CHG_BUCK_MASK			0x04

/* MAX77843 CHG_CNFG_01 register */
#define MAX77843_CHG_RESTART_THRESHOLD_100	0x00
#define MAX77843_CHG_RESTART_THRESHOLD_150	0x10
#define MAX77843_CHG_RESTART_THRESHOLD_200	0x20
#define MAX77843_CHG_RESTART_THRESHOLD_DISABLE	0x30

/* MAX77843 CHG_CNFG_02 register */
#define MAX77843_CHG_FAST_CHG_CURRENT_MIN	100000
#define MAX77843_CHG_FAST_CHG_CURRENT_MAX	3150000
#define MAX77843_CHG_FAST_CHG_CURRENT_STEP	50000
#define MAX77843_CHG_FAST_CHG_CURRENT_MASK	0x3f
#define MAX77843_CHG_OTG_ILIMIT_500		(0x00 << 6)
#define MAX77843_CHG_OTG_ILIMIT_900		(0x01 << 6)
#define MAX77843_CHG_OTG_ILIMIT_1200		(0x02 << 6)
#define MAX77843_CHG_OTG_ILIMIT_1500		(0x03 << 6)
#define MAX77843_CHG_OTG_ILIMIT_MASK		0xc0

/* MAX77843 CHG_CNFG_03 register */
#define MAX77843_CHG_TOP_OFF_CURRENT_MIN	125000
#define MAX77843_CHG_TOP_OFF_CURRENT_MAX	650000
#define MAX77843_CHG_TOP_OFF_CURRENT_STEP	75000
#define MAX77843_CHG_TOP_OFF_CURRENT_MASK	0x07

/* MAX77843 CHG_CNFG_06 register */
#define MAX77843_CHG_WRITE_CAP_BLOCK		0x10
#define MAX77843_CHG_WRITE_CAP_UNBLOCK		0x0C

/* MAX77843_CHG_CNFG_09_register */
#define MAX77843_CHG_INPUT_CURRENT_LIMIT_MIN	100000
#define MAX77843_CHG_INPUT_CURRENT_LIMIT_MAX	4000000
#define MAX77843_CHG_INPUT_CURRENT_LIMIT_REF	3367000
#define MAX77843_CHG_INPUT_CURRENT_LIMIT_STEP	33000

#define MAX77843_MUIC_ADC			BIT(0)
#define MAX77843_MUIC_ADCERROR			BIT(2)
#define MAX77843_MUIC_ADC1K			BIT(3)

#define MAX77843_MUIC_CHGTYP			BIT(0)
#define MAX77843_MUIC_CHGDETRUN			BIT(1)
#define MAX77843_MUIC_DCDTMR			BIT(2)
#define MAX77843_MUIC_DXOVP			BIT(3)
#define MAX77843_MUIC_VBVOLT			BIT(4)

#define MAX77843_MUIC_VBADC			BIT(0)
#define MAX77843_MUIC_VDNMON			BIT(1)
#define MAX77843_MUIC_DNRES			BIT(2)
#define MAX77843_MUIC_MPNACK			BIT(3)
#define MAX77843_MUIC_MRXBUFOW			BIT(4)
#define MAX77843_MUIC_MRXTRF			BIT(5)
#define MAX77843_MUIC_MRXPERR			BIT(6)
#define MAX77843_MUIC_MRXRDY			BIT(7)

/* MAX77843 INTSRCMASK register */
#define MAX77843_INTSRCMASK_CHGR		0
#define MAX77843_INTSRCMASK_SYS			1
#define MAX77843_INTSRCMASK_FG			2
#define MAX77843_INTSRCMASK_MUIC		3

#define MAX77843_INTSRCMASK_CHGR_MASK          BIT(MAX77843_INTSRCMASK_CHGR)
#define MAX77843_INTSRCMASK_SYS_MASK           BIT(MAX77843_INTSRCMASK_SYS)
#define MAX77843_INTSRCMASK_FG_MASK            BIT(MAX77843_INTSRCMASK_FG)
#define MAX77843_INTSRCMASK_MUIC_MASK          BIT(MAX77843_INTSRCMASK_MUIC)

#define MAX77843_INTSRC_MASK_MASK \
	(MAX77843_INTSRCMASK_MUIC_MASK | MAX77843_INTSRCMASK_FG_MASK | \
	MAX77843_INTSRCMASK_SYS_MASK | MAX77843_INTSRCMASK_CHGR_MASK)

/* MAX77843 STATUS register*/
#define STATUS1_ADC_SHIFT			0
#define STATUS1_ADCERROR_SHIFT			6
#define STATUS1_ADC1K_SHIFT			7
#define STATUS2_CHGTYP_SHIFT			0
#define STATUS2_CHGDETRUN_SHIFT			3
#define STATUS2_DCDTMR_SHIFT			4
#define STATUS2_DXOVP_SHIFT			5
#define STATUS2_VBVOLT_SHIFT			6
#define STATUS3_VBADC_SHIFT			0
#define STATUS3_VDNMON_SHIFT			4
#define STATUS3_DNRES_SHIFT			5
#define STATUS3_MPNACK_SHIFT			6

#define MAX77843_MUIC_STATUS1_ADC_MASK		(0x1f << STATUS1_ADC_SHIFT)
#define MAX77843_MUIC_STATUS1_ADCERROR_MASK	BIT(STATUS1_ADCERROR_SHIFT)
#define MAX77843_MUIC_STATUS1_ADC1K_MASK	BIT(STATUS1_ADC1K_SHIFT)
#define MAX77843_MUIC_STATUS2_CHGTYP_MASK	(0x7 << STATUS2_CHGTYP_SHIFT)
#define MAX77843_MUIC_STATUS2_CHGDETRUN_MASK	BIT(STATUS2_CHGDETRUN_SHIFT)
#define MAX77843_MUIC_STATUS2_DCDTMR_MASK	BIT(STATUS2_DCDTMR_SHIFT)
#define MAX77843_MUIC_STATUS2_DXOVP_MASK	BIT(STATUS2_DXOVP_SHIFT)
#define MAX77843_MUIC_STATUS2_VBVOLT_MASK	BIT(STATUS2_VBVOLT_SHIFT)
#define MAX77843_MUIC_STATUS3_VBADC_MASK	(0xf << STATUS3_VBADC_SHIFT)
#define MAX77843_MUIC_STATUS3_VDNMON_MASK	BIT(STATUS3_VDNMON_SHIFT)
#define MAX77843_MUIC_STATUS3_DNRES_MASK	BIT(STATUS3_DNRES_SHIFT)
#define MAX77843_MUIC_STATUS3_MPNACK_MASK	BIT(STATUS3_MPNACK_SHIFT)

/* MAX77843 CONTROL register */
#define CONTROL1_COMP1SW_SHIFT			0
#define CONTROL1_COMP2SW_SHIFT			3
#define CONTROL1_IDBEN_SHIFT			7
#define CONTROL2_LOWPWR_SHIFT			0
#define CONTROL2_ADCEN_SHIFT			1
#define CONTROL2_CPEN_SHIFT			2
#define CONTROL2_ACC_DET_SHIFT			5
#define CONTROL2_USBCPINT_SHIFT			6
#define CONTROL2_RCPS_SHIFT			7
#define CONTROL3_JIGSET_SHIFT			0
#define CONTROL4_ADCDBSET_SHIFT			0
#define CONTROL4_USBAUTO_SHIFT			4
#define CONTROL4_FCTAUTO_SHIFT			5
#define CONTROL4_ADCMODE_SHIFT			6

#define MAX77843_MUIC_CONTROL1_COMP1SW_MASK	(0x7 << CONTROL1_COMP1SW_SHIFT)
#define MAX77843_MUIC_CONTROL1_COMP2SW_MASK	(0x7 << CONTROL1_COMP2SW_SHIFT)
#define MAX77843_MUIC_CONTROL1_IDBEN_MASK	BIT(CONTROL1_IDBEN_SHIFT)
#define MAX77843_MUIC_CONTROL2_LOWPWR_MASK	BIT(CONTROL2_LOWPWR_SHIFT)
#define MAX77843_MUIC_CONTROL2_ADCEN_MASK	BIT(CONTROL2_ADCEN_SHIFT)
#define MAX77843_MUIC_CONTROL2_CPEN_MASK	BIT(CONTROL2_CPEN_SHIFT)
#define MAX77843_MUIC_CONTROL2_ACC_DET_MASK	BIT(CONTROL2_ACC_DET_SHIFT)
#define MAX77843_MUIC_CONTROL2_USBCPINT_MASK	BIT(CONTROL2_USBCPINT_SHIFT)
#define MAX77843_MUIC_CONTROL2_RCPS_MASK	BIT(CONTROL2_RCPS_SHIFT)
#define MAX77843_MUIC_CONTROL3_JIGSET_MASK	(0x3 << CONTROL3_JIGSET_SHIFT)
#define MAX77843_MUIC_CONTROL4_ADCDBSET_MASK	(0x3 << CONTROL4_ADCDBSET_SHIFT)
#define MAX77843_MUIC_CONTROL4_USBAUTO_MASK	BIT(CONTROL4_USBAUTO_SHIFT)
#define MAX77843_MUIC_CONTROL4_FCTAUTO_MASK	BIT(CONTROL4_FCTAUTO_SHIFT)
#define MAX77843_MUIC_CONTROL4_ADCMODE_MASK	(0x3 << CONTROL4_ADCMODE_SHIFT)

/* MAX77843 switch port */
#define COM_OPEN				0
#define COM_USB					1
#define COM_AUDIO				2
#define COM_UART				3
#define COM_AUX_USB				4
#define COM_AUX_UART				5

#define CONTROL1_COM_SW \
	((MAX77843_MUIC_CONTROL1_COMP1SW_MASK | \
	 MAX77843_MUIC_CONTROL1_COMP2SW_MASK))

#define CONTROL1_SW_OPEN \
	((COM_OPEN << CONTROL1_COMP1SW_SHIFT | \
	 COM_OPEN << CONTROL1_COMP2SW_SHIFT))
#define CONTROL1_SW_USB \
	((COM_USB << CONTROL1_COMP1SW_SHIFT | \
	 COM_USB << CONTROL1_COMP2SW_SHIFT))
#define CONTROL1_SW_AUDIO \
	((COM_AUDIO << CONTROL1_COMP1SW_SHIFT | \
	 COM_AUDIO << CONTROL1_COMP2SW_SHIFT))
#define CONTROL1_SW_UART \
	((COM_UART << CONTROL1_COMP1SW_SHIFT | \
	 COM_UART << CONTROL1_COMP2SW_SHIFT))
#define CONTROL1_SW_AUX_USB \
	((COM_AUX_USB << CONTROL1_COMP1SW_SHIFT | \
	 COM_AUX_USB << CONTROL1_COMP2SW_SHIFT))
#define CONTROL1_SW_AUX_UART \
	((COM_AUX_UART << CONTROL1_COMP1SW_SHIFT | \
	 COM_AUX_UART << CONTROL1_COMP2SW_SHIFT))

#define MAX77843_DISABLE			0
#define MAX77843_ENABLE				1

#define CONTROL4_AUTO_DISABLE \
	((MAX77843_DISABLE << CONTROL4_USBAUTO_SHIFT) | \
	(MAX77843_DISABLE << CONTROL4_FCTAUTO_SHIFT))
#define CONTROL4_AUTO_ENABLE \
	((MAX77843_ENABLE << CONTROL4_USBAUTO_SHIFT) | \
	(MAX77843_ENABLE << CONTROL4_FCTAUTO_SHIFT))

/* MAX77843 SAFEOUT LDO Control register */
#define SAFEOUTCTRL_SAFEOUT1_SHIFT		0
#define SAFEOUTCTRL_SAFEOUT2_SHIFT		2
#define SAFEOUTCTRL_ENSAFEOUT1_SHIFT		6
#define SAFEOUTCTRL_ENSAFEOUT2_SHIFT		7

#define MAX77843_REG_SAFEOUTCTRL_ENSAFEOUT1 \
		BIT(SAFEOUTCTRL_ENSAFEOUT1_SHIFT)
#define MAX77843_REG_SAFEOUTCTRL_ENSAFEOUT2 \
		BIT(SAFEOUTCTRL_ENSAFEOUT2_SHIFT)
#define MAX77843_REG_SAFEOUTCTRL_SAFEOUT1_MASK \
		(0x3 << SAFEOUTCTRL_SAFEOUT1_SHIFT)
#define MAX77843_REG_SAFEOUTCTRL_SAFEOUT2_MASK \
		(0x3 << SAFEOUTCTRL_SAFEOUT2_SHIFT)

struct max77843 {
	struct device *dev;

	struct i2c_client *i2c;
	struct i2c_client *i2c_chg;
	struct i2c_client *i2c_fuel;
	struct i2c_client *i2c_muic;

	struct regmap *regmap;
	struct regmap *regmap_chg;
	struct regmap *regmap_fuel;
	struct regmap *regmap_muic;

	struct regmap_irq_chip_data *irq_data;
	struct regmap_irq_chip_data *irq_data_chg;
	struct regmap_irq_chip_data *irq_data_fuel;
	struct regmap_irq_chip_data *irq_data_muic;

	int irq;
};
#endif /* __MAX77843_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * include/media/si476x-platform.h -- Platform data specific definitions
 *
 * Copyright (C) 2013 Andrey Smirnov
 *
 * Author: Andrey Smirnov <andrew.smirnov@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 */

#ifndef __SI476X_PLATFORM_H__
#define __SI476X_PLATFORM_H__

/* It is possible to select one of the four adresses using pins A0
 * and A1 on SI476x */
#define SI476X_I2C_ADDR_1	0x60
#define SI476X_I2C_ADDR_2	0x61
#define SI476X_I2C_ADDR_3	0x62
#define SI476X_I2C_ADDR_4	0x63

enum si476x_iqclk_config {
	SI476X_IQCLK_NOOP = 0,
	SI476X_IQCLK_TRISTATE = 1,
	SI476X_IQCLK_IQ = 21,
};
enum si476x_iqfs_config {
	SI476X_IQFS_NOOP = 0,
	SI476X_IQFS_TRISTATE = 1,
	SI476X_IQFS_IQ = 21,
};
enum si476x_iout_config {
	SI476X_IOUT_NOOP = 0,
	SI476X_IOUT_TRISTATE = 1,
	SI476X_IOUT_OUTPUT = 22,
};
enum si476x_qout_config {
	SI476X_QOUT_NOOP = 0,
	SI476X_QOUT_TRISTATE = 1,
	SI476X_QOUT_OUTPUT = 22,
};

enum si476x_dclk_config {
	SI476X_DCLK_NOOP      = 0,
	SI476X_DCLK_TRISTATE  = 1,
	SI476X_DCLK_DAUDIO    = 10,
};

enum si476x_dfs_config {
	SI476X_DFS_NOOP      = 0,
	SI476X_DFS_TRISTATE  = 1,
	SI476X_DFS_DAUDIO    = 10,
};

enum si476x_dout_config {
	SI476X_DOUT_NOOP       = 0,
	SI476X_DOUT_TRISTATE   = 1,
	SI476X_DOUT_I2S_OUTPUT = 12,
	SI476X_DOUT_I2S_INPUT  = 13,
};

enum si476x_xout_config {
	SI476X_XOUT_NOOP        = 0,
	SI476X_XOUT_TRISTATE    = 1,
	SI476X_XOUT_I2S_INPUT   = 13,
	SI476X_XOUT_MODE_SELECT = 23,
};

enum si476x_icin_config {
	SI476X_ICIN_NOOP	= 0,
	SI476X_ICIN_TRISTATE	= 1,
	SI476X_ICIN_GPO1_HIGH	= 2,
	SI476X_ICIN_GPO1_LOW	= 3,
	SI476X_ICIN_IC_LINK	= 30,
};

enum si476x_icip_config {
	SI476X_ICIP_NOOP	= 0,
	SI476X_ICIP_TRISTATE	= 1,
	SI476X_ICIP_GPO2_HIGH	= 2,
	SI476X_ICIP_GPO2_LOW	= 3,
	SI476X_ICIP_IC_LINK	= 30,
};

enum si476x_icon_config {
	SI476X_ICON_NOOP	= 0,
	SI476X_ICON_TRISTATE	= 1,
	SI476X_ICON_I2S		= 10,
	SI476X_ICON_IC_LINK	= 30,
};

enum si476x_icop_config {
	SI476X_ICOP_NOOP	= 0,
	SI476X_ICOP_TRISTATE	= 1,
	SI476X_ICOP_I2S		= 10,
	SI476X_ICOP_IC_LINK	= 30,
};


enum si476x_lrout_config {
	SI476X_LROUT_NOOP	= 0,
	SI476X_LROUT_TRISTATE	= 1,
	SI476X_LROUT_AUDIO	= 2,
	SI476X_LROUT_MPX	= 3,
};


enum si476x_intb_config {
	SI476X_INTB_NOOP     = 0,
	SI476X_INTB_TRISTATE = 1,
	SI476X_INTB_DAUDIO   = 10,
	SI476X_INTB_IRQ      = 40,
};

enum si476x_a1_config {
	SI476X_A1_NOOP     = 0,
	SI476X_A1_TRISTATE = 1,
	SI476X_A1_IRQ      = 40,
};


struct si476x_pinmux {
	enum si476x_dclk_config  dclk;
	enum si476x_dfs_config   dfs;
	enum si476x_dout_config  dout;
	enum si476x_xout_config  xout;

	enum si476x_iqclk_config iqclk;
	enum si476x_iqfs_config  iqfs;
	enum si476x_iout_config  iout;
	enum si476x_qout_config  qout;

	enum si476x_icin_config  icin;
	enum si476x_icip_config  icip;
	enum si476x_icon_config  icon;
	enum si476x_icop_config  icop;

	enum si476x_lrout_config lrout;

	enum si476x_intb_config  intb;
	enum si476x_a1_config    a1;
};

enum si476x_ibias6x {
	SI476X_IBIAS6X_OTHER			= 0,
	SI476X_IBIAS6X_RCVR1_NON_4MHZ_CLK	= 1,
};

enum si476x_xstart {
	SI476X_XSTART_MULTIPLE_TUNER	= 0x11,
	SI476X_XSTART_NORMAL		= 0x77,
};

enum si476x_freq {
	SI476X_FREQ_4_MHZ		= 0,
	SI476X_FREQ_37P209375_MHZ	= 1,
	SI476X_FREQ_36P4_MHZ		= 2,
	SI476X_FREQ_37P8_MHZ		=  3,
};

enum si476x_xmode {
	SI476X_XMODE_CRYSTAL_RCVR1	= 1,
	SI476X_XMODE_EXT_CLOCK		= 2,
	SI476X_XMODE_CRYSTAL_RCVR2_3	= 3,
};

enum si476x_xbiashc {
	SI476X_XBIASHC_SINGLE_RECEIVER = 0,
	SI476X_XBIASHC_MULTIPLE_RECEIVER = 1,
};

enum si476x_xbias {
	SI476X_XBIAS_RCVR2_3	= 0,
	SI476X_XBIAS_4MHZ_RCVR1 = 3,
	SI476X_XBIAS_RCVR1	= 7,
};

enum si476x_func {
	SI476X_FUNC_BOOTLOADER	= 0,
	SI476X_FUNC_FM_RECEIVER = 1,
	SI476X_FUNC_AM_RECEIVER = 2,
	SI476X_FUNC_WB_RECEIVER = 3,
};


/**
 * @xcload: Selects the amount of additional on-chip capacitance to
 *          be connected between XTAL1 and gnd and between XTAL2 and
 *          GND. One half of the capacitance value shown here is the
 *          additional load capacitance presented to the xtal. The
 *          minimum step size is 0.277 pF. Recommended value is 0x28
 *          but it will be layout dependent. Range is 0–0x3F i.e.
 *          (0–16.33 pF)
 * @ctsien: enable CTSINT(interrupt request when CTS condition
 *          arises) when set
 * @intsel: when set A1 pin becomes the interrupt pin; otherwise,
 *          INTB is the interrupt pin
 * @func:   selects the boot function of the device. I.e.
 *          SI476X_BOOTLOADER  - Boot loader
 *          SI476X_FM_RECEIVER - FM receiver
 *          SI476X_AM_RECEIVER - AM receiver
 *          SI476X_WB_RECEIVER - Weatherband receiver
 * @freq:   oscillator's crystal frequency:
 *          SI476X_XTAL_37P209375_MHZ - 37.209375 Mhz
 *          SI476X_XTAL_36P4_MHZ      - 36.4 Mhz
 *          SI476X_XTAL_37P8_MHZ      - 37.8 Mhz
 */
struct si476x_power_up_args {
	enum si476x_ibias6x ibias6x;
	enum si476x_xstart  xstart;
	u8   xcload;
	bool fastboot;
	enum si476x_xbiashc xbiashc;
	enum si476x_xbias   xbias;
	enum si476x_func    func;
	enum si476x_freq    freq;
	enum si476x_xmode   xmode;
};


/**
 * enum si476x_phase_diversity_mode - possbile phase diversity modes
 * for SI4764/5/6/7 chips.
 *
 * @SI476X_PHDIV_DISABLED:		Phase diversity feature is
 *					disabled.
 * @SI476X_PHDIV_PRIMARY_COMBINING:	Tuner works as a primary tuner
 *					in combination with a
 *					secondary one.
 * @SI476X_PHDIV_PRIMARY_ANTENNA:	Tuner works as a primary tuner
 *					using only its own antenna.
 * @SI476X_PHDIV_SECONDARY_ANTENNA:	Tuner works as a primary tuner
 *					usning seconary tuner's antenna.
 * @SI476X_PHDIV_SECONDARY_COMBINING:	Tuner works as a secondary
 *					tuner in combination with the
 *					primary one.
 */
enum si476x_phase_diversity_mode {
	SI476X_PHDIV_DISABLED			= 0,
	SI476X_PHDIV_PRIMARY_COMBINING		= 1,
	SI476X_PHDIV_PRIMARY_ANTENNA		= 2,
	SI476X_PHDIV_SECONDARY_ANTENNA		= 3,
	SI476X_PHDIV_SECONDARY_COMBINING	= 5,
};


/*
 * Platform dependent definition
 */
struct si476x_platform_data {
	int gpio_reset; /* < 0 if not used */

	struct si476x_power_up_args power_up_parameters;
	enum si476x_phase_diversity_mode diversity_mode;

	struct si476x_pinmux pinmux;
};


#endif /* __SI476X_PLATFORM_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Toshiba TC6393XB SoC support
 *
 * Copyright(c) 2005-2006 Chris Humbert
 * Copyright(c) 2005 Dirk Opfer
 * Copyright(c) 2005 Ian Molton <spyro@f2s.com>
 * Copyright(c) 2007 Dmitry Baryshkov
 *
 * Based on code written by Sharp/Lineo for 2.4 kernels
 * Based on locomo.c
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef MFD_TC6393XB_H
#define MFD_TC6393XB_H

#include <linux/fb.h>

/* Also one should provide the CK3P6MI clock */
struct tc6393xb_platform_data {
	u16	scr_pll2cr;	/* PLL2 Control */
	u16	scr_gper;	/* GP Enable */

	int	(*enable)(struct platform_device *dev);
	int	(*disable)(struct platform_device *dev);
	int	(*suspend)(struct platform_device *dev);
	int	(*resume)(struct platform_device *dev);

	int	irq_base;	/* base for subdevice irqs */
	int	gpio_base;
	int	(*setup)(struct platform_device *dev);
	void	(*teardown)(struct platform_device *dev);

	struct tmio_nand_data	*nand_data;
	struct tmio_fb_data	*fb_data;

	unsigned resume_restore : 1; /* make special actions
					to preserve the state
					on suspend/resume */
};

extern int tc6393xb_lcd_mode(struct platform_device *fb,
			     const struct fb_videomode *mode);
extern int tc6393xb_lcd_set_power(struct platform_device *fb, bool on);

/*
 * Relative to irq_base
 */
#define	IRQ_TC6393_NAND		0
#define	IRQ_TC6393_MMC		1
#define	IRQ_TC6393_OHCI		2
#define	IRQ_TC6393_FB		4

#define	TC6393XB_NR_IRQS	8

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 *  linux/drivers/mfd/mcp.h
 *
 *  Copyright (C) 2001 Russell King, All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 */
#ifndef MCP_H
#define MCP_H

#include <linux/device.h>

struct mcp_ops;

struct mcp {
	struct module	*owner;
	struct mcp_ops	*ops;
	spinlock_t	lock;
	int		use_count;
	unsigned int	sclk_rate;
	unsigned int	rw_timeout;
	struct device	attached_device;
};

struct mcp_ops {
	void		(*set_telecom_divisor)(struct mcp *, unsigned int);
	void		(*set_audio_divisor)(struct mcp *, unsigned int);
	void		(*reg_write)(struct mcp *, unsigned int, unsigned int);
	unsigned int	(*reg_read)(struct mcp *, unsigned int);
	void		(*enable)(struct mcp *);
	void		(*disable)(struct mcp *);
};

void mcp_set_telecom_divisor(struct mcp *, unsigned int);
void mcp_set_audio_divisor(struct mcp *, unsigned int);
void mcp_reg_write(struct mcp *, unsigned int, unsigned int);
unsigned int mcp_reg_read(struct mcp *, unsigned int);
void mcp_enable(struct mcp *);
void mcp_disable(struct mcp *);
#define mcp_get_sclk_rate(mcp)	((mcp)->sclk_rate)

struct mcp *mcp_host_alloc(struct device *, size_t);
int mcp_host_add(struct mcp *, void *);
void mcp_host_del(struct mcp *);
void mcp_host_free(struct mcp *);

struct mcp_driver {
	struct device_driver drv;
	int (*probe)(struct mcp *);
	void (*remove)(struct mcp *);
};

int mcp_driver_register(struct mcp_driver *);
void mcp_driver_unregister(struct mcp_driver *);

#define mcp_get_drvdata(mcp)	dev_get_drvdata(&(mcp)->attached_device)
#define mcp_set_drvdata(mcp,d)	dev_set_drvdata(&(mcp)->attached_device, d)

static inline void *mcp_priv(struct mcp *mcp)
{
	return mcp + 1;
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * max14577-private.h - Common API for the Maxim 14577/77836 internal sub chip
 *
 * Copyright (C) 2014 Samsung Electrnoics
 * Chanwoo Choi <cw00.choi@samsung.com>
 * Krzysztof Kozlowski <k.kozlowski@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#ifndef __MAX14577_PRIVATE_H__
#define __MAX14577_PRIVATE_H__

#include <linux/i2c.h>
#include <linux/regmap.h>

#define I2C_ADDR_PMIC	(0x46 >> 1)
#define I2C_ADDR_MUIC	(0x4A >> 1)
#define I2C_ADDR_FG	(0x6C >> 1)

enum maxim_device_type {
	MAXIM_DEVICE_TYPE_UNKNOWN	= 0,
	MAXIM_DEVICE_TYPE_MAX14577,
	MAXIM_DEVICE_TYPE_MAX77836,

	MAXIM_DEVICE_TYPE_NUM,
};

/* Slave addr = 0x4A: MUIC and Charger */
enum max14577_reg {
	MAX14577_REG_DEVICEID		= 0x00,
	MAX14577_REG_INT1		= 0x01,
	MAX14577_REG_INT2		= 0x02,
	MAX14577_REG_INT3		= 0x03,
	MAX14577_REG_STATUS1		= 0x04,
	MAX14577_REG_STATUS2		= 0x05,
	MAX14577_REG_STATUS3		= 0x06,
	MAX14577_REG_INTMASK1		= 0x07,
	MAX14577_REG_INTMASK2		= 0x08,
	MAX14577_REG_INTMASK3		= 0x09,
	MAX14577_REG_CDETCTRL1		= 0x0A,
	MAX14577_REG_RFU		= 0x0B,
	MAX14577_REG_CONTROL1		= 0x0C,
	MAX14577_REG_CONTROL2		= 0x0D,
	MAX14577_REG_CONTROL3		= 0x0E,
	MAX14577_REG_CHGCTRL1		= 0x0F,
	MAX14577_REG_CHGCTRL2		= 0x10,
	MAX14577_REG_CHGCTRL3		= 0x11,
	MAX14577_REG_CHGCTRL4		= 0x12,
	MAX14577_REG_CHGCTRL5		= 0x13,
	MAX14577_REG_CHGCTRL6		= 0x14,
	MAX14577_REG_CHGCTRL7		= 0x15,

	MAX14577_REG_END,
};

/* Slave addr = 0x4A: MUIC */
enum max14577_muic_reg {
	MAX14577_MUIC_REG_STATUS1	= 0x04,
	MAX14577_MUIC_REG_STATUS2	= 0x05,
	MAX14577_MUIC_REG_CONTROL1	= 0x0C,
	MAX14577_MUIC_REG_CONTROL3	= 0x0E,

	MAX14577_MUIC_REG_END,
};

/*
 * Combined charger types for max14577 and max77836.
 *
 * On max14577 three lower bits map to STATUS2/CHGTYP field.
 * However the max77836 has different two last values of STATUS2/CHGTYP.
 * To indicate the difference enum has two additional values for max77836.
 * These values are just a register value bitwise OR with 0x8.
 */
enum max14577_muic_charger_type {
	MAX14577_CHARGER_TYPE_NONE		= 0x0,
	MAX14577_CHARGER_TYPE_USB		= 0x1,
	MAX14577_CHARGER_TYPE_DOWNSTREAM_PORT	= 0x2,
	MAX14577_CHARGER_TYPE_DEDICATED_CHG	= 0x3,
	MAX14577_CHARGER_TYPE_SPECIAL_500MA	= 0x4,
	/* Special 1A or 2A charger */
	MAX14577_CHARGER_TYPE_SPECIAL_1A	= 0x5,
	/* max14577: reserved, used on max77836 */
	MAX14577_CHARGER_TYPE_RESERVED		= 0x6,
	/* max14577: dead-battery charing with maximum current 100mA */
	MAX14577_CHARGER_TYPE_DEAD_BATTERY	= 0x7,
	/*
	 * max77836: special charger (bias on D+/D-),
	 * matches register value of 0x6
	 */
	MAX77836_CHARGER_TYPE_SPECIAL_BIAS	= 0xe,
	/* max77836: reserved, register value 0x7 */
	MAX77836_CHARGER_TYPE_RESERVED		= 0xf,
};

/* MAX14577 interrupts */
#define MAX14577_INT1_ADC_MASK		BIT(0)
#define MAX14577_INT1_ADCLOW_MASK	BIT(1)
#define MAX14577_INT1_ADCERR_MASK	BIT(2)
#define MAX77836_INT1_ADC1K_MASK	BIT(3)

#define MAX14577_INT2_CHGTYP_MASK	BIT(0)
#define MAX14577_INT2_CHGDETRUN_MASK	BIT(1)
#define MAX14577_INT2_DCDTMR_MASK	BIT(2)
#define MAX14577_INT2_DBCHG_MASK	BIT(3)
#define MAX14577_INT2_VBVOLT_MASK	BIT(4)
#define MAX77836_INT2_VIDRM_MASK	BIT(5)

#define MAX14577_INT3_EOC_MASK		BIT(0)
#define MAX14577_INT3_CGMBC_MASK	BIT(1)
#define MAX14577_INT3_OVP_MASK		BIT(2)
#define MAX14577_INT3_MBCCHGERR_MASK	BIT(3)

/* MAX14577 DEVICE ID register */
#define DEVID_VENDORID_SHIFT		0
#define DEVID_DEVICEID_SHIFT		3
#define DEVID_VENDORID_MASK		(0x07 << DEVID_VENDORID_SHIFT)
#define DEVID_DEVICEID_MASK		(0x1f << DEVID_DEVICEID_SHIFT)

/* MAX14577 STATUS1 register */
#define STATUS1_ADC_SHIFT		0
#define STATUS1_ADCLOW_SHIFT		5
#define STATUS1_ADCERR_SHIFT		6
#define MAX77836_STATUS1_ADC1K_SHIFT	7
#define STATUS1_ADC_MASK		(0x1f << STATUS1_ADC_SHIFT)
#define STATUS1_ADCLOW_MASK		BIT(STATUS1_ADCLOW_SHIFT)
#define STATUS1_ADCERR_MASK		BIT(STATUS1_ADCERR_SHIFT)
#define MAX77836_STATUS1_ADC1K_MASK	BIT(MAX77836_STATUS1_ADC1K_SHIFT)

/* MAX14577 STATUS2 register */
#define STATUS2_CHGTYP_SHIFT		0
#define STATUS2_CHGDETRUN_SHIFT		3
#define STATUS2_DCDTMR_SHIFT		4
#define MAX14577_STATUS2_DBCHG_SHIFT	5
#define MAX77836_STATUS2_DXOVP_SHIFT	5
#define STATUS2_VBVOLT_SHIFT		6
#define MAX77836_STATUS2_VIDRM_SHIFT	7
#define STATUS2_CHGTYP_MASK		(0x7 << STATUS2_CHGTYP_SHIFT)
#define STATUS2_CHGDETRUN_MASK		BIT(STATUS2_CHGDETRUN_SHIFT)
#define STATUS2_DCDTMR_MASK		BIT(STATUS2_DCDTMR_SHIFT)
#define MAX14577_STATUS2_DBCHG_MASK	BIT(MAX14577_STATUS2_DBCHG_SHIFT)
#define MAX77836_STATUS2_DXOVP_MASK	BIT(MAX77836_STATUS2_DXOVP_SHIFT)
#define STATUS2_VBVOLT_MASK		BIT(STATUS2_VBVOLT_SHIFT)
#define MAX77836_STATUS2_VIDRM_MASK	BIT(MAX77836_STATUS2_VIDRM_SHIFT)

/* MAX14577 CONTROL1 register */
#define COMN1SW_SHIFT			0
#define COMP2SW_SHIFT			3
#define MICEN_SHIFT			6
#define IDBEN_SHIFT			7
#define COMN1SW_MASK			(0x7 << COMN1SW_SHIFT)
#define COMP2SW_MASK			(0x7 << COMP2SW_SHIFT)
#define MICEN_MASK			BIT(MICEN_SHIFT)
#define IDBEN_MASK			BIT(IDBEN_SHIFT)
#define CLEAR_IDBEN_MICEN_MASK		(COMN1SW_MASK | COMP2SW_MASK)
#define CTRL1_SW_USB			((1 << COMP2SW_SHIFT) \
						| (1 << COMN1SW_SHIFT))
#define CTRL1_SW_AUDIO			((2 << COMP2SW_SHIFT) \
						| (2 << COMN1SW_SHIFT))
#define CTRL1_SW_UART			((3 << COMP2SW_SHIFT) \
						| (3 << COMN1SW_SHIFT))
#define CTRL1_SW_OPEN			((0 << COMP2SW_SHIFT) \
						| (0 << COMN1SW_SHIFT))

/* MAX14577 CONTROL2 register */
#define CTRL2_LOWPWR_SHIFT		(0)
#define CTRL2_ADCEN_SHIFT		(1)
#define CTRL2_CPEN_SHIFT		(2)
#define CTRL2_SFOUTASRT_SHIFT		(3)
#define CTRL2_SFOUTORD_SHIFT		(4)
#define CTRL2_ACCDET_SHIFT		(5)
#define CTRL2_USBCPINT_SHIFT		(6)
#define CTRL2_RCPS_SHIFT		(7)
#define CTRL2_LOWPWR_MASK		BIT(CTRL2_LOWPWR_SHIFT)
#define CTRL2_ADCEN_MASK		BIT(CTRL2_ADCEN_SHIFT)
#define CTRL2_CPEN_MASK			BIT(CTRL2_CPEN_SHIFT)
#define CTRL2_SFOUTASRT_MASK		BIT(CTRL2_SFOUTASRT_SHIFT)
#define CTRL2_SFOUTORD_MASK		BIT(CTRL2_SFOUTORD_SHIFT)
#define CTRL2_ACCDET_MASK		BIT(CTRL2_ACCDET_SHIFT)
#define CTRL2_USBCPINT_MASK		BIT(CTRL2_USBCPINT_SHIFT)
#define CTRL2_RCPS_MASK			BIT(CTRL2_RCPS_SHIFT)

#define CTRL2_CPEN1_LOWPWR0 ((1 << CTRL2_CPEN_SHIFT) | \
				(0 << CTRL2_LOWPWR_SHIFT))
#define CTRL2_CPEN0_LOWPWR1 ((0 << CTRL2_CPEN_SHIFT) | \
				(1 << CTRL2_LOWPWR_SHIFT))

/* MAX14577 CONTROL3 register */
#define CTRL3_JIGSET_SHIFT		0
#define CTRL3_BOOTSET_SHIFT		2
#define CTRL3_ADCDBSET_SHIFT		4
#define CTRL3_WBTH_SHIFT		6
#define CTRL3_JIGSET_MASK		(0x3 << CTRL3_JIGSET_SHIFT)
#define CTRL3_BOOTSET_MASK		(0x3 << CTRL3_BOOTSET_SHIFT)
#define CTRL3_ADCDBSET_MASK		(0x3 << CTRL3_ADCDBSET_SHIFT)
#define CTRL3_WBTH_MASK			(0x3 << CTRL3_WBTH_SHIFT)

/* Slave addr = 0x4A: Charger */
enum max14577_charger_reg {
	MAX14577_CHG_REG_STATUS3	= 0x06,
	MAX14577_CHG_REG_CHG_CTRL1	= 0x0F,
	MAX14577_CHG_REG_CHG_CTRL2	= 0x10,
	MAX14577_CHG_REG_CHG_CTRL3	= 0x11,
	MAX14577_CHG_REG_CHG_CTRL4	= 0x12,
	MAX14577_CHG_REG_CHG_CTRL5	= 0x13,
	MAX14577_CHG_REG_CHG_CTRL6	= 0x14,
	MAX14577_CHG_REG_CHG_CTRL7	= 0x15,

	MAX14577_CHG_REG_END,
};

/* MAX14577 STATUS3 register */
#define STATUS3_EOC_SHIFT		0
#define STATUS3_CGMBC_SHIFT		1
#define STATUS3_OVP_SHIFT		2
#define STATUS3_MBCCHGERR_SHIFT		3
#define STATUS3_EOC_MASK		(0x1 << STATUS3_EOC_SHIFT)
#define STATUS3_CGMBC_MASK		(0x1 << STATUS3_CGMBC_SHIFT)
#define STATUS3_OVP_MASK		(0x1 << STATUS3_OVP_SHIFT)
#define STATUS3_MBCCHGERR_MASK		(0x1 << STATUS3_MBCCHGERR_SHIFT)

/* MAX14577 CDETCTRL1 register */
#define CDETCTRL1_CHGDETEN_SHIFT	0
#define CDETCTRL1_CHGTYPMAN_SHIFT	1
#define CDETCTRL1_DCDEN_SHIFT		2
#define CDETCTRL1_DCD2SCT_SHIFT		3
#define MAX14577_CDETCTRL1_DCHKTM_SHIFT	4
#define MAX77836_CDETCTRL1_CDLY_SHIFT	4
#define MAX14577_CDETCTRL1_DBEXIT_SHIFT	5
#define MAX77836_CDETCTRL1_DCDCPL_SHIFT	5
#define CDETCTRL1_DBIDLE_SHIFT		6
#define CDETCTRL1_CDPDET_SHIFT		7
#define CDETCTRL1_CHGDETEN_MASK		BIT(CDETCTRL1_CHGDETEN_SHIFT)
#define CDETCTRL1_CHGTYPMAN_MASK	BIT(CDETCTRL1_CHGTYPMAN_SHIFT)
#define CDETCTRL1_DCDEN_MASK		BIT(CDETCTRL1_DCDEN_SHIFT)
#define CDETCTRL1_DCD2SCT_MASK		BIT(CDETCTRL1_DCD2SCT_SHIFT)
#define MAX14577_CDETCTRL1_DCHKTM_MASK	BIT(MAX14577_CDETCTRL1_DCHKTM_SHIFT)
#define MAX77836_CDETCTRL1_CDDLY_MASK	BIT(MAX77836_CDETCTRL1_CDDLY_SHIFT)
#define MAX14577_CDETCTRL1_DBEXIT_MASK	BIT(MAX14577_CDETCTRL1_DBEXIT_SHIFT)
#define MAX77836_CDETCTRL1_DCDCPL_MASK	BIT(MAX77836_CDETCTRL1_DCDCPL_SHIFT)
#define CDETCTRL1_DBIDLE_MASK		BIT(CDETCTRL1_DBIDLE_SHIFT)
#define CDETCTRL1_CDPDET_MASK		BIT(CDETCTRL1_CDPDET_SHIFT)

/* MAX14577 CHGCTRL1 register */
#define CHGCTRL1_TCHW_SHIFT		4
#define CHGCTRL1_TCHW_MASK		(0x7 << CHGCTRL1_TCHW_SHIFT)

/* MAX14577 CHGCTRL2 register */
#define CHGCTRL2_MBCHOSTEN_SHIFT	6
#define CHGCTRL2_MBCHOSTEN_MASK		BIT(CHGCTRL2_MBCHOSTEN_SHIFT)
#define CHGCTRL2_VCHGR_RC_SHIFT		7
#define CHGCTRL2_VCHGR_RC_MASK		BIT(CHGCTRL2_VCHGR_RC_SHIFT)

/* MAX14577 CHGCTRL3 register */
#define CHGCTRL3_MBCCVWRC_SHIFT		0
#define CHGCTRL3_MBCCVWRC_MASK		(0xf << CHGCTRL3_MBCCVWRC_SHIFT)

/* MAX14577 CHGCTRL4 register */
#define CHGCTRL4_MBCICHWRCH_SHIFT	0
#define CHGCTRL4_MBCICHWRCH_MASK	(0xf << CHGCTRL4_MBCICHWRCH_SHIFT)
#define CHGCTRL4_MBCICHWRCL_SHIFT	4
#define CHGCTRL4_MBCICHWRCL_MASK	BIT(CHGCTRL4_MBCICHWRCL_SHIFT)

/* MAX14577 CHGCTRL5 register */
#define CHGCTRL5_EOCS_SHIFT		0
#define CHGCTRL5_EOCS_MASK		(0xf << CHGCTRL5_EOCS_SHIFT)

/* MAX14577 CHGCTRL6 register */
#define CHGCTRL6_AUTOSTOP_SHIFT		5
#define CHGCTRL6_AUTOSTOP_MASK		BIT(CHGCTRL6_AUTOSTOP_SHIFT)

/* MAX14577 CHGCTRL7 register */
#define CHGCTRL7_OTPCGHCVS_SHIFT	0
#define CHGCTRL7_OTPCGHCVS_MASK		(0x3 << CHGCTRL7_OTPCGHCVS_SHIFT)

/* MAX14577 charger current limits (as in CHGCTRL4 register), uA */
#define MAX14577_CHARGER_CURRENT_LIMIT_MIN		 90000U
#define MAX14577_CHARGER_CURRENT_LIMIT_HIGH_START	200000U
#define MAX14577_CHARGER_CURRENT_LIMIT_HIGH_STEP	 50000U
#define MAX14577_CHARGER_CURRENT_LIMIT_MAX		950000U

/* MAX77836 charger current limits (as in CHGCTRL4 register), uA */
#define MAX77836_CHARGER_CURRENT_LIMIT_MIN		 45000U
#define MAX77836_CHARGER_CURRENT_LIMIT_HIGH_START	100000U
#define MAX77836_CHARGER_CURRENT_LIMIT_HIGH_STEP	 25000U
#define MAX77836_CHARGER_CURRENT_LIMIT_MAX		475000U

/*
 * MAX14577 charger End-Of-Charge current limits
 * (as in CHGCTRL5 register), uA
 */
#define MAX14577_CHARGER_EOC_CURRENT_LIMIT_MIN		50000U
#define MAX14577_CHARGER_EOC_CURRENT_LIMIT_STEP		10000U
#define MAX14577_CHARGER_EOC_CURRENT_LIMIT_MAX		200000U

/*
 * MAX14577/MAX77836 Battery Constant Voltage
 * (as in CHGCTRL3 register), uV
 */
#define MAXIM_CHARGER_CONSTANT_VOLTAGE_MIN		4000000U
#define MAXIM_CHARGER_CONSTANT_VOLTAGE_STEP		20000U
#define MAXIM_CHARGER_CONSTANT_VOLTAGE_MAX		4350000U

/* Default value for fast charge timer, in hours */
#define MAXIM_CHARGER_FAST_CHARGE_TIMER_DEFAULT		5

/* MAX14577 regulator SFOUT LDO voltage, fixed, uV */
#define MAX14577_REGULATOR_SAFEOUT_VOLTAGE		4900000

/* MAX77836 regulator LDOx voltage, uV */
#define MAX77836_REGULATOR_LDO_VOLTAGE_MIN		800000
#define MAX77836_REGULATOR_LDO_VOLTAGE_MAX		3950000
#define MAX77836_REGULATOR_LDO_VOLTAGE_STEP		50000
#define MAX77836_REGULATOR_LDO_VOLTAGE_STEPS_NUM	64

/* Slave addr = 0x46: PMIC */
enum max77836_pmic_reg {
	MAX77836_PMIC_REG_PMIC_ID		= 0x20,
	MAX77836_PMIC_REG_PMIC_REV		= 0x21,
	MAX77836_PMIC_REG_INTSRC		= 0x22,
	MAX77836_PMIC_REG_INTSRC_MASK		= 0x23,
	MAX77836_PMIC_REG_TOPSYS_INT		= 0x24,
	MAX77836_PMIC_REG_TOPSYS_INT_MASK	= 0x26,
	MAX77836_PMIC_REG_TOPSYS_STAT		= 0x28,
	MAX77836_PMIC_REG_MRSTB_CNTL		= 0x2A,
	MAX77836_PMIC_REG_LSCNFG		= 0x2B,

	MAX77836_LDO_REG_CNFG1_LDO1		= 0x51,
	MAX77836_LDO_REG_CNFG2_LDO1		= 0x52,
	MAX77836_LDO_REG_CNFG1_LDO2		= 0x53,
	MAX77836_LDO_REG_CNFG2_LDO2		= 0x54,
	MAX77836_LDO_REG_CNFG_LDO_BIAS		= 0x55,

	MAX77836_COMP_REG_COMP1			= 0x60,

	MAX77836_PMIC_REG_END,
};

#define MAX77836_INTSRC_MASK_TOP_INT_SHIFT	1
#define MAX77836_INTSRC_MASK_MUIC_CHG_INT_SHIFT	3
#define MAX77836_INTSRC_MASK_TOP_INT_MASK	BIT(MAX77836_INTSRC_MASK_TOP_INT_SHIFT)
#define MAX77836_INTSRC_MASK_MUIC_CHG_INT_MASK	BIT(MAX77836_INTSRC_MASK_MUIC_CHG_INT_SHIFT)

/* MAX77836 PMIC interrupts */
#define MAX77836_TOPSYS_INT_T120C_SHIFT		0
#define MAX77836_TOPSYS_INT_T140C_SHIFT		1
#define MAX77836_TOPSYS_INT_T120C_MASK		BIT(MAX77836_TOPSYS_INT_T120C_SHIFT)
#define MAX77836_TOPSYS_INT_T140C_MASK		BIT(MAX77836_TOPSYS_INT_T140C_SHIFT)

/* LDO1/LDO2 CONFIG1 register */
#define MAX77836_CNFG1_LDO_PWRMD_SHIFT		6
#define MAX77836_CNFG1_LDO_TV_SHIFT		0
#define MAX77836_CNFG1_LDO_PWRMD_MASK		(0x3 << MAX77836_CNFG1_LDO_PWRMD_SHIFT)
#define MAX77836_CNFG1_LDO_TV_MASK		(0x3f << MAX77836_CNFG1_LDO_TV_SHIFT)

/* LDO1/LDO2 CONFIG2 register */
#define MAX77836_CNFG2_LDO_OVCLMPEN_SHIFT	7
#define MAX77836_CNFG2_LDO_ALPMEN_SHIFT		6
#define MAX77836_CNFG2_LDO_COMP_SHIFT		4
#define MAX77836_CNFG2_LDO_POK_SHIFT		3
#define MAX77836_CNFG2_LDO_ADE_SHIFT		1
#define MAX77836_CNFG2_LDO_SS_SHIFT		0
#define MAX77836_CNFG2_LDO_OVCLMPEN_MASK	BIT(MAX77836_CNFG2_LDO_OVCLMPEN_SHIFT)
#define MAX77836_CNFG2_LDO_ALPMEN_MASK		BIT(MAX77836_CNFG2_LDO_ALPMEN_SHIFT)
#define MAX77836_CNFG2_LDO_COMP_MASK		(0x3 << MAX77836_CNFG2_LDO_COMP_SHIFT)
#define MAX77836_CNFG2_LDO_POK_MASK		BIT(MAX77836_CNFG2_LDO_POK_SHIFT)
#define MAX77836_CNFG2_LDO_ADE_MASK		BIT(MAX77836_CNFG2_LDO_ADE_SHIFT)
#define MAX77836_CNFG2_LDO_SS_MASK		BIT(MAX77836_CNFG2_LDO_SS_SHIFT)

/* Slave addr = 0x6C: Fuel-Gauge/Battery */
enum max77836_fg_reg {
	MAX77836_FG_REG_VCELL_MSB	= 0x02,
	MAX77836_FG_REG_VCELL_LSB	= 0x03,
	MAX77836_FG_REG_SOC_MSB		= 0x04,
	MAX77836_FG_REG_SOC_LSB		= 0x05,
	MAX77836_FG_REG_MODE_H		= 0x06,
	MAX77836_FG_REG_MODE_L		= 0x07,
	MAX77836_FG_REG_VERSION_MSB	= 0x08,
	MAX77836_FG_REG_VERSION_LSB	= 0x09,
	MAX77836_FG_REG_HIBRT_H		= 0x0A,
	MAX77836_FG_REG_HIBRT_L		= 0x0B,
	MAX77836_FG_REG_CONFIG_H	= 0x0C,
	MAX77836_FG_REG_CONFIG_L	= 0x0D,
	MAX77836_FG_REG_VALRT_MIN	= 0x14,
	MAX77836_FG_REG_VALRT_MAX	= 0x15,
	MAX77836_FG_REG_CRATE_MSB	= 0x16,
	MAX77836_FG_REG_CRATE_LSB	= 0x17,
	MAX77836_FG_REG_VRESET		= 0x18,
	MAX77836_FG_REG_FGID		= 0x19,
	MAX77836_FG_REG_STATUS_H	= 0x1A,
	MAX77836_FG_REG_STATUS_L	= 0x1B,
	/*
	 * TODO: TABLE registers
	 * TODO: CMD register
	 */

	MAX77836_FG_REG_END,
};

enum max14577_irq {
	/* INT1 */
	MAX14577_IRQ_INT1_ADC,
	MAX14577_IRQ_INT1_ADCLOW,
	MAX14577_IRQ_INT1_ADCERR,
	MAX77836_IRQ_INT1_ADC1K,

	/* INT2 */
	MAX14577_IRQ_INT2_CHGTYP,
	MAX14577_IRQ_INT2_CHGDETRUN,
	MAX14577_IRQ_INT2_DCDTMR,
	MAX14577_IRQ_INT2_DBCHG,
	MAX14577_IRQ_INT2_VBVOLT,
	MAX77836_IRQ_INT2_VIDRM,

	/* INT3 */
	MAX14577_IRQ_INT3_EOC,
	MAX14577_IRQ_INT3_CGMBC,
	MAX14577_IRQ_INT3_OVP,
	MAX14577_IRQ_INT3_MBCCHGERR,

	/* TOPSYS_INT, only MAX77836 */
	MAX77836_IRQ_TOPSYS_T140C,
	MAX77836_IRQ_TOPSYS_T120C,

	MAX14577_IRQ_NUM,
};

struct max14577 {
	struct device *dev;
	struct i2c_client *i2c; /* Slave addr = 0x4A */
	struct i2c_client *i2c_pmic; /* Slave addr = 0x46 */
	enum maxim_device_type dev_type;

	struct regmap *regmap; /* For MUIC and Charger */
	struct regmap *regmap_pmic;

	struct regmap_irq_chip_data *irq_data; /* For MUIC and Charger */
	struct regmap_irq_chip_data *irq_data_pmic;
	int irq;
};

/* MAX14577 shared regmap API function */
static inline int max14577_read_reg(struct regmap *map, u8 reg, u8 *dest)
{
	unsigned int val;
	int ret;

	ret = regmap_read(map, reg, &val);
	*dest = val;

	return ret;
}

static inline int max14577_bulk_read(struct regmap *map, u8 reg, u8 *buf,
		int count)
{
	return regmap_bulk_read(map, reg, buf, count);
}

static inline int max14577_write_reg(struct regmap *map, u8 reg, u8 value)
{
	return regmap_write(map, reg, value);
}

static inline int max14577_bulk_write(struct regmap *map, u8 reg, u8 *buf,
		int count)
{
	return regmap_bulk_write(map, reg, buf, count);
}

static inline int max14577_update_reg(struct regmap *map, u8 reg, u8 mask,
		u8 val)
{
	return regmap_update_bits(map, reg, mask, val);
}

#endif /* __MAX14577_PRIVATE_H__ */
                                                                                                                                        /*
 * Functions to access Menelaus power management chip
 */

#ifndef __ASM_ARCH_MENELAUS_H
#define __ASM_ARCH_MENELAUS_H

struct device;

struct menelaus_platform_data {
	int (* late_init)(struct device *dev);
};

extern int menelaus_register_mmc_callback(void (*callback)(void *data, u8 card_mask),
					  void *data);
extern void menelaus_unregister_mmc_callback(void);
extern int menelaus_set_mmc_opendrain(int slot, int enable);
extern int menelaus_set_mmc_slot(int slot, int enable, int power, int cd_on);

extern int menelaus_set_vmem(unsigned int mV);
extern int menelaus_set_vio(unsigned int mV);
extern int menelaus_set_vmmc(unsigned int mV);
extern int menelaus_set_vaux(unsigned int mV);
extern int menelaus_set_vdcdc(int dcdc, unsigned int mV);
extern int menelaus_set_slot_sel(int enable);
extern int menelaus_get_slot_pin_states(void);
extern int menelaus_set_vcore_hw(unsigned int roof_mV, unsigned int floor_mV);

#define EN_VPLL_SLEEP	(1 << 7)
#define EN_VMMC_SLEEP	(1 << 6)
#define EN_VAUX_SLEEP	(1 << 5)
#define EN_VIO_SLEEP	(1 << 4)
#define EN_VMEM_SLEEP	(1 << 3)
#define EN_DC3_SLEEP	(1 << 2)
#define EN_DC2_SLEEP	(1 << 1)
#define EN_VC_SLEEP	(1 << 0)

extern int menelaus_set_regulator_sleep(int enable, u32 val);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * linux/mfd/tps65217.h
 *
 * Functions to access TPS65217 power management chip.
 *
 * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation version 2.
 *
 * This program is distributed "as is" WITHOUT ANY WARRANTY of any
 * kind, whether express or implied; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#ifndef __LINUX_MFD_TPS65217_H
#define __LINUX_MFD_TPS65217_H

#include <linux/i2c.h>
#include <linux/regulator/driver.h>
#include <linux/regulator/machine.h>

/* TPS chip id list */
#define TPS65217			0xF0

/* I2C ID for TPS65217 part */
#define TPS65217_I2C_ID			0x24

/* All register addresses */
#define TPS65217_REG_CHIPID		0X00
#define TPS65217_REG_PPATH		0X01
#define TPS65217_REG_INT		0X02
#define TPS65217_REG_CHGCONFIG0		0X03
#define TPS65217_REG_CHGCONFIG1		0X04
#define TPS65217_REG_CHGCONFIG2		0X05
#define TPS65217_REG_CHGCONFIG3		0X06
#define TPS65217_REG_WLEDCTRL1		0X07
#define TPS65217_REG_WLEDCTRL2		0X08
#define TPS65217_REG_MUXCTRL		0X09
#define TPS65217_REG_STATUS		0X0A
#define TPS65217_REG_PASSWORD		0X0B
#define TPS65217_REG_PGOOD		0X0C
#define TPS65217_REG_DEFPG		0X0D
#define TPS65217_REG_DEFDCDC1		0X0E
#define TPS65217_REG_DEFDCDC2		0X0F
#define TPS65217_REG_DEFDCDC3		0X10
#define TPS65217_REG_DEFSLEW		0X11
#define TPS65217_REG_DEFLDO1		0X12
#define TPS65217_REG_DEFLDO2		0X13
#define TPS65217_REG_DEFLS1		0X14
#define TPS65217_REG_DEFLS2		0X15
#define TPS65217_REG_ENABLE		0X16
#define TPS65217_REG_DEFUVLO		0X18
#define TPS65217_REG_SEQ1		0X19
#define TPS65217_REG_SEQ2		0X1A
#define TPS65217_REG_SEQ3		0X1B
#define TPS65217_REG_SEQ4		0X1C
#define TPS65217_REG_SEQ5		0X1D
#define TPS65217_REG_SEQ6		0X1E

#define TPS65217_REG_MAX		TPS65217_REG_SEQ6

/* Register field definitions */
#define TPS65217_CHIPID_CHIP_MASK	0xF0
#define TPS65217_CHIPID_REV_MASK	0x0F

#define TPS65217_PPATH_ACSINK_ENABLE	BIT(7)
#define TPS65217_PPATH_USBSINK_ENABLE	BIT(6)
#define TPS65217_PPATH_AC_PW_ENABLE	BIT(5)
#define TPS65217_PPATH_USB_PW_ENABLE	BIT(4)
#define TPS65217_PPATH_AC_CURRENT_MASK	0x0C
#define TPS65217_PPATH_USB_CURRENT_MASK	0x03

#define TPS65217_INT_PBM		BIT(6)
#define TPS65217_INT_ACM		BIT(5)
#define TPS65217_INT_USBM		BIT(4)
#define TPS65217_INT_PBI		BIT(2)
#define TPS65217_INT_ACI		BIT(1)
#define TPS65217_INT_USBI		BIT(0)

#define TPS65217_CHGCONFIG0_TREG	BIT(7)
#define TPS65217_CHGCONFIG0_DPPM	BIT(6)
#define TPS65217_CHGCONFIG0_TSUSP	BIT(5)
#define TPS65217_CHGCONFIG0_TERMI	BIT(4)
#define TPS65217_CHGCONFIG0_ACTIVE	BIT(3)
#define TPS65217_CHGCONFIG0_CHGTOUT	BIT(2)
#define TPS65217_CHGCONFIG0_PCHGTOUT	BIT(1)
#define TPS65217_CHGCONFIG0_BATTEMP	BIT(0)

#define TPS65217_CHGCONFIG1_TMR_MASK	0xC0
#define TPS65217_CHGCONFIG1_TMR_ENABLE	BIT(5)
#define TPS65217_CHGCONFIG1_NTC_TYPE	BIT(4)
#define TPS65217_CHGCONFIG1_RESET	BIT(3)
#define TPS65217_CHGCONFIG1_TERM	BIT(2)
#define TPS65217_CHGCONFIG1_SUSP	BIT(1)
#define TPS65217_CHGCONFIG1_CHG_EN	BIT(0)

#define TPS65217_CHGCONFIG2_DYNTMR	BIT(7)
#define TPS65217_CHGCONFIG2_VPREGHG	BIT(6)
#define TPS65217_CHGCONFIG2_VOREG_MASK	0x30

#define TPS65217_CHGCONFIG3_ICHRG_MASK	0xC0
#define TPS65217_CHGCONFIG3_DPPMTH_MASK	0x30
#define TPS65217_CHGCONFIG2_PCHRGT	BIT(3)
#define TPS65217_CHGCONFIG2_TERMIF	0x06
#define TPS65217_CHGCONFIG2_TRANGE	BIT(0)

#define TPS65217_WLEDCTRL1_ISINK_ENABLE	BIT(3)
#define TPS65217_WLEDCTRL1_ISEL		BIT(2)
#define TPS65217_WLEDCTRL1_FDIM_MASK	0x03

#define TPS65217_WLEDCTRL2_DUTY_MASK	0x7F

#define TPS65217_MUXCTRL_MUX_MASK	0x07

#define TPS65217_STATUS_OFF		BIT(7)
#define TPS65217_STATUS_ACPWR		BIT(3)
#define TPS65217_STATUS_USBPWR		BIT(2)
#define TPS65217_STATUS_PB		BIT(0)

#define TPS65217_PASSWORD_REGS_UNLOCK	0x7D

#define TPS65217_PGOOD_LDO3_PG		BIT(6)
#define TPS65217_PGOOD_LDO4_PG		BIT(5)
#define TPS65217_PGOOD_DC1_PG		BIT(4)
#define TPS65217_PGOOD_DC2_PG		BIT(3)
#define TPS65217_PGOOD_DC3_PG		BIT(2)
#define TPS65217_PGOOD_LDO1_PG		BIT(1)
#define TPS65217_PGOOD_LDO2_PG		BIT(0)

#define TPS65217_DEFPG_LDO1PGM		BIT(3)
#define TPS65217_DEFPG_LDO2PGM		BIT(2)
#define TPS65217_DEFPG_PGDLY_MASK	0x03

#define TPS65217_DEFDCDCX_XADJX		BIT(7)
#define TPS65217_DEFDCDCX_DCDC_MASK	0x3F

#define TPS65217_DEFSLEW_GO		BIT(7)
#define TPS65217_DEFSLEW_GODSBL		BIT(6)
#define TPS65217_DEFSLEW_PFM_EN1	BIT(5)
#define TPS65217_DEFSLEW_PFM_EN2	BIT(4)
#define TPS65217_DEFSLEW_PFM_EN3	BIT(3)
#define TPS65217_DEFSLEW_SLEW_MASK	0x07

#define TPS65217_DEFLDO1_LDO1_MASK	0x0F

#define TPS65217_DEFLDO2_TRACK		BIT(6)
#define TPS65217_DEFLDO2_LDO2_MASK	0x3F

#define TPS65217_DEFLDO3_LDO3_EN	BIT(5)
#define TPS65217_DEFLDO3_LDO3_MASK	0x1F

#define TPS65217_DEFLDO4_LDO4_EN	BIT(5)
#define TPS65217_DEFLDO4_LDO4_MASK	0x1F

#define TPS65217_ENABLE_LS1_EN		BIT(6)
#define TPS65217_ENABLE_LS2_EN		BIT(5)
#define TPS65217_ENABLE_DC1_EN		BIT(4)
#define TPS65217_ENABLE_DC2_EN		BIT(3)
#define TPS65217_ENABLE_DC3_EN		BIT(2)
#define TPS65217_ENABLE_LDO1_EN		BIT(1)
#define TPS65217_ENABLE_LDO2_EN		BIT(0)

#define TPS65217_DEFUVLO_UVLOHYS	BIT(2)
#define TPS65217_DEFUVLO_UVLO_MASK	0x03

#define TPS65217_SEQ1_DC1_SEQ_MASK	0xF0
#define TPS65217_SEQ1_DC2_SEQ_MASK	0x0F

#define TPS65217_SEQ2_DC3_SEQ_MASK	0xF0
#define TPS65217_SEQ2_LDO1_SEQ_MASK	0x0F

#define TPS65217_SEQ3_LDO2_SEQ_MASK	0xF0
#define TPS65217_SEQ3_LDO3_SEQ_MASK	0x0F

#define TPS65217_SEQ4_LDO4_SEQ_MASK	0xF0

#define TPS65217_SEQ5_DLY1_MASK		0xC0
#define TPS65217_SEQ5_DLY2_MASK		0x30
#define TPS65217_SEQ5_DLY3_MASK		0x0C
#define TPS65217_SEQ5_DLY4_MASK		0x03

#define TPS65217_SEQ6_DLY5_MASK		0xC0
#define TPS65217_SEQ6_DLY6_MASK		0x30
#define TPS65217_SEQ6_SEQUP		BIT(2)
#define TPS65217_SEQ6_SEQDWN		BIT(1)
#define TPS65217_SEQ6_INSTDWN		BIT(0)

#define TPS65217_MAX_REGISTER		0x1E
#define TPS65217_PROTECT_NONE		0
#define TPS65217_PROTECT_L1		1
#define TPS65217_PROTECT_L2		2


enum tps65217_regulator_id {
	/* DCDC's */
	TPS65217_DCDC_1,
	TPS65217_DCDC_2,
	TPS65217_DCDC_3,
	/* LDOs */
	TPS65217_LDO_1,
	TPS65217_LDO_2,
	TPS65217_LDO_3,
	TPS65217_LDO_4,
};

#define TPS65217_MAX_REG_ID		TPS65217_LDO_4

/* Number of step-down converters available */
#define TPS65217_NUM_DCDC		3
/* Number of LDO voltage regulators available */
#define TPS65217_NUM_LDO		4
/* Number of total regulators available */
#define TPS65217_NUM_REGULATOR		(TPS65217_NUM_DCDC + TPS65217_NUM_LDO)

enum tps65217_bl_isel {
	TPS65217_BL_ISET1 = 1,
	TPS65217_BL_ISET2,
};

enum tps65217_bl_fdim {
	TPS65217_BL_FDIM_100HZ,
	TPS65217_BL_FDIM_200HZ,
	TPS65217_BL_FDIM_500HZ,
	TPS65217_BL_FDIM_1000HZ,
};

struct tps65217_bl_pdata {
	enum tps65217_bl_isel isel;
	enum tps65217_bl_fdim fdim;
	int dft_brightness;
};

/**
 * struct tps65217_board - packages regulator init data
 * @tps65217_regulator_data: regulator initialization values
 *
 * Board data may be used to initialize regulator.
 */
struct tps65217_board {
	struct regulator_init_data *tps65217_init_data[TPS65217_NUM_REGULATOR];
	struct device_node *of_node[TPS65217_NUM_REGULATOR];
	struct tps65217_bl_pdata *bl_pdata;
};

/**
 * struct tps65217 - tps65217 sub-driver chip access routines
 *
 * Device data may be used to access the TPS65217 chip
 */

struct tps65217 {
	struct device *dev;
	struct tps65217_board *pdata;
	unsigned long id;
	struct regulator_desc desc[TPS65217_NUM_REGULATOR];
	struct regmap *regmap;
};

static inline struct tps65217 *dev_to_tps65217(struct device *dev)
{
	return dev_get_drvdata(dev);
}

static inline unsigned long tps65217_chip_id(struct tps65217 *tps65217)
{
	return tps65217->id;
}

int tps65217_reg_read(struct tps65217 *tps, unsigned int reg,
					unsigned int *val);
int tps65217_reg_write(struct tps65217 *tps, unsigned int reg,
			unsigned int val, unsigned int level);
int tps65217_set_bits(struct tps65217 *tps, unsigned int reg,
		unsigned int mask, unsigned int val, unsigned int level);
int tps65217_clear_bits(struct tps65217 *tps, unsigned int reg,
		unsigned int mask, unsigned int level);

#endif /*  __LINUX_MFD_TPS65217_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /* Driver for Realtek RTS5139 USB card reader
 *
 * Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *   Roger Tseng <rogerable@realtek.com>
 */

#ifndef __RTSX_USB_H
#define __RTSX_USB_H

#include <linux/usb.h>

/* related module names */
#define RTSX_USB_SD_CARD	0
#define RTSX_USB_MS_CARD	1

/* endpoint numbers */
#define EP_BULK_OUT		1
#define EP_BULK_IN		2
#define EP_INTR_IN		3

/* USB vendor requests */
#define RTSX_USB_REQ_REG_OP	0x00
#define RTSX_USB_REQ_POLL	0x02

/* miscellaneous parameters */
#define MIN_DIV_N		60
#define MAX_DIV_N		120

#define MAX_PHASE		15
#define RX_TUNING_CNT		3

#define QFN24			0
#define LQFP48			1
#define CHECK_PKG(ucr, pkg)	((ucr)->package == (pkg))

/* data structures */
struct rtsx_ucr {
	u16			vendor_id;
	u16			product_id;

	int			package;
	u8			ic_version;
	bool			is_rts5179;

	unsigned int		cur_clk;

	u8			*cmd_buf;
	unsigned int		cmd_idx;
	u8			*rsp_buf;

	struct usb_device	*pusb_dev;
	struct usb_interface	*pusb_intf;
	struct usb_sg_request	current_sg;
	unsigned char		*iobuf;
	dma_addr_t		iobuf_dma;

	struct timer_list	sg_timer;
	struct mutex		dev_mutex;
};

/* buffer size */
#define IOBUF_SIZE		1024

/* prototypes of exported functions */
extern int rtsx_usb_get_card_status(struct rtsx_ucr *ucr, u16 *status);

extern int rtsx_usb_read_register(struct rtsx_ucr *ucr, u16 addr, u8 *data);
extern int rtsx_usb_write_register(struct rtsx_ucr *ucr, u16 addr, u8 mask,
		u8 data);

extern int rtsx_usb_ep0_write_register(struct rtsx_ucr *ucr, u16 addr, u8 mask,
		u8 data);
extern int rtsx_usb_ep0_read_register(struct rtsx_ucr *ucr, u16 addr,
		u8 *data);

extern void rtsx_usb_add_cmd(struct rtsx_ucr *ucr, u8 cmd_type,
		u16 reg_addr, u8 mask, u8 data);
extern int rtsx_usb_send_cmd(struct rtsx_ucr *ucr, u8 flag, int timeout);
extern int rtsx_usb_get_rsp(struct rtsx_ucr *ucr, int rsp_len, int timeout);
extern int rtsx_usb_transfer_data(struct rtsx_ucr *ucr, unsigned int pipe,
			      void *buf, unsigned int len, int use_sg,
			      unsigned int *act_len, int timeout);

extern int rtsx_usb_read_ppbuf(struct rtsx_ucr *ucr, u8 *buf, int buf_len);
extern int rtsx_usb_write_ppbuf(struct rtsx_ucr *ucr, u8 *buf, int buf_len);
extern int rtsx_usb_switch_clock(struct rtsx_ucr *ucr, unsigned int card_clock,
		u8 ssc_depth, bool initial_mode, bool double_clk, bool vpclk);
extern int rtsx_usb_card_exclusive_check(struct rtsx_ucr *ucr, int card);

/* card status */
#define SD_CD		0x01
#define MS_CD		0x02
#define XD_CD		0x04
#define CD_MASK		(SD_CD | MS_CD | XD_CD)
#define SD_WP		0x08

/* reader command field offset & parameters */
#define READ_REG_CMD		0
#define WRITE_REG_CMD		1
#define CHECK_REG_CMD		2

#define PACKET_TYPE		4
#define CNT_H			5
#define CNT_L			6
#define STAGE_FLAG		7
#define CMD_OFFSET		8
#define SEQ_WRITE_DATA_OFFSET	12

#define BATCH_CMD		0
#define SEQ_READ		1
#define SEQ_WRITE		2

#define STAGE_R			0x01
#define STAGE_DI		0x02
#define STAGE_DO		0x04
#define STAGE_MS_STATUS		0x08
#define STAGE_XD_STATUS		0x10
#define MODE_C			0x00
#define MODE_CR			(STAGE_R)
#define MODE_CDIR		(STAGE_R | STAGE_DI)
#define MODE_CDOR		(STAGE_R | STAGE_DO)

#define EP0_OP_SHIFT		14
#define EP0_READ_REG_CMD	2
#define EP0_WRITE_REG_CMD	3

#define rtsx_usb_cmd_hdr_tag(ucr)		\
	do {					\
		ucr->cmd_buf[0] = 'R';		\
		ucr->cmd_buf[1] = 'T';		\
		ucr->cmd_buf[2] = 'C';		\
		ucr->cmd_buf[3] = 'R';		\
	} while (0)

static inline void rtsx_usb_init_cmd(struct rtsx_ucr *ucr)
{
	rtsx_usb_cmd_hdr_tag(ucr);
	ucr->cmd_idx = 0;
	ucr->cmd_buf[PACKET_TYPE] = BATCH_CMD;
}

/* internal register address */
#define FPDCTL				0xFC00
#define SSC_DIV_N_0			0xFC07
#define SSC_CTL1			0xFC09
#define SSC_CTL2			0xFC0A
#define CFG_MODE			0xFC0E
#define CFG_MODE_1			0xFC0F
#define RCCTL				0xFC14
#define SOF_WDOG			0xFC28
#define SYS_DUMMY0			0xFC30

#define MS_BLKEND			0xFD30
#define MS_READ_START			0xFD31
#define MS_READ_COUNT			0xFD32
#define MS_WRITE_START			0xFD33
#define MS_WRITE_COUNT			0xFD34
#define MS_COMMAND			0xFD35
#define MS_OLD_BLOCK_0			0xFD36
#define MS_OLD_BLOCK_1			0xFD37
#define MS_NEW_BLOCK_0			0xFD38
#define MS_NEW_BLOCK_1			0xFD39
#define MS_LOG_BLOCK_0			0xFD3A
#define MS_LOG_BLOCK_1			0xFD3B
#define MS_BUS_WIDTH			0xFD3C
#define MS_PAGE_START			0xFD3D
#define MS_PAGE_LENGTH			0xFD3E
#define MS_CFG				0xFD40
#define MS_TPC				0xFD41
#define MS_TRANS_CFG			0xFD42
#define MS_TRANSFER			0xFD43
#define MS_INT_REG			0xFD44
#define MS_BYTE_CNT			0xFD45
#define MS_SECTOR_CNT_L			0xFD46
#define MS_SECTOR_CNT_H			0xFD47
#define MS_DBUS_H			0xFD48

#define CARD_DMA1_CTL			0xFD5C
#define CARD_PULL_CTL1			0xFD60
#define CARD_PULL_CTL2			0xFD61
#define CARD_PULL_CTL3			0xFD62
#define CARD_PULL_CTL4			0xFD63
#define CARD_PULL_CTL5			0xFD64
#define CARD_PULL_CTL6			0xFD65
#define CARD_EXIST			0xFD6F
#define CARD_INT_PEND			0xFD71

#define LDO_POWER_CFG			0xFD7B

#define SD_CFG1				0xFDA0
#define SD_CFG2				0xFDA1
#define SD_CFG3				0xFDA2
#define SD_STAT1			0xFDA3
#define SD_STAT2			0xFDA4
#define SD_BUS_STAT			0xFDA5
#define SD_PAD_CTL			0xFDA6
#define SD_SAMPLE_POINT_CTL		0xFDA7
#define SD_PUSH_POINT_CTL		0xFDA8
#define SD_CMD0				0xFDA9
#define SD_CMD1				0xFDAA
#define SD_CMD2				0xFDAB
#define SD_CMD3				0xFDAC
#define SD_CMD4				0xFDAD
#define SD_CMD5				0xFDAE
#define SD_BYTE_CNT_L			0xFDAF
#define SD_BYTE_CNT_H			0xFDB0
#define SD_BLOCK_CNT_L			0xFDB1
#define SD_BLOCK_CNT_H			0xFDB2
#define SD_TRANSFER			0xFDB3
#define SD_CMD_STATE			0xFDB5
#define SD_DATA_STATE			0xFDB6
#define SD_VPCLK0_CTL			0xFC2A
#define SD_VPCLK1_CTL			0xFC2B
#define SD_DCMPS0_CTL			0xFC2C
#define SD_DCMPS1_CTL			0xFC2D

#define CARD_DMA1_CTL			0xFD5C

#define HW_VERSION			0xFC01

#define SSC_CLK_FPGA_SEL		0xFC02
#define CLK_DIV				0xFC03
#define SFSM_ED				0xFC04

#define CD_DEGLITCH_WIDTH		0xFC20
#define CD_DEGLITCH_EN			0xFC21
#define AUTO_DELINK_EN			0xFC23

#define FPGA_PULL_CTL			0xFC1D
#define CARD_CLK_SOURCE			0xFC2E

#define CARD_SHARE_MODE			0xFD51
#define CARD_DRIVE_SEL			0xFD52
#define CARD_STOP			0xFD53
#define CARD_OE				0xFD54
#define CARD_AUTO_BLINK			0xFD55
#define CARD_GPIO			0xFD56
#define SD30_DRIVE_SEL			0xFD57

#define CARD_DATA_SOURCE		0xFD5D
#define CARD_SELECT			0xFD5E

#define CARD_CLK_EN			0xFD79
#define CARD_PWR_CTL			0xFD7A

#define OCPCTL				0xFD80
#define OCPPARA1			0xFD81
#define OCPPARA2			0xFD82
#define OCPSTAT				0xFD83

#define HS_USB_STAT			0xFE01
#define HS_VCONTROL			0xFE26
#define HS_VSTAIN			0xFE27
#define HS_VLOADM			0xFE28
#define HS_VSTAOUT			0xFE29

#define MC_IRQ				0xFF00
#define MC_IRQEN			0xFF01
#define MC_FIFO_CTL			0xFF02
#define MC_FIFO_BC0			0xFF03
#define MC_FIFO_BC1			0xFF04
#define MC_FIFO_STAT			0xFF05
#define MC_FIFO_MODE			0xFF06
#define MC_FIFO_RD_PTR0			0xFF07
#define MC_FIFO_RD_PTR1			0xFF08
#define MC_DMA_CTL			0xFF10
#define MC_DMA_TC0			0xFF11
#define MC_DMA_TC1			0xFF12
#define MC_DMA_TC2			0xFF13
#define MC_DMA_TC3			0xFF14
#define MC_DMA_RST			0xFF15

#define RBUF_SIZE_MASK			0xFBFF
#define RBUF_BASE			0xF000
#define PPBUF_BASE1			0xF800
#define PPBUF_BASE2			0xFA00

/* internal register value macros */
#define POWER_OFF			0x03
#define PARTIAL_POWER_ON		0x02
#define POWER_ON			0x00
#define POWER_MASK			0x03
#define LDO3318_PWR_MASK		0x0C
#define LDO_ON				0x00
#define LDO_SUSPEND			0x08
#define LDO_OFF				0x0C
#define DV3318_AUTO_PWR_OFF		0x10
#define FORCE_LDO_POWERB		0x60

/* LDO_POWER_CFG */
#define TUNE_SD18_MASK			0x1C
#define TUNE_SD18_1V7			0x00
#define TUNE_SD18_1V8			(0x01 << 2)
#define TUNE_SD18_1V9			(0x02 << 2)
#define TUNE_SD18_2V0			(0x03 << 2)
#define TUNE_SD18_2V7			(0x04 << 2)
#define TUNE_SD18_2V8			(0x05 << 2)
#define TUNE_SD18_2V9			(0x06 << 2)
#define TUNE_SD18_3V3			(0x07 << 2)

/* CLK_DIV */
#define CLK_CHANGE			0x80
#define CLK_DIV_1			0x00
#define CLK_DIV_2			0x01
#define CLK_DIV_4			0x02
#define CLK_DIV_8			0x03

#define SSC_POWER_MASK			0x01
#define SSC_POWER_DOWN			0x01
#define SSC_POWER_ON			0x00

#define FPGA_VER			0x80
#define HW_VER_MASK			0x0F

#define EXTEND_DMA1_ASYNC_SIGNAL	0x02

/* CFG_MODE*/
#define XTAL_FREE			0x80
#define CLK_MODE_MASK			0x03
#define CLK_MODE_12M_XTAL		0x00
#define CLK_MODE_NON_XTAL		0x01
#define CLK_MODE_24M_OSC		0x02
#define CLK_MODE_48M_OSC		0x03

/* CFG_MODE_1*/
#define RTS5179				0x02

#define NYET_EN				0x01
#define NYET_MSAK			0x01

#define SD30_DRIVE_MASK			0x07
#define SD20_DRIVE_MASK			0x03

#define DISABLE_SD_CD			0x08
#define DISABLE_MS_CD			0x10
#define DISABLE_XD_CD			0x20
#define SD_CD_DEGLITCH_EN		0x01
#define MS_CD_DEGLITCH_EN		0x02
#define XD_CD_DEGLITCH_EN		0x04

#define	CARD_SHARE_LQFP48		0x04
#define	CARD_SHARE_QFN24		0x00
#define CARD_SHARE_LQFP_SEL		0x04
#define	CARD_SHARE_XD			0x00
#define	CARD_SHARE_SD			0x01
#define	CARD_SHARE_MS			0x02
#define CARD_SHARE_MASK			0x03


/* SD30_DRIVE_SEL */
#define DRIVER_TYPE_A			0x05
#define DRIVER_TYPE_B			0x03
#define DRIVER_TYPE_C			0x02
#define DRIVER_TYPE_D			0x01

/* SD_BUS_STAT */
#define	SD_CLK_TOGGLE_EN		0x80
#define	SD_CLK_FORCE_STOP	        0x40
#define	SD_DAT3_STATUS		        0x10
#define	SD_DAT2_STATUS		        0x08
#define	SD_DAT1_STATUS		        0x04
#define	SD_DAT0_STATUS		        0x02
#define	SD_CMD_STATUS			0x01

/* SD_PAD_CTL */
#define	SD_IO_USING_1V8		        0x80
#define	SD_IO_USING_3V3		        0x7F
#define	TYPE_A_DRIVING		        0x00
#define	TYPE_B_DRIVING			0x01
#define	TYPE_C_DRIVING			0x02
#define	TYPE_D_DRIVING		        0x03

/* CARD_CLK_EN */
#define SD_CLK_EN			0x04
#define MS_CLK_EN			0x08

/* CARD_SELECT */
#define SD_MOD_SEL			2
#define MS_MOD_SEL			3

/* CARD_SHARE_MODE */
#define	CARD_SHARE_LQFP48		0x04
#define	CARD_SHARE_QFN24		0x00
#define CARD_SHARE_LQFP_SEL		0x04
#define	CARD_SHARE_XD			0x00
#define	CARD_SHARE_SD			0x01
#define	CARD_SHARE_MS			0x02
#define CARD_SHARE_MASK			0x03

/* SSC_CTL1 */
#define SSC_RSTB			0x80
#define SSC_8X_EN			0x40
#define SSC_FIX_FRAC			0x20
#define SSC_SEL_1M			0x00
#define SSC_SEL_2M			0x08
#define SSC_SEL_4M			0x10
#define SSC_SEL_8M			0x18

/* SSC_CTL2 */
#define SSC_DEPTH_MASK			0x03
#define SSC_DEPTH_DISALBE		0x00
#define SSC_DEPTH_2M			0x01
#define SSC_DEPTH_1M			0x02
#define SSC_DEPTH_512K			0x03

/* SD_VPCLK0_CTL */
#define PHASE_CHANGE			0x80
#define PHASE_NOT_RESET			0x40

/* SD_TRANSFER */
#define	SD_TRANSFER_START		0x80
#define	SD_TRANSFER_END			0x40
#define SD_STAT_IDLE			0x20
#define	SD_TRANSFER_ERR			0x10
#define	SD_TM_NORMAL_WRITE		0x00
#define	SD_TM_AUTO_WRITE_3		0x01
#define	SD_TM_AUTO_WRITE_4		0x02
#define	SD_TM_AUTO_READ_3		0x05
#define	SD_TM_AUTO_READ_4		0x06
#define	SD_TM_CMD_RSP			0x08
#define	SD_TM_AUTO_WRITE_1		0x09
#define	SD_TM_AUTO_WRITE_2		0x0A
#define	SD_TM_NORMAL_READ		0x0C
#define	SD_TM_AUTO_READ_1		0x0D
#define	SD_TM_AUTO_READ_2		0x0E
#define	SD_TM_AUTO_TUNING		0x0F

/* SD_CFG1 */
#define SD_CLK_DIVIDE_0			0x00
#define	SD_CLK_DIVIDE_256		0xC0
#define	SD_CLK_DIVIDE_128		0x80
#define SD_CLK_DIVIDE_MASK		0xC0
#define	SD_BUS_WIDTH_1BIT		0x00
#define	SD_BUS_WIDTH_4BIT		0x01
#define	SD_BUS_WIDTH_8BIT		0x02
#define	SD_ASYNC_FIFO_RST		0x10
#define	SD_20_MODE			0x00
#define	SD_DDR_MODE			0x04
#define	SD_30_MODE			0x08

/* SD_CFG2 */
#define	SD_CALCULATE_CRC7		0x00
#define	SD_NO_CALCULATE_CRC7		0x80
#define	SD_CHECK_CRC16			0x00
#define	SD_NO_CHECK_CRC16		0x40
#define SD_WAIT_CRC_TO_EN		0x20
#define	SD_WAIT_BUSY_END		0x08
#define	SD_NO_WAIT_BUSY_END		0x00
#define	SD_CHECK_CRC7			0x00
#define	SD_NO_CHECK_CRC7		0x04
#define	SD_RSP_LEN_0			0x00
#define	SD_RSP_LEN_6			0x01
#define	SD_RSP_LEN_17			0x02
#define	SD_RSP_TYPE_R0			0x04
#define	SD_RSP_TYPE_R1			0x01
#define	SD_RSP_TYPE_R1b			0x09
#define	SD_RSP_TYPE_R2			0x02
#define	SD_RSP_TYPE_R3			0x05
#define	SD_RSP_TYPE_R4			0x05
#define	SD_RSP_TYPE_R5			0x01
#define	SD_RSP_TYPE_R6			0x01
#define	SD_RSP_TYPE_R7			0x01

/* SD_STAT1 */
#define	SD_CRC7_ERR			0x80
#define	SD_CRC16_ERR			0x40
#define	SD_CRC_WRITE_ERR		0x20
#define	SD_CRC_WRITE_ERR_MASK		0x1C
#define	GET_CRC_TIME_OUT		0x02
#define	SD_TUNING_COMPARE_ERR		0x01

/* SD_DATA_STATE */
#define SD_DATA_IDLE			0x80

/* CARD_DATA_SOURCE */
#define PINGPONG_BUFFER			0x01
#define RING_BUFFER			0x00

/* CARD_OE */
#define SD_OUTPUT_EN			0x04
#define MS_OUTPUT_EN			0x08

/* CARD_STOP */
#define SD_STOP				0x04
#define MS_STOP				0x08
#define SD_CLR_ERR			0x40
#define MS_CLR_ERR			0x80

/* CARD_CLK_SOURCE */
#define CRC_FIX_CLK			(0x00 << 0)
#define CRC_VAR_CLK0			(0x01 << 0)
#define CRC_VAR_CLK1			(0x02 << 0)
#define SD30_FIX_CLK			(0x00 << 2)
#define SD30_VAR_CLK0			(0x01 << 2)
#define SD30_VAR_CLK1			(0x02 << 2)
#define SAMPLE_FIX_CLK			(0x00 << 4)
#define SAMPLE_VAR_CLK0			(0x01 << 4)
#define SAMPLE_VAR_CLK1			(0x02 << 4)

/* SD_SAMPLE_POINT_CTL */
#define	DDR_FIX_RX_DAT			0x00
#define	DDR_VAR_RX_DAT			0x80
#define	DDR_FIX_RX_DAT_EDGE		0x00
#define	DDR_FIX_RX_DAT_14_DELAY		0x40
#define	DDR_FIX_RX_CMD			0x00
#define	DDR_VAR_RX_CMD			0x20
#define	DDR_FIX_RX_CMD_POS_EDGE		0x00
#define	DDR_FIX_RX_CMD_14_DELAY		0x10
#define	SD20_RX_POS_EDGE		0x00
#define	SD20_RX_14_DELAY		0x08
#define SD20_RX_SEL_MASK		0x08

/* SD_PUSH_POINT_CTL */
#define	DDR_FIX_TX_CMD_DAT		0x00
#define	DDR_VAR_TX_CMD_DAT		0x80
#define	DDR_FIX_TX_DAT_14_TSU		0x00
#define	DDR_FIX_TX_DAT_12_TSU		0x40
#define	DDR_FIX_TX_CMD_NEG_EDGE		0x00
#define	DDR_FIX_TX_CMD_14_AHEAD		0x20
#define	SD20_TX_NEG_EDGE		0x00
#define	SD20_TX_14_AHEAD		0x10
#define SD20_TX_SEL_MASK		0x10
#define	DDR_VAR_SDCLK_POL_SWAP		0x01

/* MS_CFG */
#define	SAMPLE_TIME_RISING		0x00
#define	SAMPLE_TIME_FALLING		0x80
#define	PUSH_TIME_DEFAULT		0x00
#define	PUSH_TIME_ODD			0x40
#define	NO_EXTEND_TOGGLE		0x00
#define	EXTEND_TOGGLE_CHK		0x20
#define	MS_BUS_WIDTH_1			0x00
#define	MS_BUS_WIDTH_4			0x10
#define	MS_BUS_WIDTH_8			0x18
#define	MS_2K_SECTOR_MODE		0x04
#define	MS_512_SECTOR_MODE		0x00
#define	MS_TOGGLE_TIMEOUT_EN		0x00
#define	MS_TOGGLE_TIMEOUT_DISEN		0x01
#define MS_NO_CHECK_INT			0x02

/* MS_TRANS_CFG */
#define	WAIT_INT			0x80
#define	NO_WAIT_INT			0x00
#define	NO_AUTO_READ_INT_REG		0x00
#define	AUTO_READ_INT_REG		0x40
#define	MS_CRC16_ERR			0x20
#define	MS_RDY_TIMEOUT			0x10
#define	MS_INT_CMDNK			0x08
#define	MS_INT_BREQ			0x04
#define	MS_INT_ERR			0x02
#define	MS_INT_CED			0x01

/* MS_TRANSFER */
#define	MS_TRANSFER_START		0x80
#define	MS_TRANSFER_END			0x40
#define	MS_TRANSFER_ERR			0x20
#define	MS_BS_STATE			0x10
#define	MS_TM_READ_BYTES		0x00
#define	MS_TM_NORMAL_READ		0x01
#define	MS_TM_WRITE_BYTES		0x04
#define	MS_TM_NORMAL_WRITE		0x05
#define	MS_TM_AUTO_READ			0x08
#define	MS_TM_AUTO_WRITE		0x0C
#define MS_TM_SET_CMD			0x06
#define MS_TM_COPY_PAGE			0x07
#define MS_TM_MULTI_READ		0x02
#define MS_TM_MULTI_WRITE		0x03

/* MC_FIFO_CTL */
#define FIFO_FLUSH			0x01

/* MC_DMA_RST */
#define DMA_RESET  0x01

/* MC_DMA_CTL */
#define DMA_TC_EQ_0			0x80
#define DMA_DIR_TO_CARD			0x00
#define DMA_DIR_FROM_CARD		0x02
#define DMA_EN				0x01
#define DMA_128				(0 << 2)
#define DMA_256				(1 << 2)
#define DMA_512				(2 << 2)
#define DMA_1024			(3 << 2)
#define DMA_PACK_SIZE_MASK		0x0C

/* CARD_INT_PEND */
#define XD_INT				0x10
#define MS_INT				0x08
#define SD_INT				0x04

/* LED operations*/
static inline int rtsx_usb_turn_on_led(struct rtsx_ucr *ucr)
{
	return  rtsx_usb_ep0_write_register(ucr, CARD_GPIO, 0x03, 0x02);
}

static inline int rtsx_usb_turn_off_led(struct rtsx_ucr *ucr)
{
	return rtsx_usb_ep0_write_register(ucr, CARD_GPIO, 0x03, 0x03);
}

/* HW error clearing */
static inline void rtsx_usb_clear_fsm_err(struct rtsx_ucr *ucr)
{
	rtsx_usb_ep0_write_register(ucr, SFSM_ED, 0xf8, 0xf8);
}

static inline void rtsx_usb_clear_dma_err(struct rtsx_ucr *ucr)
{
	rtsx_usb_ep0_write_register(ucr, MC_FIFO_CTL,
			FIFO_FLUSH, FIFO_FLUSH);
	rtsx_usb_ep0_write_register(ucr, MC_DMA_RST, DMA_RESET, DMA_RESET);
}
#endif /* __RTS51139_H */
                                                  /*
 * Functions and registers to access AXP20X power management chip.
 *
 * Copyright (C) 2013, Carlo Caione <carlo@caione.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef __LINUX_MFD_AXP20X_H
#define __LINUX_MFD_AXP20X_H

enum {
	AXP202_ID = 0,
	AXP209_ID,
	AXP288_ID,
	NR_AXP20X_VARIANTS,
};

#define AXP20X_DATACACHE(m)		(0x04 + (m))

/* Power supply */
#define AXP20X_PWR_INPUT_STATUS		0x00
#define AXP20X_PWR_OP_MODE		0x01
#define AXP20X_USB_OTG_STATUS		0x02
#define AXP20X_PWR_OUT_CTRL		0x12
#define AXP20X_DCDC2_V_OUT		0x23
#define AXP20X_DCDC2_LDO3_V_SCAL	0x25
#define AXP20X_DCDC3_V_OUT		0x27
#define AXP20X_LDO24_V_OUT		0x28
#define AXP20X_LDO3_V_OUT		0x29
#define AXP20X_VBUS_IPSOUT_MGMT		0x30
#define AXP20X_V_OFF			0x31
#define AXP20X_OFF_CTRL			0x32
#define AXP20X_CHRG_CTRL1		0x33
#define AXP20X_CHRG_CTRL2		0x34
#define AXP20X_CHRG_BAK_CTRL		0x35
#define AXP20X_PEK_KEY			0x36
#define AXP20X_DCDC_FREQ		0x37
#define AXP20X_V_LTF_CHRG		0x38
#define AXP20X_V_HTF_CHRG		0x39
#define AXP20X_APS_WARN_L1		0x3a
#define AXP20X_APS_WARN_L2		0x3b
#define AXP20X_V_LTF_DISCHRG		0x3c
#define AXP20X_V_HTF_DISCHRG		0x3d

/* Interrupt */
#define AXP20X_IRQ1_EN			0x40
#define AXP20X_IRQ2_EN			0x41
#define AXP20X_IRQ3_EN			0x42
#define AXP20X_IRQ4_EN			0x43
#define AXP20X_IRQ5_EN			0x44
#define AXP20X_IRQ6_EN			0x45
#define AXP20X_IRQ1_STATE		0x48
#define AXP20X_IRQ2_STATE		0x49
#define AXP20X_IRQ3_STATE		0x4a
#define AXP20X_IRQ4_STATE		0x4b
#define AXP20X_IRQ5_STATE		0x4c
#define AXP20X_IRQ6_STATE		0x4d

/* ADC */
#define AXP20X_ACIN_V_ADC_H		0x56
#define AXP20X_ACIN_V_ADC_L		0x57
#define AXP20X_ACIN_I_ADC_H		0x58
#define AXP20X_ACIN_I_ADC_L		0x59
#define AXP20X_VBUS_V_ADC_H		0x5a
#define AXP20X_VBUS_V_ADC_L		0x5b
#define AXP20X_VBUS_I_ADC_H		0x5c
#define AXP20X_VBUS_I_ADC_L		0x5d
#define AXP20X_TEMP_ADC_H		0x5e
#define AXP20X_TEMP_ADC_L		0x5f
#define AXP20X_TS_IN_H			0x62
#define AXP20X_TS_IN_L			0x63
#define AXP20X_GPIO0_V_ADC_H		0x64
#define AXP20X_GPIO0_V_ADC_L		0x65
#define AXP20X_GPIO1_V_ADC_H		0x66
#define AXP20X_GPIO1_V_ADC_L		0x67
#define AXP20X_PWR_BATT_H		0x70
#define AXP20X_PWR_BATT_M		0x71
#define AXP20X_PWR_BATT_L		0x72
#define AXP20X_BATT_V_H			0x78
#define AXP20X_BATT_V_L			0x79
#define AXP20X_BATT_CHRG_I_H		0x7a
#define AXP20X_BATT_CHRG_I_L		0x7b
#define AXP20X_BATT_DISCHRG_I_H		0x7c
#define AXP20X_BATT_DISCHRG_I_L		0x7d
#define AXP20X_IPSOUT_V_HIGH_H		0x7e
#define AXP20X_IPSOUT_V_HIGH_L		0x7f

/* Power supply */
#define AXP20X_DCDC_MODE		0x80
#define AXP20X_ADC_EN1			0x82
#define AXP20X_ADC_EN2			0x83
#define AXP20X_ADC_RATE			0x84
#define AXP20X_GPIO10_IN_RANGE		0x85
#define AXP20X_GPIO1_ADC_IRQ_RIS	0x86
#define AXP20X_GPIO1_ADC_IRQ_FAL	0x87
#define AXP20X_TIMER_CTRL		0x8a
#define AXP20X_VBUS_MON			0x8b
#define AXP20X_OVER_TMP			0x8f

/* GPIO */
#define AXP20X_GPIO0_CTRL		0x90
#define AXP20X_LDO5_V_OUT		0x91
#define AXP20X_GPIO1_CTRL		0x92
#define AXP20X_GPIO2_CTRL		0x93
#define AXP20X_GPIO20_SS		0x94
#define AXP20X_GPIO3_CTRL		0x95

/* Battery */
#define AXP20X_CHRG_CC_31_24		0xb0
#define AXP20X_CHRG_CC_23_16		0xb1
#define AXP20X_CHRG_CC_15_8		0xb2
#define AXP20X_CHRG_CC_7_0		0xb3
#define AXP20X_DISCHRG_CC_31_24		0xb4
#define AXP20X_DISCHRG_CC_23_16		0xb5
#define AXP20X_DISCHRG_CC_15_8		0xb6
#define AXP20X_DISCHRG_CC_7_0		0xb7
#define AXP20X_CC_CTRL			0xb8
#define AXP20X_FG_RES			0xb9

/* AXP288 specific registers */
#define AXP288_PMIC_ADC_H               0x56
#define AXP288_PMIC_ADC_L               0x57
#define AXP288_ADC_TS_PIN_CTRL          0x84
#define AXP288_PMIC_ADC_EN              0x84

/* Fuel Gauge */
#define AXP288_FG_RDC1_REG          0xba
#define AXP288_FG_RDC0_REG          0xbb
#define AXP288_FG_OCVH_REG          0xbc
#define AXP288_FG_OCVL_REG          0xbd
#define AXP288_FG_OCV_CURVE_REG     0xc0
#define AXP288_FG_DES_CAP1_REG      0xe0
#define AXP288_FG_DES_CAP0_REG      0xe1
#define AXP288_FG_CC_MTR1_REG       0xe2
#define AXP288_FG_CC_MTR0_REG       0xe3
#define AXP288_FG_OCV_CAP_REG       0xe4
#define AXP288_FG_CC_CAP_REG        0xe5
#define AXP288_FG_LOW_CAP_REG       0xe6
#define AXP288_FG_TUNE0             0xe8
#define AXP288_FG_TUNE1             0xe9
#define AXP288_FG_TUNE2             0xea
#define AXP288_FG_TUNE3             0xeb
#define AXP288_FG_TUNE4             0xec
#define AXP288_FG_TUNE5             0xed

/* Regulators IDs */
enum {
	AXP20X_LDO1 = 0,
	AXP20X_LDO2,
	AXP20X_LDO3,
	AXP20X_LDO4,
	AXP20X_LDO5,
	AXP20X_DCDC2,
	AXP20X_DCDC3,
	AXP20X_REG_ID_MAX,
};

/* IRQs */
enum {
	AXP20X_IRQ_ACIN_OVER_V = 1,
	AXP20X_IRQ_ACIN_PLUGIN,
	AXP20X_IRQ_ACIN_REMOVAL,
	AXP20X_IRQ_VBUS_OVER_V,
	AXP20X_IRQ_VBUS_PLUGIN,
	AXP20X_IRQ_VBUS_REMOVAL,
	AXP20X_IRQ_VBUS_V_LOW,
	AXP20X_IRQ_BATT_PLUGIN,
	AXP20X_IRQ_BATT_REMOVAL,
	AXP20X_IRQ_BATT_ENT_ACT_MODE,
	AXP20X_IRQ_BATT_EXIT_ACT_MODE,
	AXP20X_IRQ_CHARG,
	AXP20X_IRQ_CHARG_DONE,
	AXP20X_IRQ_BATT_TEMP_HIGH,
	AXP20X_IRQ_BATT_TEMP_LOW,
	AXP20X_IRQ_DIE_TEMP_HIGH,
	AXP20X_IRQ_CHARG_I_LOW,
	AXP20X_IRQ_DCDC1_V_LONG,
	AXP20X_IRQ_DCDC2_V_LONG,
	AXP20X_IRQ_DCDC3_V_LONG,
	AXP20X_IRQ_PEK_SHORT = 22,
	AXP20X_IRQ_PEK_LONG,
	AXP20X_IRQ_N_OE_PWR_ON,
	AXP20X_IRQ_N_OE_PWR_OFF,
	AXP20X_IRQ_VBUS_VALID,
	AXP20X_IRQ_VBUS_NOT_VALID,
	AXP20X_IRQ_VBUS_SESS_VALID,
	AXP20X_IRQ_VBUS_SESS_END,
	AXP20X_IRQ_LOW_PWR_LVL1,
	AXP20X_IRQ_LOW_PWR_LVL2,
	AXP20X_IRQ_TIMER,
	AXP20X_IRQ_PEK_RIS_EDGE,
	AXP20X_IRQ_PEK_FAL_EDGE,
	AXP20X_IRQ_GPIO3_INPUT,
	AXP20X_IRQ_GPIO2_INPUT,
	AXP20X_IRQ_GPIO1_INPUT,
	AXP20X_IRQ_GPIO0_INPUT,
};

enum axp288_irqs {
	AXP288_IRQ_VBUS_FALL     = 2,
	AXP288_IRQ_VBUS_RISE,
	AXP288_IRQ_OV,
	AXP288_IRQ_FALLING_ALT,
	AXP288_IRQ_RISING_ALT,
	AXP288_IRQ_OV_ALT,
	AXP288_IRQ_DONE          = 10,
	AXP288_IRQ_CHARGING,
	AXP288_IRQ_SAFE_QUIT,
	AXP288_IRQ_SAFE_ENTER,
	AXP288_IRQ_ABSENT,
	AXP288_IRQ_APPEND,
	AXP288_IRQ_QWBTU,
	AXP288_IRQ_WBTU,
	AXP288_IRQ_QWBTO,
	AXP288_IRQ_WBTO,
	AXP288_IRQ_QCBTU,
	AXP288_IRQ_CBTU,
	AXP288_IRQ_QCBTO,
	AXP288_IRQ_CBTO,
	AXP288_IRQ_WL2,
	AXP288_IRQ_WL1,
	AXP288_IRQ_GPADC,
	AXP288_IRQ_OT            = 31,
	AXP288_IRQ_GPIO0,
	AXP288_IRQ_GPIO1,
	AXP288_IRQ_POKO,
	AXP288_IRQ_POKL,
	AXP288_IRQ_POKS,
	AXP288_IRQ_POKN,
	AXP288_IRQ_POKP,
	AXP288_IRQ_TIMER,
	AXP288_IRQ_MV_CHNG,
	AXP288_IRQ_BC_USB_CHNG,
};

#define AXP288_TS_ADC_H		0x58
#define AXP288_TS_ADC_L		0x59
#define AXP288_GP_ADC_H		0x5a
#define AXP288_GP_ADC_L		0x5b

struct axp20x_dev {
	struct device			*dev;
	struct i2c_client		*i2c_client;
	struct regmap			*regmap;
	struct regmap_irq_chip_data	*regmap_irqc;
	long				variant;
	int                             nr_cells;
	struct mfd_cell                 *cells;
	const struct regmap_config	*regmap_cfg;
	const struct regmap_irq_chip	*regmap_irq_chip;
};

#define BATTID_LEN				64
#define OCV_CURVE_SIZE			32
#define MAX_THERM_CURVE_SIZE	25
#define PD_DEF_MIN_TEMP			0
#define PD_DEF_MAX_TEMP			55

struct axp20x_fg_pdata {
	char battid[BATTID_LEN + 1];
	int design_cap;
	int min_volt;
	int max_volt;
	int max_temp;
	int min_temp;
	int cap1;
	int cap0;
	int rdc1;
	int rdc0;
	int ocv_curve[OCV_CURVE_SIZE];
	int tcsz;
	int thermistor_curve[MAX_THERM_CURVE_SIZE][2];
};

#endif /* __LINUX_MFD_AXP20X_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * Broadcom BCM590xx PMU
 *
 * Copyright 2014 Linaro Limited
 * Author: Matt Porter <mporter@linaro.org>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under  the terms of the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the License, or (at your
 * option) any later version.
 *
 */

#ifndef __LINUX_MFD_BCM590XX_H
#define __LINUX_MFD_BCM590XX_H

#include <linux/device.h>
#include <linux/i2c.h>
#include <linux/regmap.h>

/* max register address */
#define BCM590XX_MAX_REGISTER_PRI	0xe7
#define BCM590XX_MAX_REGISTER_SEC	0xf0

struct bcm590xx {
	struct device *dev;
	struct i2c_client *i2c_pri;
	struct i2c_client *i2c_sec;
	struct regmap *regmap_pri;
	struct regmap *regmap_sec;
	unsigned int id;
};

#endif /*  __LINUX_MFD_BCM590XX_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * MFD core driver for the RT5033
 *
 * Copyright (C) 2014 Samsung Electronics
 * Author: Beomho Seo <beomho.seo@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published bythe Free Software Foundation.
 */

#ifndef __RT5033_H__
#define __RT5033_H__

#include <linux/regulator/consumer.h>
#include <linux/i2c.h>
#include <linux/regmap.h>
#include <linux/power_supply.h>

/* RT5033 regulator IDs */
enum rt5033_regulators {
	RT5033_BUCK = 0,
	RT5033_LDO,
	RT5033_SAFE_LDO,

	RT5033_REGULATOR_NUM,
};

struct rt5033_dev {
	struct device *dev;

	struct regmap *regmap;
	struct regmap_irq_chip_data *irq_data;
	int irq;
	bool wakeup;
};

struct rt5033_battery {
	struct i2c_client	*client;
	struct rt5033_dev	*rt5033;
	struct regmap		*regmap;
	struct power_supply	*psy;
};

/* RT5033 charger platform data */
struct rt5033_charger_data {
	unsigned int pre_uamp;
	unsigned int pre_uvolt;
	unsigned int const_uvolt;
	unsigned int eoc_uamp;
	unsigned int fast_uamp;
};

struct rt5033_charger {
	struct device		*dev;
	struct rt5033_dev	*rt5033;
	struct power_supply	psy;

	struct rt5033_charger_data	*chg;
};

#endif /* __RT5033_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * MFD core driver for Richtek RT5033
 *
 * Copyright (C) 2014 Samsung Electronics, Co., Ltd.
 * Author: Beomho Seo <beomho.seo@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published bythe Free Software Foundation.
 */

#ifndef __RT5033_PRIVATE_H__
#define __RT5033_PRIVATE_H__

enum rt5033_reg {
	RT5033_REG_CHG_STAT		= 0x00,
	RT5033_REG_CHG_CTRL1		= 0x01,
	RT5033_REG_CHG_CTRL2		= 0x02,
	RT5033_REG_DEVICE_ID		= 0x03,
	RT5033_REG_CHG_CTRL3		= 0x04,
	RT5033_REG_CHG_CTRL4		= 0x05,
	RT5033_REG_CHG_CTRL5		= 0x06,
	RT5033_REG_RT_CTRL0		= 0x07,
	RT5033_REG_CHG_RESET		= 0x08,
	/* Reserved 0x09~0x18 */
	RT5033_REG_RT_CTRL1		= 0x19,
	/* Reserved 0x1A~0x20 */
	RT5033_REG_FLED_FUNCTION1	= 0x21,
	RT5033_REG_FLED_FUNCTION2	= 0x22,
	RT5033_REG_FLED_STROBE_CTRL1	= 0x23,
	RT5033_REG_FLED_STROBE_CTRL2	= 0x24,
	RT5033_REG_FLED_CTRL1		= 0x25,
	RT5033_REG_FLED_CTRL2		= 0x26,
	RT5033_REG_FLED_CTRL3		= 0x27,
	RT5033_REG_FLED_CTRL4		= 0x28,
	RT5033_REG_FLED_CTRL5		= 0x29,
	/* Reserved 0x2A~0x40 */
	RT5033_REG_CTRL			= 0x41,
	RT5033_REG_BUCK_CTRL		= 0x42,
	RT5033_REG_LDO_CTRL		= 0x43,
	/* Reserved 0x44~0x46 */
	RT5033_REG_MANUAL_RESET_CTRL	= 0x47,
	/* Reserved 0x48~0x5F */
	RT5033_REG_CHG_IRQ1		= 0x60,
	RT5033_REG_CHG_IRQ2		= 0x61,
	RT5033_REG_CHG_IRQ3		= 0x62,
	RT5033_REG_CHG_IRQ1_CTRL	= 0x63,
	RT5033_REG_CHG_IRQ2_CTRL	= 0x64,
	RT5033_REG_CHG_IRQ3_CTRL	= 0x65,
	RT5033_REG_LED_IRQ_STAT		= 0x66,
	RT5033_REG_LED_IRQ_CTRL		= 0x67,
	RT5033_REG_PMIC_IRQ_STAT	= 0x68,
	RT5033_REG_PMIC_IRQ_CTRL	= 0x69,
	RT5033_REG_SHDN_CTRL		= 0x6A,
	RT5033_REG_OFF_EVENT		= 0x6B,

	RT5033_REG_END,
};

/* RT5033 Charger state register */
#define RT5033_CHG_STAT_MASK		0x20
#define RT5033_CHG_STAT_DISCHARGING	0x00
#define RT5033_CHG_STAT_FULL		0x10
#define RT5033_CHG_STAT_CHARGING	0x20
#define RT5033_CHG_STAT_NOT_CHARGING	0x30
#define RT5033_CHG_STAT_TYPE_MASK	0x60
#define RT5033_CHG_STAT_TYPE_PRE	0x20
#define RT5033_CHG_STAT_TYPE_FAST	0x60

/* RT5033 CHGCTRL1 register */
#define RT5033_CHGCTRL1_IAICR_MASK	0xe0
#define RT5033_CHGCTRL1_MODE_MASK	0x01

/* RT5033 CHGCTRL2 register */
#define RT5033_CHGCTRL2_CV_MASK		0xfc

/* RT5033 CHGCTRL3 register */
#define RT5033_CHGCTRL3_CFO_EN_MASK	0x40
#define RT5033_CHGCTRL3_TIMER_MASK	0x38
#define RT5033_CHGCTRL3_TIMER_EN_MASK	0x01

/* RT5033 CHGCTRL4 register */
#define RT5033_CHGCTRL4_EOC_MASK	0x07
#define RT5033_CHGCTRL4_IPREC_MASK	0x18

/* RT5033 CHGCTRL5 register */
#define RT5033_CHGCTRL5_VPREC_MASK	0x0f
#define RT5033_CHGCTRL5_ICHG_MASK	0xf0
#define RT5033_CHGCTRL5_ICHG_SHIFT	0x04
#define RT5033_CHG_MAX_CURRENT		0x0d

/* RT5033 RT CTRL1 register */
#define RT5033_RT_CTRL1_UUG_MASK	0x02
#define RT5033_RT_HZ_MASK		0x01

/* RT5033 control register */
#define RT5033_CTRL_FCCM_BUCK_MASK		0x00
#define RT5033_CTRL_BUCKOMS_MASK		0x01
#define RT5033_CTRL_LDOOMS_MASK			0x02
#define RT5033_CTRL_SLDOOMS_MASK		0x03
#define RT5033_CTRL_EN_BUCK_MASK		0x04
#define RT5033_CTRL_EN_LDO_MASK			0x05
#define RT5033_CTRL_EN_SAFE_LDO_MASK		0x06
#define RT5033_CTRL_LDO_SLEEP_MASK		0x07

/* RT5033 BUCK control register */
#define RT5033_BUCK_CTRL_MASK			0x1f

/* RT5033 LDO control register */
#define RT5033_LDO_CTRL_MASK			0x1f

/* RT5033 charger property - model, manufacturer */

#define RT5033_CHARGER_MODEL	"RT5033WSC Charger"
#define RT5033_MANUFACTURER	"Richtek Technology Corporation"

/*
 * RT5033 charger fast-charge current lmits (as in CHGCTRL1 register),
 * AICR mode limits the input current for example,
 * the AIRC 100 mode limits the input current to 100 mA.
 */
#define RT5033_AICR_100_MODE			0x20
#define RT5033_AICR_500_MODE			0x40
#define RT5033_AICR_700_MODE			0x60
#define RT5033_AICR_900_MODE			0x80
#define RT5033_AICR_1500_MODE			0xc0
#define RT5033_AICR_2000_MODE			0xe0
#define RT5033_AICR_MODE_MASK			0xe0

/* RT5033 use internal timer need to set time */
#define RT5033_FAST_CHARGE_TIMER4		0x00
#define RT5033_FAST_CHARGE_TIMER6		0x01
#define RT5033_FAST_CHARGE_TIMER8		0x02
#define RT5033_FAST_CHARGE_TIMER9		0x03
#define RT5033_FAST_CHARGE_TIMER12		0x04
#define RT5033_FAST_CHARGE_TIMER14		0x05
#define RT5033_FAST_CHARGE_TIMER16		0x06

#define RT5033_INT_TIMER_ENABLE			0x01

/* RT5033 charger termination enable mask */
#define RT5033_TE_ENABLE_MASK			0x08

/*
 * RT5033 charger opa mode. RT50300 have two opa mode charger mode
 * and boost mode for OTG
 */

#define RT5033_CHARGER_MODE			0x00
#define RT5033_BOOST_MODE			0x01

/* RT5033 charger termination enable */
#define RT5033_TE_ENABLE			0x08

/* RT5033 charger CFO enable */
#define RT5033_CFO_ENABLE			0x40

/* RT5033 charger constant charge voltage (as in CHGCTRL2 register), uV */
#define RT5033_CHARGER_CONST_VOLTAGE_LIMIT_MIN	3650000U
#define RT5033_CHARGER_CONST_VOLTAGE_STEP_NUM   25000U
#define RT5033_CHARGER_CONST_VOLTAGE_LIMIT_MAX	4400000U

/* RT5033 charger pre-charge current limits (as in CHGCTRL4 register), uA */
#define RT5033_CHARGER_PRE_CURRENT_LIMIT_MIN	350000U
#define RT5033_CHARGER_PRE_CURRENT_STEP_NUM	100000U
#define RT5033_CHARGER_PRE_CURRENT_LIMIT_MAX	650000U

/* RT5033 charger fast-charge current (as in CHGCTRL5 register), uA */
#define RT5033_CHARGER_FAST_CURRENT_MIN		700000U
#define RT5033_CHARGER_FAST_CURRENT_STEP_NUM	100000U
#define RT5033_CHARGER_FAST_CURRENT_MAX		2000000U

/*
 * RT5033 charger const-charge end of charger current (
 * as in CHGCTRL4 register), uA
 */
#define RT5033_CHARGER_EOC_MIN			150000U
#define RT5033_CHARGER_EOC_REF			300000U
#define RT5033_CHARGER_EOC_STEP_NUM1		50000U
#define RT5033_CHARGER_EOC_STEP_NUM2		100000U
#define RT5033_CHARGER_EOC_MAX			600000U

/*
 * RT5033 charger pre-charge threshold volt limits
 * (as in CHGCTRL5 register), uV
 */

#define RT5033_CHARGER_PRE_THRESHOLD_LIMIT_MIN	2300000U
#define RT5033_CHARGER_PRE_THRESHOLD_STEP_NUM	100000U
#define RT5033_CHARGER_PRE_THRESHOLD_LIMIT_MAX	3800000U

/*
 * RT5033 charger enable UUG, If UUG enable MOS auto control by H/W charger
 * circuit.
 */
#define RT5033_CHARGER_UUG_ENABLE		0x02

/* RT5033 charger High impedance mode */
#define RT5033_CHARGER_HZ_DISABLE		0x00
#define RT5033_CHARGER_HZ_ENABLE		0x01

/* RT5033 regulator BUCK output voltage uV */
#define RT5033_REGULATOR_BUCK_VOLTAGE_MIN		1000000U
#define RT5033_REGULATOR_BUCK_VOLTAGE_MAX		3000000U
#define RT5033_REGULATOR_BUCK_VOLTAGE_STEP		100000U
#define RT5033_REGULATOR_BUCK_VOLTAGE_STEP_NUM		32

/* RT5033 regulator LDO output voltage uV */
#define RT5033_REGULATOR_LDO_VOLTAGE_MIN		1200000U
#define RT5033_REGULATOR_LDO_VOLTAGE_MAX		3000000U
#define RT5033_REGULATOR_LDO_VOLTAGE_STEP		100000U
#define RT5033_REGULATOR_LDO_VOLTAGE_STEP_NUM		32

/* RT5033 regulator SAFE LDO output voltage uV */
#define RT5033_REGULATOR_SAFE_LDO_VOLTAGE		4900000U

enum rt5033_fuel_reg {
	RT5033_FUEL_REG_OCV_H		= 0x00,
	RT5033_FUEL_REG_OCV_L		= 0x01,
	RT5033_FUEL_REG_VBAT_H		= 0x02,
	RT5033_FUEL_REG_VBAT_L		= 0x03,
	RT5033_FUEL_REG_SOC_H		= 0x04,
	RT5033_FUEL_REG_SOC_L		= 0x05,
	RT5033_FUEL_REG_CTRL_H		= 0x06,
	RT5033_FUEL_REG_CTRL_L		= 0x07,
	RT5033_FUEL_REG_CRATE		= 0x08,
	RT5033_FUEL_REG_DEVICE_ID	= 0x09,
	RT5033_FUEL_REG_AVG_VOLT_H	= 0x0A,
	RT5033_FUEL_REG_AVG_VOLT_L	= 0x0B,
	RT5033_FUEL_REG_CONFIG_H	= 0x0C,
	RT5033_FUEL_REG_CONFIG_L	= 0x0D,
	/* Reserved 0x0E~0x0F */
	RT5033_FUEL_REG_IRQ_CTRL	= 0x10,
	RT5033_FUEL_REG_IRQ_FLAG	= 0x11,
	RT5033_FUEL_VMIN		= 0x12,
	RT5033_FUEL_SMIN		= 0x13,
	/* Reserved 0x14~0x1F */
	RT5033_FUEL_VGCOMP1		= 0x20,
	RT5033_FUEL_VGCOMP2		= 0x21,
	RT5033_FUEL_VGCOMP3		= 0x22,
	RT5033_FUEL_VGCOMP4		= 0x23,
	/* Reserved 0x24~0xFD */
	RT5033_FUEL_MFA_H		= 0xFE,
	RT5033_FUEL_MFA_L		= 0xFF,

	RT5033_FUEL_REG_END,
};

/* RT5033 fuel gauge battery present property */
#define RT5033_FUEL_BAT_PRESENT		0x02

/* RT5033 PMIC interrupts */
#define RT5033_PMIC_IRQ_BUCKOCP		2
#define RT5033_PMIC_IRQ_BUCKLV		3
#define RT5033_PMIC_IRQ_SAFELDOLV	4
#define RT5033_PMIC_IRQ_LDOLV		5
#define RT5033_PMIC_IRQ_OT		6
#define RT5033_PMIC_IRQ_VDDA_UV		7

#endif /* __RT5033_PRIVATE_H__ */
                                                                                                                                                                      #ifndef MFD_TMIO_H
#define MFD_TMIO_H

#include <linux/device.h>
#include <linux/fb.h>
#include <linux/io.h>
#include <linux/jiffies.h>
#include <linux/mmc/card.h>
#include <linux/platform_device.h>
#include <linux/pm_runtime.h>

#define tmio_ioread8(addr) readb(addr)
#define tmio_ioread16(addr) readw(addr)
#define tmio_ioread16_rep(r, b, l) readsw(r, b, l)
#define tmio_ioread32(addr) \
	(((u32) readw((addr))) | (((u32) readw((addr) + 2)) << 16))

#define tmio_iowrite8(val, addr) writeb((val), (addr))
#define tmio_iowrite16(val, addr) writew((val), (addr))
#define tmio_iowrite16_rep(r, b, l) writesw(r, b, l)
#define tmio_iowrite32(val, addr) \
	do { \
	writew((val),       (addr)); \
	writew((val) >> 16, (addr) + 2); \
	} while (0)

#define CNF_CMD     0x04
#define CNF_CTL_BASE   0x10
#define CNF_INT_PIN  0x3d
#define CNF_STOP_CLK_CTL 0x40
#define CNF_GCLK_CTL 0x41
#define CNF_SD_CLK_MODE 0x42
#define CNF_PIN_STATUS 0x44
#define CNF_PWR_CTL_1 0x48
#define CNF_PWR_CTL_2 0x49
#define CNF_PWR_CTL_3 0x4a
#define CNF_CARD_DETECT_MODE 0x4c
#define CNF_SD_SLOT 0x50
#define CNF_EXT_GCLK_CTL_1 0xf0
#define CNF_EXT_GCLK_CTL_2 0xf1
#define CNF_EXT_GCLK_CTL_3 0xf9
#define CNF_SD_LED_EN_1 0xfa
#define CNF_SD_LED_EN_2 0xfe

#define   SDCREN 0x2   /* Enable access to MMC CTL regs. (flag in COMMAND_REG)*/

#define sd_config_write8(base, shift, reg, val) \
	tmio_iowrite8((val), (base) + ((reg) << (shift)))
#define sd_config_write16(base, shift, reg, val) \
	tmio_iowrite16((val), (base) + ((reg) << (shift)))
#define sd_config_write32(base, shift, reg, val) \
	do { \
		tmio_iowrite16((val), (base) + ((reg) << (shift)));   \
		tmio_iowrite16((val) >> 16, (base) + ((reg + 2) << (shift))); \
	} while (0)

/* tmio MMC platform flags */
#define TMIO_MMC_WRPROTECT_DISABLE	(1 << 0)
/*
 * Some controllers can support a 2-byte block size when the bus width
 * is configured in 4-bit mode.
 */
#define TMIO_MMC_BLKSZ_2BYTES		(1 << 1)
/*
 * Some controllers can support SDIO IRQ signalling.
 */
#define TMIO_MMC_SDIO_IRQ		(1 << 2)
/*
 * Some controllers require waiting for the SD bus to become
 * idle before writing to some registers.
 */
#define TMIO_MMC_HAS_IDLE_WAIT		(1 << 4)
/*
 * A GPIO is used for card hotplug detection. We need an extra flag for this,
 * because 0 is a valid GPIO number too, and requiring users to specify
 * cd_gpio < 0 to disable GPIO hotplug would break backwards compatibility.
 */
#define TMIO_MMC_USE_GPIO_CD		(1 << 5)

/*
 * Some controllers doesn't have over 0x100 register.
 * it is used to checking accessibility of
 * CTL_SD_CARD_CLK_CTL / CTL_CLK_AND_WAIT_CTL
 */
#define TMIO_MMC_HAVE_HIGH_REG		(1 << 6)

/*
 * Some controllers have CMD12 automatically
 * issue/non-issue register
 */
#define TMIO_MMC_HAVE_CMD12_CTRL	(1 << 7)

/*
 * Some controllers needs to set 1 on SDIO status reserved bits
 */
#define TMIO_MMC_SDIO_STATUS_QUIRK	(1 << 8)

/*
 * Some controllers allows to set SDx actual clock
 */
#define TMIO_MMC_CLK_ACTUAL		(1 << 10)

int tmio_core_mmc_enable(void __iomem *cnf, int shift, unsigned long base);
int tmio_core_mmc_resume(void __iomem *cnf, int shift, unsigned long base);
void tmio_core_mmc_pwr(void __iomem *cnf, int shift, int state);
void tmio_core_mmc_clk_div(void __iomem *cnf, int shift, int state);

struct dma_chan;

/*
 * data for the MMC controller
 */
struct tmio_mmc_data {
	void				*chan_priv_tx;
	void				*chan_priv_rx;
	unsigned int			hclk;
	unsigned long			capabilities;
	unsigned long			capabilities2;
	unsigned long			flags;
	u32				ocr_mask;	/* available voltages */
	unsigned int			cd_gpio;
	int				alignment_shift;
	dma_addr_t			dma_rx_offset;
	void (*set_pwr)(struct platform_device *host, int state);
	void (*set_clk_div)(struct platform_device *host, int state);
};

/*
 * data for the NAND controller
 */
struct tmio_nand_data {
	struct nand_bbt_descr	*badblock_pattern;
	struct mtd_partition	*partition;
	unsigned int		num_partitions;
};

#define FBIO_TMIO_ACC_WRITE	0x7C639300
#define FBIO_TMIO_ACC_SYNC	0x7C639301

struct tmio_fb_data {
	int			(*lcd_set_power)(struct platform_device *fb_dev,
								bool on);
	int			(*lcd_mode)(struct platform_device *fb_dev,
					const struct fb_videomode *mode);
	int			num_modes;
	struct fb_videomode	*modes;

	/* in mm: size of screen */
	int			height;
	int			width;
};


#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * System Control Driver
 *
 * Copyright (C) 2012 Freescale Semiconductor, Inc.
 * Copyright (C) 2012 Linaro Ltd.
 *
 * Author: Dong Aisheng <dong.aisheng@linaro.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef __LINUX_MFD_SYSCON_H__
#define __LINUX_MFD_SYSCON_H__

#include <linux/err.h>

struct device_node;

#ifdef CONFIG_MFD_SYSCON
extern struct regmap *syscon_node_to_regmap(struct device_node *np);
extern struct regmap *syscon_regmap_lookup_by_compatible(const char *s);
extern struct regmap *syscon_regmap_lookup_by_pdevname(const char *s);
extern struct regmap *syscon_regmap_lookup_by_phandle(
					struct device_node *np,
					const char *property);
#else
static inline struct regmap *syscon_node_to_regmap(struct device_node *np)
{
	return ERR_PTR(-ENOSYS);
}

static inline struct regmap *syscon_regmap_lookup_by_compatible(const char *s)
{
	return ERR_PTR(-ENOSYS);
}

static inline struct regmap *syscon_regmap_lookup_by_pdevname(const char *s)
{
	return ERR_PTR(-ENOSYS);
}

static inline struct regmap *syscon_regmap_lookup_by_phandle(
					struct device_node *np,
					const char *property)
{
	return ERR_PTR(-ENOSYS);
}
#endif

#endif /* __LINUX_MFD_SYSCON_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef __LINUX_MFD_TPS6586X_H
#define __LINUX_MFD_TPS6586X_H

#define TPS6586X_SLEW_RATE_INSTANTLY	0x00
#define TPS6586X_SLEW_RATE_110UV	0x01
#define TPS6586X_SLEW_RATE_220UV	0x02
#define TPS6586X_SLEW_RATE_440UV	0x03
#define TPS6586X_SLEW_RATE_880UV	0x04
#define TPS6586X_SLEW_RATE_1760UV	0x05
#define TPS6586X_SLEW_RATE_3520UV	0x06
#define TPS6586X_SLEW_RATE_7040UV	0x07

#define TPS6586X_SLEW_RATE_SET		0x08
#define TPS6586X_SLEW_RATE_MASK         0x07

/* VERSION CRC */
#define TPS658621A	0x15
#define TPS658621CD	0x2c
#define TPS658623	0x1b
#define TPS658640	0x01
#define TPS658640v2	0x02
#define TPS658643	0x03

enum {
	TPS6586X_ID_SYS,
	TPS6586X_ID_SM_0,
	TPS6586X_ID_SM_1,
	TPS6586X_ID_SM_2,
	TPS6586X_ID_LDO_0,
	TPS6586X_ID_LDO_1,
	TPS6586X_ID_LDO_2,
	TPS6586X_ID_LDO_3,
	TPS6586X_ID_LDO_4,
	TPS6586X_ID_LDO_5,
	TPS6586X_ID_LDO_6,
	TPS6586X_ID_LDO_7,
	TPS6586X_ID_LDO_8,
	TPS6586X_ID_LDO_9,
	TPS6586X_ID_LDO_RTC,
	TPS6586X_ID_MAX_REGULATOR,
};

enum {
	TPS6586X_INT_PLDO_0,
	TPS6586X_INT_PLDO_1,
	TPS6586X_INT_PLDO_2,
	TPS6586X_INT_PLDO_3,
	TPS6586X_INT_PLDO_4,
	TPS6586X_INT_PLDO_5,
	TPS6586X_INT_PLDO_6,
	TPS6586X_INT_PLDO_7,
	TPS6586X_INT_COMP_DET,
	TPS6586X_INT_ADC,
	TPS6586X_INT_PLDO_8,
	TPS6586X_INT_PLDO_9,
	TPS6586X_INT_PSM_0,
	TPS6586X_INT_PSM_1,
	TPS6586X_INT_PSM_2,
	TPS6586X_INT_PSM_3,
	TPS6586X_INT_RTC_ALM1,
	TPS6586X_INT_ACUSB_OVP,
	TPS6586X_INT_USB_DET,
	TPS6586X_INT_AC_DET,
	TPS6586X_INT_BAT_DET,
	TPS6586X_INT_CHG_STAT,
	TPS6586X_INT_CHG_TEMP,
	TPS6586X_INT_PP,
	TPS6586X_INT_RESUME,
	TPS6586X_INT_LOW_SYS,
	TPS6586X_INT_RTC_ALM2,
};

struct tps6586x_settings {
	int slew_rate;
};

struct tps6586x_subdev_info {
	int		id;
	const char	*name;
	void		*platform_data;
	struct device_node *of_node;
};

struct tps6586x_platform_data {
	int num_subdevs;
	struct tps6586x_subdev_info *subdevs;

	int gpio_base;
	int irq_base;
	bool pm_off;

	struct regulator_init_data *reg_init_data[TPS6586X_ID_MAX_REGULATOR];
};

/*
 * NOTE: the functions below are not intended for use outside
 * of the TPS6586X sub-device drivers
 */
extern int tps6586x_write(struct device *dev, int reg, uint8_t val);
extern int tps6586x_writes(struct device *dev, int reg, int len, uint8_t *val);
extern int tps6586x_read(struct device *dev, int reg, uint8_t *val);
extern int tps6586x_reads(struct device *dev, int reg, int len, uint8_t *val);
extern int tps6586x_set_bits(struct device *dev, int reg, uint8_t bit_mask);
extern int tps6586x_clr_bits(struct device *dev, int reg, uint8_t bit_mask);
extern int tps6586x_update(struct device *dev, int reg, uint8_t val,
			   uint8_t mask);
extern int tps6586x_irq_get_virq(struct device *dev, int irq);
extern int tps6586x_get_version(struct device *dev);

#endif /*__LINUX_MFD_TPS6586X_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * include/media/si476x-platform.h -- Definitions of the data formats
 * returned by debugfs hooks
 *
 * Copyright (C) 2013 Andrey Smirnov
 *
 * Author: Andrey Smirnov <andrew.smirnov@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 */

#ifndef __SI476X_REPORTS_H__
#define __SI476X_REPORTS_H__

/**
 * struct si476x_rsq_status - structure containing received signal
 * quality
 * @multhint:   Multipath Detect High.
 *              true  - Indicatedes that the value is below
 *                      FM_RSQ_MULTIPATH_HIGH_THRESHOLD
 *              false - Indicatedes that the value is above
 *                      FM_RSQ_MULTIPATH_HIGH_THRESHOLD
 * @multlint:   Multipath Detect Low.
 *              true  - Indicatedes that the value is below
 *                      FM_RSQ_MULTIPATH_LOW_THRESHOLD
 *              false - Indicatedes that the value is above
 *                      FM_RSQ_MULTIPATH_LOW_THRESHOLD
 * @snrhint:    SNR Detect High.
 *              true  - Indicatedes that the value is below
 *                      FM_RSQ_SNR_HIGH_THRESHOLD
 *              false - Indicatedes that the value is above
 *                      FM_RSQ_SNR_HIGH_THRESHOLD
 * @snrlint:    SNR Detect Low.
 *              true  - Indicatedes that the value is below
 *                      FM_RSQ_SNR_LOW_THRESHOLD
 *              false - Indicatedes that the value is above
 *                      FM_RSQ_SNR_LOW_THRESHOLD
 * @rssihint:   RSSI Detect High.
 *              true  - Indicatedes that the value is below
 *                      FM_RSQ_RSSI_HIGH_THRESHOLD
 *              false - Indicatedes that the value is above
 *                      FM_RSQ_RSSI_HIGH_THRESHOLD
 * @rssilint:   RSSI Detect Low.
 *              true  - Indicatedes that the value is below
 *                      FM_RSQ_RSSI_LOW_THRESHOLD
 *              false - Indicatedes that the value is above
 *                      FM_RSQ_RSSI_LOW_THRESHOLD
 * @bltf:       Band Limit.
 *              Set if seek command hits the band limit or wrapped to
 *              the original frequency.
 * @snr_ready:  SNR measurement in progress.
 * @rssiready:  RSSI measurement in progress.
 * @afcrl:      Set if FREQOFF >= MAX_TUNE_ERROR
 * @valid:      Set if the channel is valid
 *               rssi < FM_VALID_RSSI_THRESHOLD
 *               snr  < FM_VALID_SNR_THRESHOLD
 *               tune_error < FM_VALID_MAX_TUNE_ERROR
 * @readfreq:   Current tuned frequency.
 * @freqoff:    Signed frequency offset.
 * @rssi:       Received Signal Strength Indicator(dBuV).
 * @snr:        RF SNR Indicator(dB).
 * @lassi:
 * @hassi:      Low/High side Adjacent(100 kHz) Channel Strength Indicator
 * @mult:       Multipath indicator
 * @dev:        Who knows? But values may vary.
 * @readantcap: Antenna tuning capacity value.
 * @assi:       Adjacent Channel(+/- 200kHz) Strength Indicator
 * @usn:        Ultrasonic Noise Inticator in -DBFS
 */
struct si476x_rsq_status_report {
	__u8 multhint, multlint;
	__u8 snrhint,  snrlint;
	__u8 rssihint, rssilint;
	__u8 bltf;
	__u8 snr_ready;
	__u8 rssiready;
	__u8 injside;
	__u8 afcrl;
	__u8 valid;

	__u16 readfreq;
	__s8  freqoff;
	__s8  rssi;
	__s8  snr;
	__s8  issi;
	__s8  lassi, hassi;
	__s8  mult;
	__u8  dev;
	__u16 readantcap;
	__s8  assi;
	__s8  usn;

	__u8 pilotdev;
	__u8 rdsdev;
	__u8 assidev;
	__u8 strongdev;
	__u16 rdspi;
} __packed;

/**
 * si476x_acf_status_report - ACF report results
 *
 * @blend_int: If set, indicates that stereo separation has crossed
 * below the blend threshold as set by FM_ACF_BLEND_THRESHOLD
 * @hblend_int: If set, indicates that HiBlend cutoff frequency is
 * lower than threshold as set by FM_ACF_HBLEND_THRESHOLD
 * @hicut_int:  If set, indicates that HiCut cutoff frequency is lower
 * than the threshold set by ACF_

 */
struct si476x_acf_status_report {
	__u8 blend_int;
	__u8 hblend_int;
	__u8 hicut_int;
	__u8 chbw_int;
	__u8 softmute_int;
	__u8 smute;
	__u8 smattn;
	__u8 chbw;
	__u8 hicut;
	__u8 hiblend;
	__u8 pilot;
	__u8 stblend;
} __packed;

enum si476x_fmagc {
	SI476X_FMAGC_10K_OHM	= 0,
	SI476X_FMAGC_800_OHM	= 1,
	SI476X_FMAGC_400_OHM	= 2,
	SI476X_FMAGC_200_OHM	= 4,
	SI476X_FMAGC_100_OHM	= 8,
	SI476X_FMAGC_50_OHM	= 16,
	SI476X_FMAGC_25_OHM	= 32,
	SI476X_FMAGC_12P5_OHM	= 64,
	SI476X_FMAGC_6P25_OHM	= 128,
};

struct si476x_agc_status_report {
	__u8 mxhi;
	__u8 mxlo;
	__u8 lnahi;
	__u8 lnalo;
	__u8 fmagc1;
	__u8 fmagc2;
	__u8 pgagain;
	__u8 fmwblang;
} __packed;

struct si476x_rds_blockcount_report {
	__u16 expected;
	__u16 received;
	__u16 uncorrectable;
} __packed;

#endif  /* __SI476X_REPORTS_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef __LINUX_TI_AM335X_TSCADC_MFD_H
#define __LINUX_TI_AM335X_TSCADC_MFD_H

/*
 * TI Touch Screen / ADC MFD driver
 *
 * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation version 2.
 *
 * This program is distributed "as is" WITHOUT ANY WARRANTY of any
 * kind, whether express or implied; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include <linux/mfd/core.h>

#define REG_RAWIRQSTATUS	0x024
#define REG_IRQSTATUS		0x028
#define REG_IRQENABLE		0x02C
#define REG_IRQCLR		0x030
#define REG_IRQWAKEUP		0x034
#define REG_CTRL		0x040
#define REG_ADCFSM		0x044
#define REG_CLKDIV		0x04C
#define REG_SE			0x054
#define REG_IDLECONFIG		0x058
#define REG_CHARGECONFIG	0x05C
#define REG_CHARGEDELAY		0x060
#define REG_STEPCONFIG(n)	(0x64 + ((n) * 8))
#define REG_STEPDELAY(n)	(0x68 + ((n) * 8))
#define REG_FIFO0CNT		0xE4
#define REG_FIFO0THR		0xE8
#define REG_FIFO1CNT		0xF0
#define REG_FIFO1THR		0xF4
#define REG_FIFO0		0x100
#define REG_FIFO1		0x200

/*	Register Bitfields	*/
/* IRQ wakeup enable */
#define IRQWKUP_ENB		BIT(0)

/* Step Enable */
#define STEPENB_MASK		(0x1FFFF << 0)
#define STEPENB(val)		((val) << 0)
#define ENB(val)			(1 << (val))
#define STPENB_STEPENB		STEPENB(0x1FFFF)
#define STPENB_STEPENB_TC	STEPENB(0x1FFF)

/* IRQ enable */
#define IRQENB_HW_PEN		BIT(0)
#define IRQENB_EOS		BIT(1)
#define IRQENB_FIFO0THRES	BIT(2)
#define IRQENB_FIFO0OVRRUN	BIT(3)
#define IRQENB_FIFO0UNDRFLW	BIT(4)
#define IRQENB_FIFO1THRES	BIT(5)
#define IRQENB_FIFO1OVRRUN	BIT(6)
#define IRQENB_FIFO1UNDRFLW	BIT(7)
#define IRQENB_PENUP		BIT(9)

/* Step Configuration */
#define STEPCONFIG_MODE_MASK	(3 << 0)
#define STEPCONFIG_MODE(val)	((val) << 0)
#define STEPCONFIG_MODE_SWCNT	STEPCONFIG_MODE(1)
#define STEPCONFIG_MODE_HWSYNC	STEPCONFIG_MODE(2)
#define STEPCONFIG_AVG_MASK	(7 << 2)
#define STEPCONFIG_AVG(val)	((val) << 2)
#define STEPCONFIG_AVG_16	STEPCONFIG_AVG(4)
#define STEPCONFIG_XPP		BIT(5)
#define STEPCONFIG_XNN		BIT(6)
#define STEPCONFIG_YPP		BIT(7)
#define STEPCONFIG_YNN		BIT(8)
#define STEPCONFIG_XNP		BIT(9)
#define STEPCONFIG_YPN		BIT(10)
#define STEPCONFIG_INM_MASK	(0xF << 15)
#define STEPCONFIG_INM(val)	((val) << 15)
#define STEPCONFIG_INM_ADCREFM	STEPCONFIG_INM(8)
#define STEPCONFIG_INP_MASK	(0xF << 19)
#define STEPCONFIG_INP(val)	((val) << 19)
#define STEPCONFIG_INP_AN4	STEPCONFIG_INP(4)
#define STEPCONFIG_INP_ADCREFM	STEPCONFIG_INP(8)
#define STEPCONFIG_FIFO1	BIT(26)

/* Delay register */
#define STEPDELAY_OPEN_MASK	(0x3FFFF << 0)
#define STEPDELAY_OPEN(val)	((val) << 0)
#define STEPCONFIG_OPENDLY	STEPDELAY_OPEN(0x098)
#define STEPDELAY_SAMPLE_MASK	(0xFF << 24)
#define STEPDELAY_SAMPLE(val)	((val) << 24)
#define STEPCONFIG_SAMPLEDLY	STEPDELAY_SAMPLE(0)

/* Charge Config */
#define STEPCHARGE_RFP_MASK	(7 << 12)
#define STEPCHARGE_RFP(val)	((val) << 12)
#define STEPCHARGE_RFP_XPUL	STEPCHARGE_RFP(1)
#define STEPCHARGE_INM_MASK	(0xF << 15)
#define STEPCHARGE_INM(val)	((val) << 15)
#define STEPCHARGE_INM_AN1	STEPCHARGE_INM(1)
#define STEPCHARGE_INP_MASK	(0xF << 19)
#define STEPCHARGE_INP(val)	((val) << 19)
#define STEPCHARGE_RFM_MASK	(3 << 23)
#define STEPCHARGE_RFM(val)	((val) << 23)
#define STEPCHARGE_RFM_XNUR	STEPCHARGE_RFM(1)

/* Charge delay */
#define CHARGEDLY_OPEN_MASK	(0x3FFFF << 0)
#define CHARGEDLY_OPEN(val)	((val) << 0)
#define CHARGEDLY_OPENDLY	CHARGEDLY_OPEN(0x400)

/* Control register */
#define CNTRLREG_TSCSSENB	BIT(0)
#define CNTRLREG_STEPID		BIT(1)
#define CNTRLREG_STEPCONFIGWRT	BIT(2)
#define CNTRLREG_POWERDOWN	BIT(4)
#define CNTRLREG_AFE_CTRL_MASK	(3 << 5)
#define CNTRLREG_AFE_CTRL(val)	((val) << 5)
#define CNTRLREG_4WIRE		CNTRLREG_AFE_CTRL(1)
#define CNTRLREG_5WIRE		CNTRLREG_AFE_CTRL(2)
#define CNTRLREG_8WIRE		CNTRLREG_AFE_CTRL(3)
#define CNTRLREG_TSCENB		BIT(7)

/* FIFO READ Register */
#define FIFOREAD_DATA_MASK (0xfff << 0)
#define FIFOREAD_CHNLID_MASK (0xf << 16)

/* Sequencer Status */
#define SEQ_STATUS BIT(5)
#define CHARGE_STEP		0x11

#define ADC_CLK			3000000
#define TOTAL_STEPS		16
#define TOTAL_CHANNELS		8
#define FIFO1_THRESHOLD		19

/*
 * time in us for processing a single channel, calculated as follows:
 *
 * num cycles = open delay + (sample delay + conv time) * averaging
 *
 * num cycles: 152 + (1 + 13) * 16 = 376
 *
 * clock frequency: 26MHz / 8 = 3.25MHz
 * clock period: 1 / 3.25MHz = 308ns
 *
 * processing time: 376 * 308ns = 116us
 */
#define IDLE_TIMEOUT 116 /* microsec */

#define TSCADC_CELLS		2

struct ti_tscadc_dev {
	struct device *dev;
	struct regmap *regmap_tscadc;
	void __iomem *tscadc_base;
	int irq;
	int used_cells;	/* 1-2 */
	int tsc_wires;
	int tsc_cell;	/* -1 if not used */
	int adc_cell;	/* -1 if not used */
	struct mfd_cell cells[TSCADC_CELLS];
	u32 reg_se_cache;
	bool adc_waiting;
	bool adc_in_use;
	wait_queue_head_t reg_se_wait;
	spinlock_t reg_lock;
	unsigned int clk_div;

	/* tsc device */
	struct titsc *tsc;

	/* adc device */
	struct adc_device *adc;
};

static inline struct ti_tscadc_dev *ti_tscadc_dev_get(struct platform_device *p)
{
	struct ti_tscadc_dev **tscadc_dev = p->dev.platform_data;

	return *tscadc_dev;
}

void am335x_tsc_se_set_cache(struct ti_tscadc_dev *tsadc, u32 val);
void am335x_tsc_se_set_once(struct ti_tscadc_dev *tsadc, u32 val);
void am335x_tsc_se_clr(struct ti_tscadc_dev *tsadc, u32 val);
void am335x_tsc_se_adc_done(struct ti_tscadc_dev *tsadc);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * TI LP8788 MFD - common definitions for current sinks
 *
 * Copyright 2012 Texas Instruments
 *
 * Author: Milo(Woogyom) Kim <milo.kim@ti.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 */

#ifndef __ISINK_LP8788_H__
#define __ISINK_LP8788_H__

/* register address */
#define LP8788_ISINK_CTRL		0x99
#define LP8788_ISINK12_IOUT		0x9A
#define LP8788_ISINK3_IOUT		0x9B
#define LP8788_ISINK1_PWM		0x9C
#define LP8788_ISINK2_PWM		0x9D
#define LP8788_ISINK3_PWM		0x9E

/* mask bits */
#define LP8788_ISINK1_IOUT_M		0x0F	/* Addr 9Ah */
#define LP8788_ISINK2_IOUT_M		0xF0
#define LP8788_ISINK3_IOUT_M		0x0F	/* Addr 9Bh */

/* 6 bits used for PWM code : Addr 9C ~ 9Eh */
#define LP8788_ISINK_MAX_PWM		63
#define LP8788_ISINK_SCALE_OFFSET	3

static const u8 lp8788_iout_addr[] = {
	LP8788_ISINK12_IOUT,
	LP8788_ISINK12_IOUT,
	LP8788_ISINK3_IOUT,
};

static const u8 lp8788_iout_mask[] = {
	LP8788_ISINK1_IOUT_M,
	LP8788_ISINK2_IOUT_M,
	LP8788_ISINK3_IOUT_M,
};

static const u8 lp8788_pwm_addr[] = {
	LP8788_ISINK1_PWM,
	LP8788_ISINK2_PWM,
	LP8788_ISINK3_PWM,
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * max8998.h - Voltage regulator driver for the Maxim 8998
 *
 *  Copyright (C) 2009-2010 Samsung Electrnoics
 *  Kyungmin Park <kyungmin.park@samsung.com>
 *  Marek Szyprowski <m.szyprowski@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef __LINUX_MFD_MAX8998_H
#define __LINUX_MFD_MAX8998_H

#include <linux/regulator/machine.h>

/* MAX 8998 regulator ids */
enum {
	MAX8998_LDO2 = 2,
	MAX8998_LDO3,
	MAX8998_LDO4,
	MAX8998_LDO5,
	MAX8998_LDO6,
	MAX8998_LDO7,
	MAX8998_LDO8,
	MAX8998_LDO9,
	MAX8998_LDO10,
	MAX8998_LDO11,
	MAX8998_LDO12,
	MAX8998_LDO13,
	MAX8998_LDO14,
	MAX8998_LDO15,
	MAX8998_LDO16,
	MAX8998_LDO17,
	MAX8998_BUCK1,
	MAX8998_BUCK2,
	MAX8998_BUCK3,
	MAX8998_BUCK4,
	MAX8998_EN32KHZ_AP,
	MAX8998_EN32KHZ_CP,
	MAX8998_ENVICHG,
	MAX8998_ESAFEOUT1,
	MAX8998_ESAFEOUT2,
};

/**
 * max8998_regulator_data - regulator data
 * @id: regulator id
 * @initdata: regulator init data (contraints, supplies, ...)
 * @reg_node: DT node of regulator (unused on non-DT platforms)
 */
struct max8998_regulator_data {
	int				id;
	struct regulator_init_data	*initdata;
	struct device_node		*reg_node;
};

/**
 * struct max8998_board - packages regulator init data
 * @regulators: array of defined regulators
 * @num_regulators: number of regulators used
 * @irq_base: base IRQ number for max8998, required for IRQs
 * @ono: power onoff IRQ number for max8998
 * @buck_voltage_lock: Do NOT change the values of the following six
 *   registers set by buck?_voltage?. The voltage of BUCK1/2 cannot
 *   be other than the preset values.
 * @buck1_voltage: BUCK1 DVS mode 1 voltage registers
 * @buck2_voltage: BUCK2 DVS mode 2 voltage registers
 * @buck1_set1: BUCK1 gpio pin 1 to set output voltage
 * @buck1_set2: BUCK1 gpio pin 2 to set output voltage
 * @buck1_default_idx: Default for BUCK1 gpio pin 1, 2
 * @buck2_set3: BUCK2 gpio pin to set output voltage
 * @buck2_default_idx: Default for BUCK2 gpio pin.
 * @wakeup: Allow to wake up from suspend
 * @rtc_delay: LP3974 RTC chip bug that requires delay after a register
 * write before reading it.
 * @eoc: End of Charge Level in percent: 10% ~ 45% by 5% step
 *   If it equals 0, leave it unchanged.
 *   Otherwise, it is a invalid value.
 * @restart: Restart Level in mV: 100, 150, 200, and -1 for disable.
 *   If it equals 0, leave it unchanged.
 *   Otherwise, it is a invalid value.
 * @timeout: Full Timeout in hours: 5, 6, 7, and -1 for disable.
 *   If it equals 0, leave it unchanged.
 *   Otherwise, leave it unchanged.
 */
struct max8998_platform_data {
	struct max8998_regulator_data	*regulators;
	int				num_regulators;
	unsigned int			irq_base;
	int				ono;
	bool				buck_voltage_lock;
	int				buck1_voltage[4];
	int				buck2_voltage[2];
	int				buck1_set1;
	int				buck1_set2;
	int				buck1_default_idx;
	int				buck2_set3;
	int				buck2_default_idx;
	bool				wakeup;
	bool				rtc_delay;
	int				eoc;
	int				restart;
	int				timeout;
};

#endif /*  __LINUX_MFD_MAX8998_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* Driver for Realtek PCI-Express card reader
 *
 * Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *   Wei WANG <wei_wang@realsil.com.cn>
 */

#ifndef __RTSX_PCI_H
#define __RTSX_PCI_H

#include <linux/sched.h>
#include <linux/pci.h>
#include <linux/mfd/rtsx_common.h>

#define MAX_RW_REG_CNT			1024

#define RTSX_HCBAR			0x00
#define RTSX_HCBCTLR			0x04
#define   STOP_CMD			(0x01 << 28)
#define   READ_REG_CMD			0
#define   WRITE_REG_CMD			1
#define   CHECK_REG_CMD			2

#define RTSX_HDBAR			0x08
#define   SG_INT			0x04
#define   SG_END			0x02
#define   SG_VALID			0x01
#define   SG_NO_OP			0x00
#define   SG_TRANS_DATA			(0x02 << 4)
#define   SG_LINK_DESC			(0x03 << 4)
#define RTSX_HDBCTLR			0x0C
#define   SDMA_MODE			0x00
#define   ADMA_MODE			(0x02 << 26)
#define   STOP_DMA			(0x01 << 28)
#define   TRIG_DMA			(0x01 << 31)

#define RTSX_HAIMR			0x10
#define   HAIMR_TRANS_START		(0x01 << 31)
#define   HAIMR_READ			0x00
#define   HAIMR_WRITE			(0x01 << 30)
#define   HAIMR_READ_START		(HAIMR_TRANS_START | HAIMR_READ)
#define   HAIMR_WRITE_START		(HAIMR_TRANS_START | HAIMR_WRITE)
#define   HAIMR_TRANS_END			(HAIMR_TRANS_START)

#define RTSX_BIPR			0x14
#define   CMD_DONE_INT			(1 << 31)
#define   DATA_DONE_INT			(1 << 30)
#define   TRANS_OK_INT			(1 << 29)
#define   TRANS_FAIL_INT		(1 << 28)
#define   XD_INT			(1 << 27)
#define   MS_INT			(1 << 26)
#define   SD_INT			(1 << 25)
#define   GPIO0_INT			(1 << 24)
#define   OC_INT			(1 << 23)
#define   SD_WRITE_PROTECT		(1 << 19)
#define   XD_EXIST			(1 << 18)
#define   MS_EXIST			(1 << 17)
#define   SD_EXIST			(1 << 16)
#define   DELINK_INT			GPIO0_INT
#define   MS_OC_INT			(1 << 23)
#define   SD_OC_INT			(1 << 22)

#define CARD_INT		(XD_INT | MS_INT | SD_INT)
#define NEED_COMPLETE_INT	(DATA_DONE_INT | TRANS_OK_INT | TRANS_FAIL_INT)
#define RTSX_INT		(CMD_DONE_INT | NEED_COMPLETE_INT | \
					CARD_INT | GPIO0_INT | OC_INT)
#define CARD_EXIST		(XD_EXIST | MS_EXIST | SD_EXIST)

#define RTSX_BIER			0x18
#define   CMD_DONE_INT_EN		(1 << 31)
#define   DATA_DONE_INT_EN		(1 << 30)
#define   TRANS_OK_INT_EN		(1 << 29)
#define   TRANS_FAIL_INT_EN		(1 << 28)
#define   XD_INT_EN			(1 << 27)
#define   MS_INT_EN			(1 << 26)
#define   SD_INT_EN			(1 << 25)
#define   GPIO0_INT_EN			(1 << 24)
#define   OC_INT_EN			(1 << 23)
#define   DELINK_INT_EN			GPIO0_INT_EN
#define   MS_OC_INT_EN			(1 << 23)
#define   SD_OC_INT_EN			(1 << 22)


/*
 * macros for easy use
 */
#define rtsx_pci_writel(pcr, reg, value) \
	iowrite32(value, (pcr)->remap_addr + reg)
#define rtsx_pci_readl(pcr, reg) \
	ioread32((pcr)->remap_addr + reg)
#define rtsx_pci_writew(pcr, reg, value) \
	iowrite16(value, (pcr)->remap_addr + reg)
#define rtsx_pci_readw(pcr, reg) \
	ioread16((pcr)->remap_addr + reg)
#define rtsx_pci_writeb(pcr, reg, value) \
	iowrite8(value, (pcr)->remap_addr + reg)
#define rtsx_pci_readb(pcr, reg) \
	ioread8((pcr)->remap_addr + reg)

#define rtsx_pci_read_config_byte(pcr, where, val) \
	pci_read_config_byte((pcr)->pci, where, val)

#define rtsx_pci_write_config_byte(pcr, where, val) \
	pci_write_config_byte((pcr)->pci, where, val)

#define rtsx_pci_read_config_dword(pcr, where, val) \
	pci_read_config_dword((pcr)->pci, where, val)

#define rtsx_pci_write_config_dword(pcr, where, val) \
	pci_write_config_dword((pcr)->pci, where, val)

#define STATE_TRANS_NONE		0
#define STATE_TRANS_CMD			1
#define STATE_TRANS_BUF			2
#define STATE_TRANS_SG			3

#define TRANS_NOT_READY			0
#define TRANS_RESULT_OK			1
#define TRANS_RESULT_FAIL		2
#define TRANS_NO_DEVICE			3

#define RTSX_RESV_BUF_LEN		4096
#define HOST_CMDS_BUF_LEN		1024
#define HOST_SG_TBL_BUF_LEN		(RTSX_RESV_BUF_LEN - HOST_CMDS_BUF_LEN)
#define HOST_SG_TBL_ITEMS		(HOST_SG_TBL_BUF_LEN / 8)
#define MAX_SG_ITEM_LEN			0x80000
#define HOST_TO_DEVICE			0
#define DEVICE_TO_HOST			1

#define OUTPUT_3V3			0
#define OUTPUT_1V8			1

#define RTSX_PHASE_MAX			32
#define RX_TUNING_CNT			3

#define MS_CFG				0xFD40
#define   SAMPLE_TIME_RISING		0x00
#define   SAMPLE_TIME_FALLING		0x80
#define   PUSH_TIME_DEFAULT		0x00
#define   PUSH_TIME_ODD			0x40
#define   NO_EXTEND_TOGGLE		0x00
#define   EXTEND_TOGGLE_CHK		0x20
#define   MS_BUS_WIDTH_1		0x00
#define   MS_BUS_WIDTH_4		0x10
#define   MS_BUS_WIDTH_8		0x18
#define   MS_2K_SECTOR_MODE		0x04
#define   MS_512_SECTOR_MODE		0x00
#define   MS_TOGGLE_TIMEOUT_EN		0x00
#define   MS_TOGGLE_TIMEOUT_DISEN	0x01
#define MS_NO_CHECK_INT			0x02
#define MS_TPC				0xFD41
#define MS_TRANS_CFG			0xFD42
#define   WAIT_INT			0x80
#define   NO_WAIT_INT			0x00
#define   NO_AUTO_READ_INT_REG		0x00
#define   AUTO_READ_INT_REG		0x40
#define   MS_CRC16_ERR			0x20
#define   MS_RDY_TIMEOUT		0x10
#define   MS_INT_CMDNK			0x08
#define   MS_INT_BREQ			0x04
#define   MS_INT_ERR			0x02
#define   MS_INT_CED			0x01
#define MS_TRANSFER			0xFD43
#define   MS_TRANSFER_START		0x80
#define   MS_TRANSFER_END		0x40
#define   MS_TRANSFER_ERR		0x20
#define   MS_BS_STATE			0x10
#define   MS_TM_READ_BYTES		0x00
#define   MS_TM_NORMAL_READ		0x01
#define   MS_TM_WRITE_BYTES		0x04
#define   MS_TM_NORMAL_WRITE		0x05
#define   MS_TM_AUTO_READ		0x08
#define   MS_TM_AUTO_WRITE		0x0C
#define MS_INT_REG			0xFD44
#define MS_BYTE_CNT			0xFD45
#define MS_SECTOR_CNT_L			0xFD46
#define MS_SECTOR_CNT_H			0xFD47
#define MS_DBUS_H			0xFD48

#define SD_CFG1				0xFDA0
#define   SD_CLK_DIVIDE_0		0x00
#define   SD_CLK_DIVIDE_256		0xC0
#define   SD_CLK_DIVIDE_128		0x80
#define   SD_BUS_WIDTH_1BIT		0x00
#define   SD_BUS_WIDTH_4BIT		0x01
#define   SD_BUS_WIDTH_8BIT		0x02
#define   SD_ASYNC_FIFO_NOT_RST		0x10
#define   SD_20_MODE			0x00
#define   SD_DDR_MODE			0x04
#define   SD_30_MODE			0x08
#define   SD_CLK_DIVIDE_MASK		0xC0
#define SD_CFG2				0xFDA1
#define   SD_CALCULATE_CRC7		0x00
#define   SD_NO_CALCULATE_CRC7		0x80
#define   SD_CHECK_CRC16		0x00
#define   SD_NO_CHECK_CRC16		0x40
#define   SD_NO_CHECK_WAIT_CRC_TO	0x20
#define   SD_WAIT_BUSY_END		0x08
#define   SD_NO_WAIT_BUSY_END		0x00
#define   SD_CHECK_CRC7			0x00
#define   SD_NO_CHECK_CRC7		0x04
#define   SD_RSP_LEN_0			0x00
#define   SD_RSP_LEN_6			0x01
#define   SD_RSP_LEN_17			0x02
#define   SD_RSP_TYPE_R0		0x04
#define   SD_RSP_TYPE_R1		0x01
#define   SD_RSP_TYPE_R1b		0x09
#define   SD_RSP_TYPE_R2		0x02
#define   SD_RSP_TYPE_R3		0x05
#define   SD_RSP_TYPE_R4		0x05
#define   SD_RSP_TYPE_R5		0x01
#define   SD_RSP_TYPE_R6		0x01
#define   SD_RSP_TYPE_R7		0x01
#define SD_CFG3				0xFDA2
#define   SD_RSP_80CLK_TIMEOUT_EN	0x01

#define SD_STAT1			0xFDA3
#define   SD_CRC7_ERR			0x80
#define   SD_CRC16_ERR			0x40
#define   SD_CRC_WRITE_ERR		0x20
#define   SD_CRC_WRITE_ERR_MASK		0x1C
#define   GET_CRC_TIME_OUT		0x02
#define   SD_TUNING_COMPARE_ERR		0x01
#define SD_STAT2			0xFDA4
#define   SD_RSP_80CLK_TIMEOUT		0x01

#define SD_BUS_STAT			0xFDA5
#define   SD_CLK_TOGGLE_EN		0x80
#define   SD_CLK_FORCE_STOP		0x40
#define   SD_DAT3_STATUS		0x10
#define   SD_DAT2_STATUS		0x08
#define   SD_DAT1_STATUS		0x04
#define   SD_DAT0_STATUS		0x02
#define   SD_CMD_STATUS			0x01
#define SD_PAD_CTL			0xFDA6
#define   SD_IO_USING_1V8		0x80
#define   SD_IO_USING_3V3		0x7F
#define   TYPE_A_DRIVING		0x00
#define   TYPE_B_DRIVING		0x01
#define   TYPE_C_DRIVING		0x02
#define   TYPE_D_DRIVING		0x03
#define SD_SAMPLE_POINT_CTL		0xFDA7
#define   DDR_FIX_RX_DAT		0x00
#define   DDR_VAR_RX_DAT		0x80
#define   DDR_FIX_RX_DAT_EDGE		0x00
#define   DDR_FIX_RX_DAT_14_DELAY	0x40
#define   DDR_FIX_RX_CMD		0x00
#define   DDR_VAR_RX_CMD		0x20
#define   DDR_FIX_RX_CMD_POS_EDGE	0x00
#define   DDR_FIX_RX_CMD_14_DELAY	0x10
#define   SD20_RX_POS_EDGE		0x00
#define   SD20_RX_14_DELAY		0x08
#define SD20_RX_SEL_MASK		0x08
#define SD_PUSH_POINT_CTL		0xFDA8
#define   DDR_FIX_TX_CMD_DAT		0x00
#define   DDR_VAR_TX_CMD_DAT		0x80
#define   DDR_FIX_TX_DAT_14_TSU		0x00
#define   DDR_FIX_TX_DAT_12_TSU		0x40
#define   DDR_FIX_TX_CMD_NEG_EDGE	0x00
#define   DDR_FIX_TX_CMD_14_AHEAD	0x20
#define   SD20_TX_NEG_EDGE		0x00
#define   SD20_TX_14_AHEAD		0x10
#define   SD20_TX_SEL_MASK		0x10
#define   DDR_VAR_SDCLK_POL_SWAP	0x01
#define SD_CMD0				0xFDA9
#define   SD_CMD_START			0x40
#define SD_CMD1				0xFDAA
#define SD_CMD2				0xFDAB
#define SD_CMD3				0xFDAC
#define SD_CMD4				0xFDAD
#define SD_CMD5				0xFDAE
#define SD_BYTE_CNT_L			0xFDAF
#define SD_BYTE_CNT_H			0xFDB0
#define SD_BLOCK_CNT_L			0xFDB1
#define SD_BLOCK_CNT_H			0xFDB2
#define SD_TRANSFER			0xFDB3
#define   SD_TRANSFER_START		0x80
#define   SD_TRANSFER_END		0x40
#define   SD_STAT_IDLE			0x20
#define   SD_TRANSFER_ERR		0x10
#define   SD_TM_NORMAL_WRITE		0x00
#define   SD_TM_AUTO_WRITE_3		0x01
#define   SD_TM_AUTO_WRITE_4		0x02
#define   SD_TM_AUTO_READ_3		0x05
#define   SD_TM_AUTO_READ_4		0x06
#define   SD_TM_CMD_RSP			0x08
#define   SD_TM_AUTO_WRITE_1		0x09
#define   SD_TM_AUTO_WRITE_2		0x0A
#define   SD_TM_NORMAL_READ		0x0C
#define   SD_TM_AUTO_READ_1		0x0D
#define   SD_TM_AUTO_READ_2		0x0E
#define   SD_TM_AUTO_TUNING		0x0F
#define SD_CMD_STATE			0xFDB5
#define   SD_CMD_IDLE			0x80

#define SD_DATA_STATE			0xFDB6
#define   SD_DATA_IDLE			0x80

#define SRCTL				0xFC13

#define DCM_DRP_CTL			0xFC23
#define   DCM_RESET			0x08
#define   DCM_LOCKED			0x04
#define   DCM_208M			0x00
#define   DCM_TX			0x01
#define   DCM_RX			0x02
#define DCM_DRP_TRIG			0xFC24
#define   DRP_START			0x80
#define   DRP_DONE			0x40
#define DCM_DRP_CFG			0xFC25
#define   DRP_WRITE			0x80
#define   DRP_READ			0x00
#define   DCM_WRITE_ADDRESS_50		0x50
#define   DCM_WRITE_ADDRESS_51		0x51
#define   DCM_READ_ADDRESS_00		0x00
#define   DCM_READ_ADDRESS_51		0x51
#define DCM_DRP_WR_DATA_L		0xFC26
#define DCM_DRP_WR_DATA_H		0xFC27
#define DCM_DRP_RD_DATA_L		0xFC28
#define DCM_DRP_RD_DATA_H		0xFC29
#define SD_VPCLK0_CTL			0xFC2A
#define SD_VPCLK1_CTL			0xFC2B
#define SD_DCMPS0_CTL			0xFC2C
#define SD_DCMPS1_CTL			0xFC2D
#define SD_VPTX_CTL			SD_VPCLK0_CTL
#define SD_VPRX_CTL			SD_VPCLK1_CTL
#define   PHASE_CHANGE			0x80
#define   PHASE_NOT_RESET		0x40
#define SD_DCMPS_TX_CTL			SD_DCMPS0_CTL
#define SD_DCMPS_RX_CTL			SD_DCMPS1_CTL
#define   DCMPS_CHANGE			0x80
#define   DCMPS_CHANGE_DONE		0x40
#define   DCMPS_ERROR			0x20
#define   DCMPS_CURRENT_PHASE		0x1F
#define CARD_CLK_SOURCE			0xFC2E
#define   CRC_FIX_CLK			(0x00 << 0)
#define   CRC_VAR_CLK0			(0x01 << 0)
#define   CRC_VAR_CLK1			(0x02 << 0)
#define   SD30_FIX_CLK			(0x00 << 2)
#define   SD30_VAR_CLK0			(0x01 << 2)
#define   SD30_VAR_CLK1			(0x02 << 2)
#define   SAMPLE_FIX_CLK		(0x00 << 4)
#define   SAMPLE_VAR_CLK0		(0x01 << 4)
#define   SAMPLE_VAR_CLK1		(0x02 << 4)
#define CARD_PWR_CTL			0xFD50
#define   PMOS_STRG_MASK		0x10
#define   PMOS_STRG_800mA		0x10
#define   PMOS_STRG_400mA		0x00
#define   SD_POWER_OFF			0x03
#define   SD_PARTIAL_POWER_ON		0x01
#define   SD_POWER_ON			0x00
#define   SD_POWER_MASK			0x03
#define   MS_POWER_OFF			0x0C
#define   MS_PARTIAL_POWER_ON		0x04
#define   MS_POWER_ON			0x00
#define   MS_POWER_MASK			0x0C
#define   BPP_POWER_OFF			0x0F
#define   BPP_POWER_5_PERCENT_ON	0x0E
#define   BPP_POWER_10_PERCENT_ON	0x0C
#define   BPP_POWER_15_PERCENT_ON	0x08
#define   BPP_POWER_ON			0x00
#define   BPP_POWER_MASK		0x0F
#define   SD_VCC_PARTIAL_POWER_ON	0x02
#define   SD_VCC_POWER_ON		0x00
#define CARD_CLK_SWITCH			0xFD51
#define RTL8411B_PACKAGE_MODE		0xFD51
#define CARD_SHARE_MODE			0xFD52
#define   CARD_SHARE_MASK		0x0F
#define   CARD_SHARE_MULTI_LUN		0x00
#define   CARD_SHARE_NORMAL		0x00
#define   CARD_SHARE_48_SD		0x04
#define   CARD_SHARE_48_MS		0x08
#define   CARD_SHARE_BAROSSA_SD		0x01
#define   CARD_SHARE_BAROSSA_MS		0x02
#define CARD_DRIVE_SEL			0xFD53
#define   MS_DRIVE_8mA			(0x01 << 6)
#define   MMC_DRIVE_8mA			(0x01 << 4)
#define   XD_DRIVE_8mA			(0x01 << 2)
#define   GPIO_DRIVE_8mA		0x01
#define RTS5209_CARD_DRIVE_DEFAULT	(MS_DRIVE_8mA | MMC_DRIVE_8mA |\
					XD_DRIVE_8mA | GPIO_DRIVE_8mA)
#define RTL8411_CARD_DRIVE_DEFAULT	(MS_DRIVE_8mA | MMC_DRIVE_8mA |\
					XD_DRIVE_8mA)
#define RTSX_CARD_DRIVE_DEFAULT		(MS_DRIVE_8mA | GPIO_DRIVE_8mA)

#define CARD_STOP			0xFD54
#define   SPI_STOP			0x01
#define   XD_STOP			0x02
#define   SD_STOP			0x04
#define   MS_STOP			0x08
#define   SPI_CLR_ERR			0x10
#define   XD_CLR_ERR			0x20
#define   SD_CLR_ERR			0x40
#define   MS_CLR_ERR			0x80
#define CARD_OE				0xFD55
#define   SD_OUTPUT_EN			0x04
#define   MS_OUTPUT_EN			0x08
#define CARD_AUTO_BLINK			0xFD56
#define CARD_GPIO_DIR			0xFD57
#define CARD_GPIO			0xFD58
#define CARD_DATA_SOURCE		0xFD5B
#define   PINGPONG_BUFFER		0x01
#define   RING_BUFFER			0x00
#define SD30_CLK_DRIVE_SEL		0xFD5A
#define   DRIVER_TYPE_A			0x05
#define   DRIVER_TYPE_B			0x03
#define   DRIVER_TYPE_C			0x02
#define   DRIVER_TYPE_D			0x01
#define CARD_SELECT			0xFD5C
#define   SD_MOD_SEL			2
#define   MS_MOD_SEL			3
#define SD30_DRIVE_SEL			0xFD5E
#define   CFG_DRIVER_TYPE_A		0x02
#define   CFG_DRIVER_TYPE_B		0x03
#define   CFG_DRIVER_TYPE_C		0x01
#define   CFG_DRIVER_TYPE_D		0x00
#define SD30_CMD_DRIVE_SEL		0xFD5E
#define SD30_DAT_DRIVE_SEL		0xFD5F
#define CARD_CLK_EN			0xFD69
#define   SD_CLK_EN			0x04
#define   MS_CLK_EN			0x08
#define SDIO_CTRL			0xFD6B
#define CD_PAD_CTL			0xFD73
#define   CD_DISABLE_MASK		0x07
#define   MS_CD_DISABLE			0x04
#define   SD_CD_DISABLE			0x02
#define   XD_CD_DISABLE			0x01
#define   CD_DISABLE			0x07
#define   CD_ENABLE			0x00
#define   MS_CD_EN_ONLY			0x03
#define   SD_CD_EN_ONLY			0x05
#define   XD_CD_EN_ONLY			0x06
#define   FORCE_CD_LOW_MASK		0x38
#define   FORCE_CD_XD_LOW		0x08
#define   FORCE_CD_SD_LOW		0x10
#define   FORCE_CD_MS_LOW		0x20
#define   CD_AUTO_DISABLE		0x40
#define FPDCTL				0xFC00
#define   SSC_POWER_DOWN		0x01
#define   SD_OC_POWER_DOWN		0x02
#define   ALL_POWER_DOWN		0x07
#define   OC_POWER_DOWN			0x06
#define PDINFO				0xFC01

#define CLK_CTL				0xFC02
#define   CHANGE_CLK			0x01
#define   CLK_LOW_FREQ			0x01

#define CLK_DIV				0xFC03
#define   CLK_DIV_1			0x01
#define   CLK_DIV_2			0x02
#define   CLK_DIV_4			0x03
#define   CLK_DIV_8			0x04
#define CLK_SEL				0xFC04

#define SSC_DIV_N_0			0xFC0F
#define SSC_DIV_N_1			0xFC10
#define SSC_CTL1			0xFC11
#define    SSC_RSTB			0x80
#define    SSC_8X_EN			0x40
#define    SSC_FIX_FRAC			0x20
#define    SSC_SEL_1M			0x00
#define    SSC_SEL_2M			0x08
#define    SSC_SEL_4M			0x10
#define    SSC_SEL_8M			0x18
#define SSC_CTL2			0xFC12
#define    SSC_DEPTH_MASK		0x07
#define    SSC_DEPTH_DISALBE		0x00
#define    SSC_DEPTH_4M			0x01
#define    SSC_DEPTH_2M			0x02
#define    SSC_DEPTH_1M			0x03
#define    SSC_DEPTH_500K		0x04
#define    SSC_DEPTH_250K		0x05
#define RCCTL				0xFC14

#define FPGA_PULL_CTL			0xFC1D
#define OLT_LED_CTL			0xFC1E
#define GPIO_CTL			0xFC1F

#define LDO_CTL				0xFC1E
#define   BPP_ASIC_1V7			0x00
#define   BPP_ASIC_1V8			0x01
#define   BPP_ASIC_1V9			0x02
#define   BPP_ASIC_2V0			0x03
#define   BPP_ASIC_2V7			0x04
#define   BPP_ASIC_2V8			0x05
#define   BPP_ASIC_3V2			0x06
#define   BPP_ASIC_3V3			0x07
#define   BPP_REG_TUNED18		0x07
#define   BPP_TUNED18_SHIFT_8402	5
#define   BPP_TUNED18_SHIFT_8411	4
#define   BPP_PAD_MASK			0x04
#define   BPP_PAD_3V3			0x04
#define   BPP_PAD_1V8			0x00
#define   BPP_LDO_POWB			0x03
#define   BPP_LDO_ON			0x00
#define   BPP_LDO_SUSPEND		0x02
#define   BPP_LDO_OFF			0x03
#define SYS_VER				0xFC32

#define CARD_PULL_CTL1			0xFD60
#define CARD_PULL_CTL2			0xFD61
#define CARD_PULL_CTL3			0xFD62
#define CARD_PULL_CTL4			0xFD63
#define CARD_PULL_CTL5			0xFD64
#define CARD_PULL_CTL6			0xFD65

/* PCI Express Related Registers */
#define IRQEN0				0xFE20
#define IRQSTAT0			0xFE21
#define    DMA_DONE_INT			0x80
#define    SUSPEND_INT			0x40
#define    LINK_RDY_INT			0x20
#define    LINK_DOWN_INT		0x10
#define IRQEN1				0xFE22
#define IRQSTAT1			0xFE23
#define TLPRIEN				0xFE24
#define TLPRISTAT			0xFE25
#define TLPTIEN				0xFE26
#define TLPTISTAT			0xFE27
#define DMATC0				0xFE28
#define DMATC1				0xFE29
#define DMATC2				0xFE2A
#define DMATC3				0xFE2B
#define DMACTL				0xFE2C
#define   DMA_RST			0x80
#define   DMA_BUSY			0x04
#define   DMA_DIR_TO_CARD		0x00
#define   DMA_DIR_FROM_CARD		0x02
#define   DMA_EN			0x01
#define   DMA_128			(0 << 4)
#define   DMA_256			(1 << 4)
#define   DMA_512			(2 << 4)
#define   DMA_1024			(3 << 4)
#define   DMA_PACK_SIZE_MASK		0x30
#define BCTL				0xFE2D
#define RBBC0				0xFE2E
#define RBBC1				0xFE2F
#define RBDAT				0xFE30
#define RBCTL				0xFE34
#define CFGADDR0			0xFE35
#define CFGADDR1			0xFE36
#define CFGDATA0			0xFE37
#define CFGDATA1			0xFE38
#define CFGDATA2			0xFE39
#define CFGDATA3			0xFE3A
#define CFGRWCTL			0xFE3B
#define PHYRWCTL			0xFE3C
#define PHYDATA0			0xFE3D
#define PHYDATA1			0xFE3E
#define PHYADDR				0xFE3F
#define MSGRXDATA0			0xFE40
#define MSGRXDATA1			0xFE41
#define MSGRXDATA2			0xFE42
#define MSGRXDATA3			0xFE43
#define MSGTXDATA0			0xFE44
#define MSGTXDATA1			0xFE45
#define MSGTXDATA2			0xFE46
#define MSGTXDATA3			0xFE47
#define MSGTXCTL			0xFE48
#define LTR_CTL				0xFE4A
#define OBFF_CFG			0xFE4C

#define CDRESUMECTL			0xFE52
#define WAKE_SEL_CTL			0xFE54
#define PCLK_CTL			0xFE55
#define   PCLK_MODE_SEL			0x20
#define PME_FORCE_CTL			0xFE56

#define ASPM_FORCE_CTL			0xFE57
#define   FORCE_ASPM_CTL0		0x10
#define   FORCE_ASPM_VAL_MASK		0x03
#define   FORCE_ASPM_L1_EN		0x02
#define   FORCE_ASPM_L0_EN		0x01
#define   FORCE_ASPM_NO_ASPM		0x00
#define PM_CLK_FORCE_CTL		0xFE58
#define FUNC_FORCE_CTL			0xFE59
#define PERST_GLITCH_WIDTH		0xFE5C
#define CHANGE_LINK_STATE		0xFE5B
#define RESET_LOAD_REG			0xFE5E
#define EFUSE_CONTENT			0xFE5F
#define HOST_SLEEP_STATE		0xFE60
#define   HOST_ENTER_S1			1
#define   HOST_ENTER_S3			2

#define SDIO_CFG			0xFE70
#define PM_EVENT_DEBUG			0xFE71
#define   PME_DEBUG_0			0x08
#define NFTS_TX_CTRL			0xFE72

#define PWR_GATE_CTRL			0xFE75
#define   PWR_GATE_EN			0x01
#define   LDO3318_PWR_MASK		0x06
#define   LDO_ON			0x00
#define   LDO_SUSPEND			0x04
#define   LDO_OFF			0x06
#define PWD_SUSPEND_EN			0xFE76
#define LDO_PWR_SEL			0xFE78

#define L1SUB_CONFIG1			0xFE8D
#define L1SUB_CONFIG2			0xFE8E
#define   L1SUB_AUTO_CFG		0x02
#define L1SUB_CONFIG3			0xFE8F

#define DUMMY_REG_RESET_0		0xFE90

#define AUTOLOAD_CFG_BASE		0xFF00
#define PETXCFG				0xFF03

#define PM_CTRL1			0xFF44
#define   CD_RESUME_EN_MASK		0xF0

#define PM_CTRL2			0xFF45
#define PM_CTRL3			0xFF46
#define   SDIO_SEND_PME_EN		0x80
#define   FORCE_RC_MODE_ON		0x40
#define   FORCE_RX50_LINK_ON		0x20
#define   D3_DELINK_MODE_EN		0x10
#define   USE_PESRTB_CTL_DELINK		0x08
#define   DELAY_PIN_WAKE		0x04
#define   RESET_PIN_WAKE		0x02
#define   PM_WAKE_EN			0x01
#define PM_CTRL4			0xFF47

/* Memory mapping */
#define SRAM_BASE			0xE600
#define RBUF_BASE			0xF400
#define PPBUF_BASE1			0xF800
#define PPBUF_BASE2			0xFA00
#define IMAGE_FLAG_ADDR0		0xCE80
#define IMAGE_FLAG_ADDR1		0xCE81

#define RREF_CFG			0xFF6C
#define   RREF_VBGSEL_MASK		0x38
#define   RREF_VBGSEL_1V25		0x28

#define OOBS_CONFIG			0xFF6E
#define   OOBS_AUTOK_DIS		0x80
#define   OOBS_VAL_MASK			0x1F

#define LDO_DV18_CFG			0xFF70
#define   LDO_DV18_SR_MASK		0xC0
#define   LDO_DV18_SR_DF		0x40

#define LDO_CONFIG2			0xFF71
#define   LDO_D3318_MASK		0x07
#define   LDO_D3318_33V			0x07
#define   LDO_D3318_18V			0x02

#define LDO_VCC_CFG0			0xFF72
#define   LDO_VCC_LMTVTH_MASK		0x30
#define   LDO_VCC_LMTVTH_2A		0x10

#define LDO_VCC_CFG1			0xFF73
#define   LDO_VCC_REF_TUNE_MASK		0x30
#define   LDO_VCC_REF_1V2		0x20
#define   LDO_VCC_TUNE_MASK		0x07
#define   LDO_VCC_1V8			0x04
#define   LDO_VCC_3V3			0x07
#define   LDO_VCC_LMT_EN		0x08

#define LDO_VIO_CFG			0xFF75
#define   LDO_VIO_SR_MASK		0xC0
#define   LDO_VIO_SR_DF			0x40
#define   LDO_VIO_REF_TUNE_MASK		0x30
#define   LDO_VIO_REF_1V2		0x20
#define   LDO_VIO_TUNE_MASK		0x07
#define   LDO_VIO_1V7			0x03
#define   LDO_VIO_1V8			0x04
#define   LDO_VIO_3V3			0x07

#define LDO_DV12S_CFG			0xFF76
#define   LDO_REF12_TUNE_MASK		0x18
#define   LDO_REF12_TUNE_DF		0x10
#define   LDO_D12_TUNE_MASK		0x07
#define   LDO_D12_TUNE_DF		0x04

#define LDO_AV12S_CFG			0xFF77
#define   LDO_AV12S_TUNE_MASK		0x07
#define   LDO_AV12S_TUNE_DF		0x04

#define SD40_LDO_CTL1			0xFE7D
#define   SD40_VIO_TUNE_MASK		0x70
#define   SD40_VIO_TUNE_1V7		0x30
#define   SD_VIO_LDO_1V8		0x40
#define   SD_VIO_LDO_3V3		0x70

/* Phy register */
#define PHY_PCR				0x00
#define   PHY_PCR_FORCE_CODE		0xB000
#define   PHY_PCR_OOBS_CALI_50		0x0800
#define   PHY_PCR_OOBS_VCM_08		0x0200
#define   PHY_PCR_OOBS_SEN_90		0x0040
#define   PHY_PCR_RSSI_EN		0x0002
#define   PHY_PCR_RX10K			0x0001

#define PHY_RCR0			0x01
#define PHY_RCR1			0x02
#define   PHY_RCR1_ADP_TIME_4		0x0400
#define   PHY_RCR1_VCO_COARSE		0x001F
#define PHY_SSCCR2			0x02
#define   PHY_SSCCR2_PLL_NCODE		0x0A00
#define   PHY_SSCCR2_TIME0		0x001C
#define   PHY_SSCCR2_TIME2_WIDTH	0x0003

#define PHY_RCR2			0x03
#define   PHY_RCR2_EMPHASE_EN		0x8000
#define   PHY_RCR2_NADJR		0x4000
#define   PHY_RCR2_CDR_SR_2		0x0100
#define   PHY_RCR2_FREQSEL_12		0x0040
#define   PHY_RCR2_CDR_SC_12P		0x0010
#define   PHY_RCR2_CALIB_LATE		0x0002
#define PHY_SSCCR3			0x03
#define   PHY_SSCCR3_STEP_IN		0x2740
#define   PHY_SSCCR3_CHECK_DELAY	0x0008
#define _PHY_ANA03			0x03
#define   _PHY_ANA03_TIMER_MAX		0x2700
#define   _PHY_ANA03_OOBS_DEB_EN	0x0040
#define   _PHY_CMU_DEBUG_EN		0x0008

#define PHY_RTCR			0x04
#define PHY_RDR				0x05
#define   PHY_RDR_RXDSEL_1_9		0x4000
#define   PHY_SSC_AUTO_PWD		0x0600
#define PHY_TCR0			0x06
#define PHY_TCR1			0x07
#define PHY_TUNE			0x08
#define   PHY_TUNE_TUNEREF_1_0		0x4000
#define   PHY_TUNE_VBGSEL_1252		0x0C00
#define   PHY_TUNE_SDBUS_33		0x0200
#define   PHY_TUNE_TUNED18		0x01C0
#define   PHY_TUNE_TUNED12		0X0020
#define   PHY_TUNE_TUNEA12		0x0004
#define   PHY_TUNE_VOLTAGE_MASK		0xFC3F
#define   PHY_TUNE_VOLTAGE_3V3		0x03C0
#define   PHY_TUNE_D18_1V8		0x0100
#define   PHY_TUNE_D18_1V7		0x0080
#define PHY_ANA08			0x08
#define   PHY_ANA08_RX_EQ_DCGAIN	0x5000
#define   PHY_ANA08_SEL_RX_EN		0x0400
#define   PHY_ANA08_RX_EQ_VAL		0x03C0
#define   PHY_ANA08_SCP			0x0020
#define   PHY_ANA08_SEL_IPI		0x0004

#define PHY_IMR				0x09
#define PHY_BPCR			0x0A
#define   PHY_BPCR_IBRXSEL		0x0400
#define   PHY_BPCR_IBTXSEL		0x0100
#define   PHY_BPCR_IB_FILTER		0x0080
#define   PHY_BPCR_CMIRROR_EN		0x0040

#define PHY_BIST			0x0B
#define PHY_RAW_L			0x0C
#define PHY_RAW_H			0x0D
#define PHY_RAW_DATA			0x0E
#define PHY_HOST_CLK_CTRL		0x0F
#define PHY_DMR				0x10
#define PHY_BACR			0x11
#define   PHY_BACR_BASIC_MASK		0xFFF3
#define PHY_IER				0x12
#define PHY_BCSR			0x13
#define PHY_BPR				0x14
#define PHY_BPNR2			0x15
#define PHY_BPNR			0x16
#define PHY_BRNR2			0x17
#define PHY_BENR			0x18
#define PHY_REV				0x19
#define   PHY_REV_RESV			0xE000
#define   PHY_REV_RXIDLE_LATCHED	0x1000
#define   PHY_REV_P1_EN			0x0800
#define   PHY_REV_RXIDLE_EN		0x0400
#define   PHY_REV_CLKREQ_TX_EN		0x0200
#define   PHY_REV_CLKREQ_RX_EN		0x0100
#define   PHY_REV_CLKREQ_DT_1_0		0x0040
#define   PHY_REV_STOP_CLKRD		0x0020
#define   PHY_REV_RX_PWST		0x0008
#define   PHY_REV_STOP_CLKWR		0x0004
#define _PHY_REV0			0x19
#define   _PHY_REV0_FILTER_OUT		0x3800
#define   _PHY_REV0_CDR_BYPASS_PFD	0x0100
#define   _PHY_REV0_CDR_RX_IDLE_BYPASS	0x0002

#define PHY_FLD0			0x1A
#define PHY_ANA1A			0x1A
#define   PHY_ANA1A_TXR_LOOPBACK	0x2000
#define   PHY_ANA1A_RXT_BIST		0x0500
#define   PHY_ANA1A_TXR_BIST		0x0040
#define   PHY_ANA1A_REV			0x0006
#define PHY_FLD1			0x1B
#define PHY_FLD2			0x1C
#define PHY_FLD3			0x1D
#define   PHY_FLD3_TIMER_4		0x0800
#define   PHY_FLD3_TIMER_6		0x0020
#define   PHY_FLD3_RXDELINK		0x0004
#define PHY_ANA1D			0x1D
#define   PHY_ANA1D_DEBUG_ADDR		0x0004
#define _PHY_FLD0			0x1D
#define   _PHY_FLD0_CLK_REQ_20C		0x8000
#define   _PHY_FLD0_RX_IDLE_EN		0x1000
#define   _PHY_FLD0_BIT_ERR_RSTN	0x0800
#define   _PHY_FLD0_BER_COUNT		0x01E0
#define   _PHY_FLD0_BER_TIMER		0x001E
#define   _PHY_FLD0_CHECK_EN		0x0001

#define PHY_FLD4			0x1E
#define   PHY_FLD4_FLDEN_SEL		0x4000
#define   PHY_FLD4_REQ_REF		0x2000
#define   PHY_FLD4_RXAMP_OFF		0x1000
#define   PHY_FLD4_REQ_ADDA		0x0800
#define   PHY_FLD4_BER_COUNT		0x00E0
#define   PHY_FLD4_BER_TIMER		0x000A
#define   PHY_FLD4_BER_CHK_EN		0x0001
#define PHY_DIG1E			0x1E
#define   PHY_DIG1E_REV			0x4000
#define   PHY_DIG1E_D0_X_D1		0x1000
#define   PHY_DIG1E_RX_ON_HOST		0x0800
#define   PHY_DIG1E_RCLK_REF_HOST	0x0400
#define   PHY_DIG1E_RCLK_TX_EN_KEEP	0x0040
#define   PHY_DIG1E_RCLK_TX_TERM_KEEP	0x0020
#define   PHY_DIG1E_RCLK_RX_EIDLE_ON	0x0010
#define   PHY_DIG1E_TX_TERM_KEEP	0x0008
#define   PHY_DIG1E_RX_TERM_KEEP	0x0004
#define   PHY_DIG1E_TX_EN_KEEP		0x0002
#define   PHY_DIG1E_RX_EN_KEEP		0x0001
#define PHY_DUM_REG			0x1F

#define PCR_SETTING_REG1		0x724
#define PCR_SETTING_REG2		0x814
#define PCR_SETTING_REG3		0x747

#define rtsx_pci_init_cmd(pcr)		((pcr)->ci = 0)

struct rtsx_pcr;

struct pcr_handle {
	struct rtsx_pcr			*pcr;
};

struct pcr_ops {
	int (*write_phy)(struct rtsx_pcr *pcr, u8 addr, u16 val);
	int (*read_phy)(struct rtsx_pcr *pcr, u8 addr, u16 *val);
	int		(*extra_init_hw)(struct rtsx_pcr *pcr);
	int		(*optimize_phy)(struct rtsx_pcr *pcr);
	int		(*turn_on_led)(struct rtsx_pcr *pcr);
	int		(*turn_off_led)(struct rtsx_pcr *pcr);
	int		(*enable_auto_blink)(struct rtsx_pcr *pcr);
	int		(*disable_auto_blink)(struct rtsx_pcr *pcr);
	int		(*card_power_on)(struct rtsx_pcr *pcr, int card);
	int		(*card_power_off)(struct rtsx_pcr *pcr, int card);
	int		(*switch_output_voltage)(struct rtsx_pcr *pcr,
						u8 voltage);
	unsigned int	(*cd_deglitch)(struct rtsx_pcr *pcr);
	int		(*conv_clk_and_div_n)(int clk, int dir);
	void		(*fetch_vendor_settings)(struct rtsx_pcr *pcr);
	void		(*force_power_down)(struct rtsx_pcr *pcr, u8 pm_state);
};

enum PDEV_STAT  {PDEV_STAT_IDLE, PDEV_STAT_RUN};

struct rtsx_pcr {
	struct pci_dev			*pci;
	unsigned int			id;
	int				pcie_cap;

	/* pci resources */
	unsigned long			addr;
	void __iomem			*remap_addr;
	int				irq;

	/* host reserved buffer */
	void				*rtsx_resv_buf;
	dma_addr_t			rtsx_resv_buf_addr;

	void				*host_cmds_ptr;
	dma_addr_t			host_cmds_addr;
	int				ci;

	void				*host_sg_tbl_ptr;
	dma_addr_t			host_sg_tbl_addr;
	int				sgi;

	u32				bier;
	char				trans_result;

	unsigned int			card_inserted;
	unsigned int			card_removed;
	unsigned int			card_exist;

	struct delayed_work		carddet_work;
	struct delayed_work		idle_work;

	spinlock_t			lock;
	struct mutex			pcr_mutex;
	struct completion		*done;
	struct completion		*finish_me;

	unsigned int			cur_clock;
	bool				remove_pci;
	bool				msi_en;

#define EXTRA_CAPS_SD_SDR50		(1 << 0)
#define EXTRA_CAPS_SD_SDR104		(1 << 1)
#define EXTRA_CAPS_SD_DDR50		(1 << 2)
#define EXTRA_CAPS_MMC_HSDDR		(1 << 3)
#define EXTRA_CAPS_MMC_HS200		(1 << 4)
#define EXTRA_CAPS_MMC_8BIT		(1 << 5)
	u32				extra_caps;

#define IC_VER_A			0
#define IC_VER_B			1
#define IC_VER_C			2
#define IC_VER_D			3
	u8				ic_version;

	u8				sd30_drive_sel_1v8;
	u8				sd30_drive_sel_3v3;
	u8				card_drive_sel;
#define ASPM_L1_EN			0x02
	u8				aspm_en;

#define PCR_MS_PMOS			(1 << 0)
#define PCR_REVERSE_SOCKET		(1 << 1)
	u32				flags;

	u32				tx_initial_phase;
	u32				rx_initial_phase;

	const u32			*sd_pull_ctl_enable_tbl;
	const u32			*sd_pull_ctl_disable_tbl;
	const u32			*ms_pull_ctl_enable_tbl;
	const u32			*ms_pull_ctl_disable_tbl;

	const struct pcr_ops		*ops;
	enum PDEV_STAT			state;

	u16				reg_pm_ctrl3;

	int				num_slots;
	struct rtsx_slot		*slots;
};

#define CHK_PCI_PID(pcr, pid)		((pcr)->pci->device == (pid))
#define PCI_VID(pcr)			((pcr)->pci->vendor)
#define PCI_PID(pcr)			((pcr)->pci->device)
#define is_version(pcr, pid, ver)				\
	(CHK_PCI_PID(pcr, pid) && (pcr)->ic_version == (ver))
#define pcr_dbg(pcr, fmt, arg...)				\
	dev_dbg(&(pcr)->pci->dev, fmt, ##arg)

#define SDR104_PHASE(val)		((val) & 0xFF)
#define SDR50_PHASE(val)		(((val) >> 8) & 0xFF)
#define DDR50_PHASE(val)		(((val) >> 16) & 0xFF)
#define SDR104_TX_PHASE(pcr)		SDR104_PHASE((pcr)->tx_initial_phase)
#define SDR50_TX_PHASE(pcr)		SDR50_PHASE((pcr)->tx_initial_phase)
#define DDR50_TX_PHASE(pcr)		DDR50_PHASE((pcr)->tx_initial_phase)
#define SDR104_RX_PHASE(pcr)		SDR104_PHASE((pcr)->rx_initial_phase)
#define SDR50_RX_PHASE(pcr)		SDR50_PHASE((pcr)->rx_initial_phase)
#define DDR50_RX_PHASE(pcr)		DDR50_PHASE((pcr)->rx_initial_phase)
#define SET_CLOCK_PHASE(sdr104, sdr50, ddr50)	\
				(((ddr50) << 16) | ((sdr50) << 8) | (sdr104))

void rtsx_pci_start_run(struct rtsx_pcr *pcr);
int rtsx_pci_write_register(struct rtsx_pcr *pcr, u16 addr, u8 mask, u8 data);
int rtsx_pci_read_register(struct rtsx_pcr *pcr, u16 addr, u8 *data);
int rtsx_pci_write_phy_register(struct rtsx_pcr *pcr, u8 addr, u16 val);
int rtsx_pci_read_phy_register(struct rtsx_pcr *pcr, u8 addr, u16 *val);
void rtsx_pci_stop_cmd(struct rtsx_pcr *pcr);
void rtsx_pci_add_cmd(struct rtsx_pcr *pcr,
		u8 cmd_type, u16 reg_addr, u8 mask, u8 data);
void rtsx_pci_send_cmd_no_wait(struct rtsx_pcr *pcr);
int rtsx_pci_send_cmd(struct rtsx_pcr *pcr, int timeout);
int rtsx_pci_transfer_data(struct rtsx_pcr *pcr, struct scatterlist *sglist,
		int num_sg, bool read, int timeout);
int rtsx_pci_dma_map_sg(struct rtsx_pcr *pcr, struct scatterlist *sglist,
		int num_sg, bool read);
void rtsx_pci_dma_unmap_sg(struct rtsx_pcr *pcr, struct scatterlist *sglist,
		int num_sg, bool read);
int rtsx_pci_dma_transfer(struct rtsx_pcr *pcr, struct scatterlist *sglist,
		int count, bool read, int timeout);
int rtsx_pci_read_ppbuf(struct rtsx_pcr *pcr, u8 *buf, int buf_len);
int rtsx_pci_write_ppbuf(struct rtsx_pcr *pcr, u8 *buf, int buf_len);
int rtsx_pci_card_pull_ctl_enable(struct rtsx_pcr *pcr, int card);
int rtsx_pci_card_pull_ctl_disable(struct rtsx_pcr *pcr, int card);
int rtsx_pci_switch_clock(struct rtsx_pcr *pcr, unsigned int card_clock,
		u8 ssc_depth, bool initial_mode, bool double_clk, bool vpclk);
int rtsx_pci_card_power_on(struct rtsx_pcr *pcr, int card);
int rtsx_pci_card_power_off(struct rtsx_pcr *pcr, int card);
int rtsx_pci_card_exclusive_check(struct rtsx_pcr *pcr, int card);
int rtsx_pci_switch_output_voltage(struct rtsx_pcr *pcr, u8 voltage);
unsigned int rtsx_pci_card_exist(struct rtsx_pcr *pcr);
void rtsx_pci_complete_unfinished_transfer(struct rtsx_pcr *pcr);

static inline u8 *rtsx_pci_get_cmd_data(struct rtsx_pcr *pcr)
{
	return (u8 *)(pcr->host_cmds_ptr);
}

static inline int rtsx_pci_update_cfg_byte(struct rtsx_pcr *pcr, int addr,
		u8 mask, u8 append)
{
	int err;
	u8 val;

	err = pci_read_config_byte(pcr->pci, addr, &val);
	if (err < 0)
		return err;
	return pci_write_config_byte(pcr->pci, addr, (val & mask) | append);
}

static inline void rtsx_pci_write_be32(struct rtsx_pcr *pcr, u16 reg, u32 val)
{
	rtsx_pci_add_cmd(pcr, WRITE_REG_CMD, reg,     0xFF, val >> 24);
	rtsx_pci_add_cmd(pcr, WRITE_REG_CMD, reg + 1, 0xFF, val >> 16);
	rtsx_pci_add_cmd(pcr, WRITE_REG_CMD, reg + 2, 0xFF, val >> 8);
	rtsx_pci_add_cmd(pcr, WRITE_REG_CMD, reg + 3, 0xFF, val);
}

static inline int rtsx_pci_update_phy(struct rtsx_pcr *pcr, u8 addr,
	u16 mask, u16 append)
{
	int err;
	u16 val;

	err = rtsx_pci_read_phy_register(pcr, addr, &val);
	if (err < 0)
		return err;

	return rtsx_pci_write_phy_register(pcr, addr, (val & mask) | append);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Copyright 2009 Daniel Ribeiro <drwyrm@gmail.com>
 *
 * For further information, please see http://wiki.openezx.org/PCAP2
 */

#ifndef EZX_PCAP_H
#define EZX_PCAP_H

struct pcap_subdev {
	int id;
	const char *name;
	void *platform_data;
};

struct pcap_platform_data {
	unsigned int irq_base;
	unsigned int config;
	int gpio;
	void (*init) (void *);	/* board specific init */
	int num_subdevs;
	struct pcap_subdev *subdevs;
};

struct pcap_chip;

int ezx_pcap_write(struct pcap_chip *, u8, u32);
int ezx_pcap_read(struct pcap_chip *, u8, u32 *);
int ezx_pcap_set_bits(struct pcap_chip *, u8, u32, u32);
int pcap_to_irq(struct pcap_chip *, int);
int irq_to_pcap(struct pcap_chip *, int);
int pcap_adc_async(struct pcap_chip *, u8, u32, u8[], void *, void *);
int pcap_adc_sync(struct pcap_chip *, u8, u32, u8[], u16[]);
void pcap_set_ts_bits(struct pcap_chip *, u32);

#define PCAP_SECOND_PORT	1
#define PCAP_CS_AH		2

#define PCAP_REGISTER_WRITE_OP_BIT	0x80000000
#define PCAP_REGISTER_READ_OP_BIT	0x00000000

#define PCAP_REGISTER_VALUE_MASK	0x01ffffff
#define PCAP_REGISTER_ADDRESS_MASK	0x7c000000
#define PCAP_REGISTER_ADDRESS_SHIFT	26
#define PCAP_REGISTER_NUMBER		32
#define PCAP_CLEAR_INTERRUPT_REGISTER	0x01ffffff
#define PCAP_MASK_ALL_INTERRUPT		0x01ffffff

/* registers accessible by both pcap ports */
#define PCAP_REG_ISR		0x0	/* Interrupt Status */
#define PCAP_REG_MSR		0x1	/* Interrupt Mask */
#define PCAP_REG_PSTAT		0x2	/* Processor Status */
#define PCAP_REG_VREG2		0x6	/* Regulator Bank 2 Control */
#define PCAP_REG_AUXVREG	0x7	/* Auxiliary Regulator Control */
#define PCAP_REG_BATT		0x8	/* Battery Control */
#define PCAP_REG_ADC		0x9	/* AD Control */
#define PCAP_REG_ADR		0xa	/* AD Result */
#define PCAP_REG_CODEC		0xb	/* Audio Codec Control */
#define PCAP_REG_RX_AMPS	0xc	/* RX Audio Amplifiers Control */
#define PCAP_REG_ST_DAC		0xd	/* Stereo DAC Control */
#define PCAP_REG_BUSCTRL	0x14	/* Connectivity Control */
#define PCAP_REG_PERIPH		0x15	/* Peripheral Control */
#define PCAP_REG_LOWPWR		0x18	/* Regulator Low Power Control */
#define PCAP_REG_TX_AMPS	0x1a	/* TX Audio Amplifiers Control */
#define PCAP_REG_GP		0x1b	/* General Purpose */
#define PCAP_REG_TEST1		0x1c
#define PCAP_REG_TEST2		0x1d
#define PCAP_REG_VENDOR_TEST1	0x1e
#define PCAP_REG_VENDOR_TEST2	0x1f

/* registers accessible by pcap port 1 only (a1200, e2 & e6) */
#define PCAP_REG_INT_SEL	0x3	/* Interrupt Select */
#define PCAP_REG_SWCTRL		0x4	/* Switching Regulator Control */
#define PCAP_REG_VREG1		0x5	/* Regulator Bank 1 Control */
#define PCAP_REG_RTC_TOD	0xe	/* RTC Time of Day */
#define PCAP_REG_RTC_TODA	0xf	/* RTC Time of Day Alarm */
#define PCAP_REG_RTC_DAY	0x10	/* RTC Day */
#define PCAP_REG_RTC_DAYA	0x11	/* RTC Day Alarm */
#define PCAP_REG_MTRTMR		0x12	/* AD Monitor Timer */
#define PCAP_REG_PWR		0x13	/* Power Control */
#define PCAP_REG_AUXVREG_MASK	0x16	/* Auxiliary Regulator Mask */
#define PCAP_REG_VENDOR_REV	0x17
#define PCAP_REG_PERIPH_MASK	0x19	/* Peripheral Mask */

/* PCAP2 Interrupts */
#define PCAP_NIRQS		23
#define PCAP_IRQ_ADCDONE	0	/* ADC done port 1 */
#define PCAP_IRQ_TS		1	/* Touch Screen */
#define PCAP_IRQ_1HZ		2	/* 1HZ timer */
#define PCAP_IRQ_WH		3	/* ADC above high limit */
#define PCAP_IRQ_WL		4	/* ADC below low limit */
#define PCAP_IRQ_TODA		5	/* Time of day alarm */
#define PCAP_IRQ_USB4V		6	/* USB above 4V */
#define PCAP_IRQ_ONOFF		7	/* On/Off button */
#define PCAP_IRQ_ONOFF2		8	/* On/Off button 2 */
#define PCAP_IRQ_USB1V		9	/* USB above 1V */
#define PCAP_IRQ_MOBPORT	10
#define PCAP_IRQ_MIC		11	/* Mic attach/HS button */
#define PCAP_IRQ_HS		12	/* Headset attach */
#define PCAP_IRQ_ST		13
#define PCAP_IRQ_PC		14	/* Power Cut */
#define PCAP_IRQ_WARM		15
#define PCAP_IRQ_EOL		16	/* Battery End Of Life */
#define PCAP_IRQ_CLK		17
#define PCAP_IRQ_SYSRST		18	/* System Reset */
#define PCAP_IRQ_DUMMY		19
#define PCAP_IRQ_ADCDONE2	20	/* ADC done port 2 */
#define PCAP_IRQ_SOFTRESET	21
#define PCAP_IRQ_MNEXB		22

/* voltage regulators */
#define V1		0
#define V2		1
#define V3		2
#define V4		3
#define V5		4
#define V6		5
#define V7		6
#define V8		7
#define V9		8
#define V10		9
#define VAUX1		10
#define VAUX2		11
#define VAUX3		12
#define VAUX4		13
#define VSIM		14
#define VSIM2		15
#define VVIB		16
#define SW1		17
#define SW2		18
#define SW3		19
#define SW1S		20
#define SW2S		21

#define PCAP_BATT_DAC_MASK		0x000000ff
#define PCAP_BATT_DAC_SHIFT		0
#define PCAP_BATT_B_FDBK		(1 << 8)
#define PCAP_BATT_EXT_ISENSE		(1 << 9)
#define PCAP_BATT_V_COIN_MASK		0x00003c00
#define PCAP_BATT_V_COIN_SHIFT		10
#define PCAP_BATT_I_COIN		(1 << 14)
#define PCAP_BATT_COIN_CH_EN		(1 << 15)
#define PCAP_BATT_EOL_SEL_MASK		0x000e0000
#define PCAP_BATT_EOL_SEL_SHIFT		17
#define PCAP_BATT_EOL_CMP_EN		(1 << 20)
#define PCAP_BATT_BATT_DET_EN		(1 << 21)
#define PCAP_BATT_THERMBIAS_CTRL	(1 << 22)

#define PCAP_ADC_ADEN			(1 << 0)
#define PCAP_ADC_RAND			(1 << 1)
#define PCAP_ADC_AD_SEL1		(1 << 2)
#define PCAP_ADC_AD_SEL2		(1 << 3)
#define PCAP_ADC_ADA1_MASK		0x00000070
#define PCAP_ADC_ADA1_SHIFT		4
#define PCAP_ADC_ADA2_MASK		0x00000380
#define PCAP_ADC_ADA2_SHIFT		7
#define PCAP_ADC_ATO_MASK		0x00003c00
#define PCAP_ADC_ATO_SHIFT		10
#define PCAP_ADC_ATOX			(1 << 14)
#define PCAP_ADC_MTR1			(1 << 15)
#define PCAP_ADC_MTR2			(1 << 16)
#define PCAP_ADC_TS_M_MASK		0x000e0000
#define PCAP_ADC_TS_M_SHIFT		17
#define PCAP_ADC_TS_REF_LOWPWR		(1 << 20)
#define PCAP_ADC_TS_REFENB		(1 << 21)
#define PCAP_ADC_BATT_I_POLARITY	(1 << 22)
#define PCAP_ADC_BATT_I_ADC		(1 << 23)

#define PCAP_ADC_BANK_0			0
#define PCAP_ADC_BANK_1			1
/* ADC bank 0 */
#define PCAP_ADC_CH_COIN		0
#define PCAP_ADC_CH_BATT		1
#define PCAP_ADC_CH_BPLUS		2
#define PCAP_ADC_CH_MOBPORTB		3
#define PCAP_ADC_CH_TEMPERATURE		4
#define PCAP_ADC_CH_CHARGER_ID		5
#define PCAP_ADC_CH_AD6			6
/* ADC bank 1 */
#define PCAP_ADC_CH_AD7			0
#define PCAP_ADC_CH_AD8			1
#define PCAP_ADC_CH_AD9			2
#define PCAP_ADC_CH_TS_X1		3
#define PCAP_ADC_CH_TS_X2		4
#define PCAP_ADC_CH_TS_Y1		5
#define PCAP_ADC_CH_TS_Y2		6

#define PCAP_ADC_T_NOW			0
#define PCAP_ADC_T_IN_BURST		1
#define PCAP_ADC_T_OUT_BURST		2

#define PCAP_ADC_ATO_IN_BURST		6
#define PCAP_ADC_ATO_OUT_BURST		0

#define PCAP_ADC_TS_M_XY		1
#define PCAP_ADC_TS_M_PRESSURE		2
#define PCAP_ADC_TS_M_PLATE_X		3
#define PCAP_ADC_TS_M_PLATE_Y		4
#define PCAP_ADC_TS_M_STANDBY		5
#define PCAP_ADC_TS_M_NONTS		6

#define PCAP_ADR_ADD1_MASK		0x000003ff
#define PCAP_ADR_ADD1_SHIFT		0
#define PCAP_ADR_ADD2_MASK		0x000ffc00
#define PCAP_ADR_ADD2_SHIFT		10
#define PCAP_ADR_ADINC1			(1 << 20)
#define PCAP_ADR_ADINC2			(1 << 21)
#define PCAP_ADR_ASC			(1 << 22)
#define PCAP_ADR_ONESHOT		(1 << 23)

#define PCAP_BUSCTRL_FSENB		(1 << 0)
#define PCAP_BUSCTRL_USB_SUSPEND	(1 << 1)
#define PCAP_BUSCTRL_USB_PU		(1 << 2)
#define PCAP_BUSCTRL_USB_PD		(1 << 3)
#define PCAP_BUSCTRL_VUSB_EN		(1 << 4)
#define PCAP_BUSCTRL_USB_PS		(1 << 5)
#define PCAP_BUSCTRL_VUSB_MSTR_EN	(1 << 6)
#define PCAP_BUSCTRL_VBUS_PD_ENB	(1 << 7)
#define PCAP_BUSCTRL_CURRLIM		(1 << 8)
#define PCAP_BUSCTRL_RS232ENB		(1 << 9)
#define PCAP_BUSCTRL_RS232_DIR		(1 << 10)
#define PCAP_BUSCTRL_SE0_CONN		(1 << 11)
#define PCAP_BUSCTRL_USB_PDM		(1 << 12)
#define PCAP_BUSCTRL_BUS_PRI_ADJ	(1 << 24)

/* leds */
#define PCAP_LED0		0
#define PCAP_LED1		1
#define PCAP_BL0		2
#define PCAP_BL1		3
#define PCAP_LED_3MA		0
#define PCAP_LED_4MA		1
#define PCAP_LED_5MA		2
#define PCAP_LED_9MA		3
#define PCAP_LED_T_MASK		0xf
#define PCAP_LED_C_MASK		0x3
#define PCAP_BL_MASK		0x1f
#define PCAP_BL0_SHIFT		0
#define PCAP_LED0_EN		(1 << 5)
#define PCAP_LED1_EN		(1 << 6)
#define PCAP_LED0_T_SHIFT	7
#define PCAP_LED1_T_SHIFT	11
#define PCAP_LED0_C_SHIFT	15
#define PCAP_LED1_C_SHIFT	17
#define PCAP_BL1_SHIFT		20

/* RTC */
#define PCAP_RTC_DAY_MASK	0x3fff
#define PCAP_RTC_TOD_MASK	0xffff
#define PCAP_RTC_PC_MASK	0x7
#define SEC_PER_DAY		86400

#endif
                                                                                                                                                                                                                                                                                                           /*
 * Maxim8925 Interface
 *
 * Copyright (C) 2009 Marvell International Ltd.
 *	Haojian Zhuang <haojian.zhuang@marvell.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef __LINUX_MFD_MAX8925_H
#define __LINUX_MFD_MAX8925_H

#include <linux/mutex.h>
#include <linux/interrupt.h>

/* Unified sub device IDs for MAX8925 */
enum {
	MAX8925_ID_SD1,
	MAX8925_ID_SD2,
	MAX8925_ID_SD3,
	MAX8925_ID_LDO1,
	MAX8925_ID_LDO2,
	MAX8925_ID_LDO3,
	MAX8925_ID_LDO4,
	MAX8925_ID_LDO5,
	MAX8925_ID_LDO6,
	MAX8925_ID_LDO7,
	MAX8925_ID_LDO8,
	MAX8925_ID_LDO9,
	MAX8925_ID_LDO10,
	MAX8925_ID_LDO11,
	MAX8925_ID_LDO12,
	MAX8925_ID_LDO13,
	MAX8925_ID_LDO14,
	MAX8925_ID_LDO15,
	MAX8925_ID_LDO16,
	MAX8925_ID_LDO17,
	MAX8925_ID_LDO18,
	MAX8925_ID_LDO19,
	MAX8925_ID_LDO20,
	MAX8925_ID_MAX,
};

enum {
	/*
	 * Charging current threshold trigger going from fast charge
	 * to TOPOFF charge. From 5% to 20% of fasting charging current.
	 */
	MAX8925_TOPOFF_THR_5PER,
	MAX8925_TOPOFF_THR_10PER,
	MAX8925_TOPOFF_THR_15PER,
	MAX8925_TOPOFF_THR_20PER,
};

enum {
	/* Fast charging current */
	MAX8925_FCHG_85MA,
	MAX8925_FCHG_300MA,
	MAX8925_FCHG_460MA,
	MAX8925_FCHG_600MA,
	MAX8925_FCHG_700MA,
	MAX8925_FCHG_800MA,
	MAX8925_FCHG_900MA,
	MAX8925_FCHG_1000MA,
};

/* Charger registers */
#define MAX8925_CHG_IRQ1		(0x7e)
#define MAX8925_CHG_IRQ2		(0x7f)
#define MAX8925_CHG_IRQ1_MASK		(0x80)
#define MAX8925_CHG_IRQ2_MASK		(0x81)
#define MAX8925_CHG_STATUS		(0x82)

/* GPM registers */
#define MAX8925_SYSENSEL		(0x00)
#define MAX8925_ON_OFF_IRQ1		(0x01)
#define MAX8925_ON_OFF_IRQ1_MASK	(0x02)
#define MAX8925_ON_OFF_STATUS		(0x03)
#define MAX8925_ON_OFF_IRQ2		(0x0d)
#define MAX8925_ON_OFF_IRQ2_MASK	(0x0e)
#define MAX8925_RESET_CNFG		(0x0f)

/* Touch registers */
#define MAX8925_TSC_IRQ			(0x00)
#define MAX8925_TSC_IRQ_MASK		(0x01)
#define MAX8925_TSC_CNFG1		(0x02)
#define MAX8925_ADC_SCHED		(0x10)
#define MAX8925_ADC_RES_END		(0x6f)

#define MAX8925_NREF_OK			(1 << 4)

/* RTC registers */
#define MAX8925_ALARM0_CNTL		(0x18)
#define MAX8925_ALARM1_CNTL		(0x19)
#define MAX8925_RTC_IRQ			(0x1c)
#define MAX8925_RTC_IRQ_MASK		(0x1d)
#define MAX8925_MPL_CNTL		(0x1e)

/* WLED registers */
#define MAX8925_WLED_MODE_CNTL		(0x84)
#define MAX8925_WLED_CNTL		(0x85)

/* MAX8925 Registers */
#define MAX8925_SDCTL1			(0x04)
#define MAX8925_SDCTL2			(0x07)
#define MAX8925_SDCTL3			(0x0A)
#define MAX8925_SDV1			(0x06)
#define MAX8925_SDV2			(0x09)
#define MAX8925_SDV3			(0x0C)
#define MAX8925_LDOCTL1			(0x18)
#define MAX8925_LDOCTL2			(0x1C)
#define MAX8925_LDOCTL3			(0x20)
#define MAX8925_LDOCTL4			(0x24)
#define MAX8925_LDOCTL5			(0x28)
#define MAX8925_LDOCTL6			(0x2C)
#define MAX8925_LDOCTL7			(0x30)
#define MAX8925_LDOCTL8			(0x34)
#define MAX8925_LDOCTL9			(0x38)
#define MAX8925_LDOCTL10		(0x3C)
#define MAX8925_LDOCTL11		(0x40)
#define MAX8925_LDOCTL12		(0x44)
#define MAX8925_LDOCTL13		(0x48)
#define MAX8925_LDOCTL14		(0x4C)
#define MAX8925_LDOCTL15		(0x50)
#define MAX8925_LDOCTL16		(0x10)
#define MAX8925_LDOCTL17		(0x14)
#define MAX8925_LDOCTL18		(0x72)
#define MAX8925_LDOCTL19		(0x5C)
#define MAX8925_LDOCTL20		(0x9C)
#define MAX8925_LDOVOUT1		(0x1A)
#define MAX8925_LDOVOUT2		(0x1E)
#define MAX8925_LDOVOUT3		(0x22)
#define MAX8925_LDOVOUT4		(0x26)
#define MAX8925_LDOVOUT5		(0x2A)
#define MAX8925_LDOVOUT6		(0x2E)
#define MAX8925_LDOVOUT7		(0x32)
#define MAX8925_LDOVOUT8		(0x36)
#define MAX8925_LDOVOUT9		(0x3A)
#define MAX8925_LDOVOUT10		(0x3E)
#define MAX8925_LDOVOUT11		(0x42)
#define MAX8925_LDOVOUT12		(0x46)
#define MAX8925_LDOVOUT13		(0x4A)
#define MAX8925_LDOVOUT14		(0x4E)
#define MAX8925_LDOVOUT15		(0x52)
#define MAX8925_LDOVOUT16		(0x12)
#define MAX8925_LDOVOUT17		(0x16)
#define MAX8925_LDOVOUT18		(0x74)
#define MAX8925_LDOVOUT19		(0x5E)
#define MAX8925_LDOVOUT20		(0x9E)

/* bit definitions */
#define CHG_IRQ1_MASK			(0x07)
#define CHG_IRQ2_MASK			(0xff)
#define ON_OFF_IRQ1_MASK		(0xff)
#define ON_OFF_IRQ2_MASK		(0x03)
#define TSC_IRQ_MASK			(0x03)
#define RTC_IRQ_MASK			(0x0c)

#define MAX8925_NAME_SIZE		(32)

/* IRQ definitions */
enum {
	MAX8925_IRQ_VCHG_DC_OVP,
	MAX8925_IRQ_VCHG_DC_F,
	MAX8925_IRQ_VCHG_DC_R,
	MAX8925_IRQ_VCHG_THM_OK_R,
	MAX8925_IRQ_VCHG_THM_OK_F,
	MAX8925_IRQ_VCHG_SYSLOW_F,
	MAX8925_IRQ_VCHG_SYSLOW_R,
	MAX8925_IRQ_VCHG_RST,
	MAX8925_IRQ_VCHG_DONE,
	MAX8925_IRQ_VCHG_TOPOFF,
	MAX8925_IRQ_VCHG_TMR_FAULT,
	MAX8925_IRQ_GPM_RSTIN,
	MAX8925_IRQ_GPM_MPL,
	MAX8925_IRQ_GPM_SW_3SEC,
	MAX8925_IRQ_GPM_EXTON_F,
	MAX8925_IRQ_GPM_EXTON_R,
	MAX8925_IRQ_GPM_SW_1SEC,
	MAX8925_IRQ_GPM_SW_F,
	MAX8925_IRQ_GPM_SW_R,
	MAX8925_IRQ_GPM_SYSCKEN_F,
	MAX8925_IRQ_GPM_SYSCKEN_R,
	MAX8925_IRQ_RTC_ALARM1,
	MAX8925_IRQ_RTC_ALARM0,
	MAX8925_IRQ_TSC_STICK,
	MAX8925_IRQ_TSC_NSTICK,
	MAX8925_NR_IRQS,
};



struct max8925_chip {
	struct device		*dev;
	struct i2c_client	*i2c;
	struct i2c_client	*adc;
	struct i2c_client	*rtc;
	struct mutex		io_lock;
	struct mutex		irq_lock;

	int			irq_base;
	int			core_irq;
	int			tsc_irq;
	unsigned int            wakeup_flag;
};

struct max8925_backlight_pdata {
	int	lxw_scl;	/* 0/1 -- 0.8Ohm/0.4Ohm */
	int	lxw_freq;	/* 700KHz ~ 1400KHz */
	int	dual_string;	/* 0/1 -- single/dual string */
};

struct max8925_touch_pdata {
	unsigned int		flags;
};

struct max8925_power_pdata {
	int		(*set_charger)(int);
	unsigned	batt_detect:1;
	unsigned	topoff_threshold:2;
	unsigned	fast_charge:3;	/* charge current */
	unsigned	no_temp_support:1; /* set if no temperature detect */
	unsigned	no_insert_detect:1; /* set if no ac insert detect */
	char		**supplied_to;
	int		num_supplicants;
};

/*
 * irq_base: stores IRQ base number of MAX8925 in platform
 * tsc_irq: stores IRQ number of MAX8925 TSC
 */
struct max8925_platform_data {
	struct max8925_backlight_pdata	*backlight;
	struct max8925_touch_pdata	*touch;
	struct max8925_power_pdata	*power;
	struct regulator_init_data	*sd1;
	struct regulator_init_data	*sd2;
	struct regulator_init_data	*sd3;
	struct regulator_init_data	*ldo1;
	struct regulator_init_data	*ldo2;
	struct regulator_init_data	*ldo3;
	struct regulator_init_data	*ldo4;
	struct regulator_init_data	*ldo5;
	struct regulator_init_data	*ldo6;
	struct regulator_init_data	*ldo7;
	struct regulator_init_data	*ldo8;
	struct regulator_init_data	*ldo9;
	struct regulator_init_data	*ldo10;
	struct regulator_init_data	*ldo11;
	struct regulator_init_data	*ldo12;
	struct regulator_init_data	*ldo13;
	struct regulator_init_data	*ldo14;
	struct regulator_init_data	*ldo15;
	struct regulator_init_data	*ldo16;
	struct regulator_init_data	*ldo17;
	struct regulator_init_data	*ldo18;
	struct regulator_init_data	*ldo19;
	struct regulator_init_data	*ldo20;

	int		irq_base;
	int		tsc_irq;
};

extern int max8925_reg_read(struct i2c_client *, int);
extern int max8925_reg_write(struct i2c_client *, int, unsigned char);
extern int max8925_bulk_read(struct i2c_client *, int, int, unsigned char *);
extern int max8925_bulk_write(struct i2c_client *, int, int, unsigned char *);
extern int max8925_set_bits(struct i2c_client *, int, unsigned char,
			unsigned char);

extern int max8925_device_init(struct max8925_chip *,
				struct max8925_platform_data *);
extern void max8925_device_exit(struct max8925_chip *);
#endif /* __LINUX_MFD_MAX8925_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * max8997-private.h - Voltage regulator driver for the Maxim 8997
 *
 *  Copyright (C) 2010 Samsung Electrnoics
 *  MyungJoo Ham <myungjoo.ham@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef __LINUX_MFD_MAX8997_PRIV_H
#define __LINUX_MFD_MAX8997_PRIV_H

#include <linux/i2c.h>
#include <linux/export.h>
#include <linux/irqdomain.h>

#define MAX8997_REG_INVALID	(0xff)

enum max8997_pmic_reg {
	MAX8997_REG_PMIC_ID0	= 0x00,
	MAX8997_REG_PMIC_ID1	= 0x01,
	MAX8997_REG_INTSRC	= 0x02,
	MAX8997_REG_INT1	= 0x03,
	MAX8997_REG_INT2	= 0x04,
	MAX8997_REG_INT3	= 0x05,
	MAX8997_REG_INT4	= 0x06,

	MAX8997_REG_INT1MSK	= 0x08,
	MAX8997_REG_INT2MSK	= 0x09,
	MAX8997_REG_INT3MSK	= 0x0a,
	MAX8997_REG_INT4MSK	= 0x0b,

	MAX8997_REG_STATUS1	= 0x0d,
	MAX8997_REG_STATUS2	= 0x0e,
	MAX8997_REG_STATUS3	= 0x0f,
	MAX8997_REG_STATUS4	= 0x10,

	MAX8997_REG_MAINCON1	= 0x13,
	MAX8997_REG_MAINCON2	= 0x14,
	MAX8997_REG_BUCKRAMP	= 0x15,

	MAX8997_REG_BUCK1CTRL	= 0x18,
	MAX8997_REG_BUCK1DVS1	= 0x19,
	MAX8997_REG_BUCK1DVS2	= 0x1a,
	MAX8997_REG_BUCK1DVS3	= 0x1b,
	MAX8997_REG_BUCK1DVS4	= 0x1c,
	MAX8997_REG_BUCK1DVS5	= 0x1d,
	MAX8997_REG_BUCK1DVS6	= 0x1e,
	MAX8997_REG_BUCK1DVS7	= 0x1f,
	MAX8997_REG_BUCK1DVS8	= 0x20,
	MAX8997_REG_BUCK2CTRL	= 0x21,
	MAX8997_REG_BUCK2DVS1	= 0x22,
	MAX8997_REG_BUCK2DVS2	= 0x23,
	MAX8997_REG_BUCK2DVS3	= 0x24,
	MAX8997_REG_BUCK2DVS4	= 0x25,
	MAX8997_REG_BUCK2DVS5	= 0x26,
	MAX8997_REG_BUCK2DVS6	= 0x27,
	MAX8997_REG_BUCK2DVS7	= 0x28,
	MAX8997_REG_BUCK2DVS8	= 0x29,
	MAX8997_REG_BUCK3CTRL	= 0x2a,
	MAX8997_REG_BUCK3DVS	= 0x2b,
	MAX8997_REG_BUCK4CTRL	= 0x2c,
	MAX8997_REG_BUCK4DVS	= 0x2d,
	MAX8997_REG_BUCK5CTRL	= 0x2e,
	MAX8997_REG_BUCK5DVS1	= 0x2f,
	MAX8997_REG_BUCK5DVS2	= 0x30,
	MAX8997_REG_BUCK5DVS3	= 0x31,
	MAX8997_REG_BUCK5DVS4	= 0x32,
	MAX8997_REG_BUCK5DVS5	= 0x33,
	MAX8997_REG_BUCK5DVS6	= 0x34,
	MAX8997_REG_BUCK5DVS7	= 0x35,
	MAX8997_REG_BUCK5DVS8	= 0x36,
	MAX8997_REG_BUCK6CTRL	= 0x37,
	MAX8997_REG_BUCK6BPSKIPCTRL	= 0x38,
	MAX8997_REG_BUCK7CTRL	= 0x39,
	MAX8997_REG_BUCK7DVS	= 0x3a,
	MAX8997_REG_LDO1CTRL	= 0x3b,
	MAX8997_REG_LDO2CTRL	= 0x3c,
	MAX8997_REG_LDO3CTRL	= 0x3d,
	MAX8997_REG_LDO4CTRL	= 0x3e,
	MAX8997_REG_LDO5CTRL	= 0x3f,
	MAX8997_REG_LDO6CTRL	= 0x40,
	MAX8997_REG_LDO7CTRL	= 0x41,
	MAX8997_REG_LDO8CTRL	= 0x42,
	MAX8997_REG_LDO9CTRL	= 0x43,
	MAX8997_REG_LDO10CTRL	= 0x44,
	MAX8997_REG_LDO11CTRL	= 0x45,
	MAX8997_REG_LDO12CTRL	= 0x46,
	MAX8997_REG_LDO13CTRL	= 0x47,
	MAX8997_REG_LDO14CTRL	= 0x48,
	MAX8997_REG_LDO15CTRL	= 0x49,
	MAX8997_REG_LDO16CTRL	= 0x4a,
	MAX8997_REG_LDO17CTRL	= 0x4b,
	MAX8997_REG_LDO18CTRL	= 0x4c,
	MAX8997_REG_LDO21CTRL	= 0x4d,

	MAX8997_REG_MBCCTRL1	= 0x50,
	MAX8997_REG_MBCCTRL2	= 0x51,
	MAX8997_REG_MBCCTRL3	= 0x52,
	MAX8997_REG_MBCCTRL4	= 0x53,
	MAX8997_REG_MBCCTRL5	= 0x54,
	MAX8997_REG_MBCCTRL6	= 0x55,
	MAX8997_REG_OTPCGHCVS	= 0x56,

	MAX8997_REG_SAFEOUTCTRL	= 0x5a,

	MAX8997_REG_LBCNFG1	= 0x5e,
	MAX8997_REG_LBCNFG2	= 0x5f,
	MAX8997_REG_BBCCTRL	= 0x60,

	MAX8997_REG_FLASH1_CUR	= 0x63, /* 0x63 ~ 0x6e for FLASH */
	MAX8997_REG_FLASH2_CUR	= 0x64,
	MAX8997_REG_MOVIE_CUR	= 0x65,
	MAX8997_REG_GSMB_CUR	= 0x66,
	MAX8997_REG_BOOST_CNTL	= 0x67,
	MAX8997_REG_LEN_CNTL	= 0x68,
	MAX8997_REG_FLASH_CNTL	= 0x69,
	MAX8997_REG_WDT_CNTL	= 0x6a,
	MAX8997_REG_MAXFLASH1	= 0x6b,
	MAX8997_REG_MAXFLASH2	= 0x6c,
	MAX8997_REG_FLASHSTATUS	= 0x6d,
	MAX8997_REG_FLASHSTATUSMASK	= 0x6e,

	MAX8997_REG_GPIOCNTL1	= 0x70,
	MAX8997_REG_GPIOCNTL2	= 0x71,
	MAX8997_REG_GPIOCNTL3	= 0x72,
	MAX8997_REG_GPIOCNTL4	= 0x73,
	MAX8997_REG_GPIOCNTL5	= 0x74,
	MAX8997_REG_GPIOCNTL6	= 0x75,
	MAX8997_REG_GPIOCNTL7	= 0x76,
	MAX8997_REG_GPIOCNTL8	= 0x77,
	MAX8997_REG_GPIOCNTL9	= 0x78,
	MAX8997_REG_GPIOCNTL10	= 0x79,
	MAX8997_REG_GPIOCNTL11	= 0x7a,
	MAX8997_REG_GPIOCNTL12	= 0x7b,

	MAX8997_REG_LDO1CONFIG	= 0x80,
	MAX8997_REG_LDO2CONFIG	= 0x81,
	MAX8997_REG_LDO3CONFIG	= 0x82,
	MAX8997_REG_LDO4CONFIG	= 0x83,
	MAX8997_REG_LDO5CONFIG	= 0x84,
	MAX8997_REG_LDO6CONFIG	= 0x85,
	MAX8997_REG_LDO7CONFIG	= 0x86,
	MAX8997_REG_LDO8CONFIG	= 0x87,
	MAX8997_REG_LDO9CONFIG	= 0x88,
	MAX8997_REG_LDO10CONFIG	= 0x89,
	MAX8997_REG_LDO11CONFIG	= 0x8a,
	MAX8997_REG_LDO12CONFIG	= 0x8b,
	MAX8997_REG_LDO13CONFIG	= 0x8c,
	MAX8997_REG_LDO14CONFIG	= 0x8d,
	MAX8997_REG_LDO15CONFIG	= 0x8e,
	MAX8997_REG_LDO16CONFIG	= 0x8f,
	MAX8997_REG_LDO17CONFIG	= 0x90,
	MAX8997_REG_LDO18CONFIG	= 0x91,
	MAX8997_REG_LDO21CONFIG	= 0x92,

	MAX8997_REG_DVSOKTIMER1	= 0x97,
	MAX8997_REG_DVSOKTIMER2	= 0x98,
	MAX8997_REG_DVSOKTIMER4	= 0x99,
	MAX8997_REG_DVSOKTIMER5	= 0x9a,

	MAX8997_REG_PMIC_END	= 0x9b,
};

enum max8997_muic_reg {
	MAX8997_MUIC_REG_ID		= 0x0,
	MAX8997_MUIC_REG_INT1		= 0x1,
	MAX8997_MUIC_REG_INT2		= 0x2,
	MAX8997_MUIC_REG_INT3		= 0x3,
	MAX8997_MUIC_REG_STATUS1	= 0x4,
	MAX8997_MUIC_REG_STATUS2	= 0x5,
	MAX8997_MUIC_REG_STATUS3	= 0x6,
	MAX8997_MUIC_REG_INTMASK1	= 0x7,
	MAX8997_MUIC_REG_INTMASK2	= 0x8,
	MAX8997_MUIC_REG_INTMASK3	= 0x9,
	MAX8997_MUIC_REG_CDETCTRL	= 0xa,

	MAX8997_MUIC_REG_CONTROL1	= 0xc,
	MAX8997_MUIC_REG_CONTROL2	= 0xd,
	MAX8997_MUIC_REG_CONTROL3	= 0xe,

	MAX8997_MUIC_REG_END		= 0xf,
};

/* MAX8997-MUIC STATUS1 register */
#define STATUS1_ADC_SHIFT		0
#define STATUS1_ADCLOW_SHIFT		5
#define STATUS1_ADCERR_SHIFT		6
#define STATUS1_ADC_MASK		(0x1f << STATUS1_ADC_SHIFT)
#define STATUS1_ADCLOW_MASK		(0x1 << STATUS1_ADCLOW_SHIFT)
#define STATUS1_ADCERR_MASK		(0x1 << STATUS1_ADCERR_SHIFT)

/* MAX8997-MUIC STATUS2 register */
#define STATUS2_CHGTYP_SHIFT		0
#define STATUS2_CHGDETRUN_SHIFT		3
#define STATUS2_DCDTMR_SHIFT		4
#define STATUS2_DBCHG_SHIFT		5
#define STATUS2_VBVOLT_SHIFT		6
#define STATUS2_CHGTYP_MASK		(0x7 << STATUS2_CHGTYP_SHIFT)
#define STATUS2_CHGDETRUN_MASK		(0x1 << STATUS2_CHGDETRUN_SHIFT)
#define STATUS2_DCDTMR_MASK		(0x1 << STATUS2_DCDTMR_SHIFT)
#define STATUS2_DBCHG_MASK		(0x1 << STATUS2_DBCHG_SHIFT)
#define STATUS2_VBVOLT_MASK		(0x1 << STATUS2_VBVOLT_SHIFT)

/* MAX8997-MUIC STATUS3 register */
#define STATUS3_OVP_SHIFT		2
#define STATUS3_OVP_MASK		(0x1 << STATUS3_OVP_SHIFT)

/* MAX8997-MUIC CONTROL1 register */
#define COMN1SW_SHIFT			0
#define COMP2SW_SHIFT			3
#define COMN1SW_MASK			(0x7 << COMN1SW_SHIFT)
#define COMP2SW_MASK			(0x7 << COMP2SW_SHIFT)
#define COMP_SW_MASK		(COMP2SW_MASK | COMN1SW_MASK)

#define CONTROL1_SW_USB			((1 << COMP2SW_SHIFT) \
						| (1 << COMN1SW_SHIFT))
#define CONTROL1_SW_AUDIO		((2 << COMP2SW_SHIFT) \
						| (2 << COMN1SW_SHIFT))
#define CONTROL1_SW_UART		((3 << COMP2SW_SHIFT) \
						| (3 << COMN1SW_SHIFT))
#define CONTROL1_SW_OPEN		((0 << COMP2SW_SHIFT) \
						| (0 << COMN1SW_SHIFT))

#define CONTROL2_LOWPWR_SHIFT		(0)
#define CONTROL2_ADCEN_SHIFT		(1)
#define CONTROL2_CPEN_SHIFT		(2)
#define CONTROL2_SFOUTASRT_SHIFT	(3)
#define CONTROL2_SFOUTORD_SHIFT		(4)
#define CONTROL2_ACCDET_SHIFT		(5)
#define CONTROL2_USBCPINT_SHIFT		(6)
#define CONTROL2_RCPS_SHIFT		(7)
#define CONTROL2_LOWPWR_MASK		(0x1 << CONTROL2_LOWPWR_SHIFT)
#define CONTROL2_ADCEN_MASK		(0x1 << CONTROL2_ADCEN_SHIFT)
#define CONTROL2_CPEN_MASK		(0x1 << CONTROL2_CPEN_SHIFT)
#define CONTROL2_SFOUTASRT_MASK		(0x1 << CONTROL2_SFOUTASRT_SHIFT)
#define CONTROL2_SFOUTORD_MASK		(0x1 << CONTROL2_SFOUTORD_SHIFT)
#define CONTROL2_ACCDET_MASK		(0x1 << CONTROL2_ACCDET_SHIFT)
#define CONTROL2_USBCPINT_MASK		(0x1 << CONTROL2_USBCPINT_SHIFT)
#define CONTROL2_RCPS_MASK		(0x1 << CONTROL2_RCPS_SHIFT)

#define CONTROL3_JIGSET_SHIFT		(0)
#define CONTROL3_BTLDSET_SHIFT		(2)
#define CONTROL3_ADCDBSET_SHIFT		(4)
#define CONTROL3_JIGSET_MASK		(0x3 << CONTROL3_JIGSET_SHIFT)
#define CONTROL3_BTLDSET_MASK		(0x3 << CONTROL3_BTLDSET_SHIFT)
#define CONTROL3_ADCDBSET_MASK		(0x3 << CONTROL3_ADCDBSET_SHIFT)

enum max8997_haptic_reg {
	MAX8997_HAPTIC_REG_GENERAL	= 0x00,
	MAX8997_HAPTIC_REG_CONF1	= 0x01,
	MAX8997_HAPTIC_REG_CONF2	= 0x02,
	MAX8997_HAPTIC_REG_DRVCONF	= 0x03,
	MAX8997_HAPTIC_REG_CYCLECONF1	= 0x04,
	MAX8997_HAPTIC_REG_CYCLECONF2	= 0x05,
	MAX8997_HAPTIC_REG_SIGCONF1	= 0x06,
	MAX8997_HAPTIC_REG_SIGCONF2	= 0x07,
	MAX8997_HAPTIC_REG_SIGCONF3	= 0x08,
	MAX8997_HAPTIC_REG_SIGCONF4	= 0x09,
	MAX8997_HAPTIC_REG_SIGDC1	= 0x0a,
	MAX8997_HAPTIC_REG_SIGDC2	= 0x0b,
	MAX8997_HAPTIC_REG_SIGPWMDC1	= 0x0c,
	MAX8997_HAPTIC_REG_SIGPWMDC2	= 0x0d,
	MAX8997_HAPTIC_REG_SIGPWMDC3	= 0x0e,
	MAX8997_HAPTIC_REG_SIGPWMDC4	= 0x0f,
	MAX8997_HAPTIC_REG_MTR_REV	= 0x10,

	MAX8997_HAPTIC_REG_END		= 0x11,
};

/* slave addr = 0x0c: using "2nd part" of rev4 datasheet */
enum max8997_rtc_reg {
	MAX8997_RTC_CTRLMASK		= 0x02,
	MAX8997_RTC_CTRL		= 0x03,
	MAX8997_RTC_UPDATE1		= 0x04,
	MAX8997_RTC_UPDATE2		= 0x05,
	MAX8997_RTC_WTSR_SMPL		= 0x06,

	MAX8997_RTC_SEC			= 0x10,
	MAX8997_RTC_MIN			= 0x11,
	MAX8997_RTC_HOUR		= 0x12,
	MAX8997_RTC_DAY_OF_WEEK		= 0x13,
	MAX8997_RTC_MONTH		= 0x14,
	MAX8997_RTC_YEAR		= 0x15,
	MAX8997_RTC_DAY_OF_MONTH	= 0x16,
	MAX8997_RTC_ALARM1_SEC		= 0x17,
	MAX8997_RTC_ALARM1_MIN		= 0x18,
	MAX8997_RTC_ALARM1_HOUR		= 0x19,
	MAX8997_RTC_ALARM1_DAY_OF_WEEK	= 0x1a,
	MAX8997_RTC_ALARM1_MONTH	= 0x1b,
	MAX8997_RTC_ALARM1_YEAR		= 0x1c,
	MAX8997_RTC_ALARM1_DAY_OF_MONTH	= 0x1d,
	MAX8997_RTC_ALARM2_SEC		= 0x1e,
	MAX8997_RTC_ALARM2_MIN		= 0x1f,
	MAX8997_RTC_ALARM2_HOUR		= 0x20,
	MAX8997_RTC_ALARM2_DAY_OF_WEEK	= 0x21,
	MAX8997_RTC_ALARM2_MONTH	= 0x22,
	MAX8997_RTC_ALARM2_YEAR		= 0x23,
	MAX8997_RTC_ALARM2_DAY_OF_MONTH	= 0x24,
};

enum max8997_irq_source {
	PMIC_INT1 = 0,
	PMIC_INT2,
	PMIC_INT3,
	PMIC_INT4,

	FUEL_GAUGE, /* Ignored (MAX17042 driver handles) */

	MUIC_INT1,
	MUIC_INT2,
	MUIC_INT3,

	GPIO_LOW, /* Not implemented */
	GPIO_HI, /* Not implemented */

	FLASH_STATUS, /* Not implemented */

	MAX8997_IRQ_GROUP_NR,
};

enum max8997_irq {
	MAX8997_PMICIRQ_PWRONR,
	MAX8997_PMICIRQ_PWRONF,
	MAX8997_PMICIRQ_PWRON1SEC,
	MAX8997_PMICIRQ_JIGONR,
	MAX8997_PMICIRQ_JIGONF,
	MAX8997_PMICIRQ_LOWBAT2,
	MAX8997_PMICIRQ_LOWBAT1,

	MAX8997_PMICIRQ_JIGR,
	MAX8997_PMICIRQ_JIGF,
	MAX8997_PMICIRQ_MR,
	MAX8997_PMICIRQ_DVS1OK,
	MAX8997_PMICIRQ_DVS2OK,
	MAX8997_PMICIRQ_DVS3OK,
	MAX8997_PMICIRQ_DVS4OK,

	MAX8997_PMICIRQ_CHGINS,
	MAX8997_PMICIRQ_CHGRM,
	MAX8997_PMICIRQ_DCINOVP,
	MAX8997_PMICIRQ_TOPOFFR,
	MAX8997_PMICIRQ_CHGRSTF,
	MAX8997_PMICIRQ_MBCHGTMEXPD,

	MAX8997_PMICIRQ_RTC60S,
	MAX8997_PMICIRQ_RTCA1,
	MAX8997_PMICIRQ_RTCA2,
	MAX8997_PMICIRQ_SMPL_INT,
	MAX8997_PMICIRQ_RTC1S,
	MAX8997_PMICIRQ_WTSR,

	MAX8997_MUICIRQ_ADCError,
	MAX8997_MUICIRQ_ADCLow,
	MAX8997_MUICIRQ_ADC,

	MAX8997_MUICIRQ_VBVolt,
	MAX8997_MUICIRQ_DBChg,
	MAX8997_MUICIRQ_DCDTmr,
	MAX8997_MUICIRQ_ChgDetRun,
	MAX8997_MUICIRQ_ChgTyp,

	MAX8997_MUICIRQ_OVP,

	MAX8997_IRQ_NR,
};

#define MAX8997_NUM_GPIO	12
struct max8997_dev {
	struct device *dev;
	struct max8997_platform_data *pdata;
	struct i2c_client *i2c; /* 0xcc / PMIC, Battery Control, and FLASH */
	struct i2c_client *rtc; /* slave addr 0x0c */
	struct i2c_client *haptic; /* slave addr 0x90 */
	struct i2c_client *muic; /* slave addr 0x4a */
	struct mutex iolock;

	unsigned long type;
	struct platform_device *battery; /* battery control (not fuel gauge) */

	int irq;
	int ono;
	struct irq_domain *irq_domain;
	struct mutex irqlock;
	int irq_masks_cur[MAX8997_IRQ_GROUP_NR];
	int irq_masks_cache[MAX8997_IRQ_GROUP_NR];

	/* For hibernation */
	u8 reg_dump[MAX8997_REG_PMIC_END + MAX8997_MUIC_REG_END +
		MAX8997_HAPTIC_REG_END];

	bool gpio_status[MAX8997_NUM_GPIO];
};

enum max8997_types {
	TYPE_MAX8997,
	TYPE_MAX8966,
};

extern int max8997_irq_init(struct max8997_dev *max8997);
extern void max8997_irq_exit(struct max8997_dev *max8997);
extern int max8997_irq_resume(struct max8997_dev *max8997);

extern int max8997_read_reg(struct i2c_client *i2c, u8 reg, u8 *dest);
extern int max8997_bulk_read(struct i2c_client *i2c, u8 reg, int count,
				u8 *buf);
extern int max8997_write_reg(struct i2c_client *i2c, u8 reg, u8 value);
extern int max8997_bulk_write(struct i2c_client *i2c, u8 reg, int count,
				u8 *buf);
extern int max8997_update_reg(struct i2c_client *i2c, u8 reg, u8 val, u8 mask);

#define MAX8997_GPIO_INT_BOTH	(0x3 << 4)
#define MAX8997_GPIO_INT_RISE	(0x2 << 4)
#define MAX8997_GPIO_INT_FALL	(0x1 << 4)

#define MAX8997_GPIO_INT_MASK	(0x3 << 4)
#define MAX8997_GPIO_DATA_MASK	(0x1 << 2)
#endif /*  __LINUX_MFD_MAX8997_PRIV_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * include/linux/mfd/wl1273-core.h
 *
 * Some definitions for the wl1273 radio receiver/transmitter chip.
 *
 * Copyright (C) 2010 Nokia Corporation
 * Author: Matti J. Aaltonen <matti.j.aaltonen@nokia.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */

#ifndef WL1273_CORE_H
#define WL1273_CORE_H

#include <linux/i2c.h>
#include <linux/mfd/core.h>

#define WL1273_FM_DRIVER_NAME	"wl1273-fm"
#define RX71_FM_I2C_ADDR	0x22

#define WL1273_STEREO_GET		0
#define WL1273_RSSI_LVL_GET		1
#define WL1273_IF_COUNT_GET		2
#define WL1273_FLAG_GET			3
#define WL1273_RDS_SYNC_GET		4
#define WL1273_RDS_DATA_GET		5
#define WL1273_FREQ_SET			10
#define WL1273_AF_FREQ_SET		11
#define WL1273_MOST_MODE_SET		12
#define WL1273_MOST_BLEND_SET		13
#define WL1273_DEMPH_MODE_SET		14
#define WL1273_SEARCH_LVL_SET		15
#define WL1273_BAND_SET			16
#define WL1273_MUTE_STATUS_SET		17
#define WL1273_RDS_PAUSE_LVL_SET	18
#define WL1273_RDS_PAUSE_DUR_SET	19
#define WL1273_RDS_MEM_SET		20
#define WL1273_RDS_BLK_B_SET		21
#define WL1273_RDS_MSK_B_SET		22
#define WL1273_RDS_PI_MASK_SET		23
#define WL1273_RDS_PI_SET		24
#define WL1273_RDS_SYSTEM_SET		25
#define WL1273_INT_MASK_SET		26
#define WL1273_SEARCH_DIR_SET		27
#define WL1273_VOLUME_SET		28
#define WL1273_AUDIO_ENABLE		29
#define WL1273_PCM_MODE_SET		30
#define WL1273_I2S_MODE_CONFIG_SET	31
#define WL1273_POWER_SET		32
#define WL1273_INTX_CONFIG_SET		33
#define WL1273_PULL_EN_SET		34
#define WL1273_HILO_SET			35
#define WL1273_SWITCH2FREF		36
#define WL1273_FREQ_DRIFT_REPORT	37

#define WL1273_PCE_GET			40
#define WL1273_FIRM_VER_GET		41
#define WL1273_ASIC_VER_GET		42
#define WL1273_ASIC_ID_GET		43
#define WL1273_MAN_ID_GET		44
#define WL1273_TUNER_MODE_SET		45
#define WL1273_STOP_SEARCH		46
#define WL1273_RDS_CNTRL_SET		47

#define WL1273_WRITE_HARDWARE_REG	100
#define WL1273_CODE_DOWNLOAD		101
#define WL1273_RESET			102

#define WL1273_FM_POWER_MODE		254
#define WL1273_FM_INTERRUPT		255

/* Transmitter API */

#define WL1273_CHANL_SET			55
#define WL1273_SCAN_SPACING_SET			56
#define WL1273_REF_SET				57
#define WL1273_POWER_ENB_SET			90
#define WL1273_POWER_ATT_SET			58
#define WL1273_POWER_LEV_SET			59
#define WL1273_AUDIO_DEV_SET			60
#define WL1273_PILOT_DEV_SET			61
#define WL1273_RDS_DEV_SET			62
#define WL1273_PUPD_SET				91
#define WL1273_AUDIO_IO_SET			63
#define WL1273_PREMPH_SET			64
#define WL1273_MONO_SET				66
#define WL1273_MUTE				92
#define WL1273_MPX_LMT_ENABLE			67
#define WL1273_PI_SET				93
#define WL1273_ECC_SET				69
#define WL1273_PTY				70
#define WL1273_AF				71
#define WL1273_DISPLAY_MODE			74
#define WL1273_RDS_REP_SET			77
#define WL1273_RDS_CONFIG_DATA_SET		98
#define WL1273_RDS_DATA_SET			99
#define WL1273_RDS_DATA_ENB			94
#define WL1273_TA_SET				78
#define WL1273_TP_SET				79
#define WL1273_DI_SET				80
#define WL1273_MS_SET				81
#define WL1273_PS_SCROLL_SPEED			82
#define WL1273_TX_AUDIO_LEVEL_TEST		96
#define WL1273_TX_AUDIO_LEVEL_TEST_THRESHOLD	73
#define WL1273_TX_AUDIO_INPUT_LEVEL_RANGE_SET	54
#define WL1273_RX_ANTENNA_SELECT		87
#define WL1273_I2C_DEV_ADDR_SET			86
#define WL1273_REF_ERR_CALIB_PARAM_SET		88
#define WL1273_REF_ERR_CALIB_PERIODICITY_SET	89
#define WL1273_SOC_INT_TRIGGER			52
#define WL1273_SOC_AUDIO_PATH_SET		83
#define WL1273_SOC_PCMI_OVERRIDE		84
#define WL1273_SOC_I2S_OVERRIDE			85
#define WL1273_RSSI_BLOCK_SCAN_FREQ_SET		95
#define WL1273_RSSI_BLOCK_SCAN_START		97
#define WL1273_RSSI_BLOCK_SCAN_DATA_GET		5
#define WL1273_READ_FMANT_TUNE_VALUE		104

#define WL1273_RDS_OFF		0
#define WL1273_RDS_ON		1
#define WL1273_RDS_RESET	2

#define WL1273_AUDIO_DIGITAL	0
#define WL1273_AUDIO_ANALOG	1

#define WL1273_MODE_RX		BIT(0)
#define WL1273_MODE_TX		BIT(1)
#define WL1273_MODE_OFF		BIT(2)
#define WL1273_MODE_SUSPENDED	BIT(3)

#define WL1273_RADIO_CHILD	BIT(0)
#define WL1273_CODEC_CHILD	BIT(1)

#define WL1273_RX_MONO		1
#define WL1273_RX_STEREO	0
#define WL1273_TX_MONO		0
#define WL1273_TX_STEREO	1

#define WL1273_MAX_VOLUME	0xffff
#define WL1273_DEFAULT_VOLUME	0x78b8

/* I2S protocol, left channel first, data width 16 bits */
#define WL1273_PCM_DEF_MODE		0x00

/* Rx */
#define WL1273_AUDIO_ENABLE_I2S		BIT(0)
#define WL1273_AUDIO_ENABLE_ANALOG	BIT(1)

/* Tx */
#define WL1273_AUDIO_IO_SET_ANALOG	0
#define WL1273_AUDIO_IO_SET_I2S		1

#define WL1273_PUPD_SET_OFF		0x00
#define WL1273_PUPD_SET_ON		0x01
#define WL1273_PUPD_SET_RETENTION	0x10

/* I2S mode */
#define WL1273_IS2_WIDTH_32	0x0
#define WL1273_IS2_WIDTH_40	0x1
#define WL1273_IS2_WIDTH_22_23	0x2
#define WL1273_IS2_WIDTH_23_22	0x3
#define WL1273_IS2_WIDTH_48	0x4
#define WL1273_IS2_WIDTH_50	0x5
#define WL1273_IS2_WIDTH_60	0x6
#define WL1273_IS2_WIDTH_64	0x7
#define WL1273_IS2_WIDTH_80	0x8
#define WL1273_IS2_WIDTH_96	0x9
#define WL1273_IS2_WIDTH_128	0xa
#define WL1273_IS2_WIDTH	0xf

#define WL1273_IS2_FORMAT_STD	(0x0 << 4)
#define WL1273_IS2_FORMAT_LEFT	(0x1 << 4)
#define WL1273_IS2_FORMAT_RIGHT	(0x2 << 4)
#define WL1273_IS2_FORMAT_USER	(0x3 << 4)

#define WL1273_IS2_MASTER	(0x0 << 6)
#define WL1273_IS2_SLAVEW	(0x1 << 6)

#define WL1273_IS2_TRI_AFTER_SENDING	(0x0 << 7)
#define WL1273_IS2_TRI_ALWAYS_ACTIVE	(0x1 << 7)

#define WL1273_IS2_SDOWS_RR	(0x0 << 8)
#define WL1273_IS2_SDOWS_RF	(0x1 << 8)
#define WL1273_IS2_SDOWS_FR	(0x2 << 8)
#define WL1273_IS2_SDOWS_FF	(0x3 << 8)

#define WL1273_IS2_TRI_OPT	(0x0 << 10)
#define WL1273_IS2_TRI_ALWAYS	(0x1 << 10)

#define WL1273_IS2_RATE_48K	(0x0 << 12)
#define WL1273_IS2_RATE_44_1K	(0x1 << 12)
#define WL1273_IS2_RATE_32K	(0x2 << 12)
#define WL1273_IS2_RATE_22_05K	(0x4 << 12)
#define WL1273_IS2_RATE_16K	(0x5 << 12)
#define WL1273_IS2_RATE_12K	(0x8 << 12)
#define WL1273_IS2_RATE_11_025	(0x9 << 12)
#define WL1273_IS2_RATE_8K	(0xa << 12)
#define WL1273_IS2_RATE		(0xf << 12)

#define WL1273_I2S_DEF_MODE	(WL1273_IS2_WIDTH_32 | \
				 WL1273_IS2_FORMAT_STD | \
				 WL1273_IS2_MASTER | \
				 WL1273_IS2_TRI_AFTER_SENDING | \
				 WL1273_IS2_SDOWS_RR | \
				 WL1273_IS2_TRI_OPT | \
				 WL1273_IS2_RATE_48K)

#define SCHAR_MIN (-128)
#define SCHAR_MAX 127

#define WL1273_FR_EVENT			BIT(0)
#define WL1273_BL_EVENT			BIT(1)
#define WL1273_RDS_EVENT		BIT(2)
#define WL1273_BBLK_EVENT		BIT(3)
#define WL1273_LSYNC_EVENT		BIT(4)
#define WL1273_LEV_EVENT		BIT(5)
#define WL1273_IFFR_EVENT		BIT(6)
#define WL1273_PI_EVENT			BIT(7)
#define WL1273_PD_EVENT			BIT(8)
#define WL1273_STIC_EVENT		BIT(9)
#define WL1273_MAL_EVENT		BIT(10)
#define WL1273_POW_ENB_EVENT		BIT(11)
#define WL1273_SCAN_OVER_EVENT		BIT(12)
#define WL1273_ERROR_EVENT		BIT(13)

#define TUNER_MODE_STOP_SEARCH		0
#define TUNER_MODE_PRESET		1
#define TUNER_MODE_AUTO_SEEK		2
#define TUNER_MODE_AF			3
#define TUNER_MODE_AUTO_SEEK_PI		4
#define TUNER_MODE_AUTO_SEEK_BULK	5

#define RDS_BLOCK_SIZE	3

struct wl1273_fm_platform_data {
	int (*request_resources) (struct i2c_client *client);
	void (*free_resources) (void);
	void (*enable) (void);
	void (*disable) (void);

	u8 forbidden_modes;
	unsigned int children;
};

#define WL1273_FM_CORE_CELLS	2

#define WL1273_BAND_OTHER	0
#define WL1273_BAND_JAPAN	1

#define WL1273_BAND_JAPAN_LOW	76000
#define WL1273_BAND_JAPAN_HIGH	90000
#define WL1273_BAND_OTHER_LOW	87500
#define WL1273_BAND_OTHER_HIGH	108000

#define WL1273_BAND_TX_LOW	76000
#define WL1273_BAND_TX_HIGH	108000

struct wl1273_core {
	struct mfd_cell cells[WL1273_FM_CORE_CELLS];
	struct wl1273_fm_platform_data *pdata;

	unsigned int mode;
	unsigned int i2s_mode;
	unsigned int volume;
	unsigned int audio_mode;
	unsigned int channel_number;
	struct mutex lock; /* for serializing fm radio operations */

	struct i2c_client *client;

	int (*read)(struct wl1273_core *core, u8, u16 *);
	int (*write)(struct wl1273_core *core, u8, u16);
	int (*write_data)(struct wl1273_core *core, u8 *, u16);
	int (*set_audio)(struct wl1273_core *core, unsigned int);
	int (*set_volume)(struct wl1273_core *core, unsigned int);
};

#endif	/* ifndef WL1273_CORE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * TI/National Semiconductor LP3943 Device
 *
 * Copyright 2013 Texas Instruments
 *
 * Author: Milo Kim <milo.kim@ti.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 */

#ifndef __MFD_LP3943_H__
#define __MFD_LP3943_H__

#include <linux/gpio.h>
#include <linux/pwm.h>
#include <linux/regmap.h>

/* Registers */
#define LP3943_REG_GPIO_A		0x00
#define LP3943_REG_GPIO_B		0x01
#define LP3943_REG_PRESCALE0		0x02
#define LP3943_REG_PWM0			0x03
#define LP3943_REG_PRESCALE1		0x04
#define LP3943_REG_PWM1			0x05
#define LP3943_REG_MUX0			0x06
#define LP3943_REG_MUX1			0x07
#define LP3943_REG_MUX2			0x08
#define LP3943_REG_MUX3			0x09

/* Bit description for LP3943_REG_MUX0 ~ 3 */
#define LP3943_GPIO_IN			0x00
#define LP3943_GPIO_OUT_HIGH		0x00
#define LP3943_GPIO_OUT_LOW		0x01
#define LP3943_DIM_PWM0			0x02
#define LP3943_DIM_PWM1			0x03

#define LP3943_NUM_PWMS			2

enum lp3943_pwm_output {
	LP3943_PWM_OUT0,
	LP3943_PWM_OUT1,
	LP3943_PWM_OUT2,
	LP3943_PWM_OUT3,
	LP3943_PWM_OUT4,
	LP3943_PWM_OUT5,
	LP3943_PWM_OUT6,
	LP3943_PWM_OUT7,
	LP3943_PWM_OUT8,
	LP3943_PWM_OUT9,
	LP3943_PWM_OUT10,
	LP3943_PWM_OUT11,
	LP3943_PWM_OUT12,
	LP3943_PWM_OUT13,
	LP3943_PWM_OUT14,
	LP3943_PWM_OUT15,
};

/*
 * struct lp3943_pwm_map
 * @output: Output pins which are mapped to each PWM channel
 * @num_outputs: Number of outputs
 */
struct lp3943_pwm_map {
	enum lp3943_pwm_output *output;
	int num_outputs;
};

/*
 * struct lp3943_platform_data
 * @pwms: Output channel definitions for PWM channel 0 and 1
 */
struct lp3943_platform_data {
	struct lp3943_pwm_map *pwms[LP3943_NUM_PWMS];
};

/*
 * struct lp3943_reg_cfg
 * @reg: Register address
 * @mask: Register bit mask to be updated
 * @shift: Register bit shift
 */
struct lp3943_reg_cfg {
	u8 reg;
	u8 mask;
	u8 shift;
};

/*
 * struct lp3943
 * @dev: Parent device pointer
 * @regmap: Used for I2C communication on accessing registers
 * @pdata: LP3943 platform specific data
 * @mux_cfg: Register configuration for pin MUX
 * @pin_used: Bit mask for output pin used.
 *	      This bitmask is used for pin assignment management.
 *	      1 = pin used, 0 = available.
 *	      Only LSB 16 bits are used, but it is unsigned long type
 *	      for atomic bitwise operations.
 */
struct lp3943 {
	struct device *dev;
	struct regmap *regmap;
	struct lp3943_platform_data *pdata;
	const struct lp3943_reg_cfg *mux_cfg;
	unsigned long pin_used;
};

int lp3943_read_byte(struct lp3943 *lp3943, u8 reg, u8 *read);
int lp3943_write_byte(struct lp3943 *lp3943, u8 reg, u8 data);
int lp3943_update_bits(struct lp3943 *lp3943, u8 reg, u8 mask, u8 data);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Copyright (C) ST-Ericsson SA 2010
 *
 * License Terms: GNU General Public License, version 2
 * Author: Rabin Vincent <rabin.vincent@stericsson.com> for ST-Ericsson
 */

#ifndef __LINUX_MFD_STMPE_H
#define __LINUX_MFD_STMPE_H

#include <linux/mutex.h>

struct device;
struct regulator;

enum stmpe_block {
	STMPE_BLOCK_GPIO	= 1 << 0,
	STMPE_BLOCK_KEYPAD	= 1 << 1,
	STMPE_BLOCK_TOUCHSCREEN	= 1 << 2,
	STMPE_BLOCK_ADC		= 1 << 3,
	STMPE_BLOCK_PWM		= 1 << 4,
	STMPE_BLOCK_ROTATOR	= 1 << 5,
};

enum stmpe_partnum {
	STMPE610,
	STMPE801,
	STMPE811,
	STMPE1601,
	STMPE1801,
	STMPE2401,
	STMPE2403,
	STMPE_NBR_PARTS
};

/*
 * For registers whose locations differ on variants,  the correct address is
 * obtained by indexing stmpe->regs with one of the following.
 */
enum {
	STMPE_IDX_CHIP_ID,
	STMPE_IDX_ICR_LSB,
	STMPE_IDX_IER_LSB,
	STMPE_IDX_ISR_LSB,
	STMPE_IDX_ISR_MSB,
	STMPE_IDX_GPMR_LSB,
	STMPE_IDX_GPSR_LSB,
	STMPE_IDX_GPCR_LSB,
	STMPE_IDX_GPDR_LSB,
	STMPE_IDX_GPEDR_MSB,
	STMPE_IDX_GPRER_LSB,
	STMPE_IDX_GPFER_LSB,
	STMPE_IDX_GPPUR_LSB,
	STMPE_IDX_GPPDR_LSB,
	STMPE_IDX_GPAFR_U_MSB,
	STMPE_IDX_IEGPIOR_LSB,
	STMPE_IDX_ISGPIOR_LSB,
	STMPE_IDX_ISGPIOR_MSB,
	STMPE_IDX_MAX,
};


struct stmpe_variant_info;
struct stmpe_client_info;

/**
 * struct stmpe - STMPE MFD structure
 * @vcc: optional VCC regulator
 * @vio: optional VIO regulator
 * @lock: lock protecting I/O operations
 * @irq_lock: IRQ bus lock
 * @dev: device, mostly for dev_dbg()
 * @irq_domain: IRQ domain
 * @client: client - i2c or spi
 * @ci: client specific information
 * @partnum: part number
 * @variant: the detected STMPE model number
 * @regs: list of addresses of registers which are at different addresses on
 *	  different variants.  Indexed by one of STMPE_IDX_*.
 * @irq: irq number for stmpe
 * @num_gpios: number of gpios, differs for variants
 * @ier: cache of IER registers for bus_lock
 * @oldier: cache of IER registers for bus_lock
 * @pdata: platform data
 */
struct stmpe {
	struct regulator *vcc;
	struct regulator *vio;
	struct mutex lock;
	struct mutex irq_lock;
	struct device *dev;
	struct irq_domain *domain;
	void *client;
	struct stmpe_client_info *ci;
	enum stmpe_partnum partnum;
	struct stmpe_variant_info *variant;
	const u8 *regs;

	int irq;
	int num_gpios;
	u8 ier[2];
	u8 oldier[2];
	struct stmpe_platform_data *pdata;
};

extern int stmpe_reg_write(struct stmpe *stmpe, u8 reg, u8 data);
extern int stmpe_reg_read(struct stmpe *stmpe, u8 reg);
extern int stmpe_block_read(struct stmpe *stmpe, u8 reg, u8 length,
			    u8 *values);
extern int stmpe_block_write(struct stmpe *stmpe, u8 reg, u8 length,
			     const u8 *values);
extern int stmpe_set_bits(struct stmpe *stmpe, u8 reg, u8 mask, u8 val);
extern int stmpe_set_altfunc(struct stmpe *stmpe, u32 pins,
			     enum stmpe_block block);
extern int stmpe_enable(struct stmpe *stmpe, unsigned int blocks);
extern int stmpe_disable(struct stmpe *stmpe, unsigned int blocks);

#define STMPE_GPIO_NOREQ_811_TOUCH	(0xf0)

/**
 * struct stmpe_ts_platform_data - stmpe811 touch screen controller platform
 * data
 * @sample_time: ADC converstion time in number of clock.
 * (0 -> 36 clocks, 1 -> 44 clocks, 2 -> 56 clocks, 3 -> 64 clocks,
 * 4 -> 80 clocks, 5 -> 96 clocks, 6 -> 144 clocks),
 * recommended is 4.
 * @mod_12b: ADC Bit mode (0 -> 10bit ADC, 1 -> 12bit ADC)
 * @ref_sel: ADC reference source
 * (0 -> internal reference, 1 -> external reference)
 * @adc_freq: ADC Clock speed
 * (0 -> 1.625 MHz, 1 -> 3.25 MHz, 2 || 3 -> 6.5 MHz)
 * @ave_ctrl: Sample average control
 * (0 -> 1 sample, 1 -> 2 samples, 2 -> 4 samples, 3 -> 8 samples)
 * @touch_det_delay: Touch detect interrupt delay
 * (0 -> 10 us, 1 -> 50 us, 2 -> 100 us, 3 -> 500 us,
 * 4-> 1 ms, 5 -> 5 ms, 6 -> 10 ms, 7 -> 50 ms)
 * recommended is 3
 * @settling: Panel driver settling time
 * (0 -> 10 us, 1 -> 100 us, 2 -> 500 us, 3 -> 1 ms,
 * 4 -> 5 ms, 5 -> 10 ms, 6 for 50 ms, 7 -> 100 ms)
 * recommended is 2
 * @fraction_z: Length of the fractional part in z
 * (fraction_z ([0..7]) = Count of the fractional part)
 * recommended is 7
 * @i_drive: current limit value of the touchscreen drivers
 * (0 -> 20 mA typical 35 mA max, 1 -> 50 mA typical 80 mA max)
 *
 * */
struct stmpe_ts_platform_data {
       u8 sample_time;
       u8 mod_12b;
       u8 ref_sel;
       u8 adc_freq;
       u8 ave_ctrl;
       u8 touch_det_delay;
       u8 settling;
       u8 fraction_z;
       u8 i_drive;
};

/**
 * struct stmpe_platform_data - STMPE platform data
 * @id: device id to distinguish between multiple STMPEs on the same board
 * @blocks: bitmask of blocks to enable (use STMPE_BLOCK_*)
 * @irq_trigger: IRQ trigger to use for the interrupt to the host
 * @autosleep: bool to enable/disable stmpe autosleep
 * @autosleep_timeout: inactivity timeout in milliseconds for autosleep
 * @irq_over_gpio: true if gpio is used to get irq
 * @irq_gpio: gpio number over which irq will be requested (significant only if
 *	      irq_over_gpio is true)
 * @ts: touchscreen-specific platform data
 */
struct stmpe_platform_data {
	int id;
	unsigned int blocks;
	unsigned int irq_trigger;
	bool autosleep;
	bool irq_over_gpio;
	int irq_gpio;
	int autosleep_timeout;

	struct stmpe_ts_platform_data *ts;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * Copyright 2010 Yong Shen <yong.shen@linaro.org>
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License version 2 as published by the
 * Free Software Foundation.
 */

#ifndef __LINUX_MFD_MC13892_H
#define __LINUX_MFD_MC13892_H

#include <linux/mfd/mc13xxx.h>

#define MC13892_SW1		0
#define MC13892_SW2		1
#define MC13892_SW3		2
#define MC13892_SW4		3
#define MC13892_SWBST	4
#define MC13892_VIOHI	5
#define MC13892_VPLL	6
#define MC13892_VDIG	7
#define MC13892_VSD	8
#define MC13892_VUSB2	9
#define MC13892_VVIDEO	10
#define MC13892_VAUDIO	11
#define MC13892_VCAM	12
#define MC13892_VGEN1	13
#define MC13892_VGEN2	14
#define MC13892_VGEN3	15
#define MC13892_VUSB	16
#define MC13892_GPO1	17
#define MC13892_GPO2	18
#define MC13892_GPO3	19
#define MC13892_GPO4	20
#define MC13892_PWGT1SPI	21
#define MC13892_PWGT2SPI	22
#define MC13892_VCOINCELL	23

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * Copyright (C) 2011 ST-Ericsson SA
 * Written on behalf of Linaro for ST-Ericsson
 *
 * Author: Linus Walleij <linus.walleij@linaro.org>
 *
 * License terms: GNU General Public License (GPL) version 2
 */
#ifndef MFD_TPS6105X_H
#define MFD_TPS6105X_H

#include <linux/i2c.h>
#include <linux/regulator/machine.h>

/*
 * Register definitions to all subdrivers
 */
#define TPS6105X_REG_0			0x00
#define TPS6105X_REG0_MODE_SHIFT	6
#define TPS6105X_REG0_MODE_MASK		(0x03<<6)
/* These defines for both reg0 and reg1 */
#define TPS6105X_REG0_MODE_SHUTDOWN	0x00
#define TPS6105X_REG0_MODE_TORCH	0x01
#define TPS6105X_REG0_MODE_TORCH_FLASH	0x02
#define TPS6105X_REG0_MODE_VOLTAGE	0x03
#define TPS6105X_REG0_VOLTAGE_SHIFT	4
#define TPS6105X_REG0_VOLTAGE_MASK	(3<<4)
#define TPS6105X_REG0_VOLTAGE_450	0
#define TPS6105X_REG0_VOLTAGE_500	1
#define TPS6105X_REG0_VOLTAGE_525	2
#define TPS6105X_REG0_VOLTAGE_500_2	3
#define TPS6105X_REG0_DIMMING_SHIFT	3
#define TPS6105X_REG0_TORCHC_SHIFT	0
#define TPS6105X_REG0_TORCHC_MASK	(7<<0)
#define TPS6105X_REG0_TORCHC_0		0x00
#define TPS6105X_REG0_TORCHC_50		0x01
#define TPS6105X_REG0_TORCHC_75		0x02
#define TPS6105X_REG0_TORCHC_100	0x03
#define TPS6105X_REG0_TORCHC_150	0x04
#define TPS6105X_REG0_TORCHC_200	0x05
#define TPS6105X_REG0_TORCHC_250_400	0x06
#define TPS6105X_REG0_TORCHC_250_500	0x07
#define TPS6105X_REG_1			0x01
#define TPS6105X_REG1_MODE_SHIFT	6
#define TPS6105X_REG1_MODE_MASK		(0x03<<6)
#define TPS6105X_REG1_MODE_SHUTDOWN	0x00
#define TPS6105X_REG1_MODE_TORCH	0x01
#define TPS6105X_REG1_MODE_TORCH_FLASH	0x02
#define TPS6105X_REG1_MODE_VOLTAGE	0x03
#define TPS6105X_REG_2			0x02
#define TPS6105X_REG_3			0x03

/**
 * enum tps6105x_mode - desired mode for the TPS6105x
 * @TPS6105X_MODE_SHUTDOWN: this instance is inactive, not used for anything
 * @TPS61905X_MODE_TORCH: this instance is used as a LED, usually a while
 *	LED, for example as backlight or flashlight. If this is set, the
 *	TPS6105X will register to the LED framework
 * @TPS6105X_MODE_TORCH_FLASH: this instance is used as a flashgun, usually
 *	in a camera
 * @TPS6105X_MODE_VOLTAGE: this instance is used as a voltage regulator and
 *	will register to the regulator framework
 */
enum tps6105x_mode {
	TPS6105X_MODE_SHUTDOWN,
	TPS6105X_MODE_TORCH,
	TPS6105X_MODE_TORCH_FLASH,
	TPS6105X_MODE_VOLTAGE,
};

/**
 * struct tps6105x_platform_data - TPS61905x platform data
 * @mode: what mode this instance shall be operated in,
 *	this is not selectable at runtime
 * @regulator_data: initialization data for the voltage
 *	regulator if used as a voltage source
 */
struct tps6105x_platform_data {
	enum tps6105x_mode mode;
	struct regulator_init_data *regulator_data;
};

/**
 * struct tps6105x - state holder for the TPS6105x drivers
 * @mutex: mutex to serialize I2C accesses
 * @i2c_client: corresponding I2C client
 * @regulator: regulator device if used in voltage mode
 */
struct tps6105x {
	struct tps6105x_platform_data *pdata;
	struct mutex		lock;
	struct i2c_client	*client;
	struct regulator_dev	*regulator;
};

extern int tps6105x_set(struct tps6105x *tps6105x, u8 reg, u8 value);
extern int tps6105x_get(struct tps6105x *tps6105x, u8 reg, u8 *buf);
extern int tps6105x_mask_and_set(struct tps6105x *tps6105x, u8 reg,
				 u8 bitmask, u8 bitvalues);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Marvell 88PM860x Interface
 *
 * Copyright (C) 2009 Marvell International Ltd.
 * 	Haojian Zhuang <haojian.zhuang@marvell.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef __LINUX_MFD_88PM860X_H
#define __LINUX_MFD_88PM860X_H

#include <linux/interrupt.h>

#define MFD_NAME_SIZE		(40)

enum {
	CHIP_INVALID = 0,
	CHIP_PM8606,
	CHIP_PM8607,
	CHIP_MAX,
};

enum {
	PM8606_ID_INVALID,
	PM8606_ID_BACKLIGHT,
	PM8606_ID_LED,
	PM8606_ID_VIBRATOR,
	PM8606_ID_TOUCH,
	PM8606_ID_SOUND,
	PM8606_ID_CHARGER,
	PM8606_ID_MAX,
};


/* 8606 Registers */
#define PM8606_DCM_BOOST		(0x00)
#define PM8606_PWM			(0x01)

#define PM8607_MISC2			(0x42)

/* Power Up Log Register */
#define PM8607_POWER_UP_LOG		(0x3F)

/* Charger Control Registers */
#define PM8607_CCNT			(0x47)
#define PM8607_CHG_CTRL1		(0x48)
#define PM8607_CHG_CTRL2		(0x49)
#define PM8607_CHG_CTRL3		(0x4A)
#define PM8607_CHG_CTRL4		(0x4B)
#define PM8607_CHG_CTRL5		(0x4C)
#define PM8607_CHG_CTRL6		(0x4D)
#define PM8607_CHG_CTRL7		(0x4E)

/* Backlight Registers */
#define PM8606_WLED1A			(0x02)
#define PM8606_WLED1B			(0x03)
#define PM8606_WLED2A			(0x04)
#define PM8606_WLED2B			(0x05)
#define PM8606_WLED3A			(0x06)
#define PM8606_WLED3B			(0x07)

/* LED Registers */
#define PM8606_RGB2A			(0x08)
#define PM8606_RGB2B			(0x09)
#define PM8606_RGB2C			(0x0A)
#define PM8606_RGB2D			(0x0B)
#define PM8606_RGB1A			(0x0C)
#define PM8606_RGB1B			(0x0D)
#define PM8606_RGB1C			(0x0E)
#define PM8606_RGB1D			(0x0F)

#define PM8606_PREREGULATORA		(0x10)
#define PM8606_PREREGULATORB		(0x11)
#define PM8606_VIBRATORA		(0x12)
#define PM8606_VIBRATORB		(0x13)
#define PM8606_VCHG			(0x14)
#define PM8606_VSYS			(0x15)
#define PM8606_MISC			(0x16)
#define PM8606_CHIP_ID			(0x17)
#define PM8606_STATUS			(0x18)
#define PM8606_FLAGS			(0x19)
#define PM8606_PROTECTA			(0x1A)
#define PM8606_PROTECTB			(0x1B)
#define PM8606_PROTECTC			(0x1C)

/* Bit definitions of PM8606 registers */
#define PM8606_DCM_500MA		(0x0)	/* current limit */
#define PM8606_DCM_750MA		(0x1)
#define PM8606_DCM_1000MA		(0x2)
#define PM8606_DCM_1250MA		(0x3)
#define PM8606_DCM_250MV		(0x0 << 2)
#define PM8606_DCM_300MV		(0x1 << 2)
#define PM8606_DCM_350MV		(0x2 << 2)
#define PM8606_DCM_400MV		(0x3 << 2)

#define PM8606_PWM_31200HZ		(0x0)
#define PM8606_PWM_15600HZ		(0x1)
#define PM8606_PWM_7800HZ		(0x2)
#define PM8606_PWM_3900HZ		(0x3)
#define PM8606_PWM_1950HZ		(0x4)
#define PM8606_PWM_976HZ		(0x5)
#define PM8606_PWM_488HZ		(0x6)
#define PM8606_PWM_244HZ		(0x7)
#define PM8606_PWM_FREQ_MASK		(0x7)

#define PM8606_WLED_ON			(1 << 0)
#define PM8606_WLED_CURRENT(x)		((x & 0x1F) << 1)

#define PM8606_LED_CURRENT(x)		(((x >> 2) & 0x07) << 5)

#define PM8606_VSYS_EN			(1 << 1)

#define PM8606_MISC_OSC_EN		(1 << 4)

enum {
	PM8607_ID_BUCK1 = 0,
	PM8607_ID_BUCK2,
	PM8607_ID_BUCK3,

	PM8607_ID_LDO1,
	PM8607_ID_LDO2,
	PM8607_ID_LDO3,
	PM8607_ID_LDO4,
	PM8607_ID_LDO5,
	PM8607_ID_LDO6,
	PM8607_ID_LDO7,
	PM8607_ID_LDO8,
	PM8607_ID_LDO9,
	PM8607_ID_LDO10,
	PM8607_ID_LDO11,
	PM8607_ID_LDO12,
	PM8607_ID_LDO13,
	PM8607_ID_LDO14,
	PM8607_ID_LDO15,
	PM8606_ID_PREG,

	PM8607_ID_RG_MAX,
};

/* 8607 chip ID is 0x40 or 0x50 */
#define PM8607_VERSION_MASK		(0xF0)	/* 8607 chip ID mask */

/* Interrupt Registers */
#define PM8607_STATUS_1			(0x01)
#define PM8607_STATUS_2			(0x02)
#define PM8607_INT_STATUS1		(0x03)
#define PM8607_INT_STATUS2		(0x04)
#define PM8607_INT_STATUS3		(0x05)
#define PM8607_INT_MASK_1		(0x06)
#define PM8607_INT_MASK_2		(0x07)
#define PM8607_INT_MASK_3		(0x08)

/* Regulator Control Registers */
#define PM8607_LDO1			(0x10)
#define PM8607_LDO2			(0x11)
#define PM8607_LDO3			(0x12)
#define PM8607_LDO4			(0x13)
#define PM8607_LDO5			(0x14)
#define PM8607_LDO6			(0x15)
#define PM8607_LDO7			(0x16)
#define PM8607_LDO8			(0x17)
#define PM8607_LDO9			(0x18)
#define PM8607_LDO10			(0x19)
#define PM8607_LDO12			(0x1A)
#define PM8607_LDO14			(0x1B)
#define PM8607_SLEEP_MODE1		(0x1C)
#define PM8607_SLEEP_MODE2		(0x1D)
#define PM8607_SLEEP_MODE3		(0x1E)
#define PM8607_SLEEP_MODE4		(0x1F)
#define PM8607_GO			(0x20)
#define PM8607_SLEEP_BUCK1		(0x21)
#define PM8607_SLEEP_BUCK2		(0x22)
#define PM8607_SLEEP_BUCK3		(0x23)
#define PM8607_BUCK1			(0x24)
#define PM8607_BUCK2			(0x25)
#define PM8607_BUCK3			(0x26)
#define PM8607_BUCK_CONTROLS		(0x27)
#define PM8607_SUPPLIES_EN11		(0x2B)
#define PM8607_SUPPLIES_EN12		(0x2C)
#define PM8607_GROUP1			(0x2D)
#define PM8607_GROUP2			(0x2E)
#define PM8607_GROUP3			(0x2F)
#define PM8607_GROUP4			(0x30)
#define PM8607_GROUP5			(0x31)
#define PM8607_GROUP6			(0x32)
#define PM8607_SUPPLIES_EN21		(0x33)
#define PM8607_SUPPLIES_EN22		(0x34)

/* Vibrator Control Registers */
#define PM8607_VIBRATOR_SET		(0x28)
#define PM8607_VIBRATOR_PWM		(0x29)

/* GPADC Registers */
#define PM8607_GP_BIAS1			(0x4F)
#define PM8607_MEAS_EN1			(0x50)
#define PM8607_MEAS_EN2			(0x51)
#define PM8607_MEAS_EN3			(0x52)
#define PM8607_MEAS_OFF_TIME1		(0x53)
#define PM8607_MEAS_OFF_TIME2		(0x54)
#define PM8607_TSI_PREBIAS		(0x55)	/* prebias time */
#define PM8607_PD_PREBIAS		(0x56)	/* prebias time */
#define PM8607_GPADC_MISC1		(0x57)

/* bit definitions of  MEAS_EN1*/
#define PM8607_MEAS_EN1_VBAT		(1 << 0)
#define PM8607_MEAS_EN1_VCHG		(1 << 1)
#define PM8607_MEAS_EN1_VSYS		(1 << 2)
#define PM8607_MEAS_EN1_TINT		(1 << 3)
#define PM8607_MEAS_EN1_RFTMP		(1 << 4)
#define PM8607_MEAS_EN1_TBAT		(1 << 5)
#define PM8607_MEAS_EN1_GPADC2		(1 << 6)
#define PM8607_MEAS_EN1_GPADC3		(1 << 7)

/* Battery Monitor Registers */
#define PM8607_GP_BIAS2			(0x5A)
#define PM8607_VBAT_LOWTH		(0x5B)
#define PM8607_VCHG_LOWTH		(0x5C)
#define PM8607_VSYS_LOWTH		(0x5D)
#define PM8607_TINT_LOWTH		(0x5E)
#define PM8607_GPADC0_LOWTH		(0x5F)
#define PM8607_GPADC1_LOWTH		(0x60)
#define PM8607_GPADC2_LOWTH		(0x61)
#define PM8607_GPADC3_LOWTH		(0x62)
#define PM8607_VBAT_HIGHTH		(0x63)
#define PM8607_VCHG_HIGHTH		(0x64)
#define PM8607_VSYS_HIGHTH		(0x65)
#define PM8607_TINT_HIGHTH		(0x66)
#define PM8607_GPADC0_HIGHTH		(0x67)
#define PM8607_GPADC1_HIGHTH		(0x68)
#define PM8607_GPADC2_HIGHTH		(0x69)
#define PM8607_GPADC3_HIGHTH		(0x6A)
#define PM8607_IBAT_MEAS1		(0x6B)
#define PM8607_IBAT_MEAS2		(0x6C)
#define PM8607_VBAT_MEAS1		(0x6D)
#define PM8607_VBAT_MEAS2		(0x6E)
#define PM8607_VCHG_MEAS1		(0x6F)
#define PM8607_VCHG_MEAS2		(0x70)
#define PM8607_VSYS_MEAS1		(0x71)
#define PM8607_VSYS_MEAS2		(0x72)
#define PM8607_TINT_MEAS1		(0x73)
#define PM8607_TINT_MEAS2		(0x74)
#define PM8607_GPADC0_MEAS1		(0x75)
#define PM8607_GPADC0_MEAS2		(0x76)
#define PM8607_GPADC1_MEAS1		(0x77)
#define PM8607_GPADC1_MEAS2		(0x78)
#define PM8607_GPADC2_MEAS1		(0x79)
#define PM8607_GPADC2_MEAS2		(0x7A)
#define PM8607_GPADC3_MEAS1		(0x7B)
#define PM8607_GPADC3_MEAS2		(0x7C)
#define PM8607_CCNT_MEAS1		(0x95)
#define PM8607_CCNT_MEAS2		(0x96)
#define PM8607_VBAT_AVG			(0x97)
#define PM8607_VCHG_AVG			(0x98)
#define PM8607_VSYS_AVG			(0x99)
#define PM8607_VBAT_MIN			(0x9A)
#define PM8607_VCHG_MIN			(0x9B)
#define PM8607_VSYS_MIN			(0x9C)
#define PM8607_VBAT_MAX			(0x9D)
#define PM8607_VCHG_MAX			(0x9E)
#define PM8607_VSYS_MAX			(0x9F)

#define PM8607_GPADC_MISC2		(0x59)
#define PM8607_GPADC0_GP_BIAS_A0	(1 << 0)
#define PM8607_GPADC1_GP_BIAS_A1	(1 << 1)
#define PM8607_GPADC2_GP_BIAS_A2	(1 << 2)
#define PM8607_GPADC3_GP_BIAS_A3	(1 << 3)
#define PM8607_GPADC2_GP_BIAS_OUT2	(1 << 6)

/* RTC Control Registers */
#define PM8607_RTC1			(0xA0)
#define PM8607_RTC_COUNTER1		(0xA1)
#define PM8607_RTC_COUNTER2		(0xA2)
#define PM8607_RTC_COUNTER3		(0xA3)
#define PM8607_RTC_COUNTER4		(0xA4)
#define PM8607_RTC_EXPIRE1		(0xA5)
#define PM8607_RTC_EXPIRE2		(0xA6)
#define PM8607_RTC_EXPIRE3		(0xA7)
#define PM8607_RTC_EXPIRE4		(0xA8)
#define PM8607_RTC_TRIM1		(0xA9)
#define PM8607_RTC_TRIM2		(0xAA)
#define PM8607_RTC_TRIM3		(0xAB)
#define PM8607_RTC_TRIM4		(0xAC)
#define PM8607_RTC_MISC1		(0xAD)
#define PM8607_RTC_MISC2		(0xAE)
#define PM8607_RTC_MISC3		(0xAF)

/* Misc Registers */
#define PM8607_CHIP_ID			(0x00)
#define PM8607_B0_MISC1			(0x0C)
#define PM8607_LDO1			(0x10)
#define PM8607_DVC3			(0x26)
#define PM8607_A1_MISC1			(0x40)

/* bit definitions of Status Query Interface */
#define PM8607_STATUS_CC		(1 << 3)
#define PM8607_STATUS_PEN		(1 << 4)
#define PM8607_STATUS_HEADSET		(1 << 5)
#define PM8607_STATUS_HOOK		(1 << 6)
#define PM8607_STATUS_MICIN		(1 << 7)
#define PM8607_STATUS_ONKEY		(1 << 8)
#define PM8607_STATUS_EXTON		(1 << 9)
#define PM8607_STATUS_CHG		(1 << 10)
#define PM8607_STATUS_BAT		(1 << 11)
#define PM8607_STATUS_VBUS		(1 << 12)
#define PM8607_STATUS_OV		(1 << 13)

/* bit definitions of BUCK3 */
#define PM8607_BUCK3_DOUBLE		(1 << 6)

/* bit definitions of Misc1 */
#define PM8607_A1_MISC1_PI2C		(1 << 0)
#define PM8607_B0_MISC1_INV_INT		(1 << 0)
#define PM8607_B0_MISC1_INT_CLEAR	(1 << 1)
#define PM8607_B0_MISC1_INT_MASK	(1 << 2)
#define PM8607_B0_MISC1_PI2C		(1 << 3)
#define PM8607_B0_MISC1_RESET		(1 << 6)

/* bits definitions of GPADC */
#define PM8607_GPADC_EN			(1 << 0)
#define PM8607_GPADC_PREBIAS_MASK	(3 << 1)
#define PM8607_GPADC_SLOT_CYCLE_MASK	(3 << 3)	/* slow mode */
#define PM8607_GPADC_OFF_SCALE_MASK	(3 << 5)	/* GP sleep mode */
#define PM8607_GPADC_SW_CAL_MASK	(1 << 7)

#define PM8607_PD_PREBIAS_MASK		(0x1F << 0)
#define PM8607_PD_PRECHG_MASK		(7 << 5)

#define PM8606_REF_GP_OSC_OFF         0
#define PM8606_REF_GP_OSC_ON          1
#define PM8606_REF_GP_OSC_UNKNOWN     2

/* Clients of reference group and 8MHz oscillator in 88PM8606 */
enum pm8606_ref_gp_and_osc_clients {
	REF_GP_NO_CLIENTS       = 0,
	WLED1_DUTY              = (1<<0), /*PF 0x02.7:0*/
	WLED2_DUTY              = (1<<1), /*PF 0x04.7:0*/
	WLED3_DUTY              = (1<<2), /*PF 0x06.7:0*/
	RGB1_ENABLE             = (1<<3), /*PF 0x07.1*/
	RGB2_ENABLE             = (1<<4), /*PF 0x07.2*/
	LDO_VBR_EN              = (1<<5), /*PF 0x12.0*/
	REF_GP_MAX_CLIENT       = 0xFFFF
};

/* Interrupt Number in 88PM8607 */
enum {
	PM8607_IRQ_ONKEY,
	PM8607_IRQ_EXTON,
	PM8607_IRQ_CHG,
	PM8607_IRQ_BAT,
	PM8607_IRQ_RTC,
	PM8607_IRQ_CC,
	PM8607_IRQ_VBAT,
	PM8607_IRQ_VCHG,
	PM8607_IRQ_VSYS,
	PM8607_IRQ_TINT,
	PM8607_IRQ_GPADC0,
	PM8607_IRQ_GPADC1,
	PM8607_IRQ_GPADC2,
	PM8607_IRQ_GPADC3,
	PM8607_IRQ_AUDIO_SHORT,
	PM8607_IRQ_PEN,
	PM8607_IRQ_HEADSET,
	PM8607_IRQ_HOOK,
	PM8607_IRQ_MICIN,
	PM8607_IRQ_CHG_FAIL,
	PM8607_IRQ_CHG_DONE,
	PM8607_IRQ_CHG_FAULT,
};

enum {
	PM8607_CHIP_A0 = 0x40,
	PM8607_CHIP_A1 = 0x41,
	PM8607_CHIP_B0 = 0x48,
};

struct pm860x_chip {
	struct device		*dev;
	struct mutex		irq_lock;
	struct mutex		osc_lock;
	struct i2c_client	*client;
	struct i2c_client	*companion;	/* companion chip client */
	struct regmap           *regmap;
	struct regmap           *regmap_companion;

	int			buck3_double;	/* DVC ramp slope double */
	int			companion_addr;
	unsigned short		osc_vote;
	int			id;
	int			irq_mode;
	int			irq_base;
	int			core_irq;
	unsigned char		chip_version;
	unsigned char		osc_status;

	unsigned int            wakeup_flag;
};

enum {
	GI2C_PORT = 0,
	PI2C_PORT,
};

struct pm860x_backlight_pdata {
	int		pwm;
	int		iset;
};

struct pm860x_led_pdata {
	int		iset;
};

struct pm860x_rtc_pdata {
	int		(*sync)(unsigned int ticks);
	int		vrtc;
};

struct pm860x_touch_pdata {
	int		gpadc_prebias;
	int		slot_cycle;
	int		off_scale;
	int		sw_cal;
	int		tsi_prebias;	/* time, slot */
	int		pen_prebias;	/* time, slot */
	int		pen_prechg;	/* time, slot */
	int		res_x;		/* resistor of Xplate */
	unsigned long	flags;
};

struct pm860x_power_pdata {
	int		max_capacity;
	int		resistor;
};

struct pm860x_platform_data {
	struct pm860x_backlight_pdata	*backlight;
	struct pm860x_led_pdata		*led;
	struct pm860x_rtc_pdata		*rtc;
	struct pm860x_touch_pdata	*touch;
	struct pm860x_power_pdata	*power;
	struct regulator_init_data	*buck1;
	struct regulator_init_data	*buck2;
	struct regulator_init_data	*buck3;
	struct regulator_init_data	*ldo1;
	struct regulator_init_data	*ldo2;
	struct regulator_init_data	*ldo3;
	struct regulator_init_data	*ldo4;
	struct regulator_init_data	*ldo5;
	struct regulator_init_data	*ldo6;
	struct regulator_init_data	*ldo7;
	struct regulator_init_data	*ldo8;
	struct regulator_init_data	*ldo9;
	struct regulator_init_data	*ldo10;
	struct regulator_init_data	*ldo12;
	struct regulator_init_data	*ldo_vibrator;
	struct regulator_init_data	*ldo14;
	struct charger_desc		*chg_desc;

	int 		companion_addr;	/* I2C address of companion chip */
	int		i2c_port;	/* Controlled by GI2C or PI2C */
	int		irq_mode;	/* Clear interrupt by read/write(0/1) */
	int		irq_base;	/* IRQ base number of 88pm860x */
	int		num_leds;
	int		num_backlights;
};

extern int pm8606_osc_enable(struct pm860x_chip *, unsigned short);
extern int pm8606_osc_disable(struct pm860x_chip *, unsigned short);

extern int pm860x_reg_read(struct i2c_client *, int);
extern int pm860x_reg_write(struct i2c_client *, int, unsigned char);
extern int pm860x_bulk_read(struct i2c_client *, int, int, unsigned char *);
extern int pm860x_bulk_write(struct i2c_client *, int, int, unsigned char *);
extern int pm860x_set_bits(struct i2c_client *, int, unsigned char,
			   unsigned char);
extern int pm860x_page_reg_read(struct i2c_client *, int);
extern int pm860x_page_reg_write(struct i2c_client *, int, unsigned char);
extern int pm860x_page_bulk_read(struct i2c_client *, int, int,
				 unsigned char *);
extern int pm860x_page_bulk_write(struct i2c_client *, int, int,
				  unsigned char *);
extern int pm860x_page_set_bits(struct i2c_client *, int, unsigned char,
				unsigned char);

#endif /* __LINUX_MFD_88PM860X_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * as3722 definitions
 *
 * Copyright (C) 2013 ams
 * Copyright (c) 2013, NVIDIA Corporation. All rights reserved.
 *
 * Author: Florian Lobmaier <florian.lobmaier@ams.com>
 * Author: Laxman Dewangan <ldewangan@nvidia.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 *
 */

#ifndef __LINUX_MFD_AS3722_H__
#define __LINUX_MFD_AS3722_H__

#include <linux/regmap.h>

/* AS3722 registers */
#define AS3722_SD0_VOLTAGE_REG				0x00
#define AS3722_SD1_VOLTAGE_REG				0x01
#define AS3722_SD2_VOLTAGE_REG				0x02
#define AS3722_SD3_VOLTAGE_REG				0x03
#define AS3722_SD4_VOLTAGE_REG				0x04
#define AS3722_SD5_VOLTAGE_REG				0x05
#define AS3722_SD6_VOLTAGE_REG				0x06
#define AS3722_GPIO0_CONTROL_REG			0x08
#define AS3722_GPIO1_CONTROL_REG			0x09
#define AS3722_GPIO2_CONTROL_REG			0x0A
#define AS3722_GPIO3_CONTROL_REG			0x0B
#define AS3722_GPIO4_CONTROL_REG			0x0C
#define AS3722_GPIO5_CONTROL_REG			0x0D
#define AS3722_GPIO6_CONTROL_REG			0x0E
#define AS3722_GPIO7_CONTROL_REG			0x0F
#define AS3722_LDO0_VOLTAGE_REG				0x10
#define AS3722_LDO1_VOLTAGE_REG				0x11
#define AS3722_LDO2_VOLTAGE_REG				0x12
#define AS3722_LDO3_VOLTAGE_REG				0x13
#define AS3722_LDO4_VOLTAGE_REG				0x14
#define AS3722_LDO5_VOLTAGE_REG				0x15
#define AS3722_LDO6_VOLTAGE_REG				0x16
#define AS3722_LDO7_VOLTAGE_REG				0x17
#define AS3722_LDO9_VOLTAGE_REG				0x19
#define AS3722_LDO10_VOLTAGE_REG			0x1A
#define AS3722_LDO11_VOLTAGE_REG			0x1B
#define AS3722_GPIO_DEB1_REG				0x1E
#define AS3722_GPIO_DEB2_REG				0x1F
#define AS3722_GPIO_SIGNAL_OUT_REG			0x20
#define AS3722_GPIO_SIGNAL_IN_REG			0x21
#define AS3722_REG_SEQU_MOD1_REG			0x22
#define AS3722_REG_SEQU_MOD2_REG			0x23
#define AS3722_REG_SEQU_MOD3_REG			0x24
#define AS3722_SD_PHSW_CTRL_REG				0x27
#define AS3722_SD_PHSW_STATUS				0x28
#define AS3722_SD0_CONTROL_REG				0x29
#define AS3722_SD1_CONTROL_REG				0x2A
#define AS3722_SDmph_CONTROL_REG			0x2B
#define AS3722_SD23_CONTROL_REG				0x2C
#define AS3722_SD4_CONTROL_REG				0x2D
#define AS3722_SD5_CONTROL_REG				0x2E
#define AS3722_SD6_CONTROL_REG				0x2F
#define AS3722_SD_DVM_REG				0x30
#define AS3722_RESET_REASON_REG				0x31
#define AS3722_BATTERY_VOLTAGE_MONITOR_REG		0x32
#define AS3722_STARTUP_CONTROL_REG			0x33
#define AS3722_RESET_TIMER_REG				0x34
#define AS3722_REFERENCE_CONTROL_REG			0x35
#define AS3722_RESET_CONTROL_REG			0x36
#define AS3722_OVER_TEMP_CONTROL_REG			0x37
#define AS3722_WATCHDOG_CONTROL_REG			0x38
#define AS3722_REG_STANDBY_MOD1_REG			0x39
#define AS3722_REG_STANDBY_MOD2_REG			0x3A
#define AS3722_REG_STANDBY_MOD3_REG			0x3B
#define AS3722_ENABLE_CTRL1_REG				0x3C
#define AS3722_ENABLE_CTRL2_REG				0x3D
#define AS3722_ENABLE_CTRL3_REG				0x3E
#define AS3722_ENABLE_CTRL4_REG				0x3F
#define AS3722_ENABLE_CTRL5_REG				0x40
#define AS3722_PWM_CONTROL_L_REG			0x41
#define AS3722_PWM_CONTROL_H_REG			0x42
#define AS3722_WATCHDOG_TIMER_REG			0x46
#define AS3722_WATCHDOG_SOFTWARE_SIGNAL_REG		0x48
#define AS3722_IOVOLTAGE_REG				0x49
#define AS3722_BATTERY_VOLTAGE_MONITOR2_REG		0x4A
#define AS3722_SD_CONTROL_REG				0x4D
#define AS3722_LDOCONTROL0_REG				0x4E
#define AS3722_LDOCONTROL1_REG				0x4F
#define AS3722_SD0_PROTECT_REG				0x50
#define AS3722_SD6_PROTECT_REG				0x51
#define AS3722_PWM_VCONTROL1_REG			0x52
#define AS3722_PWM_VCONTROL2_REG			0x53
#define AS3722_PWM_VCONTROL3_REG			0x54
#define AS3722_PWM_VCONTROL4_REG			0x55
#define AS3722_BB_CHARGER_REG				0x57
#define AS3722_CTRL_SEQU1_REG				0x58
#define AS3722_CTRL_SEQU2_REG				0x59
#define AS3722_OVCURRENT_REG				0x5A
#define AS3722_OVCURRENT_DEB_REG			0x5B
#define AS3722_SDLV_DEB_REG				0x5C
#define AS3722_OC_PG_CTRL_REG				0x5D
#define AS3722_OC_PG_CTRL2_REG				0x5E
#define AS3722_CTRL_STATUS				0x5F
#define AS3722_RTC_CONTROL_REG				0x60
#define AS3722_RTC_SECOND_REG				0x61
#define AS3722_RTC_MINUTE_REG				0x62
#define AS3722_RTC_HOUR_REG				0x63
#define AS3722_RTC_DAY_REG				0x64
#define AS3722_RTC_MONTH_REG				0x65
#define AS3722_RTC_YEAR_REG				0x66
#define AS3722_RTC_ALARM_SECOND_REG			0x67
#define AS3722_RTC_ALARM_MINUTE_REG			0x68
#define AS3722_RTC_ALARM_HOUR_REG			0x69
#define AS3722_RTC_ALARM_DAY_REG			0x6A
#define AS3722_RTC_ALARM_MONTH_REG			0x6B
#define AS3722_RTC_ALARM_YEAR_REG			0x6C
#define AS3722_SRAM_REG					0x6D
#define AS3722_RTC_ACCESS_REG				0x6F
#define AS3722_RTC_STATUS_REG				0x73
#define AS3722_INTERRUPT_MASK1_REG			0x74
#define AS3722_INTERRUPT_MASK2_REG			0x75
#define AS3722_INTERRUPT_MASK3_REG			0x76
#define AS3722_INTERRUPT_MASK4_REG			0x77
#define AS3722_INTERRUPT_STATUS1_REG			0x78
#define AS3722_INTERRUPT_STATUS2_REG			0x79
#define AS3722_INTERRUPT_STATUS3_REG			0x7A
#define AS3722_INTERRUPT_STATUS4_REG			0x7B
#define AS3722_TEMP_STATUS_REG				0x7D
#define AS3722_ADC0_CONTROL_REG				0x80
#define AS3722_ADC1_CONTROL_REG				0x81
#define AS3722_ADC0_MSB_RESULT_REG			0x82
#define AS3722_ADC0_LSB_RESULT_REG			0x83
#define AS3722_ADC1_MSB_RESULT_REG			0x84
#define AS3722_ADC1_LSB_RESULT_REG			0x85
#define AS3722_ADC1_THRESHOLD_HI_MSB_REG		0x86
#define AS3722_ADC1_THRESHOLD_HI_LSB_REG		0x87
#define AS3722_ADC1_THRESHOLD_LO_MSB_REG		0x88
#define AS3722_ADC1_THRESHOLD_LO_LSB_REG		0x89
#define AS3722_ADC_CONFIGURATION_REG			0x8A
#define AS3722_ASIC_ID1_REG				0x90
#define AS3722_ASIC_ID2_REG				0x91
#define AS3722_LOCK_REG					0x9E
#define AS3722_FUSE7_REG				0xA7
#define AS3722_MAX_REGISTER				0xF4

#define AS3722_SD0_EXT_ENABLE_MASK			0x03
#define AS3722_SD1_EXT_ENABLE_MASK			0x0C
#define AS3722_SD2_EXT_ENABLE_MASK			0x30
#define AS3722_SD3_EXT_ENABLE_MASK			0xC0
#define AS3722_SD4_EXT_ENABLE_MASK			0x03
#define AS3722_SD5_EXT_ENABLE_MASK			0x0C
#define AS3722_SD6_EXT_ENABLE_MASK			0x30
#define AS3722_LDO0_EXT_ENABLE_MASK			0x03
#define AS3722_LDO1_EXT_ENABLE_MASK			0x0C
#define AS3722_LDO2_EXT_ENABLE_MASK			0x30
#define AS3722_LDO3_EXT_ENABLE_MASK			0xC0
#define AS3722_LDO4_EXT_ENABLE_MASK			0x03
#define AS3722_LDO5_EXT_ENABLE_MASK			0x0C
#define AS3722_LDO6_EXT_ENABLE_MASK			0x30
#define AS3722_LDO7_EXT_ENABLE_MASK			0xC0
#define AS3722_LDO9_EXT_ENABLE_MASK			0x0C
#define AS3722_LDO10_EXT_ENABLE_MASK			0x30
#define AS3722_LDO11_EXT_ENABLE_MASK			0xC0

#define AS3722_OVCURRENT_SD0_ALARM_MASK			0x07
#define AS3722_OVCURRENT_SD0_ALARM_SHIFT		0x01
#define AS3722_OVCURRENT_SD0_TRIP_MASK			0x18
#define AS3722_OVCURRENT_SD0_TRIP_SHIFT			0x03
#define AS3722_OVCURRENT_SD1_TRIP_MASK			0x60
#define AS3722_OVCURRENT_SD1_TRIP_SHIFT			0x05

#define AS3722_OVCURRENT_SD6_ALARM_MASK			0x07
#define AS3722_OVCURRENT_SD6_ALARM_SHIFT		0x01
#define AS3722_OVCURRENT_SD6_TRIP_MASK			0x18
#define AS3722_OVCURRENT_SD6_TRIP_SHIFT			0x03

/* AS3722 register bits and bit masks */
#define AS3722_LDO_ILIMIT_MASK				BIT(7)
#define AS3722_LDO_ILIMIT_BIT				BIT(7)
#define AS3722_LDO0_VSEL_MASK				0x1F
#define AS3722_LDO0_VSEL_MIN				0x01
#define AS3722_LDO0_VSEL_MAX				0x12
#define AS3722_LDO0_NUM_VOLT				0x12
#define AS3722_LDO3_VSEL_MASK				0x3F
#define AS3722_LDO3_VSEL_MIN				0x01
#define AS3722_LDO3_VSEL_MAX				0x2D
#define AS3722_LDO3_NUM_VOLT				0x2D
#define AS3722_LDO_VSEL_MASK				0x7F
#define AS3722_LDO_VSEL_MIN				0x01
#define AS3722_LDO_VSEL_MAX				0x7F
#define AS3722_LDO_VSEL_DNU_MIN				0x25
#define AS3722_LDO_VSEL_DNU_MAX				0x3F
#define AS3722_LDO_NUM_VOLT				0x80

#define AS3722_LDO0_CTRL				BIT(0)
#define AS3722_LDO1_CTRL				BIT(1)
#define AS3722_LDO2_CTRL				BIT(2)
#define AS3722_LDO3_CTRL				BIT(3)
#define AS3722_LDO4_CTRL				BIT(4)
#define AS3722_LDO5_CTRL				BIT(5)
#define AS3722_LDO6_CTRL				BIT(6)
#define AS3722_LDO7_CTRL				BIT(7)
#define AS3722_LDO9_CTRL				BIT(1)
#define AS3722_LDO10_CTRL				BIT(2)
#define AS3722_LDO11_CTRL				BIT(3)

#define AS3722_LDO3_MODE_MASK				(3 << 6)
#define AS3722_LDO3_MODE_VAL(n)				(((n) & 0x3) << 6)
#define AS3722_LDO3_MODE_PMOS				AS3722_LDO3_MODE_VAL(0)
#define AS3722_LDO3_MODE_PMOS_TRACKING			AS3722_LDO3_MODE_VAL(1)
#define AS3722_LDO3_MODE_NMOS				AS3722_LDO3_MODE_VAL(2)
#define AS3722_LDO3_MODE_SWITCH				AS3722_LDO3_MODE_VAL(3)

#define AS3722_SD_VSEL_MASK				0x7F
#define AS3722_SD0_VSEL_MIN				0x01
#define AS3722_SD0_VSEL_MAX				0x5A
#define AS3722_SD0_VSEL_LOW_VOL_MAX			0x6E
#define AS3722_SD2_VSEL_MIN				0x01
#define AS3722_SD2_VSEL_MAX				0x7F

#define AS3722_SDn_CTRL(n)				BIT(n)

#define AS3722_SD0_MODE_FAST				BIT(4)
#define AS3722_SD1_MODE_FAST				BIT(4)
#define AS3722_SD2_MODE_FAST				BIT(2)
#define AS3722_SD3_MODE_FAST				BIT(6)
#define AS3722_SD4_MODE_FAST				BIT(2)
#define AS3722_SD5_MODE_FAST				BIT(2)
#define AS3722_SD6_MODE_FAST				BIT(4)

#define AS3722_POWER_OFF				BIT(1)

#define AS3722_INTERRUPT_MASK1_LID			BIT(0)
#define AS3722_INTERRUPT_MASK1_ACOK			BIT(1)
#define AS3722_INTERRUPT_MASK1_ENABLE1			BIT(2)
#define AS3722_INTERRUPT_MASK1_OCURR_ALARM_SD0		BIT(3)
#define AS3722_INTERRUPT_MASK1_ONKEY_LONG		BIT(4)
#define AS3722_INTERRUPT_MASK1_ONKEY			BIT(5)
#define AS3722_INTERRUPT_MASK1_OVTMP			BIT(6)
#define AS3722_INTERRUPT_MASK1_LOWBAT			BIT(7)

#define AS3722_INTERRUPT_MASK2_SD0_LV			BIT(0)
#define AS3722_INTERRUPT_MASK2_SD1_LV			BIT(1)
#define AS3722_INTERRUPT_MASK2_SD2345_LV		BIT(2)
#define AS3722_INTERRUPT_MASK2_PWM1_OV_PROT		BIT(3)
#define AS3722_INTERRUPT_MASK2_PWM2_OV_PROT		BIT(4)
#define AS3722_INTERRUPT_MASK2_ENABLE2			BIT(5)
#define AS3722_INTERRUPT_MASK2_SD6_LV			BIT(6)
#define AS3722_INTERRUPT_MASK2_RTC_REP			BIT(7)

#define AS3722_INTERRUPT_MASK3_RTC_ALARM		BIT(0)
#define AS3722_INTERRUPT_MASK3_GPIO1			BIT(1)
#define AS3722_INTERRUPT_MASK3_GPIO2			BIT(2)
#define AS3722_INTERRUPT_MASK3_GPIO3			BIT(3)
#define AS3722_INTERRUPT_MASK3_GPIO4			BIT(4)
#define AS3722_INTERRUPT_MASK3_GPIO5			BIT(5)
#define AS3722_INTERRUPT_MASK3_WATCHDOG			BIT(6)
#define AS3722_INTERRUPT_MASK3_ENABLE3			BIT(7)

#define AS3722_INTERRUPT_MASK4_TEMP_SD0_SHUTDOWN	BIT(0)
#define AS3722_INTERRUPT_MASK4_TEMP_SD1_SHUTDOWN	BIT(1)
#define AS3722_INTERRUPT_MASK4_TEMP_SD6_SHUTDOWN	BIT(2)
#define AS3722_INTERRUPT_MASK4_TEMP_SD0_ALARM		BIT(3)
#define AS3722_INTERRUPT_MASK4_TEMP_SD1_ALARM		BIT(4)
#define AS3722_INTERRUPT_MASK4_TEMP_SD6_ALARM		BIT(5)
#define AS3722_INTERRUPT_MASK4_OCCUR_ALARM_SD6		BIT(6)
#define AS3722_INTERRUPT_MASK4_ADC			BIT(7)

#define AS3722_ADC1_INTERVAL_TIME			BIT(0)
#define AS3722_ADC1_INT_MODE_ON				BIT(1)
#define AS3722_ADC_BUF_ON				BIT(2)
#define AS3722_ADC1_LOW_VOLTAGE_RANGE			BIT(5)
#define AS3722_ADC1_INTEVAL_SCAN			BIT(6)
#define AS3722_ADC1_INT_MASK				BIT(7)

#define AS3722_ADC_MSB_VAL_MASK				0x7F
#define AS3722_ADC_LSB_VAL_MASK				0x07

#define AS3722_ADC0_CONV_START				BIT(7)
#define AS3722_ADC0_CONV_NOTREADY			BIT(7)
#define AS3722_ADC0_SOURCE_SELECT_MASK			0x1F

#define AS3722_ADC1_CONV_START				BIT(7)
#define AS3722_ADC1_CONV_NOTREADY			BIT(7)
#define AS3722_ADC1_SOURCE_SELECT_MASK			0x1F

/* GPIO modes */
#define AS3722_GPIO_MODE_MASK				0x07
#define AS3722_GPIO_MODE_INPUT				0x00
#define AS3722_GPIO_MODE_OUTPUT_VDDH			0x01
#define AS3722_GPIO_MODE_IO_OPEN_DRAIN			0x02
#define AS3722_GPIO_MODE_ADC_IN				0x03
#define AS3722_GPIO_MODE_INPUT_PULL_UP			0x04
#define AS3722_GPIO_MODE_INPUT_PULL_DOWN		0x05
#define AS3722_GPIO_MODE_IO_OPEN_DRAIN_PULL_UP		0x06
#define AS3722_GPIO_MODE_OUTPUT_VDDL			0x07
#define AS3722_GPIO_MODE_VAL(n)			((n) & AS3722_GPIO_MODE_MASK)

#define AS3722_GPIO_INV					BIT(7)
#define AS3722_GPIO_IOSF_MASK				0x78
#define AS3722_GPIO_IOSF_VAL(n)				(((n) & 0xF) << 3)
#define AS3722_GPIO_IOSF_NORMAL				AS3722_GPIO_IOSF_VAL(0)
#define AS3722_GPIO_IOSF_INTERRUPT_OUT			AS3722_GPIO_IOSF_VAL(1)
#define AS3722_GPIO_IOSF_VSUP_LOW_OUT			AS3722_GPIO_IOSF_VAL(2)
#define AS3722_GPIO_IOSF_GPIO_INTERRUPT_IN		AS3722_GPIO_IOSF_VAL(3)
#define AS3722_GPIO_IOSF_ISINK_PWM_IN			AS3722_GPIO_IOSF_VAL(4)
#define AS3722_GPIO_IOSF_VOLTAGE_STBY			AS3722_GPIO_IOSF_VAL(5)
#define AS3722_GPIO_IOSF_SD0_OUT			AS3722_GPIO_IOSF_VAL(6)
#define AS3722_GPIO_IOSF_PWR_GOOD_OUT			AS3722_GPIO_IOSF_VAL(7)
#define AS3722_GPIO_IOSF_Q32K_OUT			AS3722_GPIO_IOSF_VAL(8)
#define AS3722_GPIO_IOSF_WATCHDOG_IN			AS3722_GPIO_IOSF_VAL(9)
#define AS3722_GPIO_IOSF_SOFT_RESET_IN			AS3722_GPIO_IOSF_VAL(11)
#define AS3722_GPIO_IOSF_PWM_OUT			AS3722_GPIO_IOSF_VAL(12)
#define AS3722_GPIO_IOSF_VSUP_LOW_DEB_OUT		AS3722_GPIO_IOSF_VAL(13)
#define AS3722_GPIO_IOSF_SD6_LOW_VOLT_LOW		AS3722_GPIO_IOSF_VAL(14)

#define AS3722_GPIOn_SIGNAL(n)				BIT(n)
#define AS3722_GPIOn_CONTROL_REG(n)		(AS3722_GPIO0_CONTROL_REG + n)
#define AS3722_I2C_PULL_UP				BIT(4)
#define AS3722_INT_PULL_UP				BIT(5)

#define AS3722_RTC_REP_WAKEUP_EN			BIT(0)
#define AS3722_RTC_ALARM_WAKEUP_EN			BIT(1)
#define AS3722_RTC_ON					BIT(2)
#define AS3722_RTC_IRQMODE				BIT(3)
#define AS3722_RTC_CLK32K_OUT_EN			BIT(5)

#define AS3722_WATCHDOG_TIMER_MAX			0x7F
#define AS3722_WATCHDOG_ON				BIT(0)
#define AS3722_WATCHDOG_SW_SIG				BIT(0)

#define AS3722_EXT_CONTROL_ENABLE1			0x1
#define AS3722_EXT_CONTROL_ENABLE2			0x2
#define AS3722_EXT_CONTROL_ENABLE3			0x3

#define AS3722_FUSE7_SD0_LOW_VOLTAGE			BIT(4)

/* Interrupt IDs */
enum as3722_irq {
	AS3722_IRQ_LID,
	AS3722_IRQ_ACOK,
	AS3722_IRQ_ENABLE1,
	AS3722_IRQ_OCCUR_ALARM_SD0,
	AS3722_IRQ_ONKEY_LONG_PRESS,
	AS3722_IRQ_ONKEY,
	AS3722_IRQ_OVTMP,
	AS3722_IRQ_LOWBAT,
	AS3722_IRQ_SD0_LV,
	AS3722_IRQ_SD1_LV,
	AS3722_IRQ_SD2_LV,
	AS3722_IRQ_PWM1_OV_PROT,
	AS3722_IRQ_PWM2_OV_PROT,
	AS3722_IRQ_ENABLE2,
	AS3722_IRQ_SD6_LV,
	AS3722_IRQ_RTC_REP,
	AS3722_IRQ_RTC_ALARM,
	AS3722_IRQ_GPIO1,
	AS3722_IRQ_GPIO2,
	AS3722_IRQ_GPIO3,
	AS3722_IRQ_GPIO4,
	AS3722_IRQ_GPIO5,
	AS3722_IRQ_WATCHDOG,
	AS3722_IRQ_ENABLE3,
	AS3722_IRQ_TEMP_SD0_SHUTDOWN,
	AS3722_IRQ_TEMP_SD1_SHUTDOWN,
	AS3722_IRQ_TEMP_SD2_SHUTDOWN,
	AS3722_IRQ_TEMP_SD0_ALARM,
	AS3722_IRQ_TEMP_SD1_ALARM,
	AS3722_IRQ_TEMP_SD6_ALARM,
	AS3722_IRQ_OCCUR_ALARM_SD6,
	AS3722_IRQ_ADC,
	AS3722_IRQ_MAX,
};

struct as3722 {
	struct device *dev;
	struct regmap *regmap;
	int chip_irq;
	unsigned long irq_flags;
	bool en_intern_int_pullup;
	bool en_intern_i2c_pullup;
	struct regmap_irq_chip_data *irq_data;
};

static inline int as3722_read(struct as3722 *as3722, u32 reg, u32 *dest)
{
	return regmap_read(as3722->regmap, reg, dest);
}

static inline int as3722_write(struct as3722 *as3722, u32 reg, u32 value)
{
	return regmap_write(as3722->regmap, reg, value);
}

static inline int as3722_block_read(struct as3722 *as3722, u32 reg,
		int count, u8 *buf)
{
	return regmap_bulk_read(as3722->regmap, reg, buf, count);
}

static inline int as3722_block_write(struct as3722 *as3722, u32 reg,
		int count, u8 *data)
{
	return regmap_bulk_write(as3722->regmap, reg, data, count);
}

static inline int as3722_update_bits(struct as3722 *as3722, u32 reg,
		u32 mask, u8 val)
{
	return regmap_update_bits(as3722->regmap, reg, mask, val);
}

static inline int as3722_irq_get_virq(struct as3722 *as3722, int irq)
{
	return regmap_irq_get_virq(as3722->irq_data, irq);
}
#endif /* __LINUX_MFD_AS3722_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #ifndef __LINUX_USB_DLN2_H
#define __LINUX_USB_DLN2_H

#define DLN2_CMD(cmd, id)		((cmd) | ((id) << 8))

struct dln2_platform_data {
	u16 handle;		/* sub-driver handle (internally used only) */
	u8 port;		/* I2C/SPI port */
};

/**
 * dln2_event_cb_t - event callback function signature
 *
 * @pdev - the sub-device that registered this callback
 * @echo - the echo header field received in the message
 * @data - the data payload
 * @len  - the data payload length
 *
 * The callback function is called in interrupt context and the data payload is
 * only valid during the call. If the user needs later access of the data, it
 * must copy it.
 */

typedef void (*dln2_event_cb_t)(struct platform_device *pdev, u16 echo,
				const void *data, int len);

/**
 * dl2n_register_event_cb - register a callback function for an event
 *
 * @pdev - the sub-device that registers the callback
 * @event - the event for which to register a callback
 * @event_cb - the callback function
 *
 * @return 0 in case of success, negative value in case of error
 */
int dln2_register_event_cb(struct platform_device *pdev, u16 event,
			   dln2_event_cb_t event_cb);

/**
 * dln2_unregister_event_cb - unregister the callback function for an event
 *
 * @pdev - the sub-device that registered the callback
 * @event - the event for which to register a callback
 */
void dln2_unregister_event_cb(struct platform_device *pdev, u16 event);

/**
 * dln2_transfer - issue a DLN2 command and wait for a response and the
 * associated data
 *
 * @pdev - the sub-device which is issuing this transfer
 * @cmd - the command to be sent to the device
 * @obuf - the buffer to be sent to the device; it can be NULL if the user
 *	doesn't need to transmit data with this command
 * @obuf_len - the size of the buffer to be sent to the device
 * @ibuf - any data associated with the response will be copied here; it can be
 *	NULL if the user doesn't need the response data
 * @ibuf_len - must be initialized to the input buffer size; it will be modified
 *	to indicate the actual data transferred;
 *
 * @return 0 for success, negative value for errors
 */
int dln2_transfer(struct platform_device *pdev, u16 cmd,
		  const void *obuf, unsigned obuf_len,
		  void *ibuf, unsigned *ibuf_len);

/**
 * dln2_transfer_rx - variant of @dln2_transfer() where TX buffer is not needed
 *
 * @pdev - the sub-device which is issuing this transfer
 * @cmd - the command to be sent to the device
 * @ibuf - any data associated with the response will be copied here; it can be
 *	NULL if the user doesn't need the response data
 * @ibuf_len - must be initialized to the input buffer size; it will be modified
 *	to indicate the actual data transferred;
 *
 * @return 0 for success, negative value for errors
 */

static inline int dln2_transfer_rx(struct platform_device *pdev, u16 cmd,
				   void *ibuf, unsigned *ibuf_len)
{
	return dln2_transfer(pdev, cmd, NULL, 0, ibuf, ibuf_len);
}

/**
 * dln2_transfer_tx - variant of @dln2_transfer() where RX buffer is not needed
 *
 * @pdev - the sub-device which is issuing this transfer
 * @cmd - the command to be sent to the device
 * @obuf - the buffer to be sent to the device; it can be NULL if the
 *	user doesn't need to transmit data with this command
 * @obuf_len - the size of the buffer to be sent to the device
 *
 * @return 0 for success, negative value for errors
 */
static inline int dln2_transfer_tx(struct platform_device *pdev, u16 cmd,
				   const void *obuf, unsigned obuf_len)
{
	return dln2_transfer(pdev, cmd, obuf, obuf_len, NULL, NULL);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * max77686.h - Driver for the Maxim 77686/802
 *
 *  Copyright (C) 2012 Samsung Electrnoics
 *  Chiwoong Byun <woong.byun@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * This driver is based on max8997.h
 *
 * MAX77686 has PMIC, RTC devices.
 * The devices share the same I2C bus and included in
 * this mfd driver.
 */

#ifndef __LINUX_MFD_MAX77686_H
#define __LINUX_MFD_MAX77686_H

#include <linux/regulator/consumer.h>

/* MAX77686 regulator IDs */
enum max77686_regulators {
	MAX77686_LDO1 = 0,
	MAX77686_LDO2,
	MAX77686_LDO3,
	MAX77686_LDO4,
	MAX77686_LDO5,
	MAX77686_LDO6,
	MAX77686_LDO7,
	MAX77686_LDO8,
	MAX77686_LDO9,
	MAX77686_LDO10,
	MAX77686_LDO11,
	MAX77686_LDO12,
	MAX77686_LDO13,
	MAX77686_LDO14,
	MAX77686_LDO15,
	MAX77686_LDO16,
	MAX77686_LDO17,
	MAX77686_LDO18,
	MAX77686_LDO19,
	MAX77686_LDO20,
	MAX77686_LDO21,
	MAX77686_LDO22,
	MAX77686_LDO23,
	MAX77686_LDO24,
	MAX77686_LDO25,
	MAX77686_LDO26,
	MAX77686_BUCK1,
	MAX77686_BUCK2,
	MAX77686_BUCK3,
	MAX77686_BUCK4,
	MAX77686_BUCK5,
	MAX77686_BUCK6,
	MAX77686_BUCK7,
	MAX77686_BUCK8,
	MAX77686_BUCK9,

	MAX77686_REG_MAX,
};

/* MAX77802 regulator IDs */
enum max77802_regulators {
	MAX77802_BUCK1 = 0,
	MAX77802_BUCK2,
	MAX77802_BUCK3,
	MAX77802_BUCK4,
	MAX77802_BUCK5,
	MAX77802_BUCK6,
	MAX77802_BUCK7,
	MAX77802_BUCK8,
	MAX77802_BUCK9,
	MAX77802_BUCK10,
	MAX77802_LDO1,
	MAX77802_LDO2,
	MAX77802_LDO3,
	MAX77802_LDO4,
	MAX77802_LDO5,
	MAX77802_LDO6,
	MAX77802_LDO7,
	MAX77802_LDO8,
	MAX77802_LDO9,
	MAX77802_LDO10,
	MAX77802_LDO11,
	MAX77802_LDO12,
	MAX77802_LDO13,
	MAX77802_LDO14,
	MAX77802_LDO15,
	MAX77802_LDO17,
	MAX77802_LDO18,
	MAX77802_LDO19,
	MAX77802_LDO20,
	MAX77802_LDO21,
	MAX77802_LDO23,
	MAX77802_LDO24,
	MAX77802_LDO25,
	MAX77802_LDO26,
	MAX77802_LDO27,
	MAX77802_LDO28,
	MAX77802_LDO29,
	MAX77802_LDO30,
	MAX77802_LDO32,
	MAX77802_LDO33,
	MAX77802_LDO34,
	MAX77802_LDO35,

	MAX77802_REG_MAX,
};

enum max77686_opmode {
	MAX77686_OPMODE_NORMAL,
	MAX77686_OPMODE_LP,
	MAX77686_OPMODE_STANDBY,
};

struct max77686_opmode_data {
	int id;
	int mode;
};

#endif /* __LINUX_MFD_MAX77686_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * lm3533.h -- LM3533 interface
 *
 * Copyright (C) 2011-2012 Texas Instruments
 *
 * Author: Johan Hovold <jhovold@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under  the terms of the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the License, or (at your
 * option) any later version.
 */

#ifndef __LINUX_MFD_LM3533_H
#define __LINUX_MFD_LM3533_H

#define LM3533_ATTR_RO(_name) \
	DEVICE_ATTR(_name, S_IRUGO, show_##_name, NULL)
#define LM3533_ATTR_RW(_name) \
	DEVICE_ATTR(_name, S_IRUGO | S_IWUSR , show_##_name, store_##_name)

struct device;
struct regmap;

struct lm3533 {
	struct device *dev;

	struct regmap *regmap;

	int gpio_hwen;
	int irq;

	unsigned have_als:1;
	unsigned have_backlights:1;
	unsigned have_leds:1;
};

struct lm3533_ctrlbank {
	struct lm3533 *lm3533;
	struct device *dev;
	int id;
};

struct lm3533_als_platform_data {
	unsigned pwm_mode:1;		/* PWM input mode (default analog) */
	u8 r_select;			/* 1 - 127 (ignored in PWM-mode) */
};

struct lm3533_bl_platform_data {
	char *name;
	u16 max_current;		/* 5000 - 29800 uA (800 uA step) */
	u8 default_brightness;		/* 0 - 255 */
	u8 pwm;				/* 0 - 0x3f */
};

struct lm3533_led_platform_data {
	char *name;
	const char *default_trigger;
	u16 max_current;		/* 5000 - 29800 uA (800 uA step) */
	u8 pwm;				/* 0 - 0x3f */
};

enum lm3533_boost_freq {
	LM3533_BOOST_FREQ_500KHZ,
	LM3533_BOOST_FREQ_1000KHZ,
};

enum lm3533_boost_ovp {
	LM3533_BOOST_OVP_16V,
	LM3533_BOOST_OVP_24V,
	LM3533_BOOST_OVP_32V,
	LM3533_BOOST_OVP_40V,
};

struct lm3533_platform_data {
	int gpio_hwen;

	enum lm3533_boost_ovp boost_ovp;
	enum lm3533_boost_freq boost_freq;

	struct lm3533_als_platform_data *als;

	struct lm3533_bl_platform_data *backlights;
	int num_backlights;

	struct lm3533_led_platform_data *leds;
	int num_leds;
};

extern int lm3533_ctrlbank_enable(struct lm3533_ctrlbank *cb);
extern int lm3533_ctrlbank_disable(struct lm3533_ctrlbank *cb);

extern int lm3533_ctrlbank_set_brightness(struct lm3533_ctrlbank *cb, u8 val);
extern int lm3533_ctrlbank_get_brightness(struct lm3533_ctrlbank *cb, u8 *val);
extern int lm3533_ctrlbank_set_max_current(struct lm3533_ctrlbank *cb,
								u16 imax);
extern int lm3533_ctrlbank_set_pwm(struct lm3533_ctrlbank *cb, u8 val);
extern int lm3533_ctrlbank_get_pwm(struct lm3533_ctrlbank *cb, u8 *val);

extern int lm3533_read(struct lm3533 *lm3533, u8 reg, u8 *val);
extern int lm3533_write(struct lm3533 *lm3533, u8 reg, u8 val);
extern int lm3533_update(struct lm3533 *lm3533, u8 reg, u8 val, u8 mask);

#endif	/* __LINUX_MFD_LM3533_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * max77693-private.h - Voltage regulator driver for the Maxim 77693
 *
 *  Copyright (C) 2012 Samsung Electrnoics
 *  SangYoung Son <hello.son@samsung.com>
 *
 * This program is not provided / owned by Maxim Integrated Products.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef __LINUX_MFD_MAX77693_PRIV_H
#define __LINUX_MFD_MAX77693_PRIV_H

#include <linux/i2c.h>

#define MAX77693_REG_INVALID		(0xff)

/* Slave addr = 0xCC: PMIC, Charger, Flash LED */
enum max77693_pmic_reg {
	MAX77693_LED_REG_IFLASH1			= 0x00,
	MAX77693_LED_REG_IFLASH2			= 0x01,
	MAX77693_LED_REG_ITORCH				= 0x02,
	MAX77693_LED_REG_ITORCHTIMER			= 0x03,
	MAX77693_LED_REG_FLASH_TIMER			= 0x04,
	MAX77693_LED_REG_FLASH_EN			= 0x05,
	MAX77693_LED_REG_MAX_FLASH1			= 0x06,
	MAX77693_LED_REG_MAX_FLASH2			= 0x07,
	MAX77693_LED_REG_MAX_FLASH3			= 0x08,
	MAX77693_LED_REG_MAX_FLASH4			= 0x09,
	MAX77693_LED_REG_VOUT_CNTL			= 0x0A,
	MAX77693_LED_REG_VOUT_FLASH1			= 0x0B,
	MAX77693_LED_REG_VOUT_FLASH2			= 0x0C,
	MAX77693_LED_REG_FLASH_INT			= 0x0E,
	MAX77693_LED_REG_FLASH_INT_MASK			= 0x0F,
	MAX77693_LED_REG_FLASH_STATUS			= 0x10,

	MAX77693_PMIC_REG_PMIC_ID1			= 0x20,
	MAX77693_PMIC_REG_PMIC_ID2			= 0x21,
	MAX77693_PMIC_REG_INTSRC			= 0x22,
	MAX77693_PMIC_REG_INTSRC_MASK			= 0x23,
	MAX77693_PMIC_REG_TOPSYS_INT			= 0x24,
	MAX77693_PMIC_REG_TOPSYS_INT_MASK		= 0x26,
	MAX77693_PMIC_REG_TOPSYS_STAT			= 0x28,
	MAX77693_PMIC_REG_MAINCTRL1			= 0x2A,
	MAX77693_PMIC_REG_LSCNFG			= 0x2B,

	MAX77693_CHG_REG_CHG_INT			= 0xB0,
	MAX77693_CHG_REG_CHG_INT_MASK			= 0xB1,
	MAX77693_CHG_REG_CHG_INT_OK			= 0xB2,
	MAX77693_CHG_REG_CHG_DETAILS_00			= 0xB3,
	MAX77693_CHG_REG_CHG_DETAILS_01			= 0xB4,
	MAX77693_CHG_REG_CHG_DETAILS_02			= 0xB5,
	MAX77693_CHG_REG_CHG_DETAILS_03			= 0xB6,
	MAX77693_CHG_REG_CHG_CNFG_00			= 0xB7,
	MAX77693_CHG_REG_CHG_CNFG_01			= 0xB8,
	MAX77693_CHG_REG_CHG_CNFG_02			= 0xB9,
	MAX77693_CHG_REG_CHG_CNFG_03			= 0xBA,
	MAX77693_CHG_REG_CHG_CNFG_04			= 0xBB,
	MAX77693_CHG_REG_CHG_CNFG_05			= 0xBC,
	MAX77693_CHG_REG_CHG_CNFG_06			= 0xBD,
	MAX77693_CHG_REG_CHG_CNFG_07			= 0xBE,
	MAX77693_CHG_REG_CHG_CNFG_08			= 0xBF,
	MAX77693_CHG_REG_CHG_CNFG_09			= 0xC0,
	MAX77693_CHG_REG_CHG_CNFG_10			= 0xC1,
	MAX77693_CHG_REG_CHG_CNFG_11			= 0xC2,
	MAX77693_CHG_REG_CHG_CNFG_12			= 0xC3,
	MAX77693_CHG_REG_CHG_CNFG_13			= 0xC4,
	MAX77693_CHG_REG_CHG_CNFG_14			= 0xC5,
	MAX77693_CHG_REG_SAFEOUT_CTRL			= 0xC6,

	MAX77693_PMIC_REG_END,
};

/* MAX77693 ITORCH register */
#define TORCH_IOUT1_SHIFT	0
#define TORCH_IOUT2_SHIFT	4
#define TORCH_IOUT_MASK(x)	(0xf << (x))
#define TORCH_IOUT_MIN		15625
#define TORCH_IOUT_MAX		250000
#define TORCH_IOUT_STEP		15625

/* MAX77693 IFLASH1 and IFLASH2 registers */
#define FLASH_IOUT_MIN		15625
#define FLASH_IOUT_MAX_1LED	1000000
#define FLASH_IOUT_MAX_2LEDS	625000
#define FLASH_IOUT_STEP		15625

/* MAX77693 TORCH_TIMER register */
#define TORCH_TMR_NO_TIMER	0x40
#define TORCH_TIMEOUT_MIN	262000
#define TORCH_TIMEOUT_MAX	15728000

/* MAX77693 FLASH_TIMER register */
#define FLASH_TMR_LEVEL		0x80
#define FLASH_TIMEOUT_MIN	62500
#define FLASH_TIMEOUT_MAX	1000000
#define FLASH_TIMEOUT_STEP	62500

/* MAX77693 FLASH_EN register */
#define FLASH_EN_OFF		0x0
#define FLASH_EN_FLASH		0x1
#define FLASH_EN_TORCH		0x2
#define FLASH_EN_ON		0x3
#define FLASH_EN_SHIFT(x)	(6 - (x) * 2)
#define TORCH_EN_SHIFT(x)	(2 - (x) * 2)

/* MAX77693 MAX_FLASH1 register */
#define MAX_FLASH1_MAX_FL_EN	0x80
#define MAX_FLASH1_VSYS_MIN	2400
#define MAX_FLASH1_VSYS_MAX	3400
#define MAX_FLASH1_VSYS_STEP	33

/* MAX77693 VOUT_CNTL register */
#define FLASH_BOOST_FIXED	0x04
#define FLASH_BOOST_LEDNUM_2	0x80

/* MAX77693 VOUT_FLASH1 register */
#define FLASH_VOUT_MIN		3300
#define FLASH_VOUT_MAX		5500
#define FLASH_VOUT_STEP		25
#define FLASH_VOUT_RMIN		0x0c

/* MAX77693 FLASH_STATUS register */
#define FLASH_STATUS_FLASH_ON	BIT(3)
#define FLASH_STATUS_TORCH_ON	BIT(2)

/* MAX77693 FLASH_INT register */
#define FLASH_INT_FLED2_OPEN	BIT(0)
#define FLASH_INT_FLED2_SHORT	BIT(1)
#define FLASH_INT_FLED1_OPEN	BIT(2)
#define FLASH_INT_FLED1_SHORT	BIT(3)
#define FLASH_INT_OVER_CURRENT	BIT(4)

/* Fast charge timer in in hours */
#define DEFAULT_FAST_CHARGE_TIMER		4
/* microamps */
#define DEFAULT_TOP_OFF_THRESHOLD_CURRENT	150000
/* minutes */
#define DEFAULT_TOP_OFF_TIMER			30
/* microvolts */
#define DEFAULT_CONSTANT_VOLT			4200000
/* microvolts */
#define DEFAULT_MIN_SYSTEM_VOLT			3600000
/* celsius */
#define DEFAULT_THERMAL_REGULATION_TEMP		100
/* microamps */
#define DEFAULT_BATTERY_OVERCURRENT		3500000
/* microvolts */
#define DEFAULT_CHARGER_INPUT_THRESHOLD_VOLT	4300000

/* MAX77693_CHG_REG_CHG_INT_OK register */
#define CHG_INT_OK_BYP_SHIFT		0
#define CHG_INT_OK_BAT_SHIFT		3
#define CHG_INT_OK_CHG_SHIFT		4
#define CHG_INT_OK_CHGIN_SHIFT		6
#define CHG_INT_OK_DETBAT_SHIFT		7
#define CHG_INT_OK_BYP_MASK		BIT(CHG_INT_OK_BYP_SHIFT)
#define CHG_INT_OK_BAT_MASK		BIT(CHG_INT_OK_BAT_SHIFT)
#define CHG_INT_OK_CHG_MASK		BIT(CHG_INT_OK_CHG_SHIFT)
#define CHG_INT_OK_CHGIN_MASK		BIT(CHG_INT_OK_CHGIN_SHIFT)
#define CHG_INT_OK_DETBAT_MASK		BIT(CHG_INT_OK_DETBAT_SHIFT)

/* MAX77693_CHG_REG_CHG_DETAILS_00 register */
#define CHG_DETAILS_00_CHGIN_SHIFT	5
#define CHG_DETAILS_00_CHGIN_MASK	(0x3 << CHG_DETAILS_00_CHGIN_SHIFT)

/* MAX77693_CHG_REG_CHG_DETAILS_01 register */
#define CHG_DETAILS_01_CHG_SHIFT	0
#define CHG_DETAILS_01_BAT_SHIFT	4
#define CHG_DETAILS_01_TREG_SHIFT	7
#define CHG_DETAILS_01_CHG_MASK		(0xf << CHG_DETAILS_01_CHG_SHIFT)
#define CHG_DETAILS_01_BAT_MASK		(0x7 << CHG_DETAILS_01_BAT_SHIFT)
#define CHG_DETAILS_01_TREG_MASK	BIT(7)

/* MAX77693_CHG_REG_CHG_DETAILS_01/CHG field */
enum max77693_charger_charging_state {
	MAX77693_CHARGING_PREQUALIFICATION	= 0x0,
	MAX77693_CHARGING_FAST_CONST_CURRENT,
	MAX77693_CHARGING_FAST_CONST_VOLTAGE,
	MAX77693_CHARGING_TOP_OFF,
	MAX77693_CHARGING_DONE,
	MAX77693_CHARGING_HIGH_TEMP,
	MAX77693_CHARGING_TIMER_EXPIRED,
	MAX77693_CHARGING_THERMISTOR_SUSPEND,
	MAX77693_CHARGING_OFF,
	MAX77693_CHARGING_RESERVED,
	MAX77693_CHARGING_OVER_TEMP,
	MAX77693_CHARGING_WATCHDOG_EXPIRED,
};

/* MAX77693_CHG_REG_CHG_DETAILS_01/BAT field */
enum max77693_charger_battery_state {
	MAX77693_BATTERY_NOBAT			= 0x0,
	/* Dead-battery or low-battery prequalification */
	MAX77693_BATTERY_PREQUALIFICATION,
	MAX77693_BATTERY_TIMER_EXPIRED,
	MAX77693_BATTERY_GOOD,
	MAX77693_BATTERY_LOWVOLTAGE,
	MAX77693_BATTERY_OVERVOLTAGE,
	MAX77693_BATTERY_OVERCURRENT,
	MAX77693_BATTERY_RESERVED,
};

/* MAX77693_CHG_REG_CHG_DETAILS_02 register */
#define CHG_DETAILS_02_BYP_SHIFT	0
#define CHG_DETAILS_02_BYP_MASK		(0xf << CHG_DETAILS_02_BYP_SHIFT)

/* MAX77693 CHG_CNFG_00 register */
#define CHG_CNFG_00_CHG_MASK		0x1
#define CHG_CNFG_00_BUCK_MASK		0x4

/* MAX77693_CHG_REG_CHG_CNFG_01 register */
#define CHG_CNFG_01_FCHGTIME_SHIFT	0
#define CHG_CNFG_01_CHGRSTRT_SHIFT	4
#define CHG_CNFG_01_PQEN_SHIFT		7
#define CHG_CNFG_01_FCHGTIME_MASK	(0x7 << CHG_CNFG_01_FCHGTIME_SHIFT)
#define CHG_CNFG_01_CHGRSTRT_MASK	(0x3 << CHG_CNFG_01_CHGRSTRT_SHIFT)
#define CHG_CNFG_01_PQEN_MAKS		BIT(CHG_CNFG_01_PQEN_SHIFT)

/* MAX77693_CHG_REG_CHG_CNFG_03 register */
#define CHG_CNFG_03_TOITH_SHIFT		0
#define CHG_CNFG_03_TOTIME_SHIFT	3
#define CHG_CNFG_03_TOITH_MASK		(0x7 << CHG_CNFG_03_TOITH_SHIFT)
#define CHG_CNFG_03_TOTIME_MASK		(0x7 << CHG_CNFG_03_TOTIME_SHIFT)

/* MAX77693_CHG_REG_CHG_CNFG_04 register */
#define CHG_CNFG_04_CHGCVPRM_SHIFT	0
#define CHG_CNFG_04_MINVSYS_SHIFT	5
#define CHG_CNFG_04_CHGCVPRM_MASK	(0x1f << CHG_CNFG_04_CHGCVPRM_SHIFT)
#define CHG_CNFG_04_MINVSYS_MASK	(0x7 << CHG_CNFG_04_MINVSYS_SHIFT)

/* MAX77693_CHG_REG_CHG_CNFG_06 register */
#define CHG_CNFG_06_CHGPROT_SHIFT	2
#define CHG_CNFG_06_CHGPROT_MASK	(0x3 << CHG_CNFG_06_CHGPROT_SHIFT)

/* MAX77693_CHG_REG_CHG_CNFG_07 register */
#define CHG_CNFG_07_REGTEMP_SHIFT	5
#define CHG_CNFG_07_REGTEMP_MASK	(0x3 << CHG_CNFG_07_REGTEMP_SHIFT)

/* MAX77693_CHG_REG_CHG_CNFG_12 register */
#define CHG_CNFG_12_B2SOVRC_SHIFT	0
#define CHG_CNFG_12_VCHGINREG_SHIFT	3
#define CHG_CNFG_12_B2SOVRC_MASK	(0x7 << CHG_CNFG_12_B2SOVRC_SHIFT)
#define CHG_CNFG_12_VCHGINREG_MASK	(0x3 << CHG_CNFG_12_VCHGINREG_SHIFT)

/* MAX77693 CHG_CNFG_09 Register */
#define CHG_CNFG_09_CHGIN_ILIM_MASK	0x7F

/* MAX77693 CHG_CTRL Register */
#define SAFEOUT_CTRL_SAFEOUT1_MASK	0x3
#define SAFEOUT_CTRL_SAFEOUT2_MASK	0xC
#define SAFEOUT_CTRL_ENSAFEOUT1_MASK	0x40
#define SAFEOUT_CTRL_ENSAFEOUT2_MASK	0x80

/* Slave addr = 0x4A: MUIC */
enum max77693_muic_reg {
	MAX77693_MUIC_REG_ID		= 0x00,
	MAX77693_MUIC_REG_INT1		= 0x01,
	MAX77693_MUIC_REG_INT2		= 0x02,
	MAX77693_MUIC_REG_INT3		= 0x03,
	MAX77693_MUIC_REG_STATUS1	= 0x04,
	MAX77693_MUIC_REG_STATUS2	= 0x05,
	MAX77693_MUIC_REG_STATUS3	= 0x06,
	MAX77693_MUIC_REG_INTMASK1	= 0x07,
	MAX77693_MUIC_REG_INTMASK2	= 0x08,
	MAX77693_MUIC_REG_INTMASK3	= 0x09,
	MAX77693_MUIC_REG_CDETCTRL1	= 0x0A,
	MAX77693_MUIC_REG_CDETCTRL2	= 0x0B,
	MAX77693_MUIC_REG_CTRL1		= 0x0C,
	MAX77693_MUIC_REG_CTRL2		= 0x0D,
	MAX77693_MUIC_REG_CTRL3		= 0x0E,

	MAX77693_MUIC_REG_END,
};

/* MAX77693 INTMASK1~2 Register */
#define INTMASK1_ADC1K_SHIFT		3
#define INTMASK1_ADCERR_SHIFT		2
#define INTMASK1_ADCLOW_SHIFT		1
#define INTMASK1_ADC_SHIFT		0
#define INTMASK1_ADC1K_MASK		(1 << INTMASK1_ADC1K_SHIFT)
#define INTMASK1_ADCERR_MASK		(1 << INTMASK1_ADCERR_SHIFT)
#define INTMASK1_ADCLOW_MASK		(1 << INTMASK1_ADCLOW_SHIFT)
#define INTMASK1_ADC_MASK		(1 << INTMASK1_ADC_SHIFT)

#define INTMASK2_VIDRM_SHIFT		5
#define INTMASK2_VBVOLT_SHIFT		4
#define INTMASK2_DXOVP_SHIFT		3
#define INTMASK2_DCDTMR_SHIFT		2
#define INTMASK2_CHGDETRUN_SHIFT	1
#define INTMASK2_CHGTYP_SHIFT		0
#define INTMASK2_VIDRM_MASK		(1 << INTMASK2_VIDRM_SHIFT)
#define INTMASK2_VBVOLT_MASK		(1 << INTMASK2_VBVOLT_SHIFT)
#define INTMASK2_DXOVP_MASK		(1 << INTMASK2_DXOVP_SHIFT)
#define INTMASK2_DCDTMR_MASK		(1 << INTMASK2_DCDTMR_SHIFT)
#define INTMASK2_CHGDETRUN_MASK		(1 << INTMASK2_CHGDETRUN_SHIFT)
#define INTMASK2_CHGTYP_MASK		(1 << INTMASK2_CHGTYP_SHIFT)

/* MAX77693 MUIC - STATUS1~3 Register */
#define STATUS1_ADC_SHIFT		(0)
#define STATUS1_ADCLOW_SHIFT		(5)
#define STATUS1_ADCERR_SHIFT		(6)
#define STATUS1_ADC1K_SHIFT		(7)
#define STATUS1_ADC_MASK		(0x1f << STATUS1_ADC_SHIFT)
#define STATUS1_ADCLOW_MASK		(0x1 << STATUS1_ADCLOW_SHIFT)
#define STATUS1_ADCERR_MASK		(0x1 << STATUS1_ADCERR_SHIFT)
#define STATUS1_ADC1K_MASK		(0x1 << STATUS1_ADC1K_SHIFT)

#define STATUS2_CHGTYP_SHIFT		(0)
#define STATUS2_CHGDETRUN_SHIFT		(3)
#define STATUS2_DCDTMR_SHIFT		(4)
#define STATUS2_DXOVP_SHIFT		(5)
#define STATUS2_VBVOLT_SHIFT		(6)
#define STATUS2_VIDRM_SHIFT		(7)
#define STATUS2_CHGTYP_MASK		(0x7 << STATUS2_CHGTYP_SHIFT)
#define STATUS2_CHGDETRUN_MASK		(0x1 << STATUS2_CHGDETRUN_SHIFT)
#define STATUS2_DCDTMR_MASK		(0x1 << STATUS2_DCDTMR_SHIFT)
#define STATUS2_DXOVP_MASK		(0x1 << STATUS2_DXOVP_SHIFT)
#define STATUS2_VBVOLT_MASK		(0x1 << STATUS2_VBVOLT_SHIFT)
#define STATUS2_VIDRM_MASK		(0x1 << STATUS2_VIDRM_SHIFT)

#define STATUS3_OVP_SHIFT		(2)
#define STATUS3_OVP_MASK		(0x1 << STATUS3_OVP_SHIFT)

/* MAX77693 CDETCTRL1~2 register */
#define CDETCTRL1_CHGDETEN_SHIFT	(0)
#define CDETCTRL1_CHGTYPMAN_SHIFT	(1)
#define CDETCTRL1_DCDEN_SHIFT		(2)
#define CDETCTRL1_DCD2SCT_SHIFT		(3)
#define CDETCTRL1_CDDELAY_SHIFT		(4)
#define CDETCTRL1_DCDCPL_SHIFT		(5)
#define CDETCTRL1_CDPDET_SHIFT		(7)
#define CDETCTRL1_CHGDETEN_MASK		(0x1 << CDETCTRL1_CHGDETEN_SHIFT)
#define CDETCTRL1_CHGTYPMAN_MASK	(0x1 << CDETCTRL1_CHGTYPMAN_SHIFT)
#define CDETCTRL1_DCDEN_MASK		(0x1 << CDETCTRL1_DCDEN_SHIFT)
#define CDETCTRL1_DCD2SCT_MASK		(0x1 << CDETCTRL1_DCD2SCT_SHIFT)
#define CDETCTRL1_CDDELAY_MASK		(0x1 << CDETCTRL1_CDDELAY_SHIFT)
#define CDETCTRL1_DCDCPL_MASK		(0x1 << CDETCTRL1_DCDCPL_SHIFT)
#define CDETCTRL1_CDPDET_MASK		(0x1 << CDETCTRL1_CDPDET_SHIFT)

#define CDETCTRL2_VIDRMEN_SHIFT		(1)
#define CDETCTRL2_DXOVPEN_SHIFT		(3)
#define CDETCTRL2_VIDRMEN_MASK		(0x1 << CDETCTRL2_VIDRMEN_SHIFT)
#define CDETCTRL2_DXOVPEN_MASK		(0x1 << CDETCTRL2_DXOVPEN_SHIFT)

/* MAX77693 MUIC - CONTROL1~3 register */
#define COMN1SW_SHIFT			(0)
#define COMP2SW_SHIFT			(3)
#define COMN1SW_MASK			(0x7 << COMN1SW_SHIFT)
#define COMP2SW_MASK			(0x7 << COMP2SW_SHIFT)
#define COMP_SW_MASK			(COMP2SW_MASK | COMN1SW_MASK)
#define CONTROL1_SW_USB			((1 << COMP2SW_SHIFT) \
						| (1 << COMN1SW_SHIFT))
#define CONTROL1_SW_AUDIO		((2 << COMP2SW_SHIFT) \
						| (2 << COMN1SW_SHIFT))
#define CONTROL1_SW_UART		((3 << COMP2SW_SHIFT) \
						| (3 << COMN1SW_SHIFT))
#define CONTROL1_SW_OPEN		((0 << COMP2SW_SHIFT) \
						| (0 << COMN1SW_SHIFT))

#define CONTROL2_LOWPWR_SHIFT		(0)
#define CONTROL2_ADCEN_SHIFT		(1)
#define CONTROL2_CPEN_SHIFT		(2)
#define CONTROL2_SFOUTASRT_SHIFT	(3)
#define CONTROL2_SFOUTORD_SHIFT		(4)
#define CONTROL2_ACCDET_SHIFT		(5)
#define CONTROL2_USBCPINT_SHIFT		(6)
#define CONTROL2_RCPS_SHIFT		(7)
#define CONTROL2_LOWPWR_MASK		(0x1 << CONTROL2_LOWPWR_SHIFT)
#define CONTROL2_ADCEN_MASK		(0x1 << CONTROL2_ADCEN_SHIFT)
#define CONTROL2_CPEN_MASK		(0x1 << CONTROL2_CPEN_SHIFT)
#define CONTROL2_SFOUTASRT_MASK		(0x1 << CONTROL2_SFOUTASRT_SHIFT)
#define CONTROL2_SFOUTORD_MASK		(0x1 << CONTROL2_SFOUTORD_SHIFT)
#define CONTROL2_ACCDET_MASK		(0x1 << CONTROL2_ACCDET_SHIFT)
#define CONTROL2_USBCPINT_MASK		(0x1 << CONTROL2_USBCPINT_SHIFT)
#define CONTROL2_RCPS_MASK		(0x1 << CONTROL2_RCPS_SHIFT)

#define CONTROL3_JIGSET_SHIFT		(0)
#define CONTROL3_BTLDSET_SHIFT		(2)
#define CONTROL3_ADCDBSET_SHIFT		(4)
#define CONTROL3_JIGSET_MASK		(0x3 << CONTROL3_JIGSET_SHIFT)
#define CONTROL3_BTLDSET_MASK		(0x3 << CONTROL3_BTLDSET_SHIFT)
#define CONTROL3_ADCDBSET_MASK		(0x3 << CONTROL3_ADCDBSET_SHIFT)

/* Slave addr = 0x90: Haptic */
enum max77693_haptic_reg {
	MAX77693_HAPTIC_REG_STATUS		= 0x00,
	MAX77693_HAPTIC_REG_CONFIG1		= 0x01,
	MAX77693_HAPTIC_REG_CONFIG2		= 0x02,
	MAX77693_HAPTIC_REG_CONFIG_CHNL		= 0x03,
	MAX77693_HAPTIC_REG_CONFG_CYC1		= 0x04,
	MAX77693_HAPTIC_REG_CONFG_CYC2		= 0x05,
	MAX77693_HAPTIC_REG_CONFIG_PER1		= 0x06,
	MAX77693_HAPTIC_REG_CONFIG_PER2		= 0x07,
	MAX77693_HAPTIC_REG_CONFIG_PER3		= 0x08,
	MAX77693_HAPTIC_REG_CONFIG_PER4		= 0x09,
	MAX77693_HAPTIC_REG_CONFIG_DUTY1	= 0x0A,
	MAX77693_HAPTIC_REG_CONFIG_DUTY2	= 0x0B,
	MAX77693_HAPTIC_REG_CONFIG_PWM1		= 0x0C,
	MAX77693_HAPTIC_REG_CONFIG_PWM2		= 0x0D,
	MAX77693_HAPTIC_REG_CONFIG_PWM3		= 0x0E,
	MAX77693_HAPTIC_REG_CONFIG_PWM4		= 0x0F,
	MAX77693_HAPTIC_REG_REV			= 0x10,

	MAX77693_HAPTIC_REG_END,
};

/* max77693-pmic LSCNFG configuraton register */
#define MAX77693_PMIC_LOW_SYS_MASK      0x80
#define MAX77693_PMIC_LOW_SYS_SHIFT     7

/* max77693-haptic configuration register */
#define MAX77693_CONFIG2_MODE           7
#define MAX77693_CONFIG2_MEN            6
#define MAX77693_CONFIG2_HTYP           5

enum max77693_irq_source {
	LED_INT = 0,
	TOPSYS_INT,
	CHG_INT,
	MUIC_INT1,
	MUIC_INT2,
	MUIC_INT3,

	MAX77693_IRQ_GROUP_NR,
};

#define SRC_IRQ_CHARGER			BIT(0)
#define SRC_IRQ_TOP			BIT(1)
#define SRC_IRQ_FLASH			BIT(2)
#define SRC_IRQ_MUIC			BIT(3)
#define SRC_IRQ_ALL			(SRC_IRQ_CHARGER | SRC_IRQ_TOP \
						| SRC_IRQ_FLASH | SRC_IRQ_MUIC)

#define LED_IRQ_FLED2_OPEN		BIT(0)
#define LED_IRQ_FLED2_SHORT		BIT(1)
#define LED_IRQ_FLED1_OPEN		BIT(2)
#define LED_IRQ_FLED1_SHORT		BIT(3)
#define LED_IRQ_MAX_FLASH		BIT(4)

#define TOPSYS_IRQ_T120C_INT		BIT(0)
#define TOPSYS_IRQ_T140C_INT		BIT(1)
#define TOPSYS_IRQ_LOWSYS_INT		BIT(3)

#define CHG_IRQ_BYP_I			BIT(0)
#define CHG_IRQ_THM_I			BIT(2)
#define CHG_IRQ_BAT_I			BIT(3)
#define CHG_IRQ_CHG_I			BIT(4)
#define CHG_IRQ_CHGIN_I			BIT(6)

#define MUIC_IRQ_INT1_ADC		BIT(0)
#define MUIC_IRQ_INT1_ADC_LOW		BIT(1)
#define MUIC_IRQ_INT1_ADC_ERR		BIT(2)
#define MUIC_IRQ_INT1_ADC1K		BIT(3)

#define MUIC_IRQ_INT2_CHGTYP		BIT(0)
#define MUIC_IRQ_INT2_CHGDETREUN	BIT(1)
#define MUIC_IRQ_INT2_DCDTMR		BIT(2)
#define MUIC_IRQ_INT2_DXOVP		BIT(3)
#define MUIC_IRQ_INT2_VBVOLT		BIT(4)
#define MUIC_IRQ_INT2_VIDRM		BIT(5)

#define MUIC_IRQ_INT3_EOC		BIT(0)
#define MUIC_IRQ_INT3_CGMBC		BIT(1)
#define MUIC_IRQ_INT3_OVP		BIT(2)
#define MUIC_IRQ_INT3_MBCCHG_ERR	BIT(3)
#define MUIC_IRQ_INT3_CHG_ENABLED	BIT(4)
#define MUIC_IRQ_INT3_BAT_DET		BIT(5)

enum max77693_irq {
	/* PMIC - FLASH */
	MAX77693_LED_IRQ_FLED2_OPEN,
	MAX77693_LED_IRQ_FLED2_SHORT,
	MAX77693_LED_IRQ_FLED1_OPEN,
	MAX77693_LED_IRQ_FLED1_SHORT,
	MAX77693_LED_IRQ_MAX_FLASH,

	/* PMIC - TOPSYS */
	MAX77693_TOPSYS_IRQ_T120C_INT,
	MAX77693_TOPSYS_IRQ_T140C_INT,
	MAX77693_TOPSYS_IRQ_LOWSYS_INT,

	/* PMIC - Charger */
	MAX77693_CHG_IRQ_BYP_I,
	MAX77693_CHG_IRQ_THM_I,
	MAX77693_CHG_IRQ_BAT_I,
	MAX77693_CHG_IRQ_CHG_I,
	MAX77693_CHG_IRQ_CHGIN_I,

	MAX77693_IRQ_NR,
};

enum max77693_irq_muic {
	/* MUIC INT1 */
	MAX77693_MUIC_IRQ_INT1_ADC,
	MAX77693_MUIC_IRQ_INT1_ADC_LOW,
	MAX77693_MUIC_IRQ_INT1_ADC_ERR,
	MAX77693_MUIC_IRQ_INT1_ADC1K,

	/* MUIC INT2 */
	MAX77693_MUIC_IRQ_INT2_CHGTYP,
	MAX77693_MUIC_IRQ_INT2_CHGDETREUN,
	MAX77693_MUIC_IRQ_INT2_DCDTMR,
	MAX77693_MUIC_IRQ_INT2_DXOVP,
	MAX77693_MUIC_IRQ_INT2_VBVOLT,
	MAX77693_MUIC_IRQ_INT2_VIDRM,

	/* MUIC INT3 */
	MAX77693_MUIC_IRQ_INT3_EOC,
	MAX77693_MUIC_IRQ_INT3_CGMBC,
	MAX77693_MUIC_IRQ_INT3_OVP,
	MAX77693_MUIC_IRQ_INT3_MBCCHG_ERR,
	MAX77693_MUIC_IRQ_INT3_CHG_ENABLED,
	MAX77693_MUIC_IRQ_INT3_BAT_DET,

	MAX77693_MUIC_IRQ_NR,
};

struct max77693_dev {
	struct device *dev;
	struct i2c_client *i2c;		/* 0xCC , PMIC, Charger, Flash LED */
	struct i2c_client *muic;	/* 0x4A , MUIC */
	struct i2c_client *haptic;	/* 0x90 , Haptic */

	int type;

	struct regmap *regmap;
	struct regmap *regmap_muic;
	struct regmap *regmap_haptic;

	struct regmap_irq_chip_data *irq_data_led;
	struct regmap_irq_chip_data *irq_data_topsys;
	struct regmap_irq_chip_data *irq_data_charger;
	struct regmap_irq_chip_data *irq_data_muic;

	int irq;
	int irq_gpio;
	struct mutex irqlock;
	int irq_masks_cur[MAX77693_IRQ_GROUP_NR];
	int irq_masks_cache[MAX77693_IRQ_GROUP_NR];
};

enum max77693_types {
	TYPE_MAX77693,
};

extern int max77693_irq_init(struct max77693_dev *max77686);
extern void max77693_irq_exit(struct max77693_dev *max77686);
extern int max77693_irq_resume(struct max77693_dev *max77686);

#endif /*  __LINUX_MFD_MAX77693_PRIV_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * HTC simple EGPIO irq and gpio extender
 */

#ifndef __HTC_EGPIO_H__
#define __HTC_EGPIO_H__

#include <linux/gpio.h>

/* Descriptive values for all-in or all-out htc_egpio_chip descriptors. */
#define HTC_EGPIO_OUTPUT (~0)
#define HTC_EGPIO_INPUT  0

/**
 * struct htc_egpio_chip - descriptor to create gpio_chip for register range
 * @reg_start: index of first register
 * @gpio_base: gpio number of first pin in this register range
 * @num_gpios: number of gpios in this register range, max BITS_PER_LONG
 *    (number of registers = DIV_ROUND_UP(num_gpios, reg_width))
 * @direction: bitfield, '0' = input, '1' = output,
 */
struct htc_egpio_chip {
	int           reg_start;
	int           gpio_base;
	int           num_gpios;
	unsigned long direction;
	unsigned long initial_values;
};

/**
 * struct htc_egpio_platform_data - description provided by the arch
 * @irq_base: beginning of available IRQs (eg, IRQ_BOARD_START)
 * @num_irqs: number of irqs
 * @reg_width: number of bits per register, either 8 or 16 bit
 * @bus_width: alignment of the registers, either 16 or 32 bit
 * @invert_acks: set if chip requires writing '0' to ack an irq, instead of '1'
 * @ack_register: location of the irq/ack register
 * @chip: pointer to array of htc_egpio_chip descriptors
 * @num_chips: number of egpio chip descriptors
 */
struct htc_egpio_platform_data {
	int                   bus_width;
	int                   reg_width;

	int                   irq_base;
	int                   num_irqs;
	int                   invert_acks;
	int                   ack_register;

	struct htc_egpio_chip *chip;
	int                   num_chips;
};

/* Determine the wakeup irq, to be called during early resume */
extern int htc_egpio_get_wakeup_irq(struct device *dev);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * Header file for the compaq Micro MFD
 */

#ifndef _MFD_IPAQ_MICRO_H_
#define _MFD_IPAQ_MICRO_H_

#include <linux/spinlock.h>
#include <linux/completion.h>
#include <linux/list.h>

#define TX_BUF_SIZE	32
#define RX_BUF_SIZE	16
#define CHAR_SOF	0x02

/*
 * These are the different messages that can be sent to the microcontroller
 * to control various aspects.
 */
#define MSG_VERSION		0x0
#define MSG_KEYBOARD		0x2
#define MSG_TOUCHSCREEN		0x3
#define MSG_EEPROM_READ		0x4
#define MSG_EEPROM_WRITE	0x5
#define MSG_THERMAL_SENSOR	0x6
#define MSG_NOTIFY_LED		0x8
#define MSG_BATTERY		0x9
#define MSG_SPI_READ		0xb
#define MSG_SPI_WRITE		0xc
#define MSG_BACKLIGHT		0xd /* H3600 only */
#define MSG_CODEC_CTRL		0xe /* H3100 only */
#define MSG_DISPLAY_CTRL	0xf /* H3100 only */

/* state of receiver parser */
enum rx_state {
	STATE_SOF = 0,     /* Next byte should be start of frame */
	STATE_ID,          /* Next byte is ID & message length   */
	STATE_DATA,        /* Next byte is a data byte           */
	STATE_CHKSUM       /* Next byte should be checksum       */
};

/**
 * struct ipaq_micro_txdev - TX state
 * @len: length of message in TX buffer
 * @index: current index into TX buffer
 * @buf: TX buffer
 */
struct ipaq_micro_txdev {
	u8 len;
	u8 index;
	u8 buf[TX_BUF_SIZE];
};

/**
 * struct ipaq_micro_rxdev - RX state
 * @state: context of RX state machine
 * @chksum: calculated checksum
 * @id: message ID from packet
 * @len: RX buffer length
 * @index: RX buffer index
 * @buf: RX buffer
 */
struct ipaq_micro_rxdev {
	enum rx_state state;
	unsigned char chksum;
	u8            id;
	unsigned int  len;
	unsigned int  index;
	u8            buf[RX_BUF_SIZE];
};

/**
 * struct ipaq_micro_msg - message to the iPAQ microcontroller
 * @id: 4-bit ID of the message
 * @tx_len: length of TX data
 * @tx_data: TX data to send
 * @rx_len: length of receieved RX data
 * @rx_data: RX data to recieve
 * @ack: a completion that will be completed when RX is complete
 * @node: list node if message gets queued
 */
struct ipaq_micro_msg {
	u8 id;
	u8 tx_len;
	u8 tx_data[TX_BUF_SIZE];
	u8 rx_len;
	u8 rx_data[RX_BUF_SIZE];
	struct completion ack;
	struct list_head node;
};

/**
 * struct ipaq_micro - iPAQ microcontroller state
 * @dev: corresponding platform device
 * @base: virtual memory base for underlying serial device
 * @sdlc: virtual memory base for Synchronous Data Link Controller
 * @version: version string
 * @tx: TX state
 * @rx: RX state
 * @lock: lock for this state container
 * @msg: current message
 * @queue: message queue
 * @key: callback for asynchronous key events
 * @key_data: data to pass along with key events
 * @ts: callback for asynchronous touchscreen events
 * @ts_data: data to pass along with key events
 */
struct ipaq_micro {
	struct device *dev;
	void __iomem *base;
	void __iomem *sdlc;
	char version[5];
	struct ipaq_micro_txdev tx;	/* transmit ISR state */
	struct ipaq_micro_rxdev rx;	/* receive ISR state */
	spinlock_t lock;
	struct ipaq_micro_msg *msg;
	struct list_head queue;
	void (*key) (void *data, int len, unsigned char *rxdata);
	void *key_data;
	void (*ts) (void *data, int len, unsigned char *rxdata);
	void *ts_data;
};

extern int
ipaq_micro_tx_msg(struct ipaq_micro *micro, struct ipaq_micro_msg *msg);

static inline int
ipaq_micro_tx_msg_sync(struct ipaq_micro *micro,
		       struct ipaq_micro_msg *msg)
{
	int ret;

	init_completion(&msg->ack);
	ret = ipaq_micro_tx_msg(micro, msg);
	wait_for_completion(&msg->ack);

	return ret;
}

static inline int
ipaq_micro_tx_msg_async(struct ipaq_micro *micro,
			struct ipaq_micro_msg *msg)
{
	init_completion(&msg->ack);
	return ipaq_micro_tx_msg(micro, msg);
}

#endif /* _MFD_IPAQ_MICRO_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Retu/Tahvo MFD driver interface
 *
 * This file is subject to the terms and conditions of the GNU General
 * Public License. See the file "COPYING" in the main directory of this
 * archive for more details.
 */

#ifndef __LINUX_MFD_RETU_H
#define __LINUX_MFD_RETU_H

struct retu_dev;

int retu_read(struct retu_dev *, u8);
int retu_write(struct retu_dev *, u8, u16);

/* Registers */
#define RETU_REG_WATCHDOG	0x17		/* Watchdog */
#define RETU_REG_CC1		0x0d		/* Common control register 1 */
#define RETU_REG_STATUS		0x16		/* Status register */

/* Interrupt sources */
#define TAHVO_INT_VBUS		0		/* VBUS state */

/* Interrupt status */
#define TAHVO_STAT_VBUS		(1 << TAHVO_INT_VBUS)

#endif /* __LINUX_MFD_RETU_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * TI LP8788 MFD Device
 *
 * Copyright 2012 Texas Instruments
 *
 * Author: Milo(Woogyom) Kim <milo.kim@ti.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 */

#ifndef __MFD_LP8788_H__
#define __MFD_LP8788_H__

#include <linux/gpio.h>
#include <linux/irqdomain.h>
#include <linux/pwm.h>
#include <linux/regmap.h>

#define LP8788_DEV_BUCK		"lp8788-buck"
#define LP8788_DEV_DLDO		"lp8788-dldo"
#define LP8788_DEV_ALDO		"lp8788-aldo"
#define LP8788_DEV_CHARGER	"lp8788-charger"
#define LP8788_DEV_RTC		"lp8788-rtc"
#define LP8788_DEV_BACKLIGHT	"lp8788-backlight"
#define LP8788_DEV_VIBRATOR	"lp8788-vibrator"
#define LP8788_DEV_KEYLED	"lp8788-keyled"
#define LP8788_DEV_ADC		"lp8788-adc"

#define LP8788_NUM_BUCKS	4
#define LP8788_NUM_DLDOS	12
#define LP8788_NUM_ALDOS	10
#define LP8788_NUM_BUCK2_DVS	2

#define LP8788_CHG_IRQ		"CHG_IRQ"
#define LP8788_PRSW_IRQ		"PRSW_IRQ"
#define LP8788_BATT_IRQ		"BATT_IRQ"
#define LP8788_ALM_IRQ		"ALARM_IRQ"

enum lp8788_int_id {
	/* interrup register 1 : Addr 00h */
	LP8788_INT_TSDL,
	LP8788_INT_TSDH,
	LP8788_INT_UVLO,
	LP8788_INT_FLAGMON,
	LP8788_INT_PWRON_TIME,
	LP8788_INT_PWRON,
	LP8788_INT_COMP1,
	LP8788_INT_COMP2,

	/* interrupt register 2 : Addr 01h */
	LP8788_INT_CHG_INPUT_STATE,
	LP8788_INT_CHG_STATE,
	LP8788_INT_EOC,
	LP8788_INT_CHG_RESTART,
	LP8788_INT_RESTART_TIMEOUT,
	LP8788_INT_FULLCHG_TIMEOUT,
	LP8788_INT_PRECHG_TIMEOUT,

	/* interrupt register 3 : Addr 02h */
	LP8788_INT_RTC_ALARM1 = 17,
	LP8788_INT_RTC_ALARM2,
	LP8788_INT_ENTER_SYS_SUPPORT,
	LP8788_INT_EXIT_SYS_SUPPORT,
	LP8788_INT_BATT_LOW,
	LP8788_INT_NO_BATT,

	LP8788_INT_MAX = 24,
};

enum lp8788_dvs_sel {
	DVS_SEL_V0,
	DVS_SEL_V1,
	DVS_SEL_V2,
	DVS_SEL_V3,
};

enum lp8788_ext_ldo_en_id {
	EN_ALDO1,
	EN_ALDO234,
	EN_ALDO5,
	EN_ALDO7,
	EN_DLDO7,
	EN_DLDO911,
	EN_LDOS_MAX,
};

enum lp8788_charger_event {
	NO_CHARGER,
	CHARGER_DETECTED,
};

enum lp8788_bl_ctrl_mode {
	LP8788_BL_REGISTER_ONLY,
	LP8788_BL_COMB_PWM_BASED,	/* PWM + I2C, changed by PWM input */
	LP8788_BL_COMB_REGISTER_BASED,	/* PWM + I2C, changed by I2C */
};

enum lp8788_bl_dim_mode {
	LP8788_DIM_EXPONENTIAL,
	LP8788_DIM_LINEAR,
};

enum lp8788_bl_full_scale_current {
	LP8788_FULLSCALE_5000uA,
	LP8788_FULLSCALE_8500uA,
	LP8788_FULLSCALE_1200uA,
	LP8788_FULLSCALE_1550uA,
	LP8788_FULLSCALE_1900uA,
	LP8788_FULLSCALE_2250uA,
	LP8788_FULLSCALE_2600uA,
	LP8788_FULLSCALE_2950uA,
};

enum lp8788_bl_ramp_step {
	LP8788_RAMP_8us,
	LP8788_RAMP_1024us,
	LP8788_RAMP_2048us,
	LP8788_RAMP_4096us,
	LP8788_RAMP_8192us,
	LP8788_RAMP_16384us,
	LP8788_RAMP_32768us,
	LP8788_RAMP_65538us,
};

enum lp8788_isink_scale {
	LP8788_ISINK_SCALE_100mA,
	LP8788_ISINK_SCALE_120mA,
};

enum lp8788_isink_number {
	LP8788_ISINK_1,
	LP8788_ISINK_2,
	LP8788_ISINK_3,
};

enum lp8788_alarm_sel {
	LP8788_ALARM_1,
	LP8788_ALARM_2,
	LP8788_ALARM_MAX,
};

enum lp8788_adc_id {
	LPADC_VBATT_5P5,
	LPADC_VIN_CHG,
	LPADC_IBATT,
	LPADC_IC_TEMP,
	LPADC_VBATT_6P0,
	LPADC_VBATT_5P0,
	LPADC_ADC1,
	LPADC_ADC2,
	LPADC_VDD,
	LPADC_VCOIN,
	LPADC_VDD_LDO,
	LPADC_ADC3,
	LPADC_ADC4,
	LPADC_MAX,
};

struct lp8788;

/*
 * lp8788_buck1_dvs
 * @gpio         : gpio pin number for dvs control
 * @vsel         : dvs selector for buck v1 register
 */
struct lp8788_buck1_dvs {
	int gpio;
	enum lp8788_dvs_sel vsel;
};

/*
 * lp8788_buck2_dvs
 * @gpio         : two gpio pin numbers are used for dvs
 * @vsel         : dvs selector for buck v2 register
 */
struct lp8788_buck2_dvs {
	int gpio[LP8788_NUM_BUCK2_DVS];
	enum lp8788_dvs_sel vsel;
};

/*
 * struct lp8788_ldo_enable_pin
 *
 *   Basically, all LDOs are enabled through the I2C commands.
 *   But ALDO 1 ~ 5, 7, DLDO 7, 9, 11 can be enabled by external gpio pins.
 *
 * @gpio         : gpio number which is used for enabling ldos
 * @init_state   : initial gpio state (ex. GPIOF_OUT_INIT_LOW)
 */
struct lp8788_ldo_enable_pin {
	int gpio;
	int init_state;
};

/*
 * struct lp8788_chg_param
 * @addr         : charging control register address (range : 0x11 ~ 0x1C)
 * @val          : charging parameter value
 */
struct lp8788_chg_param {
	u8 addr;
	u8 val;
};

/*
 * struct lp8788_charger_platform_data
 * @adc_vbatt         : adc channel name for battery voltage
 * @adc_batt_temp     : adc channel name for battery temperature
 * @max_vbatt_mv      : used for calculating battery capacity
 * @chg_params        : initial charging parameters
 * @num_chg_params    : numbers of charging parameters
 * @charger_event     : the charger event can be reported to the platform side
 */
struct lp8788_charger_platform_data {
	const char *adc_vbatt;
	const char *adc_batt_temp;
	unsigned int max_vbatt_mv;
	struct lp8788_chg_param *chg_params;
	int num_chg_params;
	void (*charger_event) (struct lp8788 *lp,
				enum lp8788_charger_event event);
};

/*
 * struct lp8788_backlight_platform_data
 * @name                  : backlight driver name. (default: "lcd-backlight")
 * @initial_brightness    : initial value of backlight brightness
 * @bl_mode               : brightness control by pwm or lp8788 register
 * @dim_mode              : dimming mode selection
 * @full_scale            : full scale current setting
 * @rise_time             : brightness ramp up step time
 * @fall_time             : brightness ramp down step time
 * @pwm_pol               : pwm polarity setting when bl_mode is pwm based
 * @period_ns             : platform specific pwm period value. unit is nano.
			    Only valid when bl_mode is LP8788_BL_COMB_PWM_BASED
 */
struct lp8788_backlight_platform_data {
	char *name;
	int initial_brightness;
	enum lp8788_bl_ctrl_mode bl_mode;
	enum lp8788_bl_dim_mode dim_mode;
	enum lp8788_bl_full_scale_current full_scale;
	enum lp8788_bl_ramp_step rise_time;
	enum lp8788_bl_ramp_step fall_time;
	enum pwm_polarity pwm_pol;
	unsigned int period_ns;
};

/*
 * struct lp8788_led_platform_data
 * @name         : led driver name. (default: "keyboard-backlight")
 * @scale        : current scale
 * @num          : current sink number
 * @iout_code    : current output value (Addr 9Ah ~ 9Bh)
 */
struct lp8788_led_platform_data {
	char *name;
	enum lp8788_isink_scale scale;
	enum lp8788_isink_number num;
	int iout_code;
};

/*
 * struct lp8788_vib_platform_data
 * @name         : vibrator driver name
 * @scale        : current scale
 * @num          : current sink number
 * @iout_code    : current output value (Addr 9Ah ~ 9Bh)
 * @pwm_code     : PWM code value (Addr 9Ch ~ 9Eh)
 */
struct lp8788_vib_platform_data {
	char *name;
	enum lp8788_isink_scale scale;
	enum lp8788_isink_number num;
	int iout_code;
	int pwm_code;
};

/*
 * struct lp8788_platform_data
 * @init_func    : used for initializing registers
 *                 before mfd driver is registered
 * @buck_data    : regulator initial data for buck
 * @dldo_data    : regulator initial data for digital ldo
 * @aldo_data    : regulator initial data for analog ldo
 * @buck1_dvs    : gpio configurations for buck1 dvs
 * @buck2_dvs    : gpio configurations for buck2 dvs
 * @ldo_pin      : gpio configurations for enabling LDOs
 * @chg_pdata    : platform data for charger driver
 * @alarm_sel    : rtc alarm selection (1 or 2)
 * @bl_pdata     : configurable data for backlight driver
 * @led_pdata    : configurable data for led driver
 * @vib_pdata    : configurable data for vibrator driver
 * @adc_pdata    : iio map data for adc driver
 */
struct lp8788_platform_data {
	/* general system information */
	int (*init_func) (struct lp8788 *lp);

	/* regulators */
	struct regulator_init_data *buck_data[LP8788_NUM_BUCKS];
	struct regulator_init_data *dldo_data[LP8788_NUM_DLDOS];
	struct regulator_init_data *aldo_data[LP8788_NUM_ALDOS];
	struct lp8788_buck1_dvs *buck1_dvs;
	struct lp8788_buck2_dvs *buck2_dvs;
	struct lp8788_ldo_enable_pin *ldo_pin[EN_LDOS_MAX];

	/* charger */
	struct lp8788_charger_platform_data *chg_pdata;

	/* rtc alarm */
	enum lp8788_alarm_sel alarm_sel;

	/* backlight */
	struct lp8788_backlight_platform_data *bl_pdata;

	/* current sinks */
	struct lp8788_led_platform_data *led_pdata;
	struct lp8788_vib_platform_data *vib_pdata;

	/* adc iio map data */
	struct iio_map *adc_pdata;
};

/*
 * struct lp8788
 * @dev          : parent device pointer
 * @regmap       : used for i2c communcation on accessing registers
 * @irqdm        : interrupt domain for handling nested interrupt
 * @irq          : pin number of IRQ_N
 * @pdata        : lp8788 platform specific data
 */
struct lp8788 {
	struct device *dev;
	struct regmap *regmap;
	struct irq_domain *irqdm;
	int irq;
	struct lp8788_platform_data *pdata;
};

int lp8788_irq_init(struct lp8788 *lp, int chip_irq);
void lp8788_irq_exit(struct lp8788 *lp);
int lp8788_read_byte(struct lp8788 *lp, u8 reg, u8 *data);
int lp8788_read_multi_bytes(struct lp8788 *lp, u8 reg, u8 *data, size_t count);
int lp8788_write_byte(struct lp8788 *lp, u8 reg, u8 data);
int lp8788_update_bits(struct lp8788 *lp, u8 reg, u8 mask, u8 data);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * Copyright 2010 Yong Shen <yong.shen@linaro.org>
 * Copyright 2009-2010 Pengutronix
 * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License version 2 as published by the
 * Free Software Foundation.
 */
#ifndef __LINUX_MFD_MC13783_H
#define __LINUX_MFD_MC13783_H

#include <linux/mfd/mc13xxx.h>

#define	MC13783_REG_SW1A		0
#define	MC13783_REG_SW1B		1
#define	MC13783_REG_SW2A		2
#define	MC13783_REG_SW2B		3
#define	MC13783_REG_SW3		4
#define	MC13783_REG_PLL		5
#define	MC13783_REG_VAUDIO	6
#define	MC13783_REG_VIOHI	7
#define	MC13783_REG_VIOLO	8
#define	MC13783_REG_VDIG	9
#define	MC13783_REG_VGEN	10
#define	MC13783_REG_VRFDIG	11
#define	MC13783_REG_VRFREF	12
#define	MC13783_REG_VRFCP	13
#define	MC13783_REG_VSIM	14
#define	MC13783_REG_VESIM	15
#define	MC13783_REG_VCAM	16
#define	MC13783_REG_VRFBG	17
#define	MC13783_REG_VVIB	18
#define	MC13783_REG_VRF1	19
#define	MC13783_REG_VRF2	20
#define	MC13783_REG_VMMC1	21
#define	MC13783_REG_VMMC2	22
#define	MC13783_REG_GPO1	23
#define	MC13783_REG_GPO2	24
#define	MC13783_REG_GPO3	25
#define	MC13783_REG_GPO4	26
#define	MC13783_REG_V1		27
#define	MC13783_REG_V2		28
#define	MC13783_REG_V3		29
#define	MC13783_REG_V4		30
#define	MC13783_REG_PWGT1SPI	31
#define	MC13783_REG_PWGT2SPI	32

#define MC13783_IRQ_ADCDONE	MC13XXX_IRQ_ADCDONE
#define MC13783_IRQ_ADCBISDONE	MC13XXX_IRQ_ADCBISDONE
#define MC13783_IRQ_TS		MC13XXX_IRQ_TS
#define MC13783_IRQ_WHIGH	3
#define MC13783_IRQ_WLOW	4
#define MC13783_IRQ_CHGDET	MC13XXX_IRQ_CHGDET
#define MC13783_IRQ_CHGOV	7
#define MC13783_IRQ_CHGREV	MC13XXX_IRQ_CHGREV
#define MC13783_IRQ_CHGSHORT	MC13XXX_IRQ_CHGSHORT
#define MC13783_IRQ_CCCV	MC13XXX_IRQ_CCCV
#define MC13783_IRQ_CHGCURR	MC13XXX_IRQ_CHGCURR
#define MC13783_IRQ_BPON	MC13XXX_IRQ_BPON
#define MC13783_IRQ_LOBATL	MC13XXX_IRQ_LOBATL
#define MC13783_IRQ_LOBATH	MC13XXX_IRQ_LOBATH
#define MC13783_IRQ_UDP		15
#define MC13783_IRQ_USB		16
#define MC13783_IRQ_ID		19
#define MC13783_IRQ_SE1		21
#define MC13783_IRQ_CKDET	22
#define MC13783_IRQ_UDM		23
#define MC13783_IRQ_1HZ		MC13XXX_IRQ_1HZ
#define MC13783_IRQ_TODA	MC13XXX_IRQ_TODA
#define MC13783_IRQ_ONOFD1	27
#define MC13783_IRQ_ONOFD2	28
#define MC13783_IRQ_ONOFD3	29
#define MC13783_IRQ_SYSRST	MC13XXX_IRQ_SYSRST
#define MC13783_IRQ_RTCRST	MC13XXX_IRQ_RTCRST
#define MC13783_IRQ_PC		MC13XXX_IRQ_PC
#define MC13783_IRQ_WARM	MC13XXX_IRQ_WARM
#define MC13783_IRQ_MEMHLD	MC13XXX_IRQ_MEMHLD
#define MC13783_IRQ_PWRRDY	35
#define MC13783_IRQ_THWARNL	MC13XXX_IRQ_THWARNL
#define MC13783_IRQ_THWARNH	MC13XXX_IRQ_THWARNH
#define MC13783_IRQ_CLK		MC13XXX_IRQ_CLK
#define MC13783_IRQ_SEMAF	39
#define MC13783_IRQ_MC2B	41
#define MC13783_IRQ_HSDET	42
#define MC13783_IRQ_HSL		43
#define MC13783_IRQ_ALSPTH	44
#define MC13783_IRQ_AHSSHORT	45

#endif /* ifndef __LINUX_MFD_MC13783_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * wm8400 client interface
 *
 * Copyright 2008 Wolfson Microelectronics plc
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef __LINUX_MFD_WM8400_H
#define __LINUX_MFD_WM8400_H

#include <linux/regulator/machine.h>

#define WM8400_LDO1  0
#define WM8400_LDO2  1
#define WM8400_LDO3  2
#define WM8400_LDO4  3
#define WM8400_DCDC1 4
#define WM8400_DCDC2 5

struct wm8400_platform_data {
	int (*platform_init)(struct device *dev);
};

int wm8400_register_regulator(struct device *dev, int reg,
			      struct regulator_init_data *initdata);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * tps65910.h  --  TI TPS6591x
 *
 * Copyright 2010-2011 Texas Instruments Inc.
 *
 * Author: Graeme Gregory <gg@slimlogic.co.uk>
 * Author: Jorge Eduardo Candelaria <jedu@slimlogic.co.uk>
 * Author: Arnaud Deconinck <a-deconinck@ti.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under  the terms of the GNU General  Public License as published by the
 *  Free Software Foundation;  either version 2 of the License, or (at your
 *  option) any later version.
 *
 */

#ifndef __LINUX_MFD_TPS65910_H
#define __LINUX_MFD_TPS65910_H

#include <linux/gpio.h>
#include <linux/regmap.h>

/* TPS chip id list */
#define TPS65910			0
#define TPS65911			1

/* TPS regulator type list */
#define REGULATOR_LDO			0
#define REGULATOR_DCDC			1

/*
 * List of registers for component TPS65910
 *
 */

#define TPS65910_SECONDS				0x0
#define TPS65910_MINUTES				0x1
#define TPS65910_HOURS					0x2
#define TPS65910_DAYS					0x3
#define TPS65910_MONTHS					0x4
#define TPS65910_YEARS					0x5
#define TPS65910_WEEKS					0x6
#define TPS65910_ALARM_SECONDS				0x8
#define TPS65910_ALARM_MINUTES				0x9
#define TPS65910_ALARM_HOURS				0xA
#define TPS65910_ALARM_DAYS				0xB
#define TPS65910_ALARM_MONTHS				0xC
#define TPS65910_ALARM_YEARS				0xD
#define TPS65910_RTC_CTRL				0x10
#define TPS65910_RTC_STATUS				0x11
#define TPS65910_RTC_INTERRUPTS				0x12
#define TPS65910_RTC_COMP_LSB				0x13
#define TPS65910_RTC_COMP_MSB				0x14
#define TPS65910_RTC_RES_PROG				0x15
#define TPS65910_RTC_RESET_STATUS			0x16
#define TPS65910_BCK1					0x17
#define TPS65910_BCK2					0x18
#define TPS65910_BCK3					0x19
#define TPS65910_BCK4					0x1A
#define TPS65910_BCK5					0x1B
#define TPS65910_PUADEN					0x1C
#define TPS65910_REF					0x1D
#define TPS65910_VRTC					0x1E
#define TPS65910_VIO					0x20
#define TPS65910_VDD1					0x21
#define TPS65910_VDD1_OP				0x22
#define TPS65910_VDD1_SR				0x23
#define TPS65910_VDD2					0x24
#define TPS65910_VDD2_OP				0x25
#define TPS65910_VDD2_SR				0x26
#define TPS65910_VDD3					0x27
#define TPS65910_VDIG1					0x30
#define TPS65910_VDIG2					0x31
#define TPS65910_VAUX1					0x32
#define TPS65910_VAUX2					0x33
#define TPS65910_VAUX33					0x34
#define TPS65910_VMMC					0x35
#define TPS65910_VPLL					0x36
#define TPS65910_VDAC					0x37
#define TPS65910_THERM					0x38
#define TPS65910_BBCH					0x39
#define TPS65910_DCDCCTRL				0x3E
#define TPS65910_DEVCTRL				0x3F
#define TPS65910_DEVCTRL2				0x40
#define TPS65910_SLEEP_KEEP_LDO_ON			0x41
#define TPS65910_SLEEP_KEEP_RES_ON			0x42
#define TPS65910_SLEEP_SET_LDO_OFF			0x43
#define TPS65910_SLEEP_SET_RES_OFF			0x44
#define TPS65910_EN1_LDO_ASS				0x45
#define TPS65910_EN1_SMPS_ASS				0x46
#define TPS65910_EN2_LDO_ASS				0x47
#define TPS65910_EN2_SMPS_ASS				0x48
#define TPS65910_EN3_LDO_ASS				0x49
#define TPS65910_SPARE					0x4A
#define TPS65910_INT_STS				0x50
#define TPS65910_INT_MSK				0x51
#define TPS65910_INT_STS2				0x52
#define TPS65910_INT_MSK2				0x53
#define TPS65910_INT_STS3				0x54
#define TPS65910_INT_MSK3				0x55
#define TPS65910_GPIO0					0x60
#define TPS65910_GPIO1					0x61
#define TPS65910_GPIO2					0x62
#define TPS65910_GPIO3					0x63
#define TPS65910_GPIO4					0x64
#define TPS65910_GPIO5					0x65
#define TPS65910_GPIO6					0x66
#define TPS65910_GPIO7					0x67
#define TPS65910_GPIO8					0x68
#define TPS65910_JTAGVERNUM				0x80
#define TPS65910_MAX_REGISTER				0x80

/*
 * List of registers specific to TPS65911
 */
#define TPS65911_VDDCTRL				0x27
#define TPS65911_VDDCTRL_OP				0x28
#define TPS65911_VDDCTRL_SR				0x29
#define TPS65911_LDO1					0x30
#define TPS65911_LDO2					0x31
#define TPS65911_LDO5					0x32
#define TPS65911_LDO8					0x33
#define TPS65911_LDO7					0x34
#define TPS65911_LDO6					0x35
#define TPS65911_LDO4					0x36
#define TPS65911_LDO3					0x37
#define TPS65911_VMBCH					0x6A
#define TPS65911_VMBCH2					0x6B

/*
 * List of register bitfields for component TPS65910
 *
 */

/* RTC_CTRL_REG bitfields */
#define TPS65910_RTC_CTRL_STOP_RTC			0x01 /*0=stop, 1=run */
#define TPS65910_RTC_CTRL_GET_TIME			0x40

/* RTC_STATUS_REG bitfields */
#define TPS65910_RTC_STATUS_ALARM               0x40

/* RTC_INTERRUPTS_REG bitfields */
#define TPS65910_RTC_INTERRUPTS_EVERY           0x03
#define TPS65910_RTC_INTERRUPTS_IT_ALARM        0x08

/*Register BCK1  (0x80) register.RegisterDescription */
#define BCK1_BCKUP_MASK					0xFF
#define BCK1_BCKUP_SHIFT				0


/*Register BCK2  (0x80) register.RegisterDescription */
#define BCK2_BCKUP_MASK					0xFF
#define BCK2_BCKUP_SHIFT				0


/*Register BCK3  (0x80) register.RegisterDescription */
#define BCK3_BCKUP_MASK					0xFF
#define BCK3_BCKUP_SHIFT				0


/*Register BCK4  (0x80) register.RegisterDescription */
#define BCK4_BCKUP_MASK					0xFF
#define BCK4_BCKUP_SHIFT				0


/*Register BCK5  (0x80) register.RegisterDescription */
#define BCK5_BCKUP_MASK					0xFF
#define BCK5_BCKUP_SHIFT				0


/*Register PUADEN  (0x80) register.RegisterDescription */
#define PUADEN_EN3P_MASK				0x80
#define PUADEN_EN3P_SHIFT				7
#define PUADEN_I2CCTLP_MASK				0x40
#define PUADEN_I2CCTLP_SHIFT				6
#define PUADEN_I2CSRP_MASK				0x20
#define PUADEN_I2CSRP_SHIFT				5
#define PUADEN_PWRONP_MASK				0x10
#define PUADEN_PWRONP_SHIFT				4
#define PUADEN_SLEEPP_MASK				0x08
#define PUADEN_SLEEPP_SHIFT				3
#define PUADEN_PWRHOLDP_MASK				0x04
#define PUADEN_PWRHOLDP_SHIFT				2
#define PUADEN_BOOT1P_MASK				0x02
#define PUADEN_BOOT1P_SHIFT				1
#define PUADEN_BOOT0P_MASK				0x01
#define PUADEN_BOOT0P_SHIFT				0


/*Register REF	(0x80) register.RegisterDescription */
#define REF_VMBCH_SEL_MASK				0x0C
#define REF_VMBCH_SEL_SHIFT				2
#define REF_ST_MASK					0x03
#define REF_ST_SHIFT					0


/*Register VRTC  (0x80) register.RegisterDescription */
#define VRTC_VRTC_OFFMASK_MASK				0x08
#define VRTC_VRTC_OFFMASK_SHIFT				3
#define VRTC_ST_MASK					0x03
#define VRTC_ST_SHIFT					0


/*Register VIO	(0x80) register.RegisterDescription */
#define VIO_ILMAX_MASK					0xC0
#define VIO_ILMAX_SHIFT					6
#define VIO_SEL_MASK					0x0C
#define VIO_SEL_SHIFT					2
#define VIO_ST_MASK					0x03
#define VIO_ST_SHIFT					0


/*Register VDD1  (0x80) register.RegisterDescription */
#define VDD1_VGAIN_SEL_MASK				0xC0
#define VDD1_VGAIN_SEL_SHIFT				6
#define VDD1_ILMAX_MASK					0x20
#define VDD1_ILMAX_SHIFT				5
#define VDD1_TSTEP_MASK					0x1C
#define VDD1_TSTEP_SHIFT				2
#define VDD1_ST_MASK					0x03
#define VDD1_ST_SHIFT					0


/*Register VDD1_OP  (0x80) register.RegisterDescription */
#define VDD1_OP_CMD_MASK				0x80
#define VDD1_OP_CMD_SHIFT				7
#define VDD1_OP_SEL_MASK				0x7F
#define VDD1_OP_SEL_SHIFT				0


/*Register VDD1_SR  (0x80) register.RegisterDescription */
#define VDD1_SR_SEL_MASK				0x7F
#define VDD1_SR_SEL_SHIFT				0


/*Register VDD2  (0x80) register.RegisterDescription */
#define VDD2_VGAIN_SEL_MASK				0xC0
#define VDD2_VGAIN_SEL_SHIFT				6
#define VDD2_ILMAX_MASK					0x20
#define VDD2_ILMAX_SHIFT				5
#define VDD2_TSTEP_MASK					0x1C
#define VDD2_TSTEP_SHIFT				2
#define VDD2_ST_MASK					0x03
#define VDD2_ST_SHIFT					0


/*Register VDD2_OP  (0x80) register.RegisterDescription */
#define VDD2_OP_CMD_MASK				0x80
#define VDD2_OP_CMD_SHIFT				7
#define VDD2_OP_SEL_MASK				0x7F
#define VDD2_OP_SEL_SHIFT				0

/*Register VDD2_SR  (0x80) register.RegisterDescription */
#define VDD2_SR_SEL_MASK				0x7F
#define VDD2_SR_SEL_SHIFT				0


/*Registers VDD1, VDD2 voltage values definitions */
#define VDD1_2_NUM_VOLT_FINE				73
#define VDD1_2_NUM_VOLT_COARSE				3
#define VDD1_2_MIN_VOLT					6000
#define VDD1_2_OFFSET					125


/*Register VDD3  (0x80) register.RegisterDescription */
#define VDD3_CKINEN_MASK				0x04
#define VDD3_CKINEN_SHIFT				2
#define VDD3_ST_MASK					0x03
#define VDD3_ST_SHIFT					0
#define VDDCTRL_MIN_VOLT				6000
#define VDDCTRL_OFFSET					125

/*Registers VDIG (0x80) to VDAC register.RegisterDescription */
#define LDO_SEL_MASK					0x0C
#define LDO_SEL_SHIFT					2
#define LDO_ST_MASK					0x03
#define LDO_ST_SHIFT					0
#define LDO_ST_ON_BIT					0x01
#define LDO_ST_MODE_BIT					0x02	


/* Registers LDO1 to LDO8 in tps65910 */
#define LDO1_SEL_MASK					0xFC
#define LDO3_SEL_MASK					0x7C
#define LDO_MIN_VOLT					1000
#define LDO_MAX_VOLT					3300


/*Register VDIG1  (0x80) register.RegisterDescription */
#define VDIG1_SEL_MASK					0x0C
#define VDIG1_SEL_SHIFT					2
#define VDIG1_ST_MASK					0x03
#define VDIG1_ST_SHIFT					0


/*Register VDIG2  (0x80) register.RegisterDescription */
#define VDIG2_SEL_MASK					0x0C
#define VDIG2_SEL_SHIFT					2
#define VDIG2_ST_MASK					0x03
#define VDIG2_ST_SHIFT					0


/*Register VAUX1  (0x80) register.RegisterDescription */
#define VAUX1_SEL_MASK					0x0C
#define VAUX1_SEL_SHIFT					2
#define VAUX1_ST_MASK					0x03
#define VAUX1_ST_SHIFT					0


/*Register VAUX2  (0x80) register.RegisterDescription */
#define VAUX2_SEL_MASK					0x0C
#define VAUX2_SEL_SHIFT					2
#define VAUX2_ST_MASK					0x03
#define VAUX2_ST_SHIFT					0


/*Register VAUX33  (0x80) register.RegisterDescription */
#define VAUX33_SEL_MASK					0x0C
#define VAUX33_SEL_SHIFT				2
#define VAUX33_ST_MASK					0x03
#define VAUX33_ST_SHIFT					0


/*Register VMMC  (0x80) register.RegisterDescription */
#define VMMC_SEL_MASK					0x0C
#define VMMC_SEL_SHIFT					2
#define VMMC_ST_MASK					0x03
#define VMMC_ST_SHIFT					0


/*Register VPLL  (0x80) register.RegisterDescription */
#define VPLL_SEL_MASK					0x0C
#define VPLL_SEL_SHIFT					2
#define VPLL_ST_MASK					0x03
#define VPLL_ST_SHIFT					0


/*Register VDAC  (0x80) register.RegisterDescription */
#define VDAC_SEL_MASK					0x0C
#define VDAC_SEL_SHIFT					2
#define VDAC_ST_MASK					0x03
#define VDAC_ST_SHIFT					0


/*Register THERM  (0x80) register.RegisterDescription */
#define THERM_THERM_HD_MASK				0x20
#define THERM_THERM_HD_SHIFT				5
#define THERM_THERM_TS_MASK				0x10
#define THERM_THERM_TS_SHIFT				4
#define THERM_THERM_HDSEL_MASK				0x0C
#define THERM_THERM_HDSEL_SHIFT				2
#define THERM_RSVD1_MASK				0x02
#define THERM_RSVD1_SHIFT				1
#define THERM_THERM_STATE_MASK				0x01
#define THERM_THERM_STATE_SHIFT				0


/*Register BBCH  (0x80) register.RegisterDescription */
#define BBCH_BBSEL_MASK					0x06
#define BBCH_BBSEL_SHIFT				1


/*Register DCDCCTRL  (0x80) register.RegisterDescription */
#define DCDCCTRL_VDD2_PSKIP_MASK			0x20
#define DCDCCTRL_VDD2_PSKIP_SHIFT			5
#define DCDCCTRL_VDD1_PSKIP_MASK			0x10
#define DCDCCTRL_VDD1_PSKIP_SHIFT			4
#define DCDCCTRL_VIO_PSKIP_MASK				0x08
#define DCDCCTRL_VIO_PSKIP_SHIFT			3
#define DCDCCTRL_DCDCCKEXT_MASK				0x04
#define DCDCCTRL_DCDCCKEXT_SHIFT			2
#define DCDCCTRL_DCDCCKSYNC_MASK			0x03
#define DCDCCTRL_DCDCCKSYNC_SHIFT			0


/*Register DEVCTRL  (0x80) register.RegisterDescription */
#define DEVCTRL_PWR_OFF_MASK				0x80
#define DEVCTRL_PWR_OFF_SHIFT				7
#define DEVCTRL_RTC_PWDN_MASK				0x40
#define DEVCTRL_RTC_PWDN_SHIFT				6
#define DEVCTRL_CK32K_CTRL_MASK				0x20
#define DEVCTRL_CK32K_CTRL_SHIFT			5
#define DEVCTRL_SR_CTL_I2C_SEL_MASK			0x10
#define DEVCTRL_SR_CTL_I2C_SEL_SHIFT			4
#define DEVCTRL_DEV_OFF_RST_MASK			0x08
#define DEVCTRL_DEV_OFF_RST_SHIFT			3
#define DEVCTRL_DEV_ON_MASK				0x04
#define DEVCTRL_DEV_ON_SHIFT				2
#define DEVCTRL_DEV_SLP_MASK				0x02
#define DEVCTRL_DEV_SLP_SHIFT				1
#define DEVCTRL_DEV_OFF_MASK				0x01
#define DEVCTRL_DEV_OFF_SHIFT				0


/*Register DEVCTRL2  (0x80) register.RegisterDescription */
#define DEVCTRL2_TSLOT_LENGTH_MASK			0x30
#define DEVCTRL2_TSLOT_LENGTH_SHIFT			4
#define DEVCTRL2_SLEEPSIG_POL_MASK			0x08
#define DEVCTRL2_SLEEPSIG_POL_SHIFT			3
#define DEVCTRL2_PWON_LP_OFF_MASK			0x04
#define DEVCTRL2_PWON_LP_OFF_SHIFT			2
#define DEVCTRL2_PWON_LP_RST_MASK			0x02
#define DEVCTRL2_PWON_LP_RST_SHIFT			1
#define DEVCTRL2_IT_POL_MASK				0x01
#define DEVCTRL2_IT_POL_SHIFT				0


/*Register SLEEP_KEEP_LDO_ON  (0x80) register.RegisterDescription */
#define SLEEP_KEEP_LDO_ON_VDAC_KEEPON_MASK		0x80
#define SLEEP_KEEP_LDO_ON_VDAC_KEEPON_SHIFT		7
#define SLEEP_KEEP_LDO_ON_VPLL_KEEPON_MASK		0x40
#define SLEEP_KEEP_LDO_ON_VPLL_KEEPON_SHIFT		6
#define SLEEP_KEEP_LDO_ON_VAUX33_KEEPON_MASK		0x20
#define SLEEP_KEEP_LDO_ON_VAUX33_KEEPON_SHIFT		5
#define SLEEP_KEEP_LDO_ON_VAUX2_KEEPON_MASK		0x10
#define SLEEP_KEEP_LDO_ON_VAUX2_KEEPON_SHIFT		4
#define SLEEP_KEEP_LDO_ON_VAUX1_KEEPON_MASK		0x08
#define SLEEP_KEEP_LDO_ON_VAUX1_KEEPON_SHIFT		3
#define SLEEP_KEEP_LDO_ON_VDIG2_KEEPON_MASK		0x04
#define SLEEP_KEEP_LDO_ON_VDIG2_KEEPON_SHIFT		2
#define SLEEP_KEEP_LDO_ON_VDIG1_KEEPON_MASK		0x02
#define SLEEP_KEEP_LDO_ON_VDIG1_KEEPON_SHIFT		1
#define SLEEP_KEEP_LDO_ON_VMMC_KEEPON_MASK		0x01
#define SLEEP_KEEP_LDO_ON_VMMC_KEEPON_SHIFT		0


/*Register SLEEP_KEEP_RES_ON  (0x80) register.RegisterDescription */
#define SLEEP_KEEP_RES_ON_THERM_KEEPON_MASK		0x80
#define SLEEP_KEEP_RES_ON_THERM_KEEPON_SHIFT		7
#define SLEEP_KEEP_RES_ON_CLKOUT32K_KEEPON_MASK		0x40
#define SLEEP_KEEP_RES_ON_CLKOUT32K_KEEPON_SHIFT	6
#define SLEEP_KEEP_RES_ON_VRTC_KEEPON_MASK		0x20
#define SLEEP_KEEP_RES_ON_VRTC_KEEPON_SHIFT		5
#define SLEEP_KEEP_RES_ON_I2CHS_KEEPON_MASK		0x10
#define SLEEP_KEEP_RES_ON_I2CHS_KEEPON_SHIFT		4
#define SLEEP_KEEP_RES_ON_VDD3_KEEPON_MASK		0x08
#define SLEEP_KEEP_RES_ON_VDD3_KEEPON_SHIFT		3
#define SLEEP_KEEP_RES_ON_VDD2_KEEPON_MASK		0x04
#define SLEEP_KEEP_RES_ON_VDD2_KEEPON_SHIFT		2
#define SLEEP_KEEP_RES_ON_VDD1_KEEPON_MASK		0x02
#define SLEEP_KEEP_RES_ON_VDD1_KEEPON_SHIFT		1
#define SLEEP_KEEP_RES_ON_VIO_KEEPON_MASK		0x01
#define SLEEP_KEEP_RES_ON_VIO_KEEPON_SHIFT		0


/*Register SLEEP_SET_LDO_OFF  (0x80) register.RegisterDescription */
#define SLEEP_SET_LDO_OFF_VDAC_SETOFF_MASK		0x80
#define SLEEP_SET_LDO_OFF_VDAC_SETOFF_SHIFT		7
#define SLEEP_SET_LDO_OFF_VPLL_SETOFF_MASK		0x40
#define SLEEP_SET_LDO_OFF_VPLL_SETOFF_SHIFT		6
#define SLEEP_SET_LDO_OFF_VAUX33_SETOFF_MASK		0x20
#define SLEEP_SET_LDO_OFF_VAUX33_SETOFF_SHIFT		5
#define SLEEP_SET_LDO_OFF_VAUX2_SETOFF_MASK		0x10
#define SLEEP_SET_LDO_OFF_VAUX2_SETOFF_SHIFT		4
#define SLEEP_SET_LDO_OFF_VAUX1_SETOFF_MASK		0x08
#define SLEEP_SET_LDO_OFF_VAUX1_SETOFF_SHIFT		3
#define SLEEP_SET_LDO_OFF_VDIG2_SETOFF_MASK		0x04
#define SLEEP_SET_LDO_OFF_VDIG2_SETOFF_SHIFT		2
#define SLEEP_SET_LDO_OFF_VDIG1_SETOFF_MASK		0x02
#define SLEEP_SET_LDO_OFF_VDIG1_SETOFF_SHIFT		1
#define SLEEP_SET_LDO_OFF_VMMC_SETOFF_MASK		0x01
#define SLEEP_SET_LDO_OFF_VMMC_SETOFF_SHIFT		0


/*Register SLEEP_SET_RES_OFF  (0x80) register.RegisterDescription */
#define SLEEP_SET_RES_OFF_DEFAULT_VOLT_MASK		0x80
#define SLEEP_SET_RES_OFF_DEFAULT_VOLT_SHIFT		7
#define SLEEP_SET_RES_OFF_RSVD_MASK			0x60
#define SLEEP_SET_RES_OFF_RSVD_SHIFT			5
#define SLEEP_SET_RES_OFF_SPARE_SETOFF_MASK		0x10
#define SLEEP_SET_RES_OFF_SPARE_SETOFF_SHIFT		4
#define SLEEP_SET_RES_OFF_VDD3_SETOFF_MASK		0x08
#define SLEEP_SET_RES_OFF_VDD3_SETOFF_SHIFT		3
#define SLEEP_SET_RES_OFF_VDD2_SETOFF_MASK		0x04
#define SLEEP_SET_RES_OFF_VDD2_SETOFF_SHIFT		2
#define SLEEP_SET_RES_OFF_VDD1_SETOFF_MASK		0x02
#define SLEEP_SET_RES_OFF_VDD1_SETOFF_SHIFT		1
#define SLEEP_SET_RES_OFF_VIO_SETOFF_MASK		0x01
#define SLEEP_SET_RES_OFF_VIO_SETOFF_SHIFT		0


/*Register EN1_LDO_ASS	(0x80) register.RegisterDescription */
#define EN1_LDO_ASS_VDAC_EN1_MASK			0x80
#define EN1_LDO_ASS_VDAC_EN1_SHIFT			7
#define EN1_LDO_ASS_VPLL_EN1_MASK			0x40
#define EN1_LDO_ASS_VPLL_EN1_SHIFT			6
#define EN1_LDO_ASS_VAUX33_EN1_MASK			0x20
#define EN1_LDO_ASS_VAUX33_EN1_SHIFT			5
#define EN1_LDO_ASS_VAUX2_EN1_MASK			0x10
#define EN1_LDO_ASS_VAUX2_EN1_SHIFT			4
#define EN1_LDO_ASS_VAUX1_EN1_MASK			0x08
#define EN1_LDO_ASS_VAUX1_EN1_SHIFT			3
#define EN1_LDO_ASS_VDIG2_EN1_MASK			0x04
#define EN1_LDO_ASS_VDIG2_EN1_SHIFT			2
#define EN1_LDO_ASS_VDIG1_EN1_MASK			0x02
#define EN1_LDO_ASS_VDIG1_EN1_SHIFT			1
#define EN1_LDO_ASS_VMMC_EN1_MASK			0x01
#define EN1_LDO_ASS_VMMC_EN1_SHIFT			0


/*Register EN1_SMPS_ASS  (0x80) register.RegisterDescription */
#define EN1_SMPS_ASS_RSVD_MASK				0xE0
#define EN1_SMPS_ASS_RSVD_SHIFT				5
#define EN1_SMPS_ASS_SPARE_EN1_MASK			0x10
#define EN1_SMPS_ASS_SPARE_EN1_SHIFT			4
#define EN1_SMPS_ASS_VDD3_EN1_MASK			0x08
#define EN1_SMPS_ASS_VDD3_EN1_SHIFT			3
#define EN1_SMPS_ASS_VDD2_EN1_MASK			0x04
#define EN1_SMPS_ASS_VDD2_EN1_SHIFT			2
#define EN1_SMPS_ASS_VDD1_EN1_MASK			0x02
#define EN1_SMPS_ASS_VDD1_EN1_SHIFT			1
#define EN1_SMPS_ASS_VIO_EN1_MASK			0x01
#define EN1_SMPS_ASS_VIO_EN1_SHIFT			0


/*Register EN2_LDO_ASS	(0x80) register.RegisterDescription */
#define EN2_LDO_ASS_VDAC_EN2_MASK			0x80
#define EN2_LDO_ASS_VDAC_EN2_SHIFT			7
#define EN2_LDO_ASS_VPLL_EN2_MASK			0x40
#define EN2_LDO_ASS_VPLL_EN2_SHIFT			6
#define EN2_LDO_ASS_VAUX33_EN2_MASK			0x20
#define EN2_LDO_ASS_VAUX33_EN2_SHIFT			5
#define EN2_LDO_ASS_VAUX2_EN2_MASK			0x10
#define EN2_LDO_ASS_VAUX2_EN2_SHIFT			4
#define EN2_LDO_ASS_VAUX1_EN2_MASK			0x08
#define EN2_LDO_ASS_VAUX1_EN2_SHIFT			3
#define EN2_LDO_ASS_VDIG2_EN2_MASK			0x04
#define EN2_LDO_ASS_VDIG2_EN2_SHIFT			2
#define EN2_LDO_ASS_VDIG1_EN2_MASK			0x02
#define EN2_LDO_ASS_VDIG1_EN2_SHIFT			1
#define EN2_LDO_ASS_VMMC_EN2_MASK			0x01
#define EN2_LDO_ASS_VMMC_EN2_SHIFT			0


/*Register EN2_SMPS_ASS  (0x80) register.RegisterDescription */
#define EN2_SMPS_ASS_RSVD_MASK				0xE0
#define EN2_SMPS_ASS_RSVD_SHIFT				5
#define EN2_SMPS_ASS_SPARE_EN2_MASK			0x10
#define EN2_SMPS_ASS_SPARE_EN2_SHIFT			4
#define EN2_SMPS_ASS_VDD3_EN2_MASK			0x08
#define EN2_SMPS_ASS_VDD3_EN2_SHIFT			3
#define EN2_SMPS_ASS_VDD2_EN2_MASK			0x04
#define EN2_SMPS_ASS_VDD2_EN2_SHIFT			2
#define EN2_SMPS_ASS_VDD1_EN2_MASK			0x02
#define EN2_SMPS_ASS_VDD1_EN2_SHIFT			1
#define EN2_SMPS_ASS_VIO_EN2_MASK			0x01
#define EN2_SMPS_ASS_VIO_EN2_SHIFT			0


/*Register EN3_LDO_ASS	(0x80) register.RegisterDescription */
#define EN3_LDO_ASS_VDAC_EN3_MASK			0x80
#define EN3_LDO_ASS_VDAC_EN3_SHIFT			7
#define EN3_LDO_ASS_VPLL_EN3_MASK			0x40
#define EN3_LDO_ASS_VPLL_EN3_SHIFT			6
#define EN3_LDO_ASS_VAUX33_EN3_MASK			0x20
#define EN3_LDO_ASS_VAUX33_EN3_SHIFT			5
#define EN3_LDO_ASS_VAUX2_EN3_MASK			0x10
#define EN3_LDO_ASS_VAUX2_EN3_SHIFT			4
#define EN3_LDO_ASS_VAUX1_EN3_MASK			0x08
#define EN3_LDO_ASS_VAUX1_EN3_SHIFT			3
#define EN3_LDO_ASS_VDIG2_EN3_MASK			0x04
#define EN3_LDO_ASS_VDIG2_EN3_SHIFT			2
#define EN3_LDO_ASS_VDIG1_EN3_MASK			0x02
#define EN3_LDO_ASS_VDIG1_EN3_SHIFT			1
#define EN3_LDO_ASS_VMMC_EN3_MASK			0x01
#define EN3_LDO_ASS_VMMC_EN3_SHIFT			0


/*Register SPARE  (0x80) register.RegisterDescription */
#define SPARE_SPARE_MASK				0xFF
#define SPARE_SPARE_SHIFT				0

#define TPS65910_INT_STS_RTC_PERIOD_IT_MASK			0x80
#define TPS65910_INT_STS_RTC_PERIOD_IT_SHIFT			7
#define TPS65910_INT_STS_RTC_ALARM_IT_MASK			0x40
#define TPS65910_INT_STS_RTC_ALARM_IT_SHIFT			6
#define TPS65910_INT_STS_HOTDIE_IT_MASK				0x20
#define TPS65910_INT_STS_HOTDIE_IT_SHIFT			5
#define TPS65910_INT_STS_PWRHOLD_F_IT_MASK			0x10
#define TPS65910_INT_STS_PWRHOLD_F_IT_SHIFT			4
#define TPS65910_INT_STS_PWRON_LP_IT_MASK			0x08
#define TPS65910_INT_STS_PWRON_LP_IT_SHIFT			3
#define TPS65910_INT_STS_PWRON_IT_MASK				0x04
#define TPS65910_INT_STS_PWRON_IT_SHIFT				2
#define TPS65910_INT_STS_VMBHI_IT_MASK				0x02
#define TPS65910_INT_STS_VMBHI_IT_SHIFT				1
#define TPS65910_INT_STS_VMBDCH_IT_MASK				0x01
#define TPS65910_INT_STS_VMBDCH_IT_SHIFT			0

#define TPS65910_INT_MSK_RTC_PERIOD_IT_MSK_MASK			0x80
#define TPS65910_INT_MSK_RTC_PERIOD_IT_MSK_SHIFT		7
#define TPS65910_INT_MSK_RTC_ALARM_IT_MSK_MASK			0x40
#define TPS65910_INT_MSK_RTC_ALARM_IT_MSK_SHIFT			6
#define TPS65910_INT_MSK_HOTDIE_IT_MSK_MASK			0x20
#define TPS65910_INT_MSK_HOTDIE_IT_MSK_SHIFT			5
#define TPS65910_INT_MSK_PWRHOLD_IT_MSK_MASK			0x10
#define TPS65910_INT_MSK_PWRHOLD_IT_MSK_SHIFT			4
#define TPS65910_INT_MSK_PWRON_LP_IT_MSK_MASK			0x08
#define TPS65910_INT_MSK_PWRON_LP_IT_MSK_SHIFT			3
#define TPS65910_INT_MSK_PWRON_IT_MSK_MASK			0x04
#define TPS65910_INT_MSK_PWRON_IT_MSK_SHIFT			2
#define TPS65910_INT_MSK_VMBHI_IT_MSK_MASK			0x02
#define TPS65910_INT_MSK_VMBHI_IT_MSK_SHIFT			1
#define TPS65910_INT_MSK_VMBDCH_IT_MSK_MASK			0x01
#define TPS65910_INT_MSK_VMBDCH_IT_MSK_SHIFT			0

#define TPS65910_INT_STS2_GPIO0_F_IT_SHIFT			2
#define TPS65910_INT_STS2_GPIO0_F_IT_MASK			0x02
#define TPS65910_INT_STS2_GPIO0_R_IT_SHIFT			1
#define TPS65910_INT_STS2_GPIO0_R_IT_MASK			0x01

#define TPS65910_INT_MSK2_GPIO0_F_IT_MSK_SHIFT			2
#define TPS65910_INT_MSK2_GPIO0_F_IT_MSK_MASK			0x02
#define TPS65910_INT_MSK2_GPIO0_R_IT_MSK_SHIFT			1
#define TPS65910_INT_MSK2_GPIO0_R_IT_MSK_MASK			0x01

/*Register INT_STS  (0x80) register.RegisterDescription */
#define INT_STS_RTC_PERIOD_IT_MASK			0x80
#define INT_STS_RTC_PERIOD_IT_SHIFT			7
#define INT_STS_RTC_ALARM_IT_MASK			0x40
#define INT_STS_RTC_ALARM_IT_SHIFT			6
#define INT_STS_HOTDIE_IT_MASK				0x20
#define INT_STS_HOTDIE_IT_SHIFT				5
#define INT_STS_PWRHOLD_R_IT_MASK			0x10
#define INT_STS_PWRHOLD_R_IT_SHIFT			4
#define INT_STS_PWRON_LP_IT_MASK			0x08
#define INT_STS_PWRON_LP_IT_SHIFT			3
#define INT_STS_PWRON_IT_MASK				0x04
#define INT_STS_PWRON_IT_SHIFT				2
#define INT_STS_VMBHI_IT_MASK				0x02
#define INT_STS_VMBHI_IT_SHIFT				1
#define INT_STS_PWRHOLD_F_IT_MASK			0x01
#define INT_STS_PWRHOLD_F_IT_SHIFT			0


/*Register INT_MSK  (0x80) register.RegisterDescription */
#define INT_MSK_RTC_PERIOD_IT_MSK_MASK			0x80
#define INT_MSK_RTC_PERIOD_IT_MSK_SHIFT			7
#define INT_MSK_RTC_ALARM_IT_MSK_MASK			0x40
#define INT_MSK_RTC_ALARM_IT_MSK_SHIFT			6
#define INT_MSK_HOTDIE_IT_MSK_MASK			0x20
#define INT_MSK_HOTDIE_IT_MSK_SHIFT			5
#define INT_MSK_PWRHOLD_R_IT_MSK_MASK			0x10
#define INT_MSK_PWRHOLD_R_IT_MSK_SHIFT			4
#define INT_MSK_PWRON_LP_IT_MSK_MASK			0x08
#define INT_MSK_PWRON_LP_IT_MSK_SHIFT			3
#define INT_MSK_PWRON_IT_MSK_MASK			0x04
#define INT_MSK_PWRON_IT_MSK_SHIFT			2
#define INT_MSK_VMBHI_IT_MSK_MASK			0x02
#define INT_MSK_VMBHI_IT_MSK_SHIFT			1
#define INT_MSK_PWRHOLD_F_IT_MSK_MASK			0x01
#define INT_MSK_PWRHOLD_F_IT_MSK_SHIFT			0


/*Register INT_STS2  (0x80) register.RegisterDescription */
#define INT_STS2_GPIO3_F_IT_MASK			0x80
#define INT_STS2_GPIO3_F_IT_SHIFT			7
#define INT_STS2_GPIO3_R_IT_MASK			0x40
#define INT_STS2_GPIO3_R_IT_SHIFT			6
#define INT_STS2_GPIO2_F_IT_MASK			0x20
#define INT_STS2_GPIO2_F_IT_SHIFT			5
#define INT_STS2_GPIO2_R_IT_MASK			0x10
#define INT_STS2_GPIO2_R_IT_SHIFT			4
#define INT_STS2_GPIO1_F_IT_MASK			0x08
#define INT_STS2_GPIO1_F_IT_SHIFT			3
#define INT_STS2_GPIO1_R_IT_MASK			0x04
#define INT_STS2_GPIO1_R_IT_SHIFT			2
#define INT_STS2_GPIO0_F_IT_MASK			0x02
#define INT_STS2_GPIO0_F_IT_SHIFT			1
#define INT_STS2_GPIO0_R_IT_MASK			0x01
#define INT_STS2_GPIO0_R_IT_SHIFT			0


/*Register INT_MSK2  (0x80) register.RegisterDescription */
#define INT_MSK2_GPIO3_F_IT_MSK_MASK			0x80
#define INT_MSK2_GPIO3_F_IT_MSK_SHIFT			7
#define INT_MSK2_GPIO3_R_IT_MSK_MASK			0x40
#define INT_MSK2_GPIO3_R_IT_MSK_SHIFT			6
#define INT_MSK2_GPIO2_F_IT_MSK_MASK			0x20
#define INT_MSK2_GPIO2_F_IT_MSK_SHIFT			5
#define INT_MSK2_GPIO2_R_IT_MSK_MASK			0x10
#define INT_MSK2_GPIO2_R_IT_MSK_SHIFT			4
#define INT_MSK2_GPIO1_F_IT_MSK_MASK			0x08
#define INT_MSK2_GPIO1_F_IT_MSK_SHIFT			3
#define INT_MSK2_GPIO1_R_IT_MSK_MASK			0x04
#define INT_MSK2_GPIO1_R_IT_MSK_SHIFT			2
#define INT_MSK2_GPIO0_F_IT_MSK_MASK			0x02
#define INT_MSK2_GPIO0_F_IT_MSK_SHIFT			1
#define INT_MSK2_GPIO0_R_IT_MSK_MASK			0x01
#define INT_MSK2_GPIO0_R_IT_MSK_SHIFT			0


/*Register INT_STS3  (0x80) register.RegisterDescription */
#define INT_STS3_PWRDN_IT_MASK				0x80
#define INT_STS3_PWRDN_IT_SHIFT				7
#define INT_STS3_VMBCH2_L_IT_MASK			0x40
#define INT_STS3_VMBCH2_L_IT_SHIFT			6
#define INT_STS3_VMBCH2_H_IT_MASK			0x20
#define INT_STS3_VMBCH2_H_IT_SHIFT			5
#define INT_STS3_WTCHDG_IT_MASK				0x10
#define INT_STS3_WTCHDG_IT_SHIFT			4
#define INT_STS3_GPIO5_F_IT_MASK			0x08
#define INT_STS3_GPIO5_F_IT_SHIFT			3
#define INT_STS3_GPIO5_R_IT_MASK			0x04
#define INT_STS3_GPIO5_R_IT_SHIFT			2
#define INT_STS3_GPIO4_F_IT_MASK			0x02
#define INT_STS3_GPIO4_F_IT_SHIFT			1
#define INT_STS3_GPIO4_R_IT_MASK			0x01
#define INT_STS3_GPIO4_R_IT_SHIFT			0


/*Register INT_MSK3  (0x80) register.RegisterDescription */
#define INT_MSK3_PWRDN_IT_MSK_MASK			0x80
#define INT_MSK3_PWRDN_IT_MSK_SHIFT			7
#define INT_MSK3_VMBCH2_L_IT_MSK_MASK			0x40
#define INT_MSK3_VMBCH2_L_IT_MSK_SHIFT			6
#define INT_MSK3_VMBCH2_H_IT_MSK_MASK			0x20
#define INT_MSK3_VMBCH2_H_IT_MSK_SHIFT			5
#define INT_MSK3_WTCHDG_IT_MSK_MASK			0x10
#define INT_MSK3_WTCHDG_IT_MSK_SHIFT			4
#define INT_MSK3_GPIO5_F_IT_MSK_MASK			0x08
#define INT_MSK3_GPIO5_F_IT_MSK_SHIFT			3
#define INT_MSK3_GPIO5_R_IT_MSK_MASK			0x04
#define INT_MSK3_GPIO5_R_IT_MSK_SHIFT			2
#define INT_MSK3_GPIO4_F_IT_MSK_MASK			0x02
#define INT_MSK3_GPIO4_F_IT_MSK_SHIFT			1
#define INT_MSK3_GPIO4_R_IT_MSK_MASK			0x01
#define INT_MSK3_GPIO4_R_IT_MSK_SHIFT			0


/*Register GPIO  (0x80) register.RegisterDescription */
#define GPIO_SLEEP_MASK                         0x80
#define GPIO_SLEEP_SHIFT                        7
#define GPIO_DEB_MASK                           0x10
#define GPIO_DEB_SHIFT                          4
#define GPIO_PUEN_MASK                          0x08
#define GPIO_PUEN_SHIFT                         3
#define GPIO_CFG_MASK                           0x04
#define GPIO_CFG_SHIFT                          2
#define GPIO_STS_MASK                           0x02
#define GPIO_STS_SHIFT                          1
#define GPIO_SET_MASK                           0x01
#define GPIO_SET_SHIFT                          0


/*Register JTAGVERNUM  (0x80) register.RegisterDescription */
#define JTAGVERNUM_VERNUM_MASK				0x0F
#define JTAGVERNUM_VERNUM_SHIFT				0


/* Register VDDCTRL (0x27) bit definitions */
#define VDDCTRL_ST_MASK                                  0x03
#define VDDCTRL_ST_SHIFT                                 0


/*Register VDDCTRL_OP  (0x28) bit definitios */
#define VDDCTRL_OP_CMD_MASK                              0x80
#define VDDCTRL_OP_CMD_SHIFT                             7
#define VDDCTRL_OP_SEL_MASK                              0x7F
#define VDDCTRL_OP_SEL_SHIFT                             0


/*Register VDDCTRL_SR  (0x29) bit definitions */
#define VDDCTRL_SR_SEL_MASK                              0x7F
#define VDDCTRL_SR_SEL_SHIFT                             0


/* IRQ Definitions */
#define TPS65910_IRQ_VBAT_VMBDCH			0
#define TPS65910_IRQ_VBAT_VMHI				1
#define TPS65910_IRQ_PWRON				2
#define TPS65910_IRQ_PWRON_LP				3
#define TPS65910_IRQ_PWRHOLD				4
#define TPS65910_IRQ_HOTDIE				5
#define TPS65910_IRQ_RTC_ALARM				6
#define TPS65910_IRQ_RTC_PERIOD				7
#define TPS65910_IRQ_GPIO_R				8
#define TPS65910_IRQ_GPIO_F				9
#define TPS65910_NUM_IRQ				10

#define TPS65911_IRQ_PWRHOLD_F				0
#define TPS65911_IRQ_VBAT_VMHI				1
#define TPS65911_IRQ_PWRON				2
#define TPS65911_IRQ_PWRON_LP				3
#define TPS65911_IRQ_PWRHOLD_R				4
#define TPS65911_IRQ_HOTDIE				5
#define TPS65911_IRQ_RTC_ALARM				6
#define TPS65911_IRQ_RTC_PERIOD				7
#define TPS65911_IRQ_GPIO0_R				8
#define TPS65911_IRQ_GPIO0_F				9
#define TPS65911_IRQ_GPIO1_R				10
#define TPS65911_IRQ_GPIO1_F				11
#define TPS65911_IRQ_GPIO2_R				12
#define TPS65911_IRQ_GPIO2_F				13
#define TPS65911_IRQ_GPIO3_R				14
#define TPS65911_IRQ_GPIO3_F				15
#define TPS65911_IRQ_GPIO4_R				16
#define TPS65911_IRQ_GPIO4_F				17
#define TPS65911_IRQ_GPIO5_R				18
#define TPS65911_IRQ_GPIO5_F				19
#define TPS65911_IRQ_WTCHDG				20
#define TPS65911_IRQ_VMBCH2_H				21
#define TPS65911_IRQ_VMBCH2_L				22
#define TPS65911_IRQ_PWRDN				23

#define TPS65911_NUM_IRQ				24

/* GPIO Register Definitions */
#define TPS65910_GPIO_DEB				BIT(2)
#define TPS65910_GPIO_PUEN				BIT(3)
#define TPS65910_GPIO_CFG				BIT(2)
#define TPS65910_GPIO_STS				BIT(1)
#define TPS65910_GPIO_SET				BIT(0)

/* Max number of TPS65910/11 GPIOs */
#define TPS65910_NUM_GPIO				6
#define TPS65911_NUM_GPIO				9
#define TPS6591X_MAX_NUM_GPIO				9

/* Regulator Index Definitions */
#define TPS65910_REG_VRTC				0
#define TPS65910_REG_VIO				1
#define TPS65910_REG_VDD1				2
#define TPS65910_REG_VDD2				3
#define TPS65910_REG_VDD3				4
#define TPS65910_REG_VDIG1				5
#define TPS65910_REG_VDIG2				6
#define TPS65910_REG_VPLL				7
#define TPS65910_REG_VDAC				8
#define TPS65910_REG_VAUX1				9
#define TPS65910_REG_VAUX2				10
#define TPS65910_REG_VAUX33				11
#define TPS65910_REG_VMMC				12
#define TPS65910_REG_VBB				13

#define TPS65911_REG_VDDCTRL				4
#define TPS65911_REG_LDO1				5
#define TPS65911_REG_LDO2				6
#define TPS65911_REG_LDO3				7
#define TPS65911_REG_LDO4				8
#define TPS65911_REG_LDO5				9
#define TPS65911_REG_LDO6				10
#define TPS65911_REG_LDO7				11
#define TPS65911_REG_LDO8				12

/* Max number of TPS65910/11 regulators */
#define TPS65910_NUM_REGS				14

/* External sleep controls through EN1/EN2/EN3/SLEEP inputs */
#define TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1		0x1
#define TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2		0x2
#define TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3		0x4
#define TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP		0x8

/*
 * Sleep keepon data: Maintains the state in sleep mode
 * @therm_keepon: Keep on the thermal monitoring in sleep state.
 * @clkout32k_keepon: Keep on the 32KHz clock output in sleep state.
 * @i2chs_keepon: Keep on high speed internal clock in sleep state.
 */
struct tps65910_sleep_keepon_data {
	unsigned therm_keepon:1;
	unsigned clkout32k_keepon:1;
	unsigned i2chs_keepon:1;
};

/**
 * struct tps65910_board
 * Board platform data may be used to initialize regulators.
 */

struct tps65910_board {
	int gpio_base;
	int irq;
	int irq_base;
	int vmbch_threshold;
	int vmbch2_threshold;
	bool en_ck32k_xtal;
	bool en_dev_slp;
	bool pm_off;
	struct tps65910_sleep_keepon_data *slp_keepon;
	bool en_gpio_sleep[TPS6591X_MAX_NUM_GPIO];
	unsigned long regulator_ext_sleep_control[TPS65910_NUM_REGS];
	struct regulator_init_data *tps65910_pmic_init_data[TPS65910_NUM_REGS];
};

/**
 * struct tps65910 - tps65910 sub-driver chip access routines
 */

struct tps65910 {
	struct device *dev;
	struct i2c_client *i2c_client;
	struct regmap *regmap;
	unsigned long id;

	/* Client devices */
	struct tps65910_pmic *pmic;
	struct tps65910_rtc *rtc;
	struct tps65910_power *power;

	/* Device node parsed board data */
	struct tps65910_board *of_plat_data;

	/* IRQ Handling */
	int chip_irq;
	struct regmap_irq_chip_data *irq_data;
};

struct tps65910_platform_data {
	int irq;
	int irq_base;
};

static inline int tps65910_chip_id(struct tps65910 *tps65910)
{
	return tps65910->id;
}

static inline int tps65910_reg_read(struct tps65910 *tps65910, u8 reg,
		unsigned int *val)
{
	return regmap_read(tps65910->regmap, reg, val);
}

static inline int tps65910_reg_write(struct tps65910 *tps65910, u8 reg,
		unsigned int val)
{
	return regmap_write(tps65910->regmap, reg, val);
}

static inline int tps65910_reg_set_bits(struct tps65910 *tps65910, u8 reg,
		u8 mask)
{
	return regmap_update_bits(tps65910->regmap, reg, mask, mask);
}

static inline int tps65910_reg_clear_bits(struct tps65910 *tps65910, u8 reg,
		u8 mask)
{
	return regmap_update_bits(tps65910->regmap, reg, mask, 0);
}

static inline int tps65910_reg_update_bits(struct tps65910 *tps65910, u8 reg,
					   u8 mask, u8 val)
{
	return regmap_update_bits(tps65910->regmap, reg, mask, val);
}

static inline int tps65910_irq_get_virq(struct tps65910 *tps65910, int irq)
{
	return regmap_irq_get_virq(tps65910->irq_data, irq);
}

#endif /*  __LINUX_MFD_TPS65910_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #ifndef _LINUX_SWAPFILE_H
#define _LINUX_SWAPFILE_H

/*
 * these were static in swapfile.c but frontswap.c needs them and we don't
 * want to expose them to the dozens of source files that include swap.h
 */
extern spinlock_t swap_lock;
extern struct plist_head swap_active_head;
extern struct swap_info_struct *swap_info[];
extern int try_to_unuse(unsigned int, bool, unsigned long);

#endif /* _LINUX_SWAPFILE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * omap iommu: simple virtual address space management
 *
 * Copyright (C) 2008-2009 Nokia Corporation
 *
 * Written by Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef _OMAP_IOMMU_H_
#define _OMAP_IOMMU_H_

extern void omap_iommu_save_ctx(struct device *dev);
extern void omap_iommu_restore_ctx(struct device *dev);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef _LINUX_PAGEMAP_H
#define _LINUX_PAGEMAP_H

/*
 * Copyright 1995 Linus Torvalds
 */
#include <linux/mm.h>
#include <linux/fs.h>
#include <linux/list.h>
#include <linux/highmem.h>
#include <linux/compiler.h>
#include <asm/uaccess.h>
#include <linux/gfp.h>
#include <linux/bitops.h>
#include <linux/hardirq.h> /* for in_interrupt() */
#include <linux/hugetlb_inline.h>

/*
 * Bits in mapping->flags.  The lower __GFP_BITS_SHIFT bits are the page
 * allocation mode flags.
 */
enum mapping_flags {
	AS_EIO		= __GFP_BITS_SHIFT + 0,	/* IO error on async write */
	AS_ENOSPC	= __GFP_BITS_SHIFT + 1,	/* ENOSPC on async write */
	AS_MM_ALL_LOCKS	= __GFP_BITS_SHIFT + 2,	/* under mm_take_all_locks() */
	AS_UNEVICTABLE	= __GFP_BITS_SHIFT + 3,	/* e.g., ramdisk, SHM_LOCK */
	AS_EXITING	= __GFP_BITS_SHIFT + 4, /* final truncate in progress */
};

static inline void mapping_set_error(struct address_space *mapping, int error)
{
	if (unlikely(error)) {
		if (error == -ENOSPC)
			set_bit(AS_ENOSPC, &mapping->flags);
		else
			set_bit(AS_EIO, &mapping->flags);
	}
}

static inline void mapping_set_unevictable(struct address_space *mapping)
{
	set_bit(AS_UNEVICTABLE, &mapping->flags);
}

static inline void mapping_clear_unevictable(struct address_space *mapping)
{
	clear_bit(AS_UNEVICTABLE, &mapping->flags);
}

static inline int mapping_unevictable(struct address_space *mapping)
{
	if (mapping)
		return test_bit(AS_UNEVICTABLE, &mapping->flags);
	return !!mapping;
}

static inline void mapping_set_exiting(struct address_space *mapping)
{
	set_bit(AS_EXITING, &mapping->flags);
}

static inline int mapping_exiting(struct address_space *mapping)
{
	return test_bit(AS_EXITING, &mapping->flags);
}

static inline gfp_t mapping_gfp_mask(struct address_space * mapping)
{
	return (__force gfp_t)mapping->flags & __GFP_BITS_MASK;
}

/*
 * This is non-atomic.  Only to be used before the mapping is activated.
 * Probably needs a barrier...
 */
static inline void mapping_set_gfp_mask(struct address_space *m, gfp_t mask)
{
	m->flags = (m->flags & ~(__force unsigned long)__GFP_BITS_MASK) |
				(__force unsigned long)mask;
}

/*
 * The page cache can be done in larger chunks than
 * one page, because it allows for more efficient
 * throughput (it can then be mapped into user
 * space in smaller chunks for same flexibility).
 *
 * Or rather, it _will_ be done in larger chunks.
 */
#define PAGE_CACHE_SHIFT	PAGE_SHIFT
#define PAGE_CACHE_SIZE		PAGE_SIZE
#define PAGE_CACHE_MASK		PAGE_MASK
#define PAGE_CACHE_ALIGN(addr)	(((addr)+PAGE_CACHE_SIZE-1)&PAGE_CACHE_MASK)

#define page_cache_get(page)		get_page(page)
#define page_cache_release(page)	put_page(page)
void release_pages(struct page **pages, int nr, bool cold);

/*
 * speculatively take a reference to a page.
 * If the page is free (_count == 0), then _count is untouched, and 0
 * is returned. Otherwise, _count is incremented by 1 and 1 is returned.
 *
 * This function must be called inside the same rcu_read_lock() section as has
 * been used to lookup the page in the pagecache radix-tree (or page table):
 * this allows allocators to use a synchronize_rcu() to stabilize _count.
 *
 * Unless an RCU grace period has passed, the count of all pages coming out
 * of the allocator must be considered unstable. page_count may return higher
 * than expected, and put_page must be able to do the right thing when the
 * page has been finished with, no matter what it is subsequently allocated
 * for (because put_page is what is used here to drop an invalid speculative
 * reference).
 *
 * This is the interesting part of the lockless pagecache (and lockless
 * get_user_pages) locking protocol, where the lookup-side (eg. find_get_page)
 * has the following pattern:
 * 1. find page in radix tree
 * 2. conditionally increment refcount
 * 3. check the page is still in pagecache (if no, goto 1)
 *
 * Remove-side that cares about stability of _count (eg. reclaim) has the
 * following (with tree_lock held for write):
 * A. atomically check refcount is correct and set it to 0 (atomic_cmpxchg)
 * B. remove page from pagecache
 * C. free the page
 *
 * There are 2 critical interleavings that matter:
 * - 2 runs before A: in this case, A sees elevated refcount and bails out
 * - A runs before 2: in this case, 2 sees zero refcount and retries;
 *   subsequently, B will complete and 1 will find no page, causing the
 *   lookup to return NULL.
 *
 * It is possible that between 1 and 2, the page is removed then the exact same
 * page is inserted into the same position in pagecache. That's OK: the
 * old find_get_page using tree_lock could equally have run before or after
 * such a re-insertion, depending on order that locks are granted.
 *
 * Lookups racing against pagecache insertion isn't a big problem: either 1
 * will find the page or it will not. Likewise, the old find_get_page could run
 * either before the insertion or afterwards, depending on timing.
 */
static inline int page_cache_get_speculative(struct page *page)
{
	VM_BUG_ON(in_interrupt());

#ifdef CONFIG_TINY_RCU
# ifdef CONFIG_PREEMPT_COUNT
	VM_BUG_ON(!in_atomic());
# endif
	/*
	 * Preempt must be disabled here - we rely on rcu_read_lock doing
	 * this for us.
	 *
	 * Pagecache won't be truncated from interrupt context, so if we have
	 * found a page in the radix tree here, we have pinned its refcount by
	 * disabling preempt, and hence no need for the "speculative get" that
	 * SMP requires.
	 */
	VM_BUG_ON_PAGE(page_count(page) == 0, page);
	atomic_inc(&page->_count);

#else
	if (unlikely(!get_page_unless_zero(page))) {
		/*
		 * Either the page has been freed, or will be freed.
		 * In either case, retry here and the caller should
		 * do the right thing (see comments above).
		 */
		return 0;
	}
#endif
	VM_BUG_ON_PAGE(PageTail(page), page);

	return 1;
}

/*
 * Same as above, but add instead of inc (could just be merged)
 */
static inline int page_cache_add_speculative(struct page *page, int count)
{
	VM_BUG_ON(in_interrupt());

#if !defined(CONFIG_SMP) && defined(CONFIG_TREE_RCU)
# ifdef CONFIG_PREEMPT_COUNT
	VM_BUG_ON(!in_atomic());
# endif
	VM_BUG_ON_PAGE(page_count(page) == 0, page);
	atomic_add(count, &page->_count);

#else
	if (unlikely(!atomic_add_unless(&page->_count, count, 0)))
		return 0;
#endif
	VM_BUG_ON_PAGE(PageCompound(page) && page != compound_head(page), page);

	return 1;
}

static inline int page_freeze_refs(struct page *page, int count)
{
	return likely(atomic_cmpxchg(&page->_count, count, 0) == count);
}

static inline void page_unfreeze_refs(struct page *page, int count)
{
	VM_BUG_ON_PAGE(page_count(page) != 0, page);
	VM_BUG_ON(count == 0);

	atomic_set(&page->_count, count);
}

#ifdef CONFIG_NUMA
extern struct page *__page_cache_alloc(gfp_t gfp);
#else
static inline struct page *__page_cache_alloc(gfp_t gfp)
{
	return alloc_pages(gfp, 0);
}
#endif

static inline struct page *page_cache_alloc(struct address_space *x)
{
	return __page_cache_alloc(mapping_gfp_mask(x));
}

static inline struct page *page_cache_alloc_cold(struct address_space *x)
{
	return __page_cache_alloc(mapping_gfp_mask(x)|__GFP_COLD);
}

static inline struct page *page_cache_alloc_readahead(struct address_space *x)
{
	return __page_cache_alloc(mapping_gfp_mask(x) |
				  __GFP_COLD | __GFP_NORETRY | __GFP_NOWARN);
}

typedef int filler_t(void *, struct page *);

pgoff_t page_cache_next_hole(struct address_space *mapping,
			     pgoff_t index, unsigned long max_scan);
pgoff_t page_cache_prev_hole(struct address_space *mapping,
			     pgoff_t index, unsigned long max_scan);

#define FGP_ACCESSED		0x00000001
#define FGP_LOCK		0x00000002
#define FGP_CREAT		0x00000004
#define FGP_WRITE		0x00000008
#define FGP_NOFS		0x00000010
#define FGP_NOWAIT		0x00000020

struct page *pagecache_get_page(struct address_space *mapping, pgoff_t offset,
		int fgp_flags, gfp_t cache_gfp_mask);

/**
 * find_get_page - find and get a page reference
 * @mapping: the address_space to search
 * @offset: the page index
 *
 * Looks up the page cache slot at @mapping & @offset.  If there is a
 * page cache page, it is returned with an increased refcount.
 *
 * Otherwise, %NULL is returned.
 */
static inline struct page *find_get_page(struct address_space *mapping,
					pgoff_t offset)
{
	return pagecache_get_page(mapping, offset, 0, 0);
}

static inline struct page *find_get_page_flags(struct address_space *mapping,
					pgoff_t offset, int fgp_flags)
{
	return pagecache_get_page(mapping, offset, fgp_flags, 0);
}

/**
 * find_lock_page - locate, pin and lock a pagecache page
 * pagecache_get_page - find and get a page reference
 * @mapping: the address_space to search
 * @offset: the page index
 *
 * Looks up the page cache slot at @mapping & @offset.  If there is a
 * page cache page, it is returned locked and with an increased
 * refcount.
 *
 * Otherwise, %NULL is returned.
 *
 * find_lock_page() may sleep.
 */
static inline struct page *find_lock_page(struct address_space *mapping,
					pgoff_t offset)
{
	return pagecache_get_page(mapping, offset, FGP_LOCK, 0);
}

/**
 * find_or_create_page - locate or add a pagecache page
 * @mapping: the page's address_space
 * @index: the page's index into the mapping
 * @gfp_mask: page allocation mode
 *
 * Looks up the page cache slot at @mapping & @offset.  If there is a
 * page cache page, it is returned locked and with an increased
 * refcount.
 *
 * If the page is not present, a new page is allocated using @gfp_mask
 * and added to the page cache and the VM's LRU list.  The page is
 * returned locked and with an increased refcount.
 *
 * On memory exhaustion, %NULL is returned.
 *
 * find_or_create_page() may sleep, even if @gfp_flags specifies an
 * atomic allocation!
 */
static inline struct page *find_or_create_page(struct address_space *mapping,
					pgoff_t offset, gfp_t gfp_mask)
{
	return pagecache_get_page(mapping, offset,
					FGP_LOCK|FGP_ACCESSED|FGP_CREAT,
					gfp_mask);
}

/**
 * grab_cache_page_nowait - returns locked page at given index in given cache
 * @mapping: target address_space
 * @index: the page index
 *
 * Same as grab_cache_page(), but do not wait if the page is unavailable.
 * This is intended for speculative data generators, where the data can
 * be regenerated if the page couldn't be grabbed.  This routine should
 * be safe to call while holding the lock for another page.
 *
 * Clear __GFP_FS when allocating the page to avoid recursion into the fs
 * and deadlock against the caller's locked page.
 */
static inline struct page *grab_cache_page_nowait(struct address_space *mapping,
				pgoff_t index)
{
	return pagecache_get_page(mapping, index,
			FGP_LOCK|FGP_CREAT|FGP_NOFS|FGP_NOWAIT,
			mapping_gfp_mask(mapping));
}

struct page *find_get_entry(struct address_space *mapping, pgoff_t offset);
struct page *find_lock_entry(struct address_space *mapping, pgoff_t offset);
unsigned find_get_entries(struct address_space *mapping, pgoff_t start,
			  unsigned int nr_entries, struct page **entries,
			  pgoff_t *indices);
unsigned find_get_pages(struct address_space *mapping, pgoff_t start,
			unsigned int nr_pages, struct page **pages);
unsigned find_get_pages_contig(struct address_space *mapping, pgoff_t start,
			       unsigned int nr_pages, struct page **pages);
unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages);

struct page *grab_cache_page_write_begin(struct address_space *mapping,
			pgoff_t index, unsigned flags);

/*
 * Returns locked page at given index in given cache, creating it if needed.
 */
static inline struct page *grab_cache_page(struct address_space *mapping,
								pgoff_t index)
{
	return find_or_create_page(mapping, index, mapping_gfp_mask(mapping));
}

extern struct page * read_cache_page(struct address_space *mapping,
				pgoff_t index, filler_t *filler, void *data);
extern struct page * read_cache_page_gfp(struct address_space *mapping,
				pgoff_t index, gfp_t gfp_mask);
extern int read_cache_pages(struct address_space *mapping,
		struct list_head *pages, filler_t *filler, void *data);

static inline struct page *read_mapping_page(struct address_space *mapping,
				pgoff_t index, void *data)
{
	filler_t *filler = (filler_t *)mapping->a_ops->readpage;
	return read_cache_page(mapping, index, filler, data);
}

/*
 * Get the offset in PAGE_SIZE.
 * (TODO: hugepage should have ->index in PAGE_SIZE)
 */
static inline pgoff_t page_to_pgoff(struct page *page)
{
	if (unlikely(PageHeadHuge(page)))
		return page->index << compound_order(page);
	else
		return page->index << (PAGE_CACHE_SHIFT - PAGE_SHIFT);
}

/*
 * Return byte-offset into filesystem object for page.
 */
static inline loff_t page_offset(struct page *page)
{
	return ((loff_t)page->index) << PAGE_CACHE_SHIFT;
}

static inline loff_t page_file_offset(struct page *page)
{
	return ((loff_t)page_file_index(page)) << PAGE_CACHE_SHIFT;
}

extern pgoff_t linear_hugepage_index(struct vm_area_struct *vma,
				     unsigned long address);

static inline pgoff_t linear_page_index(struct vm_area_struct *vma,
					unsigned long address)
{
	pgoff_t pgoff;
	if (unlikely(is_vm_hugetlb_page(vma)))
		return linear_hugepage_index(vma, address);
	pgoff = (address - vma->vm_start) >> PAGE_SHIFT;
	pgoff += vma->vm_pgoff;
	return pgoff >> (PAGE_CACHE_SHIFT - PAGE_SHIFT);
}

extern void __lock_page(struct page *page);
extern int __lock_page_killable(struct page *page);
extern int __lock_page_or_retry(struct page *page, struct mm_struct *mm,
				unsigned int flags);
extern void unlock_page(struct page *page);

static inline void __set_page_locked(struct page *page)
{
	__set_bit(PG_locked, &page->flags);
}

static inline void __clear_page_locked(struct page *page)
{
	__clear_bit(PG_locked, &page->flags);
}

static inline int trylock_page(struct page *page)
{
	return (likely(!test_and_set_bit_lock(PG_locked, &page->flags)));
}

/*
 * lock_page may only be called if we have the page's inode pinned.
 */
static inline void lock_page(struct page *page)
{
	might_sleep();
	if (!trylock_page(page))
		__lock_page(page);
}

/*
 * lock_page_killable is like lock_page but can be interrupted by fatal
 * signals.  It returns 0 if it locked the page and -EINTR if it was
 * killed while waiting.
 */
static inline int lock_page_killable(struct page *page)
{
	might_sleep();
	if (!trylock_page(page))
		return __lock_page_killable(page);
	return 0;
}

/*
 * lock_page_or_retry - Lock the page, unless this would block and the
 * caller indicated that it can handle a retry.
 *
 * Return value and mmap_sem implications depend on flags; see
 * __lock_page_or_retry().
 */
static inline int lock_page_or_retry(struct page *page, struct mm_struct *mm,
				     unsigned int flags)
{
	might_sleep();
	return trylock_page(page) || __lock_page_or_retry(page, mm, flags);
}

/*
 * This is exported only for wait_on_page_locked/wait_on_page_writeback,
 * and for filesystems which need to wait on PG_private.
 */
extern void wait_on_page_bit(struct page *page, int bit_nr);

extern int wait_on_page_bit_killable(struct page *page, int bit_nr);
extern int wait_on_page_bit_killable_timeout(struct page *page,
					     int bit_nr, unsigned long timeout);

static inline int wait_on_page_locked_killable(struct page *page)
{
	if (PageLocked(page))
		return wait_on_page_bit_killable(page, PG_locked);
	return 0;
}

extern wait_queue_head_t *page_waitqueue(struct page *page);
static inline void wake_up_page(struct page *page, int bit)
{
	__wake_up_bit(page_waitqueue(page), &page->flags, bit);
}

/* 
 * Wait for a page to be unlocked.
 *
 * This must be called with the caller "holding" the page,
 * ie with increased "page->count" so that the page won't
 * go away during the wait..
 */
static inline void wait_on_page_locked(struct page *page)
{
	if (PageLocked(page))
		wait_on_page_bit(page, PG_locked);
}

/* 
 * Wait for a page to complete writeback
 */
static inline void wait_on_page_writeback(struct page *page)
{
	if (PageWriteback(page))
		wait_on_page_bit(page, PG_writeback);
}

extern void end_page_writeback(struct page *page);
void wait_for_stable_page(struct page *page);

void page_endio(struct page *page, int rw, int err);

/*
 * Add an arbitrary waiter to a page's wait queue
 */
extern void add_page_wait_queue(struct page *page, wait_queue_t *waiter);

/*
 * Fault a userspace page into pagetables.  Return non-zero on a fault.
 *
 * This assumes that two userspace pages are always sufficient.  That's
 * not true if PAGE_CACHE_SIZE > PAGE_SIZE.
 */
static inline int fault_in_pages_writeable(char __user *uaddr, int size)
{
	int ret;

	if (unlikely(size == 0))
		return 0;

	/*
	 * Writing zeroes into userspace here is OK, because we know that if
	 * the zero gets there, we'll be overwriting it.
	 */
	ret = __put_user(0, uaddr);
	if (ret == 0) {
		char __user *end = uaddr + size - 1;

		/*
		 * If the page was already mapped, this will get a cache miss
		 * for sure, so try to avoid doing it.
		 */
		if (((unsigned long)uaddr & PAGE_MASK) !=
				((unsigned long)end & PAGE_MASK))
			ret = __put_user(0, end);
	}
	return ret;
}

static inline int fault_in_pages_readable(const char __user *uaddr, int size)
{
	volatile char c;
	int ret;

	if (unlikely(size == 0))
		return 0;

	ret = __get_user(c, uaddr);
	if (ret == 0) {
		const char __user *end = uaddr + size - 1;

		if (((unsigned long)uaddr & PAGE_MASK) !=
				((unsigned long)end & PAGE_MASK)) {
			ret = __get_user(c, end);
			(void)c;
		}
	}
	return ret;
}

/*
 * Multipage variants of the above prefault helpers, useful if more than
 * PAGE_SIZE of data needs to be prefaulted. These are separate from the above
 * functions (which only handle up to PAGE_SIZE) to avoid clobbering the
 * filemap.c hotpaths.
 */
static inline int fault_in_multipages_writeable(char __user *uaddr, int size)
{
	int ret = 0;
	char __user *end = uaddr + size - 1;

	if (unlikely(size == 0))
		return ret;

	/*
	 * Writing zeroes into userspace here is OK, because we know that if
	 * the zero gets there, we'll be overwriting it.
	 */
	while (uaddr <= end) {
		ret = __put_user(0, uaddr);
		if (ret != 0)
			return ret;
		uaddr += PAGE_SIZE;
	}

	/* Check whether the range spilled into the next page. */
	if (((unsigned long)uaddr & PAGE_MASK) ==
			((unsigned long)end & PAGE_MASK))
		ret = __put_user(0, end);

	return ret;
}

static inline int fault_in_multipages_readable(const char __user *uaddr,
					       int size)
{
	volatile char c;
	int ret = 0;
	const char __user *end = uaddr + size - 1;

	if (unlikely(size == 0))
		return ret;

	while (uaddr <= end) {
		ret = __get_user(c, uaddr);
		if (ret != 0)
			return ret;
		uaddr += PAGE_SIZE;
	}

	/* Check whether the range spilled into the next page. */
	if (((unsigned long)uaddr & PAGE_MASK) ==
			((unsigned long)end & PAGE_MASK)) {
		ret = __get_user(c, end);
		(void)c;
	}

	return ret;
}

int add_to_page_cache_locked(struct page *page, struct address_space *mapping,
				pgoff_t index, gfp_t gfp_mask);
int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
				pgoff_t index, gfp_t gfp_mask);
extern void delete_from_page_cache(struct page *page);
extern void __delete_from_page_cache(struct page *page, void *shadow);
int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask);

/*
 * Like add_to_page_cache_locked, but used to add newly allocated pages:
 * the page is new, so we can just run __set_page_locked() against it.
 */
static inline int add_to_page_cache(struct page *page,
		struct address_space *mapping, pgoff_t offset, gfp_t gfp_mask)
{
	int error;

	__set_page_locked(page);
	error = add_to_page_cache_locked(page, mapping, offset, gfp_mask);
	if (unlikely(error))
		__clear_page_locked(page);
	return error;
}

#endif /* _LINUX_PAGEMAP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Function declerations and data structures related to the splice
 * implementation.
 *
 * Copyright (C) 2007 Jens Axboe <jens.axboe@oracle.com>
 *
 */
#ifndef SPLICE_H
#define SPLICE_H

#include <linux/pipe_fs_i.h>

/*
 * Flags passed in from splice/tee/vmsplice
 */
#define SPLICE_F_MOVE	(0x01)	/* move pages instead of copying */
#define SPLICE_F_NONBLOCK (0x02) /* don't block on the pipe splicing (but */
				 /* we may still block on the fd we splice */
				 /* from/to, of course */
#define SPLICE_F_MORE	(0x04)	/* expect more data */
#define SPLICE_F_GIFT	(0x08)	/* pages passed in are a gift */

/*
 * Passed to the actors
 */
struct splice_desc {
	size_t total_len;		/* remaining length */
	unsigned int len;		/* current length */
	unsigned int flags;		/* splice flags */
	/*
	 * actor() private data
	 */
	union {
		void __user *userptr;	/* memory to write to */
		struct file *file;	/* file to read/write */
		void *data;		/* cookie */
	} u;
	loff_t pos;			/* file position */
	loff_t *opos;			/* sendfile: output position */
	size_t num_spliced;		/* number of bytes already spliced */
	bool need_wakeup;		/* need to wake up writer */
};

struct partial_page {
	unsigned int offset;
	unsigned int len;
	unsigned long private;
};

/*
 * Passed to splice_to_pipe
 */
struct splice_pipe_desc {
	struct page **pages;		/* page map */
	struct partial_page *partial;	/* pages[] may not be contig */
	int nr_pages;			/* number of populated pages in map */
	unsigned int nr_pages_max;	/* pages[] & partial[] arrays size */
	unsigned int flags;		/* splice flags */
	const struct pipe_buf_operations *ops;/* ops associated with output pipe */
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

typedef int (splice_actor)(struct pipe_inode_info *, struct pipe_buffer *,
			   struct splice_desc *);
typedef int (splice_direct_actor)(struct pipe_inode_info *,
				  struct splice_desc *);

extern ssize_t splice_from_pipe(struct pipe_inode_info *, struct file *,
				loff_t *, size_t, unsigned int,
				splice_actor *);
extern ssize_t __splice_from_pipe(struct pipe_inode_info *,
				  struct splice_desc *, splice_actor *);
extern ssize_t splice_to_pipe(struct pipe_inode_info *,
			      struct splice_pipe_desc *);
extern ssize_t splice_direct_to_actor(struct file *, struct splice_desc *,
				      splice_direct_actor *);

/*
 * for dynamic pipe sizing
 */
extern int splice_grow_spd(const struct pipe_inode_info *, struct splice_pipe_desc *);
extern void splice_shrink_spd(struct splice_pipe_desc *);
extern void spd_release_page(struct splice_pipe_desc *, unsigned int);

extern const struct pipe_buf_operations page_cache_pipe_buf_ops;
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef _LINUX_I2C_ALGO_PXA_H
#define _LINUX_I2C_ALGO_PXA_H

typedef enum i2c_slave_event_e {
	I2C_SLAVE_EVENT_START_READ,
	I2C_SLAVE_EVENT_START_WRITE,
	I2C_SLAVE_EVENT_STOP
} i2c_slave_event_t;

struct i2c_slave_client {
	void *data;
	void (*event)(void *ptr, i2c_slave_event_t event);
	int  (*read) (void *ptr);
	void (*write)(void *ptr, unsigned int val);
};

#endif /* _LINUX_I2C_ALGO_PXA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * procfs namespace bits
 */
#ifndef _LINUX_PROC_NS_H
#define _LINUX_PROC_NS_H

#include <linux/ns_common.h>

struct pid_namespace;
struct nsproxy;
struct path;

struct proc_ns_operations {
	const char *name;
	int type;
	struct ns_common *(*get)(struct task_struct *task);
	void (*put)(struct ns_common *ns);
	int (*install)(struct nsproxy *nsproxy, struct ns_common *ns);
};

extern const struct proc_ns_operations netns_operations;
extern const struct proc_ns_operations utsns_operations;
extern const struct proc_ns_operations ipcns_operations;
extern const struct proc_ns_operations pidns_operations;
extern const struct proc_ns_operations userns_operations;
extern const struct proc_ns_operations mntns_operations;

/*
 * We always define these enumerators
 */
enum {
	PROC_ROOT_INO		= 1,
	PROC_IPC_INIT_INO	= 0xEFFFFFFFU,
	PROC_UTS_INIT_INO	= 0xEFFFFFFEU,
	PROC_USER_INIT_INO	= 0xEFFFFFFDU,
	PROC_PID_INIT_INO	= 0xEFFFFFFCU,
};

#ifdef CONFIG_PROC_FS

extern int pid_ns_prepare_proc(struct pid_namespace *ns);
extern void pid_ns_release_proc(struct pid_namespace *ns);
extern int proc_alloc_inum(unsigned int *pino);
extern void proc_free_inum(unsigned int inum);

#else /* CONFIG_PROC_FS */

static inline int pid_ns_prepare_proc(struct pid_namespace *ns) { return 0; }
static inline void pid_ns_release_proc(struct pid_namespace *ns) {}

static inline int proc_alloc_inum(unsigned int *inum)
{
	*inum = 1;
	return 0;
}
static inline void proc_free_inum(unsigned int inum) {}

#endif /* CONFIG_PROC_FS */

static inline int ns_alloc_inum(struct ns_common *ns)
{
	atomic_long_set(&ns->stashed, 0);
	return proc_alloc_inum(&ns->inum);
}

#define ns_free_inum(ns) proc_free_inum((ns)->inum)

extern struct file *proc_ns_fget(int fd);
#define get_proc_ns(inode) ((struct ns_common *)(inode)->i_private)
extern void *ns_get_path(struct path *path, struct task_struct *task,
			const struct proc_ns_operations *ns_ops);

extern int ns_get_name(char *buf, size_t size, struct task_struct *task,
			const struct proc_ns_operations *ns_ops);
extern void nsfs_init(void);

#endif /* _LINUX_PROC_NS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef _LINUX_PERCPU_COUNTER_H
#define _LINUX_PERCPU_COUNTER_H
/*
 * A simple "approximate counter" for use in ext2 and ext3 superblocks.
 *
 * WARNING: these things are HUGE.  4 kbytes per counter on 32-way P4.
 */

#include <linux/spinlock.h>
#include <linux/smp.h>
#include <linux/list.h>
#include <linux/threads.h>
#include <linux/percpu.h>
#include <linux/types.h>
#include <linux/gfp.h>

#ifdef CONFIG_SMP

struct percpu_counter {
	raw_spinlock_t lock;
	s64 count;
#ifdef CONFIG_HOTPLUG_CPU
	struct list_head list;	/* All percpu_counters are on a list */
#endif
	s32 __percpu *counters;
};

extern int percpu_counter_batch;

int __percpu_counter_init(struct percpu_counter *fbc, s64 amount, gfp_t gfp,
			  struct lock_class_key *key);

#define percpu_counter_init(fbc, value, gfp)				\
	({								\
		static struct lock_class_key __key;			\
									\
		__percpu_counter_init(fbc, value, gfp, &__key);		\
	})

void percpu_counter_destroy(struct percpu_counter *fbc);
void percpu_counter_set(struct percpu_counter *fbc, s64 amount);
void __percpu_counter_add(struct percpu_counter *fbc, s64 amount, s32 batch);
s64 __percpu_counter_sum(struct percpu_counter *fbc);
int __percpu_counter_compare(struct percpu_counter *fbc, s64 rhs, s32 batch);

static inline int percpu_counter_compare(struct percpu_counter *fbc, s64 rhs)
{
	return __percpu_counter_compare(fbc, rhs, percpu_counter_batch);
}

static inline void percpu_counter_add(struct percpu_counter *fbc, s64 amount)
{
	__percpu_counter_add(fbc, amount, percpu_counter_batch);
}

static inline s64 percpu_counter_sum_positive(struct percpu_counter *fbc)
{
	s64 ret = __percpu_counter_sum(fbc);
	return ret < 0 ? 0 : ret;
}

static inline s64 percpu_counter_sum(struct percpu_counter *fbc)
{
	return __percpu_counter_sum(fbc);
}

static inline s64 percpu_counter_read(struct percpu_counter *fbc)
{
	return fbc->count;
}

/*
 * It is possible for the percpu_counter_read() to return a small negative
 * number for some counter which should never be negative.
 *
 */
static inline s64 percpu_counter_read_positive(struct percpu_counter *fbc)
{
	s64 ret = fbc->count;

	barrier();		/* Prevent reloads of fbc->count */
	if (ret >= 0)
		return ret;
	return 0;
}

static inline int percpu_counter_initialized(struct percpu_counter *fbc)
{
	return (fbc->counters != NULL);
}

#else /* !CONFIG_SMP */

struct percpu_counter {
	s64 count;
};

static inline int percpu_counter_init(struct percpu_counter *fbc, s64 amount,
				      gfp_t gfp)
{
	fbc->count = amount;
	return 0;
}

static inline void percpu_counter_destroy(struct percpu_counter *fbc)
{
}

static inline void percpu_counter_set(struct percpu_counter *fbc, s64 amount)
{
	fbc->count = amount;
}

static inline int percpu_counter_compare(struct percpu_counter *fbc, s64 rhs)
{
	if (fbc->count > rhs)
		return 1;
	else if (fbc->count < rhs)
		return -1;
	else
		return 0;
}

static inline int
__percpu_counter_compare(struct percpu_counter *fbc, s64 rhs, s32 batch)
{
	return percpu_counter_compare(fbc, rhs);
}

static inline void
percpu_counter_add(struct percpu_counter *fbc, s64 amount)
{
	preempt_disable();
	fbc->count += amount;
	preempt_enable();
}

static inline void
__percpu_counter_add(struct percpu_counter *fbc, s64 amount, s32 batch)
{
	percpu_counter_add(fbc, amount);
}

static inline s64 percpu_counter_read(struct percpu_counter *fbc)
{
	return fbc->count;
}

/*
 * percpu_counter is intended to track positive numbers. In the UP case the
 * number should never be negative.
 */
static inline s64 percpu_counter_read_positive(struct percpu_counter *fbc)
{
	return fbc->count;
}

static inline s64 percpu_counter_sum_positive(struct percpu_counter *fbc)
{
	return percpu_counter_read_positive(fbc);
}

static inline s64 percpu_counter_sum(struct percpu_counter *fbc)
{
	return percpu_counter_read(fbc);
}

static inline int percpu_counter_initialized(struct percpu_counter *fbc)
{
	return 1;
}

#endif	/* CONFIG_SMP */

static inline void percpu_counter_inc(struct percpu_counter *fbc)
{
	percpu_counter_add(fbc, 1);
}

static inline void percpu_counter_dec(struct percpu_counter *fbc)
{
	percpu_counter_add(fbc, -1);
}

static inline void percpu_counter_sub(struct percpu_counter *fbc, s64 amount)
{
	percpu_counter_add(fbc, -amount);
}

#endif /* _LINUX_PERCPU_COUNTER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * OF helpers for the MDIO (Ethernet PHY) API
 *
 * Copyright (c) 2009 Secret Lab Technologies, Ltd.
 *
 * This file is released under the GPLv2
 */

#ifndef __LINUX_OF_MDIO_H
#define __LINUX_OF_MDIO_H

#include <linux/phy.h>
#include <linux/of.h>

#ifdef CONFIG_OF
extern int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np);
extern struct phy_device *of_phy_find_device(struct device_node *phy_np);
extern struct phy_device *of_phy_connect(struct net_device *dev,
					 struct device_node *phy_np,
					 void (*hndlr)(struct net_device *),
					 u32 flags, phy_interface_t iface);
struct phy_device *of_phy_attach(struct net_device *dev,
				 struct device_node *phy_np, u32 flags,
				 phy_interface_t iface);

extern struct mii_bus *of_mdio_find_bus(struct device_node *mdio_np);
extern int of_mdio_parse_addr(struct device *dev, const struct device_node *np);

#else /* CONFIG_OF */
static inline int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
{
	/*
	 * Fall back to the non-DT function to register a bus.
	 * This way, we don't have to keep compat bits around in drivers.
	 */

	return mdiobus_register(mdio);
}

static inline struct phy_device *of_phy_find_device(struct device_node *phy_np)
{
	return NULL;
}

static inline struct phy_device *of_phy_connect(struct net_device *dev,
						struct device_node *phy_np,
						void (*hndlr)(struct net_device *),
						u32 flags, phy_interface_t iface)
{
	return NULL;
}

static inline struct phy_device *of_phy_attach(struct net_device *dev,
					       struct device_node *phy_np,
					       u32 flags, phy_interface_t iface)
{
	return NULL;
}

static inline struct mii_bus *of_mdio_find_bus(struct device_node *mdio_np)
{
	return NULL;
}

static inline int of_mdio_parse_addr(struct device *dev,
				     const struct device_node *np)
{
	return -ENOSYS;
}
#endif /* CONFIG_OF */

#if defined(CONFIG_OF) && defined(CONFIG_FIXED_PHY)
extern int of_phy_register_fixed_link(struct device_node *np);
extern bool of_phy_is_fixed_link(struct device_node *np);
#else
static inline int of_phy_register_fixed_link(struct device_node *np)
{
	return -ENOSYS;
}
static inline bool of_phy_is_fixed_link(struct device_node *np)
{
	return false;
}
#endif


#endif /* __LINUX_OF_MDIO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * sched_clock.h: support for extending counters to full 64-bit ns counter
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#ifndef LINUX_SCHED_CLOCK
#define LINUX_SCHED_CLOCK

#ifdef CONFIG_GENERIC_SCHED_CLOCK
extern void sched_clock_postinit(void);
#else
static inline void sched_clock_postinit(void) { }
#endif

extern void sched_clock_register(u64 (*read)(void), int bits,
				 unsigned long rate);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /******************************************************************************
*******************************************************************************
**
**  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.
**  Copyright (C) 2004-2011 Red Hat, Inc.  All rights reserved.
**
**  This copyrighted material is made available to anyone wishing to use,
**  modify, copy, or redistribute it subject to the terms and conditions
**  of the GNU General Public License v.2.
**
*******************************************************************************
******************************************************************************/
#ifndef __DLM_DOT_H__
#define __DLM_DOT_H__

#include <uapi/linux/dlm.h>


struct dlm_slot {
	int nodeid; /* 1 to MAX_INT */
	int slot;   /* 1 to MAX_INT */
};

/*
 * recover_prep: called before the dlm begins lock recovery.
 *   Notfies lockspace user that locks from failed members will be granted.
 * recover_slot: called after recover_prep and before recover_done.
 *   Identifies a failed lockspace member.
 * recover_done: called after the dlm completes lock recovery.
 *   Identifies lockspace members and lockspace generation number.
 */

struct dlm_lockspace_ops {
	void (*recover_prep) (void *ops_arg);
	void (*recover_slot) (void *ops_arg, struct dlm_slot *slot);
	void (*recover_done) (void *ops_arg, struct dlm_slot *slots,
			      int num_slots, int our_slot, uint32_t generation);
};

/*
 * dlm_new_lockspace
 *
 * Create/join a lockspace.
 *
 * name: lockspace name, null terminated, up to DLM_LOCKSPACE_LEN (not
 *   including terminating null).
 *
 * cluster: cluster name, null terminated, up to DLM_LOCKSPACE_LEN (not
 *   including terminating null).  Optional.  When cluster is null, it
 *   is not used.  When set, dlm_new_lockspace() returns -EBADR if cluster
 *   is not equal to the dlm cluster name.
 *
 * flags:
 * DLM_LSFL_NODIR
 *   The dlm should not use a resource directory, but statically assign
 *   resource mastery to nodes based on the name hash that is otherwise
 *   used to select the directory node.  Must be the same on all nodes.
 * DLM_LSFL_TIMEWARN
 *   The dlm should emit netlink messages if locks have been waiting
 *   for a configurable amount of time.  (Unused.)
 * DLM_LSFL_FS
 *   The lockspace user is in the kernel (i.e. filesystem).  Enables
 *   direct bast/cast callbacks.
 * DLM_LSFL_NEWEXCL
 *   dlm_new_lockspace() should return -EEXIST if the lockspace exists.
 *
 * lvblen: length of lvb in bytes.  Must be multiple of 8.
 *   dlm_new_lockspace() returns an error if this does not match
 *   what other nodes are using.
 *
 * ops: callbacks that indicate lockspace recovery points so the
 *   caller can coordinate its recovery and know lockspace members.
 *   This is only used by the initial dlm_new_lockspace() call.
 *   Optional.
 *
 * ops_arg: arg for ops callbacks.
 *
 * ops_result: tells caller if the ops callbacks (if provided) will
 *   be used or not.  0: will be used, -EXXX will not be used.
 *   -EOPNOTSUPP: the dlm does not have recovery_callbacks enabled.
 *
 * lockspace: handle for dlm functions
 */

int dlm_new_lockspace(const char *name, const char *cluster,
		      uint32_t flags, int lvblen,
		      const struct dlm_lockspace_ops *ops, void *ops_arg,
		      int *ops_result, dlm_lockspace_t **lockspace);

/*
 * dlm_release_lockspace
 *
 * Stop a lockspace.
 */

int dlm_release_lockspace(dlm_lockspace_t *lockspace, int force);

/*
 * dlm_lock
 *
 * Make an asynchronous request to acquire or convert a lock on a named
 * resource.
 *
 * lockspace: context for the request
 * mode: the requested mode of the lock (DLM_LOCK_)
 * lksb: lock status block for input and async return values
 * flags: input flags (DLM_LKF_)
 * name: name of the resource to lock, can be binary
 * namelen: the length in bytes of the resource name (MAX_RESNAME_LEN)
 * parent: the lock ID of a parent lock or 0 if none
 * lockast: function DLM executes when it completes processing the request
 * astarg: argument passed to lockast and bast functions
 * bast: function DLM executes when this lock later blocks another request
 *
 * Returns:
 * 0 if request is successfully queued for processing
 * -EINVAL if any input parameters are invalid
 * -EAGAIN if request would block and is flagged DLM_LKF_NOQUEUE
 * -ENOMEM if there is no memory to process request
 * -ENOTCONN if there is a communication error
 *
 * If the call to dlm_lock returns an error then the operation has failed and
 * the AST routine will not be called.  If dlm_lock returns 0 it is still
 * possible that the lock operation will fail. The AST routine will be called
 * when the locking is complete and the status is returned in the lksb.
 *
 * If the AST routines or parameter are passed to a conversion operation then
 * they will overwrite those values that were passed to a previous dlm_lock
 * call.
 *
 * AST routines should not block (at least not for long), but may make
 * any locking calls they please.
 */

int dlm_lock(dlm_lockspace_t *lockspace,
	     int mode,
	     struct dlm_lksb *lksb,
	     uint32_t flags,
	     void *name,
	     unsigned int namelen,
	     uint32_t parent_lkid,
	     void (*lockast) (void *astarg),
	     void *astarg,
	     void (*bast) (void *astarg, int mode));

/*
 * dlm_unlock
 *
 * Asynchronously release a lock on a resource.  The AST routine is called
 * when the resource is successfully unlocked.
 *
 * lockspace: context for the request
 * lkid: the lock ID as returned in the lksb
 * flags: input flags (DLM_LKF_)
 * lksb: if NULL the lksb parameter passed to last lock request is used
 * astarg: the arg used with the completion ast for the unlock
 *
 * Returns:
 * 0 if request is successfully queued for processing
 * -EINVAL if any input parameters are invalid
 * -ENOTEMPTY if the lock still has sublocks
 * -EBUSY if the lock is waiting for a remote lock operation
 * -ENOTCONN if there is a communication error
 */

int dlm_unlock(dlm_lockspace_t *lockspace,
	       uint32_t lkid,
	       uint32_t flags,
	       struct dlm_lksb *lksb,
	       void *astarg);

#endif				/* __DLM_DOT_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * pm_domain.h - Definitions and headers related to device power domains.
 *
 * Copyright (C) 2011 Rafael J. Wysocki <rjw@sisk.pl>, Renesas Electronics Corp.
 *
 * This file is released under the GPLv2.
 */

#ifndef _LINUX_PM_DOMAIN_H
#define _LINUX_PM_DOMAIN_H

#include <linux/device.h>
#include <linux/mutex.h>
#include <linux/pm.h>
#include <linux/err.h>
#include <linux/of.h>
#include <linux/notifier.h>
#include <linux/cpuidle.h>

/* Defines used for the flags field in the struct generic_pm_domain */
#define GENPD_FLAG_PM_CLK	(1U << 0) /* PM domain uses PM clk */

enum gpd_status {
	GPD_STATE_ACTIVE = 0,	/* PM domain is active */
	GPD_STATE_WAIT_MASTER,	/* PM domain's master is being waited for */
	GPD_STATE_BUSY,		/* Something is happening to the PM domain */
	GPD_STATE_REPEAT,	/* Power off in progress, to be repeated */
	GPD_STATE_POWER_OFF,	/* PM domain is off */
};

struct dev_power_governor {
	bool (*power_down_ok)(struct dev_pm_domain *domain);
	bool (*stop_ok)(struct device *dev);
};

struct gpd_dev_ops {
	int (*start)(struct device *dev);
	int (*stop)(struct device *dev);
	int (*save_state)(struct device *dev);
	int (*restore_state)(struct device *dev);
	bool (*active_wakeup)(struct device *dev);
};

struct gpd_cpuidle_data {
	unsigned int saved_exit_latency;
	struct cpuidle_state *idle_state;
};

struct generic_pm_domain {
	struct dev_pm_domain domain;	/* PM domain operations */
	struct list_head gpd_list_node;	/* Node in the global PM domains list */
	struct list_head master_links;	/* Links with PM domain as a master */
	struct list_head slave_links;	/* Links with PM domain as a slave */
	struct list_head dev_list;	/* List of devices */
	struct mutex lock;
	struct dev_power_governor *gov;
	struct work_struct power_off_work;
	const char *name;
	unsigned int in_progress;	/* Number of devices being suspended now */
	atomic_t sd_count;	/* Number of subdomains with power "on" */
	enum gpd_status status;	/* Current state of the domain */
	wait_queue_head_t status_wait_queue;
	struct task_struct *poweroff_task;	/* Powering off task */
	unsigned int resume_count;	/* Number of devices being resumed */
	unsigned int device_count;	/* Number of devices */
	unsigned int suspended_count;	/* System suspend device counter */
	unsigned int prepared_count;	/* Suspend counter of prepared devices */
	bool suspend_power_off;	/* Power status before system suspend */
	int (*power_off)(struct generic_pm_domain *domain);
	s64 power_off_latency_ns;
	int (*power_on)(struct generic_pm_domain *domain);
	s64 power_on_latency_ns;
	struct gpd_dev_ops dev_ops;
	s64 max_off_time_ns;	/* Maximum allowed "suspended" time. */
	bool max_off_time_changed;
	bool cached_power_down_ok;
	struct gpd_cpuidle_data *cpuidle_data;
	int (*attach_dev)(struct generic_pm_domain *domain,
			  struct device *dev);
	void (*detach_dev)(struct generic_pm_domain *domain,
			   struct device *dev);
	unsigned int flags;		/* Bit field of configs for genpd */
};

static inline struct generic_pm_domain *pd_to_genpd(struct dev_pm_domain *pd)
{
	return container_of(pd, struct generic_pm_domain, domain);
}

struct gpd_link {
	struct generic_pm_domain *master;
	struct list_head master_node;
	struct generic_pm_domain *slave;
	struct list_head slave_node;
};

struct gpd_timing_data {
	s64 stop_latency_ns;
	s64 start_latency_ns;
	s64 save_state_latency_ns;
	s64 restore_state_latency_ns;
	s64 effective_constraint_ns;
	bool constraint_changed;
	bool cached_stop_ok;
};

struct pm_domain_data {
	struct list_head list_node;
	struct device *dev;
};

struct generic_pm_domain_data {
	struct pm_domain_data base;
	struct gpd_timing_data td;
	struct notifier_block nb;
	int need_restore;
};

#ifdef CONFIG_PM_GENERIC_DOMAINS
static inline struct generic_pm_domain_data *to_gpd_data(struct pm_domain_data *pdd)
{
	return container_of(pdd, struct generic_pm_domain_data, base);
}

static inline struct generic_pm_domain_data *dev_gpd_data(struct device *dev)
{
	return to_gpd_data(dev->power.subsys_data->domain_data);
}

extern struct generic_pm_domain *pm_genpd_lookup_dev(struct device *dev);
extern int __pm_genpd_add_device(struct generic_pm_domain *genpd,
				 struct device *dev,
				 struct gpd_timing_data *td);

extern int __pm_genpd_name_add_device(const char *domain_name,
				      struct device *dev,
				      struct gpd_timing_data *td);

extern int pm_genpd_remove_device(struct generic_pm_domain *genpd,
				  struct device *dev);
extern int pm_genpd_add_subdomain(struct generic_pm_domain *genpd,
				  struct generic_pm_domain *new_subdomain);
extern int pm_genpd_add_subdomain_names(const char *master_name,
					const char *subdomain_name);
extern int pm_genpd_remove_subdomain(struct generic_pm_domain *genpd,
				     struct generic_pm_domain *target);
extern int pm_genpd_attach_cpuidle(struct generic_pm_domain *genpd, int state);
extern int pm_genpd_name_attach_cpuidle(const char *name, int state);
extern int pm_genpd_detach_cpuidle(struct generic_pm_domain *genpd);
extern int pm_genpd_name_detach_cpuidle(const char *name);
extern void pm_genpd_init(struct generic_pm_domain *genpd,
			  struct dev_power_governor *gov, bool is_off);

extern int pm_genpd_poweron(struct generic_pm_domain *genpd);
extern int pm_genpd_name_poweron(const char *domain_name);
extern void pm_genpd_poweroff_unused(void);

extern struct dev_power_governor simple_qos_governor;
extern struct dev_power_governor pm_domain_always_on_gov;
#else

static inline struct generic_pm_domain_data *dev_gpd_data(struct device *dev)
{
	return ERR_PTR(-ENOSYS);
}
static inline struct generic_pm_domain *pm_genpd_lookup_dev(struct device *dev)
{
	return NULL;
}
static inline int __pm_genpd_add_device(struct generic_pm_domain *genpd,
					struct device *dev,
					struct gpd_timing_data *td)
{
	return -ENOSYS;
}
static inline int __pm_genpd_name_add_device(const char *domain_name,
					     struct device *dev,
					     struct gpd_timing_data *td)
{
	return -ENOSYS;
}
static inline int pm_genpd_remove_device(struct generic_pm_domain *genpd,
					 struct device *dev)
{
	return -ENOSYS;
}
static inline int pm_genpd_add_subdomain(struct generic_pm_domain *genpd,
					 struct generic_pm_domain *new_sd)
{
	return -ENOSYS;
}
static inline int pm_genpd_add_subdomain_names(const char *master_name,
					       const char *subdomain_name)
{
	return -ENOSYS;
}
static inline int pm_genpd_remove_subdomain(struct generic_pm_domain *genpd,
					    struct generic_pm_domain *target)
{
	return -ENOSYS;
}
static inline int pm_genpd_attach_cpuidle(struct generic_pm_domain *genpd, int st)
{
	return -ENOSYS;
}
static inline int pm_genpd_name_attach_cpuidle(const char *name, int state)
{
	return -ENOSYS;
}
static inline int pm_genpd_detach_cpuidle(struct generic_pm_domain *genpd)
{
	return -ENOSYS;
}
static inline int pm_genpd_name_detach_cpuidle(const char *name)
{
	return -ENOSYS;
}
static inline void pm_genpd_init(struct generic_pm_domain *genpd,
				 struct dev_power_governor *gov, bool is_off)
{
}
static inline int pm_genpd_poweron(struct generic_pm_domain *genpd)
{
	return -ENOSYS;
}
static inline int pm_genpd_name_poweron(const char *domain_name)
{
	return -ENOSYS;
}
static inline void pm_genpd_poweroff_unused(void) {}
#define simple_qos_governor NULL
#define pm_domain_always_on_gov NULL
#endif

static inline int pm_genpd_add_device(struct generic_pm_domain *genpd,
				      struct device *dev)
{
	return __pm_genpd_add_device(genpd, dev, NULL);
}

static inline int pm_genpd_name_add_device(const char *domain_name,
					   struct device *dev)
{
	return __pm_genpd_name_add_device(domain_name, dev, NULL);
}

#ifdef CONFIG_PM_GENERIC_DOMAINS_SLEEP
extern void pm_genpd_syscore_poweroff(struct device *dev);
extern void pm_genpd_syscore_poweron(struct device *dev);
#else
static inline void pm_genpd_syscore_poweroff(struct device *dev) {}
static inline void pm_genpd_syscore_poweron(struct device *dev) {}
#endif

/* OF PM domain providers */
struct of_device_id;

struct genpd_onecell_data {
	struct generic_pm_domain **domains;
	unsigned int num_domains;
};

typedef struct generic_pm_domain *(*genpd_xlate_t)(struct of_phandle_args *args,
						void *data);

#ifdef CONFIG_PM_GENERIC_DOMAINS_OF
int __of_genpd_add_provider(struct device_node *np, genpd_xlate_t xlate,
			void *data);
void of_genpd_del_provider(struct device_node *np);
struct generic_pm_domain *of_genpd_get_from_provider(
			struct of_phandle_args *genpdspec);

struct generic_pm_domain *__of_genpd_xlate_simple(
					struct of_phandle_args *genpdspec,
					void *data);
struct generic_pm_domain *__of_genpd_xlate_onecell(
					struct of_phandle_args *genpdspec,
					void *data);

int genpd_dev_pm_attach(struct device *dev);
#else /* !CONFIG_PM_GENERIC_DOMAINS_OF */
static inline int __of_genpd_add_provider(struct device_node *np,
					genpd_xlate_t xlate, void *data)
{
	return 0;
}
static inline void of_genpd_del_provider(struct device_node *np) {}

static inline struct generic_pm_domain *of_genpd_get_from_provider(
			struct of_phandle_args *genpdspec)
{
	return NULL;
}

#define __of_genpd_xlate_simple		NULL
#define __of_genpd_xlate_onecell	NULL

static inline int genpd_dev_pm_attach(struct device *dev)
{
	return -ENODEV;
}
#endif /* CONFIG_PM_GENERIC_DOMAINS_OF */

static inline int of_genpd_add_provider_simple(struct device_node *np,
					struct generic_pm_domain *genpd)
{
	return __of_genpd_add_provider(np, __of_genpd_xlate_simple, genpd);
}
static inline int of_genpd_add_provider_onecell(struct device_node *np,
					struct genpd_onecell_data *data)
{
	return __of_genpd_add_provider(np, __of_genpd_xlate_onecell, data);
}

#ifdef CONFIG_PM
extern int dev_pm_domain_attach(struct device *dev, bool power_on);
extern void dev_pm_domain_detach(struct device *dev, bool power_off);
#else
static inline int dev_pm_domain_attach(struct device *dev, bool power_on)
{
	return -ENODEV;
}
static inline void dev_pm_domain_detach(struct device *dev, bool power_off) {}
#endif

#endif /* _LINUX_PM_DOMAIN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Generic HDLC support routines for Linux
 *
 * Copyright (C) 1999-2005 Krzysztof Halasa <khc@pm.waw.pl>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License
 * as published by the Free Software Foundation.
 */
#ifndef __HDLC_H
#define __HDLC_H


#include <linux/skbuff.h>
#include <linux/netdevice.h>
#include <linux/hdlc/ioctl.h>
#include <uapi/linux/hdlc.h>

/* This structure is a private property of HDLC protocols.
   Hardware drivers have no interest here */

struct hdlc_proto {
	int (*open)(struct net_device *dev);
	void (*close)(struct net_device *dev);
	void (*start)(struct net_device *dev); /* if open & DCD */
	void (*stop)(struct net_device *dev); /* if open & !DCD */
	void (*detach)(struct net_device *dev);
	int (*ioctl)(struct net_device *dev, struct ifreq *ifr);
	__be16 (*type_trans)(struct sk_buff *skb, struct net_device *dev);
	int (*netif_rx)(struct sk_buff *skb);
	netdev_tx_t (*xmit)(struct sk_buff *skb, struct net_device *dev);
	struct module *module;
	struct hdlc_proto *next; /* next protocol in the list */
};


/* Pointed to by netdev_priv(dev) */
typedef struct hdlc_device {
	/* used by HDLC layer to take control over HDLC device from hw driver*/
	int (*attach)(struct net_device *dev,
		      unsigned short encoding, unsigned short parity);

	/* hardware driver must handle this instead of dev->hard_start_xmit */
	netdev_tx_t (*xmit)(struct sk_buff *skb, struct net_device *dev);

	/* Things below are for HDLC layer internal use only */
	const struct hdlc_proto *proto;
	int carrier;
	int open;
	spinlock_t state_lock;
	void *state;
	void *priv;
} hdlc_device;



/* Exported from hdlc module */

/* Called by hardware driver when a user requests HDLC service */
int hdlc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);

/* Must be used by hardware driver on module startup/exit */
#define register_hdlc_device(dev)	register_netdev(dev)
void unregister_hdlc_device(struct net_device *dev);


void register_hdlc_protocol(struct hdlc_proto *proto);
void unregister_hdlc_protocol(struct hdlc_proto *proto);

struct net_device *alloc_hdlcdev(void *priv);

static inline struct hdlc_device* dev_to_hdlc(struct net_device *dev)
{
	return netdev_priv(dev);
}

static __inline__ void debug_frame(const struct sk_buff *skb)
{
	int i;

	for (i=0; i < skb->len; i++) {
		if (i == 100) {
			printk("...\n");
			return;
		}
		printk(" %02X", skb->data[i]);
	}
	printk("\n");
}


/* Must be called by hardware driver when HDLC device is being opened */
int hdlc_open(struct net_device *dev);
/* Must be called by hardware driver when HDLC device is being closed */
void hdlc_close(struct net_device *dev);
/* May be used by hardware driver */
int hdlc_change_mtu(struct net_device *dev, int new_mtu);
/* Must be pointed to by hw driver's dev->netdev_ops->ndo_start_xmit */
netdev_tx_t hdlc_start_xmit(struct sk_buff *skb, struct net_device *dev);

int attach_hdlc_protocol(struct net_device *dev, struct hdlc_proto *proto,
			 size_t size);
/* May be used by hardware driver to gain control over HDLC device */
void detach_hdlc_protocol(struct net_device *dev);

static __inline__ __be16 hdlc_type_trans(struct sk_buff *skb,
					 struct net_device *dev)
{
	hdlc_device *hdlc = dev_to_hdlc(dev);

	skb->dev = dev;
	skb_reset_mac_header(skb);

	if (hdlc->proto->type_trans)
		return hdlc->proto->type_trans(skb, dev);
	else
		return htons(ETH_P_HDLC);
}

#endif /* __HDLC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #ifndef _KBD_KERN_H
#define _KBD_KERN_H

#include <linux/tty.h>
#include <linux/interrupt.h>
#include <linux/keyboard.h>

extern struct tasklet_struct keyboard_tasklet;

extern char *func_table[MAX_NR_FUNC];
extern char func_buf[];
extern char *funcbufptr;
extern int funcbufsize, funcbufleft;

/*
 * kbd->xxx contains the VC-local things (flag settings etc..)
 *
 * Note: externally visible are LED_SCR, LED_NUM, LED_CAP defined in kd.h
 *       The code in KDGETLED / KDSETLED depends on the internal and
 *       external order being the same.
 *
 * Note: lockstate is used as index in the array key_map.
 */
struct kbd_struct {

	unsigned char lockstate;
/* 8 modifiers - the names do not have any meaning at all;
   they can be associated to arbitrarily chosen keys */
#define VC_SHIFTLOCK	KG_SHIFT	/* shift lock mode */
#define VC_ALTGRLOCK	KG_ALTGR	/* altgr lock mode */
#define VC_CTRLLOCK	KG_CTRL 	/* control lock mode */
#define VC_ALTLOCK	KG_ALT  	/* alt lock mode */
#define VC_SHIFTLLOCK	KG_SHIFTL	/* shiftl lock mode */
#define VC_SHIFTRLOCK	KG_SHIFTR	/* shiftr lock mode */
#define VC_CTRLLLOCK	KG_CTRLL 	/* ctrll lock mode */
#define VC_CTRLRLOCK	KG_CTRLR 	/* ctrlr lock mode */
	unsigned char slockstate; 	/* for `sticky' Shift, Ctrl, etc. */

	unsigned char ledmode:1;
#define LED_SHOW_FLAGS 0        /* traditional state */
#define LED_SHOW_IOCTL 1        /* only change leds upon ioctl */

	unsigned char ledflagstate:4;	/* flags, not lights */
	unsigned char default_ledflagstate:4;
#define VC_SCROLLOCK	0	/* scroll-lock mode */
#define VC_NUMLOCK	1	/* numeric lock mode */
#define VC_CAPSLOCK	2	/* capslock mode */
#define VC_KANALOCK	3	/* kanalock mode */

	unsigned char kbdmode:3;	/* one 3-bit value */
#define VC_XLATE	0	/* translate keycodes using keymap */
#define VC_MEDIUMRAW	1	/* medium raw (keycode) mode */
#define VC_RAW		2	/* raw (scancode) mode */
#define VC_UNICODE	3	/* Unicode mode */
#define VC_OFF		4	/* disabled mode */

	unsigned char modeflags:5;
#define VC_APPLIC	0	/* application key mode */
#define VC_CKMODE	1	/* cursor key mode */
#define VC_REPEAT	2	/* keyboard repeat */
#define VC_CRLF		3	/* 0 - enter sends CR, 1 - enter sends CRLF */
#define VC_META		4	/* 0 - meta, 1 - meta=prefix with ESC */
};

extern int kbd_init(void);

extern void setledstate(struct kbd_struct *kbd, unsigned int led);

extern int do_poke_blanked_console;

extern void (*kbd_ledfunc)(unsigned int led);

extern int set_console(int nr);
extern void schedule_console_callback(void);

/* FIXME: review locking for vt.c callers */
static inline void set_leds(void)
{
	tasklet_schedule(&keyboard_tasklet);
}

static inline int vc_kbd_mode(struct kbd_struct * kbd, int flag)
{
	return ((kbd->modeflags >> flag) & 1);
}

static inline int vc_kbd_led(struct kbd_struct * kbd, int flag)
{
	return ((kbd->ledflagstate >> flag) & 1);
}

static inline void set_vc_kbd_mode(struct kbd_struct * kbd, int flag)
{
	kbd->modeflags |= 1 << flag;
}

static inline void set_vc_kbd_led(struct kbd_struct * kbd, int flag)
{
	kbd->ledflagstate |= 1 << flag;
}

static inline void clr_vc_kbd_mode(struct kbd_struct * kbd, int flag)
{
	kbd->modeflags &= ~(1 << flag);
}

static inline void clr_vc_kbd_led(struct kbd_struct * kbd, int flag)
{
	kbd->ledflagstate &= ~(1 << flag);
}

static inline void chg_vc_kbd_lock(struct kbd_struct * kbd, int flag)
{
	kbd->lockstate ^= 1 << flag;
}

static inline void chg_vc_kbd_slock(struct kbd_struct * kbd, int flag)
{
	kbd->slockstate ^= 1 << flag;
}

static inline void chg_vc_kbd_mode(struct kbd_struct * kbd, int flag)
{
	kbd->modeflags ^= 1 << flag;
}

static inline void chg_vc_kbd_led(struct kbd_struct * kbd, int flag)
{
	kbd->ledflagstate ^= 1 << flag;
}

#define U(x) ((x) ^ 0xf000)

#define BRL_UC_ROW 0x2800

/* keyboard.c */

struct console;

void compute_shiftstate(void);

/* defkeymap.c */

extern unsigned int keymap_count;

#endif
                                                                                                                                                                                                            /*
 * Copyright (C) 2003 Sistina Software
 * Copyright (C) 2004 - 2008 Red Hat, Inc. All rights reserved.
 *
 * Device-Mapper low-level I/O.
 *
 * This file is released under the GPL.
 */

#ifndef _LINUX_DM_IO_H
#define _LINUX_DM_IO_H

#ifdef __KERNEL__

#include <linux/types.h>

struct dm_io_region {
	struct block_device *bdev;
	sector_t sector;
	sector_t count;		/* If this is zero the region is ignored. */
};

struct page_list {
	struct page_list *next;
	struct page *page;
};

typedef void (*io_notify_fn)(unsigned long error, void *context);

enum dm_io_mem_type {
	DM_IO_PAGE_LIST,/* Page list */
	DM_IO_BIO,	/* Bio vector */
	DM_IO_VMA,	/* Virtual memory area */
	DM_IO_KMEM,	/* Kernel memory */
};

struct dm_io_memory {
	enum dm_io_mem_type type;

	unsigned offset;

	union {
		struct page_list *pl;
		struct bio *bio;
		void *vma;
		void *addr;
	} ptr;
};

struct dm_io_notify {
	io_notify_fn fn;	/* Callback for asynchronous requests */
	void *context;		/* Passed to callback */
};

/*
 * IO request structure
 */
struct dm_io_client;
struct dm_io_request {
	int bi_rw;			/* READ|WRITE - not READA */
	struct dm_io_memory mem;	/* Memory to use for io */
	struct dm_io_notify notify;	/* Synchronous if notify.fn is NULL */
	struct dm_io_client *client;	/* Client memory handler */
};

/*
 * For async io calls, users can alternatively use the dm_io() function below
 * and dm_io_client_create() to create private mempools for the client.
 *
 * Create/destroy may block.
 */
struct dm_io_client *dm_io_client_create(void);
void dm_io_client_destroy(struct dm_io_client *client);

/*
 * IO interface using private per-client pools.
 * Each bit in the optional 'sync_error_bits' bitset indicates whether an
 * error occurred doing io to the corresponding region.
 */
int dm_io(struct dm_io_request *io_req, unsigned num_regions,
	  struct dm_io_region *region, unsigned long *sync_error_bits);

#endif	/* __KERNEL__ */
#endif	/* _LINUX_DM_IO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*******************************************************************************

  Header file for stmmac platform data

  Copyright (C) 2009  STMicroelectronics Ltd

  This program is free software; you can redistribute it and/or modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.

  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.

  You should have received a copy of the GNU General Public License along with
  this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

  The full GNU General Public License is included in this distribution in
  the file called "COPYING".

  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
*******************************************************************************/

#ifndef __STMMAC_PLATFORM_DATA
#define __STMMAC_PLATFORM_DATA

#include <linux/platform_device.h>

#define STMMAC_RX_COE_NONE	0
#define STMMAC_RX_COE_TYPE1	1
#define STMMAC_RX_COE_TYPE2	2

/* Define the macros for CSR clock range parameters to be passed by
 * platform code.
 * This could also be configured at run time using CPU freq framework. */

/* MDC Clock Selection define*/
#define	STMMAC_CSR_60_100M	0x0	/* MDC = clk_scr_i/42 */
#define	STMMAC_CSR_100_150M	0x1	/* MDC = clk_scr_i/62 */
#define	STMMAC_CSR_20_35M	0x2	/* MDC = clk_scr_i/16 */
#define	STMMAC_CSR_35_60M	0x3	/* MDC = clk_scr_i/26 */
#define	STMMAC_CSR_150_250M	0x4	/* MDC = clk_scr_i/102 */
#define	STMMAC_CSR_250_300M	0x5	/* MDC = clk_scr_i/122 */

/* The MDC clock could be set higher than the IEEE 802.3
 * specified frequency limit 0f 2.5 MHz, by programming a clock divider
 * of value different than the above defined values. The resultant MDIO
 * clock frequency of 12.5 MHz is applicable for the interfacing chips
 * supporting higher MDC clocks.
 * The MDC clock selection macros need to be defined for MDC clock rate
 * of 12.5 MHz, corresponding to the following selection.
 */
#define STMMAC_CSR_I_4		0x8	/* clk_csr_i/4 */
#define STMMAC_CSR_I_6		0x9	/* clk_csr_i/6 */
#define STMMAC_CSR_I_8		0xA	/* clk_csr_i/8 */
#define STMMAC_CSR_I_10		0xB	/* clk_csr_i/10 */
#define STMMAC_CSR_I_12		0xC	/* clk_csr_i/12 */
#define STMMAC_CSR_I_14		0xD	/* clk_csr_i/14 */
#define STMMAC_CSR_I_16		0xE	/* clk_csr_i/16 */
#define STMMAC_CSR_I_18		0xF	/* clk_csr_i/18 */

/* AXI DMA Burst length supported */
#define DMA_AXI_BLEN_4		(1 << 1)
#define DMA_AXI_BLEN_8		(1 << 2)
#define DMA_AXI_BLEN_16		(1 << 3)
#define DMA_AXI_BLEN_32		(1 << 4)
#define DMA_AXI_BLEN_64		(1 << 5)
#define DMA_AXI_BLEN_128	(1 << 6)
#define DMA_AXI_BLEN_256	(1 << 7)
#define DMA_AXI_BLEN_ALL (DMA_AXI_BLEN_4 | DMA_AXI_BLEN_8 | DMA_AXI_BLEN_16 \
			| DMA_AXI_BLEN_32 | DMA_AXI_BLEN_64 \
			| DMA_AXI_BLEN_128 | DMA_AXI_BLEN_256)

/* Platfrom data for platform device structure's platform_data field */

struct stmmac_mdio_bus_data {
	int (*phy_reset)(void *priv);
	unsigned int phy_mask;
	int *irqs;
	int probed_phy_irq;
#ifdef CONFIG_OF
	int reset_gpio, active_low;
	u32 delays[3];
#endif
};

struct stmmac_dma_cfg {
	int pbl;
	int fixed_burst;
	int mixed_burst;
	int burst_len;
};

struct plat_stmmacenet_data {
	char *phy_bus_name;
	int bus_id;
	int phy_addr;
	int interface;
	struct stmmac_mdio_bus_data *mdio_bus_data;
	struct stmmac_dma_cfg *dma_cfg;
	int clk_csr;
	int has_gmac;
	int enh_desc;
	int tx_coe;
	int rx_coe;
	int bugged_jumbo;
	int pmt;
	int force_sf_dma_mode;
	int force_thresh_dma_mode;
	int riwt_off;
	int max_speed;
	int maxmtu;
	int multicast_filter_bins;
	int unicast_filter_entries;
	int tx_fifo_size;
	int rx_fifo_size;
	void (*fix_mac_speed)(void *priv, unsigned int speed);
	void (*bus_setup)(void __iomem *ioaddr);
	void *(*setup)(struct platform_device *pdev);
	void (*free)(struct platform_device *pdev, void *priv);
	int (*init)(struct platform_device *pdev, void *priv);
	void (*exit)(struct platform_device *pdev, void *priv);
	void *custom_cfg;
	void *custom_data;
	void *bsp_priv;
};

/* of_data for SoC glue layer device tree bindings */

struct stmmac_of_data {
	int has_gmac;
	int enh_desc;
	int tx_coe;
	int rx_coe;
	int bugged_jumbo;
	int pmt;
	int riwt_off;
	void (*fix_mac_speed)(void *priv, unsigned int speed);
	void (*bus_setup)(void __iomem *ioaddr);
	void *(*setup)(struct platform_device *pdev);
	void (*free)(struct platform_device *pdev, void *priv);
	int (*init)(struct platform_device *pdev, void *priv);
	void (*exit)(struct platform_device *pdev, void *priv);
};
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef _LINUX_CGROUP_H
#define _LINUX_CGROUP_H
/*
 *  cgroup interface
 *
 *  Copyright (C) 2003 BULL SA
 *  Copyright (C) 2004-2006 Silicon Graphics, Inc.
 *
 */

#include <linux/sched.h>
#include <linux/cpumask.h>
#include <linux/nodemask.h>
#include <linux/rculist.h>
#include <linux/cgroupstats.h>
#include <linux/rwsem.h>
#include <linux/fs.h>
#include <linux/seq_file.h>
#include <linux/kernfs.h>

#include <linux/cgroup-defs.h>

#ifdef CONFIG_CGROUPS

extern int cgroup_init_early(void);
extern int cgroup_init(void);
extern void cgroup_fork(struct task_struct *p);
extern void cgroup_post_fork(struct task_struct *p);
extern void cgroup_exit(struct task_struct *p);
extern int cgroupstats_build(struct cgroupstats *stats,
				struct dentry *dentry);

extern int proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,
			    struct pid *pid, struct task_struct *tsk);

/**
 * css_get - obtain a reference on the specified css
 * @css: target css
 *
 * The caller must already have a reference.
 */
static inline void css_get(struct cgroup_subsys_state *css)
{
	if (!(css->flags & CSS_NO_REF))
		percpu_ref_get(&css->refcnt);
}

/**
 * css_get_many - obtain references on the specified css
 * @css: target css
 * @n: number of references to get
 *
 * The caller must already have a reference.
 */
static inline void css_get_many(struct cgroup_subsys_state *css, unsigned int n)
{
	if (!(css->flags & CSS_NO_REF))
		percpu_ref_get_many(&css->refcnt, n);
}

/**
 * css_tryget - try to obtain a reference on the specified css
 * @css: target css
 *
 * Obtain a reference on @css unless it already has reached zero and is
 * being released.  This function doesn't care whether @css is on or
 * offline.  The caller naturally needs to ensure that @css is accessible
 * but doesn't have to be holding a reference on it - IOW, RCU protected
 * access is good enough for this function.  Returns %true if a reference
 * count was successfully obtained; %false otherwise.
 */
static inline bool css_tryget(struct cgroup_subsys_state *css)
{
	if (!(css->flags & CSS_NO_REF))
		return percpu_ref_tryget(&css->refcnt);
	return true;
}

/**
 * css_tryget_online - try to obtain a reference on the specified css if online
 * @css: target css
 *
 * Obtain a reference on @css if it's online.  The caller naturally needs
 * to ensure that @css is accessible but doesn't have to be holding a
 * reference on it - IOW, RCU protected access is good enough for this
 * function.  Returns %true if a reference count was successfully obtained;
 * %false otherwise.
 */
static inline bool css_tryget_online(struct cgroup_subsys_state *css)
{
	if (!(css->flags & CSS_NO_REF))
		return percpu_ref_tryget_live(&css->refcnt);
	return true;
}

/**
 * css_put - put a css reference
 * @css: target css
 *
 * Put a reference obtained via css_get() and css_tryget_online().
 */
static inline void css_put(struct cgroup_subsys_state *css)
{
	if (!(css->flags & CSS_NO_REF))
		percpu_ref_put(&css->refcnt);
}

/**
 * css_put_many - put css references
 * @css: target css
 * @n: number of references to put
 *
 * Put references obtained via css_get() and css_tryget_online().
 */
static inline void css_put_many(struct cgroup_subsys_state *css, unsigned int n)
{
	if (!(css->flags & CSS_NO_REF))
		percpu_ref_put_many(&css->refcnt, n);
}

extern struct cgroup_root cgrp_dfl_root;
extern struct css_set init_css_set;

/**
 * cgroup_on_dfl - test whether a cgroup is on the default hierarchy
 * @cgrp: the cgroup of interest
 *
 * The default hierarchy is the v2 interface of cgroup and this function
 * can be used to test whether a cgroup is on the default hierarchy for
 * cases where a subsystem should behave differnetly depending on the
 * interface version.
 *
 * The set of behaviors which change on the default hierarchy are still
 * being determined and the mount option is prefixed with __DEVEL__.
 *
 * List of changed behaviors:
 *
 * - Mount options "noprefix", "xattr", "clone_children", "release_agent"
 *   and "name" are disallowed.
 *
 * - When mounting an existing superblock, mount options should match.
 *
 * - Remount is disallowed.
 *
 * - rename(2) is disallowed.
 *
 * - "tasks" is removed.  Everything should be at process granularity.  Use
 *   "cgroup.procs" instead.
 *
 * - "cgroup.procs" is not sorted.  pids will be unique unless they got
 *   recycled inbetween reads.
 *
 * - "release_agent" and "notify_on_release" are removed.  Replacement
 *   notification mechanism will be implemented.
 *
 * - "cgroup.clone_children" is removed.
 *
 * - "cgroup.subtree_populated" is available.  Its value is 0 if the cgroup
 *   and its descendants contain no task; otherwise, 1.  The file also
 *   generates kernfs notification which can be monitored through poll and
 *   [di]notify when the value of the file changes.
 *
 * - cpuset: tasks will be kept in empty cpusets when hotplug happens and
 *   take masks of ancestors with non-empty cpus/mems, instead of being
 *   moved to an ancestor.
 *
 * - cpuset: a task can be moved into an empty cpuset, and again it takes
 *   masks of ancestors.
 *
 * - memcg: use_hierarchy is on by default and the cgroup file for the flag
 *   is not created.
 *
 * - blkcg: blk-throttle becomes properly hierarchical.
 *
 * - debug: disallowed on the default hierarchy.
 */
static inline bool cgroup_on_dfl(const struct cgroup *cgrp)
{
	return cgrp->root == &cgrp_dfl_root;
}

/* no synchronization, the result can only be used as a hint */
static inline bool cgroup_has_tasks(struct cgroup *cgrp)
{
	return !list_empty(&cgrp->cset_links);
}

/* returns ino associated with a cgroup */
static inline ino_t cgroup_ino(struct cgroup *cgrp)
{
	return cgrp->kn->ino;
}

/* cft/css accessors for cftype->write() operation */
static inline struct cftype *of_cft(struct kernfs_open_file *of)
{
	return of->kn->priv;
}

struct cgroup_subsys_state *of_css(struct kernfs_open_file *of);

/* cft/css accessors for cftype->seq_*() operations */
static inline struct cftype *seq_cft(struct seq_file *seq)
{
	return of_cft(seq->private);
}

static inline struct cgroup_subsys_state *seq_css(struct seq_file *seq)
{
	return of_css(seq->private);
}

/*
 * Name / path handling functions.  All are thin wrappers around the kernfs
 * counterparts and can be called under any context.
 */

static inline int cgroup_name(struct cgroup *cgrp, char *buf, size_t buflen)
{
	return kernfs_name(cgrp->kn, buf, buflen);
}

static inline char * __must_check cgroup_path(struct cgroup *cgrp, char *buf,
					      size_t buflen)
{
	return kernfs_path(cgrp->kn, buf, buflen);
}

static inline void pr_cont_cgroup_name(struct cgroup *cgrp)
{
	pr_cont_kernfs_name(cgrp->kn);
}

static inline void pr_cont_cgroup_path(struct cgroup *cgrp)
{
	pr_cont_kernfs_path(cgrp->kn);
}

char *task_cgroup_path(struct task_struct *task, char *buf, size_t buflen);

int cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts);
int cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts);
int cgroup_rm_cftypes(struct cftype *cfts);

bool cgroup_is_descendant(struct cgroup *cgrp, struct cgroup *ancestor);

struct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset);
struct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset);

/**
 * cgroup_taskset_for_each - iterate cgroup_taskset
 * @task: the loop cursor
 * @tset: taskset to iterate
 */
#define cgroup_taskset_for_each(task, tset)				\
	for ((task) = cgroup_taskset_first((tset)); (task);		\
	     (task) = cgroup_taskset_next((tset)))

#define SUBSYS(_x) extern struct cgroup_subsys _x ## _cgrp_subsys;
#include <linux/cgroup_subsys.h>
#undef SUBSYS

/**
 * task_css_set_check - obtain a task's css_set with extra access conditions
 * @task: the task to obtain css_set for
 * @__c: extra condition expression to be passed to rcu_dereference_check()
 *
 * A task's css_set is RCU protected, initialized and exited while holding
 * task_lock(), and can only be modified while holding both cgroup_mutex
 * and task_lock() while the task is alive.  This macro verifies that the
 * caller is inside proper critical section and returns @task's css_set.
 *
 * The caller can also specify additional allowed conditions via @__c, such
 * as locks used during the cgroup_subsys::attach() methods.
 */
#ifdef CONFIG_PROVE_RCU
extern struct mutex cgroup_mutex;
extern struct rw_semaphore css_set_rwsem;
#define task_css_set_check(task, __c)					\
	rcu_dereference_check((task)->cgroups,				\
		lockdep_is_held(&cgroup_mutex) ||			\
		lockdep_is_held(&css_set_rwsem) ||			\
		((task)->flags & PF_EXITING) || (__c))
#else
#define task_css_set_check(task, __c)					\
	rcu_dereference((task)->cgroups)
#endif

/**
 * task_css_check - obtain css for (task, subsys) w/ extra access conds
 * @task: the target task
 * @subsys_id: the target subsystem ID
 * @__c: extra condition expression to be passed to rcu_dereference_check()
 *
 * Return the cgroup_subsys_state for the (@task, @subsys_id) pair.  The
 * synchronization rules are the same as task_css_set_check().
 */
#define task_css_check(task, subsys_id, __c)				\
	task_css_set_check((task), (__c))->subsys[(subsys_id)]

/**
 * task_css_set - obtain a task's css_set
 * @task: the task to obtain css_set for
 *
 * See task_css_set_check().
 */
static inline struct css_set *task_css_set(struct task_struct *task)
{
	return task_css_set_check(task, false);
}

/**
 * task_css - obtain css for (task, subsys)
 * @task: the target task
 * @subsys_id: the target subsystem ID
 *
 * See task_css_check().
 */
static inline struct cgroup_subsys_state *task_css(struct task_struct *task,
						   int subsys_id)
{
	return task_css_check(task, subsys_id, false);
}

/**
 * task_css_is_root - test whether a task belongs to the root css
 * @task: the target task
 * @subsys_id: the target subsystem ID
 *
 * Test whether @task belongs to the root css on the specified subsystem.
 * May be invoked in any context.
 */
static inline bool task_css_is_root(struct task_struct *task, int subsys_id)
{
	return task_css_check(task, subsys_id, true) ==
		init_css_set.subsys[subsys_id];
}

static inline struct cgroup *task_cgroup(struct task_struct *task,
					 int subsys_id)
{
	return task_css(task, subsys_id)->cgroup;
}

struct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,
					   struct cgroup_subsys_state *parent);

struct cgroup_subsys_state *css_from_id(int id, struct cgroup_subsys *ss);

/**
 * css_for_each_child - iterate through children of a css
 * @pos: the css * to use as the loop cursor
 * @parent: css whose children to walk
 *
 * Walk @parent's children.  Must be called under rcu_read_lock().
 *
 * If a subsystem synchronizes ->css_online() and the start of iteration, a
 * css which finished ->css_online() is guaranteed to be visible in the
 * future iterations and will stay visible until the last reference is put.
 * A css which hasn't finished ->css_online() or already finished
 * ->css_offline() may show up during traversal.  It's each subsystem's
 * responsibility to synchronize against on/offlining.
 *
 * It is allowed to temporarily drop RCU read lock during iteration.  The
 * caller is responsible for ensuring that @pos remains accessible until
 * the start of the next iteration by, for example, bumping the css refcnt.
 */
#define css_for_each_child(pos, parent)					\
	for ((pos) = css_next_child(NULL, (parent)); (pos);		\
	     (pos) = css_next_child((pos), (parent)))

struct cgroup_subsys_state *
css_next_descendant_pre(struct cgroup_subsys_state *pos,
			struct cgroup_subsys_state *css);

struct cgroup_subsys_state *
css_rightmost_descendant(struct cgroup_subsys_state *pos);

/**
 * css_for_each_descendant_pre - pre-order walk of a css's descendants
 * @pos: the css * to use as the loop cursor
 * @root: css whose descendants to walk
 *
 * Walk @root's descendants.  @root is included in the iteration and the
 * first node to be visited.  Must be called under rcu_read_lock().
 *
 * If a subsystem synchronizes ->css_online() and the start of iteration, a
 * css which finished ->css_online() is guaranteed to be visible in the
 * future iterations and will stay visible until the last reference is put.
 * A css which hasn't finished ->css_online() or already finished
 * ->css_offline() may show up during traversal.  It's each subsystem's
 * responsibility to synchronize against on/offlining.
 *
 * For example, the following guarantees that a descendant can't escape
 * state updates of its ancestors.
 *
 * my_online(@css)
 * {
 *	Lock @css's parent and @css;
 *	Inherit state from the parent;
 *	Unlock both.
 * }
 *
 * my_update_state(@css)
 * {
 *	css_for_each_descendant_pre(@pos, @css) {
 *		Lock @pos;
 *		if (@pos == @css)
 *			Update @css's state;
 *		else
 *			Verify @pos is alive and inherit state from its parent;
 *		Unlock @pos;
 *	}
 * }
 *
 * As long as the inheriting step, including checking the parent state, is
 * enclosed inside @pos locking, double-locking the parent isn't necessary
 * while inheriting.  The state update to the parent is guaranteed to be
 * visible by walking order and, as long as inheriting operations to the
 * same @pos are atomic to each other, multiple updates racing each other
 * still result in the correct state.  It's guaranateed that at least one
 * inheritance happens for any css after the latest update to its parent.
 *
 * If checking parent's state requires locking the parent, each inheriting
 * iteration should lock and unlock both @pos->parent and @pos.
 *
 * Alternatively, a subsystem may choose to use a single global lock to
 * synchronize ->css_online() and ->css_offline() against tree-walking
 * operations.
 *
 * It is allowed to temporarily drop RCU read lock during iteration.  The
 * caller is responsible for ensuring that @pos remains accessible until
 * the start of the next iteration by, for example, bumping the css refcnt.
 */
#define css_for_each_descendant_pre(pos, css)				\
	for ((pos) = css_next_descendant_pre(NULL, (css)); (pos);	\
	     (pos) = css_next_descendant_pre((pos), (css)))

struct cgroup_subsys_state *
css_next_descendant_post(struct cgroup_subsys_state *pos,
			 struct cgroup_subsys_state *css);

/**
 * css_for_each_descendant_post - post-order walk of a css's descendants
 * @pos: the css * to use as the loop cursor
 * @css: css whose descendants to walk
 *
 * Similar to css_for_each_descendant_pre() but performs post-order
 * traversal instead.  @root is included in the iteration and the last
 * node to be visited.
 *
 * If a subsystem synchronizes ->css_online() and the start of iteration, a
 * css which finished ->css_online() is guaranteed to be visible in the
 * future iterations and will stay visible until the last reference is put.
 * A css which hasn't finished ->css_online() or already finished
 * ->css_offline() may show up during traversal.  It's each subsystem's
 * responsibility to synchronize against on/offlining.
 *
 * Note that the walk visibility guarantee example described in pre-order
 * walk doesn't apply the same to post-order walks.
 */
#define css_for_each_descendant_post(pos, css)				\
	for ((pos) = css_next_descendant_post(NULL, (css)); (pos);	\
	     (pos) = css_next_descendant_post((pos), (css)))

bool css_has_online_children(struct cgroup_subsys_state *css);

/* A css_task_iter should be treated as an opaque object */
struct css_task_iter {
	struct cgroup_subsys		*ss;

	struct list_head		*cset_pos;
	struct list_head		*cset_head;

	struct list_head		*task_pos;
	struct list_head		*tasks_head;
	struct list_head		*mg_tasks_head;
};

void css_task_iter_start(struct cgroup_subsys_state *css,
			 struct css_task_iter *it);
struct task_struct *css_task_iter_next(struct css_task_iter *it);
void css_task_iter_end(struct css_task_iter *it);

int cgroup_attach_task_all(struct task_struct *from, struct task_struct *);
int cgroup_transfer_tasks(struct cgroup *to, struct cgroup *from);

struct cgroup_subsys_state *cgroup_get_e_css(struct cgroup *cgroup,
					     struct cgroup_subsys *ss);
struct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,
						       struct cgroup_subsys *ss);

#else /* !CONFIG_CGROUPS */

struct cgroup_subsys_state;

static inline int cgroup_init_early(void) { return 0; }
static inline int cgroup_init(void) { return 0; }
static inline void cgroup_fork(struct task_struct *p) {}
static inline void cgroup_post_fork(struct task_struct *p) {}
static inline void cgroup_exit(struct task_struct *p) {}

static inline int cgroupstats_build(struct cgroupstats *stats,
					struct dentry *dentry)
{
	return -EINVAL;
}

static inline void css_put(struct cgroup_subsys_state *css) {}

/* No cgroups - nothing to do */
static inline int cgroup_attach_task_all(struct task_struct *from,
					 struct task_struct *t)
{
	return 0;
}

#endif /* !CONFIG_CGROUPS */

#endif /* _LINUX_CGROUP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             u32 scx200_gpio_configure(unsigned index, u32 set, u32 clear);

extern unsigned scx200_gpio_base;
extern unsigned long scx200_gpio_shadow[2];
extern struct nsc_gpio_ops scx200_gpio_ops;

#define scx200_gpio_present() (scx200_gpio_base!=0)

/* Definitions to make sure I do the same thing in all functions */
#define __SCx200_GPIO_BANK unsigned bank = index>>5
#define __SCx200_GPIO_IOADDR unsigned short ioaddr = scx200_gpio_base+0x10*bank
#define __SCx200_GPIO_SHADOW unsigned long *shadow = scx200_gpio_shadow+bank
#define __SCx200_GPIO_INDEX index &= 31

#define __SCx200_GPIO_OUT __asm__ __volatile__("outsl":"=mS" (shadow):"d" (ioaddr), "0" (shadow))

/* returns the value of the GPIO pin */

static inline int scx200_gpio_get(unsigned index) {
	__SCx200_GPIO_BANK;
	__SCx200_GPIO_IOADDR + 0x04;
	__SCx200_GPIO_INDEX;
		
	return (inl(ioaddr) & (1<<index)) ? 1 : 0;
}

/* return the value driven on the GPIO signal (the value that will be
   driven if the GPIO is configured as an output, it might not be the
   state of the GPIO right now if the GPIO is configured as an input) */

static inline int scx200_gpio_current(unsigned index) {
        __SCx200_GPIO_BANK;
	__SCx200_GPIO_INDEX;
		
	return (scx200_gpio_shadow[bank] & (1<<index)) ? 1 : 0;
}

/* drive the GPIO signal high */

static inline void scx200_gpio_set_high(unsigned index) {
	__SCx200_GPIO_BANK;
	__SCx200_GPIO_IOADDR;
	__SCx200_GPIO_SHADOW;
	__SCx200_GPIO_INDEX;
	set_bit(index, shadow);	/* __set_bit()? */
	__SCx200_GPIO_OUT;
}

/* drive the GPIO signal low */

static inline void scx200_gpio_set_low(unsigned index) {
	__SCx200_GPIO_BANK;
	__SCx200_GPIO_IOADDR;
	__SCx200_GPIO_SHADOW;
	__SCx200_GPIO_INDEX;
	clear_bit(index, shadow); /* __clear_bit()? */
	__SCx200_GPIO_OUT;
}

/* drive the GPIO signal to state */

static inline void scx200_gpio_set(unsigned index, int state) {
	__SCx200_GPIO_BANK;
	__SCx200_GPIO_IOADDR;
	__SCx200_GPIO_SHADOW;
	__SCx200_GPIO_INDEX;
	if (state)
		set_bit(index, shadow);
	else
		clear_bit(index, shadow);
	__SCx200_GPIO_OUT;
}

/* toggle the GPIO signal */
static inline void scx200_gpio_change(unsigned index) {
	__SCx200_GPIO_BANK;
	__SCx200_GPIO_IOADDR;
	__SCx200_GPIO_SHADOW;
	__SCx200_GPIO_INDEX;
	change_bit(index, shadow);
	__SCx200_GPIO_OUT;
}

#undef __SCx200_GPIO_BANK
#undef __SCx200_GPIO_IOADDR
#undef __SCx200_GPIO_SHADOW
#undef __SCx200_GPIO_INDEX
#undef __SCx200_GPIO_OUT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #ifndef _LINUX_SWAB_H
#define _LINUX_SWAB_H

#include <uapi/linux/swab.h>

# define swab16 __swab16
# define swab32 __swab32
# define swab64 __swab64
# define swahw32 __swahw32
# define swahb32 __swahb32
# define swab16p __swab16p
# define swab32p __swab32p
# define swab64p __swab64p
# define swahw32p __swahw32p
# define swahb32p __swahb32p
# define swab16s __swab16s
# define swab32s __swab32s
# define swab64s __swab64s
# define swahw32s __swahw32s
# define swahb32s __swahb32s
#endif /* _LINUX_SWAB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * tsacct_kern.h - kernel header for system accounting over taskstats interface
 *
 * Copyright (C) Jay Lan	SGI
 */

#ifndef _LINUX_TSACCT_KERN_H
#define _LINUX_TSACCT_KERN_H

#include <linux/taskstats.h>

#ifdef CONFIG_TASKSTATS
extern void bacct_add_tsk(struct user_namespace *user_ns,
			  struct pid_namespace *pid_ns,
			  struct taskstats *stats, struct task_struct *tsk);
#else
static inline void bacct_add_tsk(struct user_namespace *user_ns,
				 struct pid_namespace *pid_ns,
				 struct taskstats *stats, struct task_struct *tsk)
{}
#endif /* CONFIG_TASKSTATS */

#ifdef CONFIG_TASK_XACCT
extern void xacct_add_tsk(struct taskstats *stats, struct task_struct *p);
extern void acct_update_integrals(struct task_struct *tsk);
extern void acct_account_cputime(struct task_struct *tsk);
extern void acct_clear_integrals(struct task_struct *tsk);
#else
static inline void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)
{}
static inline void acct_update_integrals(struct task_struct *tsk)
{}
static inline void acct_account_cputime(struct task_struct *tsk)
{}
static inline void acct_clear_integrals(struct task_struct *tsk)
{}
#endif /* CONFIG_TASK_XACCT */

#endif


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * console_struct.h
 *
 * Data structure describing single virtual console except for data
 * used by vt.c.
 *
 * Fields marked with [#] must be set by the low-level driver.
 * Fields marked with [!] can be changed by the low-level driver
 * to achieve effects such as fast scrolling by changing the origin.
 */

#ifndef _LINUX_CONSOLE_STRUCT_H
#define _LINUX_CONSOLE_STRUCT_H

#include <linux/wait.h>
#include <linux/vt.h>
#include <linux/workqueue.h>

struct vt_struct;
struct uni_pagedir;

#define NPAR 16

struct vc_data {
	struct tty_port port;			/* Upper level data */

	unsigned short	vc_num;			/* Console number */
	unsigned int	vc_cols;		/* [#] Console size */
	unsigned int	vc_rows;
	unsigned int	vc_size_row;		/* Bytes per row */
	unsigned int	vc_scan_lines;		/* # of scan lines */
	unsigned long	vc_origin;		/* [!] Start of real screen */
	unsigned long	vc_scr_end;		/* [!] End of real screen */
	unsigned long	vc_visible_origin;	/* [!] Top of visible window */
	unsigned int	vc_top, vc_bottom;	/* Scrolling region */
	const struct consw *vc_sw;
	unsigned short	*vc_screenbuf;		/* In-memory character/attribute buffer */
	unsigned int	vc_screenbuf_size;
	unsigned char	vc_mode;		/* KD_TEXT, ... */
	/* attributes for all characters on screen */
	unsigned char	vc_attr;		/* Current attributes */
	unsigned char	vc_def_color;		/* Default colors */
	unsigned char	vc_color;		/* Foreground & background */
	unsigned char	vc_s_color;		/* Saved foreground & background */
	unsigned char	vc_ulcolor;		/* Color for underline mode */
	unsigned char   vc_itcolor;
	unsigned char	vc_halfcolor;		/* Color for half intensity mode */
	/* cursor */
	unsigned int	vc_cursor_type;
	unsigned short	vc_complement_mask;	/* [#] Xor mask for mouse pointer */
	unsigned short	vc_s_complement_mask;	/* Saved mouse pointer mask */
	unsigned int	vc_x, vc_y;		/* Cursor position */
	unsigned int	vc_saved_x, vc_saved_y;
	unsigned long	vc_pos;			/* Cursor address */
	/* fonts */	
	unsigned short	vc_hi_font_mask;	/* [#] Attribute set for upper 256 chars of font or 0 if not supported */
	struct console_font vc_font;		/* Current VC font set */
	unsigned short	vc_video_erase_char;	/* Background erase character */
	/* VT terminal data */
	unsigned int	vc_state;		/* Escape sequence parser state */
	unsigned int	vc_npar,vc_par[NPAR];	/* Parameters of current escape sequence */
	/* data for manual vt switching */
	struct vt_mode	vt_mode;
	struct pid 	*vt_pid;
	int		vt_newvt;
	wait_queue_head_t paste_wait;
	/* mode flags */
	unsigned int	vc_charset	: 1;	/* Character set G0 / G1 */
	unsigned int	vc_s_charset	: 1;	/* Saved character set */
	unsigned int	vc_disp_ctrl	: 1;	/* Display chars < 32? */
	unsigned int	vc_toggle_meta	: 1;	/* Toggle high bit? */
	unsigned int	vc_decscnm	: 1;	/* Screen Mode */
	unsigned int	vc_decom	: 1;	/* Origin Mode */
	unsigned int	vc_decawm	: 1;	/* Autowrap Mode */
	unsigned int	vc_deccm	: 1;	/* Cursor Visible */
	unsigned int	vc_decim	: 1;	/* Insert Mode */
	unsigned int	vc_deccolm	: 1;	/* 80/132 Column Mode */
	/* attribute flags */
	unsigned int	vc_intensity	: 2;	/* 0=half-bright, 1=normal, 2=bold */
	unsigned int    vc_italic:1;
	unsigned int	vc_underline	: 1;
	unsigned int	vc_blink	: 1;
	unsigned int	vc_reverse	: 1;
	unsigned int	vc_s_intensity	: 2;	/* saved rendition */
	unsigned int    vc_s_italic:1;
	unsigned int	vc_s_underline	: 1;
	unsigned int	vc_s_blink	: 1;
	unsigned int	vc_s_reverse	: 1;
	/* misc */
	unsigned int	vc_ques		: 1;
	unsigned int	vc_need_wrap	: 1;
	unsigned int	vc_can_do_color	: 1;
	unsigned int	vc_report_mouse : 2;
	unsigned char	vc_utf		: 1;	/* Unicode UTF-8 encoding */
	unsigned char	vc_utf_count;
		 int	vc_utf_char;
	unsigned int	vc_tab_stop[8];		/* Tab stops. 256 columns. */
	unsigned char   vc_palette[16*3];       /* Colour palette for VGA+ */
	unsigned short * vc_translate;
	unsigned char 	vc_G0_charset;
	unsigned char 	vc_G1_charset;
	unsigned char 	vc_saved_G0;
	unsigned char 	vc_saved_G1;
	unsigned int    vc_resize_user;         /* resize request from user */
	unsigned int	vc_bell_pitch;		/* Console bell pitch */
	unsigned int	vc_bell_duration;	/* Console bell duration */
	struct vc_data **vc_display_fg;		/* [!] Ptr to var holding fg console for this display */
	struct uni_pagedir *vc_uni_pagedir;
	struct uni_pagedir **vc_uni_pagedir_loc; /* [!] Location of uni_pagedir variable for this console */
	bool vc_panic_force_write; /* when oops/panic this VC can accept forced output/blanking */
	/* additional information is in vt_kern.h */
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;

	/* might add  scrmem, vt_struct, kbd  at some time,
	   to have everything in one place - the disadvantage
	   would be that vc_cons etc can no longer be static */
};

extern struct vc vc_cons [MAX_NR_CONSOLES];
extern void vc_SAK(struct work_struct *work);

#define CUR_DEF		0
#define CUR_NONE	1
#define CUR_UNDERLINE	2
#define CUR_LOWER_THIRD	3
#define CUR_LOWER_HALF	4
#define CUR_TWO_THIRDS	5
#define CUR_BLOCK	6
#define CUR_HWMASK	0x0f
#define CUR_SWMASK	0xfff0

#define CUR_DEFAULT CUR_UNDERLINE

#define CON_IS_VISIBLE(conp) (*conp->vc_display_fg == conp)

#endif /* _LINUX_CONSOLE_STRUCT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef _LINUX_TIME64_H
#define _LINUX_TIME64_H

#include <uapi/linux/time.h>

typedef __s64 time64_t;

/*
 * This wants to go into uapi/linux/time.h once we agreed about the
 * userspace interfaces.
 */
#if __BITS_PER_LONG == 64
# define timespec64 timespec
#else
struct timespec64 {
	time64_t	tv_sec;			/* seconds */
	long		tv_nsec;		/* nanoseconds */
};
#endif

/* Parameters used to convert the timespec values: */
#define MSEC_PER_SEC	1000L
#define USEC_PER_MSEC	1000L
#define NSEC_PER_USEC	1000L
#define NSEC_PER_MSEC	1000000L
#define USEC_PER_SEC	1000000L
#define NSEC_PER_SEC	1000000000L
#define FSEC_PER_SEC	1000000000000000LL

/* Located here for timespec[64]_valid_strict */
#define KTIME_MAX			((s64)~((u64)1 << 63))
#define KTIME_SEC_MAX			(KTIME_MAX / NSEC_PER_SEC)

#if __BITS_PER_LONG == 64

static inline struct timespec timespec64_to_timespec(const struct timespec64 ts64)
{
	return ts64;
}

static inline struct timespec64 timespec_to_timespec64(const struct timespec ts)
{
	return ts;
}

# define timespec64_equal		timespec_equal
# define timespec64_compare		timespec_compare
# define set_normalized_timespec64	set_normalized_timespec
# define timespec64_add_safe		timespec_add_safe
# define timespec64_add			timespec_add
# define timespec64_sub			timespec_sub
# define timespec64_valid		timespec_valid
# define timespec64_valid_strict	timespec_valid_strict
# define timespec64_to_ns		timespec_to_ns
# define ns_to_timespec64		ns_to_timespec
# define timespec64_add_ns		timespec_add_ns

#else

static inline struct timespec timespec64_to_timespec(const struct timespec64 ts64)
{
	struct timespec ret;

	ret.tv_sec = (time_t)ts64.tv_sec;
	ret.tv_nsec = ts64.tv_nsec;
	return ret;
}

static inline struct timespec64 timespec_to_timespec64(const struct timespec ts)
{
	struct timespec64 ret;

	ret.tv_sec = ts.tv_sec;
	ret.tv_nsec = ts.tv_nsec;
	return ret;
}

static inline int timespec64_equal(const struct timespec64 *a,
				   const struct timespec64 *b)
{
	return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
}

/*
 * lhs < rhs:  return <0
 * lhs == rhs: return 0
 * lhs > rhs:  return >0
 */
static inline int timespec64_compare(const struct timespec64 *lhs, const struct timespec64 *rhs)
{
	if (lhs->tv_sec < rhs->tv_sec)
		return -1;
	if (lhs->tv_sec > rhs->tv_sec)
		return 1;
	return lhs->tv_nsec - rhs->tv_nsec;
}

extern void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec);

/*
 * timespec64_add_safe assumes both values are positive and checks for
 * overflow. It will return TIME_T_MAX if the returned value would be
 * smaller then either of the arguments.
 */
extern struct timespec64 timespec64_add_safe(const struct timespec64 lhs,
					 const struct timespec64 rhs);


static inline struct timespec64 timespec64_add(struct timespec64 lhs,
						struct timespec64 rhs)
{
	struct timespec64 ts_delta;
	set_normalized_timespec64(&ts_delta, lhs.tv_sec + rhs.tv_sec,
				lhs.tv_nsec + rhs.tv_nsec);
	return ts_delta;
}

/*
 * sub = lhs - rhs, in normalized form
 */
static inline struct timespec64 timespec64_sub(struct timespec64 lhs,
						struct timespec64 rhs)
{
	struct timespec64 ts_delta;
	set_normalized_timespec64(&ts_delta, lhs.tv_sec - rhs.tv_sec,
				lhs.tv_nsec - rhs.tv_nsec);
	return ts_delta;
}

/*
 * Returns true if the timespec64 is norm, false if denorm:
 */
static inline bool timespec64_valid(const struct timespec64 *ts)
{
	/* Dates before 1970 are bogus */
	if (ts->tv_sec < 0)
		return false;
	/* Can't have more nanoseconds then a second */
	if ((unsigned long)ts->tv_nsec >= NSEC_PER_SEC)
		return false;
	return true;
}

static inline bool timespec64_valid_strict(const struct timespec64 *ts)
{
	if (!timespec64_valid(ts))
		return false;
	/* Disallow values that could overflow ktime_t */
	if ((unsigned long long)ts->tv_sec >= KTIME_SEC_MAX)
		return false;
	return true;
}

/**
 * timespec64_to_ns - Convert timespec64 to nanoseconds
 * @ts:		pointer to the timespec64 variable to be converted
 *
 * Returns the scalar nanosecond representation of the timespec64
 * parameter.
 */
static inline s64 timespec64_to_ns(const struct timespec64 *ts)
{
	return ((s64) ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec;
}

/**
 * ns_to_timespec64 - Convert nanoseconds to timespec64
 * @nsec:	the nanoseconds value to be converted
 *
 * Returns the timespec64 representation of the nsec parameter.
 */
extern struct timespec64 ns_to_timespec64(const s64 nsec);

/**
 * timespec64_add_ns - Adds nanoseconds to a timespec64
 * @a:		pointer to timespec64 to be incremented
 * @ns:		unsigned nanoseconds value to be added
 *
 * This must always be inlined because its used from the x86-64 vdso,
 * which cannot call other kernel functions.
 */
static __always_inline void timespec64_add_ns(struct timespec64 *a, u64 ns)
{
	a->tv_sec += __iter_div_u64_rem(a->tv_nsec + ns, NSEC_PER_SEC, &ns);
	a->tv_nsec = ns;
}

#endif

#endif /* _LINUX_TIME64_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #ifndef _LINUX_KERNEL_VTIME_H
#define _LINUX_KERNEL_VTIME_H

#include <linux/context_tracking_state.h>
#ifdef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE
#include <asm/vtime.h>
#endif


struct task_struct;

/*
 * vtime_accounting_enabled() definitions/declarations
 */
#ifdef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE
static inline bool vtime_accounting_enabled(void) { return true; }
#endif /* CONFIG_VIRT_CPU_ACCOUNTING_NATIVE */

#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
static inline bool vtime_accounting_enabled(void)
{
	if (context_tracking_is_enabled()) {
		if (context_tracking_cpu_is_enabled())
			return true;
	}

	return false;
}
#endif /* CONFIG_VIRT_CPU_ACCOUNTING_GEN */

#ifndef CONFIG_VIRT_CPU_ACCOUNTING
static inline bool vtime_accounting_enabled(void) { return false; }
#endif /* !CONFIG_VIRT_CPU_ACCOUNTING */


/*
 * Common vtime APIs
 */
#ifdef CONFIG_VIRT_CPU_ACCOUNTING

#ifdef __ARCH_HAS_VTIME_TASK_SWITCH
extern void vtime_task_switch(struct task_struct *prev);
#else
extern void vtime_common_task_switch(struct task_struct *prev);
static inline void vtime_task_switch(struct task_struct *prev)
{
	if (vtime_accounting_enabled())
		vtime_common_task_switch(prev);
}
#endif /* __ARCH_HAS_VTIME_TASK_SWITCH */

extern void vtime_account_system(struct task_struct *tsk);
extern void vtime_account_idle(struct task_struct *tsk);
extern void vtime_account_user(struct task_struct *tsk);

#ifdef __ARCH_HAS_VTIME_ACCOUNT
extern void vtime_account_irq_enter(struct task_struct *tsk);
#else
extern void vtime_common_account_irq_enter(struct task_struct *tsk);
static inline void vtime_account_irq_enter(struct task_struct *tsk)
{
	if (vtime_accounting_enabled())
		vtime_common_account_irq_enter(tsk);
}
#endif /* __ARCH_HAS_VTIME_ACCOUNT */

#else /* !CONFIG_VIRT_CPU_ACCOUNTING */

static inline void vtime_task_switch(struct task_struct *prev) { }
static inline void vtime_account_system(struct task_struct *tsk) { }
static inline void vtime_account_user(struct task_struct *tsk) { }
static inline void vtime_account_irq_enter(struct task_struct *tsk) { }
#endif /* !CONFIG_VIRT_CPU_ACCOUNTING */

#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
extern void arch_vtime_task_switch(struct task_struct *tsk);
extern void vtime_gen_account_irq_exit(struct task_struct *tsk);

static inline void vtime_account_irq_exit(struct task_struct *tsk)
{
	if (vtime_accounting_enabled())
		vtime_gen_account_irq_exit(tsk);
}

extern void vtime_user_enter(struct task_struct *tsk);

static inline void vtime_user_exit(struct task_struct *tsk)
{
	vtime_account_user(tsk);
}
extern void vtime_guest_enter(struct task_struct *tsk);
extern void vtime_guest_exit(struct task_struct *tsk);
extern void vtime_init_idle(struct task_struct *tsk, int cpu);
#else /* !CONFIG_VIRT_CPU_ACCOUNTING_GEN  */
static inline void vtime_account_irq_exit(struct task_struct *tsk)
{
	/* On hard|softirq exit we always account to hard|softirq cputime */
	vtime_account_system(tsk);
}
static inline void vtime_user_enter(struct task_struct *tsk) { }
static inline void vtime_user_exit(struct task_struct *tsk) { }
static inline void vtime_guest_enter(struct task_struct *tsk) { }
static inline void vtime_guest_exit(struct task_struct *tsk) { }
static inline void vtime_init_idle(struct task_struct *tsk, int cpu) { }
#endif

#ifdef CONFIG_IRQ_TIME_ACCOUNTING
extern void irqtime_account_irq(struct task_struct *tsk);
#else
static inline void irqtime_account_irq(struct task_struct *tsk) { }
#endif

static inline void account_irq_enter_time(struct task_struct *tsk)
{
	vtime_account_irq_enter(tsk);
	irqtime_account_irq(tsk);
}

static inline void account_irq_exit_time(struct task_struct *tsk)
{
	vtime_account_irq_exit(tsk);
	irqtime_account_irq(tsk);
}

#endif /* _LINUX_KERNEL_VTIME_H */
                                                                                                                                                                                                                                                                                                                                                              #ifndef LINUX_PREEMPT_MASK_H
#define LINUX_PREEMPT_MASK_H

#include <linux/preempt.h>

/*
 * We put the hardirq and softirq counter into the preemption
 * counter. The bitmask has the following meaning:
 *
 * - bits 0-7 are the preemption count (max preemption depth: 256)
 * - bits 8-15 are the softirq count (max # of softirqs: 256)
 *
 * The hardirq count could in theory be the same as the number of
 * interrupts in the system, but we run all interrupt handlers with
 * interrupts disabled, so we cannot have nesting interrupts. Though
 * there are a few palaeontologic drivers which reenable interrupts in
 * the handler, so we need more than one bit here.
 *
 * PREEMPT_MASK:	0x000000ff
 * SOFTIRQ_MASK:	0x0000ff00
 * HARDIRQ_MASK:	0x000f0000
 *     NMI_MASK:	0x00100000
 * PREEMPT_ACTIVE:	0x00200000
 */
#define PREEMPT_BITS	8
#define SOFTIRQ_BITS	8
#define HARDIRQ_BITS	4
#define NMI_BITS	1

#define PREEMPT_SHIFT	0
#define SOFTIRQ_SHIFT	(PREEMPT_SHIFT + PREEMPT_BITS)
#define HARDIRQ_SHIFT	(SOFTIRQ_SHIFT + SOFTIRQ_BITS)
#define NMI_SHIFT	(HARDIRQ_SHIFT + HARDIRQ_BITS)

#define __IRQ_MASK(x)	((1UL << (x))-1)

#define PREEMPT_MASK	(__IRQ_MASK(PREEMPT_BITS) << PREEMPT_SHIFT)
#define SOFTIRQ_MASK	(__IRQ_MASK(SOFTIRQ_BITS) << SOFTIRQ_SHIFT)
#define HARDIRQ_MASK	(__IRQ_MASK(HARDIRQ_BITS) << HARDIRQ_SHIFT)
#define NMI_MASK	(__IRQ_MASK(NMI_BITS)     << NMI_SHIFT)

#define PREEMPT_OFFSET	(1UL << PREEMPT_SHIFT)
#define SOFTIRQ_OFFSET	(1UL << SOFTIRQ_SHIFT)
#define HARDIRQ_OFFSET	(1UL << HARDIRQ_SHIFT)
#define NMI_OFFSET	(1UL << NMI_SHIFT)

#define SOFTIRQ_DISABLE_OFFSET	(2 * SOFTIRQ_OFFSET)

#define PREEMPT_ACTIVE_BITS	1
#define PREEMPT_ACTIVE_SHIFT	(NMI_SHIFT + NMI_BITS)
#define PREEMPT_ACTIVE	(__IRQ_MASK(PREEMPT_ACTIVE_BITS) << PREEMPT_ACTIVE_SHIFT)

#define hardirq_count()	(preempt_count() & HARDIRQ_MASK)
#define softirq_count()	(preempt_count() & SOFTIRQ_MASK)
#define irq_count()	(preempt_count() & (HARDIRQ_MASK | SOFTIRQ_MASK \
				 | NMI_MASK))

/*
 * Are we doing bottom half or hardware interrupt processing?
 * Are we in a softirq context? Interrupt context?
 * in_softirq - Are we currently processing softirq or have bh disabled?
 * in_serving_softirq - Are we currently processing softirq?
 */
#define in_irq()		(hardirq_count())
#define in_softirq()		(softirq_count())
#define in_interrupt()		(irq_count())
#define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)

/*
 * Are we in NMI context?
 */
#define in_nmi()	(preempt_count() & NMI_MASK)

/*
 * The preempt_count offset after preempt_disable();
 */
#if defined(CONFIG_PREEMPT_COUNT)
# define PREEMPT_DISABLE_OFFSET	PREEMPT_OFFSET
#else
# define PREEMPT_DISABLE_OFFSET	0
#endif

/*
 * The preempt_count offset after spin_lock()
 */
#define PREEMPT_LOCK_OFFSET	PREEMPT_DISABLE_OFFSET

/*
 * The preempt_count offset needed for things like:
 *
 *  spin_lock_bh()
 *
 * Which need to disable both preemption (CONFIG_PREEMPT_COUNT) and
 * softirqs, such that unlock sequences of:
 *
 *  spin_unlock();
 *  local_bh_enable();
 *
 * Work as expected.
 */
#define SOFTIRQ_LOCK_OFFSET (SOFTIRQ_DISABLE_OFFSET + PREEMPT_LOCK_OFFSET)

/*
 * Are we running in atomic context?  WARNING: this macro cannot
 * always detect atomic context; in particular, it cannot know about
 * held spinlocks in non-preemptible kernels.  Thus it should not be
 * used in the general case to determine whether sleeping is possible.
 * Do not use in_atomic() in driver code.
 */
#define in_atomic()	((preempt_count() & ~PREEMPT_ACTIVE) != 0)

/*
 * Check whether we were atomic before we did preempt_disable():
 * (used by the scheduler, *after* releasing the kernel lock)
 */
#define in_atomic_preempt_off() \
		((preempt_count() & ~PREEMPT_ACTIVE) != PREEMPT_DISABLE_OFFSET)

#ifdef CONFIG_PREEMPT_COUNT
# define preemptible()	(preempt_count() == 0 && !irqs_disabled())
#else
# define preemptible()	0
#endif

#endif /* LINUX_PREEMPT_MASK_H */
                                                                                                                                                                                            /* atm_tcp.h - Driver-specific declarations of the ATMTCP driver (for use by
	       driver-specific utilities) */

/* Written 1997-2000 by Werner Almesberger, EPFL LRC/ICA */

#ifndef LINUX_ATM_TCP_H
#define LINUX_ATM_TCP_H

#include <uapi/linux/atm_tcp.h>


struct atm_tcp_ops {
	int (*attach)(struct atm_vcc *vcc,int itf);
	int (*create_persistent)(int itf);
	int (*remove_persistent)(int itf);
	struct module *owner;
};

extern struct atm_tcp_ops atm_tcp_ops;

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef _LINUX_SORT_H
#define _LINUX_SORT_H

#include <linux/types.h>

void sort(void *base, size_t num, size_t size,
	  int (*cmp)(const void *, const void *),
	  void (*swap)(void *, void *, int));

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #ifndef _LINUX_HIGHMEM_H
#define _LINUX_HIGHMEM_H

#include <linux/fs.h>
#include <linux/kernel.h>
#include <linux/bug.h>
#include <linux/mm.h>
#include <linux/uaccess.h>
#include <linux/hardirq.h>

#include <asm/cacheflush.h>

#ifndef ARCH_HAS_FLUSH_ANON_PAGE
static inline void flush_anon_page(struct vm_area_struct *vma, struct page *page, unsigned long vmaddr)
{
}
#endif

#ifndef ARCH_HAS_FLUSH_KERNEL_DCACHE_PAGE
static inline void flush_kernel_dcache_page(struct page *page)
{
}
static inline void flush_kernel_vmap_range(void *vaddr, int size)
{
}
static inline void invalidate_kernel_vmap_range(void *vaddr, int size)
{
}
#endif

#include <asm/kmap_types.h>

#ifdef CONFIG_HIGHMEM
#include <asm/highmem.h>

/* declarations for linux/mm/highmem.c */
unsigned int nr_free_highpages(void);
extern unsigned long totalhigh_pages;

void kmap_flush_unused(void);

struct page *kmap_to_page(void *addr);

#else /* CONFIG_HIGHMEM */

static inline unsigned int nr_free_highpages(void) { return 0; }

static inline struct page *kmap_to_page(void *addr)
{
	return virt_to_page(addr);
}

#define totalhigh_pages 0UL

#ifndef ARCH_HAS_KMAP
static inline void *kmap(struct page *page)
{
	might_sleep();
	return page_address(page);
}

static inline void kunmap(struct page *page)
{
}

static inline void *kmap_atomic(struct page *page)
{
	pagefault_disable();
	return page_address(page);
}
#define kmap_atomic_prot(page, prot)	kmap_atomic(page)

static inline void __kunmap_atomic(void *addr)
{
	pagefault_enable();
}

#define kmap_atomic_pfn(pfn)	kmap_atomic(pfn_to_page(pfn))
#define kmap_atomic_to_page(ptr)	virt_to_page(ptr)

#define kmap_flush_unused()	do {} while(0)
#endif

#endif /* CONFIG_HIGHMEM */

#if defined(CONFIG_HIGHMEM) || defined(CONFIG_X86_32)

DECLARE_PER_CPU(int, __kmap_atomic_idx);

static inline int kmap_atomic_idx_push(void)
{
	int idx = __this_cpu_inc_return(__kmap_atomic_idx) - 1;

#ifdef CONFIG_DEBUG_HIGHMEM
	WARN_ON_ONCE(in_irq() && !irqs_disabled());
	BUG_ON(idx >= KM_TYPE_NR);
#endif
	return idx;
}

static inline int kmap_atomic_idx(void)
{
	return __this_cpu_read(__kmap_atomic_idx) - 1;
}

static inline void kmap_atomic_idx_pop(void)
{
#ifdef CONFIG_DEBUG_HIGHMEM
	int idx = __this_cpu_dec_return(__kmap_atomic_idx);

	BUG_ON(idx < 0);
#else
	__this_cpu_dec(__kmap_atomic_idx);
#endif
}

#endif

/*
 * Prevent people trying to call kunmap_atomic() as if it were kunmap()
 * kunmap_atomic() should get the return value of kmap_atomic, not the page.
 */
#define kunmap_atomic(addr)                                     \
do {                                                            \
	BUILD_BUG_ON(__same_type((addr), struct page *));       \
	__kunmap_atomic(addr);                                  \
} while (0)


/* when CONFIG_HIGHMEM is not set these will be plain clear/copy_page */
#ifndef clear_user_highpage
static inline void clear_user_highpage(struct page *page, unsigned long vaddr)
{
	void *addr = kmap_atomic(page);
	clear_user_page(addr, vaddr, page);
	kunmap_atomic(addr);
}
#endif

#ifndef __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
/**
 * __alloc_zeroed_user_highpage - Allocate a zeroed HIGHMEM page for a VMA with caller-specified movable GFP flags
 * @movableflags: The GFP flags related to the pages future ability to move like __GFP_MOVABLE
 * @vma: The VMA the page is to be allocated for
 * @vaddr: The virtual address the page will be inserted into
 *
 * This function will allocate a page for a VMA but the caller is expected
 * to specify via movableflags whether the page will be movable in the
 * future or not
 *
 * An architecture may override this function by defining
 * __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE and providing their own
 * implementation.
 */
static inline struct page *
__alloc_zeroed_user_highpage(gfp_t movableflags,
			struct vm_area_struct *vma,
			unsigned long vaddr)
{
	struct page *page = alloc_page_vma(GFP_HIGHUSER | movableflags,
			vma, vaddr);

	if (page)
		clear_user_highpage(page, vaddr);

	return page;
}
#endif

/**
 * alloc_zeroed_user_highpage_movable - Allocate a zeroed HIGHMEM page for a VMA that the caller knows can move
 * @vma: The VMA the page is to be allocated for
 * @vaddr: The virtual address the page will be inserted into
 *
 * This function will allocate a page for a VMA that the caller knows will
 * be able to migrate in the future using move_pages() or reclaimed
 */
static inline struct page *
alloc_zeroed_user_highpage_movable(struct vm_area_struct *vma,
					unsigned long vaddr)
{
	return __alloc_zeroed_user_highpage(__GFP_MOVABLE, vma, vaddr);
}

static inline void clear_highpage(struct page *page)
{
	void *kaddr = kmap_atomic(page);
	clear_page(kaddr);
	kunmap_atomic(kaddr);
}

static inline void zero_user_segments(struct page *page,
	unsigned start1, unsigned end1,
	unsigned start2, unsigned end2)
{
	void *kaddr = kmap_atomic(page);

	BUG_ON(end1 > PAGE_SIZE || end2 > PAGE_SIZE);

	if (end1 > start1)
		memset(kaddr + start1, 0, end1 - start1);

	if (end2 > start2)
		memset(kaddr + start2, 0, end2 - start2);

	kunmap_atomic(kaddr);
	flush_dcache_page(page);
}

static inline void zero_user_segment(struct page *page,
	unsigned start, unsigned end)
{
	zero_user_segments(page, start, end, 0, 0);
}

static inline void zero_user(struct page *page,
	unsigned start, unsigned size)
{
	zero_user_segments(page, start, start + size, 0, 0);
}

#ifndef __HAVE_ARCH_COPY_USER_HIGHPAGE

static inline void copy_user_highpage(struct page *to, struct page *from,
	unsigned long vaddr, struct vm_area_struct *vma)
{
	char *vfrom, *vto;

	vfrom = kmap_atomic(from);
	vto = kmap_atomic(to);
	copy_user_page(vto, vfrom, vaddr, to);
	kunmap_atomic(vto);
	kunmap_atomic(vfrom);
}

#endif

static inline void copy_highpage(struct page *to, struct page *from)
{
	char *vfrom, *vto;

	vfrom = kmap_atomic(from);
	vto = kmap_atomic(to);
	copy_page(vto, vfrom);
	kunmap_atomic(vto);
	kunmap_atomic(vfrom);
}

#endif /* _LINUX_HIGHMEM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * This header, excluding the #ifdef __KERNEL__ part, is BSD licensed so
 * anyone can use the definitions to implement compatible drivers/servers:
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of IBM nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (C) Red Hat, Inc., 2009, 2010, 2011
 * Copyright (C) Amit Shah <amit.shah@redhat.com>, 2009, 2010, 2011
 */
#ifndef _LINUX_VIRTIO_CONSOLE_H
#define _LINUX_VIRTIO_CONSOLE_H

#include <uapi/linux/virtio_console.h>

int __init virtio_cons_early_init(int (*put_chars)(u32, const char *, int));
#endif /* _LINUX_VIRTIO_CONSOLE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef _LINUX_TASK_WORK_H
#define _LINUX_TASK_WORK_H

#include <linux/list.h>
#include <linux/sched.h>

typedef void (*task_work_func_t)(struct callback_head *);

static inline void
init_task_work(struct callback_head *twork, task_work_func_t func)
{
	twork->func = func;
}

int task_work_add(struct task_struct *task, struct callback_head *twork, bool);
struct callback_head *task_work_cancel(struct task_struct *, task_work_func_t);
void task_work_run(void);

static inline void exit_task_work(struct task_struct *task)
{
	task_work_run();
}

#endif	/* _LINUX_TASK_WORK_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef __LZ4_H__
#define __LZ4_H__
/*
 * LZ4 Kernel Interface
 *
 * Copyright (C) 2013, LG Electronics, Kyungsik Lee <kyungsik.lee@lge.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#define LZ4_MEM_COMPRESS	(4096 * sizeof(unsigned char *))
#define LZ4HC_MEM_COMPRESS	(65538 * sizeof(unsigned char *))

/*
 * lz4_compressbound()
 * Provides the maximum size that LZ4 may output in a "worst case" scenario
 * (input data not compressible)
 */
static inline size_t lz4_compressbound(size_t isize)
{
	return isize + (isize / 255) + 16;
}

/*
 * lz4_compress()
 *	src     : source address of the original data
 *	src_len : size of the original data
 *	dst	: output buffer address of the compressed data
 *		This requires 'dst' of size LZ4_COMPRESSBOUND.
 *	dst_len : is the output size, which is returned after compress done
 *	workmem : address of the working memory.
 *		This requires 'workmem' of size LZ4_MEM_COMPRESS.
 *	return  : Success if return 0
 *		  Error if return (< 0)
 *	note :  Destination buffer and workmem must be already allocated with
 *		the defined size.
 */
int lz4_compress(const unsigned char *src, size_t src_len,
		unsigned char *dst, size_t *dst_len, void *wrkmem);

 /*
  * lz4hc_compress()
  *	 src	 : source address of the original data
  *	 src_len : size of the original data
  *	 dst	 : output buffer address of the compressed data
  *		This requires 'dst' of size LZ4_COMPRESSBOUND.
  *	 dst_len : is the output size, which is returned after compress done
  *	 workmem : address of the working memory.
  *		This requires 'workmem' of size LZ4HC_MEM_COMPRESS.
  *	 return  : Success if return 0
  *		   Error if return (< 0)
  *	 note :  Destination buffer and workmem must be already allocated with
  *		 the defined size.
  */
int lz4hc_compress(const unsigned char *src, size_t src_len,
		unsigned char *dst, size_t *dst_len, void *wrkmem);

/*
 * lz4_decompress()
 *	src     : source address of the compressed data
 *	src_len : is the input size, whcih is returned after decompress done
 *	dest	: output buffer address of the decompressed data
 *	actual_dest_len: is the size of uncompressed data, supposing it's known
 *	return  : Success if return 0
 *		  Error if return (< 0)
 *	note :  Destination buffer must be already allocated.
 *		slightly faster than lz4_decompress_unknownoutputsize()
 */
int lz4_decompress(const unsigned char *src, size_t *src_len,
		unsigned char *dest, size_t actual_dest_len);

/*
 * lz4_decompress_unknownoutputsize()
 *	src     : source address of the compressed data
 *	src_len : is the input size, therefore the compressed size
 *	dest	: output buffer address of the decompressed data
 *	dest_len: is the max size of the destination buffer, which is
 *			returned with actual size of decompressed data after
 *			decompress done
 *	return  : Success if return 0
 *		  Error if return (< 0)
 *	note :  Destination buffer must be already allocated.
 */
int lz4_decompress_unknownoutputsize(const unsigned char *src, size_t src_len,
		unsigned char *dest, size_t *dest_len);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #ifndef _LINUX_RAMFS_H
#define _LINUX_RAMFS_H

struct inode *ramfs_get_inode(struct super_block *sb, const struct inode *dir,
	 umode_t mode, dev_t dev);
extern struct dentry *ramfs_mount(struct file_system_type *fs_type,
	 int flags, const char *dev_name, void *data);

#ifdef CONFIG_MMU
static inline int
ramfs_nommu_expand_for_mapping(struct inode *inode, size_t newsize)
{
	return 0;
}
#else
extern int ramfs_nommu_expand_for_mapping(struct inode *inode, size_t newsize);
#endif

extern const struct file_operations ramfs_file_operations;
extern const struct vm_operations_struct generic_file_vm_ops;
extern int __init init_ramfs_fs(void);

int ramfs_fill_super(struct super_block *sb, void *data, int silent);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #ifndef LINUX_KMEMCHECK_H
#define LINUX_KMEMCHECK_H

#include <linux/mm_types.h>
#include <linux/types.h>

#ifdef CONFIG_KMEMCHECK
extern int kmemcheck_enabled;

/* The slab-related functions. */
void kmemcheck_alloc_shadow(struct page *page, int order, gfp_t flags, int node);
void kmemcheck_free_shadow(struct page *page, int order);
void kmemcheck_slab_alloc(struct kmem_cache *s, gfp_t gfpflags, void *object,
			  size_t size);
void kmemcheck_slab_free(struct kmem_cache *s, void *object, size_t size);

void kmemcheck_pagealloc_alloc(struct page *p, unsigned int order,
			       gfp_t gfpflags);

void kmemcheck_show_pages(struct page *p, unsigned int n);
void kmemcheck_hide_pages(struct page *p, unsigned int n);

bool kmemcheck_page_is_tracked(struct page *p);

void kmemcheck_mark_unallocated(void *address, unsigned int n);
void kmemcheck_mark_uninitialized(void *address, unsigned int n);
void kmemcheck_mark_initialized(void *address, unsigned int n);
void kmemcheck_mark_freed(void *address, unsigned int n);

void kmemcheck_mark_unallocated_pages(struct page *p, unsigned int n);
void kmemcheck_mark_uninitialized_pages(struct page *p, unsigned int n);
void kmemcheck_mark_initialized_pages(struct page *p, unsigned int n);

int kmemcheck_show_addr(unsigned long address);
int kmemcheck_hide_addr(unsigned long address);

bool kmemcheck_is_obj_initialized(unsigned long addr, size_t size);

/*
 * Bitfield annotations
 *
 * How to use: If you have a struct using bitfields, for example
 *
 *     struct a {
 *             int x:8, y:8;
 *     };
 *
 * then this should be rewritten as
 *
 *     struct a {
 *             kmemcheck_bitfield_begin(flags);
 *             int x:8, y:8;
 *             kmemcheck_bitfield_end(flags);
 *     };
 *
 * Now the "flags_begin" and "flags_end" members may be used to refer to the
 * beginning and end, respectively, of the bitfield (and things like
 * &x.flags_begin is allowed). As soon as the struct is allocated, the bit-
 * fields should be annotated:
 *
 *     struct a *a = kmalloc(sizeof(struct a), GFP_KERNEL);
 *     kmemcheck_annotate_bitfield(a, flags);
 */
#define kmemcheck_bitfield_begin(name)	\
	int name##_begin[0];

#define kmemcheck_bitfield_end(name)	\
	int name##_end[0];

#define kmemcheck_annotate_bitfield(ptr, name)				\
	do {								\
		int _n;							\
									\
		if (!ptr)						\
			break;						\
									\
		_n = (long) &((ptr)->name##_end)			\
			- (long) &((ptr)->name##_begin);		\
		BUILD_BUG_ON(_n < 0);					\
									\
		kmemcheck_mark_initialized(&((ptr)->name##_begin), _n);	\
	} while (0)

#define kmemcheck_annotate_variable(var)				\
	do {								\
		kmemcheck_mark_initialized(&(var), sizeof(var));	\
	} while (0)							\

#else
#define kmemcheck_enabled 0

static inline void
kmemcheck_alloc_shadow(struct page *page, int order, gfp_t flags, int node)
{
}

static inline void
kmemcheck_free_shadow(struct page *page, int order)
{
}

static inline void
kmemcheck_slab_alloc(struct kmem_cache *s, gfp_t gfpflags, void *object,
		     size_t size)
{
}

static inline void kmemcheck_slab_free(struct kmem_cache *s, void *object,
				       size_t size)
{
}

static inline void kmemcheck_pagealloc_alloc(struct page *p,
	unsigned int order, gfp_t gfpflags)
{
}

static inline bool kmemcheck_page_is_tracked(struct page *p)
{
	return false;
}

static inline void kmemcheck_mark_unallocated(void *address, unsigned int n)
{
}

static inline void kmemcheck_mark_uninitialized(void *address, unsigned int n)
{
}

static inline void kmemcheck_mark_initialized(void *address, unsigned int n)
{
}

static inline void kmemcheck_mark_freed(void *address, unsigned int n)
{
}

static inline void kmemcheck_mark_unallocated_pages(struct page *p,
						    unsigned int n)
{
}

static inline void kmemcheck_mark_uninitialized_pages(struct page *p,
						      unsigned int n)
{
}

static inline void kmemcheck_mark_initialized_pages(struct page *p,
						    unsigned int n)
{
}

static inline bool kmemcheck_is_obj_initialized(unsigned long addr, size_t size)
{
	return true;
}

#define kmemcheck_bitfield_begin(name)
#define kmemcheck_bitfield_end(name)
#define kmemcheck_annotate_bitfield(ptr, name)	\
	do {					\
	} while (0)

#define kmemcheck_annotate_variable(var)	\
	do {					\
	} while (0)

#endif /* CONFIG_KMEMCHECK */

#endif /* LINUX_KMEMCHECK_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef _LINUX_UCS2_STRING_H_
#define _LINUX_UCS2_STRING_H_

#include <linux/types.h>	/* for size_t */
#include <linux/stddef.h>	/* for NULL */

typedef u16 ucs2_char_t;

unsigned long ucs2_strnlen(const ucs2_char_t *s, size_t maxlength);
unsigned long ucs2_strlen(const ucs2_char_t *s);
unsigned long ucs2_strsize(const ucs2_char_t *data, unsigned long maxlength);
int ucs2_strncmp(const ucs2_char_t *a, const ucs2_char_t *b, size_t len);

#endif /* _LINUX_UCS2_STRING_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * include/linux/firmware-map.h:
 *  Copyright (C) 2008 SUSE LINUX Products GmbH
 *  by Bernhard Walle <bernhard.walle@gmx.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License v2.0 as published by
 * the Free Software Foundation
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */
#ifndef _LINUX_FIRMWARE_MAP_H
#define _LINUX_FIRMWARE_MAP_H

#include <linux/list.h>

/*
 * provide a dummy interface if CONFIG_FIRMWARE_MEMMAP is disabled
 */
#ifdef CONFIG_FIRMWARE_MEMMAP

int firmware_map_add_early(u64 start, u64 end, const char *type);
int firmware_map_add_hotplug(u64 start, u64 end, const char *type);
int firmware_map_remove(u64 start, u64 end, const char *type);

#else /* CONFIG_FIRMWARE_MEMMAP */

static inline int firmware_map_add_early(u64 start, u64 end, const char *type)
{
	return 0;
}

static inline int firmware_map_add_hotplug(u64 start, u64 end, const char *type)
{
	return 0;
}

static inline int firmware_map_remove(u64 start, u64 end, const char *type)
{
	return 0;
}

#endif /* CONFIG_FIRMWARE_MEMMAP */

#endif /* _LINUX_FIRMWARE_MAP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /* Miscellaneous definitions for VIA chipsets
   Currently used only by drivers/parport/parport_pc.c */

/* Values for SuperIO function select configuration register */
#define VIA_FUNCTION_PARPORT_SPP     0x00
#define VIA_FUNCTION_PARPORT_ECP     0x01
#define VIA_FUNCTION_PARPORT_EPP     0x02
#define VIA_FUNCTION_PARPORT_DISABLE 0x03
#define VIA_FUNCTION_PROBE           0xFF /* Special magic value to be used in code, not to be written into chip */

/* Bits for parallel port mode configuration register */
#define VIA_PARPORT_ECPEPP 0X20
#define VIA_PARPORT_BIDIR  0x80

/* VIA configuration registers */
#define VIA_CONFIG_INDEX 0x3F0
#define VIA_CONFIG_DATA  0x3F1

/* Mask for parallel port IRQ bits (in ISA PnP IRQ routing register 1) */
#define VIA_IRQCONTROL_PARALLEL 0xF0
/* Mask for parallel port DMA bits (in ISA PnP DMA routing register) */
#define VIA_DMACONTROL_PARALLEL 0x0C
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
#ifndef I7300_IDLE_H
#define I7300_IDLE_H

#include <linux/pci.h>

/*
 * I/O AT controls (PCI bus 0 device 8 function 0)
 * DIMM controls (PCI bus 0 device 16 function 1)
 */
#define IOAT_BUS 0
#define IOAT_DEVFN PCI_DEVFN(8, 0)
#define MEMCTL_BUS 0
#define MEMCTL_DEVFN PCI_DEVFN(16, 1)

struct fbd_ioat {
	unsigned int vendor;
	unsigned int ioat_dev;
	unsigned int enabled;
};

/*
 * The i5000 chip-set has the same hooks as the i7300
 * but it is not enabled by default and must be manually
 * manually enabled with "forceload=1" because it is
 * only lightly validated.
 */

static const struct fbd_ioat fbd_ioat_list[] = {
	{PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_IOAT_CNB, 1},
	{PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_IOAT, 0},
	{0, 0}
};

/* table of devices that work with this driver */
static const struct pci_device_id pci_tbl[] = {
	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_FBD_CNB) },
	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_5000_ERR) },
	{ } /* Terminating entry */
};

/* Check for known platforms with I/O-AT */
static inline int i7300_idle_platform_probe(struct pci_dev **fbd_dev,
						struct pci_dev **ioat_dev,
						int enable_all)
{
	int i;
	struct pci_dev *memdev, *dmadev;

	memdev = pci_get_bus_and_slot(MEMCTL_BUS, MEMCTL_DEVFN);
	if (!memdev)
		return -ENODEV;

	for (i = 0; pci_tbl[i].vendor != 0; i++) {
		if (memdev->vendor == pci_tbl[i].vendor &&
		    memdev->device == pci_tbl[i].device) {
			break;
		}
	}
	if (pci_tbl[i].vendor == 0)
		return -ENODEV;

	dmadev = pci_get_bus_and_slot(IOAT_BUS, IOAT_DEVFN);
	if (!dmadev)
		return -ENODEV;

	for (i = 0; fbd_ioat_list[i].vendor != 0; i++) {
		if (dmadev->vendor == fbd_ioat_list[i].vendor &&
		    dmadev->device == fbd_ioat_list[i].ioat_dev) {
			if (!(fbd_ioat_list[i].enabled || enable_all))
				continue;
			if (fbd_dev)
				*fbd_dev = memdev;
			if (ioat_dev)
				*ioat_dev = dmadev;

			return 0;
		}
	}
	return -ENODEV;
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef _LINUX_MEI_CL_BUS_H
#define _LINUX_MEI_CL_BUS_H

#include <linux/device.h>
#include <linux/uuid.h>
#include <linux/mod_devicetable.h>

struct mei_cl_device;

struct mei_cl_driver {
	struct device_driver driver;
	const char *name;

	const struct mei_cl_device_id *id_table;

	int (*probe)(struct mei_cl_device *dev,
		     const struct mei_cl_device_id *id);
	int (*remove)(struct mei_cl_device *dev);
};

int __mei_cl_driver_register(struct mei_cl_driver *driver,
				struct module *owner);
#define mei_cl_driver_register(driver)             \
	__mei_cl_driver_register(driver, THIS_MODULE)

void mei_cl_driver_unregister(struct mei_cl_driver *driver);

ssize_t mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length);
ssize_t  mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length);

typedef void (*mei_cl_event_cb_t)(struct mei_cl_device *device,
			       u32 events, void *context);
int mei_cl_register_event_cb(struct mei_cl_device *device,
			  mei_cl_event_cb_t read_cb, void *context);

#define MEI_CL_EVENT_RX 0
#define MEI_CL_EVENT_TX 1

void *mei_cl_get_drvdata(const struct mei_cl_device *device);
void mei_cl_set_drvdata(struct mei_cl_device *device, void *data);

int mei_cl_enable_device(struct mei_cl_device *device);
int mei_cl_disable_device(struct mei_cl_device *device);

#endif /* _LINUX_MEI_CL_BUS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * This file is part of wl12xx
 *
 * Copyright (C) 2009 Nokia Corporation
 *
 * Contact: Luciano Coelho <luciano.coelho@nokia.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */

#ifndef _LINUX_WL12XX_H
#define _LINUX_WL12XX_H

#include <linux/err.h>

struct wl1251_platform_data {
	int power_gpio;
	/* SDIO only: IRQ number if WLAN_IRQ line is used, 0 for SDIO IRQs */
	int irq;
	bool use_eeprom;
};

#ifdef CONFIG_WILINK_PLATFORM_DATA

int wl1251_set_platform_data(const struct wl1251_platform_data *data);

struct wl1251_platform_data *wl1251_get_platform_data(void);

#else

static inline
int wl1251_set_platform_data(const struct wl1251_platform_data *data)
{
	return -ENOSYS;
}

static inline
struct wl1251_platform_data *wl1251_get_platform_data(void)
{
	return ERR_PTR(-ENODATA);
}

#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef __LINUX_PARPORT_PC_H
#define __LINUX_PARPORT_PC_H

#include <asm/io.h>

/* --- register definitions ------------------------------- */

#define ECONTROL(p) ((p)->base_hi + 0x2)
#define CONFIGB(p)  ((p)->base_hi + 0x1)
#define CONFIGA(p)  ((p)->base_hi + 0x0)
#define FIFO(p)     ((p)->base_hi + 0x0)
#define EPPDATA(p)  ((p)->base    + 0x4)
#define EPPADDR(p)  ((p)->base    + 0x3)
#define CONTROL(p)  ((p)->base    + 0x2)
#define STATUS(p)   ((p)->base    + 0x1)
#define DATA(p)     ((p)->base    + 0x0)

struct parport_pc_private {
	/* Contents of CTR. */
	unsigned char ctr;

	/* Bitmask of writable CTR bits. */
	unsigned char ctr_writable;

	/* Whether or not there's an ECR. */
	int ecr;

	/* Number of PWords that FIFO will hold. */
	int fifo_depth;

	/* Number of bytes per portword. */
	int pword;

	/* Not used yet. */
	int readIntrThreshold;
	int writeIntrThreshold;

	/* buffer suitable for DMA, if DMA enabled */
	char *dma_buf;
	dma_addr_t dma_handle;
	struct list_head list;
	struct parport *port;
};

struct parport_pc_via_data
{
	/* ISA PnP IRQ routing register 1 */
	u8 via_pci_parport_irq_reg;
	/* ISA PnP DMA request routing register */
	u8 via_pci_parport_dma_reg;
	/* Register and value to enable SuperIO configuration access */
	u8 via_pci_superio_config_reg;
	u8 via_pci_superio_config_data;
	/* SuperIO function register number */
	u8 viacfg_function;
	/* parallel port control register number */
	u8 viacfg_parport_control;
	/* Parallel port base address register */
	u8 viacfg_parport_base;
};

static __inline__ void parport_pc_write_data(struct parport *p, unsigned char d)
{
#ifdef DEBUG_PARPORT
	printk (KERN_DEBUG "parport_pc_write_data(%p,0x%02x)\n", p, d);
#endif
	outb(d, DATA(p));
}

static __inline__ unsigned char parport_pc_read_data(struct parport *p)
{
	unsigned char val = inb (DATA (p));
#ifdef DEBUG_PARPORT
	printk (KERN_DEBUG "parport_pc_read_data(%p) = 0x%02x\n",
		p, val);
#endif
	return val;
}

#ifdef DEBUG_PARPORT
static inline void dump_parport_state (char *str, struct parport *p)
{
	/* here's hoping that reading these ports won't side-effect anything underneath */
	unsigned char ecr = inb (ECONTROL (p));
	unsigned char dcr = inb (CONTROL (p));
	unsigned char dsr = inb (STATUS (p));
	static const char *const ecr_modes[] = {"SPP", "PS2", "PPFIFO", "ECP", "xXx", "yYy", "TST", "CFG"};
	const struct parport_pc_private *priv = p->physport->private_data;
	int i;

	printk (KERN_DEBUG "*** parport state (%s): ecr=[%s", str, ecr_modes[(ecr & 0xe0) >> 5]);
	if (ecr & 0x10) printk (",nErrIntrEn");
	if (ecr & 0x08) printk (",dmaEn");
	if (ecr & 0x04) printk (",serviceIntr");
	if (ecr & 0x02) printk (",f_full");
	if (ecr & 0x01) printk (",f_empty");
	for (i=0; i<2; i++) {
		printk ("]  dcr(%s)=[", i ? "soft" : "hard");
		dcr = i ? priv->ctr : inb (CONTROL (p));
	
		if (dcr & 0x20) {
			printk ("rev");
		} else {
			printk ("fwd");
		}
		if (dcr & 0x10) printk (",ackIntEn");
		if (!(dcr & 0x08)) printk (",N-SELECT-IN");
		if (dcr & 0x04) printk (",N-INIT");
		if (!(dcr & 0x02)) printk (",N-AUTOFD");
		if (!(dcr & 0x01)) printk (",N-STROBE");
	}
	printk ("]  dsr=[");
	if (!(dsr & 0x80)) printk ("BUSY");
	if (dsr & 0x40) printk (",N-ACK");
	if (dsr & 0x20) printk (",PERROR");
	if (dsr & 0x10) printk (",SELECT");
	if (dsr & 0x08) printk (",N-FAULT");
	printk ("]\n");
	return;
}
#else	/* !DEBUG_PARPORT */
#define dump_parport_state(args...)
#endif	/* !DEBUG_PARPORT */

/* __parport_pc_frob_control differs from parport_pc_frob_control in that
 * it doesn't do any extra masking. */
static __inline__ unsigned char __parport_pc_frob_control (struct parport *p,
							   unsigned char mask,
							   unsigned char val)
{
	struct parport_pc_private *priv = p->physport->private_data;
	unsigned char ctr = priv->ctr;
#ifdef DEBUG_PARPORT
	printk (KERN_DEBUG
		"__parport_pc_frob_control(%02x,%02x): %02x -> %02x\n",
		mask, val, ctr, ((ctr & ~mask) ^ val) & priv->ctr_writable);
#endif
	ctr = (ctr & ~mask) ^ val;
	ctr &= priv->ctr_writable; /* only write writable bits. */
	outb (ctr, CONTROL (p));
	priv->ctr = ctr;	/* Update soft copy */
	return ctr;
}

static __inline__ void parport_pc_data_reverse (struct parport *p)
{
	__parport_pc_frob_control (p, 0x20, 0x20);
}

static __inline__ void parport_pc_data_forward (struct parport *p)
{
	__parport_pc_frob_control (p, 0x20, 0x00);
}

static __inline__ void parport_pc_write_control (struct parport *p,
						 unsigned char d)
{
	const unsigned char wm = (PARPORT_CONTROL_STROBE |
				  PARPORT_CONTROL_AUTOFD |
				  PARPORT_CONTROL_INIT |
				  PARPORT_CONTROL_SELECT);

	/* Take this out when drivers have adapted to newer interface. */
	if (d & 0x20) {
		printk (KERN_DEBUG "%s (%s): use data_reverse for this!\n",
			p->name, p->cad->name);
		parport_pc_data_reverse (p);
	}

	__parport_pc_frob_control (p, wm, d & wm);
}

static __inline__ unsigned char parport_pc_read_control(struct parport *p)
{
	const unsigned char rm = (PARPORT_CONTROL_STROBE |
				  PARPORT_CONTROL_AUTOFD |
				  PARPORT_CONTROL_INIT |
				  PARPORT_CONTROL_SELECT);
	const struct parport_pc_private *priv = p->physport->private_data;
	return priv->ctr & rm; /* Use soft copy */
}

static __inline__ unsigned char parport_pc_frob_control (struct parport *p,
							 unsigned char mask,
							 unsigned char val)
{
	const unsigned char wm = (PARPORT_CONTROL_STROBE |
				  PARPORT_CONTROL_AUTOFD |
				  PARPORT_CONTROL_INIT |
				  PARPORT_CONTROL_SELECT);

	/* Take this out when drivers have adapted to newer interface. */
	if (mask & 0x20) {
		printk (KERN_DEBUG "%s (%s): use data_%s for this!\n",
			p->name, p->cad->name,
			(val & 0x20) ? "reverse" : "forward");
		if (val & 0x20)
			parport_pc_data_reverse (p);
		else
			parport_pc_data_forward (p);
	}

	/* Restrict mask and val to control lines. */
	mask &= wm;
	val &= wm;

	return __parport_pc_frob_control (p, mask, val);
}

static __inline__ unsigned char parport_pc_read_status(struct parport *p)
{
	return inb(STATUS(p));
}


static __inline__ void parport_pc_disable_irq(struct parport *p)
{
	__parport_pc_frob_control (p, 0x10, 0x00);
}

static __inline__ void parport_pc_enable_irq(struct parport *p)
{
	__parport_pc_frob_control (p, 0x10, 0x10);
}

extern void parport_pc_release_resources(struct parport *p);

extern int parport_pc_claim_resources(struct parport *p);

/* PCMCIA code will want to get us to look at a port.  Provide a mechanism. */
extern struct parport *parport_pc_probe_port(unsigned long base,
					     unsigned long base_hi,
					     int irq, int dma,
					     struct device *dev,
					     int irqflags);
extern void parport_pc_unregister_port(struct parport *p);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * HID Sensors Driver
 * Copyright (c) 2012, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */
#ifndef _HID_SENSORS_IDS_H
#define _HID_SENSORS_IDS_H

#define HID_MAX_PHY_DEVICES					0xFF

#define HID_USAGE_SENSOR_COLLECTION				0x200001

/* Accel 3D (200073) */
#define HID_USAGE_SENSOR_ACCEL_3D				0x200073
#define HID_USAGE_SENSOR_DATA_ACCELERATION			0x200452
#define HID_USAGE_SENSOR_ACCEL_X_AXIS				0x200453
#define HID_USAGE_SENSOR_ACCEL_Y_AXIS				0x200454
#define HID_USAGE_SENSOR_ACCEL_Z_AXIS				0x200455

/* ALS (200041) */
#define HID_USAGE_SENSOR_ALS					0x200041
#define HID_USAGE_SENSOR_DATA_LIGHT				0x2004d0
#define HID_USAGE_SENSOR_LIGHT_ILLUM				0x2004d1

/* PROX (200011) */
#define HID_USAGE_SENSOR_PROX                                   0x200011
#define HID_USAGE_SENSOR_DATA_PRESENCE                          0x2004b0
#define HID_USAGE_SENSOR_HUMAN_PRESENCE                         0x2004b1

/* Pressure (200031) */
#define HID_USAGE_SENSOR_PRESSURE                               0x200031
#define HID_USAGE_SENSOR_DATA_ATMOSPHERIC_PRESSURE              0x200430
#define HID_USAGE_SENSOR_ATMOSPHERIC_PRESSURE                   0x200431

/* Gyro 3D: (200076) */
#define HID_USAGE_SENSOR_GYRO_3D				0x200076
#define HID_USAGE_SENSOR_DATA_ANGL_VELOCITY			0x200456
#define HID_USAGE_SENSOR_ANGL_VELOCITY_X_AXIS			0x200457
#define HID_USAGE_SENSOR_ANGL_VELOCITY_Y_AXIS			0x200458
#define HID_USAGE_SENSOR_ANGL_VELOCITY_Z_AXIS			0x200459

/* ORIENTATION: Compass 3D: (200083) */
#define HID_USAGE_SENSOR_COMPASS_3D				0x200083
#define HID_USAGE_SENSOR_DATA_ORIENTATION			0x200470
#define HID_USAGE_SENSOR_ORIENT_MAGN_HEADING			0x200471
#define HID_USAGE_SENSOR_ORIENT_MAGN_HEADING_X			0x200472
#define HID_USAGE_SENSOR_ORIENT_MAGN_HEADING_Y			0x200473
#define HID_USAGE_SENSOR_ORIENT_MAGN_HEADING_Z			0x200474

#define HID_USAGE_SENSOR_ORIENT_COMP_MAGN_NORTH			0x200475
#define HID_USAGE_SENSOR_ORIENT_COMP_TRUE_NORTH			0x200476
#define HID_USAGE_SENSOR_ORIENT_MAGN_NORTH			0x200477
#define HID_USAGE_SENSOR_ORIENT_TRUE_NORTH			0x200478

#define HID_USAGE_SENSOR_ORIENT_DISTANCE			0x200479
#define HID_USAGE_SENSOR_ORIENT_DISTANCE_X			0x20047A
#define HID_USAGE_SENSOR_ORIENT_DISTANCE_Y			0x20047B
#define HID_USAGE_SENSOR_ORIENT_DISTANCE_Z			0x20047C
#define HID_USAGE_SENSOR_ORIENT_DISTANCE_OUT_OF_RANGE		0x20047D

/* ORIENTATION: Inclinometer 3D: (200086) */
#define HID_USAGE_SENSOR_INCLINOMETER_3D			0x200086
#define HID_USAGE_SENSOR_ORIENT_TILT				0x20047E
#define HID_USAGE_SENSOR_ORIENT_TILT_X				0x20047F
#define HID_USAGE_SENSOR_ORIENT_TILT_Y				0x200480
#define HID_USAGE_SENSOR_ORIENT_TILT_Z				0x200481

#define HID_USAGE_SENSOR_DEVICE_ORIENTATION			0x20008A
#define HID_USAGE_SENSOR_ORIENT_ROTATION_MATRIX			0x200482
#define HID_USAGE_SENSOR_ORIENT_QUATERNION			0x200483
#define HID_USAGE_SENSOR_ORIENT_MAGN_FLUX			0x200484

#define HID_USAGE_SENSOR_ORIENT_MAGN_FLUX_X_AXIS		0x200485
#define HID_USAGE_SENSOR_ORIENT_MAGN_FLUX_Y_AXIS		0x200486
#define HID_USAGE_SENSOR_ORIENT_MAGN_FLUX_Z_AXIS		0x200487

/* Time (2000a0) */
#define HID_USAGE_SENSOR_TIME					0x2000a0
#define HID_USAGE_SENSOR_TIME_YEAR				0x200521
#define HID_USAGE_SENSOR_TIME_MONTH				0x200522
#define HID_USAGE_SENSOR_TIME_DAY				0x200523
#define HID_USAGE_SENSOR_TIME_HOUR				0x200525
#define HID_USAGE_SENSOR_TIME_MINUTE				0x200526
#define HID_USAGE_SENSOR_TIME_SECOND				0x200527

/* Units */
#define HID_USAGE_SENSOR_UNITS_NOT_SPECIFIED			0x00
#define HID_USAGE_SENSOR_UNITS_LUX				0x01
#define HID_USAGE_SENSOR_UNITS_KELVIN				0x01000100
#define HID_USAGE_SENSOR_UNITS_FAHRENHEIT			0x03000100
#define HID_USAGE_SENSOR_UNITS_PASCAL				0xF1E1
#define HID_USAGE_SENSOR_UNITS_NEWTON				0x11E1
#define HID_USAGE_SENSOR_UNITS_METERS_PER_SECOND		0x11F0
#define HID_USAGE_SENSOR_UNITS_METERS_PER_SEC_SQRD		0x11E0
#define HID_USAGE_SENSOR_UNITS_FARAD				0xE14F2000
#define HID_USAGE_SENSOR_UNITS_AMPERE				0x01001000
#define HID_USAGE_SENSOR_UNITS_WATT				0x21d1
#define HID_USAGE_SENSOR_UNITS_HENRY				0x21E1E000
#define HID_USAGE_SENSOR_UNITS_OHM				0x21D1E000
#define HID_USAGE_SENSOR_UNITS_VOLT				0x21D1F000
#define HID_USAGE_SENSOR_UNITS_HERTZ				0x01F0
#define HID_USAGE_SENSOR_UNITS_DEGREES_PER_SEC_SQRD		0x14E0
#define HID_USAGE_SENSOR_UNITS_RADIANS				0x12
#define HID_USAGE_SENSOR_UNITS_RADIANS_PER_SECOND		0x12F0
#define HID_USAGE_SENSOR_UNITS_RADIANS_PER_SEC_SQRD		0x12E0
#define HID_USAGE_SENSOR_UNITS_SECOND				0x0110
#define HID_USAGE_SENSOR_UNITS_GAUSS				0x01E1F000
#define HID_USAGE_SENSOR_UNITS_GRAM				0x0101
#define HID_USAGE_SENSOR_UNITS_CENTIMETER			0x11
#define HID_USAGE_SENSOR_UNITS_G				0x1A
#define HID_USAGE_SENSOR_UNITS_MILLISECOND			0x19
#define HID_USAGE_SENSOR_UNITS_PERCENT				0x17
#define HID_USAGE_SENSOR_UNITS_DEGREES				0x14
#define HID_USAGE_SENSOR_UNITS_DEGREES_PER_SECOND		0x15

/* Common selectors */
#define HID_USAGE_SENSOR_PROP_REPORT_INTERVAL			0x20030E
#define HID_USAGE_SENSOR_PROP_SENSITIVITY_ABS			0x20030F
#define HID_USAGE_SENSOR_PROP_SENSITIVITY_RANGE_PCT		0x200310
#define HID_USAGE_SENSOR_PROP_SENSITIVITY_REL_PCT		0x200311
#define HID_USAGE_SENSOR_PROP_ACCURACY				0x200312
#define HID_USAGE_SENSOR_PROP_RESOLUTION			0x200313
#define HID_USAGE_SENSOR_PROP_RANGE_MAXIMUM			0x200314
#define HID_USAGE_SENSOR_PROP_RANGE_MINIMUM			0x200315
#define HID_USAGE_SENSOR_PROP_REPORT_STATE			0x200316
#define HID_USAGE_SENSOR_PROY_POWER_STATE			0x200319

/* Per data field properties */
#define HID_USAGE_SENSOR_DATA_MOD_NONE					0x00
#define HID_USAGE_SENSOR_DATA_MOD_CHANGE_SENSITIVITY_ABS		0x1000

/* Power state enumerations */
#define HID_USAGE_SENSOR_PROP_POWER_STATE_UNDEFINED_ENUM	0x200850
#define HID_USAGE_SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM	0x200851
#define HID_USAGE_SENSOR_PROP_POWER_STATE_D1_LOW_POWER_ENUM	0x200852
#define HID_USAGE_SENSOR_PROP_POWER_STATE_D2_STANDBY_WITH_WAKE_ENUM 0x200853
#define HID_USAGE_SENSOR_PROP_POWER_STATE_D3_SLEEP_WITH_WAKE_ENUM 0x200854
#define HID_USAGE_SENSOR_PROP_POWER_STATE_D4_POWER_OFF_ENUM	0x200855

/* Report State enumerations */
#define HID_USAGE_SENSOR_PROP_REPORTING_STATE_NO_EVENTS_ENUM	0x200840
#define HID_USAGE_SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM	0x200841

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * linux/include/kmsg_dump.h
 *
 * Copyright (C) 2009 Net Insight AB
 *
 * Author: Simon Kagstrom <simon.kagstrom@netinsight.net>
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive
 * for more details.
 */
#ifndef _LINUX_KMSG_DUMP_H
#define _LINUX_KMSG_DUMP_H

#include <linux/errno.h>
#include <linux/list.h>

/*
 * Keep this list arranged in rough order of priority. Anything listed after
 * KMSG_DUMP_OOPS will not be logged by default unless printk.always_kmsg_dump
 * is passed to the kernel.
 */
enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF,
	KMSG_DUMP_PANIC,
	KMSG_DUMP_OOPS,
	KMSG_DUMP_EMERG,
	KMSG_DUMP_RESTART,
	KMSG_DUMP_HALT,
	KMSG_DUMP_POWEROFF,
};

/**
 * struct kmsg_dumper - kernel crash message dumper structure
 * @list:	Entry in the dumper list (private)
 * @dump:	Call into dumping code which will retrieve the data with
 * 		through the record iterator
 * @max_reason:	filter for highest reason number that should be dumped
 * @registered:	Flag that specifies if this is already registered
 */
struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *dumper, enum kmsg_dump_reason reason);
	enum kmsg_dump_reason max_reason;
	bool active;
	bool registered;

	/* private state of the kmsg iterator */
	u32 cur_idx;
	u32 next_idx;
	u64 cur_seq;
	u64 next_seq;
};

#ifdef CONFIG_PRINTK
void kmsg_dump(enum kmsg_dump_reason reason);

bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
			       char *line, size_t size, size_t *len);

bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
			char *line, size_t size, size_t *len);

bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
			  char *buf, size_t size, size_t *len);

void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper);

void kmsg_dump_rewind(struct kmsg_dumper *dumper);

int kmsg_dump_register(struct kmsg_dumper *dumper);

int kmsg_dump_unregister(struct kmsg_dumper *dumper);
#else
static inline void kmsg_dump(enum kmsg_dump_reason reason)
{
}

static inline bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper,
					     bool syslog, const char *line,
					     size_t size, size_t *len)
{
	return false;
}

static inline bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
				const char *line, size_t size, size_t *len)
{
	return false;
}

static inline bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
					char *buf, size_t size, size_t *len)
{
	return false;
}

static inline void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)
{
}

static inline void kmsg_dump_rewind(struct kmsg_dumper *dumper)
{
}

static inline int kmsg_dump_register(struct kmsg_dumper *dumper)
{
	return -EINVAL;
}

static inline int kmsg_dump_unregister(struct kmsg_dumper *dumper)
{
	return -EINVAL;
}
#endif

#endif /* _LINUX_KMSG_DUMP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Interface to the libusual.
 *
 * Copyright (c) 2005 Pete Zaitcev <zaitcev@redhat.com>
 * Copyright (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
 * Copyright (c) 1999 Michael Gee (michael@linuxspecific.com)
 */

#ifndef __LINUX_USB_USUAL_H
#define __LINUX_USB_USUAL_H


/* We should do this for cleanliness... But other usb_foo.h do not do this. */
/* #include <linux/usb.h> */

/*
 * The flags field, which we store in usb_device_id.driver_info.
 * It is compatible with the old usb-storage flags in lower 24 bits.
 */

/*
 * Static flag definitions.  We use this roundabout technique so that the
 * proc_info() routine can automatically display a message for each flag.
 */
#define US_DO_ALL_FLAGS						\
	US_FLAG(SINGLE_LUN,	0x00000001)			\
		/* allow access to only LUN 0 */		\
	US_FLAG(NEED_OVERRIDE,	0x00000002)			\
		/* unusual_devs entry is necessary */		\
	US_FLAG(SCM_MULT_TARG,	0x00000004)			\
		/* supports multiple targets */			\
	US_FLAG(FIX_INQUIRY,	0x00000008)			\
		/* INQUIRY response needs faking */		\
	US_FLAG(FIX_CAPACITY,	0x00000010)			\
		/* READ CAPACITY response too big */		\
	US_FLAG(IGNORE_RESIDUE,	0x00000020)			\
		/* reported residue is wrong */			\
	US_FLAG(BULK32,		0x00000040)			\
		/* Uses 32-byte CBW length */			\
	US_FLAG(NOT_LOCKABLE,	0x00000080)			\
		/* PREVENT/ALLOW not supported */		\
	US_FLAG(GO_SLOW,	0x00000100)			\
		/* Need delay after Command phase */		\
	US_FLAG(NO_WP_DETECT,	0x00000200)			\
		/* Don't check for write-protect */		\
	US_FLAG(MAX_SECTORS_64,	0x00000400)			\
		/* Sets max_sectors to 64    */			\
	US_FLAG(IGNORE_DEVICE,	0x00000800)			\
		/* Don't claim device */			\
	US_FLAG(CAPACITY_HEURISTICS,	0x00001000)		\
		/* sometimes sizes is too big */		\
	US_FLAG(MAX_SECTORS_MIN,0x00002000)			\
		/* Sets max_sectors to arch min */		\
	US_FLAG(BULK_IGNORE_TAG,0x00004000)			\
		/* Ignore tag mismatch in bulk operations */    \
	US_FLAG(SANE_SENSE,     0x00008000)			\
		/* Sane Sense (> 18 bytes) */			\
	US_FLAG(CAPACITY_OK,	0x00010000)			\
		/* READ CAPACITY response is correct */		\
	US_FLAG(BAD_SENSE,	0x00020000)			\
		/* Bad Sense (never more than 18 bytes) */	\
	US_FLAG(NO_READ_DISC_INFO,	0x00040000)		\
		/* cannot handle READ_DISC_INFO */		\
	US_FLAG(NO_READ_CAPACITY_16,	0x00080000)		\
		/* cannot handle READ_CAPACITY_16 */		\
	US_FLAG(INITIAL_READ10,	0x00100000)			\
		/* Initial READ(10) (and others) must be retried */	\
	US_FLAG(WRITE_CACHE,	0x00200000)			\
		/* Write Cache status is not available */	\
	US_FLAG(NEEDS_CAP16,	0x00400000)			\
		/* cannot handle READ_CAPACITY_10 */		\
	US_FLAG(IGNORE_UAS,	0x00800000)			\
		/* Device advertises UAS but it is broken */	\
	US_FLAG(BROKEN_FUA,	0x01000000)			\
		/* Cannot handle FUA in WRITE or READ CDBs */	\
	US_FLAG(NO_ATA_1X,	0x02000000)			\
		/* Cannot handle ATA_12 or ATA_16 CDBs */	\
	US_FLAG(NO_REPORT_OPCODES,	0x04000000)		\
		/* Cannot handle MI_REPORT_SUPPORTED_OPERATION_CODES */	\
	US_FLAG(MAX_SECTORS_240,	0x08000000)		\
		/* Sets max_sectors to 240 */			\

#define US_FLAG(name, value)	US_FL_##name = value ,
enum { US_DO_ALL_FLAGS };
#undef US_FLAG

#include <linux/usb/storage.h>

extern int usb_usual_ignore_device(struct usb_interface *intf);
extern struct usb_device_id usb_storage_usb_ids[];

#endif /* __LINUX_USB_USUAL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * kobj_map.h
 */

#ifndef _KOBJ_MAP_H_
#define _KOBJ_MAP_H_

#include <linux/mutex.h>

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);
struct kobj_map;

int kobj_map(struct kobj_map *, dev_t, unsigned long, struct module *,
	     kobj_probe_t *, int (*)(dev_t, void *), void *);
void kobj_unmap(struct kobj_map *, dev_t, unsigned long);
struct kobject *kobj_lookup(struct kobj_map *, dev_t, int *);
struct kobj_map *kobj_map_init(kobj_probe_t *, struct mutex *);

#endif /* _KOBJ_MAP_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * Copyright (C) 2010 Marco Stornelli <marco.stornelli@gmail.com>
 * Copyright (C) 2011 Kees Cook <keescook@chromium.org>
 * Copyright (C) 2011 Google, Inc.
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#ifndef __LINUX_PSTORE_RAM_H__
#define __LINUX_PSTORE_RAM_H__

#include <linux/device.h>
#include <linux/kernel.h>
#include <linux/list.h>
#include <linux/types.h>
#include <linux/init.h>

struct persistent_ram_buffer;
struct rs_control;

struct persistent_ram_ecc_info {
	int block_size;
	int ecc_size;
	int symsize;
	int poly;
};

struct persistent_ram_zone {
	phys_addr_t paddr;
	size_t size;
	void *vaddr;
	struct persistent_ram_buffer *buffer;
	size_t buffer_size;

	/* ECC correction */
	char *par_buffer;
	char *par_header;
	struct rs_control *rs_decoder;
	int corrected_bytes;
	int bad_blocks;
	struct persistent_ram_ecc_info ecc_info;

	char *old_log;
	size_t old_log_size;
};

struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,
			u32 sig, struct persistent_ram_ecc_info *ecc_info,
			unsigned int memtype);
void persistent_ram_free(struct persistent_ram_zone *prz);
void persistent_ram_zap(struct persistent_ram_zone *prz);

int persistent_ram_write(struct persistent_ram_zone *prz, const void *s,
	unsigned int count);

void persistent_ram_save_old(struct persistent_ram_zone *prz);
size_t persistent_ram_old_size(struct persistent_ram_zone *prz);
void *persistent_ram_old(struct persistent_ram_zone *prz);
void persistent_ram_free_old(struct persistent_ram_zone *prz);
ssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,
	char *str, size_t len);

/*
 * Ramoops platform data
 * @mem_size	memory size for ramoops
 * @mem_address	physical memory address to contain ramoops
 */

struct ramoops_platform_data {
	unsigned long	mem_size;
	unsigned long	mem_address;
	unsigned int	mem_type;
	unsigned long	record_size;
	unsigned long	console_size;
	unsigned long	ftrace_size;
	unsigned long	pmsg_size;
	int		dump_oops;
	struct persistent_ram_ecc_info ecc_info;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /* IPv4-specific defines for netfilter. 
 * (C)1998 Rusty Russell -- This code is GPL.
 */
#ifndef __LINUX_IP_NETFILTER_H
#define __LINUX_IP_NETFILTER_H

#include <uapi/linux/netfilter_ipv4.h>

int ip_route_me_harder(struct sk_buff *skb, unsigned addr_type);
__sum16 nf_ip_checksum(struct sk_buff *skb, unsigned int hook,
		       unsigned int dataoff, u_int8_t protocol);
#endif /*__LINUX_IP_NETFILTER_H*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #include <asm/user.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef __LINUX_BITMAP_H
#define __LINUX_BITMAP_H

#ifndef __ASSEMBLY__

#include <linux/types.h>
#include <linux/bitops.h>
#include <linux/string.h>
#include <linux/kernel.h>

/*
 * bitmaps provide bit arrays that consume one or more unsigned
 * longs.  The bitmap interface and available operations are listed
 * here, in bitmap.h
 *
 * Function implementations generic to all architectures are in
 * lib/bitmap.c.  Functions implementations that are architecture
 * specific are in various include/asm-<arch>/bitops.h headers
 * and other arch/<arch> specific files.
 *
 * See lib/bitmap.c for more details.
 */

/*
 * The available bitmap operations and their rough meaning in the
 * case that the bitmap is a single unsigned long are thus:
 *
 * Note that nbits should be always a compile time evaluable constant.
 * Otherwise many inlines will generate horrible code.
 *
 * bitmap_zero(dst, nbits)			*dst = 0UL
 * bitmap_fill(dst, nbits)			*dst = ~0UL
 * bitmap_copy(dst, src, nbits)			*dst = *src
 * bitmap_and(dst, src1, src2, nbits)		*dst = *src1 & *src2
 * bitmap_or(dst, src1, src2, nbits)		*dst = *src1 | *src2
 * bitmap_xor(dst, src1, src2, nbits)		*dst = *src1 ^ *src2
 * bitmap_andnot(dst, src1, src2, nbits)	*dst = *src1 & ~(*src2)
 * bitmap_complement(dst, src, nbits)		*dst = ~(*src)
 * bitmap_equal(src1, src2, nbits)		Are *src1 and *src2 equal?
 * bitmap_intersects(src1, src2, nbits) 	Do *src1 and *src2 overlap?
 * bitmap_subset(src1, src2, nbits)		Is *src1 a subset of *src2?
 * bitmap_empty(src, nbits)			Are all bits zero in *src?
 * bitmap_full(src, nbits)			Are all bits set in *src?
 * bitmap_weight(src, nbits)			Hamming Weight: number set bits
 * bitmap_set(dst, pos, nbits)			Set specified bit area
 * bitmap_clear(dst, pos, nbits)		Clear specified bit area
 * bitmap_find_next_zero_area(buf, len, pos, n, mask)	Find bit free area
 * bitmap_find_next_zero_area_off(buf, len, pos, n, mask)	as above
 * bitmap_shift_right(dst, src, n, nbits)	*dst = *src >> n
 * bitmap_shift_left(dst, src, n, nbits)	*dst = *src << n
 * bitmap_remap(dst, src, old, new, nbits)	*dst = map(old, new)(src)
 * bitmap_bitremap(oldbit, old, new, nbits)	newbit = map(old, new)(oldbit)
 * bitmap_onto(dst, orig, relmap, nbits)	*dst = orig relative to relmap
 * bitmap_fold(dst, orig, sz, nbits)		dst bits = orig bits mod sz
 * bitmap_parse(buf, buflen, dst, nbits)	Parse bitmap dst from kernel buf
 * bitmap_parse_user(ubuf, ulen, dst, nbits)	Parse bitmap dst from user buf
 * bitmap_parselist(buf, dst, nbits)		Parse bitmap dst from kernel buf
 * bitmap_parselist_user(buf, dst, nbits)	Parse bitmap dst from user buf
 * bitmap_find_free_region(bitmap, bits, order)	Find and allocate bit region
 * bitmap_release_region(bitmap, pos, order)	Free specified bit region
 * bitmap_allocate_region(bitmap, pos, order)	Allocate specified bit region
 */

/*
 * Also the following operations in asm/bitops.h apply to bitmaps.
 *
 * set_bit(bit, addr)			*addr |= bit
 * clear_bit(bit, addr)			*addr &= ~bit
 * change_bit(bit, addr)		*addr ^= bit
 * test_bit(bit, addr)			Is bit set in *addr?
 * test_and_set_bit(bit, addr)		Set bit and return old value
 * test_and_clear_bit(bit, addr)	Clear bit and return old value
 * test_and_change_bit(bit, addr)	Change bit and return old value
 * find_first_zero_bit(addr, nbits)	Position first zero bit in *addr
 * find_first_bit(addr, nbits)		Position first set bit in *addr
 * find_next_zero_bit(addr, nbits, bit)	Position next zero bit in *addr >= bit
 * find_next_bit(addr, nbits, bit)	Position next set bit in *addr >= bit
 */

/*
 * The DECLARE_BITMAP(name,bits) macro, in linux/types.h, can be used
 * to declare an array named 'name' of just enough unsigned longs to
 * contain all bit positions from 0 to 'bits' - 1.
 */

/*
 * lib/bitmap.c provides these functions:
 */

extern int __bitmap_empty(const unsigned long *bitmap, unsigned int nbits);
extern int __bitmap_full(const unsigned long *bitmap, unsigned int nbits);
extern int __bitmap_equal(const unsigned long *bitmap1,
			  const unsigned long *bitmap2, unsigned int nbits);
extern void __bitmap_complement(unsigned long *dst, const unsigned long *src,
			unsigned int nbits);
extern void __bitmap_shift_right(unsigned long *dst, const unsigned long *src,
				unsigned int shift, unsigned int nbits);
extern void __bitmap_shift_left(unsigned long *dst, const unsigned long *src,
				unsigned int shift, unsigned int nbits);
extern int __bitmap_and(unsigned long *dst, const unsigned long *bitmap1,
			const unsigned long *bitmap2, unsigned int nbits);
extern void __bitmap_or(unsigned long *dst, const unsigned long *bitmap1,
			const unsigned long *bitmap2, unsigned int nbits);
extern void __bitmap_xor(unsigned long *dst, const unsigned long *bitmap1,
			const unsigned long *bitmap2, unsigned int nbits);
extern int __bitmap_andnot(unsigned long *dst, const unsigned long *bitmap1,
			const unsigned long *bitmap2, unsigned int nbits);
extern int __bitmap_intersects(const unsigned long *bitmap1,
			const unsigned long *bitmap2, unsigned int nbits);
extern int __bitmap_subset(const unsigned long *bitmap1,
			const unsigned long *bitmap2, unsigned int nbits);
extern int __bitmap_weight(const unsigned long *bitmap, unsigned int nbits);

extern void bitmap_set(unsigned long *map, unsigned int start, int len);
extern void bitmap_clear(unsigned long *map, unsigned int start, int len);

extern unsigned long bitmap_find_next_zero_area_off(unsigned long *map,
						    unsigned long size,
						    unsigned long start,
						    unsigned int nr,
						    unsigned long align_mask,
						    unsigned long align_offset);

/**
 * bitmap_find_next_zero_area - find a contiguous aligned zero area
 * @map: The address to base the search on
 * @size: The bitmap size in bits
 * @start: The bitnumber to start searching at
 * @nr: The number of zeroed bits we're looking for
 * @align_mask: Alignment mask for zero area
 *
 * The @align_mask should be one less than a power of 2; the effect is that
 * the bit offset of all zero areas this function finds is multiples of that
 * power of 2. A @align_mask of 0 means no alignment is required.
 */
static inline unsigned long
bitmap_find_next_zero_area(unsigned long *map,
			   unsigned long size,
			   unsigned long start,
			   unsigned int nr,
			   unsigned long align_mask)
{
	return bitmap_find_next_zero_area_off(map, size, start, nr,
					      align_mask, 0);
}

extern int __bitmap_parse(const char *buf, unsigned int buflen, int is_user,
			unsigned long *dst, int nbits);
extern int bitmap_parse_user(const char __user *ubuf, unsigned int ulen,
			unsigned long *dst, int nbits);
extern int bitmap_parselist(const char *buf, unsigned long *maskp,
			int nmaskbits);
extern int bitmap_parselist_user(const char __user *ubuf, unsigned int ulen,
			unsigned long *dst, int nbits);
extern void bitmap_remap(unsigned long *dst, const unsigned long *src,
		const unsigned long *old, const unsigned long *new, unsigned int nbits);
extern int bitmap_bitremap(int oldbit,
		const unsigned long *old, const unsigned long *new, int bits);
extern void bitmap_onto(unsigned long *dst, const unsigned long *orig,
		const unsigned long *relmap, unsigned int bits);
extern void bitmap_fold(unsigned long *dst, const unsigned long *orig,
		unsigned int sz, unsigned int nbits);
extern int bitmap_find_free_region(unsigned long *bitmap, unsigned int bits, int order);
extern void bitmap_release_region(unsigned long *bitmap, unsigned int pos, int order);
extern int bitmap_allocate_region(unsigned long *bitmap, unsigned int pos, int order);
#ifdef __BIG_ENDIAN
extern void bitmap_copy_le(unsigned long *dst, const unsigned long *src, unsigned int nbits);
#else
#define bitmap_copy_le bitmap_copy
#endif
extern unsigned int bitmap_ord_to_pos(const unsigned long *bitmap, unsigned int ord, unsigned int nbits);
extern int bitmap_print_to_pagebuf(bool list, char *buf,
				   const unsigned long *maskp, int nmaskbits);

#define BITMAP_FIRST_WORD_MASK(start) (~0UL << ((start) & (BITS_PER_LONG - 1)))
#define BITMAP_LAST_WORD_MASK(nbits) (~0UL >> (-(nbits) & (BITS_PER_LONG - 1)))

#define small_const_nbits(nbits) \
	(__builtin_constant_p(nbits) && (nbits) <= BITS_PER_LONG)

static inline void bitmap_zero(unsigned long *dst, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		*dst = 0UL;
	else {
		unsigned int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
		memset(dst, 0, len);
	}
}

static inline void bitmap_fill(unsigned long *dst, unsigned int nbits)
{
	unsigned int nlongs = BITS_TO_LONGS(nbits);
	if (!small_const_nbits(nbits)) {
		unsigned int len = (nlongs - 1) * sizeof(unsigned long);
		memset(dst, 0xff,  len);
	}
	dst[nlongs - 1] = BITMAP_LAST_WORD_MASK(nbits);
}

static inline void bitmap_copy(unsigned long *dst, const unsigned long *src,
			unsigned int nbits)
{
	if (small_const_nbits(nbits))
		*dst = *src;
	else {
		unsigned int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
		memcpy(dst, src, len);
	}
}

static inline int bitmap_and(unsigned long *dst, const unsigned long *src1,
			const unsigned long *src2, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		return (*dst = *src1 & *src2 & BITMAP_LAST_WORD_MASK(nbits)) != 0;
	return __bitmap_and(dst, src1, src2, nbits);
}

static inline void bitmap_or(unsigned long *dst, const unsigned long *src1,
			const unsigned long *src2, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		*dst = *src1 | *src2;
	else
		__bitmap_or(dst, src1, src2, nbits);
}

static inline void bitmap_xor(unsigned long *dst, const unsigned long *src1,
			const unsigned long *src2, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		*dst = *src1 ^ *src2;
	else
		__bitmap_xor(dst, src1, src2, nbits);
}

static inline int bitmap_andnot(unsigned long *dst, const unsigned long *src1,
			const unsigned long *src2, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		return (*dst = *src1 & ~(*src2) & BITMAP_LAST_WORD_MASK(nbits)) != 0;
	return __bitmap_andnot(dst, src1, src2, nbits);
}

static inline void bitmap_complement(unsigned long *dst, const unsigned long *src,
			unsigned int nbits)
{
	if (small_const_nbits(nbits))
		*dst = ~(*src);
	else
		__bitmap_complement(dst, src, nbits);
}

static inline int bitmap_equal(const unsigned long *src1,
			const unsigned long *src2, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		return ! ((*src1 ^ *src2) & BITMAP_LAST_WORD_MASK(nbits));
	else
		return __bitmap_equal(src1, src2, nbits);
}

static inline int bitmap_intersects(const unsigned long *src1,
			const unsigned long *src2, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		return ((*src1 & *src2) & BITMAP_LAST_WORD_MASK(nbits)) != 0;
	else
		return __bitmap_intersects(src1, src2, nbits);
}

static inline int bitmap_subset(const unsigned long *src1,
			const unsigned long *src2, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		return ! ((*src1 & ~(*src2)) & BITMAP_LAST_WORD_MASK(nbits));
	else
		return __bitmap_subset(src1, src2, nbits);
}

static inline int bitmap_empty(const unsigned long *src, unsigned nbits)
{
	if (small_const_nbits(nbits))
		return ! (*src & BITMAP_LAST_WORD_MASK(nbits));

	return find_first_bit(src, nbits) == nbits;
}

static inline int bitmap_full(const unsigned long *src, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		return ! (~(*src) & BITMAP_LAST_WORD_MASK(nbits));

	return find_first_zero_bit(src, nbits) == nbits;
}

static inline int bitmap_weight(const unsigned long *src, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		return hweight_long(*src & BITMAP_LAST_WORD_MASK(nbits));
	return __bitmap_weight(src, nbits);
}

static inline void bitmap_shift_right(unsigned long *dst, const unsigned long *src,
				unsigned int shift, int nbits)
{
	if (small_const_nbits(nbits))
		*dst = (*src & BITMAP_LAST_WORD_MASK(nbits)) >> shift;
	else
		__bitmap_shift_right(dst, src, shift, nbits);
}

static inline void bitmap_shift_left(unsigned long *dst, const unsigned long *src,
				unsigned int shift, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		*dst = (*src << shift) & BITMAP_LAST_WORD_MASK(nbits);
	else
		__bitmap_shift_left(dst, src, shift, nbits);
}

static inline int bitmap_parse(const char *buf, unsigned int buflen,
			unsigned long *maskp, int nmaskbits)
{
	return __bitmap_parse(buf, buflen, 0, maskp, nmaskbits);
}

#endif /* __ASSEMBLY__ */

#endif /* __LINUX_BITMAP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 *  Shared Transport Header file
 *	To be included by the protocol stack drivers for
 *	Texas Instruments BT,FM and GPS combo chip drivers
 *	and also serves the sub-modules of the shared transport driver.
 *
 *  Copyright (C) 2009-2010 Texas Instruments
 *  Author: Pavan Savoy <pavan_savoy@ti.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 2 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#ifndef TI_WILINK_ST_H
#define TI_WILINK_ST_H

#include <linux/skbuff.h>

/**
 * enum proto-type - The protocol on WiLink chips which share a
 *	common physical interface like UART.
 */
enum proto_type {
	ST_BT,
	ST_FM,
	ST_GPS,
	ST_MAX_CHANNELS = 16,
};

/**
 * struct st_proto_s - Per Protocol structure from BT/FM/GPS to ST
 * @type: type of the protocol being registered among the
 *	available proto_type(BT, FM, GPS the protocol which share TTY).
 * @recv: the receiver callback pointing to a function in the
 *	protocol drivers called by the ST driver upon receiving
 *	relevant data.
 * @match_packet: reserved for future use, to make ST more generic
 * @reg_complete_cb: callback handler pointing to a function in protocol
 *	handler called by ST when the pending registrations are complete.
 *	The registrations are marked pending, in situations when fw
 *	download is in progress.
 * @write: pointer to function in ST provided to protocol drivers from ST,
 *	to be made use when protocol drivers have data to send to TTY.
 * @priv_data: privdate data holder for the protocol drivers, sent
 *	from the protocol drivers during registration, and sent back on
 *	reg_complete_cb and recv.
 * @chnl_id: channel id the protocol driver is interested in, the channel
 *	id is nothing but the 1st byte of the packet in UART frame.
 * @max_frame_size: size of the largest frame the protocol can receive.
 * @hdr_len: length of the header structure of the protocol.
 * @offset_len_in_hdr: this provides the offset of the length field in the
 *	header structure of the protocol header, to assist ST to know
 *	how much to receive, if the data is split across UART frames.
 * @len_size: whether the length field inside the header is 2 bytes
 *	or 1 byte.
 * @reserve: the number of bytes ST needs to reserve in the skb being
 *	prepared for the protocol driver.
 */
struct st_proto_s {
	enum proto_type type;
	long (*recv) (void *, struct sk_buff *);
	unsigned char (*match_packet) (const unsigned char *data);
	void (*reg_complete_cb) (void *, char data);
	long (*write) (struct sk_buff *skb);
	void *priv_data;

	unsigned char chnl_id;
	unsigned short max_frame_size;
	unsigned char hdr_len;
	unsigned char offset_len_in_hdr;
	unsigned char len_size;
	unsigned char reserve;
};

extern long st_register(struct st_proto_s *);
extern long st_unregister(struct st_proto_s *);

extern struct ti_st_plat_data   *dt_pdata;

/*
 * header information used by st_core.c
 */

/* states of protocol list */
#define ST_NOTEMPTY	1
#define ST_EMPTY	0

/*
 * possible st_states
 */
#define ST_INITIALIZING		1
#define ST_REG_IN_PROGRESS	2
#define ST_REG_PENDING		3
#define ST_WAITING_FOR_RESP	4

/**
 * struct st_data_s - ST core internal structure
 * @st_state: different states of ST like initializing, registration
 *	in progress, this is mainly used to return relevant err codes
 *	when protocol drivers are registering. It is also used to track
 *	the recv function, as in during fw download only HCI events
 *	can occur , where as during other times other events CH8, CH9
 *	can occur.
 * @tty: tty provided by the TTY core for line disciplines.
 * @tx_skb: If for some reason the tty's write returns lesser bytes written
 *	then to maintain the rest of data to be written on next instance.
 *	This needs to be protected, hence the lock inside wakeup func.
 * @tx_state: if the data is being written onto the TTY and protocol driver
 *	wants to send more, queue up data and mark that there is
 *	more data to send.
 * @list: the list of protocols registered, only MAX can exist, one protocol
 *	can register only once.
 * @rx_state: states to be maintained inside st's tty receive
 * @rx_count: count to be maintained inside st's tty receieve
 * @rx_skb: the skb where all data for a protocol gets accumulated,
 *	since tty might not call receive when a complete event packet
 *	is received, the states, count and the skb needs to be maintained.
 * @rx_chnl: the channel ID for which the data is getting accumalated for.
 * @txq: the list of skbs which needs to be sent onto the TTY.
 * @tx_waitq: if the chip is not in AWAKE state, the skbs needs to be queued
 *	up in here, PM(WAKEUP_IND) data needs to be sent and then the skbs
 *	from waitq can be moved onto the txq.
 *	Needs locking too.
 * @lock: the lock to protect skbs, queues, and ST states.
 * @protos_registered: count of the protocols registered, also when 0 the
 *	chip enable gpio can be toggled, and when it changes to 1 the fw
 *	needs to be downloaded to initialize chip side ST.
 * @ll_state: the various PM states the chip can be, the states are notified
 *	to us, when the chip sends relevant PM packets(SLEEP_IND, WAKE_IND).
 * @kim_data: reference to the parent encapsulating structure.
 *
 */
struct st_data_s {
	unsigned long st_state;
	struct sk_buff *tx_skb;
#define ST_TX_SENDING	1
#define ST_TX_WAKEUP	2
	unsigned long tx_state;
	struct st_proto_s *list[ST_MAX_CHANNELS];
	bool is_registered[ST_MAX_CHANNELS];
	unsigned long rx_state;
	unsigned long rx_count;
	struct sk_buff *rx_skb;
	unsigned char rx_chnl;
	struct sk_buff_head txq, tx_waitq;
	spinlock_t lock;
	unsigned char	protos_registered;
	unsigned long ll_state;
	void *kim_data;
	struct tty_struct *tty;
};

/*
 * wrapper around tty->ops->write_room to check
 * availability during firmware download
 */
int st_get_uart_wr_room(struct st_data_s *st_gdata);
/**
 * st_int_write -
 * point this to tty->driver->write or tty->ops->write
 * depending upon the kernel version
 */
int st_int_write(struct st_data_s*, const unsigned char*, int);

/**
 * st_write -
 * internal write function, passed onto protocol drivers
 * via the write function ptr of protocol struct
 */
long st_write(struct sk_buff *);

/* function to be called from ST-LL */
void st_ll_send_frame(enum proto_type, struct sk_buff *);

/* internal wake up function */
void st_tx_wakeup(struct st_data_s *st_data);

/* init, exit entry funcs called from KIM */
int st_core_init(struct st_data_s **);
void st_core_exit(struct st_data_s *);

/* ask for reference from KIM */
void st_kim_ref(struct st_data_s **, int);

#define GPS_STUB_TEST
#ifdef GPS_STUB_TEST
int gps_chrdrv_stub_write(const unsigned char*, int);
void gps_chrdrv_stub_init(void);
#endif

/*
 * header information used by st_kim.c
 */

/* time in msec to wait for
 * line discipline to be installed
 */
#define LDISC_TIME	1000
#define CMD_RESP_TIME	800
#define CMD_WR_TIME	5000
#define MAKEWORD(a, b)  ((unsigned short)(((unsigned char)(a)) \
	| ((unsigned short)((unsigned char)(b))) << 8))

#define GPIO_HIGH 1
#define GPIO_LOW  0

/* the Power-On-Reset logic, requires to attempt
 * to download firmware onto chip more than once
 * since the self-test for chip takes a while
 */
#define POR_RETRY_COUNT 5

/**
 * struct chip_version - save the chip version
 */
struct chip_version {
	unsigned short full;
	unsigned short chip;
	unsigned short min_ver;
	unsigned short maj_ver;
};

#define UART_DEV_NAME_LEN 32
/**
 * struct kim_data_s - the KIM internal data, embedded as the
 *	platform's drv data. One for each ST device in the system.
 * @uim_pid: KIM needs to communicate with UIM to request to install
 *	the ldisc by opening UART when protocol drivers register.
 * @kim_pdev: the platform device added in one of the board-XX.c file
 *	in arch/XX/ directory, 1 for each ST device.
 * @kim_rcvd: completion handler to notify when data was received,
 *	mainly used during fw download, which involves multiple send/wait
 *	for each of the HCI-VS commands.
 * @ldisc_installed: completion handler to notify that the UIM accepted
 *	the request to install ldisc, notify from tty_open which suggests
 *	the ldisc was properly installed.
 * @resp_buffer: data buffer for the .bts fw file name.
 * @fw_entry: firmware class struct to request/release the fw.
 * @rx_state: the rx state for kim's receive func during fw download.
 * @rx_count: the rx count for the kim's receive func during fw download.
 * @rx_skb: all of fw data might not come at once, and hence data storage for
 *	whole of the fw response, only HCI_EVENTs and hence diff from ST's
 *	response.
 * @core_data: ST core's data, which mainly is the tty's disc_data
 * @version: chip version available via a sysfs entry.
 *
 */
struct kim_data_s {
	long uim_pid;
	struct platform_device *kim_pdev;
	struct completion kim_rcvd, ldisc_installed;
	char resp_buffer[30];
	const struct firmware *fw_entry;
	unsigned nshutdown;
	unsigned long rx_state;
	unsigned long rx_count;
	struct sk_buff *rx_skb;
	struct st_data_s *core_data;
	struct chip_version version;
	unsigned char ldisc_install;
	unsigned char dev_name[UART_DEV_NAME_LEN + 1];
	unsigned flow_cntrl;
	unsigned baud_rate;
};

/**
 * functions called when 1 of the protocol drivers gets
 * registered, these need to communicate with UIM to request
 * ldisc installed, read chip_version, download relevant fw
 */
long st_kim_start(void *);
long st_kim_stop(void *);

void st_kim_complete(void *);
void kim_st_list_protocols(struct st_data_s *, void *);
void st_kim_recv(void *, const unsigned char *, long);


/*
 * BTS headers
 */
#define ACTION_SEND_COMMAND     1
#define ACTION_WAIT_EVENT       2
#define ACTION_SERIAL           3
#define ACTION_DELAY            4
#define ACTION_RUN_SCRIPT       5
#define ACTION_REMARKS          6

/**
 * struct bts_header - the fw file is NOT binary which can
 *	be sent onto TTY as is. The .bts is more a script
 *	file which has different types of actions.
 *	Each such action needs to be parsed by the KIM and
 *	relevant procedure to be called.
 */
struct bts_header {
	u32 magic;
	u32 version;
	u8 future[24];
	u8 actions[0];
} __attribute__ ((packed));

/**
 * struct bts_action - Each .bts action has its own type of
 *	data.
 */
struct bts_action {
	u16 type;
	u16 size;
	u8 data[0];
} __attribute__ ((packed));

struct bts_action_send {
	u8 data[0];
} __attribute__ ((packed));

struct bts_action_wait {
	u32 msec;
	u32 size;
	u8 data[0];
} __attribute__ ((packed));

struct bts_action_delay {
	u32 msec;
} __attribute__ ((packed));

struct bts_action_serial {
	u32 baud;
	u32 flow_control;
} __attribute__ ((packed));

/**
 * struct hci_command - the HCI-VS for intrepreting
 *	the change baud rate of host-side UART, which
 *	needs to be ignored, since UIM would do that
 *	when it receives request from KIM for ldisc installation.
 */
struct hci_command {
	u8 prefix;
	u16 opcode;
	u8 plen;
	u32 speed;
} __attribute__ ((packed));

/*
 * header information used by st_ll.c
 */

/* ST LL receiver states */
#define ST_W4_PACKET_TYPE       0
#define ST_W4_HEADER		1
#define ST_W4_DATA		2

/* ST LL state machines */
#define ST_LL_ASLEEP               0
#define ST_LL_ASLEEP_TO_AWAKE      1
#define ST_LL_AWAKE                2
#define ST_LL_AWAKE_TO_ASLEEP      3
#define ST_LL_INVALID		   4

/* different PM notifications coming from chip */
#define LL_SLEEP_IND	0x30
#define LL_SLEEP_ACK	0x31
#define LL_WAKE_UP_IND	0x32
#define LL_WAKE_UP_ACK	0x33

/* initialize and de-init ST LL */
long st_ll_init(struct st_data_s *);
long st_ll_deinit(struct st_data_s *);

/**
 * enable/disable ST LL along with KIM start/stop
 * called by ST Core
 */
void st_ll_enable(struct st_data_s *);
void st_ll_disable(struct st_data_s *);

/**
 * various funcs used by ST core to set/get the various PM states
 * of the chip.
 */
unsigned long st_ll_getstate(struct st_data_s *);
unsigned long st_ll_sleep_state(struct st_data_s *, unsigned char);
void st_ll_wakeup(struct st_data_s *);

/*
 * header information used by st_core.c for FM and GPS
 * packet parsing, the bluetooth headers are already available
 * at net/bluetooth/
 */

struct fm_event_hdr {
	u8 plen;
} __attribute__ ((packed));

#define FM_MAX_FRAME_SIZE 0xFF	/* TODO: */
#define FM_EVENT_HDR_SIZE 1	/* size of fm_event_hdr */
#define ST_FM_CH8_PKT 0x8

/* gps stuff */
struct gps_event_hdr {
	u8 opcode;
	u16 plen;
} __attribute__ ((packed));

/**
 * struct ti_st_plat_data - platform data shared between ST driver and
 *	platform specific board file which adds the ST device.
 * @nshutdown_gpio: Host's GPIO line to which chip's BT_EN is connected.
 * @dev_name: The UART/TTY name to which chip is interfaced. (eg: /dev/ttyS1)
 * @flow_cntrl: Should always be 1, since UART's CTS/RTS is used for PM
 *	purposes.
 * @baud_rate: The baud rate supported by the Host UART controller, this will
 *	be shared across with the chip via a HCI VS command from User-Space Init
 *	Mgr application.
 * @suspend:
 * @resume: legacy PM routines hooked to platform specific board file, so as
 *	to take chip-host interface specific action.
 * @chip_enable:
 * @chip_disable: Platform/Interface specific mux mode setting, GPIO
 *	configuring, Host side PM disabling etc.. can be done here.
 * @chip_asleep:
 * @chip_awake: Chip specific deep sleep states is communicated to Host
 *	specific board-xx.c to take actions such as cut UART clocks when chip
 *	asleep or run host faster when chip awake etc..
 *
 */
struct ti_st_plat_data {
	u32 nshutdown_gpio;
	unsigned char dev_name[UART_DEV_NAME_LEN]; /* uart name */
	u32 flow_cntrl; /* flow control flag */
	u32 baud_rate;
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	int (*chip_enable) (struct kim_data_s *);
	int (*chip_disable) (struct kim_data_s *);
	int (*chip_asleep) (struct kim_data_s *);
	int (*chip_awake) (struct kim_data_s *);
};

#endif /* TI_WILINK_ST_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #ifndef _LINUX_INTERVAL_TREE_H
#define _LINUX_INTERVAL_TREE_H

#include <linux/rbtree.h>

struct interval_tree_node {
	struct rb_node rb;
	unsigned long start;	/* Start of interval */
	unsigned long last;	/* Last location _in_ interval */
	unsigned long __subtree_last;
};

extern void
interval_tree_insert(struct interval_tree_node *node, struct rb_root *root);

extern void
interval_tree_remove(struct interval_tree_node *node, struct rb_root *root);

extern struct interval_tree_node *
interval_tree_iter_first(struct rb_root *root,
			 unsigned long start, unsigned long last);

extern struct interval_tree_node *
interval_tree_iter_next(struct interval_tree_node *node,
			unsigned long start, unsigned long last);

#endif	/* _LINUX_INTERVAL_TREE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 *  Copyright (c) 2007 Jiri Kosina
 */
/*
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 */
#ifndef _HIDRAW_H
#define _HIDRAW_H

#include <uapi/linux/hidraw.h>


struct hidraw {
	unsigned int minor;
	int exist;
	int open;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct device *dev;
	spinlock_t list_lock;
	struct list_head list;
};

struct hidraw_report {
	__u8 *value;
	int len;
};

struct hidraw_list {
	struct hidraw_report buffer[HIDRAW_BUFFER_SIZE];
	int head;
	int tail;
	struct fasync_struct *fasync;
	struct hidraw *hidraw;
	struct list_head node;
	struct mutex read_mutex;
};

#ifdef CONFIG_HIDRAW
int hidraw_init(void);
void hidraw_exit(void);
int hidraw_report_event(struct hid_device *, u8 *, int);
int hidraw_connect(struct hid_device *);
void hidraw_disconnect(struct hid_device *);
#else
static inline int hidraw_init(void) { return 0; }
static inline void hidraw_exit(void) { }
static inline int hidraw_report_event(struct hid_device *hid, u8 *data, int len) { return 0; }
static inline int hidraw_connect(struct hid_device *hid) { return -1; }
static inline void hidraw_disconnect(struct hid_device *hid) { }
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef __OF_IOMMU_H
#define __OF_IOMMU_H

#include <linux/device.h>
#include <linux/iommu.h>
#include <linux/of.h>

#ifdef CONFIG_OF_IOMMU

extern int of_get_dma_window(struct device_node *dn, const char *prefix,
			     int index, unsigned long *busno, dma_addr_t *addr,
			     size_t *size);

extern void of_iommu_init(void);
extern struct iommu_ops *of_iommu_configure(struct device *dev,
					struct device_node *master_np);

#else

static inline int of_get_dma_window(struct device_node *dn, const char *prefix,
			    int index, unsigned long *busno, dma_addr_t *addr,
			    size_t *size)
{
	return -EINVAL;
}

static inline void of_iommu_init(void) { }
static inline struct iommu_ops *of_iommu_configure(struct device *dev,
					 struct device_node *master_np)
{
	return NULL;
}

#endif	/* CONFIG_OF_IOMMU */

void of_iommu_set_ops(struct device_node *np, struct iommu_ops *ops);
struct iommu_ops *of_iommu_get_ops(struct device_node *np);

extern struct of_device_id __iommu_of_table;

typedef int (*of_iommu_init_fn)(struct device_node *);

#define IOMMU_OF_DECLARE(name, compat, fn) \
	_OF_DECLARE(iommu, name, compat, fn, of_iommu_init_fn)

#endif /* __OF_IOMMU_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 *	Linux ethernet bridge
 *
 *	Authors:
 *	Lennert Buytenhek		<buytenh@gnu.org>
 *
 *	This program is free software; you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License
 *	as published by the Free Software Foundation; either version
 *	2 of the License, or (at your option) any later version.
 */
#ifndef _LINUX_IF_BRIDGE_H
#define _LINUX_IF_BRIDGE_H


#include <linux/netdevice.h>
#include <uapi/linux/if_bridge.h>
#include <linux/bitops.h>

struct br_ip {
	union {
		__be32	ip4;
#if IS_ENABLED(CONFIG_IPV6)
		struct in6_addr ip6;
#endif
	} u;
	__be16		proto;
	__u16           vid;
};

struct br_ip_list {
	struct list_head list;
	struct br_ip addr;
};

#define BR_HAIRPIN_MODE		BIT(0)
#define BR_BPDU_GUARD		BIT(1)
#define BR_ROOT_BLOCK		BIT(2)
#define BR_MULTICAST_FAST_LEAVE	BIT(3)
#define BR_ADMIN_COST		BIT(4)
#define BR_LEARNING		BIT(5)
#define BR_FLOOD		BIT(6)
#define BR_AUTO_MASK		(BR_FLOOD | BR_LEARNING)
#define BR_PROMISC		BIT(7)
#define BR_PROXYARP		BIT(8)
#define BR_LEARNING_SYNC	BIT(9)
#define BR_PROXYARP_WIFI	BIT(10)

extern void brioctl_set(int (*ioctl_hook)(struct net *, unsigned int, void __user *));

typedef int br_should_route_hook_t(struct sk_buff *skb);
extern br_should_route_hook_t __rcu *br_should_route_hook;

#if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
int br_multicast_list_adjacent(struct net_device *dev,
			       struct list_head *br_ip_list);
bool br_multicast_has_querier_anywhere(struct net_device *dev, int proto);
bool br_multicast_has_querier_adjacent(struct net_device *dev, int proto);
#else
static inline int br_multicast_list_adjacent(struct net_device *dev,
					     struct list_head *br_ip_list)
{
	return 0;
}
static inline bool br_multicast_has_querier_anywhere(struct net_device *dev,
						     int proto)
{
	return false;
}
static inline bool br_multicast_has_querier_adjacent(struct net_device *dev,
						     int proto)
{
	return false;
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * Generic PWM backlight driver data - see drivers/video/backlight/pwm_bl.c
 */
#ifndef __LINUX_PWM_BACKLIGHT_H
#define __LINUX_PWM_BACKLIGHT_H

#include <linux/backlight.h>

struct platform_pwm_backlight_data {
	int pwm_id;
	unsigned int max_brightness;
	unsigned int dft_brightness;
	unsigned int lth_brightness;
	unsigned int pwm_period_ns;
	unsigned int *levels;
	/* TODO remove once all users are switched to gpiod_* API */
	int enable_gpio;
	int (*init)(struct device *dev);
	int (*notify)(struct device *dev, int brightness);
	void (*notify_after)(struct device *dev, int brightness);
	void (*exit)(struct device *dev);
	int (*check_fb)(struct device *dev, struct fb_info *info);
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #ifndef __mISDNdsp_H__
#define __mISDNdsp_H__

struct mISDN_dsp_element_arg {
	char	*name;
	char	*def;
	char	*desc;
};

struct mISDN_dsp_element {
	char	*name;
	void	*(*new)(const char *arg);
	void	(*free)(void *p);
	void	(*process_tx)(void *p, unsigned char *data, int len);
	void	(*process_rx)(void *p, unsigned char *data, int len,
			unsigned int txlen);
	int	num_args;
	struct mISDN_dsp_element_arg
		*args;
};

extern int  mISDN_dsp_element_register(struct mISDN_dsp_element *elem);
extern void mISDN_dsp_element_unregister(struct mISDN_dsp_element *elem);

struct dsp_features {
	int	hfc_id; /* unique id to identify the chip (or -1) */
	int	hfc_dtmf; /* set if HFCmulti card supports dtmf */
	int	hfc_conf; /* set if HFCmulti card supports conferences */
	int	hfc_loops; /* set if card supports tone loops */
	int	hfc_echocanhw; /* set if card supports echocancelation*/
	int	pcm_id; /* unique id to identify the pcm bus (or -1) */
	int	pcm_slots; /* number of slots on the pcm bus */
	int	pcm_banks; /* number of IO banks of pcm bus */
	int	unclocked; /* data is not clocked (has jitter/loss) */
	int	unordered; /* data is unordered (packets have index) */
};

#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #ifndef _LINUX_VT_H
#define _LINUX_VT_H

#include <uapi/linux/vt.h>


/* Virtual Terminal events. */
#define VT_ALLOCATE		0x0001 /* Console got allocated */
#define VT_DEALLOCATE		0x0002 /* Console will be deallocated */
#define VT_WRITE		0x0003 /* A char got output */
#define VT_UPDATE		0x0004 /* A bigger update occurred */
#define VT_PREWRITE		0x0005 /* A char is about to be written to the console */

#ifdef CONFIG_VT_CONSOLE

extern int vt_kmsg_redirect(int new);

#else

static inline int vt_kmsg_redirect(int new)
{
	return 0;
}

#endif

#endif /* _LINUX_VT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef __LINUX_PAGE_EXT_H
#define __LINUX_PAGE_EXT_H

#include <linux/types.h>
#include <linux/stacktrace.h>

struct pglist_data;
struct page_ext_operations {
	bool (*need)(void);
	void (*init)(void);
};

#ifdef CONFIG_PAGE_EXTENSION

/*
 * page_ext->flags bits:
 *
 * PAGE_EXT_DEBUG_POISON is set for poisoned pages. This is used to
 * implement generic debug pagealloc feature. The pages are filled with
 * poison patterns and set this flag after free_pages(). The poisoned
 * pages are verified whether the patterns are not corrupted and clear
 * the flag before alloc_pages().
 */

enum page_ext_flags {
	PAGE_EXT_DEBUG_POISON,		/* Page is poisoned */
	PAGE_EXT_DEBUG_GUARD,
	PAGE_EXT_OWNER,
};

/*
 * Page Extension can be considered as an extended mem_map.
 * A page_ext page is associated with every page descriptor. The
 * page_ext helps us add more information about the page.
 * All page_ext are allocated at boot or memory hotplug event,
 * then the page_ext for pfn always exists.
 */
struct page_ext {
	unsigned long flags;
#ifdef CONFIG_PAGE_OWNER
	unsigned int order;
	gfp_t gfp_mask;
	unsigned int nr_entries;
	unsigned long trace_entries[8];
#endif
};

extern void pgdat_page_ext_init(struct pglist_data *pgdat);

#ifdef CONFIG_SPARSEMEM
static inline void page_ext_init_flatmem(void)
{
}
extern void page_ext_init(void);
#else
extern void page_ext_init_flatmem(void);
static inline void page_ext_init(void)
{
}
#endif

struct page_ext *lookup_page_ext(struct page *page);

#else /* !CONFIG_PAGE_EXTENSION */
struct page_ext;

static inline void pgdat_page_ext_init(struct pglist_data *pgdat)
{
}

static inline struct page_ext *lookup_page_ext(struct page *page)
{
	return NULL;
}

static inline void page_ext_init(void)
{
}

static inline void page_ext_init_flatmem(void)
{
}
#endif /* CONFIG_PAGE_EXTENSION */
#endif /* __LINUX_PAGE_EXT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * Resizable, Scalable, Concurrent Hash Table
 *
 * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
 * Copyright (c) 2014-2015 Thomas Graf <tgraf@suug.ch>
 * Copyright (c) 2008-2014 Patrick McHardy <kaber@trash.net>
 *
 * Code partially derived from nft_hash
 * Rewritten with rehash code from br_multicast plus single list
 * pointer as suggested by Josh Triplett
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef _LINUX_RHASHTABLE_H
#define _LINUX_RHASHTABLE_H

#include <linux/atomic.h>
#include <linux/compiler.h>
#include <linux/errno.h>
#include <linux/jhash.h>
#include <linux/list_nulls.h>
#include <linux/workqueue.h>
#include <linux/mutex.h>
#include <linux/rcupdate.h>

/*
 * The end of the chain is marked with a special nulls marks which has
 * the following format:
 *
 * +-------+-----------------------------------------------------+-+
 * | Base  |                      Hash                           |1|
 * +-------+-----------------------------------------------------+-+
 *
 * Base (4 bits) : Reserved to distinguish between multiple tables.
 *                 Specified via &struct rhashtable_params.nulls_base.
 * Hash (27 bits): Full hash (unmasked) of first element added to bucket
 * 1 (1 bit)     : Nulls marker (always set)
 *
 * The remaining bits of the next pointer remain unused for now.
 */
#define RHT_BASE_BITS		4
#define RHT_HASH_BITS		27
#define RHT_BASE_SHIFT		RHT_HASH_BITS

/* Base bits plus 1 bit for nulls marker */
#define RHT_HASH_RESERVED_SPACE	(RHT_BASE_BITS + 1)

struct rhash_head {
	struct rhash_head __rcu		*next;
};

/**
 * struct bucket_table - Table of hash buckets
 * @size: Number of hash buckets
 * @rehash: Current bucket being rehashed
 * @hash_rnd: Random seed to fold into hash
 * @locks_mask: Mask to apply before accessing locks[]
 * @locks: Array of spinlocks protecting individual buckets
 * @walkers: List of active walkers
 * @rcu: RCU structure for freeing the table
 * @future_tbl: Table under construction during rehashing
 * @buckets: size * hash buckets
 */
struct bucket_table {
	unsigned int		size;
	unsigned int		rehash;
	u32			hash_rnd;
	unsigned int		locks_mask;
	spinlock_t		*locks;
	struct list_head	walkers;
	struct rcu_head		rcu;

	struct bucket_table __rcu *future_tbl;

	struct rhash_head __rcu	*buckets[] ____cacheline_aligned_in_smp;
};

/**
 * struct rhashtable_compare_arg - Key for the function rhashtable_compare
 * @ht: Hash table
 * @key: Key to compare against
 */
struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

typedef u32 (*rht_hashfn_t)(const void *data, u32 len, u32 seed);
typedef u32 (*rht_obj_hashfn_t)(const void *data, u32 len, u32 seed);
typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *arg,
			       const void *obj);

struct rhashtable;

/**
 * struct rhashtable_params - Hash table construction parameters
 * @nelem_hint: Hint on number of elements, should be 75% of desired size
 * @key_len: Length of key
 * @key_offset: Offset of key in struct to be hashed
 * @head_offset: Offset of rhash_head in struct to be hashed
 * @insecure_max_entries: Maximum number of entries (may be exceeded)
 * @max_size: Maximum size while expanding
 * @min_size: Minimum size while shrinking
 * @nulls_base: Base value to generate nulls marker
 * @insecure_elasticity: Set to true to disable chain length checks
 * @automatic_shrinking: Enable automatic shrinking of tables
 * @locks_mul: Number of bucket locks to allocate per cpu (default: 128)
 * @hashfn: Hash function (default: jhash2 if !(key_len % 4), or jhash)
 * @obj_hashfn: Function to hash object
 * @obj_cmpfn: Function to compare key with object
 */
struct rhashtable_params {
	size_t			nelem_hint;
	size_t			key_len;
	size_t			key_offset;
	size_t			head_offset;
	unsigned int		insecure_max_entries;
	unsigned int		max_size;
	unsigned int		min_size;
	u32			nulls_base;
	bool			insecure_elasticity;
	bool			automatic_shrinking;
	size_t			locks_mul;
	rht_hashfn_t		hashfn;
	rht_obj_hashfn_t	obj_hashfn;
	rht_obj_cmpfn_t		obj_cmpfn;
};

/**
 * struct rhashtable - Hash table handle
 * @tbl: Bucket table
 * @nelems: Number of elements in table
 * @key_len: Key length for hashfn
 * @elasticity: Maximum chain length before rehash
 * @p: Configuration parameters
 * @run_work: Deferred worker to expand/shrink asynchronously
 * @mutex: Mutex to protect current/future table swapping
 * @lock: Spin lock to protect walker list
 */
struct rhashtable {
	struct bucket_table __rcu	*tbl;
	atomic_t			nelems;
	unsigned int			key_len;
	unsigned int			elasticity;
	struct rhashtable_params	p;
	struct work_struct		run_work;
	struct mutex                    mutex;
	spinlock_t			lock;
};

/**
 * struct rhashtable_walker - Hash table walker
 * @list: List entry on list of walkers
 * @tbl: The table that we were walking over
 */
struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

/**
 * struct rhashtable_iter - Hash table iterator, fits into netlink cb
 * @ht: Table to iterate through
 * @p: Current pointer
 * @walker: Associated rhashtable walker
 * @slot: Current slot
 * @skip: Number of entries to skip in slot
 */
struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhashtable_walker *walker;
	unsigned int slot;
	unsigned int skip;
};

static inline unsigned long rht_marker(const struct rhashtable *ht, u32 hash)
{
	return NULLS_MARKER(ht->p.nulls_base + hash);
}

#define INIT_RHT_NULLS_HEAD(ptr, ht, hash) \
	((ptr) = (typeof(ptr)) rht_marker(ht, hash))

static inline bool rht_is_a_nulls(const struct rhash_head *ptr)
{
	return ((unsigned long) ptr & 1);
}

static inline unsigned long rht_get_nulls_value(const struct rhash_head *ptr)
{
	return ((unsigned long) ptr) >> 1;
}

static inline void *rht_obj(const struct rhashtable *ht,
			    const struct rhash_head *he)
{
	return (char *)he - ht->p.head_offset;
}

static inline unsigned int rht_bucket_index(const struct bucket_table *tbl,
					    unsigned int hash)
{
	return (hash >> RHT_HASH_RESERVED_SPACE) & (tbl->size - 1);
}

static inline unsigned int rht_key_hashfn(
	struct rhashtable *ht, const struct bucket_table *tbl,
	const void *key, const struct rhashtable_params params)
{
	unsigned int hash;

	/* params must be equal to ht->p if it isn't constant. */
	if (!__builtin_constant_p(params.key_len))
		hash = ht->p.hashfn(key, ht->key_len, tbl->hash_rnd);
	else if (params.key_len) {
		unsigned int key_len = params.key_len;

		if (params.hashfn)
			hash = params.hashfn(key, key_len, tbl->hash_rnd);
		else if (key_len & (sizeof(u32) - 1))
			hash = jhash(key, key_len, tbl->hash_rnd);
		else
			hash = jhash2(key, key_len / sizeof(u32),
				      tbl->hash_rnd);
	} else {
		unsigned int key_len = ht->p.key_len;

		if (params.hashfn)
			hash = params.hashfn(key, key_len, tbl->hash_rnd);
		else
			hash = jhash(key, key_len, tbl->hash_rnd);
	}

	return rht_bucket_index(tbl, hash);
}

static inline unsigned int rht_head_hashfn(
	struct rhashtable *ht, const struct bucket_table *tbl,
	const struct rhash_head *he, const struct rhashtable_params params)
{
	const char *ptr = rht_obj(ht, he);

	return likely(params.obj_hashfn) ?
	       rht_bucket_index(tbl, params.obj_hashfn(ptr, params.key_len ?:
							    ht->p.key_len,
						       tbl->hash_rnd)) :
	       rht_key_hashfn(ht, tbl, ptr + params.key_offset, params);
}

/**
 * rht_grow_above_75 - returns true if nelems > 0.75 * table-size
 * @ht:		hash table
 * @tbl:	current table
 */
static inline bool rht_grow_above_75(const struct rhashtable *ht,
				     const struct bucket_table *tbl)
{
	/* Expand table when exceeding 75% load */
	return atomic_read(&ht->nelems) > (tbl->size / 4 * 3) &&
	       (!ht->p.max_size || tbl->size < ht->p.max_size);
}

/**
 * rht_shrink_below_30 - returns true if nelems < 0.3 * table-size
 * @ht:		hash table
 * @tbl:	current table
 */
static inline bool rht_shrink_below_30(const struct rhashtable *ht,
				       const struct bucket_table *tbl)
{
	/* Shrink table beneath 30% load */
	return atomic_read(&ht->nelems) < (tbl->size * 3 / 10) &&
	       tbl->size > ht->p.min_size;
}

/**
 * rht_grow_above_100 - returns true if nelems > table-size
 * @ht:		hash table
 * @tbl:	current table
 */
static inline bool rht_grow_above_100(const struct rhashtable *ht,
				      const struct bucket_table *tbl)
{
	return atomic_read(&ht->nelems) > tbl->size &&
		(!ht->p.max_size || tbl->size < ht->p.max_size);
}

/**
 * rht_grow_above_max - returns true if table is above maximum
 * @ht:		hash table
 * @tbl:	current table
 */
static inline bool rht_grow_above_max(const struct rhashtable *ht,
				      const struct bucket_table *tbl)
{
	return ht->p.insecure_max_entries &&
	       atomic_read(&ht->nelems) >= ht->p.insecure_max_entries;
}

/* The bucket lock is selected based on the hash and protects mutations
 * on a group of hash buckets.
 *
 * A maximum of tbl->size/2 bucket locks is allocated. This ensures that
 * a single lock always covers both buckets which may both contains
 * entries which link to the same bucket of the old table during resizing.
 * This allows to simplify the locking as locking the bucket in both
 * tables during resize always guarantee protection.
 *
 * IMPORTANT: When holding the bucket lock of both the old and new table
 * during expansions and shrinking, the old bucket lock must always be
 * acquired first.
 */
static inline spinlock_t *rht_bucket_lock(const struct bucket_table *tbl,
					  unsigned int hash)
{
	return &tbl->locks[hash & tbl->locks_mask];
}

#ifdef CONFIG_PROVE_LOCKING
int lockdep_rht_mutex_is_held(struct rhashtable *ht);
int lockdep_rht_bucket_is_held(const struct bucket_table *tbl, u32 hash);
#else
static inline int lockdep_rht_mutex_is_held(struct rhashtable *ht)
{
	return 1;
}

static inline int lockdep_rht_bucket_is_held(const struct bucket_table *tbl,
					     u32 hash)
{
	return 1;
}
#endif /* CONFIG_PROVE_LOCKING */

int rhashtable_init(struct rhashtable *ht,
		    const struct rhashtable_params *params);

int rhashtable_insert_slow(struct rhashtable *ht, const void *key,
			   struct rhash_head *obj,
			   struct bucket_table *old_tbl);
int rhashtable_insert_rehash(struct rhashtable *ht);

int rhashtable_walk_init(struct rhashtable *ht, struct rhashtable_iter *iter);
void rhashtable_walk_exit(struct rhashtable_iter *iter);
int rhashtable_walk_start(struct rhashtable_iter *iter) __acquires(RCU);
void *rhashtable_walk_next(struct rhashtable_iter *iter);
void rhashtable_walk_stop(struct rhashtable_iter *iter) __releases(RCU);

void rhashtable_free_and_destroy(struct rhashtable *ht,
				 void (*free_fn)(void *ptr, void *arg),
				 void *arg);
void rhashtable_destroy(struct rhashtable *ht);

#define rht_dereference(p, ht) \
	rcu_dereference_protected(p, lockdep_rht_mutex_is_held(ht))

#define rht_dereference_rcu(p, ht) \
	rcu_dereference_check(p, lockdep_rht_mutex_is_held(ht))

#define rht_dereference_bucket(p, tbl, hash) \
	rcu_dereference_protected(p, lockdep_rht_bucket_is_held(tbl, hash))

#define rht_dereference_bucket_rcu(p, tbl, hash) \
	rcu_dereference_check(p, lockdep_rht_bucket_is_held(tbl, hash))

#define rht_entry(tpos, pos, member) \
	({ tpos = container_of(pos, typeof(*tpos), member); 1; })

/**
 * rht_for_each_continue - continue iterating over hash chain
 * @pos:	the &struct rhash_head to use as a loop cursor.
 * @head:	the previous &struct rhash_head to continue from
 * @tbl:	the &struct bucket_table
 * @hash:	the hash value / bucket index
 */
#define rht_for_each_continue(pos, head, tbl, hash) \
	for (pos = rht_dereference_bucket(head, tbl, hash); \
	     !rht_is_a_nulls(pos); \
	     pos = rht_dereference_bucket((pos)->next, tbl, hash))

/**
 * rht_for_each - iterate over hash chain
 * @pos:	the &struct rhash_head to use as a loop cursor.
 * @tbl:	the &struct bucket_table
 * @hash:	the hash value / bucket index
 */
#define rht_for_each(pos, tbl, hash) \
	rht_for_each_continue(pos, (tbl)->buckets[hash], tbl, hash)

/**
 * rht_for_each_entry_continue - continue iterating over hash chain
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &struct rhash_head to use as a loop cursor.
 * @head:	the previous &struct rhash_head to continue from
 * @tbl:	the &struct bucket_table
 * @hash:	the hash value / bucket index
 * @member:	name of the &struct rhash_head within the hashable struct.
 */
#define rht_for_each_entry_continue(tpos, pos, head, tbl, hash, member)	\
	for (pos = rht_dereference_bucket(head, tbl, hash);		\
	     (!rht_is_a_nulls(pos)) && rht_entry(tpos, pos, member);	\
	     pos = rht_dereference_bucket((pos)->next, tbl, hash))

/**
 * rht_for_each_entry - iterate over hash chain of given type
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &struct rhash_head to use as a loop cursor.
 * @tbl:	the &struct bucket_table
 * @hash:	the hash value / bucket index
 * @member:	name of the &struct rhash_head within the hashable struct.
 */
#define rht_for_each_entry(tpos, pos, tbl, hash, member)		\
	rht_for_each_entry_continue(tpos, pos, (tbl)->buckets[hash],	\
				    tbl, hash, member)

/**
 * rht_for_each_entry_safe - safely iterate over hash chain of given type
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &struct rhash_head to use as a loop cursor.
 * @next:	the &struct rhash_head to use as next in loop cursor.
 * @tbl:	the &struct bucket_table
 * @hash:	the hash value / bucket index
 * @member:	name of the &struct rhash_head within the hashable struct.
 *
 * This hash chain list-traversal primitive allows for the looped code to
 * remove the loop cursor from the list.
 */
#define rht_for_each_entry_safe(tpos, pos, next, tbl, hash, member)	    \
	for (pos = rht_dereference_bucket((tbl)->buckets[hash], tbl, hash), \
	     next = !rht_is_a_nulls(pos) ?				    \
		       rht_dereference_bucket(pos->next, tbl, hash) : NULL; \
	     (!rht_is_a_nulls(pos)) && rht_entry(tpos, pos, member);	    \
	     pos = next,						    \
	     next = !rht_is_a_nulls(pos) ?				    \
		       rht_dereference_bucket(pos->next, tbl, hash) : NULL)

/**
 * rht_for_each_rcu_continue - continue iterating over rcu hash chain
 * @pos:	the &struct rhash_head to use as a loop cursor.
 * @head:	the previous &struct rhash_head to continue from
 * @tbl:	the &struct bucket_table
 * @hash:	the hash value / bucket index
 *
 * This hash chain list-traversal primitive may safely run concurrently with
 * the _rcu mutation primitives such as rhashtable_insert() as long as the
 * traversal is guarded by rcu_read_lock().
 */
#define rht_for_each_rcu_continue(pos, head, tbl, hash)			\
	for (({barrier(); }),						\
	     pos = rht_dereference_bucket_rcu(head, tbl, hash);		\
	     !rht_is_a_nulls(pos);					\
	     pos = rcu_dereference_raw(pos->next))

/**
 * rht_for_each_rcu - iterate over rcu hash chain
 * @pos:	the &struct rhash_head to use as a loop cursor.
 * @tbl:	the &struct bucket_table
 * @hash:	the hash value / bucket index
 *
 * This hash chain list-traversal primitive may safely run concurrently with
 * the _rcu mutation primitives such as rhashtable_insert() as long as the
 * traversal is guarded by rcu_read_lock().
 */
#define rht_for_each_rcu(pos, tbl, hash)				\
	rht_for_each_rcu_continue(pos, (tbl)->buckets[hash], tbl, hash)

/**
 * rht_for_each_entry_rcu_continue - continue iterating over rcu hash chain
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &struct rhash_head to use as a loop cursor.
 * @head:	the previous &struct rhash_head to continue from
 * @tbl:	the &struct bucket_table
 * @hash:	the hash value / bucket index
 * @member:	name of the &struct rhash_head within the hashable struct.
 *
 * This hash chain list-traversal primitive may safely run concurrently with
 * the _rcu mutation primitives such as rhashtable_insert() as long as the
 * traversal is guarded by rcu_read_lock().
 */
#define rht_for_each_entry_rcu_continue(tpos, pos, head, tbl, hash, member) \
	for (({barrier(); }),						    \
	     pos = rht_dereference_bucket_rcu(head, tbl, hash);		    \
	     (!rht_is_a_nulls(pos)) && rht_entry(tpos, pos, member);	    \
	     pos = rht_dereference_bucket_rcu(pos->next, tbl, hash))

/**
 * rht_for_each_entry_rcu - iterate over rcu hash chain of given type
 * @tpos:	the type * to use as a loop cursor.
 * @pos:	the &struct rhash_head to use as a loop cursor.
 * @tbl:	the &struct bucket_table
 * @hash:	the hash value / bucket index
 * @member:	name of the &struct rhash_head within the hashable struct.
 *
 * This hash chain list-traversal primitive may safely run concurrently with
 * the _rcu mutation primitives such as rhashtable_insert() as long as the
 * traversal is guarded by rcu_read_lock().
 */
#define rht_for_each_entry_rcu(tpos, pos, tbl, hash, member)		\
	rht_for_each_entry_rcu_continue(tpos, pos, (tbl)->buckets[hash],\
					tbl, hash, member)

static inline int rhashtable_compare(struct rhashtable_compare_arg *arg,
				     const void *obj)
{
	struct rhashtable *ht = arg->ht;
	const char *ptr = obj;

	return memcmp(ptr + ht->p.key_offset, arg->key, ht->p.key_len);
}

/**
 * rhashtable_lookup_fast - search hash table, inlined version
 * @ht:		hash table
 * @key:	the pointer to the key
 * @params:	hash table parameters
 *
 * Computes the hash value for the key and traverses the bucket chain looking
 * for a entry with an identical key. The first matching entry is returned.
 *
 * Returns the first entry on which the compare function returned true.
 */
static inline void *rhashtable_lookup_fast(
	struct rhashtable *ht, const void *key,
	const struct rhashtable_params params)
{
	struct rhashtable_compare_arg arg = {
		.ht = ht,
		.key = key,
	};
	const struct bucket_table *tbl;
	struct rhash_head *he;
	unsigned int hash;

	rcu_read_lock();

	tbl = rht_dereference_rcu(ht->tbl, ht);
restart:
	hash = rht_key_hashfn(ht, tbl, key, params);
	rht_for_each_rcu(he, tbl, hash) {
		if (params.obj_cmpfn ?
		    params.obj_cmpfn(&arg, rht_obj(ht, he)) :
		    rhashtable_compare(&arg, rht_obj(ht, he)))
			continue;
		rcu_read_unlock();
		return rht_obj(ht, he);
	}

	/* Ensure we see any new tables. */
	smp_rmb();

	tbl = rht_dereference_rcu(tbl->future_tbl, ht);
	if (unlikely(tbl))
		goto restart;
	rcu_read_unlock();

	return NULL;
}

/* Internal function, please use rhashtable_insert_fast() instead */
static inline int __rhashtable_insert_fast(
	struct rhashtable *ht, const void *key, struct rhash_head *obj,
	const struct rhashtable_params params)
{
	struct rhashtable_compare_arg arg = {
		.ht = ht,
		.key = key,
	};
	struct bucket_table *tbl, *new_tbl;
	struct rhash_head *head;
	spinlock_t *lock;
	unsigned int elasticity;
	unsigned int hash;
	int err;

restart:
	rcu_read_lock();

	tbl = rht_dereference_rcu(ht->tbl, ht);

	/* All insertions must grab the oldest table containing
	 * the hashed bucket that is yet to be rehashed.
	 */
	for (;;) {
		hash = rht_head_hashfn(ht, tbl, obj, params);
		lock = rht_bucket_lock(tbl, hash);
		spin_lock_bh(lock);

		if (tbl->rehash <= hash)
			break;

		spin_unlock_bh(lock);
		tbl = rht_dereference_rcu(tbl->future_tbl, ht);
	}

	new_tbl = rht_dereference_rcu(tbl->future_tbl, ht);
	if (unlikely(new_tbl)) {
		err = rhashtable_insert_slow(ht, key, obj, new_tbl);
		if (err == -EAGAIN)
			goto slow_path;
		goto out;
	}

	err = -E2BIG;
	if (unlikely(rht_grow_above_max(ht, tbl)))
		goto out;

	if (unlikely(rht_grow_above_100(ht, tbl))) {
slow_path:
		spin_unlock_bh(lock);
		err = rhashtable_insert_rehash(ht);
		rcu_read_unlock();
		if (err)
			return err;

		goto restart;
	}

	err = -EEXIST;
	elasticity = ht->elasticity;
	rht_for_each(head, tbl, hash) {
		if (key &&
		    unlikely(!(params.obj_cmpfn ?
			       params.obj_cmpfn(&arg, rht_obj(ht, head)) :
			       rhashtable_compare(&arg, rht_obj(ht, head)))))
			goto out;
		if (!--elasticity)
			goto slow_path;
	}

	err = 0;

	head = rht_dereference_bucket(tbl->buckets[hash], tbl, hash);

	RCU_INIT_POINTER(obj->next, head);

	rcu_assign_pointer(tbl->buckets[hash], obj);

	atomic_inc(&ht->nelems);
	if (rht_grow_above_75(ht, tbl))
		schedule_work(&ht->run_work);

out:
	spin_unlock_bh(lock);
	rcu_read_unlock();

	return err;
}

/**
 * rhashtable_insert_fast - insert object into hash table
 * @ht:		hash table
 * @obj:	pointer to hash head inside object
 * @params:	hash table parameters
 *
 * Will take a per bucket spinlock to protect against mutual mutations
 * on the same bucket. Multiple insertions may occur in parallel unless
 * they map to the same bucket lock.
 *
 * It is safe to call this function from atomic context.
 *
 * Will trigger an automatic deferred table resizing if the size grows
 * beyond the watermark indicated by grow_decision() which can be passed
 * to rhashtable_init().
 */
static inline int rhashtable_insert_fast(
	struct rhashtable *ht, struct rhash_head *obj,
	const struct rhashtable_params params)
{
	return __rhashtable_insert_fast(ht, NULL, obj, params);
}

/**
 * rhashtable_lookup_insert_fast - lookup and insert object into hash table
 * @ht:		hash table
 * @obj:	pointer to hash head inside object
 * @params:	hash table parameters
 *
 * Locks down the bucket chain in both the old and new table if a resize
 * is in progress to ensure that writers can't remove from the old table
 * and can't insert to the new table during the atomic operation of search
 * and insertion. Searches for duplicates in both the old and new table if
 * a resize is in progress.
 *
 * This lookup function may only be used for fixed key hash table (key_len
 * parameter set). It will BUG() if used inappropriately.
 *
 * It is safe to call this function from atomic context.
 *
 * Will trigger an automatic deferred table resizing if the size grows
 * beyond the watermark indicated by grow_decision() which can be passed
 * to rhashtable_init().
 */
static inline int rhashtable_lookup_insert_fast(
	struct rhashtable *ht, struct rhash_head *obj,
	const struct rhashtable_params params)
{
	const char *key = rht_obj(ht, obj);

	BUG_ON(ht->p.obj_hashfn);

	return __rhashtable_insert_fast(ht, key + ht->p.key_offset, obj,
					params);
}

/**
 * rhashtable_lookup_insert_key - search and insert object to hash table
 *				  with explicit key
 * @ht:		hash table
 * @key:	key
 * @obj:	pointer to hash head inside object
 * @params:	hash table parameters
 *
 * Locks down the bucket chain in both the old and new table if a resize
 * is in progress to ensure that writers can't remove from the old table
 * and can't insert to the new table during the atomic operation of search
 * and insertion. Searches for duplicates in both the old and new table if
 * a resize is in progress.
 *
 * Lookups may occur in parallel with hashtable mutations and resizing.
 *
 * Will trigger an automatic deferred table resizing if the size grows
 * beyond the watermark indicated by grow_decision() which can be passed
 * to rhashtable_init().
 *
 * Returns zero on success.
 */
static inline int rhashtable_lookup_insert_key(
	struct rhashtable *ht, const void *key, struct rhash_head *obj,
	const struct rhashtable_params params)
{
	BUG_ON(!ht->p.obj_hashfn || !key);

	return __rhashtable_insert_fast(ht, key, obj, params);
}

/* Internal function, please use rhashtable_remove_fast() instead */
static inline int __rhashtable_remove_fast(
	struct rhashtable *ht, struct bucket_table *tbl,
	struct rhash_head *obj, const struct rhashtable_params params)
{
	struct rhash_head __rcu **pprev;
	struct rhash_head *he;
	spinlock_t * lock;
	unsigned int hash;
	int err = -ENOENT;

	hash = rht_head_hashfn(ht, tbl, obj, params);
	lock = rht_bucket_lock(tbl, hash);

	spin_lock_bh(lock);

	pprev = &tbl->buckets[hash];
	rht_for_each(he, tbl, hash) {
		if (he != obj) {
			pprev = &he->next;
			continue;
		}

		rcu_assign_pointer(*pprev, obj->next);
		err = 0;
		break;
	}

	spin_unlock_bh(lock);

	return err;
}

/**
 * rhashtable_remove_fast - remove object from hash table
 * @ht:		hash table
 * @obj:	pointer to hash head inside object
 * @params:	hash table parameters
 *
 * Since the hash chain is single linked, the removal operation needs to
 * walk the bucket chain upon removal. The removal operation is thus
 * considerable slow if the hash table is not correctly sized.
 *
 * Will automatically shrink the table via rhashtable_expand() if the
 * shrink_decision function specified at rhashtable_init() returns true.
 *
 * Returns zero on success, -ENOENT if the entry could not be found.
 */
static inline int rhashtable_remove_fast(
	struct rhashtable *ht, struct rhash_head *obj,
	const struct rhashtable_params params)
{
	struct bucket_table *tbl;
	int err;

	rcu_read_lock();

	tbl = rht_dereference_rcu(ht->tbl, ht);

	/* Because we have already taken (and released) the bucket
	 * lock in old_tbl, if we find that future_tbl is not yet
	 * visible then that guarantees the entry to still be in
	 * the old tbl if it exists.
	 */
	while ((err = __rhashtable_remove_fast(ht, tbl, obj, params)) &&
	       (tbl = rht_dereference_rcu(tbl->future_tbl, ht)))
		;

	if (err)
		goto out;

	atomic_dec(&ht->nelems);
	if (unlikely(ht->p.automatic_shrinking &&
		     rht_shrink_below_30(ht, tbl)))
		schedule_work(&ht->run_work);

out:
	rcu_read_unlock();

	return err;
}

#endif /* _LINUX_RHASHTABLE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * Copyright (c) 2011, NVIDIA Corporation.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */


#ifndef __RFKILL_GPIO_H
#define __RFKILL_GPIO_H

#include <linux/types.h>
#include <linux/rfkill.h>

/**
 * struct rfkill_gpio_platform_data - platform data for rfkill gpio device.
 * for unused gpio's, the expected value is -1.
 * @name:		name for the gpio rf kill instance
 */

struct rfkill_gpio_platform_data {
	char			*name;
	enum rfkill_type	type;
};

#endif /* __RFKILL_GPIO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * sysfs.h - definitions for the device driver filesystem
 *
 * Copyright (c) 2001,2002 Patrick Mochel
 * Copyright (c) 2004 Silicon Graphics, Inc.
 * Copyright (c) 2007 SUSE Linux Products GmbH
 * Copyright (c) 2007 Tejun Heo <teheo@suse.de>
 *
 * Please see Documentation/filesystems/sysfs.txt for more information.
 */

#ifndef _SYSFS_H_
#define _SYSFS_H_

#include <linux/kernfs.h>
#include <linux/compiler.h>
#include <linux/errno.h>
#include <linux/list.h>
#include <linux/lockdep.h>
#include <linux/kobject_ns.h>
#include <linux/stat.h>
#include <linux/atomic.h>

struct kobject;
struct module;
struct bin_attribute;
enum kobj_ns_type;

struct attribute {
	const char		*name;
	umode_t			mode;
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	bool			ignore_lockdep:1;
	struct lock_class_key	*key;
	struct lock_class_key	skey;
#endif
};

/**
 *	sysfs_attr_init - initialize a dynamically allocated sysfs attribute
 *	@attr: struct attribute to initialize
 *
 *	Initialize a dynamically allocated struct attribute so we can
 *	make lockdep happy.  This is a new requirement for attributes
 *	and initially this is only needed when lockdep is enabled.
 *	Lockdep gives a nice error when your attribute is added to
 *	sysfs if you don't have this.
 */
#ifdef CONFIG_DEBUG_LOCK_ALLOC
#define sysfs_attr_init(attr)				\
do {							\
	static struct lock_class_key __key;		\
							\
	(attr)->key = &__key;				\
} while (0)
#else
#define sysfs_attr_init(attr) do {} while (0)
#endif

/**
 * struct attribute_group - data structure used to declare an attribute group.
 * @name:	Optional: Attribute group name
 *		If specified, the attribute group will be created in
 *		a new subdirectory with this name.
 * @is_visible:	Optional: Function to return permissions associated with an
 *		attribute of the group. Will be called repeatedly for each
 *		attribute in the group. Only read/write permissions as well as
 *		SYSFS_PREALLOC are accepted. Must return 0 if an attribute is
 *		not visible. The returned value will replace static permissions
 *		defined in struct attribute or struct bin_attribute.
 * @attrs:	Pointer to NULL terminated list of attributes.
 * @bin_attrs:	Pointer to NULL terminated list of binary attributes.
 *		Either attrs or bin_attrs or both must be provided.
 */
struct attribute_group {
	const char		*name;
	umode_t			(*is_visible)(struct kobject *,
					      struct attribute *, int);
	struct attribute	**attrs;
	struct bin_attribute	**bin_attrs;
};

/**
 * Use these macros to make defining attributes easier. See include/linux/device.h
 * for examples..
 */

#define SYSFS_PREALLOC 010000

#define __ATTR(_name, _mode, _show, _store) {				\
	.attr = {.name = __stringify(_name),				\
		 .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },		\
	.show	= _show,						\
	.store	= _store,						\
}

#define __ATTR_PREALLOC(_name, _mode, _show, _store) {			\
	.attr = {.name = __stringify(_name),				\
		 .mode = SYSFS_PREALLOC | VERIFY_OCTAL_PERMISSIONS(_mode) },\
	.show	= _show,						\
	.store	= _store,						\
}

#define __ATTR_RO(_name) {						\
	.attr	= { .name = __stringify(_name), .mode = S_IRUGO },	\
	.show	= _name##_show,						\
}

#define __ATTR_WO(_name) {						\
	.attr	= { .name = __stringify(_name), .mode = S_IWUSR },	\
	.store	= _name##_store,					\
}

#define __ATTR_RW(_name) __ATTR(_name, (S_IWUSR | S_IRUGO),		\
			 _name##_show, _name##_store)

#define __ATTR_NULL { .attr = { .name = NULL } }

#ifdef CONFIG_DEBUG_LOCK_ALLOC
#define __ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) {	\
	.attr = {.name = __stringify(_name), .mode = _mode,	\
			.ignore_lockdep = true },		\
	.show		= _show,				\
	.store		= _store,				\
}
#else
#define __ATTR_IGNORE_LOCKDEP	__ATTR
#endif

#define __ATTRIBUTE_GROUPS(_name)				\
static const struct attribute_group *_name##_groups[] = {	\
	&_name##_group,						\
	NULL,							\
}

#define ATTRIBUTE_GROUPS(_name)					\
static const struct attribute_group _name##_group = {		\
	.attrs = _name##_attrs,					\
};								\
__ATTRIBUTE_GROUPS(_name)

struct file;
struct vm_area_struct;

struct bin_attribute {
	struct attribute	attr;
	size_t			size;
	void			*private;
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *,
			char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *,
			 char *, loff_t, size_t);
	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *attr,
		    struct vm_area_struct *vma);
};

/**
 *	sysfs_bin_attr_init - initialize a dynamically allocated bin_attribute
 *	@attr: struct bin_attribute to initialize
 *
 *	Initialize a dynamically allocated struct bin_attribute so we
 *	can make lockdep happy.  This is a new requirement for
 *	attributes and initially this is only needed when lockdep is
 *	enabled.  Lockdep gives a nice error when your attribute is
 *	added to sysfs if you don't have this.
 */
#define sysfs_bin_attr_init(bin_attr) sysfs_attr_init(&(bin_attr)->attr)

/* macros to create static binary attributes easier */
#define __BIN_ATTR(_name, _mode, _read, _write, _size) {		\
	.attr = { .name = __stringify(_name), .mode = _mode },		\
	.read	= _read,						\
	.write	= _write,						\
	.size	= _size,						\
}

#define __BIN_ATTR_RO(_name, _size) {					\
	.attr	= { .name = __stringify(_name), .mode = S_IRUGO },	\
	.read	= _name##_read,						\
	.size	= _size,						\
}

#define __BIN_ATTR_RW(_name, _size) __BIN_ATTR(_name,			\
				   (S_IWUSR | S_IRUGO), _name##_read,	\
				   _name##_write, _size)

#define __BIN_ATTR_NULL __ATTR_NULL

#define BIN_ATTR(_name, _mode, _read, _write, _size)			\
struct bin_attribute bin_attr_##_name = __BIN_ATTR(_name, _mode, _read,	\
					_write, _size)

#define BIN_ATTR_RO(_name, _size)					\
struct bin_attribute bin_attr_##_name = __BIN_ATTR_RO(_name, _size)

#define BIN_ATTR_RW(_name, _size)					\
struct bin_attribute bin_attr_##_name = __BIN_ATTR_RW(_name, _size)

struct sysfs_ops {
	ssize_t	(*show)(struct kobject *, struct attribute *, char *);
	ssize_t	(*store)(struct kobject *, struct attribute *, const char *, size_t);
};

#ifdef CONFIG_SYSFS

int __must_check sysfs_create_dir_ns(struct kobject *kobj, const void *ns);
void sysfs_remove_dir(struct kobject *kobj);
int __must_check sysfs_rename_dir_ns(struct kobject *kobj, const char *new_name,
				     const void *new_ns);
int __must_check sysfs_move_dir_ns(struct kobject *kobj,
				   struct kobject *new_parent_kobj,
				   const void *new_ns);
int __must_check sysfs_create_mount_point(struct kobject *parent_kobj,
					  const char *name);
void sysfs_remove_mount_point(struct kobject *parent_kobj,
			      const char *name);

int __must_check sysfs_create_file_ns(struct kobject *kobj,
				      const struct attribute *attr,
				      const void *ns);
int __must_check sysfs_create_files(struct kobject *kobj,
				   const struct attribute **attr);
int __must_check sysfs_chmod_file(struct kobject *kobj,
				  const struct attribute *attr, umode_t mode);
void sysfs_remove_file_ns(struct kobject *kobj, const struct attribute *attr,
			  const void *ns);
bool sysfs_remove_file_self(struct kobject *kobj, const struct attribute *attr);
void sysfs_remove_files(struct kobject *kobj, const struct attribute **attr);

int __must_check sysfs_create_bin_file(struct kobject *kobj,
				       const struct bin_attribute *attr);
void sysfs_remove_bin_file(struct kobject *kobj,
			   const struct bin_attribute *attr);

int __must_check sysfs_create_link(struct kobject *kobj, struct kobject *target,
				   const char *name);
int __must_check sysfs_create_link_nowarn(struct kobject *kobj,
					  struct kobject *target,
					  const char *name);
void sysfs_remove_link(struct kobject *kobj, const char *name);

int sysfs_rename_link_ns(struct kobject *kobj, struct kobject *target,
			 const char *old_name, const char *new_name,
			 const void *new_ns);

void sysfs_delete_link(struct kobject *dir, struct kobject *targ,
			const char *name);

int __must_check sysfs_create_group(struct kobject *kobj,
				    const struct attribute_group *grp);
int __must_check sysfs_create_groups(struct kobject *kobj,
				     const struct attribute_group **groups);
int sysfs_update_group(struct kobject *kobj,
		       const struct attribute_group *grp);
void sysfs_remove_group(struct kobject *kobj,
			const struct attribute_group *grp);
void sysfs_remove_groups(struct kobject *kobj,
			 const struct attribute_group **groups);
int sysfs_add_file_to_group(struct kobject *kobj,
			const struct attribute *attr, const char *group);
void sysfs_remove_file_from_group(struct kobject *kobj,
			const struct attribute *attr, const char *group);
int sysfs_merge_group(struct kobject *kobj,
		       const struct attribute_group *grp);
void sysfs_unmerge_group(struct kobject *kobj,
		       const struct attribute_group *grp);
int sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,
			    struct kobject *target, const char *link_name);
void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
				  const char *link_name);

void sysfs_notify(struct kobject *kobj, const char *dir, const char *attr);

int __must_check sysfs_init(void);

static inline void sysfs_enable_ns(struct kernfs_node *kn)
{
	return kernfs_enable_ns(kn);
}

#else /* CONFIG_SYSFS */

static inline int sysfs_create_dir_ns(struct kobject *kobj, const void *ns)
{
	return 0;
}

static inline void sysfs_remove_dir(struct kobject *kobj)
{
}

static inline int sysfs_rename_dir_ns(struct kobject *kobj,
				      const char *new_name, const void *new_ns)
{
	return 0;
}

static inline int sysfs_move_dir_ns(struct kobject *kobj,
				    struct kobject *new_parent_kobj,
				    const void *new_ns)
{
	return 0;
}

static inline int sysfs_create_mount_point(struct kobject *parent_kobj,
					   const char *name)
{
	return 0;
}

static inline void sysfs_remove_mount_point(struct kobject *parent_kobj,
					    const char *name)
{
}

static inline int sysfs_create_file_ns(struct kobject *kobj,
				       const struct attribute *attr,
				       const void *ns)
{
	return 0;
}

static inline int sysfs_create_files(struct kobject *kobj,
				    const struct attribute **attr)
{
	return 0;
}

static inline int sysfs_chmod_file(struct kobject *kobj,
				   const struct attribute *attr, umode_t mode)
{
	return 0;
}

static inline void sysfs_remove_file_ns(struct kobject *kobj,
					const struct attribute *attr,
					const void *ns)
{
}

static inline bool sysfs_remove_file_self(struct kobject *kobj,
					  const struct attribute *attr)
{
	return false;
}

static inline void sysfs_remove_files(struct kobject *kobj,
				     const struct attribute **attr)
{
}

static inline int sysfs_create_bin_file(struct kobject *kobj,
					const struct bin_attribute *attr)
{
	return 0;
}

static inline void sysfs_remove_bin_file(struct kobject *kobj,
					 const struct bin_attribute *attr)
{
}

static inline int sysfs_create_link(struct kobject *kobj,
				    struct kobject *target, const char *name)
{
	return 0;
}

static inline int sysfs_create_link_nowarn(struct kobject *kobj,
					   struct kobject *target,
					   const char *name)
{
	return 0;
}

static inline void sysfs_remove_link(struct kobject *kobj, const char *name)
{
}

static inline int sysfs_rename_link_ns(struct kobject *k, struct kobject *t,
				       const char *old_name,
				       const char *new_name, const void *ns)
{
	return 0;
}

static inline void sysfs_delete_link(struct kobject *k, struct kobject *t,
				     const char *name)
{
}

static inline int sysfs_create_group(struct kobject *kobj,
				     const struct attribute_group *grp)
{
	return 0;
}

static inline int sysfs_create_groups(struct kobject *kobj,
				      const struct attribute_group **groups)
{
	return 0;
}

static inline int sysfs_update_group(struct kobject *kobj,
				const struct attribute_group *grp)
{
	return 0;
}

static inline void sysfs_remove_group(struct kobject *kobj,
				      const struct attribute_group *grp)
{
}

static inline void sysfs_remove_groups(struct kobject *kobj,
				       const struct attribute_group **groups)
{
}

static inline int sysfs_add_file_to_group(struct kobject *kobj,
		const struct attribute *attr, const char *group)
{
	return 0;
}

static inline void sysfs_remove_file_from_group(struct kobject *kobj,
		const struct attribute *attr, const char *group)
{
}

static inline int sysfs_merge_group(struct kobject *kobj,
		       const struct attribute_group *grp)
{
	return 0;
}

static inline void sysfs_unmerge_group(struct kobject *kobj,
		       const struct attribute_group *grp)
{
}

static inline int sysfs_add_link_to_group(struct kobject *kobj,
		const char *group_name, struct kobject *target,
		const char *link_name)
{
	return 0;
}

static inline void sysfs_remove_link_from_group(struct kobject *kobj,
		const char *group_name, const char *link_name)
{
}

static inline void sysfs_notify(struct kobject *kobj, const char *dir,
				const char *attr)
{
}

static inline int __must_check sysfs_init(void)
{
	return 0;
}

static inline void sysfs_enable_ns(struct kernfs_node *kn)
{
}

#endif /* CONFIG_SYSFS */

static inline int __must_check sysfs_create_file(struct kobject *kobj,
						 const struct attribute *attr)
{
	return sysfs_create_file_ns(kobj, attr, NULL);
}

static inline void sysfs_remove_file(struct kobject *kobj,
				     const struct attribute *attr)
{
	sysfs_remove_file_ns(kobj, attr, NULL);
}

static inline int sysfs_rename_link(struct kobject *kobj, struct kobject *target,
				    const char *old_name, const char *new_name)
{
	return sysfs_rename_link_ns(kobj, target, old_name, new_name, NULL);
}

static inline void sysfs_notify_dirent(struct kernfs_node *kn)
{
	kernfs_notify(kn);
}

static inline struct kernfs_node *sysfs_get_dirent(struct kernfs_node *parent,
						   const unsigned char *name)
{
	return kernfs_find_and_get(parent, name);
}

static inline struct kernfs_node *sysfs_get(struct kernfs_node *kn)
{
	kernfs_get(kn);
	return kn;
}

static inline void sysfs_put(struct kernfs_node *kn)
{
	kernfs_put(kn);
}

#endif /* _SYSFS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * include/linux/atmel_serial.h
 *
 * Copyright (C) 2005 Ivan Kokshaysky
 * Copyright (C) SAN People
 *
 * USART registers.
 * Based on AT91RM9200 datasheet revision E.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef ATMEL_SERIAL_H
#define ATMEL_SERIAL_H

#define ATMEL_US_CR		0x00			/* Control Register */
#define		ATMEL_US_RSTRX		(1 <<  2)		/* Reset Receiver */
#define		ATMEL_US_RSTTX		(1 <<  3)		/* Reset Transmitter */
#define		ATMEL_US_RXEN		(1 <<  4)		/* Receiver Enable */
#define		ATMEL_US_RXDIS		(1 <<  5)		/* Receiver Disable */
#define		ATMEL_US_TXEN		(1 <<  6)		/* Transmitter Enable */
#define		ATMEL_US_TXDIS		(1 <<  7)		/* Transmitter Disable */
#define		ATMEL_US_RSTSTA		(1 <<  8)		/* Reset Status Bits */
#define		ATMEL_US_STTBRK		(1 <<  9)		/* Start Break */
#define		ATMEL_US_STPBRK		(1 << 10)		/* Stop Break */
#define		ATMEL_US_STTTO		(1 << 11)		/* Start Time-out */
#define		ATMEL_US_SENDA		(1 << 12)		/* Send Address */
#define		ATMEL_US_RSTIT		(1 << 13)		/* Reset Iterations */
#define		ATMEL_US_RSTNACK	(1 << 14)		/* Reset Non Acknowledge */
#define		ATMEL_US_RETTO		(1 << 15)		/* Rearm Time-out */
#define		ATMEL_US_DTREN		(1 << 16)		/* Data Terminal Ready Enable [AT91RM9200 only] */
#define		ATMEL_US_DTRDIS		(1 << 17)		/* Data Terminal Ready Disable [AT91RM9200 only] */
#define		ATMEL_US_RTSEN		(1 << 18)		/* Request To Send Enable */
#define		ATMEL_US_RTSDIS		(1 << 19)		/* Request To Send Disable */

#define ATMEL_US_MR		0x04			/* Mode Register */
#define		ATMEL_US_USMODE		(0xf <<  0)		/* Mode of the USART */
#define			ATMEL_US_USMODE_NORMAL		0
#define			ATMEL_US_USMODE_RS485		1
#define			ATMEL_US_USMODE_HWHS		2
#define			ATMEL_US_USMODE_MODEM		3
#define			ATMEL_US_USMODE_ISO7816_T0	4
#define			ATMEL_US_USMODE_ISO7816_T1	6
#define			ATMEL_US_USMODE_IRDA		8
#define		ATMEL_US_USCLKS		(3   <<  4)		/* Clock Selection */
#define			ATMEL_US_USCLKS_MCK		(0 <<  4)
#define			ATMEL_US_USCLKS_MCK_DIV8	(1 <<  4)
#define			ATMEL_US_USCLKS_SCK		(3 <<  4)
#define		ATMEL_US_CHRL		(3   <<  6)		/* Character Length */
#define			ATMEL_US_CHRL_5			(0 <<  6)
#define			ATMEL_US_CHRL_6			(1 <<  6)
#define			ATMEL_US_CHRL_7			(2 <<  6)
#define			ATMEL_US_CHRL_8			(3 <<  6)
#define		ATMEL_US_SYNC		(1 <<  8)		/* Synchronous Mode Select */
#define		ATMEL_US_PAR		(7 <<  9)		/* Parity Type */
#define			ATMEL_US_PAR_EVEN		(0 <<  9)
#define			ATMEL_US_PAR_ODD		(1 <<  9)
#define			ATMEL_US_PAR_SPACE		(2 <<  9)
#define			ATMEL_US_PAR_MARK		(3 <<  9)
#define			ATMEL_US_PAR_NONE		(4 <<  9)
#define			ATMEL_US_PAR_MULTI_DROP		(6 <<  9)
#define		ATMEL_US_NBSTOP		(3 << 12)		/* Number of Stop Bits */
#define			ATMEL_US_NBSTOP_1		(0 << 12)
#define			ATMEL_US_NBSTOP_1_5		(1 << 12)
#define			ATMEL_US_NBSTOP_2		(2 << 12)
#define		ATMEL_US_CHMODE		(3 << 14)		/* Channel Mode */
#define			ATMEL_US_CHMODE_NORMAL		(0 << 14)
#define			ATMEL_US_CHMODE_ECHO		(1 << 14)
#define			ATMEL_US_CHMODE_LOC_LOOP	(2 << 14)
#define			ATMEL_US_CHMODE_REM_LOOP	(3 << 14)
#define		ATMEL_US_MSBF		(1 << 16)		/* Bit Order */
#define		ATMEL_US_MODE9		(1 << 17)		/* 9-bit Character Length */
#define		ATMEL_US_CLKO		(1 << 18)		/* Clock Output Select */
#define		ATMEL_US_OVER		(1 << 19)		/* Oversampling Mode */
#define		ATMEL_US_INACK		(1 << 20)		/* Inhibit Non Acknowledge */
#define		ATMEL_US_DSNACK		(1 << 21)		/* Disable Successive NACK */
#define		ATMEL_US_MAX_ITER	(7 << 24)		/* Max Iterations */
#define		ATMEL_US_FILTER		(1 << 28)		/* Infrared Receive Line Filter */

#define ATMEL_US_IER		0x08			/* Interrupt Enable Register */
#define		ATMEL_US_RXRDY		(1 <<  0)		/* Receiver Ready */
#define		ATMEL_US_TXRDY		(1 <<  1)		/* Transmitter Ready */
#define		ATMEL_US_RXBRK		(1 <<  2)		/* Break Received / End of Break */
#define		ATMEL_US_ENDRX		(1 <<  3)		/* End of Receiver Transfer */
#define		ATMEL_US_ENDTX		(1 <<  4)		/* End of Transmitter Transfer */
#define		ATMEL_US_OVRE		(1 <<  5)		/* Overrun Error */
#define		ATMEL_US_FRAME		(1 <<  6)		/* Framing Error */
#define		ATMEL_US_PARE		(1 <<  7)		/* Parity Error */
#define		ATMEL_US_TIMEOUT	(1 <<  8)		/* Receiver Time-out */
#define		ATMEL_US_TXEMPTY	(1 <<  9)		/* Transmitter Empty */
#define		ATMEL_US_ITERATION	(1 << 10)		/* Max number of Repetitions Reached */
#define		ATMEL_US_TXBUFE		(1 << 11)		/* Transmission Buffer Empty */
#define		ATMEL_US_RXBUFF		(1 << 12)		/* Reception Buffer Full */
#define		ATMEL_US_NACK		(1 << 13)		/* Non Acknowledge */
#define		ATMEL_US_RIIC		(1 << 16)		/* Ring Indicator Input Change [AT91RM9200 only] */
#define		ATMEL_US_DSRIC		(1 << 17)		/* Data Set Ready Input Change [AT91RM9200 only] */
#define		ATMEL_US_DCDIC		(1 << 18)		/* Data Carrier Detect Input Change [AT91RM9200 only] */
#define		ATMEL_US_CTSIC		(1 << 19)		/* Clear to Send Input Change */
#define		ATMEL_US_RI		(1 << 20)		/* RI */
#define		ATMEL_US_DSR		(1 << 21)		/* DSR */
#define		ATMEL_US_DCD		(1 << 22)		/* DCD */
#define		ATMEL_US_CTS		(1 << 23)		/* CTS */

#define ATMEL_US_IDR		0x0c			/* Interrupt Disable Register */
#define ATMEL_US_IMR		0x10			/* Interrupt Mask Register */
#define ATMEL_US_CSR		0x14			/* Channel Status Register */
#define ATMEL_US_RHR		0x18			/* Receiver Holding Register */
#define ATMEL_US_THR		0x1c			/* Transmitter Holding Register */
#define		ATMEL_US_SYNH		(1 << 15)		/* Transmit/Receive Sync [AT91SAM9261 only] */

#define ATMEL_US_BRGR		0x20			/* Baud Rate Generator Register */
#define		ATMEL_US_CD		(0xffff << 0)		/* Clock Divider */

#define ATMEL_US_RTOR		0x24			/* Receiver Time-out Register */
#define		ATMEL_US_TO		(0xffff << 0)		/* Time-out Value */

#define ATMEL_US_TTGR		0x28			/* Transmitter Timeguard Register */
#define		ATMEL_US_TG		(0xff << 0)		/* Timeguard Value */

#define ATMEL_US_FIDI		0x40			/* FI DI Ratio Register */
#define ATMEL_US_NER		0x44			/* Number of Errors Register */
#define ATMEL_US_IF		0x4c			/* IrDA Filter Register */

#define ATMEL_US_NAME		0xf0			/* Ip Name */
#define ATMEL_US_VERSION	0xfc			/* Ip Version */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /* $Id: isdn.h,v 1.125.2.3 2004/02/10 01:07:14 keil Exp $
 *
 * Main header for the Linux ISDN subsystem (linklevel).
 *
 * Copyright 1994,95,96 by Fritz Elfert (fritz@isdn4linux.de)
 * Copyright 1995,96    by Thinking Objects Software GmbH Wuerzburg
 * Copyright 1995,96    by Michael Hipp (Michael.Hipp@student.uni-tuebingen.de)
 * 
 * This software may be used and distributed according to the terms
 * of the GNU General Public License, incorporated herein by reference.
 *
 */
#ifndef __ISDN_H__
#define __ISDN_H__


#include <linux/errno.h>
#include <linux/fs.h>
#include <linux/major.h>
#include <asm/io.h>
#include <linux/kernel.h>
#include <linux/signal.h>
#include <linux/slab.h>
#include <linux/timer.h>
#include <linux/wait.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/serial_reg.h>
#include <linux/fcntl.h>
#include <linux/types.h>
#include <linux/interrupt.h>
#include <linux/ip.h>
#include <linux/in.h>
#include <linux/netdevice.h>
#include <linux/etherdevice.h>
#include <linux/skbuff.h>
#include <linux/tcp.h>
#include <linux/mutex.h>
#include <uapi/linux/isdn.h>

#define ISDN_TTY_MAJOR    43
#define ISDN_TTYAUX_MAJOR 44
#define ISDN_MAJOR        45

/* The minor-devicenumbers for Channel 0 and 1 are used as arguments for
 * physical Channel-Mapping, so they MUST NOT be changed without changing
 * the correspondent code in isdn.c
 */

#define ISDN_MINOR_B        0
#define ISDN_MINOR_BMAX     (ISDN_MAX_CHANNELS-1)
#define ISDN_MINOR_CTRL     64
#define ISDN_MINOR_CTRLMAX  (64 + (ISDN_MAX_CHANNELS-1))
#define ISDN_MINOR_PPP      128
#define ISDN_MINOR_PPPMAX   (128 + (ISDN_MAX_CHANNELS-1))
#define ISDN_MINOR_STATUS   255

#ifdef CONFIG_ISDN_PPP

#ifdef CONFIG_ISDN_PPP_VJ
#  include <net/slhc_vj.h>
#endif

#include <linux/ppp_defs.h>
#include <linux/ppp-ioctl.h>

#include <linux/isdn_ppp.h>
#endif

#ifdef CONFIG_ISDN_X25
#  include <linux/concap.h>
#endif

#include <linux/isdnif.h>

#define ISDN_DRVIOCTL_MASK       0x7f  /* Mask for Device-ioctl */

/* Until now unused */
#define ISDN_SERVICE_VOICE 1
#define ISDN_SERVICE_AB    1<<1 
#define ISDN_SERVICE_X21   1<<2
#define ISDN_SERVICE_G4    1<<3
#define ISDN_SERVICE_BTX   1<<4
#define ISDN_SERVICE_DFUE  1<<5
#define ISDN_SERVICE_X25   1<<6
#define ISDN_SERVICE_TTX   1<<7
#define ISDN_SERVICE_MIXED 1<<8
#define ISDN_SERVICE_FW    1<<9
#define ISDN_SERVICE_GTEL  1<<10
#define ISDN_SERVICE_BTXN  1<<11
#define ISDN_SERVICE_BTEL  1<<12

/* Macros checking plain usage */
#define USG_NONE(x)         ((x & ISDN_USAGE_MASK)==ISDN_USAGE_NONE)
#define USG_RAW(x)          ((x & ISDN_USAGE_MASK)==ISDN_USAGE_RAW)
#define USG_MODEM(x)        ((x & ISDN_USAGE_MASK)==ISDN_USAGE_MODEM)
#define USG_VOICE(x)        ((x & ISDN_USAGE_MASK)==ISDN_USAGE_VOICE)
#define USG_NET(x)          ((x & ISDN_USAGE_MASK)==ISDN_USAGE_NET)
#define USG_FAX(x)          ((x & ISDN_USAGE_MASK)==ISDN_USAGE_FAX)
#define USG_OUTGOING(x)     ((x & ISDN_USAGE_OUTGOING)==ISDN_USAGE_OUTGOING)
#define USG_MODEMORVOICE(x) (((x & ISDN_USAGE_MASK)==ISDN_USAGE_MODEM) || \
                             ((x & ISDN_USAGE_MASK)==ISDN_USAGE_VOICE)     )

/* Timer-delays and scheduling-flags */
#define ISDN_TIMER_RES         4                         /* Main Timer-Resolution   */
#define ISDN_TIMER_02SEC       (HZ/ISDN_TIMER_RES/5)     /* Slow-Timer1 .2 sec      */
#define ISDN_TIMER_1SEC        (HZ/ISDN_TIMER_RES)       /* Slow-Timer2 1 sec       */
#define ISDN_TIMER_RINGING     5 /* tty RINGs = ISDN_TIMER_1SEC * this factor       */
#define ISDN_TIMER_KEEPINT    10 /* Cisco-Keepalive = ISDN_TIMER_1SEC * this factor */
#define ISDN_TIMER_MODEMREAD   1
#define ISDN_TIMER_MODEMPLUS   2
#define ISDN_TIMER_MODEMRING   4
#define ISDN_TIMER_MODEMXMIT   8
#define ISDN_TIMER_NETDIAL    16 
#define ISDN_TIMER_NETHANGUP  32
#define ISDN_TIMER_CARRIER   256 /* Wait for Carrier */
#define ISDN_TIMER_FAST      (ISDN_TIMER_MODEMREAD | ISDN_TIMER_MODEMPLUS | \
                              ISDN_TIMER_MODEMXMIT)
#define ISDN_TIMER_SLOW      (ISDN_TIMER_MODEMRING | ISDN_TIMER_NETHANGUP | \
                              ISDN_TIMER_NETDIAL | ISDN_TIMER_CARRIER)

/* Timeout-Values for isdn_net_dial() */
#define ISDN_TIMER_DTIMEOUT10 (10*HZ/(ISDN_TIMER_02SEC*(ISDN_TIMER_RES+1)))
#define ISDN_TIMER_DTIMEOUT15 (15*HZ/(ISDN_TIMER_02SEC*(ISDN_TIMER_RES+1)))
#define ISDN_TIMER_DTIMEOUT60 (60*HZ/(ISDN_TIMER_02SEC*(ISDN_TIMER_RES+1)))

/* GLOBAL_FLAGS */
#define ISDN_GLOBAL_STOPPED 1

/*=================== Start of ip-over-ISDN stuff =========================*/

/* Feature- and status-flags for a net-interface */
#define ISDN_NET_CONNECTED  0x01       /* Bound to ISDN-Channel             */
#define ISDN_NET_SECURE     0x02       /* Accept calls from phonelist only  */
#define ISDN_NET_CALLBACK   0x04       /* activate callback                 */
#define ISDN_NET_CBHUP      0x08       /* hangup before callback            */
#define ISDN_NET_CBOUT      0x10       /* remote machine does callback      */

#define ISDN_NET_MAGIC      0x49344C02 /* for paranoia-checking             */

/* Phone-list-element */
typedef struct {
  void *next;
  char num[ISDN_MSNLEN];
} isdn_net_phone;

/*
   Principles when extending structures for generic encapsulation protocol
   ("concap") support:
   - Stuff which is hardware specific (here i4l-specific) goes in 
     the netdev -> local structure (here: isdn_net_local)
   - Stuff which is encapsulation protocol specific goes in the structure
     which holds the linux device structure (here: isdn_net_device)
*/

/* Local interface-data */
typedef struct isdn_net_local_s {
  ulong                  magic;
  struct net_device_stats stats;       /* Ethernet Statistics              */
  int                    isdn_device;  /* Index to isdn-device             */
  int                    isdn_channel; /* Index to isdn-channel            */
  int			 ppp_slot;     /* PPPD device slot number          */
  int                    pre_device;   /* Preselected isdn-device          */
  int                    pre_channel;  /* Preselected isdn-channel         */
  int                    exclusive;    /* If non-zero idx to reserved chan.*/
  int                    flags;        /* Connection-flags                 */
  int                    dialretry;    /* Counter for Dialout-retries      */
  int                    dialmax;      /* Max. Number of Dial-retries      */
  int                    cbdelay;      /* Delay before Callback starts     */
  int                    dtimer;       /* Timeout-counter for dialing      */
  char                   msn[ISDN_MSNLEN]; /* MSNs/EAZs for this interface */
  u_char                 cbhup;        /* Flag: Reject Call before Callback*/
  u_char                 dialstate;    /* State for dialing                */
  u_char                 p_encap;      /* Packet encapsulation             */
                                       /*   0 = Ethernet over ISDN         */
				       /*   1 = RAW-IP                     */
                                       /*   2 = IP with type field         */
  u_char                 l2_proto;     /* Layer-2-protocol                 */
				       /* See ISDN_PROTO_L2..-constants in */
                                       /* isdnif.h                         */
                                       /*   0 = X75/LAPB with I-Frames     */
				       /*   1 = X75/LAPB with UI-Frames    */
				       /*   2 = X75/LAPB with BUI-Frames   */
				       /*   3 = HDLC                       */
  u_char                 l3_proto;     /* Layer-3-protocol                 */
				       /* See ISDN_PROTO_L3..-constants in */
                                       /* isdnif.h                         */
                                       /*   0 = Transparent                */
  int                    huptimer;     /* Timeout-counter for auto-hangup  */
  int                    charge;       /* Counter for charging units       */
  ulong                  chargetime;   /* Timer for Charging info          */
  int                    hupflags;     /* Flags for charge-unit-hangup:    */
				       /* bit0: chargeint is invalid       */
				       /* bit1: Getting charge-interval    */
                                       /* bit2: Do charge-unit-hangup      */
                                       /* bit3: Do hangup even on incoming */
  int                    outgoing;     /* Flag: outgoing call              */
  int                    onhtime;      /* Time to keep link up             */
  int                    chargeint;    /* Interval between charge-infos    */
  int                    onum;         /* Flag: at least 1 outgoing number */
  int                    cps;          /* current speed of this interface  */
  int                    transcount;   /* byte-counter for cps-calculation */
  int                    sqfull;       /* Flag: netdev-queue overloaded    */
  ulong                  sqfull_stamp; /* Start-Time of overload           */
  ulong                  slavedelay;   /* Dynamic bundling delaytime       */
  int                    triggercps;   /* BogoCPS needed for trigger slave */
  isdn_net_phone         *phone[2];    /* List of remote-phonenumbers      */
				       /* phone[0] = Incoming Numbers      */
				       /* phone[1] = Outgoing Numbers      */
  isdn_net_phone         *dial;        /* Pointer to dialed number         */
  struct net_device      *master;      /* Ptr to Master device for slaves  */
  struct net_device      *slave;       /* Ptr to Slave device for masters  */
  struct isdn_net_local_s *next;       /* Ptr to next link in bundle       */
  struct isdn_net_local_s *last;       /* Ptr to last link in bundle       */
  struct isdn_net_dev_s  *netdev;      /* Ptr to netdev                    */
  struct sk_buff_head    super_tx_queue; /* List of supervisory frames to  */
	                               /* be transmitted asap              */
  atomic_t frame_cnt;                  /* number of frames currently       */
                        	       /* queued in HL driver              */    
                                       /* Ptr to orig. hard_header_cache   */
  spinlock_t             xmit_lock;    /* used to protect the xmit path of */
                                       /* a particular channel (including  */
                                       /* the frame_cnt                    */

  int  pppbind;                        /* ippp device for bindings         */
  int					dialtimeout;	/* How long shall we try on dialing? (jiffies) */
  int					dialwait;		/* How long shall we wait after failed attempt? (jiffies) */
  ulong					dialstarted;	/* jiffies of first dialing-attempt */
  ulong					dialwait_timer;	/* jiffies of earliest next dialing-attempt */
  int					huptimeout;		/* How long will the connection be up? (seconds) */
#ifdef CONFIG_ISDN_X25
  struct concap_device_ops *dops;      /* callbacks used by encapsulator   */
#endif
  /* use an own struct for that in later versions */
  ulong cisco_myseq;                   /* Local keepalive seq. for Cisco   */
  ulong cisco_mineseen;                /* returned keepalive seq. from remote */
  ulong cisco_yourseq;                 /* Remote keepalive seq. for Cisco  */
  int cisco_keepalive_period;		/* keepalive period */
  ulong cisco_last_slarp_in;		/* jiffie of last keepalive packet we received */
  char cisco_line_state;		/* state of line according to keepalive packets */
  char cisco_debserint;			/* debugging flag of cisco hdlc with slarp */
  struct timer_list cisco_timer;
  struct work_struct tqueue;
} isdn_net_local;

/* the interface itself */
typedef struct isdn_net_dev_s {
  isdn_net_local *local;
  isdn_net_local *queue;               /* circular list of all bundled
					  channels, which are currently
					  online                           */
  spinlock_t queue_lock;               /* lock to protect queue            */
  void *next;                          /* Pointer to next isdn-interface   */
  struct net_device *dev;              /* interface to upper levels        */
#ifdef CONFIG_ISDN_PPP
  ippp_bundle * pb;		/* pointer to the common bundle structure
   			         * with the per-bundle data */
#endif
#ifdef CONFIG_ISDN_X25
  struct concap_proto  *cprot; /* connection oriented encapsulation protocol */
#endif

} isdn_net_dev;

/*===================== End of ip-over-ISDN stuff ===========================*/

/*======================= Start of ISDN-tty stuff ===========================*/

#define ISDN_ASYNC_MAGIC          0x49344C01 /* for paranoia-checking        */
#define ISDN_SERIAL_XMIT_SIZE           1024 /* Default bufsize for write    */
#define ISDN_SERIAL_XMIT_MAX            4000 /* Maximum bufsize for write    */

#ifdef CONFIG_ISDN_AUDIO
/* For using sk_buffs with audio we need some private variables
 * within each sk_buff. For this purpose, we declare a struct here,
 * and put it always at the private skb->cb data array. A few macros help
 * accessing the variables.
 */
typedef struct _isdn_audio_data {
  unsigned short dle_count;
  unsigned char  lock;
} isdn_audio_data_t;

#define ISDN_AUDIO_SKB_DLECOUNT(skb)	(((isdn_audio_data_t *)&skb->cb[0])->dle_count)
#define ISDN_AUDIO_SKB_LOCK(skb)	(((isdn_audio_data_t *)&skb->cb[0])->lock)
#endif

/* Private data of AT-command-interpreter */
typedef struct atemu {
	u_char       profile[ISDN_MODEM_NUMREG]; /* Modem-Regs. Profile 0              */
	u_char       mdmreg[ISDN_MODEM_NUMREG];  /* Modem-Registers                    */
	char         pmsn[ISDN_MSNLEN];          /* EAZ/MSNs Profile 0                 */
	char         msn[ISDN_MSNLEN];           /* EAZ/MSN                            */
	char         plmsn[ISDN_LMSNLEN];        /* Listening MSNs Profile 0           */
	char         lmsn[ISDN_LMSNLEN];         /* Listening MSNs                     */
	char         cpn[ISDN_MSNLEN];           /* CalledPartyNumber on incoming call */
	char         connmsg[ISDN_CMSGLEN];	 /* CONNECT-Msg from HL-Driver	       */
#ifdef CONFIG_ISDN_AUDIO
	u_char       vpar[10];                   /* Voice-parameters                   */
	int          lastDLE;                    /* Flag for voice-coding: DLE seen    */
#endif
	int          mdmcmdl;                    /* Length of Modem-Commandbuffer      */
	int          pluscount;                  /* Counter for +++ sequence           */
	u_long       lastplus;                   /* Timestamp of last +                */
	int	     carrierwait;                /* Seconds of carrier waiting         */
	char         mdmcmd[255];                /* Modem-Commandbuffer                */
	unsigned int charge;                     /* Charge units of current connection */
} atemu;

/* Private data (similar to async_struct in <linux/serial.h>) */
typedef struct modem_info {
  int			magic;
  struct tty_port	port;
  int			x_char;		 /* xon/xoff character             */
  int			mcr;		 /* Modem control register         */
  int                   msr;             /* Modem status register          */
  int                   lsr;             /* Line status register           */
  int			line;
  int                   online;          /* 1 = B-Channel is up, drop data */
					 /* 2 = B-Channel is up, deliver d.*/
  int                   dialing;         /* Dial in progress or ATA        */
  int                   rcvsched;        /* Receive needs schedule         */
  int                   isdn_driver;	 /* Index to isdn-driver           */
  int                   isdn_channel;    /* Index to isdn-channel          */
  int                   drv_index;       /* Index to dev->usage            */
  int                   ncarrier;        /* Flag: schedule NO CARRIER      */
  unsigned char         last_cause[8];   /* Last cause message             */
  unsigned char         last_num[ISDN_MSNLEN];
	                                 /* Last phone-number              */
  unsigned char         last_l2;         /* Last layer-2 protocol          */
  unsigned char         last_si;         /* Last service                   */
  unsigned char         last_lhup;       /* Last hangup local?             */
  unsigned char         last_dir;        /* Last direction (in or out)     */
  struct timer_list     nc_timer;        /* Timer for delayed NO CARRIER   */
  int                   send_outstanding;/* # of outstanding send-requests */
  int                   xmit_size;       /* max. # of chars in xmit_buf    */
  int                   xmit_count;      /* # of chars in xmit_buf         */
  struct sk_buff_head   xmit_queue;      /* transmit queue                 */
  atomic_t              xmit_lock;       /* Semaphore for isdn_tty_write   */
#ifdef CONFIG_ISDN_AUDIO
  int                   vonline;         /* Voice-channel status           */
					 /* Bit 0 = recording              */
					 /* Bit 1 = playback               */
					 /* Bit 2 = playback, DLE-ETX seen */
  struct sk_buff_head   dtmf_queue;      /* queue for dtmf results         */
  void                  *adpcms;         /* state for adpcm decompression  */
  void                  *adpcmr;         /* state for adpcm compression    */
  void                  *dtmf_state;     /* state for dtmf decoder         */
  void                  *silence_state;  /* state for silence detection    */
#endif
#ifdef CONFIG_ISDN_TTY_FAX
  struct T30_s		*fax;		 /* T30 Fax Group 3 data/interface */
  int			faxonline;	 /* Fax-channel status             */
#endif
  atemu                 emu;             /* AT-emulator data               */
  spinlock_t	        readlock;
} modem_info;

#define ISDN_MODEM_WINSIZE 8

/* Description of one ISDN-tty */
typedef struct _isdn_modem {
  int                refcount;				/* Number of opens        */
  struct tty_driver  *tty_modem;			/* tty-device             */
  struct tty_struct  *modem_table[ISDN_MAX_CHANNELS];	/* ?? copied from Orig    */
  struct ktermios     *modem_termios[ISDN_MAX_CHANNELS];
  struct ktermios     *modem_termios_locked[ISDN_MAX_CHANNELS];
  modem_info         info[ISDN_MAX_CHANNELS];	   /* Private data           */
} isdn_modem_t;

/*======================= End of ISDN-tty stuff ============================*/

/*======================== Start of V.110 stuff ============================*/
#define V110_BUFSIZE 1024

typedef struct {
	int nbytes;                    /* 1 Matrixbyte -> nbytes in stream     */
	int nbits;                     /* Number of used bits in streambyte    */
	unsigned char key;             /* Bitmask in stream eg. 11 (nbits=2)   */
	int decodelen;                 /* Amount of data in decodebuf          */
	int SyncInit;                  /* Number of sync frames to send        */
	unsigned char *OnlineFrame;    /* Precalculated V110 idle frame        */
	unsigned char *OfflineFrame;   /* Precalculated V110 sync Frame        */
	int framelen;                  /* Length of frames                     */
	int skbuser;                   /* Number of unacked userdata skbs      */
	int skbidle;                   /* Number of unacked idle/sync skbs     */
	int introducer;                /* Local vars for decoder               */
	int dbit;
	unsigned char b;
	int skbres;                    /* space to reserve in outgoing skb     */
	int maxsize;                   /* maxbufsize of lowlevel driver        */
	unsigned char *encodebuf;      /* temporary buffer for encoding        */
	unsigned char decodebuf[V110_BUFSIZE]; /* incomplete V110 matrices     */
} isdn_v110_stream;

/*========================= End of V.110 stuff =============================*/

/*======================= Start of general stuff ===========================*/

typedef struct {
	char *next;
	char *private;
} infostruct;

#define DRV_FLAG_RUNNING 1
#define DRV_FLAG_REJBUS  2
#define DRV_FLAG_LOADED  4

/* Description of hardware-level-driver */
typedef struct _isdn_driver {
	ulong               online;           /* Channel-Online flags             */
	ulong               flags;            /* Misc driver Flags                */
	int                 locks;            /* Number of locks for this driver  */
	int                 channels;         /* Number of channels               */
	wait_queue_head_t   st_waitq;         /* Wait-Queue for status-read's     */
	int                 maxbufsize;       /* Maximum Buffersize supported     */
	unsigned long       pktcount;         /* Until now: unused                */
	int                 stavail;          /* Chars avail on Status-device     */
	isdn_if            *interface;        /* Interface to driver              */
	int                *rcverr;           /* Error-counters for B-Ch.-receive */
	int                *rcvcount;         /* Byte-counters for B-Ch.-receive  */
#ifdef CONFIG_ISDN_AUDIO
	unsigned long      DLEflag;           /* Flags: Insert DLE at next read   */
#endif
	struct sk_buff_head *rpqueue;         /* Pointers to start of Rcv-Queue   */
	wait_queue_head_t  *rcv_waitq;       /* Wait-Queues for B-Channel-Reads  */
	wait_queue_head_t  *snd_waitq;       /* Wait-Queue for B-Channel-Send's  */
	char               msn2eaz[10][ISDN_MSNLEN];  /* Mapping-Table MSN->EAZ   */
} isdn_driver_t;

/* Main driver-data */
typedef struct isdn_devt {
	struct module     *owner;
	spinlock_t	  lock;
	unsigned short    flags;		      /* Bitmapped Flags:           */
	int               drivers;		      /* Current number of drivers  */
	int               channels;		      /* Current number of channels */
	int               net_verbose;                /* Verbose-Flag               */
	int               modempoll;		      /* Flag: tty-read active      */
	spinlock_t	  timerlock;
	int               tflags;                     /* Timer-Flags:               */
	/*  see ISDN_TIMER_..defines  */
	int               global_flags;
	infostruct        *infochain;                 /* List of open info-devs.    */
	wait_queue_head_t info_waitq;                 /* Wait-Queue for isdninfo    */
	struct timer_list timer;		      /* Misc.-function Timer       */
	int               chanmap[ISDN_MAX_CHANNELS]; /* Map minor->device-channel  */
	int               drvmap[ISDN_MAX_CHANNELS];  /* Map minor->driver-index    */
	int               usage[ISDN_MAX_CHANNELS];   /* Used by tty/ip/voice       */
	char              num[ISDN_MAX_CHANNELS][ISDN_MSNLEN];
	/* Remote number of active ch.*/
	int               m_idx[ISDN_MAX_CHANNELS];   /* Index for mdm....          */
	isdn_driver_t     *drv[ISDN_MAX_DRIVERS];     /* Array of drivers           */
	isdn_net_dev      *netdev;		      /* Linked list of net-if's    */
	char              drvid[ISDN_MAX_DRIVERS][20];/* Driver-ID                 */
	struct task_struct *profd;                    /* For iprofd                 */
	isdn_modem_t      mdm;			      /* tty-driver-data            */
	isdn_net_dev      *rx_netdev[ISDN_MAX_CHANNELS]; /* rx netdev-pointers     */
	isdn_net_dev      *st_netdev[ISDN_MAX_CHANNELS]; /* stat netdev-pointers   */
	ulong             ibytes[ISDN_MAX_CHANNELS];  /* Statistics incoming bytes  */
	ulong             obytes[ISDN_MAX_CHANNELS];  /* Statistics outgoing bytes  */
	int               v110emu[ISDN_MAX_CHANNELS]; /* V.110 emulator-mode 0=none */
	atomic_t          v110use[ISDN_MAX_CHANNELS]; /* Usage-Semaphore for stream */
	isdn_v110_stream  *v110[ISDN_MAX_CHANNELS];   /* V.110 private data         */
	struct mutex      mtx;                        /* serialize list access*/
	unsigned long     global_features;
} isdn_dev;

extern isdn_dev *dev;


#endif /* __ISDN_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * pm_runtime.h - Device run-time power management helper functions.
 *
 * Copyright (C) 2009 Rafael J. Wysocki <rjw@sisk.pl>
 *
 * This file is released under the GPLv2.
 */

#ifndef _LINUX_PM_RUNTIME_H
#define _LINUX_PM_RUNTIME_H

#include <linux/device.h>
#include <linux/notifier.h>
#include <linux/pm.h>

#include <linux/jiffies.h>

/* Runtime PM flag argument bits */
#define RPM_ASYNC		0x01	/* Request is asynchronous */
#define RPM_NOWAIT		0x02	/* Don't wait for concurrent
					    state change */
#define RPM_GET_PUT		0x04	/* Increment/decrement the
					    usage_count */
#define RPM_AUTO		0x08	/* Use autosuspend_delay */

#ifdef CONFIG_PM
extern struct workqueue_struct *pm_wq;

static inline bool queue_pm_work(struct work_struct *work)
{
	return queue_work(pm_wq, work);
}

extern int pm_generic_runtime_suspend(struct device *dev);
extern int pm_generic_runtime_resume(struct device *dev);
extern int pm_runtime_force_suspend(struct device *dev);
extern int pm_runtime_force_resume(struct device *dev);

extern int __pm_runtime_idle(struct device *dev, int rpmflags);
extern int __pm_runtime_suspend(struct device *dev, int rpmflags);
extern int __pm_runtime_resume(struct device *dev, int rpmflags);
extern int pm_schedule_suspend(struct device *dev, unsigned int delay);
extern int __pm_runtime_set_status(struct device *dev, unsigned int status);
extern int pm_runtime_barrier(struct device *dev);
extern void pm_runtime_enable(struct device *dev);
extern void __pm_runtime_disable(struct device *dev, bool check_resume);
extern void pm_runtime_allow(struct device *dev);
extern void pm_runtime_forbid(struct device *dev);
extern void pm_runtime_no_callbacks(struct device *dev);
extern void pm_runtime_irq_safe(struct device *dev);
extern void __pm_runtime_use_autosuspend(struct device *dev, bool use);
extern void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);
extern unsigned long pm_runtime_autosuspend_expiration(struct device *dev);
extern void pm_runtime_update_max_time_suspended(struct device *dev,
						 s64 delta_ns);
extern void pm_runtime_set_memalloc_noio(struct device *dev, bool enable);

static inline bool pm_children_suspended(struct device *dev)
{
	return dev->power.ignore_children
		|| !atomic_read(&dev->power.child_count);
}

static inline void pm_runtime_get_noresume(struct device *dev)
{
	atomic_inc(&dev->power.usage_count);
}

static inline void pm_runtime_put_noidle(struct device *dev)
{
	atomic_add_unless(&dev->power.usage_count, -1, 0);
}

static inline bool device_run_wake(struct device *dev)
{
	return dev->power.run_wake;
}

static inline void device_set_run_wake(struct device *dev, bool enable)
{
	dev->power.run_wake = enable;
}

static inline bool pm_runtime_suspended(struct device *dev)
{
	return dev->power.runtime_status == RPM_SUSPENDED
		&& !dev->power.disable_depth;
}

static inline bool pm_runtime_active(struct device *dev)
{
	return dev->power.runtime_status == RPM_ACTIVE
		|| dev->power.disable_depth;
}

static inline bool pm_runtime_status_suspended(struct device *dev)
{
	return dev->power.runtime_status == RPM_SUSPENDED;
}

static inline bool pm_runtime_suspended_if_enabled(struct device *dev)
{
	return pm_runtime_status_suspended(dev) && dev->power.disable_depth == 1;
}

static inline bool pm_runtime_enabled(struct device *dev)
{
	return !dev->power.disable_depth;
}

static inline bool pm_runtime_callbacks_present(struct device *dev)
{
	return !dev->power.no_callbacks;
}

static inline void pm_runtime_mark_last_busy(struct device *dev)
{
	ACCESS_ONCE(dev->power.last_busy) = jiffies;
}

static inline bool pm_runtime_is_irq_safe(struct device *dev)
{
	return dev->power.irq_safe;
}

#else /* !CONFIG_PM */

static inline bool queue_pm_work(struct work_struct *work) { return false; }

static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
static inline int pm_runtime_force_suspend(struct device *dev) { return 0; }
static inline int pm_runtime_force_resume(struct device *dev) { return 0; }

static inline int __pm_runtime_idle(struct device *dev, int rpmflags)
{
	return -ENOSYS;
}
static inline int __pm_runtime_suspend(struct device *dev, int rpmflags)
{
	return -ENOSYS;
}
static inline int __pm_runtime_resume(struct device *dev, int rpmflags)
{
	return 1;
}
static inline int pm_schedule_suspend(struct device *dev, unsigned int delay)
{
	return -ENOSYS;
}
static inline int __pm_runtime_set_status(struct device *dev,
					    unsigned int status) { return 0; }
static inline int pm_runtime_barrier(struct device *dev) { return 0; }
static inline void pm_runtime_enable(struct device *dev) {}
static inline void __pm_runtime_disable(struct device *dev, bool c) {}
static inline void pm_runtime_allow(struct device *dev) {}
static inline void pm_runtime_forbid(struct device *dev) {}

static inline bool pm_children_suspended(struct device *dev) { return false; }
static inline void pm_runtime_get_noresume(struct device *dev) {}
static inline void pm_runtime_put_noidle(struct device *dev) {}
static inline bool device_run_wake(struct device *dev) { return false; }
static inline void device_set_run_wake(struct device *dev, bool enable) {}
static inline bool pm_runtime_suspended(struct device *dev) { return false; }
static inline bool pm_runtime_active(struct device *dev) { return true; }
static inline bool pm_runtime_status_suspended(struct device *dev) { return false; }
static inline bool pm_runtime_suspended_if_enabled(struct device *dev) { return false; }
static inline bool pm_runtime_enabled(struct device *dev) { return false; }

static inline void pm_runtime_no_callbacks(struct device *dev) {}
static inline void pm_runtime_irq_safe(struct device *dev) {}
static inline bool pm_runtime_is_irq_safe(struct device *dev) { return false; }

static inline bool pm_runtime_callbacks_present(struct device *dev) { return false; }
static inline void pm_runtime_mark_last_busy(struct device *dev) {}
static inline void __pm_runtime_use_autosuspend(struct device *dev,
						bool use) {}
static inline void pm_runtime_set_autosuspend_delay(struct device *dev,
						int delay) {}
static inline unsigned long pm_runtime_autosuspend_expiration(
				struct device *dev) { return 0; }
static inline void pm_runtime_set_memalloc_noio(struct device *dev,
						bool enable){}

#endif /* !CONFIG_PM */

static inline int pm_runtime_idle(struct device *dev)
{
	return __pm_runtime_idle(dev, 0);
}

static inline int pm_runtime_suspend(struct device *dev)
{
	return __pm_runtime_suspend(dev, 0);
}

static inline int pm_runtime_autosuspend(struct device *dev)
{
	return __pm_runtime_suspend(dev, RPM_AUTO);
}

static inline int pm_runtime_resume(struct device *dev)
{
	return __pm_runtime_resume(dev, 0);
}

static inline int pm_request_idle(struct device *dev)
{
	return __pm_runtime_idle(dev, RPM_ASYNC);
}

static inline int pm_request_resume(struct device *dev)
{
	return __pm_runtime_resume(dev, RPM_ASYNC);
}

static inline int pm_request_autosuspend(struct device *dev)
{
	return __pm_runtime_suspend(dev, RPM_ASYNC | RPM_AUTO);
}

static inline int pm_runtime_get(struct device *dev)
{
	return __pm_runtime_resume(dev, RPM_GET_PUT | RPM_ASYNC);
}

static inline int pm_runtime_get_sync(struct device *dev)
{
	return __pm_runtime_resume(dev, RPM_GET_PUT);
}

static inline int pm_runtime_put(struct device *dev)
{
	return __pm_runtime_idle(dev, RPM_GET_PUT | RPM_ASYNC);
}

static inline int pm_runtime_put_autosuspend(struct device *dev)
{
	return __pm_runtime_suspend(dev,
	    RPM_GET_PUT | RPM_ASYNC | RPM_AUTO);
}

static inline int pm_runtime_put_sync(struct device *dev)
{
	return __pm_runtime_idle(dev, RPM_GET_PUT);
}

static inline int pm_runtime_put_sync_suspend(struct device *dev)
{
	return __pm_runtime_suspend(dev, RPM_GET_PUT);
}

static inline int pm_runtime_put_sync_autosuspend(struct device *dev)
{
	return __pm_runtime_suspend(dev, RPM_GET_PUT | RPM_AUTO);
}

static inline int pm_runtime_set_active(struct device *dev)
{
	return __pm_runtime_set_status(dev, RPM_ACTIVE);
}

static inline void pm_runtime_set_suspended(struct device *dev)
{
	__pm_runtime_set_status(dev, RPM_SUSPENDED);
}

static inline void pm_runtime_disable(struct device *dev)
{
	__pm_runtime_disable(dev, true);
}

static inline void pm_runtime_use_autosuspend(struct device *dev)
{
	__pm_runtime_use_autosuspend(dev, true);
}

static inline void pm_runtime_dont_use_autosuspend(struct device *dev)
{
	__pm_runtime_use_autosuspend(dev, false);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #ifndef _LINUX_ELFCORE_H
#define _LINUX_ELFCORE_H

#include <linux/user.h>
#include <linux/bug.h>
#include <asm/elf.h>
#include <uapi/linux/elfcore.h>

struct coredump_params;

static inline void elf_core_copy_regs(elf_gregset_t *elfregs, struct pt_regs *regs)
{
#ifdef ELF_CORE_COPY_REGS
	ELF_CORE_COPY_REGS((*elfregs), regs)
#else
	BUG_ON(sizeof(*elfregs) != sizeof(*regs));
	*(struct pt_regs *)elfregs = *regs;
#endif
}

static inline void elf_core_copy_kernel_regs(elf_gregset_t *elfregs, struct pt_regs *regs)
{
#ifdef ELF_CORE_COPY_KERNEL_REGS
	ELF_CORE_COPY_KERNEL_REGS((*elfregs), regs);
#else
	elf_core_copy_regs(elfregs, regs);
#endif
}

static inline int elf_core_copy_task_regs(struct task_struct *t, elf_gregset_t* elfregs)
{
#if defined (ELF_CORE_COPY_TASK_REGS)
	return ELF_CORE_COPY_TASK_REGS(t, elfregs);
#elif defined (task_pt_regs)
	elf_core_copy_regs(elfregs, task_pt_regs(t));
#endif
	return 0;
}

extern int dump_fpu (struct pt_regs *, elf_fpregset_t *);

static inline int elf_core_copy_task_fpregs(struct task_struct *t, struct pt_regs *regs, elf_fpregset_t *fpu)
{
#ifdef ELF_CORE_COPY_FPREGS
	return ELF_CORE_COPY_FPREGS(t, fpu);
#else
	return dump_fpu(regs, fpu);
#endif
}

#ifdef ELF_CORE_COPY_XFPREGS
static inline int elf_core_copy_task_xfpregs(struct task_struct *t, elf_fpxregset_t *xfpu)
{
	return ELF_CORE_COPY_XFPREGS(t, xfpu);
}
#endif

/*
 * These functions parameterize elf_core_dump in fs/binfmt_elf.c to write out
 * extra segments containing the gate DSO contents.  Dumping its
 * contents makes post-mortem fully interpretable later without matching up
 * the same kernel and hardware config to see what PC values meant.
 * Dumping its extra ELF program headers includes all the other information
 * a debugger needs to easily find how the gate DSO was being used.
 */
extern Elf_Half elf_core_extra_phdrs(void);
extern int
elf_core_write_extra_phdrs(struct coredump_params *cprm, loff_t offset);
extern int
elf_core_write_extra_data(struct coredump_params *cprm);
extern size_t elf_core_extra_data_size(void);

#endif /* _LINUX_ELFCORE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #ifndef _LINUX_JHASH_H
#define _LINUX_JHASH_H

/* jhash.h: Jenkins hash support.
 *
 * Copyright (C) 2006. Bob Jenkins (bob_jenkins@burtleburtle.net)
 *
 * http://burtleburtle.net/bob/hash/
 *
 * These are the credits from Bob's sources:
 *
 * lookup3.c, by Bob Jenkins, May 2006, Public Domain.
 *
 * These are functions for producing 32-bit hashes for hash table lookup.
 * hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()
 * are externally useful functions.  Routines to test the hash are included
 * if SELF_TEST is defined.  You can use this free for any purpose.  It's in
 * the public domain.  It has no warranty.
 *
 * Copyright (C) 2009-2010 Jozsef Kadlecsik (kadlec@blackhole.kfki.hu)
 *
 * I've modified Bob's hash to be useful in the Linux kernel, and
 * any bugs present are my fault.
 * Jozsef
 */
#include <linux/bitops.h>
#include <linux/unaligned/packed_struct.h>

/* Best hash sizes are of power of two */
#define jhash_size(n)   ((u32)1<<(n))
/* Mask the hash value, i.e (value & jhash_mask(n)) instead of (value % n) */
#define jhash_mask(n)   (jhash_size(n)-1)

/* __jhash_mix -- mix 3 32-bit values reversibly. */
#define __jhash_mix(a, b, c)			\
{						\
	a -= c;  a ^= rol32(c, 4);  c += b;	\
	b -= a;  b ^= rol32(a, 6);  a += c;	\
	c -= b;  c ^= rol32(b, 8);  b += a;	\
	a -= c;  a ^= rol32(c, 16); c += b;	\
	b -= a;  b ^= rol32(a, 19); a += c;	\
	c -= b;  c ^= rol32(b, 4);  b += a;	\
}

/* __jhash_final - final mixing of 3 32-bit values (a,b,c) into c */
#define __jhash_final(a, b, c)			\
{						\
	c ^= b; c -= rol32(b, 14);		\
	a ^= c; a -= rol32(c, 11);		\
	b ^= a; b -= rol32(a, 25);		\
	c ^= b; c -= rol32(b, 16);		\
	a ^= c; a -= rol32(c, 4);		\
	b ^= a; b -= rol32(a, 14);		\
	c ^= b; c -= rol32(b, 24);		\
}

/* An arbitrary initial parameter */
#define JHASH_INITVAL		0xdeadbeef

/* jhash - hash an arbitrary key
 * @k: sequence of bytes as key
 * @length: the length of the key
 * @initval: the previous hash, or an arbitray value
 *
 * The generic version, hashes an arbitrary sequence of bytes.
 * No alignment or length assumptions are made about the input key.
 *
 * Returns the hash value of the key. The result depends on endianness.
 */
static inline u32 jhash(const void *key, u32 length, u32 initval)
{
	u32 a, b, c;
	const u8 *k = key;

	/* Set up the internal state */
	a = b = c = JHASH_INITVAL + length + initval;

	/* All but the last block: affect some 32 bits of (a,b,c) */
	while (length > 12) {
		a += __get_unaligned_cpu32(k);
		b += __get_unaligned_cpu32(k + 4);
		c += __get_unaligned_cpu32(k + 8);
		__jhash_mix(a, b, c);
		length -= 12;
		k += 12;
	}
	/* Last block: affect all 32 bits of (c) */
	/* All the case statements fall through */
	switch (length) {
	case 12: c += (u32)k[11]<<24;
	case 11: c += (u32)k[10]<<16;
	case 10: c += (u32)k[9]<<8;
	case 9:  c += k[8];
	case 8:  b += (u32)k[7]<<24;
	case 7:  b += (u32)k[6]<<16;
	case 6:  b += (u32)k[5]<<8;
	case 5:  b += k[4];
	case 4:  a += (u32)k[3]<<24;
	case 3:  a += (u32)k[2]<<16;
	case 2:  a += (u32)k[1]<<8;
	case 1:  a += k[0];
		 __jhash_final(a, b, c);
	case 0: /* Nothing left to add */
		break;
	}

	return c;
}

/* jhash2 - hash an array of u32's
 * @k: the key which must be an array of u32's
 * @length: the number of u32's in the key
 * @initval: the previous hash, or an arbitray value
 *
 * Returns the hash value of the key.
 */
static inline u32 jhash2(const u32 *k, u32 length, u32 initval)
{
	u32 a, b, c;

	/* Set up the internal state */
	a = b = c = JHASH_INITVAL + (length<<2) + initval;

	/* Handle most of the key */
	while (length > 3) {
		a += k[0];
		b += k[1];
		c += k[2];
		__jhash_mix(a, b, c);
		length -= 3;
		k += 3;
	}

	/* Handle the last 3 u32's: all the case statements fall through */
	switch (length) {
	case 3: c += k[2];
	case 2: b += k[1];
	case 1: a += k[0];
		__jhash_final(a, b, c);
	case 0:	/* Nothing left to add */
		break;
	}

	return c;
}


/* __jhash_nwords - hash exactly 3, 2 or 1 word(s) */
static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval)
{
	a += initval;
	b += initval;
	c += initval;

	__jhash_final(a, b, c);

	return c;
}

static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)
{
	return __jhash_nwords(a, b, c, initval + JHASH_INITVAL + (3 << 2));
}

static inline u32 jhash_2words(u32 a, u32 b, u32 initval)
{
	return __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 << 2));
}

static inline u32 jhash_1word(u32 a, u32 initval)
{
	return __jhash_nwords(a, 0, 0, initval + JHASH_INITVAL + (1 << 2));
}

#endif /* _LINUX_JHASH_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 *  External connector (extcon) class driver
 *
 * Copyright (C) 2012 Samsung Electronics
 * Author: Donggeun Kim <dg77.kim@samsung.com>
 * Author: MyungJoo Ham <myungjoo.ham@samsung.com>
 *
 * based on switch class driver
 * Copyright (C) 2008 Google, Inc.
 * Author: Mike Lockwood <lockwood@android.com>
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
*/

#ifndef __LINUX_EXTCON_H__
#define __LINUX_EXTCON_H__

#include <linux/device.h>
#include <linux/notifier.h>
#include <linux/sysfs.h>

#define SUPPORTED_CABLE_MAX	32
#define CABLE_NAME_MAX		30

/*
 * The standard cable name is to help support general notifier
 * and notifiee device drivers to share the common names.
 * Please use standard cable names unless your notifier device has
 * a very unique and abnormal cable or
 * the cable type is supposed to be used with only one unique
 * pair of notifier/notifiee devices.
 *
 * Please add any other "standard" cables used with extcon dev.
 *
 * You may add a dot and number to specify version or specification
 * of the specific cable if it is required. (e.g., "Fast-charger.18"
 * and "Fast-charger.10" for 1.8A and 1.0A chargers)
 * However, the notifiee and notifier should be able to handle such
 * string and if the notifiee can negotiate the protocol or identify,
 * you don't need such convention. This convention is helpful when
 * notifier can distinguish but notifiee cannot.
 */
enum extcon_cable_name {
	EXTCON_USB = 0,
	EXTCON_USB_HOST,
	EXTCON_TA,			/* Travel Adaptor */
	EXTCON_FAST_CHARGER,
	EXTCON_SLOW_CHARGER,
	EXTCON_CHARGE_DOWNSTREAM,	/* Charging an external device */
	EXTCON_HDMI,
	EXTCON_MHL,
	EXTCON_DVI,
	EXTCON_VGA,
	EXTCON_DOCK,
	EXTCON_LINE_IN,
	EXTCON_LINE_OUT,
	EXTCON_MIC_IN,
	EXTCON_HEADPHONE_OUT,
	EXTCON_SPDIF_IN,
	EXTCON_SPDIF_OUT,
	EXTCON_VIDEO_IN,
	EXTCON_VIDEO_OUT,
	EXTCON_MECHANICAL,
};
extern const char extcon_cable_name[][CABLE_NAME_MAX + 1];

struct extcon_cable;

/**
 * struct extcon_dev - An extcon device represents one external connector.
 * @name:		The name of this extcon device. Parent device name is
 *			used if NULL.
 * @supported_cable:	Array of supported cable names ending with NULL.
 *			If supported_cable is NULL, cable name related APIs
 *			are disabled.
 * @mutually_exclusive:	Array of mutually exclusive set of cables that cannot
 *			be attached simultaneously. The array should be
 *			ending with NULL or be NULL (no mutually exclusive
 *			cables). For example, if it is { 0x7, 0x30, 0}, then,
 *			{0, 1}, {0, 1, 2}, {0, 2}, {1, 2}, or {4, 5} cannot
 *			be attached simulataneously. {0x7, 0} is equivalent to
 *			{0x3, 0x6, 0x5, 0}. If it is {0xFFFFFFFF, 0}, there
 *			can be no simultaneous connections.
 * @print_name:		An optional callback to override the method to print the
 *			name of the extcon device.
 * @print_state:	An optional callback to override the method to print the
 *			status of the extcon device.
 * @dev:		Device of this extcon.
 * @state:		Attach/detach state of this extcon. Do not provide at
 *			register-time.
 * @nh:			Notifier for the state change events from this extcon
 * @entry:		To support list of extcon devices so that users can search
 *			for extcon devices based on the extcon name.
 * @lock:
 * @max_supported:	Internal value to store the number of cables.
 * @extcon_dev_type:	Device_type struct to provide attribute_groups
 *			customized for each extcon device.
 * @cables:		Sysfs subdirectories. Each represents one cable.
 *
 * In most cases, users only need to provide "User initializing data" of
 * this struct when registering an extcon. In some exceptional cases,
 * optional callbacks may be needed. However, the values in "internal data"
 * are overwritten by register function.
 */
struct extcon_dev {
	/* Optional user initializing data */
	const char *name;
	const char **supported_cable;
	const u32 *mutually_exclusive;

	/* Optional callbacks to override class functions */
	ssize_t	(*print_name)(struct extcon_dev *edev, char *buf);
	ssize_t	(*print_state)(struct extcon_dev *edev, char *buf);

	/* Internal data. Please do not set. */
	struct device dev;
	struct raw_notifier_head nh;
	struct list_head entry;
	int max_supported;
	spinlock_t lock;	/* could be called by irq handler */
	u32 state;

	/* /sys/class/extcon/.../cable.n/... */
	struct device_type extcon_dev_type;
	struct extcon_cable *cables;

	/* /sys/class/extcon/.../mutually_exclusive/... */
	struct attribute_group attr_g_muex;
	struct attribute **attrs_muex;
	struct device_attribute *d_attrs_muex;
};

/**
 * struct extcon_cable - An internal data for each cable of extcon device.
 * @edev:		The extcon device
 * @cable_index:	Index of this cable in the edev
 * @attr_g:		Attribute group for the cable
 * @attr_name:		"name" sysfs entry
 * @attr_state:		"state" sysfs entry
 * @attrs:		Array pointing to attr_name and attr_state for attr_g
 */
struct extcon_cable {
	struct extcon_dev *edev;
	int cable_index;

	struct attribute_group attr_g;
	struct device_attribute attr_name;
	struct device_attribute attr_state;

	struct attribute *attrs[3]; /* to be fed to attr_g.attrs */
};

/**
 * struct extcon_specific_cable_nb - An internal data for
 *				     extcon_register_interest().
 * @internal_nb:	A notifier block bridging extcon notifier
 *			and cable notifier.
 * @user_nb:		user provided notifier block for events from
 *			a specific cable.
 * @cable_index:	the target cable.
 * @edev:		the target extcon device.
 * @previous_value:	the saved previous event value.
 */
struct extcon_specific_cable_nb {
	struct notifier_block internal_nb;
	struct notifier_block *user_nb;
	int cable_index;
	struct extcon_dev *edev;
	unsigned long previous_value;
};

#if IS_ENABLED(CONFIG_EXTCON)

/*
 * Following APIs are for notifiers or configurations.
 * Notifiers are the external port and connection devices.
 */
extern int extcon_dev_register(struct extcon_dev *edev);
extern void extcon_dev_unregister(struct extcon_dev *edev);
extern int devm_extcon_dev_register(struct device *dev,
				    struct extcon_dev *edev);
extern void devm_extcon_dev_unregister(struct device *dev,
				       struct extcon_dev *edev);
extern struct extcon_dev *extcon_get_extcon_dev(const char *extcon_name);

/*
 * Following APIs control the memory of extcon device.
 */
extern struct extcon_dev *extcon_dev_allocate(const char **cables);
extern void extcon_dev_free(struct extcon_dev *edev);
extern struct extcon_dev *devm_extcon_dev_allocate(struct device *dev,
						   const char **cables);
extern void devm_extcon_dev_free(struct device *dev, struct extcon_dev *edev);

/*
 * get/set/update_state access the 32b encoded state value, which represents
 * states of all possible cables of the multistate port. For example, if one
 * calls extcon_set_state(edev, 0x7), it may mean that all the three cables
 * are attached to the port.
 */
static inline u32 extcon_get_state(struct extcon_dev *edev)
{
	return edev->state;
}

extern int extcon_set_state(struct extcon_dev *edev, u32 state);
extern int extcon_update_state(struct extcon_dev *edev, u32 mask, u32 state);

/*
 * get/set_cable_state access each bit of the 32b encoded state value.
 * They are used to access the status of each cable based on the cable_name
 * or cable_index, which is retrieved by extcon_find_cable_index
 */
extern int extcon_find_cable_index(struct extcon_dev *sdev,
				   const char *cable_name);
extern int extcon_get_cable_state_(struct extcon_dev *edev, int cable_index);
extern int extcon_set_cable_state_(struct extcon_dev *edev, int cable_index,
				   bool cable_state);

extern int extcon_get_cable_state(struct extcon_dev *edev,
				  const char *cable_name);
extern int extcon_set_cable_state(struct extcon_dev *edev,
				  const char *cable_name, bool cable_state);

/*
 * Following APIs are for notifiees (those who want to be notified)
 * to register a callback for events from a specific cable of the extcon.
 * Notifiees are the connected device drivers wanting to get notified by
 * a specific external port of a connection device.
 */
extern int extcon_register_interest(struct extcon_specific_cable_nb *obj,
				    const char *extcon_name,
				    const char *cable_name,
				    struct notifier_block *nb);
extern int extcon_unregister_interest(struct extcon_specific_cable_nb *nb);

/*
 * Following APIs are to monitor every action of a notifier.
 * Registrar gets notified for every external port of a connection device.
 * Probably this could be used to debug an action of notifier; however,
 * we do not recommend to use this for normal 'notifiee' device drivers who
 * want to be notified by a specific external port of the notifier.
 */
extern int extcon_register_notifier(struct extcon_dev *edev,
				    struct notifier_block *nb);
extern int extcon_unregister_notifier(struct extcon_dev *edev,
				      struct notifier_block *nb);

/*
 * Following API get the extcon device from devicetree.
 * This function use phandle of devicetree to get extcon device directly.
 */
extern struct extcon_dev *extcon_get_edev_by_phandle(struct device *dev, int index);
#else /* CONFIG_EXTCON */
static inline int extcon_dev_register(struct extcon_dev *edev)
{
	return 0;
}

static inline void extcon_dev_unregister(struct extcon_dev *edev) { }

static inline int devm_extcon_dev_register(struct device *dev,
					   struct extcon_dev *edev)
{
	return -EINVAL;
}

static inline void devm_extcon_dev_unregister(struct device *dev,
					      struct extcon_dev *edev) { }

static inline struct extcon_dev *extcon_dev_allocate(const char **cables)
{
	return ERR_PTR(-ENOSYS);
}

static inline void extcon_dev_free(struct extcon_dev *edev) { }

static inline struct extcon_dev *devm_extcon_dev_allocate(struct device *dev,
							  const char **cables)
{
	return ERR_PTR(-ENOSYS);
}

static inline void devm_extcon_dev_free(struct extcon_dev *edev) { }

static inline u32 extcon_get_state(struct extcon_dev *edev)
{
	return 0;
}

static inline int extcon_set_state(struct extcon_dev *edev, u32 state)
{
	return 0;
}

static inline int extcon_update_state(struct extcon_dev *edev, u32 mask,
				       u32 state)
{
	return 0;
}

static inline int extcon_find_cable_index(struct extcon_dev *edev,
					  const char *cable_name)
{
	return 0;
}

static inline int extcon_get_cable_state_(struct extcon_dev *edev,
					  int cable_index)
{
	return 0;
}

static inline int extcon_set_cable_state_(struct extcon_dev *edev,
					  int cable_index, bool cable_state)
{
	return 0;
}

static inline int extcon_get_cable_state(struct extcon_dev *edev,
			const char *cable_name)
{
	return 0;
}

static inline int extcon_set_cable_state(struct extcon_dev *edev,
			const char *cable_name, int state)
{
	return 0;
}

static inline struct extcon_dev *extcon_get_extcon_dev(const char *extcon_name)
{
	return NULL;
}

static inline int extcon_register_notifier(struct extcon_dev *edev,
					   struct notifier_block *nb)
{
	return 0;
}

static inline int extcon_unregister_notifier(struct extcon_dev *edev,
					     struct notifier_block *nb)
{
	return 0;
}

static inline int extcon_register_interest(struct extcon_specific_cable_nb *obj,
					   const char *extcon_name,
					   const char *cable_name,
					   struct notifier_block *nb)
{
	return 0;
}

static inline int extcon_unregister_interest(struct extcon_specific_cable_nb
						    *obj)
{
	return 0;
}

static inline struct extcon_dev *extcon_get_edev_by_phandle(struct device *dev,
							    int index)
{
	return ERR_PTR(-ENODEV);
}
#endif /* CONFIG_EXTCON */
#endif /* __LINUX_EXTCON_H__ */
                                                                                                                                                                                                                                                                                                                                                      #ifndef _IDE_H
#define _IDE_H
/*
 *  linux/include/linux/ide.h
 *
 *  Copyright (C) 1994-2002  Linus Torvalds & authors
 */

#include <linux/init.h>
#include <linux/ioport.h>
#include <linux/ata.h>
#include <linux/blkdev.h>
#include <linux/proc_fs.h>
#include <linux/interrupt.h>
#include <linux/bitops.h>
#include <linux/bio.h>
#include <linux/pci.h>
#include <linux/completion.h>
#include <linux/pm.h>
#include <linux/mutex.h>
/* for request_sense */
#include <linux/cdrom.h>
#include <asm/byteorder.h>
#include <asm/io.h>

#if defined(CONFIG_CRIS) || defined(CONFIG_FRV) || defined(CONFIG_MN10300)
# define SUPPORT_VLB_SYNC 0
#else
# define SUPPORT_VLB_SYNC 1
#endif

/*
 * Probably not wise to fiddle with these
 */
#define IDE_DEFAULT_MAX_FAILURES	1
#define ERROR_MAX	8	/* Max read/write errors per sector */
#define ERROR_RESET	3	/* Reset controller every 4th retry */
#define ERROR_RECAL	1	/* Recalibrate every 2nd retry */

struct device;

/* Error codes returned in rq->errors to the higher part of the driver. */
enum {
	IDE_DRV_ERROR_GENERAL	= 101,
	IDE_DRV_ERROR_FILEMARK	= 102,
	IDE_DRV_ERROR_EOD	= 103,
};

/*
 * Definitions for accessing IDE controller registers
 */
#define IDE_NR_PORTS		(10)

struct ide_io_ports {
	unsigned long	data_addr;

	union {
		unsigned long error_addr;	/*   read:  error */
		unsigned long feature_addr;	/*  write: feature */
	};

	unsigned long	nsect_addr;
	unsigned long	lbal_addr;
	unsigned long	lbam_addr;
	unsigned long	lbah_addr;

	unsigned long	device_addr;

	union {
		unsigned long status_addr;	/*  read: status  */
		unsigned long command_addr;	/* write: command */
	};

	unsigned long	ctl_addr;

	unsigned long	irq_addr;
};

#define OK_STAT(stat,good,bad)	(((stat)&((good)|(bad)))==(good))

#define BAD_R_STAT	(ATA_BUSY | ATA_ERR)
#define BAD_W_STAT	(BAD_R_STAT | ATA_DF)
#define BAD_STAT	(BAD_R_STAT | ATA_DRQ)
#define DRIVE_READY	(ATA_DRDY | ATA_DSC)

#define BAD_CRC		(ATA_ABORTED | ATA_ICRC)

#define SATA_NR_PORTS		(3)	/* 16 possible ?? */

#define SATA_STATUS_OFFSET	(0)
#define SATA_ERROR_OFFSET	(1)
#define SATA_CONTROL_OFFSET	(2)

/*
 * Our Physical Region Descriptor (PRD) table should be large enough
 * to handle the biggest I/O request we are likely to see.  Since requests
 * can have no more than 256 sectors, and since the typical blocksize is
 * two or more sectors, we could get by with a limit of 128 entries here for
 * the usual worst case.  Most requests seem to include some contiguous blocks,
 * further reducing the number of table entries required.
 *
 * The driver reverts to PIO mode for individual requests that exceed
 * this limit (possible with 512 byte blocksizes, eg. MSDOS f/s), so handling
 * 100% of all crazy scenarios here is not necessary.
 *
 * As it turns out though, we must allocate a full 4KB page for this,
 * so the two PRD tables (ide0 & ide1) will each get half of that,
 * allowing each to have about 256 entries (8 bytes each) from this.
 */
#define PRD_BYTES       8
#define PRD_ENTRIES	256

/*
 * Some more useful definitions
 */
#define PARTN_BITS	6	/* number of minor dev bits for partitions */
#define MAX_DRIVES	2	/* per interface; 2 assumed by lots of code */
#define SECTOR_SIZE	512

/*
 * Timeouts for various operations:
 */
enum {
	/* spec allows up to 20ms, but CF cards and SSD drives need more */
	WAIT_DRQ	= 1 * HZ,	/* 1s */
	/* some laptops are very slow */
	WAIT_READY	= 5 * HZ,	/* 5s */
	/* should be less than 3ms (?), if all ATAPI CD is closed at boot */
	WAIT_PIDENTIFY	= 10 * HZ,	/* 10s */
	/* worst case when spinning up */
	WAIT_WORSTCASE	= 30 * HZ,	/* 30s */
	/* maximum wait for an IRQ to happen */
	WAIT_CMD	= 10 * HZ,	/* 10s */
	/* Some drives require a longer IRQ timeout. */
	WAIT_FLOPPY_CMD	= 50 * HZ,	/* 50s */
	/*
	 * Some drives (for example, Seagate STT3401A Travan) require a very
	 * long timeout, because they don't return an interrupt or clear their
	 * BSY bit until after the command completes (even retension commands).
	 */
	WAIT_TAPE_CMD	= 900 * HZ,	/* 900s */
	/* minimum sleep time */
	WAIT_MIN_SLEEP	= HZ / 50,	/* 20ms */
};

/*
 * Op codes for special requests to be handled by ide_special_rq().
 * Values should be in the range of 0x20 to 0x3f.
 */
#define REQ_DRIVE_RESET		0x20
#define REQ_DEVSET_EXEC		0x21
#define REQ_PARK_HEADS		0x22
#define REQ_UNPARK_HEADS	0x23

/*
 * hwif_chipset_t is used to keep track of the specific hardware
 * chipset used by each IDE interface, if known.
 */
enum {		ide_unknown,	ide_generic,	ide_pci,
		ide_cmd640,	ide_dtc2278,	ide_ali14xx,
		ide_qd65xx,	ide_umc8672,	ide_ht6560b,
		ide_4drives,	ide_pmac,	ide_acorn,
		ide_au1xxx,	ide_palm3710
};

typedef u8 hwif_chipset_t;

/*
 * Structure to hold all information about the location of this port
 */
struct ide_hw {
	union {
		struct ide_io_ports	io_ports;
		unsigned long		io_ports_array[IDE_NR_PORTS];
	};

	int		irq;			/* our irq number */
	struct device	*dev, *parent;
	unsigned long	config;
};

static inline void ide_std_init_ports(struct ide_hw *hw,
				      unsigned long io_addr,
				      unsigned long ctl_addr)
{
	unsigned int i;

	for (i = 0; i <= 7; i++)
		hw->io_ports_array[i] = io_addr++;

	hw->io_ports.ctl_addr = ctl_addr;
}

#define MAX_HWIFS	10

/*
 * Now for the data we need to maintain per-drive:  ide_drive_t
 */

#define ide_scsi	0x21
#define ide_disk	0x20
#define ide_optical	0x7
#define ide_cdrom	0x5
#define ide_tape	0x1
#define ide_floppy	0x0

/*
 * Special Driver Flags
 */
enum {
	IDE_SFLAG_SET_GEOMETRY		= (1 << 0),
	IDE_SFLAG_RECALIBRATE		= (1 << 1),
	IDE_SFLAG_SET_MULTMODE		= (1 << 2),
};

/*
 * Status returned from various ide_ functions
 */
typedef enum {
	ide_stopped,	/* no drive operation was started */
	ide_started,	/* a drive operation was started, handler was set */
} ide_startstop_t;

enum {
	IDE_VALID_ERROR 		= (1 << 1),
	IDE_VALID_FEATURE		= IDE_VALID_ERROR,
	IDE_VALID_NSECT 		= (1 << 2),
	IDE_VALID_LBAL			= (1 << 3),
	IDE_VALID_LBAM			= (1 << 4),
	IDE_VALID_LBAH			= (1 << 5),
	IDE_VALID_DEVICE		= (1 << 6),
	IDE_VALID_LBA			= IDE_VALID_LBAL |
					  IDE_VALID_LBAM |
					  IDE_VALID_LBAH,
	IDE_VALID_OUT_TF		= IDE_VALID_FEATURE |
					  IDE_VALID_NSECT |
					  IDE_VALID_LBA,
	IDE_VALID_IN_TF 		= IDE_VALID_NSECT |
					  IDE_VALID_LBA,
	IDE_VALID_OUT_HOB		= IDE_VALID_OUT_TF,
	IDE_VALID_IN_HOB		= IDE_VALID_ERROR |
					  IDE_VALID_NSECT |
					  IDE_VALID_LBA,
};

enum {
	IDE_TFLAG_LBA48			= (1 << 0),
	IDE_TFLAG_WRITE			= (1 << 1),
	IDE_TFLAG_CUSTOM_HANDLER	= (1 << 2),
	IDE_TFLAG_DMA_PIO_FALLBACK	= (1 << 3),
	/* force 16-bit I/O operations */
	IDE_TFLAG_IO_16BIT		= (1 << 4),
	/* struct ide_cmd was allocated using kmalloc() */
	IDE_TFLAG_DYN			= (1 << 5),
	IDE_TFLAG_FS			= (1 << 6),
	IDE_TFLAG_MULTI_PIO		= (1 << 7),
	IDE_TFLAG_SET_XFER		= (1 << 8),
};

enum {
	IDE_FTFLAG_FLAGGED		= (1 << 0),
	IDE_FTFLAG_SET_IN_FLAGS		= (1 << 1),
	IDE_FTFLAG_OUT_DATA		= (1 << 2),
	IDE_FTFLAG_IN_DATA		= (1 << 3),
};

struct ide_taskfile {
	u8	data;		/* 0: data byte (for TASKFILE ioctl) */
	union {			/* 1: */
		u8 error;	/*  read: error */
		u8 feature;	/* write: feature */
	};
	u8	nsect;		/* 2: number of sectors */
	u8	lbal;		/* 3: LBA low */
	u8	lbam;		/* 4: LBA mid */
	u8	lbah;		/* 5: LBA high */
	u8	device;		/* 6: device select */
	union {			/* 7: */
		u8 status;	/*  read: status */
		u8 command;	/* write: command */
	};
};

struct ide_cmd {
	struct ide_taskfile	tf;
	struct ide_taskfile	hob;
	struct {
		struct {
			u8		tf;
			u8		hob;
		} out, in;
	} valid;

	u16			tf_flags;
	u8			ftf_flags;	/* for TASKFILE ioctl */
	int			protocol;

	int			sg_nents;	  /* number of sg entries */
	int			orig_sg_nents;
	int			sg_dma_direction; /* DMA transfer direction */

	unsigned int		nbytes;
	unsigned int		nleft;
	unsigned int		last_xfer_len;

	struct scatterlist	*cursg;
	unsigned int		cursg_ofs;

	struct request		*rq;		/* copy of request */
};

/* ATAPI packet command flags */
enum {
	/* set when an error is considered normal - no retry (ide-tape) */
	PC_FLAG_ABORT			= (1 << 0),
	PC_FLAG_SUPPRESS_ERROR		= (1 << 1),
	PC_FLAG_WAIT_FOR_DSC		= (1 << 2),
	PC_FLAG_DMA_OK			= (1 << 3),
	PC_FLAG_DMA_IN_PROGRESS		= (1 << 4),
	PC_FLAG_DMA_ERROR		= (1 << 5),
	PC_FLAG_WRITING			= (1 << 6),
};

#define ATAPI_WAIT_PC		(60 * HZ)

struct ide_atapi_pc {
	/* actual packet bytes */
	u8 c[12];
	/* incremented on each retry */
	int retries;
	int error;

	/* bytes to transfer */
	int req_xfer;

	/* the corresponding request */
	struct request *rq;

	unsigned long flags;

	/*
	 * those are more or less driver-specific and some of them are subject
	 * to change/removal later.
	 */
	unsigned long timeout;
};

struct ide_devset;
struct ide_driver;

#ifdef CONFIG_BLK_DEV_IDEACPI
struct ide_acpi_drive_link;
struct ide_acpi_hwif_link;
#endif

struct ide_drive_s;

struct ide_disk_ops {
	int		(*check)(struct ide_drive_s *, const char *);
	int		(*get_capacity)(struct ide_drive_s *);
	void		(*unlock_native_capacity)(struct ide_drive_s *);
	void		(*setup)(struct ide_drive_s *);
	void		(*flush)(struct ide_drive_s *);
	int		(*init_media)(struct ide_drive_s *, struct gendisk *);
	int		(*set_doorlock)(struct ide_drive_s *, struct gendisk *,
					int);
	ide_startstop_t	(*do_request)(struct ide_drive_s *, struct request *,
				      sector_t);
	int		(*ioctl)(struct ide_drive_s *, struct block_device *,
				 fmode_t, unsigned int, unsigned long);
};

/* ATAPI device flags */
enum {
	IDE_AFLAG_DRQ_INTERRUPT		= (1 << 0),

	/* ide-cd */
	/* Drive cannot eject the disc. */
	IDE_AFLAG_NO_EJECT		= (1 << 1),
	/* Drive is a pre ATAPI 1.2 drive. */
	IDE_AFLAG_PRE_ATAPI12		= (1 << 2),
	/* TOC addresses are in BCD. */
	IDE_AFLAG_TOCADDR_AS_BCD	= (1 << 3),
	/* TOC track numbers are in BCD. */
	IDE_AFLAG_TOCTRACKS_AS_BCD	= (1 << 4),
	/* Saved TOC information is current. */
	IDE_AFLAG_TOC_VALID		= (1 << 6),
	/* We think that the drive door is locked. */
	IDE_AFLAG_DOOR_LOCKED		= (1 << 7),
	/* SET_CD_SPEED command is unsupported. */
	IDE_AFLAG_NO_SPEED_SELECT	= (1 << 8),
	IDE_AFLAG_VERTOS_300_SSD	= (1 << 9),
	IDE_AFLAG_VERTOS_600_ESD	= (1 << 10),
	IDE_AFLAG_SANYO_3CD		= (1 << 11),
	IDE_AFLAG_FULL_CAPS_PAGE	= (1 << 12),
	IDE_AFLAG_PLAY_AUDIO_OK		= (1 << 13),
	IDE_AFLAG_LE_SPEED_FIELDS	= (1 << 14),

	/* ide-floppy */
	/* Avoid commands not supported in Clik drive */
	IDE_AFLAG_CLIK_DRIVE		= (1 << 15),
	/* Requires BH algorithm for packets */
	IDE_AFLAG_ZIP_DRIVE		= (1 << 16),
	/* Supports format progress report */
	IDE_AFLAG_SRFP			= (1 << 17),

	/* ide-tape */
	IDE_AFLAG_IGNORE_DSC		= (1 << 18),
	/* 0 When the tape position is unknown */
	IDE_AFLAG_ADDRESS_VALID		= (1 <<	19),
	/* Device already opened */
	IDE_AFLAG_BUSY			= (1 << 20),
	/* Attempt to auto-detect the current user block size */
	IDE_AFLAG_DETECT_BS		= (1 << 21),
	/* Currently on a filemark */
	IDE_AFLAG_FILEMARK		= (1 << 22),
	/* 0 = no tape is loaded, so we don't rewind after ejecting */
	IDE_AFLAG_MEDIUM_PRESENT	= (1 << 23),

	IDE_AFLAG_NO_AUTOCLOSE		= (1 << 24),
};

/* device flags */
enum {
	/* restore settings after device reset */
	IDE_DFLAG_KEEP_SETTINGS		= (1 << 0),
	/* device is using DMA for read/write */
	IDE_DFLAG_USING_DMA		= (1 << 1),
	/* okay to unmask other IRQs */
	IDE_DFLAG_UNMASK		= (1 << 2),
	/* don't attempt flushes */
	IDE_DFLAG_NOFLUSH		= (1 << 3),
	/* DSC overlap */
	IDE_DFLAG_DSC_OVERLAP		= (1 << 4),
	/* give potential excess bandwidth */
	IDE_DFLAG_NICE1			= (1 << 5),
	/* device is physically present */
	IDE_DFLAG_PRESENT		= (1 << 6),
	/* disable Host Protected Area */
	IDE_DFLAG_NOHPA			= (1 << 7),
	/* id read from device (synthetic if not set) */
	IDE_DFLAG_ID_READ		= (1 << 8),
	IDE_DFLAG_NOPROBE		= (1 << 9),
	/* need to do check_media_change() */
	IDE_DFLAG_REMOVABLE		= (1 << 10),
	/* needed for removable devices */
	IDE_DFLAG_ATTACH		= (1 << 11),
	IDE_DFLAG_FORCED_GEOM		= (1 << 12),
	/* disallow setting unmask bit */
	IDE_DFLAG_NO_UNMASK		= (1 << 13),
	/* disallow enabling 32-bit I/O */
	IDE_DFLAG_NO_IO_32BIT		= (1 << 14),
	/* for removable only: door lock/unlock works */
	IDE_DFLAG_DOORLOCKING		= (1 << 15),
	/* disallow DMA */
	IDE_DFLAG_NODMA			= (1 << 16),
	/* powermanagement told us not to do anything, so sleep nicely */
	IDE_DFLAG_BLOCKED		= (1 << 17),
	/* sleeping & sleep field valid */
	IDE_DFLAG_SLEEPING		= (1 << 18),
	IDE_DFLAG_POST_RESET		= (1 << 19),
	IDE_DFLAG_UDMA33_WARNED		= (1 << 20),
	IDE_DFLAG_LBA48			= (1 << 21),
	/* status of write cache */
	IDE_DFLAG_WCACHE		= (1 << 22),
	/* used for ignoring ATA_DF */
	IDE_DFLAG_NOWERR		= (1 << 23),
	/* retrying in PIO */
	IDE_DFLAG_DMA_PIO_RETRY		= (1 << 24),
	IDE_DFLAG_LBA			= (1 << 25),
	/* don't unload heads */
	IDE_DFLAG_NO_UNLOAD		= (1 << 26),
	/* heads unloaded, please don't reset port */
	IDE_DFLAG_PARKED		= (1 << 27),
	IDE_DFLAG_MEDIA_CHANGED		= (1 << 28),
	/* write protect */
	IDE_DFLAG_WP			= (1 << 29),
	IDE_DFLAG_FORMAT_IN_PROGRESS	= (1 << 30),
	IDE_DFLAG_NIEN_QUIRK		= (1 << 31),
};

struct ide_drive_s {
	char		name[4];	/* drive name, such as "hda" */
        char            driver_req[10];	/* requests specific driver */

	struct request_queue	*queue;	/* request queue */

	struct request		*rq;	/* current request */
	void		*driver_data;	/* extra driver data */
	u16			*id;	/* identification info */
#ifdef CONFIG_IDE_PROC_FS
	struct proc_dir_entry *proc;	/* /proc/ide/ directory entry */
	const struct ide_proc_devset *settings; /* /proc/ide/ drive settings */
#endif
	struct hwif_s		*hwif;	/* actually (ide_hwif_t *) */

	const struct ide_disk_ops *disk_ops;

	unsigned long dev_flags;

	unsigned long sleep;		/* sleep until this time */
	unsigned long timeout;		/* max time to wait for irq */

	u8	special_flags;		/* special action flags */

	u8	select;			/* basic drive/head select reg value */
	u8	retry_pio;		/* retrying dma capable host in pio */
	u8	waiting_for_dma;	/* dma currently in progress */
	u8	dma;			/* atapi dma flag */

        u8	init_speed;	/* transfer rate set at boot */
        u8	current_speed;	/* current transfer rate set */
	u8	desired_speed;	/* desired transfer rate set */
	u8	pio_mode;	/* for ->set_pio_mode _only_ */
	u8	dma_mode;	/* for ->set_dma_mode _only_ */
	u8	dn;		/* now wide spread use */
	u8	acoustic;	/* acoustic management */
	u8	media;		/* disk, cdrom, tape, floppy, ... */
	u8	ready_stat;	/* min status value for drive ready */
	u8	mult_count;	/* current multiple sector setting */
	u8	mult_req;	/* requested multiple sector setting */
	u8	io_32bit;	/* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
	u8	bad_wstat;	/* used for ignoring ATA_DF */
	u8	head;		/* "real" number of heads */
	u8	sect;		/* "real" sectors per track */
	u8	bios_head;	/* BIOS/fdisk/LILO number of heads */
	u8	bios_sect;	/* BIOS/fdisk/LILO sectors per track */

	/* delay this long before sending packet command */
	u8 pc_delay;

	unsigned int	bios_cyl;	/* BIOS/fdisk/LILO number of cyls */
	unsigned int	cyl;		/* "real" number of cyls */
	void		*drive_data;	/* used by set_pio_mode/dev_select() */
	unsigned int	failures;	/* current failure count */
	unsigned int	max_failures;	/* maximum allowed failure count */
	u64		probed_capacity;/* initial/native media capacity */
	u64		capacity64;	/* total number of sectors */

	int		lun;		/* logical unit */
	int		crc_count;	/* crc counter to reduce drive speed */

	unsigned long	debug_mask;	/* debugging levels switch */

#ifdef CONFIG_BLK_DEV_IDEACPI
	struct ide_acpi_drive_link *acpidata;
#endif
	struct list_head list;
	struct device	gendev;
	struct completion gendev_rel_comp;	/* to deal with device release() */

	/* current packet command */
	struct ide_atapi_pc *pc;

	/* last failed packet command */
	struct ide_atapi_pc *failed_pc;

	/* callback for packet commands */
	int  (*pc_callback)(struct ide_drive_s *, int);

	ide_startstop_t (*irq_handler)(struct ide_drive_s *);

	unsigned long atapi_flags;

	struct ide_atapi_pc request_sense_pc;

	/* current sense rq and buffer */
	bool sense_rq_armed;
	struct request sense_rq;
	struct request_sense sense_data;
};

typedef struct ide_drive_s ide_drive_t;

#define to_ide_device(dev)		container_of(dev, ide_drive_t, gendev)

#define to_ide_drv(obj, cont_type)	\
	container_of(obj, struct cont_type, dev)

#define ide_drv_g(disk, cont_type)	\
	container_of((disk)->private_data, struct cont_type, driver)

struct ide_port_info;

struct ide_tp_ops {
	void	(*exec_command)(struct hwif_s *, u8);
	u8	(*read_status)(struct hwif_s *);
	u8	(*read_altstatus)(struct hwif_s *);
	void	(*write_devctl)(struct hwif_s *, u8);

	void	(*dev_select)(ide_drive_t *);
	void	(*tf_load)(ide_drive_t *, struct ide_taskfile *, u8);
	void	(*tf_read)(ide_drive_t *, struct ide_taskfile *, u8);

	void	(*input_data)(ide_drive_t *, struct ide_cmd *,
			      void *, unsigned int);
	void	(*output_data)(ide_drive_t *, struct ide_cmd *,
			       void *, unsigned int);
};

extern const struct ide_tp_ops default_tp_ops;

/**
 * struct ide_port_ops - IDE port operations
 *
 * @init_dev:		host specific initialization of a device
 * @set_pio_mode:	routine to program host for PIO mode
 * @set_dma_mode:	routine to program host for DMA mode
 * @reset_poll:		chipset polling based on hba specifics
 * @pre_reset:		chipset specific changes to default for device-hba resets
 * @resetproc:		routine to reset controller after a disk reset
 * @maskproc:		special host masking for drive selection
 * @quirkproc:		check host's drive quirk list
 * @clear_irq:		clear IRQ
 *
 * @mdma_filter:	filter MDMA modes
 * @udma_filter:	filter UDMA modes
 *
 * @cable_detect:	detect cable type
 */
struct ide_port_ops {
	void	(*init_dev)(ide_drive_t *);
	void	(*set_pio_mode)(struct hwif_s *, ide_drive_t *);
	void	(*set_dma_mode)(struct hwif_s *, ide_drive_t *);
	int	(*reset_poll)(ide_drive_t *);
	void	(*pre_reset)(ide_drive_t *);
	void	(*resetproc)(ide_drive_t *);
	void	(*maskproc)(ide_drive_t *, int);
	void	(*quirkproc)(ide_drive_t *);
	void	(*clear_irq)(ide_drive_t *);
	int	(*test_irq)(struct hwif_s *);

	u8	(*mdma_filter)(ide_drive_t *);
	u8	(*udma_filter)(ide_drive_t *);

	u8	(*cable_detect)(struct hwif_s *);
};

struct ide_dma_ops {
	void	(*dma_host_set)(struct ide_drive_s *, int);
	int	(*dma_setup)(struct ide_drive_s *, struct ide_cmd *);
	void	(*dma_start)(struct ide_drive_s *);
	int	(*dma_end)(struct ide_drive_s *);
	int	(*dma_test_irq)(struct ide_drive_s *);
	void	(*dma_lost_irq)(struct ide_drive_s *);
	/* below ones are optional */
	int	(*dma_check)(struct ide_drive_s *, struct ide_cmd *);
	int	(*dma_timer_expiry)(struct ide_drive_s *);
	void	(*dma_clear)(struct ide_drive_s *);
	/*
	 * The following method is optional and only required to be
	 * implemented for the SFF-8038i compatible controllers.
	 */
	u8	(*dma_sff_read_status)(struct hwif_s *);
};

enum {
	IDE_PFLAG_PROBING		= (1 << 0),
};

struct ide_host;

typedef struct hwif_s {
	struct hwif_s *mate;		/* other hwif from same PCI chip */
	struct proc_dir_entry *proc;	/* /proc/ide/ directory entry */

	struct ide_host *host;

	char name[6];			/* name of interface, eg. "ide0" */

	struct ide_io_ports	io_ports;

	unsigned long	sata_scr[SATA_NR_PORTS];

	ide_drive_t	*devices[MAX_DRIVES + 1];

	unsigned long	port_flags;

	u8 major;	/* our major number */
	u8 index;	/* 0 for ide0; 1 for ide1; ... */
	u8 channel;	/* for dual-port chips: 0=primary, 1=secondary */

	u32 host_flags;

	u8 pio_mask;

	u8 ultra_mask;
	u8 mwdma_mask;
	u8 swdma_mask;

	u8 cbl;		/* cable type */

	hwif_chipset_t chipset;	/* sub-module for tuning.. */

	struct device *dev;

	void (*rw_disk)(ide_drive_t *, struct request *);

	const struct ide_tp_ops		*tp_ops;
	const struct ide_port_ops	*port_ops;
	const struct ide_dma_ops	*dma_ops;

	/* dma physical region descriptor table (cpu view) */
	unsigned int	*dmatable_cpu;
	/* dma physical region descriptor table (dma view) */
	dma_addr_t	dmatable_dma;

	/* maximum number of PRD table entries */
	int prd_max_nents;
	/* PRD entry size in bytes */
	int prd_ent_size;

	/* Scatter-gather list used to build the above */
	struct scatterlist *sg_table;
	int sg_max_nents;		/* Maximum number of entries in it */

	struct ide_cmd cmd;		/* current command */

	int		rqsize;		/* max sectors per request */
	int		irq;		/* our irq number */

	unsigned long	dma_base;	/* base addr for dma ports */

	unsigned long	config_data;	/* for use by chipset-specific code */
	unsigned long	select_data;	/* for use by chipset-specific code */

	unsigned long	extra_base;	/* extra addr for dma ports */
	unsigned	extra_ports;	/* number of extra dma ports */

	unsigned	present    : 1;	/* this interface exists */
	unsigned	busy	   : 1; /* serializes devices on a port */

	struct device		gendev;
	struct device		*portdev;

	struct completion gendev_rel_comp; /* To deal with device release() */

	void		*hwif_data;	/* extra hwif data */

#ifdef CONFIG_BLK_DEV_IDEACPI
	struct ide_acpi_hwif_link *acpidata;
#endif

	/* IRQ handler, if active */
	ide_startstop_t	(*handler)(ide_drive_t *);

	/* BOOL: polling active & poll_timeout field valid */
	unsigned int polling : 1;

	/* current drive */
	ide_drive_t *cur_dev;

	/* current request */
	struct request *rq;

	/* failsafe timer */
	struct timer_list timer;
	/* timeout value during long polls */
	unsigned long poll_timeout;
	/* queried upon timeouts */
	int (*expiry)(ide_drive_t *);

	int req_gen;
	int req_gen_timer;

	spinlock_t lock;
} ____cacheline_internodealigned_in_smp ide_hwif_t;

#define MAX_HOST_PORTS 4

struct ide_host {
	ide_hwif_t	*ports[MAX_HOST_PORTS + 1];
	unsigned int	n_ports;
	struct device	*dev[2];

	int		(*init_chipset)(struct pci_dev *);

	void		(*get_lock)(irq_handler_t, void *);
	void		(*release_lock)(void);

	irq_handler_t	irq_handler;

	unsigned long	host_flags;

	int		irq_flags;

	void		*host_priv;
	ide_hwif_t	*cur_port;	/* for hosts requiring serialization */

	/* used for hosts requiring serialization */
	volatile unsigned long	host_busy;
};

#define IDE_HOST_BUSY 0

/*
 *  internal ide interrupt handler type
 */
typedef ide_startstop_t (ide_handler_t)(ide_drive_t *);
typedef int (ide_expiry_t)(ide_drive_t *);

/* used by ide-cd, ide-floppy, etc. */
typedef void (xfer_func_t)(ide_drive_t *, struct ide_cmd *, void *, unsigned);

extern struct mutex ide_setting_mtx;

/*
 * configurable drive settings
 */

#define DS_SYNC	(1 << 0)

struct ide_devset {
	int		(*get)(ide_drive_t *);
	int		(*set)(ide_drive_t *, int);
	unsigned int	flags;
};

#define __DEVSET(_flags, _get, _set) { \
	.flags	= _flags, \
	.get	= _get,	\
	.set	= _set,	\
}

#define ide_devset_get(name, field) \
static int get_##name(ide_drive_t *drive) \
{ \
	return drive->field; \
}

#define ide_devset_set(name, field) \
static int set_##name(ide_drive_t *drive, int arg) \
{ \
	drive->field = arg; \
	return 0; \
}

#define ide_devset_get_flag(name, flag) \
static int get_##name(ide_drive_t *drive) \
{ \
	return !!(drive->dev_flags & flag); \
}

#define ide_devset_set_flag(name, flag) \
static int set_##name(ide_drive_t *drive, int arg) \
{ \
	if (arg) \
		drive->dev_flags |= flag; \
	else \
		drive->dev_flags &= ~flag; \
	return 0; \
}

#define __IDE_DEVSET(_name, _flags, _get, _set) \
const struct ide_devset ide_devset_##_name = \
	__DEVSET(_flags, _get, _set)

#define IDE_DEVSET(_name, _flags, _get, _set) \
static __IDE_DEVSET(_name, _flags, _get, _set)

#define ide_devset_rw(_name, _func) \
IDE_DEVSET(_name, 0, get_##_func, set_##_func)

#define ide_devset_w(_name, _func) \
IDE_DEVSET(_name, 0, NULL, set_##_func)

#define ide_ext_devset_rw(_name, _func) \
__IDE_DEVSET(_name, 0, get_##_func, set_##_func)

#define ide_ext_devset_rw_sync(_name, _func) \
__IDE_DEVSET(_name, DS_SYNC, get_##_func, set_##_func)

#define ide_decl_devset(_name) \
extern const struct ide_devset ide_devset_##_name

ide_decl_devset(io_32bit);
ide_decl_devset(keepsettings);
ide_decl_devset(pio_mode);
ide_decl_devset(unmaskirq);
ide_decl_devset(using_dma);

#ifdef CONFIG_IDE_PROC_FS
/*
 * /proc/ide interface
 */

#define ide_devset_rw_field(_name, _field) \
ide_devset_get(_name, _field); \
ide_devset_set(_name, _field); \
IDE_DEVSET(_name, DS_SYNC, get_##_name, set_##_name)

#define ide_devset_rw_flag(_name, _field) \
ide_devset_get_flag(_name, _field); \
ide_devset_set_flag(_name, _field); \
IDE_DEVSET(_name, DS_SYNC, get_##_name, set_##_name)

struct ide_proc_devset {
	const char		*name;
	const struct ide_devset	*setting;
	int			min, max;
	int			(*mulf)(ide_drive_t *);
	int			(*divf)(ide_drive_t *);
};

#define __IDE_PROC_DEVSET(_name, _min, _max, _mulf, _divf) { \
	.name = __stringify(_name), \
	.setting = &ide_devset_##_name, \
	.min = _min, \
	.max = _max, \
	.mulf = _mulf, \
	.divf = _divf, \
}

#define IDE_PROC_DEVSET(_name, _min, _max) \
__IDE_PROC_DEVSET(_name, _min, _max, NULL, NULL)

typedef struct {
	const char	*name;
	umode_t		mode;
	const struct file_operations *proc_fops;
} ide_proc_entry_t;

void proc_ide_create(void);
void proc_ide_destroy(void);
void ide_proc_register_port(ide_hwif_t *);
void ide_proc_port_register_devices(ide_hwif_t *);
void ide_proc_unregister_device(ide_drive_t *);
void ide_proc_unregister_port(ide_hwif_t *);
void ide_proc_register_driver(ide_drive_t *, struct ide_driver *);
void ide_proc_unregister_driver(ide_drive_t *, struct ide_driver *);

extern const struct file_operations ide_capacity_proc_fops;
extern const struct file_operations ide_geometry_proc_fops;
#else
static inline void proc_ide_create(void) { ; }
static inline void proc_ide_destroy(void) { ; }
static inline void ide_proc_register_port(ide_hwif_t *hwif) { ; }
static inline void ide_proc_port_register_devices(ide_hwif_t *hwif) { ; }
static inline void ide_proc_unregister_device(ide_drive_t *drive) { ; }
static inline void ide_proc_unregister_port(ide_hwif_t *hwif) { ; }
static inline void ide_proc_register_driver(ide_drive_t *drive,
					    struct ide_driver *driver) { ; }
static inline void ide_proc_unregister_driver(ide_drive_t *drive,
					      struct ide_driver *driver) { ; }
#endif

enum {
	/* enter/exit functions */
	IDE_DBG_FUNC =			(1 << 0),
	/* sense key/asc handling */
	IDE_DBG_SENSE =			(1 << 1),
	/* packet commands handling */
	IDE_DBG_PC =			(1 << 2),
	/* request handling */
	IDE_DBG_RQ =			(1 << 3),
	/* driver probing/setup */
	IDE_DBG_PROBE =			(1 << 4),
};

/* DRV_NAME has to be defined in the driver before using the macro below */
#define __ide_debug_log(lvl, fmt, args...)				\
{									\
	if (unlikely(drive->debug_mask & lvl))				\
		printk(KERN_INFO DRV_NAME ": %s: " fmt "\n",		\
					  __func__, ## args);		\
}

/*
 * Power Management state machine (rq->pm->pm_step).
 *
 * For each step, the core calls ide_start_power_step() first.
 * This can return:
 *	- ide_stopped :	In this case, the core calls us back again unless
 *			step have been set to ide_power_state_completed.
 *	- ide_started :	In this case, the channel is left busy until an
 *			async event (interrupt) occurs.
 * Typically, ide_start_power_step() will issue a taskfile request with
 * do_rw_taskfile().
 *
 * Upon reception of the interrupt, the core will call ide_complete_power_step()
 * with the error code if any. This routine should update the step value
 * and return. It should not start a new request. The core will call
 * ide_start_power_step() for the new step value, unless step have been
 * set to IDE_PM_COMPLETED.
 */
enum {
	IDE_PM_START_SUSPEND,
	IDE_PM_FLUSH_CACHE	= IDE_PM_START_SUSPEND,
	IDE_PM_STANDBY,

	IDE_PM_START_RESUME,
	IDE_PM_RESTORE_PIO	= IDE_PM_START_RESUME,
	IDE_PM_IDLE,
	IDE_PM_RESTORE_DMA,

	IDE_PM_COMPLETED,
};

int generic_ide_suspend(struct device *, pm_message_t);
int generic_ide_resume(struct device *);

void ide_complete_power_step(ide_drive_t *, struct request *);
ide_startstop_t ide_start_power_step(ide_drive_t *, struct request *);
void ide_complete_pm_rq(ide_drive_t *, struct request *);
void ide_check_pm_state(ide_drive_t *, struct request *);

/*
 * Subdrivers support.
 *
 * The gendriver.owner field should be set to the module owner of this driver.
 * The gendriver.name field should be set to the name of this driver
 */
struct ide_driver {
	const char			*version;
	ide_startstop_t	(*do_request)(ide_drive_t *, struct request *, sector_t);
	struct device_driver	gen_driver;
	int		(*probe)(ide_drive_t *);
	void		(*remove)(ide_drive_t *);
	void		(*resume)(ide_drive_t *);
	void		(*shutdown)(ide_drive_t *);
#ifdef CONFIG_IDE_PROC_FS
	ide_proc_entry_t *		(*proc_entries)(ide_drive_t *);
	const struct ide_proc_devset *	(*proc_devsets)(ide_drive_t *);
#endif
};

#define to_ide_driver(drv) container_of(drv, struct ide_driver, gen_driver)

int ide_device_get(ide_drive_t *);
void ide_device_put(ide_drive_t *);

struct ide_ioctl_devset {
	unsigned int	get_ioctl;
	unsigned int	set_ioctl;
	const struct ide_devset *setting;
};

int ide_setting_ioctl(ide_drive_t *, struct block_device *, unsigned int,
		      unsigned long, const struct ide_ioctl_devset *);

int generic_ide_ioctl(ide_drive_t *, struct block_device *, unsigned, unsigned long);

extern int ide_vlb_clk;
extern int ide_pci_clk;

int ide_end_rq(ide_drive_t *, struct request *, int, unsigned int);
void ide_kill_rq(ide_drive_t *, struct request *);

void __ide_set_handler(ide_drive_t *, ide_handler_t *, unsigned int);
void ide_set_handler(ide_drive_t *, ide_handler_t *, unsigned int);

void ide_execute_command(ide_drive_t *, struct ide_cmd *, ide_handler_t *,
			 unsigned int);

void ide_pad_transfer(ide_drive_t *, int, int);

ide_startstop_t ide_error(ide_drive_t *, const char *, u8);

void ide_fix_driveid(u16 *);

extern void ide_fixstring(u8 *, const int, const int);

int ide_busy_sleep(ide_drive_t *, unsigned long, int);

int __ide_wait_stat(ide_drive_t *, u8, u8, unsigned long, u8 *);
int ide_wait_stat(ide_startstop_t *, ide_drive_t *, u8, u8, unsigned long);

ide_startstop_t ide_do_park_unpark(ide_drive_t *, struct request *);
ide_startstop_t ide_do_devset(ide_drive_t *, struct request *);

extern ide_startstop_t ide_do_reset (ide_drive_t *);

extern int ide_devset_execute(ide_drive_t *drive,
			      const struct ide_devset *setting, int arg);

void ide_complete_cmd(ide_drive_t *, struct ide_cmd *, u8, u8);
int ide_complete_rq(ide_drive_t *, int, unsigned int);

void ide_tf_readback(ide_drive_t *drive, struct ide_cmd *cmd);
void ide_tf_dump(const char *, struct ide_cmd *);

void ide_exec_command(ide_hwif_t *, u8);
u8 ide_read_status(ide_hwif_t *);
u8 ide_read_altstatus(ide_hwif_t *);
void ide_write_devctl(ide_hwif_t *, u8);

void ide_dev_select(ide_drive_t *);
void ide_tf_load(ide_drive_t *, struct ide_taskfile *, u8);
void ide_tf_read(ide_drive_t *, struct ide_taskfile *, u8);

void ide_input_data(ide_drive_t *, struct ide_cmd *, void *, unsigned int);
void ide_output_data(ide_drive_t *, struct ide_cmd *, void *, unsigned int);

void SELECT_MASK(ide_drive_t *, int);

u8 ide_read_error(ide_drive_t *);
void ide_read_bcount_and_ireason(ide_drive_t *, u16 *, u8 *);

int ide_check_ireason(ide_drive_t *, struct request *, int, int, int);

int ide_check_atapi_device(ide_drive_t *, const char *);

void ide_init_pc(struct ide_atapi_pc *);

/* Disk head parking */
extern wait_queue_head_t ide_park_wq;
ssize_t ide_park_show(struct device *dev, struct device_attribute *attr,
		      char *buf);
ssize_t ide_park_store(struct device *dev, struct device_attribute *attr,
		       const char *buf, size_t len);

/*
 * Special requests for ide-tape block device strategy routine.
 *
 * In order to service a character device command, we add special requests to
 * the tail of our block device request queue and wait for their completion.
 */
enum {
	REQ_IDETAPE_PC1		= (1 << 0), /* packet command (first stage) */
	REQ_IDETAPE_PC2		= (1 << 1), /* packet command (second stage) */
	REQ_IDETAPE_READ	= (1 << 2),
	REQ_IDETAPE_WRITE	= (1 << 3),
};

int ide_queue_pc_tail(ide_drive_t *, struct gendisk *, struct ide_atapi_pc *,
		      void *, unsigned int);

int ide_do_test_unit_ready(ide_drive_t *, struct gendisk *);
int ide_do_start_stop(ide_drive_t *, struct gendisk *, int);
int ide_set_media_lock(ide_drive_t *, struct gendisk *, int);
void ide_create_request_sense_cmd(ide_drive_t *, struct ide_atapi_pc *);
void ide_retry_pc(ide_drive_t *drive);

void ide_prep_sense(ide_drive_t *drive, struct request *rq);
int ide_queue_sense_rq(ide_drive_t *drive, void *special);

int ide_cd_expiry(ide_drive_t *);

int ide_cd_get_xferlen(struct request *);

ide_startstop_t ide_issue_pc(ide_drive_t *, struct ide_cmd *);

ide_startstop_t do_rw_taskfile(ide_drive_t *, struct ide_cmd *);

void ide_pio_bytes(ide_drive_t *, struct ide_cmd *, unsigned int, unsigned int);

void ide_finish_cmd(ide_drive_t *, struct ide_cmd *, u8);

int ide_raw_taskfile(ide_drive_t *, struct ide_cmd *, u8 *, u16);
int ide_no_data_taskfile(ide_drive_t *, struct ide_cmd *);

int ide_taskfile_ioctl(ide_drive_t *, unsigned long);

int ide_dev_read_id(ide_drive_t *, u8, u16 *, int);

extern int ide_driveid_update(ide_drive_t *);
extern int ide_config_drive_speed(ide_drive_t *, u8);
extern u8 eighty_ninty_three (ide_drive_t *);
extern int taskfile_lib_get_identify(ide_drive_t *drive, u8 *);

extern int ide_wait_not_busy(ide_hwif_t *hwif, unsigned long timeout);

extern void ide_stall_queue(ide_drive_t *drive, unsigned long timeout);

extern void ide_timer_expiry(unsigned long);
extern irqreturn_t ide_intr(int irq, void *dev_id);
extern void do_ide_request(struct request_queue *);
extern void ide_requeue_and_plug(ide_drive_t *drive, struct request *rq);

void ide_init_disk(struct gendisk *, ide_drive_t *);

#ifdef CONFIG_IDEPCI_PCIBUS_ORDER
extern int __ide_pci_register_driver(struct pci_driver *driver, struct module *owner, const char *mod_name);
#define ide_pci_register_driver(d) __ide_pci_register_driver(d, THIS_MODULE, KBUILD_MODNAME)
#else
#define ide_pci_register_driver(d) pci_register_driver(d)
#endif

static inline int ide_pci_is_in_compatibility_mode(struct pci_dev *dev)
{
	if ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE && (dev->class & 5) != 5)
		return 1;
	return 0;
}

void ide_pci_setup_ports(struct pci_dev *, const struct ide_port_info *,
			 struct ide_hw *, struct ide_hw **);
void ide_setup_pci_noise(struct pci_dev *, const struct ide_port_info *);

#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
int ide_pci_set_master(struct pci_dev *, const char *);
unsigned long ide_pci_dma_base(ide_hwif_t *, const struct ide_port_info *);
int ide_pci_check_simplex(ide_hwif_t *, const struct ide_port_info *);
int ide_hwif_setup_dma(ide_hwif_t *, const struct ide_port_info *);
#else
static inline int ide_hwif_setup_dma(ide_hwif_t *hwif,
				     const struct ide_port_info *d)
{
	return -EINVAL;
}
#endif

struct ide_pci_enablebit {
	u8	reg;	/* byte pci reg holding the enable-bit */
	u8	mask;	/* mask to isolate the enable-bit */
	u8	val;	/* value of masked reg when "enabled" */
};

enum {
	/* Uses ISA control ports not PCI ones. */
	IDE_HFLAG_ISA_PORTS		= (1 << 0),
	/* single port device */
	IDE_HFLAG_SINGLE		= (1 << 1),
	/* don't use legacy PIO blacklist */
	IDE_HFLAG_PIO_NO_BLACKLIST	= (1 << 2),
	/* set for the second port of QD65xx */
	IDE_HFLAG_QD_2ND_PORT		= (1 << 3),
	/* use PIO8/9 for prefetch off/on */
	IDE_HFLAG_ABUSE_PREFETCH	= (1 << 4),
	/* use PIO6/7 for fast-devsel off/on */
	IDE_HFLAG_ABUSE_FAST_DEVSEL	= (1 << 5),
	/* use 100-102 and 200-202 PIO values to set DMA modes */
	IDE_HFLAG_ABUSE_DMA_MODES	= (1 << 6),
	/*
	 * keep DMA setting when programming PIO mode, may be used only
	 * for hosts which have separate PIO and DMA timings (ie. PMAC)
	 */
	IDE_HFLAG_SET_PIO_MODE_KEEP_DMA	= (1 << 7),
	/* program host for the transfer mode after programming device */
	IDE_HFLAG_POST_SET_MODE		= (1 << 8),
	/* don't program host/device for the transfer mode ("smart" hosts) */
	IDE_HFLAG_NO_SET_MODE		= (1 << 9),
	/* trust BIOS for programming chipset/device for DMA */
	IDE_HFLAG_TRUST_BIOS_FOR_DMA	= (1 << 10),
	/* host is CS5510/CS5520 */
	IDE_HFLAG_CS5520		= (1 << 11),
	/* ATAPI DMA is unsupported */
	IDE_HFLAG_NO_ATAPI_DMA		= (1 << 12),
	/* set if host is a "non-bootable" controller */
	IDE_HFLAG_NON_BOOTABLE		= (1 << 13),
	/* host doesn't support DMA */
	IDE_HFLAG_NO_DMA		= (1 << 14),
	/* check if host is PCI IDE device before allowing DMA */
	IDE_HFLAG_NO_AUTODMA		= (1 << 15),
	/* host uses MMIO */
	IDE_HFLAG_MMIO			= (1 << 16),
	/* no LBA48 */
	IDE_HFLAG_NO_LBA48		= (1 << 17),
	/* no LBA48 DMA */
	IDE_HFLAG_NO_LBA48_DMA		= (1 << 18),
	/* data FIFO is cleared by an error */
	IDE_HFLAG_ERROR_STOPS_FIFO	= (1 << 19),
	/* serialize ports */
	IDE_HFLAG_SERIALIZE		= (1 << 20),
	/* host is DTC2278 */
	IDE_HFLAG_DTC2278		= (1 << 21),
	/* 4 devices on a single set of I/O ports */
	IDE_HFLAG_4DRIVES		= (1 << 22),
	/* host is TRM290 */
	IDE_HFLAG_TRM290		= (1 << 23),
	/* use 32-bit I/O ops */
	IDE_HFLAG_IO_32BIT		= (1 << 24),
	/* unmask IRQs */
	IDE_HFLAG_UNMASK_IRQS		= (1 << 25),
	IDE_HFLAG_BROKEN_ALTSTATUS	= (1 << 26),
	/* serialize ports if DMA is possible (for sl82c105) */
	IDE_HFLAG_SERIALIZE_DMA		= (1 << 27),
	/* force host out of "simplex" mode */
	IDE_HFLAG_CLEAR_SIMPLEX		= (1 << 28),
	/* DSC overlap is unsupported */
	IDE_HFLAG_NO_DSC		= (1 << 29),
	/* never use 32-bit I/O ops */
	IDE_HFLAG_NO_IO_32BIT		= (1 << 30),
	/* never unmask IRQs */
	IDE_HFLAG_NO_UNMASK_IRQS	= (1 << 31),
};

#ifdef CONFIG_BLK_DEV_OFFBOARD
# define IDE_HFLAG_OFF_BOARD	0
#else
# define IDE_HFLAG_OFF_BOARD	IDE_HFLAG_NON_BOOTABLE
#endif

struct ide_port_info {
	char			*name;

	int			(*init_chipset)(struct pci_dev *);

	void			(*get_lock)(irq_handler_t, void *);
	void			(*release_lock)(void);

	void			(*init_iops)(ide_hwif_t *);
	void                    (*init_hwif)(ide_hwif_t *);
	int			(*init_dma)(ide_hwif_t *,
					    const struct ide_port_info *);

	const struct ide_tp_ops		*tp_ops;
	const struct ide_port_ops	*port_ops;
	const struct ide_dma_ops	*dma_ops;

	struct ide_pci_enablebit	enablebits[2];

	hwif_chipset_t		chipset;

	u16			max_sectors;	/* if < than the default one */

	u32			host_flags;

	int			irq_flags;

	u8			pio_mask;
	u8			swdma_mask;
	u8			mwdma_mask;
	u8			udma_mask;
};

int ide_pci_init_one(struct pci_dev *, const struct ide_port_info *, void *);
int ide_pci_init_two(struct pci_dev *, struct pci_dev *,
		     const struct ide_port_info *, void *);
void ide_pci_remove(struct pci_dev *);

#ifdef CONFIG_PM
int ide_pci_suspend(struct pci_dev *, pm_message_t);
int ide_pci_resume(struct pci_dev *);
#else
#define ide_pci_suspend NULL
#define ide_pci_resume NULL
#endif

void ide_map_sg(ide_drive_t *, struct ide_cmd *);
void ide_init_sg_cmd(struct ide_cmd *, unsigned int);

#define BAD_DMA_DRIVE		0
#define GOOD_DMA_DRIVE		1

struct drive_list_entry {
	const char *id_model;
	const char *id_firmware;
};

int ide_in_drive_list(u16 *, const struct drive_list_entry *);

#ifdef CONFIG_BLK_DEV_IDEDMA
int ide_dma_good_drive(ide_drive_t *);
int __ide_dma_bad_drive(ide_drive_t *);

u8 ide_find_dma_mode(ide_drive_t *, u8);

static inline u8 ide_max_dma_mode(ide_drive_t *drive)
{
	return ide_find_dma_mode(drive, XFER_UDMA_6);
}

void ide_dma_off_quietly(ide_drive_t *);
void ide_dma_off(ide_drive_t *);
void ide_dma_on(ide_drive_t *);
int ide_set_dma(ide_drive_t *);
void ide_check_dma_crc(ide_drive_t *);
ide_startstop_t ide_dma_intr(ide_drive_t *);

int ide_allocate_dma_engine(ide_hwif_t *);
void ide_release_dma_engine(ide_hwif_t *);

int ide_dma_prepare(ide_drive_t *, struct ide_cmd *);
void ide_dma_unmap_sg(ide_drive_t *, struct ide_cmd *);

#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
int config_drive_for_dma(ide_drive_t *);
int ide_build_dmatable(ide_drive_t *, struct ide_cmd *);
void ide_dma_host_set(ide_drive_t *, int);
int ide_dma_setup(ide_drive_t *, struct ide_cmd *);
extern void ide_dma_start(ide_drive_t *);
int ide_dma_end(ide_drive_t *);
int ide_dma_test_irq(ide_drive_t *);
int ide_dma_sff_timer_expiry(ide_drive_t *);
u8 ide_dma_sff_read_status(ide_hwif_t *);
extern const struct ide_dma_ops sff_dma_ops;
#else
static inline int config_drive_for_dma(ide_drive_t *drive) { return 0; }
#endif /* CONFIG_BLK_DEV_IDEDMA_SFF */

void ide_dma_lost_irq(ide_drive_t *);
ide_startstop_t ide_dma_timeout_retry(ide_drive_t *, int);

#else
static inline u8 ide_find_dma_mode(ide_drive_t *drive, u8 speed) { return 0; }
static inline u8 ide_max_dma_mode(ide_drive_t *drive) { return 0; }
static inline void ide_dma_off_quietly(ide_drive_t *drive) { ; }
static inline void ide_dma_off(ide_drive_t *drive) { ; }
static inline void ide_dma_on(ide_drive_t *drive) { ; }
static inline void ide_dma_verbose(ide_drive_t *drive) { ; }
static inline int ide_set_dma(ide_drive_t *drive) { return 1; }
static inline void ide_check_dma_crc(ide_drive_t *drive) { ; }
static inline ide_startstop_t ide_dma_intr(ide_drive_t *drive) { return ide_stopped; }
static inline ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error) { return ide_stopped; }
static inline void ide_release_dma_engine(ide_hwif_t *hwif) { ; }
static inline int ide_dma_prepare(ide_drive_t *drive,
				  struct ide_cmd *cmd) { return 1; }
static inline void ide_dma_unmap_sg(ide_drive_t *drive,
				    struct ide_cmd *cmd) { ; }
#endif /* CONFIG_BLK_DEV_IDEDMA */

#ifdef CONFIG_BLK_DEV_IDEACPI
int ide_acpi_init(void);
bool ide_port_acpi(ide_hwif_t *hwif);
extern int ide_acpi_exec_tfs(ide_drive_t *drive);
extern void ide_acpi_get_timing(ide_hwif_t *hwif);
extern void ide_acpi_push_timing(ide_hwif_t *hwif);
void ide_acpi_init_port(ide_hwif_t *);
void ide_acpi_port_init_devices(ide_hwif_t *);
extern void ide_acpi_set_state(ide_hwif_t *hwif, int on);
#else
static inline int ide_acpi_init(void) { return 0; }
static inline bool ide_port_acpi(ide_hwif_t *hwif) { return 0; }
static inline int ide_acpi_exec_tfs(ide_drive_t *drive) { return 0; }
static inline void ide_acpi_get_timing(ide_hwif_t *hwif) { ; }
static inline void ide_acpi_push_timing(ide_hwif_t *hwif) { ; }
static inline void ide_acpi_init_port(ide_hwif_t *hwif) { ; }
static inline void ide_acpi_port_init_devices(ide_hwif_t *hwif) { ; }
static inline void ide_acpi_set_state(ide_hwif_t *hwif, int on) {}
#endif

void ide_register_region(struct gendisk *);
void ide_unregister_region(struct gendisk *);

void ide_check_nien_quirk_list(ide_drive_t *);
void ide_undecoded_slave(ide_drive_t *);

void ide_port_apply_params(ide_hwif_t *);
int ide_sysfs_register_port(ide_hwif_t *);

struct ide_host *ide_host_alloc(const struct ide_port_info *, struct ide_hw **,
				unsigned int);
void ide_host_free(struct ide_host *);
int ide_host_register(struct ide_host *, const struct ide_port_info *,
		      struct ide_hw **);
int ide_host_add(const struct ide_port_info *, struct ide_hw **, unsigned int,
		 struct ide_host **);
void ide_host_remove(struct ide_host *);
int ide_legacy_device_add(const struct ide_port_info *, unsigned long);
void ide_port_unregister_devices(ide_hwif_t *);
void ide_port_scan(ide_hwif_t *);

static inline void *ide_get_hwifdata (ide_hwif_t * hwif)
{
	return hwif->hwif_data;
}

static inline void ide_set_hwifdata (ide_hwif_t * hwif, void *data)
{
	hwif->hwif_data = data;
}

extern void ide_toggle_bounce(ide_drive_t *drive, int on);

u64 ide_get_lba_addr(struct ide_cmd *, int);
u8 ide_dump_status(ide_drive_t *, const char *, u8);

struct ide_timing {
	u8  mode;
	u8  setup;	/* t1 */
	u16 act8b;	/* t2 for 8-bit io */
	u16 rec8b;	/* t2i for 8-bit io */
	u16 cyc8b;	/* t0 for 8-bit io */
	u16 active;	/* t2 or tD */
	u16 recover;	/* t2i or tK */
	u16 cycle;	/* t0 */
	u16 udma;	/* t2CYCTYP/2 */
};

enum {
	IDE_TIMING_SETUP	= (1 << 0),
	IDE_TIMING_ACT8B	= (1 << 1),
	IDE_TIMING_REC8B	= (1 << 2),
	IDE_TIMING_CYC8B	= (1 << 3),
	IDE_TIMING_8BIT		= IDE_TIMING_ACT8B | IDE_TIMING_REC8B |
				  IDE_TIMING_CYC8B,
	IDE_TIMING_ACTIVE	= (1 << 4),
	IDE_TIMING_RECOVER	= (1 << 5),
	IDE_TIMING_CYCLE	= (1 << 6),
	IDE_TIMING_UDMA		= (1 << 7),
	IDE_TIMING_ALL		= IDE_TIMING_SETUP | IDE_TIMING_8BIT |
				  IDE_TIMING_ACTIVE | IDE_TIMING_RECOVER |
				  IDE_TIMING_CYCLE | IDE_TIMING_UDMA,
};

struct ide_timing *ide_timing_find_mode(u8);
u16 ide_pio_cycle_time(ide_drive_t *, u8);
void ide_timing_merge(struct ide_timing *, struct ide_timing *,
		      struct ide_timing *, unsigned int);
int ide_timing_compute(ide_drive_t *, u8, struct ide_timing *, int, int);

#ifdef CONFIG_IDE_XFER_MODE
int ide_scan_pio_blacklist(char *);
const char *ide_xfer_verbose(u8);
int ide_pio_need_iordy(ide_drive_t *, const u8);
int ide_set_pio_mode(ide_drive_t *, u8);
int ide_set_dma_mode(ide_drive_t *, u8);
void ide_set_pio(ide_drive_t *, u8);
int ide_set_xfer_rate(ide_drive_t *, u8);
#else
static inline void ide_set_pio(ide_drive_t *drive, u8 pio) { ; }
static inline int ide_set_xfer_rate(ide_drive_t *drive, u8 rate) { return -1; }
#endif

static inline void ide_set_max_pio(ide_drive_t *drive)
{
	ide_set_pio(drive, 255);
}

char *ide_media_string(ide_drive_t *);

extern const struct attribute_group *ide_dev_groups[];
extern struct bus_type ide_bus_type;
extern struct class *ide_port_class;

static inline void ide_dump_identify(u8 *id)
{
	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 2, id, 512, 0);
}

static inline int hwif_to_node(ide_hwif_t *hwif)
{
	return hwif->dev ? dev_to_node(hwif->dev) : -1;
}

static inline ide_