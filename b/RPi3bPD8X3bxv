 define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SNAPPER_9260
# endif
# define machine_is_snapper_9260()	(machine_arch_type == MACH_TYPE_SNAPPER_9260)
#else
# define machine_is_snapper_9260()	(0)
#endif

#ifdef CONFIG_MACH_DSM320
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DSM320
# endif
# define machine_is_dsm320()	(machine_arch_type == MACH_TYPE_DSM320)
#else
# define machine_is_dsm320()	(0)
#endif

#ifdef CONFIG_MACH_EXEDA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EXEDA
# endif
# define machine_is_exeda()	(machine_arch_type == MACH_TYPE_EXEDA)
#else
# define machine_is_exeda()	(0)
#endif

#ifdef CONFIG_MACH_MINI2440
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MINI2440
# endif
# define machine_is_mini2440()	(machine_arch_type == MACH_TYPE_MINI2440)
#else
# define machine_is_mini2440()	(0)
#endif

#ifdef CONFIG_MACH_COLIBRI300
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COLIBRI300
# endif
# define machine_is_colibri300()	(machine_arch_type == MACH_TYPE_COLIBRI300)
#else
# define machine_is_colibri300()	(0)
#endif

#ifdef CONFIG_MACH_LINKSTATION_LS_HGL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LINKSTATION_LS_HGL
# endif
# define machine_is_linkstation_ls_hgl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LS_HGL)
#else
# define machine_is_linkstation_ls_hgl()	(0)
#endif

#ifdef CONFIG_MACH_CPUAT9G20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CPUAT9G20
# endif
# define machine_is_cpuat9g20()	(machine_arch_type == MACH_TYPE_CPUAT9G20)
#else
# define machine_is_cpuat9g20()	(0)
#endif

#ifdef CONFIG_MACH_SMDK6440
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK6440
# endif
# define machine_is_smdk6440()	(machine_arch_type == MACH_TYPE_SMDK6440)
#else
# define machine_is_smdk6440()	(0)
#endif

#ifdef CONFIG_MACH_NAS4220B
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NAS4220B
# endif
# define machine_is_nas4220b()	(machine_arch_type == MACH_TYPE_NAS4220B)
#else
# define machine_is_nas4220b()	(0)
#endif

#ifdef CONFIG_MACH_ZYLONITE2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ZYLONITE2
# endif
# define machine_is_zylonite2()	(machine_arch_type == MACH_TYPE_ZYLONITE2)
#else
# define machine_is_zylonite2()	(0)
#endif

#ifdef CONFIG_MACH_ASPENITE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ASPENITE
# endif
# define machine_is_aspenite()	(machine_arch_type == MACH_TYPE_ASPENITE)
#else
# define machine_is_aspenite()	(0)
#endif

#ifdef CONFIG_MACH_TTC_DKB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TTC_DKB
# endif
# define machine_is_ttc_dkb()	(machine_arch_type == MACH_TYPE_TTC_DKB)
#else
# define machine_is_ttc_dkb()	(0)
#endif

#ifdef CONFIG_MACH_PCM043
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM043
# endif
# define machine_is_pcm043()	(machine_arch_type == MACH_TYPE_PCM043)
#else
# define machine_is_pcm043()	(0)
#endif

#ifdef CONFIG_MACH_SHEEVAPLUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SHEEVAPLUG
# endif
# define machine_is_sheevaplug()	(machine_arch_type == MACH_TYPE_SHEEVAPLUG)
#else
# define machine_is_sheevaplug()	(0)
#endif

#ifdef CONFIG_MACH_AVENGERS_LITE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AVENGERS_LITE
# endif
# define machine_is_avengers_lite()	(machine_arch_type == MACH_TYPE_AVENGERS_LITE)
#else
# define machine_is_avengers_lite()	(0)
#endif

#ifdef CONFIG_MACH_MX51_BABBAGE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX51_BABBAGE
# endif
# define machine_is_mx51_babbage()	(machine_arch_type == MACH_TYPE_MX51_BABBAGE)
#else
# define machine_is_mx51_babbage()	(0)
#endif

#ifdef CONFIG_MACH_RD78X00_MASA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RD78X00_MASA
# endif
# define machine_is_rd78x00_masa()	(machine_arch_type == MACH_TYPE_RD78X00_MASA)
#else
# define machine_is_rd78x00_masa()	(0)
#endif

#ifdef CONFIG_MACH_DM355_LEOPARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DM355_LEOPARD
# endif
# define machine_is_dm355_leopard()	(machine_arch_type == MACH_TYPE_DM355_LEOPARD)
#else
# define machine_is_dm355_leopard()	(0)
#endif

#ifdef CONFIG_MACH_TS219
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TS219
# endif
# define machine_is_ts219()	(machine_arch_type == MACH_TYPE_TS219)
#else
# define machine_is_ts219()	(0)
#endif

#ifdef CONFIG_MACH_PCA100
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCA100
# endif
# define machine_is_pca100()	(machine_arch_type == MACH_TYPE_PCA100)
#else
# define machine_is_pca100()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_DA850_EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_DA850_EVM
# endif
# define machine_is_davinci_da850_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA850_EVM)
#else
# define machine_is_davinci_da850_evm()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9G10EK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9G10EK
# endif
# define machine_is_at91sam9g10ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G10EK)
#else
# define machine_is_at91sam9g10ek()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_4430SDP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_4430SDP
# endif
# define machine_is_omap_4430sdp()	(machine_arch_type == MACH_TYPE_OMAP_4430SDP)
#else
# define machine_is_omap_4430sdp()	(0)
#endif

#ifdef CONFIG_MACH_MAGX_ZN5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAGX_ZN5
# endif
# define machine_is_magx_zn5()	(machine_arch_type == MACH_TYPE_MAGX_ZN5)
#else
# define machine_is_magx_zn5()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_TORPEDO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_TORPEDO
# endif
# define machine_is_omap3_torpedo()	(machine_arch_type == MACH_TYPE_OMAP3_TORPEDO)
#else
# define machine_is_omap3_torpedo()	(0)
#endif

#ifdef CONFIG_MACH_ANW6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ANW6410
# endif
# define machine_is_anw6410()	(machine_arch_type == MACH_TYPE_ANW6410)
#else
# define machine_is_anw6410()	(0)
#endif

#ifdef CONFIG_MACH_IMX27_VISSTRIM_M10
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IMX27_VISSTRIM_M10
# endif
# define machine_is_imx27_visstrim_m10()	(machine_arch_type == MACH_TYPE_IMX27_VISSTRIM_M10)
#else
# define machine_is_imx27_visstrim_m10()	(0)
#endif

#ifdef CONFIG_MACH_PORTUXG20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PORTUXG20
# endif
# define machine_is_portuxg20()	(machine_arch_type == MACH_TYPE_PORTUXG20)
#else
# define machine_is_portuxg20()	(0)
#endif

#ifdef CONFIG_MACH_SMDKC110
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDKC110
# endif
# define machine_is_smdkc110()	(machine_arch_type == MACH_TYPE_SMDKC110)
#else
# define machine_is_smdkc110()	(0)
#endif

#ifdef CONFIG_MACH_CABESPRESSO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CABESPRESSO
# endif
# define machine_is_cabespresso()	(machine_arch_type == MACH_TYPE_CABESPRESSO)
#else
# define machine_is_cabespresso()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3517EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3517EVM
# endif
# define machine_is_omap3517evm()	(machine_arch_type == MACH_TYPE_OMAP3517EVM)
#else
# define machine_is_omap3517evm()	(0)
#endif

#ifdef CONFIG_MACH_NETSPACE_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NETSPACE_V2
# endif
# define machine_is_netspace_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_V2)
#else
# define machine_is_netspace_v2()	(0)
#endif

#ifdef CONFIG_MACH_NETSPACE_MAX_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NETSPACE_MAX_V2
# endif
# define machine_is_netspace_max_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_MAX_V2)
#else
# define machine_is_netspace_max_v2()	(0)
#endif

#ifdef CONFIG_MACH_D2NET_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_D2NET_V2
# endif
# define machine_is_d2net_v2()	(machine_arch_type == MACH_TYPE_D2NET_V2)
#else
# define machine_is_d2net_v2()	(0)
#endif

#ifdef CONFIG_MACH_NET2BIG_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NET2BIG_V2
# endif
# define machine_is_net2big_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_V2)
#else
# define machine_is_net2big_v2()	(0)
#endif

#ifdef CONFIG_MACH_NET5BIG_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NET5BIG_V2
# endif
# define machine_is_net5big_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_V2)
#else
# define machine_is_net5big_v2()	(0)
#endif

#ifdef CONFIG_MACH_INETSPACE_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_INETSPACE_V2
# endif
# define machine_is_inetspace_v2()	(machine_arch_type == MACH_TYPE_INETSPACE_V2)
#else
# define machine_is_inetspace_v2()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9G45EKES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9G45EKES
# endif
# define machine_is_at91sam9g45ekes()	(machine_arch_type == MACH_TYPE_AT91SAM9G45EKES)
#else
# define machine_is_at91sam9g45ekes()	(0)
#endif

#ifdef CONFIG_MACH_SPEAR600
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPEAR600
# endif
# define machine_is_spear600()	(machine_arch_type == MACH_TYPE_SPEAR600)
#else
# define machine_is_spear600()	(0)
#endif

#ifdef CONFIG_MACH_SPEAR300
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPEAR300
# endif
# define machine_is_spear300()	(machine_arch_type == MACH_TYPE_SPEAR300)
#else
# define machine_is_spear300()	(0)
#endif

#ifdef CONFIG_MACH_LILLY1131
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LILLY1131
# endif
# define machine_is_lilly1131()	(machine_arch_type == MACH_TYPE_LILLY1131)
#else
# define machine_is_lilly1131()	(0)
#endif

#ifdef CONFIG_MACH_HMT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HMT
# endif
# define machine_is_hmt()	(machine_arch_type == MACH_TYPE_HMT)
#else
# define machine_is_hmt()	(0)
#endif

#ifdef CONFIG_MACH_VEXPRESS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VEXPRESS
# endif
# define machine_is_vexpress()	(machine_arch_type == MACH_TYPE_VEXPRESS)
#else
# define machine_is_vexpress()	(0)
#endif

#ifdef CONFIG_MACH_D2NET
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_D2NET
# endif
# define machine_is_d2net()	(machine_arch_type == MACH_TYPE_D2NET)
#else
# define machine_is_d2net()	(0)
#endif

#ifdef CONFIG_MACH_BIGDISK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BIGDISK
# endif
# define machine_is_bigdisk()	(machine_arch_type == MACH_TYPE_BIGDISK)
#else
# define machine_is_bigdisk()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9G20EK_2MMC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK_2MMC
# endif
# define machine_is_at91sam9g20ek_2mmc()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK_2MMC)
#else
# define machine_is_at91sam9g20ek_2mmc()	(0)
#endif

#ifdef CONFIG_MACH_BCMRING
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BCMRING
# endif
# define machine_is_bcmring()	(machine_arch_type == MACH_TYPE_BCMRING)
#else
# define machine_is_bcmring()	(0)
#endif

#ifdef CONFIG_MACH_MAHIMAHI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAHIMAHI
# endif
# define machine_is_mahimahi()	(machine_arch_type == MACH_TYPE_MAHIMAHI)
#else
# define machine_is_mahimahi()	(0)
#endif

#ifdef CONFIG_MACH_CEREBRIC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CEREBRIC
# endif
# define machine_is_cerebric()	(machine_arch_type == MACH_TYPE_CEREBRIC)
#else
# define machine_is_cerebric()	(0)
#endif

#ifdef CONFIG_MACH_SMDK6442
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK6442
# endif
# define machine_is_smdk6442()	(machine_arch_type == MACH_TYPE_SMDK6442)
#else
# define machine_is_smdk6442()	(0)
#endif

#ifdef CONFIG_MACH_OPENRD_BASE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OPENRD_BASE
# endif
# define machine_is_openrd_base()	(machine_arch_type == MACH_TYPE_OPENRD_BASE)
#else
# define machine_is_openrd_base()	(0)
#endif

#ifdef CONFIG_MACH_DEVKIT8000
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DEVKIT8000
# endif
# define machine_is_devkit8000()	(machine_arch_type == MACH_TYPE_DEVKIT8000)
#else
# define machine_is_devkit8000()	(0)
#endif

#ifdef CONFIG_MACH_MX51_EFIKAMX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX51_EFIKAMX
# endif
# define machine_is_mx51_efikamx()	(machine_arch_type == MACH_TYPE_MX51_EFIKAMX)
#else
# define machine_is_mx51_efikamx()	(0)
#endif

#ifdef CONFIG_MACH_CM_T35
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_T35
# endif
# define machine_is_cm_t35()	(machine_arch_type == MACH_TYPE_CM_T35)
#else
# define machine_is_cm_t35()	(0)
#endif

#ifdef CONFIG_MACH_NET2BIG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NET2BIG
# endif
# define machine_is_net2big()	(machine_arch_type == MACH_TYPE_NET2BIG)
#else
# define machine_is_net2big()	(0)
#endif

#ifdef CONFIG_MACH_IGEP0020
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IGEP0020
# endif
# define machine_is_igep0020()	(machine_arch_type == MACH_TYPE_IGEP0020)
#else
# define machine_is_igep0020()	(0)
#endif

#ifdef CONFIG_MACH_NUC932EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NUC932EVB
# endif
# define machine_is_nuc932evb()	(machine_arch_type == MACH_TYPE_NUC932EVB)
#else
# define machine_is_nuc932evb()	(0)
#endif

#ifdef CONFIG_MACH_OPENRD_CLIENT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OPENRD_CLIENT
# endif
# define machine_is_openrd_client()	(machine_arch_type == MACH_TYPE_OPENRD_CLIENT)
#else
# define machine_is_openrd_client()	(0)
#endif

#ifdef CONFIG_MACH_U8500
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U8500
# endif
# define machine_is_u8500()	(machine_arch_type == MACH_TYPE_U8500)
#else
# define machine_is_u8500()	(0)
#endif

#ifdef CONFIG_MACH_MX51_EFIKASB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX51_EFIKASB
# endif
# define machine_is_mx51_efikasb()	(machine_arch_type == MACH_TYPE_MX51_EFIKASB)
#else
# define machine_is_mx51_efikasb()	(0)
#endif

#ifdef CONFIG_MACH_MARVELL_JASPER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MARVELL_JASPER
# endif
# define machine_is_marvell_jasper()	(machine_arch_type == MACH_TYPE_MARVELL_JASPER)
#else
# define machine_is_marvell_jasper()	(0)
#endif

#ifdef CONFIG_MACH_FLINT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FLINT
# endif
# define machine_is_flint()	(machine_arch_type == MACH_TYPE_FLINT)
#else
# define machine_is_flint()	(0)
#endif

#ifdef CONFIG_MACH_TAVOREVB3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TAVOREVB3
# endif
# define machine_is_tavorevb3()	(machine_arch_type == MACH_TYPE_TAVOREVB3)
#else
# define machine_is_tavorevb3()	(0)
#endif

#ifdef CONFIG_MACH_TOUCHBOOK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TOUCHBOOK
# endif
# define machine_is_touchbook()	(machine_arch_type == MACH_TYPE_TOUCHBOOK)
#else
# define machine_is_touchbook()	(0)
#endif

#ifdef CONFIG_MACH_RAUMFELD_RC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RAUMFELD_RC
# endif
# define machine_is_raumfeld_rc()	(machine_arch_type == MACH_TYPE_RAUMFELD_RC)
#else
# define machine_is_raumfeld_rc()	(0)
#endif

#ifdef CONFIG_MACH_RAUMFELD_CONNECTOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RAUMFELD_CONNECTOR
# endif
# define machine_is_raumfeld_connector()	(machine_arch_type == MACH_TYPE_RAUMFELD_CONNECTOR)
#else
# define machine_is_raumfeld_connector()	(0)
#endif

#ifdef CONFIG_MACH_RAUMFELD_SPEAKER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RAUMFELD_SPEAKER
# endif
# define machine_is_raumfeld_speaker()	(machine_arch_type == MACH_TYPE_RAUMFELD_SPEAKER)
#else
# define machine_is_raumfeld_speaker()	(0)
#endif

#ifdef CONFIG_MACH_TNETV107X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TNETV107X
# endif
# define machine_is_tnetv107x()	(machine_arch_type == MACH_TYPE_TNETV107X)
#else
# define machine_is_tnetv107x()	(0)
#endif

#ifdef CONFIG_MACH_SMDKV210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDKV210
# endif
# define machine_is_smdkv210()	(machine_arch_type == MACH_TYPE_SMDKV210)
#else
# define machine_is_smdkv210()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_ZOOM3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM3
# endif
# define machine_is_omap_zoom3()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM3)
#else
# define machine_is_omap_zoom3()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_3630SDP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_3630SDP
# endif
# define machine_is_omap_3630sdp()	(machine_arch_type == MACH_TYPE_OMAP_3630SDP)
#else
# define machine_is_omap_3630sdp()	(0)
#endif

#ifdef CONFIG_MACH_CYBOOK2440
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CYBOOK2440
# endif
# define machine_is_cybook2440()	(machine_arch_type == MACH_TYPE_CYBOOK2440)
#else
# define machine_is_cybook2440()	(0)
#endif

#ifdef CONFIG_MACH_SMARTQ7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMARTQ7
# endif
# define machine_is_smartq7()	(machine_arch_type == MACH_TYPE_SMARTQ7)
#else
# define machine_is_smartq7()	(0)
#endif

#ifdef CONFIG_MACH_WATSON_EFM_PLUGIN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WATSON_EFM_PLUGIN
# endif
# define machine_is_watson_efm_plugin()	(machine_arch_type == MACH_TYPE_WATSON_EFM_PLUGIN)
#else
# define machine_is_watson_efm_plugin()	(0)
#endif

#ifdef CONFIG_MACH_G4EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_G4EVM
# endif
# define machine_is_g4evm()	(machine_arch_type == MACH_TYPE_G4EVM)
#else
# define machine_is_g4evm()	(0)
#endif

#ifdef CONFIG_MACH_OMAPL138_HAWKBOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAPL138_HAWKBOARD
# endif
# define machine_is_omapl138_hawkboard()	(machine_arch_type == MACH_TYPE_OMAPL138_HAWKBOARD)
#else
# define machine_is_omapl138_hawkboard()	(0)
#endif

#ifdef CONFIG_MACH_TS41X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TS41X
# endif
# define machine_is_ts41x()	(machine_arch_type == MACH_TYPE_TS41X)
#else
# define machine_is_ts41x()	(0)
#endif

#ifdef CONFIG_MACH_PHY3250
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PHY3250
# endif
# define machine_is_phy3250()	(machine_arch_type == MACH_TYPE_PHY3250)
#else
# define machine_is_phy3250()	(0)
#endif

#ifdef CONFIG_MACH_MINI6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MINI6410
# endif
# define machine_is_mini6410()	(machine_arch_type == MACH_TYPE_MINI6410)
#else
# define machine_is_mini6410()	(0)
#endif

#ifdef CONFIG_MACH_MX28EVK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX28EVK
# endif
# define machine_is_mx28evk()	(machine_arch_type == MACH_TYPE_MX28EVK)
#else
# define machine_is_mx28evk()	(0)
#endif

#ifdef CONFIG_MACH_SMARTQ5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMARTQ5
# endif
# define machine_is_smartq5()	(machine_arch_type == MACH_TYPE_SMARTQ5)
#else
# define machine_is_smartq5()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_DM6467TEVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467TEVM
# endif
# define machine_is_davinci_dm6467tevm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467TEVM)
#else
# define machine_is_davinci_dm6467tevm()	(0)
#endif

#ifdef CONFIG_MACH_MXT_TD60
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MXT_TD60
# endif
# define machine_is_mxt_td60()	(machine_arch_type == MACH_TYPE_MXT_TD60)
#else
# define machine_is_mxt_td60()	(0)
#endif

#ifdef CONFIG_MACH_CAPC7117
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CAPC7117
# endif
# define machine_is_capc7117()	(machine_arch_type == MACH_TYPE_CAPC7117)
#else
# define machine_is_capc7117()	(0)
#endif

#ifdef CONFIG_MACH_ICONTROL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ICONTROL
# endif
# define machine_is_icontrol()	(machine_arch_type == MACH_TYPE_ICONTROL)
#else
# define machine_is_icontrol()	(0)
#endif

#ifdef CONFIG_MACH_GPLUGD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GPLUGD
# endif
# define machine_is_gplugd()	(machine_arch_type == MACH_TYPE_GPLUGD)
#else
# define machine_is_gplugd()	(0)
#endif

#ifdef CONFIG_MACH_QSD8X50A_ST1_5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QSD8X50A_ST1_5
# endif
# define machine_is_qsd8x50a_st1_5()	(machine_arch_type == MACH_TYPE_QSD8X50A_ST1_5)
#else
# define machine_is_qsd8x50a_st1_5()	(0)
#endif

#ifdef CONFIG_MACH_MX23EVK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX23EVK
# endif
# define machine_is_mx23evk()	(machine_arch_type == MACH_TYPE_MX23EVK)
#else
# define machine_is_mx23evk()	(0)
#endif

#ifdef CONFIG_MACH_AP4EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AP4EVB
# endif
# define machine_is_ap4evb()	(machine_arch_type == MACH_TYPE_AP4EVB)
#else
# define machine_is_ap4evb()	(0)
#endif

#ifdef CONFIG_MACH_MITYOMAPL138
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MITYOMAPL138
# endif
# define machine_is_mityomapl138()	(machine_arch_type == MACH_TYPE_MITYOMAPL138)
#else
# define machine_is_mityomapl138()	(0)
#endif

#ifdef CONFIG_MACH_GURUPLUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GURUPLUG
# endif
# define machine_is_guruplug()	(machine_arch_type == MACH_TYPE_GURUPLUG)
#else
# define machine_is_guruplug()	(0)
#endif

#ifdef CONFIG_MACH_SPEAR310
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPEAR310
# endif
# define machine_is_spear310()	(machine_arch_type == MACH_TYPE_SPEAR310)
#else
# define machine_is_spear310()	(0)
#endif

#ifdef CONFIG_MACH_SPEAR320
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPEAR320
# endif
# define machine_is_spear320()	(machine_arch_type == MACH_TYPE_SPEAR320)
#else
# define machine_is_spear320()	(0)
#endif

#ifdef CONFIG_MACH_AQUILA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AQUILA
# endif
# define machine_is_aquila()	(machine_arch_type == MACH_TYPE_AQUILA)
#else
# define machine_is_aquila()	(0)
#endif

#ifdef CONFIG_MACH_ESATA_SHEEVAPLUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ESATA_SHEEVAPLUG
# endif
# define machine_is_esata_sheevaplug()	(machine_arch_type == MACH_TYPE_ESATA_SHEEVAPLUG)
#else
# define machine_is_esata_sheevaplug()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X30_SURF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X30_SURF
# endif
# define machine_is_msm7x30_surf()	(machine_arch_type == MACH_TYPE_MSM7X30_SURF)
#else
# define machine_is_msm7x30_surf()	(0)
#endif

#ifdef CONFIG_MACH_TERASTATION_WXL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TERASTATION_WXL
# endif
# define machine_is_terastation_wxl()	(machine_arch_type == MACH_TYPE_TERASTATION_WXL)
#else
# define machine_is_terastation_wxl()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X25_SURF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X25_SURF
# endif
# define machine_is_msm7x25_surf()	(machine_arch_type == MACH_TYPE_MSM7X25_SURF)
#else
# define machine_is_msm7x25_surf()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X25_FFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X25_FFA
# endif
# define machine_is_msm7x25_ffa()	(machine_arch_type == MACH_TYPE_MSM7X25_FFA)
#else
# define machine_is_msm7x25_ffa()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X27_SURF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X27_SURF
# endif
# define machine_is_msm7x27_surf()	(machine_arch_type == MACH_TYPE_MSM7X27_SURF)
#else
# define machine_is_msm7x27_surf()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X27_FFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X27_FFA
# endif
# define machine_is_msm7x27_ffa()	(machine_arch_type == MACH_TYPE_MSM7X27_FFA)
#else
# define machine_is_msm7x27_ffa()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X30_FFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X30_FFA
# endif
# define machine_is_msm7x30_ffa()	(machine_arch_type == MACH_TYPE_MSM7X30_FFA)
#else
# define machine_is_msm7x30_ffa()	(0)
#endif

#ifdef CONFIG_MACH_QSD8X50_SURF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QSD8X50_SURF
# endif
# define machine_is_qsd8x50_surf()	(machine_arch_type == MACH_TYPE_QSD8X50_SURF)
#else
# define machine_is_qsd8x50_surf()	(0)
#endif

#ifdef CONFIG_MACH_MX53_EVK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_EVK
# endif
# define machine_is_mx53_evk()	(machine_arch_type == MACH_TYPE_MX53_EVK)
#else
# define machine_is_mx53_evk()	(0)
#endif

#ifdef CONFIG_MACH_IGEP0030
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IGEP0030
# endif
# define machine_is_igep0030()	(machine_arch_type == MACH_TYPE_IGEP0030)
#else
# define machine_is_igep0030()	(0)
#endif

#ifdef CONFIG_MACH_SBC3530
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SBC3530
# endif
# define machine_is_sbc3530()	(machine_arch_type == MACH_TYPE_SBC3530)
#else
# define machine_is_sbc3530()	(0)
#endif

#ifdef CONFIG_MACH_SAARB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SAARB
# endif
# define machine_is_saarb()	(machine_arch_type == MACH_TYPE_SAARB)
#else
# define machine_is_saarb()	(0)
#endif

#ifdef CONFIG_MACH_HARMONY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HARMONY
# endif
# define machine_is_harmony()	(machine_arch_type == MACH_TYPE_HARMONY)
#else
# define machine_is_harmony()	(0)
#endif

#ifdef CONFIG_MACH_CYBOOK_ORIZON
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CYBOOK_ORIZON
# endif
# define machine_is_cybook_orizon()	(machine_arch_type == MACH_TYPE_CYBOOK_ORIZON)
#else
# define machine_is_cybook_orizon()	(0)
#endif

#ifdef CONFIG_MACH_MSM7X30_FLUID
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM7X30_FLUID
# endif
# define machine_is_msm7x30_fluid()	(machine_arch_type == MACH_TYPE_MSM7X30_FLUID)
#else
# define machine_is_msm7x30_fluid()	(0)
#endif

#ifdef CONFIG_MACH_CM_T3517
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_T3517
# endif
# define machine_is_cm_t3517()	(machine_arch_type == MACH_TYPE_CM_T3517)
#else
# define machine_is_cm_t3517()	(0)
#endif

#ifdef CONFIG_MACH_WBD222
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WBD222
# endif
# define machine_is_wbd222()	(machine_arch_type == MACH_TYPE_WBD222)
#else
# define machine_is_wbd222()	(0)
#endif

#ifdef CONFIG_MACH_MSM8X60_SURF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8X60_SURF
# endif
# define machine_is_msm8x60_surf()	(machine_arch_type == MACH_TYPE_MSM8X60_SURF)
#else
# define machine_is_msm8x60_surf()	(0)
#endif

#ifdef CONFIG_MACH_MSM8X60_SIM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8X60_SIM
# endif
# define machine_is_msm8x60_sim()	(machine_arch_type == MACH_TYPE_MSM8X60_SIM)
#else
# define machine_is_msm8x60_sim()	(0)
#endif

#ifdef CONFIG_MACH_TCC8000_SDK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TCC8000_SDK
# endif
# define machine_is_tcc8000_sdk()	(machine_arch_type == MACH_TYPE_TCC8000_SDK)
#else
# define machine_is_tcc8000_sdk()	(0)
#endif

#ifdef CONFIG_MACH_CNS3420VB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CNS3420VB
# endif
# define machine_is_cns3420vb()	(machine_arch_type == MACH_TYPE_CNS3420VB)
#else
# define machine_is_cns3420vb()	(0)
#endif

#ifdef CONFIG_MACH_OMAP4_PANDA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP4_PANDA
# endif
# define machine_is_omap4_panda()	(machine_arch_type == MACH_TYPE_OMAP4_PANDA)
#else
# define machine_is_omap4_panda()	(0)
#endif

#ifdef CONFIG_MACH_TI8168EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TI8168EVM
# endif
# define machine_is_ti8168evm()	(machine_arch_type == MACH_TYPE_TI8168EVM)
#else
# define machine_is_ti8168evm()	(0)
#endif

#ifdef CONFIG_MACH_TETON_BGA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TETON_BGA
# endif
# define machine_is_teton_bga()	(machine_arch_type == MACH_TYPE_TETON_BGA)
#else
# define machine_is_teton_bga()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX25SD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX25SD
# endif
# define machine_is_eukrea_cpuimx25sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX25SD)
#else
# define machine_is_eukrea_cpuimx25sd()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX35SD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX35SD
# endif
# define machine_is_eukrea_cpuimx35sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX35SD)
#else
# define machine_is_eukrea_cpuimx35sd()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX51SD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51SD
# endif
# define machine_is_eukrea_cpuimx51sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51SD)
#else
# define machine_is_eukrea_cpuimx51sd()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX51
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51
# endif
# define machine_is_eukrea_cpuimx51()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51)
#else
# define machine_is_eukrea_cpuimx51()	(0)
#endif

#ifdef CONFIG_MACH_SMDKC210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDKC210
# endif
# define machine_is_smdkc210()	(machine_arch_type == MACH_TYPE_SMDKC210)
#else
# define machine_is_smdkc210()	(0)
#endif

#ifdef CONFIG_MACH_T5325
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_T5325
# endif
# define machine_is_t5325()	(machine_arch_type == MACH_TYPE_T5325)
#else
# define machine_is_t5325()	(0)
#endif

#ifdef CONFIG_MACH_INCOME
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_INCOME
# endif
# define machine_is_income()	(machine_arch_type == MACH_TYPE_INCOME)
#else
# define machine_is_income()	(0)
#endif

#ifdef CONFIG_MACH_GONI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GONI
# endif
# define machine_is_goni()	(machine_arch_type == MACH_TYPE_GONI)
#else
# define machine_is_goni()	(0)
#endif

#ifdef CONFIG_MACH_BV07
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BV07
# endif
# define machine_is_bv07()	(machine_arch_type == MACH_TYPE_BV07)
#else
# define machine_is_bv07()	(0)
#endif

#ifdef CONFIG_MACH_OPENRD_ULTIMATE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OPENRD_ULTIMATE
# endif
# define machine_is_openrd_ultimate()	(machine_arch_type == MACH_TYPE_OPENRD_ULTIMATE)
#else
# define machine_is_openrd_ultimate()	(0)
#endif

#ifdef CONFIG_MACH_DEVIXP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DEVIXP
# endif
# define machine_is_devixp()	(machine_arch_type == MACH_TYPE_DEVIXP)
#else
# define machine_is_devixp()	(0)
#endif

#ifdef CONFIG_MACH_MICCPT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MICCPT
# endif
# define machine_is_miccpt()	(machine_arch_type == MACH_TYPE_MICCPT)
#else
# define machine_is_miccpt()	(0)
#endif

#ifdef CONFIG_MACH_MIC256
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MIC256
# endif
# define machine_is_mic256()	(machine_arch_type == MACH_TYPE_MIC256)
#else
# define machine_is_mic256()	(0)
#endif

#ifdef CONFIG_MACH_U5500
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U5500
# endif
# define machine_is_u5500()	(machine_arch_type == MACH_TYPE_U5500)
#else
# define machine_is_u5500()	(0)
#endif

#ifdef CONFIG_MACH_LINKSTATION_LSCHL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LINKSTATION_LSCHL
# endif
# define machine_is_linkstation_lschl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LSCHL)
#else
# define machine_is_linkstation_lschl()	(0)
#endif

#ifdef CONFIG_MACH_SMDKV310
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDKV310
# endif
# define machine_is_smdkv310()	(machine_arch_type == MACH_TYPE_SMDKV310)
#else
# define machine_is_smdkv310()	(0)
#endif

#ifdef CONFIG_MACH_WM8505_7IN_NETBOOK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WM8505_7IN_NETBOOK
# endif
# define machine_is_wm8505_7in_netbook()	(machine_arch_type == MACH_TYPE_WM8505_7IN_NETBOOK)
#else
# define machine_is_wm8505_7in_netbook()	(0)
#endif

#ifdef CONFIG_MACH_CRANEBOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CRANEBOARD
# endif
# define machine_is_craneboard()	(machine_arch_type == MACH_TYPE_CRANEBOARD)
#else
# define machine_is_craneboard()	(0)
#endif

#ifdef CONFIG_MACH_SMDK6450
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK6450
# endif
# define machine_is_smdk6450()	(machine_arch_type == MACH_TYPE_SMDK6450)
#else
# define machine_is_smdk6450()	(0)
#endif

#ifdef CONFIG_MACH_BROWNSTONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BROWNSTONE
# endif
# define machine_is_brownstone()	(machine_arch_type == MACH_TYPE_BROWNSTONE)
#else
# define machine_is_brownstone()	(0)
#endif

#ifdef CONFIG_MACH_FLEXIBITY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FLEXIBITY
# endif
# define machine_is_flexibity()	(machine_arch_type == MACH_TYPE_FLEXIBITY)
#else
# define machine_is_flexibity()	(0)
#endif

#ifdef CONFIG_MACH_MX50_RDP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX50_RDP
# endif
# define machine_is_mx50_rdp()	(machine_arch_type == MACH_TYPE_MX50_RDP)
#else
# define machine_is_mx50_rdp()	(0)
#endif

#ifdef CONFIG_MACH_UNIVERSAL_C210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_UNIVERSAL_C210
# endif
# define machine_is_universal_c210()	(machine_arch_type == MACH_TYPE_UNIVERSAL_C210)
#else
# define machine_is_universal_c210()	(0)
#endif

#ifdef CONFIG_MACH_REAL6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_REAL6410
# endif
# define machine_is_real6410()	(machine_arch_type == MACH_TYPE_REAL6410)
#else
# define machine_is_real6410()	(0)
#endif

#ifdef CONFIG_MACH_DOCKSTAR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DOCKSTAR
# endif
# define machine_is_dockstar()	(machine_arch_type == MACH_TYPE_DOCKSTAR)
#else
# define machine_is_dockstar()	(0)
#endif

#ifdef CONFIG_MACH_TI8148EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TI8148EVM
# endif
# define machine_is_ti8148evm()	(machine_arch_type == MACH_TYPE_TI8148EVM)
#else
# define machine_is_ti8148evm()	(0)
#endif

#ifdef CONFIG_MACH_SEABOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SEABOARD
# endif
# define machine_is_seaboard()	(machine_arch_type == MACH_TYPE_SEABOARD)
#else
# define machine_is_seaboard()	(0)
#endif

#ifdef CONFIG_MACH_MX53_ARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_ARD
# endif
# define machine_is_mx53_ard()	(machine_arch_type == MACH_TYPE_MX53_ARD)
#else
# define machine_is_mx53_ard()	(0)
#endif

#ifdef CONFIG_MACH_MX53_SMD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_SMD
# endif
# define machine_is_mx53_smd()	(machine_arch_type == MACH_TYPE_MX53_SMD)
#else
# define machine_is_mx53_smd()	(0)
#endif

#ifdef CONFIG_MACH_MSM8X60_RUMI3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8X60_RUMI3
# endif
# define machine_is_msm8x60_rumi3()	(machine_arch_type == MACH_TYPE_MSM8X60_RUMI3)
#else
# define machine_is_msm8x60_rumi3()	(0)
#endif

#ifdef CONFIG_MACH_MSM8X60_FFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8X60_FFA
# endif
# define machine_is_msm8x60_ffa()	(machine_arch_type == MACH_TYPE_MSM8X60_FFA)
#else
# define machine_is_msm8x60_ffa()	(0)
#endif

#ifdef CONFIG_MACH_CM_A510
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_A510
# endif
# define machine_is_cm_a510()	(machine_arch_type == MACH_TYPE_CM_A510)
#else
# define machine_is_cm_a510()	(0)
#endif

#ifdef CONFIG_MACH_TX28
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TX28
# endif
# define machine_is_tx28()	(machine_arch_type == MACH_TYPE_TX28)
#else
# define machine_is_tx28()	(0)
#endif

#ifdef CONFIG_MACH_PCONTROL_G20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCONTROL_G20
# endif
# define machine_is_pcontrol_g20()	(machine_arch_type == MACH_TYPE_PCONTROL_G20)
#else
# define machine_is_pcontrol_g20()	(0)
#endif

#ifdef CONFIG_MACH_VPR200
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VPR200
# endif
# define machine_is_vpr200()	(machine_arch_type == MACH_TYPE_VPR200)
#else
# define machine_is_vpr200()	(0)
#endif

#ifdef CONFIG_MACH_TORBRECK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TORBRECK
# endif
# define machine_is_torbreck()	(machine_arch_type == MACH_TYPE_TORBRECK)
#else
# define machine_is_torbreck()	(0)
#endif

#ifdef CONFIG_MACH_PRIMA2_EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PRIMA2_EVB
# endif
# define machine_is_prima2_evb()	(machine_arch_type == MACH_TYPE_PRIMA2_EVB)
#else
# define machine_is_prima2_evb()	(0)
#endif

#ifdef CONFIG_MACH_PAZ00
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PAZ00
# endif
# define machine_is_paz00()	(machine_arch_type == MACH_TYPE_PAZ00)
#else
# define machine_is_paz00()	(0)
#endif

#ifdef CONFIG_MACH_ACMENETUSFOXG20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACMENETUSFOXG20
# endif
# define machine_is_acmenetusfoxg20()	(machine_arch_type == MACH_TYPE_ACMENETUSFOXG20)
#else
# define machine_is_acmenetusfoxg20()	(0)
#endif

#ifdef CONFIG_MACH_BCM2708
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BCM2708
# endif
# define machine_is_bcm2708()	(machine_arch_type == MACH_TYPE_BCM2708)
#else
# define machine_is_bcm2708()	(0)
#endif

#ifdef CONFIG_MACH_BCM2709
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BCM2709
# endif
# define machine_is_bcm2709()	(machine_arch_type == MACH_TYPE_BCM2709)
#else
# define machine_is_bcm2709()	(0)
#endif

#ifdef CONFIG_MACH_AG5EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AG5EVM
# endif
# define machine_is_ag5evm()	(machine_arch_type == MACH_TYPE_AG5EVM)
#else
# define machine_is_ag5evm()	(0)
#endif

#ifdef CONFIG_MACH_ICS_IF_VOIP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ICS_IF_VOIP
# endif
# define machine_is_ics_if_voip()	(machine_arch_type == MACH_TYPE_ICS_IF_VOIP)
#else
# define machine_is_ics_if_voip()	(0)
#endif

#ifdef CONFIG_MACH_WLF_CRAGG_6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WLF_CRAGG_6410
# endif
# define machine_is_wlf_cragg_6410()	(machine_arch_type == MACH_TYPE_WLF_CRAGG_6410)
#else
# define machine_is_wlf_cragg_6410()	(0)
#endif

#ifdef CONFIG_MACH_TRIMSLICE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TRIMSLICE
# endif
# define machine_is_trimslice()	(machine_arch_type == MACH_TYPE_TRIMSLICE)
#else
# define machine_is_trimslice()	(0)
#endif

#ifdef CONFIG_MACH_KAEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KAEN
# endif
# define machine_is_kaen()	(machine_arch_type == MACH_TYPE_KAEN)
#else
# define machine_is_kaen()	(0)
#endif

#ifdef CONFIG_MACH_NOKIA_RM680
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOKIA_RM680
# endif
# define machine_is_nokia_rm680()	(machine_arch_type == MACH_TYPE_NOKIA_RM680)
#else
# define machine_is_nokia_rm680()	(0)
#endif

#ifdef CONFIG_MACH_MSM8960_SIM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8960_SIM
# endif
# define machine_is_msm8960_sim()	(machine_arch_type == MACH_TYPE_MSM8960_SIM)
#else
# define machine_is_msm8960_sim()	(0)
#endif

#ifdef CONFIG_MACH_MSM8960_RUMI3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8960_RUMI3
# endif
# define machine_is_msm8960_rumi3()	(machine_arch_type == MACH_TYPE_MSM8960_RUMI3)
#else
# define machine_is_msm8960_rumi3()	(0)
#endif

#ifdef CONFIG_MACH_GSIA18S
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GSIA18S
# endif
# define machine_is_gsia18s()	(machine_arch_type == MACH_TYPE_GSIA18S)
#else
# define machine_is_gsia18s()	(0)
#endif

#ifdef CONFIG_MACH_MX53_LOCO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_LOCO
# endif
# define machine_is_mx53_loco()	(machine_arch_type == MACH_TYPE_MX53_LOCO)
#else
# define machine_is_mx53_loco()	(0)
#endif

#ifdef CONFIG_MACH_WARIO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WARIO
# endif
# define machine_is_wario()	(machine_arch_type == MACH_TYPE_WARIO)
#else
# define machine_is_wario()	(0)
#endif

#ifdef CONFIG_MACH_CM_T3730
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_T3730
# endif
# define machine_is_cm_t3730()	(machine_arch_type == MACH_TYPE_CM_T3730)
#else
# define machine_is_cm_t3730()	(0)
#endif

#ifdef CONFIG_MACH_HREFV60
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HREFV60
# endif
# define machine_is_hrefv60()	(machine_arch_type == MACH_TYPE_HREFV60)
#else
# define machine_is_hrefv60()	(0)
#endif

#ifdef CONFIG_MACH_ARMLEX4210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMLEX4210
# endif
# define machine_is_armlex4210()	(machine_arch_type == MACH_TYPE_ARMLEX4210)
#else
# define machine_is_armlex4210()	(0)
#endif

#ifdef CONFIG_MACH_SNOWBALL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SNOWBALL
# endif
# define machine_is_snowball()	(machine_arch_type == MACH_TYPE_SNOWBALL)
#else
# define machine_is_snowball()	(0)
#endif

#ifdef CONFIG_MACH_XILINX_EP107
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_XILINX_EP107
# endif
# define machine_is_xilinx_ep107()	(machine_arch_type == MACH_TYPE_XILINX_EP107)
#else
# define machine_is_xilinx_ep107()	(0)
#endif

#ifdef CONFIG_MACH_NURI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NURI
# endif
# define machine_is_nuri()	(machine_arch_type == MACH_TYPE_NURI)
#else
# define machine_is_nuri()	(0)
#endif

#ifdef CONFIG_MACH_ORIGEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ORIGEN
# endif
# define machine_is_origen()	(machine_arch_type == MACH_TYPE_ORIGEN)
#else
# define machine_is_origen()	(0)
#endif

#ifdef CONFIG_MACH_NSPIRE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSPIRE
# endif
# define machine_is_nspire()	(machine_arch_type == MACH_TYPE_NSPIRE)
#else
# define machine_is_nspire()	(0)
#endif

#ifdef CONFIG_MACH_NOKIA_RM696
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOKIA_RM696
# endif
# define machine_is_nokia_rm696()	(machine_arch_type == MACH_TYPE_NOKIA_RM696)
#else
# define machine_is_nokia_rm696()	(0)
#endif

#ifdef CONFIG_MACH_MIKRAP_X168
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MIKRAP_X168
# endif
# define machine_is_mikrap_x168()	(machine_arch_type == MACH_TYPE_MIKRAP_X168)
#else
# define machine_is_mikrap_x168()	(0)
#endif

#ifdef CONFIG_MACH_DETO_MACARM9
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DETO_MACARM9
# endif
# define machine_is_deto_macarm9()	(machine_arch_type == MACH_TYPE_DETO_MACARM9)
#else
# define machine_is_deto_macarm9()	(0)
#endif

#ifdef CONFIG_MACH_M28EVK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M28EVK
# endif
# define machine_is_m28evk()	(machine_arch_type == MACH_TYPE_M28EVK)
#else
# define machine_is_m28evk()	(0)
#endif

#ifdef CONFIG_MACH_KOTA2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KOTA2
# endif
# define machine_is_kota2()	(machine_arch_type == MACH_TYPE_KOTA2)
#else
# define machine_is_kota2()	(0)
#endif

#ifdef CONFIG_MACH_BONITO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BONITO
# endif
# define machine_is_bonito()	(machine_arch_type == MACH_TYPE_BONITO)
#else
# define machine_is_bonito()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_EGF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_EGF
# endif
# define machine_is_omap3_egf()	(machine_arch_type == MACH_TYPE_OMAP3_EGF)
#else
# define machine_is_omap3_egf()	(0)
#endif

#ifdef CONFIG_MACH_SMDK4212
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK4212
# endif
# define machine_is_smdk4212()	(machine_arch_type == MACH_TYPE_SMDK4212)
#else
# define machine_is_smdk4212()	(0)
#endif

#ifdef CONFIG_MACH_APX4DEVKIT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_APX4DEVKIT
# endif
# define machine_is_apx4devkit()	(machine_arch_type == MACH_TYPE_APX4DEVKIT)
#else
# define machine_is_apx4devkit()	(0)
#endif

#ifdef CONFIG_MACH_SMDK4412
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK4412
# endif
# define machine_is_smdk4412()	(machine_arch_type == MACH_TYPE_SMDK4412)
#else
# define machine_is_smdk4412()	(0)
#endif

#ifdef CONFIG_MACH_MARZEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MARZEN
# endif
# define machine_is_marzen()	(machine_arch_type == MACH_TYPE_MARZEN)
#else
# define machine_is_marzen()	(0)
#endif

#ifdef CONFIG_MACH_KROME
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KROME
# endif
# define machine_is_krome()	(machine_arch_type == MACH_TYPE_KROME)
#else
# define machine_is_krome()	(0)
#endif

#ifdef CONFIG_MACH_ARMADILLO800EVA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMADILLO800EVA
# endif
# define machine_is_armadillo800eva()	(machine_arch_type == MACH_TYPE_ARMADILLO800EVA)
#else
# define machine_is_armadillo800eva()	(0)
#endif

#ifdef CONFIG_MACH_MX53_UMOBO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_UMOBO
# endif
# define machine_is_mx53_umobo()	(machine_arch_type == MACH_TYPE_MX53_UMOBO)
#else
# define machine_is_mx53_umobo()	(0)
#endif

#ifdef CONFIG_MACH_MT4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MT4
# endif
# define machine_is_mt4()	(machine_arch_type == MACH_TYPE_MT4)
#else
# define machine_is_mt4()	(0)
#endif

#ifdef CONFIG_MACH_U8520
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U8520
# endif
# define machine_is_u8520()	(machine_arch_type == MACH_TYPE_U8520)
#else
# define machine_is_u8520()	(0)
#endif

#ifdef CONFIG_MACH_CHUPACABRA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CHUPACABRA
# endif
# define machine_is_chupacabra()	(machine_arch_type == MACH_TYPE_CHUPACABRA)
#else
# define machine_is_chupacabra()	(0)
#endif

#ifdef CONFIG_MACH_SCORPION
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SCORPION
# endif
# define machine_is_scorpion()	(machine_arch_type == MACH_TYPE_SCORPION)
#else
# define machine_is_scorpion()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_HE_HMI10
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_HE_HMI10
# endif
# define machine_is_davinci_he_hmi10()	(machine_arch_type == MACH_TYPE_DAVINCI_HE_HMI10)
#else
# define machine_is_davinci_he_hmi10()	(0)
#endif

#ifdef CONFIG_MACH_TOPKICK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TOPKICK
# endif
# define machine_is_topkick()	(machine_arch_type == MACH_TYPE_TOPKICK)
#else
# define machine_is_topkick()	(0)
#endif

#ifdef CONFIG_MACH_M3_AUGUESTRUSH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M3_AUGUESTRUSH
# endif
# define machine_is_m3_auguestrush()	(machine_arch_type == MACH_TYPE_M3_AUGUESTRUSH)
#else
# define machine_is_m3_auguestrush()	(0)
#endif

#ifdef CONFIG_MACH_IPC335X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IPC335X
# endif
# define machine_is_ipc335x()	(machine_arch_type == MACH_TYPE_IPC335X)
#else
# define machine_is_ipc335x()	(0)
#endif

#ifdef CONFIG_MACH_SUN4I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SUN4I
# endif
# define machine_is_sun4i()	(machine_arch_type == MACH_TYPE_SUN4I)
#else
# define machine_is_sun4i()	(0)
#endif

#ifdef CONFIG_MACH_IMX233_OLINUXINO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IMX233_OLINUXINO
# endif
# define machine_is_imx233_olinuxino()	(machine_arch_type == MACH_TYPE_IMX233_OLINUXINO)
#else
# define machine_is_imx233_olinuxino()	(0)
#endif

#ifdef CONFIG_MACH_K2_WL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K2_WL
# endif
# define machine_is_k2_wl()	(machine_arch_type == MACH_TYPE_K2_WL)
#else
# define machine_is_k2_wl()	(0)
#endif

#ifdef CONFIG_MACH_K2_UL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K2_UL
# endif
# define machine_is_k2_ul()	(machine_arch_type == MACH_TYPE_K2_UL)
#else
# define machine_is_k2_ul()	(0)
#endif

#ifdef CONFIG_MACH_K2_CL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K2_CL
# endif
# define machine_is_k2_cl()	(machine_arch_type == MACH_TYPE_K2_CL)
#else
# define machine_is_k2_cl()	(0)
#endif

#ifdef CONFIG_MACH_MINBARI_W
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MINBARI_W
# endif
# define machine_is_minbari_w()	(machine_arch_type == MACH_TYPE_MINBARI_W)
#else
# define machine_is_minbari_w()	(0)
#endif

#ifdef CONFIG_MACH_MINBARI_M
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MINBARI_M
# endif
# define machine_is_minbari_m()	(machine_arch_type == MACH_TYPE_MINBARI_M)
#else
# define machine_is_minbari_m()	(0)
#endif

#ifdef CONFIG_MACH_K035
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K035
# endif
# define machine_is_k035()	(machine_arch_type == MACH_TYPE_K035)
#else
# define machine_is_k035()	(0)
#endif

#ifdef CONFIG_MACH_ARIEL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARIEL
# endif
# define machine_is_ariel()	(machine_arch_type == MACH_TYPE_ARIEL)
#else
# define machine_is_ariel()	(0)
#endif

#ifdef CONFIG_MACH_ARIELSAARC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARIELSAARC
# endif
# define machine_is_arielsaarc()	(machine_arch_type == MACH_TYPE_ARIELSAARC)
#else
# define machine_is_arielsaarc()	(0)
#endif

#ifdef CONFIG_MACH_ARIELDKB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARIELDKB
# endif
# define machine_is_arieldkb()	(machine_arch_type == MACH_TYPE_ARIELDKB)
#else
# define machine_is_arieldkb()	(0)
#endif

#ifdef CONFIG_MACH_ARMADILLO810
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMADILLO810
# endif
# define machine_is_armadillo810()	(machine_arch_type == MACH_TYPE_ARMADILLO810)
#else
# define machine_is_armadillo810()	(0)
#endif

#ifdef CONFIG_MACH_TAM335X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TAM335X
# endif
# define machine_is_tam335x()	(machine_arch_type == MACH_TYPE_TAM335X)
#else
# define machine_is_tam335x()	(0)
#endif

#ifdef CONFIG_MACH_GROUPER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GROUPER
# endif
# define machine_is_grouper()	(machine_arch_type == MACH_TYPE_GROUPER)
#else
# define machine_is_grouper()	(0)
#endif

#ifdef CONFIG_MACH_MPCSA21_9G20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MPCSA21_9G20
# endif
# define machine_is_mpcsa21_9g20()	(machine_arch_type == MACH_TYPE_MPCSA21_9G20)
#else
# define machine_is_mpcsa21_9g20()	(0)
#endif

#ifdef CONFIG_MACH_M6U_CPU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M6U_CPU
# endif
# define machine_is_m6u_cpu()	(machine_arch_type == MACH_TYPE_M6U_CPU)
#else
# define machine_is_m6u_cpu()	(0)
#endif

#ifdef CONFIG_MACH_GINKGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GINKGO
# endif
# define machine_is_ginkgo()	(machine_arch_type == MACH_TYPE_GINKGO)
#else
# define machine_is_ginkgo()	(0)
#endif

#ifdef CONFIG_MACH_CGT_QMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CGT_QMX6
# endif
# define machine_is_cgt_qmx6()	(machine_arch_type == MACH_TYPE_CGT_QMX6)
#else
# define machine_is_cgt_qmx6()	(0)
#endif

#ifdef CONFIG_MACH_PROFPGA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROFPGA
# endif
# define machine_is_profpga()	(machine_arch_type == MACH_TYPE_PROFPGA)
#else
# define machine_is_profpga()	(0)
#endif

#ifdef CONFIG_MACH_ACFX100OC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACFX100OC
# endif
# define machine_is_acfx100oc()	(machine_arch_type == MACH_TYPE_ACFX100OC)
#else
# define machine_is_acfx100oc()	(0)
#endif

#ifdef CONFIG_MACH_ACFX100NB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACFX100NB
# endif
# define machine_is_acfx100nb()	(machine_arch_type == MACH_TYPE_ACFX100NB)
#else
# define machine_is_acfx100nb()	(0)
#endif

#ifdef CONFIG_MACH_CAPRICORN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CAPRICORN
# endif
# define machine_is_capricorn()	(machine_arch_type == MACH_TYPE_CAPRICORN)
#else
# define machine_is_capricorn()	(0)
#endif

#ifdef CONFIG_MACH_PISCES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PISCES
# endif
# define machine_is_pisces()	(machine_arch_type == MACH_TYPE_PISCES)
#else
# define machine_is_pisces()	(0)
#endif

#ifdef CONFIG_MACH_ARIES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARIES
# endif
# define machine_is_aries()	(machine_arch_type == MACH_TYPE_ARIES)
#else
# define machine_is_aries()	(0)
#endif

#ifdef CONFIG_MACH_CANCER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CANCER
# endif
# define machine_is_cancer()	(machine_arch_type == MACH_TYPE_CANCER)
#else
# define machine_is_cancer()	(0)
#endif

#ifdef CONFIG_MACH_LEO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LEO
# endif
# define machine_is_leo()	(machine_arch_type == MACH_TYPE_LEO)
#else
# define machine_is_leo()	(0)
#endif

#ifdef CONFIG_MACH_VIRGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VIRGO
# endif
# define machine_is_virgo()	(machine_arch_type == MACH_TYPE_VIRGO)
#else
# define machine_is_virgo()	(0)
#endif

#ifdef CONFIG_MACH_SAGITTARIUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SAGITTARIUS
# endif
# define machine_is_sagittarius()	(machine_arch_type == MACH_TYPE_SAGITTARIUS)
#else
# define machine_is_sagittarius()	(0)
#endif

#ifdef CONFIG_MACH_DEVIL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DEVIL
# endif
# define machine_is_devil()	(machine_arch_type == MACH_TYPE_DEVIL)
#else
# define machine_is_devil()	(0)
#endif

#ifdef CONFIG_MACH_BALLANTINES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BALLANTINES
# endif
# define machine_is_ballantines()	(machine_arch_type == MACH_TYPE_BALLANTINES)
#else
# define machine_is_ballantines()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_PROCERUSVPU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_PROCERUSVPU
# endif
# define machine_is_omap3_procerusvpu()	(machine_arch_type == MACH_TYPE_OMAP3_PROCERUSVPU)
#else
# define machine_is_omap3_procerusvpu()	(0)
#endif

#ifdef CONFIG_MACH_MY27
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MY27
# endif
# define machine_is_my27()	(machine_arch_type == MACH_TYPE_MY27)
#else
# define machine_is_my27()	(0)
#endif

#ifdef CONFIG_MACH_SUN6I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SUN6I
# endif
# define machine_is_sun6i()	(machine_arch_type == MACH_TYPE_SUN6I)
#else
# define machine_is_sun6i()	(0)
#endif

#ifdef CONFIG_MACH_SUN5I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SUN5I
# endif
# define machine_is_sun5i()	(machine_arch_type == MACH_TYPE_SUN5I)
#else
# define machine_is_sun5i()	(0)
#endif

#ifdef CONFIG_MACH_MX512_MX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX512_MX
# endif
# define machine_is_mx512_mx()	(machine_arch_type == MACH_TYPE_MX512_MX)
#else
# define machine_is_mx512_mx()	(0)
#endif

#ifdef CONFIG_MACH_KZM9G
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KZM9G
# endif
# define machine_is_kzm9g()	(machine_arch_type == MACH_TYPE_KZM9G)
#else
# define machine_is_kzm9g()	(0)
#endif

#ifdef CONFIG_MACH_VDSTBN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VDSTBN
# endif
# define machine_is_vdstbn()	(machine_arch_type == MACH_TYPE_VDSTBN)
#else
# define machine_is_vdstbn()	(0)
#endif

#ifdef CONFIG_MACH_CFA10036
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CFA10036
# endif
# define machine_is_cfa10036()	(machine_arch_type == MACH_TYPE_CFA10036)
#else
# define machine_is_cfa10036()	(0)
#endif

#ifdef CONFIG_MACH_CFA10049
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CFA10049
# endif
# define machine_is_cfa10049()	(machine_arch_type == MACH_TYPE_CFA10049)
#else
# define machine_is_cfa10049()	(0)
#endif

#ifdef CONFIG_MACH_PCM051
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM051
# endif
# define machine_is_pcm051()	(machine_arch_type == MACH_TYPE_PCM051)
#else
# define machine_is_pcm051()	(0)
#endif

#ifdef CONFIG_MACH_VYBRID_VF7XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VYBRID_VF7XX
# endif
# define machine_is_vybrid_vf7xx()	(machine_arch_type == MACH_TYPE_VYBRID_VF7XX)
#else
# define machine_is_vybrid_vf7xx()	(0)
#endif

#ifdef CONFIG_MACH_VYBRID_VF6XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VYBRID_VF6XX
# endif
# define machine_is_vybrid_vf6xx()	(machine_arch_type == MACH_TYPE_VYBRID_VF6XX)
#else
# define machine_is_vybrid_vf6xx()	(0)
#endif

#ifdef CONFIG_MACH_VYBRID_VF5XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VYBRID_VF5XX
# endif
# define machine_is_vybrid_vf5xx()	(machine_arch_type == MACH_TYPE_VYBRID_VF5XX)
#else
# define machine_is_vybrid_vf5xx()	(0)
#endif

#ifdef CONFIG_MACH_VYBRID_VF4XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VYBRID_VF4XX
# endif
# define machine_is_vybrid_vf4xx()	(machine_arch_type == MACH_TYPE_VYBRID_VF4XX)
#else
# define machine_is_vybrid_vf4xx()	(0)
#endif

#ifdef CONFIG_MACH_ARIA_G25
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARIA_G25
# endif
# define machine_is_aria_g25()	(machine_arch_type == MACH_TYPE_ARIA_G25)
#else
# define machine_is_aria_g25()	(0)
#endif

#ifdef CONFIG_MACH_BCM21553
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BCM21553
# endif
# define machine_is_bcm21553()	(machine_arch_type == MACH_TYPE_BCM21553)
#else
# define machine_is_bcm21553()	(0)
#endif

#ifdef CONFIG_MACH_SMDK5410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK5410
# endif
# define machine_is_smdk5410()	(machine_arch_type == MACH_TYPE_SMDK5410)
#else
# define machine_is_smdk5410()	(0)
#endif

#ifdef CONFIG_MACH_LPC18XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LPC18XX
# endif
# define machine_is_lpc18xx()	(machine_arch_type == MACH_TYPE_LPC18XX)
#else
# define machine_is_lpc18xx()	(0)
#endif

#ifdef CONFIG_MACH_ORATISPARTY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ORATISPARTY
# endif
# define machine_is_oratisparty()	(machine_arch_type == MACH_TYPE_ORATISPARTY)
#else
# define machine_is_oratisparty()	(0)
#endif

#ifdef CONFIG_MACH_QSEVEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QSEVEN
# endif
# define machine_is_qseven()	(machine_arch_type == MACH_TYPE_QSEVEN)
#else
# define machine_is_qseven()	(0)
#endif

#ifdef CONFIG_MACH_GMV_GENERIC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GMV_GENERIC
# endif
# define machine_is_gmv_generic()	(machine_arch_type == MACH_TYPE_GMV_GENERIC)
#else
# define machine_is_gmv_generic()	(0)
#endif

#ifdef CONFIG_MACH_TH_LINK_ETH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TH_LINK_ETH
# endif
# define machine_is_th_link_eth()	(machine_arch_type == MACH_TYPE_TH_LINK_ETH)
#else
# define machine_is_th_link_eth()	(0)
#endif

#ifdef CONFIG_MACH_TN_MUNINN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TN_MUNINN
# endif
# define machine_is_tn_muninn()	(machine_arch_type == MACH_TYPE_TN_MUNINN)
#else
# define machine_is_tn_muninn()	(0)
#endif

#ifdef CONFIG_MACH_RAMPAGE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RAMPAGE
# endif
# define machine_is_rampage()	(machine_arch_type == MACH_TYPE_RAMPAGE)
#else
# define machine_is_rampage()	(0)
#endif

#ifdef CONFIG_MACH_VISSTRIM_MV10
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VISSTRIM_MV10
# endif
# define machine_is_visstrim_mv10()	(machine_arch_type == MACH_TYPE_VISSTRIM_MV10)
#else
# define machine_is_visstrim_mv10()	(0)
#endif

#ifdef CONFIG_MACH_MX28_WILMA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX28_WILMA
# endif
# define machine_is_mx28_wilma()	(machine_arch_type == MACH_TYPE_MX28_WILMA)
#else
# define machine_is_mx28_wilma()	(0)
#endif

#ifdef CONFIG_MACH_MSM8625_FFA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8625_FFA
# endif
# define machine_is_msm8625_ffa()	(machine_arch_type == MACH_TYPE_MSM8625_FFA)
#else
# define machine_is_msm8625_ffa()	(0)
#endif

#ifdef CONFIG_MACH_VPU101
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VPU101
# endif
# define machine_is_vpu101()	(machine_arch_type == MACH_TYPE_VPU101)
#else
# define machine_is_vpu101()	(0)
#endif

#ifdef CONFIG_MACH_BAILEYS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BAILEYS
# endif
# define machine_is_baileys()	(machine_arch_type == MACH_TYPE_BAILEYS)
#else
# define machine_is_baileys()	(0)
#endif

#ifdef CONFIG_MACH_FAMILYBOX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FAMILYBOX
# endif
# define machine_is_familybox()	(machine_arch_type == MACH_TYPE_FAMILYBOX)
#else
# define machine_is_familybox()	(0)
#endif

#ifdef CONFIG_MACH_ENSEMBLE_MX35
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ENSEMBLE_MX35
# endif
# define machine_is_ensemble_mx35()	(machine_arch_type == MACH_TYPE_ENSEMBLE_MX35)
#else
# define machine_is_ensemble_mx35()	(0)
#endif

#ifdef CONFIG_MACH_SC_SPS_1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SC_SPS_1
# endif
# define machine_is_sc_sps_1()	(machine_arch_type == MACH_TYPE_SC_SPS_1)
#else
# define machine_is_sc_sps_1()	(0)
#endif

#ifdef CONFIG_MACH_UCSIMPLY_SAM9260
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_UCSIMPLY_SAM9260
# endif
# define machine_is_ucsimply_sam9260()	(machine_arch_type == MACH_TYPE_UCSIMPLY_SAM9260)
#else
# define machine_is_ucsimply_sam9260()	(0)
#endif

#ifdef CONFIG_MACH_UNICORN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_UNICORN
# endif
# define machine_is_unicorn()	(machine_arch_type == MACH_TYPE_UNICORN)
#else
# define machine_is_unicorn()	(0)
#endif

#ifdef CONFIG_MACH_M9G45A
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M9G45A
# endif
# define machine_is_m9g45a()	(machine_arch_type == MACH_TYPE_M9G45A)
#else
# define machine_is_m9g45a()	(0)
#endif

#ifdef CONFIG_MACH_MTWEBIF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MTWEBIF
# endif
# define machine_is_mtwebif()	(machine_arch_type == MACH_TYPE_MTWEBIF)
#else
# define machine_is_mtwebif()	(0)
#endif

#ifdef CONFIG_MACH_PLAYSTONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PLAYSTONE
# endif
# define machine_is_playstone()	(machine_arch_type == MACH_TYPE_PLAYSTONE)
#else
# define machine_is_playstone()	(0)
#endif

#ifdef CONFIG_MACH_CHELSEA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CHELSEA
# endif
# define machine_is_chelsea()	(machine_arch_type == MACH_TYPE_CHELSEA)
#else
# define machine_is_chelsea()	(0)
#endif

#ifdef CONFIG_MACH_BAYERN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BAYERN
# endif
# define machine_is_bayern()	(machine_arch_type == MACH_TYPE_BAYERN)
#else
# define machine_is_bayern()	(0)
#endif

#ifdef CONFIG_MACH_MITWO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MITWO
# endif
# define machine_is_mitwo()	(machine_arch_type == MACH_TYPE_MITWO)
#else
# define machine_is_mitwo()	(0)
#endif

#ifdef CONFIG_MACH_MX25_NOAH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX25_NOAH
# endif
# define machine_is_mx25_noah()	(machine_arch_type == MACH_TYPE_MX25_NOAH)
#else
# define machine_is_mx25_noah()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2020
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2020
# endif
# define machine_is_stm_b2020()	(machine_arch_type == MACH_TYPE_STM_B2020)
#else
# define machine_is_stm_b2020()	(0)
#endif

#ifdef CONFIG_MACH_ANNAX_SRC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ANNAX_SRC
# endif
# define machine_is_annax_src()	(machine_arch_type == MACH_TYPE_ANNAX_SRC)
#else
# define machine_is_annax_src()	(0)
#endif

#ifdef CONFIG_MACH_IONICS_STRATUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IONICS_STRATUS
# endif
# define machine_is_ionics_stratus()	(machine_arch_type == MACH_TYPE_IONICS_STRATUS)
#else
# define machine_is_ionics_stratus()	(0)
#endif

#ifdef CONFIG_MACH_HUGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HUGO
# endif
# define machine_is_hugo()	(machine_arch_type == MACH_TYPE_HUGO)
#else
# define machine_is_hugo()	(0)
#endif

#ifdef CONFIG_MACH_EM300
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EM300
# endif
# define machine_is_em300()	(machine_arch_type == MACH_TYPE_EM300)
#else
# define machine_is_em300()	(0)
#endif

#ifdef CONFIG_MACH_MMP3_QSEVEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MMP3_QSEVEN
# endif
# define machine_is_mmp3_qseven()	(machine_arch_type == MACH_TYPE_MMP3_QSEVEN)
#else
# define machine_is_mmp3_qseven()	(0)
#endif

#ifdef CONFIG_MACH_BOSPHORUS2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BOSPHORUS2
# endif
# define machine_is_bosphorus2()	(machine_arch_type == MACH_TYPE_BOSPHORUS2)
#else
# define machine_is_bosphorus2()	(0)
#endif

#ifdef CONFIG_MACH_TT2200
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TT2200
# endif
# define machine_is_tt2200()	(machine_arch_type == MACH_TYPE_TT2200)
#else
# define machine_is_tt2200()	(0)
#endif

#ifdef CONFIG_MACH_OCELOT3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OCELOT3
# endif
# define machine_is_ocelot3()	(machine_arch_type == MACH_TYPE_OCELOT3)
#else
# define machine_is_ocelot3()	(0)
#endif

#ifdef CONFIG_MACH_TEK_COBRA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TEK_COBRA
# endif
# define machine_is_tek_cobra()	(machine_arch_type == MACH_TYPE_TEK_COBRA)
#else
# define machine_is_tek_cobra()	(0)
#endif

#ifdef CONFIG_MACH_PROTOU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROTOU
# endif
# define machine_is_protou()	(machine_arch_type == MACH_TYPE_PROTOU)
#else
# define machine_is_protou()	(0)
#endif

#ifdef CONFIG_MACH_MSM8625_EVT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8625_EVT
# endif
# define machine_is_msm8625_evt()	(machine_arch_type == MACH_TYPE_MSM8625_EVT)
#else
# define machine_is_msm8625_evt()	(0)
#endif

#ifdef CONFIG_MACH_MX53_SELLWOOD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_SELLWOOD
# endif
# define machine_is_mx53_sellwood()	(machine_arch_type == MACH_TYPE_MX53_SELLWOOD)
#else
# define machine_is_mx53_sellwood()	(0)
#endif

#ifdef CONFIG_MACH_SOMIQ_AM35
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SOMIQ_AM35
# endif
# define machine_is_somiq_am35()	(machine_arch_type == MACH_TYPE_SOMIQ_AM35)
#else
# define machine_is_somiq_am35()	(0)
#endif

#ifdef CONFIG_MACH_SOMIQ_AM37
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SOMIQ_AM37
# endif
# define machine_is_somiq_am37()	(machine_arch_type == MACH_TYPE_SOMIQ_AM37)
#else
# define machine_is_somiq_am37()	(0)
#endif

#ifdef CONFIG_MACH_K2_PLC_CL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K2_PLC_CL
# endif
# define machine_is_k2_plc_cl()	(machine_arch_type == MACH_TYPE_K2_PLC_CL)
#else
# define machine_is_k2_plc_cl()	(0)
#endif

#ifdef CONFIG_MACH_TC2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TC2
# endif
# define machine_is_tc2()	(machine_arch_type == MACH_TYPE_TC2)
#else
# define machine_is_tc2()	(0)
#endif

#ifdef CONFIG_MACH_DULEX_J
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DULEX_J
# endif
# define machine_is_dulex_j()	(machine_arch_type == MACH_TYPE_DULEX_J)
#else
# define machine_is_dulex_j()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2044
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2044
# endif
# define machine_is_stm_b2044()	(machine_arch_type == MACH_TYPE_STM_B2044)
#else
# define machine_is_stm_b2044()	(0)
#endif

#ifdef CONFIG_MACH_DELUXE_J
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DELUXE_J
# endif
# define machine_is_deluxe_j()	(machine_arch_type == MACH_TYPE_DELUXE_J)
#else
# define machine_is_deluxe_j()	(0)
#endif

#ifdef CONFIG_MACH_MANGO2443
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MANGO2443
# endif
# define machine_is_mango2443()	(machine_arch_type == MACH_TYPE_MANGO2443)
#else
# define machine_is_mango2443()	(0)
#endif

#ifdef CONFIG_MACH_CP2DCG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CP2DCG
# endif
# define machine_is_cp2dcg()	(machine_arch_type == MACH_TYPE_CP2DCG)
#else
# define machine_is_cp2dcg()	(0)
#endif

#ifdef CONFIG_MACH_CP2DTG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CP2DTG
# endif
# define machine_is_cp2dtg()	(machine_arch_type == MACH_TYPE_CP2DTG)
#else
# define machine_is_cp2dtg()	(0)
#endif

#ifdef CONFIG_MACH_CP2DUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CP2DUG
# endif
# define machine_is_cp2dug()	(machine_arch_type == MACH_TYPE_CP2DUG)
#else
# define machine_is_cp2dug()	(0)
#endif

#ifdef CONFIG_MACH_VAR_SOM_AM33
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VAR_SOM_AM33
# endif
# define machine_is_var_som_am33()	(machine_arch_type == MACH_TYPE_VAR_SOM_AM33)
#else
# define machine_is_var_som_am33()	(0)
#endif

#ifdef CONFIG_MACH_PEPPER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PEPPER
# endif
# define machine_is_pepper()	(machine_arch_type == MACH_TYPE_PEPPER)
#else
# define machine_is_pepper()	(0)
#endif

#ifdef CONFIG_MACH_MANGO2450
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MANGO2450
# endif
# define machine_is_mango2450()	(machine_arch_type == MACH_TYPE_MANGO2450)
#else
# define machine_is_mango2450()	(0)
#endif

#ifdef CONFIG_MACH_VALENTE_WX_C9
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VALENTE_WX_C9
# endif
# define machine_is_valente_wx_c9()	(machine_arch_type == MACH_TYPE_VALENTE_WX_C9)
#else
# define machine_is_valente_wx_c9()	(0)
#endif

#ifdef CONFIG_MACH_MINITV
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MINITV
# endif
# define machine_is_minitv()	(machine_arch_type == MACH_TYPE_MINITV)
#else
# define machine_is_minitv()	(0)
#endif

#ifdef CONFIG_MACH_U8540
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U8540
# endif
# define machine_is_u8540()	(machine_arch_type == MACH_TYPE_U8540)
#else
# define machine_is_u8540()	(0)
#endif

#ifdef CONFIG_MACH_IV_ATLAS_I_Z7E
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IV_ATLAS_I_Z7E
# endif
# define machine_is_iv_atlas_i_z7e()	(machine_arch_type == MACH_TYPE_IV_ATLAS_I_Z7E)
#else
# define machine_is_iv_atlas_i_z7e()	(0)
#endif

#ifdef CONFIG_MACH_MACH_TYPE_SKY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MACH_TYPE_SKY
# endif
# define machine_is_mach_type_sky()	(machine_arch_type == MACH_TYPE_MACH_TYPE_SKY)
#else
# define machine_is_mach_type_sky()	(0)
#endif

#ifdef CONFIG_MACH_BLUESKY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BLUESKY
# endif
# define machine_is_bluesky()	(machine_arch_type == MACH_TYPE_BLUESKY)
#else
# define machine_is_bluesky()	(0)
#endif

#ifdef CONFIG_MACH_NGROUTER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NGROUTER
# endif
# define machine_is_ngrouter()	(machine_arch_type == MACH_TYPE_NGROUTER)
#else
# define machine_is_ngrouter()	(0)
#endif

#ifdef CONFIG_MACH_MX53_DENETIM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_DENETIM
# endif
# define machine_is_mx53_denetim()	(machine_arch_type == MACH_TYPE_MX53_DENETIM)
#else
# define machine_is_mx53_denetim()	(0)
#endif

#ifdef CONFIG_MACH_OPAL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OPAL
# endif
# define machine_is_opal()	(machine_arch_type == MACH_TYPE_OPAL)
#else
# define machine_is_opal()	(0)
#endif

#ifdef CONFIG_MACH_GNET_US3GREF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GNET_US3GREF
# endif
# define machine_is_gnet_us3gref()	(machine_arch_type == MACH_TYPE_GNET_US3GREF)
#else
# define machine_is_gnet_us3gref()	(0)
#endif

#ifdef CONFIG_MACH_GNET_NC3G
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GNET_NC3G
# endif
# define machine_is_gnet_nc3g()	(machine_arch_type == MACH_TYPE_GNET_NC3G)
#else
# define machine_is_gnet_nc3g()	(0)
#endif

#ifdef CONFIG_MACH_GNET_GE3G
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GNET_GE3G
# endif
# define machine_is_gnet_ge3g()	(machine_arch_type == MACH_TYPE_GNET_GE3G)
#else
# define machine_is_gnet_ge3g()	(0)
#endif

#ifdef CONFIG_MACH_ADP2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ADP2
# endif
# define machine_is_adp2()	(machine_arch_type == MACH_TYPE_ADP2)
#else
# define machine_is_adp2()	(0)
#endif

#ifdef CONFIG_MACH_TQMA28
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TQMA28
# endif
# define machine_is_tqma28()	(machine_arch_type == MACH_TYPE_TQMA28)
#else
# define machine_is_tqma28()	(0)
#endif

#ifdef CONFIG_MACH_KACOM3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KACOM3
# endif
# define machine_is_kacom3()	(machine_arch_type == MACH_TYPE_KACOM3)
#else
# define machine_is_kacom3()	(0)
#endif

#ifdef CONFIG_MACH_RRHDEMO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RRHDEMO
# endif
# define machine_is_rrhdemo()	(machine_arch_type == MACH_TYPE_RRHDEMO)
#else
# define machine_is_rrhdemo()	(0)
#endif

#ifdef CONFIG_MACH_PROTODUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROTODUG
# endif
# define machine_is_protodug()	(machine_arch_type == MACH_TYPE_PROTODUG)
#else
# define machine_is_protodug()	(0)
#endif

#ifdef CONFIG_MACH_LAGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LAGO
# endif
# define machine_is_lago()	(machine_arch_type == MACH_TYPE_LAGO)
#else
# define machine_is_lago()	(0)
#endif

#ifdef CONFIG_MACH_KTT30
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KTT30
# endif
# define machine_is_ktt30()	(machine_arch_type == MACH_TYPE_KTT30)
#else
# define machine_is_ktt30()	(0)
#endif

#ifdef CONFIG_MACH_TS43XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TS43XX
# endif
# define machine_is_ts43xx()	(machine_arch_type == MACH_TYPE_TS43XX)
#else
# define machine_is_ts43xx()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_DENSO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_DENSO
# endif
# define machine_is_mx6q_denso()	(machine_arch_type == MACH_TYPE_MX6Q_DENSO)
#else
# define machine_is_mx6q_denso()	(0)
#endif

#ifdef CONFIG_MACH_COMSAT_GSMUMTS8
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COMSAT_GSMUMTS8
# endif
# define machine_is_comsat_gsmumts8()	(machine_arch_type == MACH_TYPE_COMSAT_GSMUMTS8)
#else
# define machine_is_comsat_gsmumts8()	(0)
#endif

#ifdef CONFIG_MACH_DREAMX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DREAMX
# endif
# define machine_is_dreamx()	(machine_arch_type == MACH_TYPE_DREAMX)
#else
# define machine_is_dreamx()	(0)
#endif

#ifdef CONFIG_MACH_THUNDERSTONEM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_THUNDERSTONEM
# endif
# define machine_is_thunderstonem()	(machine_arch_type == MACH_TYPE_THUNDERSTONEM)
#else
# define machine_is_thunderstonem()	(0)
#endif

#ifdef CONFIG_MACH_YOYOPAD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_YOYOPAD
# endif
# define machine_is_yoyopad()	(machine_arch_type == MACH_TYPE_YOYOPAD)
#else
# define machine_is_yoyopad()	(0)
#endif

#ifdef CONFIG_MACH_YOYOPATIENT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_YOYOPATIENT
# endif
# define machine_is_yoyopatient()	(machine_arch_type == MACH_TYPE_YOYOPATIENT)
#else
# define machine_is_yoyopatient()	(0)
#endif

#ifdef CONFIG_MACH_A10L
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_A10L
# endif
# define machine_is_a10l()	(machine_arch_type == MACH_TYPE_A10L)
#else
# define machine_is_a10l()	(0)
#endif

#ifdef CONFIG_MACH_MQ60
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MQ60
# endif
# define machine_is_mq60()	(machine_arch_type == MACH_TYPE_MQ60)
#else
# define machine_is_mq60()	(0)
#endif

#ifdef CONFIG_MACH_LINKSTATION_LSQL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LINKSTATION_LSQL
# endif
# define machine_is_linkstation_lsql()	(machine_arch_type == MACH_TYPE_LINKSTATION_LSQL)
#else
# define machine_is_linkstation_lsql()	(0)
#endif

#ifdef CONFIG_MACH_AM3703GATEWAY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AM3703GATEWAY
# endif
# define machine_is_am3703gateway()	(machine_arch_type == MACH_TYPE_AM3703GATEWAY)
#else
# define machine_is_am3703gateway()	(0)
#endif

#ifdef CONFIG_MACH_ACCIPITER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACCIPITER
# endif
# define machine_is_accipiter()	(machine_arch_type == MACH_TYPE_ACCIPITER)
#else
# define machine_is_accipiter()	(0)
#endif

#ifdef CONFIG_MACH_MAGNIDUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAGNIDUG
# endif
# define machine_is_magnidug()	(machine_arch_type == MACH_TYPE_MAGNIDUG)
#else
# define machine_is_magnidug()	(0)
#endif

#ifdef CONFIG_MACH_HYDRA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HYDRA
# endif
# define machine_is_hydra()	(machine_arch_type == MACH_TYPE_HYDRA)
#else
# define machine_is_hydra()	(0)
#endif

#ifdef CONFIG_MACH_SUN3I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SUN3I
# endif
# define machine_is_sun3i()	(machine_arch_type == MACH_TYPE_SUN3I)
#else
# define machine_is_sun3i()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2078
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2078
# endif
# define machine_is_stm_b2078()	(machine_arch_type == MACH_TYPE_STM_B2078)
#else
# define machine_is_stm_b2078()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9263DESKV2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9263DESKV2
# endif
# define machine_is_at91sam9263deskv2()	(machine_arch_type == MACH_TYPE_AT91SAM9263DESKV2)
#else
# define machine_is_at91sam9263deskv2()	(0)
#endif

#ifdef CONFIG_MACH_DELUXE_R
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DELUXE_R
# endif
# define machine_is_deluxe_r()	(machine_arch_type == MACH_TYPE_DELUXE_R)
#else
# define machine_is_deluxe_r()	(0)
#endif

#ifdef CONFIG_MACH_P_98_V
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_P_98_V
# endif
# define machine_is_p_98_v()	(machine_arch_type == MACH_TYPE_P_98_V)
#else
# define machine_is_p_98_v()	(0)
#endif

#ifdef CONFIG_MACH_P_98_C
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_P_98_C
# endif
# define machine_is_p_98_c()	(machine_arch_type == MACH_TYPE_P_98_C)
#else
# define machine_is_p_98_c()	(0)
#endif

#ifdef CONFIG_MACH_DAVINCI_AM18XX_OMN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAVINCI_AM18XX_OMN
# endif
# define machine_is_davinci_am18xx_omn()	(machine_arch_type == MACH_TYPE_DAVINCI_AM18XX_OMN)
#else
# define machine_is_davinci_am18xx_omn()	(0)
#endif

#ifdef CONFIG_MACH_SOCFPGA_CYCLONE5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SOCFPGA_CYCLONE5
# endif
# define machine_is_socfpga_cyclone5()	(machine_arch_type == MACH_TYPE_SOCFPGA_CYCLONE5)
#else
# define machine_is_socfpga_cyclone5()	(0)
#endif

#ifdef CONFIG_MACH_CABATUIN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CABATUIN
# endif
# define machine_is_cabatuin()	(machine_arch_type == MACH_TYPE_CABATUIN)
#else
# define machine_is_cabatuin()	(0)
#endif

#ifdef CONFIG_MACH_YOYOPAD_FT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_YOYOPAD_FT
# endif
# define machine_is_yoyopad_ft()	(machine_arch_type == MACH_TYPE_YOYOPAD_FT)
#else
# define machine_is_yoyopad_ft()	(0)
#endif

#ifdef CONFIG_MACH_DAN2400EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAN2400EVB
# endif
# define machine_is_dan2400evb()	(machine_arch_type == MACH_TYPE_DAN2400EVB)
#else
# define machine_is_dan2400evb()	(0)
#endif

#ifdef CONFIG_MACH_DAN3400EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DAN3400EVB
# endif
# define machine_is_dan3400evb()	(machine_arch_type == MACH_TYPE_DAN3400EVB)
#else
# define machine_is_dan3400evb()	(0)
#endif

#ifdef CONFIG_MACH_EDM_SF_IMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDM_SF_IMX6
# endif
# define machine_is_edm_sf_imx6()	(machine_arch_type == MACH_TYPE_EDM_SF_IMX6)
#else
# define machine_is_edm_sf_imx6()	(0)
#endif

#ifdef CONFIG_MACH_EDM_CF_IMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EDM_CF_IMX6
# endif
# define machine_is_edm_cf_imx6()	(machine_arch_type == MACH_TYPE_EDM_CF_IMX6)
#else
# define machine_is_edm_cf_imx6()	(0)
#endif

#ifdef CONFIG_MACH_VPOS3XX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VPOS3XX
# endif
# define machine_is_vpos3xx()	(machine_arch_type == MACH_TYPE_VPOS3XX)
#else
# define machine_is_vpos3xx()	(0)
#endif

#ifdef CONFIG_MACH_VULCANO_9X5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VULCANO_9X5
# endif
# define machine_is_vulcano_9x5()	(machine_arch_type == MACH_TYPE_VULCANO_9X5)
#else
# define machine_is_vulcano_9x5()	(0)
#endif

#ifdef CONFIG_MACH_SPMP8000
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPMP8000
# endif
# define machine_is_spmp8000()	(machine_arch_type == MACH_TYPE_SPMP8000)
#else
# define machine_is_spmp8000()	(0)
#endif

#ifdef CONFIG_MACH_CATALINA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CATALINA
# endif
# define machine_is_catalina()	(machine_arch_type == MACH_TYPE_CATALINA)
#else
# define machine_is_catalina()	(0)
#endif

#ifdef CONFIG_MACH_RD88F5181L_FE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RD88F5181L_FE
# endif
# define machine_is_rd88f5181l_fe()	(machine_arch_type == MACH_TYPE_RD88F5181L_FE)
#else
# define machine_is_rd88f5181l_fe()	(0)
#endif

#ifdef CONFIG_MACH_MX535_MX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX535_MX
# endif
# define machine_is_mx535_mx()	(machine_arch_type == MACH_TYPE_MX535_MX)
#else
# define machine_is_mx535_mx()	(0)
#endif

#ifdef CONFIG_MACH_ARMADILLO840
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMADILLO840
# endif
# define machine_is_armadillo840()	(machine_arch_type == MACH_TYPE_ARMADILLO840)
#else
# define machine_is_armadillo840()	(0)
#endif

#ifdef CONFIG_MACH_SPC9000BASEBOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPC9000BASEBOARD
# endif
# define machine_is_spc9000baseboard()	(machine_arch_type == MACH_TYPE_SPC9000BASEBOARD)
#else
# define machine_is_spc9000baseboard()	(0)
#endif

#ifdef CONFIG_MACH_IRIS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IRIS
# endif
# define machine_is_iris()	(machine_arch_type == MACH_TYPE_IRIS)
#else
# define machine_is_iris()	(0)
#endif

#ifdef CONFIG_MACH_PROTODCG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROTODCG
# endif
# define machine_is_protodcg()	(machine_arch_type == MACH_TYPE_PROTODCG)
#else
# define machine_is_protodcg()	(0)
#endif

#ifdef CONFIG_MACH_PALMTREE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PALMTREE
# endif
# define machine_is_palmtree()	(machine_arch_type == MACH_TYPE_PALMTREE)
#else
# define machine_is_palmtree()	(0)
#endif

#ifdef CONFIG_MACH_NOVENA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOVENA
# endif
# define machine_is_novena()	(machine_arch_type == MACH_TYPE_NOVENA)
#else
# define machine_is_novena()	(0)
#endif

#ifdef CONFIG_MACH_MA_UM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MA_UM
# endif
# define machine_is_ma_um()	(machine_arch_type == MACH_TYPE_MA_UM)
#else
# define machine_is_ma_um()	(0)
#endif

#ifdef CONFIG_MACH_MA_AM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MA_AM
# endif
# define machine_is_ma_am()	(machine_arch_type == MACH_TYPE_MA_AM)
#else
# define machine_is_ma_am()	(0)
#endif

#ifdef CONFIG_MACH_EMS348
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EMS348
# endif
# define machine_is_ems348()	(machine_arch_type == MACH_TYPE_EMS348)
#else
# define machine_is_ems348()	(0)
#endif

#ifdef CONFIG_MACH_CM_FX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CM_FX6
# endif
# define machine_is_cm_fx6()	(machine_arch_type == MACH_TYPE_CM_FX6)
#else
# define machine_is_cm_fx6()	(0)
#endif

#ifdef CONFIG_MACH_ARNDALE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARNDALE
# endif
# define machine_is_arndale()	(machine_arch_type == MACH_TYPE_ARNDALE)
#else
# define machine_is_arndale()	(0)
#endif

#ifdef CONFIG_MACH_Q5XR5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_Q5XR5
# endif
# define machine_is_q5xr5()	(machine_arch_type == MACH_TYPE_Q5XR5)
#else
# define machine_is_q5xr5()	(0)
#endif

#ifdef CONFIG_MACH_WILLOW
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WILLOW
# endif
# define machine_is_willow()	(machine_arch_type == MACH_TYPE_WILLOW)
#else
# define machine_is_willow()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3621_ODYV3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3621_ODYV3
# endif
# define machine_is_omap3621_odyv3()	(machine_arch_type == MACH_TYPE_OMAP3621_ODYV3)
#else
# define machine_is_omap3621_odyv3()	(0)
#endif

#ifdef CONFIG_MACH_OMAPL138_PRESONUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAPL138_PRESONUS
# endif
# define machine_is_omapl138_presonus()	(machine_arch_type == MACH_TYPE_OMAPL138_PRESONUS)
#else
# define machine_is_omapl138_presonus()	(0)
#endif

#ifdef CONFIG_MACH_DVF99
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DVF99
# endif
# define machine_is_dvf99()	(machine_arch_type == MACH_TYPE_DVF99)
#else
# define machine_is_dvf99()	(0)
#endif

#ifdef CONFIG_MACH_IMPRESSION_J
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IMPRESSION_J
# endif
# define machine_is_impression_j()	(machine_arch_type == MACH_TYPE_IMPRESSION_J)
#else
# define machine_is_impression_j()	(0)
#endif

#ifdef CONFIG_MACH_QBLISSA9
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QBLISSA9
# endif
# define machine_is_qblissa9()	(machine_arch_type == MACH_TYPE_QBLISSA9)
#else
# define machine_is_qblissa9()	(0)
#endif

#ifdef CONFIG_MACH_ROBIN_HELIVIEW10
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ROBIN_HELIVIEW10
# endif
# define machine_is_robin_heliview10()	(machine_arch_type == MACH_TYPE_ROBIN_HELIVIEW10)
#else
# define machine_is_robin_heliview10()	(0)
#endif

#ifdef CONFIG_MACH_SUN7I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SUN7I
# endif
# define machine_is_sun7i()	(machine_arch_type == MACH_TYPE_SUN7I)
#else
# define machine_is_sun7i()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_HDMIDONGLE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_HDMIDONGLE
# endif
# define machine_is_mx6q_hdmidongle()	(machine_arch_type == MACH_TYPE_MX6Q_HDMIDONGLE)
#else
# define machine_is_mx6q_hdmidongle()	(0)
#endif

#ifdef CONFIG_MACH_MX6_SID2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_SID2
# endif
# define machine_is_mx6_sid2()	(machine_arch_type == MACH_TYPE_MX6_SID2)
#else
# define machine_is_mx6_sid2()	(0)
#endif

#ifdef CONFIG_MACH_HELIOS_V3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HELIOS_V3
# endif
# define machine_is_helios_v3()	(machine_arch_type == MACH_TYPE_HELIOS_V3)
#else
# define machine_is_helios_v3()	(0)
#endif

#ifdef CONFIG_MACH_HELIOS_V4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HELIOS_V4
# endif
# define machine_is_helios_v4()	(machine_arch_type == MACH_TYPE_HELIOS_V4)
#else
# define machine_is_helios_v4()	(0)
#endif

#ifdef CONFIG_MACH_Q7_IMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_Q7_IMX6
# endif
# define machine_is_q7_imx6()	(machine_arch_type == MACH_TYPE_Q7_IMX6)
#else
# define machine_is_q7_imx6()	(0)
#endif

#ifdef CONFIG_MACH_ODROIDX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ODROIDX
# endif
# define machine_is_odroidx()	(machine_arch_type == MACH_TYPE_ODROIDX)
#else
# define machine_is_odroidx()	(0)
#endif

#ifdef CONFIG_MACH_ROBPRO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ROBPRO
# endif
# define machine_is_robpro()	(machine_arch_type == MACH_TYPE_ROBPRO)
#else
# define machine_is_robpro()	(0)
#endif

#ifdef CONFIG_MACH_RESEARCH59IF_MK1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RESEARCH59IF_MK1
# endif
# define machine_is_research59if_mk1()	(machine_arch_type == MACH_TYPE_RESEARCH59IF_MK1)
#else
# define machine_is_research59if_mk1()	(0)
#endif

#ifdef CONFIG_MACH_BOBSLEIGH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BOBSLEIGH
# endif
# define machine_is_bobsleigh()	(machine_arch_type == MACH_TYPE_BOBSLEIGH)
#else
# define machine_is_bobsleigh()	(0)
#endif

#ifdef CONFIG_MACH_DCSHGWT3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DCSHGWT3
# endif
# define machine_is_dcshgwt3()	(machine_arch_type == MACH_TYPE_DCSHGWT3)
#else
# define machine_is_dcshgwt3()	(0)
#endif

#ifdef CONFIG_MACH_GLD1018
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GLD1018
# endif
# define machine_is_gld1018()	(machine_arch_type == MACH_TYPE_GLD1018)
#else
# define machine_is_gld1018()	(0)
#endif

#ifdef CONFIG_MACH_EV10
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EV10
# endif
# define machine_is_ev10()	(machine_arch_type == MACH_TYPE_EV10)
#else
# define machine_is_ev10()	(0)
#endif

#ifdef CONFIG_MACH_NITROGEN6X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NITROGEN6X
# endif
# define machine_is_nitrogen6x()	(machine_arch_type == MACH_TYPE_NITROGEN6X)
#else
# define machine_is_nitrogen6x()	(0)
#endif

#ifdef CONFIG_MACH_P_107_BB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_P_107_BB
# endif
# define machine_is_p_107_bb()	(machine_arch_type == MACH_TYPE_P_107_BB)
#else
# define machine_is_p_107_bb()	(0)
#endif

#ifdef CONFIG_MACH_EVITA_UTL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EVITA_UTL
# endif
# define machine_is_evita_utl()	(machine_arch_type == MACH_TYPE_EVITA_UTL)
#else
# define machine_is_evita_utl()	(0)
#endif

#ifdef CONFIG_MACH_FALCONWING
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FALCONWING
# endif
# define machine_is_falconwing()	(machine_arch_type == MACH_TYPE_FALCONWING)
#else
# define machine_is_falconwing()	(0)
#endif

#ifdef CONFIG_MACH_DCT3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DCT3
# endif
# define machine_is_dct3()	(machine_arch_type == MACH_TYPE_DCT3)
#else
# define machine_is_dct3()	(0)
#endif

#ifdef CONFIG_MACH_CPX2E_CELL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CPX2E_CELL
# endif
# define machine_is_cpx2e_cell()	(machine_arch_type == MACH_TYPE_CPX2E_CELL)
#else
# define machine_is_cpx2e_cell()	(0)
#endif

#ifdef CONFIG_MACH_AMIRO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AMIRO
# endif
# define machine_is_amiro()	(machine_arch_type == MACH_TYPE_AMIRO)
#else
# define machine_is_amiro()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_BRASSBOARD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_BRASSBOARD
# endif
# define machine_is_mx6q_brassboard()	(machine_arch_type == MACH_TYPE_MX6Q_BRASSBOARD)
#else
# define machine_is_mx6q_brassboard()	(0)
#endif

#ifdef CONFIG_MACH_DALMORE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DALMORE
# endif
# define machine_is_dalmore()	(machine_arch_type == MACH_TYPE_DALMORE)
#else
# define machine_is_dalmore()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_PORTAL7CP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_PORTAL7CP
# endif
# define machine_is_omap3_portal7cp()	(machine_arch_type == MACH_TYPE_OMAP3_PORTAL7CP)
#else
# define machine_is_omap3_portal7cp()	(0)
#endif

#ifdef CONFIG_MACH_TEGRA_PLUTO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TEGRA_PLUTO
# endif
# define machine_is_tegra_pluto()	(machine_arch_type == MACH_TYPE_TEGRA_PLUTO)
#else
# define machine_is_tegra_pluto()	(0)
#endif

#ifdef CONFIG_MACH_MX6SL_EVK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6SL_EVK
# endif
# define machine_is_mx6sl_evk()	(machine_arch_type == MACH_TYPE_MX6SL_EVK)
#else
# define machine_is_mx6sl_evk()	(0)
#endif

#ifdef CONFIG_MACH_M7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7
# endif
# define machine_is_m7()	(machine_arch_type == MACH_TYPE_M7)
#else
# define machine_is_m7()	(0)
#endif

#ifdef CONFIG_MACH_PXM2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PXM2
# endif
# define machine_is_pxm2()	(machine_arch_type == MACH_TYPE_PXM2)
#else
# define machine_is_pxm2()	(0)
#endif

#ifdef CONFIG_MACH_HABA_KNX_LITE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HABA_KNX_LITE
# endif
# define machine_is_haba_knx_lite()	(machine_arch_type == MACH_TYPE_HABA_KNX_LITE)
#else
# define machine_is_haba_knx_lite()	(0)
#endif

#ifdef CONFIG_MACH_TAI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TAI
# endif
# define machine_is_tai()	(machine_arch_type == MACH_TYPE_TAI)
#else
# define machine_is_tai()	(0)
#endif

#ifdef CONFIG_MACH_PROTOTD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROTOTD
# endif
# define machine_is_prototd()	(machine_arch_type == MACH_TYPE_PROTOTD)
#else
# define machine_is_prototd()	(0)
#endif

#ifdef CONFIG_MACH_DST_TONTO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DST_TONTO
# endif
# define machine_is_dst_tonto()	(machine_arch_type == MACH_TYPE_DST_TONTO)
#else
# define machine_is_dst_tonto()	(0)
#endif

#ifdef CONFIG_MACH_DRACO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DRACO
# endif
# define machine_is_draco()	(machine_arch_type == MACH_TYPE_DRACO)
#else
# define machine_is_draco()	(0)
#endif

#ifdef CONFIG_MACH_DXR2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DXR2
# endif
# define machine_is_dxr2()	(machine_arch_type == MACH_TYPE_DXR2)
#else
# define machine_is_dxr2()	(0)
#endif

#ifdef CONFIG_MACH_RUT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RUT
# endif
# define machine_is_rut()	(machine_arch_type == MACH_TYPE_RUT)
#else
# define machine_is_rut()	(0)
#endif

#ifdef CONFIG_MACH_AM180X_WSC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AM180X_WSC
# endif
# define machine_is_am180x_wsc()	(machine_arch_type == MACH_TYPE_AM180X_WSC)
#else
# define machine_is_am180x_wsc()	(0)
#endif

#ifdef CONFIG_MACH_DELUXE_U
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DELUXE_U
# endif
# define machine_is_deluxe_u()	(machine_arch_type == MACH_TYPE_DELUXE_U)
#else
# define machine_is_deluxe_u()	(0)
#endif

#ifdef CONFIG_MACH_DELUXE_UL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DELUXE_UL
# endif
# define machine_is_deluxe_ul()	(machine_arch_type == MACH_TYPE_DELUXE_UL)
#else
# define machine_is_deluxe_ul()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9260MEDTHS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9260MEDTHS
# endif
# define machine_is_at91sam9260medths()	(machine_arch_type == MACH_TYPE_AT91SAM9260MEDTHS)
#else
# define machine_is_at91sam9260medths()	(0)
#endif

#ifdef CONFIG_MACH_MATRIX516
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MATRIX516
# endif
# define machine_is_matrix516()	(machine_arch_type == MACH_TYPE_MATRIX516)
#else
# define machine_is_matrix516()	(0)
#endif

#ifdef CONFIG_MACH_VID401X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VID401X
# endif
# define machine_is_vid401x()	(machine_arch_type == MACH_TYPE_VID401X)
#else
# define machine_is_vid401x()	(0)
#endif

#ifdef CONFIG_MACH_HELIOS_V5
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HELIOS_V5
# endif
# define machine_is_helios_v5()	(machine_arch_type == MACH_TYPE_HELIOS_V5)
#else
# define machine_is_helios_v5()	(0)
#endif

#ifdef CONFIG_MACH_PLAYPAQ2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PLAYPAQ2
# endif
# define machine_is_playpaq2()	(machine_arch_type == MACH_TYPE_PLAYPAQ2)
#else
# define machine_is_playpaq2()	(0)
#endif

#ifdef CONFIG_MACH_IGAM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IGAM
# endif
# define machine_is_igam()	(machine_arch_type == MACH_TYPE_IGAM)
#else
# define machine_is_igam()	(0)
#endif

#ifdef CONFIG_MACH_AMICO_I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AMICO_I
# endif
# define machine_is_amico_i()	(machine_arch_type == MACH_TYPE_AMICO_I)
#else
# define machine_is_amico_i()	(0)
#endif

#ifdef CONFIG_MACH_AMICO_E
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AMICO_E
# endif
# define machine_is_amico_e()	(machine_arch_type == MACH_TYPE_AMICO_E)
#else
# define machine_is_amico_e()	(0)
#endif

#ifdef CONFIG_MACH_SENTIENT_MM3_CK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SENTIENT_MM3_CK
# endif
# define machine_is_sentient_mm3_ck()	(machine_arch_type == MACH_TYPE_SENTIENT_MM3_CK)
#else
# define machine_is_sentient_mm3_ck()	(0)
#endif

#ifdef CONFIG_MACH_SMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMX6
# endif
# define machine_is_smx6()	(machine_arch_type == MACH_TYPE_SMX6)
#else
# define machine_is_smx6()	(0)
#endif

#ifdef CONFIG_MACH_PANGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PANGO
# endif
# define machine_is_pango()	(machine_arch_type == MACH_TYPE_PANGO)
#else
# define machine_is_pango()	(0)
#endif

#ifdef CONFIG_MACH_NS115_STICK
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NS115_STICK
# endif
# define machine_is_ns115_stick()	(machine_arch_type == MACH_TYPE_NS115_STICK)
#else
# define machine_is_ns115_stick()	(0)
#endif

#ifdef CONFIG_MACH_BCTRM3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BCTRM3
# endif
# define machine_is_bctrm3()	(machine_arch_type == MACH_TYPE_BCTRM3)
#else
# define machine_is_bctrm3()	(0)
#endif

#ifdef CONFIG_MACH_DOCTORWS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DOCTORWS
# endif
# define machine_is_doctorws()	(machine_arch_type == MACH_TYPE_DOCTORWS)
#else
# define machine_is_doctorws()	(0)
#endif

#ifdef CONFIG_MACH_M2601
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M2601
# endif
# define machine_is_m2601()	(machine_arch_type == MACH_TYPE_M2601)
#else
# define machine_is_m2601()	(0)
#endif

#ifdef CONFIG_MACH_VGG1111
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VGG1111
# endif
# define machine_is_vgg1111()	(machine_arch_type == MACH_TYPE_VGG1111)
#else
# define machine_is_vgg1111()	(0)
#endif

#ifdef CONFIG_MACH_COUNTACH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COUNTACH
# endif
# define machine_is_countach()	(machine_arch_type == MACH_TYPE_COUNTACH)
#else
# define machine_is_countach()	(0)
#endif

#ifdef CONFIG_MACH_VISSTRIM_SM20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VISSTRIM_SM20
# endif
# define machine_is_visstrim_sm20()	(machine_arch_type == MACH_TYPE_VISSTRIM_SM20)
#else
# define machine_is_visstrim_sm20()	(0)
#endif

#ifdef CONFIG_MACH_A639
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_A639
# endif
# define machine_is_a639()	(machine_arch_type == MACH_TYPE_A639)
#else
# define machine_is_a639()	(0)
#endif

#ifdef CONFIG_MACH_SPACEMONKEY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SPACEMONKEY
# endif
# define machine_is_spacemonkey()	(machine_arch_type == MACH_TYPE_SPACEMONKEY)
#else
# define machine_is_spacemonkey()	(0)
#endif

#ifdef CONFIG_MACH_ZPDU_STAMP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ZPDU_STAMP
# endif
# define machine_is_zpdu_stamp()	(machine_arch_type == MACH_TYPE_ZPDU_STAMP)
#else
# define machine_is_zpdu_stamp()	(0)
#endif

#ifdef CONFIG_MACH_HTC_G7_CLONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HTC_G7_CLONE
# endif
# define machine_is_htc_g7_clone()	(machine_arch_type == MACH_TYPE_HTC_G7_CLONE)
#else
# define machine_is_htc_g7_clone()	(0)
#endif

#ifdef CONFIG_MACH_FT2080_CORVUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FT2080_CORVUS
# endif
# define machine_is_ft2080_corvus()	(machine_arch_type == MACH_TYPE_FT2080_CORVUS)
#else
# define machine_is_ft2080_corvus()	(0)
#endif

#ifdef CONFIG_MACH_FISLAND
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FISLAND
# endif
# define machine_is_fisland()	(machine_arch_type == MACH_TYPE_FISLAND)
#else
# define machine_is_fisland()	(0)
#endif

#ifdef CONFIG_MACH_ZPDU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ZPDU
# endif
# define machine_is_zpdu()	(machine_arch_type == MACH_TYPE_ZPDU)
#else
# define machine_is_zpdu()	(0)
#endif

#ifdef CONFIG_MACH_URT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_URT
# endif
# define machine_is_urt()	(machine_arch_type == MACH_TYPE_URT)
#else
# define machine_is_urt()	(0)
#endif

#ifdef CONFIG_MACH_CONTI_OVIP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CONTI_OVIP
# endif
# define machine_is_conti_ovip()	(machine_arch_type == MACH_TYPE_CONTI_OVIP)
#else
# define machine_is_conti_ovip()	(0)
#endif

#ifdef CONFIG_MACH_OMAPL138_NAGRA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAPL138_NAGRA
# endif
# define machine_is_omapl138_nagra()	(machine_arch_type == MACH_TYPE_OMAPL138_NAGRA)
#else
# define machine_is_omapl138_nagra()	(0)
#endif

#ifdef CONFIG_MACH_DA850_AT3KP1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DA850_AT3KP1
# endif
# define machine_is_da850_at3kp1()	(machine_arch_type == MACH_TYPE_DA850_AT3KP1)
#else
# define machine_is_da850_at3kp1()	(0)
#endif

#ifdef CONFIG_MACH_DA850_AT3KP2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DA850_AT3KP2
# endif
# define machine_is_da850_at3kp2()	(machine_arch_type == MACH_TYPE_DA850_AT3KP2)
#else
# define machine_is_da850_at3kp2()	(0)
#endif

#ifdef CONFIG_MACH_SURMA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SURMA
# endif
# define machine_is_surma()	(machine_arch_type == MACH_TYPE_SURMA)
#else
# define machine_is_surma()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2092
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2092
# endif
# define machine_is_stm_b2092()	(machine_arch_type == MACH_TYPE_STM_B2092)
#else
# define machine_is_stm_b2092()	(0)
#endif

#ifdef CONFIG_MACH_MX535_YCR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX535_YCR
# endif
# define machine_is_mx535_ycr()	(machine_arch_type == MACH_TYPE_MX535_YCR)
#else
# define machine_is_mx535_ycr()	(0)
#endif

#ifdef CONFIG_MACH_M7_WL
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7_WL
# endif
# define machine_is_m7_wl()	(machine_arch_type == MACH_TYPE_M7_WL)
#else
# define machine_is_m7_wl()	(0)
#endif

#ifdef CONFIG_MACH_M7_U
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7_U
# endif
# define machine_is_m7_u()	(machine_arch_type == MACH_TYPE_M7_U)
#else
# define machine_is_m7_u()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_STNDT_EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_STNDT_EVM
# endif
# define machine_is_omap3_stndt_evm()	(machine_arch_type == MACH_TYPE_OMAP3_STNDT_EVM)
#else
# define machine_is_omap3_stndt_evm()	(0)
#endif

#ifdef CONFIG_MACH_M7_WLV
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7_WLV
# endif
# define machine_is_m7_wlv()	(machine_arch_type == MACH_TYPE_M7_WLV)
#else
# define machine_is_m7_wlv()	(0)
#endif

#ifdef CONFIG_MACH_XAM3517
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_XAM3517
# endif
# define machine_is_xam3517()	(machine_arch_type == MACH_TYPE_XAM3517)
#else
# define machine_is_xam3517()	(0)
#endif

#ifdef CONFIG_MACH_A220
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_A220
# endif
# define machine_is_a220()	(machine_arch_type == MACH_TYPE_A220)
#else
# define machine_is_a220()	(0)
#endif

#ifdef CONFIG_MACH_ACLIMA_ODIE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACLIMA_ODIE
# endif
# define machine_is_aclima_odie()	(machine_arch_type == MACH_TYPE_ACLIMA_ODIE)
#else
# define machine_is_aclima_odie()	(0)
#endif

#ifdef CONFIG_MACH_VIBBLE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VIBBLE
# endif
# define machine_is_vibble()	(machine_arch_type == MACH_TYPE_VIBBLE)
#else
# define machine_is_vibble()	(0)
#endif

#ifdef CONFIG_MACH_K2_U
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_K2_U
# endif
# define machine_is_k2_u()	(machine_arch_type == MACH_TYPE_K2_U)
#else
# define machine_is_k2_u()	(0)
#endif

#ifdef CONFIG_MACH_MX53_EGF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_EGF
# endif
# define machine_is_mx53_egf()	(machine_arch_type == MACH_TYPE_MX53_EGF)
#else
# define machine_is_mx53_egf()	(0)
#endif

#ifdef CONFIG_MACH_NOVPEK_IMX53
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOVPEK_IMX53
# endif
# define machine_is_novpek_imx53()	(machine_arch_type == MACH_TYPE_NOVPEK_IMX53)
#else
# define machine_is_novpek_imx53()	(0)
#endif

#ifdef CONFIG_MACH_NOVPEK_IMX6X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NOVPEK_IMX6X
# endif
# define machine_is_novpek_imx6x()	(machine_arch_type == MACH_TYPE_NOVPEK_IMX6X)
#else
# define machine_is_novpek_imx6x()	(0)
#endif

#ifdef CONFIG_MACH_MX25_SMARTBOX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX25_SMARTBOX
# endif
# define machine_is_mx25_smartbox()	(machine_arch_type == MACH_TYPE_MX25_SMARTBOX)
#else
# define machine_is_mx25_smartbox()	(0)
#endif

#ifdef CONFIG_MACH_EICG6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EICG6410
# endif
# define machine_is_eicg6410()	(machine_arch_type == MACH_TYPE_EICG6410)
#else
# define machine_is_eicg6410()	(0)
#endif

#ifdef CONFIG_MACH_PICASSO_E3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PICASSO_E3
# endif
# define machine_is_picasso_e3()	(machine_arch_type == MACH_TYPE_PICASSO_E3)
#else
# define machine_is_picasso_e3()	(0)
#endif

#ifdef CONFIG_MACH_MOTONAVIGATOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MOTONAVIGATOR
# endif
# define machine_is_motonavigator()	(machine_arch_type == MACH_TYPE_MOTONAVIGATOR)
#else
# define machine_is_motonavigator()	(0)
#endif

#ifdef CONFIG_MACH_VARIOCONNECT2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VARIOCONNECT2
# endif
# define machine_is_varioconnect2()	(machine_arch_type == MACH_TYPE_VARIOCONNECT2)
#else
# define machine_is_varioconnect2()	(0)
#endif

#ifdef CONFIG_MACH_DELUXE_TW
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DELUXE_TW
# endif
# define machine_is_deluxe_tw()	(machine_arch_type == MACH_TYPE_DELUXE_TW)
#else
# define machine_is_deluxe_tw()	(0)
#endif

#ifdef CONFIG_MACH_KORE3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KORE3
# endif
# define machine_is_kore3()	(machine_arch_type == MACH_TYPE_KORE3)
#else
# define machine_is_kore3()	(0)
#endif

#ifdef CONFIG_MACH_MX6S_DRS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6S_DRS
# endif
# define machine_is_mx6s_drs()	(machine_arch_type == MACH_TYPE_MX6S_DRS)
#else
# define machine_is_mx6s_drs()	(0)
#endif

#ifdef CONFIG_MACH_CMIMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CMIMX6
# endif
# define machine_is_cmimx6()	(machine_arch_type == MACH_TYPE_CMIMX6)
#else
# define machine_is_cmimx6()	(0)
#endif

#ifdef CONFIG_MACH_ROTH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ROTH
# endif
# define machine_is_roth()	(machine_arch_type == MACH_TYPE_ROTH)
#else
# define machine_is_roth()	(0)
#endif

#ifdef CONFIG_MACH_EQ4UX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EQ4UX
# endif
# define machine_is_eq4ux()	(machine_arch_type == MACH_TYPE_EQ4UX)
#else
# define machine_is_eq4ux()	(0)
#endif

#ifdef CONFIG_MACH_X1PLUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_X1PLUS
# endif
# define machine_is_x1plus()	(machine_arch_type == MACH_TYPE_X1PLUS)
#else
# define machine_is_x1plus()	(0)
#endif

#ifdef CONFIG_MACH_MODIMX27
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MODIMX27
# endif
# define machine_is_modimx27()	(machine_arch_type == MACH_TYPE_MODIMX27)
#else
# define machine_is_modimx27()	(0)
#endif

#ifdef CONFIG_MACH_VIDEON_HDUAC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VIDEON_HDUAC
# endif
# define machine_is_videon_hduac()	(machine_arch_type == MACH_TYPE_VIDEON_HDUAC)
#else
# define machine_is_videon_hduac()	(0)
#endif

#ifdef CONFIG_MACH_BLACKBIRD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BLACKBIRD
# endif
# define machine_is_blackbird()	(machine_arch_type == MACH_TYPE_BLACKBIRD)
#else
# define machine_is_blackbird()	(0)
#endif

#ifdef CONFIG_MACH_RUNMASTER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RUNMASTER
# endif
# define machine_is_runmaster()	(machine_arch_type == MACH_TYPE_RUNMASTER)
#else
# define machine_is_runmaster()	(0)
#endif

#ifdef CONFIG_MACH_CERES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CERES
# endif
# define machine_is_ceres()	(machine_arch_type == MACH_TYPE_CERES)
#else
# define machine_is_ceres()	(0)
#endif

#ifdef CONFIG_MACH_NAD435
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NAD435
# endif
# define machine_is_nad435()	(machine_arch_type == MACH_TYPE_NAD435)
#else
# define machine_is_nad435()	(0)
#endif

#ifdef CONFIG_MACH_NS115_PROTO_TYPE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NS115_PROTO_TYPE
# endif
# define machine_is_ns115_proto_type()	(machine_arch_type == MACH_TYPE_NS115_PROTO_TYPE)
#else
# define machine_is_ns115_proto_type()	(0)
#endif

#ifdef CONFIG_MACH_FS20_VCC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FS20_VCC
# endif
# define machine_is_fs20_vcc()	(machine_arch_type == MACH_TYPE_FS20_VCC)
#else
# define machine_is_fs20_vcc()	(0)
#endif

#ifdef CONFIG_MACH_MESON6TV_SKT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MESON6TV_SKT
# endif
# define machine_is_meson6tv_skt()	(machine_arch_type == MACH_TYPE_MESON6TV_SKT)
#else
# define machine_is_meson6tv_skt()	(0)
#endif

#ifdef CONFIG_MACH_KEYSTONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KEYSTONE
# endif
# define machine_is_keystone()	(machine_arch_type == MACH_TYPE_KEYSTONE)
#else
# define machine_is_keystone()	(0)
#endif

#ifdef CONFIG_MACH_PCM052
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM052
# endif
# define machine_is_pcm052()	(machine_arch_type == MACH_TYPE_PCM052)
#else
# define machine_is_pcm052()	(0)
#endif

#ifdef CONFIG_MACH_QRD_SKUD_PRIME
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QRD_SKUD_PRIME
# endif
# define machine_is_qrd_skud_prime()	(machine_arch_type == MACH_TYPE_QRD_SKUD_PRIME)
#else
# define machine_is_qrd_skud_prime()	(0)
#endif

#ifdef CONFIG_MACH_GUF_SANTARO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GUF_SANTARO
# endif
# define machine_is_guf_santaro()	(machine_arch_type == MACH_TYPE_GUF_SANTARO)
#else
# define machine_is_guf_santaro()	(0)
#endif

#ifdef CONFIG_MACH_SHEEPSHEAD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SHEEPSHEAD
# endif
# define machine_is_sheepshead()	(machine_arch_type == MACH_TYPE_SHEEPSHEAD)
#else
# define machine_is_sheepshead()	(0)
#endif

#ifdef CONFIG_MACH_MX6_IWG15M_MXM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_IWG15M_MXM
# endif
# define machine_is_mx6_iwg15m_mxm()	(machine_arch_type == MACH_TYPE_MX6_IWG15M_MXM)
#else
# define machine_is_mx6_iwg15m_mxm()	(0)
#endif

#ifdef CONFIG_MACH_MX6_IWG15M_Q7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_IWG15M_Q7
# endif
# define machine_is_mx6_iwg15m_q7()	(machine_arch_type == MACH_TYPE_MX6_IWG15M_Q7)
#else
# define machine_is_mx6_iwg15m_q7()	(0)
#endif

#ifdef CONFIG_MACH_AT91SAM9263IF8MIC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AT91SAM9263IF8MIC
# endif
# define machine_is_at91sam9263if8mic()	(machine_arch_type == MACH_TYPE_AT91SAM9263IF8MIC)
#else
# define machine_is_at91sam9263if8mic()	(0)
#endif

#ifdef CONFIG_MACH_MARCOPOLO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MARCOPOLO
# endif
# define machine_is_marcopolo()	(machine_arch_type == MACH_TYPE_MARCOPOLO)
#else
# define machine_is_marcopolo()	(0)
#endif

#ifdef CONFIG_MACH_MX535_SDCR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX535_SDCR
# endif
# define machine_is_mx535_sdcr()	(machine_arch_type == MACH_TYPE_MX535_SDCR)
#else
# define machine_is_mx535_sdcr()	(0)
#endif

#ifdef CONFIG_MACH_MX53_CSB2733
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX53_CSB2733
# endif
# define machine_is_mx53_csb2733()	(machine_arch_type == MACH_TYPE_MX53_CSB2733)
#else
# define machine_is_mx53_csb2733()	(0)
#endif

#ifdef CONFIG_MACH_DIVA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DIVA
# endif
# define machine_is_diva()	(machine_arch_type == MACH_TYPE_DIVA)
#else
# define machine_is_diva()	(0)
#endif

#ifdef CONFIG_MACH_NCR_7744
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NCR_7744
# endif
# define machine_is_ncr_7744()	(machine_arch_type == MACH_TYPE_NCR_7744)
#else
# define machine_is_ncr_7744()	(0)
#endif

#ifdef CONFIG_MACH_MACALLAN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MACALLAN
# endif
# define machine_is_macallan()	(machine_arch_type == MACH_TYPE_MACALLAN)
#else
# define machine_is_macallan()	(0)
#endif

#ifdef CONFIG_MACH_WNR3500
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WNR3500
# endif
# define machine_is_wnr3500()	(machine_arch_type == MACH_TYPE_WNR3500)
#else
# define machine_is_wnr3500()	(0)
#endif

#ifdef CONFIG_MACH_PGAVRF
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PGAVRF
# endif
# define machine_is_pgavrf()	(machine_arch_type == MACH_TYPE_PGAVRF)
#else
# define machine_is_pgavrf()	(0)
#endif

#ifdef CONFIG_MACH_HELIOS_V6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HELIOS_V6
# endif
# define machine_is_helios_v6()	(machine_arch_type == MACH_TYPE_HELIOS_V6)
#else
# define machine_is_helios_v6()	(0)
#endif

#ifdef CONFIG_MACH_LCCT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LCCT
# endif
# define machine_is_lcct()	(machine_arch_type == MACH_TYPE_LCCT)
#else
# define machine_is_lcct()	(0)
#endif

#ifdef CONFIG_MACH_CSNDUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CSNDUG
# endif
# define machine_is_csndug()	(machine_arch_type == MACH_TYPE_CSNDUG)
#else
# define machine_is_csndug()	(0)
#endif

#ifdef CONFIG_MACH_WANDBOARD_IMX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WANDBOARD_IMX6
# endif
# define machine_is_wandboard_imx6()	(machine_arch_type == MACH_TYPE_WANDBOARD_IMX6)
#else
# define machine_is_wandboard_imx6()	(0)
#endif

#ifdef CONFIG_MACH_OMAP4_JET
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP4_JET
# endif
# define machine_is_omap4_jet()	(machine_arch_type == MACH_TYPE_OMAP4_JET)
#else
# define machine_is_omap4_jet()	(0)
#endif

#ifdef CONFIG_MACH_TEGRA_ROTH
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TEGRA_ROTH
# endif
# define machine_is_tegra_roth()	(machine_arch_type == MACH_TYPE_TEGRA_ROTH)
#else
# define machine_is_tegra_roth()	(0)
#endif

#ifdef CONFIG_MACH_M7DCG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7DCG
# endif
# define machine_is_m7dcg()	(machine_arch_type == MACH_TYPE_M7DCG)
#else
# define machine_is_m7dcg()	(0)
#endif

#ifdef CONFIG_MACH_M7DUG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7DUG
# endif
# define machine_is_m7dug()	(machine_arch_type == MACH_TYPE_M7DUG)
#else
# define machine_is_m7dug()	(0)
#endif

#ifdef CONFIG_MACH_M7DTG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7DTG
# endif
# define machine_is_m7dtg()	(machine_arch_type == MACH_TYPE_M7DTG)
#else
# define machine_is_m7dtg()	(0)
#endif

#ifdef CONFIG_MACH_AP42X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AP42X
# endif
# define machine_is_ap42x()	(machine_arch_type == MACH_TYPE_AP42X)
#else
# define machine_is_ap42x()	(0)
#endif

#ifdef CONFIG_MACH_VAR_SOM_MX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VAR_SOM_MX6
# endif
# define machine_is_var_som_mx6()	(machine_arch_type == MACH_TYPE_VAR_SOM_MX6)
#else
# define machine_is_var_som_mx6()	(0)
#endif

#ifdef CONFIG_MACH_PDLU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PDLU
# endif
# define machine_is_pdlu()	(machine_arch_type == MACH_TYPE_PDLU)
#else
# define machine_is_pdlu()	(0)
#endif

#ifdef CONFIG_MACH_HYDROGEN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HYDROGEN
# endif
# define machine_is_hydrogen()	(machine_arch_type == MACH_TYPE_HYDROGEN)
#else
# define machine_is_hydrogen()	(0)
#endif

#ifdef CONFIG_MACH_NPA211E
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NPA211E
# endif
# define machine_is_npa211e()	(machine_arch_type == MACH_TYPE_NPA211E)
#else
# define machine_is_npa211e()	(0)
#endif

#ifdef CONFIG_MACH_ARCADIA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARCADIA
# endif
# define machine_is_arcadia()	(machine_arch_type == MACH_TYPE_ARCADIA)
#else
# define machine_is_arcadia()	(0)
#endif

#ifdef CONFIG_MACH_ARCADIA_L
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARCADIA_L
# endif
# define machine_is_arcadia_l()	(machine_arch_type == MACH_TYPE_ARCADIA_L)
#else
# define machine_is_arcadia_l()	(0)
#endif

#ifdef CONFIG_MACH_MSM8930DT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8930DT
# endif
# define machine_is_msm8930dt()	(machine_arch_type == MACH_TYPE_MSM8930DT)
#else
# define machine_is_msm8930dt()	(0)
#endif

#ifdef CONFIG_MACH_KTAM3874
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KTAM3874
# endif
# define machine_is_ktam3874()	(machine_arch_type == MACH_TYPE_KTAM3874)
#else
# define machine_is_ktam3874()	(0)
#endif

#ifdef CONFIG_MACH_CEC4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CEC4
# endif
# define machine_is_cec4()	(machine_arch_type == MACH_TYPE_CEC4)
#else
# define machine_is_cec4()	(0)
#endif

#ifdef CONFIG_MACH_APE6EVM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_APE6EVM
# endif
# define machine_is_ape6evm()	(machine_arch_type == MACH_TYPE_APE6EVM)
#else
# define machine_is_ape6evm()	(0)
#endif

#ifdef CONFIG_MACH_TX6
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TX6
# endif
# define machine_is_tx6()	(machine_arch_type == MACH_TYPE_TX6)
#else
# define machine_is_tx6()	(0)
#endif

#ifdef CONFIG_MACH_CFA10037
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CFA10037
# endif
# define machine_is_cfa10037()	(machine_arch_type == MACH_TYPE_CFA10037)
#else
# define machine_is_cfa10037()	(0)
#endif

#ifdef CONFIG_MACH_EZP1000
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EZP1000
# endif
# define machine_is_ezp1000()	(machine_arch_type == MACH_TYPE_EZP1000)
#else
# define machine_is_ezp1000()	(0)
#endif

#ifdef CONFIG_MACH_WGR826V
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WGR826V
# endif
# define machine_is_wgr826v()	(machine_arch_type == MACH_TYPE_WGR826V)
#else
# define machine_is_wgr826v()	(0)
#endif

#ifdef CONFIG_MACH_EXUMA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EXUMA
# endif
# define machine_is_exuma()	(machine_arch_type == MACH_TYPE_EXUMA)
#else
# define machine_is_exuma()	(0)
#endif

#ifdef CONFIG_MACH_FREGATE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FREGATE
# endif
# define machine_is_fregate()	(machine_arch_type == MACH_TYPE_FREGATE)
#else
# define machine_is_fregate()	(0)
#endif

#ifdef CONFIG_MACH_OSIRISIMX508
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OSIRISIMX508
# endif
# define machine_is_osirisimx508()	(machine_arch_type == MACH_TYPE_OSIRISIMX508)
#else
# define machine_is_osirisimx508()	(0)
#endif

#ifdef CONFIG_MACH_ST_EXIGO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ST_EXIGO
# endif
# define machine_is_st_exigo()	(machine_arch_type == MACH_TYPE_ST_EXIGO)
#else
# define machine_is_st_exigo()	(0)
#endif

#ifdef CONFIG_MACH_PISMO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PISMO
# endif
# define machine_is_pismo()	(machine_arch_type == MACH_TYPE_PISMO)
#else
# define machine_is_pismo()	(0)
#endif

#ifdef CONFIG_MACH_ATC7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ATC7
# endif
# define machine_is_atc7()	(machine_arch_type == MACH_TYPE_ATC7)
#else
# define machine_is_atc7()	(0)
#endif

#ifdef CONFIG_MACH_NSPIRECLP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSPIRECLP
# endif
# define machine_is_nspireclp()	(machine_arch_type == MACH_TYPE_NSPIRECLP)
#else
# define machine_is_nspireclp()	(0)
#endif

#ifdef CONFIG_MACH_NSPIRETP
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSPIRETP
# endif
# define machine_is_nspiretp()	(machine_arch_type == MACH_TYPE_NSPIRETP)
#else
# define machine_is_nspiretp()	(0)
#endif

#ifdef CONFIG_MACH_NSPIRECX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSPIRECX
# endif
# define machine_is_nspirecx()	(machine_arch_type == MACH_TYPE_NSPIRECX)
#else
# define machine_is_nspirecx()	(0)
#endif

#ifdef CONFIG_MACH_MAYA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAYA
# endif
# define machine_is_maya()	(machine_arch_type == MACH_TYPE_MAYA)
#else
# define machine_is_maya()	(0)
#endif

#ifdef CONFIG_MACH_WECCT
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WECCT
# endif
# define machine_is_wecct()	(machine_arch_type == MACH_TYPE_WECCT)
#else
# define machine_is_wecct()	(0)
#endif

#ifdef CONFIG_MACH_M2S
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M2S
# endif
# define machine_is_m2s()	(machine_arch_type == MACH_TYPE_M2S)
#else
# define machine_is_m2s()	(0)
#endif

#ifdef CONFIG_MACH_MSM8625Q_EVBD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8625Q_EVBD
# endif
# define machine_is_msm8625q_evbd()	(machine_arch_type == MACH_TYPE_MSM8625Q_EVBD)
#else
# define machine_is_msm8625q_evbd()	(0)
#endif

#ifdef CONFIG_MACH_TINY210
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TINY210
# endif
# define machine_is_tiny210()	(machine_arch_type == MACH_TYPE_TINY210)
#else
# define machine_is_tiny210()	(0)
#endif

#ifdef CONFIG_MACH_G3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_G3
# endif
# define machine_is_g3()	(machine_arch_type == MACH_TYPE_G3)
#else
# define machine_is_g3()	(0)
#endif

#ifdef CONFIG_MACH_HURRICANE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HURRICANE
# endif
# define machine_is_hurricane()	(machine_arch_type == MACH_TYPE_HURRICANE)
#else
# define machine_is_hurricane()	(0)
#endif

#ifdef CONFIG_MACH_MX6_POD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_POD
# endif
# define machine_is_mx6_pod()	(machine_arch_type == MACH_TYPE_MX6_POD)
#else
# define machine_is_mx6_pod()	(0)
#endif

#ifdef CONFIG_MACH_ELONDCN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ELONDCN
# endif
# define machine_is_elondcn()	(machine_arch_type == MACH_TYPE_ELONDCN)
#else
# define machine_is_elondcn()	(0)
#endif

#ifdef CONFIG_MACH_CWMX535
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CWMX535
# endif
# define machine_is_cwmx535()	(machine_arch_type == MACH_TYPE_CWMX535)
#else
# define machine_is_cwmx535()	(0)
#endif

#ifdef CONFIG_MACH_M7_WLJ
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_M7_WLJ
# endif
# define machine_is_m7_wlj()	(machine_arch_type == MACH_TYPE_M7_WLJ)
#else
# define machine_is_m7_wlj()	(0)
#endif

#ifdef CONFIG_MACH_QSP_ARM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QSP_ARM
# endif
# define machine_is_qsp_arm()	(machine_arch_type == MACH_TYPE_QSP_ARM)
#else
# define machine_is_qsp_arm()	(0)
#endif

#ifdef CONFIG_MACH_MSM8625Q_SKUD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8625Q_SKUD
# endif
# define machine_is_msm8625q_skud()	(machine_arch_type == MACH_TYPE_MSM8625Q_SKUD)
#else
# define machine_is_msm8625q_skud()	(0)
#endif

#ifdef CONFIG_MACH_HTCMONDRIAN
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HTCMONDRIAN
# endif
# define machine_is_htcmondrian()	(machine_arch_type == MACH_TYPE_HTCMONDRIAN)
#else
# define machine_is_htcmondrian()	(0)
#endif

#ifdef CONFIG_MACH_WATSON_EAD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WATSON_EAD
# endif
# define machine_is_watson_ead()	(machine_arch_type == MACH_TYPE_WATSON_EAD)
#else
# define machine_is_watson_ead()	(0)
#endif

#ifdef CONFIG_MACH_MITWOA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MITWOA
# endif
# define machine_is_mitwoa()	(machine_arch_type == MACH_TYPE_MITWOA)
#else
# define machine_is_mitwoa()	(0)
#endif

#ifdef CONFIG_MACH_OMAP3_WOLVERINE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP3_WOLVERINE
# endif
# define machine_is_omap3_wolverine()	(machine_arch_type == MACH_TYPE_OMAP3_WOLVERINE)
#else
# define machine_is_omap3_wolverine()	(0)
#endif

#ifdef CONFIG_MACH_MAPLETREE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MAPLETREE
# endif
# define machine_is_mapletree()	(machine_arch_type == MACH_TYPE_MAPLETREE)
#else
# define machine_is_mapletree()	(0)
#endif

#ifdef CONFIG_MACH_MSM8625_FIH_SAE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8625_FIH_SAE
# endif
# define machine_is_msm8625_fih_sae()	(machine_arch_type == MACH_TYPE_MSM8625_FIH_SAE)
#else
# define machine_is_msm8625_fih_sae()	(0)
#endif

#ifdef CONFIG_MACH_EPC35
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EPC35
# endif
# define machine_is_epc35()	(machine_arch_type == MACH_TYPE_EPC35)
#else
# define machine_is_epc35()	(0)
#endif

#ifdef CONFIG_MACH_SMARTRTU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMARTRTU
# endif
# define machine_is_smartrtu()	(machine_arch_type == MACH_TYPE_SMARTRTU)
#else
# define machine_is_smartrtu()	(0)
#endif

#ifdef CONFIG_MACH_RCM101
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RCM101
# endif
# define machine_is_rcm101()	(machine_arch_type == MACH_TYPE_RCM101)
#else
# define machine_is_rcm101()	(0)
#endif

#ifdef CONFIG_MACH_AMX_IMX53_MXX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AMX_IMX53_MXX
# endif
# define machine_is_amx_imx53_mxx()	(machine_arch_type == MACH_TYPE_AMX_IMX53_MXX)
#else
# define machine_is_amx_imx53_mxx()	(0)
#endif

#ifdef CONFIG_MACH_ACER_A12
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ACER_A12
# endif
# define machine_is_acer_a12()	(machine_arch_type == MACH_TYPE_ACER_A12)
#else
# define machine_is_acer_a12()	(0)
#endif

#ifdef CONFIG_MACH_SBC6X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SBC6X
# endif
# define machine_is_sbc6x()	(machine_arch_type == MACH_TYPE_SBC6X)
#else
# define machine_is_sbc6x()	(0)
#endif

#ifdef CONFIG_MACH_U2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_U2
# endif
# define machine_is_u2()	(machine_arch_type == MACH_TYPE_U2)
#else
# define machine_is_u2()	(0)
#endif

#ifdef CONFIG_MACH_SMDK4270
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SMDK4270
# endif
# define machine_is_smdk4270()	(machine_arch_type == MACH_TYPE_SMDK4270)
#else
# define machine_is_smdk4270()	(0)
#endif

#ifdef CONFIG_MACH_PRISCILLAG
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PRISCILLAG
# endif
# define machine_is_priscillag()	(machine_arch_type == MACH_TYPE_PRISCILLAG)
#else
# define machine_is_priscillag()	(0)
#endif

#ifdef CONFIG_MACH_PRISCILLAC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PRISCILLAC
# endif
# define machine_is_priscillac()	(machine_arch_type == MACH_TYPE_PRISCILLAC)
#else
# define machine_is_priscillac()	(0)
#endif

#ifdef CONFIG_MACH_PRISCILLA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PRISCILLA
# endif
# define machine_is_priscilla()	(machine_arch_type == MACH_TYPE_PRISCILLA)
#else
# define machine_is_priscilla()	(0)
#endif

#ifdef CONFIG_MACH_INNOVA_SHPU_V2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_INNOVA_SHPU_V2
# endif
# define machine_is_innova_shpu_v2()	(machine_arch_type == MACH_TYPE_INNOVA_SHPU_V2)
#else
# define machine_is_innova_shpu_v2()	(0)
#endif

#ifdef CONFIG_MACH_MACH_TYPE_DEP2410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MACH_TYPE_DEP2410
# endif
# define machine_is_mach_type_dep2410()	(machine_arch_type == MACH_TYPE_MACH_TYPE_DEP2410)
#else
# define machine_is_mach_type_dep2410()	(0)
#endif

#ifdef CONFIG_MACH_BCTRE3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BCTRE3
# endif
# define machine_is_bctre3()	(machine_arch_type == MACH_TYPE_BCTRE3)
#else
# define machine_is_bctre3()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_M100
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_M100
# endif
# define machine_is_omap_m100()	(machine_arch_type == MACH_TYPE_OMAP_M100)
#else
# define machine_is_omap_m100()	(0)
#endif

#ifdef CONFIG_MACH_FLO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FLO
# endif
# define machine_is_flo()	(machine_arch_type == MACH_TYPE_FLO)
#else
# define machine_is_flo()	(0)
#endif

#ifdef CONFIG_MACH_NANOBONE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NANOBONE
# endif
# define machine_is_nanobone()	(machine_arch_type == MACH_TYPE_NANOBONE)
#else
# define machine_is_nanobone()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2105
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2105
# endif
# define machine_is_stm_b2105()	(machine_arch_type == MACH_TYPE_STM_B2105)
#else
# define machine_is_stm_b2105()	(0)
#endif

#ifdef CONFIG_MACH_OMAP4_BSC_BAP_V3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP4_BSC_BAP_V3
# endif
# define machine_is_omap4_bsc_bap_v3()	(machine_arch_type == MACH_TYPE_OMAP4_BSC_BAP_V3)
#else
# define machine_is_omap4_bsc_bap_v3()	(0)
#endif

#ifdef CONFIG_MACH_SS1PAM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SS1PAM
# endif
# define machine_is_ss1pam()	(machine_arch_type == MACH_TYPE_SS1PAM)
#else
# define machine_is_ss1pam()	(0)
#endif

#ifdef CONFIG_MACH_PRIMOMINIU
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PRIMOMINIU
# endif
# define machine_is_primominiu()	(machine_arch_type == MACH_TYPE_PRIMOMINIU)
#else
# define machine_is_primominiu()	(0)
#endif

#ifdef CONFIG_MACH_MRT_35HD_DUALNAS_E
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MRT_35HD_DUALNAS_E
# endif
# define machine_is_mrt_35hd_dualnas_e()	(machine_arch_type == MACH_TYPE_MRT_35HD_DUALNAS_E)
#else
# define machine_is_mrt_35hd_dualnas_e()	(0)
#endif

#ifdef CONFIG_MACH_KIWI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_KIWI
# endif
# define machine_is_kiwi()	(machine_arch_type == MACH_TYPE_KIWI)
#else
# define machine_is_kiwi()	(0)
#endif

#ifdef CONFIG_MACH_HW90496
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HW90496
# endif
# define machine_is_hw90496()	(machine_arch_type == MACH_TYPE_HW90496)
#else
# define machine_is_hw90496()	(0)
#endif

#ifdef CONFIG_MACH_MEP2440
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MEP2440
# endif
# define machine_is_mep2440()	(machine_arch_type == MACH_TYPE_MEP2440)
#else
# define machine_is_mep2440()	(0)
#endif

#ifdef CONFIG_MACH_COLIBRI_T30
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COLIBRI_T30
# endif
# define machine_is_colibri_t30()	(machine_arch_type == MACH_TYPE_COLIBRI_T30)
#else
# define machine_is_colibri_t30()	(0)
#endif

#ifdef CONFIG_MACH_CWV1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CWV1
# endif
# define machine_is_cwv1()	(machine_arch_type == MACH_TYPE_CWV1)
#else
# define machine_is_cwv1()	(0)
#endif

#ifdef CONFIG_MACH_NSA325
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NSA325
# endif
# define machine_is_nsa325()	(machine_arch_type == MACH_TYPE_NSA325)
#else
# define machine_is_nsa325()	(0)
#endif

#ifdef CONFIG_MACH_DPXMTC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DPXMTC
# endif
# define machine_is_dpxmtc()	(machine_arch_type == MACH_TYPE_DPXMTC)
#else
# define machine_is_dpxmtc()	(0)
#endif

#ifdef CONFIG_MACH_TT_STUTTGART
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TT_STUTTGART
# endif
# define machine_is_tt_stuttgart()	(machine_arch_type == MACH_TYPE_TT_STUTTGART)
#else
# define machine_is_tt_stuttgart()	(0)
#endif

#ifdef CONFIG_MACH_MIRANDA_APCII
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MIRANDA_APCII
# endif
# define machine_is_miranda_apcii()	(machine_arch_type == MACH_TYPE_MIRANDA_APCII)
#else
# define machine_is_miranda_apcii()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_MODEROX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_MODEROX
# endif
# define machine_is_mx6q_moderox()	(machine_arch_type == MACH_TYPE_MX6Q_MODEROX)
#else
# define machine_is_mx6q_moderox()	(0)
#endif

#ifdef CONFIG_MACH_MUDSKIPPER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MUDSKIPPER
# endif
# define machine_is_mudskipper()	(machine_arch_type == MACH_TYPE_MUDSKIPPER)
#else
# define machine_is_mudskipper()	(0)
#endif

#ifdef CONFIG_MACH_URANIA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_URANIA
# endif
# define machine_is_urania()	(machine_arch_type == MACH_TYPE_URANIA)
#else
# define machine_is_urania()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2112
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2112
# endif
# define machine_is_stm_b2112()	(machine_arch_type == MACH_TYPE_STM_B2112)
#else
# define machine_is_stm_b2112()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_ATS_PHOENIX
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_ATS_PHOENIX
# endif
# define machine_is_mx6q_ats_phoenix()	(machine_arch_type == MACH_TYPE_MX6Q_ATS_PHOENIX)
#else
# define machine_is_mx6q_ats_phoenix()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2116
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2116
# endif
# define machine_is_stm_b2116()	(machine_arch_type == MACH_TYPE_STM_B2116)
#else
# define machine_is_stm_b2116()	(0)
#endif

#ifdef CONFIG_MACH_MYTHOLOGY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MYTHOLOGY
# endif
# define machine_is_mythology()	(machine_arch_type == MACH_TYPE_MYTHOLOGY)
#else
# define machine_is_mythology()	(0)
#endif

#ifdef CONFIG_MACH_FC360V1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FC360V1
# endif
# define machine_is_fc360v1()	(machine_arch_type == MACH_TYPE_FC360V1)
#else
# define machine_is_fc360v1()	(0)
#endif

#ifdef CONFIG_MACH_GPS_SENSOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GPS_SENSOR
# endif
# define machine_is_gps_sensor()	(machine_arch_type == MACH_TYPE_GPS_SENSOR)
#else
# define machine_is_gps_sensor()	(0)
#endif

#ifdef CONFIG_MACH_GAZELLE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GAZELLE
# endif
# define machine_is_gazelle()	(machine_arch_type == MACH_TYPE_GAZELLE)
#else
# define machine_is_gazelle()	(0)
#endif

#ifdef CONFIG_MACH_MPQ8064_DMA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MPQ8064_DMA
# endif
# define machine_is_mpq8064_dma()	(machine_arch_type == MACH_TYPE_MPQ8064_DMA)
#else
# define machine_is_mpq8064_dma()	(0)
#endif

#ifdef CONFIG_MACH_WEMS_ASD01
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_WEMS_ASD01
# endif
# define machine_is_wems_asd01()	(machine_arch_type == MACH_TYPE_WEMS_ASD01)
#else
# define machine_is_wems_asd01()	(0)
#endif

#ifdef CONFIG_MACH_APALIS_T30
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_APALIS_T30
# endif
# define machine_is_apalis_t30()	(machine_arch_type == MACH_TYPE_APALIS_T30)
#else
# define machine_is_apalis_t30()	(0)
#endif

#ifdef CONFIG_MACH_ARMSTONEA9
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ARMSTONEA9
# endif
# define machine_is_armstonea9()	(machine_arch_type == MACH_TYPE_ARMSTONEA9)
#else
# define machine_is_armstonea9()	(0)
#endif

#ifdef CONFIG_MACH_OMAP_BLAZETABLET
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_OMAP_BLAZETABLET
# endif
# define machine_is_omap_blazetablet()	(machine_arch_type == MACH_TYPE_OMAP_BLAZETABLET)
#else
# define machine_is_omap_blazetablet()	(0)
#endif

#ifdef CONFIG_MACH_AR6MXQ
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AR6MXQ
# endif
# define machine_is_ar6mxq()	(machine_arch_type == MACH_TYPE_AR6MXQ)
#else
# define machine_is_ar6mxq()	(0)
#endif

#ifdef CONFIG_MACH_AR6MXS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AR6MXS
# endif
# define machine_is_ar6mxs()	(machine_arch_type == MACH_TYPE_AR6MXS)
#else
# define machine_is_ar6mxs()	(0)
#endif

#ifdef CONFIG_MACH_GWVENTANA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GWVENTANA
# endif
# define machine_is_gwventana()	(machine_arch_type == MACH_TYPE_GWVENTANA)
#else
# define machine_is_gwventana()	(0)
#endif

#ifdef CONFIG_MACH_IGEP0033
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IGEP0033
# endif
# define machine_is_igep0033()	(machine_arch_type == MACH_TYPE_IGEP0033)
#else
# define machine_is_igep0033()	(0)
#endif

#ifdef CONFIG_MACH_H52C1_CONCERTO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_H52C1_CONCERTO
# endif
# define machine_is_h52c1_concerto()	(machine_arch_type == MACH_TYPE_H52C1_CONCERTO)
#else
# define machine_is_h52c1_concerto()	(0)
#endif

#ifdef CONFIG_MACH_FCMBRD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_FCMBRD
# endif
# define machine_is_fcmbrd()	(machine_arch_type == MACH_TYPE_FCMBRD)
#else
# define machine_is_fcmbrd()	(0)
#endif

#ifdef CONFIG_MACH_PCAAXS1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCAAXS1
# endif
# define machine_is_pcaaxs1()	(machine_arch_type == MACH_TYPE_PCAAXS1)
#else
# define machine_is_pcaaxs1()	(0)
#endif

#ifdef CONFIG_MACH_LS_ORCA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LS_ORCA
# endif
# define machine_is_ls_orca()	(machine_arch_type == MACH_TYPE_LS_ORCA)
#else
# define machine_is_ls_orca()	(0)
#endif

#ifdef CONFIG_MACH_PCM051LB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PCM051LB
# endif
# define machine_is_pcm051lb()	(machine_arch_type == MACH_TYPE_PCM051LB)
#else
# define machine_is_pcm051lb()	(0)
#endif

#ifdef CONFIG_MACH_MX6S_LP507_GVCI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6S_LP507_GVCI
# endif
# define machine_is_mx6s_lp507_gvci()	(machine_arch_type == MACH_TYPE_MX6S_LP507_GVCI)
#else
# define machine_is_mx6s_lp507_gvci()	(0)
#endif

#ifdef CONFIG_MACH_DIDO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DIDO
# endif
# define machine_is_dido()	(machine_arch_type == MACH_TYPE_DIDO)
#else
# define machine_is_dido()	(0)
#endif

#ifdef CONFIG_MACH_SWARCO_ITC3_9G20
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SWARCO_ITC3_9G20
# endif
# define machine_is_swarco_itc3_9g20()	(machine_arch_type == MACH_TYPE_SWARCO_ITC3_9G20)
#else
# define machine_is_swarco_itc3_9g20()	(0)
#endif

#ifdef CONFIG_MACH_ROBO_ROADY
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ROBO_ROADY
# endif
# define machine_is_robo_roady()	(machine_arch_type == MACH_TYPE_ROBO_ROADY)
#else
# define machine_is_robo_roady()	(0)
#endif

#ifdef CONFIG_MACH_RSKRZA1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_RSKRZA1
# endif
# define machine_is_rskrza1()	(machine_arch_type == MACH_TYPE_RSKRZA1)
#else
# define machine_is_rskrza1()	(0)
#endif

#ifdef CONFIG_MACH_SWARCO_SID
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SWARCO_SID
# endif
# define machine_is_swarco_sid()	(machine_arch_type == MACH_TYPE_SWARCO_SID)
#else
# define machine_is_swarco_sid()	(0)
#endif

#ifdef CONFIG_MACH_MX6_IWG15S_SBC
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_IWG15S_SBC
# endif
# define machine_is_mx6_iwg15s_sbc()	(machine_arch_type == MACH_TYPE_MX6_IWG15S_SBC)
#else
# define machine_is_mx6_iwg15s_sbc()	(0)
#endif

#ifdef CONFIG_MACH_MX6Q_CAMARO
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6Q_CAMARO
# endif
# define machine_is_mx6q_camaro()	(machine_arch_type == MACH_TYPE_MX6Q_CAMARO)
#else
# define machine_is_mx6q_camaro()	(0)
#endif

#ifdef CONFIG_MACH_HB6MXS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HB6MXS
# endif
# define machine_is_hb6mxs()	(machine_arch_type == MACH_TYPE_HB6MXS)
#else
# define machine_is_hb6mxs()	(0)
#endif

#ifdef CONFIG_MACH_LAGER
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LAGER
# endif
# define machine_is_lager()	(machine_arch_type == MACH_TYPE_LAGER)
#else
# define machine_is_lager()	(0)
#endif

#ifdef CONFIG_MACH_LP8X4X
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_LP8X4X
# endif
# define machine_is_lp8x4x()	(machine_arch_type == MACH_TYPE_LP8X4X)
#else
# define machine_is_lp8x4x()	(0)
#endif

#ifdef CONFIG_MACH_TEGRATAB7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TEGRATAB7
# endif
# define machine_is_tegratab7()	(machine_arch_type == MACH_TYPE_TEGRATAB7)
#else
# define machine_is_tegratab7()	(0)
#endif

#ifdef CONFIG_MACH_ANDROMEDA
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ANDROMEDA
# endif
# define machine_is_andromeda()	(machine_arch_type == MACH_TYPE_ANDROMEDA)
#else
# define machine_is_andromeda()	(0)
#endif

#ifdef CONFIG_MACH_BOOTES
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BOOTES
# endif
# define machine_is_bootes()	(machine_arch_type == MACH_TYPE_BOOTES)
#else
# define machine_is_bootes()	(0)
#endif

#ifdef CONFIG_MACH_NETHMI
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_NETHMI
# endif
# define machine_is_nethmi()	(machine_arch_type == MACH_TYPE_NETHMI)
#else
# define machine_is_nethmi()	(0)
#endif

#ifdef CONFIG_MACH_TEGRATAB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TEGRATAB
# endif
# define machine_is_tegratab()	(machine_arch_type == MACH_TYPE_TEGRATAB)
#else
# define machine_is_tegratab()	(0)
#endif

#ifdef CONFIG_MACH_SOM5_EVB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SOM5_EVB
# endif
# define machine_is_som5_evb()	(machine_arch_type == MACH_TYPE_SOM5_EVB)
#else
# define machine_is_som5_evb()	(0)
#endif

#ifdef CONFIG_MACH_VENATICORUM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_VENATICORUM
# endif
# define machine_is_venaticorum()	(machine_arch_type == MACH_TYPE_VENATICORUM)
#else
# define machine_is_venaticorum()	(0)
#endif

#ifdef CONFIG_MACH_STM_B2110
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_STM_B2110
# endif
# define machine_is_stm_b2110()	(machine_arch_type == MACH_TYPE_STM_B2110)
#else
# define machine_is_stm_b2110()	(0)
#endif

#ifdef CONFIG_MACH_ELUX_HATHOR
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ELUX_HATHOR
# endif
# define machine_is_elux_hathor()	(machine_arch_type == MACH_TYPE_ELUX_HATHOR)
#else
# define machine_is_elux_hathor()	(0)
#endif

#ifdef CONFIG_MACH_HELIOS_V7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_HELIOS_V7
# endif
# define machine_is_helios_v7()	(machine_arch_type == MACH_TYPE_HELIOS_V7)
#else
# define machine_is_helios_v7()	(0)
#endif

#ifdef CONFIG_MACH_XC10V1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_XC10V1
# endif
# define machine_is_xc10v1()	(machine_arch_type == MACH_TYPE_XC10V1)
#else
# define machine_is_xc10v1()	(0)
#endif

#ifdef CONFIG_MACH_CP2U
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CP2U
# endif
# define machine_is_cp2u()	(machine_arch_type == MACH_TYPE_CP2U)
#else
# define machine_is_cp2u()	(0)
#endif

#ifdef CONFIG_MACH_IAP_F
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IAP_F
# endif
# define machine_is_iap_f()	(machine_arch_type == MACH_TYPE_IAP_F)
#else
# define machine_is_iap_f()	(0)
#endif

#ifdef CONFIG_MACH_IAP_G
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_IAP_G
# endif
# define machine_is_iap_g()	(machine_arch_type == MACH_TYPE_IAP_G)
#else
# define machine_is_iap_g()	(0)
#endif

#ifdef CONFIG_MACH_AAE
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_AAE
# endif
# define machine_is_aae()	(machine_arch_type == MACH_TYPE_AAE)
#else
# define machine_is_aae()	(0)
#endif

#ifdef CONFIG_MACH_PEGASUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PEGASUS
# endif
# define machine_is_pegasus()	(machine_arch_type == MACH_TYPE_PEGASUS)
#else
# define machine_is_pegasus()	(0)
#endif

#ifdef CONFIG_MACH_CYGNUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CYGNUS
# endif
# define machine_is_cygnus()	(machine_arch_type == MACH_TYPE_CYGNUS)
#else
# define machine_is_cygnus()	(0)
#endif

#ifdef CONFIG_MACH_CENTAURUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_CENTAURUS
# endif
# define machine_is_centaurus()	(machine_arch_type == MACH_TYPE_CENTAURUS)
#else
# define machine_is_centaurus()	(0)
#endif

#ifdef CONFIG_MACH_MSM8930_QRD8930
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MSM8930_QRD8930
# endif
# define machine_is_msm8930_qrd8930()	(machine_arch_type == MACH_TYPE_MSM8930_QRD8930)
#else
# define machine_is_msm8930_qrd8930()	(0)
#endif

#ifdef CONFIG_MACH_QUBY_TIM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_QUBY_TIM
# endif
# define machine_is_quby_tim()	(machine_arch_type == MACH_TYPE_QUBY_TIM)
#else
# define machine_is_quby_tim()	(0)
#endif

#ifdef CONFIG_MACH_ZEDI3250A
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ZEDI3250A
# endif
# define machine_is_zedi3250a()	(machine_arch_type == MACH_TYPE_ZEDI3250A)
#else
# define machine_is_zedi3250a()	(0)
#endif

#ifdef CONFIG_MACH_GRUS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_GRUS
# endif
# define machine_is_grus()	(machine_arch_type == MACH_TYPE_GRUS)
#else
# define machine_is_grus()	(0)
#endif

#ifdef CONFIG_MACH_APOLLO3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_APOLLO3
# endif
# define machine_is_apollo3()	(machine_arch_type == MACH_TYPE_APOLLO3)
#else
# define machine_is_apollo3()	(0)
#endif

#ifdef CONFIG_MACH_COWON_R7
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_COWON_R7
# endif
# define machine_is_cowon_r7()	(machine_arch_type == MACH_TYPE_COWON_R7)
#else
# define machine_is_cowon_r7()	(0)
#endif

#ifdef CONFIG_MACH_TONGA3
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_TONGA3
# endif
# define machine_is_tonga3()	(machine_arch_type == MACH_TYPE_TONGA3)
#else
# define machine_is_tonga3()	(0)
#endif

#ifdef CONFIG_MACH_P535
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_P535
# endif
# define machine_is_p535()	(machine_arch_type == MACH_TYPE_P535)
#else
# define machine_is_p535()	(0)
#endif

#ifdef CONFIG_MACH_SA3874I
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_SA3874I
# endif
# define machine_is_sa3874i()	(machine_arch_type == MACH_TYPE_SA3874I)
#else
# define machine_is_sa3874i()	(0)
#endif

#ifdef CONFIG_MACH_MX6_NAVICO_COM
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_MX6_NAVICO_COM
# endif
# define machine_is_mx6_navico_com()	(machine_arch_type == MACH_TYPE_MX6_NAVICO_COM)
#else
# define machine_is_mx6_navico_com()	(0)
#endif

#ifdef CONFIG_MACH_PROXMOBIL2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PROXMOBIL2
# endif
# define machine_is_proxmobil2()	(machine_arch_type == MACH_TYPE_PROXMOBIL2)
#else
# define machine_is_proxmobil2()	(0)
#endif

#ifdef CONFIG_MACH_UBINUX1
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_UBINUX1
# endif
# define machine_is_ubinux1()	(machine_arch_type == MACH_TYPE_UBINUX1)
#else
# define machine_is_ubinux1()	(0)
#endif

#ifdef CONFIG_MACH_ISTOS
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ISTOS
# endif
# define machine_is_istos()	(machine_arch_type == MACH_TYPE_ISTOS)
#else
# define machine_is_istos()	(0)
#endif

#ifdef CONFIG_MACH_BENVOLIO4
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_BENVOLIO4
# endif
# define machine_is_benvolio4()	(machine_arch_type == MACH_TYPE_BENVOLIO4)
#else
# define machine_is_benvolio4()	(0)
#endif

#ifdef CONFIG_MACH_ECO5_BX2
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_ECO5_BX2
# endif
# define machine_is_eco5_bx2()	(machine_arch_type == MACH_TYPE_ECO5_BX2)
#else
# define machine_is_eco5_bx2()	(0)
#endif

#ifdef CONFIG_MACH_EUKREA_CPUIMX28SD
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX28SD
# endif
# define machine_is_eukrea_cpuimx28sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX28SD)
#else
# define machine_is_eukrea_cpuimx28sd()	(0)
#endif

#ifdef CONFIG_MACH_DOMOTAB
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_DOMOTAB
# endif
# define machine_is_domotab()	(machine_arch_type == MACH_TYPE_DOMOTAB)
#else
# define machine_is_domotab()	(0)
#endif

#ifdef CONFIG_MACH_PFLA03
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type	__machine_arch_type
# else
#  define machine_arch_type	MACH_TYPE_PFLA03
# endif
# define machine_is_pfla03()	(machine_arch_type == MACH_TYPE_PFLA03)
#else
# define machine_is_pfla03()	(0)
#endif

/*
 * These have not yet been registered
 */

#ifndef machine_arch_type
#define machine_arch_type	__machine_arch_type
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (O  .   'O  ..  +O  mediatek-new)O  amd/O  sprddpkg-new-O  arme;O  	freescalekg-new 1O  qcom3O  exynos  5O  xilinx  7O  apm 9O , cavium  	  Makefile.dpkg-neww  =O ,Makefile                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            )O  .   (O ( ..  	  Makefile.dpkg-newy.h*O Makefile	 
spi-core.hne	 	fb-core.h.dp	 
adc-core.hi-	 keypad.h	 nand-core.hp	 regs-irqtype.hre	 pm.h	 adc.hd.h	 
regs-adc.h	 tfb.h	 h
ata-core.hgs	 T	usb-phy.hew 	 @
gpio-cfg.hne	 ,
map-base.hdp	 fb-s3c2410.h	 keypad-core.h 	 gpio-core.h 	 
cpu-freq.hg-	 backlight.h.	 cpu-freq-core.ho	 
irq-uart.h	 	 gpio-cfg-helpers.h	 	 hregs-srom.hk	 T	map-s3c.heyp	 @samsung-time.h	 	 (devs.hh.	 pm-common.h-	 
iic-core.h	 	 wakeup-mask.hnew	 sdhci.hq	 
pwm-core.h	 	 onenand-core.hw 	 watchdog-reset.h	 	map-s5p.h 	 p
regs-spi.hew	  map-s3c.h.dpkg-new  	   samsung-time.h.dpkg-new 	  devs.h.dpkg-new 	  pm-common.h.dpkg-new	  iic-core.h.dpkg-new 	   wakeup-mask.h.dpkg-new  	  sdhci.h.dpkg-new	  pwm-core.h.dpkg-new 	   onenand-core.h.dpkg-new 	 $ watchdog-reset.h.dpkg-new   	  map-s5p.h.dpkg-new  	  regs-spi.h.dpkg-new 	 
regs-udc.h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              +O  .   (O ( ..  	  Makefile.dpkg-new   ,O Makefile                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -O  .   (O ( ..  	  Makefile.dpkg-new	 .O Makefileg-newdpk	 KconfigMakefile.gate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /O  .   (O ( ..  	  Makefile.dpkg-new	 0O Makefilet.dpkg-new  	  Makefile.dpkg-new   	 Kconfig                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     1O  .   (O ( ..  	  Makefile.dpkg-new   2O Makefile                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            3O  .   (O ( ..  	  Makefile.dpkg-new	 4O Makefileg-newr.h	 Kconfig 0	 raid10.h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    5O  .   (O ( ..  	  Makefile.dpkg-new	 6O Makefileg-new	 	 Kconfig xpad.h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          7O  .   (O ( ..  	  Makefile.dpkg-new	 8O Makefiledts 	  Makefile.dpkg-newew 	 Makefile                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        9O  .   (O ( ..  	  Makefile.dpkg-news.h:O Makefile                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;O  .   (O ( ..  	  Makefile.dpkg-newg-n<O Makefilefile.dpkg-new   	  overlays	 Makefile.orig                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ?O  .   O ( ..  	  Makefile.dpkg-new   @O Makefile                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            AO  .   6#  ..  YO  Kconfig.debugnewnewwBO  mach-commonDO  
mach-bf533  JO  lib LO  kernel  RO  
mach-bf609  hO < Makefiledebug.dpkg-new  	  Makefile.dpkg-newew ZO  
mach-bf538  `O  
mach-bf548  fO  mm  XO  Kconfig527.dpkg-new iO  
mach-bf518  oO  
mach-bf561  uO  oprofilewO  
mach-bf537  }O  bootO 
mach-bf527                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              BO  .   AO ( ..  	  Makefile.dpkg-new   CO Makefile-new	 sn2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             DO  .   AO  ..  IO  Makefiledpkg-newEO , boardsle	  Makefile.dpkg-newig HO Kconfig                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     EO  .   DO  ..  GO 4 Makefiledpkg-new	  Makefile.dpkg-newakeFO Kconfignew  0	  Makefile.dpkg-new   .	 Kconfig                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     JO  .   AO ( ..  	  Makefile.dpkg-new	 KO Makefile                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            LO  .   AO ( ..  	  Makefile.dpkg-newewMO  
cplb-nompurnOO  Makefile.dpkg-new	 PO cplb-mpuuncompress.h!	 	shannon.hemo"	 	SA-1100.h	 #	 cerf.hkg$	 simpad.h%	 x	mtd-xip.h   &	 d
neponset.hdp'	 P
bitfield.h-1(	 <reset.h )	 ,
hardware.hg-*	 	generic.hd.h+	 badge4.h,	  	SA-1101.hg-n-	  collie.hnset.h.dpkg-new '	  bitfield.h.dpkg-new (	  reset.h.dpkg-new)	  hardware.h.dpkg-new *	  generic.h.dpkg-new  +	  badge4.h.dpkg-new   ,	  SA-1101.h.dpkg-new  -	  collie.h.dpkg-new   	 nanoengine.h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        MO  .   LO ( ..  	  Makefile.dpkg-new	 NO MakefileMakefile.boot.dpkg-newle;	 Makefile.dpkg-newprofilenew 	 ( mm  	  Kconfig.platformw   	 TKconfigg-neww-ne	 <boot	 0pci 	 $Kconfig.platform.dpkg-new                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   PO  .   LO ( ..  	  Makefile.dpkg-new	 QO Makefile                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            RO  .   AO  ..  WO  Makefiledpkg-newSO , boards	 	  Makefile.dpkg-newardVO Kconfigentry-macro.Sh.dpkg-new 8	  hardware.h.dpkg-new 9	   entry-macro.S.dpkg-new  4	 @board.h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #ifndef _RADEON_H
#define _RADEON_H


#define RADEON_REGSIZE			0x4000


#define MM_INDEX                               0x0000
#define MM_DATA                                0x0004
#define BUS_CNTL                               0x0030
#define HI_STAT                                0x004C
#define BUS_CNTL1                              0x0034
#define I2C_CNTL_1			       0x0094
#define CNFG_CNTL                              0x00E0
#define CNFG_MEMSIZE                           0x00F8
#define CNFG_APER_0_BASE                       0x0100
#define CNFG_APER_1_BASE                       0x0104
#define CNFG_APER_SIZE                         0x0108
#define CNFG_REG_1_BASE                        0x010C
#define CNFG_REG_APER_SIZE                     0x0110
#define PAD_AGPINPUT_DELAY                     0x0164
#define PAD_CTLR_STRENGTH                      0x0168
#define PAD_CTLR_UPDATE                        0x016C
#define PAD_CTLR_MISC                          0x0aa0
#define AGP_CNTL                               0x0174
#define BM_STATUS                              0x0160
#define CAP0_TRIG_CNTL			       0x0950
#define CAP1_TRIG_CNTL		               0x09c0
#define VIPH_CONTROL			       0x0C40
#define VENDOR_ID                              0x0F00
#define DEVICE_ID                              0x0F02
#define COMMAND                                0x0F04
#define STATUS                                 0x0F06
#define REVISION_ID                            0x0F08
#define REGPROG_INF                            0x0F09
#define SUB_CLASS                              0x0F0A
#define BASE_CODE                              0x0F0B
#define CACHE_LINE                             0x0F0C
#define LATENCY                                0x0F0D
#define HEADER                                 0x0F0E
#define BIST                                   0x0F0F
#define REG_MEM_BASE                           0x0F10
#define REG_IO_BASE                            0x0F14
#define REG_REG_BASE                           0x0F18
#define ADAPTER_ID                             0x0F2C
#define BIOS_ROM                               0x0F30
#define CAPABILITIES_PTR                       0x0F34
#define INTERRUPT_LINE                         0x0F3C
#define INTERRUPT_PIN                          0x0F3D
#define MIN_GRANT                              0x0F3E
#define MAX_LATENCY                            0x0F3F
#define ADAPTER_ID_W                           0x0F4C
#define PMI_CAP_ID                             0x0F50
#define PMI_NXT_CAP_PTR                        0x0F51
#define PMI_PMC_REG                            0x0F52
#define PM_STATUS                              0x0F54
#define PMI_DATA                               0x0F57
#define AGP_CAP_ID                             0x0F58
#define AGP_STATUS                             0x0F5C
#define AGP_COMMAND                            0x0F60
#define AIC_CTRL                               0x01D0
#define AIC_STAT                               0x01D4
#define AIC_PT_BASE                            0x01D8
#define AIC_LO_ADDR                            0x01DC
#define AIC_HI_ADDR                            0x01E0
#define AIC_TLB_ADDR                           0x01E4
#define AIC_TLB_DATA                           0x01E8
#define DAC_CNTL                               0x0058
#define DAC_CNTL2                              0x007c
#define CRTC_GEN_CNTL                          0x0050
#define MEM_CNTL                               0x0140
#define MC_CNTL                                0x0140
#define EXT_MEM_CNTL                           0x0144
#define MC_TIMING_CNTL                         0x0144
#define MC_AGP_LOCATION                        0x014C
#define MEM_IO_CNTL_A0                         0x0178
#define MEM_REFRESH_CNTL                       0x0178
#define MEM_INIT_LATENCY_TIMER                 0x0154
#define MC_INIT_GFX_LAT_TIMER                  0x0154
#define MEM_SDRAM_MODE_REG                     0x0158
#define AGP_BASE                               0x0170
#define MEM_IO_CNTL_A1                         0x017C
#define MC_READ_CNTL_AB                        0x017C
#define MEM_IO_CNTL_B0                         0x0180
#define MC_INIT_MISC_LAT_TIMER                 0x0180
#define MEM_IO_CNTL_B1                         0x0184
#define MC_IOPAD_CNTL                          0x0184
#define MC_DEBUG                               0x0188
#define MC_STATUS                              0x0150
#define MEM_IO_OE_CNTL                         0x018C
#define MC_CHIP_IO_OE_CNTL_AB                  0x018C
#define MC_FB_LOCATION                         0x0148
#define HOST_PATH_CNTL                         0x0130
#define MEM_VGA_WP_SEL                         0x0038
#define MEM_VGA_RP_SEL                         0x003C
#define HDP_DEBUG                              0x0138
#define SW_SEMAPHORE                           0x013C
#define CRTC2_GEN_CNTL                         0x03f8
#define CRTC2_DISPLAY_BASE_ADDR                0x033c
#define SURFACE_CNTL                           0x0B00
#define SURFACE0_LOWER_BOUND                   0x0B04
#define SURFACE1_LOWER_BOUND                   0x0B14
#define SURFACE2_LOWER_BOUND                   0x0B24
#define SURFACE3_LOWER_BOUND                   0x0B34
#define SURFACE4_LOWER_BOUND                   0x0B44
#define SURFACE5_LOWER_BOUND                   0x0B54
#define SURFACE6_LOWER_BOUND                   0x0B64
#define SURFACE7_LOWER_BOUND                   0x0B74
#define SURFACE0_UPPER_BOUND                   0x0B08
#define SURFACE1_UPPER_BOUND                   0x0B18
#define SURFACE2_UPPER_BOUND                   0x0B28
#define SURFACE3_UPPER_BOUND                   0x0B38
#define SURFACE4_UPPER_BOUND                   0x0B48
#define SURFACE5_UPPER_BOUND                   0x0B58
#define SURFACE6_UPPER_BOUND                   0x0B68
#define SURFACE7_UPPER_BOUND                   0x0B78
#define SURFACE0_INFO                          0x0B0C
#define SURFACE1_INFO                          0x0B1C
#define SURFACE2_INFO                          0x0B2C
#define SURFACE3_INFO                          0x0B3C
#define SURFACE4_INFO                          0x0B4C
#define SURFACE5_INFO                          0x0B5C
#define SURFACE6_INFO                          0x0B6C
#define SURFACE7_INFO                          0x0B7C
#define SURFACE_ACCESS_FLAGS                   0x0BF8
#define SURFACE_ACCESS_CLR                     0x0BFC
#define GEN_INT_CNTL                           0x0040
#define GEN_INT_STATUS                         0x0044
#define CRTC_EXT_CNTL                          0x0054
#define RB3D_CNTL			       0x1C3C
#define WAIT_UNTIL                             0x1720
#define ISYNC_CNTL                             0x1724
#define RBBM_GUICNTL                           0x172C
#define RBBM_STATUS                            0x0E40
#define RBBM_STATUS_alt_1                      0x1740
#define RBBM_CNTL                              0x00EC
#define RBBM_CNTL_alt_1                        0x0E44
#define RBBM_SOFT_RESET                        0x00F0
#define RBBM_SOFT_RESET_alt_1                  0x0E48
#define NQWAIT_UNTIL                           0x0E50
#define RBBM_DEBUG                             0x0E6C
#define RBBM_CMDFIFO_ADDR                      0x0E70
#define RBBM_CMDFIFO_DATAL                     0x0E74
#define RBBM_CMDFIFO_DATAH                     0x0E78
#define RBBM_CMDFIFO_STAT                      0x0E7C
#define CRTC_STATUS                            0x005C
#define GPIO_VGA_DDC                           0x0060
#define GPIO_DVI_DDC                           0x0064
#define GPIO_MONID                             0x0068
#define GPIO_CRT2_DDC                          0x006c
#define PALETTE_INDEX                          0x00B0
#define PALETTE_DATA                           0x00B4
#define PALETTE_30_DATA                        0x00B8
#define CRTC_H_TOTAL_DISP                      0x0200
#define CRTC_H_SYNC_STRT_WID                   0x0204
#define CRTC_V_TOTAL_DISP                      0x0208
#define CRTC_V_SYNC_STRT_WID                   0x020C
#define CRTC_VLINE_CRNT_VLINE                  0x0210
#define CRTC_CRNT_FRAME                        0x0214
#define CRTC_GUI_TRIG_VLINE                    0x0218
#define CRTC_DEBUG                             0x021C
#define CRTC_OFFSET_RIGHT                      0x0220
#define CRTC_OFFSET                            0x0224
#define CRTC_OFFSET_CNTL                       0x0228
#define CRTC_PITCH                             0x022C
#define OVR_CLR                                0x0230
#define OVR_WID_LEFT_RIGHT                     0x0234
#define OVR_WID_TOP_BOTTOM                     0x0238
#define DISPLAY_BASE_ADDR                      0x023C
#define SNAPSHOT_VH_COUNTS                     0x0240
#define SNAPSHOT_F_COUNT                       0x0244
#define N_VIF_COUNT                            0x0248
#define SNAPSHOT_VIF_COUNT                     0x024C
#define FP_CRTC_H_TOTAL_DISP                   0x0250
#define FP_CRTC_V_TOTAL_DISP                   0x0254
#define CRT_CRTC_H_SYNC_STRT_WID               0x0258
#define CRT_CRTC_V_SYNC_STRT_WID               0x025C
#define CUR_OFFSET                             0x0260
#define CUR_HORZ_VERT_POSN                     0x0264
#define CUR_HORZ_VERT_OFF                      0x0268
#define CUR_CLR0                               0x026C
#define CUR_CLR1                               0x0270
#define FP_HORZ_VERT_ACTIVE                    0x0278
#define CRTC_MORE_CNTL                         0x027C
#define CRTC_H_CUTOFF_ACTIVE_EN                (1<<4)
#define CRTC_V_CUTOFF_ACTIVE_EN                (1<<5)
#define DAC_EXT_CNTL                           0x0280
#define FP_GEN_CNTL                            0x0284
#define FP_HORZ_STRETCH                        0x028C
#define FP_VERT_STRETCH                        0x0290
#define FP_H_SYNC_STRT_WID                     0x02C4
#define FP_V_SYNC_STRT_WID                     0x02C8
#define AUX_WINDOW_HORZ_CNTL                   0x02D8
#define AUX_WINDOW_VERT_CNTL                   0x02DC
//#define DDA_CONFIG			       0x02e0
//#define DDA_ON_OFF			       0x02e4
#define DVI_I2C_CNTL_1			       0x02e4
#define GRPH_BUFFER_CNTL                       0x02F0
#define GRPH2_BUFFER_CNTL                      0x03F0
#define VGA_BUFFER_CNTL                        0x02F4
#define OV0_Y_X_START                          0x0400
#define OV0_Y_X_END                            0x0404
#define OV0_PIPELINE_CNTL                      0x0408
#define OV0_REG_LOAD_CNTL                      0x0410
#define OV0_SCALE_CNTL                         0x0420
#define OV0_V_INC                              0x0424
#define OV0_P1_V_ACCUM_INIT                    0x0428
#define OV0_P23_V_ACCUM_INIT                   0x042C
#define OV0_P1_BLANK_LINES_AT_TOP              0x0430
#define OV0_P23_BLANK_LINES_AT_TOP             0x0434
#define OV0_BASE_ADDR                          0x043C
#define OV0_VID_BUF0_BASE_ADRS                 0x0440
#define OV0_VID_BUF1_BASE_ADRS                 0x0444
#define OV0_VID_BUF2_BASE_ADRS                 0x0448
#define OV0_VID_BUF3_BASE_ADRS                 0x044C
#define OV0_VID_BUF4_BASE_ADRS                 0x0450
#define OV0_VID_BUF5_BASE_ADRS                 0x0454
#define OV0_VID_BUF_PITCH0_VALUE               0x0460
#define OV0_VID_BUF_PITCH1_VALUE               0x0464
#define OV0_AUTO_FLIP_CNTRL                    0x0470
#define OV0_DEINTERLACE_PATTERN                0x0474
#define OV0_SUBMIT_HISTORY                     0x0478
#define OV0_H_INC                              0x0480
#define OV0_STEP_BY                            0x0484
#define OV0_P1_H_ACCUM_INIT                    0x0488
#define OV0_P23_H_ACCUM_INIT                   0x048C
#define OV0_P1_X_START_END                     0x0494
#define OV0_P2_X_START_END                     0x0498
#define OV0_P3_X_START_END                     0x049C
#define OV0_FILTER_CNTL                        0x04A0
#define OV0_FOUR_TAP_COEF_0                    0x04B0
#define OV0_FOUR_TAP_COEF_1                    0x04B4
#define OV0_FOUR_TAP_COEF_2                    0x04B8
#define OV0_FOUR_TAP_COEF_3                    0x04BC
#define OV0_FOUR_TAP_COEF_4                    0x04C0
#define OV0_FLAG_CNTRL                         0x04DC
#define OV0_SLICE_CNTL                         0x04E0
#define OV0_VID_KEY_CLR_LOW                    0x04E4
#define OV0_VID_KEY_CLR_HIGH                   0x04E8
#define OV0_GRPH_KEY_CLR_LOW                   0x04EC
#define OV0_GRPH_KEY_CLR_HIGH                  0x04F0
#define OV0_KEY_CNTL                           0x04F4
#define OV0_TEST                               0x04F8
#define SUBPIC_CNTL                            0x0540
#define SUBPIC_DEFCOLCON                       0x0544
#define SUBPIC_Y_X_START                       0x054C
#define SUBPIC_Y_X_END                         0x0550
#define SUBPIC_V_INC                           0x0554
#define SUBPIC_H_INC                           0x0558
#define SUBPIC_BUF0_OFFSET                     0x055C
#define SUBPIC_BUF1_OFFSET                     0x0560
#define SUBPIC_LC0_OFFSET                      0x0564
#define SUBPIC_LC1_OFFSET                      0x0568
#define SUBPIC_PITCH                           0x056C
#define SUBPIC_BTN_HLI_COLCON                  0x0570
#define SUBPIC_BTN_HLI_Y_X_START               0x0574
#define SUBPIC_BTN_HLI_Y_X_END                 0x0578
#define SUBPIC_PALETTE_INDEX                   0x057C
#define SUBPIC_PALETTE_DATA                    0x0580
#define SUBPIC_H_ACCUM_INIT                    0x0584
#define SUBPIC_V_ACCUM_INIT                    0x0588
#define DISP_MISC_CNTL                         0x0D00
#define DAC_MACRO_CNTL                         0x0D04
#define DISP_PWR_MAN                           0x0D08
#define DISP_TEST_DEBUG_CNTL                   0x0D10
#define DISP_HW_DEBUG                          0x0D14
#define DAC_CRC_SIG1                           0x0D18
#define DAC_CRC_SIG2                           0x0D1C
#define OV0_LIN_TRANS_A                        0x0D20
#define OV0_LIN_TRANS_B                        0x0D24
#define OV0_LIN_TRANS_C                        0x0D28
#define OV0_LIN_TRANS_D                        0x0D2C
#define OV0_LIN_TRANS_E                        0x0D30
#define OV0_LIN_TRANS_F                        0x0D34
#define OV0_GAMMA_0_F                          0x0D40
#define OV0_GAMMA_10_1F                        0x0D44
#define OV0_GAMMA_20_3F                        0x0D48
#define OV0_GAMMA_40_7F                        0x0D4C
#define OV0_GAMMA_380_3BF                      0x0D50
#define OV0_GAMMA_3C0_3FF                      0x0D54
#define DISP_MERGE_CNTL                        0x0D60
#define DISP_OUTPUT_CNTL                       0x0D64
#define DISP_LIN_TRANS_GRPH_A                  0x0D80
#define DISP_LIN_TRANS_GRPH_B                  0x0D84
#define DISP_LIN_TRANS_GRPH_C                  0x0D88
#define DISP_LIN_TRANS_GRPH_D                  0x0D8C
#define DISP_LIN_TRANS_GRPH_E                  0x0D90
#define DISP_LIN_TRANS_GRPH_F                  0x0D94
#define DISP_LIN_TRANS_VID_A                   0x0D98
#define DISP_LIN_TRANS_VID_B                   0x0D9C
#define DISP_LIN_TRANS_VID_C                   0x0DA0
#define DISP_LIN_TRANS_VID_D                   0x0DA4
#define DISP_LIN_TRANS_VID_E                   0x0DA8
#define DISP_LIN_TRANS_VID_F                   0x0DAC
#define RMX_HORZ_FILTER_0TAP_COEF              0x0DB0
#define RMX_HORZ_FILTER_1TAP_COEF              0x0DB4
#define RMX_HORZ_FILTER_2TAP_COEF              0x0DB8
#define RMX_HORZ_PHASE                         0x0DBC
#define DAC_EMBEDDED_SYNC_CNTL                 0x0DC0
#define DAC_BROAD_PULSE                        0x0DC4
#define DAC_SKEW_CLKS                          0x0DC8
#define DAC_INCR                               0x0DCC
#define DAC_NEG_SYNC_LEVEL                     0x0DD0
#define DAC_POS_SYNC_LEVEL                     0x0DD4
#define DAC_BLANK_LEVEL                        0x0DD8
#define CLOCK_CNTL_INDEX                       0x0008
#define CLOCK_CNTL_DATA                        0x000C
#define CP_RB_CNTL                             0x0704
#define CP_RB_BASE                             0x0700
#define CP_RB_RPTR_ADDR                        0x070C
#define CP_RB_RPTR                             0x0710
#define CP_RB_WPTR                             0x0714
#define CP_RB_WPTR_DELAY                       0x0718
#define CP_IB_BASE                             0x0738
#define CP_IB_BUFSZ                            0x073C
#define SCRATCH_REG0                           0x15E0
#define GUI_SCRATCH_REG0                       0x15E0
#define SCRATCH_REG1                           0x15E4
#define GUI_SCRATCH_REG1                       0x15E4
#define SCRATCH_REG2                           0x15E8
#define GUI_SCRATCH_REG2                       0x15E8
#define SCRATCH_REG3                           0x15EC
#define GUI_SCRATCH_REG3                       0x15EC
#define SCRATCH_REG4                           0x15F0
#define GUI_SCRATCH_REG4                       0x15F0
#define SCRATCH_REG5                           0x15F4
#define GUI_SCRATCH_REG5                       0x15F4
#define SCRATCH_UMSK                           0x0770
#define SCRATCH_ADDR                           0x0774
#define DP_BRUSH_FRGD_CLR                      0x147C
#define DP_BRUSH_BKGD_CLR                      0x1478
#define DST_LINE_START                         0x1600
#define DST_LINE_END                           0x1604
#define SRC_OFFSET                             0x15AC
#define SRC_PITCH                              0x15B0
#define SRC_TILE                               0x1704
#define SRC_PITCH_OFFSET                       0x1428
#define SRC_X                                  0x1414
#define SRC_Y                                  0x1418
#define SRC_X_Y                                0x1590
#define SRC_Y_X                                0x1434
#define DST_Y_X				       0x1438
#define DST_WIDTH_HEIGHT		       0x1598
#define DST_HEIGHT_WIDTH		       0x143c
#define DST_OFFSET                             0x1404
#define SRC_CLUT_ADDRESS                       0x1780
#define SRC_CLUT_DATA                          0x1784
#define SRC_CLUT_DATA_RD                       0x1788
#define HOST_DATA0                             0x17C0
#define HOST_DATA1                             0x17C4
#define HOST_DATA2                             0x17C8
#define HOST_DATA3                             0x17CC
#define HOST_DATA4                             0x17D0
#define HOST_DATA5                             0x17D4
#define HOST_DATA6                             0x17D8
#define HOST_DATA7                             0x17DC
#define HOST_DATA_LAST                         0x17E0
#define DP_SRC_ENDIAN                          0x15D4
#define DP_SRC_FRGD_CLR                        0x15D8
#define DP_SRC_BKGD_CLR                        0x15DC
#define SC_LEFT                                0x1640
#define SC_RIGHT                               0x1644
#define SC_TOP                                 0x1648
#define SC_BOTTOM                              0x164C
#define SRC_SC_RIGHT                           0x1654
#define SRC_SC_BOTTOM                          0x165C
#define DP_CNTL                                0x16C0
#define DP_CNTL_XDIR_YDIR_YMAJOR               0x16D0
#define DP_DATATYPE                            0x16C4
#define DP_MIX                                 0x16C8
#define DP_WRITE_MSK                           0x16CC
#define DP_XOP                                 0x17F8
#define CLR_CMP_CLR_SRC                        0x15C4
#define CLR_CMP_CLR_DST                        0x15C8
#define CLR_CMP_CNTL                           0x15C0
#define CLR_CMP_MSK                            0x15CC
#define DSTCACHE_MODE                          0x1710
#define DSTCACHE_CTLSTAT                       0x1714
#define DEFAULT_PITCH_OFFSET                   0x16E0
#define DEFAULT_SC_BOTTOM_RIGHT                0x16E8
#define DEFAULT_SC_TOP_LEFT                    0x16EC
#define SRC_PITCH_OFFSET                       0x1428
#define DST_PITCH_OFFSET                       0x142C
#define DP_GUI_MASTER_CNTL                     0x146C
#define SC_TOP_LEFT                            0x16EC
#define SC_BOTTOM_RIGHT                        0x16F0
#define SRC_SC_BOTTOM_RIGHT                    0x16F4
#define RB2D_DSTCACHE_MODE		       0x3428
#define RB2D_DSTCACHE_CTLSTAT_broken	       0x342C /* do not use */
#define LVDS_GEN_CNTL			       0x02d0
#define LVDS_PLL_CNTL			       0x02d4
#define FP2_GEN_CNTL                           0x0288
#define TMDS_CNTL                              0x0294
#define TMDS_CRC			       0x02a0
#define TMDS_TRANSMITTER_CNTL		       0x02a4
#define MPP_TB_CONFIG            	       0x01c0
#define PAMAC0_DLY_CNTL                        0x0a94
#define PAMAC1_DLY_CNTL                        0x0a98
#define PAMAC2_DLY_CNTL                        0x0a9c
#define FW_CNTL                                0x0118
#define FCP_CNTL                               0x0910
#define VGA_DDA_ON_OFF                         0x02ec
#define TV_MASTER_CNTL                         0x0800

//#define BASE_CODE			       0x0f0b
#define BIOS_0_SCRATCH			       0x0010
#define BIOS_1_SCRATCH			       0x0014
#define BIOS_2_SCRATCH			       0x0018
#define BIOS_3_SCRATCH			       0x001c
#define BIOS_4_SCRATCH			       0x0020
#define BIOS_5_SCRATCH			       0x0024
#define BIOS_6_SCRATCH			       0x0028
#define BIOS_7_SCRATCH			       0x002c

#define HDP_SOFT_RESET                         (1 << 26)

#define TV_DAC_CNTL                            0x088c
#define GPIOPAD_MASK                           0x0198
#define GPIOPAD_A                              0x019c
#define GPIOPAD_EN                             0x01a0
#define GPIOPAD_Y                              0x01a4
#define ZV_LCDPAD_MASK                         0x01a8
#define ZV_LCDPAD_A                            0x01ac
#define ZV_LCDPAD_EN                           0x01b0
#define ZV_LCDPAD_Y                            0x01b4

/* PLL Registers */
#define CLK_PIN_CNTL                               0x0001
#define PPLL_CNTL                                  0x0002
#define PPLL_REF_DIV                               0x0003
#define PPLL_DIV_0                                 0x0004
#define PPLL_DIV_1                                 0x0005
#define PPLL_DIV_2                                 0x0006
#define PPLL_DIV_3                                 0x0007
#define VCLK_ECP_CNTL                              0x0008
#define HTOTAL_CNTL                                0x0009
#define M_SPLL_REF_FB_DIV                          0x000a
#define AGP_PLL_CNTL                               0x000b
#define SPLL_CNTL                                  0x000c
#define SCLK_CNTL                                  0x000d
#define MPLL_CNTL                                  0x000e
#define MDLL_CKO                                   0x000f
#define MDLL_RDCKA                                 0x0010
#define MCLK_CNTL                                  0x0012
#define AGP_PLL_CNTL                               0x000b
#define PLL_TEST_CNTL                              0x0013
#define CLK_PWRMGT_CNTL                            0x0014
#define PLL_PWRMGT_CNTL                            0x0015
#define MCLK_MISC                                  0x001f
#define P2PLL_CNTL                                 0x002a
#define P2PLL_REF_DIV                              0x002b
#define PIXCLKS_CNTL                               0x002d
#define SCLK_MORE_CNTL				   0x0035

/* MCLK_CNTL bit constants */
#define FORCEON_MCLKA				   (1 << 16)
#define FORCEON_MCLKB         		   	   (1 << 17)
#define FORCEON_YCLKA         	    	   	   (1 << 18)
#define FORCEON_YCLKB         		   	   (1 << 19)
#define FORCEON_MC            		   	   (1 << 20)
#define FORCEON_AIC           		   	   (1 << 21)

/* SCLK_CNTL bit constants */
#define DYN_STOP_LAT_MASK			   0x00007ff8
#define CP_MAX_DYN_STOP_LAT			   0x0008
#define SCLK_FORCEON_MASK			   0xffff8000

/* SCLK_MORE_CNTL bit constants */
#define SCLK_MORE_FORCEON			   0x0700

/* BUS_CNTL bit constants */
#define BUS_DBL_RESYNC                             0x00000001
#define BUS_MSTR_RESET                             0x00000002
#define BUS_FLUSH_BUF                              0x00000004
#define BUS_STOP_REQ_DIS                           0x00000008
#define BUS_ROTATION_DIS                           0x00000010
#define BUS_MASTER_DIS                             0x00000040
#define BUS_ROM_WRT_EN                             0x00000080
#define BUS_DIS_ROM                                0x00001000
#define BUS_PCI_READ_RETRY_EN                      0x00002000
#define BUS_AGP_AD_STEPPING_EN                     0x00004000
#define BUS_PCI_WRT_RETRY_EN                       0x00008000
#define BUS_MSTR_RD_MULT                           0x00100000
#define BUS_MSTR_RD_LINE                           0x00200000
#define BUS_SUSPEND                                0x00400000
#define LAT_16X                                    0x00800000
#define BUS_RD_DISCARD_EN                          0x01000000
#define BUS_RD_ABORT_EN                            0x02000000
#define BUS_MSTR_WS                                0x04000000
#define BUS_PARKING_DIS                            0x08000000
#define BUS_MSTR_DISCONNECT_EN                     0x10000000
#define BUS_WRT_BURST                              0x20000000
#define BUS_READ_BURST                             0x40000000
#define BUS_RDY_READ_DLY                           0x80000000

/* PIXCLKS_CNTL */
#define PIX2CLK_SRC_SEL_MASK                       0x03
#define PIX2CLK_SRC_SEL_CPUCLK                     0x00
#define PIX2CLK_SRC_SEL_PSCANCLK                   0x01
#define PIX2CLK_SRC_SEL_BYTECLK                    0x02
#define PIX2CLK_SRC_SEL_P2PLLCLK                   0x03
#define PIX2CLK_ALWAYS_ONb                         (1<<6)
#define PIX2CLK_DAC_ALWAYS_ONb                     (1<<7)
#define PIXCLK_TV_SRC_SEL                          (1 << 8)
#define PIXCLK_LVDS_ALWAYS_ONb                     (1 << 14)
#define PIXCLK_TMDS_ALWAYS_ONb                     (1 << 15)


/* CLOCK_CNTL_INDEX bit constants */
#define PLL_WR_EN                                  0x00000080

/* CNFG_CNTL bit constants */
#define CFG_VGA_RAM_EN                             0x00000100
#define CFG_ATI_REV_ID_MASK			   (0xf << 16)
#define CFG_ATI_REV_A11				   (0 << 16)
#define CFG_ATI_REV_A12				   (1 << 16)
#define CFG_ATI_REV_A13				   (2 << 16)

/* CRTC_EXT_CNTL bit constants */
#define VGA_ATI_LINEAR                             0x00000008
#define VGA_128KAP_PAGING                          0x00000010
#define	XCRT_CNT_EN				   (1 << 6)
#define CRTC_HSYNC_DIS				   (1 << 8)
#define CRTC_VSYNC_DIS				   (1 << 9)
#define CRTC_DISPLAY_DIS			   (1 << 10)
#define CRTC_CRT_ON				   (1 << 15)


/* DSTCACHE_CTLSTAT bit constants */
#define RB2D_DC_FLUSH_2D			   (1 << 0)
#define RB2D_DC_FREE_2D				   (1 << 2)
#define RB2D_DC_FLUSH_ALL			   (RB2D_DC_FLUSH_2D | RB2D_DC_FREE_2D)
#define RB2D_DC_BUSY				   (1 << 31)

/* DSTCACHE_MODE bits constants */
#define RB2D_DC_AUTOFLUSH_ENABLE                   (1 << 8)
#define RB2D_DC_DC_DISABLE_IGNORE_PE               (1 << 17)

/* CRTC_GEN_CNTL bit constants */
#define CRTC_DBL_SCAN_EN                           0x00000001
#define CRTC_CUR_EN                                0x00010000
#define CRTC_INTERLACE_EN			   (1 << 1)
#define CRTC_BYPASS_LUT_EN     			   (1 << 14)
#define CRTC_EXT_DISP_EN      			   (1 << 24)
#define CRTC_EN					   (1 << 25)
#define CRTC_DISP_REQ_EN_B                         (1 << 26)

/* CRTC_STATUS bit constants */
#define CRTC_VBLANK                                0x00000001

/* CRTC2_GEN_CNTL bit constants */
#define CRT2_ON                                    (1 << 7)
#define CRTC2_DISPLAY_DIS                          (1 << 23)
#define CRTC2_EN                                   (1 << 25)
#define CRTC2_DISP_REQ_EN_B                        (1 << 26)

/* CUR_OFFSET, CUR_HORZ_VERT_POSN, CUR_HORZ_VERT_OFF bit constants */
#define CUR_LOCK                                   0x80000000

/* GPIO bit constants */
#define GPIO_A_0		(1 <<  0)
#define GPIO_A_1		(1 <<  1)
#define GPIO_Y_0		(1 <<  8)
#define GPIO_Y_1		(1 <<  9)
#define GPIO_EN_0		(1 << 16)
#define GPIO_EN_1		(1 << 17)
#define GPIO_MASK_0		(1 << 24)
#define GPIO_MASK_1		(1 << 25)
#define VGA_DDC_DATA_OUTPUT	GPIO_A_0
#define VGA_DDC_CLK_OUTPUT	GPIO_A_1
#define VGA_DDC_DATA_INPUT	GPIO_Y_0
#define VGA_DDC_CLK_INPUT	GPIO_Y_1
#define VGA_DDC_DATA_OUT_EN	GPIO_EN_0
#define VGA_DDC_CLK_OUT_EN	GPIO_EN_1


/* FP bit constants */
#define FP_CRTC_H_TOTAL_MASK			   0x000003ff
#define FP_CRTC_H_DISP_MASK			   0x01ff0000
#define FP_CRTC_V_TOTAL_MASK			   0x00000fff
#define FP_CRTC_V_DISP_MASK			   0x0fff0000
#define FP_H_SYNC_STRT_CHAR_MASK		   0x00001ff8
#define FP_H_SYNC_WID_MASK			   0x003f0000
#define FP_V_SYNC_STRT_MASK			   0x00000fff
#define FP_V_SYNC_WID_MASK			   0x001f0000
#define FP_CRTC_H_TOTAL_SHIFT			   0x00000000
#define FP_CRTC_H_DISP_SHIFT			   0x00000010
#define FP_CRTC_V_TOTAL_SHIFT			   0x00000000
#define FP_CRTC_V_DISP_SHIFT			   0x00000010
#define FP_H_SYNC_STRT_CHAR_SHIFT		   0x00000003
#define FP_H_SYNC_WID_SHIFT			   0x00000010
#define FP_V_SYNC_STRT_SHIFT			   0x00000000
#define FP_V_SYNC_WID_SHIFT			   0x00000010

/* FP_GEN_CNTL bit constants */
#define FP_FPON					   (1 << 0)
#define FP_TMDS_EN				   (1 << 2)
#define FP_PANEL_FORMAT                            (1 << 3)
#define FP_EN_TMDS				   (1 << 7)
#define FP_DETECT_SENSE				   (1 << 8)
#define R200_FP_SOURCE_SEL_MASK                    (3 << 10)
#define R200_FP_SOURCE_SEL_CRTC1                   (0 << 10)
#define R200_FP_SOURCE_SEL_CRTC2                   (1 << 10)
#define R200_FP_SOURCE_SEL_RMX                     (2 << 10)
#define R200_FP_SOURCE_SEL_TRANS                   (3 << 10)
#define FP_SEL_CRTC1				   (0 << 13)
#define FP_SEL_CRTC2				   (1 << 13)
#define FP_USE_VGA_HSYNC                           (1 << 14)
#define FP_CRTC_DONT_SHADOW_HPAR		   (1 << 15)
#define FP_CRTC_DONT_SHADOW_VPAR		   (1 << 16)
#define FP_CRTC_DONT_SHADOW_HEND		   (1 << 17)
#define FP_CRTC_USE_SHADOW_VEND			   (1 << 18)
#define FP_RMX_HVSYNC_CONTROL_EN		   (1 << 20)
#define FP_DFP_SYNC_SEL				   (1 << 21)
#define FP_CRTC_LOCK_8DOT			   (1 << 22)
#define FP_CRT_SYNC_SEL				   (1 << 23)
#define FP_USE_SHADOW_EN			   (1 << 24)
#define FP_CRT_SYNC_ALT				   (1 << 26)

/* FP2_GEN_CNTL bit constants */
#define FP2_BLANK_EN             (1 <<  1)
#define FP2_ON                   (1 <<  2)
#define FP2_PANEL_FORMAT         (1 <<  3)
#define FP2_SOURCE_SEL_MASK      (3 << 10)
#define FP2_SOURCE_SEL_CRTC2     (1 << 10)
#define FP2_SRC_SEL_MASK         (3 << 13)
#define FP2_SRC_SEL_CRTC2        (1 << 13)
#define FP2_FP_POL               (1 << 16)
#define FP2_LP_POL               (1 << 17)
#define FP2_SCK_POL              (1 << 18)
#define FP2_LCD_CNTL_MASK        (7 << 19)
#define FP2_PAD_FLOP_EN          (1 << 22)
#define FP2_CRC_EN               (1 << 23)
#define FP2_CRC_READ_EN          (1 << 24)
#define FP2_DV0_EN               (1 << 25)
#define FP2_DV0_RATE_SEL_SDR     (1 << 26)


/* LVDS_GEN_CNTL bit constants */
#define LVDS_ON					   (1 << 0)
#define LVDS_DISPLAY_DIS			   (1 << 1)
#define LVDS_PANEL_TYPE				   (1 << 2)
#define LVDS_PANEL_FORMAT			   (1 << 3)
#define LVDS_EN					   (1 << 7)
#define LVDS_BL_MOD_LEVEL_MASK			   0x0000ff00
#define LVDS_BL_MOD_LEVEL_SHIFT			   8
#define LVDS_BL_MOD_EN				   (1 << 16)
#define LVDS_DIGON				   (1 << 18)
#define LVDS_BLON				   (1 << 19)
#define LVDS_SEL_CRTC2				   (1 << 23)
#define LVDS_STATE_MASK	\
	(LVDS_ON | LVDS_DISPLAY_DIS | LVDS_BL_MOD_LEVEL_MASK | LVDS_BLON)

/* LVDS_PLL_CNTL bit constatns */
#define HSYNC_DELAY_SHIFT			   0x1c
#define HSYNC_DELAY_MASK			   (0xf << 0x1c)

/* TMDS_TRANSMITTER_CNTL bit constants */
#define TMDS_PLL_EN				   (1 << 0)
#define TMDS_PLLRST				   (1 << 1)
#define TMDS_RAN_PAT_RST			   (1 << 7)
#define TMDS_ICHCSEL				   (1 << 28)

/* FP_HORZ_STRETCH bit constants */
#define HORZ_STRETCH_RATIO_MASK			   0xffff
#define HORZ_STRETCH_RATIO_MAX			   4096
#define HORZ_PANEL_SIZE				   (0x1ff << 16)
#define HORZ_PANEL_SHIFT			   16
#define HORZ_STRETCH_PIXREP			   (0 << 25)
#define HORZ_STRETCH_BLEND			   (1 << 26)
#define HORZ_STRETCH_ENABLE			   (1 << 25)
#define HORZ_AUTO_RATIO				   (1 << 27)
#define HORZ_FP_LOOP_STRETCH			   (0x7 << 28)
#define HORZ_AUTO_RATIO_INC			   (1 << 31)


/* FP_VERT_STRETCH bit constants */
#define VERT_STRETCH_RATIO_MASK			   0xfff
#define VERT_STRETCH_RATIO_MAX			   4096
#define VERT_PANEL_SIZE				   (0xfff << 12)
#define VERT_PANEL_SHIFT			   12
#define VERT_STRETCH_LINREP			   (0 << 26)
#define VERT_STRETCH_BLEND			   (1 << 26)
#define VERT_STRETCH_ENABLE			   (1 << 25)
#define VERT_AUTO_RATIO_EN			   (1 << 27)
#define VERT_FP_LOOP_STRETCH			   (0x7 << 28)
#define VERT_STRETCH_RESERVED			   0xf1000000

/* DAC_CNTL bit constants */
#define DAC_8BIT_EN                                0x00000100
#define DAC_4BPP_PIX_ORDER                         0x00000200
#define DAC_CRC_EN                                 0x00080000
#define DAC_MASK_ALL				   (0xff << 24)
#define DAC_PDWN                                   (1 << 15)
#define DAC_EXPAND_MODE				   (1 << 14)
#define DAC_VGA_ADR_EN				   (1 << 13)
#define DAC_RANGE_CNTL				   (3 <<  0)
#define DAC_RANGE_CNTL_MASK    			   0x03
#define DAC_BLANKING				   (1 <<  2)
#define DAC_CMP_EN                                 (1 <<  3)
#define DAC_CMP_OUTPUT                             (1 <<  7)

/* DAC_CNTL2 bit constants */
#define DAC2_EXPAND_MODE			   (1 << 14)
#define DAC2_CMP_EN                                (1 << 7)
#define DAC2_PALETTE_ACCESS_CNTL                   (1 << 5)

/* DAC_EXT_CNTL bit constants */
#define DAC_FORCE_BLANK_OFF_EN                     (1 << 4)
#define DAC_FORCE_DATA_EN                          (1 << 5)
#define DAC_FORCE_DATA_SEL_MASK                    (3 << 6)
#define DAC_FORCE_DATA_MASK                        0x0003ff00
#define DAC_FORCE_DATA_SHIFT                       8

/* GEN_RESET_CNTL bit constants */
#define SOFT_RESET_GUI                             0x00000001
#define SOFT_RESET_VCLK                            0x00000100
#define SOFT_RESET_PCLK                            0x00000200
#define SOFT_RESET_ECP                             0x00000400
#define SOFT_RESET_DISPENG_XCLK                    0x00000800

/* MEM_CNTL bit constants */
#define MEM_CTLR_STATUS_IDLE                       0x00000000
#define MEM_CTLR_STATUS_BUSY                       0x00100000
#define MEM_SEQNCR_STATUS_IDLE                     0x00000000
#define MEM_SEQNCR_STATUS_BUSY                     0x00200000
#define MEM_ARBITER_STATUS_IDLE                    0x00000000
#define MEM_ARBITER_STATUS_BUSY                    0x00400000
#define MEM_REQ_UNLOCK                             0x00000000
#define MEM_REQ_LOCK                               0x00800000
#define MEM_NUM_CHANNELS_MASK 			   0x00000001
#define MEM_USE_B_CH_ONLY                          0x00000002
#define RV100_MEM_HALF_MODE                        0x00000008
#define R300_MEM_NUM_CHANNELS_MASK                 0x00000003
#define R300_MEM_USE_CD_CH_ONLY                    0x00000004


/* RBBM_SOFT_RESET bit constants */
#define SOFT_RESET_CP           		   (1 <<  0)
#define SOFT_RESET_HI           		   (1 <<  1)
#define SOFT_RESET_SE           		   (1 <<  2)
#define SOFT_RESET_RE           		   (1 <<  3)
#define SOFT_RESET_PP           		   (1 <<  4)
#define SOFT_RESET_E2           		   (1 <<  5)
#define SOFT_RESET_RB           		   (1 <<  6)
#define SOFT_RESET_HDP          		   (1 <<  7)

/* WAIT_UNTIL bit constants */
#define WAIT_DMA_GUI_IDLE			   (1 << 9)
#define WAIT_2D_IDLECLEAN			   (1 << 16)

/* SURFACE_CNTL bit consants */
#define SURF_TRANSLATION_DIS			   (1 << 8)
#define NONSURF_AP0_SWP_16BPP			   (1 << 20)
#define NONSURF_AP0_SWP_32BPP			   (1 << 21)
#define NONSURF_AP1_SWP_16BPP			   (1 << 22)
#define NONSURF_AP1_SWP_32BPP			   (1 << 23)

/* DEFAULT_SC_BOTTOM_RIGHT bit constants */
#define DEFAULT_SC_RIGHT_MAX			   (0x1fff << 0)
#define DEFAULT_SC_BOTTOM_MAX			   (0x1fff << 16)

/* MM_INDEX bit constants */
#define MM_APER                                    0x80000000

/* CLR_CMP_CNTL bit constants */
#define COMPARE_SRC_FALSE                          0x00000000
#define COMPARE_SRC_TRUE                           0x00000001
#define COMPARE_SRC_NOT_EQUAL                      0x00000004
#define COMPARE_SRC_EQUAL                          0x00000005
#define COMPARE_SRC_EQUAL_FLIP                     0x00000007
#define COMPARE_DST_FALSE                          0x00000000
#define COMPARE_DST_TRUE                           0x00000100
#define COMPARE_DST_NOT_EQUAL                      0x00000400
#define COMPARE_DST_EQUAL                          0x00000500
#define COMPARE_DESTINATION                        0x00000000
#define COMPARE_SOURCE                             0x01000000
#define COMPARE_SRC_AND_DST                        0x02000000


/* DP_CNTL bit constants */
#define DST_X_RIGHT_TO_LEFT                        0x00000000
#define DST_X_LEFT_TO_RIGHT                        0x00000001
#define DST_Y_BOTTOM_TO_TOP                        0x00000000
#define DST_Y_TOP_TO_BOTTOM                        0x00000002
#define DST_X_MAJOR                                0x00000000
#define DST_Y_MAJOR                                0x00000004
#define DST_X_TILE                                 0x00000008
#define DST_Y_TILE                                 0x00000010
#define DST_LAST_PEL                               0x00000020
#define DST_TRAIL_X_RIGHT_TO_LEFT                  0x00000000
#define DST_TRAIL_X_LEFT_TO_RIGHT                  0x00000040
#define DST_TRAP_FILL_RIGHT_TO_LEFT                0x00000000
#define DST_TRAP_FILL_LEFT_TO_RIGHT                0x00000080
#define DST_BRES_SIGN                              0x00000100
#define DST_HOST_BIG_ENDIAN_EN                     0x00000200
#define DST_POLYLINE_NONLAST                       0x00008000
#define DST_RASTER_STALL                           0x00010000
#define DST_POLY_EDGE                              0x00040000


/* DP_CNTL_YDIR_XDIR_YMAJOR bit constants (short version of DP_CNTL) */
#define DST_X_MAJOR_S                              0x00000000
#define DST_Y_MAJOR_S                              0x00000001
#define DST_Y_BOTTOM_TO_TOP_S                      0x00000000
#define DST_Y_TOP_TO_BOTTOM_S                      0x00008000
#define DST_X_RIGHT_TO_LEFT_S                      0x00000000
#define DST_X_LEFT_TO_RIGHT_S                      0x80000000


/* DP_DATATYPE bit constants */
#define DST_8BPP                                   0x00000002
#define DST_15BPP                                  0x00000003
#define DST_16BPP                                  0x00000004
#define DST_24BPP                                  0x00000005
#define DST_32BPP                                  0x00000006
#define DST_8BPP_RGB332                            0x00000007
#define DST_8BPP_Y8                                0x00000008
#define DST_8BPP_RGB8                              0x00000009
#define DST_16BPP_VYUY422                          0x0000000b
#define DST_16BPP_YVYU422                          0x0000000c
#define DST_32BPP_AYUV444                          0x0000000e
#define DST_16BPP_ARGB4444                         0x0000000f
#define BRUSH_SOLIDCOLOR                           0x00000d00
#define SRC_MONO                                   0x00000000
#define SRC_MONO_LBKGD                             0x00010000
#define SRC_DSTCOLOR                               0x00030000
#define BYTE_ORDER_MSB_TO_LSB                      0x00000000
#define BYTE_ORDER_LSB_TO_MSB                      0x40000000
#define DP_CONVERSION_TEMP                         0x80000000
#define HOST_BIG_ENDIAN_EN			   (1 << 29)


/* DP_GUI_MASTER_CNTL bit constants */
#define GMC_SRC_PITCH_OFFSET_DEFAULT               0x00000000
#define GMC_SRC_PITCH_OFFSET_LEAVE                 0x00000001
#define GMC_DST_PITCH_OFFSET_DEFAULT               0x00000000
#define GMC_DST_PITCH_OFFSET_LEAVE                 0x00000002
#define GMC_SRC_CLIP_DEFAULT                       0x00000000
#define GMC_SRC_CLIP_LEAVE                         0x00000004
#define GMC_DST_CLIP_DEFAULT                       0x00000000
#define GMC_DST_CLIP_LEAVE                         0x00000008
#define GMC_BRUSH_8x8MONO                          0x00000000
#define GMC_BRUSH_8x8MONO_LBKGD                    0x00000010
#define GMC_BRUSH_8x1MONO                          0x00000020
#define GMC_BRUSH_8x1MONO_LBKGD                    0x00000030
#define GMC_BRUSH_1x8MONO                          0x00000040
#define GMC_BRUSH_1x8MONO_LBKGD                    0x00000050
#define GMC_BRUSH_32x1MONO                         0x00000060
#define GMC_BRUSH_32x1MONO_LBKGD                   0x00000070
#define GMC_BRUSH_32x32MONO                        0x00000080
#define GMC_BRUSH_32x32MONO_LBKGD                  0x00000090
#define GMC_BRUSH_8x8COLOR                         0x000000a0
#define GMC_BRUSH_8x1COLOR                         0x000000b0
#define GMC_BRUSH_1x8COLOR                         0x000000c0
#define GMC_BRUSH_SOLID_COLOR                       0x000000d0
#define GMC_DST_8BPP                               0x00000200
#define GMC_DST_15BPP                              0x00000300
#define GMC_DST_16BPP                              0x00000400
#define GMC_DST_24BPP                              0x00000500
#define GMC_DST_32BPP                              0x00000600
#define GMC_DST_8BPP_RGB332                        0x00000700
#define GMC_DST_8BPP_Y8                            0x00000800
#define GMC_DST_8BPP_RGB8                          0x00000900
#define GMC_DST_16BPP_VYUY422                      0x00000b00
#define GMC_DST_16BPP_YVYU422                      0x00000c00
#define GMC_DST_32BPP_AYUV444                      0x00000e00
#define GMC_DST_16BPP_ARGB4444                     0x00000f00
#define GMC_SRC_MONO                               0x00000000
#define GMC_SRC_MONO_LBKGD                         0x00001000
#define GMC_SRC_DSTCOLOR                           0x00003000
#define GMC_BYTE_ORDER_MSB_TO_LSB                  0x00000000
#define GMC_BYTE_ORDER_LSB_TO_MSB                  0x00004000
#define GMC_DP_CONVERSION_TEMP_9300                0x00008000
#define GMC_DP_CONVERSION_TEMP_6500                0x00000000
#define GMC_DP_SRC_RECT                            0x02000000
#define GMC_DP_SRC_HOST                            0x03000000
#define GMC_DP_SRC_HOST_BYTEALIGN                  0x04000000
#define GMC_3D_FCN_EN_CLR                          0x00000000
#define GMC_3D_FCN_EN_SET                          0x08000000
#define GMC_DST_CLR_CMP_FCN_LEAVE                  0x00000000
#define GMC_DST_CLR_CMP_FCN_CLEAR                  0x10000000
#define GMC_AUX_CLIP_LEAVE                         0x00000000
#define GMC_AUX_CLIP_CLEAR                         0x20000000
#define GMC_WRITE_MASK_LEAVE                       0x00000000
#define GMC_WRITE_MASK_SET                         0x40000000
#define GMC_CLR_CMP_CNTL_DIS      		   (1 << 28)
#define GMC_SRC_DATATYPE_COLOR			   (3 << 12)
#define ROP3_S                			   0x00cc0000
#define ROP3_SRCCOPY				   0x00cc0000
#define ROP3_P                			   0x00f00000
#define ROP3_PATCOPY				   0x00f00000
#define DP_SRC_SOURCE_MASK        		   (7    << 24)
#define GMC_BRUSH_NONE            		   (15   <<  4)
#define DP_SRC_SOURCE_MEMORY			   (2    << 24)
#define GMC_BRUSH_SOLIDCOLOR			   0x000000d0

/* DP_MIX bit constants */
#define DP_SRC_RECT                                0x00000200
#define DP_SRC_HOST                                0x00000300
#define DP_SRC_HOST_BYTEALIGN                      0x00000400

/* MPLL_CNTL bit constants */
#define MPLL_RESET                                 0x00000001

/* MDLL_CKO bit constants */
#define MCKOA_SLEEP                                0x00000001
#define MCKOA_RESET                                0x00000002
#define MCKOA_REF_SKEW_MASK                        0x00000700
#define MCKOA_FB_SKEW_MASK                         0x00007000

/* MDLL_RDCKA bit constants */
#define MRDCKA0_SLEEP                              0x00000001
#define MRDCKA0_RESET                              0x00000002
#define MRDCKA1_SLEEP                              0x00010000
#define MRDCKA1_RESET                              0x00020000

/* VCLK_ECP_CNTL constants */
#define VCLK_SRC_SEL_MASK                          0x03
#define VCLK_SRC_SEL_CPUCLK                        0x00
#define VCLK_SRC_SEL_PSCANCLK                      0x01
#define VCLK_SRC_SEL_BYTECLK	                   0x02
#define VCLK_SRC_SEL_PPLLCLK			   0x03
#define PIXCLK_ALWAYS_ONb                          0x00000040
#define PIXCLK_DAC_ALWAYS_ONb                      0x00000080

/* BUS_CNTL1 constants */
#define BUS_CNTL1_MOBILE_PLATFORM_SEL_MASK         0x0c000000
#define BUS_CNTL1_MOBILE_PLATFORM_SEL_SHIFT        26
#define BUS_CNTL1_AGPCLK_VALID                     0x80000000

/* PLL_PWRMGT_CNTL constants */
#define PLL_PWRMGT_CNTL_SPLL_TURNOFF               0x00000002
#define PLL_PWRMGT_CNTL_PPLL_TURNOFF               0x00000004
#define PLL_PWRMGT_CNTL_P2PLL_TURNOFF              0x00000008
#define PLL_PWRMGT_CNTL_TVPLL_TURNOFF              0x00000010
#define PLL_PWRMGT_CNTL_MOBILE_SU                  0x00010000
#define PLL_PWRMGT_CNTL_SU_SCLK_USE_BCLK           0x00020000
#define PLL_PWRMGT_CNTL_SU_MCLK_USE_BCLK           0x00040000

/* TV_DAC_CNTL constants */
#define TV_DAC_CNTL_BGSLEEP                        0x00000040
#define TV_DAC_CNTL_DETECT                         0x00000010
#define TV_DAC_CNTL_BGADJ_MASK                     0x000f0000
#define TV_DAC_CNTL_DACADJ_MASK                    0x00f00000
#define TV_DAC_CNTL_BGADJ__SHIFT                   16
#define TV_DAC_CNTL_DACADJ__SHIFT                  20
#define TV_DAC_CNTL_RDACPD                         0x01000000
#define TV_DAC_CNTL_GDACPD                         0x02000000
#define TV_DAC_CNTL_BDACPD                         0x04000000

/* DISP_MISC_CNTL constants */
#define DISP_MISC_CNTL_SOFT_RESET_GRPH_PP          (1 << 0)
#define DISP_MISC_CNTL_SOFT_RESET_SUBPIC_PP        (1 << 1)
#define DISP_MISC_CNTL_SOFT_RESET_OV0_PP           (1 << 2)
#define DISP_MISC_CNTL_SOFT_RESET_GRPH_SCLK        (1 << 4)
#define DISP_MISC_CNTL_SOFT_RESET_SUBPIC_SCLK      (1 << 5)
#define DISP_MISC_CNTL_SOFT_RESET_OV0_SCLK         (1 << 6)
#define DISP_MISC_CNTL_SOFT_RESET_GRPH2_PP         (1 << 12)
#define DISP_MISC_CNTL_SOFT_RESET_GRPH2_SCLK       (1 << 15)
#define DISP_MISC_CNTL_SOFT_RESET_LVDS             (1 << 16)
#define DISP_MISC_CNTL_SOFT_RESET_TMDS             (1 << 17)
#define DISP_MISC_CNTL_SOFT_RESET_DIG_TMDS         (1 << 18)
#define DISP_MISC_CNTL_SOFT_RESET_TV               (1 << 19)

/* DISP_PWR_MAN constants */
#define DISP_PWR_MAN_DISP_PWR_MAN_D3_CRTC_EN       (1 << 0)
#define DISP_PWR_MAN_DISP2_PWR_MAN_D3_CRTC2_EN     (1 << 4)
#define DISP_PWR_MAN_DISP_D3_RST                   (1 << 16)
#define DISP_PWR_MAN_DISP_D3_REG_RST               (1 << 17)
#define DISP_PWR_MAN_DISP_D3_GRPH_RST              (1 << 18)
#define DISP_PWR_MAN_DISP_D3_SUBPIC_RST            (1 << 19)
#define DISP_PWR_MAN_DISP_D3_OV0_RST               (1 << 20)
#define DISP_PWR_MAN_DISP_D1D2_GRPH_RST            (1 << 21)
#define DISP_PWR_MAN_DISP_D1D2_SUBPIC_RST          (1 << 22)
#define DISP_PWR_MAN_DISP_D1D2_OV0_RST             (1 << 23)
#define DISP_PWR_MAN_DIG_TMDS_ENABLE_RST           (1 << 24)
#define DISP_PWR_MAN_TV_ENABLE_RST                 (1 << 25)
#define DISP_PWR_MAN_AUTO_PWRUP_EN                 (1 << 26)

/* masks */

#define CNFG_MEMSIZE_MASK		0x1f000000
#define MEM_CFG_TYPE			0x40000000
#define DST_OFFSET_MASK			0x003fffff
#define DST_PITCH_MASK			0x3fc00000
#define DEFAULT_TILE_MASK		0xc0000000
#define	PPLL_DIV_SEL_MASK		0x00000300
#define	PPLL_RESET			0x00000001
#define	PPLL_SLEEP			0x00000002
#define PPLL_ATOMIC_UPDATE_EN		0x00010000
#define PPLL_REF_DIV_MASK		0x000003ff
#define	PPLL_FB3_DIV_MASK		0x000007ff
#define	PPLL_POST3_DIV_MASK		0x00070000
#define PPLL_ATOMIC_UPDATE_R		0x00008000
#define PPLL_ATOMIC_UPDATE_W		0x00008000
#define	PPLL_VGA_ATOMIC_UPDATE_EN	0x00020000
#define R300_PPLL_REF_DIV_ACC_MASK	(0x3ff << 18)
#define R300_PPLL_REF_DIV_ACC_SHIFT	18

#define GUI_ACTIVE			0x80000000


#define MC_IND_INDEX                           0x01F8
#define MC_IND_DATA                            0x01FC

/* PAD_CTLR_STRENGTH */
#define PAD_MANUAL_OVERRIDE		0x80000000

// pllCLK_PIN_CNTL
#define CLK_PIN_CNTL__OSC_EN_MASK                          0x00000001L
#define CLK_PIN_CNTL__OSC_EN                               0x00000001L
#define CLK_PIN_CNTL__XTL_LOW_GAIN_MASK                    0x00000004L
#define CLK_PIN_CNTL__XTL_LOW_GAIN                         0x00000004L
#define CLK_PIN_CNTL__DONT_USE_XTALIN_MASK                 0x00000010L
#define CLK_PIN_CNTL__DONT_USE_XTALIN                      0x00000010L
#define CLK_PIN_CNTL__SLOW_CLOCK_SOURCE_MASK               0x00000020L
#define CLK_PIN_CNTL__SLOW_CLOCK_SOURCE                    0x00000020L
#define CLK_PIN_CNTL__CG_CLK_TO_OUTPIN_MASK                0x00000800L
#define CLK_PIN_CNTL__CG_CLK_TO_OUTPIN                     0x00000800L
#define CLK_PIN_CNTL__CG_COUNT_UP_TO_OUTPIN_MASK           0x00001000L
#define CLK_PIN_CNTL__CG_COUNT_UP_TO_OUTPIN                0x00001000L
#define CLK_PIN_CNTL__ACCESS_REGS_IN_SUSPEND_MASK          0x00002000L
#define CLK_PIN_CNTL__ACCESS_REGS_IN_SUSPEND               0x00002000L
#define CLK_PIN_CNTL__CG_SPARE_MASK                        0x00004000L
#define CLK_PIN_CNTL__CG_SPARE                             0x00004000L
#define CLK_PIN_CNTL__SCLK_DYN_START_CNTL_MASK             0x00008000L
#define CLK_PIN_CNTL__SCLK_DYN_START_CNTL                  0x00008000L
#define CLK_PIN_CNTL__CP_CLK_RUNNING_MASK                  0x00010000L
#define CLK_PIN_CNTL__CP_CLK_RUNNING                       0x00010000L
#define CLK_PIN_CNTL__CG_SPARE_RD_MASK                     0x00060000L
#define CLK_PIN_CNTL__XTALIN_ALWAYS_ONb_MASK               0x00080000L
#define CLK_PIN_CNTL__XTALIN_ALWAYS_ONb                    0x00080000L
#define CLK_PIN_CNTL__PWRSEQ_DELAY_MASK                    0xff000000L

// pllCLK_PWRMGT_CNTL
#define	CLK_PWRMGT_CNTL__MPLL_PWRMGT_OFF__SHIFT         0x00000000
#define	CLK_PWRMGT_CNTL__SPLL_PWRMGT_OFF__SHIFT         0x00000001
#define	CLK_PWRMGT_CNTL__PPLL_PWRMGT_OFF__SHIFT         0x00000002
#define	CLK_PWRMGT_CNTL__P2PLL_PWRMGT_OFF__SHIFT        0x00000003
#define	CLK_PWRMGT_CNTL__MCLK_TURNOFF__SHIFT            0x00000004
#define	CLK_PWRMGT_CNTL__SCLK_TURNOFF__SHIFT            0x00000005
#define	CLK_PWRMGT_CNTL__PCLK_TURNOFF__SHIFT            0x00000006
#define	CLK_PWRMGT_CNTL__P2CLK_TURNOFF__SHIFT           0x00000007
#define	CLK_PWRMGT_CNTL__MC_CH_MODE__SHIFT              0x00000008
#define	CLK_PWRMGT_CNTL__TEST_MODE__SHIFT               0x00000009
#define	CLK_PWRMGT_CNTL__GLOBAL_PMAN_EN__SHIFT          0x0000000a
#define	CLK_PWRMGT_CNTL__ENGINE_DYNCLK_MODE__SHIFT      0x0000000c
#define	CLK_PWRMGT_CNTL__ACTIVE_HILO_LAT__SHIFT         0x0000000d
#define	CLK_PWRMGT_CNTL__DISP_DYN_STOP_LAT__SHIFT       0x0000000f
#define	CLK_PWRMGT_CNTL__MC_BUSY__SHIFT                 0x00000010
#define	CLK_PWRMGT_CNTL__MC_INT_CNTL__SHIFT             0x00000011
#define	CLK_PWRMGT_CNTL__MC_SWITCH__SHIFT               0x00000012
#define	CLK_PWRMGT_CNTL__DLL_READY__SHIFT               0x00000013
#define	CLK_PWRMGT_CNTL__DISP_PM__SHIFT                 0x00000014
#define	CLK_PWRMGT_CNTL__DYN_STOP_MODE__SHIFT           0x00000015
#define	CLK_PWRMGT_CNTL__CG_NO1_DEBUG__SHIFT            0x00000018
#define	CLK_PWRMGT_CNTL__TVPLL_PWRMGT_OFF__SHIFT        0x0000001e
#define	CLK_PWRMGT_CNTL__TVCLK_TURNOFF__SHIFT           0x0000001f

// pllP2PLL_CNTL
#define P2PLL_CNTL__P2PLL_RESET_MASK                       0x00000001L
#define P2PLL_CNTL__P2PLL_RESET                            0x00000001L
#define P2PLL_CNTL__P2PLL_SLEEP_MASK                       0x00000002L
#define P2PLL_CNTL__P2PLL_SLEEP                            0x00000002L
#define P2PLL_CNTL__P2PLL_TST_EN_MASK                      0x00000004L
#define P2PLL_CNTL__P2PLL_TST_EN                           0x00000004L
#define P2PLL_CNTL__P2PLL_REFCLK_SEL_MASK                  0x00000010L
#define P2PLL_CNTL__P2PLL_REFCLK_SEL                       0x00000010L
#define P2PLL_CNTL__P2PLL_FBCLK_SEL_MASK                   0x00000020L
#define P2PLL_CNTL__P2PLL_FBCLK_SEL                        0x00000020L
#define P2PLL_CNTL__P2PLL_TCPOFF_MASK                      0x00000040L
#define P2PLL_CNTL__P2PLL_TCPOFF                           0x00000040L
#define P2PLL_CNTL__P2PLL_TVCOMAX_MASK                     0x00000080L
#define P2PLL_CNTL__P2PLL_TVCOMAX                          0x00000080L
#define P2PLL_CNTL__P2PLL_PCP_MASK                         0x00000700L
#define P2PLL_CNTL__P2PLL_PVG_MASK                         0x00003800L
#define P2PLL_CNTL__P2PLL_PDC_MASK                         0x0000c000L
#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_EN_MASK            0x00010000L
#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_EN                 0x00010000L
#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_SYNC_MASK          0x00040000L
#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_SYNC               0x00040000L
#define P2PLL_CNTL__P2PLL_DISABLE_AUTO_RESET_MASK          0x00080000L
#define P2PLL_CNTL__P2PLL_DISABLE_AUTO_RESET               0x00080000L

// pllPIXCLKS_CNTL
#define	PIXCLKS_CNTL__PIX2CLK_SRC_SEL__SHIFT               0x00000000
#define	PIXCLKS_CNTL__PIX2CLK_INVERT__SHIFT                0x00000004
#define	PIXCLKS_CNTL__PIX2CLK_SRC_INVERT__SHIFT            0x00000005
#define	PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb__SHIFT            0x00000006
#define	PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb__SHIFT        0x00000007
#define	PIXCLKS_CNTL__PIXCLK_TV_SRC_SEL__SHIFT             0x00000008
#define	PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb__SHIFT       0x0000000b
#define	PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb__SHIFT          0x0000000c
#define	PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb__SHIFT    0x0000000d
#define	PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb__SHIFT        0x0000000e
#define	PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb__SHIFT        0x0000000f


// pllPIXCLKS_CNTL
#define PIXCLKS_CNTL__PIX2CLK_SRC_SEL_MASK                 0x00000003L
#define PIXCLKS_CNTL__PIX2CLK_INVERT                       0x00000010L
#define PIXCLKS_CNTL__PIX2CLK_SRC_INVERT                   0x00000020L
#define PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb                   0x00000040L
#define PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb               0x00000080L
#define PIXCLKS_CNTL__PIXCLK_TV_SRC_SEL                    0x00000100L
#define PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb              0x00000800L
#define PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb                 0x00001000L
#define PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb           0x00002000L
#define PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb               0x00004000L
#define PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb               0x00008000L
#define PIXCLKS_CNTL__DISP_TVOUT_PIXCLK_TV_ALWAYS_ONb      (1 << 9)
#define PIXCLKS_CNTL__R300_DVOCLK_ALWAYS_ONb               (1 << 10)
#define PIXCLKS_CNTL__R300_PIXCLK_DVO_ALWAYS_ONb           (1 << 13)
#define PIXCLKS_CNTL__R300_PIXCLK_TRANS_ALWAYS_ONb         (1 << 16)
#define PIXCLKS_CNTL__R300_PIXCLK_TVO_ALWAYS_ONb           (1 << 17)
#define PIXCLKS_CNTL__R300_P2G2CLK_ALWAYS_ONb              (1 << 18)
#define PIXCLKS_CNTL__R300_P2G2CLK_DAC_ALWAYS_ONb          (1 << 19)
#define PIXCLKS_CNTL__R300_DISP_DAC_PIXCLK_DAC2_BLANK_OFF  (1 << 23)


// pllP2PLL_DIV_0
#define P2PLL_DIV_0__P2PLL_FB_DIV_MASK                     0x000007ffL
#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_W_MASK            0x00008000L
#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_W                 0x00008000L
#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_R_MASK            0x00008000L
#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_R                 0x00008000L
#define P2PLL_DIV_0__P2PLL_POST_DIV_MASK                   0x00070000L

// pllSCLK_CNTL
#define SCLK_CNTL__SCLK_SRC_SEL_MASK                    0x00000007L
#define SCLK_CNTL__CP_MAX_DYN_STOP_LAT                  0x00000008L
#define SCLK_CNTL__HDP_MAX_DYN_STOP_LAT                 0x00000010L
#define SCLK_CNTL__TV_MAX_DYN_STOP_LAT                  0x00000020L
#define SCLK_CNTL__E2_MAX_DYN_STOP_LAT                  0x00000040L
#define SCLK_CNTL__SE_MAX_DYN_STOP_LAT                  0x00000080L
#define SCLK_CNTL__IDCT_MAX_DYN_STOP_LAT                0x00000100L
#define SCLK_CNTL__VIP_MAX_DYN_STOP_LAT                 0x00000200L
#define SCLK_CNTL__RE_MAX_DYN_STOP_LAT                  0x00000400L
#define SCLK_CNTL__PB_MAX_DYN_STOP_LAT                  0x00000800L
#define SCLK_CNTL__TAM_MAX_DYN_STOP_LAT                 0x00001000L
#define SCLK_CNTL__TDM_MAX_DYN_STOP_LAT                 0x00002000L
#define SCLK_CNTL__RB_MAX_DYN_STOP_LAT                  0x00004000L
#define SCLK_CNTL__DYN_STOP_LAT_MASK                     0x00007ff8
#define SCLK_CNTL__FORCE_DISP2                          0x00008000L
#define SCLK_CNTL__FORCE_CP                             0x00010000L
#define SCLK_CNTL__FORCE_HDP                            0x00020000L
#define SCLK_CNTL__FORCE_DISP1                          0x00040000L
#define SCLK_CNTL__FORCE_TOP                            0x00080000L
#define SCLK_CNTL__FORCE_E2                             0x00100000L
#define SCLK_CNTL__FORCE_SE                             0x00200000L
#define SCLK_CNTL__FORCE_IDCT                           0x00400000L
#define SCLK_CNTL__FORCE_VIP                            0x00800000L
#define SCLK_CNTL__FORCE_RE                             0x01000000L
#define SCLK_CNTL__FORCE_PB                             0x02000000L
#define SCLK_CNTL__FORCE_TAM                            0x04000000L
#define SCLK_CNTL__FORCE_TDM                            0x08000000L
#define SCLK_CNTL__FORCE_RB                             0x10000000L
#define SCLK_CNTL__FORCE_TV_SCLK                        0x20000000L
#define SCLK_CNTL__FORCE_SUBPIC                         0x40000000L
#define SCLK_CNTL__FORCE_OV0                            0x80000000L
#define SCLK_CNTL__R300_FORCE_VAP                       (1<<21)
#define SCLK_CNTL__R300_FORCE_SR                        (1<<25)
#define SCLK_CNTL__R300_FORCE_PX                        (1<<26)
#define SCLK_CNTL__R300_FORCE_TX                        (1<<27)
#define SCLK_CNTL__R300_FORCE_US                        (1<<28)
#define SCLK_CNTL__R300_FORCE_SU                        (1<<30)
#define SCLK_CNTL__FORCEON_MASK                         0xffff8000L

// pllSCLK_CNTL2
#define SCLK_CNTL2__R300_TCL_MAX_DYN_STOP_LAT           (1<<10)
#define SCLK_CNTL2__R300_GA_MAX_DYN_STOP_LAT            (1<<11)
#define SCLK_CNTL2__R300_CBA_MAX_DYN_STOP_LAT           (1<<12)
#define SCLK_CNTL2__R300_FORCE_TCL                      (1<<13)
#define SCLK_CNTL2__R300_FORCE_CBA                      (1<<14)
#define SCLK_CNTL2__R300_FORCE_GA                       (1<<15)

// SCLK_MORE_CNTL
#define SCLK_MORE_CNTL__DISPREGS_MAX_DYN_STOP_LAT          0x00000001L
#define SCLK_MORE_CNTL__MC_GUI_MAX_DYN_STOP_LAT            0x00000002L
#define SCLK_MORE_CNTL__MC_HOST_MAX_DYN_STOP_LAT           0x00000004L
#define SCLK_MORE_CNTL__FORCE_DISPREGS                     0x00000100L
#define SCLK_MORE_CNTL__FORCE_MC_GUI                       0x00000200L
#define SCLK_MORE_CNTL__FORCE_MC_HOST                      0x00000400L
#define SCLK_MORE_CNTL__STOP_SCLK_EN                       0x00001000L
#define SCLK_MORE_CNTL__STOP_SCLK_A                        0x00002000L
#define SCLK_MORE_CNTL__STOP_SCLK_B                        0x00004000L
#define SCLK_MORE_CNTL__STOP_SCLK_C                        0x00008000L
#define SCLK_MORE_CNTL__HALF_SPEED_SCLK                    0x00010000L
#define SCLK_MORE_CNTL__IO_CG_VOLTAGE_DROP                 0x00020000L
#define SCLK_MORE_CNTL__TVFB_SOFT_RESET                    0x00040000L
#define SCLK_MORE_CNTL__VOLTAGE_DROP_SYNC                  0x00080000L
#define SCLK_MORE_CNTL__IDLE_DELAY_HALF_SCLK               0x00400000L
#define SCLK_MORE_CNTL__AGP_BUSY_HALF_SCLK                 0x00800000L
#define SCLK_MORE_CNTL__CG_SPARE_RD_C_MASK                 0xff000000L
#define SCLK_MORE_CNTL__FORCEON                            0x00000700L

// MCLK_CNTL
#define MCLK_CNTL__MCLKA_SRC_SEL_MASK                   0x00000007L
#define MCLK_CNTL__YCLKA_SRC_SEL_MASK                   0x00000070L
#define MCLK_CNTL__MCLKB_SRC_SEL_MASK                   0x00000700L
#define MCLK_CNTL__YCLKB_SRC_SEL_MASK                   0x00007000L
#define MCLK_CNTL__FORCE_MCLKA_MASK                     0x00010000L
#define MCLK_CNTL__FORCE_MCLKA                          0x00010000L
#define MCLK_CNTL__FORCE_MCLKB_MASK                     0x00020000L
#define MCLK_CNTL__FORCE_MCLKB                          0x00020000L
#define MCLK_CNTL__FORCE_YCLKA_MASK                     0x00040000L
#define MCLK_CNTL__FORCE_YCLKA                          0x00040000L
#define MCLK_CNTL__FORCE_YCLKB_MASK                     0x00080000L
#define MCLK_CNTL__FORCE_YCLKB                          0x00080000L
#define MCLK_CNTL__FORCE_MC_MASK                        0x00100000L
#define MCLK_CNTL__FORCE_MC                             0x00100000L
#define MCLK_CNTL__FORCE_AIC_MASK                       0x00200000L
#define MCLK_CNTL__FORCE_AIC                            0x00200000L
#define MCLK_CNTL__MRDCKA0_SOUTSEL_MASK                 0x03000000L
#define MCLK_CNTL__MRDCKA1_SOUTSEL_MASK                 0x0c000000L
#define MCLK_CNTL__MRDCKB0_SOUTSEL_MASK                 0x30000000L
#define MCLK_CNTL__MRDCKB1_SOUTSEL_MASK                 0xc0000000L
#define MCLK_CNTL__R300_DISABLE_MC_MCLKA                (1 << 21)
#define MCLK_CNTL__R300_DISABLE_MC_MCLKB                (1 << 21)

// MCLK_MISC
#define MCLK_MISC__SCLK_SOURCED_FROM_MPLL_SEL_MASK         0x00000003L
#define MCLK_MISC__MCLK_FROM_SPLL_DIV_SEL_MASK             0x00000004L
#define MCLK_MISC__MCLK_FROM_SPLL_DIV_SEL                  0x00000004L
#define MCLK_MISC__ENABLE_SCLK_FROM_MPLL_MASK              0x00000008L
#define MCLK_MISC__ENABLE_SCLK_FROM_MPLL                   0x00000008L
#define MCLK_MISC__MPLL_MODEA_MODEC_HW_SEL_EN_MASK         0x00000010L
#define MCLK_MISC__MPLL_MODEA_MODEC_HW_SEL_EN              0x00000010L
#define MCLK_MISC__DLL_READY_LAT_MASK                      0x00000100L
#define MCLK_MISC__DLL_READY_LAT                           0x00000100L
#define MCLK_MISC__MC_MCLK_MAX_DYN_STOP_LAT_MASK           0x00001000L
#define MCLK_MISC__MC_MCLK_MAX_DYN_STOP_LAT                0x00001000L
#define MCLK_MISC__IO_MCLK_MAX_DYN_STOP_LAT_MASK           0x00002000L
#define MCLK_MISC__IO_MCLK_MAX_DYN_STOP_LAT                0x00002000L
#define MCLK_MISC__MC_MCLK_DYN_ENABLE_MASK                 0x00004000L
#define MCLK_MISC__MC_MCLK_DYN_ENABLE                      0x00004000L
#define MCLK_MISC__IO_MCLK_DYN_ENABLE_MASK                 0x00008000L
#define MCLK_MISC__IO_MCLK_DYN_ENABLE                      0x00008000L
#define MCLK_MISC__CGM_CLK_TO_OUTPIN_MASK                  0x00010000L
#define MCLK_MISC__CGM_CLK_TO_OUTPIN                       0x00010000L
#define MCLK_MISC__CLK_OR_COUNT_SEL_MASK                   0x00020000L
#define MCLK_MISC__CLK_OR_COUNT_SEL                        0x00020000L
#define MCLK_MISC__EN_MCLK_TRISTATE_IN_SUSPEND_MASK        0x00040000L
#define MCLK_MISC__EN_MCLK_TRISTATE_IN_SUSPEND             0x00040000L
#define MCLK_MISC__CGM_SPARE_RD_MASK                       0x00300000L
#define MCLK_MISC__CGM_SPARE_A_RD_MASK                     0x00c00000L
#define MCLK_MISC__TCLK_TO_YCLKB_EN_MASK                   0x01000000L
#define MCLK_MISC__TCLK_TO_YCLKB_EN                        0x01000000L
#define MCLK_MISC__CGM_SPARE_A_MASK                        0x0e000000L

// VCLK_ECP_CNTL
#define VCLK_ECP_CNTL__VCLK_SRC_SEL_MASK                   0x00000003L
#define VCLK_ECP_CNTL__VCLK_INVERT                         0x00000010L
#define VCLK_ECP_CNTL__PIXCLK_SRC_INVERT                   0x00000020L
#define VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb                   0x00000040L
#define VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb               0x00000080L
#define VCLK_ECP_CNTL__ECP_DIV_MASK                        0x00000300L
#define VCLK_ECP_CNTL__ECP_FORCE_ON                        0x00040000L
#define VCLK_ECP_CNTL__SUBCLK_FORCE_ON                     0x00080000L
#define VCLK_ECP_CNTL__R300_DISP_DAC_PIXCLK_DAC_BLANK_OFF  (1<<23)

// PLL_PWRMGT_CNTL
#define PLL_PWRMGT_CNTL__MPLL_TURNOFF_MASK                 0x00000001L
#define PLL_PWRMGT_CNTL__MPLL_TURNOFF                      0x00000001L
#define PLL_PWRMGT_CNTL__SPLL_TURNOFF_MASK                 0x00000002L
#define PLL_PWRMGT_CNTL__SPLL_TURNOFF                      0x00000002L
#define PLL_PWRMGT_CNTL__PPLL_TURNOFF_MASK                 0x00000004L
#define PLL_PWRMGT_CNTL__PPLL_TURNOFF                      0x00000004L
#define PLL_PWRMGT_CNTL__P2PLL_TURNOFF_MASK                0x00000008L
#define PLL_PWRMGT_CNTL__P2PLL_TURNOFF                     0x00000008L
#define PLL_PWRMGT_CNTL__TVPLL_TURNOFF_MASK                0x00000010L
#define PLL_PWRMGT_CNTL__TVPLL_TURNOFF                     0x00000010L
#define PLL_PWRMGT_CNTL__AGPCLK_DYN_STOP_LAT_MASK          0x000001e0L
#define PLL_PWRMGT_CNTL__APM_POWER_STATE_MASK              0x00000600L
#define PLL_PWRMGT_CNTL__APM_PWRSTATE_RD_MASK              0x00001800L
#define PLL_PWRMGT_CNTL__PM_MODE_SEL_MASK                  0x00002000L
#define PLL_PWRMGT_CNTL__PM_MODE_SEL                       0x00002000L
#define PLL_PWRMGT_CNTL__EN_PWRSEQ_DONE_COND_MASK          0x00004000L
#define PLL_PWRMGT_CNTL__EN_PWRSEQ_DONE_COND               0x00004000L
#define PLL_PWRMGT_CNTL__EN_DISP_PARKED_COND_MASK          0x00008000L
#define PLL_PWRMGT_CNTL__EN_DISP_PARKED_COND               0x00008000L
#define PLL_PWRMGT_CNTL__MOBILE_SU_MASK                    0x00010000L
#define PLL_PWRMGT_CNTL__MOBILE_SU                         0x00010000L
#define PLL_PWRMGT_CNTL__SU_SCLK_USE_BCLK_MASK             0x00020000L
#define PLL_PWRMGT_CNTL__SU_SCLK_USE_BCLK                  0x00020000L
#define PLL_PWRMGT_CNTL__SU_MCLK_USE_BCLK_MASK             0x00040000L
#define PLL_PWRMGT_CNTL__SU_MCLK_USE_BCLK                  0x00040000L
#define PLL_PWRMGT_CNTL__SU_SUSTAIN_DISABLE_MASK           0x00080000L
#define PLL_PWRMGT_CNTL__SU_SUSTAIN_DISABLE                0x00080000L
#define PLL_PWRMGT_CNTL__TCL_BYPASS_DISABLE_MASK           0x00100000L
#define PLL_PWRMGT_CNTL__TCL_BYPASS_DISABLE                0x00100000L
#define PLL_PWRMGT_CNTL__TCL_CLOCK_CTIVE_RD_MASK          0x00200000L
#define PLL_PWRMGT_CNTL__TCL_CLOCK_ACTIVE_RD               0x00200000L
#define PLL_PWRMGT_CNTL__CG_NO2_DEBUG_MASK                 0xff000000L

// CLK_PWRMGT_CNTL
#define CLK_PWRMGT_CNTL__MPLL_PWRMGT_OFF_MASK           0x00000001L
#define CLK_PWRMGT_CNTL__MPLL_PWRMGT_OFF                0x00000001L
#define CLK_PWRMGT_CNTL__SPLL_PWRMGT_OFF_MASK           0x00000002L
#define CLK_PWRMGT_CNTL__SPLL_PWRMGT_OFF                0x00000002L
#define CLK_PWRMGT_CNTL__PPLL_PWRMGT_OFF_MASK           0x00000004L
#define CLK_PWRMGT_CNTL__PPLL_PWRMGT_OFF                0x00000004L
#define CLK_PWRMGT_CNTL__P2PLL_PWRMGT_OFF_MASK          0x00000008L
#define CLK_PWRMGT_CNTL__P2PLL_PWRMGT_OFF               0x00000008L
#define CLK_PWRMGT_CNTL__MCLK_TURNOFF_MASK              0x00000010L
#define CLK_PWRMGT_CNTL__MCLK_TURNOFF                   0x00000010L
#define CLK_PWRMGT_CNTL__SCLK_TURNOFF_MASK              0x00000020L
#define CLK_PWRMGT_CNTL__SCLK_TURNOFF                   0x00000020L
#define CLK_PWRMGT_CNTL__PCLK_TURNOFF_MASK              0x00000040L
#define CLK_PWRMGT_CNTL__PCLK_TURNOFF                   0x00000040L
#define CLK_PWRMGT_CNTL__P2CLK_TURNOFF_MASK             0x00000080L
#define CLK_PWRMGT_CNTL__P2CLK_TURNOFF                  0x00000080L
#define CLK_PWRMGT_CNTL__MC_CH_MODE_MASK                0x00000100L
#define CLK_PWRMGT_CNTL__MC_CH_MODE                     0x00000100L
#define CLK_PWRMGT_CNTL__TEST_MODE_MASK                 0x00000200L
#define CLK_PWRMGT_CNTL__TEST_MODE                      0x00000200L
#define CLK_PWRMGT_CNTL__GLOBAL_PMAN_EN_MASK            0x00000400L
#define CLK_PWRMGT_CNTL__GLOBAL_PMAN_EN                 0x00000400L
#define CLK_PWRMGT_CNTL__ENGINE_DYNCLK_MODE_MASK        0x00001000L
#define CLK_PWRMGT_CNTL__ENGINE_DYNCLK_MODE             0x00001000L
#define CLK_PWRMGT_CNTL__ACTIVE_HILO_LAT_MASK           0x00006000L
#define CLK_PWRMGT_CNTL__DISP_DYN_STOP_LAT_MASK         0x00008000L
#define CLK_PWRMGT_CNTL__DISP_DYN_STOP_LAT              0x00008000L
#define CLK_PWRMGT_CNTL__MC_BUSY_MASK                   0x00010000L
#define CLK_PWRMGT_CNTL__MC_BUSY                        0x00010000L
#define CLK_PWRMGT_CNTL__MC_INT_CNTL_MASK               0x00020000L
#define CLK_PWRMGT_CNTL__MC_INT_CNTL                    0x00020000L
#define CLK_PWRMGT_CNTL__MC_SWITCH_MASK                 0x00040000L
#define CLK_PWRMGT_CNTL__MC_SWITCH                      0x00040000L
#define CLK_PWRMGT_CNTL__DLL_READY_MASK                 0x00080000L
#define CLK_PWRMGT_CNTL__DLL_READY                      0x00080000L
#define CLK_PWRMGT_CNTL__DISP_PM_MASK                   0x00100000L
#define CLK_PWRMGT_CNTL__DISP_PM                        0x00100000L
#define CLK_PWRMGT_CNTL__DYN_STOP_MODE_MASK             0x00e00000L
#define CLK_PWRMGT_CNTL__CG_NO1_DEBUG_MASK              0x3f000000L
#define CLK_PWRMGT_CNTL__TVPLL_PWRMGT_OFF_MASK          0x40000000L
#define CLK_PWRMGT_CNTL__TVPLL_PWRMGT_OFF               0x40000000L
#define CLK_PWRMGT_CNTL__TVCLK_TURNOFF_MASK             0x80000000L
#define CLK_PWRMGT_CNTL__TVCLK_TURNOFF                  0x80000000L

// BUS_CNTL1
#define BUS_CNTL1__PMI_IO_DISABLE_MASK                     0x00000001L
#define BUS_CNTL1__PMI_IO_DISABLE                          0x00000001L
#define BUS_CNTL1__PMI_MEM_DISABLE_MASK                    0x00000002L
#define BUS_CNTL1__PMI_MEM_DISABLE                         0x00000002L
#define BUS_CNTL1__PMI_BM_DISABLE_MASK                     0x00000004L
#define BUS_CNTL1__PMI_BM_DISABLE                          0x00000004L
#define BUS_CNTL1__PMI_INT_DISABLE_MASK                    0x00000008L
#define BUS_CNTL1__PMI_INT_DISABLE                         0x00000008L
#define BUS_CNTL1__BUS2_IMMEDIATE_PMI_DISABLE_MASK         0x00000020L
#define BUS_CNTL1__BUS2_IMMEDIATE_PMI_DISABLE              0x00000020L
#define BUS_CNTL1__BUS2_VGA_REG_COHERENCY_DIS_MASK         0x00000100L
#define BUS_CNTL1__BUS2_VGA_REG_COHERENCY_DIS              0x00000100L
#define BUS_CNTL1__BUS2_VGA_MEM_COHERENCY_DIS_MASK         0x00000200L
#define BUS_CNTL1__BUS2_VGA_MEM_COHERENCY_DIS              0x00000200L
#define BUS_CNTL1__BUS2_HDP_REG_COHERENCY_DIS_MASK         0x00000400L
#define BUS_CNTL1__BUS2_HDP_REG_COHERENCY_DIS              0x00000400L
#define BUS_CNTL1__BUS2_GUI_INITIATOR_COHERENCY_DIS_MASK   0x00000800L
#define BUS_CNTL1__BUS2_GUI_INITIATOR_COHERENCY_DIS        0x00000800L
#define BUS_CNTL1__MOBILE_PLATFORM_SEL_MASK                0x0c000000L
#define BUS_CNTL1__SEND_SBA_LATENCY_MASK                   0x70000000L
#define BUS_CNTL1__AGPCLK_VALID_MASK                       0x80000000L
#define BUS_CNTL1__AGPCLK_VALID                            0x80000000L

// BUS_CNTL1
#define	BUS_CNTL1__PMI_IO_DISABLE__SHIFT                   0x00000000
#define	BUS_CNTL1__PMI_MEM_DISABLE__SHIFT                  0x00000001
#define	BUS_CNTL1__PMI_BM_DISABLE__SHIFT                   0x00000002
#define	BUS_CNTL1__PMI_INT_DISABLE__SHIFT                  0x00000003
#define	BUS_CNTL1__BUS2_IMMEDIATE_PMI_DISABLE__SHIFT       0x00000005
#define	BUS_CNTL1__BUS2_VGA_REG_COHERENCY_DIS__SHIFT       0x00000008
#define	BUS_CNTL1__BUS2_VGA_MEM_COHERENCY_DIS__SHIFT       0x00000009
#define	BUS_CNTL1__BUS2_HDP_REG_COHERENCY_DIS__SHIFT       0x0000000a
#define	BUS_CNTL1__BUS2_GUI_INITIATOR_COHERENCY_DIS__SHIFT 0x0000000b
#define	BUS_CNTL1__MOBILE_PLATFORM_SEL__SHIFT              0x0000001a
#define	BUS_CNTL1__SEND_SBA_LATENCY__SHIFT                 0x0000001c
#define	BUS_CNTL1__AGPCLK_VALID__SHIFT                     0x0000001f

// CRTC_OFFSET_CNTL
#define CRTC_OFFSET_CNTL__CRTC_TILE_LINE_MASK              0x0000000fL
#define CRTC_OFFSET_CNTL__CRTC_TILE_LINE_RIGHT_MASK        0x000000f0L
#define CRTC_OFFSET_CNTL__CRTC_TILE_EN_RIGHT_MASK          0x00004000L
#define CRTC_OFFSET_CNTL__CRTC_TILE_EN_RIGHT               0x00004000L
#define CRTC_OFFSET_CNTL__CRTC_TILE_EN_MASK                0x00008000L
#define CRTC_OFFSET_CNTL__CRTC_TILE_EN                     0x00008000L
#define CRTC_OFFSET_CNTL__CRTC_OFFSET_FLIP_CNTL_MASK       0x00010000L
#define CRTC_OFFSET_CNTL__CRTC_OFFSET_FLIP_CNTL            0x00010000L
#define CRTC_OFFSET_CNTL__CRTC_STEREO_OFFSET_EN_MASK       0x00020000L
#define CRTC_OFFSET_CNTL__CRTC_STEREO_OFFSET_EN            0x00020000L
#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_EN_MASK         0x000c0000L
#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_OUT_EN_MASK     0x00100000L
#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_OUT_EN          0x00100000L
#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_MASK            0x00200000L
#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC                 0x00200000L
#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_LEFT_EN_MASK 0x10000000L
#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_LEFT_EN     0x10000000L
#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_RIGHT_EN_MASK 0x20000000L
#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_RIGHT_EN    0x20000000L
#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_MASK        0x40000000L
#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET             0x40000000L
#define CRTC_OFFSET_CNTL__CRTC_OFFSET_LOCK_MASK            0x80000000L
#define CRTC_OFFSET_CNTL__CRTC_OFFSET_LOCK                 0x80000000L

// CRTC_GEN_CNTL
#define CRTC_GEN_CNTL__CRTC_DBL_SCAN_EN_MASK               0x00000001L
#define CRTC_GEN_CNTL__CRTC_DBL_SCAN_EN                    0x00000001L
#define CRTC_GEN_CNTL__CRTC_INTERLACE_EN_MASK              0x00000002L
#define CRTC_GEN_CNTL__CRTC_INTERLACE_EN                   0x00000002L
#define CRTC_GEN_CNTL__CRTC_C_SYNC_EN_MASK                 0x00000010L
#define CRTC_GEN_CNTL__CRTC_C_SYNC_EN                      0x00000010L
#define CRTC_GEN_CNTL__CRTC_PIX_WIDTH_MASK                 0x00000f00L
#define CRTC_GEN_CNTL__CRTC_ICON_EN_MASK                   0x00008000L
#define CRTC_GEN_CNTL__CRTC_ICON_EN                        0x00008000L
#define CRTC_GEN_CNTL__CRTC_CUR_EN_MASK                    0x00010000L
#define CRTC_GEN_CNTL__CRTC_CUR_EN                         0x00010000L
#define CRTC_GEN_CNTL__CRTC_VSTAT_MODE_MASK                0x00060000L
#define CRTC_GEN_CNTL__CRTC_CUR_MODE_MASK                  0x00700000L
#define CRTC_GEN_CNTL__CRTC_EXT_DISP_EN_MASK               0x01000000L
#define CRTC_GEN_CNTL__CRTC_EXT_DISP_EN                    0x01000000L
#define CRTC_GEN_CNTL__CRTC_EN_MASK                        0x02000000L
#define CRTC_GEN_CNTL__CRTC_EN                             0x02000000L
#define CRTC_GEN_CNTL__CRTC_DISP_REQ_EN_B_MASK             0x04000000L
#define CRTC_GEN_CNTL__CRTC_DISP_REQ_EN_B                  0x04000000L

// CRTC2_GEN_CNTL
#define CRTC2_GEN_CNTL__CRTC2_DBL_SCAN_EN_MASK             0x00000001L
#define CRTC2_GEN_CNTL__CRTC2_DBL_SCAN_EN                  0x00000001L
#define CRTC2_GEN_CNTL__CRTC2_INTERLACE_EN_MASK            0x00000002L
#define CRTC2_GEN_CNTL__CRTC2_INTERLACE_EN                 0x00000002L
#define CRTC2_GEN_CNTL__CRTC2_SYNC_TRISTATE_MASK           0x00000010L
#define CRTC2_GEN_CNTL__CRTC2_SYNC_TRISTATE                0x00000010L
#define CRTC2_GEN_CNTL__CRTC2_HSYNC_TRISTATE_MASK          0x00000020L
#define CRTC2_GEN_CNTL__CRTC2_HSYNC_TRISTATE               0x00000020L
#define CRTC2_GEN_CNTL__CRTC2_VSYNC_TRISTATE_MASK          0x00000040L
#define CRTC2_GEN_CNTL__CRTC2_VSYNC_TRISTATE               0x00000040L
#define CRTC2_GEN_CNTL__CRT2_ON_MASK                       0x00000080L
#define CRTC2_GEN_CNTL__CRT2_ON                            0x00000080L
#define CRTC2_GEN_CNTL__CRTC2_PIX_WIDTH_MASK               0x00000f00L
#define CRTC2_GEN_CNTL__CRTC2_ICON_EN_MASK                 0x00008000L
#define CRTC2_GEN_CNTL__CRTC2_ICON_EN                      0x00008000L
#define CRTC2_GEN_CNTL__CRTC2_CUR_EN_MASK                  0x00010000L
#define CRTC2_GEN_CNTL__CRTC2_CUR_EN                       0x00010000L
#define CRTC2_GEN_CNTL__CRTC2_CUR_MODE_MASK                0x00700000L
#define CRTC2_GEN_CNTL__CRTC2_DISPLAY_DIS_MASK             0x00800000L
#define CRTC2_GEN_CNTL__CRTC2_DISPLAY_DIS                  0x00800000L
#define CRTC2_GEN_CNTL__CRTC2_EN_MASK                      0x02000000L
#define CRTC2_GEN_CNTL__CRTC2_EN                           0x02000000L
#define CRTC2_GEN_CNTL__CRTC2_DISP_REQ_EN_B_MASK           0x04000000L
#define CRTC2_GEN_CNTL__CRTC2_DISP_REQ_EN_B                0x04000000L
#define CRTC2_GEN_CNTL__CRTC2_C_SYNC_EN_MASK               0x08000000L
#define CRTC2_GEN_CNTL__CRTC2_C_SYNC_EN                    0x08000000L
#define CRTC2_GEN_CNTL__CRTC2_HSYNC_DIS_MASK               0x10000000L
#define CRTC2_GEN_CNTL__CRTC2_HSYNC_DIS                    0x10000000L
#define CRTC2_GEN_CNTL__CRTC2_VSYNC_DIS_MASK               0x20000000L
#define CRTC2_GEN_CNTL__CRTC2_VSYNC_DIS                    0x20000000L

// AGP_CNTL
#define AGP_CNTL__MAX_IDLE_CLK_MASK                        0x000000ffL
#define AGP_CNTL__HOLD_RD_FIFO_MASK                        0x00000100L
#define AGP_CNTL__HOLD_RD_FIFO                             0x00000100L
#define AGP_CNTL__HOLD_RQ_FIFO_MASK                        0x00000200L
#define AGP_CNTL__HOLD_RQ_FIFO                             0x00000200L
#define AGP_CNTL__EN_2X_STBB_MASK                          0x00000400L
#define AGP_CNTL__EN_2X_STBB                               0x00000400L
#define AGP_CNTL__FORCE_FULL_SBA_MASK                      0x00000800L
#define AGP_CNTL__FORCE_FULL_SBA                           0x00000800L
#define AGP_CNTL__SBA_DIS_MASK                             0x00001000L
#define AGP_CNTL__SBA_DIS                                  0x00001000L
#define AGP_CNTL__AGP_REV_ID_MASK                          0x00002000L
#define AGP_CNTL__AGP_REV_ID                               0x00002000L
#define AGP_CNTL__REG_CRIPPLE_AGP4X_MASK                   0x00004000L
#define AGP_CNTL__REG_CRIPPLE_AGP4X                        0x00004000L
#define AGP_CNTL__REG_CRIPPLE_AGP2X4X_MASK                 0x00008000L
#define AGP_CNTL__REG_CRIPPLE_AGP2X4X                      0x00008000L
#define AGP_CNTL__FORCE_INT_VREF_MASK                      0x00010000L
#define AGP_CNTL__FORCE_INT_VREF                           0x00010000L
#define AGP_CNTL__PENDING_SLOTS_VAL_MASK                   0x00060000L
#define AGP_CNTL__PENDING_SLOTS_SEL_MASK                   0x00080000L
#define AGP_CNTL__PENDING_SLOTS_SEL                        0x00080000L
#define AGP_CNTL__EN_EXTENDED_AD_STB_2X_MASK               0x00100000L
#define AGP_CNTL__EN_EXTENDED_AD_STB_2X                    0x00100000L
#define AGP_CNTL__DIS_QUEUED_GNT_FIX_MASK                  0x00200000L
#define AGP_CNTL__DIS_QUEUED_GNT_FIX                       0x00200000L
#define AGP_CNTL__EN_RDATA2X4X_MULTIRESET_MASK             0x00400000L
#define AGP_CNTL__EN_RDATA2X4X_MULTIRESET                  0x00400000L
#define AGP_CNTL__EN_RBFCALM_MASK                          0x00800000L
#define AGP_CNTL__EN_RBFCALM                               0x00800000L
#define AGP_CNTL__FORCE_EXT_VREF_MASK                      0x01000000L
#define AGP_CNTL__FORCE_EXT_VREF                           0x01000000L
#define AGP_CNTL__DIS_RBF_MASK                             0x02000000L
#define AGP_CNTL__DIS_RBF                                  0x02000000L
#define AGP_CNTL__DELAY_FIRST_SBA_EN_MASK                  0x04000000L
#define AGP_CNTL__DELAY_FIRST_SBA_EN                       0x04000000L
#define AGP_CNTL__DELAY_FIRST_SBA_VAL_MASK                 0x38000000L
#define AGP_CNTL__AGP_MISC_MASK                            0xc0000000L

// AGP_CNTL
#define	AGP_CNTL__MAX_IDLE_CLK__SHIFT                      0x00000000
#define	AGP_CNTL__HOLD_RD_FIFO__SHIFT                      0x00000008
#define	AGP_CNTL__HOLD_RQ_FIFO__SHIFT                      0x00000009
#define	AGP_CNTL__EN_2X_STBB__SHIFT                        0x0000000a
#define	AGP_CNTL__FORCE_FULL_SBA__SHIFT                    0x0000000b
#define	AGP_CNTL__SBA_DIS__SHIFT                           0x0000000c
#define	AGP_CNTL__AGP_REV_ID__SHIFT                        0x0000000d
#define	AGP_CNTL__REG_CRIPPLE_AGP4X__SHIFT                 0x0000000e
#define	AGP_CNTL__REG_CRIPPLE_AGP2X4X__SHIFT               0x0000000f
#define	AGP_CNTL__FORCE_INT_VREF__SHIFT                    0x00000010
#define	AGP_CNTL__PENDING_SLOTS_VAL__SHIFT                 0x00000011
#define	AGP_CNTL__PENDING_SLOTS_SEL__SHIFT                 0x00000013
#define	AGP_CNTL__EN_EXTENDED_AD_STB_2X__SHIFT             0x00000014
#define	AGP_CNTL__DIS_QUEUED_GNT_FIX__SHIFT                0x00000015
#define	AGP_CNTL__EN_RDATA2X4X_MULTIRESET__SHIFT           0x00000016
#define	AGP_CNTL__EN_RBFCALM__SHIFT                        0x00000017
#define	AGP_CNTL__FORCE_EXT_VREF__SHIFT                    0x00000018
#define	AGP_CNTL__DIS_RBF__SHIFT                           0x00000019
#define	AGP_CNTL__DELAY_FIRST_SBA_EN__SHIFT                0x0000001a
#define	AGP_CNTL__DELAY_FIRST_SBA_VAL__SHIFT               0x0000001b
#define	AGP_CNTL__AGP_MISC__SHIFT                          0x0000001e

// DISP_MISC_CNTL
#define DISP_MISC_CNTL__SOFT_RESET_GRPH_PP_MASK            0x00000001L
#define DISP_MISC_CNTL__SOFT_RESET_GRPH_PP                 0x00000001L
#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_PP_MASK          0x00000002L
#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_PP               0x00000002L
#define DISP_MISC_CNTL__SOFT_RESET_OV0_PP_MASK             0x00000004L
#define DISP_MISC_CNTL__SOFT_RESET_OV0_PP                  0x00000004L
#define DISP_MISC_CNTL__SOFT_RESET_GRPH_SCLK_MASK          0x00000010L
#define DISP_MISC_CNTL__SOFT_RESET_GRPH_SCLK               0x00000010L
#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_SCLK_MASK        0x00000020L
#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_SCLK             0x00000020L
#define DISP_MISC_CNTL__SOFT_RESET_OV0_SCLK_MASK           0x00000040L
#define DISP_MISC_CNTL__SOFT_RESET_OV0_SCLK                0x00000040L
#define DISP_MISC_CNTL__SYNC_STRENGTH_MASK                 0x00000300L
#define DISP_MISC_CNTL__SYNC_PAD_FLOP_EN_MASK              0x00000400L
#define DISP_MISC_CNTL__SYNC_PAD_FLOP_EN                   0x00000400L
#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_PP_MASK           0x00001000L
#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_PP                0x00001000L
#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_SCLK_MASK         0x00008000L
#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_SCLK              0x00008000L
#define DISP_MISC_CNTL__SOFT_RESET_LVDS_MASK               0x00010000L
#define DISP_MISC_CNTL__SOFT_RESET_LVDS                    0x00010000L
#define DISP_MISC_CNTL__SOFT_RESET_TMDS_MASK               0x00020000L
#define DISP_MISC_CNTL__SOFT_RESET_TMDS                    0x00020000L
#define DISP_MISC_CNTL__SOFT_RESET_DIG_TMDS_MASK           0x00040000L
#define DISP_MISC_CNTL__SOFT_RESET_DIG_TMDS                0x00040000L
#define DISP_MISC_CNTL__SOFT_RESET_TV_MASK                 0x00080000L
#define DISP_MISC_CNTL__SOFT_RESET_TV                      0x00080000L
#define DISP_MISC_CNTL__PALETTE2_MEM_RD_MARGIN_MASK        0x00f00000L
#define DISP_MISC_CNTL__PALETTE_MEM_RD_MARGIN_MASK         0x0f000000L
#define DISP_MISC_CNTL__RMX_BUF_MEM_RD_MARGIN_MASK         0xf0000000L

// DISP_PWR_MAN
#define DISP_PWR_MAN__DISP_PWR_MAN_D3_CRTC_EN_MASK         0x00000001L
#define DISP_PWR_MAN__DISP_PWR_MAN_D3_CRTC_EN              0x00000001L
#define DISP_PWR_MAN__DISP2_PWR_MAN_D3_CRTC2_EN_MASK       0x00000010L
#define DISP_PWR_MAN__DISP2_PWR_MAN_D3_CRTC2_EN            0x00000010L
#define DISP_PWR_MAN__DISP_PWR_MAN_DPMS_MASK               0x00000300L
#define DISP_PWR_MAN__DISP_D3_RST_MASK                     0x00010000L
#define DISP_PWR_MAN__DISP_D3_RST                          0x00010000L
#define DISP_PWR_MAN__DISP_D3_REG_RST_MASK                 0x00020000L
#define DISP_PWR_MAN__DISP_D3_REG_RST                      0x00020000L
#define DISP_PWR_MAN__DISP_D3_GRPH_RST_MASK                0x00040000L
#define DISP_PWR_MAN__DISP_D3_GRPH_RST                     0x00040000L
#define DISP_PWR_MAN__DISP_D3_SUBPIC_RST_MASK              0x00080000L
#define DISP_PWR_MAN__DISP_D3_SUBPIC_RST                   0x00080000L
#define DISP_PWR_MAN__DISP_D3_OV0_RST_MASK                 0x00100000L
#define DISP_PWR_MAN__DISP_D3_OV0_RST                      0x00100000L
#define DISP_PWR_MAN__DISP_D1D2_GRPH_RST_MASK              0x00200000L
#define DISP_PWR_MAN__DISP_D1D2_GRPH_RST                   0x00200000L
#define DISP_PWR_MAN__DISP_D1D2_SUBPIC_RST_MASK            0x00400000L
#define DISP_PWR_MAN__DISP_D1D2_SUBPIC_RST                 0x00400000L
#define DISP_PWR_MAN__DISP_D1D2_OV0_RST_MASK               0x00800000L
#define DISP_PWR_MAN__DISP_D1D2_OV0_RST                    0x00800000L
#define DISP_PWR_MAN__DIG_TMDS_ENABLE_RST_MASK             0x01000000L
#define DISP_PWR_MAN__DIG_TMDS_ENABLE_RST                  0x01000000L
#define DISP_PWR_MAN__TV_ENABLE_RST_MASK                   0x02000000L
#define DISP_PWR_MAN__TV_ENABLE_RST                        0x02000000L
#define DISP_PWR_MAN__AUTO_PWRUP_EN_MASK                   0x04000000L
#define DISP_PWR_MAN__AUTO_PWRUP_EN                        0x04000000L

// MC_IND_INDEX
#define MC_IND_INDEX__MC_IND_ADDR_MASK                     0x0000001fL
#define MC_IND_INDEX__MC_IND_WR_EN_MASK                    0x00000100L
#define MC_IND_INDEX__MC_IND_WR_EN                         0x00000100L

// MC_IND_DATA
#define MC_IND_DATA__MC_IND_DATA_MASK                      0xffffffffL

// MC_CHP_IO_CNTL_A1
#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_CKA__SHIFT            0x00000000
#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_AA__SHIFT             0x00000001
#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQMA__SHIFT           0x00000002
#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQSA__SHIFT           0x00000003
#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_CKA__SHIFT            0x00000004
#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_AA__SHIFT             0x00000005
#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQMA__SHIFT           0x00000006
#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQSA__SHIFT           0x00000007
#define	MC_CHP_IO_CNTL_A1__MEM_PREAMP_AA__SHIFT            0x00000008
#define	MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQMA__SHIFT          0x00000009
#define	MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQSA__SHIFT          0x0000000a
#define	MC_CHP_IO_CNTL_A1__MEM_IO_MODEA__SHIFT             0x0000000c
#define	MC_CHP_IO_CNTL_A1__MEM_REC_CKA__SHIFT              0x0000000e
#define	MC_CHP_IO_CNTL_A1__MEM_REC_AA__SHIFT               0x00000010
#define	MC_CHP_IO_CNTL_A1__MEM_REC_DQMA__SHIFT             0x00000012
#define	MC_CHP_IO_CNTL_A1__MEM_REC_DQSA__SHIFT             0x00000014
#define	MC_CHP_IO_CNTL_A1__MEM_SYNC_PHASEA__SHIFT          0x00000016
#define	MC_CHP_IO_CNTL_A1__MEM_SYNC_CENTERA__SHIFT         0x00000017
#define	MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA__SHIFT             0x00000018
#define	MC_CHP_IO_CNTL_A1__MEM_CLK_SELA__SHIFT             0x0000001a
#define	MC_CHP_IO_CNTL_A1__MEM_CLK_INVA__SHIFT             0x0000001c
#define	MC_CHP_IO_CNTL_A1__MEM_DATA_ENIMP_A__SHIFT         0x0000001e
#define	MC_CHP_IO_CNTL_A1__MEM_CNTL_ENIMP_A__SHIFT         0x0000001f

// MC_CHP_IO_CNTL_B1
#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_CKB__SHIFT            0x00000000
#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_AB__SHIFT             0x00000001
#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQMB__SHIFT           0x00000002
#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQSB__SHIFT           0x00000003
#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_CKB__SHIFT            0x00000004
#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_AB__SHIFT             0x00000005
#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQMB__SHIFT           0x00000006
#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQSB__SHIFT           0x00000007
#define	MC_CHP_IO_CNTL_B1__MEM_PREAMP_AB__SHIFT            0x00000008
#define	MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQMB__SHIFT          0x00000009
#define	MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQSB__SHIFT          0x0000000a
#define	MC_CHP_IO_CNTL_B1__MEM_IO_MODEB__SHIFT             0x0000000c
#define	MC_CHP_IO_CNTL_B1__MEM_REC_CKB__SHIFT              0x0000000e
#define	MC_CHP_IO_CNTL_B1__MEM_REC_AB__SHIFT               0x00000010
#define	MC_CHP_IO_CNTL_B1__MEM_REC_DQMB__SHIFT             0x00000012
#define	MC_CHP_IO_CNTL_B1__MEM_REC_DQSB__SHIFT             0x00000014
#define	MC_CHP_IO_CNTL_B1__MEM_SYNC_PHASEB__SHIFT          0x00000016
#define	MC_CHP_IO_CNTL_B1__MEM_SYNC_CENTERB__SHIFT         0x00000017
#define	MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB__SHIFT             0x00000018
#define	MC_CHP_IO_CNTL_B1__MEM_CLK_SELB__SHIFT             0x0000001a
#define	MC_CHP_IO_CNTL_B1__MEM_CLK_INVB__SHIFT             0x0000001c
#define	MC_CHP_IO_CNTL_B1__MEM_DATA_ENIMP_B__SHIFT         0x0000001e
#define	MC_CHP_IO_CNTL_B1__MEM_CNTL_ENIMP_B__SHIFT         0x0000001f

// MC_CHP_IO_CNTL_A1
#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_CKA_MASK              0x00000001L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_CKA                   0x00000001L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_AA_MASK               0x00000002L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_AA                    0x00000002L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQMA_MASK             0x00000004L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQMA                  0x00000004L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQSA_MASK             0x00000008L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQSA                  0x00000008L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_CKA_MASK              0x00000010L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_CKA                   0x00000010L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_AA_MASK               0x00000020L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_AA                    0x00000020L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQMA_MASK             0x00000040L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQMA                  0x00000040L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQSA_MASK             0x00000080L
#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQSA                  0x00000080L
#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_AA_MASK              0x00000100L
#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_AA                   0x00000100L
#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQMA_MASK            0x00000200L
#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQMA                 0x00000200L
#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQSA_MASK            0x00000400L
#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQSA                 0x00000400L
#define MC_CHP_IO_CNTL_A1__MEM_IO_MODEA_MASK               0x00003000L
#define MC_CHP_IO_CNTL_A1__MEM_REC_CKA_MASK                0x0000c000L
#define MC_CHP_IO_CNTL_A1__MEM_REC_AA_MASK                 0x00030000L
#define MC_CHP_IO_CNTL_A1__MEM_REC_DQMA_MASK               0x000c0000L
#define MC_CHP_IO_CNTL_A1__MEM_REC_DQSA_MASK               0x00300000L
#define MC_CHP_IO_CNTL_A1__MEM_SYNC_PHASEA_MASK            0x00400000L
#define MC_CHP_IO_CNTL_A1__MEM_SYNC_PHASEA                 0x00400000L
#define MC_CHP_IO_CNTL_A1__MEM_SYNC_CENTERA_MASK           0x00800000L
#define MC_CHP_IO_CNTL_A1__MEM_SYNC_CENTERA                0x00800000L
#define MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA_MASK               0x03000000L
#define MC_CHP_IO_CNTL_A1__MEM_CLK_SELA_MASK               0x0c000000L
#define MC_CHP_IO_CNTL_A1__MEM_CLK_INVA_MASK               0x10000000L
#define MC_CHP_IO_CNTL_A1__MEM_CLK_INVA                    0x10000000L
#define MC_CHP_IO_CNTL_A1__MEM_DATA_ENIMP_A_MASK           0x40000000L
#define MC_CHP_IO_CNTL_A1__MEM_DATA_ENIMP_A                0x40000000L
#define MC_CHP_IO_CNTL_A1__MEM_CNTL_ENIMP_A_MASK           0x80000000L
#define MC_CHP_IO_CNTL_A1__MEM_CNTL_ENIMP_A                0x80000000L

// MC_CHP_IO_CNTL_B1
#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_CKB_MASK              0x00000001L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_CKB                   0x00000001L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_AB_MASK               0x00000002L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_AB                    0x00000002L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQMB_MASK             0x00000004L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQMB                  0x00000004L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQSB_MASK             0x00000008L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQSB                  0x00000008L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_CKB_MASK              0x00000010L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_CKB                   0x00000010L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_AB_MASK               0x00000020L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_AB                    0x00000020L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQMB_MASK             0x00000040L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQMB                  0x00000040L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQSB_MASK             0x00000080L
#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQSB                  0x00000080L
#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_AB_MASK              0x00000100L
#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_AB                   0x00000100L
#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQMB_MASK            0x00000200L
#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQMB                 0x00000200L
#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQSB_MASK            0x00000400L
#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQSB                 0x00000400L
#define MC_CHP_IO_CNTL_B1__MEM_IO_MODEB_MASK               0x00003000L
#define MC_CHP_IO_CNTL_B1__MEM_REC_CKB_MASK                0x0000c000L
#define MC_CHP_IO_CNTL_B1__MEM_REC_AB_MASK                 0x00030000L
#define MC_CHP_IO_CNTL_B1__MEM_REC_DQMB_MASK               0x000c0000L
#define MC_CHP_IO_CNTL_B1__MEM_REC_DQSB_MASK               0x00300000L
#define MC_CHP_IO_CNTL_B1__MEM_SYNC_PHASEB_MASK            0x00400000L
#define MC_CHP_IO_CNTL_B1__MEM_SYNC_PHASEB                 0x00400000L
#define MC_CHP_IO_CNTL_B1__MEM_SYNC_CENTERB_MASK           0x00800000L
#define MC_CHP_IO_CNTL_B1__MEM_SYNC_CENTERB                0x00800000L
#define MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB_MASK               0x03000000L
#define MC_CHP_IO_CNTL_B1__MEM_CLK_SELB_MASK               0x0c000000L
#define MC_CHP_IO_CNTL_B1__MEM_CLK_INVB_MASK               0x10000000L
#define MC_CHP_IO_CNTL_B1__MEM_CLK_INVB                    0x10000000L
#define MC_CHP_IO_CNTL_B1__MEM_DATA_ENIMP_B_MASK           0x40000000L
#define MC_CHP_IO_CNTL_B1__MEM_DATA_ENIMP_B                0x40000000L
#define MC_CHP_IO_CNTL_B1__MEM_CNTL_ENIMP_B_MASK           0x80000000L
#define MC_CHP_IO_CNTL_B1__MEM_CNTL_ENIMP_B                0x80000000L

// MEM_SDRAM_MODE_REG
#define MEM_SDRAM_MODE_REG__MEM_MODE_REG_MASK              0x00007fffL
#define MEM_SDRAM_MODE_REG__MEM_WR_LATENCY_MASK            0x000f0000L
#define MEM_SDRAM_MODE_REG__MEM_CAS_LATENCY_MASK           0x00700000L
#define MEM_SDRAM_MODE_REG__MEM_CMD_LATENCY_MASK           0x00800000L
#define MEM_SDRAM_MODE_REG__MEM_CMD_LATENCY                0x00800000L
#define MEM_SDRAM_MODE_REG__MEM_STR_LATENCY_MASK           0x01000000L
#define MEM_SDRAM_MODE_REG__MEM_STR_LATENCY                0x01000000L
#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_CMD_MASK          0x02000000L
#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_CMD               0x02000000L
#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_DATA_MASK         0x04000000L
#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_DATA              0x04000000L
#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_STR_MASK          0x08000000L
#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_STR               0x08000000L
#define MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE_MASK          0x10000000L
#define MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE               0x10000000L
#define MEM_SDRAM_MODE_REG__MEM_DDR_DLL_MASK               0x20000000L
#define MEM_SDRAM_MODE_REG__MEM_DDR_DLL                    0x20000000L
#define MEM_SDRAM_MODE_REG__MEM_CFG_TYPE_MASK              0x40000000L
#define MEM_SDRAM_MODE_REG__MEM_CFG_TYPE                   0x40000000L
#define MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET_MASK           0x80000000L
#define MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET                0x80000000L

// MEM_SDRAM_MODE_REG
#define	MEM_SDRAM_MODE_REG__MEM_MODE_REG__SHIFT            0x00000000
#define	MEM_SDRAM_MODE_REG__MEM_WR_LATENCY__SHIFT          0x00000010
#define	MEM_SDRAM_MODE_REG__MEM_CAS_LATENCY__SHIFT         0x00000014
#define	MEM_SDRAM_MODE_REG__MEM_CMD_LATENCY__SHIFT         0x00000017
#define	MEM_SDRAM_MODE_REG__MEM_STR_LATENCY__SHIFT         0x00000018
#define	MEM_SDRAM_MODE_REG__MEM_FALL_OUT_CMD__SHIFT        0x00000019
#define	MEM_SDRAM_MODE_REG__MEM_FALL_OUT_DATA__SHIFT       0x0000001a
#define	MEM_SDRAM_MODE_REG__MEM_FALL_OUT_STR__SHIFT        0x0000001b
#define	MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE__SHIFT        0x0000001c
#define	MEM_SDRAM_MODE_REG__MEM_DDR_DLL__SHIFT             0x0000001d
#define	MEM_SDRAM_MODE_REG__MEM_CFG_TYPE__SHIFT            0x0000001e
#define	MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET__SHIFT         0x0000001f

// MEM_REFRESH_CNTL
#define MEM_REFRESH_CNTL__MEM_REFRESH_RATE_MASK            0x000000ffL
#define MEM_REFRESH_CNTL__MEM_REFRESH_DIS_MASK             0x00000100L
#define MEM_REFRESH_CNTL__MEM_REFRESH_DIS                  0x00000100L
#define MEM_REFRESH_CNTL__MEM_DYNAMIC_CKE_MASK             0x00000200L
#define MEM_REFRESH_CNTL__MEM_DYNAMIC_CKE                  0x00000200L
#define MEM_REFRESH_CNTL__MEM_TRFC_MASK                    0x0000f000L
#define MEM_REFRESH_CNTL__MEM_CLKA0_ENABLE_MASK            0x00010000L
#define MEM_REFRESH_CNTL__MEM_CLKA0_ENABLE                 0x00010000L
#define MEM_REFRESH_CNTL__MEM_CLKA0b_ENABLE_MASK           0x00020000L
#define MEM_REFRESH_CNTL__MEM_CLKA0b_ENABLE                0x00020000L
#define MEM_REFRESH_CNTL__MEM_CLKA1_ENABLE_MASK            0x00040000L
#define MEM_REFRESH_CNTL__MEM_CLKA1_ENABLE                 0x00040000L
#define MEM_REFRESH_CNTL__MEM_CLKA1b_ENABLE_MASK           0x00080000L
#define MEM_REFRESH_CNTL__MEM_CLKA1b_ENABLE                0x00080000L
#define MEM_REFRESH_CNTL__MEM_CLKAFB_ENABLE_MASK           0x00100000L
#define MEM_REFRESH_CNTL__MEM_CLKAFB_ENABLE                0x00100000L
#define MEM_REFRESH_CNTL__DLL_FB_SLCT_CKA_MASK             0x00c00000L
#define MEM_REFRESH_CNTL__MEM_CLKB0_ENABLE_MASK            0x01000000L
#define MEM_REFRESH_CNTL__MEM_CLKB0_ENABLE                 0x01000000L
#define MEM_REFRESH_CNTL__MEM_CLKB0b_ENABLE_MASK           0x02000000L
#define MEM_REFRESH_CNTL__MEM_CLKB0b_ENABLE                0x02000000L
#define MEM_REFRESH_CNTL__MEM_CLKB1_ENABLE_MASK            0x04000000L
#define MEM_REFRESH_CNTL__MEM_CLKB1_ENABLE                 0x04000000L
#define MEM_REFRESH_CNTL__MEM_CLKB1b_ENABLE_MASK           0x08000000L
#define MEM_REFRESH_CNTL__MEM_CLKB1b_ENABLE                0x08000000L
#define MEM_REFRESH_CNTL__MEM_CLKBFB_ENABLE_MASK           0x10000000L
#define MEM_REFRESH_CNTL__MEM_CLKBFB_ENABLE                0x10000000L
#define MEM_REFRESH_CNTL__DLL_FB_SLCT_CKB_MASK             0xc0000000L

// MC_STATUS
#define MC_STATUS__MEM_PWRUP_COMPL_A_MASK                  0x00000001L
#define MC_STATUS__MEM_PWRUP_COMPL_A                       0x00000001L
#define MC_STATUS__MEM_PWRUP_COMPL_B_MASK                  0x00000002L
#define MC_STATUS__MEM_PWRUP_COMPL_B                       0x00000002L
#define MC_STATUS__MC_IDLE_MASK                            0x00000004L
#define MC_STATUS__MC_IDLE                                 0x00000004L
#define MC_STATUS__IMP_N_VALUE_R_BACK_MASK                 0x00000078L
#define MC_STATUS__IMP_P_VALUE_R_BACK_MASK                 0x00000780L
#define MC_STATUS__TEST_OUT_R_BACK_MASK                    0x00000800L
#define MC_STATUS__TEST_OUT_R_BACK                         0x00000800L
#define MC_STATUS__DUMMY_OUT_R_BACK_MASK                   0x00001000L
#define MC_STATUS__DUMMY_OUT_R_BACK                        0x00001000L
#define MC_STATUS__IMP_N_VALUE_A_R_BACK_MASK               0x0001e000L
#define MC_STATUS__IMP_P_VALUE_A_R_BACK_MASK               0x001e0000L
#define MC_STATUS__IMP_N_VALUE_CK_R_BACK_MASK              0x01e00000L
#define MC_STATUS__IMP_P_VALUE_CK_R_BACK_MASK              0x1e000000L

// MDLL_CKO
#define MDLL_CKO__MCKOA_SLEEP_MASK                         0x00000001L
#define MDLL_CKO__MCKOA_SLEEP                              0x00000001L
#define MDLL_CKO__MCKOA_RESET_MASK                         0x00000002L
#define MDLL_CKO__MCKOA_RESET                              0x00000002L
#define MDLL_CKO__MCKOA_RANGE_MASK                         0x0000000cL
#define MDLL_CKO__ERSTA_SOUTSEL_MASK                       0x00000030L
#define MDLL_CKO__MCKOA_FB_SEL_MASK                        0x000000c0L
#define MDLL_CKO__MCKOA_REF_SKEW_MASK                      0x00000700L
#define MDLL_CKO__MCKOA_FB_SKEW_MASK                       0x00007000L
#define MDLL_CKO__MCKOA_BP_SEL_MASK                        0x00008000L
#define MDLL_CKO__MCKOA_BP_SEL                             0x00008000L
#define MDLL_CKO__MCKOB_SLEEP_MASK                         0x00010000L
#define MDLL_CKO__MCKOB_SLEEP                              0x00010000L
#define MDLL_CKO__MCKOB_RESET_MASK                         0x00020000L
#define MDLL_CKO__MCKOB_RESET                              0x00020000L
#define MDLL_CKO__MCKOB_RANGE_MASK                         0x000c0000L
#define MDLL_CKO__ERSTB_SOUTSEL_MASK                       0x00300000L
#define MDLL_CKO__MCKOB_FB_SEL_MASK                        0x00c00000L
#define MDLL_CKO__MCKOB_REF_SKEW_MASK                      0x07000000L
#define MDLL_CKO__MCKOB_FB_SKEW_MASK                       0x70000000L
#define MDLL_CKO__MCKOB_BP_SEL_MASK                        0x80000000L
#define MDLL_CKO__MCKOB_BP_SEL                             0x80000000L

// MDLL_RDCKA
#define MDLL_RDCKA__MRDCKA0_SLEEP_MASK                     0x00000001L
#define MDLL_RDCKA__MRDCKA0_SLEEP                          0x00000001L
#define MDLL_RDCKA__MRDCKA0_RESET_MASK                     0x00000002L
#define MDLL_RDCKA__MRDCKA0_RESET                          0x00000002L
#define MDLL_RDCKA__MRDCKA0_RANGE_MASK                     0x0000000cL
#define MDLL_RDCKA__MRDCKA0_REF_SEL_MASK                   0x00000030L
#define MDLL_RDCKA__MRDCKA0_FB_SEL_MASK                    0x000000c0L
#define MDLL_RDCKA__MRDCKA0_REF_SKEW_MASK                  0x00000700L
#define MDLL_RDCKA__MRDCKA0_SINSEL_MASK                    0x00000800L
#define MDLL_RDCKA__MRDCKA0_SINSEL                         0x00000800L
#define MDLL_RDCKA__MRDCKA0_FB_SKEW_MASK                   0x00007000L
#define MDLL_RDCKA__MRDCKA0_BP_SEL_MASK                    0x00008000L
#define MDLL_RDCKA__MRDCKA0_BP_SEL                         0x00008000L
#define MDLL_RDCKA__MRDCKA1_SLEEP_MASK                     0x00010000L
#define MDLL_RDCKA__MRDCKA1_SLEEP                          0x00010000L
#define MDLL_RDCKA__MRDCKA1_RESET_MASK                     0x00020000L
#define MDLL_RDCKA__MRDCKA1_RESET                          0x00020000L
#define MDLL_RDCKA__MRDCKA1_RANGE_MASK                     0x000c0000L
#define MDLL_RDCKA__MRDCKA1_REF_SEL_MASK                   0x00300000L
#define MDLL_RDCKA__MRDCKA1_FB_SEL_MASK                    0x00c00000L
#define MDLL_RDCKA__MRDCKA1_REF_SKEW_MASK                  0x07000000L
#define MDLL_RDCKA__MRDCKA1_SINSEL_MASK                    0x08000000L
#define MDLL_RDCKA__MRDCKA1_SINSEL                         0x08000000L
#define MDLL_RDCKA__MRDCKA1_FB_SKEW_MASK                   0x70000000L
#define MDLL_RDCKA__MRDCKA1_BP_SEL_MASK                    0x80000000L
#define MDLL_RDCKA__MRDCKA1_BP_SEL                         0x80000000L

// MDLL_RDCKB
#define MDLL_RDCKB__MRDCKB0_SLEEP_MASK                     0x00000001L
#define MDLL_RDCKB__MRDCKB0_SLEEP                          0x00000001L
#define MDLL_RDCKB__MRDCKB0_RESET_MASK                     0x00000002L
#define MDLL_RDCKB__MRDCKB0_RESET                          0x00000002L
#define MDLL_RDCKB__MRDCKB0_RANGE_MASK                     0x0000000cL
#define MDLL_RDCKB__MRDCKB0_REF_SEL_MASK                   0x00000030L
#define MDLL_RDCKB__MRDCKB0_FB_SEL_MASK                    0x000000c0L
#define MDLL_RDCKB__MRDCKB0_REF_SKEW_MASK                  0x00000700L
#define MDLL_RDCKB__MRDCKB0_SINSEL_MASK                    0x00000800L
#define MDLL_RDCKB__MRDCKB0_SINSEL                         0x00000800L
#define MDLL_RDCKB__MRDCKB0_FB_SKEW_MASK                   0x00007000L
#define MDLL_RDCKB__MRDCKB0_BP_SEL_MASK                    0x00008000L
#define MDLL_RDCKB__MRDCKB0_BP_SEL                         0x00008000L
#define MDLL_RDCKB__MRDCKB1_SLEEP_MASK                     0x00010000L
#define MDLL_RDCKB__MRDCKB1_SLEEP                          0x00010000L
#define MDLL_RDCKB__MRDCKB1_RESET_MASK                     0x00020000L
#define MDLL_RDCKB__MRDCKB1_RESET                          0x00020000L
#define MDLL_RDCKB__MRDCKB1_RANGE_MASK                     0x000c0000L
#define MDLL_RDCKB__MRDCKB1_REF_SEL_MASK                   0x00300000L
#define MDLL_RDCKB__MRDCKB1_FB_SEL_MASK                    0x00c00000L
#define MDLL_RDCKB__MRDCKB1_REF_SKEW_MASK                  0x07000000L
#define MDLL_RDCKB__MRDCKB1_SINSEL_MASK                    0x08000000L
#define MDLL_RDCKB__MRDCKB1_SINSEL                         0x08000000L
#define MDLL_RDCKB__MRDCKB1_FB_SKEW_MASK                   0x70000000L
#define MDLL_RDCKB__MRDCKB1_BP_SEL_MASK                    0x80000000L
#define MDLL_RDCKB__MRDCKB1_BP_SEL                         0x80000000L

#define MDLL_R300_RDCK__MRDCKA_SLEEP                       0x00000001L
#define MDLL_R300_RDCK__MRDCKA_RESET                       0x00000002L
#define MDLL_R300_RDCK__MRDCKB_SLEEP                       0x00000004L
#define MDLL_R300_RDCK__MRDCKB_RESET                       0x00000008L
#define MDLL_R300_RDCK__MRDCKC_SLEEP                       0x00000010L
#define MDLL_R300_RDCK__MRDCKC_RESET                       0x00000020L
#define MDLL_R300_RDCK__MRDCKD_SLEEP                       0x00000040L
#define MDLL_R300_RDCK__MRDCKD_RESET                       0x00000080L

#define pllCLK_PIN_CNTL                             0x0001
#define pllPPLL_CNTL                                0x0002
#define pllPPLL_REF_DIV                             0x0003
#define pllPPLL_DIV_0                               0x0004
#define pllPPLL_DIV_1                               0x0005
#define pllPPLL_DIV_2                               0x0006
#define pllPPLL_DIV_3                               0x0007
#define pllVCLK_ECP_CNTL                            0x0008
#define pllHTOTAL_CNTL                              0x0009
#define pllM_SPLL_REF_FB_DIV                        0x000A
#define pllAGP_PLL_CNTL                             0x000B
#define pllSPLL_CNTL                                0x000C
#define pllSCLK_CNTL                                0x000D
#define pllMPLL_CNTL                                0x000E
#define pllMDLL_CKO                                 0x000F
#define pllMDLL_RDCKA                               0x0010
#define pllMDLL_RDCKB                               0x0011
#define pllMCLK_CNTL                                0x0012
#define pllPLL_TEST_CNTL                            0x0013
#define pllCLK_PWRMGT_CNTL                          0x0014
#define pllPLL_PWRMGT_CNTL                          0x0015
#define pllCG_TEST_MACRO_RW_WRITE                   0x0016
#define pllCG_TEST_MACRO_RW_READ                    0x0017
#define pllCG_TEST_MACRO_RW_DATA                    0x0018
#define pllCG_TEST_MACRO_RW_CNTL                    0x0019
#define pllDISP_TEST_MACRO_RW_WRITE                 0x001A
#define pllDISP_TEST_MACRO_RW_READ                  0x001B
#define pllDISP_TEST_MACRO_RW_DATA                  0x001C
#define pllDISP_TEST_MACRO_RW_CNTL                  0x001D
#define pllSCLK_CNTL2                               0x001E
#define pllMCLK_MISC                                0x001F
#define pllTV_PLL_FINE_CNTL                         0x0020
#define pllTV_PLL_CNTL                              0x0021
#define pllTV_PLL_CNTL1                             0x0022
#define pllTV_DTO_INCREMENTS                        0x0023
#define pllSPLL_AUX_CNTL                            0x0024
#define pllMPLL_AUX_CNTL                            0x0025
#define pllP2PLL_CNTL                               0x002A
#define pllP2PLL_REF_DIV                            0x002B
#define pllP2PLL_DIV_0                              0x002C
#define pllPIXCLKS_CNTL                             0x002D
#define pllHTOTAL2_CNTL                             0x002E
#define pllSSPLL_CNTL                               0x0030
#define pllSSPLL_REF_DIV                            0x0031
#define pllSSPLL_DIV_0                              0x0032
#define pllSS_INT_CNTL                              0x0033
#define pllSS_TST_CNTL                              0x0034
#define pllSCLK_MORE_CNTL                           0x0035

#define ixMC_PERF_CNTL                             0x0000
#define ixMC_PERF_SEL                              0x0001
#define ixMC_PERF_REGION_0                         0x0002
#define ixMC_PERF_REGION_1                         0x0003
#define ixMC_PERF_COUNT_0                          0x0004
#define ixMC_PERF_COUNT_1                          0x0005
#define ixMC_PERF_COUNT_2                          0x0006
#define ixMC_PERF_COUNT_3                          0x0007
#define ixMC_PERF_COUNT_MEMCH_A                    0x0008
#define ixMC_PERF_COUNT_MEMCH_B                    0x0009
#define ixMC_IMP_CNTL                              0x000A
#define ixMC_CHP_IO_CNTL_A0                        0x000B
#define ixMC_CHP_IO_CNTL_A1                        0x000C
#define ixMC_CHP_IO_CNTL_B0                        0x000D
#define ixMC_CHP_IO_CNTL_B1                        0x000E
#define ixMC_IMP_CNTL_0                            0x000F
#define ixTC_MISMATCH_1                            0x0010
#define ixTC_MISMATCH_2                            0x0011
#define ixMC_BIST_CTRL                             0x0012
#define ixREG_COLLAR_WRITE                         0x0013
#define ixREG_COLLAR_READ                          0x0014
#define ixR300_MC_IMP_CNTL                         0x0018
#define ixR300_MC_CHP_IO_CNTL_A0                   0x0019
#define ixR300_MC_CHP_IO_CNTL_A1                   0x001a
#define ixR300_MC_CHP_IO_CNTL_B0                   0x001b
#define ixR300_MC_CHP_IO_CNTL_B1                   0x001c
#define ixR300_MC_CHP_IO_CNTL_C0                   0x001d
#define ixR300_MC_CHP_IO_CNTL_C1                   0x001e
#define ixR300_MC_CHP_IO_CNTL_D0                   0x001f
#define ixR300_MC_CHP_IO_CNTL_D1                   0x0020
#define ixR300_MC_IMP_CNTL_0                       0x0021
#define ixR300_MC_ELPIDA_CNTL                      0x0022
#define ixR300_MC_CHP_IO_OE_CNTL_CD                0x0023
#define ixR300_MC_READ_CNTL_CD                     0x0024
#define ixR300_MC_MC_INIT_WR_LAT_TIMER             0x0025
#define ixR300_MC_DEBUG_CNTL                       0x0026
#define ixR300_MC_BIST_CNTL_0                      0x0028
#define ixR300_MC_BIST_CNTL_1                      0x0029
#define ixR300_MC_BIST_CNTL_2                      0x002a
#define ixR300_MC_BIST_CNTL_3                      0x002b
#define ixR300_MC_BIST_CNTL_4                      0x002c
#define ixR300_MC_BIST_CNTL_5                      0x002d
#define ixR300_MC_IMP_STATUS                       0x002e
#define ixR300_MC_DLL_CNTL                         0x002f
#define NB_TOM                                     0x15C


#endif	/* _RADEON_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * mac80211 <-> driver interface
 *
 * Copyright 2002-2005, Devicescape Software, Inc.
 * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
 * Copyright 2007-2010	Johannes Berg <johannes@sipsolutions.net>
 * Copyright 2013-2014  Intel Mobile Communications GmbH
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef MAC80211_H
#define MAC80211_H

#include <linux/bug.h>
#include <linux/kernel.h>
#include <linux/if_ether.h>
#include <linux/skbuff.h>
#include <linux/ieee80211.h>
#include <net/cfg80211.h>
#include <asm/unaligned.h>

/**
 * DOC: Introduction
 *
 * mac80211 is the Linux stack for 802.11 hardware that implements
 * only partial functionality in hard- or firmware. This document
 * defines the interface between mac80211 and low-level hardware
 * drivers.
 */

/**
 * DOC: Calling mac80211 from interrupts
 *
 * Only ieee80211_tx_status_irqsafe() and ieee80211_rx_irqsafe() can be
 * called in hardware interrupt context. The low-level driver must not call any
 * other functions in hardware interrupt context. If there is a need for such
 * call, the low-level driver should first ACK the interrupt and perform the
 * IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even
 * tasklet function.
 *
 * NOTE: If the driver opts to use the _irqsafe() functions, it may not also
 *	 use the non-IRQ-safe functions!
 */

/**
 * DOC: Warning
 *
 * If you're reading this document and not the header file itself, it will
 * be incomplete because not all documentation has been converted yet.
 */

/**
 * DOC: Frame format
 *
 * As a general rule, when frames are passed between mac80211 and the driver,
 * they start with the IEEE 802.11 header and include the same octets that are
 * sent over the air except for the FCS which should be calculated by the
 * hardware.
 *
 * There are, however, various exceptions to this rule for advanced features:
 *
 * The first exception is for hardware encryption and decryption offload
 * where the IV/ICV may or may not be generated in hardware.
 *
 * Secondly, when the hardware handles fragmentation, the frame handed to
 * the driver from mac80211 is the MSDU, not the MPDU.
 */

/**
 * DOC: mac80211 workqueue
 *
 * mac80211 provides its own workqueue for drivers and internal mac80211 use.
 * The workqueue is a single threaded workqueue and can only be accessed by
 * helpers for sanity checking. Drivers must ensure all work added onto the
 * mac80211 workqueue should be cancelled on the driver stop() callback.
 *
 * mac80211 will flushed the workqueue upon interface removal and during
 * suspend.
 *
 * All work performed on the mac80211 workqueue must not acquire the RTNL lock.
 *
 */

/**
 * DOC: mac80211 software tx queueing
 *
 * mac80211 provides an optional intermediate queueing implementation designed
 * to allow the driver to keep hardware queues short and provide some fairness
 * between different stations/interfaces.
 * In this model, the driver pulls data frames from the mac80211 queue instead
 * of letting mac80211 push them via drv_tx().
 * Other frames (e.g. control or management) are still pushed using drv_tx().
 *
 * Drivers indicate that they use this model by implementing the .wake_tx_queue
 * driver operation.
 *
 * Intermediate queues (struct ieee80211_txq) are kept per-sta per-tid, with a
 * single per-vif queue for multicast data frames.
 *
 * The driver is expected to initialize its private per-queue data for stations
 * and interfaces in the .add_interface and .sta_add ops.
 *
 * The driver can't access the queue directly. To dequeue a frame, it calls
 * ieee80211_tx_dequeue(). Whenever mac80211 adds a new frame to a queue, it
 * calls the .wake_tx_queue driver op.
 *
 * For AP powersave TIM handling, the driver only needs to indicate if it has
 * buffered packets in the driver specific data structures by calling
 * ieee80211_sta_set_buffered(). For frames buffered in the ieee80211_txq
 * struct, mac80211 sets the appropriate TIM PVB bits and calls
 * .release_buffered_frames().
 * In that callback the driver is therefore expected to release its own
 * buffered frames and afterwards also frames from the ieee80211_txq (obtained
 * via the usual ieee80211_tx_dequeue).
 */

struct device;

/**
 * enum ieee80211_max_queues - maximum number of queues
 *
 * @IEEE80211_MAX_QUEUES: Maximum number of regular device queues.
 * @IEEE80211_MAX_QUEUE_MAP: bitmap with maximum queues set
 */
enum ieee80211_max_queues {
	IEEE80211_MAX_QUEUES =		16,
	IEEE80211_MAX_QUEUE_MAP =	BIT(IEEE80211_MAX_QUEUES) - 1,
};

#define IEEE80211_INVAL_HW_QUEUE	0xff

/**
 * enum ieee80211_ac_numbers - AC numbers as used in mac80211
 * @IEEE80211_AC_VO: voice
 * @IEEE80211_AC_VI: video
 * @IEEE80211_AC_BE: best effort
 * @IEEE80211_AC_BK: background
 */
enum ieee80211_ac_numbers {
	IEEE80211_AC_VO		= 0,
	IEEE80211_AC_VI		= 1,
	IEEE80211_AC_BE		= 2,
	IEEE80211_AC_BK		= 3,
};
#define IEEE80211_NUM_ACS	4

/**
 * struct ieee80211_tx_queue_params - transmit queue configuration
 *
 * The information provided in this structure is required for QoS
 * transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.
 *
 * @aifs: arbitration interframe space [0..255]
 * @cw_min: minimum contention window [a value of the form
 *	2^n-1 in the range 1..32767]
 * @cw_max: maximum contention window [like @cw_min]
 * @txop: maximum burst time in units of 32 usecs, 0 meaning disabled
 * @acm: is mandatory admission control required for the access category
 * @uapsd: is U-APSD mode enabled for the queue
 */
struct ieee80211_tx_queue_params {
	u16 txop;
	u16 cw_min;
	u16 cw_max;
	u8 aifs;
	bool acm;
	bool uapsd;
};

struct ieee80211_low_level_stats {
	unsigned int dot11ACKFailureCount;
	unsigned int dot11RTSFailureCount;
	unsigned int dot11FCSErrorCount;
	unsigned int dot11RTSSuccessCount;
};

/**
 * enum ieee80211_chanctx_change - change flag for channel context
 * @IEEE80211_CHANCTX_CHANGE_WIDTH: The channel width changed
 * @IEEE80211_CHANCTX_CHANGE_RX_CHAINS: The number of RX chains changed
 * @IEEE80211_CHANCTX_CHANGE_RADAR: radar detection flag changed
 * @IEEE80211_CHANCTX_CHANGE_CHANNEL: switched to another operating channel,
 *	this is used only with channel switching with CSA
 * @IEEE80211_CHANCTX_CHANGE_MIN_WIDTH: The min required channel width changed
 */
enum ieee80211_chanctx_change {
	IEEE80211_CHANCTX_CHANGE_WIDTH		= BIT(0),
	IEEE80211_CHANCTX_CHANGE_RX_CHAINS	= BIT(1),
	IEEE80211_CHANCTX_CHANGE_RADAR		= BIT(2),
	IEEE80211_CHANCTX_CHANGE_CHANNEL	= BIT(3),
	IEEE80211_CHANCTX_CHANGE_MIN_WIDTH	= BIT(4),
};

/**
 * struct ieee80211_chanctx_conf - channel context that vifs may be tuned to
 *
 * This is the driver-visible part. The ieee80211_chanctx
 * that contains it is visible in mac80211 only.
 *
 * @def: the channel definition
 * @min_def: the minimum channel definition currently required.
 * @rx_chains_static: The number of RX chains that must always be
 *	active on the channel to receive MIMO transmissions
 * @rx_chains_dynamic: The number of RX chains that must be enabled
 *	after RTS/CTS handshake to receive SMPS MIMO transmissions;
 *	this will always be >= @rx_chains_static.
 * @radar_enabled: whether radar detection is enabled on this channel.
 * @drv_priv: data area for driver use, will always be aligned to
 *	sizeof(void *), size is determined in hw information.
 */
struct ieee80211_chanctx_conf {
	struct cfg80211_chan_def def;
	struct cfg80211_chan_def min_def;

	u8 rx_chains_static, rx_chains_dynamic;

	bool radar_enabled;

	u8 drv_priv[0] __aligned(sizeof(void *));
};

/**
 * enum ieee80211_chanctx_switch_mode - channel context switch mode
 * @CHANCTX_SWMODE_REASSIGN_VIF: Both old and new contexts already
 *	exist (and will continue to exist), but the virtual interface
 *	needs to be switched from one to the other.
 * @CHANCTX_SWMODE_SWAP_CONTEXTS: The old context exists but will stop
 *      to exist with this call, the new context doesn't exist but
 *      will be active after this call, the virtual interface switches
 *      from the old to the new (note that the driver may of course
 *      implement this as an on-the-fly chandef switch of the existing
 *      hardware context, but the mac80211 pointer for the old context
 *      will cease to exist and only the new one will later be used
 *      for changes/removal.)
 */
enum ieee80211_chanctx_switch_mode {
	CHANCTX_SWMODE_REASSIGN_VIF,
	CHANCTX_SWMODE_SWAP_CONTEXTS,
};

/**
 * struct ieee80211_vif_chanctx_switch - vif chanctx switch information
 *
 * This is structure is used to pass information about a vif that
 * needs to switch from one chanctx to another.  The
 * &ieee80211_chanctx_switch_mode defines how the switch should be
 * done.
 *
 * @vif: the vif that should be switched from old_ctx to new_ctx
 * @old_ctx: the old context to which the vif was assigned
 * @new_ctx: the new context to which the vif must be assigned
 */
struct ieee80211_vif_chanctx_switch {
	struct ieee80211_vif *vif;
	struct ieee80211_chanctx_conf *old_ctx;
	struct ieee80211_chanctx_conf *new_ctx;
};

/**
 * enum ieee80211_bss_change - BSS change notification flags
 *
 * These flags are used with the bss_info_changed() callback
 * to indicate which BSS parameter changed.
 *
 * @BSS_CHANGED_ASSOC: association status changed (associated/disassociated),
 *	also implies a change in the AID.
 * @BSS_CHANGED_ERP_CTS_PROT: CTS protection changed
 * @BSS_CHANGED_ERP_PREAMBLE: preamble changed
 * @BSS_CHANGED_ERP_SLOT: slot timing changed
 * @BSS_CHANGED_HT: 802.11n parameters changed
 * @BSS_CHANGED_BASIC_RATES: Basic rateset changed
 * @BSS_CHANGED_BEACON_INT: Beacon interval changed
 * @BSS_CHANGED_BSSID: BSSID changed, for whatever
 *	reason (IBSS and managed mode)
 * @BSS_CHANGED_BEACON: Beacon data changed, retrieve
 *	new beacon (beaconing modes)
 * @BSS_CHANGED_BEACON_ENABLED: Beaconing should be
 *	enabled/disabled (beaconing modes)
 * @BSS_CHANGED_CQM: Connection quality monitor config changed
 * @BSS_CHANGED_IBSS: IBSS join status changed
 * @BSS_CHANGED_ARP_FILTER: Hardware ARP filter address list or state changed.
 * @BSS_CHANGED_QOS: QoS for this association was enabled/disabled. Note
 *	that it is only ever disabled for station mode.
 * @BSS_CHANGED_IDLE: Idle changed for this BSS/interface.
 * @BSS_CHANGED_SSID: SSID changed for this BSS (AP and IBSS mode)
 * @BSS_CHANGED_AP_PROBE_RESP: Probe Response changed for this BSS (AP mode)
 * @BSS_CHANGED_PS: PS changed for this BSS (STA mode)
 * @BSS_CHANGED_TXPOWER: TX power setting changed for this interface
 * @BSS_CHANGED_P2P_PS: P2P powersave settings (CTWindow, opportunistic PS)
 *	changed (currently only in P2P client mode, GO mode will be later)
 * @BSS_CHANGED_BEACON_INFO: Data from the AP's beacon became available:
 *	currently dtim_period only is under consideration.
 * @BSS_CHANGED_BANDWIDTH: The bandwidth used by this interface changed,
 *	note that this is only called when it changes after the channel
 *	context had been assigned.
 * @BSS_CHANGED_OCB: OCB join status changed
 */
enum ieee80211_bss_change {
	BSS_CHANGED_ASSOC		= 1<<0,
	BSS_CHANGED_ERP_CTS_PROT	= 1<<1,
	BSS_CHANGED_ERP_PREAMBLE	= 1<<2,
	BSS_CHANGED_ERP_SLOT		= 1<<3,
	BSS_CHANGED_HT			= 1<<4,
	BSS_CHANGED_BASIC_RATES		= 1<<5,
	BSS_CHANGED_BEACON_INT		= 1<<6,
	BSS_CHANGED_BSSID		= 1<<7,
	BSS_CHANGED_BEACON		= 1<<8,
	BSS_CHANGED_BEACON_ENABLED	= 1<<9,
	BSS_CHANGED_CQM			= 1<<10,
	BSS_CHANGED_IBSS		= 1<<11,
	BSS_CHANGED_ARP_FILTER		= 1<<12,
	BSS_CHANGED_QOS			= 1<<13,
	BSS_CHANGED_IDLE		= 1<<14,
	BSS_CHANGED_SSID		= 1<<15,
	BSS_CHANGED_AP_PROBE_RESP	= 1<<16,
	BSS_CHANGED_PS			= 1<<17,
	BSS_CHANGED_TXPOWER		= 1<<18,
	BSS_CHANGED_P2P_PS		= 1<<19,
	BSS_CHANGED_BEACON_INFO		= 1<<20,
	BSS_CHANGED_BANDWIDTH		= 1<<21,
	BSS_CHANGED_OCB                 = 1<<22,

	/* when adding here, make sure to change ieee80211_reconfig */
};

/*
 * The maximum number of IPv4 addresses listed for ARP filtering. If the number
 * of addresses for an interface increase beyond this value, hardware ARP
 * filtering will be disabled.
 */
#define IEEE80211_BSS_ARP_ADDR_LIST_LEN 4

/**
 * enum ieee80211_event_type - event to be notified to the low level driver
 * @RSSI_EVENT: AP's rssi crossed the a threshold set by the driver.
 * @MLME_EVENT: event related to MLME
 */
enum ieee80211_event_type {
	RSSI_EVENT,
	MLME_EVENT,
};

/**
 * enum ieee80211_rssi_event_data - relevant when event type is %RSSI_EVENT
 * @RSSI_EVENT_HIGH: AP's rssi went below the threshold set by the driver.
 * @RSSI_EVENT_LOW: AP's rssi went above the threshold set by the driver.
 */
enum ieee80211_rssi_event_data {
	RSSI_EVENT_HIGH,
	RSSI_EVENT_LOW,
};

/**
 * struct ieee80211_rssi_event - data attached to an %RSSI_EVENT
 * @data: See &enum ieee80211_rssi_event_data
 */
struct ieee80211_rssi_event {
	enum ieee80211_rssi_event_data data;
};

/**
 * enum ieee80211_mlme_event_data - relevant when event type is %MLME_EVENT
 * @AUTH_EVENT: the MLME operation is authentication
 * @ASSOC_EVENT: the MLME operation is association
 * @DEAUTH_RX_EVENT: deauth received..
 * @DEAUTH_TX_EVENT: deauth sent.
 */
enum ieee80211_mlme_event_data {
	AUTH_EVENT,
	ASSOC_EVENT,
	DEAUTH_RX_EVENT,
	DEAUTH_TX_EVENT,
};

/**
 * enum ieee80211_mlme_event_status - relevant when event type is %MLME_EVENT
 * @MLME_SUCCESS: the MLME operation completed successfully.
 * @MLME_DENIED: the MLME operation was denied by the peer.
 * @MLME_TIMEOUT: the MLME operation timed out.
 */
enum ieee80211_mlme_event_status {
	MLME_SUCCESS,
	MLME_DENIED,
	MLME_TIMEOUT,
};

/**
 * struct ieee80211_mlme_event - data attached to an %MLME_EVENT
 * @data: See &enum ieee80211_mlme_event_data
 * @status: See &enum ieee80211_mlme_event_status
 * @reason: the reason code if applicable
 */
struct ieee80211_mlme_event {
	enum ieee80211_mlme_event_data data;
	enum ieee80211_mlme_event_status status;
	u16 reason;
};

/**
 * struct ieee80211_event - event to be sent to the driver
 * @type: The event itself. See &enum ieee80211_event_type.
 * @rssi: relevant if &type is %RSSI_EVENT
 * @mlme: relevant if &type is %AUTH_EVENT
 * @u:    union holding the above two fields
 */
struct ieee80211_event {
	enum ieee80211_event_type type;
	union {
		struct ieee80211_rssi_event rssi;
		struct ieee80211_mlme_event mlme;
	} u;
};

/**
 * struct ieee80211_bss_conf - holds the BSS's changing parameters
 *
 * This structure keeps information about a BSS (and an association
 * to that BSS) that can change during the lifetime of the BSS.
 *
 * @assoc: association status
 * @ibss_joined: indicates whether this station is part of an IBSS
 *	or not
 * @ibss_creator: indicates if a new IBSS network is being created
 * @aid: association ID number, valid only when @assoc is true
 * @use_cts_prot: use CTS protection
 * @use_short_preamble: use 802.11b short preamble;
 *	if the hardware cannot handle this it must set the
 *	IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE hardware flag
 * @use_short_slot: use short slot time (only relevant for ERP);
 *	if the hardware cannot handle this it must set the
 *	IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE hardware flag
 * @dtim_period: num of beacons before the next DTIM, for beaconing,
 *	valid in station mode only if after the driver was notified
 *	with the %BSS_CHANGED_BEACON_INFO flag, will be non-zero then.
 * @sync_tsf: last beacon's/probe response's TSF timestamp (could be old
 *	as it may have been received during scanning long ago). If the
 *	HW flag %IEEE80211_HW_TIMING_BEACON_ONLY is set, then this can
 *	only come from a beacon, but might not become valid until after
 *	association when a beacon is received (which is notified with the
 *	%BSS_CHANGED_DTIM flag.). See also sync_dtim_count important notice.
 * @sync_device_ts: the device timestamp corresponding to the sync_tsf,
 *	the driver/device can use this to calculate synchronisation
 *	(see @sync_tsf). See also sync_dtim_count important notice.
 * @sync_dtim_count: Only valid when %IEEE80211_HW_TIMING_BEACON_ONLY
 *	is requested, see @sync_tsf/@sync_device_ts.
 *	IMPORTANT: These three sync_* parameters would possibly be out of sync
 *	by the time the driver will use them. The synchronized view is currently
 *	guaranteed only in certain callbacks.
 * @beacon_int: beacon interval
 * @assoc_capability: capabilities taken from assoc resp
 * @basic_rates: bitmap of basic rates, each bit stands for an
 *	index into the rate table configured by the driver in
 *	the current band.
 * @beacon_rate: associated AP's beacon TX rate
 * @mcast_rate: per-band multicast rate index + 1 (0: disabled)
 * @bssid: The BSSID for this BSS
 * @enable_beacon: whether beaconing should be enabled or not
 * @chandef: Channel definition for this BSS -- the hardware might be
 *	configured a higher bandwidth than this BSS uses, for example.
 * @ht_operation_mode: HT operation mode like in &struct ieee80211_ht_operation.
 *	This field is only valid when the channel type is one of the HT types.
 * @cqm_rssi_thold: Connection quality monitor RSSI threshold, a zero value
 *	implies disabled
 * @cqm_rssi_hyst: Connection quality monitor RSSI hysteresis
 * @arp_addr_list: List of IPv4 addresses for hardware ARP filtering. The
 *	may filter ARP queries targeted for other addresses than listed here.
 *	The driver must allow ARP queries targeted for all address listed here
 *	to pass through. An empty list implies no ARP queries need to pass.
 * @arp_addr_cnt: Number of addresses currently on the list. Note that this
 *	may be larger than %IEEE80211_BSS_ARP_ADDR_LIST_LEN (the arp_addr_list
 *	array size), it's up to the driver what to do in that case.
 * @qos: This is a QoS-enabled BSS.
 * @idle: This interface is idle. There's also a global idle flag in the
 *	hardware config which may be more appropriate depending on what
 *	your driver/device needs to do.
 * @ps: power-save mode (STA only). This flag is NOT affected by
 *	offchannel/dynamic_ps operations.
 * @ssid: The SSID of the current vif. Valid in AP and IBSS mode.
 * @ssid_len: Length of SSID given in @ssid.
 * @hidden_ssid: The SSID of the current vif is hidden. Only valid in AP-mode.
 * @txpower: TX power in dBm
 * @txpower_type: TX power adjustment used to control per packet Transmit
 *	Power Control (TPC) in lower driver for the current vif. In particular
 *	TPC is enabled if value passed in %txpower_type is
 *	NL80211_TX_POWER_LIMITED (allow using less than specified from
 *	userspace), whereas TPC is disabled if %txpower_type is set to
 *	NL80211_TX_POWER_FIXED (use value configured from userspace)
 * @p2p_noa_attr: P2P NoA attribute for P2P powersave
 */
struct ieee80211_bss_conf {
	const u8 *bssid;
	/* association related data */
	bool assoc, ibss_joined;
	bool ibss_creator;
	u16 aid;
	/* erp related data */
	bool use_cts_prot;
	bool use_short_preamble;
	bool use_short_slot;
	bool enable_beacon;
	u8 dtim_period;
	u16 beacon_int;
	u16 assoc_capability;
	u64 sync_tsf;
	u32 sync_device_ts;
	u8 sync_dtim_count;
	u32 basic_rates;
	struct ieee80211_rate *beacon_rate;
	int mcast_rate[IEEE80211_NUM_BANDS];
	u16 ht_operation_mode;
	s32 cqm_rssi_thold;
	u32 cqm_rssi_hyst;
	struct cfg80211_chan_def chandef;
	__be32 arp_addr_list[IEEE80211_BSS_ARP_ADDR_LIST_LEN];
	int arp_addr_cnt;
	bool qos;
	bool idle;
	bool ps;
	u8 ssid[IEEE80211_MAX_SSID_LEN];
	size_t ssid_len;
	bool hidden_ssid;
	int txpower;
	enum nl80211_tx_power_setting txpower_type;
	struct ieee80211_p2p_noa_attr p2p_noa_attr;
};

/**
 * enum mac80211_tx_info_flags - flags to describe transmission information/status
 *
 * These flags are used with the @flags member of &ieee80211_tx_info.
 *
 * @IEEE80211_TX_CTL_REQ_TX_STATUS: require TX status callback for this frame.
 * @IEEE80211_TX_CTL_ASSIGN_SEQ: The driver has to assign a sequence
 *	number to this frame, taking care of not overwriting the fragment
 *	number and increasing the sequence number only when the
 *	IEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly
 *	assign sequence numbers to QoS-data frames but cannot do so correctly
 *	for non-QoS-data and management frames because beacons need them from
 *	that counter as well and mac80211 cannot guarantee proper sequencing.
 *	If this flag is set, the driver should instruct the hardware to
 *	assign a sequence number to the frame or assign one itself. Cf. IEEE
 *	802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for
 *	beacons and always be clear for frames without a sequence number field.
 * @IEEE80211_TX_CTL_NO_ACK: tell the low level not to wait for an ack
 * @IEEE80211_TX_CTL_CLEAR_PS_FILT: clear powersave filter for destination
 *	station
 * @IEEE80211_TX_CTL_FIRST_FRAGMENT: this is a first fragment of the frame
 * @IEEE80211_TX_CTL_SEND_AFTER_DTIM: send this frame after DTIM beacon
 * @IEEE80211_TX_CTL_AMPDU: this frame should be sent as part of an A-MPDU
 * @IEEE80211_TX_CTL_INJECTED: Frame was injected, internal to mac80211.
 * @IEEE80211_TX_STAT_TX_FILTERED: The frame was not transmitted
 *	because the destination STA was in powersave mode. Note that to
 *	avoid race conditions, the filter must be set by the hardware or
 *	firmware upon receiving a frame that indicates that the station
 *	went to sleep (must be done on device to filter frames already on
 *	the queue) and may only be unset after mac80211 gives the OK for
 *	that by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),
 *	since only then is it guaranteed that no more frames are in the
 *	hardware queue.
 * @IEEE80211_TX_STAT_ACK: Frame was acknowledged
 * @IEEE80211_TX_STAT_AMPDU: The frame was aggregated, so status
 * 	is for the whole aggregation.
 * @IEEE80211_TX_STAT_AMPDU_NO_BACK: no block ack was returned,
 * 	so consider using block ack request (BAR).
 * @IEEE80211_TX_CTL_RATE_CTRL_PROBE: internal to mac80211, can be
 *	set by rate control algorithms to indicate probe rate, will
 *	be cleared for fragmented frames (except on the last fragment)
 * @IEEE80211_TX_INTFL_OFFCHAN_TX_OK: Internal to mac80211. Used to indicate
 *	that a frame can be transmitted while the queues are stopped for
 *	off-channel operation.
 * @IEEE80211_TX_INTFL_NEED_TXPROCESSING: completely internal to mac80211,
 *	used to indicate that a pending frame requires TX processing before
 *	it can be sent out.
 * @IEEE80211_TX_INTFL_RETRIED: completely internal to mac80211,
 *	used to indicate that a frame was already retried due to PS
 * @IEEE80211_TX_INTFL_DONT_ENCRYPT: completely internal to mac80211,
 *	used to indicate frame should not be encrypted
 * @IEEE80211_TX_CTL_NO_PS_BUFFER: This frame is a response to a poll
 *	frame (PS-Poll or uAPSD) or a non-bufferable MMPDU and must
 *	be sent although the station is in powersave mode.
 * @IEEE80211_TX_CTL_MORE_FRAMES: More frames will be passed to the
 *	transmit function after the current frame, this can be used
 *	by drivers to kick the DMA queue only if unset or when the
 *	queue gets full.
 * @IEEE80211_TX_INTFL_RETRANSMISSION: This frame is being retransmitted
 *	after TX status because the destination was asleep, it must not
 *	be modified again (no seqno assignment, crypto, etc.)
 * @IEEE80211_TX_INTFL_MLME_CONN_TX: This frame was transmitted by the MLME
 *	code for connection establishment, this indicates that its status
 *	should kick the MLME state machine.
 * @IEEE80211_TX_INTFL_NL80211_FRAME_TX: Frame was requested through nl80211
 *	MLME command (internal to mac80211 to figure out whether to send TX
 *	status to user space)
 * @IEEE80211_TX_CTL_LDPC: tells the driver to use LDPC for this frame
 * @IEEE80211_TX_CTL_STBC: Enables Space-Time Block Coding (STBC) for this
 *	frame and selects the maximum number of streams that it can use.
 * @IEEE80211_TX_CTL_TX_OFFCHAN: Marks this packet to be transmitted on
 *	the off-channel channel when a remain-on-channel offload is done
 *	in hardware -- normal packets still flow and are expected to be
 *	handled properly by the device.
 * @IEEE80211_TX_INTFL_TKIP_MIC_FAILURE: Marks this packet to be used for TKIP
 *	testing. It will be sent out with incorrect Michael MIC key to allow
 *	TKIP countermeasures to be tested.
 * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.
 *	This flag is actually used for management frame especially for P2P
 *	frames not being sent at CCK rate in 2GHz band.
 * @IEEE80211_TX_STATUS_EOSP: This packet marks the end of service period,
 *	when its status is reported the service period ends. For frames in
 *	an SP that mac80211 transmits, it is already set; for driver frames
 *	the driver may set this flag. It is also used to do the same for
 *	PS-Poll responses.
 * @IEEE80211_TX_CTL_USE_MINRATE: This frame will be sent at lowest rate.
 *	This flag is used to send nullfunc frame at minimum rate when
 *	the nullfunc is used for connection monitoring purpose.
 * @IEEE80211_TX_CTL_DONTFRAG: Don't fragment this packet even if it
 *	would be fragmented by size (this is optional, only used for
 *	monitor injection).
 * @IEEE80211_TX_STAT_NOACK_TRANSMITTED: A frame that was marked with
 *	IEEE80211_TX_CTL_NO_ACK has been successfully transmitted without
 *	any errors (like issues specific to the driver/HW).
 *	This flag must not be set for frames that don't request no-ack
 *	behaviour with IEEE80211_TX_CTL_NO_ACK.
 *
 * Note: If you have to add new flags to the enumeration, then don't
 *	 forget to update %IEEE80211_TX_TEMPORARY_FLAGS when necessary.
 */
enum mac80211_tx_info_flags {
	IEEE80211_TX_CTL_REQ_TX_STATUS		= BIT(0),
	IEEE80211_TX_CTL_ASSIGN_SEQ		= BIT(1),
	IEEE80211_TX_CTL_NO_ACK			= BIT(2),
	IEEE80211_TX_CTL_CLEAR_PS_FILT		= BIT(3),
	IEEE80211_TX_CTL_FIRST_FRAGMENT		= BIT(4),
	IEEE80211_TX_CTL_SEND_AFTER_DTIM	= BIT(5),
	IEEE80211_TX_CTL_AMPDU			= BIT(6),
	IEEE80211_TX_CTL_INJECTED		= BIT(7),
	IEEE80211_TX_STAT_TX_FILTERED		= BIT(8),
	IEEE80211_TX_STAT_ACK			= BIT(9),
	IEEE80211_TX_STAT_AMPDU			= BIT(10),
	IEEE80211_TX_STAT_AMPDU_NO_BACK		= BIT(11),
	IEEE80211_TX_CTL_RATE_CTRL_PROBE	= BIT(12),
	IEEE80211_TX_INTFL_OFFCHAN_TX_OK	= BIT(13),
	IEEE80211_TX_INTFL_NEED_TXPROCESSING	= BIT(14),
	IEEE80211_TX_INTFL_RETRIED		= BIT(15),
	IEEE80211_TX_INTFL_DONT_ENCRYPT		= BIT(16),
	IEEE80211_TX_CTL_NO_PS_BUFFER		= BIT(17),
	IEEE80211_TX_CTL_MORE_FRAMES		= BIT(18),
	IEEE80211_TX_INTFL_RETRANSMISSION	= BIT(19),
	IEEE80211_TX_INTFL_MLME_CONN_TX		= BIT(20),
	IEEE80211_TX_INTFL_NL80211_FRAME_TX	= BIT(21),
	IEEE80211_TX_CTL_LDPC			= BIT(22),
	IEEE80211_TX_CTL_STBC			= BIT(23) | BIT(24),
	IEEE80211_TX_CTL_TX_OFFCHAN		= BIT(25),
	IEEE80211_TX_INTFL_TKIP_MIC_FAILURE	= BIT(26),
	IEEE80211_TX_CTL_NO_CCK_RATE		= BIT(27),
	IEEE80211_TX_STATUS_EOSP		= BIT(28),
	IEEE80211_TX_CTL_USE_MINRATE		= BIT(29),
	IEEE80211_TX_CTL_DONTFRAG		= BIT(30),
	IEEE80211_TX_STAT_NOACK_TRANSMITTED	= BIT(31),
};

#define IEEE80211_TX_CTL_STBC_SHIFT		23

/**
 * enum mac80211_tx_control_flags - flags to describe transmit control
 *
 * @IEEE80211_TX_CTRL_PORT_CTRL_PROTO: this frame is a port control
 *	protocol frame (e.g. EAP)
 * @IEEE80211_TX_CTRL_PS_RESPONSE: This frame is a response to a poll
 *	frame (PS-Poll or uAPSD).
 *
 * These flags are used in tx_info->control.flags.
 */
enum mac80211_tx_control_flags {
	IEEE80211_TX_CTRL_PORT_CTRL_PROTO	= BIT(0),
	IEEE80211_TX_CTRL_PS_RESPONSE		= BIT(1),
};

/*
 * This definition is used as a mask to clear all temporary flags, which are
 * set by the tx handlers for each transmission attempt by the mac80211 stack.
 */
#define IEEE80211_TX_TEMPORARY_FLAGS (IEEE80211_TX_CTL_NO_ACK |		      \
	IEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT |    \
	IEEE80211_TX_CTL_SEND_AFTER_DTIM | IEEE80211_TX_CTL_AMPDU |	      \
	IEEE80211_TX_STAT_TX_FILTERED |	IEEE80211_TX_STAT_ACK |		      \
	IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |	      \
	IEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_NO_PS_BUFFER |    \
	IEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |		      \
	IEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)

/**
 * enum mac80211_rate_control_flags - per-rate flags set by the
 *	Rate Control algorithm.
 *
 * These flags are set by the Rate control algorithm for each rate during tx,
 * in the @flags member of struct ieee80211_tx_rate.
 *
 * @IEEE80211_TX_RC_USE_RTS_CTS: Use RTS/CTS exchange for this rate.
 * @IEEE80211_TX_RC_USE_CTS_PROTECT: CTS-to-self protection is required.
 *	This is set if the current BSS requires ERP protection.
 * @IEEE80211_TX_RC_USE_SHORT_PREAMBLE: Use short preamble.
 * @IEEE80211_TX_RC_MCS: HT rate.
 * @IEEE80211_TX_RC_VHT_MCS: VHT MCS rate, in this case the idx field is split
 *	into a higher 4 bits (Nss) and lower 4 bits (MCS number)
 * @IEEE80211_TX_RC_GREEN_FIELD: Indicates whether this rate should be used in
 *	Greenfield mode.
 * @IEEE80211_TX_RC_40_MHZ_WIDTH: Indicates if the Channel Width should be 40 MHz.
 * @IEEE80211_TX_RC_80_MHZ_WIDTH: Indicates 80 MHz transmission
 * @IEEE80211_TX_RC_160_MHZ_WIDTH: Indicates 160 MHz transmission
 *	(80+80 isn't supported yet)
 * @IEEE80211_TX_RC_DUP_DATA: The frame should be transmitted on both of the
 *	adjacent 20 MHz channels, if the current channel type is
 *	NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.
 * @IEEE80211_TX_RC_SHORT_GI: Short Guard interval should be used for this rate.
 */
enum mac80211_rate_control_flags {
	IEEE80211_TX_RC_USE_RTS_CTS		= BIT(0),
	IEEE80211_TX_RC_USE_CTS_PROTECT		= BIT(1),
	IEEE80211_TX_RC_USE_SHORT_PREAMBLE	= BIT(2),

	/* rate index is an HT/VHT MCS instead of an index */
	IEEE80211_TX_RC_MCS			= BIT(3),
	IEEE80211_TX_RC_GREEN_FIELD		= BIT(4),
	IEEE80211_TX_RC_40_MHZ_WIDTH		= BIT(5),
	IEEE80211_TX_RC_DUP_DATA		= BIT(6),
	IEEE80211_TX_RC_SHORT_GI		= BIT(7),
	IEEE80211_TX_RC_VHT_MCS			= BIT(8),
	IEEE80211_TX_RC_80_MHZ_WIDTH		= BIT(9),
	IEEE80211_TX_RC_160_MHZ_WIDTH		= BIT(10),
};


/* there are 40 bytes if you don't need the rateset to be kept */
#define IEEE80211_TX_INFO_DRIVER_DATA_SIZE 40

/* if you do need the rateset, then you have less space */
#define IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE 24

/* maximum number of rate stages */
#define IEEE80211_TX_MAX_RATES	4

/* maximum number of rate table entries */
#define IEEE80211_TX_RATE_TABLE_SIZE	4

/**
 * struct ieee80211_tx_rate - rate selection/status
 *
 * @idx: rate index to attempt to send with
 * @flags: rate control flags (&enum mac80211_rate_control_flags)
 * @count: number of tries in this rate before going to the next rate
 *
 * A value of -1 for @idx indicates an invalid rate and, if used
 * in an array of retry rates, that no more rates should be tried.
 *
 * When used for transmit status reporting, the driver should
 * always report the rate along with the flags it used.
 *
 * &struct ieee80211_tx_info contains an array of these structs
 * in the control information, and it will be filled by the rate
 * control algorithm according to what should be sent. For example,
 * if this array contains, in the format { <idx>, <count> } the
 * information
 *    { 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }
 * then this means that the frame should be transmitted
 * up to twice at rate 3, up to twice at rate 2, and up to four
 * times at rate 1 if it doesn't get acknowledged. Say it gets
 * acknowledged by the peer after the fifth attempt, the status
 * information should then contain
 *   { 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...
 * since it was transmitted twice at rate 3, twice at rate 2
 * and once at rate 1 after which we received an acknowledgement.
 */
struct ieee80211_tx_rate {
	s8 idx;
	u16 count:5,
	    flags:11;
} __packed;

#define IEEE80211_MAX_TX_RETRY		31

static inline void ieee80211_rate_set_vht(struct ieee80211_tx_rate *rate,
					  u8 mcs, u8 nss)
{
	WARN_ON(mcs & ~0xF);
	WARN_ON((nss - 1) & ~0x7);
	rate->idx = ((nss - 1) << 4) | mcs;
}

static inline u8
ieee80211_rate_get_vht_mcs(const struct ieee80211_tx_rate *rate)
{
	return rate->idx & 0xF;
}

static inline u8
ieee80211_rate_get_vht_nss(const struct ieee80211_tx_rate *rate)
{
	return (rate->idx >> 4) + 1;
}

/**
 * struct ieee80211_tx_info - skb transmit information
 *
 * This structure is placed in skb->cb for three uses:
 *  (1) mac80211 TX control - mac80211 tells the driver what to do
 *  (2) driver internal use (if applicable)
 *  (3) TX status information - driver tells mac80211 what happened
 *
 * @flags: transmit info flags, defined above
 * @band: the band to transmit on (use for checking for races)
 * @hw_queue: HW queue to put the frame on, skb_get_queue_mapping() gives the AC
 * @ack_frame_id: internal frame ID for TX status, used internally
 * @control: union for control data
 * @status: union for status data
 * @driver_data: array of driver_data pointers
 * @ampdu_ack_len: number of acked aggregated frames.
 * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.
 * @ampdu_len: number of aggregated frames.
 * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.
 * @ack_signal: signal strength of the ACK frame
 */
struct ieee80211_tx_info {
	/* common information */
	u32 flags;
	u8 band;

	u8 hw_queue;

	u16 ack_frame_id;

	union {
		struct {
			union {
				/* rate control */
				struct {
					struct ieee80211_tx_rate rates[
						IEEE80211_TX_MAX_RATES];
					s8 rts_cts_rate_idx;
					u8 use_rts:1;
					u8 use_cts_prot:1;
					u8 short_preamble:1;
					u8 skip_table:1;
					/* 2 bytes free */
				};
				/* only needed before rate control */
				unsigned long jiffies;
			};
			/* NB: vif can be NULL for injected frames */
			struct ieee80211_vif *vif;
			struct ieee80211_key_conf *hw_key;
			u32 flags;
			/* 4 bytes free */
		} control;
		struct {
			struct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];
			s32 ack_signal;
			u8 ampdu_ack_len;
			u8 ampdu_len;
			u8 antenna;
			u16 tx_time;
			void *status_driver_data[19 / sizeof(void *)];
		} status;
		struct {
			struct ieee80211_tx_rate driver_rates[
				IEEE80211_TX_MAX_RATES];
			u8 pad[4];

			void *rate_driver_data[
				IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE / sizeof(void *)];
		};
		void *driver_data[
			IEEE80211_TX_INFO_DRIVER_DATA_SIZE / sizeof(void *)];
	};
};

/**
 * struct ieee80211_scan_ies - descriptors for different blocks of IEs
 *
 * This structure is used to point to different blocks of IEs in HW scan
 * and scheduled scan. These blocks contain the IEs passed by userspace
 * and the ones generated by mac80211.
 *
 * @ies: pointers to band specific IEs.
 * @len: lengths of band_specific IEs.
 * @common_ies: IEs for all bands (especially vendor specific ones)
 * @common_ie_len: length of the common_ies
 */
struct ieee80211_scan_ies {
	const u8 *ies[IEEE80211_NUM_BANDS];
	size_t len[IEEE80211_NUM_BANDS];
	const u8 *common_ies;
	size_t common_ie_len;
};


static inline struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb)
{
	return (struct ieee80211_tx_info *)skb->cb;
}

static inline struct ieee80211_rx_status *IEEE80211_SKB_RXCB(struct sk_buff *skb)
{
	return (struct ieee80211_rx_status *)skb->cb;
}

/**
 * ieee80211_tx_info_clear_status - clear TX status
 *
 * @info: The &struct ieee80211_tx_info to be cleared.
 *
 * When the driver passes an skb back to mac80211, it must report
 * a number of things in TX status. This function clears everything
 * in the TX status but the rate control information (it does clear
 * the count since you need to fill that in anyway).
 *
 * NOTE: You can only use this function if you do NOT use
 *	 info->driver_data! Use info->rate_driver_data
 *	 instead if you need only the less space that allows.
 */
static inline void
ieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)
{
	int i;

	BUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=
		     offsetof(struct ieee80211_tx_info, control.rates));
	BUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=
		     offsetof(struct ieee80211_tx_info, driver_rates));
	BUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) != 8);
	/* clear the rate counts */
	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
		info->status.rates[i].count = 0;

	BUILD_BUG_ON(
	    offsetof(struct ieee80211_tx_info, status.ack_signal) != 20);
	memset(&info->status.ampdu_ack_len, 0,
	       sizeof(struct ieee80211_tx_info) -
	       offsetof(struct ieee80211_tx_info, status.ampdu_ack_len));
}


/**
 * enum mac80211_rx_flags - receive flags
 *
 * These flags are used with the @flag member of &struct ieee80211_rx_status.
 * @RX_FLAG_MMIC_ERROR: Michael MIC error was reported on this frame.
 *	Use together with %RX_FLAG_MMIC_STRIPPED.
 * @RX_FLAG_DECRYPTED: This frame was decrypted in hardware.
 * @RX_FLAG_MMIC_STRIPPED: the Michael MIC is stripped off this frame,
 *	verification has been done by the hardware.
 * @RX_FLAG_IV_STRIPPED: The IV/ICV are stripped from this frame.
 *	If this flag is set, the stack cannot do any replay detection
 *	hence the driver or hardware will have to do that.
 * @RX_FLAG_FAILED_FCS_CRC: Set this flag if the FCS check failed on
 *	the frame.
 * @RX_FLAG_FAILED_PLCP_CRC: Set this flag if the PCLP check failed on
 *	the frame.
 * @RX_FLAG_MACTIME_START: The timestamp passed in the RX status (@mactime
 *	field) is valid and contains the time the first symbol of the MPDU
 *	was received. This is useful in monitor mode and for proper IBSS
 *	merging.
 * @RX_FLAG_MACTIME_END: The timestamp passed in the RX status (@mactime
 *	field) is valid and contains the time the last symbol of the MPDU
 *	(including FCS) was received.
 * @RX_FLAG_SHORTPRE: Short preamble was used for this frame
 * @RX_FLAG_HT: HT MCS was used and rate_idx is MCS index
 * @RX_FLAG_VHT: VHT MCS was used and rate_index is MCS index
 * @RX_FLAG_40MHZ: HT40 (40 MHz) was used
 * @RX_FLAG_SHORT_GI: Short guard interval was used
 * @RX_FLAG_NO_SIGNAL_VAL: The signal strength value is not present.
 *	Valid only for data frames (mainly A-MPDU)
 * @RX_FLAG_HT_GF: This frame was received in a HT-greenfield transmission, if
 *	the driver fills this value it should add %IEEE80211_RADIOTAP_MCS_HAVE_FMT
 *	to hw.radiotap_mcs_details to advertise that fact
 * @RX_FLAG_AMPDU_DETAILS: A-MPDU details are known, in particular the reference
 *	number (@ampdu_reference) must be populated and be a distinct number for
 *	each A-MPDU
 * @RX_FLAG_AMPDU_REPORT_ZEROLEN: driver reports 0-length subframes
 * @RX_FLAG_AMPDU_IS_ZEROLEN: This is a zero-length subframe, for
 *	monitoring purposes only
 * @RX_FLAG_AMPDU_LAST_KNOWN: last subframe is known, should be set on all
 *	subframes of a single A-MPDU
 * @RX_FLAG_AMPDU_IS_LAST: this subframe is the last subframe of the A-MPDU
 * @RX_FLAG_AMPDU_DELIM_CRC_ERROR: A delimiter CRC error has been detected
 *	on this subframe
 * @RX_FLAG_AMPDU_DELIM_CRC_KNOWN: The delimiter CRC field is known (the CRC
 *	is stored in the @ampdu_delimiter_crc field)
 * @RX_FLAG_LDPC: LDPC was used
 * @RX_FLAG_STBC_MASK: STBC 2 bit bitmask. 1 - Nss=1, 2 - Nss=2, 3 - Nss=3
 * @RX_FLAG_10MHZ: 10 MHz (half channel) was used
 * @RX_FLAG_5MHZ: 5 MHz (quarter channel) was used
 * @RX_FLAG_AMSDU_MORE: Some drivers may prefer to report separate A-MSDU
 *	subframes instead of a one huge frame for performance reasons.
 *	All, but the last MSDU from an A-MSDU should have this flag set. E.g.
 *	if an A-MSDU has 3 frames, the first 2 must have the flag set, while
 *	the 3rd (last) one must not have this flag set. The flag is used to
 *	deal with retransmission/duplication recovery properly since A-MSDU
 *	subframes share the same sequence number. Reported subframes can be
 *	either regular MSDU or singly A-MSDUs. Subframes must not be
 *	interleaved with other frames.
 * @RX_FLAG_RADIOTAP_VENDOR_DATA: This frame contains vendor-specific
 *	radiotap data in the skb->data (before the frame) as described by
 *	the &struct ieee80211_vendor_radiotap.
 */
enum mac80211_rx_flags {
	RX_FLAG_MMIC_ERROR		= BIT(0),
	RX_FLAG_DECRYPTED		= BIT(1),
	RX_FLAG_MMIC_STRIPPED		= BIT(3),
	RX_FLAG_IV_STRIPPED		= BIT(4),
	RX_FLAG_FAILED_FCS_CRC		= BIT(5),
	RX_FLAG_FAILED_PLCP_CRC 	= BIT(6),
	RX_FLAG_MACTIME_START		= BIT(7),
	RX_FLAG_SHORTPRE		= BIT(8),
	RX_FLAG_HT			= BIT(9),
	RX_FLAG_40MHZ			= BIT(10),
	RX_FLAG_SHORT_GI		= BIT(11),
	RX_FLAG_NO_SIGNAL_VAL		= BIT(12),
	RX_FLAG_HT_GF			= BIT(13),
	RX_FLAG_AMPDU_DETAILS		= BIT(14),
	RX_FLAG_AMPDU_REPORT_ZEROLEN	= BIT(15),
	RX_FLAG_AMPDU_IS_ZEROLEN	= BIT(16),
	RX_FLAG_AMPDU_LAST_KNOWN	= BIT(17),
	RX_FLAG_AMPDU_IS_LAST		= BIT(18),
	RX_FLAG_AMPDU_DELIM_CRC_ERROR	= BIT(19),
	RX_FLAG_AMPDU_DELIM_CRC_KNOWN	= BIT(20),
	RX_FLAG_MACTIME_END		= BIT(21),
	RX_FLAG_VHT			= BIT(22),
	RX_FLAG_LDPC			= BIT(23),
	RX_FLAG_STBC_MASK		= BIT(26) | BIT(27),
	RX_FLAG_10MHZ			= BIT(28),
	RX_FLAG_5MHZ			= BIT(29),
	RX_FLAG_AMSDU_MORE		= BIT(30),
	RX_FLAG_RADIOTAP_VENDOR_DATA	= BIT(31),
};

#define RX_FLAG_STBC_SHIFT		26

/**
 * enum mac80211_rx_vht_flags - receive VHT flags
 *
 * These flags are used with the @vht_flag member of
 *	&struct ieee80211_rx_status.
 * @RX_VHT_FLAG_80MHZ: 80 MHz was used
 * @RX_VHT_FLAG_160MHZ: 160 MHz was used
 * @RX_VHT_FLAG_BF: packet was beamformed
 */
enum mac80211_rx_vht_flags {
	RX_VHT_FLAG_80MHZ		= BIT(0),
	RX_VHT_FLAG_160MHZ		= BIT(1),
	RX_VHT_FLAG_BF			= BIT(2),
};

/**
 * struct ieee80211_rx_status - receive status
 *
 * The low-level driver should provide this information (the subset
 * supported by hardware) to the 802.11 code with each received
 * frame, in the skb's control buffer (cb).
 *
 * @mactime: value in microseconds of the 64-bit Time Synchronization Function
 * 	(TSF) timer when the first data symbol (MPDU) arrived at the hardware.
 * @device_timestamp: arbitrary timestamp for the device, mac80211 doesn't use
 *	it but can store it and pass it back to the driver for synchronisation
 * @band: the active band when this frame was received
 * @freq: frequency the radio was tuned to when receiving this frame, in MHz
 * @signal: signal strength when receiving this frame, either in dBm, in dB or
 *	unspecified depending on the hardware capabilities flags
 *	@IEEE80211_HW_SIGNAL_*
 * @chains: bitmask of receive chains for which separate signal strength
 *	values were filled.
 * @chain_signal: per-chain signal strength, in dBm (unlike @signal, doesn't
 *	support dB or unspecified units)
 * @antenna: antenna used
 * @rate_idx: index of data rate into band's supported rates or MCS index if
 *	HT or VHT is used (%RX_FLAG_HT/%RX_FLAG_VHT)
 * @vht_nss: number of streams (VHT only)
 * @flag: %RX_FLAG_*
 * @vht_flag: %RX_VHT_FLAG_*
 * @rx_flags: internal RX flags for mac80211
 * @ampdu_reference: A-MPDU reference number, must be a different value for
 *	each A-MPDU but the same for each subframe within one A-MPDU
 * @ampdu_delimiter_crc: A-MPDU delimiter CRC
 */
struct ieee80211_rx_status {
	u64 mactime;
	u32 device_timestamp;
	u32 ampdu_reference;
	u32 flag;
	u16 freq;
	u8 vht_flag;
	u8 rate_idx;
	u8 vht_nss;
	u8 rx_flags;
	u8 band;
	u8 antenna;
	s8 signal;
	u8 chains;
	s8 chain_signal[IEEE80211_MAX_CHAINS];
	u8 ampdu_delimiter_crc;
};

/**
 * struct ieee80211_vendor_radiotap - vendor radiotap data information
 * @present: presence bitmap for this vendor namespace
 *	(this could be extended in the future if any vendor needs more
 *	 bits, the radiotap spec does allow for that)
 * @align: radiotap vendor namespace alignment. This defines the needed
 *	alignment for the @data field below, not for the vendor namespace
 *	description itself (which has a fixed 2-byte alignment)
 *	Must be a power of two, and be set to at least 1!
 * @oui: radiotap vendor namespace OUI
 * @subns: radiotap vendor sub namespace
 * @len: radiotap vendor sub namespace skip length, if alignment is done
 *	then that's added to this, i.e. this is only the length of the
 *	@data field.
 * @pad: number of bytes of padding after the @data, this exists so that
 *	the skb data alignment can be preserved even if the data has odd
 *	length
 * @data: the actual vendor namespace data
 *
 * This struct, including the vendor data, goes into the skb->data before
 * the 802.11 header. It's split up in mac80211 using the align/oui/subns
 * data.
 */
struct ieee80211_vendor_radiotap {
	u32 present;
	u8 align;
	u8 oui[3];
	u8 subns;
	u8 pad;
	u16 len;
	u8 data[];
} __packed;

/**
 * enum ieee80211_conf_flags - configuration flags
 *
 * Flags to define PHY configuration options
 *
 * @IEEE80211_CONF_MONITOR: there's a monitor interface present -- use this
 *	to determine for example whether to calculate timestamps for packets
 *	or not, do not use instead of filter flags!
 * @IEEE80211_CONF_PS: Enable 802.11 power save mode (managed mode only).
 *	This is the power save mode defined by IEEE 802.11-2007 section 11.2,
 *	meaning that the hardware still wakes up for beacons, is able to
 *	transmit frames and receive the possible acknowledgment frames.
 *	Not to be confused with hardware specific wakeup/sleep states,
 *	driver is responsible for that. See the section "Powersave support"
 *	for more.
 * @IEEE80211_CONF_IDLE: The device is running, but idle; if the flag is set
 *	the driver should be prepared to handle configuration requests but
 *	may turn the device off as much as possible. Typically, this flag will
 *	be set when an interface is set UP but not associated or scanning, but
 *	it can also be unset in that case when monitor interfaces are active.
 * @IEEE80211_CONF_OFFCHANNEL: The device is currently not on its main
 *	operating channel.
 */
enum ieee80211_conf_flags {
	IEEE80211_CONF_MONITOR		= (1<<0),
	IEEE80211_CONF_PS		= (1<<1),
	IEEE80211_CONF_IDLE		= (1<<2),
	IEEE80211_CONF_OFFCHANNEL	= (1<<3),
};


/**
 * enum ieee80211_conf_changed - denotes which configuration changed
 *
 * @IEEE80211_CONF_CHANGE_LISTEN_INTERVAL: the listen interval changed
 * @IEEE80211_CONF_CHANGE_MONITOR: the monitor flag changed
 * @IEEE80211_CONF_CHANGE_PS: the PS flag or dynamic PS timeout changed
 * @IEEE80211_CONF_CHANGE_POWER: the TX power changed
 * @IEEE80211_CONF_CHANGE_CHANNEL: the channel/channel_type changed
 * @IEEE80211_CONF_CHANGE_RETRY_LIMITS: retry limits changed
 * @IEEE80211_CONF_CHANGE_IDLE: Idle flag changed
 * @IEEE80211_CONF_CHANGE_SMPS: Spatial multiplexing powersave mode changed
 *	Note that this is only valid if channel contexts are not used,
 *	otherwise each channel context has the number of chains listed.
 */
enum ieee80211_conf_changed {
	IEEE80211_CONF_CHANGE_SMPS		= BIT(1),
	IEEE80211_CONF_CHANGE_LISTEN_INTERVAL	= BIT(2),
	IEEE80211_CONF_CHANGE_MONITOR		= BIT(3),
	IEEE80211_CONF_CHANGE_PS		= BIT(4),
	IEEE80211_CONF_CHANGE_POWER		= BIT(5),
	IEEE80211_CONF_CHANGE_CHANNEL		= BIT(6),
	IEEE80211_CONF_CHANGE_RETRY_LIMITS	= BIT(7),
	IEEE80211_CONF_CHANGE_IDLE		= BIT(8),
};

/**
 * enum ieee80211_smps_mode - spatial multiplexing power save mode
 *
 * @IEEE80211_SMPS_AUTOMATIC: automatic
 * @IEEE80211_SMPS_OFF: off
 * @IEEE80211_SMPS_STATIC: static
 * @IEEE80211_SMPS_DYNAMIC: dynamic
 * @IEEE80211_SMPS_NUM_MODES: internal, don't use
 */
enum ieee80211_smps_mode {
	IEEE80211_SMPS_AUTOMATIC,
	IEEE80211_SMPS_OFF,
	IEEE80211_SMPS_STATIC,
	IEEE80211_SMPS_DYNAMIC,

	/* keep last */
	IEEE80211_SMPS_NUM_MODES,
};

/**
 * struct ieee80211_conf - configuration of the device
 *
 * This struct indicates how the driver shall configure the hardware.
 *
 * @flags: configuration flags defined above
 *
 * @listen_interval: listen interval in units of beacon interval
 * @max_sleep_period: the maximum number of beacon intervals to sleep for
 *	before checking the beacon for a TIM bit (managed mode only); this
 *	value will be only achievable between DTIM frames, the hardware
 *	needs to check for the multicast traffic bit in DTIM beacons.
 *	This variable is valid only when the CONF_PS flag is set.
 * @ps_dtim_period: The DTIM period of the AP we're connected to, for use
 *	in power saving. Power saving will not be enabled until a beacon
 *	has been received and the DTIM period is known.
 * @dynamic_ps_timeout: The dynamic powersave timeout (in ms), see the
 *	powersave documentation below. This variable is valid only when
 *	the CONF_PS flag is set.
 *
 * @power_level: requested transmit power (in dBm), backward compatibility
 *	value only that is set to the minimum of all interfaces
 *
 * @chandef: the channel definition to tune to
 * @radar_enabled: whether radar detection is enabled
 *
 * @long_frame_max_tx_count: Maximum number of transmissions for a "long" frame
 *	(a frame not RTS protected), called "dot11LongRetryLimit" in 802.11,
 *	but actually means the number of transmissions not the number of retries
 * @short_frame_max_tx_count: Maximum number of transmissions for a "short"
 *	frame, called "dot11ShortRetryLimit" in 802.11, but actually means the
 *	number of transmissions not the number of retries
 *
 * @smps_mode: spatial multiplexing powersave mode; note that
 *	%IEEE80211_SMPS_STATIC is used when the device is not
 *	configured for an HT channel.
 *	Note that this is only valid if channel contexts are not used,
 *	otherwise each channel context has the number of chains listed.
 */
struct ieee80211_conf {
	u32 flags;
	int power_level, dynamic_ps_timeout;
	int max_sleep_period;

	u16 listen_interval;
	u8 ps_dtim_period;

	u8 long_frame_max_tx_count, short_frame_max_tx_count;

	struct cfg80211_chan_def chandef;
	bool radar_enabled;
	enum ieee80211_smps_mode smps_mode;
};

/**
 * struct ieee80211_channel_switch - holds the channel switch data
 *
 * The information provided in this structure is required for channel switch
 * operation.
 *
 * @timestamp: value in microseconds of the 64-bit Time Synchronization
 *	Function (TSF) timer when the frame containing the channel switch
 *	announcement was received. This is simply the rx.mactime parameter
 *	the driver passed into mac80211.
 * @device_timestamp: arbitrary timestamp for the device, this is the
 *	rx.device_timestamp parameter the driver passed to mac80211.
 * @block_tx: Indicates whether transmission must be blocked before the
 *	scheduled channel switch, as indicated by the AP.
 * @chandef: the new channel to switch to
 * @count: the number of TBTT's until the channel switch event
 */
struct ieee80211_channel_switch {
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	struct cfg80211_chan_def chandef;
	u8 count;
};

/**
 * enum ieee80211_vif_flags - virtual interface flags
 *
 * @IEEE80211_VIF_BEACON_FILTER: the device performs beacon filtering
 *	on this virtual interface to avoid unnecessary CPU wakeups
 * @IEEE80211_VIF_SUPPORTS_CQM_RSSI: the device can do connection quality
 *	monitoring on this virtual interface -- i.e. it can monitor
 *	connection quality related parameters, such as the RSSI level and
 *	provide notifications if configured trigger levels are reached.
 * @IEEE80211_VIF_SUPPORTS_UAPSD: The device can do U-APSD for this
 *	interface. This flag should be set during interface addition,
 *	but may be set/cleared as late as authentication to an AP. It is
 *	only valid for managed/station mode interfaces.
 */
enum ieee80211_vif_flags {
	IEEE80211_VIF_BEACON_FILTER		= BIT(0),
	IEEE80211_VIF_SUPPORTS_CQM_RSSI		= BIT(1),
	IEEE80211_VIF_SUPPORTS_UAPSD		= BIT(2),
};

/**
 * struct ieee80211_vif - per-interface data
 *
 * Data in this structure is continually present for driver
 * use during the life of a virtual interface.
 *
 * @type: type of this virtual interface
 * @bss_conf: BSS configuration for this interface, either our own
 *	or the BSS we're associated to
 * @addr: address of this interface
 * @p2p: indicates whether this AP or STA interface is a p2p
 *	interface, i.e. a GO or p2p-sta respectively
 * @csa_active: marks whether a channel switch is going on. Internally it is
 *	write-protected by sdata_lock and local->mtx so holding either is fine
 *	for read access.
 * @driver_flags: flags/capabilities the driver has for this interface,
 *	these need to be set (or cleared) when the interface is added
 *	or, if supported by the driver, the interface type is changed
 *	at runtime, mac80211 will never touch this field
 * @hw_queue: hardware queue for each AC
 * @cab_queue: content-after-beacon (DTIM beacon really) queue, AP mode only
 * @chanctx_conf: The channel context this interface is assigned to, or %NULL
 *	when it is not assigned. This pointer is RCU-protected due to the TX
 *	path needing to access it; even though the netdev carrier will always
 *	be off when it is %NULL there can still be races and packets could be
 *	processed after it switches back to %NULL.
 * @debugfs_dir: debugfs dentry, can be used by drivers to create own per
 *	interface debug files. Note that it will be NULL for the virtual
 *	monitor interface (if that is requested.)
 * @drv_priv: data area for driver use, will always be aligned to
 *	sizeof(void *).
 * @txq: the multicast data TX queue (if driver uses the TXQ abstraction)
 */
struct ieee80211_vif {
	enum nl80211_iftype type;
	struct ieee80211_bss_conf bss_conf;
	u8 addr[ETH_ALEN];
	bool p2p;
	bool csa_active;

	u8 cab_queue;
	u8 hw_queue[IEEE80211_NUM_ACS];

	struct ieee80211_txq *txq;

	struct ieee80211_chanctx_conf __rcu *chanctx_conf;

	u32 driver_flags;

#ifdef CONFIG_MAC80211_DEBUGFS
	struct dentry *debugfs_dir;
#endif

	/* must be last */
	u8 drv_priv[0] __aligned(sizeof(void *));
};

static inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)
{
#ifdef CONFIG_MAC80211_MESH
	return vif->type == NL80211_IFTYPE_MESH_POINT;
#endif
	return false;
}

/**
 * wdev_to_ieee80211_vif - return a vif struct from a wdev
 * @wdev: the wdev to get the vif for
 *
 * This can be used by mac80211 drivers with direct cfg80211 APIs
 * (like the vendor commands) that get a wdev.
 *
 * Note that this function may return %NULL if the given wdev isn't
 * associated with a vif that the driver knows about (e.g. monitor
 * or AP_VLAN interfaces.)
 */
struct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev);

/**
 * ieee80211_vif_to_wdev - return a wdev struct from a vif
 * @vif: the vif to get the wdev for
 *
 * This can be used by mac80211 drivers with direct cfg80211 APIs
 * (like the vendor commands) that needs to get the wdev for a vif.
 *
 * Note that this function may return %NULL if the given wdev isn't
 * associated with a vif that the driver knows about (e.g. monitor
 * or AP_VLAN interfaces.)
 */
struct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif);

/**
 * enum ieee80211_key_flags - key flags
 *
 * These flags are used for communication about keys between the driver
 * and mac80211, with the @flags parameter of &struct ieee80211_key_conf.
 *
 * @IEEE80211_KEY_FLAG_GENERATE_IV: This flag should be set by the
 *	driver to indicate that it requires IV generation for this
 *	particular key. Setting this flag does not necessarily mean that SKBs
 *	will have sufficient tailroom for ICV or MIC.
 * @IEEE80211_KEY_FLAG_GENERATE_MMIC: This flag should be set by
 *	the driver for a TKIP key if it requires Michael MIC
 *	generation in software.
 * @IEEE80211_KEY_FLAG_PAIRWISE: Set by mac80211, this flag indicates
 *	that the key is pairwise rather then a shared key.
 * @IEEE80211_KEY_FLAG_SW_MGMT_TX: This flag should be set by the driver for a
 *	CCMP/GCMP key if it requires CCMP/GCMP encryption of management frames
 *	(MFP) to be done in software.
 * @IEEE80211_KEY_FLAG_PUT_IV_SPACE: This flag should be set by the driver
 *	if space should be prepared for the IV, but the IV
 *	itself should not be generated. Do not set together with
 *	@IEEE80211_KEY_FLAG_GENERATE_IV on the same key. Setting this flag does
 *	not necessarily mean that SKBs will have sufficient tailroom for ICV or
 *	MIC.
 * @IEEE80211_KEY_FLAG_RX_MGMT: This key will be used to decrypt received
 *	management frames. The flag can help drivers that have a hardware
 *	crypto implementation that doesn't deal with management frames
 *	properly by allowing them to not upload the keys to hardware and
 *	fall back to software crypto. Note that this flag deals only with
 *	RX, if your crypto engine can't deal with TX you can also set the
 *	%IEEE80211_KEY_FLAG_SW_MGMT_TX flag to encrypt such frames in SW.
 * @IEEE80211_KEY_FLAG_GENERATE_IV_MGMT: This flag should be set by the
 *	driver for a CCMP/GCMP key to indicate that is requires IV generation
 *	only for managment frames (MFP).
 * @IEEE80211_KEY_FLAG_RESERVE_TAILROOM: This flag should be set by the
 *	driver for a key to indicate that sufficient tailroom must always
 *	be reserved for ICV or MIC, even when HW encryption is enabled.
 */
enum ieee80211_key_flags {
	IEEE80211_KEY_FLAG_GENERATE_IV_MGMT	= BIT(0),
	IEEE80211_KEY_FLAG_GENERATE_IV		= BIT(1),
	IEEE80211_KEY_FLAG_GENERATE_MMIC	= BIT(2),
	IEEE80211_KEY_FLAG_PAIRWISE		= BIT(3),
	IEEE80211_KEY_FLAG_SW_MGMT_TX		= BIT(4),
	IEEE80211_KEY_FLAG_PUT_IV_SPACE		= BIT(5),
	IEEE80211_KEY_FLAG_RX_MGMT		= BIT(6),
	IEEE80211_KEY_FLAG_RESERVE_TAILROOM	= BIT(7),
};

/**
 * struct ieee80211_key_conf - key information
 *
 * This key information is given by mac80211 to the driver by
 * the set_key() callback in &struct ieee80211_ops.
 *
 * @hw_key_idx: To be set by the driver, this is the key index the driver
 *	wants to be given when a frame is transmitted and needs to be
 *	encrypted in hardware.
 * @cipher: The key's cipher suite selector.
 * @flags: key flags, see &enum ieee80211_key_flags.
 * @keyidx: the key index (0-3)
 * @keylen: key material length
 * @key: key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)
 * 	data block:
 * 	- Temporal Encryption Key (128 bits)
 * 	- Temporal Authenticator Tx MIC Key (64 bits)
 * 	- Temporal Authenticator Rx MIC Key (64 bits)
 * @icv_len: The ICV length for this key type
 * @iv_len: The IV length for this key type
 */
struct ieee80211_key_conf {
	u32 cipher;
	u8 icv_len;
	u8 iv_len;
	u8 hw_key_idx;
	u8 flags;
	s8 keyidx;
	u8 keylen;
	u8 key[0];
};

/**
 * struct ieee80211_cipher_scheme - cipher scheme
 *
 * This structure contains a cipher scheme information defining
 * the secure packet crypto handling.
 *
 * @cipher: a cipher suite selector
 * @iftype: a cipher iftype bit mask indicating an allowed cipher usage
 * @hdr_len: a length of a security header used the cipher
 * @pn_len: a length of a packet number in the security header
 * @pn_off: an offset of pn from the beginning of the security header
 * @key_idx_off: an offset of key index byte in the security header
 * @key_idx_mask: a bit mask of key_idx bits
 * @key_idx_shift: a bit shift needed to get key_idx
 *     key_idx value calculation:
 *      (sec_header_base[key_idx_off] & key_idx_mask) >> key_idx_shift
 * @mic_len: a mic length in bytes
 */
struct ieee80211_cipher_scheme {
	u32 cipher;
	u16 iftype;
	u8 hdr_len;
	u8 pn_len;
	u8 pn_off;
	u8 key_idx_off;
	u8 key_idx_mask;
	u8 key_idx_shift;
	u8 mic_len;
};

/**
 * enum set_key_cmd - key command
 *
 * Used with the set_key() callback in &struct ieee80211_ops, this
 * indicates whether a key is being removed or added.
 *
 * @SET_KEY: a key is set
 * @DISABLE_KEY: a key must be disabled
 */
enum set_key_cmd {
	SET_KEY, DISABLE_KEY,
};

/**
 * enum ieee80211_sta_state - station state
 *
 * @IEEE80211_STA_NOTEXIST: station doesn't exist at all,
 *	this is a special state for add/remove transitions
 * @IEEE80211_STA_NONE: station exists without special state
 * @IEEE80211_STA_AUTH: station is authenticated
 * @IEEE80211_STA_ASSOC: station is associated
 * @IEEE80211_STA_AUTHORIZED: station is authorized (802.1X)
 */
enum ieee80211_sta_state {
	/* NOTE: These need to be ordered correctly! */
	IEEE80211_STA_NOTEXIST,
	IEEE80211_STA_NONE,
	IEEE80211_STA_AUTH,
	IEEE80211_STA_ASSOC,
	IEEE80211_STA_AUTHORIZED,
};

/**
 * enum ieee80211_sta_rx_bandwidth - station RX bandwidth
 * @IEEE80211_STA_RX_BW_20: station can only receive 20 MHz
 * @IEEE80211_STA_RX_BW_40: station can receive up to 40 MHz
 * @IEEE80211_STA_RX_BW_80: station can receive up to 80 MHz
 * @IEEE80211_STA_RX_BW_160: station can receive up to 160 MHz
 *	(including 80+80 MHz)
 *
 * Implementation note: 20 must be zero to be initialized
 *	correctly, the values must be sorted.
 */
enum ieee80211_sta_rx_bandwidth {
	IEEE80211_STA_RX_BW_20 = 0,
	IEEE80211_STA_RX_BW_40,
	IEEE80211_STA_RX_BW_80,
	IEEE80211_STA_RX_BW_160,
};

/**
 * struct ieee80211_sta_rates - station rate selection table
 *
 * @rcu_head: RCU head used for freeing the table on update
 * @rate: transmit rates/flags to be used by default.
 *	Overriding entries per-packet is possible by using cb tx control.
 */
struct ieee80211_sta_rates {
	struct rcu_head rcu_head;
	struct {
		s8 idx;
		u8 count;
		u8 count_cts;
		u8 count_rts;
		u16 flags;
	} rate[IEEE80211_TX_RATE_TABLE_SIZE];
};

/**
 * struct ieee80211_sta - station table entry
 *
 * A station table entry represents a station we are possibly
 * communicating with. Since stations are RCU-managed in
 * mac80211, any ieee80211_sta pointer you get access to must
 * either be protected by rcu_read_lock() explicitly or implicitly,
 * or you must take good care to not use such a pointer after a
 * call to your sta_remove callback that removed it.
 *
 * @addr: MAC address
 * @aid: AID we assigned to the station if we're an AP
 * @supp_rates: Bitmap of supported rates (per band)
 * @ht_cap: HT capabilities of this STA; restricted to our own capabilities
 * @vht_cap: VHT capabilities of this STA; restricted to our own capabilities
 * @wme: indicates whether the STA supports QoS/WME (if local devices does,
 *	otherwise always false)
 * @drv_priv: data area for driver use, will always be aligned to
 *	sizeof(void *), size is determined in hw information.
 * @uapsd_queues: bitmap of queues configured for uapsd. Only valid
 *	if wme is supported.
 * @max_sp: max Service Period. Only valid if wme is supported.
 * @bandwidth: current bandwidth the station can receive with
 * @rx_nss: in HT/VHT, the maximum number of spatial streams the
 *	station can receive at the moment, changed by operating mode
 *	notifications and capabilities. The value is only valid after
 *	the station moves to associated state.
 * @smps_mode: current SMPS mode (off, static or dynamic)
 * @rates: rate control selection table
 * @tdls: indicates whether the STA is a TDLS peer
 * @tdls_initiator: indicates the STA is an initiator of the TDLS link. Only
 *	valid if the STA is a TDLS peer in the first place.
 * @mfp: indicates whether the STA uses management frame protection or not.
 * @txq: per-TID data TX queues (if driver uses the TXQ abstraction)
 */
struct ieee80211_sta {
	u32 supp_rates[IEEE80211_NUM_BANDS];
	u8 addr[ETH_ALEN];
	u16 aid;
	struct ieee80211_sta_ht_cap ht_cap;
	struct ieee80211_sta_vht_cap vht_cap;
	bool wme;
	u8 uapsd_queues;
	u8 max_sp;
	u8 rx_nss;
	enum ieee80211_sta_rx_bandwidth bandwidth;
	enum ieee80211_smps_mode smps_mode;
	struct ieee80211_sta_rates __rcu *rates;
	bool tdls;
	bool tdls_initiator;
	bool mfp;

	struct ieee80211_txq *txq[IEEE80211_NUM_TIDS];

	/* must be last */
	u8 drv_priv[0] __aligned(sizeof(void *));
};

/**
 * enum sta_notify_cmd - sta notify command
 *
 * Used with the sta_notify() callback in &struct ieee80211_ops, this
 * indicates if an associated station made a power state transition.
 *
 * @STA_NOTIFY_SLEEP: a station is now sleeping
 * @STA_NOTIFY_AWAKE: a sleeping station woke up
 */
enum sta_notify_cmd {
	STA_NOTIFY_SLEEP, STA_NOTIFY_AWAKE,
};

/**
 * struct ieee80211_tx_control - TX control data
 *
 * @sta: station table entry, this sta pointer may be NULL and
 * 	it is not allowed to copy the pointer, due to RCU.
 */
struct ieee80211_tx_control {
	struct ieee80211_sta *sta;
};

/**
 * struct ieee80211_txq - Software intermediate tx queue
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @sta: station table entry, %NULL for per-vif queue
 * @tid: the TID for this queue (unused for per-vif queue)
 * @ac: the AC for this queue
 * @drv_priv: data area for driver use, will always be aligned to
 *	sizeof(void *).
 *
 * The driver can obtain packets from this queue by calling
 * ieee80211_tx_dequeue().
 */
struct ieee80211_txq {
	struct ieee80211_vif *vif;
	struct ieee80211_sta *sta;
	u8 tid;
	u8 ac;

	/* must be last */
	u8 drv_priv[0] __aligned(sizeof(void *));
};

/**
 * enum ieee80211_hw_flags - hardware flags
 *
 * These flags are used to indicate hardware capabilities to
 * the stack. Generally, flags here should have their meaning
 * done in a way that the simplest hardware doesn't need setting
 * any particular flags. There are some exceptions to this rule,
 * however, so you are advised to review these flags carefully.
 *
 * @IEEE80211_HW_HAS_RATE_CONTROL:
 *	The hardware or firmware includes rate control, and cannot be
 *	controlled by the stack. As such, no rate control algorithm
 *	should be instantiated, and the TX rate reported to userspace
 *	will be taken from the TX status instead of the rate control
 *	algorithm.
 *	Note that this requires that the driver implement a number of
 *	callbacks so it has the correct information, it needs to have
 *	the @set_rts_threshold callback and must look at the BSS config
 *	@use_cts_prot for G/N protection, @use_short_slot for slot
 *	timing in 2.4 GHz and @use_short_preamble for preambles for
 *	CCK frames.
 *
 * @IEEE80211_HW_RX_INCLUDES_FCS:
 *	Indicates that received frames passed to the stack include
 *	the FCS at the end.
 *
 * @IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING:
 *	Some wireless LAN chipsets buffer broadcast/multicast frames
 *	for power saving stations in the hardware/firmware and others
 *	rely on the host system for such buffering. This option is used
 *	to configure the IEEE 802.11 upper layer to buffer broadcast and
 *	multicast frames when there are power saving stations so that
 *	the driver can fetch them with ieee80211_get_buffered_bc().
 *
 * @IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE:
 *	Hardware is not capable of short slot operation on the 2.4 GHz band.
 *
 * @IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE:
 *	Hardware is not capable of receiving frames with short preamble on
 *	the 2.4 GHz band.
 *
 * @IEEE80211_HW_SIGNAL_UNSPEC:
 *	Hardware can provide signal values but we don't know its units. We
 *	expect values between 0 and @max_signal.
 *	If possible please provide dB or dBm instead.
 *
 * @IEEE80211_HW_SIGNAL_DBM:
 *	Hardware gives signal values in dBm, decibel difference from
 *	one milliwatt. This is the preferred method since it is standardized
 *	between different devices. @max_signal does not need to be set.
 *
 * @IEEE80211_HW_SPECTRUM_MGMT:
 * 	Hardware supports spectrum management defined in 802.11h
 * 	Measurement, Channel Switch, Quieting, TPC
 *
 * @IEEE80211_HW_AMPDU_AGGREGATION:
 *	Hardware supports 11n A-MPDU aggregation.
 *
 * @IEEE80211_HW_SUPPORTS_PS:
 *	Hardware has power save support (i.e. can go to sleep).
 *
 * @IEEE80211_HW_PS_NULLFUNC_STACK:
 *	Hardware requires nullfunc frame handling in stack, implies
 *	stack support for dynamic PS.
 *
 * @IEEE80211_HW_SUPPORTS_DYNAMIC_PS:
 *	Hardware has support for dynamic PS.
 *
 * @IEEE80211_HW_MFP_CAPABLE:
 *	Hardware supports management frame protection (MFP, IEEE 802.11w).
 *
 * @IEEE80211_HW_REPORTS_TX_ACK_STATUS:
 *	Hardware can provide ack status reports of Tx frames to
 *	the stack.
 *
 * @IEEE80211_HW_CONNECTION_MONITOR:
 *	The hardware performs its own connection monitoring, including
 *	periodic keep-alives to the AP and probing the AP on beacon loss.
 *
 * @IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC:
 *	This device needs to get data from beacon before association (i.e.
 *	dtim_period).
 *
 * @IEEE80211_HW_SUPPORTS_PER_STA_GTK: The device's crypto engine supports
 *	per-station GTKs as used by IBSS RSN or during fast transition. If
 *	the device doesn't support per-station GTKs, but can be asked not
 *	to decrypt group addressed frames, then IBSS RSN support is still
 *	possible but software crypto will be used. Advertise the wiphy flag
 *	only in that case.
 *
 * @IEEE80211_HW_AP_LINK_PS: When operating in AP mode the device
 *	autonomously manages the PS status of connected stations. When
 *	this flag is set mac80211 will not trigger PS mode for connected
 *	stations based on the PM bit of incoming frames.
 *	Use ieee80211_start_ps()/ieee8021_end_ps() to manually configure
 *	the PS mode of connected stations.
 *
 * @IEEE80211_HW_TX_AMPDU_SETUP_IN_HW: The device handles TX A-MPDU session
 *	setup strictly in HW. mac80211 should not attempt to do this in
 *	software.
 *
 * @IEEE80211_HW_WANT_MONITOR_VIF: The driver would like to be informed of
 *	a virtual monitor interface when monitor interfaces are the only
 *	active interfaces.
 *
 * @IEEE80211_HW_NO_AUTO_VIF: The driver would like for no wlanX to
 *	be created.  It is expected user-space will create vifs as
 *	desired (and thus have them named as desired).
 *
 * @IEEE80211_HW_SW_CRYPTO_CONTROL: The driver wants to control which of the
 *	crypto algorithms can be done in software - so don't automatically
 *	try to fall back to it if hardware crypto fails, but do so only if
 *	the driver returns 1. This also forces the driver to advertise its
 *	supported cipher suites.
 *
 * @IEEE80211_HW_QUEUE_CONTROL: The driver wants to control per-interface
 *	queue mapping in order to use different queues (not just one per AC)
 *	for different virtual interfaces. See the doc section on HW queue
 *	control for more details.
 *
 * @IEEE80211_HW_SUPPORTS_RC_TABLE: The driver supports using a rate
 *	selection table provided by the rate control algorithm.
 *
 * @IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF: Use the P2P Device address for any
 *	P2P Interface. This will be honoured even if more than one interface
 *	is supported.
 *
 * @IEEE80211_HW_TIMING_BEACON_ONLY: Use sync timing from beacon frames
 *	only, to allow getting TBTT of a DTIM beacon.
 *
 * @IEEE80211_HW_SUPPORTS_HT_CCK_RATES: Hardware supports mixing HT/CCK rates
 *	and can cope with CCK rates in an aggregation session (e.g. by not
 *	using aggregation for such frames.)
 *
 * @IEEE80211_HW_CHANCTX_STA_CSA: Support 802.11h based channel-switch (CSA)
 *	for a single active channel while using channel contexts. When support
 *	is not enabled the default action is to disconnect when getting the
 *	CSA frame.
 *
 * @IEEE80211_HW_SUPPORTS_CLONED_SKBS: The driver will never modify the payload
 *	or tailroom of TX skbs without copying them first.
 *
 * @IEEE80211_SINGLE_HW_SCAN_ON_ALL_BANDS: The HW supports scanning on all bands
 *	in one command, mac80211 doesn't have to run separate scans per band.
 */
enum ieee80211_hw_flags {
	IEEE80211_HW_HAS_RATE_CONTROL			= 1<<0,
	IEEE80211_HW_RX_INCLUDES_FCS			= 1<<1,
	IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING	= 1<<2,
	IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE		= 1<<3,
	IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE	= 1<<4,
	IEEE80211_HW_SIGNAL_UNSPEC			= 1<<5,
	IEEE80211_HW_SIGNAL_DBM				= 1<<6,
	IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC		= 1<<7,
	IEEE80211_HW_SPECTRUM_MGMT			= 1<<8,
	IEEE80211_HW_AMPDU_AGGREGATION			= 1<<9,
	IEEE80211_HW_SUPPORTS_PS			= 1<<10,
	IEEE80211_HW_PS_NULLFUNC_STACK			= 1<<11,
	IEEE80211_HW_SUPPORTS_DYNAMIC_PS		= 1<<12,
	IEEE80211_HW_MFP_CAPABLE			= 1<<13,
	IEEE80211_HW_WANT_MONITOR_VIF			= 1<<14,
	IEEE80211_HW_NO_AUTO_VIF			= 1<<15,
	IEEE80211_HW_SW_CRYPTO_CONTROL			= 1<<16,
	/* free slots */
	IEEE80211_HW_REPORTS_TX_ACK_STATUS		= 1<<18,
	IEEE80211_HW_CONNECTION_MONITOR			= 1<<19,
	IEEE80211_HW_QUEUE_CONTROL			= 1<<20,
	IEEE80211_HW_SUPPORTS_PER_STA_GTK		= 1<<21,
	IEEE80211_HW_AP_LINK_PS				= 1<<22,
	IEEE80211_HW_TX_AMPDU_SETUP_IN_HW		= 1<<23,
	IEEE80211_HW_SUPPORTS_RC_TABLE			= 1<<24,
	IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF		= 1<<25,
	IEEE80211_HW_TIMING_BEACON_ONLY			= 1<<26,
	IEEE80211_HW_SUPPORTS_HT_CCK_RATES		= 1<<27,
	IEEE80211_HW_CHANCTX_STA_CSA			= 1<<28,
	IEEE80211_HW_SUPPORTS_CLONED_SKBS		= 1<<29,
	IEEE80211_SINGLE_HW_SCAN_ON_ALL_BANDS		= 1<<30,
};

/**
 * struct ieee80211_hw - hardware information and state
 *
 * This structure contains the configuration and hardware
 * information for an 802.11 PHY.
 *
 * @wiphy: This points to the &struct wiphy allocated for this
 *	802.11 PHY. You must fill in the @perm_addr and @dev
 *	members of this structure using SET_IEEE80211_DEV()
 *	and SET_IEEE80211_PERM_ADDR(). Additionally, all supported
 *	bands (with channels, bitrates) are registered here.
 *
 * @conf: &struct ieee80211_conf, device configuration, don't use.
 *
 * @priv: pointer to private area that was allocated for driver use
 *	along with this structure.
 *
 * @flags: hardware flags, see &enum ieee80211_hw_flags.
 *
 * @extra_tx_headroom: headroom to reserve in each transmit skb
 *	for use by the driver (e.g. for transmit headers.)
 *
 * @extra_beacon_tailroom: tailroom to reserve in each beacon tx skb.
 *	Can be used by drivers to add extra IEs.
 *
 * @max_signal: Maximum value for signal (rssi) in RX information, used
 *	only when @IEEE80211_HW_SIGNAL_UNSPEC or @IEEE80211_HW_SIGNAL_DB
 *
 * @max_listen_interval: max listen interval in units of beacon interval
 *	that HW supports
 *
 * @queues: number of available hardware transmit queues for
 *	data packets. WMM/QoS requires at least four, these
 *	queues need to have configurable access parameters.
 *
 * @rate_control_algorithm: rate control algorithm for this hardware.
 *	If unset (NULL), the default algorithm will be used. Must be
 *	set before calling ieee80211_register_hw().
 *
 * @vif_data_size: size (in bytes) of the drv_priv data area
 *	within &struct ieee80211_vif.
 * @sta_data_size: size (in bytes) of the drv_priv data area
 *	within &struct ieee80211_sta.
 * @chanctx_data_size: size (in bytes) of the drv_priv data area
 *	within &struct ieee80211_chanctx_conf.
 * @txq_data_size: size (in bytes) of the drv_priv data area
 *	within @struct ieee80211_txq.
 *
 * @max_rates: maximum number of alternate rate retry stages the hw
 *	can handle.
 * @max_report_rates: maximum number of alternate rate retry stages
 *	the hw can report back.
 * @max_rate_tries: maximum number of tries for each stage
 *
 * @max_rx_aggregation_subframes: maximum buffer size (number of
 *	sub-frames) to be used for A-MPDU block ack receiver
 *	aggregation.
 *	This is only relevant if the device has restrictions on the
 *	number of subframes, if it relies on mac80211 to do reordering
 *	it shouldn't be set.
 *
 * @max_tx_aggregation_subframes: maximum number of subframes in an
 *	aggregate an HT driver will transmit, used by the peer as a
 *	hint to size its reorder buffer.
 *
 * @offchannel_tx_hw_queue: HW queue ID to use for offchannel TX
 *	(if %IEEE80211_HW_QUEUE_CONTROL is set)
 *
 * @radiotap_mcs_details: lists which MCS information can the HW
 *	reports, by default it is set to _MCS, _GI and _BW but doesn't
 *	include _FMT. Use %IEEE80211_RADIOTAP_MCS_HAVE_* values, only
 *	adding _BW is supported today.
 *
 * @radiotap_vht_details: lists which VHT MCS information the HW reports,
 *	the default is _GI | _BANDWIDTH.
 *	Use the %IEEE80211_RADIOTAP_VHT_KNOWN_* values.
 *
 * @netdev_features: netdev features to be set in each netdev created
 *	from this HW. Note only HW checksum features are currently
 *	compatible with mac80211. Other feature bits will be rejected.
 *
 * @uapsd_queues: This bitmap is included in (re)association frame to indicate
 *	for each access category if it is uAPSD trigger-enabled and delivery-
 *	enabled. Use IEEE80211_WMM_IE_STA_QOSINFO_AC_* to set this bitmap.
 *	Each bit corresponds to different AC. Value '1' in specific bit means
 *	that corresponding AC is both trigger- and delivery-enabled. '0' means
 *	neither enabled.
 *
 * @uapsd_max_sp_len: maximum number of total buffered frames the WMM AP may
 *	deliver to a WMM STA during any Service Period triggered by the WMM STA.
 *	Use IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct values.
 *
 * @n_cipher_schemes: a size of an array of cipher schemes definitions.
 * @cipher_schemes: a pointer to an array of cipher scheme definitions
 *	supported by HW.
 *
 * @txq_ac_max_pending: maximum number of frames per AC pending in all txq
 *	entries for a vif.
 */
struct ieee80211_hw {
	struct ieee80211_conf conf;
	struct wiphy *wiphy;
	const char *rate_control_algorithm;
	void *priv;
	u32 flags;
	unsigned int extra_tx_headroom;
	unsigned int extra_beacon_tailroom;
	int vif_data_size;
	int sta_data_size;
	int chanctx_data_size;
	int txq_data_size;
	u16 queues;
	u16 max_listen_interval;
	s8 max_signal;
	u8 max_rates;
	u8 max_report_rates;
	u8 max_rate_tries;
	u8 max_rx_aggregation_subframes;
	u8 max_tx_aggregation_subframes;
	u8 offchannel_tx_hw_queue;
	u8 radiotap_mcs_details;
	u16 radiotap_vht_details;
	netdev_features_t netdev_features;
	u8 uapsd_queues;
	u8 uapsd_max_sp_len;
	u8 n_cipher_schemes;
	const struct ieee80211_cipher_scheme *cipher_schemes;
	int txq_ac_max_pending;
};

/**
 * struct ieee80211_scan_request - hw scan request
 *
 * @ies: pointers different parts of IEs (in req.ie)
 * @req: cfg80211 request.
 */
struct ieee80211_scan_request {
	struct ieee80211_scan_ies ies;

	/* Keep last */
	struct cfg80211_scan_request req;
};

/**
 * struct ieee80211_tdls_ch_sw_params - TDLS channel switch parameters
 *
 * @sta: peer this TDLS channel-switch request/response came from
 * @chandef: channel referenced in a TDLS channel-switch request
 * @action_code: see &enum ieee80211_tdls_actioncode
 * @status: channel-switch response status
 * @timestamp: time at which the frame was received
 * @switch_time: switch-timing parameter received in the frame
 * @switch_timeout: switch-timing parameter received in the frame
 * @tmpl_skb: TDLS switch-channel response template
 * @ch_sw_tm_ie: offset of the channel-switch timing IE inside @tmpl_skb
 */
struct ieee80211_tdls_ch_sw_params {
	struct ieee80211_sta *sta;
	struct cfg80211_chan_def *chandef;
	u8 action_code;
	u32 status;
	u32 timestamp;
	u16 switch_time;
	u16 switch_timeout;
	struct sk_buff *tmpl_skb;
	u32 ch_sw_tm_ie;
};

/**
 * wiphy_to_ieee80211_hw - return a mac80211 driver hw struct from a wiphy
 *
 * @wiphy: the &struct wiphy which we want to query
 *
 * mac80211 drivers can use this to get to their respective
 * &struct ieee80211_hw. Drivers wishing to get to their own private
 * structure can then access it via hw->priv. Note that mac802111 drivers should
 * not use wiphy_priv() to try to get their private driver structure as this
 * is already used internally by mac80211.
 *
 * Return: The mac80211 driver hw struct of @wiphy.
 */
struct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy);

/**
 * SET_IEEE80211_DEV - set device for 802.11 hardware
 *
 * @hw: the &struct ieee80211_hw to set the device for
 * @dev: the &struct device of this 802.11 device
 */
static inline void SET_IEEE80211_DEV(struct ieee80211_hw *hw, struct device *dev)
{
	set_wiphy_dev(hw->wiphy, dev);
}

/**
 * SET_IEEE80211_PERM_ADDR - set the permanent MAC address for 802.11 hardware
 *
 * @hw: the &struct ieee80211_hw to set the MAC address for
 * @addr: the address to set
 */
static inline void SET_IEEE80211_PERM_ADDR(struct ieee80211_hw *hw, u8 *addr)
{
	memcpy(hw->wiphy->perm_addr, addr, ETH_ALEN);
}

static inline struct ieee80211_rate *
ieee80211_get_tx_rate(const struct ieee80211_hw *hw,
		      const struct ieee80211_tx_info *c)
{
	if (WARN_ON_ONCE(c->control.rates[0].idx < 0))
		return NULL;
	return &hw->wiphy->bands[c->band]->bitrates[c->control.rates[0].idx];
}

static inline struct ieee80211_rate *
ieee80211_get_rts_cts_rate(const struct ieee80211_hw *hw,
			   const struct ieee80211_tx_info *c)
{
	if (c->control.rts_cts_rate_idx < 0)
		return NULL;
	return &hw->wiphy->bands[c->band]->bitrates[c->control.rts_cts_rate_idx];
}

static inline struct ieee80211_rate *
ieee80211_get_alt_retry_rate(const struct ieee80211_hw *hw,
			     const struct ieee80211_tx_info *c, int idx)
{
	if (c->control.rates[idx + 1].idx < 0)
		return NULL;
	return &hw->wiphy->bands[c->band]->bitrates[c->control.rates[idx + 1].idx];
}

/**
 * ieee80211_free_txskb - free TX skb
 * @hw: the hardware
 * @skb: the skb
 *
 * Free a transmit skb. Use this funtion when some failure
 * to transmit happened and thus status cannot be reported.
 */
void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);

/**
 * DOC: Hardware crypto acceleration
 *
 * mac80211 is capable of taking advantage of many hardware
 * acceleration designs for encryption and decryption operations.
 *
 * The set_key() callback in the &struct ieee80211_ops for a given
 * device is called to enable hardware acceleration of encryption and
 * decryption. The callback takes a @sta parameter that will be NULL
 * for default keys or keys used for transmission only, or point to
 * the station information for the peer for individual keys.
 * Multiple transmission keys with the same key index may be used when
 * VLANs are configured for an access point.
 *
 * When transmitting, the TX control data will use the @hw_key_idx
 * selected by the driver by modifying the &struct ieee80211_key_conf
 * pointed to by the @key parameter to the set_key() function.
 *
 * The set_key() call for the %SET_KEY command should return 0 if
 * the key is now in use, -%EOPNOTSUPP or -%ENOSPC if it couldn't be
 * added; if you return 0 then hw_key_idx must be assigned to the
 * hardware key index, you are free to use the full u8 range.
 *
 * Note that in the case that the @IEEE80211_HW_SW_CRYPTO_CONTROL flag is
 * set, mac80211 will not automatically fall back to software crypto if
 * enabling hardware crypto failed. The set_key() call may also return the
 * value 1 to permit this specific key/algorithm to be done in software.
 *
 * When the cmd is %DISABLE_KEY then it must succeed.
 *
 * Note that it is permissible to not decrypt a frame even if a key
 * for it has been uploaded to hardware, the stack will not make any
 * decision based on whether a key has been uploaded or not but rather
 * based on the receive flags.
 *
 * The &struct ieee80211_key_conf structure pointed to by the @key
 * parameter is guaranteed to be valid until another call to set_key()
 * removes it, but it can only be used as a cookie to differentiate
 * keys.
 *
 * In TKIP some HW need to be provided a phase 1 key, for RX decryption
 * acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key
 * handler.
 * The update_tkip_key() call updates the driver with the new phase 1 key.
 * This happens every time the iv16 wraps around (every 65536 packets). The
 * set_key() call will happen only once for each key (unless the AP did
 * rekeying), it will not include a valid phase 1 key. The valid phase 1 key is
 * provided by update_tkip_key only. The trigger that makes mac80211 call this
 * handler is software decryption with wrap around of iv16.
 *
 * The set_default_unicast_key() call updates the default WEP key index
 * configured to the hardware for WEP encryption type. This is required
 * for devices that support offload of data packets (e.g. ARP responses).
 */

/**
 * DOC: Powersave support
 *
 * mac80211 has support for various powersave implementations.
 *
 * First, it can support hardware that handles all powersaving by itself,
 * such hardware should simply set the %IEEE80211_HW_SUPPORTS_PS hardware
 * flag. In that case, it will be told about the desired powersave mode
 * with the %IEEE80211_CONF_PS flag depending on the association status.
 * The hardware must take care of sending nullfunc frames when necessary,
 * i.e. when entering and leaving powersave mode. The hardware is required
 * to look at the AID in beacons and signal to the AP that it woke up when
 * it finds traffic directed to it.
 *
 * %IEEE80211_CONF_PS flag enabled means that the powersave mode defined in
 * IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused
 * with hardware wakeup and sleep states. Driver is responsible for waking
 * up the hardware before issuing commands to the hardware and putting it
 * back to sleep at appropriate times.
 *
 * When PS is enabled, hardware needs to wakeup for beacons and receive the
 * buffered multicast/broadcast frames after the beacon. Also it must be
 * possible to send frames and receive the acknowledment frame.
 *
 * Other hardware designs cannot send nullfunc frames by themselves and also
 * need software support for parsing the TIM bitmap. This is also supported
 * by mac80211 by combining the %IEEE80211_HW_SUPPORTS_PS and
 * %IEEE80211_HW_PS_NULLFUNC_STACK flags. The hardware is of course still
 * required to pass up beacons. The hardware is still required to handle
 * waking up for multicast traffic; if it cannot the driver must handle that
 * as best as it can, mac80211 is too slow to do that.
 *
 * Dynamic powersave is an extension to normal powersave in which the
 * hardware stays awake for a user-specified period of time after sending a
 * frame so that reply frames need not be buffered and therefore delayed to
 * the next wakeup. It's compromise of getting good enough latency when
 * there's data traffic and still saving significantly power in idle
 * periods.
 *
 * Dynamic powersave is simply supported by mac80211 enabling and disabling
 * PS based on traffic. Driver needs to only set %IEEE80211_HW_SUPPORTS_PS
 * flag and mac80211 will handle everything automatically. Additionally,
 * hardware having support for the dynamic PS feature may set the
 * %IEEE80211_HW_SUPPORTS_DYNAMIC_PS flag to indicate that it can support
 * dynamic PS mode itself. The driver needs to look at the
 * @dynamic_ps_timeout hardware configuration value and use it that value
 * whenever %IEEE80211_CONF_PS is set. In this case mac80211 will disable
 * dynamic PS feature in stack and will just keep %IEEE80211_CONF_PS
 * enabled whenever user has enabled powersave.
 *
 * Driver informs U-APSD client support by enabling
 * %IEEE80211_VIF_SUPPORTS_UAPSD flag. The mode is configured through the
 * uapsd parameter in conf_tx() operation. Hardware needs to send the QoS
 * Nullfunc frames and stay awake until the service period has ended. To
 * utilize U-APSD, dynamic powersave is disabled for voip AC and all frames
 * from that AC are transmitted with powersave enabled.
 *
 * Note: U-APSD client mode is not yet supported with
 * %IEEE80211_HW_PS_NULLFUNC_STACK.
 */

/**
 * DOC: Beacon filter support
 *
 * Some hardware have beacon filter support to reduce host cpu wakeups
 * which will reduce system power consumption. It usually works so that
 * the firmware creates a checksum of the beacon but omits all constantly
 * changing elements (TSF, TIM etc). Whenever the checksum changes the
 * beacon is forwarded to the host, otherwise it will be just dropped. That
 * way the host will only receive beacons where some relevant information
 * (for example ERP protection or WMM settings) have changed.
 *
 * Beacon filter support is advertised with the %IEEE80211_VIF_BEACON_FILTER
 * interface capability. The driver needs to enable beacon filter support
 * whenever power save is enabled, that is %IEEE80211_CONF_PS is set. When
 * power save is enabled, the stack will not check for beacon loss and the
 * driver needs to notify about loss of beacons with ieee80211_beacon_loss().
 *
 * The time (or number of beacons missed) until the firmware notifies the
 * driver of a beacon loss event (which in turn causes the driver to call
 * ieee80211_beacon_loss()) should be configurable and will be controlled
 * by mac80211 and the roaming algorithm in the future.
 *
 * Since there may be constantly changing information elements that nothing
 * in the software stack cares about, we will, in the future, have mac80211
 * tell the driver which information elements are interesting in the sense
 * that we want to see changes in them. This will include
 *  - a list of information element IDs
 *  - a list of OUIs for the vendor information element
 *
 * Ideally, the hardware would filter out any beacons without changes in the
 * requested elements, but if it cannot support that it may, at the expense
 * of some efficiency, filter out only a subset. For example, if the device
 * doesn't support checking for OUIs it should pass up all changes in all
 * vendor information elements.
 *
 * Note that change, for the sake of simplification, also includes information
 * elements appearing or disappearing from the beacon.
 *
 * Some hardware supports an "ignore list" instead, just make sure nothing
 * that was requested is on the ignore list, and include commonly changing
 * information element IDs in the ignore list, for example 11 (BSS load) and
 * the various vendor-assigned IEs with unknown contents (128, 129, 133-136,
 * 149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility
 * it could also include some currently unused IDs.
 *
 *
 * In addition to these capabilities, hardware should support notifying the
 * host of changes in the beacon RSSI. This is relevant to implement roaming
 * when no traffic is flowing (when traffic is flowing we see the RSSI of
 * the received data packets). This can consist in notifying the host when
 * the RSSI changes significantly or when it drops below or rises above
 * configurable thresholds. In the future these thresholds will also be
 * configured by mac80211 (which gets them from userspace) to implement
 * them as the roaming algorithm requires.
 *
 * If the hardware cannot implement this, the driver should ask it to
 * periodically pass beacon frames to the host so that software can do the
 * signal strength threshold checking.
 */

/**
 * DOC: Spatial multiplexing power save
 *
 * SMPS (Spatial multiplexing power save) is a mechanism to conserve
 * power in an 802.11n implementation. For details on the mechanism
 * and rationale, please refer to 802.11 (as amended by 802.11n-2009)
 * "11.2.3 SM power save".
 *
 * The mac80211 implementation is capable of sending action frames
 * to update the AP about the station's SMPS mode, and will instruct
 * the driver to enter the specific mode. It will also announce the
 * requested SMPS mode during the association handshake. Hardware
 * support for this feature is required, and can be indicated by
 * hardware flags.
 *
 * The default mode will be "automatic", which nl80211/cfg80211
 * defines to be dynamic SMPS in (regular) powersave, and SMPS
 * turned off otherwise.
 *
 * To support this feature, the driver must set the appropriate
 * hardware support flags, and handle the SMPS flag to the config()
 * operation. It will then with this mechanism be instructed to
 * enter the requested SMPS mode while associated to an HT AP.
 */

/**
 * DOC: Frame filtering
 *
 * mac80211 requires to see many management frames for proper
 * operation, and users may want to see many more frames when
 * in monitor mode. However, for best CPU usage and power consumption,
 * having as few frames as possible percolate through the stack is
 * desirable. Hence, the hardware should filter as much as possible.
 *
 * To achieve this, mac80211 uses filter flags (see below) to tell
 * the driver's configure_filter() function which frames should be
 * passed to mac80211 and which should be filtered out.
 *
 * Before configure_filter() is invoked, the prepare_multicast()
 * callback is invoked with the parameters @mc_count and @mc_list
 * for the combined multicast address list of all virtual interfaces.
 * It's use is optional, and it returns a u64 that is passed to
 * configure_filter(). Additionally, configure_filter() has the
 * arguments @changed_flags telling which flags were changed and
 * @total_flags with the new flag states.
 *
 * If your device has no multicast address filters your driver will
 * need to check both the %FIF_ALLMULTI flag and the @mc_count
 * parameter to see whether multicast frames should be accepted
 * or dropped.
 *
 * All unsupported flags in @total_flags must be cleared.
 * Hardware does not support a flag if it is incapable of _passing_
 * the frame to the stack. Otherwise the driver must ignore
 * the flag, but not clear it.
 * You must _only_ clear the flag (announce no support for the
 * flag to mac80211) if you are not able to pass the packet type
 * to the stack (so the hardware always filters it).
 * So for example, you should clear @FIF_CONTROL, if your hardware
 * always filters control frames. If your hardware always passes
 * control frames to the kernel and is incapable of filtering them,
 * you do _not_ clear the @FIF_CONTROL flag.
 * This rule applies to all other FIF flags as well.
 */

/**
 * DOC: AP support for powersaving clients
 *
 * In order to implement AP and P2P GO modes, mac80211 has support for
 * client powersaving, both "legacy" PS (PS-Poll/null data) and uAPSD.
 * There currently is no support for sAPSD.
 *
 * There is one assumption that mac80211 makes, namely that a client
 * will not poll with PS-Poll and trigger with uAPSD at the same time.
 * Both are supported, and both can be used by the same client, but
 * they can't be used concurrently by the same client. This simplifies
 * the driver code.
 *
 * The first thing to keep in mind is that there is a flag for complete
 * driver implementation: %IEEE80211_HW_AP_LINK_PS. If this flag is set,
 * mac80211 expects the driver to handle most of the state machine for
 * powersaving clients and will ignore the PM bit in incoming frames.
 * Drivers then use ieee80211_sta_ps_transition() to inform mac80211 of
 * stations' powersave transitions. In this mode, mac80211 also doesn't
 * handle PS-Poll/uAPSD.
 *
 * In the mode without %IEEE80211_HW_AP_LINK_PS, mac80211 will check the
 * PM bit in incoming frames for client powersave transitions. When a
 * station goes to sleep, we will stop transmitting to it. There is,
 * however, a race condition: a station might go to sleep while there is
 * data buffered on hardware queues. If the device has support for this
 * it will reject frames, and the driver should give the frames back to
 * mac80211 with the %IEEE80211_TX_STAT_TX_FILTERED flag set which will
 * cause mac80211 to retry the frame when the station wakes up. The
 * driver is also notified of powersave transitions by calling its
 * @sta_notify callback.
 *
 * When the station is asleep, it has three choices: it can wake up,
 * it can PS-Poll, or it can possibly start a uAPSD service period.
 * Waking up is implemented by simply transmitting all buffered (and
 * filtered) frames to the station. This is the easiest case. When
 * the station sends a PS-Poll or a uAPSD trigger frame, mac80211
 * will inform the driver of this with the @allow_buffered_frames
 * callback; this callback is optional. mac80211 will then transmit
 * the frames as usual and set the %IEEE80211_TX_CTL_NO_PS_BUFFER
 * on each frame. The last frame in the service period (or the only
 * response to a PS-Poll) also has %IEEE80211_TX_STATUS_EOSP set to
 * indicate that it ends the service period; as this frame must have
 * TX status report it also sets %IEEE80211_TX_CTL_REQ_TX_STATUS.
 * When TX status is reported for this frame, the service period is
 * marked has having ended and a new one can be started by the peer.
 *
 * Additionally, non-bufferable MMPDUs can also be transmitted by
 * mac80211 with the %IEEE80211_TX_CTL_NO_PS_BUFFER set in them.
 *
 * Another race condition can happen on some devices like iwlwifi
 * when there are frames queued for the station and it wakes up
 * or polls; the frames that are already queued could end up being
 * transmitted first instead, causing reordering and/or wrong
 * processing of the EOSP. The cause is that allowing frames to be
 * transmitted to a certain station is out-of-band communication to
 * the device. To allow this problem to be solved, the driver can
 * call ieee80211_sta_block_awake() if frames are buffered when it
 * is notified that the station went to sleep. When all these frames
 * have been filtered (see above), it must call the function again
 * to indicate that the station is no longer blocked.
 *
 * If the driver buffers frames in the driver for aggregation in any
 * way, it must use the ieee80211_sta_set_buffered() call when it is
 * notified of the station going to sleep to inform mac80211 of any
 * TIDs that have frames buffered. Note that when a station wakes up
 * this information is reset (hence the requirement to call it when
 * informed of the station going to sleep). Then, when a service
 * period starts for any reason, @release_buffered_frames is called
 * with the number of frames to be released and which TIDs they are
 * to come from. In this case, the driver is responsible for setting
 * the EOSP (for uAPSD) and MORE_DATA bits in the released frames,
 * to help the @more_data parameter is passed to tell the driver if
 * there is more data on other TIDs -- the TIDs to release frames
 * from are ignored since mac80211 doesn't know how many frames the
 * buffers for those TIDs contain.
 *
 * If the driver also implement GO mode, where absence periods may
 * shorten service periods (or abort PS-Poll responses), it must
 * filter those response frames except in the case of frames that
 * are buffered in the driver -- those must remain buffered to avoid
 * reordering. Because it is possible that no frames are released
 * in this case, the driver must call ieee80211_sta_eosp()
 * to indicate to mac80211 that the service period ended anyway.
 *
 * Finally, if frames from multiple TIDs are released from mac80211
 * but the driver might reorder them, it must clear & set the flags
 * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)
 * and also take care of the EOSP and MORE_DATA bits in the frame.
 * The driver may also use ieee80211_sta_eosp() in this case.
 *
 * Note that if the driver ever buffers frames other than QoS-data
 * frames, it must take care to never send a non-QoS-data frame as
 * the last frame in a service period, adding a QoS-nulldata frame
 * after a non-QoS-data frame if needed.
 */

/**
 * DOC: HW queue control
 *
 * Before HW queue control was introduced, mac80211 only had a single static
 * assignment of per-interface AC software queues to hardware queues. This
 * was problematic for a few reasons:
 * 1) off-channel transmissions might get stuck behind other frames
 * 2) multiple virtual interfaces couldn't be handled correctly
 * 3) after-DTIM frames could get stuck behind other frames
 *
 * To solve this, hardware typically uses multiple different queues for all
 * the different usages, and this needs to be propagated into mac80211 so it
 * won't have the same problem with the software queues.
 *
 * Therefore, mac80211 now offers the %IEEE80211_HW_QUEUE_CONTROL capability
 * flag that tells it that the driver implements its own queue control. To do
 * so, the driver will set up the various queues in each &struct ieee80211_vif
 * and the offchannel queue in &struct ieee80211_hw. In response, mac80211 will
 * use those queue IDs in the hw_queue field of &struct ieee80211_tx_info and
 * if necessary will queue the frame on the right software queue that mirrors
 * the hardware queue.
 * Additionally, the driver has to then use these HW queue IDs for the queue
 * management functions (ieee80211_stop_queue() et al.)
 *
 * The driver is free to set up the queue mappings as needed, multiple virtual
 * interfaces may map to the same hardware queues if needed. The setup has to
 * happen during add_interface or change_interface callbacks. For example, a
 * driver supporting station+station and station+AP modes might decide to have
 * 10 hardware queues to handle different scenarios:
 *
 * 4 AC HW queues for 1st vif: 0, 1, 2, 3
 * 4 AC HW queues for 2nd vif: 4, 5, 6, 7
 * after-DTIM queue for AP:   8
 * off-channel queue:         9
 *
 * It would then set up the hardware like this:
 *   hw.offchannel_tx_hw_queue = 9
 *
 * and the first virtual interface that is added as follows:
 *   vif.hw_queue[IEEE80211_AC_VO] = 0
 *   vif.hw_queue[IEEE80211_AC_VI] = 1
 *   vif.hw_queue[IEEE80211_AC_BE] = 2
 *   vif.hw_queue[IEEE80211_AC_BK] = 3
 *   vif.cab_queue = 8 // if AP mode, otherwise %IEEE80211_INVAL_HW_QUEUE
 * and the second virtual interface with 4-7.
 *
 * If queue 6 gets full, for example, mac80211 would only stop the second
 * virtual interface's BE queue since virtual interface queues are per AC.
 *
 * Note that the vif.cab_queue value should be set to %IEEE80211_INVAL_HW_QUEUE
 * whenever the queue is not used (i.e. the interface is not in AP mode) if the
 * queue could potentially be shared since mac80211 will look at cab_queue when
 * a queue is stopped/woken even if the interface is not in AP mode.
 */

/**
 * enum ieee80211_filter_flags - hardware filter flags
 *
 * These flags determine what the filter in hardware should be
 * programmed to let through and what should not be passed to the
 * stack. It is always safe to pass more frames than requested,
 * but this has negative impact on power consumption.
 *
 * @FIF_PROMISC_IN_BSS: promiscuous mode within your BSS,
 *	think of the BSS as your network segment and then this corresponds
 *	to the regular ethernet device promiscuous mode.
 *
 * @FIF_ALLMULTI: pass all multicast frames, this is used if requested
 *	by the user or if the hardware is not capable of filtering by
 *	multicast address.
 *
 * @FIF_FCSFAIL: pass frames with failed FCS (but you need to set the
 *	%RX_FLAG_FAILED_FCS_CRC for them)
 *
 * @FIF_PLCPFAIL: pass frames with failed PLCP CRC (but you need to set
 *	the %RX_FLAG_FAILED_PLCP_CRC for them
 *
 * @FIF_BCN_PRBRESP_PROMISC: This flag is set during scanning to indicate
 *	to the hardware that it should not filter beacons or probe responses
 *	by BSSID. Filtering them can greatly reduce the amount of processing
 *	mac80211 needs to do and the amount of CPU wakeups, so you should
 *	honour this flag if possible.
 *
 * @FIF_CONTROL: pass control frames (except for PS Poll), if PROMISC_IN_BSS
 * 	is not set then only those addressed to this station.
 *
 * @FIF_OTHER_BSS: pass frames destined to other BSSes
 *
 * @FIF_PSPOLL: pass PS Poll frames, if PROMISC_IN_BSS is not set then only
 * 	those addressed to this station.
 *
 * @FIF_PROBE_REQ: pass probe request frames
 */
enum ieee80211_filter_flags {
	FIF_PROMISC_IN_BSS	= 1<<0,
	FIF_ALLMULTI		= 1<<1,
	FIF_FCSFAIL		= 1<<2,
	FIF_PLCPFAIL		= 1<<3,
	FIF_BCN_PRBRESP_PROMISC	= 1<<4,
	FIF_CONTROL		= 1<<5,
	FIF_OTHER_BSS		= 1<<6,
	FIF_PSPOLL		= 1<<7,
	FIF_PROBE_REQ		= 1<<8,
};

/**
 * enum ieee80211_ampdu_mlme_action - A-MPDU actions
 *
 * These flags are used with the ampdu_action() callback in
 * &struct ieee80211_ops to indicate which action is needed.
 *
 * Note that drivers MUST be able to deal with a TX aggregation
 * session being stopped even before they OK'ed starting it by
 * calling ieee80211_start_tx_ba_cb_irqsafe, because the peer
 * might receive the addBA frame and send a delBA right away!
 *
 * @IEEE80211_AMPDU_RX_START: start RX aggregation
 * @IEEE80211_AMPDU_RX_STOP: stop RX aggregation
 * @IEEE80211_AMPDU_TX_START: start TX aggregation
 * @IEEE80211_AMPDU_TX_OPERATIONAL: TX aggregation has become operational
 * @IEEE80211_AMPDU_TX_STOP_CONT: stop TX aggregation but continue transmitting
 *	queued packets, now unaggregated. After all packets are transmitted the
 *	driver has to call ieee80211_stop_tx_ba_cb_irqsafe().
 * @IEEE80211_AMPDU_TX_STOP_FLUSH: stop TX aggregation and flush all packets,
 *	called when the station is removed. There's no need or reason to call
 *	ieee80211_stop_tx_ba_cb_irqsafe() in this case as mac80211 assumes the
 *	session is gone and removes the station.
 * @IEEE80211_AMPDU_TX_STOP_FLUSH_CONT: called when TX aggregation is stopped
 *	but the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe() yet and
 *	now the connection is dropped and the station will be removed. Drivers
 *	should clean up and drop remaining packets when this is called.
 */
enum ieee80211_ampdu_mlme_action {
	IEEE80211_AMPDU_RX_START,
	IEEE80211_AMPDU_RX_STOP,
	IEEE80211_AMPDU_TX_START,
	IEEE80211_AMPDU_TX_STOP_CONT,
	IEEE80211_AMPDU_TX_STOP_FLUSH,
	IEEE80211_AMPDU_TX_STOP_FLUSH_CONT,
	IEEE80211_AMPDU_TX_OPERATIONAL,
};

/**
 * enum ieee80211_frame_release_type - frame release reason
 * @IEEE80211_FRAME_RELEASE_PSPOLL: frame released for PS-Poll
 * @IEEE80211_FRAME_RELEASE_UAPSD: frame(s) released due to
 *	frame received on trigger-enabled AC
 */
enum ieee80211_frame_release_type {
	IEEE80211_FRAME_RELEASE_PSPOLL,
	IEEE80211_FRAME_RELEASE_UAPSD,
};

/**
 * enum ieee80211_rate_control_changed - flags to indicate what changed
 *
 * @IEEE80211_RC_BW_CHANGED: The bandwidth that can be used to transmit
 *	to this station changed. The actual bandwidth is in the station
 *	information -- for HT20/40 the IEEE80211_HT_CAP_SUP_WIDTH_20_40
 *	flag changes, for HT and VHT the bandwidth field changes.
 * @IEEE80211_RC_SMPS_CHANGED: The SMPS state of the station changed.
 * @IEEE80211_RC_SUPP_RATES_CHANGED: The supported rate set of this peer
 *	changed (in IBSS mode) due to discovering more information about
 *	the peer.
 * @IEEE80211_RC_NSS_CHANGED: N_SS (number of spatial streams) was changed
 *	by the peer
 */
enum ieee80211_rate_control_changed {
	IEEE80211_RC_BW_CHANGED		= BIT(0),
	IEEE80211_RC_SMPS_CHANGED	= BIT(1),
	IEEE80211_RC_SUPP_RATES_CHANGED	= BIT(2),
	IEEE80211_RC_NSS_CHANGED	= BIT(3),
};

/**
 * enum ieee80211_roc_type - remain on channel type
 *
 * With the support for multi channel contexts and multi channel operations,
 * remain on channel operations might be limited/deferred/aborted by other
 * flows/operations which have higher priority (and vise versa).
 * Specifying the ROC type can be used by devices to prioritize the ROC
 * operations compared to other operations/flows.
 *
 * @IEEE80211_ROC_TYPE_NORMAL: There are no special requirements for this ROC.
 * @IEEE80211_ROC_TYPE_MGMT_TX: The remain on channel request is required
 *	for sending managment frames offchannel.
 */
enum ieee80211_roc_type {
	IEEE80211_ROC_TYPE_NORMAL = 0,
	IEEE80211_ROC_TYPE_MGMT_TX,
};

/**
 * enum ieee80211_reconfig_complete_type - reconfig type
 *
 * This enum is used by the reconfig_complete() callback to indicate what
 * reconfiguration type was completed.
 *
 * @IEEE80211_RECONFIG_TYPE_RESTART: hw restart type
 *	(also due to resume() callback returning 1)
 * @IEEE80211_RECONFIG_TYPE_SUSPEND: suspend type (regardless
 *	of wowlan configuration)
 */
enum ieee80211_reconfig_type {
	IEEE80211_RECONFIG_TYPE_RESTART,
	IEEE80211_RECONFIG_TYPE_SUSPEND,
};

/**
 * struct ieee80211_ops - callbacks from mac80211 to the driver
 *
 * This structure contains various callbacks that the driver may
 * handle or, in some cases, must handle, for example to configure
 * the hardware to a new channel or to transmit a frame.
 *
 * @tx: Handler that 802.11 module calls for each transmitted frame.
 *	skb contains the buffer starting from the IEEE 802.11 header.
 *	The low-level driver should send the frame out based on
 *	configuration in the TX control data. This handler should,
 *	preferably, never fail and stop queues appropriately.
 *	Must be atomic.
 *
 * @start: Called before the first netdevice attached to the hardware
 *	is enabled. This should turn on the hardware and must turn on
 *	frame reception (for possibly enabled monitor interfaces.)
 *	Returns negative error codes, these may be seen in userspace,
 *	or zero.
 *	When the device is started it should not have a MAC address
 *	to avoid acknowledging frames before a non-monitor device
 *	is added.
 *	Must be implemented and can sleep.
 *
 * @stop: Called after last netdevice attached to the hardware
 *	is disabled. This should turn off the hardware (at least
 *	it must turn off frame reception.)
 *	May be called right after add_interface if that rejects
 *	an interface. If you added any work onto the mac80211 workqueue
 *	you should ensure to cancel it on this callback.
 *	Must be implemented and can sleep.
 *
 * @suspend: Suspend the device; mac80211 itself will quiesce before and
 *	stop transmitting and doing any other configuration, and then
 *	ask the device to suspend. This is only invoked when WoWLAN is
 *	configured, otherwise the device is deconfigured completely and
 *	reconfigured at resume time.
 *	The driver may also impose special conditions under which it
 *	wants to use the "normal" suspend (deconfigure), say if it only
 *	supports WoWLAN when the device is associated. In this case, it
 *	must return 1 from this function.
 *
 * @resume: If WoWLAN was configured, this indicates that mac80211 is
 *	now resuming its operation, after this the device must be fully
 *	functional again. If this returns an error, the only way out is
 *	to also unregister the device. If it returns 1, then mac80211
 *	will also go through the regular complete restart on resume.
 *
 * @set_wakeup: Enable or disable wakeup when WoWLAN configuration is
 *	modified. The reason is that device_set_wakeup_enable() is
 *	supposed to be called when the configuration changes, not only
 *	in suspend().
 *
 * @add_interface: Called when a netdevice attached to the hardware is
 *	enabled. Because it is not called for monitor mode devices, @start
 *	and @stop must be implemented.
 *	The driver should perform any initialization it needs before
 *	the device can be enabled. The initial configuration for the
 *	interface is given in the conf parameter.
 *	The callback may refuse to add an interface by returning a
 *	negative error code (which will be seen in userspace.)
 *	Must be implemented and can sleep.
 *
 * @change_interface: Called when a netdevice changes type. This callback
 *	is optional, but only if it is supported can interface types be
 *	switched while the interface is UP. The callback may sleep.
 *	Note that while an interface is being switched, it will not be
 *	found by the interface iteration callbacks.
 *
 * @remove_interface: Notifies a driver that an interface is going down.
 *	The @stop callback is called after this if it is the last interface
 *	and no monitor interfaces are present.
 *	When all interfaces are removed, the MAC address in the hardware
 *	must be cleared so the device no longer acknowledges packets,
 *	the mac_addr member of the conf structure is, however, set to the
 *	MAC address of the device going away.
 *	Hence, this callback must be implemented. It can sleep.
 *
 * @config: Handler for configuration requests. IEEE 802.11 code calls this
 *	function to change hardware configuration, e.g., channel.
 *	This function should never fail but returns a negative error code
 *	if it does. The callback can sleep.
 *
 * @bss_info_changed: Handler for configuration requests related to BSS
 *	parameters that may vary during BSS's lifespan, and may affect low
 *	level driver (e.g. assoc/disassoc status, erp parameters).
 *	This function should not be used if no BSS has been set, unless
 *	for association indication. The @changed parameter indicates which
 *	of the bss parameters has changed when a call is made. The callback
 *	can sleep.
 *
 * @prepare_multicast: Prepare for multicast filter configuration.
 *	This callback is optional, and its return value is passed
 *	to configure_filter(). This callback must be atomic.
 *
 * @configure_filter: Configure the device's RX filter.
 *	See the section "Frame filtering" for more information.
 *	This callback must be implemented and can sleep.
 *
 * @set_tim: Set TIM bit. mac80211 calls this function when a TIM bit
 * 	must be set or cleared for a given STA. Must be atomic.
 *
 * @set_key: See the section "Hardware crypto acceleration"
 *	This callback is only called between add_interface and
 *	remove_interface calls, i.e. while the given virtual interface
 *	is enabled.
 *	Returns a negative error code if the key can't be added.
 *	The callback can sleep.
 *
 * @update_tkip_key: See the section "Hardware crypto acceleration"
 * 	This callback will be called in the context of Rx. Called for drivers
 * 	which set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.
 *	The callback must be atomic.
 *
 * @set_rekey_data: If the device supports GTK rekeying, for example while the
 *	host is suspended, it can assign this callback to retrieve the data
 *	necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
 *	After rekeying was done it should (for example during resume) notify
 *	userspace of the new replay counter using ieee80211_gtk_rekey_notify().
 *
 * @set_default_unicast_key: Set the default (unicast) key index, useful for
 *	WEP when the device sends data packets autonomously, e.g. for ARP
 *	offloading. The index can be 0-3, or -1 for unsetting it.
 *
 * @hw_scan: Ask the hardware to service the scan request, no need to start
 *	the scan state machine in stack. The scan must honour the channel
 *	configuration done by the regulatory agent in the wiphy's
 *	registered bands. The hardware (or the driver) needs to make sure
 *	that power save is disabled.
 *	The @req ie/ie_len members are rewritten by mac80211 to contain the
 *	entire IEs after the SSID, so that drivers need not look at these
 *	at all but just send them after the SSID -- mac80211 includes the
 *	(extended) supported rates and HT information (where applicable).
 *	When the scan finishes, ieee80211_scan_completed() must be called;
 *	note that it also must be called when the scan cannot finish due to
 *	any error unless this callback returned a negative error code.
 *	The callback can sleep.
 *
 * @cancel_hw_scan: Ask the low-level tp cancel the active hw scan.
 *	The driver should ask the hardware to cancel the scan (if possible),
 *	but the scan will be completed only after the driver will call
 *	ieee80211_scan_completed().
 *	This callback is needed for wowlan, to prevent enqueueing a new
 *	scan_work after the low-level driver was already suspended.
 *	The callback can sleep.
 *
 * @sched_scan_start: Ask the hardware to start scanning repeatedly at
 *	specific intervals.  The driver must call the
 *	ieee80211_sched_scan_results() function whenever it finds results.
 *	This process will continue until sched_scan_stop is called.
 *
 * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.
 *	In this case, ieee80211_sched_scan_stopped() must not be called.
 *
 * @sw_scan_start: Notifier function that is called just before a software scan
 *	is started. Can be NULL, if the driver doesn't need this notification.
 *	The mac_addr parameter allows supporting NL80211_SCAN_FLAG_RANDOM_ADDR,
 *	the driver may set the NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR flag if it
 *	can use this parameter. The callback can sleep.
 *
 * @sw_scan_complete: Notifier function that is called just after a
 *	software scan finished. Can be NULL, if the driver doesn't need
 *	this notification.
 *	The callback can sleep.
 *
 * @get_stats: Return low-level statistics.
 * 	Returns zero if statistics are available.
 *	The callback can sleep.
 *
 * @get_tkip_seq: If your device implements TKIP encryption in hardware this
 *	callback should be provided to read the TKIP transmit IVs (both IV32
 *	and IV16) for the given key from hardware.
 *	The callback must be atomic.
 *
 * @set_frag_threshold: Configuration of fragmentation threshold. Assign this
 *	if the device does fragmentation by itself; if this callback is
 *	implemented then the stack will not do fragmentation.
 *	The callback can sleep.
 *
 * @set_rts_threshold: Configuration of RTS threshold (if device needs it)
 *	The callback can sleep.
 *
 * @sta_add: Notifies low level driver about addition of an associated station,
 *	AP, IBSS/WDS/mesh peer etc. This callback can sleep.
 *
 * @sta_remove: Notifies low level driver about removal of an associated
 *	station, AP, IBSS/WDS/mesh peer etc. Note that after the callback
 *	returns it isn't safe to use the pointer, not even RCU protected;
 *	no RCU grace period is guaranteed between returning here and freeing
 *	the station. See @sta_pre_rcu_remove if needed.
 *	This callback can sleep.
 *
 * @sta_add_debugfs: Drivers can use this callback to add debugfs files
 *	when a station is added to mac80211's station list. This callback
 *	and @sta_remove_debugfs should be within a CONFIG_MAC80211_DEBUGFS
 *	conditional. This callback can sleep.
 *
 * @sta_remove_debugfs: Remove the debugfs files which were added using
 *	@sta_add_debugfs. This callback can sleep.
 *
 * @sta_notify: Notifies low level driver about power state transition of an
 *	associated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating
 *	in AP mode, this callback will not be called when the flag
 *	%IEEE80211_HW_AP_LINK_PS is set. Must be atomic.
 *
 * @sta_state: Notifies low level driver about state transition of a
 *	station (which can be the AP, a client, IBSS/WDS/mesh peer etc.)
 *	This callback is mutually exclusive with @sta_add/@sta_remove.
 *	It must not fail for down transitions but may fail for transitions
 *	up the list of states. Also note that after the callback returns it
 *	isn't safe to use the pointer, not even RCU protected - no RCU grace
 *	period is guaranteed between returning here and freeing the station.
 *	See @sta_pre_rcu_remove if needed.
 *	The callback can sleep.
 *
 * @sta_pre_rcu_remove: Notify driver about station removal before RCU
 *	synchronisation. This is useful if a driver needs to have station
 *	pointers protected using RCU, it can then use this call to clear
 *	the pointers instead of waiting for an RCU grace period to elapse
 *	in @sta_state.
 *	The callback can sleep.
 *
 * @sta_rc_update: Notifies the driver of changes to the bitrates that can be
 *	used to transmit to the station. The changes are advertised with bits
 *	from &enum ieee80211_rate_control_changed and the values are reflected
 *	in the station data. This callback should only be used when the driver
 *	uses hardware rate control (%IEEE80211_HW_HAS_RATE_CONTROL) since
 *	otherwise the rate control algorithm is notified directly.
 *	Must be atomic.
 * @sta_rate_tbl_update: Notifies the driver that the rate table changed. This
 *	is only used if the configured rate control algorithm actually uses
 *	the new rate table API, and is therefore optional. Must be atomic.
 *
 * @sta_statistics: Get statistics for this station. For example with beacon
 *	filtering, the statistics kept by mac80211 might not be accurate, so
 *	let the driver pre-fill the statistics. The driver can fill most of
 *	the values (indicating which by setting the filled bitmap), but not
 *	all of them make sense - see the source for which ones are possible.
 *	Statistics that the driver doesn't fill will be filled by mac80211.
 *	The callback can sleep.
 *
 * @conf_tx: Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),
 *	bursting) for a hardware TX queue.
 *	Returns a negative error code on failure.
 *	The callback can sleep.
 *
 * @get_tsf: Get the current TSF timer value from firmware/hardware. Currently,
 *	this is only used for IBSS mode BSSID merging and debugging. Is not a
 *	required function.
 *	The callback can sleep.
 *
 * @set_tsf: Set the TSF timer to the specified value in the firmware/hardware.
 *	Currently, this is only used for IBSS mode debugging. Is not a
 *	required function.
 *	The callback can sleep.
 *
 * @reset_tsf: Reset the TSF timer and allow firmware/hardware to synchronize
 *	with other STAs in the IBSS. This is only used in IBSS mode. This
 *	function is optional if the firmware/hardware takes full care of
 *	TSF synchronization.
 *	The callback can sleep.
 *
 * @tx_last_beacon: Determine whether the last IBSS beacon was sent by us.
 *	This is needed only for IBSS mode and the result of this function is
 *	used to determine whether to reply to Probe Requests.
 *	Returns non-zero if this device sent the last beacon.
 *	The callback can sleep.
 *
 * @ampdu_action: Perform a certain A-MPDU action
 * 	The RA/TID combination determines the destination and TID we want
 * 	the ampdu action to be performed for. The action is defined through
 * 	ieee80211_ampdu_mlme_action. Starting sequence number (@ssn)
 * 	is the first frame we expect to perform the action on. Notice
 * 	that TX/RX_STOP can pass NULL for this parameter.
 *	The @buf_size parameter is only valid when the action is set to
 *	%IEEE80211_AMPDU_TX_OPERATIONAL and indicates the peer's reorder
 *	buffer size (number of subframes) for this session -- the driver
 *	may neither send aggregates containing more subframes than this
 *	nor send aggregates in a way that lost frames would exceed the
 *	buffer size. If just limiting the aggregate size, this would be
 *	possible with a buf_size of 8:
 *	 - TX: 1.....7
 *	 - RX:  2....7 (lost frame #1)
 *	 - TX:        8..1...
 *	which is invalid since #1 was now re-transmitted well past the
 *	buffer size of 8. Correct ways to retransmit #1 would be:
 *	 - TX:       1 or 18 or 81
 *	Even "189" would be wrong since 1 could be lost again.
 *
 *	Returns a negative error code on failure.
 *	The callback can sleep.
 *
 * @get_survey: Return per-channel survey information
 *
 * @rfkill_poll: Poll rfkill hardware state. If you need this, you also
 *	need to set wiphy->rfkill_poll to %true before registration,
 *	and need to call wiphy_rfkill_set_hw_state() in the callback.
 *	The callback can sleep.
 *
 * @set_coverage_class: Set slot time for given coverage class as specified
 *	in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout
 *	accordingly; coverage class equals to -1 to enable ACK timeout
 *	estimation algorithm (dynack). To disable dynack set valid value for
 *	coverage class. This callback is not required and may sleep.
 *
 * @testmode_cmd: Implement a cfg80211 test mode command. The passed @vif may
 *	be %NULL. The callback can sleep.
 * @testmode_dump: Implement a cfg80211 test mode dump. The callback can sleep.
 *
 * @flush: Flush all pending frames from the hardware queue, making sure
 *	that the hardware queues are empty. The @queues parameter is a bitmap
 *	of queues to flush, which is useful if different virtual interfaces
 *	use different hardware queues; it may also indicate all queues.
 *	If the parameter @drop is set to %true, pending frames may be dropped.
 *	Note that vif can be NULL.
 *	The callback can sleep.
 *
 * @channel_switch: Drivers that need (or want) to offload the channel
 *	switch operation for CSAs received from the AP may implement this
 *	callback. They must then call ieee80211_chswitch_done() to indicate
 *	completion of the channel switch.
 *
 * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.
 *	Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
 *	reject TX/RX mask combinations they cannot support by returning -EINVAL
 *	(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).
 *
 * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).
 *
 * @remain_on_channel: Starts an off-channel period on the given channel, must
 *	call back to ieee80211_ready_on_channel() when on that channel. Note
 *	that normal channel traffic is not stopped as this is intended for hw
 *	offload. Frames to transmit on the off-channel channel are transmitted
 *	normally except for the %IEEE80211_TX_CTL_TX_OFFCHAN flag. When the
 *	duration (which will always be non-zero) expires, the driver must call
 *	ieee80211_remain_on_channel_expired().
 *	Note that this callback may be called while the device is in IDLE and
 *	must be accepted in this case.
 *	This callback may sleep.
 * @cancel_remain_on_channel: Requests that an ongoing off-channel period is
 *	aborted before it expires. This callback may sleep.
 *
 * @set_ringparam: Set tx and rx ring sizes.
 *
 * @get_ringparam: Get tx and rx ring current and maximum sizes.
 *
 * @tx_frames_pending: Check if there is any pending frame in the hardware
 *	queues before entering power save.
 *
 * @set_bitrate_mask: Set a mask of rates to be used for rate control selection
 *	when transmitting a frame. Currently only legacy rates are handled.
 *	The callback can sleep.
 * @event_callback: Notify driver about any event in mac80211. See
 *	&enum ieee80211_event_type for the different types.
 *	The callback can sleep.
 *
 * @release_buffered_frames: Release buffered frames according to the given
 *	parameters. In the case where the driver buffers some frames for
 *	sleeping stations mac80211 will use this callback to tell the driver
 *	to release some frames, either for PS-poll or uAPSD.
 *	Note that if the @more_data parameter is %false the driver must check
 *	if there are more frames on the given TIDs, and if there are more than
 *	the frames being released then it must still set the more-data bit in
 *	the frame. If the @more_data parameter is %true, then of course the
 *	more-data bit must always be set.
 *	The @tids parameter tells the driver which TIDs to release frames
 *	from, for PS-poll it will always have only a single bit set.
 *	In the case this is used for a PS-poll initiated release, the
 *	@num_frames parameter will always be 1 so code can be shared. In
 *	this case the driver must also set %IEEE80211_TX_STATUS_EOSP flag
 *	on the TX status (and must report TX status) so that the PS-poll
 *	period is properly ended. This is used to avoid sending multiple
 *	responses for a retried PS-poll frame.
 *	In the case this is used for uAPSD, the @num_frames parameter may be
 *	bigger than one, but the driver may send fewer frames (it must send
 *	at least one, however). In this case it is also responsible for
 *	setting the EOSP flag in the QoS header of the frames. Also, when the
 *	service period ends, the driver must set %IEEE80211_TX_STATUS_EOSP
 *	on the last frame in the SP. Alternatively, it may call the function
 *	ieee80211_sta_eosp() to inform mac80211 of the end of the SP.
 *	This callback must be atomic.
 * @allow_buffered_frames: Prepare device to allow the given number of frames
 *	to go out to the given station. The frames will be sent by mac80211
 *	via the usual TX path after this call. The TX information for frames
 *	released will also have the %IEEE80211_TX_CTL_NO_PS_BUFFER flag set
 *	and the last one will also have %IEEE80211_TX_STATUS_EOSP set. In case
 *	frames from multiple TIDs are released and the driver might reorder
 *	them between the TIDs, it must set the %IEEE80211_TX_STATUS_EOSP flag
 *	on the last frame and clear it on all others and also handle the EOSP
 *	bit in the QoS header correctly. Alternatively, it can also call the
 *	ieee80211_sta_eosp() function.
 *	The @tids parameter is a bitmap and tells the driver which TIDs the
 *	frames will be on; it will at most have two bits set.
 *	This callback must be atomic.
 *
 * @get_et_sset_count:  Ethtool API to get string-set count.
 *
 * @get_et_stats:  Ethtool API to get a set of u64 stats.
 *
 * @get_et_strings:  Ethtool API to get a set of strings to describe stats
 *	and perhaps other supported types of ethtool data-sets.
 *
 * @mgd_prepare_tx: Prepare for transmitting a management frame for association
 *	before associated. In multi-channel scenarios, a virtual interface is
 *	bound to a channel before it is associated, but as it isn't associated
 *	yet it need not necessarily be given airtime, in particular since any
 *	transmission to a P2P GO needs to be synchronized against the GO's
 *	powersave state. mac80211 will call this function before transmitting a
 *	management frame prior to having successfully associated to allow the
 *	driver to give it channel time for the transmission, to get a response
 *	and to be able to synchronize with the GO.
 *	The callback will be called before each transmission and upon return
 *	mac80211 will transmit the frame right away.
 *	The callback is optional and can (should!) sleep.
 *
 * @mgd_protect_tdls_discover: Protect a TDLS discovery session. After sending
 *	a TDLS discovery-request, we expect a reply to arrive on the AP's
 *	channel. We must stay on the channel (no PSM, scan, etc.), since a TDLS
 *	setup-response is a direct packet not buffered by the AP.
 *	mac80211 will call this function just before the transmission of a TDLS
 *	discovery-request. The recommended period of protection is at least
 *	2 * (DTIM period).
 *	The callback is optional and can sleep.
 *
 * @add_chanctx: Notifies device driver about new channel context creation.
 * @remove_chanctx: Notifies device driver about channel context destruction.
 * @change_chanctx: Notifies device driver about channel context changes that
 *	may happen when combining different virtual interfaces on the same
 *	channel context with different settings
 * @assign_vif_chanctx: Notifies device driver about channel context being bound
 *	to vif. Possible use is for hw queue remapping.
 * @unassign_vif_chanctx: Notifies device driver about channel context being
 *	unbound from vif.
 * @switch_vif_chanctx: switch a number of vifs from one chanctx to
 *	another, as specified in the list of
 *	@ieee80211_vif_chanctx_switch passed to the driver, according
 *	to the mode defined in &ieee80211_chanctx_switch_mode.
 *
 * @start_ap: Start operation on the AP interface, this is called after all the
 *	information in bss_conf is set and beacon can be retrieved. A channel
 *	context is bound before this is called. Note that if the driver uses
 *	software scan or ROC, this (and @stop_ap) isn't called when the AP is
 *	just "paused" for scanning/ROC, which is indicated by the beacon being
 *	disabled/enabled via @bss_info_changed.
 * @stop_ap: Stop operation on the AP interface.
 *
 * @reconfig_complete: Called after a call to ieee80211_restart_hw() and
 *	during resume, when the reconfiguration has completed.
 *	This can help the driver implement the reconfiguration step (and
 *	indicate mac80211 is ready to receive frames).
 *	This callback may sleep.
 *
 * @ipv6_addr_change: IPv6 address assignment on the given interface changed.
 *	Currently, this is only called for managed or P2P client interfaces.
 *	This callback is optional; it must not sleep.
 *
 * @channel_switch_beacon: Starts a channel switch to a new channel.
 *	Beacons are modified to include CSA or ECSA IEs before calling this
 *	function. The corresponding count fields in these IEs must be
 *	decremented, and when they reach 1 the driver must call
 *	ieee80211_csa_finish(). Drivers which use ieee80211_beacon_get()
 *	get the csa counter decremented by mac80211, but must check if it is
 *	1 using ieee80211_csa_is_complete() after the beacon has been
 *	transmitted and then call ieee80211_csa_finish().
 *	If the CSA count starts as zero or 1, this function will not be called,
 *	since there won't be any time to beacon before the switch anyway.
 * @pre_channel_switch: This is an optional callback that is called
 *	before a channel switch procedure is started (ie. when a STA
 *	gets a CSA or an userspace initiated channel-switch), allowing
 *	the driver to prepare for the channel switch.
 * @post_channel_switch: This is an optional callback that is called
 *	after a channel switch procedure is completed, allowing the
 *	driver to go back to a normal configuration.
 *
 * @join_ibss: Join an IBSS (on an IBSS interface); this is called after all
 *	information in bss_conf is set up and the beacon can be retrieved. A
 *	channel context is bound before this is called.
 * @leave_ibss: Leave the IBSS again.
 *
 * @get_expected_throughput: extract the expected throughput towards the
 *	specified station. The returned value is expressed in Kbps. It returns 0
 *	if the RC algorithm does not have proper data to provide.
 *
 * @get_txpower: get current maximum tx power (in dBm) based on configuration
 *	and hardware limits.
 *
 * @tdls_channel_switch: Start channel-switching with a TDLS peer. The driver
 *	is responsible for continually initiating channel-switching operations
 *	and returning to the base channel for communication with the AP. The
 *	driver receives a channel-switch request template and the location of
 *	the switch-timing IE within the template as part of the invocation.
 *	The template is valid only within the call, and the driver can
 *	optionally copy the skb for further re-use.
 * @tdls_cancel_channel_switch: Stop channel-switching with a TDLS peer. Both
 *	peers must be on the base channel when the call completes.
 * @tdls_recv_channel_switch: a TDLS channel-switch related frame (request or
 *	response) has been received from a remote peer. The driver gets
 *	parameters parsed from the incoming frame and may use them to continue
 *	an ongoing channel-switch operation. In addition, a channel-switch
 *	response template is provided, together with the location of the
 *	switch-timing IE within the template. The skb can only be used within
 *	the function call.
 *
 * @wake_tx_queue: Called when new packets have been added to the queue.
 */
struct ieee80211_ops {
	void (*tx)(struct ieee80211_hw *hw,
		   struct ieee80211_tx_control *control,
		   struct sk_buff *skb);
	int (*start)(struct ieee80211_hw *hw);
	void (*stop)(struct ieee80211_hw *hw);
#ifdef CONFIG_PM
	int (*suspend)(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);
	int (*resume)(struct ieee80211_hw *hw);
	void (*set_wakeup)(struct ieee80211_hw *hw, bool enabled);
#endif
	int (*add_interface)(struct ieee80211_hw *hw,
			     struct ieee80211_vif *vif);
	int (*change_interface)(struct ieee80211_hw *hw,
				struct ieee80211_vif *vif,
				enum nl80211_iftype new_type, bool p2p);
	void (*remove_interface)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif);
	int (*config)(struct ieee80211_hw *hw, u32 changed);
	void (*bss_info_changed)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif,
				 struct ieee80211_bss_conf *info,
				 u32 changed);

	int (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
	void (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);

	u64 (*prepare_multicast)(struct ieee80211_hw *hw,
				 struct netdev_hw_addr_list *mc_list);
	void (*configure_filter)(struct ieee80211_hw *hw,
				 unsigned int changed_flags,
				 unsigned int *total_flags,
				 u64 multicast);
	int (*set_tim)(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
		       bool set);
	int (*set_key)(struct ieee80211_hw *hw, enum set_key_cmd cmd,
		       struct ieee80211_vif *vif, struct ieee80211_sta *sta,
		       struct ieee80211_key_conf *key);
	void (*update_tkip_key)(struct ieee80211_hw *hw,
				struct ieee80211_vif *vif,
				struct ieee80211_key_conf *conf,
				struct ieee80211_sta *sta,
				u32 iv32, u16 *phase1key);
	void (*set_rekey_data)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif,
			       struct cfg80211_gtk_rekey_data *data);
	void (*set_default_unicast_key)(struct ieee80211_hw *hw,
					struct ieee80211_vif *vif, int idx);
	int (*hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		       struct ieee80211_scan_request *req);
	void (*cancel_hw_scan)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif);
	int (*sched_scan_start)(struct ieee80211_hw *hw,
				struct ieee80211_vif *vif,
				struct cfg80211_sched_scan_request *req,
				struct ieee80211_scan_ies *ies);
	int (*sched_scan_stop)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif);
	void (*sw_scan_start)(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif,
			      const u8 *mac_addr);
	void (*sw_scan_complete)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif);
	int (*get_stats)(struct ieee80211_hw *hw,
			 struct ieee80211_low_level_stats *stats);
	void (*get_tkip_seq)(struct ieee80211_hw *hw, u8 hw_key_idx,
			     u32 *iv32, u16 *iv16);
	int (*set_frag_threshold)(struct ieee80211_hw *hw, u32 value);
	int (*set_rts_threshold)(struct ieee80211_hw *hw, u32 value);
	int (*sta_add)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		       struct ieee80211_sta *sta);
	int (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			  struct ieee80211_sta *sta);
#ifdef CONFIG_MAC80211_DEBUGFS
	void (*sta_add_debugfs)(struct ieee80211_hw *hw,
				struct ieee80211_vif *vif,
				struct ieee80211_sta *sta,
				struct dentry *dir);
	void (*sta_remove_debugfs)(struct ieee80211_hw *hw,
				   struct ieee80211_vif *vif,
				   struct ieee80211_sta *sta,
				   struct dentry *dir);
#endif
	void (*sta_notify)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			enum sta_notify_cmd, struct ieee80211_sta *sta);
	int (*sta_state)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			 struct ieee80211_sta *sta,
			 enum ieee80211_sta_state old_state,
			 enum ieee80211_sta_state new_state);
	void (*sta_pre_rcu_remove)(struct ieee80211_hw *hw,
				   struct ieee80211_vif *vif,
				   struct ieee80211_sta *sta);
	void (*sta_rc_update)(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif,
			      struct ieee80211_sta *sta,
			      u32 changed);
	void (*sta_rate_tbl_update)(struct ieee80211_hw *hw,
				    struct ieee80211_vif *vif,
				    struct ieee80211_sta *sta);
	void (*sta_statistics)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif,
			       struct ieee80211_sta *sta,
			       struct station_info *sinfo);
	int (*conf_tx)(struct ieee80211_hw *hw,
		       struct ieee80211_vif *vif, u16 ac,
		       const struct ieee80211_tx_queue_params *params);
	u64 (*get_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
	void (*set_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			u64 tsf);
	void (*reset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
	int (*tx_last_beacon)(struct ieee80211_hw *hw);
	int (*ampdu_action)(struct ieee80211_hw *hw,
			    struct ieee80211_vif *vif,
			    enum ieee80211_ampdu_mlme_action action,
			    struct ieee80211_sta *sta, u16 tid, u16 *ssn,
			    u8 buf_size);
	int (*get_survey)(struct ieee80211_hw *hw, int idx,
		struct survey_info *survey);
	void (*rfkill_poll)(struct ieee80211_hw *hw);
	void (*set_coverage_class)(struct ieee80211_hw *hw, s16 coverage_class);
#ifdef CONFIG_NL80211_TESTMODE
	int (*testmode_cmd)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			    void *data, int len);
	int (*testmode_dump)(struct ieee80211_hw *hw, struct sk_buff *skb,
			     struct netlink_callback *cb,
			     void *data, int len);
#endif
	void (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		      u32 queues, bool drop);
	void (*channel_switch)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif,
			       struct ieee80211_channel_switch *ch_switch);
	int (*set_antenna)(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
	int (*get_antenna)(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);

	int (*remain_on_channel)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif,
				 struct ieee80211_channel *chan,
				 int duration,
				 enum ieee80211_roc_type type);
	int (*cancel_remain_on_channel)(struct ieee80211_hw *hw);
	int (*set_ringparam)(struct ieee80211_hw *hw, u32 tx, u32 rx);
	void (*get_ringparam)(struct ieee80211_hw *hw,
			      u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);
	bool (*tx_frames_pending)(struct ieee80211_hw *hw);
	int (*set_bitrate_mask)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
				const struct cfg80211_bitrate_mask *mask);
	void (*event_callback)(struct ieee80211_hw *hw,
			       struct ieee80211_vif *vif,
			       const struct ieee80211_event *event);

	void (*allow_buffered_frames)(struct ieee80211_hw *hw,
				      struct ieee80211_sta *sta,
				      u16 tids, int num_frames,
				      enum ieee80211_frame_release_type reason,
				      bool more_data);
	void (*release_buffered_frames)(struct ieee80211_hw *hw,
					struct ieee80211_sta *sta,
					u16 tids, int num_frames,
					enum ieee80211_frame_release_type reason,
					bool more_data);

	int	(*get_et_sset_count)(struct ieee80211_hw *hw,
				     struct ieee80211_vif *vif, int sset);
	void	(*get_et_stats)(struct ieee80211_hw *hw,
				struct ieee80211_vif *vif,
				struct ethtool_stats *stats, u64 *data);
	void	(*get_et_strings)(struct ieee80211_hw *hw,
				  struct ieee80211_vif *vif,
				  u32 sset, u8 *data);

	void	(*mgd_prepare_tx)(struct ieee80211_hw *hw,
				  struct ieee80211_vif *vif);

	void	(*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,
					     struct ieee80211_vif *vif);

	int (*add_chanctx)(struct ieee80211_hw *hw,
			   struct ieee80211_chanctx_conf *ctx);
	void (*remove_chanctx)(struct ieee80211_hw *hw,
			       struct ieee80211_chanctx_conf *ctx);
	void (*change_chanctx)(struct ieee80211_hw *hw,
			       struct ieee80211_chanctx_conf *ctx,
			       u32 changed);
	int (*assign_vif_chanctx)(struct ieee80211_hw *hw,
				  struct ieee80211_vif *vif,
				  struct ieee80211_chanctx_conf *ctx);
	void (*unassign_vif_chanctx)(struct ieee80211_hw *hw,
				     struct ieee80211_vif *vif,
				     struct ieee80211_chanctx_conf *ctx);
	int (*switch_vif_chanctx)(struct ieee80211_hw *hw,
				  struct ieee80211_vif_chanctx_switch *vifs,
				  int n_vifs,
				  enum ieee80211_chanctx_switch_mode mode);

	void (*reconfig_complete)(struct ieee80211_hw *hw,
				  enum ieee80211_reconfig_type reconfig_type);

#if IS_ENABLED(CONFIG_IPV6)
	void (*ipv6_addr_change)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif,
				 struct inet6_dev *idev);
#endif
	void (*channel_switch_beacon)(struct ieee80211_hw *hw,
				      struct ieee80211_vif *vif,
				      struct cfg80211_chan_def *chandef);
	int (*pre_channel_switch)(struct ieee80211_hw *hw,
				  struct ieee80211_vif *vif,
				  struct ieee80211_channel_switch *ch_switch);

	int (*post_channel_switch)(struct ieee80211_hw *hw,
				   struct ieee80211_vif *vif);

	int (*join_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
	void (*leave_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
	u32 (*get_expected_throughput)(struct ieee80211_sta *sta);
	int (*get_txpower)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			   int *dbm);

	int (*tdls_channel_switch)(struct ieee80211_hw *hw,
				   struct ieee80211_vif *vif,
				   struct ieee80211_sta *sta, u8 oper_class,
				   struct cfg80211_chan_def *chandef,
				   struct sk_buff *tmpl_skb, u32 ch_sw_tm_ie);
	void (*tdls_cancel_channel_switch)(struct ieee80211_hw *hw,
					   struct ieee80211_vif *vif,
					   struct ieee80211_sta *sta);
	void (*tdls_recv_channel_switch)(struct ieee80211_hw *hw,
					 struct ieee80211_vif *vif,
					 struct ieee80211_tdls_ch_sw_params *params);

	void (*wake_tx_queue)(struct ieee80211_hw *hw,
			      struct ieee80211_txq *txq);
};

/**
 * ieee80211_alloc_hw_nm - Allocate a new hardware device
 *
 * This must be called once for each hardware device. The returned pointer
 * must be used to refer to this device when calling other functions.
 * mac80211 allocates a private data area for the driver pointed to by
 * @priv in &struct ieee80211_hw, the size of this area is given as
 * @priv_data_len.
 *
 * @priv_data_len: length of private data
 * @ops: callbacks for this device
 * @requested_name: Requested name for this device.
 *	NULL is valid value, and means use the default naming (phy%d)
 *
 * Return: A pointer to the new hardware device, or %NULL on error.
 */
struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
					   const struct ieee80211_ops *ops,
					   const char *requested_name);

/**
 * ieee80211_alloc_hw - Allocate a new hardware device
 *
 * This must be called once for each hardware device. The returned pointer
 * must be used to refer to this device when calling other functions.
 * mac80211 allocates a private data area for the driver pointed to by
 * @priv in &struct ieee80211_hw, the size of this area is given as
 * @priv_data_len.
 *
 * @priv_data_len: length of private data
 * @ops: callbacks for this device
 *
 * Return: A pointer to the new hardware device, or %NULL on error.
 */
static inline
struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,
					const struct ieee80211_ops *ops)
{
	return ieee80211_alloc_hw_nm(priv_data_len, ops, NULL);
}

/**
 * ieee80211_register_hw - Register hardware device
 *
 * You must call this function before any other functions in
 * mac80211. Note that before a hardware can be registered, you
 * need to fill the contained wiphy's information.
 *
 * @hw: the device to register as returned by ieee80211_alloc_hw()
 *
 * Return: 0 on success. An error code otherwise.
 */
int ieee80211_register_hw(struct ieee80211_hw *hw);

/**
 * struct ieee80211_tpt_blink - throughput blink description
 * @throughput: throughput in Kbit/sec
 * @blink_time: blink time in milliseconds
 *	(full cycle, ie. one off + one on period)
 */
struct ieee80211_tpt_blink {
	int throughput;
	int blink_time;
};

/**
 * enum ieee80211_tpt_led_trigger_flags - throughput trigger flags
 * @IEEE80211_TPT_LEDTRIG_FL_RADIO: enable blinking with radio
 * @IEEE80211_TPT_LEDTRIG_FL_WORK: enable blinking when working
 * @IEEE80211_TPT_LEDTRIG_FL_CONNECTED: enable blinking when at least one
 *	interface is connected in some way, including being an AP
 */
enum ieee80211_tpt_led_trigger_flags {
	IEEE80211_TPT_LEDTRIG_FL_RADIO		= BIT(0),
	IEEE80211_TPT_LEDTRIG_FL_WORK		= BIT(1),
	IEEE80211_TPT_LEDTRIG_FL_CONNECTED	= BIT(2),
};

#ifdef CONFIG_MAC80211_LEDS
char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);
char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);
char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);
char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);
char *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,
					 unsigned int flags,
					 const struct ieee80211_tpt_blink *blink_table,
					 unsigned int blink_table_len);
#endif
/**
 * ieee80211_get_tx_led_name - get name of TX LED
 *
 * mac80211 creates a transmit LED trigger for each wireless hardware
 * that can be used to drive LEDs if your driver registers a LED device.
 * This function returns the name (or %NULL if not configured for LEDs)
 * of the trigger so you can automatically link the LED device.
 *
 * @hw: the hardware to get the LED trigger name for
 *
 * Return: The name of the LED trigger. %NULL if not configured for LEDs.
 */
static inline char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)
{
#ifdef CONFIG_MAC80211_LEDS
	return __ieee80211_get_tx_led_name(hw);
#else
	return NULL;
#endif
}

/**
 * ieee80211_get_rx_led_name - get name of RX LED
 *
 * mac80211 creates a receive LED trigger for each wireless hardware
 * that can be used to drive LEDs if your driver registers a LED device.
 * This function returns the name (or %NULL if not configured for LEDs)
 * of the trigger so you can automatically link the LED device.
 *
 * @hw: the hardware to get the LED trigger name for
 *
 * Return: The name of the LED trigger. %NULL if not configured for LEDs.
 */
static inline char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)
{
#ifdef CONFIG_MAC80211_LEDS
	return __ieee80211_get_rx_led_name(hw);
#else
	return NULL;
#endif
}

/**
 * ieee80211_get_assoc_led_name - get name of association LED
 *
 * mac80211 creates a association LED trigger for each wireless hardware
 * that can be used to drive LEDs if your driver registers a LED device.
 * This function returns the name (or %NULL if not configured for LEDs)
 * of the trigger so you can automatically link the LED device.
 *
 * @hw: the hardware to get the LED trigger name for
 *
 * Return: The name of the LED trigger. %NULL if not configured for LEDs.
 */
static inline char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)
{
#ifdef CONFIG_MAC80211_LEDS
	return __ieee80211_get_assoc_led_name(hw);
#else
	return NULL;
#endif
}

/**
 * ieee80211_get_radio_led_name - get name of radio LED
 *
 * mac80211 creates a radio change LED trigger for each wireless hardware
 * that can be used to drive LEDs if your driver registers a LED device.
 * This function returns the name (or %NULL if not configured for LEDs)
 * of the trigger so you can automatically link the LED device.
 *
 * @hw: the hardware to get the LED trigger name for
 *
 * Return: The name of the LED trigger. %NULL if not configured for LEDs.
 */
static inline char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)
{
#ifdef CONFIG_MAC80211_LEDS
	return __ieee80211_get_radio_led_name(hw);
#else
	return NULL;
#endif
}

/**
 * ieee80211_create_tpt_led_trigger - create throughput LED trigger
 * @hw: the hardware to create the trigger for
 * @flags: trigger flags, see &enum ieee80211_tpt_led_trigger_flags
 * @blink_table: the blink table -- needs to be ordered by throughput
 * @blink_table_len: size of the blink table
 *
 * Return: %NULL (in case of error, or if no LED triggers are
 * configured) or the name of the new trigger.
 *
 * Note: This function must be called before ieee80211_register_hw().
 */
static inline char *
ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,
				 const struct ieee80211_tpt_blink *blink_table,
				 unsigned int blink_table_len)
{
#ifdef CONFIG_MAC80211_LEDS
	return __ieee80211_create_tpt_led_trigger(hw, flags, blink_table,
						  blink_table_len);
#else
	return NULL;
#endif
}

/**
 * ieee80211_unregister_hw - Unregister a hardware device
 *
 * This function instructs mac80211 to free allocated resources
 * and unregister netdevices from the networking subsystem.
 *
 * @hw: the hardware to unregister
 */
void ieee80211_unregister_hw(struct ieee80211_hw *hw);

/**
 * ieee80211_free_hw - free hardware descriptor
 *
 * This function frees everything that was allocated, including the
 * private data for the driver. You must call ieee80211_unregister_hw()
 * before calling this function.
 *
 * @hw: the hardware to free
 */
void ieee80211_free_hw(struct ieee80211_hw *hw);

/**
 * ieee80211_restart_hw - restart hardware completely
 *
 * Call this function when the hardware was restarted for some reason
 * (hardware error, ...) and the driver is unable to restore its state
 * by itself. mac80211 assumes that at this point the driver/hardware
 * is completely uninitialised and stopped, it starts the process by
 * calling the ->start() operation. The driver will need to reset all
 * internal state that it has prior to calling this function.
 *
 * @hw: the hardware to restart
 */
void ieee80211_restart_hw(struct ieee80211_hw *hw);

/**
 * ieee80211_napi_add - initialize mac80211 NAPI context
 * @hw: the hardware to initialize the NAPI context on
 * @napi: the NAPI context to initialize
 * @napi_dev: dummy NAPI netdevice, here to not waste the space if the
 *	driver doesn't use NAPI
 * @poll: poll function
 * @weight: default weight
 *
 * See also netif_napi_add().
 */
void ieee80211_napi_add(struct ieee80211_hw *hw, struct napi_struct *napi,
			struct net_device *napi_dev,
			int (*poll)(struct napi_struct *, int),
			int weight);

/**
 * ieee80211_rx - receive frame
 *
 * Use this function to hand received frames to mac80211. The receive
 * buffer in @skb must start with an IEEE 802.11 header. In case of a
 * paged @skb is used, the driver is recommended to put the ieee80211
 * header of the frame on the linear part of the @skb to avoid memory
 * allocation and/or memcpy by the stack.
 *
 * This function may not be called in IRQ context. Calls to this function
 * for a single hardware must be synchronized against each other. Calls to
 * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be
 * mixed for a single hardware. Must not run concurrently with
 * ieee80211_tx_status() or ieee80211_tx_status_ni().
 *
 * In process context use instead ieee80211_rx_ni().
 *
 * @hw: the hardware this frame came in on
 * @skb: the buffer to receive, owned by mac80211 after this call
 */
void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb);

/**
 * ieee80211_rx_irqsafe - receive frame
 *
 * Like ieee80211_rx() but can be called in IRQ context
 * (internally defers to a tasklet.)
 *
 * Calls to this function, ieee80211_rx() or ieee80211_rx_ni() may not
 * be mixed for a single hardware.Must not run concurrently with
 * ieee80211_tx_status() or ieee80211_tx_status_ni().
 *
 * @hw: the hardware this frame came in on
 * @skb: the buffer to receive, owned by mac80211 after this call
 */
void ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb);

/**
 * ieee80211_rx_ni - receive frame (in process context)
 *
 * Like ieee80211_rx() but can be called in process context
 * (internally disables bottom halves).
 *
 * Calls to this function, ieee80211_rx() and ieee80211_rx_irqsafe() may
 * not be mixed for a single hardware. Must not run concurrently with
 * ieee80211_tx_status() or ieee80211_tx_status_ni().
 *
 * @hw: the hardware this frame came in on
 * @skb: the buffer to receive, owned by mac80211 after this call
 */
static inline void ieee80211_rx_ni(struct ieee80211_hw *hw,
				   struct sk_buff *skb)
{
	local_bh_disable();
	ieee80211_rx(hw, skb);
	local_bh_enable();
}

/**
 * ieee80211_sta_ps_transition - PS transition for connected sta
 *
 * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS
 * flag set, use this function to inform mac80211 about a connected station
 * entering/leaving PS mode.
 *
 * This function may not be called in IRQ context or with softirqs enabled.
 *
 * Calls to this function for a single hardware must be synchronized against
 * each other.
 *
 * @sta: currently connected sta
 * @start: start or stop PS
 *
 * Return: 0 on success. -EINVAL when the requested PS mode is already set.
 */
int ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start);

/**
 * ieee80211_sta_ps_transition_ni - PS transition for connected sta
 *                                  (in process context)
 *
 * Like ieee80211_sta_ps_transition() but can be called in process context
 * (internally disables bottom halves). Concurrent call restriction still
 * applies.
 *
 * @sta: currently connected sta
 * @start: start or stop PS
 *
 * Return: Like ieee80211_sta_ps_transition().
 */
static inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,
						  bool start)
{
	int ret;

	local_bh_disable();
	ret = ieee80211_sta_ps_transition(sta, start);
	local_bh_enable();

	return ret;
}

/*
 * The TX headroom reserved by mac80211 for its own tx_status functions.
 * This is enough for the radiotap header.
 */
#define IEEE80211_TX_STATUS_HEADROOM	14

/**
 * ieee80211_sta_set_buffered - inform mac80211 about driver-buffered frames
 * @sta: &struct ieee80211_sta pointer for the sleeping station
 * @tid: the TID that has buffered frames
 * @buffered: indicates whether or not frames are buffered for this TID
 *
 * If a driver buffers frames for a powersave station instead of passing
 * them back to mac80211 for retransmission, the station may still need
 * to be told that there are buffered frames via the TIM bit.
 *
 * This function informs mac80211 whether or not there are frames that are
 * buffered in the driver for a given TID; mac80211 can then use this data
 * to set the TIM bit (NOTE: This may call back into the driver's set_tim
 * call! Beware of the locking!)
 *
 * If all frames are released to the station (due to PS-poll or uAPSD)
 * then the driver needs to inform mac80211 that there no longer are
 * frames buffered. However, when the station wakes up mac80211 assumes
 * that all buffered frames will be transmitted and clears this data,
 * drivers need to make sure they inform mac80211 about all buffered
 * frames on the sleep transition (sta_notify() with %STA_NOTIFY_SLEEP).
 *
 * Note that technically mac80211 only needs to know this per AC, not per
 * TID, but since driver buffering will inevitably happen per TID (since
 * it is related to aggregation) it is easier to make mac80211 map the
 * TID to the AC as required instead of keeping track in all drivers that
 * use this API.
 */
void ieee80211_sta_set_buffered(struct ieee80211_sta *sta,
				u8 tid, bool buffered);

/**
 * ieee80211_get_tx_rates - get the selected transmit rates for a packet
 *
 * Call this function in a driver with per-packet rate selection support
 * to combine the rate info in the packet tx info with the most recent
 * rate selection table for the station entry.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @sta: the receiver station to which this packet is sent.
 * @skb: the frame to be transmitted.
 * @dest: buffer for extracted rate/retry information
 * @max_rates: maximum number of rates to fetch
 */
void ieee80211_get_tx_rates(struct ieee80211_vif *vif,
			    struct ieee80211_sta *sta,
			    struct sk_buff *skb,
			    struct ieee80211_tx_rate *dest,
			    int max_rates);

/**
 * ieee80211_tx_status - transmit status callback
 *
 * Call this function for all transmitted frames after they have been
 * transmitted. It is permissible to not call this function for
 * multicast frames but this can affect statistics.
 *
 * This function may not be called in IRQ context. Calls to this function
 * for a single hardware must be synchronized against each other. Calls
 * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe()
 * may not be mixed for a single hardware. Must not run concurrently with
 * ieee80211_rx() or ieee80211_rx_ni().
 *
 * @hw: the hardware the frame was transmitted by
 * @skb: the frame that was transmitted, owned by mac80211 after this call
 */
void ieee80211_tx_status(struct ieee80211_hw *hw,
			 struct sk_buff *skb);

/**
 * ieee80211_tx_status_noskb - transmit status callback without skb
 *
 * This function can be used as a replacement for ieee80211_tx_status
 * in drivers that cannot reliably map tx status information back to
 * specific skbs.
 *
 * Calls to this function for a single hardware must be synchronized
 * against each other. Calls to this function, ieee80211_tx_status_ni()
 * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.
 *
 * @hw: the hardware the frame was transmitted by
 * @sta: the receiver station to which this packet is sent
 *	(NULL for multicast packets)
 * @info: tx status information
 */
void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,
			       struct ieee80211_sta *sta,
			       struct ieee80211_tx_info *info);

/**
 * ieee80211_tx_status_ni - transmit status callback (in process context)
 *
 * Like ieee80211_tx_status() but can be called in process context.
 *
 * Calls to this function, ieee80211_tx_status() and
 * ieee80211_tx_status_irqsafe() may not be mixed
 * for a single hardware.
 *
 * @hw: the hardware the frame was transmitted by
 * @skb: the frame that was transmitted, owned by mac80211 after this call
 */
static inline void ieee80211_tx_status_ni(struct ieee80211_hw *hw,
					  struct sk_buff *skb)
{
	local_bh_disable();
	ieee80211_tx_status(hw, skb);
	local_bh_enable();
}

/**
 * ieee80211_tx_status_irqsafe - IRQ-safe transmit status callback
 *
 * Like ieee80211_tx_status() but can be called in IRQ context
 * (internally defers to a tasklet.)
 *
 * Calls to this function, ieee80211_tx_status() and
 * ieee80211_tx_status_ni() may not be mixed for a single hardware.
 *
 * @hw: the hardware the frame was transmitted by
 * @skb: the frame that was transmitted, owned by mac80211 after this call
 */
void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,
				 struct sk_buff *skb);

/**
 * ieee80211_report_low_ack - report non-responding station
 *
 * When operating in AP-mode, call this function to report a non-responding
 * connected STA.
 *
 * @sta: the non-responding connected sta
 * @num_packets: number of packets sent to @sta without a response
 */
void ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);

#define IEEE80211_MAX_CSA_COUNTERS_NUM 2

/**
 * struct ieee80211_mutable_offsets - mutable beacon offsets
 * @tim_offset: position of TIM element
 * @tim_length: size of TIM element
 * @csa_counter_offs: array of IEEE80211_MAX_CSA_COUNTERS_NUM offsets
 *	to CSA counters.  This array can contain zero values which
 *	should be ignored.
 */
struct ieee80211_mutable_offsets {
	u16 tim_offset;
	u16 tim_length;

	u16 csa_counter_offs[IEEE80211_MAX_CSA_COUNTERS_NUM];
};

/**
 * ieee80211_beacon_get_template - beacon template generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @offs: &struct ieee80211_mutable_offsets pointer to struct that will
 *	receive the offsets that may be updated by the driver.
 *
 * If the driver implements beaconing modes, it must use this function to
 * obtain the beacon template.
 *
 * This function should be used if the beacon frames are generated by the
 * device, and then the driver must use the returned beacon as the template
 * The driver or the device are responsible to update the DTIM and, when
 * applicable, the CSA count.
 *
 * The driver is responsible for freeing the returned skb.
 *
 * Return: The beacon template. %NULL on error.
 */
struct sk_buff *
ieee80211_beacon_get_template(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif,
			      struct ieee80211_mutable_offsets *offs);

/**
 * ieee80211_beacon_get_tim - beacon generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @tim_offset: pointer to variable that will receive the TIM IE offset.
 *	Set to 0 if invalid (in non-AP modes).
 * @tim_length: pointer to variable that will receive the TIM IE length,
 *	(including the ID and length bytes!).
 *	Set to 0 if invalid (in non-AP modes).
 *
 * If the driver implements beaconing modes, it must use this function to
 * obtain the beacon frame.
 *
 * If the beacon frames are generated by the host system (i.e., not in
 * hardware/firmware), the driver uses this function to get each beacon
 * frame from mac80211 -- it is responsible for calling this function exactly
 * once before the beacon is needed (e.g. based on hardware interrupt).
 *
 * The driver is responsible for freeing the returned skb.
 *
 * Return: The beacon template. %NULL on error.
 */
struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,
					 struct ieee80211_vif *vif,
					 u16 *tim_offset, u16 *tim_length);

/**
 * ieee80211_beacon_get - beacon generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * See ieee80211_beacon_get_tim().
 *
 * Return: See ieee80211_beacon_get_tim().
 */
static inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,
						   struct ieee80211_vif *vif)
{
	return ieee80211_beacon_get_tim(hw, vif, NULL, NULL);
}

/**
 * ieee80211_csa_update_counter - request mac80211 to decrement the csa counter
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * The csa counter should be updated after each beacon transmission.
 * This function is called implicitly when
 * ieee80211_beacon_get/ieee80211_beacon_get_tim are called, however if the
 * beacon frames are generated by the device, the driver should call this
 * function after each beacon transmission to sync mac80211's csa counters.
 *
 * Return: new csa counter value
 */
u8 ieee80211_csa_update_counter(struct ieee80211_vif *vif);

/**
 * ieee80211_csa_finish - notify mac80211 about channel switch
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * After a channel switch announcement was scheduled and the counter in this
 * announcement hits 1, this function must be called by the driver to
 * notify mac80211 that the channel can be changed.
 */
void ieee80211_csa_finish(struct ieee80211_vif *vif);

/**
 * ieee80211_csa_is_complete - find out if counters reached 1
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * This function returns whether the channel switch counters reached zero.
 */
bool ieee80211_csa_is_complete(struct ieee80211_vif *vif);


/**
 * ieee80211_proberesp_get - retrieve a Probe Response template
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Creates a Probe Response template which can, for example, be uploaded to
 * hardware. The destination address should be set by the caller.
 *
 * Can only be called in AP mode.
 *
 * Return: The Probe Response template. %NULL on error.
 */
struct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,
					struct ieee80211_vif *vif);

/**
 * ieee80211_pspoll_get - retrieve a PS Poll template
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Creates a PS Poll a template which can, for example, uploaded to
 * hardware. The template must be updated after association so that correct
 * AID, BSSID and MAC address is used.
 *
 * Note: Caller (or hardware) is responsible for setting the
 * &IEEE80211_FCTL_PM bit.
 *
 * Return: The PS Poll template. %NULL on error.
 */
struct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,
				     struct ieee80211_vif *vif);

/**
 * ieee80211_nullfunc_get - retrieve a nullfunc template
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Creates a Nullfunc template which can, for example, uploaded to
 * hardware. The template must be updated after association so that correct
 * BSSID and address is used.
 *
 * Note: Caller (or hardware) is responsible for setting the
 * &IEEE80211_FCTL_PM bit as well as Duration and Sequence Control fields.
 *
 * Return: The nullfunc template. %NULL on error.
 */
struct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,
				       struct ieee80211_vif *vif);

/**
 * ieee80211_probereq_get - retrieve a Probe Request template
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @src_addr: source MAC address
 * @ssid: SSID buffer
 * @ssid_len: length of SSID
 * @tailroom: tailroom to reserve at end of SKB for IEs
 *
 * Creates a Probe Request template which can, for example, be uploaded to
 * hardware.
 *
 * Return: The Probe Request template. %NULL on error.
 */
struct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,
				       const u8 *src_addr,
				       const u8 *ssid, size_t ssid_len,
				       size_t tailroom);

/**
 * ieee80211_rts_get - RTS frame generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @frame: pointer to the frame that is going to be protected by the RTS.
 * @frame_len: the frame length (in octets).
 * @frame_txctl: &struct ieee80211_tx_info of the frame.
 * @rts: The buffer where to store the RTS frame.
 *
 * If the RTS frames are generated by the host system (i.e., not in
 * hardware/firmware), the low-level driver uses this function to receive
 * the next RTS frame from the 802.11 code. The low-level is responsible
 * for calling this function before and RTS frame is needed.
 */
void ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
		       const void *frame, size_t frame_len,
		       const struct ieee80211_tx_info *frame_txctl,
		       struct ieee80211_rts *rts);

/**
 * ieee80211_rts_duration - Get the duration field for an RTS frame
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @frame_len: the length of the frame that is going to be protected by the RTS.
 * @frame_txctl: &struct ieee80211_tx_info of the frame.
 *
 * If the RTS is generated in firmware, but the host system must provide
 * the duration field, the low-level driver uses this function to receive
 * the duration field value in little-endian byteorder.
 *
 * Return: The duration.
 */
__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif, size_t frame_len,
			      const struct ieee80211_tx_info *frame_txctl);

/**
 * ieee80211_ctstoself_get - CTS-to-self frame generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @frame: pointer to the frame that is going to be protected by the CTS-to-self.
 * @frame_len: the frame length (in octets).
 * @frame_txctl: &struct ieee80211_tx_info of the frame.
 * @cts: The buffer where to store the CTS-to-self frame.
 *
 * If the CTS-to-self frames are generated by the host system (i.e., not in
 * hardware/firmware), the low-level driver uses this function to receive
 * the next CTS-to-self frame from the 802.11 code. The low-level is responsible
 * for calling this function before and CTS-to-self frame is needed.
 */
void ieee80211_ctstoself_get(struct ieee80211_hw *hw,
			     struct ieee80211_vif *vif,
			     const void *frame, size_t frame_len,
			     const struct ieee80211_tx_info *frame_txctl,
			     struct ieee80211_cts *cts);

/**
 * ieee80211_ctstoself_duration - Get the duration field for a CTS-to-self frame
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @frame_len: the length of the frame that is going to be protected by the CTS-to-self.
 * @frame_txctl: &struct ieee80211_tx_info of the frame.
 *
 * If the CTS-to-self is generated in firmware, but the host system must provide
 * the duration field, the low-level driver uses this function to receive
 * the duration field value in little-endian byteorder.
 *
 * Return: The duration.
 */
__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,
				    struct ieee80211_vif *vif,
				    size_t frame_len,
				    const struct ieee80211_tx_info *frame_txctl);

/**
 * ieee80211_generic_frame_duration - Calculate the duration field for a frame
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @band: the band to calculate the frame duration on
 * @frame_len: the length of the frame.
 * @rate: the rate at which the frame is going to be transmitted.
 *
 * Calculate the duration field of some generic frame, given its
 * length and transmission rate (in 100kbps).
 *
 * Return: The duration.
 */
__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,
					struct ieee80211_vif *vif,
					enum ieee80211_band band,
					size_t frame_len,
					struct ieee80211_rate *rate);

/**
 * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Function for accessing buffered broadcast and multicast frames. If
 * hardware/firmware does not implement buffering of broadcast/multicast
 * frames when power saving is used, 802.11 code buffers them in the host
 * memory. The low-level driver uses this function to fetch next buffered
 * frame. In most cases, this is used when generating beacon frame.
 *
 * Return: A pointer to the next buffered skb or NULL if no more buffered
 * frames are available.
 *
 * Note: buffered frames are returned only after DTIM beacon frame was
 * generated with ieee80211_beacon_get() and the low-level driver must thus
 * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc() returns
 * NULL if the previous generated beacon was not DTIM, so the low-level driver
 * does not need to check for DTIM beacons separately and should be able to
 * use common code for all beacons.
 */
struct sk_buff *
ieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);

/**
 * ieee80211_get_tkip_p1k_iv - get a TKIP phase 1 key for IV32
 *
 * This function returns the TKIP phase 1 key for the given IV32.
 *
 * @keyconf: the parameter passed with the set key
 * @iv32: IV32 to get the P1K for
 * @p1k: a buffer to which the key will be written, as 5 u16 values
 */
void ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,
			       u32 iv32, u16 *p1k);

/**
 * ieee80211_get_tkip_p1k - get a TKIP phase 1 key
 *
 * This function returns the TKIP phase 1 key for the IV32 taken
 * from the given packet.
 *
 * @keyconf: the parameter passed with the set key
 * @skb: the packet to take the IV32 value from that will be encrypted
 *	with this P1K
 * @p1k: a buffer to which the key will be written, as 5 u16 values
 */
static inline void ieee80211_get_tkip_p1k(struct ieee80211_key_conf *keyconf,
					  struct sk_buff *skb, u16 *p1k)
{
	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
	const u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);
	u32 iv32 = get_unaligned_le32(&data[4]);

	ieee80211_get_tkip_p1k_iv(keyconf, iv32, p1k);
}

/**
 * ieee80211_get_tkip_rx_p1k - get a TKIP phase 1 key for RX
 *
 * This function returns the TKIP phase 1 key for the given IV32
 * and transmitter address.
 *
 * @keyconf: the parameter passed with the set key
 * @ta: TA that will be used with the key
 * @iv32: IV32 to get the P1K for
 * @p1k: a buffer to which the key will be written, as 5 u16 values
 */
void ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,
			       const u8 *ta, u32 iv32, u16 *p1k);

/**
 * ieee80211_get_tkip_p2k - get a TKIP phase 2 key
 *
 * This function computes the TKIP RC4 key for the IV values
 * in the packet.
 *
 * @keyconf: the parameter passed with the set key
 * @skb: the packet to take the IV32/IV16 values from that will be
 *	encrypted with this key
 * @p2k: a buffer to which the key will be written, 16 bytes
 */
void ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,
			    struct sk_buff *skb, u8 *p2k);

/**
 * ieee80211_aes_cmac_calculate_k1_k2 - calculate the AES-CMAC sub keys
 *
 * This function computes the two AES-CMAC sub-keys, based on the
 * previously installed master key.
 *
 * @keyconf: the parameter passed with the set key
 * @k1: a buffer to be filled with the 1st sub-key
 * @k2: a buffer to be filled with the 2nd sub-key
 */
void ieee80211_aes_cmac_calculate_k1_k2(struct ieee80211_key_conf *keyconf,
					u8 *k1, u8 *k2);

/**
 * struct ieee80211_key_seq - key sequence counter
 *
 * @tkip: TKIP data, containing IV32 and IV16 in host byte order
 * @ccmp: PN data, most significant byte first (big endian,
 *	reverse order than in packet)
 * @aes_cmac: PN data, most significant byte first (big endian,
 *	reverse order than in packet)
 * @aes_gmac: PN data, most significant byte first (big endian,
 *	reverse order than in packet)
 * @gcmp: PN data, most significant byte first (big endian,
 *	reverse order than in packet)
 */
struct ieee80211_key_seq {
	union {
		struct {
			u32 iv32;
			u16 iv16;
		} tkip;
		struct {
			u8 pn[6];
		} ccmp;
		struct {
			u8 pn[6];
		} aes_cmac;
		struct {
			u8 pn[6];
		} aes_gmac;
		struct {
			u8 pn[6];
		} gcmp;
	};
};

/**
 * ieee80211_get_key_tx_seq - get key TX sequence counter
 *
 * @keyconf: the parameter passed with the set key
 * @seq: buffer to receive the sequence data
 *
 * This function allows a driver to retrieve the current TX IV/PN
 * for the given key. It must not be called if IV generation is
 * offloaded to the device.
 *
 * Note that this function may only be called when no TX processing
 * can be done concurrently, for example when queues are stopped
 * and the stop has been synchronized.
 */
void ieee80211_get_key_tx_seq(struct ieee80211_key_conf *keyconf,
			      struct ieee80211_key_seq *seq);

/**
 * ieee80211_get_key_rx_seq - get key RX sequence counter
 *
 * @keyconf: the parameter passed with the set key
 * @tid: The TID, or -1 for the management frame value (CCMP/GCMP only);
 *	the value on TID 0 is also used for non-QoS frames. For
 *	CMAC, only TID 0 is valid.
 * @seq: buffer to receive the sequence data
 *
 * This function allows a driver to retrieve the current RX IV/PNs
 * for the given key. It must not be called if IV checking is done
 * by the device and not by mac80211.
 *
 * Note that this function may only be called when no RX processing
 * can be done concurrently.
 */
void ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,
			      int tid, struct ieee80211_key_seq *seq);

/**
 * ieee80211_set_key_tx_seq - set key TX sequence counter
 *
 * @keyconf: the parameter passed with the set key
 * @seq: new sequence data
 *
 * This function allows a driver to set the current TX IV/PNs for the
 * given key. This is useful when resuming from WoWLAN sleep and the
 * device may have transmitted frames using the PTK, e.g. replies to
 * ARP requests.
 *
 * Note that this function may only be called when no TX processing
 * can be done concurrently.
 */
void ieee80211_set_key_tx_seq(struct ieee80211_key_conf *keyconf,
			      struct ieee80211_key_seq *seq);

/**
 * ieee80211_set_key_rx_seq - set key RX sequence counter
 *
 * @keyconf: the parameter passed with the set key
 * @tid: The TID, or -1 for the management frame value (CCMP/GCMP only);
 *	the value on TID 0 is also used for non-QoS frames. For
 *	CMAC, only TID 0 is valid.
 * @seq: new sequence data
 *
 * This function allows a driver to set the current RX IV/PNs for the
 * given key. This is useful when resuming from WoWLAN sleep and GTK
 * rekey may have been done while suspended. It should not be called
 * if IV checking is done by the device and not by mac80211.
 *
 * Note that this function may only be called when no RX processing
 * can be done concurrently.
 */
void ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,
			      int tid, struct ieee80211_key_seq *seq);

/**
 * ieee80211_remove_key - remove the given key
 * @keyconf: the parameter passed with the set key
 *
 * Remove the given key. If the key was uploaded to the hardware at the
 * time this function is called, it is not deleted in the hardware but
 * instead assumed to have been removed already.
 *
 * Note that due to locking considerations this function can (currently)
 * only be called during key iteration (ieee80211_iter_keys().)
 */
void ieee80211_remove_key(struct ieee80211_key_conf *keyconf);

/**
 * ieee80211_gtk_rekey_add - add a GTK key from rekeying during WoWLAN
 * @vif: the virtual interface to add the key on
 * @keyconf: new key data
 *
 * When GTK rekeying was done while the system was suspended, (a) new
 * key(s) will be available. These will be needed by mac80211 for proper
 * RX processing, so this function allows setting them.
 *
 * The function returns the newly allocated key structure, which will
 * have similar contents to the passed key configuration but point to
 * mac80211-owned memory. In case of errors, the function returns an
 * ERR_PTR(), use IS_ERR() etc.
 *
 * Note that this function assumes the key isn't added to hardware
 * acceleration, so no TX will be done with the key. Since it's a GTK
 * on managed (station) networks, this is true anyway. If the driver
 * calls this function from the resume callback and subsequently uses
 * the return code 1 to reconfigure the device, this key will be part
 * of the reconfiguration.
 *
 * Note that the driver should also call ieee80211_set_key_rx_seq()
 * for the new key for each TID to set up sequence counters properly.
 *
 * IMPORTANT: If this replaces a key that is present in the hardware,
 * then it will attempt to remove it during this call. In many cases
 * this isn't what you want, so call ieee80211_remove_key() first for
 * the key that's being replaced.
 */
struct ieee80211_key_conf *
ieee80211_gtk_rekey_add(struct ieee80211_vif *vif,
			struct ieee80211_key_conf *keyconf);

/**
 * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying
 * @vif: virtual interface the rekeying was done on
 * @bssid: The BSSID of the AP, for checking association
 * @replay_ctr: the new replay counter after GTK rekeying
 * @gfp: allocation flags
 */
void ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,
				const u8 *replay_ctr, gfp_t gfp);

/**
 * ieee80211_wake_queue - wake specific queue
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 * @queue: queue number (counted from zero).
 *
 * Drivers should use this function instead of netif_wake_queue.
 */
void ieee80211_wake_queue(struct ieee80211_hw *hw, int queue);

/**
 * ieee80211_stop_queue - stop specific queue
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 * @queue: queue number (counted from zero).
 *
 * Drivers should use this function instead of netif_stop_queue.
 */
void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);

/**
 * ieee80211_queue_stopped - test status of the queue
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 * @queue: queue number (counted from zero).
 *
 * Drivers should use this function instead of netif_stop_queue.
 *
 * Return: %true if the queue is stopped. %false otherwise.
 */

int ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);

/**
 * ieee80211_stop_queues - stop all queues
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 *
 * Drivers should use this function instead of netif_stop_queue.
 */
void ieee80211_stop_queues(struct ieee80211_hw *hw);

/**
 * ieee80211_wake_queues - wake all queues
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 *
 * Drivers should use this function instead of netif_wake_queue.
 */
void ieee80211_wake_queues(struct ieee80211_hw *hw);

/**
 * ieee80211_scan_completed - completed hardware scan
 *
 * When hardware scan offload is used (i.e. the hw_scan() callback is
 * assigned) this function needs to be called by the driver to notify
 * mac80211 that the scan finished. This function can be called from
 * any context, including hardirq context.
 *
 * @hw: the hardware that finished the scan
 * @aborted: set to true if scan was aborted
 */
void ieee80211_scan_completed(struct ieee80211_hw *hw, bool aborted);

/**
 * ieee80211_sched_scan_results - got results from scheduled scan
 *
 * When a scheduled scan is running, this function needs to be called by the
 * driver whenever there are new scan results available.
 *
 * @hw: the hardware that is performing scheduled scans
 */
void ieee80211_sched_scan_results(struct ieee80211_hw *hw);

/**
 * ieee80211_sched_scan_stopped - inform that the scheduled scan has stopped
 *
 * When a scheduled scan is running, this function can be called by
 * the driver if it needs to stop the scan to perform another task.
 * Usual scenarios are drivers that cannot continue the scheduled scan
 * while associating, for instance.
 *
 * @hw: the hardware that is performing scheduled scans
 */
void ieee80211_sched_scan_stopped(struct ieee80211_hw *hw);

/**
 * enum ieee80211_interface_iteration_flags - interface iteration flags
 * @IEEE80211_IFACE_ITER_NORMAL: Iterate over all interfaces that have
 *	been added to the driver; However, note that during hardware
 *	reconfiguration (after restart_hw) it will iterate over a new
 *	interface and over all the existing interfaces even if they
 *	haven't been re-added to the driver yet.
 * @IEEE80211_IFACE_ITER_RESUME_ALL: During resume, iterate over all
 *	interfaces, even if they haven't been re-added to the driver yet.
 * @IEEE80211_IFACE_ITER_ACTIVE: Iterate only active interfaces (netdev is up).
 */
enum ieee80211_interface_iteration_flags {
	IEEE80211_IFACE_ITER_NORMAL	= 0,
	IEEE80211_IFACE_ITER_RESUME_ALL	= BIT(0),
	IEEE80211_IFACE_ITER_ACTIVE	= BIT(1),
};

/**
 * ieee80211_iterate_interfaces - iterate interfaces
 *
 * This function iterates over the interfaces associated with a given
 * hardware and calls the callback for them. This includes active as well as
 * inactive interfaces. This function allows the iterator function to sleep.
 * Will iterate over a new interface during add_interface().
 *
 * @hw: the hardware struct of which the interfaces should be iterated over
 * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags
 * @iterator: the iterator function to call
 * @data: first argument of the iterator function
 */
void ieee80211_iterate_interfaces(struct ieee80211_hw *hw, u32 iter_flags,
				  void (*iterator)(void *data, u8 *mac,
						   struct ieee80211_vif *vif),
				  void *data);

/**
 * ieee80211_iterate_active_interfaces - iterate active interfaces
 *
 * This function iterates over the interfaces associated with a given
 * hardware that are currently active and calls the callback for them.
 * This function allows the iterator function to sleep, when the iterator
 * function is atomic @ieee80211_iterate_active_interfaces_atomic can
 * be used.
 * Does not iterate over a new interface during add_interface().
 *
 * @hw: the hardware struct of which the interfaces should be iterated over
 * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags
 * @iterator: the iterator function to call
 * @data: first argument of the iterator function
 */
static inline void
ieee80211_iterate_active_interfaces(struct ieee80211_hw *hw, u32 iter_flags,
				    void (*iterator)(void *data, u8 *mac,
						     struct ieee80211_vif *vif),
				    void *data)
{
	ieee80211_iterate_interfaces(hw,
				     iter_flags | IEEE80211_IFACE_ITER_ACTIVE,
				     iterator, data);
}

/**
 * ieee80211_iterate_active_interfaces_atomic - iterate active interfaces
 *
 * This function iterates over the interfaces associated with a given
 * hardware that are currently active and calls the callback for them.
 * This function requires the iterator callback function to be atomic,
 * if that is not desired, use @ieee80211_iterate_active_interfaces instead.
 * Does not iterate over a new interface during add_interface().
 *
 * @hw: the hardware struct of which the interfaces should be iterated over
 * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags
 * @iterator: the iterator function to call, cannot sleep
 * @data: first argument of the iterator function
 */
void ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,
						u32 iter_flags,
						void (*iterator)(void *data,
						    u8 *mac,
						    struct ieee80211_vif *vif),
						void *data);

/**
 * ieee80211_iterate_active_interfaces_rtnl - iterate active interfaces
 *
 * This function iterates over the interfaces associated with a given
 * hardware that are currently active and calls the callback for them.
 * This version can only be used while holding the RTNL.
 *
 * @hw: the hardware struct of which the interfaces should be iterated over
 * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags
 * @iterator: the iterator function to call, cannot sleep
 * @data: first argument of the iterator function
 */
void ieee80211_iterate_active_interfaces_rtnl(struct ieee80211_hw *hw,
					      u32 iter_flags,
					      void (*iterator)(void *data,
						u8 *mac,
						struct ieee80211_vif *vif),
					      void *data);

/**
 * ieee80211_iterate_stations_atomic - iterate stations
 *
 * This function iterates over all stations associated with a given
 * hardware that are currently uploaded to the driver and calls the callback
 * function for them.
 * This function requires the iterator callback function to be atomic,
 *
 * @hw: the hardware struct of which the interfaces should be iterated over
 * @iterator: the iterator function to call, cannot sleep
 * @data: first argument of the iterator function
 */
void ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,
				       void (*iterator)(void *data,
						struct ieee80211_sta *sta),
				       void *data);
/**
 * ieee80211_queue_work - add work onto the mac80211 workqueue
 *
 * Drivers and mac80211 use this to add work onto the mac80211 workqueue.
 * This helper ensures drivers are not queueing work when they should not be.
 *
 * @hw: the hardware struct for the interface we are adding work for
 * @work: the work we want to add onto the mac80211 workqueue
 */
void ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);

/**
 * ieee80211_queue_delayed_work - add work onto the mac80211 workqueue
 *
 * Drivers and mac80211 use this to queue delayed work onto the mac80211
 * workqueue.
 *
 * @hw: the hardware struct for the interface we are adding work for
 * @dwork: delayable work to queue onto the mac80211 workqueue
 * @delay: number of jiffies to wait before queueing
 */
void ieee80211_queue_delayed_work(struct ieee80211_hw *hw,
				  struct delayed_work *dwork,
				  unsigned long delay);

/**
 * ieee80211_start_tx_ba_session - Start a tx Block Ack session.
 * @sta: the station for which to start a BA session
 * @tid: the TID to BA on.
 * @timeout: session timeout value (in TUs)
 *
 * Return: success if addBA request was sent, failure otherwise
 *
 * Although mac80211/low level driver/user space application can estimate
 * the need to start aggregation on a certain RA/TID, the session level
 * will be managed by the mac80211.
 */
int ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,
				  u16 timeout);

/**
 * ieee80211_start_tx_ba_cb_irqsafe - low level driver ready to aggregate.
 * @vif: &struct ieee80211_vif pointer from the add_interface callback
 * @ra: receiver address of the BA session recipient.
 * @tid: the TID to BA on.
 *
 * This function must be called by low level driver once it has
 * finished with preparations for the BA session. It can be called
 * from any context.
 */
void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
				      u16 tid);

/**
 * ieee80211_stop_tx_ba_session - Stop a Block Ack session.
 * @sta: the station whose BA session to stop
 * @tid: the TID to stop BA.
 *
 * Return: negative error if the TID is invalid, or no aggregation active
 *
 * Although mac80211/low level driver/user space application can estimate
 * the need to stop aggregation on a certain RA/TID, the session level
 * will be managed by the mac80211.
 */
int ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);

/**
 * ieee80211_stop_tx_ba_cb_irqsafe - low level driver ready to stop aggregate.
 * @vif: &struct ieee80211_vif pointer from the add_interface callback
 * @ra: receiver address of the BA session recipient.
 * @tid: the desired TID to BA on.
 *
 * This function must be called by low level driver once it has
 * finished with preparations for the BA session tear down. It
 * can be called from any context.
 */
void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
				     u16 tid);

/**
 * ieee80211_find_sta - find a station
 *
 * @vif: virtual interface to look for station on
 * @addr: station's address
 *
 * Return: The station, if found. %NULL otherwise.
 *
 * Note: This function must be called under RCU lock and the
 * resulting pointer is only valid under RCU lock as well.
 */
struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,
					 const u8 *addr);

/**
 * ieee80211_find_sta_by_ifaddr - find a station on hardware
 *
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 * @addr: remote station's address
 * @localaddr: local address (vif->sdata->vif.addr). Use NULL for 'any'.
 *
 * Return: The station, if found. %NULL otherwise.
 *
 * Note: This function must be called under RCU lock and the
 * resulting pointer is only valid under RCU lock as well.
 *
 * NOTE: You may pass NULL for localaddr, but then you will just get
 *      the first STA that matches the remote address 'addr'.
 *      We can have multiple STA associated with multiple
 *      logical stations (e.g. consider a station connecting to another
 *      BSSID on the same AP hardware without disconnecting first).
 *      In this case, the result of this method with localaddr NULL
 *      is not reliable.
 *
 * DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.
 */
struct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,
					       const u8 *addr,
					       const u8 *localaddr);

/**
 * ieee80211_sta_block_awake - block station from waking up
 * @hw: the hardware
 * @pubsta: the station
 * @block: whether to block or unblock
 *
 * Some devices require that all frames that are on the queues
 * for a specific station that went to sleep are flushed before
 * a poll response or frames after the station woke up can be
 * delivered to that it. Note that such frames must be rejected
 * by the driver as filtered, with the appropriate status flag.
 *
 * This function allows implementing this mode in a race-free
 * manner.
 *
 * To do this, a driver must keep track of the number of frames
 * still enqueued for a specific station. If this number is not
 * zero when the station goes to sleep, the driver must call
 * this function to force mac80211 to consider the station to
 * be asleep regardless of the station's actual state. Once the
 * number of outstanding frames reaches zero, the driver must
 * call this function again to unblock the station. That will
 * cause mac80211 to be able to send ps-poll responses, and if
 * the station queried in the meantime then frames will also
 * be sent out as a result of this. Additionally, the driver
 * will be notified that the station woke up some time after
 * it is unblocked, regardless of whether the station actually
 * woke up while blocked or not.
 */
void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
			       struct ieee80211_sta *pubsta, bool block);

/**
 * ieee80211_sta_eosp - notify mac80211 about end of SP
 * @pubsta: the station
 *
 * When a device transmits frames in a way that it can't tell
 * mac80211 in the TX status about the EOSP, it must clear the
 * %IEEE80211_TX_STATUS_EOSP bit and call this function instead.
 * This applies for PS-Poll as well as uAPSD.
 *
 * Note that just like with _tx_status() and _rx() drivers must
 * not mix calls to irqsafe/non-irqsafe versions, this function
 * must not be mixed with those either. Use the all irqsafe, or
 * all non-irqsafe, don't mix!
 *
 * NB: the _irqsafe version of this function doesn't exist, no
 *     driver needs it right now. Don't call this function if
 *     you'd need the _irqsafe version, look at the git history
 *     and restore the _irqsafe version!
 */
void ieee80211_sta_eosp(struct ieee80211_sta *pubsta);

/**
 * ieee80211_iter_keys - iterate keys programmed into the device
 * @hw: pointer obtained from ieee80211_alloc_hw()
 * @vif: virtual interface to iterate, may be %NULL for all
 * @iter: iterator function that will be called for each key
 * @iter_data: custom data to pass to the iterator function
 *
 * This function can be used to iterate all the keys known to
 * mac80211, even those that weren't previously programmed into
 * the device. This is intended for use in WoWLAN if the device
 * needs reprogramming of the keys during suspend. Note that due
 * to locking reasons, it is also only safe to call this at few
 * spots since it must hold the RTNL and be able to sleep.
 *
 * The order in which the keys are iterated matches the order
 * in which they were originally installed and handed to the
 * set_key callback.
 */
void ieee80211_iter_keys(struct ieee80211_hw *hw,
			 struct ieee80211_vif *vif,
			 void (*iter)(struct ieee80211_hw *hw,
				      struct ieee80211_vif *vif,
				      struct ieee80211_sta *sta,
				      struct ieee80211_key_conf *key,
				      void *data),
			 void *iter_data);

/**
 * ieee80211_iter_chan_contexts_atomic - iterate channel contexts
 * @hw: pointre obtained from ieee80211_alloc_hw().
 * @iter: iterator function
 * @iter_data: data passed to iterator function
 *
 * Iterate all active channel contexts. This function is atomic and
 * doesn't acquire any locks internally that might be held in other
 * places while calling into the driver.
 *
 * The iterator will not find a context that's being added (during
 * the driver callback to add it) but will find it while it's being
 * removed.
 *
 * Note that during hardware restart, all contexts that existed
 * before the restart are considered already present so will be
 * found while iterating, whether they've been re-added already
 * or not.
 */
void ieee80211_iter_chan_contexts_atomic(
	struct ieee80211_hw *hw,
	void (*iter)(struct ieee80211_hw *hw,
		     struct ieee80211_chanctx_conf *chanctx_conf,
		     void *data),
	void *iter_data);

/**
 * ieee80211_ap_probereq_get - retrieve a Probe Request template
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Creates a Probe Request template which can, for example, be uploaded to
 * hardware. The template is filled with bssid, ssid and supported rate
 * information. This function must only be called from within the
 * .bss_info_changed callback function and only in managed mode. The function
 * is only useful when the interface is associated, otherwise it will return
 * %NULL.
 *
 * Return: The Probe Request template. %NULL on error.
 */
struct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,
					  struct ieee80211_vif *vif);

/**
 * ieee80211_beacon_loss - inform hardware does not receive beacons
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER and
 * %IEEE80211_CONF_PS is set, the driver needs to inform whenever the
 * hardware is not receiving beacons with this function.
 */
void ieee80211_beacon_loss(struct ieee80211_vif *vif);

/**
 * ieee80211_connection_loss - inform hardware has lost connection to the AP
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER, and
 * %IEEE80211_CONF_PS and %IEEE80211_HW_CONNECTION_MONITOR are set, the driver
 * needs to inform if the connection to the AP has been lost.
 * The function may also be called if the connection needs to be terminated
 * for some other reason, even if %IEEE80211_HW_CONNECTION_MONITOR isn't set.
 *
 * This function will cause immediate change to disassociated state,
 * without connection recovery attempts.
 */
void ieee80211_connection_loss(struct ieee80211_vif *vif);

/**
 * ieee80211_resume_disconnect - disconnect from AP after resume
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 *
 * Instructs mac80211 to disconnect from the AP after resume.
 * Drivers can use this after WoWLAN if they know that the
 * connection cannot be kept up, for example because keys were
 * used while the device was asleep but the replay counters or
 * similar cannot be retrieved from the device during resume.
 *
 * Note that due to implementation issues, if the driver uses
 * the reconfiguration functionality during resume the interface
 * will still be added as associated first during resume and then
 * disconnect normally later.
 *
 * This function can only be called from the resume callback and
 * the driver must not be holding any of its own locks while it
 * calls this function, or at least not any locks it needs in the
 * key configuration paths (if it supports HW crypto).
 */
void ieee80211_resume_disconnect(struct ieee80211_vif *vif);

/**
 * ieee80211_cqm_rssi_notify - inform a configured connection quality monitoring
 *	rssi threshold triggered
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @rssi_event: the RSSI trigger event type
 * @gfp: context flags
 *
 * When the %IEEE80211_VIF_SUPPORTS_CQM_RSSI is set, and a connection quality
 * monitoring is configured with an rssi threshold, the driver will inform
 * whenever the rssi level reaches the threshold.
 */
void ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,
			       enum nl80211_cqm_rssi_threshold_event rssi_event,
			       gfp_t gfp);

/**
 * ieee80211_cqm_beacon_loss_notify - inform CQM of beacon loss
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @gfp: context flags
 */
void ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp);

/**
 * ieee80211_radar_detected - inform that a radar was detected
 *
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 */
void ieee80211_radar_detected(struct ieee80211_hw *hw);

/**
 * ieee80211_chswitch_done - Complete channel switch process
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @success: make the channel switch successful or not
 *
 * Complete the channel switch post-process: set the new operational channel
 * and wake up the suspended queues.
 */
void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success);

/**
 * ieee80211_request_smps - request SM PS transition
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @smps_mode: new SM PS mode
 *
 * This allows the driver to request an SM PS transition in managed
 * mode. This is useful when the driver has more information than
 * the stack about possible interference, for example by bluetooth.
 */
void ieee80211_request_smps(struct ieee80211_vif *vif,
			    enum ieee80211_smps_mode smps_mode);

/**
 * ieee80211_ready_on_channel - notification of remain-on-channel start
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 */
void ieee80211_ready_on_channel(struct ieee80211_hw *hw);

/**
 * ieee80211_remain_on_channel_expired - remain_on_channel duration expired
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 */
void ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw);

/**
 * ieee80211_stop_rx_ba_session - callback to stop existing BA sessions
 *
 * in order not to harm the system performance and user experience, the device
 * may request not to allow any rx ba session and tear down existing rx ba
 * sessions based on system constraints such as periodic BT activity that needs
 * to limit wlan activity (eg.sco or a2dp)."
 * in such cases, the intention is to limit the duration of the rx ppdu and
 * therefore prevent the peer device to use a-mpdu aggregation.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @ba_rx_bitmap: Bit map of open rx ba per tid
 * @addr: & to bssid mac address
 */
void ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
				  const u8 *addr);

/**
 * ieee80211_send_bar - send a BlockAckReq frame
 *
 * can be used to flush pending frames from the peer's aggregation reorder
 * buffer.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback.
 * @ra: the peer's destination address
 * @tid: the TID of the aggregation session
 * @ssn: the new starting sequence number for the receiver
 */
void ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);

/**
 * ieee80211_start_rx_ba_session_offl - start a Rx BA session
 *
 * Some device drivers may offload part of the Rx aggregation flow including
 * AddBa/DelBa negotiation but may otherwise be incapable of full Rx
 * reordering.
 *
 * Create structures responsible for reordering so device drivers may call here
 * when they complete AddBa negotiation.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback
 * @addr: station mac address
 * @tid: the rx tid
 */
void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,
					const u8 *addr, u16 tid);

/**
 * ieee80211_stop_rx_ba_session_offl - stop a Rx BA session
 *
 * Some device drivers may offload part of the Rx aggregation flow including
 * AddBa/DelBa negotiation but may otherwise be incapable of full Rx
 * reordering.
 *
 * Destroy structures responsible for reordering so device drivers may call here
 * when they complete DelBa negotiation.
 *
 * @vif: &struct ieee80211_vif pointer from the add_interface callback
 * @addr: station mac address
 * @tid: the rx tid
 */
void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,
				       const u8 *addr, u16 tid);

/* Rate control API */

/**
 * struct ieee80211_tx_rate_control - rate control information for/from RC algo
 *
 * @hw: The hardware the algorithm is invoked for.
 * @sband: The band this frame is being transmitted on.
 * @bss_conf: the current BSS configuration
 * @skb: the skb that will be transmitted, the control information in it needs
 *	to be filled in
 * @reported_rate: The rate control algorithm can fill this in to indicate
 *	which rate should be reported to userspace as the current rate and
 *	used for rate calculations in the mesh network.
 * @rts: whether RTS will be used for this frame because it is longer than the
 *	RTS threshold
 * @short_preamble: whether mac80211 will request short-preamble transmission
 *	if the selected rate supports it
 * @max_rate_idx: user-requested maximum (legacy) rate
 *	(deprecated; this will be removed once drivers get updated to use
 *	rate_idx_mask)
 * @rate_idx_mask: user-requested (legacy) rate mask
 * @rate_idx_mcs_mask: user-requested MCS rate mask (NULL if not in use)
 * @bss: whether this frame is sent out in AP or IBSS mode
 */
struct ieee80211_tx_rate_control {
	struct ieee80211_hw *hw;
	struct ieee80211_supported_band *sband;
	struct ieee80211_bss_conf *bss_conf;
	struct sk_buff *skb;
	struct ieee80211_tx_rate reported_rate;
	bool rts, short_preamble;
	u8 max_rate_idx;
	u32 rate_idx_mask;
	u8 *rate_idx_mcs_mask;
	bool bss;
};

struct rate_control_ops {
	const char *name;
	void *(*alloc)(struct ieee80211_hw *hw, struct dentry *debugfsdir);
	void (*free)(void *priv);

	void *(*alloc_sta)(void *priv, struct ieee80211_sta *sta, gfp_t gfp);
	void (*rate_init)(void *priv, struct ieee80211_supported_band *sband,
			  struct cfg80211_chan_def *chandef,
			  struct ieee80211_sta *sta, void *priv_sta);
	void (*rate_update)(void *priv, struct ieee80211_supported_band *sband,
			    struct cfg80211_chan_def *chandef,
			    struct ieee80211_sta *sta, void *priv_sta,
			    u32 changed);
	void (*free_sta)(void *priv, struct ieee80211_sta *sta,
			 void *priv_sta);

	void (*tx_status_noskb)(void *priv,
				struct ieee80211_supported_band *sband,
				struct ieee80211_sta *sta, void *priv_sta,
				struct ieee80211_tx_info *info);
	void (*tx_status)(void *priv, struct ieee80211_supported_band *sband,
			  struct ieee80211_sta *sta, void *priv_sta,
			  struct sk_buff *skb);
	void (*get_rate)(void *priv, struct ieee80211_sta *sta, void *priv_sta,
			 struct ieee80211_tx_rate_control *txrc);

	void (*add_sta_debugfs)(void *priv, void *priv_sta,
				struct dentry *dir);
	void (*remove_sta_debugfs)(void *priv, void *priv_sta);

	u32 (*get_expected_throughput)(void *priv_sta);
};

static inline int rate_supported(struct ieee80211_sta *sta,
				 enum ieee80211_band band,
				 int index)
{
	return (sta == NULL || sta->supp_rates[band] & BIT(index));
}

/**
 * rate_control_send_low - helper for drivers for management/no-ack frames
 *
 * Rate control algorithms that agree to use the lowest rate to
 * send management frames and NO_ACK data with the respective hw
 * retries should use this in the beginning of their mac80211 get_rate
 * callback. If true is returned the rate control can simply return.
 * If false is returned we guarantee that sta and sta and priv_sta is
 * not null.
 *
 * Rate control algorithms wishing to do more intelligent selection of
 * rate for multicast/broadcast frames may choose to not use this.
 *
 * @sta: &struct ieee80211_sta pointer to the target destination. Note
 * 	that this may be null.
 * @priv_sta: private rate control structure. This may be null.
 * @txrc: rate control information we sholud populate for mac80211.
 */
bool rate_control_send_low(struct ieee80211_sta *sta,
			   void *priv_sta,
			   struct ieee80211_tx_rate_control *txrc);


static inline s8
rate_lowest_index(struct ieee80211_supported_band *sband,
		  struct ieee80211_sta *sta)
{
	int i;

	for (i = 0; i < sband->n_bitrates; i++)
		if (rate_supported(sta, sband->band, i))
			return i;

	/* warn when we cannot find a rate. */
	WARN_ON_ONCE(1);

	/* and return 0 (the lowest index) */
	return 0;
}

static inline
bool rate_usable_index_exists(struct ieee80211_supported_band *sband,
			      struct ieee80211_sta *sta)
{
	unsigned int i;

	for (i = 0; i < sband->n_bitrates; i++)
		if (rate_supported(sta, sband->band, i))
			return true;
	return false;
}

/**
 * rate_control_set_rates - pass the sta rate selection to mac80211/driver
 *
 * When not doing a rate control probe to test rates, rate control should pass
 * its rate selection to mac80211. If the driver supports receiving a station
 * rate table, it will use it to ensure that frames are always sent based on
 * the most recent rate control module decision.
 *
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 * @pubsta: &struct ieee80211_sta pointer to the target destination.
 * @rates: new tx rate set to be used for this station.
 */
int rate_control_set_rates(struct ieee80211_hw *hw,
			   struct ieee80211_sta *pubsta,
			   struct ieee80211_sta_rates *rates);

int ieee80211_rate_control_register(const struct rate_control_ops *ops);
void ieee80211_rate_control_unregister(const struct rate_control_ops *ops);

static inline bool
conf_is_ht20(struct ieee80211_conf *conf)
{
	return conf->chandef.width == NL80211_CHAN_WIDTH_20;
}

static inline bool
conf_is_ht40_minus(struct ieee80211_conf *conf)
{
	return conf->chandef.width == NL80211_CHAN_WIDTH_40 &&
	       conf->chandef.center_freq1 < conf->chandef.chan->center_freq;
}

static inline bool
conf_is_ht40_plus(struct ieee80211_conf *conf)
{
	return conf->chandef.width == NL80211_CHAN_WIDTH_40 &&
	       conf->chandef.center_freq1 > conf->chandef.chan->center_freq;
}

static inline bool
conf_is_ht40(struct ieee80211_conf *conf)
{
	return conf->chandef.width == NL80211_CHAN_WIDTH_40;
}

static inline bool
conf_is_ht(struct ieee80211_conf *conf)
{
	return (conf->chandef.width != NL80211_CHAN_WIDTH_5) &&
		(conf->chandef.width != NL80211_CHAN_WIDTH_10) &&
		(conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT);
}

static inline enum nl80211_iftype
ieee80211_iftype_p2p(enum nl80211_iftype type, bool p2p)
{
	if (p2p) {
		switch (type) {
		case NL80211_IFTYPE_STATION:
			return NL80211_IFTYPE_P2P_CLIENT;
		case NL80211_IFTYPE_AP:
			return NL80211_IFTYPE_P2P_GO;
		default:
			break;
		}
	}
	return type;
}

static inline enum nl80211_iftype
ieee80211_vif_type_p2p(struct ieee80211_vif *vif)
{
	return ieee80211_iftype_p2p(vif->type, vif->p2p);
}

void ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,
				   int rssi_min_thold,
				   int rssi_max_thold);

void ieee80211_disable_rssi_reports(struct ieee80211_vif *vif);

/**
 * ieee80211_ave_rssi - report the average RSSI for the specified interface
 *
 * @vif: the specified virtual interface
 *
 * Note: This function assumes that the given vif is valid.
 *
 * Return: The average RSSI value for the requested interface, or 0 if not
 * applicable.
 */
int ieee80211_ave_rssi(struct ieee80211_vif *vif);

/**
 * ieee80211_report_wowlan_wakeup - report WoWLAN wakeup
 * @vif: virtual interface
 * @wakeup: wakeup reason(s)
 * @gfp: allocation flags
 *
 * See cfg80211_report_wowlan_wakeup().
 */
void ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,
				    struct cfg80211_wowlan_wakeup *wakeup,
				    gfp_t gfp);

/**
 * ieee80211_tx_prepare_skb - prepare an 802.11 skb for transmission
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 * @vif: virtual interface
 * @skb: frame to be sent from within the driver
 * @band: the band to transmit on
 * @sta: optional pointer to get the station to send the frame to
 *
 * Note: must be called under RCU lock
 */
bool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif, struct sk_buff *skb,
			      int band, struct ieee80211_sta **sta);

/**
 * struct ieee80211_noa_data - holds temporary data for tracking P2P NoA state
 *
 * @next_tsf: TSF timestamp of the next absent state change
 * @has_next_tsf: next absent state change event pending
 *
 * @absent: descriptor bitmask, set if GO is currently absent
 *
 * private:
 *
 * @count: count fields from the NoA descriptors
 * @desc: adjusted data from the NoA
 */
struct ieee80211_noa_data {
	u32 next_tsf;
	bool has_next_tsf;

	u8 absent;

	u8 count[IEEE80211_P2P_NOA_DESC_MAX];
	struct {
		u32 start;
		u32 duration;
		u32 interval;
	} desc[IEEE80211_P2P_NOA_DESC_MAX];
};

/**
 * ieee80211_parse_p2p_noa - initialize NoA tracking data from P2P IE
 *
 * @attr: P2P NoA IE
 * @data: NoA tracking data
 * @tsf: current TSF timestamp
 *
 * Return: number of successfully parsed descriptors
 */
int ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,
			    struct ieee80211_noa_data *data, u32 tsf);

/**
 * ieee80211_update_p2p_noa - get next pending P2P GO absent state change
 *
 * @data: NoA tracking data
 * @tsf: current TSF timestamp
 */
void ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);

/**
 * ieee80211_tdls_oper - request userspace to perform a TDLS operation
 * @vif: virtual interface
 * @peer: the peer's destination address
 * @oper: the requested TDLS operation
 * @reason_code: reason code for the operation, valid for TDLS teardown
 * @gfp: allocation flags
 *
 * See cfg80211_tdls_oper_request().
 */
void ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,
				 enum nl80211_tdls_operation oper,
				 u16 reason_code, gfp_t gfp);

/**
 * ieee80211_reserve_tid - request to reserve a specific TID
 *
 * There is sometimes a need (such as in TDLS) for blocking the driver from
 * using a specific TID so that the FW can use it for certain operations such
 * as sending PTI requests. To make sure that the driver doesn't use that TID,
 * this function must be called as it flushes out packets on this TID and marks
 * it as blocked, so that any transmit for the station on this TID will be
 * redirected to the alternative TID in the same AC.
 *
 * Note that this function blocks and may call back into the driver, so it
 * should be called without driver locks held. Also note this function should
 * only be called from the driver's @sta_state callback.
 *
 * @sta: the station to reserve the TID for
 * @tid: the TID to reserve
 *
 * Returns: 0 on success, else on failure
 */
int ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid);

/**
 * ieee80211_unreserve_tid - request to unreserve a specific TID
 *
 * Once there is no longer any need for reserving a certain TID, this function
 * should be called, and no longer will packets have their TID modified for
 * preventing use of this TID in the driver.
 *
 * Note that this function blocks and acquires a lock, so it should be called
 * without driver locks held. Also note this function should only be called
 * from the driver's @sta_state callback.
 *
 * @sta: the station
 * @tid: the TID to unreserve
 */
void ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);

/**
 * ieee80211_tx_dequeue - dequeue a packet from a software tx queue
 *
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 * @txq: pointer obtained from station or virtual interface
 *
 * Returns the skb if successful, %NULL if no frame was available.
 */
struct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,
				     struct ieee80211_txq *txq);
#endif /* MAC80211_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef __NET_CFG80211_H
#define __NET_CFG80211_H
/*
 * 802.11 device and configuration interface
 *
 * Copyright 2006-2010	Johannes Berg <johannes@sipsolutions.net>
 * Copyright 2013-2014 Intel Mobile Communications GmbH
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <linux/netdevice.h>
#include <linux/debugfs.h>
#include <linux/list.h>
#include <linux/bug.h>
#include <linux/netlink.h>
#include <linux/skbuff.h>
#include <linux/nl80211.h>
#include <linux/if_ether.h>
#include <linux/ieee80211.h>
#include <linux/net.h>
#include <net/regulatory.h>

/**
 * DOC: Introduction
 *
 * cfg80211 is the configuration API for 802.11 devices in Linux. It bridges
 * userspace and drivers, and offers some utility functionality associated
 * with 802.11. cfg80211 must, directly or indirectly via mac80211, be used
 * by all modern wireless drivers in Linux, so that they offer a consistent
 * API through nl80211. For backward compatibility, cfg80211 also offers
 * wireless extensions to userspace, but hides them from drivers completely.
 *
 * Additionally, cfg80211 contains code to help enforce regulatory spectrum
 * use restrictions.
 */


/**
 * DOC: Device registration
 *
 * In order for a driver to use cfg80211, it must register the hardware device
 * with cfg80211. This happens through a number of hardware capability structs
 * described below.
 *
 * The fundamental structure for each device is the 'wiphy', of which each
 * instance describes a physical wireless device connected to the system. Each
 * such wiphy can have zero, one, or many virtual interfaces associated with
 * it, which need to be identified as such by pointing the network interface's
 * @ieee80211_ptr pointer to a &struct wireless_dev which further describes
 * the wireless part of the interface, normally this struct is embedded in the
 * network interface's private data area. Drivers can optionally allow creating
 * or destroying virtual interfaces on the fly, but without at least one or the
 * ability to create some the wireless device isn't useful.
 *
 * Each wiphy structure contains device capability information, and also has
 * a pointer to the various operations the driver offers. The definitions and
 * structures here describe these capabilities in detail.
 */

struct wiphy;

/*
 * wireless hardware capability structures
 */

/**
 * enum ieee80211_band - supported frequency bands
 *
 * The bands are assigned this way because the supported
 * bitrates differ in these bands.
 *
 * @IEEE80211_BAND_2GHZ: 2.4GHz ISM band
 * @IEEE80211_BAND_5GHZ: around 5GHz band (4.9-5.7)
 * @IEEE80211_BAND_60GHZ: around 60 GHz band (58.32 - 64.80 GHz)
 * @IEEE80211_NUM_BANDS: number of defined bands
 */
enum ieee80211_band {
	IEEE80211_BAND_2GHZ = NL80211_BAND_2GHZ,
	IEEE80211_BAND_5GHZ = NL80211_BAND_5GHZ,
	IEEE80211_BAND_60GHZ = NL80211_BAND_60GHZ,

	/* keep last */
	IEEE80211_NUM_BANDS
};

/**
 * enum ieee80211_channel_flags - channel flags
 *
 * Channel flags set by the regulatory control code.
 *
 * @IEEE80211_CHAN_DISABLED: This channel is disabled.
 * @IEEE80211_CHAN_NO_IR: do not initiate radiation, this includes
 * 	sending probe requests or beaconing.
 * @IEEE80211_CHAN_RADAR: Radar detection is required on this channel.
 * @IEEE80211_CHAN_NO_HT40PLUS: extension channel above this channel
 * 	is not permitted.
 * @IEEE80211_CHAN_NO_HT40MINUS: extension channel below this channel
 * 	is not permitted.
 * @IEEE80211_CHAN_NO_OFDM: OFDM is not allowed on this channel.
 * @IEEE80211_CHAN_NO_80MHZ: If the driver supports 80 MHz on the band,
 *	this flag indicates that an 80 MHz channel cannot use this
 *	channel as the control or any of the secondary channels.
 *	This may be due to the driver or due to regulatory bandwidth
 *	restrictions.
 * @IEEE80211_CHAN_NO_160MHZ: If the driver supports 160 MHz on the band,
 *	this flag indicates that an 160 MHz channel cannot use this
 *	channel as the control or any of the secondary channels.
 *	This may be due to the driver or due to regulatory bandwidth
 *	restrictions.
 * @IEEE80211_CHAN_INDOOR_ONLY: see %NL80211_FREQUENCY_ATTR_INDOOR_ONLY
 * @IEEE80211_CHAN_GO_CONCURRENT: see %NL80211_FREQUENCY_ATTR_GO_CONCURRENT
 * @IEEE80211_CHAN_NO_20MHZ: 20 MHz bandwidth is not permitted
 *	on this channel.
 * @IEEE80211_CHAN_NO_10MHZ: 10 MHz bandwidth is not permitted
 *	on this channel.
 *
 */
enum ieee80211_channel_flags {
	IEEE80211_CHAN_DISABLED		= 1<<0,
	IEEE80211_CHAN_NO_IR		= 1<<1,
	/* hole at 1<<2 */
	IEEE80211_CHAN_RADAR		= 1<<3,
	IEEE80211_CHAN_NO_HT40PLUS	= 1<<4,
	IEEE80211_CHAN_NO_HT40MINUS	= 1<<5,
	IEEE80211_CHAN_NO_OFDM		= 1<<6,
	IEEE80211_CHAN_NO_80MHZ		= 1<<7,
	IEEE80211_CHAN_NO_160MHZ	= 1<<8,
	IEEE80211_CHAN_INDOOR_ONLY	= 1<<9,
	IEEE80211_CHAN_GO_CONCURRENT	= 1<<10,
	IEEE80211_CHAN_NO_20MHZ		= 1<<11,
	IEEE80211_CHAN_NO_10MHZ		= 1<<12,
};

#define IEEE80211_CHAN_NO_HT40 \
	(IEEE80211_CHAN_NO_HT40PLUS | IEEE80211_CHAN_NO_HT40MINUS)

#define IEEE80211_DFS_MIN_CAC_TIME_MS		60000
#define IEEE80211_DFS_MIN_NOP_TIME_MS		(30 * 60 * 1000)

/**
 * struct ieee80211_channel - channel definition
 *
 * This structure describes a single channel for use
 * with cfg80211.
 *
 * @center_freq: center frequency in MHz
 * @hw_value: hardware-specific value for the channel
 * @flags: channel flags from &enum ieee80211_channel_flags.
 * @orig_flags: channel flags at registration time, used by regulatory
 *	code to support devices with additional restrictions
 * @band: band this channel belongs to.
 * @max_antenna_gain: maximum antenna gain in dBi
 * @max_power: maximum transmission power (in dBm)
 * @max_reg_power: maximum regulatory transmission power (in dBm)
 * @beacon_found: helper to regulatory code to indicate when a beacon
 *	has been found on this channel. Use regulatory_hint_found_beacon()
 *	to enable this, this is useful only on 5 GHz band.
 * @orig_mag: internal use
 * @orig_mpwr: internal use
 * @dfs_state: current state of this channel. Only relevant if radar is required
 *	on this channel.
 * @dfs_state_entered: timestamp (jiffies) when the dfs state was entered.
 * @dfs_cac_ms: DFS CAC time in milliseconds, this is valid for DFS channels.
 */
struct ieee80211_channel {
	enum ieee80211_band band;
	u16 center_freq;
	u16 hw_value;
	u32 flags;
	int max_antenna_gain;
	int max_power;
	int max_reg_power;
	bool beacon_found;
	u32 orig_flags;
	int orig_mag, orig_mpwr;
	enum nl80211_dfs_state dfs_state;
	unsigned long dfs_state_entered;
	unsigned int dfs_cac_ms;
};

/**
 * enum ieee80211_rate_flags - rate flags
 *
 * Hardware/specification flags for rates. These are structured
 * in a way that allows using the same bitrate structure for
 * different bands/PHY modes.
 *
 * @IEEE80211_RATE_SHORT_PREAMBLE: Hardware can send with short
 *	preamble on this bitrate; only relevant in 2.4GHz band and
 *	with CCK rates.
 * @IEEE80211_RATE_MANDATORY_A: This bitrate is a mandatory rate
 *	when used with 802.11a (on the 5 GHz band); filled by the
 *	core code when registering the wiphy.
 * @IEEE80211_RATE_MANDATORY_B: This bitrate is a mandatory rate
 *	when used with 802.11b (on the 2.4 GHz band); filled by the
 *	core code when registering the wiphy.
 * @IEEE80211_RATE_MANDATORY_G: This bitrate is a mandatory rate
 *	when used with 802.11g (on the 2.4 GHz band); filled by the
 *	core code when registering the wiphy.
 * @IEEE80211_RATE_ERP_G: This is an ERP rate in 802.11g mode.
 * @IEEE80211_RATE_SUPPORTS_5MHZ: Rate can be used in 5 MHz mode
 * @IEEE80211_RATE_SUPPORTS_10MHZ: Rate can be used in 10 MHz mode
 */
enum ieee80211_rate_flags {
	IEEE80211_RATE_SHORT_PREAMBLE	= 1<<0,
	IEEE80211_RATE_MANDATORY_A	= 1<<1,
	IEEE80211_RATE_MANDATORY_B	= 1<<2,
	IEEE80211_RATE_MANDATORY_G	= 1<<3,
	IEEE80211_RATE_ERP_G		= 1<<4,
	IEEE80211_RATE_SUPPORTS_5MHZ	= 1<<5,
	IEEE80211_RATE_SUPPORTS_10MHZ	= 1<<6,
};

/**
 * enum ieee80211_bss_type - BSS type filter
 *
 * @IEEE80211_BSS_TYPE_ESS: Infrastructure BSS
 * @IEEE80211_BSS_TYPE_PBSS: Personal BSS
 * @IEEE80211_BSS_TYPE_IBSS: Independent BSS
 * @IEEE80211_BSS_TYPE_MBSS: Mesh BSS
 * @IEEE80211_BSS_TYPE_ANY: Wildcard value for matching any BSS type
 */
enum ieee80211_bss_type {
	IEEE80211_BSS_TYPE_ESS,
	IEEE80211_BSS_TYPE_PBSS,
	IEEE80211_BSS_TYPE_IBSS,
	IEEE80211_BSS_TYPE_MBSS,
	IEEE80211_BSS_TYPE_ANY
};

/**
 * enum ieee80211_privacy - BSS privacy filter
 *
 * @IEEE80211_PRIVACY_ON: privacy bit set
 * @IEEE80211_PRIVACY_OFF: privacy bit clear
 * @IEEE80211_PRIVACY_ANY: Wildcard value for matching any privacy setting
 */
enum ieee80211_privacy {
	IEEE80211_PRIVACY_ON,
	IEEE80211_PRIVACY_OFF,
	IEEE80211_PRIVACY_ANY
};

#define IEEE80211_PRIVACY(x)	\
	((x) ? IEEE80211_PRIVACY_ON : IEEE80211_PRIVACY_OFF)

/**
 * struct ieee80211_rate - bitrate definition
 *
 * This structure describes a bitrate that an 802.11 PHY can
 * operate with. The two values @hw_value and @hw_value_short
 * are only for driver use when pointers to this structure are
 * passed around.
 *
 * @flags: rate-specific flags
 * @bitrate: bitrate in units of 100 Kbps
 * @hw_value: driver/hardware value for this rate
 * @hw_value_short: driver/hardware value for this rate when
 *	short preamble is used
 */
struct ieee80211_rate {
	u32 flags;
	u16 bitrate;
	u16 hw_value, hw_value_short;
};

/**
 * struct ieee80211_sta_ht_cap - STA's HT capabilities
 *
 * This structure describes most essential parameters needed
 * to describe 802.11n HT capabilities for an STA.
 *
 * @ht_supported: is HT supported by the STA
 * @cap: HT capabilities map as described in 802.11n spec
 * @ampdu_factor: Maximum A-MPDU length factor
 * @ampdu_density: Minimum A-MPDU spacing
 * @mcs: Supported MCS rates
 */
struct ieee80211_sta_ht_cap {
	u16 cap; /* use IEEE80211_HT_CAP_ */
	bool ht_supported;
	u8 ampdu_factor;
	u8 ampdu_density;
	struct ieee80211_mcs_info mcs;
};

/**
 * struct ieee80211_sta_vht_cap - STA's VHT capabilities
 *
 * This structure describes most essential parameters needed
 * to describe 802.11ac VHT capabilities for an STA.
 *
 * @vht_supported: is VHT supported by the STA
 * @cap: VHT capabilities map as described in 802.11ac spec
 * @vht_mcs: Supported VHT MCS rates
 */
struct ieee80211_sta_vht_cap {
	bool vht_supported;
	u32 cap; /* use IEEE80211_VHT_CAP_ */
	struct ieee80211_vht_mcs_info vht_mcs;
};

/**
 * struct ieee80211_supported_band - frequency band definition
 *
 * This structure describes a frequency band a wiphy
 * is able to operate in.
 *
 * @channels: Array of channels the hardware can operate in
 *	in this band.
 * @band: the band this structure represents
 * @n_channels: Number of channels in @channels
 * @bitrates: Array of bitrates the hardware can operate with
 *	in this band. Must be sorted to give a valid "supported
 *	rates" IE, i.e. CCK rates first, then OFDM.
 * @n_bitrates: Number of bitrates in @bitrates
 * @ht_cap: HT capabilities in this band
 * @vht_cap: VHT capabilities in this band
 */
struct ieee80211_supported_band {
	struct ieee80211_channel *channels;
	struct ieee80211_rate *bitrates;
	enum ieee80211_band band;
	int n_channels;
	int n_bitrates;
	struct ieee80211_sta_ht_cap ht_cap;
	struct ieee80211_sta_vht_cap vht_cap;
};

/*
 * Wireless hardware/device configuration structures and methods
 */

/**
 * DOC: Actions and configuration
 *
 * Each wireless device and each virtual interface offer a set of configuration
 * operations and other actions that are invoked by userspace. Each of these
 * actions is described in the operations structure, and the parameters these
 * operations use are described separately.
 *
 * Additionally, some operations are asynchronous and expect to get status
 * information via some functions that drivers need to call.
 *
 * Scanning and BSS list handling with its associated functionality is described
 * in a separate chapter.
 */

/**
 * struct vif_params - describes virtual interface parameters
 * @use_4addr: use 4-address frames
 * @macaddr: address to use for this virtual interface.
 *	If this parameter is set to zero address the driver may
 *	determine the address as needed.
 *	This feature is only fully supported by drivers that enable the
 *	%NL80211_FEATURE_MAC_ON_CREATE flag.  Others may support creating
 **	only p2p devices with specified MAC.
 */
struct vif_params {
       int use_4addr;
       u8 macaddr[ETH_ALEN];
};

/**
 * struct key_params - key information
 *
 * Information about a key
 *
 * @key: key material
 * @key_len: length of key material
 * @cipher: cipher suite selector
 * @seq: sequence counter (IV/PN) for TKIP and CCMP keys, only used
 *	with the get_key() callback, must be in little endian,
 *	length given by @seq_len.
 * @seq_len: length of @seq.
 */
struct key_params {
	const u8 *key;
	const u8 *seq;
	int key_len;
	int seq_len;
	u32 cipher;
};

/**
 * struct cfg80211_chan_def - channel definition
 * @chan: the (control) channel
 * @width: channel width
 * @center_freq1: center frequency of first segment
 * @center_freq2: center frequency of second segment
 *	(only with 80+80 MHz)
 */
struct cfg80211_chan_def {
	struct ieee80211_channel *chan;
	enum nl80211_chan_width width;
	u32 center_freq1;
	u32 center_freq2;
};

/**
 * cfg80211_get_chandef_type - return old channel type from chandef
 * @chandef: the channel definition
 *
 * Return: The old channel type (NOHT, HT20, HT40+/-) from a given
 * chandef, which must have a bandwidth allowing this conversion.
 */
static inline enum nl80211_channel_type
cfg80211_get_chandef_type(const struct cfg80211_chan_def *chandef)
{
	switch (chandef->width) {
	case NL80211_CHAN_WIDTH_20_NOHT:
		return NL80211_CHAN_NO_HT;
	case NL80211_CHAN_WIDTH_20:
		return NL80211_CHAN_HT20;
	case NL80211_CHAN_WIDTH_40:
		if (chandef->center_freq1 > chandef->chan->center_freq)
			return NL80211_CHAN_HT40PLUS;
		return NL80211_CHAN_HT40MINUS;
	default:
		WARN_ON(1);
		return NL80211_CHAN_NO_HT;
	}
}

/**
 * cfg80211_chandef_create - create channel definition using channel type
 * @chandef: the channel definition struct to fill
 * @channel: the control channel
 * @chantype: the channel type
 *
 * Given a channel type, create a channel definition.
 */
void cfg80211_chandef_create(struct cfg80211_chan_def *chandef,
			     struct ieee80211_channel *channel,
			     enum nl80211_channel_type chantype);

/**
 * cfg80211_chandef_identical - check if two channel definitions are identical
 * @chandef1: first channel definition
 * @chandef2: second channel definition
 *
 * Return: %true if the channels defined by the channel definitions are
 * identical, %false otherwise.
 */
static inline bool
cfg80211_chandef_identical(const struct cfg80211_chan_def *chandef1,
			   const struct cfg80211_chan_def *chandef2)
{
	return (chandef1->chan == chandef2->chan &&
		chandef1->width == chandef2->width &&
		chandef1->center_freq1 == chandef2->center_freq1 &&
		chandef1->center_freq2 == chandef2->center_freq2);
}

/**
 * cfg80211_chandef_compatible - check if two channel definitions are compatible
 * @chandef1: first channel definition
 * @chandef2: second channel definition
 *
 * Return: %NULL if the given channel definitions are incompatible,
 * chandef1 or chandef2 otherwise.
 */
const struct cfg80211_chan_def *
cfg80211_chandef_compatible(const struct cfg80211_chan_def *chandef1,
			    const struct cfg80211_chan_def *chandef2);

/**
 * cfg80211_chandef_valid - check if a channel definition is valid
 * @chandef: the channel definition to check
 * Return: %true if the channel definition is valid. %false otherwise.
 */
bool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef);

/**
 * cfg80211_chandef_usable - check if secondary channels can be used
 * @wiphy: the wiphy to validate against
 * @chandef: the channel definition to check
 * @prohibited_flags: the regulatory channel flags that must not be set
 * Return: %true if secondary channels are usable. %false otherwise.
 */
bool cfg80211_chandef_usable(struct wiphy *wiphy,
			     const struct cfg80211_chan_def *chandef,
			     u32 prohibited_flags);

/**
 * cfg80211_chandef_dfs_required - checks if radar detection is required
 * @wiphy: the wiphy to validate against
 * @chandef: the channel definition to check
 * @iftype: the interface type as specified in &enum nl80211_iftype
 * Returns:
 *	1 if radar detection is required, 0 if it is not, < 0 on error
 */
int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
				  const struct cfg80211_chan_def *chandef,
				  enum nl80211_iftype iftype);

/**
 * ieee80211_chandef_rate_flags - returns rate flags for a channel
 *
 * In some channel types, not all rates may be used - for example CCK
 * rates may not be used in 5/10 MHz channels.
 *
 * @chandef: channel definition for the channel
 *
 * Returns: rate flags which apply for this channel
 */
static inline enum ieee80211_rate_flags
ieee80211_chandef_rate_flags(struct cfg80211_chan_def *chandef)
{
	switch (chandef->width) {
	case NL80211_CHAN_WIDTH_5:
		return IEEE80211_RATE_SUPPORTS_5MHZ;
	case NL80211_CHAN_WIDTH_10:
		return IEEE80211_RATE_SUPPORTS_10MHZ;
	default:
		break;
	}
	return 0;
}

/**
 * ieee80211_chandef_max_power - maximum transmission power for the chandef
 *
 * In some regulations, the transmit power may depend on the configured channel
 * bandwidth which may be defined as dBm/MHz. This function returns the actual
 * max_power for non-standard (20 MHz) channels.
 *
 * @chandef: channel definition for the channel
 *
 * Returns: maximum allowed transmission power in dBm for the chandef
 */
static inline int
ieee80211_chandef_max_power(struct cfg80211_chan_def *chandef)
{
	switch (chandef->width) {
	case NL80211_CHAN_WIDTH_5:
		return min(chandef->chan->max_reg_power - 6,
			   chandef->chan->max_power);
	case NL80211_CHAN_WIDTH_10:
		return min(chandef->chan->max_reg_power - 3,
			   chandef->chan->max_power);
	default:
		break;
	}
	return chandef->chan->max_power;
}

/**
 * enum survey_info_flags - survey information flags
 *
 * @SURVEY_INFO_NOISE_DBM: noise (in dBm) was filled in
 * @SURVEY_INFO_IN_USE: channel is currently being used
 * @SURVEY_INFO_TIME: active time (in ms) was filled in
 * @SURVEY_INFO_TIME_BUSY: busy time was filled in
 * @SURVEY_INFO_TIME_EXT_BUSY: extension channel busy time was filled in
 * @SURVEY_INFO_TIME_RX: receive time was filled in
 * @SURVEY_INFO_TIME_TX: transmit time was filled in
 * @SURVEY_INFO_TIME_SCAN: scan time was filled in
 *
 * Used by the driver to indicate which info in &struct survey_info
 * it has filled in during the get_survey().
 */
enum survey_info_flags {
	SURVEY_INFO_NOISE_DBM		= BIT(0),
	SURVEY_INFO_IN_USE		= BIT(1),
	SURVEY_INFO_TIME		= BIT(2),
	SURVEY_INFO_TIME_BUSY		= BIT(3),
	SURVEY_INFO_TIME_EXT_BUSY	= BIT(4),
	SURVEY_INFO_TIME_RX		= BIT(5),
	SURVEY_INFO_TIME_TX		= BIT(6),
	SURVEY_INFO_TIME_SCAN		= BIT(7),
};

/**
 * struct survey_info - channel survey response
 *
 * @channel: the channel this survey record reports, may be %NULL for a single
 *	record to report global statistics
 * @filled: bitflag of flags from &enum survey_info_flags
 * @noise: channel noise in dBm. This and all following fields are
 *	optional
 * @time: amount of time in ms the radio was turn on (on the channel)
 * @time_busy: amount of time the primary channel was sensed busy
 * @time_ext_busy: amount of time the extension channel was sensed busy
 * @time_rx: amount of time the radio spent receiving data
 * @time_tx: amount of time the radio spent transmitting data
 * @time_scan: amount of time the radio spent for scanning
 *
 * Used by dump_survey() to report back per-channel survey information.
 *
 * This structure can later be expanded with things like
 * channel duty cycle etc.
 */
struct survey_info {
	struct ieee80211_channel *channel;
	u64 time;
	u64 time_busy;
	u64 time_ext_busy;
	u64 time_rx;
	u64 time_tx;
	u64 time_scan;
	u32 filled;
	s8 noise;
};

/**
 * struct cfg80211_crypto_settings - Crypto settings
 * @wpa_versions: indicates which, if any, WPA versions are enabled
 *	(from enum nl80211_wpa_versions)
 * @cipher_group: group key cipher suite (or 0 if unset)
 * @n_ciphers_pairwise: number of AP supported unicast ciphers
 * @ciphers_pairwise: unicast key cipher suites
 * @n_akm_suites: number of AKM suites
 * @akm_suites: AKM suites
 * @control_port: Whether user space controls IEEE 802.1X port, i.e.,
 *	sets/clears %NL80211_STA_FLAG_AUTHORIZED. If true, the driver is
 *	required to assume that the port is unauthorized until authorized by
 *	user space. Otherwise, port is marked authorized by default.
 * @control_port_ethertype: the control port protocol that should be
 *	allowed through even on unauthorized ports
 * @control_port_no_encrypt: TRUE to prevent encryption of control port
 *	protocol frames.
 */
struct cfg80211_crypto_settings {
	u32 wpa_versions;
	u32 cipher_group;
	int n_ciphers_pairwise;
	u32 ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES];
	int n_akm_suites;
	u32 akm_suites[NL80211_MAX_NR_AKM_SUITES];
	bool control_port;
	__be16 control_port_ethertype;
	bool control_port_no_encrypt;
};

/**
 * struct cfg80211_beacon_data - beacon data
 * @head: head portion of beacon (before TIM IE)
 *	or %NULL if not changed
 * @tail: tail portion of beacon (after TIM IE)
 *	or %NULL if not changed
 * @head_len: length of @head
 * @tail_len: length of @tail
 * @beacon_ies: extra information element(s) to add into Beacon frames or %NULL
 * @beacon_ies_len: length of beacon_ies in octets
 * @proberesp_ies: extra information element(s) to add into Probe Response
 *	frames or %NULL
 * @proberesp_ies_len: length of proberesp_ies in octets
 * @assocresp_ies: extra information element(s) to add into (Re)Association
 *	Response frames or %NULL
 * @assocresp_ies_len: length of assocresp_ies in octets
 * @probe_resp_len: length of probe response template (@probe_resp)
 * @probe_resp: probe response template (AP mode only)
 */
struct cfg80211_beacon_data {
	const u8 *head, *tail;
	const u8 *beacon_ies;
	const u8 *proberesp_ies;
	const u8 *assocresp_ies;
	const u8 *probe_resp;

	size_t head_len, tail_len;
	size_t beacon_ies_len;
	size_t proberesp_ies_len;
	size_t assocresp_ies_len;
	size_t probe_resp_len;
};

struct mac_address {
	u8 addr[ETH_ALEN];
};

/**
 * struct cfg80211_acl_data - Access control list data
 *
 * @acl_policy: ACL policy to be applied on the station's
 *	entry specified by mac_addr
 * @n_acl_entries: Number of MAC address entries passed
 * @mac_addrs: List of MAC addresses of stations to be used for ACL
 */
struct cfg80211_acl_data {
	enum nl80211_acl_policy acl_policy;
	int n_acl_entries;

	/* Keep it last */
	struct mac_address mac_addrs[];
};

/**
 * struct cfg80211_ap_settings - AP configuration
 *
 * Used to configure an AP interface.
 *
 * @chandef: defines the channel to use
 * @beacon: beacon data
 * @beacon_interval: beacon interval
 * @dtim_period: DTIM period
 * @ssid: SSID to be used in the BSS (note: may be %NULL if not provided from
 *	user space)
 * @ssid_len: length of @ssid
 * @hidden_ssid: whether to hide the SSID in Beacon/Probe Response frames
 * @crypto: crypto settings
 * @privacy: the BSS uses privacy
 * @auth_type: Authentication type (algorithm)
 * @smps_mode: SMPS mode
 * @inactivity_timeout: time in seconds to determine station's inactivity.
 * @p2p_ctwindow: P2P CT Window
 * @p2p_opp_ps: P2P opportunistic PS
 * @acl: ACL configuration used by the drivers which has support for
 *	MAC address based access control
 */
struct cfg80211_ap_settings {
	struct cfg80211_chan_def chandef;

	struct cfg80211_beacon_data beacon;

	int beacon_interval, dtim_period;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_hidden_ssid hidden_ssid;
	struct cfg80211_crypto_settings crypto;
	bool privacy;
	enum nl80211_auth_type auth_type;
	enum nl80211_smps_mode smps_mode;
	int inactivity_timeout;
	u8 p2p_ctwindow;
	bool p2p_opp_ps;
	const struct cfg80211_acl_data *acl;
};

/**
 * struct cfg80211_csa_settings - channel switch settings
 *
 * Used for channel switch
 *
 * @chandef: defines the channel to use after the switch
 * @beacon_csa: beacon data while performing the switch
 * @counter_offsets_beacon: offsets of the counters within the beacon (tail)
 * @counter_offsets_presp: offsets of the counters within the probe response
 * @n_counter_offsets_beacon: number of csa counters the beacon (tail)
 * @n_counter_offsets_presp: number of csa counters in the probe response
 * @beacon_after: beacon data to be used on the new channel
 * @radar_required: whether radar detection is required on the new channel
 * @block_tx: whether transmissions should be blocked while changing
 * @count: number of beacons until switch
 */
struct cfg80211_csa_settings {
	struct cfg80211_chan_def chandef;
	struct cfg80211_beacon_data beacon_csa;
	const u16 *counter_offsets_beacon;
	const u16 *counter_offsets_presp;
	unsigned int n_counter_offsets_beacon;
	unsigned int n_counter_offsets_presp;
	struct cfg80211_beacon_data beacon_after;
	bool radar_required;
	bool block_tx;
	u8 count;
};

/**
 * enum station_parameters_apply_mask - station parameter values to apply
 * @STATION_PARAM_APPLY_UAPSD: apply new uAPSD parameters (uapsd_queues, max_sp)
 * @STATION_PARAM_APPLY_CAPABILITY: apply new capability
 * @STATION_PARAM_APPLY_PLINK_STATE: apply new plink state
 *
 * Not all station parameters have in-band "no change" signalling,
 * for those that don't these flags will are used.
 */
enum station_parameters_apply_mask {
	STATION_PARAM_APPLY_UAPSD = BIT(0),
	STATION_PARAM_APPLY_CAPABILITY = BIT(1),
	STATION_PARAM_APPLY_PLINK_STATE = BIT(2),
};

/**
 * struct station_parameters - station parameters
 *
 * Used to change and create a new station.
 *
 * @vlan: vlan interface station should belong to
 * @supported_rates: supported rates in IEEE 802.11 format
 *	(or NULL for no change)
 * @supported_rates_len: number of supported rates
 * @sta_flags_mask: station flags that changed
 *	(bitmask of BIT(NL80211_STA_FLAG_...))
 * @sta_flags_set: station flags values
 *	(bitmask of BIT(NL80211_STA_FLAG_...))
 * @listen_interval: listen interval or -1 for no change
 * @aid: AID or zero for no change
 * @plink_action: plink action to take
 * @plink_state: set the peer link state for a station
 * @ht_capa: HT capabilities of station
 * @vht_capa: VHT capabilities of station
 * @uapsd_queues: bitmap of queues configured for uapsd. same format
 *	as the AC bitmap in the QoS info field
 * @max_sp: max Service Period. same format as the MAX_SP in the
 *	QoS info field (but already shifted down)
 * @sta_modify_mask: bitmap indicating which parameters changed
 *	(for those that don't have a natural "no change" value),
 *	see &enum station_parameters_apply_mask
 * @local_pm: local link-specific mesh power save mode (no change when set
 *	to unknown)
 * @capability: station capability
 * @ext_capab: extended capabilities of the station
 * @ext_capab_len: number of extended capabilities
 * @supported_channels: supported channels in IEEE 802.11 format
 * @supported_channels_len: number of supported channels
 * @supported_oper_classes: supported oper classes in IEEE 802.11 format
 * @supported_oper_classes_len: number of supported operating classes
 * @opmode_notif: operating mode field from Operating Mode Notification
 * @opmode_notif_used: information if operating mode field is used
 */
struct station_parameters {
	const u8 *supported_rates;
	struct net_device *vlan;
	u32 sta_flags_mask, sta_flags_set;
	u32 sta_modify_mask;
	int listen_interval;
	u16 aid;
	u8 supported_rates_len;
	u8 plink_action;
	u8 plink_state;
	const struct ieee80211_ht_cap *ht_capa;
	const struct ieee80211_vht_cap *vht_capa;
	u8 uapsd_queues;
	u8 max_sp;
	enum nl80211_mesh_power_mode local_pm;
	u16 capability;
	const u8 *ext_capab;
	u8 ext_capab_len;
	const u8 *supported_channels;
	u8 supported_channels_len;
	const u8 *supported_oper_classes;
	u8 supported_oper_classes_len;
	u8 opmode_notif;
	bool opmode_notif_used;
};

/**
 * struct station_del_parameters - station deletion parameters
 *
 * Used to delete a station entry (or all stations).
 *
 * @mac: MAC address of the station to remove or NULL to remove all stations
 * @subtype: Management frame subtype to use for indicating removal
 *	(10 = Disassociation, 12 = Deauthentication)
 * @reason_code: Reason code for the Disassociation/Deauthentication frame
 */
struct station_del_parameters {
	const u8 *mac;
	u8 subtype;
	u16 reason_code;
};

/**
 * enum cfg80211_station_type - the type of station being modified
 * @CFG80211_STA_AP_CLIENT: client of an AP interface
 * @CFG80211_STA_AP_MLME_CLIENT: client of an AP interface that has
 *	the AP MLME in the device
 * @CFG80211_STA_AP_STA: AP station on managed interface
 * @CFG80211_STA_IBSS: IBSS station
 * @CFG80211_STA_TDLS_PEER_SETUP: TDLS peer on managed interface (dummy entry
 *	while TDLS setup is in progress, it moves out of this state when
 *	being marked authorized; use this only if TDLS with external setup is
 *	supported/used)
 * @CFG80211_STA_TDLS_PEER_ACTIVE: TDLS peer on managed interface (active
 *	entry that is operating, has been marked authorized by userspace)
 * @CFG80211_STA_MESH_PEER_KERNEL: peer on mesh interface (kernel managed)
 * @CFG80211_STA_MESH_PEER_USER: peer on mesh interface (user managed)
 */
enum cfg80211_station_type {
	CFG80211_STA_AP_CLIENT,
	CFG80211_STA_AP_MLME_CLIENT,
	CFG80211_STA_AP_STA,
	CFG80211_STA_IBSS,
	CFG80211_STA_TDLS_PEER_SETUP,
	CFG80211_STA_TDLS_PEER_ACTIVE,
	CFG80211_STA_MESH_PEER_KERNEL,
	CFG80211_STA_MESH_PEER_USER,
};

/**
 * cfg80211_check_station_change - validate parameter changes
 * @wiphy: the wiphy this operates on
 * @params: the new parameters for a station
 * @statype: the type of station being modified
 *
 * Utility function for the @change_station driver method. Call this function
 * with the appropriate station type looking up the station (and checking that
 * it exists). It will verify whether the station change is acceptable, and if
 * not will return an error code. Note that it may modify the parameters for
 * backward compatibility reasons, so don't use them before calling this.
 */
int cfg80211_check_station_change(struct wiphy *wiphy,
				  struct station_parameters *params,
				  enum cfg80211_station_type statype);

/**
 * enum station_info_rate_flags - bitrate info flags
 *
 * Used by the driver to indicate the specific rate transmission
 * type for 802.11n transmissions.
 *
 * @RATE_INFO_FLAGS_MCS: mcs field filled with HT MCS
 * @RATE_INFO_FLAGS_VHT_MCS: mcs field filled with VHT MCS
 * @RATE_INFO_FLAGS_SHORT_GI: 400ns guard interval
 * @RATE_INFO_FLAGS_60G: 60GHz MCS
 */
enum rate_info_flags {
	RATE_INFO_FLAGS_MCS			= BIT(0),
	RATE_INFO_FLAGS_VHT_MCS			= BIT(1),
	RATE_INFO_FLAGS_SHORT_GI		= BIT(2),
	RATE_INFO_FLAGS_60G			= BIT(3),
};

/**
 * enum rate_info_bw - rate bandwidth information
 *
 * Used by the driver to indicate the rate bandwidth.
 *
 * @RATE_INFO_BW_5: 5 MHz bandwidth
 * @RATE_INFO_BW_10: 10 MHz bandwidth
 * @RATE_INFO_BW_20: 20 MHz bandwidth
 * @RATE_INFO_BW_40: 40 MHz bandwidth
 * @RATE_INFO_BW_80: 80 MHz bandwidth
 * @RATE_INFO_BW_160: 160 MHz bandwidth
 */
enum rate_info_bw {
	RATE_INFO_BW_5,
	RATE_INFO_BW_10,
	RATE_INFO_BW_20,
	RATE_INFO_BW_40,
	RATE_INFO_BW_80,
	RATE_INFO_BW_160,
};

/**
 * struct rate_info - bitrate information
 *
 * Information about a receiving or transmitting bitrate
 *
 * @flags: bitflag of flags from &enum rate_info_flags
 * @mcs: mcs index if struct describes a 802.11n bitrate
 * @legacy: bitrate in 100kbit/s for 802.11abg
 * @nss: number of streams (VHT only)
 * @bw: bandwidth (from &enum rate_info_bw)
 */
struct rate_info {
	u8 flags;
	u8 mcs;
	u16 legacy;
	u8 nss;
	u8 bw;
};

/**
 * enum station_info_rate_flags - bitrate info flags
 *
 * Used by the driver to indicate the specific rate transmission
 * type for 802.11n transmissions.
 *
 * @BSS_PARAM_FLAGS_CTS_PROT: whether CTS protection is enabled
 * @BSS_PARAM_FLAGS_SHORT_PREAMBLE: whether short preamble is enabled
 * @BSS_PARAM_FLAGS_SHORT_SLOT_TIME: whether short slot time is enabled
 */
enum bss_param_flags {
	BSS_PARAM_FLAGS_CTS_PROT	= 1<<0,
	BSS_PARAM_FLAGS_SHORT_PREAMBLE	= 1<<1,
	BSS_PARAM_FLAGS_SHORT_SLOT_TIME	= 1<<2,
};

/**
 * struct sta_bss_parameters - BSS parameters for the attached station
 *
 * Information about the currently associated BSS
 *
 * @flags: bitflag of flags from &enum bss_param_flags
 * @dtim_period: DTIM period for the BSS
 * @beacon_interval: beacon interval
 */
struct sta_bss_parameters {
	u8 flags;
	u8 dtim_period;
	u16 beacon_interval;
};

/**
 * struct cfg80211_tid_stats - per-TID statistics
 * @filled: bitmap of flags using the bits of &enum nl80211_tid_stats to
 *	indicate the relevant values in this struct are filled
 * @rx_msdu: number of received MSDUs
 * @tx_msdu: number of (attempted) transmitted MSDUs
 * @tx_msdu_retries: number of retries (not counting the first) for
 *	transmitted MSDUs
 * @tx_msdu_failed: number of failed transmitted MSDUs
 */
struct cfg80211_tid_stats {
	u32 filled;
	u64 rx_msdu;
	u64 tx_msdu;
	u64 tx_msdu_retries;
	u64 tx_msdu_failed;
};

#define IEEE80211_MAX_CHAINS	4

/**
 * struct station_info - station information
 *
 * Station information filled by driver for get_station() and dump_station.
 *
 * @filled: bitflag of flags using the bits of &enum nl80211_sta_info to
 *	indicate the relevant values in this struct for them
 * @connected_time: time(in secs) since a station is last connected
 * @inactive_time: time since last station activity (tx/rx) in milliseconds
 * @rx_bytes: bytes (size of MPDUs) received from this station
 * @tx_bytes: bytes (size of MPDUs) transmitted to this station
 * @llid: mesh local link id
 * @plid: mesh peer link id
 * @plink_state: mesh peer link state
 * @signal: The signal strength, type depends on the wiphy's signal_type.
 *	For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
 * @signal_avg: Average signal strength, type depends on the wiphy's signal_type.
 *	For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
 * @chains: bitmask for filled values in @chain_signal, @chain_signal_avg
 * @chain_signal: per-chain signal strength of last received packet in dBm
 * @chain_signal_avg: per-chain signal strength average in dBm
 * @txrate: current unicast bitrate from this station
 * @rxrate: current unicast bitrate to this station
 * @rx_packets: packets (MSDUs & MMPDUs) received from this station
 * @tx_packets: packets (MSDUs & MMPDUs) transmitted to this station
 * @tx_retries: cumulative retry counts (MPDUs)
 * @tx_failed: number of failed transmissions (MPDUs) (retries exceeded, no ACK)
 * @rx_dropped_misc:  Dropped for un-specified reason.
 * @bss_param: current BSS parameters
 * @generation: generation number for nl80211 dumps.
 *	This number should increase every time the list of stations
 *	changes, i.e. when a station is added or removed, so that
 *	userspace can tell whether it got a consistent snapshot.
 * @assoc_req_ies: IEs from (Re)Association Request.
 *	This is used only when in AP mode with drivers that do not use
 *	user space MLME/SME implementation. The information is provided for
 *	the cfg80211_new_sta() calls to notify user space of the IEs.
 * @assoc_req_ies_len: Length of assoc_req_ies buffer in octets.
 * @sta_flags: station flags mask & values
 * @beacon_loss_count: Number of times beacon loss event has triggered.
 * @t_offset: Time offset of the station relative to this host.
 * @local_pm: local mesh STA power save mode
 * @peer_pm: peer mesh STA power save mode
 * @nonpeer_pm: non-peer mesh STA power save mode
 * @expected_throughput: expected throughput in kbps (including 802.11 headers)
 *	towards this station.
 * @rx_beacon: number of beacons received from this peer
 * @rx_beacon_signal_avg: signal strength average (in dBm) for beacons received
 *	from this peer
 * @pertid: per-TID statistics, see &struct cfg80211_tid_stats, using the last
 *	(IEEE80211_NUM_TIDS) index for MSDUs not encapsulated in QoS-MPDUs.
 */
struct station_info {
	u32 filled;
	u32 connected_time;
	u32 inactive_time;
	u64 rx_bytes;
	u64 tx_bytes;
	u16 llid;
	u16 plid;
	u8 plink_state;
	s8 signal;
	s8 signal_avg;

	u8 chains;
	s8 chain_signal[IEEE80211_MAX_CHAINS];
	s8 chain_signal_avg[IEEE80211_MAX_CHAINS];

	struct rate_info txrate;
	struct rate_info rxrate;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	struct sta_bss_parameters bss_param;
	struct nl80211_sta_flag_update sta_flags;

	int generation;

	const u8 *assoc_req_ies;
	size_t assoc_req_ies_len;

	u32 beacon_loss_count;
	s64 t_offset;
	enum nl80211_mesh_power_mode local_pm;
	enum nl80211_mesh_power_mode peer_pm;
	enum nl80211_mesh_power_mode nonpeer_pm;

	u32 expected_throughput;

	u64 rx_beacon;
	u8 rx_beacon_signal_avg;
	struct cfg80211_tid_stats pertid[IEEE80211_NUM_TIDS + 1];
};

/**
 * cfg80211_get_station - retrieve information about a given station
 * @dev: the device where the station is supposed to be connected to
 * @mac_addr: the mac address of the station of interest
 * @sinfo: pointer to the structure to fill with the information
 *
 * Returns 0 on success and sinfo is filled with the available information
 * otherwise returns a negative error code and the content of sinfo has to be
 * considered undefined.
 */
int cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,
			 struct station_info *sinfo);

/**
 * enum monitor_flags - monitor flags
 *
 * Monitor interface configuration flags. Note that these must be the bits
 * according to the nl80211 flags.
 *
 * @MONITOR_FLAG_FCSFAIL: pass frames with bad FCS
 * @MONITOR_FLAG_PLCPFAIL: pass frames with bad PLCP
 * @MONITOR_FLAG_CONTROL: pass control frames
 * @MONITOR_FLAG_OTHER_BSS: disable BSSID filtering
 * @MONITOR_FLAG_COOK_FRAMES: report frames after processing
 * @MONITOR_FLAG_ACTIVE: active monitor, ACKs frames on its MAC address
 */
enum monitor_flags {
	MONITOR_FLAG_FCSFAIL		= 1<<NL80211_MNTR_FLAG_FCSFAIL,
	MONITOR_FLAG_PLCPFAIL		= 1<<NL80211_MNTR_FLAG_PLCPFAIL,
	MONITOR_FLAG_CONTROL		= 1<<NL80211_MNTR_FLAG_CONTROL,
	MONITOR_FLAG_OTHER_BSS		= 1<<NL80211_MNTR_FLAG_OTHER_BSS,
	MONITOR_FLAG_COOK_FRAMES	= 1<<NL80211_MNTR_FLAG_COOK_FRAMES,
	MONITOR_FLAG_ACTIVE		= 1<<NL80211_MNTR_FLAG_ACTIVE,
};

/**
 * enum mpath_info_flags -  mesh path information flags
 *
 * Used by the driver to indicate which info in &struct mpath_info it has filled
 * in during get_station() or dump_station().
 *
 * @MPATH_INFO_FRAME_QLEN: @frame_qlen filled
 * @MPATH_INFO_SN: @sn filled
 * @MPATH_INFO_METRIC: @metric filled
 * @MPATH_INFO_EXPTIME: @exptime filled
 * @MPATH_INFO_DISCOVERY_TIMEOUT: @discovery_timeout filled
 * @MPATH_INFO_DISCOVERY_RETRIES: @discovery_retries filled
 * @MPATH_INFO_FLAGS: @flags filled
 */
enum mpath_info_flags {
	MPATH_INFO_FRAME_QLEN		= BIT(0),
	MPATH_INFO_SN			= BIT(1),
	MPATH_INFO_METRIC		= BIT(2),
	MPATH_INFO_EXPTIME		= BIT(3),
	MPATH_INFO_DISCOVERY_TIMEOUT	= BIT(4),
	MPATH_INFO_DISCOVERY_RETRIES	= BIT(5),
	MPATH_INFO_FLAGS		= BIT(6),
};

/**
 * struct mpath_info - mesh path information
 *
 * Mesh path information filled by driver for get_mpath() and dump_mpath().
 *
 * @filled: bitfield of flags from &enum mpath_info_flags
 * @frame_qlen: number of queued frames for this destination
 * @sn: target sequence number
 * @metric: metric (cost) of this mesh path
 * @exptime: expiration time for the mesh path from now, in msecs
 * @flags: mesh path flags
 * @discovery_timeout: total mesh path discovery timeout, in msecs
 * @discovery_retries: mesh path discovery retries
 * @generation: generation number for nl80211 dumps.
 *	This number should increase every time the list of mesh paths
 *	changes, i.e. when a station is added or removed, so that
 *	userspace can tell whether it got a consistent snapshot.
 */
struct mpath_info {
	u32 filled;
	u32 frame_qlen;
	u32 sn;
	u32 metric;
	u32 exptime;
	u32 discovery_timeout;
	u8 discovery_retries;
	u8 flags;

	int generation;
};

/**
 * struct bss_parameters - BSS parameters
 *
 * Used to change BSS parameters (mainly for AP mode).
 *
 * @use_cts_prot: Whether to use CTS protection
 *	(0 = no, 1 = yes, -1 = do not change)
 * @use_short_preamble: Whether the use of short preambles is allowed
 *	(0 = no, 1 = yes, -1 = do not change)
 * @use_short_slot_time: Whether the use of short slot time is allowed
 *	(0 = no, 1 = yes, -1 = do not change)
 * @basic_rates: basic rates in IEEE 802.11 format
 *	(or NULL for no change)
 * @basic_rates_len: number of basic rates
 * @ap_isolate: do not forward packets between connected stations
 * @ht_opmode: HT Operation mode
 * 	(u16 = opmode, -1 = do not change)
 * @p2p_ctwindow: P2P CT Window (-1 = no change)
 * @p2p_opp_ps: P2P opportunistic PS (-1 = no change)
 */
struct bss_parameters {
	int use_cts_prot;
	int use_short_preamble;
	int use_short_slot_time;
	const u8 *basic_rates;
	u8 basic_rates_len;
	int ap_isolate;
	int ht_opmode;
	s8 p2p_ctwindow, p2p_opp_ps;
};

/**
 * struct mesh_config - 802.11s mesh configuration
 *
 * These parameters can be changed while the mesh is active.
 *
 * @dot11MeshRetryTimeout: the initial retry timeout in millisecond units used
 *	by the Mesh Peering Open message
 * @dot11MeshConfirmTimeout: the initial retry timeout in millisecond units
 *	used by the Mesh Peering Open message
 * @dot11MeshHoldingTimeout: the confirm timeout in millisecond units used by
 *	the mesh peering management to close a mesh peering
 * @dot11MeshMaxPeerLinks: the maximum number of peer links allowed on this
 *	mesh interface
 * @dot11MeshMaxRetries: the maximum number of peer link open retries that can
 *	be sent to establish a new peer link instance in a mesh
 * @dot11MeshTTL: the value of TTL field set at a source mesh STA
 * @element_ttl: the value of TTL field set at a mesh STA for path selection
 *	elements
 * @auto_open_plinks: whether we should automatically open peer links when we
 *	detect compatible mesh peers
 * @dot11MeshNbrOffsetMaxNeighbor: the maximum number of neighbors to
 *	synchronize to for 11s default synchronization method
 * @dot11MeshHWMPmaxPREQretries: the number of action frames containing a PREQ
 *	that an originator mesh STA can send to a particular path target
 * @path_refresh_time: how frequently to refresh mesh paths in milliseconds
 * @min_discovery_timeout: the minimum length of time to wait until giving up on
 *	a path discovery in milliseconds
 * @dot11MeshHWMPactivePathTimeout: the time (in TUs) for which mesh STAs
 *	receiving a PREQ shall consider the forwarding information from the
 *	root to be valid. (TU = time unit)
 * @dot11MeshHWMPpreqMinInterval: the minimum interval of time (in TUs) during
 *	which a mesh STA can send only one action frame containing a PREQ
 *	element
 * @dot11MeshHWMPperrMinInterval: the minimum interval of time (in TUs) during
 *	which a mesh STA can send only one Action frame containing a PERR
 *	element
 * @dot11MeshHWMPnetDiameterTraversalTime: the interval of time (in TUs) that
 *	it takes for an HWMP information element to propagate across the mesh
 * @dot11MeshHWMPRootMode: the configuration of a mesh STA as root mesh STA
 * @dot11MeshHWMPRannInterval: the interval of time (in TUs) between root
 *	announcements are transmitted
 * @dot11MeshGateAnnouncementProtocol: whether to advertise that this mesh
 *	station has access to a broader network beyond the MBSS. (This is
 *	missnamed in draft 12.0: dot11MeshGateAnnouncementProtocol set to true
 *	only means that the station will announce others it's a mesh gate, but
 *	not necessarily using the gate announcement protocol. Still keeping the
 *	same nomenclature to be in sync with the spec)
 * @dot11MeshForwarding: whether the Mesh STA is forwarding or non-forwarding
 *	entity (default is TRUE - forwarding entity)
 * @rssi_threshold: the threshold for average signal strength of candidate
 *	station to establish a peer link
 * @ht_opmode: mesh HT protection mode
 *
 * @dot11MeshHWMPactivePathToRootTimeout: The time (in TUs) for which mesh STAs
 *	receiving a proactive PREQ shall consider the forwarding information to
 *	the root mesh STA to be valid.
 *
 * @dot11MeshHWMProotInterval: The interval of time (in TUs) between proactive
 *	PREQs are transmitted.
 * @dot11MeshHWMPconfirmationInterval: The minimum interval of time (in TUs)
 *	during which a mesh STA can send only one Action frame containing
 *	a PREQ element for root path confirmation.
 * @power_mode: The default mesh power save mode which will be the initial
 *	setting for new peer links.
 * @dot11MeshAwakeWindowDuration: The duration in TUs the STA will remain awake
 *	after transmitting its beacon.
 * @plink_timeout: If no tx activity is seen from a STA we've established
 *	peering with for longer than this time (in seconds), then remove it
 *	from the STA's list of peers.  Default is 30 minutes.
 */
struct mesh_config {
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u16 min_discovery_timeout;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	enum nl80211_mesh_power_mode power_mode;
	u16 dot11MeshAwakeWindowDuration;
	u32 plink_timeout;
};

/**
 * struct mesh_setup - 802.11s mesh setup configuration
 * @chandef: defines the channel to use
 * @mesh_id: the mesh ID
 * @mesh_id_len: length of the mesh ID, at least 1 and at most 32 bytes
 * @sync_method: which synchronization method to use
 * @path_sel_proto: which path selection protocol to use
 * @path_metric: which metric to use
 * @auth_id: which authentication method this mesh is using
 * @ie: vendor information elements (optional)
 * @ie_len: length of vendor information elements
 * @is_authenticated: this mesh requires authentication
 * @is_secure: this mesh uses security
 * @user_mpm: userspace handles all MPM functions
 * @dtim_period: DTIM period to use
 * @beacon_interval: beacon interval to use
 * @mcast_rate: multicat rate for Mesh Node [6Mbps is the default for 802.11a]
 * @basic_rates: basic rates to use when creating the mesh
 *
 * These parameters are fixed when the mesh is created.
 */
struct mesh_setup {
	struct cfg80211_chan_def chandef;
	const u8 *mesh_id;
	u8 mesh_id_len;
	u8 sync_method;
	u8 path_sel_proto;
	u8 path_metric;
	u8 auth_id;
	const u8 *ie;
	u8 ie_len;
	bool is_authenticated;
	bool is_secure;
	bool user_mpm;
	u8 dtim_period;
	u16 beacon_interval;
	int mcast_rate[IEEE80211_NUM_BANDS];
	u32 basic_rates;
};

/**
 * struct ocb_setup - 802.11p OCB mode setup configuration
 * @chandef: defines the channel to use
 *
 * These parameters are fixed when connecting to the network
 */
struct ocb_setup {
	struct cfg80211_chan_def chandef;
};

/**
 * struct ieee80211_txq_params - TX queue parameters
 * @ac: AC identifier
 * @txop: Maximum burst time in units of 32 usecs, 0 meaning disabled
 * @cwmin: Minimum contention window [a value of the form 2^n-1 in the range
 *	1..32767]
 * @cwmax: Maximum contention window [a value of the form 2^n-1 in the range
 *	1..32767]
 * @aifs: Arbitration interframe space [0..255]
 */
struct ieee80211_txq_params {
	enum nl80211_ac ac;
	u16 txop;
	u16 cwmin;
	u16 cwmax;
	u8 aifs;
};

/**
 * DOC: Scanning and BSS list handling
 *
 * The scanning process itself is fairly simple, but cfg80211 offers quite
 * a bit of helper functionality. To start a scan, the scan operation will
 * be invoked with a scan definition. This scan definition contains the
 * channels to scan, and the SSIDs to send probe requests for (including the
 * wildcard, if desired). A passive scan is indicated by having no SSIDs to
 * probe. Additionally, a scan request may contain extra information elements
 * that should be added to the probe request. The IEs are guaranteed to be
 * well-formed, and will not exceed the maximum length the driver advertised
 * in the wiphy structure.
 *
 * When scanning finds a BSS, cfg80211 needs to be notified of that, because
 * it is responsible for maintaining the BSS list; the driver should not
 * maintain a list itself. For this notification, various functions exist.
 *
 * Since drivers do not maintain a BSS list, there are also a number of
 * functions to search for a BSS and obtain information about it from the
 * BSS structure cfg80211 maintains. The BSS list is also made available
 * to userspace.
 */

/**
 * struct cfg80211_ssid - SSID description
 * @ssid: the SSID
 * @ssid_len: length of the ssid
 */
struct cfg80211_ssid {
	u8 ssid[IEEE80211_MAX_SSID_LEN];
	u8 ssid_len;
};

/**
 * struct cfg80211_scan_request - scan request description
 *
 * @ssids: SSIDs to scan for (active scan only)
 * @n_ssids: number of SSIDs
 * @channels: channels to scan on.
 * @n_channels: total number of channels to scan
 * @scan_width: channel width for scanning
 * @ie: optional information element(s) to add into Probe Request or %NULL
 * @ie_len: length of ie in octets
 * @flags: bit field of flags controlling operation
 * @rates: bitmap of rates to advertise for each band
 * @wiphy: the wiphy this was for
 * @scan_start: time (in jiffies) when the scan started
 * @wdev: the wireless device to scan for
 * @aborted: (internal) scan request was notified as aborted
 * @notified: (internal) scan request was notified as done or aborted
 * @no_cck: used to send probe requests at non CCK rate in 2GHz band
 * @mac_addr: MAC address used with randomisation
 * @mac_addr_mask: MAC address mask used with randomisation, bits that
 *	are 0 in the mask should be randomised, bits that are 1 should
 *	be taken from the @mac_addr
 */
struct cfg80211_scan_request {
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	enum nl80211_bss_scan_width scan_width;
	const u8 *ie;
	size_t ie_len;
	u32 flags;

	u32 rates[IEEE80211_NUM_BANDS];

	struct wireless_dev *wdev;

	u8 mac_addr[ETH_ALEN] __aligned(2);
	u8 mac_addr_mask[ETH_ALEN] __aligned(2);

	/* internal */
	struct wiphy *wiphy;
	unsigned long scan_start;
	bool aborted, notified;
	bool no_cck;

	/* keep last */
	struct ieee80211_channel *channels[0];
};

static inline void get_random_mask_addr(u8 *buf, const u8 *addr, const u8 *mask)
{
	int i;

	get_random_bytes(buf, ETH_ALEN);
	for (i = 0; i < ETH_ALEN; i++) {
		buf[i] &= ~mask[i];
		buf[i] |= addr[i] & mask[i];
	}
}

/**
 * struct cfg80211_match_set - sets of attributes to match
 *
 * @ssid: SSID to be matched; may be zero-length for no match (RSSI only)
 * @rssi_thold: don't report scan results below this threshold (in s32 dBm)
 */
struct cfg80211_match_set {
	struct cfg80211_ssid ssid;
	s32 rssi_thold;
};

/**
 * struct cfg80211_sched_scan_request - scheduled scan request description
 *
 * @ssids: SSIDs to scan for (passed in the probe_reqs in active scans)
 * @n_ssids: number of SSIDs
 * @n_channels: total number of channels to scan
 * @scan_width: channel width for scanning
 * @interval: interval between each scheduled scan cycle
 * @ie: optional information element(s) to add into Probe Request or %NULL
 * @ie_len: length of ie in octets
 * @flags: bit field of flags controlling operation
 * @match_sets: sets of parameters to be matched for a scan result
 * 	entry to be considered valid and to be passed to the host
 * 	(others are filtered out).
 *	If ommited, all results are passed.
 * @n_match_sets: number of match sets
 * @wiphy: the wiphy this was for
 * @dev: the interface
 * @scan_start: start time of the scheduled scan
 * @channels: channels to scan
 * @min_rssi_thold: for drivers only supporting a single threshold, this
 *	contains the minimum over all matchsets
 * @mac_addr: MAC address used with randomisation
 * @mac_addr_mask: MAC address mask used with randomisation, bits that
 *	are 0 in the mask should be randomised, bits that are 1 should
 *	be taken from the @mac_addr
 * @rcu_head: RCU callback used to free the struct
 * @owner_nlportid: netlink portid of owner (if this should is a request
 *	owned by a particular socket)
 * @delay: delay in seconds to use before starting the first scan
 *	cycle.  The driver may ignore this parameter and start
 *	immediately (or at any other time), if this feature is not
 *	supported.
 */
struct cfg80211_sched_scan_request {
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	enum nl80211_bss_scan_width scan_width;
	u32 interval;
	const u8 *ie;
	size_t ie_len;
	u32 flags;
	struct cfg80211_match_set *match_sets;
	int n_match_sets;
	s32 min_rssi_thold;
	u32 delay;

	u8 mac_addr[ETH_ALEN] __aligned(2);
	u8 mac_addr_mask[ETH_ALEN] __aligned(2);

	/* internal */
	struct wiphy *wiphy;
	struct net_device *dev;
	unsigned long scan_start;
	struct rcu_head rcu_head;
	u32 owner_nlportid;

	/* keep last */
	struct ieee80211_channel *channels[0];
};

/**
 * enum cfg80211_signal_type - signal type
 *
 * @CFG80211_SIGNAL_TYPE_NONE: no signal strength information available
 * @CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)
 * @CFG80211_SIGNAL_TYPE_UNSPEC: signal strength, increasing from 0 through 100
 */
enum cfg80211_signal_type {
	CFG80211_SIGNAL_TYPE_NONE,
	CFG80211_SIGNAL_TYPE_MBM,
	CFG80211_SIGNAL_TYPE_UNSPEC,
};

/**
 * struct cfg80211_bss_ie_data - BSS entry IE data
 * @tsf: TSF contained in the frame that carried these IEs
 * @rcu_head: internal use, for freeing
 * @len: length of the IEs
 * @from_beacon: these IEs are known to come from a beacon
 * @data: IE data
 */
struct cfg80211_bss_ies {
	u64 tsf;
	struct rcu_head rcu_head;
	int len;
	bool from_beacon;
	u8 data[];
};

/**
 * struct cfg80211_bss - BSS description
 *
 * This structure describes a BSS (which may also be a mesh network)
 * for use in scan results and similar.
 *
 * @channel: channel this BSS is on
 * @scan_width: width of the control channel
 * @bssid: BSSID of the BSS
 * @beacon_interval: the beacon interval as from the frame
 * @capability: the capability field in host byte order
 * @ies: the information elements (Note that there is no guarantee that these
 *	are well-formed!); this is a pointer to either the beacon_ies or
 *	proberesp_ies depending on whether Probe Response frame has been
 *	received. It is always non-%NULL.
 * @beacon_ies: the information elements from the last Beacon frame
 *	(implementation note: if @hidden_beacon_bss is set this struct doesn't
 *	own the beacon_ies, but they're just pointers to the ones from the
 *	@hidden_beacon_bss struct)
 * @proberesp_ies: the information elements from the last Probe Response frame
 * @hidden_beacon_bss: in case this BSS struct represents a probe response from
 *	a BSS that hides the SSID in its beacon, this points to the BSS struct
 *	that holds the beacon data. @beacon_ies is still valid, of course, and
 *	points to the same data as hidden_beacon_bss->beacon_ies in that case.
 * @signal: signal strength value (type depends on the wiphy's signal_type)
 * @priv: private area for driver use, has at least wiphy->bss_priv_size bytes
 */
struct cfg80211_bss {
	struct ieee80211_channel *channel;
	enum nl80211_bss_scan_width scan_width;

	const struct cfg80211_bss_ies __rcu *ies;
	const struct cfg80211_bss_ies __rcu *beacon_ies;
	const struct cfg80211_bss_ies __rcu *proberesp_ies;

	struct cfg80211_bss *hidden_beacon_bss;

	s32 signal;

	u16 beacon_interval;
	u16 capability;

	u8 bssid[ETH_ALEN];

	u8 priv[0] __aligned(sizeof(void *));
};

/**
 * ieee80211_bss_get_ie - find IE with given ID
 * @bss: the bss to search
 * @ie: the IE ID
 *
 * Note that the return value is an RCU-protected pointer, so
 * rcu_read_lock() must be held when calling this function.
 * Return: %NULL if not found.
 */
const u8 *ieee80211_bss_get_ie(struct cfg80211_bss *bss, u8 ie);


/**
 * struct cfg80211_auth_request - Authentication request data
 *
 * This structure provides information needed to complete IEEE 802.11
 * authentication.
 *
 * @bss: The BSS to authenticate with, the callee must obtain a reference
 *	to it if it needs to keep it.
 * @auth_type: Authentication type (algorithm)
 * @ie: Extra IEs to add to Authentication frame or %NULL
 * @ie_len: Length of ie buffer in octets
 * @key_len: length of WEP key for shared key authentication
 * @key_idx: index of WEP key for shared key authentication
 * @key: WEP key for shared key authentication
 * @sae_data: Non-IE data to use with SAE or %NULL. This starts with
 *	Authentication transaction sequence number field.
 * @sae_data_len: Length of sae_data buffer in octets
 */
struct cfg80211_auth_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	size_t ie_len;
	enum nl80211_auth_type auth_type;
	const u8 *key;
	u8 key_len, key_idx;
	const u8 *sae_data;
	size_t sae_data_len;
};

/**
 * enum cfg80211_assoc_req_flags - Over-ride default behaviour in association.
 *
 * @ASSOC_REQ_DISABLE_HT:  Disable HT (802.11n)
 * @ASSOC_REQ_DISABLE_VHT:  Disable VHT
 * @ASSOC_REQ_USE_RRM: Declare RRM capability in this association
 */
enum cfg80211_assoc_req_flags {
	ASSOC_REQ_DISABLE_HT		= BIT(0),
	ASSOC_REQ_DISABLE_VHT		= BIT(1),
	ASSOC_REQ_USE_RRM		= BIT(2),
};

/**
 * struct cfg80211_assoc_request - (Re)Association request data
 *
 * This structure provides information needed to complete IEEE 802.11
 * (re)association.
 * @bss: The BSS to associate with. If the call is successful the driver is
 *	given a reference that it must give back to cfg80211_send_rx_assoc()
 *	or to cfg80211_assoc_timeout(). To ensure proper refcounting, new
 *	association requests while already associating must be rejected.
 * @ie: Extra IEs to add to (Re)Association Request frame or %NULL
 * @ie_len: Length of ie buffer in octets
 * @use_mfp: Use management frame protection (IEEE 802.11w) in this association
 * @crypto: crypto settings
 * @prev_bssid: previous BSSID, if not %NULL use reassociate frame
 * @flags:  See &enum cfg80211_assoc_req_flags
 * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask
 *	will be used in ht_capa.  Un-supported values will be ignored.
 * @ht_capa_mask:  The bits of ht_capa which are to be used.
 * @vht_capa: VHT capability override
 * @vht_capa_mask: VHT capability mask indicating which fields to use
 */
struct cfg80211_assoc_request {
	struct cfg80211_bss *bss;
	const u8 *ie, *prev_bssid;
	size_t ie_len;
	struct cfg80211_crypto_settings crypto;
	bool use_mfp;
	u32 flags;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa, vht_capa_mask;
};

/**
 * struct cfg80211_deauth_request - Deauthentication request data
 *
 * This structure provides information needed to complete IEEE 802.11
 * deauthentication.
 *
 * @bssid: the BSSID of the BSS to deauthenticate from
 * @ie: Extra IEs to add to Deauthentication frame or %NULL
 * @ie_len: Length of ie buffer in octets
 * @reason_code: The reason code for the deauthentication
 * @local_state_change: if set, change local state only and
 *	do not set a deauth frame
 */
struct cfg80211_deauth_request {
	const u8 *bssid;
	const u8 *ie;
	size_t ie_len;
	u16 reason_code;
	bool local_state_change;
};

/**
 * struct cfg80211_disassoc_request - Disassociation request data
 *
 * This structure provides information needed to complete IEEE 802.11
 * disassocation.
 *
 * @bss: the BSS to disassociate from
 * @ie: Extra IEs to add to Disassociation frame or %NULL
 * @ie_len: Length of ie buffer in octets
 * @reason_code: The reason code for the disassociation
 * @local_state_change: This is a request for a local state only, i.e., no
 *	Disassociation frame is to be transmitted.
 */
struct cfg80211_disassoc_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	size_t ie_len;
	u16 reason_code;
	bool local_state_change;
};

/**
 * struct cfg80211_ibss_params - IBSS parameters
 *
 * This structure defines the IBSS parameters for the join_ibss()
 * method.
 *
 * @ssid: The SSID, will always be non-null.
 * @ssid_len: The length of the SSID, will always be non-zero.
 * @bssid: Fixed BSSID requested, maybe be %NULL, if set do not
 *	search for IBSSs with a different BSSID.
 * @chandef: defines the channel to use if no other IBSS to join can be found
 * @channel_fixed: The channel should be fixed -- do not search for
 *	IBSSs to join on other channels.
 * @ie: information element(s) to include in the beacon
 * @ie_len: length of that
 * @beacon_interval: beacon interval to use
 * @privacy: this is a protected network, keys will be configured
 *	after joining
 * @control_port: whether user space controls IEEE 802.1X port, i.e.,
 *	sets/clears %NL80211_STA_FLAG_AUTHORIZED. If true, the driver is
 *	required to assume that the port is unauthorized until authorized by
 *	user space. Otherwise, port is marked authorized by default.
 * @userspace_handles_dfs: whether user space controls DFS operation, i.e.
 *	changes the channel when a radar is detected. This is required
 *	to operate on DFS channels.
 * @basic_rates: bitmap of basic rates to use when creating the IBSS
 * @mcast_rate: per-band multicast rate index + 1 (0: disabled)
 * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask
 *	will be used in ht_capa.  Un-supported values will be ignored.
 * @ht_capa_mask:  The bits of ht_capa which are to be used.
 */
struct cfg80211_ibss_params {
	const u8 *ssid;
	const u8 *bssid;
	struct cfg80211_chan_def chandef;
	const u8 *ie;
	u8 ssid_len, ie_len;
	u16 beacon_interval;
	u32 basic_rates;
	bool channel_fixed;
	bool privacy;
	bool control_port;
	bool userspace_handles_dfs;
	int mcast_rate[IEEE80211_NUM_BANDS];
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
};

/**
 * struct cfg80211_connect_params - Connection parameters
 *
 * This structure provides information needed to complete IEEE 802.11
 * authentication and association.
 *
 * @channel: The channel to use or %NULL if not specified (auto-select based
 *	on scan results)
 * @channel_hint: The channel of the recommended BSS for initial connection or
 *	%NULL if not specified
 * @bssid: The AP BSSID or %NULL if not specified (auto-select based on scan
 *	results)
 * @bssid_hint: The recommended AP BSSID for initial connection to the BSS or
 *	%NULL if not specified. Unlike the @bssid parameter, the driver is
 *	allowed to ignore this @bssid_hint if it has knowledge of a better BSS
 *	to use.
 * @ssid: SSID
 * @ssid_len: Length of ssid in octets
 * @auth_type: Authentication type (algorithm)
 * @ie: IEs for association request
 * @ie_len: Length of assoc_ie in octets
 * @privacy: indicates whether privacy-enabled APs should be used
 * @mfp: indicate whether management frame protection is used
 * @crypto: crypto settings
 * @key_len: length of WEP key for shared key authentication
 * @key_idx: index of WEP key for shared key authentication
 * @key: WEP key for shared key authentication
 * @flags:  See &enum cfg80211_assoc_req_flags
 * @bg_scan_period:  Background scan period in seconds
 *	or -1 to indicate that default value is to be used.
 * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask
 *	will be used in ht_capa.  Un-supported values will be ignored.
 * @ht_capa_mask:  The bits of ht_capa which are to be used.
 * @vht_capa:  VHT Capability overrides
 * @vht_capa_mask: The bits of vht_capa which are to be used.
 */
struct cfg80211_connect_params {
	struct ieee80211_channel *channel;
	struct ieee80211_channel *channel_hint;
	const u8 *bssid;
	const u8 *bssid_hint;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_auth_type auth_type;
	const u8 *ie;
	size_t ie_len;
	bool privacy;
	enum nl80211_mfp mfp;
	struct cfg80211_crypto_settings crypto;
	const u8 *key;
	u8 key_len, key_idx;
	u32 flags;
	int bg_scan_period;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
};

/**
 * enum wiphy_params_flags - set_wiphy_params bitfield values
 * @WIPHY_PARAM_RETRY_SHORT: wiphy->retry_short has changed
 * @WIPHY_PARAM_RETRY_LONG: wiphy->retry_long has changed
 * @WIPHY_PARAM_FRAG_THRESHOLD: wiphy->frag_threshold has changed
 * @WIPHY_PARAM_RTS_THRESHOLD: wiphy->rts_threshold has changed
 * @WIPHY_PARAM_COVERAGE_CLASS: coverage class changed
 * @WIPHY_PARAM_DYN_ACK: dynack has been enabled
 */
enum wiphy_params_flags {
	WIPHY_PARAM_RETRY_SHORT		= 1 << 0,
	WIPHY_PARAM_RETRY_LONG		= 1 << 1,
	WIPHY_PARAM_FRAG_THRESHOLD	= 1 << 2,
	WIPHY_PARAM_RTS_THRESHOLD	= 1 << 3,
	WIPHY_PARAM_COVERAGE_CLASS	= 1 << 4,
	WIPHY_PARAM_DYN_ACK		= 1 << 5,
};

/*
 * cfg80211_bitrate_mask - masks for bitrate control
 */
struct cfg80211_bitrate_mask {
	struct {
		u32 legacy;
		u8 ht_mcs[IEEE80211_HT_MCS_MASK_LEN];
		u16 vht_mcs[NL80211_VHT_NSS_MAX];
		enum nl80211_txrate_gi gi;
	} control[IEEE80211_NUM_BANDS];
};
/**
 * struct cfg80211_pmksa - PMK Security Association
 *
 * This structure is passed to the set/del_pmksa() method for PMKSA
 * caching.
 *
 * @bssid: The AP's BSSID.
 * @pmkid: The PMK material itself.
 */
struct cfg80211_pmksa {
	const u8 *bssid;
	const u8 *pmkid;
};

/**
 * struct cfg80211_pkt_pattern - packet pattern
 * @mask: bitmask where to match pattern and where to ignore bytes,
 *	one bit per byte, in same format as nl80211
 * @pattern: bytes to match where bitmask is 1
 * @pattern_len: length of pattern (in bytes)
 * @pkt_offset: packet offset (in bytes)
 *
 * Internal note: @mask and @pattern are allocated in one chunk of
 * memory, free @mask only!
 */
struct cfg80211_pkt_pattern {
	const u8 *mask, *pattern;
	int pattern_len;
	int pkt_offset;
};

/**
 * struct cfg80211_wowlan_tcp - TCP connection parameters
 *
 * @sock: (internal) socket for source port allocation
 * @src: source IP address
 * @dst: destination IP address
 * @dst_mac: destination MAC address
 * @src_port: source port
 * @dst_port: destination port
 * @payload_len: data payload length
 * @payload: data payload buffer
 * @payload_seq: payload sequence stamping configuration
 * @data_interval: interval at which to send data packets
 * @wake_len: wakeup payload match length
 * @wake_data: wakeup payload match data
 * @wake_mask: wakeup payload match mask
 * @tokens_size: length of the tokens buffer
 * @payload_tok: payload token usage configuration
 */
struct cfg80211_wowlan_tcp {
	struct socket *sock;
	__be32 src, dst;
	u16 src_port, dst_port;
	u8 dst_mac[ETH_ALEN];
	int payload_len;
	const u8 *payload;
	struct nl80211_wowlan_tcp_data_seq payload_seq;
	u32 data_interval;
	u32 wake_len;
	const u8 *wake_data, *wake_mask;
	u32 tokens_size;
	/* must be last, variable member */
	struct nl80211_wowlan_tcp_data_token payload_tok;
};

/**
 * struct cfg80211_wowlan - Wake on Wireless-LAN support info
 *
 * This structure defines the enabled WoWLAN triggers for the device.
 * @any: wake up on any activity -- special trigger if device continues
 *	operating as normal during suspend
 * @disconnect: wake up if getting disconnected
 * @magic_pkt: wake up on receiving magic packet
 * @patterns: wake up on receiving packet matching a pattern
 * @n_patterns: number of patterns
 * @gtk_rekey_failure: wake up on GTK rekey failure
 * @eap_identity_req: wake up on EAP identity request packet
 * @four_way_handshake: wake up on 4-way handshake
 * @rfkill_release: wake up when rfkill is released
 * @tcp: TCP connection establishment/wakeup parameters, see nl80211.h.
 *	NULL if not configured.
 * @nd_config: configuration for the scan to be used for net detect wake.
 */
struct cfg80211_wowlan {
	bool any, disconnect, magic_pkt, gtk_rekey_failure,
	     eap_identity_req, four_way_handshake,
	     rfkill_release;
	struct cfg80211_pkt_pattern *patterns;
	struct cfg80211_wowlan_tcp *tcp;
	int n_patterns;
	struct cfg80211_sched_scan_request *nd_config;
};

/**
 * struct cfg80211_coalesce_rules - Coalesce rule parameters
 *
 * This structure defines coalesce rule for the device.
 * @delay: maximum coalescing delay in msecs.
 * @condition: condition for packet coalescence.
 *	see &enum nl80211_coalesce_condition.
 * @patterns: array of packet patterns
 * @n_patterns: number of patterns
 */
struct cfg80211_coalesce_rules {
	int delay;
	enum nl80211_coalesce_condition condition;
	struct cfg80211_pkt_pattern *patterns;
	int n_patterns;
};

/**
 * struct cfg80211_coalesce - Packet coalescing settings
 *
 * This structure defines coalescing settings.
 * @rules: array of coalesce rules
 * @n_rules: number of rules
 */
struct cfg80211_coalesce {
	struct cfg80211_coalesce_rules *rules;
	int n_rules;
};

/**
 * struct cfg80211_wowlan_nd_match - information about the match
 *
 * @ssid: SSID of the match that triggered the wake up
 * @n_channels: Number of channels where the match occurred.  This
 *	value may be zero if the driver can't report the channels.
 * @channels: center frequencies of the channels where a match
 *	occurred (in MHz)
 */
struct cfg80211_wowlan_nd_match {
	struct cfg80211_ssid ssid;
	int n_channels;
	u32 channels[];
};

/**
 * struct cfg80211_wowlan_nd_info - net detect wake up information
 *
 * @n_matches: Number of match information instances provided in
 *	@matches.  This value may be zero if the driver can't provide
 *	match information.
 * @matches: Array of pointers to matches containing information about
 *	the matches that triggered the wake up.
 */
struct cfg80211_wowlan_nd_info {
	int n_matches;
	struct cfg80211_wowlan_nd_match *matches[];
};

/**
 * struct cfg80211_wowlan_wakeup - wakeup report
 * @disconnect: woke up by getting disconnected
 * @magic_pkt: woke up by receiving magic packet
 * @gtk_rekey_failure: woke up by GTK rekey failure
 * @eap_identity_req: woke up by EAP identity request packet
 * @four_way_handshake: woke up by 4-way handshake
 * @rfkill_release: woke up by rfkill being released
 * @pattern_idx: pattern that caused wakeup, -1 if not due to pattern
 * @packet_present_len: copied wakeup packet data
 * @packet_len: original wakeup packet length
 * @packet: The packet causing the wakeup, if any.
 * @packet_80211:  For pattern match, magic packet and other data
 *	frame triggers an 802.3 frame should be reported, for
 *	disconnect due to deauth 802.11 frame. This indicates which
 *	it is.
 * @tcp_match: TCP wakeup packet received
 * @tcp_connlost: TCP connection lost or failed to establish
 * @tcp_nomoretokens: TCP data ran out of tokens
 * @net_detect: if not %NULL, woke up because of net detect
 */
struct cfg80211_wowlan_wakeup {
	bool disconnect, magic_pkt, gtk_rekey_failure,
	     eap_identity_req, four_way_handshake,
	     rfkill_release, packet_80211,
	     tcp_match, tcp_connlost, tcp_nomoretokens;
	s32 pattern_idx;
	u32 packet_present_len, packet_len;
	const void *packet;
	struct cfg80211_wowlan_nd_info *net_detect;
};

/**
 * struct cfg80211_gtk_rekey_data - rekey data
 * @kek: key encryption key (NL80211_KEK_LEN bytes)
 * @kck: key confirmation key (NL80211_KCK_LEN bytes)
 * @replay_ctr: replay counter (NL80211_REPLAY_CTR_LEN bytes)
 */
struct cfg80211_gtk_rekey_data {
	const u8 *kek, *kck, *replay_ctr;
};

/**
 * struct cfg80211_update_ft_ies_params - FT IE Information
 *
 * This structure provides information needed to update the fast transition IE
 *
 * @md: The Mobility Domain ID, 2 Octet value
 * @ie: Fast Transition IEs
 * @ie_len: Length of ft_ie in octets
 */
struct cfg80211_update_ft_ies_params {
	u16 md;
	const u8 *ie;
	size_t ie_len;
};

/**
 * struct cfg80211_mgmt_tx_params - mgmt tx parameters
 *
 * This structure provides information needed to transmit a mgmt frame
 *
 * @chan: channel to use
 * @offchan: indicates wether off channel operation is required
 * @wait: duration for ROC
 * @buf: buffer to transmit
 * @len: buffer length
 * @no_cck: don't use cck rates for this frame
 * @dont_wait_for_ack: tells the low level not to wait for an ack
 * @n_csa_offsets: length of csa_offsets array
 * @csa_offsets: array of all the csa offsets in the frame
 */
struct cfg80211_mgmt_tx_params {
	struct ieee80211_channel *chan;
	bool offchan;
	unsigned int wait;
	const u8 *buf;
	size_t len;
	bool no_cck;
	bool dont_wait_for_ack;
	int n_csa_offsets;
	const u16 *csa_offsets;
};

/**
 * struct cfg80211_dscp_exception - DSCP exception
 *
 * @dscp: DSCP value that does not adhere to the user priority range definition
 * @up: user priority value to which the corresponding DSCP value belongs
 */
struct cfg80211_dscp_exception {
	u8 dscp;
	u8 up;
};

/**
 * struct cfg80211_dscp_range - DSCP range definition for user priority
 *
 * @low: lowest DSCP value of this user priority range, inclusive
 * @high: highest DSCP value of this user priority range, inclusive
 */
struct cfg80211_dscp_range {
	u8 low;
	u8 high;
};

/* QoS Map Set element length defined in IEEE Std 802.11-2012, 8.4.2.97 */
#define IEEE80211_QOS_MAP_MAX_EX	21
#define IEEE80211_QOS_MAP_LEN_MIN	16
#define IEEE80211_QOS_MAP_LEN_MAX \
	(IEEE80211_QOS_MAP_LEN_MIN + 2 * IEEE80211_QOS_MAP_MAX_EX)

/**
 * struct cfg80211_qos_map - QoS Map Information
 *
 * This struct defines the Interworking QoS map setting for DSCP values
 *
 * @num_des: number of DSCP exceptions (0..21)
 * @dscp_exception: optionally up to maximum of 21 DSCP exceptions from
 *	the user priority DSCP range definition
 * @up: DSCP range definition for a particular user priority
 */
struct cfg80211_qos_map {
	u8 num_des;
	struct cfg80211_dscp_exception dscp_exception[IEEE80211_QOS_MAP_MAX_EX];
	struct cfg80211_dscp_range up[8];
};

/**
 * struct cfg80211_ops - backend description for wireless configuration
 *
 * This struct is registered by fullmac card drivers and/or wireless stacks
 * in order to handle configuration requests on their interfaces.
 *
 * All callbacks except where otherwise noted should return 0
 * on success or a negative error code.
 *
 * All operations are currently invoked under rtnl for consistency with the
 * wireless extensions but this is subject to reevaluation as soon as this
 * code is used more widely and we have a first user without wext.
 *
 * @suspend: wiphy device needs to be suspended. The variable @wow will
 *	be %NULL or contain the enabled Wake-on-Wireless triggers that are
 *	configured for the device.
 * @resume: wiphy device needs to be resumed
 * @set_wakeup: Called when WoWLAN is enabled/disabled, use this callback
 *	to call device_set_wakeup_enable() to enable/disable wakeup from
 *	the device.
 *
 * @add_virtual_intf: create a new virtual interface with the given name,
 *	must set the struct wireless_dev's iftype. Beware: You must create
 *	the new netdev in the wiphy's network namespace! Returns the struct
 *	wireless_dev, or an ERR_PTR. For P2P device wdevs, the driver must
 *	also set the address member in the wdev.
 *
 * @del_virtual_intf: remove the virtual interface
 *
 * @change_virtual_intf: change type/configuration of virtual interface,
 *	keep the struct wireless_dev's iftype updated.
 *
 * @add_key: add a key with the given parameters. @mac_addr will be %NULL
 *	when adding a group key.
 *
 * @get_key: get information about the key with the given parameters.
 *	@mac_addr will be %NULL when requesting information for a group
 *	key. All pointers given to the @callback function need not be valid
 *	after it returns. This function should return an error if it is
 *	not possible to retrieve the key, -ENOENT if it doesn't exist.
 *
 * @del_key: remove a key given the @mac_addr (%NULL for a group key)
 *	and @key_index, return -ENOENT if the key doesn't exist.
 *
 * @set_default_key: set the default key on an interface
 *
 * @set_default_mgmt_key: set the default management frame key on an interface
 *
 * @set_rekey_data: give the data necessary for GTK rekeying to the driver
 *
 * @start_ap: Start acting in AP mode defined by the parameters.
 * @change_beacon: Change the beacon parameters for an access point mode
 *	interface. This should reject the call when AP mode wasn't started.
 * @stop_ap: Stop being an AP, including stopping beaconing.
 *
 * @add_station: Add a new station.
 * @del_station: Remove a station
 * @change_station: Modify a given station. Note that flags changes are not much
 *	validated in cfg80211, in particular the auth/assoc/authorized flags
 *	might come to the driver in invalid combinations -- make sure to check
 *	them, also against the existing state! Drivers must call
 *	cfg80211_check_station_change() to validate the information.
 * @get_station: get station information for the station identified by @mac
 * @dump_station: dump station callback -- resume dump at index @idx
 *
 * @add_mpath: add a fixed mesh path
 * @del_mpath: delete a given mesh path
 * @change_mpath: change a given mesh path
 * @get_mpath: get a mesh path for the given parameters
 * @dump_mpath: dump mesh path callback -- resume dump at index @idx
 * @get_mpp: get a mesh proxy path for the given parameters
 * @dump_mpp: dump mesh proxy path callback -- resume dump at index @idx
 * @join_mesh: join the mesh network with the specified parameters
 *	(invoked with the wireless_dev mutex held)
 * @leave_mesh: leave the current mesh network
 *	(invoked with the wireless_dev mutex held)
 *
 * @get_mesh_config: Get the current mesh configuration
 *
 * @update_mesh_config: Update mesh parameters on a running mesh.
 *	The mask is a bitfield which tells us which parameters to
 *	set, and which to leave alone.
 *
 * @change_bss: Modify parameters for a given BSS.
 *
 * @set_txq_params: Set TX queue parameters
 *
 * @libertas_set_mesh_channel: Only for backward compatibility for libertas,
 *	as it doesn't implement join_mesh and needs to set the channel to
 *	join the mesh instead.
 *
 * @set_monitor_channel: Set the monitor mode channel for the device. If other
 *	interfaces are active this callback should reject the configuration.
 *	If no interfaces are active or the device is down, the channel should
 *	be stored for when a monitor interface becomes active.
 *
 * @scan: Request to do a scan. If returning zero, the scan request is given
 *	the driver, and will be valid until passed to cfg80211_scan_done().
 *	For scan results, call cfg80211_inform_bss(); you can call this outside
 *	the scan/scan_done bracket too.
 *
 * @auth: Request to authenticate with the specified peer
 *	(invoked with the wireless_dev mutex held)
 * @assoc: Request to (re)associate with the specified peer
 *	(invoked with the wireless_dev mutex held)
 * @deauth: Request to deauthenticate from the specified peer
 *	(invoked with the wireless_dev mutex held)
 * @disassoc: Request to disassociate from the specified peer
 *	(invoked with the wireless_dev mutex held)
 *
 * @connect: Connect to the ESS with the specified parameters. When connected,
 *	call cfg80211_connect_result() with status code %WLAN_STATUS_SUCCESS.
 *	If the connection fails for some reason, call cfg80211_connect_result()
 *	with the status from the AP.
 *	(invoked with the wireless_dev mutex held)
 * @disconnect: Disconnect from the BSS/ESS.
 *	(invoked with the wireless_dev mutex held)
 *
 * @join_ibss: Join the specified IBSS (or create if necessary). Once done, call
 *	cfg80211_ibss_joined(), also call that function when changing BSSID due
 *	to a merge.
 *	(invoked with the wireless_dev mutex held)
 * @leave_ibss: Leave the IBSS.
 *	(invoked with the wireless_dev mutex held)
 *
 * @set_mcast_rate: Set the specified multicast rate (only if vif is in ADHOC or
 *	MESH mode)
 *
 * @set_wiphy_params: Notify that wiphy parameters have changed;
 *	@changed bitfield (see &enum wiphy_params_flags) describes which values
 *	have changed. The actual parameter values are available in
 *	struct wiphy. If returning an error, no value should be changed.
 *
 * @set_tx_power: set the transmit power according to the parameters,
 *	the power passed is in mBm, to get dBm use MBM_TO_DBM(). The
 *	wdev may be %NULL if power was set for the wiphy, and will
 *	always be %NULL unless the driver supports per-vif TX power
 *	(as advertised by the nl80211 feature flag.)
 * @get_tx_power: store the current TX power into the dbm variable;
 *	return 0 if successful
 *
 * @set_wds_peer: set the WDS peer for a WDS interface
 *
 * @rfkill_poll: polls the hw rfkill line, use cfg80211 reporting
 *	functions to adjust rfkill hw state
 *
 * @dump_survey: get site survey information.
 *
 * @remain_on_channel: Request the driver to remain awake on the specified
 *	channel for the specified duration to complete an off-channel
 *	operation (e.g., public action frame exchange). When the driver is
 *	ready on the requested channel, it must indicate this with an event
 *	notification by calling cfg80211_ready_on_channel().
 * @cancel_remain_on_channel: Cancel an on-going remain-on-channel operation.
 *	This allows the operation to be terminated prior to timeout based on
 *	the duration value.
 * @mgmt_tx: Transmit a management frame.
 * @mgmt_tx_cancel_wait: Cancel the wait time from transmitting a management
 *	frame on another channel
 *
 * @testmode_cmd: run a test mode command; @wdev may be %NULL
 * @testmode_dump: Implement a test mode dump. The cb->args[2] and up may be
 *	used by the function, but 0 and 1 must not be touched. Additionally,
 *	return error codes other than -ENOBUFS and -ENOENT will terminate the
 *	dump and return to userspace with an error, so be careful. If any data
 *	was passed in from userspace then the data/len arguments will be present
 *	and point to the data contained in %NL80211_ATTR_TESTDATA.
 *
 * @set_bitrate_mask: set the bitrate mask configuration
 *
 * @set_pmksa: Cache a PMKID for a BSSID. This is mostly useful for fullmac
 *	devices running firmwares capable of generating the (re) association
 *	RSN IE. It allows for faster roaming between WPA2 BSSIDs.
 * @del_pmksa: Delete a cached PMKID.
 * @flush_pmksa: Flush all cached PMKIDs.
 * @set_power_mgmt: Configure WLAN power management. A timeout value of -1
 *	allows the driver to adjust the dynamic ps timeout value.
 * @set_cqm_rssi_config: Configure connection quality monitor RSSI threshold.
 * @set_cqm_txe_config: Configure connection quality monitor TX error
 *	thresholds.
 * @sched_scan_start: Tell the driver to start a scheduled scan.
 * @sched_scan_stop: Tell the driver to stop an ongoing scheduled scan. This
 *	call must stop the scheduled scan and be ready for starting a new one
 *	before it returns, i.e. @sched_scan_start may be called immediately
 *	after that again and should not fail in that case. The driver should
 *	not call cfg80211_sched_scan_stopped() for a requested stop (when this
 *	method returns 0.)
 *
 * @mgmt_frame_register: Notify driver that a management frame type was
 *	registered. Note that this callback may not sleep, and cannot run
 *	concurrently with itself.
 *
 * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.
 *	Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
 *	reject TX/RX mask combinations they cannot support by returning -EINVAL
 *	(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).
 *
 * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).
 *
 * @tdls_mgmt: Transmit a TDLS management frame.
 * @tdls_oper: Perform a high-level TDLS operation (e.g. TDLS link setup).
 *
 * @probe_client: probe an associated client, must return a cookie that it
 *	later passes to cfg80211_probe_status().
 *
 * @set_noack_map: Set the NoAck Map for the TIDs.
 *
 * @get_channel: Get the current operating channel for the virtual interface.
 *	For monitor interfaces, it should return %NULL unless there's a single
 *	current monitoring channel.
 *
 * @start_p2p_device: Start the given P2P device.
 * @stop_p2p_device: Stop the given P2P device.
 *
 * @set_mac_acl: Sets MAC address control list in AP and P2P GO mode.
 *	Parameters include ACL policy, an array of MAC address of stations
 *	and the number of MAC addresses. If there is already a list in driver
 *	this new list replaces the existing one. Driver has to clear its ACL
 *	when number of MAC addresses entries is passed as 0. Drivers which
 *	advertise the support for MAC based ACL have to implement this callback.
 *
 * @start_radar_detection: Start radar detection in the driver.
 *
 * @update_ft_ies: Provide updated Fast BSS Transition information to the
 *	driver. If the SME is in the driver/firmware, this information can be
 *	used in building Authentication and Reassociation Request frames.
 *
 * @crit_proto_start: Indicates a critical protocol needs more link reliability
 *	for a given duration (milliseconds). The protocol is provided so the
 *	driver can take the most appropriate actions.
 * @crit_proto_stop: Indicates critical protocol no longer needs increased link
 *	reliability. This operation can not fail.
 * @set_coalesce: Set coalesce parameters.
 *
 * @channel_switch: initiate channel-switch procedure (with CSA). Driver is
 *	responsible for veryfing if the switch is possible. Since this is
 *	inherently tricky driver may decide to disconnect an interface later
 *	with cfg80211_stop_iface(). This doesn't mean driver can accept
 *	everything. It should do it's best to verify requests and reject them
 *	as soon as possible.
 *
 * @set_qos_map: Set QoS mapping information to the driver
 *
 * @set_ap_chanwidth: Set the AP (including P2P GO) mode channel width for the
 *	given interface This is used e.g. for dynamic HT 20/40 MHz channel width
 *	changes during the lifetime of the BSS.
 *
 * @add_tx_ts: validate (if admitted_time is 0) or add a TX TS to the device
 *	with the given parameters; action frame exchange has been handled by
 *	userspace so this just has to modify the TX path to take the TS into
 *	account.
 *	If the admitted time is 0 just validate the parameters to make sure
 *	the session can be created at all; it is valid to just always return
 *	success for that but that may result in inefficient behaviour (handshake
 *	with the peer followed by immediate teardown when the addition is later
 *	rejected)
 * @del_tx_ts: remove an existing TX TS
 *
 * @join_ocb: join the OCB network with the specified parameters
 *	(invoked with the wireless_dev mutex held)
 * @leave_ocb: leave the current OCB network
 *	(invoked with the wireless_dev mutex held)
 *
 * @tdls_channel_switch: Start channel-switching with a TDLS peer. The driver
 *	is responsible for continually initiating channel-switching operations
 *	and returning to the base channel for communication with the AP.
 * @tdls_cancel_channel_switch: Stop channel-switching with a TDLS peer. Both
 *	peers must be on the base channel when the call completes.
 */
struct cfg80211_ops {
	int	(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
	int	(*resume)(struct wiphy *wiphy);
	void	(*set_wakeup)(struct wiphy *wiphy, bool enabled);

	struct wireless_dev * (*add_virtual_intf)(struct wiphy *wiphy,
						  const char *name,
						  unsigned char name_assign_type,
						  enum nl80211_iftype type,
						  u32 *flags,
						  struct vif_params *params);
	int	(*del_virtual_intf)(struct wiphy *wiphy,
				    struct wireless_dev *wdev);
	int	(*change_virtual_intf)(struct wiphy *wiphy,
				       struct net_device *dev,
				       enum nl80211_iftype type, u32 *flags,
				       struct vif_params *params);

	int	(*add_key)(struct wiphy *wiphy, struct net_device *netdev,
			   u8 key_index, bool pairwise, const u8 *mac_addr,
			   struct key_params *params);
	int	(*get_key)(struct wiphy *wiphy, struct net_device *netdev,
			   u8 key_index, bool pairwise, const u8 *mac_addr,
			   void *cookie,
			   void (*callback)(void *cookie, struct key_params*));
	int	(*del_key)(struct wiphy *wiphy, struct net_device *netdev,
			   u8 key_index, bool pairwise, const u8 *mac_addr);
	int	(*set_default_key)(struct wiphy *wiphy,
				   struct net_device *netdev,
				   u8 key_index, bool unicast, bool multicast);
	int	(*set_default_mgmt_key)(struct wiphy *wiphy,
					struct net_device *netdev,
					u8 key_index);

	int	(*start_ap)(struct wiphy *wiphy, struct net_device *dev,
			    struct cfg80211_ap_settings *settings);
	int	(*change_beacon)(struct wiphy *wiphy, struct net_device *dev,
				 struct cfg80211_beacon_data *info);
	int	(*stop_ap)(struct wiphy *wiphy, struct net_device *dev);


	int	(*add_station)(struct wiphy *wiphy, struct net_device *dev,
			       const u8 *mac,
			       struct station_parameters *params);
	int	(*del_station)(struct wiphy *wiphy, struct net_device *dev,
			       struct station_del_parameters *params);
	int	(*change_station)(struct wiphy *wiphy, struct net_device *dev,
				  const u8 *mac,
				  struct station_parameters *params);
	int	(*get_station)(struct wiphy *wiphy, struct net_device *dev,
			       const u8 *mac, struct station_info *sinfo);
	int	(*dump_station)(struct wiphy *wiphy, struct net_device *dev,
				int idx, u8 *mac, struct station_info *sinfo);

	int	(*add_mpath)(struct wiphy *wiphy, struct net_device *dev,
			       const u8 *dst, const u8 *next_hop);
	int	(*del_mpath)(struct wiphy *wiphy, struct net_device *dev,
			       const u8 *dst);
	int	(*change_mpath)(struct wiphy *wiphy, struct net_device *dev,
				  const u8 *dst, const u8 *next_hop);
	int	(*get_mpath)(struct wiphy *wiphy, struct net_device *dev,
			     u8 *dst, u8 *next_hop, struct mpath_info *pinfo);
	int	(*dump_mpath)(struct wiphy *wiphy, struct net_device *dev,
			      int idx, u8 *dst, u8 *next_hop,
			      struct mpath_info *pinfo);
	int	(*get_mpp)(struct wiphy *wiphy, struct net_device *dev,
			   u8 *dst, u8 *mpp, struct mpath_info *pinfo);
	int	(*dump_mpp)(struct wiphy *wiphy, struct net_device *dev,
			    int idx, u8 *dst, u8 *mpp,
			    struct mpath_info *pinfo);
	int	(*get_mesh_config)(struct wiphy *wiphy,
				struct net_device *dev,
				struct mesh_config *conf);
	int	(*update_mesh_config)(struct wiphy *wiphy,
				      struct net_device *dev, u32 mask,
				      const struct mesh_config *nconf);
	int	(*join_mesh)(struct wiphy *wiphy, struct net_device *dev,
			     const struct mesh_config *conf,
			     const struct mesh_setup *setup);
	int	(*leave_mesh)(struct wiphy *wiphy, struct net_device *dev);

	int	(*join_ocb)(struct wiphy *wiphy, struct net_device *dev,
			    struct ocb_setup *setup);
	int	(*leave_ocb)(struct wiphy *wiphy, struct net_device *dev);

	int	(*change_bss)(struct wiphy *wiphy, struct net_device *dev,
			      struct bss_parameters *params);

	int	(*set_txq_params)(struct wiphy *wiphy, struct net_device *dev,
				  struct ieee80211_txq_params *params);

	int	(*libertas_set_mesh_channel)(struct wiphy *wiphy,
					     struct net_device *dev,
					     struct ieee80211_channel *chan);

	int	(*set_monitor_channel)(struct wiphy *wiphy,
				       struct cfg80211_chan_def *chandef);

	int	(*scan)(struct wiphy *wiphy,
			struct cfg80211_scan_request *request);

	int	(*auth)(struct wiphy *wiphy, struct net_device *dev,
			struct cfg80211_auth_request *req);
	int	(*assoc)(struct wiphy *wiphy, struct net_device *dev,
			 struct cfg80211_assoc_request *req);
	int	(*deauth)(struct wiphy *wiphy, struct net_device *dev,
			  struct cfg80211_deauth_request *req);
	int	(*disassoc)(struct wiphy *wiphy, struct net_device *dev,
			    struct cfg80211_disassoc_request *req);

	int	(*connect)(struct wiphy *wiphy, struct net_device *dev,
			   struct cfg80211_connect_params *sme);
	int	(*disconnect)(struct wiphy *wiphy, struct net_device *dev,
			      u16 reason_code);

	int	(*join_ibss)(struct wiphy *wiphy, struct net_device *dev,
			     struct cfg80211_ibss_params *params);
	int	(*leave_ibss)(struct wiphy *wiphy, struct net_device *dev);

	int	(*set_mcast_rate)(struct wiphy *wiphy, struct net_device *dev,
				  int rate[IEEE80211_NUM_BANDS]);

	int	(*set_wiphy_params)(struct wiphy *wiphy, u32 changed);

	int	(*set_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
				enum nl80211_tx_power_setting type, int mbm);
	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
				int *dbm);

	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
				const u8 *addr);

	void	(*rfkill_poll)(struct wiphy *wiphy);

#ifdef CONFIG_NL80211_TESTMODE
	int	(*testmode_cmd)(struct wiphy *wiphy, struct wireless_dev *wdev,
				void *data, int len);
	int	(*testmode_dump)(struct wiphy *wiphy, struct sk_buff *skb,
				 struct netlink_callback *cb,
				 void *data, int len);
#endif

	int	(*set_bitrate_mask)(struct wiphy *wiphy,
				    struct net_device *dev,
				    const u8 *peer,
				    const struct cfg80211_bitrate_mask *mask);

	int	(*dump_survey)(struct wiphy *wiphy, struct net_device *netdev,
			int idx, struct survey_info *info);

	int	(*set_pmksa)(struct wiphy *wiphy, struct net_device *netdev,
			     struct cfg80211_pmksa *pmksa);
	int	(*del_pmksa)(struct wiphy *wiphy, struct net_device *netdev,
			     struct cfg80211_pmksa *pmksa);
	int	(*flush_pmksa)(struct wiphy *wiphy, struct net_device *netdev);

	int	(*remain_on_channel)(struct wiphy *wiphy,
				     struct wireless_dev *wdev,
				     struct ieee80211_channel *chan,
				     unsigned int duration,
				     u64 *cookie);
	int	(*cancel_remain_on_channel)(struct wiphy *wiphy,
					    struct wireless_dev *wdev,
					    u64 cookie);

	int	(*mgmt_tx)(struct wiphy *wiphy, struct wireless_dev *wdev,
			   struct cfg80211_mgmt_tx_params *params,
			   u64 *cookie);
	int	(*mgmt_tx_cancel_wait)(struct wiphy *wiphy,
				       struct wireless_dev *wdev,
				       u64 cookie);

	int	(*set_power_mgmt)(struct wiphy *wiphy, struct net_device *dev,
				  bool enabled, int timeout);

	int	(*set_cqm_rssi_config)(struct wiphy *wiphy,
				       struct net_device *dev,
				       s32 rssi_thold, u32 rssi_hyst);

	int	(*set_cqm_txe_config)(struct wiphy *wiphy,
				      struct net_device *dev,
				      u32 rate, u32 pkts, u32 intvl);

	void	(*mgmt_frame_register)(struct wiphy *wiphy,
				       struct wireless_dev *wdev,
				       u16 frame_type, bool reg);

	int	(*set_antenna)(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant);
	int	(*get_antenna)(struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant);

	int	(*sched_scan_start)(struct wiphy *wiphy,
				struct net_device *dev,
				struct cfg80211_sched_scan_request *request);
	int	(*sched_scan_stop)(struct wiphy *wiphy, struct net_device *dev);

	int	(*set_rekey_data)(struct wiphy *wiphy, struct net_device *dev,
				  struct cfg80211_gtk_rekey_data *data);

	int	(*tdls_mgmt)(struct wiphy *wiphy, struct net_device *dev,
			     const u8 *peer, u8 action_code,  u8 dialog_token,
			     u16 status_code, u32 peer_capability,
			     bool initiator, const u8 *buf, size_t len);
	int	(*tdls_oper)(struct wiphy *wiphy, struct net_device *dev,
			     const u8 *peer, enum nl80211_tdls_operation oper);

	int	(*probe_client)(struct wiphy *wiphy, struct net_device *dev,
				const u8 *peer, u64 *cookie);

	int	(*set_noack_map)(struct wiphy *wiphy,
				  struct net_device *dev,
				  u16 noack_map);

	int	(*get_channel)(struct wiphy *wiphy,
			       struct wireless_dev *wdev,
			       struct cfg80211_chan_def *chandef);

	int	(*start_p2p_device)(struct wiphy *wiphy,
				    struct wireless_dev *wdev);
	void	(*stop_p2p_device)(struct wiphy *wiphy,
				   struct wireless_dev *wdev);

	int	(*set_mac_acl)(struct wiphy *wiphy, struct net_device *dev,
			       const struct cfg80211_acl_data *params);

	int	(*start_radar_detection)(struct wiphy *wiphy,
					 struct net_device *dev,
					 struct cfg80211_chan_def *chandef,
					 u32 cac_time_ms);
	int	(*update_ft_ies)(struct wiphy *wiphy, struct net_device *dev,
				 struct cfg80211_update_ft_ies_params *ftie);
	int	(*crit_proto_start)(struct wiphy *wiphy,
				    struct wireless_dev *wdev,
				    enum nl80211_crit_proto_id protocol,
				    u16 duration);
	void	(*crit_proto_stop)(struct wiphy *wiphy,
				   struct wireless_dev *wdev);
	int	(*set_coalesce)(struct wiphy *wiphy,
				struct cfg80211_coalesce *coalesce);

	int	(*channel_switch)(struct wiphy *wiphy,
				  struct net_device *dev,
				  struct cfg80211_csa_settings *params);

	int     (*set_qos_map)(struct wiphy *wiphy,
			       struct net_device *dev,
			       struct cfg80211_qos_map *qos_map);

	int	(*set_ap_chanwidth)(struct wiphy *wiphy, struct net_device *dev,
				    struct cfg80211_chan_def *chandef);

	int	(*add_tx_ts)(struct wiphy *wiphy, struct net_device *dev,
			     u8 tsid, const u8 *peer, u8 user_prio,
			     u16 admitted_time);
	int	(*del_tx_ts)(struct wiphy *wiphy, struct net_device *dev,
			     u8 tsid, const u8 *peer);

	int	(*tdls_channel_switch)(struct wiphy *wiphy,
				       struct net_device *dev,
				       const u8 *addr, u8 oper_class,
				       struct cfg80211_chan_def *chandef);
	void	(*tdls_cancel_channel_switch)(struct wiphy *wiphy,
					      struct net_device *dev,
					      const u8 *addr);
};

/*
 * wireless hardware and networking interfaces structures
 * and registration/helper functions
 */

/**
 * enum wiphy_flags - wiphy capability flags
 *
 * @WIPHY_FLAG_NETNS_OK: if not set, do not allow changing the netns of this
 *	wiphy at all
 * @WIPHY_FLAG_PS_ON_BY_DEFAULT: if set to true, powersave will be enabled
 *	by default -- this flag will be set depending on the kernel's default
 *	on wiphy_new(), but can be changed by the driver if it has a good
 *	reason to override the default
 * @WIPHY_FLAG_4ADDR_AP: supports 4addr mode even on AP (with a single station
 *	on a VLAN interface)
 * @WIPHY_FLAG_4ADDR_STATION: supports 4addr mode even as a station
 * @WIPHY_FLAG_CONTROL_PORT_PROTOCOL: This device supports setting the
 *	control port protocol ethertype. The device also honours the
 *	control_port_no_encrypt flag.
 * @WIPHY_FLAG_IBSS_RSN: The device supports IBSS RSN.
 * @WIPHY_FLAG_MESH_AUTH: The device supports mesh authentication by routing
 *	auth frames to userspace. See @NL80211_MESH_SETUP_USERSPACE_AUTH.
 * @WIPHY_FLAG_SUPPORTS_SCHED_SCAN: The device supports scheduled scans.
 * @WIPHY_FLAG_SUPPORTS_FW_ROAM: The device supports roaming feature in the
 *	firmware.
 * @WIPHY_FLAG_AP_UAPSD: The device supports uapsd on AP.
 * @WIPHY_FLAG_SUPPORTS_TDLS: The device supports TDLS (802.11z) operation.
 * @WIPHY_FLAG_TDLS_EXTERNAL_SETUP: The device does not handle TDLS (802.11z)
 *	link setup/discovery operations internally. Setup, discovery and
 *	teardown packets should be sent through the @NL80211_CMD_TDLS_MGMT
 *	command. When this flag is not set, @NL80211_CMD_TDLS_OPER should be
 *	used for asking the driver/firmware to perform a TDLS operation.
 * @WIPHY_FLAG_HAVE_AP_SME: device integrates AP SME
 * @WIPHY_FLAG_REPORTS_OBSS: the device will report beacons from other BSSes
 *	when there are virtual interfaces in AP mode by calling
 *	cfg80211_report_obss_beacon().
 * @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD: When operating as an AP, the device
 *	responds to probe-requests in hardware.
 * @WIPHY_FLAG_OFFCHAN_TX: Device supports direct off-channel TX.
 * @WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL: Device supports remain-on-channel call.
 * @WIPHY_FLAG_SUPPORTS_5_10_MHZ: Device supports 5 MHz and 10 MHz channels.
 * @WIPHY_FLAG_HAS_CHANNEL_SWITCH: Device supports channel switch in
 *	beaconing mode (AP, IBSS, Mesh, ...).
 */
enum wiphy_flags {
	/* use hole at 0 */
	/* use hole at 1 */
	/* use hole at 2 */
	WIPHY_FLAG_NETNS_OK			= BIT(3),
	WIPHY_FLAG_PS_ON_BY_DEFAULT		= BIT(4),
	WIPHY_FLAG_4ADDR_AP			= BIT(5),
	WIPHY_FLAG_4ADDR_STATION		= BIT(6),
	WIPHY_FLAG_CONTROL_PORT_PROTOCOL	= BIT(7),
	WIPHY_FLAG_IBSS_RSN			= BIT(8),
	WIPHY_FLAG_MESH_AUTH			= BIT(10),
	WIPHY_FLAG_SUPPORTS_SCHED_SCAN		= BIT(11),
	/* use hole at 12 */
	WIPHY_FLAG_SUPPORTS_FW_ROAM		= BIT(13),
	WIPHY_FLAG_AP_UAPSD			= BIT(14),
	WIPHY_FLAG_SUPPORTS_TDLS		= BIT(15),
	WIPHY_FLAG_TDLS_EXTERNAL_SETUP		= BIT(16),
	WIPHY_FLAG_HAVE_AP_SME			= BIT(17),
	WIPHY_FLAG_REPORTS_OBSS			= BIT(18),
	WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD	= BIT(19),
	WIPHY_FLAG_OFFCHAN_TX			= BIT(20),
	WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL	= BIT(21),
	WIPHY_FLAG_SUPPORTS_5_10_MHZ		= BIT(22),
	WIPHY_FLAG_HAS_CHANNEL_SWITCH		= BIT(23),
};

/**
 * struct ieee80211_iface_limit - limit on certain interface types
 * @max: maximum number of interfaces of these types
 * @types: interface types (bits)
 */
struct ieee80211_iface_limit {
	u16 max;
	u16 types;
};

/**
 * struct ieee80211_iface_combination - possible interface combination
 * @limits: limits for the given interface types
 * @n_limits: number of limitations
 * @num_different_channels: can use up to this many different channels
 * @max_interfaces: maximum number of interfaces in total allowed in this
 *	group
 * @beacon_int_infra_match: In this combination, the beacon intervals
 *	between infrastructure and AP types must match. This is required
 *	only in special cases.
 * @radar_detect_widths: bitmap of channel widths supported for radar detection
 * @radar_detect_regions: bitmap of regions supported for radar detection
 *
 * With this structure the driver can describe which interface
 * combinations it supports concurrently.
 *
 * Examples:
 *
 * 1. Allow #STA <= 1, #AP <= 1, matching BI, channels = 1, 2 total:
 *
 *  struct ieee80211_iface_limit limits1[] = {
 *	{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },
 *	{ .max = 1, .types = BIT(NL80211_IFTYPE_AP}, },
 *  };
 *  struct ieee80211_iface_combination combination1 = {
 *	.limits = limits1,
 *	.n_limits = ARRAY_SIZE(limits1),
 *	.max_interfaces = 2,
 *	.beacon_int_infra_match = true,
 *  };
 *
 *
 * 2. Allow #{AP, P2P-GO} <= 8, channels = 1, 8 total:
 *
 *  struct ieee80211_iface_limit limits2[] = {
 *	{ .max = 8, .types = BIT(NL80211_IFTYPE_AP) |
 *			     BIT(NL80211_IFTYPE_P2P_GO), },
 *  };
 *  struct ieee80211_iface_combination combination2 = {
 *	.limits = limits2,
 *	.n_limits = ARRAY_SIZE(limits2),
 *	.max_interfaces = 8,
 *	.num_different_channels = 1,
 *  };
 *
 *
 * 3. Allow #STA <= 1, #{P2P-client,P2P-GO} <= 3 on two channels, 4 total.
 *
 * This allows for an infrastructure connection and three P2P connections.
 *
 *  struct ieee80211_iface_limit limits3[] = {
 *	{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },
 *	{ .max = 3, .types = BIT(NL80211_IFTYPE_P2P_GO) |
 *			     BIT(NL80211_IFTYPE_P2P_CLIENT), },
 *  };
 *  struct ieee80211_iface_combination combination3 = {
 *	.limits = limits3,
 *	.n_limits = ARRAY_SIZE(limits3),
 *	.max_interfaces = 4,
 *	.num_different_channels = 2,
 *  };
 */
struct ieee80211_iface_combination {
	const struct ieee80211_iface_limit *limits;
	u32 num_different_channels;
	u16 max_interfaces;
	u8 n_limits;
	bool beacon_int_infra_match;
	u8 radar_detect_widths;
	u8 radar_detect_regions;
};

struct ieee80211_txrx_stypes {
	u16 tx, rx;
};

/**
 * enum wiphy_wowlan_support_flags - WoWLAN support flags
 * @WIPHY_WOWLAN_ANY: supports wakeup for the special "any"
 *	trigger that keeps the device operating as-is and
 *	wakes up the host on any activity, for example a
 *	received packet that passed filtering; note that the
 *	packet should be preserved in that case
 * @WIPHY_WOWLAN_MAGIC_PKT: supports wakeup on magic packet
 *	(see nl80211.h)
 * @WIPHY_WOWLAN_DISCONNECT: supports wakeup on disconnect
 * @WIPHY_WOWLAN_SUPPORTS_GTK_REKEY: supports GTK rekeying while asleep
 * @WIPHY_WOWLAN_GTK_REKEY_FAILURE: supports wakeup on GTK rekey failure
 * @WIPHY_WOWLAN_EAP_IDENTITY_REQ: supports wakeup on EAP identity request
 * @WIPHY_WOWLAN_4WAY_HANDSHAKE: supports wakeup on 4-way handshake failure
 * @WIPHY_WOWLAN_RFKILL_RELEASE: supports wakeup on RF-kill release
 * @WIPHY_WOWLAN_NET_DETECT: supports wakeup on network detection
 */
enum wiphy_wowlan_support_flags {
	WIPHY_WOWLAN_ANY		= BIT(0),
	WIPHY_WOWLAN_MAGIC_PKT		= BIT(1),
	WIPHY_WOWLAN_DISCONNECT		= BIT(2),
	WIPHY_WOWLAN_SUPPORTS_GTK_REKEY	= BIT(3),
	WIPHY_WOWLAN_GTK_REKEY_FAILURE	= BIT(4),
	WIPHY_WOWLAN_EAP_IDENTITY_REQ	= BIT(5),
	WIPHY_WOWLAN_4WAY_HANDSHAKE	= BIT(6),
	WIPHY_WOWLAN_RFKILL_RELEASE	= BIT(7),
	WIPHY_WOWLAN_NET_DETECT		= BIT(8),
};

struct wiphy_wowlan_tcp_support {
	const struct nl80211_wowlan_tcp_data_token_feature *tok;
	u32 data_payload_max;
	u32 data_interval_max;
	u32 wake_payload_max;
	bool seq;
};

/**
 * struct wiphy_wowlan_support - WoWLAN support data
 * @flags: see &enum wiphy_wowlan_support_flags
 * @n_patterns: number of supported wakeup patterns
 *	(see nl80211.h for the pattern definition)
 * @pattern_max_len: maximum length of each pattern
 * @pattern_min_len: minimum length of each pattern
 * @max_pkt_offset: maximum Rx packet offset
 * @max_nd_match_sets: maximum number of matchsets for net-detect,
 *	similar, but not necessarily identical, to max_match_sets for
 *	scheduled scans.
 *	See &struct cfg80211_sched_scan_request.@match_sets for more
 *	details.
 * @tcp: TCP wakeup support information
 */
struct wiphy_wowlan_support {
	u32 flags;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
	int max_nd_match_sets;
	const struct wiphy_wowlan_tcp_support *tcp;
};

/**
 * struct wiphy_coalesce_support - coalesce support data
 * @n_rules: maximum number of coalesce rules
 * @max_delay: maximum supported coalescing delay in msecs
 * @n_patterns: number of supported patterns in a rule
 *	(see nl80211.h for the pattern definition)
 * @pattern_max_len: maximum length of each pattern
 * @pattern_min_len: minimum length of each pattern
 * @max_pkt_offset: maximum Rx packet offset
 */
struct wiphy_coalesce_support {
	int n_rules;
	int max_delay;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
};

/**
 * enum wiphy_vendor_command_flags - validation flags for vendor commands
 * @WIPHY_VENDOR_CMD_NEED_WDEV: vendor command requires wdev
 * @WIPHY_VENDOR_CMD_NEED_NETDEV: vendor command requires netdev
 * @WIPHY_VENDOR_CMD_NEED_RUNNING: interface/wdev must be up & running
 *	(must be combined with %_WDEV or %_NETDEV)
 */
enum wiphy_vendor_command_flags {
	WIPHY_VENDOR_CMD_NEED_WDEV = BIT(0),
	WIPHY_VENDOR_CMD_NEED_NETDEV = BIT(1),
	WIPHY_VENDOR_CMD_NEED_RUNNING = BIT(2),
};

/**
 * struct wiphy_vendor_command - vendor command definition
 * @info: vendor command identifying information, as used in nl80211
 * @flags: flags, see &enum wiphy_vendor_command_flags
 * @doit: callback for the operation, note that wdev is %NULL if the
 *	flags didn't ask for a wdev and non-%NULL otherwise; the data
 *	pointer may be %NULL if userspace provided no data at all
 */
struct wiphy_vendor_command {
	struct nl80211_vendor_cmd_info info;
	u32 flags;
	int (*doit)(struct wiphy *wiphy, struct wireless_dev *wdev,
		    const void *data, int data_len);
};

/**
 * struct wiphy - wireless hardware description
 * @reg_notifier: the driver's regulatory notification callback,
 *	note that if your driver uses wiphy_apply_custom_regulatory()
 *	the reg_notifier's request can be passed as NULL
 * @regd: the driver's regulatory domain, if one was requested via
 * 	the regulatory_hint() API. This can be used by the driver
 *	on the reg_notifier() if it chooses to ignore future
 *	regulatory domain changes caused by other drivers.
 * @signal_type: signal type reported in &struct cfg80211_bss.
 * @cipher_suites: supported cipher suites
 * @n_cipher_suites: number of supported cipher suites
 * @retry_short: Retry limit for short frames (dot11ShortRetryLimit)
 * @retry_long: Retry limit for long frames (dot11LongRetryLimit)
 * @frag_threshold: Fragmentation threshold (dot11FragmentationThreshold);
 *	-1 = fragmentation disabled, only odd values >= 256 used
 * @rts_threshold: RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled
 * @_net: the network namespace this wiphy currently lives in
 * @perm_addr: permanent MAC address of this device
 * @addr_mask: If the device supports multiple MAC addresses by masking,
 *	set this to a mask with variable bits set to 1, e.g. if the last
 *	four bits are variable then set it to 00-00-00-00-00-0f. The actual
 *	variable bits shall be determined by the interfaces added, with
 *	interfaces not matching the mask being rejected to be brought up.
 * @n_addresses: number of addresses in @addresses.
 * @addresses: If the device has more than one address, set this pointer
 *	to a list of addresses (6 bytes each). The first one will be used
 *	by default for perm_addr. In this case, the mask should be set to
 *	all-zeroes. In this case it is assumed that the device can handle
 *	the same number of arbitrary MAC addresses.
 * @registered: protects ->resume and ->suspend sysfs callbacks against
 *	unregister hardware
 * @debugfsdir: debugfs directory used for this wiphy, will be renamed
 *	automatically on wiphy renames
 * @dev: (virtual) struct device for this wiphy
 * @registered: helps synchronize suspend/resume with wiphy unregister
 * @wext: wireless extension handlers
 * @priv: driver private data (sized according to wiphy_new() parameter)
 * @interface_modes: bitmask of interfaces types valid for this wiphy,
 *	must be set by driver
 * @iface_combinations: Valid interface combinations array, should not
 *	list single interface types.
 * @n_iface_combinations: number of entries in @iface_combinations array.
 * @software_iftypes: bitmask of software interface types, these are not
 *	subject to any restrictions since they are purely managed in SW.
 * @flags: wiphy flags, see &enum wiphy_flags
 * @regulatory_flags: wiphy regulatory flags, see
 *	&enum ieee80211_regulatory_flags
 * @features: features advertised to nl80211, see &enum nl80211_feature_flags.
 * @ext_features: extended features advertised to nl80211, see
 *	&enum nl80211_ext_feature_index.
 * @bss_priv_size: each BSS struct has private data allocated with it,
 *	this variable determines its size
 * @max_scan_ssids: maximum number of SSIDs the device can scan for in
 *	any given scan
 * @max_sched_scan_ssids: maximum number of SSIDs the device can scan
 *	for in any given scheduled scan
 * @max_match_sets: maximum number of match sets the device can handle
 *	when performing a scheduled scan, 0 if filtering is not
 *	supported.
 * @max_scan_ie_len: maximum length of user-controlled IEs device can
 *	add to probe request frames transmitted during a scan, must not
 *	include fixed IEs like supported rates
 * @max_sched_scan_ie_len: same as max_scan_ie_len, but for scheduled
 *	scans
 * @coverage_class: current coverage class
 * @fw_version: firmware version for ethtool reporting
 * @hw_version: hardware version for ethtool reporting
 * @max_num_pmkids: maximum number of PMKIDs supported by device
 * @privid: a pointer that drivers can use to identify if an arbitrary
 *	wiphy is theirs, e.g. in global notifiers
 * @bands: information about bands/channels supported by this device
 *
 * @mgmt_stypes: bitmasks of frame subtypes that can be subscribed to or
 *	transmitted through nl80211, points to an array indexed by interface
 *	type
 *
 * @available_antennas_tx: bitmap of antennas which are available to be
 *	configured as TX antennas. Antenna configuration commands will be
 *	rejected unless this or @available_antennas_rx is set.
 *
 * @available_antennas_rx: bitmap of antennas which are available to be
 *	configured as RX antennas. Antenna configuration commands will be
 *	rejected unless this or @available_antennas_tx is set.
 *
 * @probe_resp_offload:
 *	 Bitmap of supported protocols for probe response offloading.
 *	 See &enum nl80211_probe_resp_offload_support_attr. Only valid
 *	 when the wiphy flag @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD is set.
 *
 * @max_remain_on_channel_duration: Maximum time a remain-on-channel operation
 *	may request, if implemented.
 *
 * @wowlan: WoWLAN support information
 * @wowlan_config: current WoWLAN configuration; this should usually not be
 *	used since access to it is necessarily racy, use the parameter passed
 *	to the suspend() operation instead.
 *
 * @ap_sme_capa: AP SME capabilities, flags from &enum nl80211_ap_sme_features.
 * @ht_capa_mod_mask:  Specify what ht_cap values can be over-ridden.
 *	If null, then none can be over-ridden.
 * @vht_capa_mod_mask:  Specify what VHT capabilities can be over-ridden.
 *	If null, then none can be over-ridden.
 *
 * @max_acl_mac_addrs: Maximum number of MAC addresses that the device
 *	supports for ACL.
 *
 * @extended_capabilities: extended capabilities supported by the driver,
 *	additional capabilities might be supported by userspace; these are
 *	the 802.11 extended capabilities ("Extended Capabilities element")
 *	and are in the same format as in the information element. See
 *	802.11-2012 8.4.2.29 for the defined fields.
 * @extended_capabilities_mask: mask of the valid values
 * @extended_capabilities_len: length of the extended capabilities
 * @coalesce: packet coalescing support information
 *
 * @vendor_commands: array of vendor commands supported by the hardware
 * @n_vendor_commands: number of vendor commands
 * @vendor_events: array of vendor events supported by the hardware
 * @n_vendor_events: number of vendor events
 *
 * @max_ap_assoc_sta: maximum number of associated stations supported in AP mode
 *	(including P2P GO) or 0 to indicate no such limit is advertised. The
 *	driver is allowed to advertise a theoretical limit that it can reach in
 *	some cases, but may not always reach.
 *
 * @max_num_csa_counters: Number of supported csa_counters in beacons
 *	and probe responses.  This value should be set if the driver
 *	wishes to limit the number of csa counters. Default (0) means
 *	infinite.
 * @max_adj_channel_rssi_comp: max offset of between the channel on which the
 *	frame was sent and the channel on which the frame was heard for which
 *	the reported rssi is still valid. If a driver is able to compensate the
 *	low rssi when a frame is heard on different channel, then it should set
 *	this variable to the maximal offset for which it can compensate.
 *	This value should be set in MHz.
 */
struct wiphy {
	/* assign these fields before you register the wiphy */

	/* permanent MAC address(es) */
	u8 perm_addr[ETH_ALEN];
	u8 addr_mask[ETH_ALEN];

	struct mac_address *addresses;

	const struct ieee80211_txrx_stypes *mgmt_stypes;

	const struct ieee80211_iface_combination *iface_combinations;
	int n_iface_combinations;
	u16 software_iftypes;

	u16 n_addresses;

	/* Supported interface modes, OR together BIT(NL80211_IFTYPE_...) */
	u16 interface_modes;

	u16 max_acl_mac_addrs;

	u32 flags, regulatory_flags, features;
	u8 ext_features[DIV_ROUND_UP(NUM_NL80211_EXT_FEATURES, 8)];

	u32 ap_sme_capa;

	enum cfg80211_signal_type signal_type;

	int bss_priv_size;
	u8 max_scan_ssids;
	u8 max_sched_scan_ssids;
	u8 max_match_sets;
	u16 max_scan_ie_len;
	u16 max_sched_scan_ie_len;

	int n_cipher_suites;
	const u32 *cipher_suites;

	u8 retry_short;
	u8 retry_long;
	u32 frag_threshold;
	u32 rts_threshold;
	u8 coverage_class;

	char fw_version[ETHTOOL_FWVERS_LEN];
	u32 hw_version;

#ifdef CONFIG_PM
	const struct wiphy_wowlan_support *wowlan;
	struct cfg80211_wowlan *wowlan_config;
#endif

	u16 max_remain_on_channel_duration;

	u8 max_num_pmkids;

	u32 available_antennas_tx;
	u32 available_antennas_rx;

	/*
	 * Bitmap of supported protocols for probe response offloading
	 * see &enum nl80211_probe_resp_offload_support_attr. Only valid
	 * when the wiphy flag @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD is set.
	 */
	u32 probe_resp_offload;

	const u8 *extended_capabilities, *extended_capabilities_mask;
	u8 extended_capabilities_len;

	/* If multiple wiphys are registered and you're handed e.g.
	 * a regular netdev with assigned ieee80211_ptr, you won't
	 * know whether it points to a wiphy your driver has registered
	 * or not. Assign this to something global to your driver to
	 * help determine whether you own this wiphy or not. */
	const void *privid;

	struct ieee80211_supported_band *bands[IEEE80211_NUM_BANDS];

	/* Lets us get back the wiphy on the callback */
	void (*reg_notifier)(struct wiphy *wiphy,
			     struct regulatory_request *request);

	/* fields below are read-only, assigned by cfg80211 */

	const struct ieee80211_regdomain __rcu *regd;

	/* the item in /sys/class/ieee80211/ points to this,
	 * you need use set_wiphy_dev() (see below) */
	struct device dev;

	/* protects ->resume, ->suspend sysfs callbacks against unregister hw */
	bool registered;

	/* dir in debugfs: ieee80211/<wiphyname> */
	struct dentry *debugfsdir;

	const struct ieee80211_ht_cap *ht_capa_mod_mask;
	const struct ieee80211_vht_cap *vht_capa_mod_mask;

	/* the network namespace this phy lives in currently */
	possible_net_t _net;

#ifdef CONFIG_CFG80211_WEXT
	const struct iw_handler_def *wext;
#endif

	const struct wiphy_coalesce_support *coalesce;

	const struct wiphy_vendor_command *vendor_commands;
	const struct nl80211_vendor_cmd_info *vendor_events;
	int n_vendor_commands, n_vendor_events;

	u16 max_ap_assoc_sta;

	u8 max_num_csa_counters;
	u8 max_adj_channel_rssi_comp;

	char priv[0] __aligned(NETDEV_ALIGN);
};

static inline struct net *wiphy_net(struct wiphy *wiphy)
{
	return read_pnet(&wiphy->_net);
}

static inline void wiphy_net_set(struct wiphy *wiphy, struct net *net)
{
	write_pnet(&wiphy->_net, net);
}

/**
 * wiphy_priv - return priv from wiphy
 *
 * @wiphy: the wiphy whose priv pointer to return
 * Return: The priv of @wiphy.
 */
static inline void *wiphy_priv(struct wiphy *wiphy)
{
	BUG_ON(!wiphy);
	return &wiphy->priv;
}

/**
 * priv_to_wiphy - return the wiphy containing the priv
 *
 * @priv: a pointer previously returned by wiphy_priv
 * Return: The wiphy of @priv.
 */
static inline struct wiphy *priv_to_wiphy(void *priv)
{
	BUG_ON(!priv);
	return container_of(priv, struct wiphy, priv);
}

/**
 * set_wiphy_dev - set device pointer for wiphy
 *
 * @wiphy: The wiphy whose device to bind
 * @dev: The device to parent it to
 */
static inline void set_wiphy_dev(struct wiphy *wiphy, struct device *dev)
{
	wiphy->dev.parent = dev;
}

/**
 * wiphy_dev - get wiphy dev pointer
 *
 * @wiphy: The wiphy whose device struct to look up
 * Return: The dev of @wiphy.
 */
static inline struct device *wiphy_dev(struct wiphy *wiphy)
{
	return wiphy->dev.parent;
}

/**
 * wiphy_name - get wiphy name
 *
 * @wiphy: The wiphy whose name to return
 * Return: The name of @wiphy.
 */
static inline const char *wiphy_name(const struct wiphy *wiphy)
{
	return dev_name(&wiphy->dev);
}

/**
 * wiphy_new_nm - create a new wiphy for use with cfg80211
 *
 * @ops: The configuration operations for this device
 * @sizeof_priv: The size of the private area to allocate
 * @requested_name: Request a particular name.
 *	NULL is valid value, and means use the default phy%d naming.
 *
 * Create a new wiphy and associate the given operations with it.
 * @sizeof_priv bytes are allocated for private use.
 *
 * Return: A pointer to the new wiphy. This pointer must be
 * assigned to each netdev's ieee80211_ptr for proper operation.
 */
struct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,
			   const char *requested_name);

/**
 * wiphy_new - create a new wiphy for use with cfg80211
 *
 * @ops: The configuration operations for this device
 * @sizeof_priv: The size of the private area to allocate
 *
 * Create a new wiphy and associate the given operations with it.
 * @sizeof_priv bytes are allocated for private use.
 *
 * Return: A pointer to the new wiphy. This pointer must be
 * assigned to each netdev's ieee80211_ptr for proper operation.
 */
static inline struct wiphy *wiphy_new(const struct cfg80211_ops *ops,
				      int sizeof_priv)
{
	return wiphy_new_nm(ops, sizeof_priv, NULL);
}

/**
 * wiphy_register - register a wiphy with cfg80211
 *
 * @wiphy: The wiphy to register.
 *
 * Return: A non-negative wiphy index or a negative error code.
 */
int wiphy_register(struct wiphy *wiphy);

/**
 * wiphy_unregister - deregister a wiphy from cfg80211
 *
 * @wiphy: The wiphy to unregister.
 *
 * After this call, no more requests can be made with this priv
 * pointer, but the call may sleep to wait for an outstanding
 * request that is being handled.
 */
void wiphy_unregister(struct wiphy *wiphy);

/**
 * wiphy_free - free wiphy
 *
 * @wiphy: The wiphy to free
 */
void wiphy_free(struct wiphy *wiphy);

/* internal structs */
struct cfg80211_conn;
struct cfg80211_internal_bss;
struct cfg80211_cached_keys;

/**
 * struct wireless_dev - wireless device state
 *
 * For netdevs, this structure must be allocated by the driver
 * that uses the ieee80211_ptr field in struct net_device (this
 * is intentional so it can be allocated along with the netdev.)
 * It need not be registered then as netdev registration will
 * be intercepted by cfg80211 to see the new wireless device.
 *
 * For non-netdev uses, it must also be allocated by the driver
 * in response to the cfg80211 callbacks that require it, as
 * there's no netdev registration in that case it may not be
 * allocated outside of callback operations that return it.
 *
 * @wiphy: pointer to hardware description
 * @iftype: interface type
 * @list: (private) Used to collect the interfaces
 * @netdev: (private) Used to reference back to the netdev, may be %NULL
 * @identifier: (private) Identifier used in nl80211 to identify this
 *	wireless device if it has no netdev
 * @current_bss: (private) Used by the internal configuration code
 * @chandef: (private) Used by the internal configuration code to track
 *	the user-set channel definition.
 * @preset_chandef: (private) Used by the internal configuration code to
 *	track the channel to be used for AP later
 * @bssid: (private) Used by the internal configuration code
 * @ssid: (private) Used by the internal configuration code
 * @ssid_len: (private) Used by the internal configuration code
 * @mesh_id_len: (private) Used by the internal configuration code
 * @mesh_id_up_len: (private) Used by the internal configuration code
 * @wext: (private) Used by the internal wireless extensions compat code
 * @use_4addr: indicates 4addr mode is used on this interface, must be
 *	set by driver (if supported) on add_interface BEFORE registering the
 *	netdev and may otherwise be used by driver read-only, will be update
 *	by cfg80211 on change_interface
 * @mgmt_registrations: list of registrations for management frames
 * @mgmt_registrations_lock: lock for the list
 * @mtx: mutex used to lock data in this struct, may be used by drivers
 *	and some API functions require it held
 * @beacon_interval: beacon interval used on this device for transmitting
 *	beacons, 0 when not valid
 * @address: The address for this device, valid only if @netdev is %NULL
 * @p2p_started: true if this is a P2P Device that has been started
 * @cac_started: true if DFS channel availability check has been started
 * @cac_start_time: timestamp (jiffies) when the dfs state was entered.
 * @cac_time_ms: CAC time in ms
 * @ps: powersave mode is enabled
 * @ps_timeout: dynamic powersave timeout
 * @ap_unexpected_nlportid: (private) netlink port ID of application
 *	registered for unexpected class 3 frames (AP mode)
 * @conn: (private) cfg80211 software SME connection state machine data
 * @connect_keys: (private) keys to set after connection is established
 * @ibss_fixed: (private) IBSS is using fixed BSSID
 * @ibss_dfs_possible: (private) IBSS may change to a DFS channel
 * @event_list: (private) list for internal event processing
 * @event_lock: (private) lock for event list
 * @owner_nlportid: (private) owner socket port ID
 */
struct wireless_dev {
	struct wiphy *wiphy;
	enum nl80211_iftype iftype;

	/* the remainder of this struct should be private to cfg80211 */
	struct list_head list;
	struct net_device *netdev;

	u32 identifier;

	struct list_head mgmt_registrations;
	spinlock_t mgmt_registrations_lock;

	struct mutex mtx;

	bool use_4addr, p2p_started;

	u8 address[ETH_ALEN] __aligned(sizeof(u16));

	/* currently used for IBSS and SME - might be rearranged later */
	u8 ssid[IEEE80211_MAX_SSID_LEN];
	u8 ssid_len, mesh_id_len, mesh_id_up_len;
	struct cfg80211_conn *conn;
	struct cfg80211_cached_keys *connect_keys;

	struct list_head event_list;
	spinlock_t event_lock;

	struct cfg80211_internal_bss *current_bss; /* associated / joined */
	struct cfg80211_chan_def preset_chandef;
	struct cfg80211_chan_def chandef;

	bool ibss_fixed;
	bool ibss_dfs_possible;

	bool ps;
	int ps_timeout;

	int beacon_interval;

	u32 ap_unexpected_nlportid;

	bool cac_started;
	unsigned long cac_start_time;
	unsigned int cac_time_ms;

	u32 owner_nlportid;

#ifdef CONFIG_CFG80211_WEXT
	/* wext data */
	struct {
		struct cfg80211_ibss_params ibss;
		struct cfg80211_connect_params connect;
		struct cfg80211_cached_keys *keys;
		const u8 *ie;
		size_t ie_len;
		u8 bssid[ETH_ALEN], prev_bssid[ETH_ALEN];
		u8 ssid[IEEE80211_MAX_SSID_LEN];
		s8 default_key, default_mgmt_key;
		bool prev_bssid_valid;
	} wext;
#endif
};

static inline u8 *wdev_address(struct wireless_dev *wdev)
{
	if (wdev->netdev)
		return wdev->netdev->dev_addr;
	return wdev->address;
}

/**
 * wdev_priv - return wiphy priv from wireless_dev
 *
 * @wdev: The wireless device whose wiphy's priv pointer to return
 * Return: The wiphy priv of @wdev.
 */
static inline void *wdev_priv(struct wireless_dev *wdev)
{
	BUG_ON(!wdev);
	return wiphy_priv(wdev->wiphy);
}

/**
 * DOC: Utility functions
 *
 * cfg80211 offers a number of utility functions that can be useful.
 */

/**
 * ieee80211_channel_to_frequency - convert channel number to frequency
 * @chan: channel number
 * @band: band, necessary due to channel number overlap
 * Return: The corresponding frequency (in MHz), or 0 if the conversion failed.
 */
int ieee80211_channel_to_frequency(int chan, enum ieee80211_band band);

/**
 * ieee80211_frequency_to_channel - convert frequency to channel number
 * @freq: center frequency
 * Return: The corresponding channel, or 0 if the conversion failed.
 */
int ieee80211_frequency_to_channel(int freq);

/*
 * Name indirection necessary because the ieee80211 code also has
 * a function named "ieee80211_get_channel", so if you include
 * cfg80211's header file you get cfg80211's version, if you try
 * to include both header files you'll (rightfully!) get a symbol
 * clash.
 */
struct ieee80211_channel *__ieee80211_get_channel(struct wiphy *wiphy,
						  int freq);
/**
 * ieee80211_get_channel - get channel struct from wiphy for specified frequency
 * @wiphy: the struct wiphy to get the channel for
 * @freq: the center frequency of the channel
 * Return: The channel struct from @wiphy at @freq.
 */
static inline struct ieee80211_channel *
ieee80211_get_channel(struct wiphy *wiphy, int freq)
{
	return __ieee80211_get_channel(wiphy, freq);
}

/**
 * ieee80211_get_response_rate - get basic rate for a given rate
 *
 * @sband: the band to look for rates in
 * @basic_rates: bitmap of basic rates
 * @bitrate: the bitrate for which to find the basic rate
 *
 * Return: The basic rate corresponding to a given bitrate, that
 * is the next lower bitrate contained in the basic rate map,
 * which is, for this function, given as a bitmap of indices of
 * rates in the band's bitrate table.
 */
struct ieee80211_rate *
ieee80211_get_response_rate(struct ieee80211_supported_band *sband,
			    u32 basic_rates, int bitrate);

/**
 * ieee80211_mandatory_rates - get mandatory rates for a given band
 * @sband: the band to look for rates in
 * @scan_width: width of the control channel
 *
 * This function returns a bitmap of the mandatory rates for the given
 * band, bits are set according to the rate position in the bitrates array.
 */
u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,
			      enum nl80211_bss_scan_width scan_width);

/*
 * Radiotap parsing functions -- for controlled injection support
 *
 * Implemented in net/wireless/radiotap.c
 * Documentation in Documentation/networking/radiotap-headers.txt
 */

struct radiotap_align_size {
	uint8_t align:4, size:4;
};

struct ieee80211_radiotap_namespace {
	const struct radiotap_align_size *align_size;
	int n_bits;
	uint32_t oui;
	uint8_t subns;
};

struct ieee80211_radiotap_vendor_namespaces {
	const struct ieee80211_radiotap_namespace *ns;
	int n_ns;
};

/**
 * struct ieee80211_radiotap_iterator - tracks walk thru present radiotap args
 * @this_arg_index: index of current arg, valid after each successful call
 *	to ieee80211_radiotap_iterator_next()
 * @this_arg: pointer to current radiotap arg; it is valid after each
 *	call to ieee80211_radiotap_iterator_next() but also after
 *	ieee80211_radiotap_iterator_init() where it will point to
 *	the beginning of the actual data portion
 * @this_arg_size: length of the current arg, for convenience
 * @current_namespace: pointer to the current namespace definition
 *	(or internally %NULL if the current namespace is unknown)
 * @is_radiotap_ns: indicates whether the current namespace is the default
 *	radiotap namespace or not
 *
 * @_rtheader: pointer to the radiotap header we are walking through
 * @_max_length: length of radiotap header in cpu byte ordering
 * @_arg_index: next argument index
 * @_arg: next argument pointer
 * @_next_bitmap: internal pointer to next present u32
 * @_bitmap_shifter: internal shifter for curr u32 bitmap, b0 set == arg present
 * @_vns: vendor namespace definitions
 * @_next_ns_data: beginning of the next namespace's data
 * @_reset_on_ext: internal; reset the arg index to 0 when going to the
 *	next bitmap word
 *
 * Describes the radiotap parser state. Fields prefixed with an underscore
 * must not be used by users of the parser, only by the parser internally.
 */

struct ieee80211_radiotap_iterator {
	struct ieee80211_radiotap_header *_rtheader;
	const struct ieee80211_radiotap_vendor_namespaces *_vns;
	const struct ieee80211_radiotap_namespace *current_namespace;

	unsigned char *_arg, *_next_ns_data;
	__le32 *_next_bitmap;

	unsigned char *this_arg;
	int this_arg_index;
	int this_arg_size;

	int is_radiotap_ns;

	int _max_length;
	int _arg_index;
	uint32_t _bitmap_shifter;
	int _reset_on_ext;
};

int
ieee80211_radiotap_iterator_init(struct ieee80211_radiotap_iterator *iterator,
				 struct ieee80211_radiotap_header *radiotap_header,
				 int max_length,
				 const struct ieee80211_radiotap_vendor_namespaces *vns);

int
ieee80211_radiotap_iterator_next(struct ieee80211_radiotap_iterator *iterator);


extern const unsigned char rfc1042_header[6];
extern const unsigned char bridge_tunnel_header[6];

/**
 * ieee80211_get_hdrlen_from_skb - get header length from data
 *
 * @skb: the frame
 *
 * Given an skb with a raw 802.11 header at the data pointer this function
 * returns the 802.11 header length.
 *
 * Return: The 802.11 header length in bytes (not including encryption
 * headers). Or 0 if the data in the sk_buff is too short to contain a valid
 * 802.11 header.
 */
unsigned int ieee80211_get_hdrlen_from_skb(const struct sk_buff *skb);

/**
 * ieee80211_hdrlen - get header length in bytes from frame control
 * @fc: frame control field in little-endian format
 * Return: The header length in bytes.
 */
unsigned int __attribute_const__ ieee80211_hdrlen(__le16 fc);

/**
 * ieee80211_get_mesh_hdrlen - get mesh extension header length
 * @meshhdr: the mesh extension header, only the flags field
 *	(first byte) will be accessed
 * Return: The length of the extension header, which is always at
 * least 6 bytes and at most 18 if address 5 and 6 are present.
 */
unsigned int ieee80211_get_mesh_hdrlen(struct ieee80211s_hdr *meshhdr);

/**
 * DOC: Data path helpers
 *
 * In addition to generic utilities, cfg80211 also offers
 * functions that help implement the data path for devices
 * that do not do the 802.11/802.3 conversion on the device.
 */

/**
 * ieee80211_data_to_8023 - convert an 802.11 data frame to 802.3
 * @skb: the 802.11 data frame
 * @addr: the device MAC address
 * @iftype: the virtual interface type
 * Return: 0 on success. Non-zero on error.
 */
int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
			   enum nl80211_iftype iftype);

/**
 * ieee80211_data_from_8023 - convert an 802.3 frame to 802.11
 * @skb: the 802.3 frame
 * @addr: the device MAC address
 * @iftype: the virtual interface type
 * @bssid: the network bssid (used only for iftype STATION and ADHOC)
 * @qos: build 802.11 QoS data frame
 * Return: 0 on success, or a negative error code.
 */
int ieee80211_data_from_8023(struct sk_buff *skb, const u8 *addr,
			     enum nl80211_iftype iftype, const u8 *bssid,
			     bool qos);

/**
 * ieee80211_amsdu_to_8023s - decode an IEEE 802.11n A-MSDU frame
 *
 * Decode an IEEE 802.11n A-MSDU frame and convert it to a list of
 * 802.3 frames. The @list will be empty if the decode fails. The
 * @skb is consumed after the function returns.
 *
 * @skb: The input IEEE 802.11n A-MSDU frame.
 * @list: The output list of 802.3 frames. It must be allocated and
 *	initialized by by the caller.
 * @addr: The device MAC address.
 * @iftype: The device interface type.
 * @extra_headroom: The hardware extra headroom for SKBs in the @list.
 * @has_80211_header: Set it true if SKB is with IEEE 802.11 header.
 */
void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
			      const u8 *addr, enum nl80211_iftype iftype,
			      const unsigned int extra_headroom,
			      bool has_80211_header);

/**
 * cfg80211_classify8021d - determine the 802.1p/1d tag for a data frame
 * @skb: the data frame
 * @qos_map: Interworking QoS mapping or %NULL if not in use
 * Return: The 802.1p/1d tag.
 */
unsigned int cfg80211_classify8021d(struct sk_buff *skb,
				    struct cfg80211_qos_map *qos_map);

/**
 * cfg80211_find_ie - find information element in data
 *
 * @eid: element ID
 * @ies: data consisting of IEs
 * @len: length of data
 *
 * Return: %NULL if the element ID could not be found or if
 * the element is invalid (claims to be longer than the given
 * data), or a pointer to the first byte of the requested
 * element, that is the byte containing the element ID.
 *
 * Note: There are no checks on the element length other than
 * having to fit into the given data.
 */
const u8 *cfg80211_find_ie(u8 eid, const u8 *ies, int len);

/**
 * cfg80211_find_vendor_ie - find vendor specific information element in data
 *
 * @oui: vendor OUI
 * @oui_type: vendor-specific OUI type
 * @ies: data consisting of IEs
 * @len: length of data
 *
 * Return: %NULL if the vendor specific element ID could not be found or if the
 * element is invalid (claims to be longer than the given data), or a pointer to
 * the first byte of the requested element, that is the byte containing the
 * element ID.
 *
 * Note: There are no checks on the element length other than having to fit into
 * the given data.
 */
const u8 *cfg80211_find_vendor_ie(unsigned int oui, u8 oui_type,
				  const u8 *ies, int len);

/**
 * DOC: Regulatory enforcement infrastructure
 *
 * TODO
 */

/**
 * regulatory_hint - driver hint to the wireless core a regulatory domain
 * @wiphy: the wireless device giving the hint (used only for reporting
 *	conflicts)
 * @alpha2: the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
 * 	should be in. If @rd is set this should be NULL. Note that if you
 * 	set this to NULL you should still set rd->alpha2 to some accepted
 * 	alpha2.
 *
 * Wireless drivers can use this function to hint to the wireless core
 * what it believes should be the current regulatory domain by
 * giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
 * domain should be in or by providing a completely build regulatory domain.
 * If the driver provides an ISO/IEC 3166 alpha2 userspace will be queried
 * for a regulatory domain structure for the respective country.
 *
 * The wiphy must have been registered to cfg80211 prior to this call.
 * For cfg80211 drivers this means you must first use wiphy_register(),
 * for mac80211 drivers you must first use ieee80211_register_hw().
 *
 * Drivers should check the return value, its possible you can get
 * an -ENOMEM.
 *
 * Return: 0 on success. -ENOMEM.
 */
int regulatory_hint(struct wiphy *wiphy, const char *alpha2);

/**
 * regulatory_set_wiphy_regd - set regdom info for self managed drivers
 * @wiphy: the wireless device we want to process the regulatory domain on
 * @rd: the regulatory domain informatoin to use for this wiphy
 *
 * Set the regulatory domain information for self-managed wiphys, only they
 * may use this function. See %REGULATORY_WIPHY_SELF_MANAGED for more
 * information.
 *
 * Return: 0 on success. -EINVAL, -EPERM
 */
int regulatory_set_wiphy_regd(struct wiphy *wiphy,
			      struct ieee80211_regdomain *rd);

/**
 * regulatory_set_wiphy_regd_sync_rtnl - set regdom for self-managed drivers
 * @wiphy: the wireless device we want to process the regulatory domain on
 * @rd: the regulatory domain information to use for this wiphy
 *
 * This functions requires the RTNL to be held and applies the new regdomain
 * synchronously to this wiphy. For more details see
 * regulatory_set_wiphy_regd().
 *
 * Return: 0 on success. -EINVAL, -EPERM
 */
int regulatory_set_wiphy_regd_sync_rtnl(struct wiphy *wiphy,
					struct ieee80211_regdomain *rd);

/**
 * wiphy_apply_custom_regulatory - apply a custom driver regulatory domain
 * @wiphy: the wireless device we want to process the regulatory domain on
 * @regd: the custom regulatory domain to use for this wiphy
 *
 * Drivers can sometimes have custom regulatory domains which do not apply
 * to a specific country. Drivers can use this to apply such custom regulatory
 * domains. This routine must be called prior to wiphy registration. The
 * custom regulatory domain will be trusted completely and as such previous
 * default channel settings will be disregarded. If no rule is found for a
 * channel on the regulatory domain the channel will be disabled.
 * Drivers using this for a wiphy should also set the wiphy flag
 * REGULATORY_CUSTOM_REG or cfg80211 will set it for the wiphy
 * that called this helper.
 */
void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
				   const struct ieee80211_regdomain *regd);

/**
 * freq_reg_info - get regulatory information for the given frequency
 * @wiphy: the wiphy for which we want to process this rule for
 * @center_freq: Frequency in KHz for which we want regulatory information for
 *
 * Use this function to get the regulatory rule for a specific frequency on
 * a given wireless device. If the device has a specific regulatory domain
 * it wants to follow we respect that unless a country IE has been received
 * and processed already.
 *
 * Return: A valid pointer, or, when an error occurs, for example if no rule
 * can be found, the return value is encoded using ERR_PTR(). Use IS_ERR() to
 * check and PTR_ERR() to obtain the numeric return value. The numeric return
 * value will be -ERANGE if we determine the given center_freq does not even
 * have a regulatory rule for a frequency range in the center_freq's band.
 * See freq_in_rule_band() for our current definition of a band -- this is
 * purely subjective and right now it's 802.11 specific.
 */
const struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,
					       u32 center_freq);

/**
 * reg_initiator_name - map regulatory request initiator enum to name
 * @initiator: the regulatory request initiator
 *
 * You can use this to map the regulatory request initiator enum to a
 * proper string representation.
 */
const char *reg_initiator_name(enum nl80211_reg_initiator initiator);

/*
 * callbacks for asynchronous cfg80211 methods, notification
 * functions and BSS handling helpers
 */

/**
 * cfg80211_scan_done - notify that scan finished
 *
 * @request: the corresponding scan request
 * @aborted: set to true if the scan was aborted for any reason,
 *	userspace will be notified of that
 */
void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted);

/**
 * cfg80211_sched_scan_results - notify that new scan results are available
 *
 * @wiphy: the wiphy which got scheduled scan results
 */
void cfg80211_sched_scan_results(struct wiphy *wiphy);

/**
 * cfg80211_sched_scan_stopped - notify that the scheduled scan has stopped
 *
 * @wiphy: the wiphy on which the scheduled scan stopped
 *
 * The driver can call this function to inform cfg80211 that the
 * scheduled scan had to be stopped, for whatever reason.  The driver
 * is then called back via the sched_scan_stop operation when done.
 */
void cfg80211_sched_scan_stopped(struct wiphy *wiphy);

/**
 * cfg80211_sched_scan_stopped_rtnl - notify that the scheduled scan has stopped
 *
 * @wiphy: the wiphy on which the scheduled scan stopped
 *
 * The driver can call this function to inform cfg80211 that the
 * scheduled scan had to be stopped, for whatever reason.  The driver
 * is then called back via the sched_scan_stop operation when done.
 * This function should be called with rtnl locked.
 */
void cfg80211_sched_scan_stopped_rtnl(struct wiphy *wiphy);

/**
 * cfg80211_inform_bss_width_frame - inform cfg80211 of a received BSS frame
 *
 * @wiphy: the wiphy reporting the BSS
 * @rx_channel: The channel the frame was received on
 * @scan_width: width of the control channel
 * @mgmt: the management frame (probe response or beacon)
 * @len: length of the management frame
 * @signal: the signal strength, type depends on the wiphy's signal_type
 * @gfp: context flags
 *
 * This informs cfg80211 that BSS information was found and
 * the BSS should be updated/added.
 *
 * Return: A referenced struct, must be released with cfg80211_put_bss()!
 * Or %NULL on error.
 */
struct cfg80211_bss * __must_check
cfg80211_inform_bss_width_frame(struct wiphy *wiphy,
				struct ieee80211_channel *rx_channel,
				enum nl80211_bss_scan_width scan_width,
				struct ieee80211_mgmt *mgmt, size_t len,
				s32 signal, gfp_t gfp);

static inline struct cfg80211_bss * __must_check
cfg80211_inform_bss_frame(struct wiphy *wiphy,
			  struct ieee80211_channel *rx_channel,
			  struct ieee80211_mgmt *mgmt, size_t len,
			  s32 signal, gfp_t gfp)
{
	return cfg80211_inform_bss_width_frame(wiphy, rx_channel,
					       NL80211_BSS_CHAN_WIDTH_20,
					       mgmt, len, signal, gfp);
}

/**
 * enum cfg80211_bss_frame_type - frame type that the BSS data came from
 * @CFG80211_BSS_FTYPE_UNKNOWN: driver doesn't know whether the data is
 *	from a beacon or probe response
 * @CFG80211_BSS_FTYPE_BEACON: data comes from a beacon
 * @CFG80211_BSS_FTYPE_PRESP: data comes from a probe response
 */
enum cfg80211_bss_frame_type {
	CFG80211_BSS_FTYPE_UNKNOWN,
	CFG80211_BSS_FTYPE_BEACON,
	CFG80211_BSS_FTYPE_PRESP,
};

/**
 * cfg80211_inform_bss_width - inform cfg80211 of a new BSS
 *
 * @wiphy: the wiphy reporting the BSS
 * @rx_channel: The channel the frame was received on
 * @scan_width: width of the control channel
 * @ftype: frame type (if known)
 * @bssid: the BSSID of the BSS
 * @tsf: the TSF sent by the peer in the beacon/probe response (or 0)
 * @capability: the capability field sent by the peer
 * @beacon_interval: the beacon interval announced by the peer
 * @ie: additional IEs sent by the peer
 * @ielen: length of the additional IEs
 * @signal: the signal strength, type depends on the wiphy's signal_type
 * @gfp: context flags
 *
 * This informs cfg80211 that BSS information was found and
 * the BSS should be updated/added.
 *
 * Return: A referenced struct, must be released with cfg80211_put_bss()!
 * Or %NULL on error.
 */
struct cfg80211_bss * __must_check
cfg80211_inform_bss_width(struct wiphy *wiphy,
			  struct ieee80211_channel *rx_channel,
			  enum nl80211_bss_scan_width scan_width,
			  enum cfg80211_bss_frame_type ftype,
			  const u8 *bssid, u64 tsf, u16 capability,
			  u16 beacon_interval, const u8 *ie, size_t ielen,
			  s32 signal, gfp_t gfp);

static inline struct cfg80211_bss * __must_check
cfg80211_inform_bss(struct wiphy *wiphy,
		    struct ieee80211_channel *rx_channel,
		    enum cfg80211_bss_frame_type ftype,
		    const u8 *bssid, u64 tsf, u16 capability,
		    u16 beacon_interval, const u8 *ie, size_t ielen,
		    s32 signal, gfp_t gfp)
{
	return cfg80211_inform_bss_width(wiphy, rx_channel,
					 NL80211_BSS_CHAN_WIDTH_20, ftype,
					 bssid, tsf, capability,
					 beacon_interval, ie, ielen, signal,
					 gfp);
}

struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
				      struct ieee80211_channel *channel,
				      const u8 *bssid,
				      const u8 *ssid, size_t ssid_len,
				      enum ieee80211_bss_type bss_type,
				      enum ieee80211_privacy);
static inline struct cfg80211_bss *
cfg80211_get_ibss(struct wiphy *wiphy,
		  struct ieee80211_channel *channel,
		  const u8 *ssid, size_t ssid_len)
{
	return cfg80211_get_bss(wiphy, channel, NULL, ssid, ssid_len,
				IEEE80211_BSS_TYPE_IBSS,
				IEEE80211_PRIVACY_ANY);
}

/**
 * cfg80211_ref_bss - reference BSS struct
 * @wiphy: the wiphy this BSS struct belongs to
 * @bss: the BSS struct to reference
 *
 * Increments the refcount of the given BSS struct.
 */
void cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);

/**
 * cfg80211_put_bss - unref BSS struct
 * @wiphy: the wiphy this BSS struct belongs to
 * @bss: the BSS struct
 *
 * Decrements the refcount of the given BSS struct.
 */
void cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);

/**
 * cfg80211_unlink_bss - unlink BSS from internal data structures
 * @wiphy: the wiphy
 * @bss: the bss to remove
 *
 * This function removes the given BSS from the internal data structures
 * thereby making it no longer show up in scan results etc. Use this
 * function when you detect a BSS is gone. Normally BSSes will also time
 * out, so it is not necessary to use this function at all.
 */
void cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);

static inline enum nl80211_bss_scan_width
cfg80211_chandef_to_scan_width(const struct cfg80211_chan_def *chandef)
{
	switch (chandef->width) {
	case NL80211_CHAN_WIDTH_5:
		return NL80211_BSS_CHAN_WIDTH_5;
	case NL80211_CHAN_WIDTH_10:
		return NL80211_BSS_CHAN_WIDTH_10;
	default:
		return NL80211_BSS_CHAN_WIDTH_20;
	}
}

/**
 * cfg80211_rx_mlme_mgmt - notification of processed MLME management frame
 * @dev: network device
 * @buf: authentication frame (header + body)
 * @len: length of the frame data
 *
 * This function is called whenever an authentication, disassociation or
 * deauthentication frame has been received and processed in station mode.
 * After being asked to authenticate via cfg80211_ops::auth() the driver must
 * call either this function or cfg80211_auth_timeout().
 * After being asked to associate via cfg80211_ops::assoc() the driver must
 * call either this function or cfg80211_auth_timeout().
 * While connected, the driver must calls this for received and processed
 * disassociation and deauthentication frames. If the frame couldn't be used
 * because it was unprotected, the driver must call the function
 * cfg80211_rx_unprot_mlme_mgmt() instead.
 *
 * This function may sleep. The caller must hold the corresponding wdev's mutex.
 */
void cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);

/**
 * cfg80211_auth_timeout - notification of timed out authentication
 * @dev: network device
 * @addr: The MAC address of the device with which the authentication timed out
 *
 * This function may sleep. The caller must hold the corresponding wdev's
 * mutex.
 */
void cfg80211_auth_timeout(struct net_device *dev, const u8 *addr);

/**
 * cfg80211_rx_assoc_resp - notification of processed association response
 * @dev: network device
 * @bss: the BSS that association was requested with, ownership of the pointer
 *	moves to cfg80211 in this call
 * @buf: authentication frame (header + body)
 * @len: length of the frame data
 * @uapsd_queues: bitmap of ACs configured to uapsd. -1 if n/a.
 *
 * After being asked to associate via cfg80211_ops::assoc() the driver must
 * call either this function or cfg80211_auth_timeout().
 *
 * This function may sleep. The caller must hold the corresponding wdev's mutex.
 */
void cfg80211_rx_assoc_resp(struct net_device *dev,
			    struct cfg80211_bss *bss,
			    const u8 *buf, size_t len,
			    int uapsd_queues);

/**
 * cfg80211_assoc_timeout - notification of timed out association
 * @dev: network device
 * @bss: The BSS entry with which association timed out.
 *
 * This function may sleep. The caller must hold the corresponding wdev's mutex.
 */
void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss);

/**
 * cfg80211_tx_mlme_mgmt - notification of transmitted deauth/disassoc frame
 * @dev: network device
 * @buf: 802.11 frame (header + body)
 * @len: length of the frame data
 *
 * This function is called whenever deauthentication has been processed in
 * station mode. This includes both received deauthentication frames and
 * locally generated ones. This function may sleep. The caller must hold the
 * corresponding wdev's mutex.
 */
void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);

/**
 * cfg80211_rx_unprot_mlme_mgmt - notification of unprotected mlme mgmt frame
 * @dev: network device
 * @buf: deauthentication frame (header + body)
 * @len: length of the frame data
 *
 * This function is called whenever a received deauthentication or dissassoc
 * frame has been dropped in station mode because of MFP being used but the
 * frame was not protected. This function may sleep.
 */
void cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev,
				  const u8 *buf, size_t len);

/**
 * cfg80211_michael_mic_failure - notification of Michael MIC failure (TKIP)
 * @dev: network device
 * @addr: The source MAC address of the frame
 * @key_type: The key type that the received frame used
 * @key_id: Key identifier (0..3). Can be -1 if missing.
 * @tsc: The TSC value of the frame that generated the MIC failure (6 octets)
 * @gfp: allocation flags
 *
 * This function is called whenever the local MAC detects a MIC failure in a
 * received frame. This matches with MLME-MICHAELMICFAILURE.indication()
 * primitive.
 */
void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
				  enum nl80211_key_type key_type, int key_id,
				  const u8 *tsc, gfp_t gfp);

/**
 * cfg80211_ibss_joined - notify cfg80211 that device joined an IBSS
 *
 * @dev: network device
 * @bssid: the BSSID of the IBSS joined
 * @channel: the channel of the IBSS joined
 * @gfp: allocation flags
 *
 * This function notifies cfg80211 that the device joined an IBSS or
 * switched to a different BSSID. Before this function can be called,
 * either a beacon has to have been received from the IBSS, or one of
 * the cfg80211_inform_bss{,_frame} functions must have been called
 * with the locally generated beacon -- this guarantees that there is
 * always a scan result for this IBSS. cfg80211 will handle the rest.
 */
void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
			  struct ieee80211_channel *channel, gfp_t gfp);

/**
 * cfg80211_notify_new_candidate - notify cfg80211 of a new mesh peer candidate
 *
 * @dev: network device
 * @macaddr: the MAC address of the new candidate
 * @ie: information elements advertised by the peer candidate
 * @ie_len: lenght of the information elements buffer
 * @gfp: allocation flags
 *
 * This function notifies cfg80211 that the mesh peer candidate has been
 * detected, most likely via a beacon or, less likely, via a probe response.
 * cfg80211 then sends a notification to userspace.
 */
void cfg80211_notify_new_peer_candidate(struct net_device *dev,
		const u8 *macaddr, const u8 *ie, u8 ie_len, gfp_t gfp);

/**
 * DOC: RFkill integration
 *
 * RFkill integration in cfg80211 is almost invisible to drivers,
 * as cfg80211 automatically registers an rfkill instance for each
 * wireless device it knows about. Soft kill is also translated
 * into disconnecting and turning all interfaces off, drivers are
 * expected to turn off the device when all interfaces are down.
 *
 * However, devices may have a hard RFkill line, in which case they
 * also need to interact with the rfkill subsystem, via cfg80211.
 * They can do this with a few helper functions documented here.
 */

/**
 * wiphy_rfkill_set_hw_state - notify cfg80211 about hw block state
 * @wiphy: the wiphy
 * @blocked: block status
 */
void wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked);

/**
 * wiphy_rfkill_start_polling - start polling rfkill
 * @wiphy: the wiphy
 */
void wiphy_rfkill_start_polling(struct wiphy *wiphy);

/**
 * wiphy_rfkill_stop_polling - stop polling rfkill
 * @wiphy: the wiphy
 */
void wiphy_rfkill_stop_polling(struct wiphy *wiphy);

/**
 * DOC: Vendor commands
 *
 * Occasionally, there are special protocol or firmware features that
 * can't be implemented very openly. For this and similar cases, the
 * vendor command functionality allows implementing the features with
 * (typically closed-source) userspace and firmware, using nl80211 as
 * the configuration mechanism.
 *
 * A driver supporting vendor commands must register them as an array
 * in struct wiphy, with handlers for each one, each command has an
 * OUI and sub command ID to identify it.
 *
 * Note that this feature should not be (ab)used to implement protocol
 * features that could openly be shared across drivers. In particular,
 * it must never be required to use vendor commands to implement any
 * "normal" functionality that higher-level userspace like connection
 * managers etc. need.
 */

struct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,
					   enum nl80211_commands cmd,
					   enum nl80211_attrs attr,
					   int approxlen);

struct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,
					   struct wireless_dev *wdev,
					   enum nl80211_commands cmd,
					   enum nl80211_attrs attr,
					   int vendor_event_idx,
					   int approxlen, gfp_t gfp);

void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp);

/**
 * cfg80211_vendor_cmd_alloc_reply_skb - allocate vendor command reply
 * @wiphy: the wiphy
 * @approxlen: an upper bound of the length of the data that will
 *	be put into the skb
 *
 * This function allocates and pre-fills an skb for a reply to
 * a vendor command. Since it is intended for a reply, calling
 * it outside of a vendor command's doit() operation is invalid.
 *
 * The returned skb is pre-filled with some identifying data in
 * a way that any data that is put into the skb (with skb_put(),
 * nla_put() or similar) will end up being within the
 * %NL80211_ATTR_VENDOR_DATA attribute, so all that needs to be done
 * with the skb is adding data for the corresponding userspace tool
 * which can then read that data out of the vendor data attribute.
 * You must not modify the skb in any other way.
 *
 * When done, call cfg80211_vendor_cmd_reply() with the skb and return
 * its error code as the result of the doit() operation.
 *
 * Return: An allocated and pre-filled skb. %NULL if any errors happen.
 */
static inline struct sk_buff *
cfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
{
	return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_VENDOR,
					  NL80211_ATTR_VENDOR_DATA, approxlen);
}

/**
 * cfg80211_vendor_cmd_reply - send the reply skb
 * @skb: The skb, must have been allocated with
 *	cfg80211_vendor_cmd_alloc_reply_skb()
 *
 * Since calling this function will usually be the last thing
 * before returning from the vendor command doit() you should
 * return the error code.  Note that this function consumes the
 * skb regardless of the return value.
 *
 * Return: An error code or 0 on success.
 */
int cfg80211_vendor_cmd_reply(struct sk_buff *skb);

/**
 * cfg80211_vendor_event_alloc - allocate vendor-specific event skb
 * @wiphy: the wiphy
 * @wdev: the wireless device
 * @event_idx: index of the vendor event in the wiphy's vendor_events
 * @approxlen: an upper bound of the length of the data that will
 *	be put into the skb
 * @gfp: allocation flags
 *
 * This function allocates and pre-fills an skb for an event on the
 * vendor-specific multicast group.
 *
 * If wdev != NULL, both the ifindex and identifier of the specified
 * wireless device are added to the event message before the vendor data
 * attribute.
 *
 * When done filling the skb, call cfg80211_vendor_event() with the
 * skb to send the event.
 *
 * Return: An allocated and pre-filled skb. %NULL if any errors happen.
 */
static inline struct sk_buff *
cfg80211_vendor_event_alloc(struct wiphy *wiphy, struct wireless_dev *wdev,
			     int approxlen, int event_idx, gfp_t gfp)
{
	return __cfg80211_alloc_event_skb(wiphy, wdev, NL80211_CMD_VENDOR,
					  NL80211_ATTR_VENDOR_DATA,
					  event_idx, approxlen, gfp);
}

/**
 * cfg80211_vendor_event - send the event
 * @skb: The skb, must have been allocated with cfg80211_vendor_event_alloc()
 * @gfp: allocation flags
 *
 * This function sends the given @skb, which must have been allocated
 * by cfg80211_vendor_event_alloc(), as an event. It always consumes it.
 */
static inline void cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp)
{
	__cfg80211_send_event_skb(skb, gfp);
}

#ifdef CONFIG_NL80211_TESTMODE
/**
 * DOC: Test mode
 *
 * Test mode is a set of utility functions to allow drivers to
 * interact with driver-specific tools to aid, for instance,
 * factory programming.
 *
 * This chapter describes how drivers interact with it, for more
 * information see the nl80211 book's chapter on it.
 */

/**
 * cfg80211_testmode_alloc_reply_skb - allocate testmode reply
 * @wiphy: the wiphy
 * @approxlen: an upper bound of the length of the data that will
 *	be put into the skb
 *
 * This function allocates and pre-fills an skb for a reply to
 * the testmode command. Since it is intended for a reply, calling
 * it outside of the @testmode_cmd operation is invalid.
 *
 * The returned skb is pre-filled with the wiphy index and set up in
 * a way that any data that is put into the skb (with skb_put(),
 * nla_put() or similar) will end up being within the
 * %NL80211_ATTR_TESTDATA attribute, so all that needs to be done
 * with the skb is adding data for the corresponding userspace tool
 * which can then read that data out of the testdata attribute. You
 * must not modify the skb in any other way.
 *
 * When done, call cfg80211_testmode_reply() with the skb and return
 * its error code as the result of the @testmode_cmd operation.
 *
 * Return: An allocated and pre-filled skb. %NULL if any errors happen.
 */
static inline struct sk_buff *
cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
{
	return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_TESTMODE,
					  NL80211_ATTR_TESTDATA, approxlen);
}

/**
 * cfg80211_testmode_reply - send the reply skb
 * @skb: The skb, must have been allocated with
 *	cfg80211_testmode_alloc_reply_skb()
 *
 * Since calling this function will usually be the last thing
 * before returning from the @testmode_cmd you should return
 * the error code.  Note that this function consumes the skb
 * regardless of the return value.
 *
 * Return: An error code or 0 on success.
 */
static inline int cfg80211_testmode_reply(struct sk_buff *skb)
{
	return cfg80211_vendor_cmd_reply(skb);
}

/**
 * cfg80211_testmode_alloc_event_skb - allocate testmode event
 * @wiphy: the wiphy
 * @approxlen: an upper bound of the length of the data that will
 *	be put into the skb
 * @gfp: allocation flags
 *
 * This function allocates and pre-fills an skb for an event on the
 * testmode multicast group.
 *
 * The returned skb is set up in the same way as with
 * cfg80211_testmode_alloc_reply_skb() but prepared for an event. As
 * there, you should simply add data to it that will then end up in the
 * %NL80211_ATTR_TESTDATA attribute. Again, you must not modify the skb
 * in any other way.
 *
 * When done filling the skb, call cfg80211_testmode_event() with the
 * skb to send the event.
 *
 * Return: An allocated and pre-filled skb. %NULL if any errors happen.
 */
static inline struct sk_buff *
cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy, int approxlen, gfp_t gfp)
{
	return __cfg80211_alloc_event_skb(wiphy, NULL, NL80211_CMD_TESTMODE,
					  NL80211_ATTR_TESTDATA, -1,
					  approxlen, gfp);
}

/**
 * cfg80211_testmode_event - send the event
 * @skb: The skb, must have been allocated with
 *	cfg80211_testmode_alloc_event_skb()
 * @gfp: allocation flags
 *
 * This function sends the given @skb, which must have been allocated
 * by cfg80211_testmode_alloc_event_skb(), as an event. It always
 * consumes it.
 */
static inline void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)
{
	__cfg80211_send_event_skb(skb, gfp);
}

#define CFG80211_TESTMODE_CMD(cmd)	.testmode_cmd = (cmd),
#define CFG80211_TESTMODE_DUMP(cmd)	.testmode_dump = (cmd),
#else
#define CFG80211_TESTMODE_CMD(cmd)
#define CFG80211_TESTMODE_DUMP(cmd)
#endif

/**
 * cfg80211_connect_result - notify cfg80211 of connection result
 *
 * @dev: network device
 * @bssid: the BSSID of the AP
 * @req_ie: association request IEs (maybe be %NULL)
 * @req_ie_len: association request IEs length
 * @resp_ie: association response IEs (may be %NULL)
 * @resp_ie_len: assoc response IEs length
 * @status: status code, 0 for successful connection, use
 *	%WLAN_STATUS_UNSPECIFIED_FAILURE if your device cannot give you
 *	the real status code for failures.
 * @gfp: allocation flags
 *
 * It should be called by the underlying driver whenever connect() has
 * succeeded.
 */
void cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
			     const u8 *req_ie, size_t req_ie_len,
			     const u8 *resp_ie, size_t resp_ie_len,
			     u16 status, gfp_t gfp);

/**
 * cfg80211_roamed - notify cfg80211 of roaming
 *
 * @dev: network device
 * @channel: the channel of the new AP
 * @bssid: the BSSID of the new AP
 * @req_ie: association request IEs (maybe be %NULL)
 * @req_ie_len: association request IEs length
 * @resp_ie: association response IEs (may be %NULL)
 * @resp_ie_len: assoc response IEs length
 * @gfp: allocation flags
 *
 * It should be called by the underlying driver whenever it roamed
 * from one AP to another while connected.
 */
void cfg80211_roamed(struct net_device *dev,
		     struct ieee80211_channel *channel,
		     const u8 *bssid,
		     const u8 *req_ie, size_t req_ie_len,
		     const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp);

/**
 * cfg80211_roamed_bss - notify cfg80211 of roaming
 *
 * @dev: network device
 * @bss: entry of bss to which STA got roamed
 * @req_ie: association request IEs (maybe be %NULL)
 * @req_ie_len: association request IEs length
 * @resp_ie: association response IEs (may be %NULL)
 * @resp_ie_len: assoc response IEs length
 * @gfp: allocation flags
 *
 * This is just a wrapper to notify cfg80211 of roaming event with driver
 * passing bss to avoid a race in timeout of the bss entry. It should be
 * called by the underlying driver whenever it roamed from one AP to another
 * while connected. Drivers which have roaming implemented in firmware
 * may use this function to avoid a race in bss entry timeout where the bss
 * entry of the new AP is seen in the driver, but gets timed out by the time
 * it is accessed in __cfg80211_roamed() due to delay in scheduling
 * rdev->event_work. In case of any failures, the reference is released
 * either in cfg80211_roamed_bss() or in __cfg80211_romed(), Otherwise,
 * it will be released while diconneting from the current bss.
 */
void cfg80211_roamed_bss(struct net_device *dev, struct cfg80211_bss *bss,
			 const u8 *req_ie, size_t req_ie_len,
			 const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp);

/**
 * cfg80211_disconnected - notify cfg80211 that connection was dropped
 *
 * @dev: network device
 * @ie: information elements of the deauth/disassoc frame (may be %NULL)
 * @ie_len: length of IEs
 * @reason: reason code for the disconnection, set it to 0 if unknown
 * @gfp: allocation flags
 *
 * After it calls this function, the driver should enter an idle state
 * and not try to connect to any AP any more.
 */
void cfg80211_disconnected(struct net_device *dev, u16 reason,
			   const u8 *ie, size_t ie_len, gfp_t gfp);

/**
 * cfg80211_ready_on_channel - notification of remain_on_channel start
 * @wdev: wireless device
 * @cookie: the request cookie
 * @chan: The current channel (from remain_on_channel request)
 * @duration: Duration in milliseconds that the driver intents to remain on the
 *	channel
 * @gfp: allocation flags
 */
void cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,
			       struct ieee80211_channel *chan,
			       unsigned int duration, gfp_t gfp);

/**
 * cfg80211_remain_on_channel_expired - remain_on_channel duration expired
 * @wdev: wireless device
 * @cookie: the request cookie
 * @chan: The current channel (from remain_on_channel request)
 * @gfp: allocation flags
 */
void cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,
					struct ieee80211_channel *chan,
					gfp_t gfp);


/**
 * cfg80211_new_sta - notify userspace about station
 *
 * @dev: the netdev
 * @mac_addr: the station's address
 * @sinfo: the station information
 * @gfp: allocation flags
 */
void cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,
		      struct station_info *sinfo, gfp_t gfp);

/**
 * cfg80211_del_sta_sinfo - notify userspace about deletion of a station
 * @dev: the netdev
 * @mac_addr: the station's address
 * @sinfo: the station information/statistics
 * @gfp: allocation flags
 */
void cfg80211_del_sta_sinfo(struct net_device *dev, const u8 *mac_addr,
			    struct station_info *sinfo, gfp_t gfp);

/**
 * cfg80211_del_sta - notify userspace about deletion of a station
 *
 * @dev: the netdev
 * @mac_addr: the station's address
 * @gfp: allocation flags
 */
static inline void cfg80211_del_sta(struct net_device *dev,
				    const u8 *mac_addr, gfp_t gfp)
{
	cfg80211_del_sta_sinfo(dev, mac_addr, NULL, gfp);
}

/**
 * cfg80211_conn_failed - connection request failed notification
 *
 * @dev: the netdev
 * @mac_addr: the station's address
 * @reason: the reason for connection failure
 * @gfp: allocation flags
 *
 * Whenever a station tries to connect to an AP and if the station
 * could not connect to the AP as the AP has rejected the connection
 * for some reasons, this function is called.
 *
 * The reason for connection failure can be any of the value from
 * nl80211_connect_failed_reason enum
 */
void cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,
			  enum nl80211_connect_failed_reason reason,
			  gfp_t gfp);

/**
 * cfg80211_rx_mgmt - notification of received, unprocessed management frame
 * @wdev: wireless device receiving the frame
 * @freq: Frequency on which the frame was received in MHz
 * @sig_dbm: signal strength in mBm, or 0 if unknown
 * @buf: Management frame (header + body)
 * @len: length of the frame data
 * @flags: flags, as defined in enum nl80211_rxmgmt_flags
 *
 * This function is called whenever an Action frame is received for a station
 * mode interface, but is not processed in kernel.
 *
 * Return: %true if a user space application has registered for this frame.
 * For action frames, that makes it responsible for rejecting unrecognized
 * action frames; %false otherwise, in which case for action frames the
 * driver is responsible for rejecting the frame.
 */
bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_dbm,
		      const u8 *buf, size_t len, u32 flags);

/**
 * cfg80211_mgmt_tx_status - notification of TX status for management frame
 * @wdev: wireless device receiving the frame
 * @cookie: Cookie returned by cfg80211_ops::mgmt_tx()
 * @buf: Management frame (header + body)
 * @len: length of the frame data
 * @ack: Whether frame was acknowledged
 * @gfp: context flags
 *
 * This function is called whenever a management frame was requested to be
 * transmitted with cfg80211_ops::mgmt_tx() to report the TX status of the
 * transmission attempt.
 */
void cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,
			     const u8 *buf, size_t len, bool ack, gfp_t gfp);


/**
 * cfg80211_cqm_rssi_notify - connection quality monitoring rssi event
 * @dev: network device
 * @rssi_event: the triggered RSSI event
 * @gfp: context flags
 *
 * This function is called when a configured connection quality monitoring
 * rssi threshold reached event occurs.
 */
void cfg80211_cqm_rssi_notify(struct net_device *dev,
			      enum nl80211_cqm_rssi_threshold_event rssi_event,
			      gfp_t gfp);

/**
 * cfg80211_cqm_pktloss_notify - notify userspace about packetloss to peer
 * @dev: network device
 * @peer: peer's MAC address
 * @num_packets: how many packets were lost -- should be a fixed threshold
 *	but probably no less than maybe 50, or maybe a throughput dependent
 *	threshold (to account for temporary interference)
 * @gfp: context flags
 */
void cfg80211_cqm_pktloss_notify(struct net_device *dev,
				 const u8 *peer, u32 num_packets, gfp_t gfp);

/**
 * cfg80211_cqm_txe_notify - TX error rate event
 * @dev: network device
 * @peer: peer's MAC address
 * @num_packets: how many packets were lost
 * @rate: % of packets which failed transmission
 * @intvl: interval (in s) over which the TX failure threshold was breached.
 * @gfp: context flags
 *
 * Notify userspace when configured % TX failures over number of packets in a
 * given interval is exceeded.
 */
void cfg80211_cqm_txe_notify(struct net_device *dev, const u8 *peer,
			     u32 num_packets, u32 rate, u32 intvl, gfp_t gfp);

/**
 * cfg80211_cqm_beacon_loss_notify - beacon loss event
 * @dev: network device
 * @gfp: context flags
 *
 * Notify userspace about beacon loss from the connected AP.
 */
void cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp);

/**
 * cfg80211_radar_event - radar detection event
 * @wiphy: the wiphy
 * @chandef: chandef for the current channel
 * @gfp: context flags
 *
 * This function is called when a radar is detected on the current chanenl.
 */
void cfg80211_radar_event(struct wiphy *wiphy,
			  struct cfg80211_chan_def *chandef, gfp_t gfp);

/**
 * cfg80211_cac_event - Channel availability check (CAC) event
 * @netdev: network device
 * @chandef: chandef for the current channel
 * @event: type of event
 * @gfp: context flags
 *
 * This function is called when a Channel availability check (CAC) is finished
 * or aborted. This must be called to notify the completion of a CAC process,
 * also by full-MAC drivers.
 */
void cfg80211_cac_event(struct net_device *netdev,
			const struct cfg80211_chan_def *chandef,
			enum nl80211_radar_event event, gfp_t gfp);


/**
 * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying
 * @dev: network device
 * @bssid: BSSID of AP (to avoid races)
 * @replay_ctr: new replay counter
 * @gfp: allocation flags
 */
void cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,
			       const u8 *replay_ctr, gfp_t gfp);

/**
 * cfg80211_pmksa_candidate_notify - notify about PMKSA caching candidate
 * @dev: network device
 * @index: candidate index (the smaller the index, the higher the priority)
 * @bssid: BSSID of AP
 * @preauth: Whether AP advertises support for RSN pre-authentication
 * @gfp: allocation flags
 */
void cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,
				     const u8 *bssid, bool preauth, gfp_t gfp);

/**
 * cfg80211_rx_spurious_frame - inform userspace about a spurious frame
 * @dev: The device the frame matched to
 * @addr: the transmitter address
 * @gfp: context flags
 *
 * This function is used in AP mode (only!) to inform userspace that
 * a spurious class 3 frame was received, to be able to deauth the
 * sender.
 * Return: %true if the frame was passed to userspace (or this failed
 * for a reason other than not having a subscription.)
 */
bool cfg80211_rx_spurious_frame(struct net_device *dev,
				const u8 *addr, gfp_t gfp);

/**
 * cfg80211_rx_unexpected_4addr_frame - inform about unexpected WDS frame
 * @dev: The device the frame matched to
 * @addr: the transmitter address
 * @gfp: context flags
 *
 * This function is used in AP mode (only!) to inform userspace that
 * an associated station sent a 4addr frame but that wasn't expected.
 * It is allowed and desirable to send this event only once for each
 * station to avoid event flooding.
 * Return: %true if the frame was passed to userspace (or this failed
 * for a reason other than not having a subscription.)
 */
bool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,
					const u8 *addr, gfp_t gfp);

/**
 * cfg80211_probe_status - notify userspace about probe status
 * @dev: the device the probe was sent on
 * @addr: the address of the peer
 * @cookie: the cookie filled in @probe_client previously
 * @acked: indicates whether probe was acked or not
 * @gfp: allocation flags
 */
void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
			   u64 cookie, bool acked, gfp_t gfp);

/**
 * cfg80211_report_obss_beacon - report beacon from other APs
 * @wiphy: The wiphy that received the beacon
 * @frame: the frame
 * @len: length of the frame
 * @freq: frequency the frame was received on
 * @sig_dbm: signal strength in mBm, or 0 if unknown
 *
 * Use this function to report to userspace when a beacon was
 * received. It is not useful to call this when there is no
 * netdev that is in AP/GO mode.
 */
void cfg80211_report_obss_beacon(struct wiphy *wiphy,
				 const u8 *frame, size_t len,
				 int freq, int sig_dbm);

/**
 * cfg80211_reg_can_beacon - check if beaconing is allowed
 * @wiphy: the wiphy
 * @chandef: the channel definition
 * @iftype: interface type
 *
 * Return: %true if there is no secondary channel or the secondary channel(s)
 * can be used for beaconing (i.e. is not a radar channel etc.)
 */
bool cfg80211_reg_can_beacon(struct wiphy *wiphy,
			     struct cfg80211_chan_def *chandef,
			     enum nl80211_iftype iftype);

/*
 * cfg80211_ch_switch_notify - update wdev channel and notify userspace
 * @dev: the device which switched channels
 * @chandef: the new channel definition
 *
 * Caller must acquire wdev_lock, therefore must only be called from sleepable
 * driver context!
 */
void cfg80211_ch_switch_notify(struct net_device *dev,
			       struct cfg80211_chan_def *chandef);

/*
 * cfg80211_ch_switch_started_notify - notify channel switch start
 * @dev: the device on which the channel switch started
 * @chandef: the future channel definition
 * @count: the number of TBTTs until the channel switch happens
 *
 * Inform the userspace about the channel switch that has just
 * started, so that it can take appropriate actions (eg. starting
 * channel switch on other vifs), if necessary.
 */
void cfg80211_ch_switch_started_notify(struct net_device *dev,
				       struct cfg80211_chan_def *chandef,
				       u8 count);

/**
 * ieee80211_operating_class_to_band - convert operating class to band
 *
 * @operating_class: the operating class to convert
 * @band: band pointer to fill
 *
 * Returns %true if the conversion was successful, %false otherwise.
 */
bool ieee80211_operating_class_to_band(u8 operating_class,
				       enum ieee80211_band *band);

/**
 * ieee80211_chandef_to_operating_class - convert chandef to operation class
 *
 * @chandef: the chandef to convert
 * @op_class: a pointer to the resulting operating class
 *
 * Returns %true if the conversion was successful, %false otherwise.
 */
bool ieee80211_chandef_to_operating_class(struct cfg80211_chan_def *chandef,
					  u8 *op_class);

/*
 * cfg80211_tdls_oper_request - request userspace to perform TDLS operation
 * @dev: the device on which the operation is requested
 * @peer: the MAC address of the peer device
 * @oper: the requested TDLS operation (NL80211_TDLS_SETUP or
 *	NL80211_TDLS_TEARDOWN)
 * @reason_code: the reason code for teardown request
 * @gfp: allocation flags
 *
 * This function is used to request userspace to perform TDLS operation that
 * requires knowledge of keys, i.e., link setup or teardown when the AP
 * connection uses encryption. This is optional mechanism for the driver to use
 * if it can automatically determine when a TDLS link could be useful (e.g.,
 * based on traffic and signal strength for a peer).
 */
void cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,
				enum nl80211_tdls_operation oper,
				u16 reason_code, gfp_t gfp);

/*
 * cfg80211_calculate_bitrate - calculate actual bitrate (in 100Kbps units)
 * @rate: given rate_info to calculate bitrate from
 *
 * return 0 if MCS index >= 32
 */
u32 cfg80211_calculate_bitrate(struct rate_info *rate);

/**
 * cfg80211_unregister_wdev - remove the given wdev
 * @wdev: struct wireless_dev to remove
 *
 * Call this function only for wdevs that have no netdev assigned,
 * e.g. P2P Devices. It removes the device from the list so that
 * it can no longer be used. It is necessary to call this function
 * even when cfg80211 requests the removal of the interface by
 * calling the del_virtual_intf() callback. The function must also
 * be called when the driver wishes to unregister the wdev, e.g.
 * when the device is unbound from the driver.
 *
 * Requires the RTNL to be held.
 */
void cfg80211_unregister_wdev(struct wireless_dev *wdev);

/**
 * struct cfg80211_ft_event - FT Information Elements
 * @ies: FT IEs
 * @ies_len: length of the FT IE in bytes
 * @target_ap: target AP's MAC address
 * @ric_ies: RIC IE
 * @ric_ies_len: length of the RIC IE in bytes
 */
struct cfg80211_ft_event_params {
	const u8 *ies;
	size_t ies_len;
	const u8 *target_ap;
	const u8 *ric_ies;
	size_t ric_ies_len;
};

/**
 * cfg80211_ft_event - notify userspace about FT IE and RIC IE
 * @netdev: network device
 * @ft_event: IE information
 */
void cfg80211_ft_event(struct net_device *netdev,
		       struct cfg80211_ft_event_params *ft_event);

/**
 * cfg80211_get_p2p_attr - find and copy a P2P attribute from IE buffer
 * @ies: the input IE buffer
 * @len: the input length
 * @attr: the attribute ID to find
 * @buf: output buffer, can be %NULL if the data isn't needed, e.g.
 *	if the function is only called to get the needed buffer size
 * @bufsize: size of the output buffer
 *
 * The function finds a given P2P attribute in the (vendor) IEs and
 * copies its contents to the given buffer.
 *
 * Return: A negative error code (-%EILSEQ or -%ENOENT) if the data is
 * malformed or the attribute can't be found (respectively), or the
 * length of the found attribute (which can be zero).
 */
int cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,
			  enum ieee80211_p2p_attr_id attr,
			  u8 *buf, unsigned int bufsize);

/**
 * ieee80211_ie_split_ric - split an IE buffer according to ordering (with RIC)
 * @ies: the IE buffer
 * @ielen: the length of the IE buffer
 * @ids: an array with element IDs that are allowed before
 *	the split
 * @n_ids: the size of the element ID array
 * @after_ric: array IE types that come after the RIC element
 * @n_after_ric: size of the @after_ric array
 * @offset: offset where to start splitting in the buffer
 *
 * This function splits an IE buffer by updating the @offset
 * variable to point to the location where the buffer should be
 * split.
 *
 * It assumes that the given IE buffer is well-formed, this
 * has to be guaranteed by the caller!
 *
 * It also assumes that the IEs in the buffer are ordered
 * correctly, if not the result of using this function will not
 * be ordered correctly either, i.e. it does no reordering.
 *
 * The function returns the offset where the next part of the
 * buffer starts, which may be @ielen if the entire (remainder)
 * of the buffer should be used.
 */
size_t ieee80211_ie_split_ric(const u8 *ies, size_t ielen,
			      const u8 *ids, int n_ids,
			      const u8 *after_ric, int n_after_ric,
			      size_t offset);

/**
 * ieee80211_ie_split - split an IE buffer according to ordering
 * @ies: the IE buffer
 * @ielen: the length of the IE buffer
 * @ids: an array with element IDs that are allowed before
 *	the split
 * @n_ids: the size of the element ID array
 * @offset: offset where to start splitting in the buffer
 *
 * This function splits an IE buffer by updating the @offset
 * variable to point to the location where the buffer should be
 * split.
 *
 * It assumes that the given IE buffer is well-formed, this
 * has to be guaranteed by the caller!
 *
 * It also assumes that the IEs in the buffer are ordered
 * correctly, if not the result of using this function will not
 * be ordered correctly either, i.e. it does no reordering.
 *
 * The function returns the offset where the next part of the
 * buffer starts, which may be @ielen if the entire (remainder)
 * of the buffer should be used.
 */
size_t ieee80211_ie_split(const u8 *ies, size_t ielen,
			  const u8 *ids, int n_ids, size_t offset);

/**
 * cfg80211_report_wowlan_wakeup - report wakeup from WoWLAN
 * @wdev: the wireless device reporting the wakeup
 * @wakeup: the wakeup report
 * @gfp: allocation flags
 *
 * This function reports that the given device woke up. If it
 * caused the wakeup, report the reason(s), otherwise you may
 * pass %NULL as the @wakeup parameter to advertise that something
 * else caused the wakeup.
 */
void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
				   struct cfg80211_wowlan_wakeup *wakeup,
				   gfp_t gfp);

/**
 * cfg80211_crit_proto_stopped() - indicate critical protocol stopped by driver.
 *
 * @wdev: the wireless device for which critical protocol is stopped.
 * @gfp: allocation flags
 *
 * This function can be called by the driver to indicate it has reverted
 * operation back to normal. One reason could be that the duration given
 * by .crit_proto_start() has expired.
 */
void cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp);

/**
 * ieee80211_get_num_supported_channels - get number of channels device has
 * @wiphy: the wiphy
 *
 * Return: the number of channels supported by the device.
 */
unsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy);

/**
 * cfg80211_check_combinations - check interface combinations
 *
 * @wiphy: the wiphy
 * @num_different_channels: the number of different channels we want
 *	to use for verification
 * @radar_detect: a bitmap where each bit corresponds to a channel
 *	width where radar detection is needed, as in the definition of
 *	&struct ieee80211_iface_combination.@radar_detect_widths
 * @iftype_num: array with the numbers of interfaces of each interface
 *	type.  The index is the interface type as specified in &enum
 *	nl80211_iftype.
 *
 * This function can be called by the driver to check whether a
 * combination of interfaces and their types are allowed according to
 * the interface combinations.
 */
int cfg80211_check_combinations(struct wiphy *wiphy,
				const int num_different_channels,
				const u8 radar_detect,
				const int iftype_num[NUM_NL80211_IFTYPES]);

/**
 * cfg80211_iter_combinations - iterate over matching combinations
 *
 * @wiphy: the wiphy
 * @num_different_channels: the number of different channels we want
 *	to use for verification
 * @radar_detect: a bitmap where each bit corresponds to a channel
 *	width where radar detection is needed, as in the definition of
 *	&struct ieee80211_iface_combination.@radar_detect_widths
 * @iftype_num: array with the numbers of interfaces of each interface
 *	type.  The index is the interface type as specified in &enum
 *	nl80211_iftype.
 * @iter: function to call for each matching combination
 * @data: pointer to pass to iter function
 *
 * This function can be called by the driver to check what possible
 * combinations it fits in at a given moment, e.g. for channel switching
 * purposes.
 */
int cfg80211_iter_combinations(struct wiphy *wiphy,
			       const int num_different_channels,
			       const u8 radar_detect,
			       const int iftype_num[NUM_NL80211_IFTYPES],
			       void (*iter)(const struct ieee80211_iface_combination *c,
					    void *data),
			       void *data);

/*
 * cfg80211_stop_iface - trigger interface disconnection
 *
 * @wiphy: the wiphy
 * @wdev: wireless device
 * @gfp: context flags
 *
 * Trigger interface to be stopped as if AP was stopped, IBSS/mesh left, STA
 * disconnected.
 *
 * Note: This doesn't need any locks and is asynchronous.
 */
void cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,
			 gfp_t gfp);

/**
 * cfg80211_shutdown_all_interfaces - shut down all interfaces for a wiphy
 * @wiphy: the wiphy to shut down
 *
 * This function shuts down all interfaces belonging to this wiphy by
 * calling dev_close() (and treating non-netdev interfaces as needed).
 * It shouldn't really be used unless there are some fatal device errors
 * that really can't be recovered in any other way.
 *
 * Callers must hold the RTNL and be able to deal with callbacks into
 * the driver while the function is running.
 */
void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy);

/**
 * wiphy_ext_feature_set - set the extended feature flag
 *
 * @wiphy: the wiphy to modify.
 * @ftidx: extended feature bit index.
 *
 * The extended features are flagged in multiple bytes (see
 * &struct wiphy.@ext_features)
 */
static inline void wiphy_ext_feature_set(struct wiphy *wiphy,
					 enum nl80211_ext_feature_index ftidx)
{
	u8 *ft_byte;

	ft_byte = &wiphy->ext_features[ftidx / 8];
	*ft_byte |= BIT(ftidx % 8);
}

/**
 * wiphy_ext_feature_isset - check the extended feature flag
 *
 * @wiphy: the wiphy to modify.
 * @ftidx: extended feature bit index.
 *
 * The extended features are flagged in multiple bytes (see
 * &struct wiphy.@ext_features)
 */
static inline bool
wiphy_ext_feature_isset(struct wiphy *wiphy,
			enum nl80211_ext_feature_index ftidx)
{
	u8 ft_byte;

	ft_byte = wiphy->ext_features[ftidx / 8];
	return (ft_byte & BIT(ftidx % 8)) != 0;
}

/* ethtool helper */
void cfg80211_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info);

/* Logging, debugging and troubleshooting/diagnostic helpers. */

/* wiphy_printk helpers, similar to dev_printk */

#define wiphy_printk(level, wiphy, format, args...)		\
	dev_printk(level, &(wiphy)->dev, format, ##args)
#define wiphy_emerg(wiphy, format, args...)			\
	dev_emerg(&(wiphy)->dev, format, ##args)
#define wiphy_alert(wiphy, format, args...)			\
	dev_alert(&(wiphy)->dev, format, ##args)
#define wiphy_crit(wiphy, format, args...)			\
	dev_crit(&(wiphy)->dev, format, ##args)
#define wiphy_err(wiphy, format, args...)			\
	dev_err(&(wiphy)->dev, format, ##args)
#define wiphy_warn(wiphy, format, args...)			\
	dev_warn(&(wiphy)->dev, format, ##args)
#define wiphy_notice(wiphy, format, args...)			\
	dev_notice(&(wiphy)->dev, format, ##args)
#define wiphy_info(wiphy, format, args...)			\
	dev_info(&(wiphy)->dev, format, ##args)

#define wiphy_debug(wiphy, format, args...)			\
	wiphy_printk(KERN_DEBUG, wiphy, format, ##args)

#define wiphy_dbg(wiphy, format, args...)			\
	dev_dbg(&(wiphy)->dev, format, ##args)

#if defined(VERBOSE_DEBUG)
#define wiphy_vdbg	wiphy_dbg
#else
#define wiphy_vdbg(wiphy, format, args...)				\
({									\
	if (0)								\
		wiphy_printk(KERN_DEBUG, wiphy, format, ##args);	\
	0;								\
})
#endif

/*
 * wiphy_WARN() acts like wiphy_printk(), but with the key difference
 * of using a WARN/WARN_ON to get the message out, including the
 * file/line information and a backtrace.
 */
#define wiphy_WARN(wiphy, format, args...)			\
	WARN(1, "wiphy: %s\n" format, wiphy_name(wiphy), ##args);

#endif /* __NET_CFG80211_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #define radeon_PCI_IDS \
	{0x1002, 0x1304, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1305, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1306, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1307, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1309, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x130A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x130B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x130C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x130D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x130E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x130F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1310, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1311, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1312, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1313, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1315, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1316, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1317, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x1318, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x131B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x131C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x131D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KAVERI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x3150, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
	{0x1002, 0x3151, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x3152, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x3154, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x3155, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x3E50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x3E54, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4136, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|RADEON_IS_IGP}, \
	{0x1002, 0x4137, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP}, \
	{0x1002, 0x4144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
	{0x1002, 0x4145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
	{0x1002, 0x4146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
	{0x1002, 0x4147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
	{0x1002, 0x4148, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
	{0x1002, 0x4149, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
	{0x1002, 0x414A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
	{0x1002, 0x414B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
	{0x1002, 0x4150, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
	{0x1002, 0x4151, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
	{0x1002, 0x4152, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
	{0x1002, 0x4153, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
	{0x1002, 0x4154, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
	{0x1002, 0x4155, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
	{0x1002, 0x4156, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
	{0x1002, 0x4237, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP}, \
	{0x1002, 0x4242, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
	{0x1002, 0x4336, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4337, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4437, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4966, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV250}, \
	{0x1002, 0x4967, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV250}, \
	{0x1002, 0x4A48, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4A49, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4A4A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4A4B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4A4C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4A4D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4A4E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4A4F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4A50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4A54, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4B48, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4B49, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4B4A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4B4B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4B4C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R420|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x4C57, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4C58, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4C59, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4C5A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4C64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV250|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4C66, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV250|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4C67, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV250|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4E44, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
	{0x1002, 0x4E45, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
	{0x1002, 0x4E46, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
	{0x1002, 0x4E47, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
	{0x1002, 0x4E48, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
	{0x1002, 0x4E49, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
	{0x1002, 0x4E4A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
	{0x1002, 0x4E4B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R350}, \
	{0x1002, 0x4E50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4E51, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4E52, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4E53, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4E54, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
	{0x1002, 0x4E56, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|RADEON_IS_MOBILITY}, \
	{0x1002, 0x5144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|RADEON_SINGLE_CRTC}, \
	{0x1002, 0x5145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|RADEON_SINGLE_CRTC}, \
	{0x1002, 0x5146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|RADEON_SINGLE_CRTC}, \
	{0x1002, 0x5147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|RADEON_SINGLE_CRTC}, \
	{0x1002, 0x5148, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
	{0x1002, 0x514C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
	{0x1002, 0x514D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
	{0x1002, 0x5157, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200}, \
	{0x1002, 0x5158, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200}, \
	{0x1002, 0x5159, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
	{0x1002, 0x515A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
	{0x1002, 0x515E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|RADEON_SINGLE_CRTC}, \
	{0x1002, 0x5460, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
	{0x1002, 0x5462, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
	{0x1002, 0x5464, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
	{0x1002, 0x5548, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5549, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x554A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x554B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x554C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x554D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x554E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x554F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5550, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5551, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5552, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5554, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x564A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x564B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x564F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5652, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5653, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5657, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|RADEON_IS_IGP}, \
	{0x1002, 0x5835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
	{0x1002, 0x5954, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
	{0x1002, 0x5955, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
	{0x1002, 0x5974, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
	{0x1002, 0x5975, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
	{0x1002, 0x5960, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
	{0x1002, 0x5961, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
	{0x1002, 0x5962, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
	{0x1002, 0x5964, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
	{0x1002, 0x5965, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
	{0x1002, 0x5969, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|RADEON_SINGLE_CRTC}, \
	{0x1002, 0x5a41, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS400|RADEON_IS_IGP|RADEON_IS_IGPGART}, \
	{0x1002, 0x5a42, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
	{0x1002, 0x5a61, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS400|RADEON_IS_IGP|RADEON_IS_IGPGART}, \
	{0x1002, 0x5a62, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
	{0x1002, 0x5b60, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5b62, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5b63, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5b64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5b65, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5c61, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|RADEON_IS_MOBILITY}, \
	{0x1002, 0x5c63, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|RADEON_IS_MOBILITY}, \
	{0x1002, 0x5d48, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5d49, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5d4a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5d4c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5d4d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5d4e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5d4f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5d50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5d52, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5d57, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5e48, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5e4a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5e4b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5e4c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5e4d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x5e4f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6600, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6601, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6602, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6603, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6604, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6605, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6606, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6607, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6608, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6610, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6611, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6613, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6617, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6620, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6621, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6623, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6631, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6640, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6641, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6646, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6647, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6649, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6650, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6651, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6658, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x665c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x665d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x665f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6660, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6663, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6664, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6665, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6667, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x666F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6700, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6701, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6702, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6703, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6704, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6705, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6706, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6707, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6708, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6709, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6718, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6719, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x671c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x671d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x671f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAYMAN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6720, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6721, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6722, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6723, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6724, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6725, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6726, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6727, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6728, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6729, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6738, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6739, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x673e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BARTS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6740, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6741, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6742, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6743, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6744, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6745, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6746, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6747, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6748, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6749, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x674A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6750, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6751, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6758, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6759, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x675B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x675D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x675F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6760, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6761, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6762, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6763, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6764, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6765, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6766, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6767, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6768, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6770, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6771, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6772, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6778, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6779, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x677B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CAICOS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6780, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6784, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6788, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x678A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6790, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6791, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6792, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6798, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6799, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x679A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x679B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x679E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x679F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TAHITI|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67A0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67A1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67A2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67A8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67A9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67AA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67B0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67B1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67B8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67B9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67BA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x67BE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6800, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6801, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6802, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6806, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6808, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6809, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6810, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6811, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6816, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6817, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6818, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6819, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6820, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6821, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6822, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6823, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6824, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6825, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6826, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6827, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6828, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6829, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x682A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x682B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x682C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x682D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x682F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6830, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6831, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6837, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6838, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6839, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x683B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x683D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x683F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_VERDE|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6840, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6841, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6842, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6843, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6849, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x684C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6850, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6858, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6859, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TURKS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6880, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6888, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6889, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x688A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x688C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x688D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6898, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x6899, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x689b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x689c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HEMLOCK|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x689d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HEMLOCK|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x689e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CYPRESS|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68a0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68a1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68a8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68a9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68b8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68b9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68ba, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68be, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68bf, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_JUNIPER|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68c1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68c7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68c8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68c9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68d8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68d9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68da, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68de, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_REDWOOD|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68e0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68e1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68e4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68e5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68e8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68e9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68f1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68f2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68f8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68f9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68fa, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x68fe, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_CEDAR|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7101, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7102, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7103, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7104, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7105, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7106, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7108, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7109, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x710A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x710B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x710C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x710E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x710F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R520|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7140, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7141, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7142, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7143, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7149, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x714A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x714B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x714C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x714D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x714E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x714F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7151, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7152, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7153, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x715E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x715F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7180, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7181, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7183, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7186, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7187, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7188, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x718A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x718B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x718C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x718D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x718F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7193, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7196, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x719B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x719F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71C0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71C1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71C2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71C3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71C4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71C5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71C6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71C7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71CD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71CE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71D2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71D4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71D5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71D6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71DA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x71DE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7200, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7210, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7211, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7240, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7243, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7244, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7245, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7246, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7247, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7248, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7249, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x724A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x724B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x724C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x724D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x724E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x724F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7280, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV570|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7281, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7283, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7284, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R580|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7287, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7288, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV570|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7289, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV570|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x728B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV570|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x728C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV570|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7290, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7291, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7293, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7297, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV560|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|RADEON_IS_IGP|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x791e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS690|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
	{0x1002, 0x791f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS690|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
	{0x1002, 0x793f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS600|RADEON_IS_IGP|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7941, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS600|RADEON_IS_IGP|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x7942, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS600|RADEON_IS_IGP|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x796c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS740|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
	{0x1002, 0x796d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS740|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
	{0x1002, 0x796e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS740|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
	{0x1002, 0x796f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS740|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART}, \
	{0x1002, 0x9400, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9401, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9402, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9403, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9405, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x940A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x940B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x940F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R600|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94A0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94A1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94A3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94B1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94B3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94B4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94B5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94B9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9440, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9441, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9442, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9443, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9444, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9446, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x944A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x944B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x944C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x944E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9450, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9452, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9456, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x945A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x945B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x945E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9460, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9462, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x946A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x946B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x947A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x947B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9480, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9487, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9488, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9489, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x948A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x948F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9490, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9491, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9495, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9498, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x949C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x949E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x949F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV730|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94C0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94C1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94C3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94C4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94C5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94C6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94C7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94C8, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94C9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94CB, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94CC, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x94CD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV610|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9500, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9501, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9504, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9505, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9506, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9507, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9508, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9509, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x950F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9511, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9515, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9517, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9519, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV670|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9540, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9541, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9542, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x954E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x954F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9552, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9553, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9555, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9557, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x955f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9580, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9581, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9583, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9586, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9587, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9588, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9589, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x958A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x958B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x958C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x958D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x958E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x958F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV630|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9590, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9591, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9593, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9595, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9596, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9597, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9598, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9599, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x959B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95C0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95C2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95C4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95C5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95C6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95C7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95C9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95CC, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95CD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95CE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x95CF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV620|RADEON_NEW_MEMMAP}, \
	{0x1002, 0x9610, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9611, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9612, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9613, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9614, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9615, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9616, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9640, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9641, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9642, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO2|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9643, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO2|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9644, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO2|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9645, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO2|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9647, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},\
	{0x1002, 0x9648, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},\
	{0x1002, 0x9649, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO2|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},\
	{0x1002, 0x964a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x964b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x964c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x964e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},\
	{0x1002, 0x964f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},\
	{0x1002, 0x9710, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9711, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9712, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9713, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9714, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9715, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9802, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9803, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9804, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9805, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9806, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9807, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9808, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9809, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x980A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9830, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9831, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9832, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9833, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9836, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9837, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9838, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9839, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x983a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x983b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x983c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x983d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x983e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x983f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_KABINI|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9850, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9851, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9852, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9853, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9854, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9855, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9856, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9857, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9858, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9859, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x985A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x985B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x985C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x985D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x985E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x985F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9900, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9901, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9903, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9904, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9905, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9906, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9907, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9908, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9909, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x990A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x990B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x990C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x990D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x990E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x990F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9910, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9913, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9917, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9918, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9919, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9990, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9991, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9992, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9993, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9994, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9995, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9996, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9997, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9998, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x9999, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x999A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x999B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x999C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x999D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x99A0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x99A2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0x1002, 0x99A4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP}, \
	{0, 0, 0}

#define r128_PCI_IDS \
	{0x1002, 0x4c45, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x4c46, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x4d46, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x4d4c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5041, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5042, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5043, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5044, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5045, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5046, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5047, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5048, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5049, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x504A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x504B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x504C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x504D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x504E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x504F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5050, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5051, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5053, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5054, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5055, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5056, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5057, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5058, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5245, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5246, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5247, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x524b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x524c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x534d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5446, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x544C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1002, 0x5452, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0, 0, 0}

#define mga_PCI_IDS \
	{0x102b, 0x0520, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MGA_CARD_TYPE_G200}, \
	{0x102b, 0x0521, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MGA_CARD_TYPE_G200}, \
	{0x102b, 0x0525, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MGA_CARD_TYPE_G400}, \
	{0x102b, 0x2527, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MGA_CARD_TYPE_G550}, \
	{0, 0, 0}

#define sisdrv_PCI_IDS \
	{0x1039, 0x0300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1039, 0x5300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1039, 0x6300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1039, 0x6330, PCI_ANY_ID, PCI_ANY_ID, 0, 0, SIS_CHIP_315}, \
	{0x1039, 0x6351, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1039, 0x7300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x18CA, 0x0040, PCI_ANY_ID, PCI_ANY_ID, 0, 0, SIS_CHIP_315}, \
	{0x18CA, 0x0042, PCI_ANY_ID, PCI_ANY_ID, 0, 0, SIS_CHIP_315}, \
	{0, 0, 0}

#define tdfx_PCI_IDS \
	{0x121a, 0x0003, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x121a, 0x0004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x121a, 0x0005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x121a, 0x0007, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x121a, 0x0009, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x121a, 0x000b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0, 0, 0}

#define viadrv_PCI_IDS \
	{0x1106, 0x3022, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1106, 0x3118, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VIA_PRO_GROUP_A}, \
	{0x1106, 0x3122, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1106, 0x7205, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1106, 0x3108, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1106, 0x3344, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1106, 0x3343, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x1106, 0x3230, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VIA_DX9_0}, \
	{0x1106, 0x3157, PCI_ANY_ID, PCI_ANY_ID, 0, 0, VIA_PRO_GROUP_A}, \
	{0, 0, 0}

#define i810_PCI_IDS \
	{0x8086, 0x7121, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x8086, 0x7123, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x8086, 0x7125, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0x8086, 0x1132, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
	{0, 0, 0}

#define savage_PCI_IDS \
	{0x5333, 0x8a20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE3D}, \
	{0x5333, 0x8a21, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE3D}, \
	{0x5333, 0x8a22, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE4}, \
	{0x5333, 0x8a23, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE4}, \
	{0x5333, 0x8c10, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE_MX}, \
	{0x5333, 0x8c11, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE_MX}, \
	{0x5333, 0x8c12, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE_MX}, \
	{0x5333, 0x8c13, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SAVAGE_MX}, \
	{0x5333, 0x8c22, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
	{0x5333, 0x8c24, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
	{0x5333, 0x8c26, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
	{0x5333, 0x8c2a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
	{0x5333, 0x8c2b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
	{0x5333, 0x8c2c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
	{0x5333, 0x8c2d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
	{0x5333, 0x8c2e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
	{0x5333, 0x8c2f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_SUPERSAVAGE}, \
	{0x5333, 0x8a25, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_PROSAVAGE}, \
	{0x5333, 0x8a26, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_PROSAVAGE}, \
	{0x5333, 0x8d01, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_TWISTER}, \
	{0x5333, 0x8d02, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_TWISTER}, \
	{0x5333, 0x8d03, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_PROSAVAGEDDR}, \
	{0x5333, 0x8d04, PCI_ANY_ID, PCI_ANY_ID, 0, 0, S3_PROSAVAGEDDR}, \
	{0, 0, 0}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             config ARCH
	string
	option env="ARCH"

config KERNELVERSION
	string
	option env="KERNELVERSION"

config DEFCONFIG_LIST
	string
	depends on !UML
	option defconfig_list
	default "/lib/modules/$UNAME_RELEASE/.config"
	default "/etc/kernel-config"
	default "/boot/config-$UNAME_RELEASE"
	default "$ARCH_DEFCONFIG"
	default "arch/$ARCH/defconfig"

config CONSTRUCTORS
	bool
	depends on !UML

config IRQ_WORK
	bool

config BUILDTIME_EXTABLE_SORT
	bool

menu "General setup"

config BROKEN
	bool

config BROKEN_ON_SMP
	bool
	depends on BROKEN || !SMP
	default y

config INIT_ENV_ARG_LIMIT
	int
	default 32 if !UML
	default 128 if UML
	help
	  Maximum of each of the number of arguments and environment
	  variables passed to init from the kernel command line.


config CROSS_COMPILE
	string "Cross-compiler tool prefix"
	help
	  Same as running 'make CROSS_COMPILE=prefix-' but stored for
	  default make runs in this kernel build directory.  You don't
	  need to set this unless you want the configured kernel build
	  directory to select the cross-compiler automatically.

config COMPILE_TEST
	bool "Compile also drivers which will not load"
	default n
	help
	  Some drivers can be compiled on a different platform than they are
	  intended to be run on. Despite they cannot be loaded there (or even
	  when they load they cannot be used due to missing HW support),
	  developers still, opposing to distributors, might want to build such
	  drivers to compile-test them.

	  If you are a developer and want to build everything available, say Y
	  here. If you are a user/distributor, say N here to exclude useless
	  drivers to be distributed.

config LOCALVERSION
	string "Local version - append to kernel release"
	default "-ipipe"
	help
	  Append an extra string to the end of your kernel version.
	  This will show up when you type uname, for example.
	  The string you set here will be appended after the contents of
	  any files with a filename matching localversion* in your
	  object and source tree, in that order.  Your total string can
	  be a maximum of 64 characters.

config LOCALVERSION_AUTO
	bool "Automatically append version information to the version string"
	default y
	help
	  This will try to automatically determine if the current tree is a
	  release tree by looking for git tags that belong to the current
	  top of tree revision.

	  A string of the format -gxxxxxxxx will be added to the localversion
	  if a git-based tree is found.  The string generated by this will be
	  appended after any matching localversion* files, and after the value
	  set in CONFIG_LOCALVERSION.

	  (The actual string used here is the first eight characters produced
	  by running the command:

	    $ git rev-parse --verify HEAD

	  which is done within the script "scripts/setlocalversion".)

config HAVE_KERNEL_GZIP
	bool

config HAVE_KERNEL_BZIP2
	bool

config HAVE_KERNEL_LZMA
	bool

config HAVE_KERNEL_XZ
	bool

config HAVE_KERNEL_LZO
	bool

config HAVE_KERNEL_LZ4
	bool

choice
	prompt "Kernel compression mode"
	default KERNEL_GZIP
	depends on HAVE_KERNEL_GZIP || HAVE_KERNEL_BZIP2 || HAVE_KERNEL_LZMA || HAVE_KERNEL_XZ || HAVE_KERNEL_LZO || HAVE_KERNEL_LZ4
	help
	  The linux kernel is a kind of self-extracting executable.
	  Several compression algorithms are available, which differ
	  in efficiency, compression and decompression speed.
	  Compression speed is only relevant when building a kernel.
	  Decompression speed is relevant at each boot.

	  If you have any problems with bzip2 or lzma compressed
	  kernels, mail me (Alain Knaff) <alain@knaff.lu>. (An older
	  version of this functionality (bzip2 only), for 2.4, was
	  supplied by Christian Ludwig)

	  High compression options are mostly useful for users, who
	  are low on disk space (embedded systems), but for whom ram
	  size matters less.

	  If in doubt, select 'gzip'

config KERNEL_GZIP
	bool "Gzip"
	depends on HAVE_KERNEL_GZIP
	help
	  The old and tried gzip compression. It provides a good balance
	  between compression ratio and decompression speed.

config KERNEL_BZIP2
	bool "Bzip2"
	depends on HAVE_KERNEL_BZIP2
	help
	  Its compression ratio and speed is intermediate.
	  Decompression speed is slowest among the choices.  The kernel
	  size is about 10% smaller with bzip2, in comparison to gzip.
	  Bzip2 uses a large amount of memory. For modern kernels you
	  will need at least 8MB RAM or more for booting.

config KERNEL_LZMA
	bool "LZMA"
	depends on HAVE_KERNEL_LZMA
	help
	  This compression algorithm's ratio is best.  Decompression speed
	  is between gzip and bzip2.  Compression is slowest.
	  The kernel size is about 33% smaller with LZMA in comparison to gzip.

config KERNEL_XZ
	bool "XZ"
	depends on HAVE_KERNEL_XZ
	help
	  XZ uses the LZMA2 algorithm and instruction set specific
	  BCJ filters which can improve compression ratio of executable
	  code. The size of the kernel is about 30% smaller with XZ in
	  comparison to gzip. On architectures for which there is a BCJ
	  filter (i386, x86_64, ARM, IA-64, PowerPC, and SPARC), XZ
	  will create a few percent smaller kernel than plain LZMA.

	  The speed is about the same as with LZMA: The decompression
	  speed of XZ is better than that of bzip2 but worse than gzip
	  and LZO. Compression is slow.

config KERNEL_LZO
	bool "LZO"
	depends on HAVE_KERNEL_LZO
	help
	  Its compression ratio is the poorest among the choices. The kernel
	  size is about 10% bigger than gzip; however its speed
	  (both compression and decompression) is the fastest.

config KERNEL_LZ4
	bool "LZ4"
	depends on HAVE_KERNEL_LZ4
	help
	  LZ4 is an LZ77-type compressor with a fixed, byte-oriented encoding.
	  A preliminary version of LZ4 de/compression tool is available at
	  <https://code.google.com/p/lz4/>.

	  Its compression ratio is worse than LZO. The size of the kernel
	  is about 8% bigger than LZO. But the decompression speed is
	  faster than LZO.

endchoice

config DEFAULT_HOSTNAME
	string "Default hostname"
	default "(none)"
	help
	  This option determines the default system hostname before userspace
	  calls sethostname(2). The kernel traditionally uses "(none)" here,
	  but you may wish to use a different default here to make a minimal
	  system more usable with less configuration.

config SWAP
	bool "Support for paging of anonymous memory (swap)"
	depends on MMU && BLOCK
	default y
	help
	  This option allows you to choose whether you want to have support
	  for so called swap devices or swap files in your kernel that are
	  used to provide more virtual memory than the actual RAM present
	  in your computer.  If unsure say Y.

config SYSVIPC
	bool "System V IPC"
	---help---
	  Inter Process Communication is a suite of library functions and
	  system calls which let processes (running programs) synchronize and
	  exchange information. It is generally considered to be a good thing,
	  and some programs won't run unless you say Y here. In particular, if
	  you want to run the DOS emulator dosemu under Linux (read the
	  DOSEMU-HOWTO, available from <http://www.tldp.org/docs.html#howto>),
	  you'll need to say Y here.

	  You can find documentation about IPC with "info ipc" and also in
	  section 6.4 of the Linux Programmer's Guide, available from
	  <http://www.tldp.org/guides.html>.

config SYSVIPC_SYSCTL
	bool
	depends on SYSVIPC
	depends on SYSCTL
	default y

config POSIX_MQUEUE
	bool "POSIX Message Queues"
	depends on NET
	---help---
	  POSIX variant of message queues is a part of IPC. In POSIX message
	  queues every message has a priority which decides about succession
	  of receiving it by a process. If you want to compile and run
	  programs written e.g. for Solaris with use of its POSIX message
	  queues (functions mq_*) say Y here.

	  POSIX message queues are visible as a filesystem called 'mqueue'
	  and can be mounted somewhere if you want to do filesystem
	  operations on message queues.

	  If unsure, say Y.

config POSIX_MQUEUE_SYSCTL
	bool
	depends on POSIX_MQUEUE
	depends on SYSCTL
	default y

config CROSS_MEMORY_ATTACH
	bool "Enable process_vm_readv/writev syscalls"
	depends on MMU
	default y
	help
	  Enabling this option adds the system calls process_vm_readv and
	  process_vm_writev which allow a process with the correct privileges
	  to directly read from or write to another process' address space.
	  See the man page for more details.

config FHANDLE
	bool "open by fhandle syscalls"
	select EXPORTFS
	help
	  If you say Y here, a user level program will be able to map
	  file names to handle and then later use the handle for
	  different file system operations. This is useful in implementing
	  userspace file servers, which now track files using handles instead
	  of names. The handle would remain the same even if file names
	  get renamed. Enables open_by_handle_at(2) and name_to_handle_at(2)
	  syscalls.

config USELIB
	bool "uselib syscall"
	default y
	help
	  This option enables the uselib syscall, a system call used in the
	  dynamic linker from libc5 and earlier.  glibc does not use this
	  system call.  If you intend to run programs built on libc5 or
	  earlier, you may need to enable this syscall.  Current systems
	  running glibc can safely disable this.

config AUDIT
	bool "Auditing support"
	depends on NET
	help
	  Enable auditing infrastructure that can be used with another
	  kernel subsystem, such as SELinux (which requires this for
	  logging of avc messages output).  Does not do system-call
	  auditing without CONFIG_AUDITSYSCALL.

config HAVE_ARCH_AUDITSYSCALL
	bool

config AUDITSYSCALL
	bool "Enable system-call auditing support"
	depends on AUDIT && HAVE_ARCH_AUDITSYSCALL
	default y if SECURITY_SELINUX
	help
	  Enable low-overhead system-call auditing infrastructure that
	  can be used independently or with another kernel subsystem,
	  such as SELinux.

config AUDIT_WATCH
	def_bool y
	depends on AUDITSYSCALL
	select FSNOTIFY

config AUDIT_TREE
	def_bool y
	depends on AUDITSYSCALL
	select FSNOTIFY

source "kernel/irq/Kconfig"
source "kernel/time/Kconfig"

menu "CPU/Task time and stats accounting"

config VIRT_CPU_ACCOUNTING
	bool

choice
	prompt "Cputime accounting"
	default TICK_CPU_ACCOUNTING if !PPC64
	default VIRT_CPU_ACCOUNTING_NATIVE if PPC64

# Kind of a stub config for the pure tick based cputime accounting
config TICK_CPU_ACCOUNTING
	bool "Simple tick based cputime accounting"
	depends on !S390 && !NO_HZ_FULL
	help
	  This is the basic tick based cputime accounting that maintains
	  statistics about user, system and idle time spent on per jiffies
	  granularity.

	  If unsure, say Y.

config VIRT_CPU_ACCOUNTING_NATIVE
	bool "Deterministic task and CPU time accounting"
	depends on HAVE_VIRT_CPU_ACCOUNTING && !NO_HZ_FULL
	select VIRT_CPU_ACCOUNTING
	help
	  Select this option to enable more accurate task and CPU time
	  accounting.  This is done by reading a CPU counter on each
	  kernel entry and exit and on transitions within the kernel
	  between system, softirq and hardirq state, so there is a
	  small performance impact.  In the case of s390 or IBM POWER > 5,
	  this also enables accounting of stolen time on logically-partitioned
	  systems.

config VIRT_CPU_ACCOUNTING_GEN
	bool "Full dynticks CPU time accounting"
	depends on HAVE_CONTEXT_TRACKING
	depends on HAVE_VIRT_CPU_ACCOUNTING_GEN
	select VIRT_CPU_ACCOUNTING
	select CONTEXT_TRACKING
	help
	  Select this option to enable task and CPU time accounting on full
	  dynticks systems. This accounting is implemented by watching every
	  kernel-user boundaries using the context tracking subsystem.
	  The accounting is thus performed at the expense of some significant
	  overhead.

	  For now this is only useful if you are working on the full
	  dynticks subsystem development.

	  If unsure, say N.

config IRQ_TIME_ACCOUNTING
	bool "Fine granularity task level IRQ time accounting"
	depends on HAVE_IRQ_TIME_ACCOUNTING && !NO_HZ_FULL
	help
	  Select this option to enable fine granularity task irq time
	  accounting. This is done by reading a timestamp on each
	  transitions between softirq and hardirq state, so there can be a
	  small performance impact.

	  If in doubt, say N here.

endchoice

config BSD_PROCESS_ACCT
	bool "BSD Process Accounting"
	depends on MULTIUSER
	help
	  If you say Y here, a user level program will be able to instruct the
	  kernel (via a special system call) to write process accounting
	  information to a file: whenever a process exits, information about
	  that process will be appended to the file by the kernel.  The
	  information includes things such as creation time, owning user,
	  command name, memory usage, controlling terminal etc. (the complete
	  list is in the struct acct in <file:include/linux/acct.h>).  It is
	  up to the user level program to do useful things with this
	  information.  This is generally a good idea, so say Y.

config BSD_PROCESS_ACCT_V3
	bool "BSD Process Accounting version 3 file format"
	depends on BSD_PROCESS_ACCT
	default n
	help
	  If you say Y here, the process accounting information is written
	  in a new file format that also logs the process IDs of each
	  process and it's parent. Note that this file format is incompatible
	  with previous v0/v1/v2 file formats, so you will need updated tools
	  for processing it. A preliminary version of these tools is available
	  at <http://www.gnu.org/software/acct/>.

config TASKSTATS
	bool "Export task/process statistics through netlink"
	depends on NET
	depends on MULTIUSER
	default n
	help
	  Export selected statistics for tasks/processes through the
	  generic netlink interface. Unlike BSD process accounting, the
	  statistics are available during the lifetime of tasks/processes as
	  responses to commands. Like BSD accounting, they are sent to user
	  space on task exit.

	  Say N if unsure.

config TASK_DELAY_ACCT
	bool "Enable per-task delay accounting"
	depends on TASKSTATS
	help
	  Collect information on time spent by a task waiting for system
	  resources like cpu, synchronous block I/O completion and swapping
	  in pages. Such statistics can help in setting a task's priorities
	  relative to other tasks for cpu, io, rss limits etc.

	  Say N if unsure.

config TASK_XACCT
	bool "Enable extended accounting over taskstats"
	depends on TASKSTATS
	help
	  Collect extended task accounting data and send the data
	  to userland for processing over the taskstats interface.

	  Say N if unsure.

config TASK_IO_ACCOUNTING
	bool "Enable per-task storage I/O accounting"
	depends on TASK_XACCT
	help
	  Collect information on the number of bytes of storage I/O which this
	  task has caused.

	  Say N if unsure.

endmenu # "CPU/Task time and stats accounting"

menu "RCU Subsystem"

choice
	prompt "RCU Implementation"
	default TREE_RCU

config TREE_RCU
	bool "Tree-based hierarchical RCU"
	depends on !PREEMPT && SMP
	help
	  This option selects the RCU implementation that is
	  designed for very large SMP system with hundreds or
	  thousands of CPUs.  It also scales down nicely to
	  smaller systems.

config PREEMPT_RCU
	bool "Preemptible tree-based hierarchical RCU"
	depends on PREEMPT
	help
	  This option selects the RCU implementation that is
	  designed for very large SMP systems with hundreds or
	  thousands of CPUs, but for which real-time response
	  is also required.  It also scales down nicely to
	  smaller systems.

	  Select this option if you are unsure.

config TINY_RCU
	bool "UP-only small-memory-footprint RCU"
	depends on !PREEMPT && !SMP
	help
	  This option selects the RCU implementation that is
	  designed for UP systems from which real-time response
	  is not required.  This option greatly reduces the
	  memory footprint of RCU.

endchoice

config SRCU
	bool
	help
	  This option selects the sleepable version of RCU. This version
	  permits arbitrary sleeping or blocking within RCU read-side critical
	  sections.

config TASKS_RCU
	bool "Task_based RCU implementation using voluntary context switch"
	default n
	select SRCU
	help
	  This option enables a task-based RCU implementation that uses
	  only voluntary context switch (not preemption!), idle, and
	  user-mode execution as quiescent states.

	  If unsure, say N.

config RCU_STALL_COMMON
	def_bool ( TREE_RCU || PREEMPT_RCU || RCU_TRACE )
	help
	  This option enables RCU CPU stall code that is common between
	  the TINY and TREE variants of RCU.  The purpose is to allow
	  the tiny variants to disable RCU CPU stall warnings, while
	  making these warnings mandatory for the tree variants.

config CONTEXT_TRACKING
       bool

config RCU_USER_QS
	bool "Consider userspace as in RCU extended quiescent state"
	depends on HAVE_CONTEXT_TRACKING && SMP
	select CONTEXT_TRACKING
	help
	  This option sets hooks on kernel / userspace boundaries and
	  puts RCU in extended quiescent state when the CPU runs in
	  userspace. It means that when a CPU runs in userspace, it is
	  excluded from the global RCU state machine and thus doesn't
	  try to keep the timer tick on for RCU.

	  Unless you want to hack and help the development of the full
	  dynticks mode, you shouldn't enable this option.  It also
	  adds unnecessary overhead.

	  If unsure say N

config CONTEXT_TRACKING_FORCE
	bool "Force context tracking"
	depends on CONTEXT_TRACKING
	default y if !NO_HZ_FULL
	help
	  The major pre-requirement for full dynticks to work is to
	  support the context tracking subsystem. But there are also
	  other dependencies to provide in order to make the full
	  dynticks working.

	  This option stands for testing when an arch implements the
	  context tracking backend but doesn't yet fullfill all the
	  requirements to make the full dynticks feature working.
	  Without the full dynticks, there is no way to test the support
	  for context tracking and the subsystems that rely on it: RCU
	  userspace extended quiescent state and tickless cputime
	  accounting. This option copes with the absence of the full
	  dynticks subsystem by forcing the context tracking on all
	  CPUs in the system.

	  Say Y only if you're working on the development of an
	  architecture backend for the context tracking.

	  Say N otherwise, this option brings an overhead that you
	  don't want in production.


config RCU_FANOUT
	int "Tree-based hierarchical RCU fanout value"
	range 2 64 if 64BIT
	range 2 32 if !64BIT
	depends on TREE_RCU || PREEMPT_RCU
	default 64 if 64BIT
	default 32 if !64BIT
	help
	  This option controls the fanout of hierarchical implementations
	  of RCU, allowing RCU to work efficiently on machines with
	  large numbers of CPUs.  This value must be at least the fourth
	  root of NR_CPUS, which allows NR_CPUS to be insanely large.
	  The default value of RCU_FANOUT should be used for production
	  systems, but if you are stress-testing the RCU implementation
	  itself, small RCU_FANOUT values allow you to test large-system
	  code paths on small(er) systems.

	  Select a specific number if testing RCU itself.
	  Take the default if unsure.

config RCU_FANOUT_LEAF
	int "Tree-based hierarchical RCU leaf-level fanout value"
	range 2 RCU_FANOUT if 64BIT
	range 2 RCU_FANOUT if !64BIT
	depends on TREE_RCU || PREEMPT_RCU
	default 16
	help
	  This option controls the leaf-level fanout of hierarchical
	  implementations of RCU, and allows trading off cache misses
	  against lock contention.  Systems that synchronize their
	  scheduling-clock interrupts for energy-efficiency reasons will
	  want the default because the smaller leaf-level fanout keeps
	  lock contention levels acceptably low.  Very large systems
	  (hundreds or thousands of CPUs) will instead want to set this
	  value to the maximum value possible in order to reduce the
	  number of cache misses incurred during RCU's grace-period
	  initialization.  These systems tend to run CPU-bound, and thus
	  are not helped by synchronized interrupts, and thus tend to
	  skew them, which reduces lock contention enough that large
	  leaf-level fanouts work well.

	  Select a specific number if testing RCU itself.

	  Select the maximum permissible value for large systems.

	  Take the default if unsure.

config RCU_FANOUT_EXACT
	bool "Disable tree-based hierarchical RCU auto-balancing"
	depends on TREE_RCU || PREEMPT_RCU
	default n
	help
	  This option forces use of the exact RCU_FANOUT value specified,
	  regardless of imbalances in the hierarchy.  This is useful for
	  testing RCU itself, and might one day be useful on systems with
	  strong NUMA behavior.

	  Without RCU_FANOUT_EXACT, the code will balance the hierarchy.

	  Say N if unsure.

config RCU_FAST_NO_HZ
	bool "Accelerate last non-dyntick-idle CPU's grace periods"
	depends on NO_HZ_COMMON && SMP
	default n
	help
	  This option permits CPUs to enter dynticks-idle state even if
	  they have RCU callbacks queued, and prevents RCU from waking
	  these CPUs up more than roughly once every four jiffies (by
	  default, you can adjust this using the rcutree.rcu_idle_gp_delay
	  parameter), thus improving energy efficiency.  On the other
	  hand, this option increases the duration of RCU grace periods,
	  for example, slowing down synchronize_rcu().

	  Say Y if energy efficiency is critically important, and you
	  	don't care about increased grace-period durations.

	  Say N if you are unsure.

config TREE_RCU_TRACE
	def_bool RCU_TRACE && ( TREE_RCU || PREEMPT_RCU )
	select DEBUG_FS
	help
	  This option provides tracing for the TREE_RCU and
	  PREEMPT_RCU implementations, permitting Makefile to
	  trivially select kernel/rcutree_trace.c.

config RCU_BOOST
	bool "Enable RCU priority boosting"
	depends on RT_MUTEXES && PREEMPT_RCU
	default n
	help
	  This option boosts the priority of preempted RCU readers that
	  block the current preemptible RCU grace period for too long.
	  This option also prevents heavy loads from blocking RCU
	  callback invocation for all flavors of RCU.

	  Say Y here if you are working with real-time apps or heavy loads
	  Say N here if you are unsure.

config RCU_KTHREAD_PRIO
	int "Real-time priority to use for RCU worker threads"
	range 1 99 if RCU_BOOST
	range 0 99 if !RCU_BOOST
	default 1 if RCU_BOOST
	default 0 if !RCU_BOOST
	help
	  This option specifies the SCHED_FIFO priority value that will be
	  assigned to the rcuc/n and rcub/n threads and is also the value
	  used for RCU_BOOST (if enabled). If you are working with a
	  real-time application that has one or more CPU-bound threads
	  running at a real-time priority level, you should set
	  RCU_KTHREAD_PRIO to a priority higher than the highest-priority
	  real-time CPU-bound application thread.  The default RCU_KTHREAD_PRIO
	  value of 1 is appropriate in the common case, which is real-time
	  applications that do not have any CPU-bound threads.

	  Some real-time applications might not have a single real-time
	  thread that saturates a given CPU, but instead might have
	  multiple real-time threads that, taken together, fully utilize
	  that CPU.  In this case, you should set RCU_KTHREAD_PRIO to
	  a priority higher than the lowest-priority thread that is
	  conspiring to prevent the CPU from running any non-real-time
	  tasks.  For example, if one thread at priority 10 and another
	  thread at priority 5 are between themselves fully consuming
	  the CPU time on a given CPU, then RCU_KTHREAD_PRIO should be
	  set to priority 6 or higher.

	  Specify the real-time priority, or take the default if unsure.

config RCU_BOOST_DELAY
	int "Milliseconds to delay boosting after RCU grace-period start"
	range 0 3000
	depends on RCU_BOOST
	default 500
	help
	  This option specifies the time to wait after the beginning of
	  a given grace period before priority-boosting preempted RCU
	  readers blocking that grace period.  Note that any RCU reader
	  blocking an expedited RCU grace period is boosted immediately.

	  Accept the default if unsure.

config RCU_NOCB_CPU
	bool "Offload RCU callback processing from boot-selected CPUs"
	depends on TREE_RCU || PREEMPT_RCU
	default n
	help
	  Use this option to reduce OS jitter for aggressive HPC or
	  real-time workloads.	It can also be used to offload RCU
	  callback invocation to energy-efficient CPUs in battery-powered
	  asymmetric multiprocessors.

	  This option offloads callback invocation from the set of
	  CPUs specified at boot time by the rcu_nocbs parameter.
	  For each such CPU, a kthread ("rcuox/N") will be created to
	  invoke callbacks, where the "N" is the CPU being offloaded,
	  and where the "x" is "b" for RCU-bh, "p" for RCU-preempt, and
	  "s" for RCU-sched.  Nothing prevents this kthread from running
	  on the specified CPUs, but (1) the kthreads may be preempted
	  between each callback, and (2) affinity or cgroups can be used
	  to force the kthreads to run on whatever set of CPUs is desired.

	  Say Y here if you want to help to debug reduced OS jitter.
	  Say N here if you are unsure.

choice
	prompt "Build-forced no-CBs CPUs"
	default RCU_NOCB_CPU_NONE
	depends on RCU_NOCB_CPU
	help
	  This option allows no-CBs CPUs (whose RCU callbacks are invoked
	  from kthreads rather than from softirq context) to be specified
	  at build time.  Additional no-CBs CPUs may be specified by
	  the rcu_nocbs= boot parameter.

config RCU_NOCB_CPU_NONE
	bool "No build_forced no-CBs CPUs"
	help
	  This option does not force any of the CPUs to be no-CBs CPUs.
	  Only CPUs designated by the rcu_nocbs= boot parameter will be
	  no-CBs CPUs, whose RCU callbacks will be invoked by per-CPU
	  kthreads whose names begin with "rcuo".  All other CPUs will
	  invoke their own RCU callbacks in softirq context.

	  Select this option if you want to choose no-CBs CPUs at
	  boot time, for example, to allow testing of different no-CBs
	  configurations without having to rebuild the kernel each time.

config RCU_NOCB_CPU_ZERO
	bool "CPU 0 is a build_forced no-CBs CPU"
	help
	  This option forces CPU 0 to be a no-CBs CPU, so that its RCU
	  callbacks are invoked by a per-CPU kthread whose name begins
	  with "rcuo".	Additional CPUs may be designated as no-CBs
	  CPUs using the rcu_nocbs= boot parameter will be no-CBs CPUs.
	  All other CPUs will invoke their own RCU callbacks in softirq
	  context.

	  Select this if CPU 0 needs to be a no-CBs CPU for real-time
	  or energy-efficiency reasons, but the real reason it exists
	  is to ensure that randconfig testing covers mixed systems.

config RCU_NOCB_CPU_ALL
	bool "All CPUs are build_forced no-CBs CPUs"
	help
	  This option forces all CPUs to be no-CBs CPUs.  The rcu_nocbs=
	  boot parameter will be ignored.  All CPUs' RCU callbacks will
	  be executed in the context of per-CPU rcuo kthreads created for
	  this purpose.  Assuming that the kthreads whose names start with
	  "rcuo" are bound to "housekeeping" CPUs, this reduces OS jitter
	  on the remaining CPUs, but might decrease memory locality during
	  RCU-callback invocation, thus potentially degrading throughput.

	  Select this if all CPUs need to be no-CBs CPUs for real-time
	  or energy-efficiency reasons.

endchoice

config RCU_EXPEDITE_BOOT
	bool
	default n
	help
	  This option enables expedited grace periods at boot time,
	  as if rcu_expedite_gp() had been invoked early in boot.
	  The corresponding rcu_unexpedite_gp() is invoked from
	  rcu_end_inkernel_boot(), which is intended to be invoked
	  at the end of the kernel-only boot sequence, just before
	  init is exec'ed.

	  Accept the default if unsure.

endmenu # "RCU Subsystem"

config BUILD_BIN2C
	bool
	default n

config IKCONFIG
	tristate "Kernel .config support"
	select BUILD_BIN2C
	---help---
	  This option enables the complete Linux kernel ".config" file
	  contents to be saved in the kernel. It provides documentation
	  of which kernel options are used in a running kernel or in an
	  on-disk kernel.  This information can be extracted from the kernel
	  image file with the script scripts/extract-ikconfig and used as
	  input to rebuild the current kernel or to build another kernel.
	  It can also be extracted from a running kernel by reading
	  /proc/config.gz if enabled (below).

config IKCONFIG_PROC
	bool "Enable access to .config through /proc/config.gz"
	depends on IKCONFIG && PROC_FS
	---help---
	  This option enables access to the kernel configuration file
	  through /proc/config.gz.

config LOG_BUF_SHIFT
	int "Kernel log buffer size (16 => 64KB, 17 => 128KB)"
	range 12 21
	default 17
	depends on PRINTK
	help
	  Select the minimal kernel log buffer size as a power of 2.
	  The final size is affected by LOG_CPU_MAX_BUF_SHIFT config
	  parameter, see below. Any higher size also might be forced
	  by "log_buf_len" boot parameter.

	  Examples:
		     17 => 128 KB
		     16 => 64 KB
		     15 => 32 KB
		     14 => 16 KB
		     13 =>  8 KB
		     12 =>  4 KB

config LOG_CPU_MAX_BUF_SHIFT
	int "CPU kernel log buffer size contribution (13 => 8 KB, 17 => 128KB)"
	depends on SMP
	range 0 21
	default 12 if !BASE_SMALL
	default 0 if BASE_SMALL
	depends on PRINTK
	help
	  This option allows to increase the default ring buffer size
	  according to the number of CPUs. The value defines the contribution
	  of each CPU as a power of 2. The used space is typically only few
	  lines however it might be much more when problems are reported,
	  e.g. backtraces.

	  The increased size means that a new buffer has to be allocated and
	  the original static one is unused. It makes sense only on systems
	  with more CPUs. Therefore this value is used only when the sum of
	  contributions is greater than the half of the default kernel ring
	  buffer as defined by LOG_BUF_SHIFT. The default values are set
	  so that more than 64 CPUs are needed to trigger the allocation.

	  Also this option is ignored when "log_buf_len" kernel parameter is
	  used as it forces an exact (power of two) size of the ring buffer.

	  The number of possible CPUs is used for this computation ignoring
	  hotplugging making the compuation optimal for the the worst case
	  scenerio while allowing a simple algorithm to be used from bootup.

	  Examples shift values and their meaning:
		     17 => 128 KB for each CPU
		     16 =>  64 KB for each CPU
		     15 =>  32 KB for each CPU
		     14 =>  16 KB for each CPU
		     13 =>   8 KB for each CPU
		     12 =>   4 KB for each CPU

#
# Architectures with an unreliable sched_clock() should select this:
#
config HAVE_UNSTABLE_SCHED_CLOCK
	bool

config GENERIC_SCHED_CLOCK
	bool

#
# For architectures that want to enable the support for NUMA-affine scheduler
# balancing logic:
#
config ARCH_SUPPORTS_NUMA_BALANCING
	bool

#
# For architectures that know their GCC __int128 support is sound
#
config ARCH_SUPPORTS_INT128
	bool

# For architectures that (ab)use NUMA to represent different memory regions
# all cpu-local but of different latencies, such as SuperH.
#
config ARCH_WANT_NUMA_VARIABLE_LOCALITY
	bool

config NUMA_BALANCING
	bool "Memory placement aware NUMA scheduler"
	depends on ARCH_SUPPORTS_NUMA_BALANCING
	depends on !ARCH_WANT_NUMA_VARIABLE_LOCALITY
	depends on SMP && NUMA && MIGRATION
	help
	  This option adds support for automatic NUMA aware memory/task placement.
	  The mechanism is quite primitive and is based on migrating memory when
	  it has references to the node the task is running on.

	  This system will be inactive on UMA systems.

config NUMA_BALANCING_DEFAULT_ENABLED
	bool "Automatically enable NUMA aware memory/task placement"
	default y
	depends on NUMA_BALANCING
	help
	  If set, automatic NUMA balancing will be enabled if running on a NUMA
	  machine.

menuconfig CGROUPS
	bool "Control Group support"
	select KERNFS
	help
	  This option adds support for grouping sets of processes together, for
	  use with process control subsystems such as Cpusets, CFS, memory
	  controls or device isolation.
	  See
		- Documentation/scheduler/sched-design-CFS.txt	(CFS)
		- Documentation/cgroups/ (features for grouping, isolation
					  and resource control)

	  Say N if unsure.

if CGROUPS

config CGROUP_DEBUG
	bool "Example debug cgroup subsystem"
	default n
	help
	  This option enables a simple cgroup subsystem that
	  exports useful debugging information about the cgroups
	  framework.

	  Say N if unsure.

config CGROUP_FREEZER
	bool "Freezer cgroup subsystem"
	help
	  Provides a way to freeze and unfreeze all tasks in a
	  cgroup.

config CGROUP_DEVICE
	bool "Device controller for cgroups"
	help
	  Provides a cgroup implementing whitelists for devices which
	  a process in the cgroup can mknod or open.

config CPUSETS
	bool "Cpuset support"
	help
	  This option will let you create and manage CPUSETs which
	  allow dynamically partitioning a system into sets of CPUs and
	  Memory Nodes and assigning tasks to run only within those sets.
	  This is primarily useful on large SMP or NUMA systems.

	  Say N if unsure.

config PROC_PID_CPUSET
	bool "Include legacy /proc/<pid>/cpuset file"
	depends on CPUSETS
	default y

config CGROUP_CPUACCT
	bool "Simple CPU accounting cgroup subsystem"
	help
	  Provides a simple Resource Controller for monitoring the
	  total CPU consumed by the tasks in a cgroup.

config PAGE_COUNTER
       bool

config MEMCG
	bool "Memory Resource Controller for Control Groups"
	select PAGE_COUNTER
	select EVENTFD
	help
	  Provides a memory resource controller that manages both anonymous
	  memory and page cache. (See Documentation/cgroups/memory.txt)

config MEMCG_SWAP
	bool "Memory Resource Controller Swap Extension"
	depends on MEMCG && SWAP
	help
	  Add swap management feature to memory resource controller. When you
	  enable this, you can limit mem+swap usage per cgroup. In other words,
	  when you disable this, memory resource controller has no cares to
	  usage of swap...a process can exhaust all of the swap. This extension
	  is useful when you want to avoid exhaustion swap but this itself
	  adds more overheads and consumes memory for remembering information.
	  Especially if you use 32bit system or small memory system, please
	  be careful about enabling this. When memory resource controller
	  is disabled by boot option, this will be automatically disabled and
	  there will be no overhead from this. Even when you set this config=y,
	  if boot option "swapaccount=0" is set, swap will not be accounted.
	  Now, memory usage of swap_cgroup is 2 bytes per entry. If swap page
	  size is 4096bytes, 512k per 1Gbytes of swap.
config MEMCG_SWAP_ENABLED
	bool "Memory Resource Controller Swap Extension enabled by default"
	depends on MEMCG_SWAP
	default y
	help
	  Memory Resource Controller Swap Extension comes with its price in
	  a bigger memory consumption. General purpose distribution kernels
	  which want to enable the feature but keep it disabled by default
	  and let the user enable it by swapaccount=1 boot command line
	  parameter should have this option unselected.
	  For those who want to have the feature enabled by default should
	  select this option (if, for some reason, they need to disable it
	  then swapaccount=0 does the trick).
config MEMCG_KMEM
	bool "Memory Resource Controller Kernel Memory accounting"
	depends on MEMCG
	depends on SLUB || SLAB
	help
	  The Kernel Memory extension for Memory Resource Controller can limit
	  the amount of memory used by kernel objects in the system. Those are
	  fundamentally different from the entities handled by the standard
	  Memory Controller, which are page-based, and can be swapped. Users of
	  the kmem extension can use it to guarantee that no group of processes
	  will ever exhaust kernel resources alone.

config CGROUP_HUGETLB
	bool "HugeTLB Resource Controller for Control Groups"
	depends on HUGETLB_PAGE
	select PAGE_COUNTER
	default n
	help
	  Provides a cgroup Resource Controller for HugeTLB pages.
	  When you enable this, you can put a per cgroup limit on HugeTLB usage.
	  The limit is enforced during page fault. Since HugeTLB doesn't
	  support page reclaim, enforcing the limit at page fault time implies
	  that, the application will get SIGBUS signal if it tries to access
	  HugeTLB pages beyond its limit. This requires the application to know
	  beforehand how much HugeTLB pages it would require for its use. The
	  control group is tracked in the third page lru pointer. This means
	  that we cannot use the controller with huge page less than 3 pages.

config CGROUP_PERF
	bool "Enable perf_event per-cpu per-container group (cgroup) monitoring"
	depends on PERF_EVENTS && CGROUPS
	help
	  This option extends the per-cpu mode to restrict monitoring to
	  threads which belong to the cgroup specified and run on the
	  designated cpu.

	  Say N if unsure.

menuconfig CGROUP_SCHED
	bool "Group CPU scheduler"
	default n
	help
	  This feature lets CPU scheduler recognize task groups and control CPU
	  bandwidth allocation to such task groups. It uses cgroups to group
	  tasks.

if CGROUP_SCHED
config FAIR_GROUP_SCHED
	bool "Group scheduling for SCHED_OTHER"
	depends on CGROUP_SCHED
	default CGROUP_SCHED

config CFS_BANDWIDTH
	bool "CPU bandwidth provisioning for FAIR_GROUP_SCHED"
	depends on FAIR_GROUP_SCHED
	default n
	help
	  This option allows users to define CPU bandwidth rates (limits) for
	  tasks running within the fair group scheduler.  Groups with no limit
	  set are considered to be unconstrained and will run with no
	  restriction.
	  See tip/Documentation/scheduler/sched-bwc.txt for more information.

config RT_GROUP_SCHED
	bool "Group scheduling for SCHED_RR/FIFO"
	depends on CGROUP_SCHED
	default n
	help
	  This feature lets you explicitly allocate real CPU bandwidth
	  to task groups. If enabled, it will also make it impossible to
	  schedule realtime tasks for non-root users until you allocate
	  realtime bandwidth for them.
	  See Documentation/scheduler/sched-rt-group.txt for more information.

endif #CGROUP_SCHED

config BLK_CGROUP
	bool "Block IO controller"
	depends on BLOCK
	default n
	---help---
	Generic block IO controller cgroup interface. This is the common
	cgroup interface which should be used by various IO controlling
	policies.

	Currently, CFQ IO scheduler uses it to recognize task groups and
	control disk bandwidth allocation (proportional time slice allocation)
	to such task groups. It is also used by bio throttling logic in
	block layer to implement upper limit in IO rates on a device.

	This option only enables generic Block IO controller infrastructure.
	One needs to also enable actual IO controlling logic/policy. For
	enabling proportional weight division of disk bandwidth in CFQ, set
	CONFIG_CFQ_GROUP_IOSCHED=y; for enabling throttling policy, set
	CONFIG_BLK_DEV_THROTTLING=y.

	See Documentation/cgroups/blkio-controller.txt for more information.

config DEBUG_BLK_CGROUP
	bool "Enable Block IO controller debugging"
	depends on BLK_CGROUP
	default n
	---help---
	Enable some debugging help. Currently it exports additional stat
	files in a cgroup which can be useful for debugging.

endif # CGROUPS

config CHECKPOINT_RESTORE
	bool "Checkpoint/restore support" if EXPERT
	default n
	help
	  Enables additional kernel features in a sake of checkpoint/restore.
	  In particular it adds auxiliary prctl codes to setup process text,
	  data and heap segment sizes, and a few additional /proc filesystem
	  entries.

	  If unsure, say N here.

menuconfig NAMESPACES
	bool "Namespaces support" if EXPERT
	depends on MULTIUSER
	default !EXPERT
	help
	  Provides the way to make tasks work with different objects using
	  the same id. For example same IPC id may refer to different objects
	  or same user id or pid may refer to different tasks when used in
	  different namespaces.

if NAMESPACES

config UTS_NS
	bool "UTS namespace"
	default y
	help
	  In this namespace tasks see different info provided with the
	  uname() system call

config IPC_NS
	bool "IPC namespace"
	depends on (SYSVIPC || POSIX_MQUEUE)
	default y
	help
	  In this namespace tasks work with IPC ids which correspond to
	  different IPC objects in different namespaces.

config USER_NS
	bool "User namespace"
	default n
	help
	  This allows containers, i.e. vservers, to use user namespaces
	  to provide different user info for different servers.

	  When user namespaces are enabled in the kernel it is
	  recommended that the MEMCG and MEMCG_KMEM options also be
	  enabled and that user-space use the memory control groups to
	  limit the amount of memory a memory unprivileged users can
	  use.

	  If unsure, say N.

config PID_NS
	bool "PID Namespaces"
	default y
	help
	  Support process id namespaces.  This allows having multiple
	  processes with the same pid as long as they are in different
	  pid namespaces.  This is a building block of containers.

config NET_NS
	bool "Network namespace"
	depends on NET
	default y
	help
	  Allow user space to create what appear to be multiple instances
	  of the network stack.

endif # NAMESPACES

config SCHED_AUTOGROUP
	bool "Automatic process group scheduling"
	select CGROUPS
	select CGROUP_SCHED
	select FAIR_GROUP_SCHED
	help
	  This option optimizes the scheduler for common desktop workloads by
	  automatically creating and populating task groups.  This separation
	  of workloads isolates aggressive CPU burners (like build jobs) from
	  desktop applications.  Task group autogeneration is currently based
	  upon task session.

config SYSFS_DEPRECATED
	bool "Enable deprecated sysfs features to support old userspace tools"
	depends on SYSFS
	default n
	help
	  This option adds code that switches the layout of the "block" class
	  devices, to not show up in /sys/class/block/, but only in
	  /sys/block/.

	  This switch is only active when the sysfs.deprecated=1 boot option is
	  passed or the SYSFS_DEPRECATED_V2 option is set.

	  This option allows new kernels to run on old distributions and tools,
	  which might get confused by /sys/class/block/. Since 2007/2008 all
	  major distributions and tools handle this just fine.

	  Recent distributions and userspace tools after 2009/2010 depend on
	  the existence of /sys/class/block/, and will not work with this
	  option enabled.

	  Only if you are using a new kernel on an old distribution, you might
	  need to say Y here.

config SYSFS_DEPRECATED_V2
	bool "Enable deprecated sysfs features by default"
	default n
	depends on SYSFS
	depends on SYSFS_DEPRECATED
	help
	  Enable deprecated sysfs by default.

	  See the CONFIG_SYSFS_DEPRECATED option for more details about this
	  option.

	  Only if you are using a new kernel on an old distribution, you might
	  need to say Y here. Even then, odds are you would not need it
	  enabled, you can always pass the boot option if absolutely necessary.

config RELAY
	bool "Kernel->user space relay support (formerly relayfs)"
	help
	  This option enables support for relay interface support in
	  certain file systems (such as debugfs).
	  It is designed to provide an efficient mechanism for tools and
	  facilities to relay large amounts of data from kernel space to
	  user space.

	  If unsure, say N.

config BLK_DEV_INITRD
	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
	depends on BROKEN || !FRV
	help
	  The initial RAM filesystem is a ramfs which is loaded by the
	  boot loader (loadlin or lilo) and that is mounted as root
	  before the normal boot procedure. It is typically used to
	  load modules needed to mount the "real" root file system,
	  etc. See <file:Documentation/initrd.txt> for details.

	  If RAM disk support (BLK_DEV_RAM) is also included, this
	  also enables initial RAM disk (initrd) support and adds
	  15 Kbytes (more on some other architectures) to the kernel size.

	  If unsure say Y.

if BLK_DEV_INITRD

source "usr/Kconfig"

endif

config CC_OPTIMIZE_FOR_SIZE
	bool "Optimize for size"
	help
	  Enabling this option will pass "-Os" instead of "-O2" to
	  your compiler resulting in a smaller kernel.

	  If unsure, say N.

config SYSCTL
	bool

config ANON_INODES
	bool

config HAVE_UID16
	bool

config SYSCTL_EXCEPTION_TRACE
	bool
	help
	  Enable support for /proc/sys/debug/exception-trace.

config SYSCTL_ARCH_UNALIGN_NO_WARN
	bool
	help
	  Enable support for /proc/sys/kernel/ignore-unaligned-usertrap
	  Allows arch to define/use @no_unaligned_warning to possibly warn
	  about unaligned access emulation going on under the hood.

config SYSCTL_ARCH_UNALIGN_ALLOW
	bool
	help
	  Enable support for /proc/sys/kernel/unaligned-trap
	  Allows arches to define/use @unaligned_enabled to runtime toggle
	  the unaligned access emulation.
	  see arch/parisc/kernel/unaligned.c for reference

config HAVE_PCSPKR_PLATFORM
	bool

# interpreter that classic socket filters depend on
config BPF
	bool

menuconfig EXPERT
	bool "Configure standard kernel features (expert users)"
	# Unhide debug options, to make the on-by-default options visible
	select DEBUG_KERNEL
	help
	  This option allows certain base kernel options and settings
          to be disabled or tweaked. This is for specialized
          environments which can tolerate a "non-standard" kernel.
          Only use this if you really know what you are doing.

config UID16
	bool "Enable 16-bit UID system calls" if EXPERT
	depends on HAVE_UID16 && MULTIUSER
	default y
	help
	  This enables the legacy 16-bit UID syscall wrappers.

config MULTIUSER
	bool "Multiple users, groups and capabilities support" if EXPERT
	default y
	help
	  This option enables support for non-root users, groups and
	  capabilities.

	  If you say N here, all processes will run with UID 0, GID 0, and all
	  possible capabilities.  Saying N here also compiles out support for
	  system calls related to UIDs, GIDs, and capabilities, such as setuid,
	  setgid, and capset.

	  If unsure, say Y here.

config SGETMASK_SYSCALL
	bool "sgetmask/ssetmask syscalls support" if EXPERT
	def_bool PARISC || MN10300 || BLACKFIN || M68K || PPC || MIPS || X86 || SPARC || CRIS || MICROBLAZE || SUPERH
	---help---
	  sys_sgetmask and sys_ssetmask are obsolete system calls
	  no longer supported in libc but still enabled by default in some
	  architectures.

	  If unsure, leave the default option here.

config SYSFS_SYSCALL
	bool "Sysfs syscall support" if EXPERT
	default y
	---help---
	  sys_sysfs is an obsolete system call no longer supported in libc.
	  Note that disabling this option is more secure but might break
	  compatibility with some systems.

	  If unsure say Y here.

config SYSCTL_SYSCALL
	bool "Sysctl syscall support" if EXPERT
	depends on PROC_SYSCTL
	default n
	select SYSCTL
	---help---
	  sys_sysctl uses binary paths that have been found challenging
	  to properly maintain and use.  The interface in /proc/sys
	  using paths with ascii names is now the primary path to this
	  information.

	  Almost nothing using the binary sysctl interface so if you are
	  trying to save some space it is probably safe to disable this,
	  making your kernel marginally smaller.

	  If unsure say N here.

config KALLSYMS
	 bool "Load all symbols for debugging/ksymoops" if EXPERT
	 default y
	 help
	   Say Y here to let the kernel print out symbolic crash information and
	   symbolic stack backtraces. This increases the size of the kernel
	   somewhat, as all symbols have to be loaded into the kernel image.

config KALLSYMS_ALL
	bool "Include all symbols in kallsyms"
	depends on DEBUG_KERNEL && KALLSYMS
	help
	   Normally kallsyms only contains the symbols of functions for nicer
	   OOPS messages and backtraces (i.e., symbols from the text and inittext
	   sections). This is sufficient for most cases. And only in very rare
	   cases (e.g., when a debugger is used) all symbols are required (e.g.,
	   names of variables from the data sections, etc).

	   This option makes sure that all symbols are loaded into the kernel
	   image (i.e., symbols from all sections) in cost of increased kernel
	   size (depending on the kernel configuration, it may be 300KiB or
	   something like this).

	   Say N unless you really need all symbols.

config PRINTK
	default y
	bool "Enable support for printk" if EXPERT
	select IRQ_WORK
	help
	  This option enables normal printk support. Removing it
	  eliminates most of the message strings from the kernel image
	  and makes the kernel more or less silent. As this makes it
	  very difficult to diagnose system problems, saying N here is
	  strongly discouraged.

config RAW_PRINTK
       bool "Enable support for raw printk"
       default n
       help
         This option enables a printk variant called raw_printk() for
         writing all output unmodified to a raw console channel,
         without any header or preparation whatsoever, usable from any
         context.

	 Unlike early_printk() console devices, raw_printk() devices
         can live past the boot sequence.

config BUG
	bool "BUG() support" if EXPERT
	default y
	help
          Disabling this option eliminates support for BUG and WARN, reducing
          the size of your kernel image and potentially quietly ignoring
          numerous fatal conditions. You should only consider disabling this
          option for embedded systems with no facilities for reporting errors.
          Just say Y.

config ELF_CORE
	depends on COREDUMP
	default y
	bool "Enable ELF core dumps" if EXPERT
	help
	  Enable support for generating core dumps. Disabling saves about 4k.


config PCSPKR_PLATFORM
	bool "Enable PC-Speaker support" if EXPERT
	depends on HAVE_PCSPKR_PLATFORM
	select I8253_LOCK
	default y
	help
          This option allows to disable the internal PC-Speaker
          support, saving some memory.

config BASE_FULL
	default y
	bool "Enable full-sized data structures for core" if EXPERT
	help
	  Disabling this option reduces the size of miscellaneous core
	  kernel data structures. This saves memory on small machines,
	  but may reduce performance.

config FUTEX
	bool "Enable futex support" if EXPERT
	default y
	select RT_MUTEXES
	help
	  Disabling this option will cause the kernel to be built without
	  support for "fast userspace mutexes".  The resulting kernel may not
	  run glibc-based applications correctly.

config HAVE_FUTEX_CMPXCHG
	bool
	depends on FUTEX
	help
	  Architectures should select this if futex_atomic_cmpxchg_inatomic()
	  is implemented and always working. This removes a couple of runtime
	  checks.

config EPOLL
	bool "Enable eventpoll support" if EXPERT
	default y
	select ANON_INODES
	help
	  Disabling this option will cause the kernel to be built without
	  support for epoll family of system calls.

config SIGNALFD
	bool "Enable signalfd() system call" if EXPERT
	select ANON_INODES
	default y
	help
	  Enable the signalfd() system call that allows to receive signals
	  on a file descriptor.

	  If unsure, say Y.

config TIMERFD
	bool "Enable timerfd() system call" if EXPERT
	select ANON_INODES
	default y
	help
	  Enable the timerfd() system call that allows to receive timer
	  events on a file descriptor.

	  If unsure, say Y.

config EVENTFD
	bool "Enable eventfd() system call" if EXPERT
	select ANON_INODES
	default y
	help
	  Enable the eventfd() system call that allows to receive both
	  kernel notification (ie. KAIO) or userspace notifications.

	  If unsure, say Y.

# syscall, maps, verifier
config BPF_SYSCALL
	bool "Enable bpf() system call"
	select ANON_INODES
	select BPF
	default n
	help
	  Enable the bpf() system call that allows to manipulate eBPF
	  programs and maps via file descriptors.

config SHMEM
	bool "Use full shmem filesystem" if EXPERT
	default y
	depends on MMU
	help
	  The shmem is an internal filesystem used to manage shared memory.
	  It is backed by swap and manages resource limits. It is also exported
	  to userspace as tmpfs if TMPFS is enabled. Disabling this
	  option replaces shmem and tmpfs with the much simpler ramfs code,
	  which may be appropriate on small systems without swap.

config AIO
	bool "Enable AIO support" if EXPERT
	default y
	help
	  This option enables POSIX asynchronous I/O which may by used
	  by some high performance threaded applications. Disabling
	  this option saves about 7k.

config ADVISE_SYSCALLS
	bool "Enable madvise/fadvise syscalls" if EXPERT
	default y
	help
	  This option enables the madvise and fadvise syscalls, used by
	  applications to advise the kernel about their future memory or file
	  usage, improving performance. If building an embedded system where no
	  applications use these syscalls, you can disable this option to save
	  space.

config PCI_QUIRKS
	default y
	bool "Enable PCI quirk workarounds" if EXPERT
	depends on PCI
	help
	  This enables workarounds for various PCI chipset
	  bugs/quirks. Disable this only if your target machine is
	  unaffected by PCI quirks.

config EMBEDDED
	bool "Embedded system"
	option allnoconfig_y
	select EXPERT
	help
	  This option should be enabled if compiling the kernel for
	  an embedded system so certain expert options are available
	  for configuration.

config HAVE_PERF_EVENTS
	bool
	help
	  See tools/perf/design.txt for details.

config PERF_USE_VMALLOC
	bool
	help
	  See tools/perf/design.txt for details

menu "Kernel Performance Events And Counters"

config PERF_EVENTS
	bool "Kernel performance events and counters"
	default y if PROFILING
	depends on HAVE_PERF_EVENTS
	select ANON_INODES
	select IRQ_WORK
	select SRCU
	help
	  Enable kernel support for various performance events provided
	  by software and hardware.

	  Software events are supported either built-in or via the
	  use of generic tracepoints.

	  Most modern CPUs support performance events via performance
	  counter registers. These registers count the number of certain
	  types of hw events: such as instructions executed, cachemisses
	  suffered, or branches mis-predicted - without slowing down the
	  kernel or applications. These registers can also trigger interrupts
	  when a threshold number of events have passed - and can thus be
	  used to profile the code that runs on that CPU.

	  The Linux Performance Event subsystem provides an abstraction of
	  these software and hardware event capabilities, available via a
	  system call and used by the "perf" utility in tools/perf/. It
	  provides per task and per CPU counters, and it provides event
	  capabilities on top of those.

	  Say Y if unsure.

config DEBUG_PERF_USE_VMALLOC
	default n
	bool "Debug: use vmalloc to back perf mmap() buffers"
	depends on PERF_EVENTS && DEBUG_KERNEL
	select PERF_USE_VMALLOC
	help
	 Use vmalloc memory to back perf mmap() buffers.

	 Mostly useful for debugging the vmalloc code on platforms
	 that don't require it.

	 Say N if unsure.

endmenu

config VM_EVENT_COUNTERS
	default y
	bool "Enable VM event counters for /proc/vmstat" if EXPERT
	help
	  VM event counters are needed for event counts to be shown.
	  This option allows the disabling of the VM event counters
	  on EXPERT systems.  /proc/vmstat will only show page counts
	  if VM event counters are disabled.

config SLUB_DEBUG
	default y
	bool "Enable SLUB debugging support" if EXPERT
	depends on SLUB && SYSFS
	help
	  SLUB has extensive debug support features. Disabling these can
	  result in significant savings in code size. This also disables
	  SLUB sysfs support. /sys/slab will not exist and there will be
	  no support for cache validation etc.

config COMPAT_BRK
	bool "Disable heap randomization"
	default y
	help
	  Randomizing heap placement makes heap exploits harder, but it
	  also breaks ancient binaries (including anything libc5 based).
	  This option changes the bootup default to heap randomization
	  disabled, and can be overridden at runtime by setting
	  /proc/sys/kernel/randomize_va_space to 2.

	  On non-ancient distros (post-2000 ones) N is usually a safe choice.

choice
	prompt "Choose SLAB allocator"
	default SLUB
	help
	   This option allows to select a slab allocator.

config SLAB
	bool "SLAB"
	help
	  The regular slab allocator that is established and known to work
	  well in all environments. It organizes cache hot objects in
	  per cpu and per node queues.

config SLUB
	bool "SLUB (Unqueued Allocator)"
	help
	   SLUB is a slab allocator that minimizes cache line usage
	   instead of managing queues of cached objects (SLAB approach).
	   Per cpu caching is realized using slabs of objects instead
	   of queues of objects. SLUB can use memory efficiently
	   and has enhanced diagnostics. SLUB is the default choice for
	   a slab allocator.

config SLOB
	depends on EXPERT
	bool "SLOB (Simple Allocator)"
	help
	   SLOB replaces the stock allocator with a drastically simpler
	   allocator. SLOB is generally more space efficient but
	   does not perform as well on large systems.

endchoice

config SLUB_CPU_PARTIAL
	default y
	depends on SLUB && SMP
	bool "SLUB per cpu partial cache"
	help
	  Per cpu partial caches accellerate objects allocation and freeing
	  that is local to a processor at the price of more indeterminism
	  in the latency of the free. On overflow these caches will be cleared
	  which requires the taking of locks that may cause latency spikes.
	  Typically one would choose no for a realtime system.

config MMAP_ALLOW_UNINITIALIZED
	bool "Allow mmapped anonymous memory to be uninitialized"
	depends on EXPERT && !MMU
	default n
	help
	  Normally, and according to the Linux spec, anonymous memory obtained
	  from mmap() has it's contents cleared before it is passed to
	  userspace.  Enabling this config option allows you to request that
	  mmap() skip that if it is given an MAP_UNINITIALIZED flag, thus
	  providing a huge performance boost.  If this option is not enabled,
	  then the flag will be ignored.

	  This is taken advantage of by uClibc's malloc(), and also by
	  ELF-FDPIC binfmt's brk and stack allocator.

	  Because of the obvious security issues, this option should only be
	  enabled on embedded devices where you control what is run in
	  userspace.  Since that isn't generally a problem on no-MMU systems,
	  it is normally safe to say Y here.

	  See Documentation/nommu-mmap.txt for more information.

config SYSTEM_TRUSTED_KEYRING
	bool "Provide system-wide ring of trusted keys"
	depends on KEYS
	help
	  Provide a system keyring to which trusted keys can be added.  Keys in
	  the keyring are considered to be trusted.  Keys may be added at will
	  by the kernel from compiled-in data and from hardware key stores, but
	  userspace may only add extra keys if those keys can be verified by
	  keys already in the keyring.

	  Keys in this keyring are used by module signature checking.

config PROFILING
	bool "Profiling support"
	help
	  Say Y here to enable the extended profiling support mechanisms used
	  by profilers such as OProfile.

#
# Place an empty function call at each tracepoint site. Can be
# dynamically changed for a probe function.
#
config TRACEPOINTS
	bool

source "arch/Kconfig"

endmenu		# General setup

config HAVE_GENERIC_DMA_COHERENT
	bool
	default n

config SLABINFO
	bool
	depends on PROC_FS
	depends on SLAB || SLUB_DEBUG
	default y

config RT_MUTEXES
	bool

config BASE_SMALL
	int
	default 0 if BASE_FULL
	default 1 if !BASE_FULL

menuconfig MODULES
	bool "Enable loadable module support"
	option modules
	help
	  Kernel modules are small pieces of compiled code which can
	  be inserted in the running kernel, rather than being
	  permanently built into the kernel.  You use the "modprobe"
	  tool to add (and sometimes remove) them.  If you say Y here,
	  many parts of the kernel can be built as modules (by
	  answering M instead of Y where indicated): this is most
	  useful for infrequently used options which are not required
	  for booting.  For more information, see the man pages for
	  modprobe, lsmod, modinfo, insmod and rmmod.

	  If you say Y here, you will need to run "make
	  modules_install" to put the modules under /lib/modules/
	  where modprobe can find them (you may need to be root to do
	  this).

	  If unsure, say Y.

if MODULES

config MODULE_FORCE_LOAD
	bool "Forced module loading"
	default n
	help
	  Allow loading of modules without version information (ie. modprobe
	  --force).  Forced module loading sets the 'F' (forced) taint flag and
	  is usually a really bad idea.

config MODULE_UNLOAD
	bool "Module unloading"
	help
	  Without this option you will not be able to unload any
	  modules (note that some modules may not be unloadable
	  anyway), which makes your kernel smaller, faster
	  and simpler.  If unsure, say Y.

config MODULE_FORCE_UNLOAD
	bool "Forced module unloading"
	depends on MODULE_UNLOAD
	help
	  This option allows you to force a module to unload, even if the
	  kernel believes it is unsafe: the kernel will remove the module
	  without waiting for anyone to stop using it (using the -f option to
	  rmmod).  This is mainly for kernel developers and desperate users.
	  If unsure, say N.

config MODVERSIONS
	bool "Module versioning support"
	help
	  Usually, you have to use modules compiled with your kernel.
	  Saying Y here makes it sometimes possible to use modules
	  compiled for different kernels, by adding enough information
	  to the modules to (hopefully) spot any changes which would
	  make them incompatible with the kernel you are running.  If
	  unsure, say N.

config MODULE_SRCVERSION_ALL
	bool "Source checksum for all modules"
	help
	  Modules which contain a MODULE_VERSION get an extra "srcversion"
	  field inserted into their modinfo section, which contains a
    	  sum of the source files which made it.  This helps maintainers
	  see exactly which source was used to build a module (since
	  others sometimes change the module source without updating
	  the version).  With this option, such a "srcversion" field
	  will be created for all modules.  If unsure, say N.

config MODULE_SIG
	bool "Module signature verification"
	depends on MODULES
	select SYSTEM_TRUSTED_KEYRING
	select KEYS
	select CRYPTO
	select ASYMMETRIC_KEY_TYPE
	select ASYMMETRIC_PUBLIC_KEY_SUBTYPE
	select PUBLIC_KEY_ALGO_RSA
	select ASN1
	select OID_REGISTRY
	select X509_CERTIFICATE_PARSER
	help
	  Check modules for valid signatures upon load: the signature
	  is simply appended to the module. For more information see
	  Documentation/module-signing.txt.

	  !!!WARNING!!!  If you enable this option, you MUST make sure that the
	  module DOES NOT get stripped after being signed.  This includes the
	  debuginfo strip done by some packagers (such as rpmbuild) and
	  inclusion into an initramfs that wants the module size reduced.

config MODULE_SIG_FORCE
	bool "Require modules to be validly signed"
	depends on MODULE_SIG
	help
	  Reject unsigned modules or signed modules for which we don't have a
	  key.  Without this, such modules will simply taint the kernel.

config MODULE_SIG_ALL
	bool "Automatically sign all modules"
	default y
	depends on MODULE_SIG
	help
	  Sign all modules during make modules_install. Without this option,
	  modules must be signed manually, using the scripts/sign-file tool.

comment "Do not forget to sign required modules with scripts/sign-file"
	depends on MODULE_SIG_FORCE && !MODULE_SIG_ALL

choice
	prompt "Which hash algorithm should modules be signed with?"
	depends on MODULE_SIG
	help
	  This determines which sort of hashing algorithm will be used during
	  signature generation.  This algorithm _must_ be built into the kernel
	  directly so that signature verification can take place.  It is not
	  possible to load a signed module containing the algorithm to check
	  the signature on that module.

config MODULE_SIG_SHA1
	bool "Sign modules with SHA-1"
	select CRYPTO_SHA1

config MODULE_SIG_SHA224
	bool "Sign modules with SHA-224"
	select CRYPTO_SHA256

config MODULE_SIG_SHA256
	bool "Sign modules with SHA-256"
	select CRYPTO_SHA256

config MODULE_SIG_SHA384
	bool "Sign modules with SHA-384"
	select CRYPTO_SHA512

config MODULE_SIG_SHA512
	bool "Sign modules with SHA-512"
	select CRYPTO_SHA512

endchoice

config MODULE_SIG_HASH
	string
	depends on MODULE_SIG
	default "sha1" if MODULE_SIG_SHA1
	default "sha224" if MODULE_SIG_SHA224
	default "sha256" if MODULE_SIG_SHA256
	default "sha384" if MODULE_SIG_SHA384
	default "sha512" if MODULE_SIG_SHA512

config MODULE_COMPRESS
	bool "Compress modules on installation"
	depends on MODULES
	help
	  This option compresses the kernel modules when 'make
	  modules_install' is run.

	  The modules will be compressed either using gzip or xz depend on the
	  choice made in "Compression algorithm".

	  module-init-tools has support for gzip format while kmod handle gzip
	  and xz compressed modules.

	  When a kernel module is installed from outside of the main kernel
	  source and uses the Kbuild system for installing modules then that
	  kernel module will also be compressed when it is installed.

	  This option provides little benefit when the modules are to be used inside
	  an initrd or initramfs, it generally is more efficient to compress the whole
	  initrd or initramfs instead.

	  This is fully compatible with signed modules while the signed module is
	  compressed. module-init-tools or kmod handles decompression and provide to
	  other layer the uncompressed but signed payload.

choice
	prompt "Compression algorithm"
	depends on MODULE_COMPRESS
	default MODULE_COMPRESS_GZIP
	help
	  This determines which sort of compression will be used during
	  'make modules_install'.

	  GZIP (default) and XZ are supported.

config MODULE_COMPRESS_GZIP
	bool "GZIP"

config MODULE_COMPRESS_XZ
	bool "XZ"

endchoice

endif # MODULES

config INIT_ALL_POSSIBLE
	bool
	help
	  Back when each arch used to define their own cpu_online_mask and
	  cpu_possible_mask, some of them chose to initialize cpu_possible_mask
	  with all 1s, and others with all 0s.  When they were centralised,
	  it was better to provide this option than to break all the archs
	  and have several arch maintainers pursuing me down dark alleys.

config STOP_MACHINE
	bool
	default y
	depends on (SMP && MODULE_UNLOAD) || HOTPLUG_CPU
	help
	  Need stop_machine() primitive.

source "block/Kconfig"

config PREEMPT_NOTIFIERS
	bool

config PADATA
	depends on SMP
	bool

# Can be selected by architectures with broken toolchains
# that get confused by correct const<->read_only section
# mappings
config BROKEN_RODATA
	bool

config ASN1
	tristate
	help
	  Build a simple ASN.1 grammar compiler that produces a bytecode output
	  that can be interpreted by the ASN.1 stream decoder and used to
	  inform it as to what tags are to be expected in a stream and what
	  functions to call on what tags.

source "kernel/Kconfig.locks"
menuconfig XENOMAI
	depends on X86_TSC || !X86
	bool "Xenomai/cobalt"
	select IPIPE
	select IPIPE_WANT_APIREV_2
	default y
	help
	  Xenomai's Cobalt core is a real-time extension to the Linux
	  kernel, which exhibits very short interrupt and scheduling
	  latency, without affecting the regular kernel services.

	  This option enables the set of extended kernel services
	  required to run the real-time applications in user-space,
	  over the Xenomai libraries.

	  Please visit http://xenomai.org for more information.

if XENOMAI
source "arch/$SRCARCH/xenomai/Kconfig"
endif

if MIGRATION
comment "WARNING! Page migration (CONFIG_MIGRATION) may increase"
comment "latency."
endif

if APM || CPU_FREQ || ACPI_PROCESSOR || INTEL_IDLE
comment "WARNING! At least one of APM, CPU frequency scaling, ACPI 'processor'"
comment "or CPU idle features is enabled. Any of these options may"
comment "cause troubles with Xenomai. You should disable them."
endif

if !GENERIC_CLOCKEVENTS
comment "NOTE: Xenomai 3.x requires CONFIG_GENERIC_CLOCKEVENTS"
endif

config XENO_VERSION_MAJOR
       int
       default 3

config XENO_VERSION_MINOR
       int
       default 0

config XENO_REVISION_LEVEL
       int
       default 5

config XENO_VERSION_STRING
       string
       default 3.0.5

config XENO_VERSION_NAME
       string
       default "Sisyphus's Boulder"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #
# fbdev configuration
#

menuconfig FB
	tristate "Support for frame buffer devices"
	select FB_CMDLINE
	---help---
	  The frame buffer device provides an abstraction for the graphics
	  hardware. It represents the frame buffer of some video hardware and
	  allows application software to access the graphics hardware through
	  a well-defined interface, so the software doesn't need to know
	  anything about the low-level (hardware register) stuff.

	  Frame buffer devices work identically across the different
	  architectures supported by Linux and make the implementation of
	  application programs easier and more portable; at this point, an X
	  server exists which uses the frame buffer device exclusively.
	  On several non-X86 architectures, the frame buffer device is the
	  only way to use the graphics hardware.

	  The device is accessed through special device nodes, usually located
	  in the /dev directory, i.e. /dev/fb*.

	  You need an utility program called fbset to make full use of frame
	  buffer devices. Please read <file:Documentation/fb/framebuffer.txt>
	  and the Framebuffer-HOWTO at
	  <http://www.munted.org.uk/programming/Framebuffer-HOWTO-1.3.html> for more
	  information.

	  Say Y here and to the driver for your graphics board below if you
	  are compiling a kernel for a non-x86 architecture.

	  If you are compiling for the x86 architecture, you can say Y if you
	  want to play with it, but it is not essential. Please note that
	  running graphical applications that directly touch the hardware
	  (e.g. an accelerated X server) and that are not frame buffer
	  device-aware may cause unexpected results. If unsure, say N.

config FIRMWARE_EDID
       bool "Enable firmware EDID"
       depends on FB
       default n
       ---help---
         This enables access to the EDID transferred from the firmware.
	 On the i386, this is from the Video BIOS. Enable this if DDC/I2C
	 transfers do not work for your driver and if you are using
	 nvidiafb, i810fb or savagefb.

	 In general, choosing Y for this option is safe.  If you
	 experience extremely long delays while booting before you get
	 something on your display, try setting this to N.  Matrox cards in
	 combination with certain motherboards and monitors are known to
	 suffer from this problem.

config FB_CMDLINE
	bool

config FB_DDC
       tristate
       depends on FB
       select I2C_ALGOBIT
       select I2C
       default n

config FB_BOOT_VESA_SUPPORT
	bool
	depends on FB
	default n
	---help---
	  If true, at least one selected framebuffer driver can take advantage
	  of VESA video modes set at an early boot stage via the vga= parameter.

config FB_CFB_FILLRECT
	tristate
	depends on FB
	default n
	---help---
	  Include the cfb_fillrect function for generic software rectangle
	  filling. This is used by drivers that don't provide their own
	  (accelerated) version.

config FB_CFB_COPYAREA
	tristate
	depends on FB
	default n
	---help---
	  Include the cfb_copyarea function for generic software area copying.
	  This is used by drivers that don't provide their own (accelerated)
	  version.

config FB_CFB_IMAGEBLIT
	tristate
	depends on FB
	default n
	---help---
	  Include the cfb_imageblit function for generic software image
	  blitting. This is used by drivers that don't provide their own
	  (accelerated) version.

config FB_CFB_REV_PIXELS_IN_BYTE
	bool
	depends on FB
	default n
	---help---
	  Allow generic frame-buffer functions to work on displays with 1, 2
	  and 4 bits per pixel depths which has opposite order of pixels in
	  byte order to bytes in long order.

config FB_SYS_FILLRECT
	tristate
	depends on FB
	default n
	---help---
	  Include the sys_fillrect function for generic software rectangle
	  filling. This is used by drivers that don't provide their own
	  (accelerated) version and the framebuffer is in system RAM.

config FB_SYS_COPYAREA
	tristate
	depends on FB
	default n
	---help---
	  Include the sys_copyarea function for generic software area copying.
	  This is used by drivers that don't provide their own (accelerated)
	  version and the framebuffer is in system RAM.

config FB_SYS_IMAGEBLIT
	tristate
	depends on FB
	default n
	---help---
	  Include the sys_imageblit function for generic software image
	  blitting. This is used by drivers that don't provide their own
	  (accelerated) version and the framebuffer is in system RAM.

menuconfig FB_FOREIGN_ENDIAN
	bool "Framebuffer foreign endianness support"
	depends on FB
	---help---
	  This menu will let you enable support for the framebuffers with
	  non-native endianness (e.g. Little-Endian framebuffer on a
	  Big-Endian machine). Most probably you don't have such hardware,
	  so it's safe to say "n" here.

choice
	prompt "Choice endianness support"
	depends on FB_FOREIGN_ENDIAN

config FB_BOTH_ENDIAN
	bool "Support for Big- and Little-Endian framebuffers"

config FB_BIG_ENDIAN
	bool "Support for Big-Endian framebuffers only"

config FB_LITTLE_ENDIAN
	bool "Support for Little-Endian framebuffers only"

endchoice

config FB_SYS_FOPS
       tristate
       depends on FB
       default n

config FB_DEFERRED_IO
	bool
	depends on FB

config FB_HECUBA
	tristate
	depends on FB
	depends on FB_DEFERRED_IO

config FB_SVGALIB
	tristate
	depends on FB
	default n
	---help---
	  Common utility functions useful to fbdev drivers of VGA-based
	  cards.

config FB_MACMODES
       tristate
       depends on FB
       default n

config FB_BACKLIGHT
	bool
	depends on FB
	select BACKLIGHT_LCD_SUPPORT
	select BACKLIGHT_CLASS_DEVICE
	default n

config FB_MODE_HELPERS
        bool "Enable Video Mode Handling Helpers"
        depends on FB
	default n
	---help---
	  This enables functions for handling video modes using the
	  Generalized Timing Formula and the EDID parser. A few drivers rely
          on this feature such as the radeonfb, rivafb, and the i810fb. If
	  your driver does not take advantage of this feature, choosing Y will
	  just increase the kernel size by about 5K.

config FB_TILEBLITTING
       bool "Enable Tile Blitting Support"
       depends on FB
       default n
       ---help---
         This enables tile blitting.  Tile blitting is a drawing technique
	 where the screen is divided into rectangular sections (tiles), whereas
	 the standard blitting divides the screen into pixels. Because the
	 default drawing element is a tile, drawing functions will be passed
	 parameters in terms of number of tiles instead of number of pixels.
	 For example, to draw a single character, instead of using bitmaps,
	 an index to an array of bitmaps will be used.  To clear or move a
	 rectangular section of a screen, the rectangle will be described in
	 terms of number of tiles in the x- and y-axis.

	 This is particularly important to one driver, matroxfb.  If
	 unsure, say N.

comment "Frame buffer hardware drivers"
	depends on FB

config FB_BCM2708
	tristate "BCM2708 framebuffer support"
	depends on FB && RASPBERRYPI_FIRMWARE
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This framebuffer device driver is for the BCM2708 framebuffer.

	  If you want to compile this as a module (=code which can be
	  inserted into and removed from the running kernel), say M
	  here and read <file:Documentation/kbuild/modules.txt>.  The module
	  will be called bcm2708_fb.

config FB_GRVGA
	tristate "Aeroflex Gaisler framebuffer support"
	depends on FB && SPARC
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	This enables support for the SVGACTRL framebuffer in the GRLIB IP library from Aeroflex Gaisler.

config FB_CIRRUS
	tristate "Cirrus Logic support"
	depends on FB && (ZORRO || PCI)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  This enables support for Cirrus Logic GD542x/543x based boards on
	  Amiga: SD64, Piccolo, Picasso II/II+, Picasso IV, or EGS Spectrum.

	  If you have a PCI-based system, this enables support for these
	  chips: GD-543x, GD-544x, GD-5480.

	  Please read the file <file:Documentation/fb/cirrusfb.txt>.

	  Say N unless you have such a graphics board or plan to get one
	  before you next recompile the kernel.

config FB_PM2
	tristate "Permedia2 support"
	depends on FB && ((AMIGA && BROKEN) || PCI)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for cards based on
	  the 3D Labs Permedia, Permedia 2 and Permedia 2V chips.
	  The driver was tested on the following cards:
		Diamond FireGL 1000 PRO AGP
		ELSA Gloria Synergy PCI
		Appian Jeronimo PRO (both heads) PCI
		3DLabs Oxygen ACX aka EONtronics Picasso P2 PCI
		Techsource Raptor GFX-8P (aka Sun PGX-32) on SPARC
		ASK Graphic Blaster Exxtreme AGP

	  To compile this driver as a module, choose M here: the
	  module will be called pm2fb.

config FB_PM2_FIFO_DISCONNECT
	bool "enable FIFO disconnect feature"
	depends on FB_PM2 && PCI
	help
	  Support the Permedia2 FIFO disconnect feature.

config FB_ARMCLCD
	tristate "ARM PrimeCell PL110 support"
	depends on ARM || ARM64 || COMPILE_TEST
	depends on FB && ARM_AMBA
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MODE_HELPERS if OF
	select VIDEOMODE_HELPERS if OF
	help
	  This framebuffer device driver is for the ARM PrimeCell PL110
	  Colour LCD controller.  ARM PrimeCells provide the building
	  blocks for System on a Chip devices.

	  If you want to compile this as a module (=code which can be
	  inserted into and removed from the running kernel), say M
	  here and read <file:Documentation/kbuild/modules.txt>.  The module
	  will be called amba-clcd.

# Helper logic selected only by the ARM Versatile platform family.
config PLAT_VERSATILE_CLCD
	def_bool ARCH_VERSATILE || ARCH_REALVIEW || ARCH_VEXPRESS || ARCH_INTEGRATOR
	depends on ARM
	depends on FB_ARMCLCD && FB=y

config FB_ACORN
	bool "Acorn VIDC support"
	depends on (FB = y) && ARM && ARCH_ACORN
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Acorn VIDC graphics
	  hardware found in Acorn RISC PCs and other ARM-based machines.  If
	  unsure, say N.

config FB_CLPS711X_OLD
	tristate
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT

config FB_CLPS711X
	tristate "CLPS711X LCD support"
	depends on FB && (ARCH_CLPS711X || COMPILE_TEST)
	select FB_CLPS711X_OLD if ARCH_CLPS711X && !ARCH_MULTIPLATFORM
	select BACKLIGHT_LCD_SUPPORT
	select FB_MODE_HELPERS
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select LCD_CLASS_DEVICE
	select VIDEOMODE_HELPERS
	help
	  Say Y to enable the Framebuffer driver for the Cirrus Logic
	  CLPS711X CPUs.

config FB_SA1100
	bool "SA-1100 LCD support"
	depends on (FB = y) && ARM && ARCH_SA1100
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is a framebuffer device for the SA-1100 LCD Controller.
	  See <http://www.linux-fbdev.org/> for information on framebuffer
	  devices.

	  If you plan to use the LCD display with your SA-1100 system, say
	  Y here.

config FB_IMX
	tristate "Freescale i.MX1/21/25/27 LCD support"
	depends on FB && ARCH_MXC
	select BACKLIGHT_LCD_SUPPORT
	select LCD_CLASS_DEVICE
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS

config FB_CYBER2000
	tristate "CyberPro 2000/2010/5000 support"
	depends on FB && PCI && (BROKEN || !SPARC64)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This enables support for the Integraphics CyberPro 20x0 and 5000
	  VGA chips used in the Rebel.com Netwinder and other machines.
	  Say Y if you have a NetWinder or a graphics card containing this
	  device, otherwise say N.

config FB_CYBER2000_DDC
	bool "DDC for CyberPro support"
	depends on FB_CYBER2000
	select FB_DDC
	default y
	help
	  Say Y here if you want DDC support for your CyberPro graphics
	  card. This is only I2C bus support, driver does not use EDID.

config FB_CYBER2000_I2C
	bool "CyberPro 2000/2010/5000 I2C support"
	depends on FB_CYBER2000 && I2C && ARCH_NETWINDER
	depends on I2C=y || FB_CYBER2000=m
	select I2C_ALGOBIT
	help
	  Enable support for the I2C video decoder interface on the
	  Integraphics CyberPro 20x0 and 5000 VGA chips.  This is used
	  on the Netwinder machines for the SAA7111 video capture.

config FB_APOLLO
	bool
	depends on (FB = y) && APOLLO
	default y
	select FB_CFB_FILLRECT
	select FB_CFB_IMAGEBLIT

config FB_Q40
	bool
	depends on (FB = y) && Q40
	default y
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT

config FB_AMIGA
	tristate "Amiga native chipset support"
	depends on FB && AMIGA
	help
	  This is the frame buffer device driver for the builtin graphics
	  chipset found in Amigas.

	  To compile this driver as a module, choose M here: the
	  module will be called amifb.

config FB_AMIGA_OCS
	bool "Amiga OCS chipset support"
	depends on FB_AMIGA
	help
	  This enables support for the original Agnus and Denise video chips,
	  found in the Amiga 1000 and most A500's and A2000's. If you intend
	  to run Linux on any of these systems, say Y; otherwise say N.

config FB_AMIGA_ECS
	bool "Amiga ECS chipset support"
	depends on FB_AMIGA
	help
	  This enables support for the Enhanced Chip Set, found in later
	  A500's, later A2000's, the A600, the A3000, the A3000T and CDTV. If
	  you intend to run Linux on any of these systems, say Y; otherwise
	  say N.

config FB_AMIGA_AGA
	bool "Amiga AGA chipset support"
	depends on FB_AMIGA
	help
	  This enables support for the Advanced Graphics Architecture (also
	  known as the AGA or AA) Chip Set, found in the A1200, A4000, A4000T
	  and CD32. If you intend to run Linux on any of these systems, say Y;
	  otherwise say N.

config FB_FM2
	bool "Amiga FrameMaster II/Rainbow II support"
	depends on (FB = y) && ZORRO
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Amiga FrameMaster
	  card from BSC (exhibited 1992 but not shipped as a CBM product).

config FB_ARC
	tristate "Arc Monochrome LCD board support"
	depends on FB && X86
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	help
	  This enables support for the Arc Monochrome LCD board. The board
	  is based on the KS-108 lcd controller and is typically a matrix
	  of 2*n chips. This driver was tested with a 128x64 panel. This
	  driver supports it for use with x86 SBCs through a 16 bit GPIO
	  interface (8 bit data, 8 bit control). If you anticipate using
	  this driver, say Y or M; otherwise say N. You must specify the
	  GPIO IO address to be used for setting control and data.

config FB_ATARI
	bool "Atari native chipset support"
	depends on (FB = y) && ATARI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the builtin graphics
	  chipset found in Ataris.

config FB_OF
	bool "Open Firmware frame buffer device support"
	depends on (FB = y) && PPC && (!PPC_PSERIES || PCI)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES
	help
	  Say Y if you want support with Open Firmware for your graphics
	  board.

config FB_CONTROL
	bool "Apple \"control\" display support"
	depends on (FB = y) && PPC_PMAC && PPC32
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES
	help
	  This driver supports a frame buffer for the graphics adapter in the
	  Power Macintosh 7300 and others.

config FB_PLATINUM
	bool "Apple \"platinum\" display support"
	depends on (FB = y) && PPC_PMAC && PPC32
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES
	help
	  This driver supports a frame buffer for the "platinum" graphics
	  adapter in some Power Macintoshes.

config FB_VALKYRIE
	bool "Apple \"valkyrie\" display support"
	depends on (FB = y) && (MAC || (PPC_PMAC && PPC32))
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES
	help
	  This driver supports a frame buffer for the "valkyrie" graphics
	  adapter in some Power Macintoshes.

config FB_CT65550
	bool "Chips 65550 display support"
	depends on (FB = y) && PPC32 && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Chips & Technologies
	  65550 graphics chip in PowerBooks.

config FB_ASILIANT
	bool "Asiliant (Chips) 69000 display support"
	depends on (FB = y) && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Asiliant 69030 chipset

config FB_IMSTT
	bool "IMS Twin Turbo display support"
	depends on (FB = y) && PCI
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES if PPC
	help
	  The IMS Twin Turbo is a PCI-based frame buffer card bundled with
	  many Macintosh and compatible computers.

config FB_VGA16
	tristate "VGA 16-color graphics support"
	depends on FB && (X86 || PPC)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VGASTATE
	select FONT_8x16 if FRAMEBUFFER_CONSOLE
	help
	  This is the frame buffer device driver for VGA 16 color graphic
	  cards. Say Y if you have such a card.

	  To compile this driver as a module, choose M here: the
	  module will be called vga16fb.

config FB_BF54X_LQ043
	tristate "SHARP LQ043 TFT LCD (BF548 EZKIT)"
	depends on FB && (BF54x) && !BF542
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	 This is the framebuffer device driver for a SHARP LQ043T1DG01 TFT LCD

config FB_BFIN_T350MCQB
	tristate "Varitronix COG-T350MCQB TFT LCD display (BF527 EZKIT)"
	depends on FB && BLACKFIN
	select BFIN_GPTIMERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	 This is the framebuffer device driver for a Varitronix VL-PS-COG-T350MCQB-01 display TFT LCD
	 This display is a QVGA 320x240 24-bit RGB display interfaced by an 8-bit wide PPI
	 It uses PPI[0..7] PPI_FS1, PPI_FS2 and PPI_CLK.

config FB_BFIN_LQ035Q1
	tristate "SHARP LQ035Q1DH02 TFT LCD"
	depends on FB && BLACKFIN && SPI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select BFIN_GPTIMERS
	help
	  This is the framebuffer device driver for a SHARP LQ035Q1DH02 TFT display found on
	  the Blackfin Landscape LCD EZ-Extender Card.
	  This display is a QVGA 320x240 18-bit RGB display interfaced by an 16-bit wide PPI
	  It uses PPI[0..15] PPI_FS1, PPI_FS2 and PPI_CLK.

	  To compile this driver as a module, choose M here: the
	  module will be called bfin-lq035q1-fb.

config FB_BF537_LQ035
	tristate "SHARP LQ035 TFT LCD (BF537 STAMP)"
	depends on FB && (BF534 || BF536 || BF537) && I2C_BLACKFIN_TWI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select BFIN_GPTIMERS
	help
	  This is the framebuffer device for a SHARP LQ035Q7DB03 TFT LCD
	  attached to a BF537.

	  To compile this driver as a module, choose M here: the
	  module will be called bf537-lq035.

config FB_BFIN_7393
	tristate "Blackfin ADV7393 Video encoder"
	depends on FB && BLACKFIN
	select I2C
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer device for a ADV7393 video encoder
	  attached to a Blackfin on the PPI port.
	  If your Blackfin board has a ADV7393 select Y.

	  To compile this driver as a module, choose M here: the
	  module will be called bfin_adv7393fb.

choice
	prompt  "Video mode support"
	depends on FB_BFIN_7393
	default NTSC

config NTSC
	bool 'NTSC 720x480'

config PAL
	bool 'PAL 720x576'

config NTSC_640x480
	bool 'NTSC 640x480 (Experimental)'

config PAL_640x480
	bool 'PAL 640x480 (Experimental)'

config NTSC_YCBCR
	bool 'NTSC 720x480 YCbCR input'

config PAL_YCBCR
	bool 'PAL 720x576 YCbCR input'

endchoice

choice
	prompt  "Size of ADV7393 frame buffer memory Single/Double Size"
	depends on (FB_BFIN_7393)
	default ADV7393_1XMEM

config ADV7393_1XMEM
	bool 'Single'

config ADV7393_2XMEM
	bool 'Double'
endchoice

config FB_STI
	tristate "HP STI frame buffer device support"
	depends on FB && PARISC
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select STI_CONSOLE
	select VT
	default y
	---help---
	  STI refers to the HP "Standard Text Interface" which is a set of
	  BIOS routines contained in a ROM chip in HP PA-RISC based machines.
	  Enabling this option will implement the linux framebuffer device
	  using calls to the STI BIOS routines for initialisation.
	
	  If you enable this option, you will get a planar framebuffer device
	  /dev/fb which will work on the most common HP graphic cards of the
	  NGLE family, including the artist chips (in the 7xx and Bxxx series),
	  HCRX, HCRX24, CRX, CRX24 and VisEG series.

	  It is safe to enable this option, so you should probably say "Y".

config FB_MAC
	bool "Generic Macintosh display support"
	depends on (FB = y) && MAC
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES

config FB_HP300
	bool
	depends on (FB = y) && DIO
	select FB_CFB_IMAGEBLIT
	default y

config FB_TGA
	tristate "TGA/SFB+ framebuffer support"
	depends on FB && (ALPHA || TC)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select BITREVERSE
	---help---
	  This is the frame buffer device driver for generic TGA and SFB+
	  graphic cards.  These include DEC ZLXp-E1, -E2 and -E3 PCI cards,
	  also known as PBXGA-A, -B and -C, and DEC ZLX-E1, -E2 and -E3
	  TURBOchannel cards, also known as PMAGD-A, -B and -C.

	  Due to hardware limitations ZLX-E2 and E3 cards are not supported
	  for DECstation 5000/200 systems.  Additionally due to firmware
	  limitations these cards may cause troubles with booting DECstation
	  5000/240 and /260 systems, but are fully supported under Linux if
	  you manage to get it going. ;-)

	  Say Y if you have one of those.

config FB_UVESA
	tristate "Userspace VESA VGA graphics support"
	depends on FB && CONNECTOR
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MODE_HELPERS
	help
	  This is the frame buffer driver for generic VBE 2.0 compliant
	  graphic cards. It can also take advantage of VBE 3.0 features,
	  such as refresh rate adjustment.

	  This driver generally provides more features than vesafb but
	  requires a userspace helper application called 'v86d'. See
	  <file:Documentation/fb/uvesafb.txt> for more information.

	  If unsure, say N.

config FB_VESA
	bool "VESA VGA graphics support"
	depends on (FB = y) && X86
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_BOOT_VESA_SUPPORT
	help
	  This is the frame buffer device driver for generic VESA 2.0
	  compliant graphic cards. The older VESA 1.2 cards are not supported.
	  You will get a boot time penguin logo at no additional cost. Please
	  read <file:Documentation/fb/vesafb.txt>. If unsure, say Y.

config FB_EFI
	bool "EFI-based Framebuffer Support"
	depends on (FB = y) && X86 && EFI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the EFI frame buffer device driver. If the firmware on
	  your platform is EFI 1.10 or UEFI 2.0, select Y to add support for
	  using the EFI framebuffer as your console.

config FB_N411
       tristate "N411 Apollo/Hecuba devkit support"
       depends on FB && X86 && MMU
       select FB_SYS_FILLRECT
       select FB_SYS_COPYAREA
       select FB_SYS_IMAGEBLIT
       select FB_SYS_FOPS
       select FB_DEFERRED_IO
       select FB_HECUBA
       help
         This enables support for the Apollo display controller in its
         Hecuba form using the n411 devkit.

config FB_HGA
	tristate "Hercules mono graphics support"
	depends on FB && X86
	help
	  Say Y here if you have a Hercules mono graphics card.

	  To compile this driver as a module, choose M here: the
	  module will be called hgafb.

	  As this card technology is at least 25 years old,
	  most people will answer N here.

config FB_GBE
	bool "SGI Graphics Backend frame buffer support"
	depends on (FB = y) && SGI_IP32
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
 	help
	  This is the frame buffer device driver for SGI Graphics Backend.
	  This chip is used in SGI O2 and Visual Workstation 320/540.

config FB_GBE_MEM
	int "Video memory size in MB"
	depends on FB_GBE
	default 4
	help
	  This is the amount of memory reserved for the framebuffer,
	  which can be any value between 1MB and 8MB.

config FB_SBUS
	bool "SBUS and UPA framebuffers"
	depends on (FB = y) && SPARC
	help
	  Say Y if you want support for SBUS or UPA based frame buffer device.

config FB_BW2
	bool "BWtwo support"
	depends on (FB = y) && (SPARC && FB_SBUS)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the BWtwo frame buffer.

config FB_CG3
	bool "CGthree support"
	depends on (FB = y) && (SPARC && FB_SBUS)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the CGthree frame buffer.

config FB_CG6
	bool "CGsix (GX,TurboGX) support"
	depends on (FB = y) && (SPARC && FB_SBUS)
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the CGsix (GX, TurboGX)
	  frame buffer.

config FB_FFB
	bool "Creator/Creator3D/Elite3D support"
	depends on FB_SBUS && SPARC64
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Creator, Creator3D,
	  and Elite3D graphics boards.

config FB_TCX
	bool "TCX (SS4/SS5 only) support"
	depends on FB_SBUS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the TCX 24/8bit frame
	  buffer.

config FB_CG14
	bool "CGfourteen (SX) support"
	depends on FB_SBUS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the CGfourteen frame
	  buffer on Desktop SPARCsystems with the SX graphics option.

config FB_P9100
	bool "P9100 (Sparcbook 3 only) support"
	depends on FB_SBUS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the P9100 card
	  supported on Sparcbook 3 machines.

config FB_LEO
	bool "Leo (ZX) support"
	depends on FB_SBUS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the SBUS-based Sun ZX
	  (leo) frame buffer cards.

config FB_IGA
	bool "IGA 168x display support"
	depends on (FB = y) && SPARC32
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer device for the INTERGRAPHICS 1680 and
	  successor frame buffer cards.

config FB_XVR500
	bool "Sun XVR-500 3DLABS Wildcat support"
	depends on (FB = y) && PCI && SPARC64
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer device for the Sun XVR-500 and similar
	  graphics cards based upon the 3DLABS Wildcat chipset.  The driver
	  only works on sparc64 systems where the system firmware has
	  mostly initialized the card already.  It is treated as a
	  completely dumb framebuffer device.

config FB_XVR2500
	bool "Sun XVR-2500 3DLABS Wildcat support"
	depends on (FB = y) && PCI && SPARC64
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer device for the Sun XVR-2500 and similar
	  graphics cards based upon the 3DLABS Wildcat chipset.  The driver
	  only works on sparc64 systems where the system firmware has
	  mostly initialized the card already.  It is treated as a
	  completely dumb framebuffer device.

config FB_XVR1000
	bool "Sun XVR-1000 support"
	depends on (FB = y) && SPARC64
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer device for the Sun XVR-1000 and similar
	  graphics cards.  The driver only works on sparc64 systems where
	  the system firmware has mostly initialized the card already.  It
	  is treated as a completely dumb framebuffer device.

config FB_PVR2
	tristate "NEC PowerVR 2 display support"
	depends on FB && SH_DREAMCAST
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Say Y here if you have a PowerVR 2 card in your box.  If you plan to
	  run linux on your Dreamcast, you will have to say Y here.
	  This driver may or may not work on other PowerVR 2 cards, but is
	  totally untested.  Use at your own risk.  If unsure, say N.

	  To compile this driver as a module, choose M here: the
	  module will be called pvr2fb.

	  You can pass several parameters to the driver at boot time or at
	  module load time.  The parameters look like "video=pvr2:XXX", where
	  the meaning of XXX can be found at the end of the main source file
	  (<file:drivers/video/pvr2fb.c>). Please see the file
	  <file:Documentation/fb/pvr2fb.txt>.

config FB_OPENCORES
	tristate "OpenCores VGA/LCD core 2.0 framebuffer support"
	depends on FB && HAS_DMA
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This enables support for the OpenCores VGA/LCD core.

	  The OpenCores VGA/LCD core is typically used together with
	  softcore CPUs (e.g. OpenRISC or Microblaze) or hard processor
	  systems (e.g. Altera socfpga or Xilinx Zynq) on FPGAs.

	  The source code and specification for the core is available at
	  <http://opencores.org/project,vga_lcd>

config FB_S1D13XXX
	tristate "Epson S1D13XXX framebuffer support"
	depends on FB
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  Support for S1D13XXX framebuffer device family (currently only
	  working with S1D13806). Product specs at
	  <http://vdc.epson.com/>

config FB_ATMEL
	tristate "AT91/AT32 LCD Controller support"
	depends on FB && HAVE_FB_ATMEL
	select FB_BACKLIGHT
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS
	help
	  This enables support for the AT91/AT32 LCD Controller.

config FB_NVIDIA
	tristate "nVidia Framebuffer Support"
	depends on FB && PCI
	select FB_BACKLIGHT if FB_NVIDIA_BACKLIGHT
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select BITREVERSE
	select VGASTATE
	help
	  This driver supports graphics boards with the nVidia chips, TNT
	  and newer. For very old chipsets, such as the RIVA128, then use
	  the rivafb.
	  Say Y if you have such a graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called nvidiafb.

config FB_NVIDIA_I2C
       bool "Enable DDC Support"
       depends on FB_NVIDIA
       select FB_DDC
       help
	  This enables I2C support for nVidia Chipsets.  This is used
	  only for getting EDID information from the attached display
	  allowing for robust video mode handling and switching.

	  Because fbdev-2.6 requires that drivers must be able to
	  independently validate video mode parameters, you should say Y
	  here.

config FB_NVIDIA_DEBUG
	bool "Lots of debug output"
	depends on FB_NVIDIA
	default n
	help
	  Say Y here if you want the nVidia driver to output all sorts
	  of debugging information to provide to the maintainer when
	  something goes wrong.

config FB_NVIDIA_BACKLIGHT
	bool "Support for backlight control"
	depends on FB_NVIDIA
	default y
	help
	  Say Y here if you want to control the backlight of your display.

config FB_RIVA
	tristate "nVidia Riva support"
	depends on FB && PCI
	select FB_BACKLIGHT if FB_RIVA_BACKLIGHT
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select BITREVERSE
	select VGASTATE
	help
	  This driver supports graphics boards with the nVidia Riva/Geforce
	  chips.
	  Say Y if you have such a graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called rivafb.

config FB_RIVA_I2C
       bool "Enable DDC Support"
       depends on FB_RIVA
       select FB_DDC
       help
	  This enables I2C support for nVidia Chipsets.  This is used
	  only for getting EDID information from the attached display
	  allowing for robust video mode handling and switching.

	  Because fbdev-2.6 requires that drivers must be able to
	  independently validate video mode parameters, you should say Y
	  here.

config FB_RIVA_DEBUG
	bool "Lots of debug output"
	depends on FB_RIVA
	default n
	help
	  Say Y here if you want the Riva driver to output all sorts
	  of debugging information to provide to the maintainer when
	  something goes wrong.

config FB_RIVA_BACKLIGHT
	bool "Support for backlight control"
	depends on FB_RIVA
	default y
	help
	  Say Y here if you want to control the backlight of your display.

config FB_I740
	tristate "Intel740 support"
	depends on FB && PCI
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VGASTATE
	select FB_DDC
	help
	  This driver supports graphics cards based on Intel740 chip.

config FB_I810
	tristate "Intel 810/815 support"
	depends on FB && PCI && X86_32 && AGP_INTEL
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VGASTATE
	help
	  This driver supports the on-board graphics built in to the Intel 810 
          and 815 chipsets.  Say Y if you have and plan to use such a board.

          To compile this driver as a module, choose M here: the
	  module will be called i810fb.

          For more information, please read 
	  <file:Documentation/fb/intel810.txt>

config FB_I810_GTF
	bool "use VESA Generalized Timing Formula"
	depends on FB_I810
	help
	  If you say Y, then the VESA standard, Generalized Timing Formula 
          or GTF, will be used to calculate the required video timing values
	  per video mode.  Since the GTF allows nondiscrete timings 
          (nondiscrete being a range of values as opposed to discrete being a
          set of values), you'll be able to use any combination of horizontal 
	  and vertical resolutions, and vertical refresh rates without having
	  to specify your own timing parameters.  This is especially useful
	  to maximize the performance of an aging display, or if you just 
          have a display with nonstandard dimensions. A VESA compliant 
	  monitor is recommended, but can still work with non-compliant ones.
	  If you need or want this, then select this option. The timings may 
	  not be compliant with Intel's recommended values. Use at your own 
	  risk.

          If you say N, the driver will revert to discrete video timings 
	  using a set recommended by Intel in their documentation.
  
          If unsure, say N.

config FB_I810_I2C
	bool "Enable DDC Support"
	depends on FB_I810 && FB_I810_GTF
	select FB_DDC
	help

config FB_LE80578
	tristate "Intel LE80578 (Vermilion) support"
	depends on FB && PCI && X86
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This driver supports the LE80578 (Vermilion Range) chipset

config FB_CARILLO_RANCH
	tristate "Intel Carillo Ranch support"
	depends on FB_LE80578 && FB && PCI && X86
	help
	  This driver supports the LE80578 (Carillo Ranch) board

config FB_INTEL
	tristate "Intel 830M/845G/852GM/855GM/865G/915G/945G/945GM/965G/965GM support"
	depends on FB && PCI && X86 && AGP_INTEL && EXPERT
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_BOOT_VESA_SUPPORT if FB_INTEL = y
	depends on !DRM_I915
	help
	  This driver supports the on-board graphics built in to the Intel
          830M/845G/852GM/855GM/865G/915G/915GM/945G/945GM/965G/965GM chipsets.
          Say Y if you have and plan to use such a board.

	  To make FB_INTELFB=Y work you need to say AGP_INTEL=y too.

	  To compile this driver as a module, choose M here: the
	  module will be called intelfb.

	  For more information, please read <file:Documentation/fb/intelfb.txt>

config FB_INTEL_DEBUG
	bool "Intel driver Debug Messages"
	depends on FB_INTEL
	---help---
	  Say Y here if you want the Intel driver to output all sorts
	  of debugging information to provide to the maintainer when
	  something goes wrong.

config FB_INTEL_I2C
	bool "DDC/I2C for Intel framebuffer support"
	depends on FB_INTEL
	select FB_DDC
	default y
	help
	  Say Y here if you want DDC/I2C support for your on-board Intel graphics.

config FB_MATROX
	tristate "Matrox acceleration"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_TILEBLITTING
	select FB_MACMODES if PPC_PMAC
	---help---
	  Say Y here if you have a Matrox Millennium, Matrox Millennium II,
	  Matrox Mystique, Matrox Mystique 220, Matrox Productiva G100, Matrox
	  Mystique G200, Matrox Millennium G200, Matrox Marvel G200 video,
	  Matrox G400, G450 or G550 card in your box.

	  To compile this driver as a module, choose M here: the
	  module will be called matroxfb.

	  You can pass several parameters to the driver at boot time or at
	  module load time. The parameters look like "video=matroxfb:XXX", and
	  are described in <file:Documentation/fb/matroxfb.txt>.

config FB_MATROX_MILLENIUM
	bool "Millennium I/II support"
	depends on FB_MATROX
	help
	  Say Y here if you have a Matrox Millennium or Matrox Millennium II
	  video card. If you select "Advanced lowlevel driver options" below,
	  you should check 4 bpp packed pixel, 8 bpp packed pixel, 16 bpp
	  packed pixel, 24 bpp packed pixel and 32 bpp packed pixel. You can
	  also use font widths different from 8.

config FB_MATROX_MYSTIQUE
	bool "Mystique support"
	depends on FB_MATROX
	help
	  Say Y here if you have a Matrox Mystique or Matrox Mystique 220
	  video card. If you select "Advanced lowlevel driver options" below,
	  you should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp
	  packed pixel and 32 bpp packed pixel. You can also use font widths
	  different from 8.

config FB_MATROX_G
	bool "G100/G200/G400/G450/G550 support"
	depends on FB_MATROX
	---help---
	  Say Y here if you have a Matrox G100, G200, G400, G450 or G550 based
	  video card. If you select "Advanced lowlevel driver options", you
	  should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp packed
	  pixel and 32 bpp packed pixel. You can also use font widths
	  different from 8.

	  If you need support for G400 secondary head, you must say Y to
	  "Matrox I2C support" and "G400 second head support" right below.
	  G450/G550 secondary head and digital output are supported without
	  additional modules.

	  The driver starts in monitor mode. You must use the matroxset tool 
	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to 
	  swap primary and secondary head outputs, or to change output mode.  
	  Secondary head driver always start in 640x480 resolution and you 
	  must use fbset to change it.

	  Do not forget that second head supports only 16 and 32 bpp
	  packed pixels, so it is a good idea to compile them into the kernel
	  too. You can use only some font widths, as the driver uses generic
	  painting procedures (the secondary head does not use acceleration
	  engine).

	  G450/G550 hardware can display TV picture only from secondary CRTC,
	  and it performs no scaling, so picture must have 525 or 625 lines.

config FB_MATROX_I2C
	tristate "Matrox I2C support"
	depends on FB_MATROX
	select FB_DDC
	---help---
	  This drivers creates I2C buses which are needed for accessing the
	  DDC (I2C) bus present on all Matroxes, an I2C bus which
	  interconnects Matrox optional devices, like MGA-TVO on G200 and
	  G400, and the secondary head DDC bus, present on G400 only.

	  You can say Y or M here if you want to experiment with monitor
	  detection code. You must say Y or M here if you want to use either
	  second head of G400 or MGA-TVO on G200 or G400.

	  If you compile it as module, it will create a module named
	  i2c-matroxfb.

config FB_MATROX_MAVEN
	tristate "G400 second head support"
	depends on FB_MATROX_G && FB_MATROX_I2C
	---help---
	  WARNING !!! This support does not work with G450 !!!

	  Say Y or M here if you want to use a secondary head (meaning two
	  monitors in parallel) on G400 or MGA-TVO add-on on G200. Secondary
	  head is not compatible with accelerated XFree 3.3.x SVGA servers -
	  secondary head output is blanked while you are in X. With XFree
	  3.9.17 preview you can use both heads if you use SVGA over fbdev or
	  the fbdev driver on first head and the fbdev driver on second head.

	  If you compile it as module, two modules are created,
	  matroxfb_crtc2 and matroxfb_maven. Matroxfb_maven is needed for
	  both G200 and G400, matroxfb_crtc2 is needed only by G400. You must
	  also load i2c-matroxfb to get it to run.

	  The driver starts in monitor mode and you must use the matroxset
	  tool (available at
	  <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to switch it to
	  PAL or NTSC or to swap primary and secondary head outputs.
	  Secondary head driver also always start in 640x480 resolution, you
	  must use fbset to change it.

	  Also do not forget that second head supports only 16 and 32 bpp
	  packed pixels, so it is a good idea to compile them into the kernel
	  too.  You can use only some font widths, as the driver uses generic
	  painting procedures (the secondary head does not use acceleration
	  engine).

config FB_RADEON
	tristate "ATI Radeon display support"
	depends on FB && PCI
	select FB_BACKLIGHT if FB_RADEON_BACKLIGHT
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MACMODES if PPC
	help
	  Choose this option if you want to use an ATI Radeon graphics card as
	  a framebuffer device.  There are both PCI and AGP versions.  You
	  don't need to choose this to run the Radeon in plain VGA mode.

	  There is a product page at
	  http://products.amd.com/en-us/GraphicCardResult.aspx

config FB_RADEON_I2C
	bool "DDC/I2C for ATI Radeon support"
	depends on FB_RADEON
	select FB_DDC
	default y
	help
	  Say Y here if you want DDC/I2C support for your Radeon board. 

config FB_RADEON_BACKLIGHT
	bool "Support for backlight control"
	depends on FB_RADEON
	default y
	help
	  Say Y here if you want to control the backlight of your display.

config FB_RADEON_DEBUG
	bool "Lots of debug output from Radeon driver"
	depends on FB_RADEON
	default n
	help
	  Say Y here if you want the Radeon driver to output all sorts
	  of debugging information to provide to the maintainer when
	  something goes wrong.

config FB_ATY128
	tristate "ATI Rage128 display support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_BACKLIGHT if FB_ATY128_BACKLIGHT
	select FB_MACMODES if PPC_PMAC
	help
	  This driver supports graphics boards with the ATI Rage128 chips.
	  Say Y if you have such a graphics board and read
	  <file:Documentation/fb/aty128fb.txt>.

	  To compile this driver as a module, choose M here: the
	  module will be called aty128fb.

config FB_ATY128_BACKLIGHT
	bool "Support for backlight control"
	depends on FB_ATY128
	default y
	help
	  Say Y here if you want to control the backlight of your display.

config FB_ATY
	tristate "ATI Mach64 display support" if PCI || ATARI
	depends on FB && !SPARC32
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_BACKLIGHT if FB_ATY_BACKLIGHT
	select FB_MACMODES if PPC
	help
	  This driver supports graphics boards with the ATI Mach64 chips.
	  Say Y if you have such a graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called atyfb.

config FB_ATY_CT
	bool "Mach64 CT/VT/GT/LT (incl. 3D RAGE) support"
	depends on PCI && FB_ATY
	default y if SPARC64 && PCI
	help
	  Say Y here to support use of ATI's 64-bit Rage boards (or other
	  boards based on the Mach64 CT, VT, GT, and LT chipsets) as a
	  framebuffer device.  The ATI product support page for these boards
	  is at <http://support.ati.com/products/pc/mach64/mach64.html>.

config FB_ATY_GENERIC_LCD
	bool "Mach64 generic LCD support"
	depends on FB_ATY_CT
	help
	  Say Y if you have a laptop with an ATI Rage LT PRO, Rage Mobility,
	  Rage XC, or Rage XL chipset.

config FB_ATY_GX
	bool "Mach64 GX support" if PCI
	depends on FB_ATY
	default y if ATARI
	help
	  Say Y here to support use of the ATI Mach64 Graphics Expression
	  board (or other boards based on the Mach64 GX chipset) as a
	  framebuffer device.  The ATI product support page for these boards
	  is at
	  <http://support.ati.com/products/pc/mach64/graphics_xpression.html>.

config FB_ATY_BACKLIGHT
	bool "Support for backlight control"
	depends on FB_ATY
	default y
	help
	  Say Y here if you want to control the backlight of your display.

config FB_S3
	tristate "S3 Trio/Virge support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_TILEBLITTING
	select FB_SVGALIB
	select VGASTATE
	select FONT_8x16 if FRAMEBUFFER_CONSOLE
	---help---
	  Driver for graphics boards with S3 Trio / S3 Virge chip.

config FB_S3_DDC
	bool "DDC for S3 support"
	depends on FB_S3
	select FB_DDC
	default y
	help
	  Say Y here if you want DDC support for your S3 graphics card.

config FB_SAVAGE
	tristate "S3 Savage support"
	depends on FB && PCI
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VGASTATE
	help
	  This driver supports notebooks and computers with S3 Savage PCI/AGP
	  chips.

	  Say Y if you have such a graphics card.

	  To compile this driver as a module, choose M here; the module
	  will be called savagefb.

config FB_SAVAGE_I2C
       bool "Enable DDC2 Support"
       depends on FB_SAVAGE
       select FB_DDC
       help
	  This enables I2C support for S3 Savage Chipsets.  This is used
	  only for getting EDID information from the attached display
	  allowing for robust video mode handling and switching.

	  Because fbdev-2.6 requires that drivers must be able to
	  independently validate video mode parameters, you should say Y
	  here.

config FB_SAVAGE_ACCEL
       bool "Enable Console Acceleration"
       depends on FB_SAVAGE
       default n
       help
          This option will compile in console acceleration support. If
          the resulting framebuffer console has bothersome glitches, then
          choose N here.

config FB_SIS
	tristate "SiS/XGI display support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_BOOT_VESA_SUPPORT if FB_SIS = y
	help
	  This is the frame buffer device driver for the SiS 300, 315, 330
	  and 340 series as well as XGI V3XT, V5, V8, Z7 graphics chipsets.
	  Specs available at <http://www.sis.com> and <http://www.xgitech.com>.

	  To compile this driver as a module, choose M here; the module
	  will be called sisfb.

config FB_SIS_300
	bool "SiS 300 series support"
	depends on FB_SIS
	help
	  Say Y here to support use of the SiS 300/305, 540, 630 and 730.

config FB_SIS_315
	bool "SiS 315/330/340 series and XGI support"
	depends on FB_SIS
	help
	  Say Y here to support use of the SiS 315, 330 and 340 series
	  (315/H/PRO, 55x, 650, 651, 740, 330, 661, 741, 760, 761) as well
	  as XGI V3XT, V5, V8 and Z7.

config FB_VIA
       tristate "VIA UniChrome (Pro) and Chrome9 display support"
       depends on FB && PCI && X86 && GPIOLIB && I2C
       select FB_CFB_FILLRECT
       select FB_CFB_COPYAREA
       select FB_CFB_IMAGEBLIT
       select I2C_ALGOBIT
       help
	  This is the frame buffer device driver for Graphics chips of VIA
	  UniChrome (Pro) Family (CLE266,PM800/CN400,P4M800CE/P4M800Pro/
	  CN700/VN800,CX700/VX700,P4M890) and Chrome9 Family (K8M890,CN896
 	  /P4M900,VX800)
	  Say Y if you have a VIA UniChrome graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called viafb.

if FB_VIA

config FB_VIA_DIRECT_PROCFS
	bool "direct hardware access via procfs (DEPRECATED)(DANGEROUS)"
	depends on FB_VIA
	default n
	help
	  Allow direct hardware access to some output registers via procfs.
	  This is dangerous but may provide the only chance to get the
	  correct output device configuration.
	  Its use is strongly discouraged.

config FB_VIA_X_COMPATIBILITY
	bool "X server compatibility"
	depends on FB_VIA
	default n
	help
	  This option reduces the functionality (power saving, ...) of the
	  framebuffer to avoid negative impact on the OpenChrome X server.
	  If you use any X server other than fbdev you should enable this
	  otherwise it should be safe to disable it and allow using all
	  features.

endif

config FB_NEOMAGIC
	tristate "NeoMagic display support"
	depends on FB && PCI
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select VGASTATE
	help
	  This driver supports notebooks with NeoMagic PCI chips.
	  Say Y if you have such a graphics card. 

	  To compile this driver as a module, choose M here: the
	  module will be called neofb.

config FB_KYRO
	tristate "IMG Kyro support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  Say Y here if you have a STG4000 / Kyro / PowerVR 3 based
	  graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called kyrofb.

config FB_3DFX
	tristate "3Dfx Banshee/Voodoo3/Voodoo5 display support"
	depends on FB && PCI
	select FB_CFB_IMAGEBLIT
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_MODE_HELPERS
	help
	  This driver supports graphics boards with the 3Dfx Banshee,
	  Voodoo3 or VSA-100 (aka Voodoo4/5) chips. Say Y if you have
	  such a graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called tdfxfb.

config FB_3DFX_ACCEL
	bool "3Dfx Acceleration functions"
	depends on FB_3DFX
	---help---
	This will compile the 3Dfx Banshee/Voodoo3/VSA-100 frame buffer
	device driver with acceleration functions.

config FB_3DFX_I2C
	bool "Enable DDC/I2C support"
	depends on FB_3DFX
	select FB_DDC
	default y
	help
	  Say Y here if you want DDC/I2C support for your 3dfx Voodoo3.

config FB_VOODOO1
	tristate "3Dfx Voodoo Graphics (sst1) support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or 
	  Voodoo2 (cvg) based graphics card.

	  To compile this driver as a module, choose M here: the
	  module will be called sstfb.

	  WARNING: Do not use any application that uses the 3D engine
	  (namely glide) while using this driver.
	  Please read the <file:Documentation/fb/sstfb.txt> for supported
	  options and other important info  support.

config FB_VT8623
	tristate "VIA VT8623 support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_TILEBLITTING
	select FB_SVGALIB
	select VGASTATE
	select FONT_8x16 if FRAMEBUFFER_CONSOLE
	---help---
	  Driver for CastleRock integrated graphics core in the
	  VIA VT8623 [Apollo CLE266] chipset.

config FB_TRIDENT
	tristate "Trident/CyberXXX/CyberBlade support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  This is the frame buffer device driver for Trident PCI/AGP chipsets.
	  Supported chipset families are TGUI 9440/96XX, 3DImage, Blade3D
	  and Blade XP.
	  There are also integrated versions of these chips called CyberXXXX,
	  CyberImage or CyberBlade. These chips are mostly found in laptops
	  but also on some motherboards including early VIA EPIA motherboards.
	  For more information, read <file:Documentation/fb/tridentfb.txt>

	  Say Y if you have such a graphics board.

	  To compile this driver as a module, choose M here: the
	  module will be called tridentfb.

config FB_ARK
	tristate "ARK 2000PV support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_TILEBLITTING
	select FB_SVGALIB
	select VGASTATE
	select FONT_8x16 if FRAMEBUFFER_CONSOLE
	---help---
	  Driver for PCI graphics boards with ARK 2000PV chip
	  and ICS 5342 RAMDAC.

config FB_PM3
	tristate "Permedia3 support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the 3DLabs Permedia3
	  chipset, used in Formac ProFormance III, 3DLabs Oxygen VX1 &
	  similar boards, 3DLabs Permedia3 Create!, Appian Jeronimo 2000
	  and maybe other boards.

config FB_CARMINE
	tristate "Fujitsu carmine frame buffer support"
	depends on FB && PCI
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Fujitsu Carmine chip.
	  The driver provides two independent frame buffer devices.

choice
	depends on FB_CARMINE
	prompt "DRAM timing"
	default FB_CARMINE_DRAM_EVAL

config FB_CARMINE_DRAM_EVAL
	bool "Eval board timings"
	help
	  Use timings which work on the eval card.

config CARMINE_DRAM_CUSTOM
	bool "Custom board timings"
	help
	  Use custom board timings.
endchoice

config FB_AU1100
	bool "Au1100 LCD Driver"
	depends on (FB = y) && MIPS_ALCHEMY
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the framebuffer driver for the AMD Au1100 SOC.  It can drive
	  various panels and CRTs by passing in kernel cmd line option
	  au1100fb:panel=<name>.

config FB_AU1200
	bool "Au1200/Au1300 LCD Driver"
	depends on (FB = y) && MIPS_ALCHEMY
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	help
	  This is the framebuffer driver for the Au1200/Au1300 SOCs.
	  It can drive various panels and CRTs by passing in kernel cmd line
	  option au1200fb:panel=<name>.

config FB_VT8500
	bool "VIA VT8500 framebuffer support"
	depends on (FB = y) && ARM && ARCH_VT8500
	select FB_SYS_FILLRECT if (!FB_WMT_GE_ROPS)
	select FB_SYS_COPYAREA if (!FB_WMT_GE_ROPS)
	select FB_SYS_IMAGEBLIT
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS
	help
	  This is the framebuffer driver for VIA VT8500 integrated LCD
	  controller.

config FB_WM8505
	bool "Wondermedia WM8xxx-series frame buffer support"
	depends on (FB = y) && ARM && ARCH_VT8500
	select FB_SYS_FILLRECT if (!FB_WMT_GE_ROPS)
	select FB_SYS_COPYAREA if (!FB_WMT_GE_ROPS)
	select FB_SYS_IMAGEBLIT
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS
	help
	  This is the framebuffer driver for WonderMedia WM8xxx-series
	  integrated LCD controller. This driver covers the WM8505, WM8650
	  and WM8850 SoCs.

config FB_WMT_GE_ROPS
	bool "VT8500/WM8xxx accelerated raster ops support"
	depends on (FB = y) && (FB_VT8500 || FB_WM8505)
	default n
	help
	  This adds support for accelerated raster operations on the
	  VIA VT8500 and Wondermedia 85xx series SoCs.

source "drivers/video/fbdev/geode/Kconfig"

config FB_HIT
	tristate "HD64461 Frame Buffer support"
	depends on FB && HD64461
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This is the frame buffer device driver for the Hitachi HD64461 LCD
	  frame buffer card.

config FB_PMAG_AA
	bool "PMAG-AA TURBOchannel framebuffer support"
	depends on (FB = y) && TC
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  Support for the PMAG-AA TURBOchannel framebuffer card (1280x1024x1)
	  used mainly in the MIPS-based DECstation series.

config FB_PMAG_BA
	tristate "PMAG-BA TURBOchannel framebuffer support"
	depends on FB && TC
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  Support for the PMAG-BA TURBOchannel framebuffer card (1024x864x8)
	  used mainly in the MIPS-based DECstation series.

config FB_PMAGB_B
	tristate "PMAGB-B TURBOchannel framebuffer support"
	depends on FB && TC
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  Support for the PMAGB-B TURBOchannel framebuffer card used mainly
	  in the MIPS-based DECstation series. The card is currently only
	  supported in 1280x1024x8 mode.

config FB_MAXINE
	bool "Maxine (Personal DECstation) onboard framebuffer support"
	depends on (FB = y) && MACH_DECSTATION
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  Support for the onboard framebuffer (1024x768x8) in the Personal
	  DECstation series (Personal DECstation 5000/20, /25, /33, /50,
	  Codename "Maxine").

config FB_G364
	bool "G364 frame buffer support"
	depends on (FB = y) && (MIPS_MAGNUM_4000 || OLIVETTI_M700)
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  The G364 driver is the framebuffer used in MIPS Magnum 4000 and
	  Olivetti M700-10 systems.

config FB_68328
	bool "Motorola 68328 native frame buffer support"
	depends on (FB = y) && (M68328 || M68EZ328 || M68VZ328)
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	help
	  Say Y here if you want to support the built-in frame buffer of
	  the Motorola 68328 CPU family.

config FB_PXA168
	tristate "PXA168/910 LCD framebuffer support"
	depends on FB && (CPU_PXA168 || CPU_PXA910)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the built-in LCD controller in the Marvell
	  MMP processor.

config FB_PXA
	tristate "PXA LCD framebuffer support"
	depends on FB && ARCH_PXA
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the built-in LCD controller in the Intel
	  PXA2x0 processor.

	  This driver is also available as a module ( = code which can be
	  inserted and removed from the running kernel whenever you want). The
	  module will be called pxafb. If you want to compile it as a module,
	  say M here and read <file:Documentation/kbuild/modules.txt>.

	  If unsure, say N.

config FB_PXA_OVERLAY
	bool "Support PXA27x/PXA3xx Overlay(s) as framebuffer"
	default n
	depends on FB_PXA && (PXA27x || PXA3xx)

config FB_PXA_SMARTPANEL
	bool "PXA Smartpanel LCD support"
	default n
	depends on FB_PXA

config FB_PXA_PARAMETERS
	bool "PXA LCD command line parameters"
	default n
	depends on FB_PXA
	---help---
	  Enable the use of kernel command line or module parameters
	  to configure the physical properties of the LCD panel when
	  using the PXA LCD driver.

	  This option allows you to override the panel parameters
	  supplied by the platform in order to support multiple
	  different models of flatpanel. If you will only be using a
	  single model of flatpanel then you can safely leave this
	  option disabled.

	  <file:Documentation/fb/pxafb.txt> describes the available parameters.

config PXA3XX_GCU
	tristate "PXA3xx 2D graphics accelerator driver"
	depends on FB_PXA
	help
	  Kernelspace driver for the 2D graphics controller unit (GCU)
	  found on PXA3xx processors. There is a counterpart driver in the
	  DirectFB suite, see http://www.directfb.org/

	  If you compile this as a module, it will be called pxa3xx_gcu.

config FB_MBX
	tristate "2700G LCD framebuffer support"
	depends on FB && ARCH_PXA
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Framebuffer driver for the Intel 2700G (Marathon) Graphics
	  Accelerator

config FB_MBX_DEBUG
       bool "Enable debugging info via debugfs"
       depends on FB_MBX && DEBUG_FS
       default n
       ---help---
         Enable this if you want debugging information using the debug
         filesystem (debugfs)

         If unsure, say N.

config FB_FSL_DIU
	tristate "Freescale DIU framebuffer support"
	depends on FB && FSL_SOC
	select FB_MODE_HELPERS
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select PPC_LIB_RHEAP
	---help---
	  Framebuffer driver for the Freescale SoC DIU

config FB_W100
	tristate "W100 frame buffer support"
	depends on FB && ARCH_PXA
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the w100 as found on the Sharp SL-Cxx series.
	  It can also drive the w3220 chip found on iPAQ hx4700.

	  This driver is also available as a module ( = code which can be
	  inserted and removed from the running kernel whenever you want). The
	  module will be called w100fb. If you want to compile it as a module,
	  say M here and read <file:Documentation/kbuild/modules.txt>.

	  If unsure, say N.

config FB_SH_MOBILE_LCDC
	tristate "SuperH Mobile LCDC framebuffer support"
	depends on FB && (SUPERH || ARCH_SHMOBILE) && HAVE_CLK
	depends on FB_SH_MOBILE_MERAM || !FB_SH_MOBILE_MERAM
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	select FB_BACKLIGHT
	select SH_MIPI_DSI if SH_LCD_MIPI_DSI
	---help---
	  Frame buffer driver for the on-chip SH-Mobile LCD controller.

config FB_SH_MOBILE_HDMI
	tristate "SuperH Mobile HDMI controller support"
	depends on FB_SH_MOBILE_LCDC
	select FB_MODE_HELPERS
	select SOUND
	select SND
	select SND_SOC
	---help---
	  Driver for the on-chip SH-Mobile HDMI controller.

config FB_TMIO
	tristate "Toshiba Mobile IO FrameBuffer support"
	depends on FB && (MFD_TMIO || COMPILE_TEST)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the Toshiba Mobile IO integrated as found
	  on the Sharp SL-6000 series

	  This driver is also available as a module ( = code which can be
	  inserted and removed from the running kernel whenever you want). The
	  module will be called tmiofb. If you want to compile it as a module,
	  say M here and read <file:Documentation/kbuild/modules.txt>.

	  If unsure, say N.

config FB_TMIO_ACCELL
	bool "tmiofb acceleration"
	depends on FB_TMIO
	default y

config FB_S3C
	tristate "Samsung S3C framebuffer support"
	depends on FB && (CPU_S3C2416 || ARCH_S3C64XX || \
		ARCH_S5PV210 || ARCH_EXYNOS)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the built-in FB controller in the Samsung
	  SoC line from the S3C2443 onwards, including the S3C2416, S3C2450,
	  and the S3C64XX series such as the S3C6400 and S3C6410.

	  These chips all have the same basic framebuffer design with the
	  actual capabilities depending on the chip. For instance the S3C6400
	  and S3C6410 support 4 hardware windows whereas the S3C24XX series
	  currently only have two.

	  Currently the support is only for the S3C6400 and S3C6410 SoCs.

config FB_S3C_DEBUG_REGWRITE
       bool "Debug register writes"
       depends on FB_S3C
       ---help---
         Show all register writes via pr_debug()

config FB_S3C2410
	tristate "S3C2410 LCD framebuffer support"
	depends on FB && ARCH_S3C24XX
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the built-in LCD controller in the Samsung
	  S3C2410 processor.

	  This driver is also available as a module ( = code which can be
	  inserted and removed from the running kernel whenever you want). The
	  module will be called s3c2410fb. If you want to compile it as a module,
	  say M here and read <file:Documentation/kbuild/modules.txt>.

	  If unsure, say N.
config FB_S3C2410_DEBUG
	bool "S3C2410 lcd debug messages"
	depends on FB_S3C2410
	help
	  Turn on debugging messages. Note that you can set/unset at run time
	  through sysfs

config FB_NUC900
        tristate "NUC900 LCD framebuffer support"
        depends on FB && ARCH_W90X900
        select FB_CFB_FILLRECT
        select FB_CFB_COPYAREA
        select FB_CFB_IMAGEBLIT
        ---help---
          Frame buffer driver for the built-in LCD controller in the Nuvoton
          NUC900 processor

config GPM1040A0_320X240
        bool "Giantplus Technology GPM1040A0 320x240 Color TFT LCD"
        depends on FB_NUC900

config FB_SM501
	tristate "Silicon Motion SM501 framebuffer support"
	depends on FB && MFD_SM501
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for the CRT and LCD controllers in the Silicon
	  Motion SM501.

	  This driver is also available as a module ( = code which can be
	  inserted and removed from the running kernel whenever you want). The
	  module will be called sm501fb. If you want to compile it as a module,
	  say M here and read <file:Documentation/kbuild/modules.txt>.

	  If unsure, say N.

config FB_SMSCUFX
	tristate "SMSC UFX6000/7000 USB Framebuffer support"
	depends on FB && USB
	select FB_MODE_HELPERS
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	---help---
	  This is a kernel framebuffer driver for SMSC UFX USB devices.
	  Supports fbdev clients like xf86-video-fbdev, kdrive, fbi, and
	  mplayer -vo fbdev. Supports both UFX6000 (USB 2.0) and UFX7000
	  (USB 3.0) devices.
	  To compile as a module, choose M here: the module name is smscufx.

config FB_UDL
	tristate "Displaylink USB Framebuffer support"
	depends on FB && USB
	select FB_MODE_HELPERS
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	---help---
	  This is a kernel framebuffer driver for DisplayLink USB devices.
	  Supports fbdev clients like xf86-video-fbdev, kdrive, fbi, and
	  mplayer -vo fbdev. Supports all USB 2.0 era DisplayLink devices.
	  To compile as a module, choose M here: the module name is udlfb.

config FB_IBM_GXT4500
	tristate "Framebuffer support for IBM GXT4000P/4500P/6000P/6500P adaptors"
	depends on FB && PPC
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Say Y here to enable support for the IBM GXT4000P/6000P and
	  GXT4500P/6500P display adaptor based on Raster Engine RC1000,
	  found on some IBM System P (pSeries) machines. This driver
	  doesn't use Geometry Engine GT1000.

config FB_PS3
	tristate "PS3 GPU framebuffer driver"
	depends on FB && PS3_PS3AV
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	---help---
	  Include support for the virtual frame buffer in the PS3 platform.

config FB_PS3_DEFAULT_SIZE_M
	int "PS3 default frame buffer size (in MiB)"
	depends on FB_PS3
	default 9
	---help---
	  This is the default size (in MiB) of the virtual frame buffer in
	  the PS3.
	  The default value can be overridden on the kernel command line
	  using the "ps3fb" option (e.g. "ps3fb=9M");

config FB_XILINX
	tristate "Xilinx frame buffer support"
	depends on FB && (XILINX_VIRTEX || MICROBLAZE || ARCH_ZYNQ)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Include support for the Xilinx ML300/ML403 reference design
	  framebuffer. ML300 carries a 640*480 LCD display on the board,
	  ML403 uses a standard DB15 VGA connector.

config FB_GOLDFISH
	tristate "Goldfish Framebuffer"
	depends on FB && HAS_DMA && (GOLDFISH || COMPILE_TEST)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Framebuffer driver for Goldfish Virtual Platform

config FB_COBALT
	tristate "Cobalt server LCD frame buffer support"
	depends on FB && (MIPS_COBALT || MIPS_SEAD3)

config FB_SH7760
	bool "SH7760/SH7763/SH7720/SH7721 LCDC support"
	depends on FB && (CPU_SUBTYPE_SH7760 || CPU_SUBTYPE_SH7763 \
		|| CPU_SUBTYPE_SH7720 || CPU_SUBTYPE_SH7721)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Support for the SH7760/SH7763/SH7720/SH7721 integrated
	  (D)STN/TFT LCD Controller.
	  Supports display resolutions up to 1024x1024 pixel, grayscale and
	  color operation, with depths ranging from 1 bpp to 8 bpp monochrome
	  and 8, 15 or 16 bpp color; 90 degrees clockwise display rotation for
	  panels <= 320 pixel horizontal resolution.

config FB_DA8XX
	tristate "DA8xx/OMAP-L1xx/AM335x Framebuffer support"
	depends on FB && (ARCH_DAVINCI_DA8XX || SOC_AM33XX)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_CFB_REV_PIXELS_IN_BYTE
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS
	---help---
	  This is the frame buffer device driver for the TI LCD controller
	  found on DA8xx/OMAP-L1xx/AM335x SoCs.
	  If unsure, say N.

config FB_VIRTUAL
	tristate "Virtual Frame Buffer support (ONLY FOR TESTING!)"
	depends on FB
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	---help---
	  This is a `virtual' frame buffer device. It operates on a chunk of
	  unswappable kernel memory instead of on the memory of a graphics
	  board. This means you cannot see any output sent to this frame
	  buffer device, while it does consume precious memory. The main use
	  of this frame buffer device is testing and debugging the frame
	  buffer subsystem. Do NOT enable it for normal systems! To protect
	  the innocent, it has to be enabled explicitly at boot time using the
	  kernel option `video=vfb:'.

	  To compile this driver as a module, choose M here: the
	  module will be called vfb. In order to load it, you must use
	  the vfb_enable=1 option.

	  If unsure, say N.

config XEN_FBDEV_FRONTEND
	tristate "Xen virtual frame buffer support"
	depends on FB && XEN
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	select INPUT_XEN_KBDDEV_FRONTEND if INPUT_MISC
	select XEN_XENBUS_FRONTEND
	default y
	help
	  This driver implements the front-end of the Xen virtual
	  frame buffer driver.  It communicates with a back-end
	  in another domain.

config FB_METRONOME
	tristate "E-Ink Metronome/8track controller support"
	depends on FB
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	help
	  This driver implements support for the E-Ink Metronome
	  controller. The pre-release name for this device was 8track
	  and could also have been called by some vendors as PVI-nnnn.

config FB_MB862XX
	tristate "Fujitsu MB862xx GDC support"
	depends on FB
	depends on PCI || (OF && PPC)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Frame buffer driver for Fujitsu Carmine/Coral-P(A)/Lime controllers.

choice
	prompt "GDC variant"
	depends on FB_MB862XX

config FB_MB862XX_PCI_GDC
	bool "Carmine/Coral-P(A) GDC"
	depends on PCI
	---help---
	  This enables framebuffer support for Fujitsu Carmine/Coral-P(A)
	  PCI graphics controller devices.

config FB_MB862XX_LIME
	bool "Lime GDC"
	depends on OF && PPC
	select FB_FOREIGN_ENDIAN
	select FB_LITTLE_ENDIAN
	---help---
	  Framebuffer support for Fujitsu Lime GDC on host CPU bus.

endchoice

config FB_MB862XX_I2C
	bool "Support I2C bus on MB862XX GDC"
	depends on FB_MB862XX && I2C
	depends on FB_MB862XX=m || I2C=y
	default y
	help
	  Selecting this option adds Coral-P(A)/Lime GDC I2C bus adapter
	  driver to support accessing I2C devices on controller's I2C bus.
	  These are usually some video decoder chips.

config FB_EP93XX
	tristate "EP93XX frame buffer support"
	depends on FB && ARCH_EP93XX
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	---help---
	  Framebuffer driver for the Cirrus Logic EP93XX series of processors.
	  This driver is also available as a module. The module will be called
	  ep93xx-fb.

config FB_PRE_INIT_FB
	bool "Don't reinitialize, use bootloader's GDC/Display configuration"
	depends on FB && FB_MB862XX_LIME
	---help---
	  Select this option if display contents should be inherited as set by
	  the bootloader.

config FB_MSM
	tristate "MSM Framebuffer support"
	depends on FB && ARCH_MSM
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT

config FB_MX3
	tristate "MX3 Framebuffer support"
	depends on FB && MX3_IPU
	select BACKLIGHT_CLASS_DEVICE
	select BACKLIGHT_LCD_SUPPORT
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	default y
	help
	  This is a framebuffer device for the i.MX31 LCD Controller. So
	  far only synchronous displays are supported. If you plan to use
	  an LCD display with your i.MX31 system, say Y here.

config FB_BROADSHEET
	tristate "E-Ink Broadsheet/Epson S1D13521 controller support"
	depends on FB
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	help
	  This driver implements support for the E-Ink Broadsheet
	  controller. The release name for this device was Epson S1D13521
	  and could also have been called by other names when coupled with
	  a bridge adapter.

config FB_AUO_K190X
	tristate "AUO-K190X EPD controller support"
	depends on FB
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	select FB_DEFERRED_IO
	help
	  Provides support for epaper controllers from the K190X series
	  of AUO. These controllers can be used to drive epaper displays
	  from Sipix.

	  This option enables the common support, shared by the individual
	  controller drivers. You will also have to enable the driver
	  for the controller type used in your device.

config FB_AUO_K1900
	tristate "AUO-K1900 EPD controller support"
	depends on FB && FB_AUO_K190X
	help
	  This driver implements support for the AUO K1900 epd-controller.
	  This controller can drive Sipix epaper displays but can only do
	  serial updates, reducing the number of possible frames per second.

config FB_AUO_K1901
	tristate "AUO-K1901 EPD controller support"
	depends on FB && FB_AUO_K190X
	help
	  This driver implements support for the AUO K1901 epd-controller.
	  This controller can drive Sipix epaper displays and supports
	  concurrent updates, making higher frames per second possible.

config FB_JZ4740
	tristate "JZ4740 LCD framebuffer support"
	depends on FB && MACH_JZ4740
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	help
	  Framebuffer support for the JZ4740 SoC.

config FB_MXS
	tristate "MXS LCD framebuffer support"
	depends on FB && (ARCH_MXS || ARCH_MXC)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	select FB_MODE_HELPERS
	select VIDEOMODE_HELPERS
	help
	  Framebuffer support for the MXS SoC.

config FB_PUV3_UNIGFX
	tristate "PKUnity v3 Unigfx framebuffer support"
	depends on FB && UNICORE32 && ARCH_PUV3
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_SYS_FOPS
	help
	  Choose this option if you want to use the Unigfx device as a
	  framebuffer device. Without the support of PCI & AGP.

config FB_HYPERV
	tristate "Microsoft Hyper-V Synthetic Video support"
	depends on FB && HYPERV
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  This framebuffer driver supports Microsoft Hyper-V Synthetic Video.

config FB_SIMPLE
	bool "Simple framebuffer support"
	depends on (FB = y)
	select FB_CFB_FILLRECT
	select FB_CFB_COPYAREA
	select FB_CFB_IMAGEBLIT
	help
	  Say Y if you want support for a simple frame-buffer.

	  This driver assumes that the display hardware has been initialized
	  before the kernel boots, and the kernel will simply render to the
	  pre-allocated frame buffer surface.

	  Configuration re: surface address, size, and format must be provided
	  through device tree, or plain old platform data.

source "drivers/video/fbdev/omap/Kconfig"
source "drivers/video/fbdev/omap2/Kconfig"
source "drivers/video/fbdev/exynos/Kconfig"
source "drivers/video/fbdev/mmp/Kconfig"

config FB_SH_MOBILE_MERAM
	tristate "SuperH Mobile MERAM read ahead support"
	depends on (SUPERH || ARCH_SHMOBILE)
	select GENERIC_ALLOCATOR
	---help---
	  Enable MERAM support for the SuperH controller.

	  This will allow for caching of the framebuffer to provide more
	  reliable access under heavy main memory bus traffic situations.
	  Up to 4 memory channels can be configured, allowing 4 RGB or
	  2 YCbCr framebuffers to be configured.

config FB_SSD1307
	tristate "Solomon SSD1307 framebuffer support"
	depends on FB && I2C
	depends on OF
	depends on GPIOLIB
	select FB_SYS_FOPS
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_DEFERRED_IO
	select PWM
	help
	  This driver implements support for the Solomon SSD1307
	  OLED controller over I2C.

config FB_RPISENSE
	tristate "Raspberry Pi Sense HAT framebuffer"
	depends on FB
	select MFD_RPISENSE_CORE
	select FB_SYS_FOPS
	select FB_SYS_FILLRECT
	select FB_SYS_COPYAREA
	select FB_SYS_IMAGEBLIT
	select FB_DEFERRED_IO

	help
	  This is the framebuffer driver for the Raspberry Pi Sense HAT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           SO  .   RO  ..  UO 4 Makefiledpkg-new	  Makefile.dpkg-newakeTO Kconfignew  B	  Makefile.dpkg-new   @	 Kconfig                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ZO  .   AO  ..  _O  Makefiledpkg-new[O , boardske	  Makefile.dpkg-new   ^O Kconfig                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     [O  .   ZO  ..  ]O 4 Makefiledpkg-new	  Makefile.dpkg-new   \O Kconfig                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     `O  .   AO  ..  eO  Makefiledpkg-newaO , boardsle	  Makefile.dpkg-newig dO Kconfig                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     aO  .   `O  ..  cO 4 Makefiledpkg-new	  Makefile.dpkg-new   bO Kconfig                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     