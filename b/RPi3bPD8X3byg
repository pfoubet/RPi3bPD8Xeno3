s
		if tag.kind == 'c' || tag.kind == 'i'
			if !has_key(tag, 'namespace')
				let no_namespace_candidate = tag.filename
			else
				if search_namespace == tolower(tag.namespace)
					return tag.filename
				endif
			endif
		endif
	endfor
	if no_namespace_candidate != ''
		return no_namespace_candidate
	endif

	return ''
endfunction
" }}}

function! phpcomplete#GetFunctionLocation(function_name, namespace) " {{{
	" builtin functions doesn't need explicit \ in front of them even in namespaces,
	" aliased built-in function names are not handled
	if has_key(g:php_builtin_functions, a:function_name.'(')
		return 'VIMPHP_BUILTINFUNCTION'
	endif


	" do in-file lookup for function definition
	let i = 1
	let buffer_lines = getline(1, line('$'))
	for line in buffer_lines
		if line =~? '^\s*function\s\+&\?'.a:function_name.'\s*('
			return expand('%:p')
		endif
	endfor


	if a:namespace == '' || a:namespace == '\'
		let search_namespace = '\'
	else
		let search_namespace = tolower(a:namespace)
	endif
	let no_namespace_candidate = ''
	let tags = phpcomplete#GetTaglist('\c^'.a:function_name.'$')

	for tag in tags
		if tag.kind == 'f'
			if !has_key(tag, 'namespace')
				let no_namespace_candidate = tag.filename
			else
				if search_namespace == tolower(tag.namespace)
					return tag.filename
				endif
			endif
		endif
	endfor
	if no_namespace_candidate != ''
		return no_namespace_candidate
	endif

	return ''
endfunction
" }}}

function! phpcomplete#GetCachedClassContents(classlocation, class_name) " {{{
	let full_file_path = fnamemodify(a:classlocation, ':p')
	let cache_key = full_file_path.'#'.a:class_name.'#'.getftime(full_file_path)

	" try to read from the cache first
	if has_key(s:cache_classstructures, cache_key)
		let classcontents = s:cache_classstructures[cache_key]
		" cached class contents can contain content from multiple files (superclasses) so we have to
		" validate cached result's validness by the filemtimes used to create the cached value
		let valid = 1
		for classstructure in classcontents
			if getftime(classstructure.file) != classstructure.mtime
				let valid = 0
				" we could break here, but the time required for checking probably worth
				" the the memory we can free by checking every file in the cached hirearchy
				call phpcomplete#ClearCachedClassContents(classstructure.file)
			endif
		endfor

		if valid
			" cache hit, we found an entry for this file + class pair and every
			" file in the response is also valid
			return classcontents
		else
			" clear the outdated cached value from the cache store
			call remove(s:cache_classstructures, cache_key)
			call phpcomplete#ClearCachedClassContents(full_file_path)

			" fall trough for the read from files path
		endif
	else
		call phpcomplete#ClearCachedClassContents(full_file_path)
	endif

	" cache miss, fetch the content from the files itself
	let classfile = readfile(a:classlocation)
	let classcontents = phpcomplete#GetClassContentsStructure(full_file_path, classfile, a:class_name)
	let s:cache_classstructures[cache_key] = classcontents

	return classcontents
endfunction " }}}

function! phpcomplete#ClearCachedClassContents(full_file_path) " {{{
	for [cache_key, cached_value] in items(s:cache_classstructures)
		if stridx(cache_key, a:full_file_path.'#') == 0
			call remove(s:cache_classstructures, cache_key)
		endif
	endfor
endfunction " }}}

function! phpcomplete#GetClassContentsStructure(file_path, file_lines, class_name) " {{{
	" returns dictionary containing content, namespace and imports for the class and all parent classes.
	" Example:
	" [
	"	{
	"		class: 'foo',
	"		content: '... class foo extends bar ... ',
	"		namespace: 'NS\Foo',
	"		imports : { ... },
	"		file: '/foo.php',
	"		mtime: 42,
	"	},
	"	{
	"		class: 'bar',
	"		content: '... class bar extends baz ... ',
	"		namespace: 'NS\Bar',
	"		imports : { ... }
	"		file: '/bar.php',
	"		mtime: 42,
	"	},
	"	...
	" ]
	"
	let full_file_path = fnamemodify(a:file_path, ':p')
	let class_name_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
	let cfile = join(a:file_lines, "\n")
	let result = []
	" We use new buffer and (later) normal! because
	" this is the most efficient way. The other way
	" is to go through the looong string looking for
	" matching {}

	" remember the window we started at
	let phpcomplete_original_window = winnr()

	silent! below 1new
	silent! 0put =cfile
	call search('\(class\|interface\)\_s\+'.a:class_name.'\(\>\|$\)')
	let cfline = line('.')
	call search('{')
	let endline = line('.')

	let content = join(getline(cfline, endline), "\n")
	" Catch extends
	if content =~? 'extends'
		let extends_class = matchstr(content, 'class\_s\+'.a:class_name.'\_s\+extends\_s\+\zs'.class_name_pattern.'\ze')
	else
		let extends_class = ''
	endif
	call searchpair('{', '', '}', 'W')
	let classcontent = join(getline(cfline, line('.')), "\n")
	silent! bw! %
	let [current_namespace, imports] = phpcomplete#GetCurrentNameSpace(a:file_lines[0:cfline])
	" go back to original window
	exe phpcomplete_original_window.'wincmd w'
	call add(result, {
				\ 'class': a:class_name,
				\ 'content': classcontent,
				\ 'namespace': current_namespace,
				\ 'imports': imports,
				\ 'file': full_file_path,
				\ 'mtime': getftime(full_file_path),
				\ })

	if extends_class != ''
		let [extends_class, namespace] = phpcomplete#ExpandClassName(extends_class, current_namespace, imports)
		if namespace == ''
			let namespace = '\'
		endif
		let classlocation = phpcomplete#GetClassLocation(extends_class, namespace)
		if classlocation == "VIMPHP_BUILTINOBJECT"
			let result += [phpcomplete#GenerateBuiltinClassStub(g:php_builtin_classes[tolower(extends_class)])]
		elseif classlocation != '' && filereadable(classlocation)
			let full_file_path = fnamemodify(classlocation, ':p')
			let result += phpcomplete#GetClassContentsStructure(full_file_path, readfile(full_file_path), extends_class)
		elseif tolower(current_namespace) == tolower(namespace)
			" try to find the declaration in the same file.
			let result += phpcomplete#GetClassContentsStructure(full_file_path, a:file_lines, extends_class)
		endif
	endif

	return result
endfunction
" }}}

function! phpcomplete#GetClassContents(classlocation, class_name) " {{{
	let classcontents = phpcomplete#GetCachedClassContents(a:classlocation, a:class_name)
	let result = []
	for classstructure in classcontents
		call add(result, classstructure.content)
	endfor
	return join(result, "\n")
endfunction
" }}}

function! phpcomplete#GenerateBuiltinClassStub(class_info) " {{{
	let re = 'class '.a:class_info['name']." {"
	for [name, initializer] in items(a:class_info.constants)
		let re .= "\n\tconst ".name." = ".initializer.";"
	endfor
	for [name, info] in items(a:class_info.properties)
		let re .= "\n\t// @var $".name." ".info.type
		let re .= "\n\tpublic $".name.";"
	endfor
	for [name, info] in items(a:class_info.static_properties)
		let re .= "\n\t// @var ".name." ".info.type
		let re .= "\n\tpublic static ".name." = ".info.initializer.";"
	endfor
	for [name, info] in items(a:class_info.methods)
		if name =~ '^__'
			continue
		endif
		let re .= "\n\t/**"
		let re .= "\n\t * ".name
		let re .= "\n\t *"
		let re .= "\n\t * @return ".info.return_type
		let re .= "\n\t */"
		let re .= "\n\tpublic function ".name."(".info.signature."){"
		let re .= "\n\t}"
	endfor
	for [name, info] in items(a:class_info.static_methods)
		let re .= "\n\t/**"
		let re .= "\n\t * ".name
		let re .= "\n\t *"
		let re .= "\n\t * @return ".info.return_type
		let re .= "\n\t */"
		let re .= "\n\tpublic static function ".name."(".info.signature."){"
		let re .= "\n\t}"
	endfor
	let re .= "\n}"

	return { 'class': a:class_info['name'],
				\ 'content': re,
				\ 'namespace': '',
				\ 'imports': {},
				\ 'file': 'VIMPHP_BUILTINOBJECT',
				\ 'mtime': 0,
				\ }
endfunction " }}}

function! phpcomplete#GetDocBlock(sccontent, search) " {{{
	let i = 0
	let l = 0
	let comment_start = -1
	let comment_end = -1
	let sccontent_len = len(a:sccontent)

	while (i < sccontent_len)
		let line = a:sccontent[i]
		" search for a function declaration
		if line =~? a:search
			let l = i - 1
			" start backward serch for the comment block
			while l != 0
				let line = a:sccontent[l]
				" if comment end found save line position and end search
				if line =~? '^\s*\*/'
					let comment_end = l
					break
				" ... or the line doesn't blank (only whitespace or nothing) end search
				elseif line !~? '^\s*$'
					break
				endif
				let l -= 1
			endwhile
			" no comment found
			if comment_end == -1
				return ''
			end

			while l != 0
				let line = a:sccontent[l]
				if line =~? '^\s*/\*\*'
					let comment_start = l
					break
				endif
				let l -= 1
			endwhile
			" no docblock comment start found
			if comment_start == -1
				return ''
			end

			let comment_start += 1 " we dont need the /**
			let comment_end   -= 1 " we dont need the */

			" remove leading whitespace and '*'s
			let docblock = join(map(copy(a:sccontent[comment_start :comment_end]), 'substitute(v:val, "^\\s*\\*\\s*", "", "")'), "\n")
			return docblock
		endif
		let i += 1
	endwhile
	return ''
endfunction
" }}}

function! phpcomplete#ParseDocBlock(docblock) " {{{
	let res = {
		\ 'description': '',
		\ 'params': [],
		\ 'return': {},
		\ 'throws': [],
		\ 'var': {},
		\ }

	let res.description = substitute(matchstr(a:docblock, '\zs\_.\{-}\ze\(@var\|@param\|@return\|$\)'), '\(^\_s*\|\_s*$\)', '', 'g')
	let docblock_lines = split(a:docblock, "\n")

	let param_lines = filter(copy(docblock_lines), 'v:val =~? "^@param"')
	for param_line in param_lines
		let parts = matchlist(param_line, '@param\s\+\(\S\+\)\s\+\(\S\+\)\s*\(.*\)')
		if len(parts) > 0
			call add(res.params, {
						\ 'line': parts[0],
						\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(parts, 1, '')),
						\ 'name': get(parts, 2, ''),
						\ 'description': get(parts, 3, '')})
		endif
	endfor

	let return_line = filter(copy(docblock_lines), 'v:val =~? "^@return"')
	if len(return_line) > 0
		let return_parts = matchlist(return_line[0], '@return\s\+\(\S\+\)\s*\(.*\)')
		let res['return'] = {
					\ 'line': return_parts[0],
					\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(return_parts, 1, '')),
					\ 'description': get(return_parts, 2, '')}
	endif

	let exception_lines = filter(copy(docblock_lines), 'v:val =~? "^\\(@throws\\|@exception\\)"')
	for exception_line in exception_lines
		let parts = matchlist(exception_line, '^\(@throws\|@exception\)\s\+\(\S\+\)\s*\(.*\)')
		if len(parts) > 0
			call add(res.throws, {
						\ 'line': parts[0],
						\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(parts, 2, '')),
						\ 'description': get(parts, 3, '')})
		endif
	endfor

	let var_line = filter(copy(docblock_lines), 'v:val =~? "^@var"')
	if len(var_line) > 0
		let var_parts = matchlist(var_line[0], '@var\s\+\(\S\+\)\s*\(.*\)')
		let res['var'] = {
					\ 'line': var_parts[0],
					\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(var_parts, 1, '')),
					\ 'description': get(var_parts, 2, '')}
	endif

	return res
endfunction
" }}}

function! phpcomplete#GetTypeFromDocBlockParam(docblock_type) " {{{
	if a:docblock_type !~ '|'
		return a:docblock_type
	endif

	let primitive_types = [
				\ 'string', 'float', 'double', 'int',
				\ 'scalar', 'array', 'bool', 'void', 'mixed',
				\ 'null', 'callable', 'resource', 'object']

	" add array of primitives to the list too, like string[]
	let primitive_types += map(copy(primitive_types), 'v:val."[]"')
	let types = split(a:docblock_type, '|')
	for type in types
		if index(primitive_types, type) == -1
			return type
		endif
	endfor

	" only primitive types found, return the first one
	return types[0]

endfunction
" }}}

function! phpcomplete#FormatDocBlock(info) " {{{
	let res = ''
	if len(a:info.description)
		let res .= "Description:\n".join(map(split(a:info['description'], "\n"), '"\t".v:val'), "\n")."\n"
	endif

	if len(a:info.params)
		let res .= "\nArguments:\n"
		for arginfo in a:info.params
			let res .= "\t".arginfo['name'].' '.arginfo['type']
			if len(arginfo.description) > 0
				let res .= ': '.arginfo['description']
			endif
			let res .= "\n"
		endfor
	endif

	if has_key(a:info.return, 'type')
		let res .= "\nReturn:\n\t".a:info['return']['type']
		if len(a:info.return.description) > 0
			let res .= ": ".a:info['return']['description']
		endif
		let res .= "\n"
	endif

	if len(a:info.throws)
		let res .= "\nThrows:\n"
		for excinfo in a:info.throws
			let res .= "\t".excinfo['type']
			if len(excinfo['description']) > 0
				let res .= ": ".excinfo['description']
			endif
			let res .= "\n"
		endfor
	endif

	if has_key(a:info.var, 'type')
		let res .= "Type:\n\t".a:info['var']['type']."\n"
		if len(a:info['var']['description']) > 0
			let res .= ': '.a:info['var']['description']
		endif
	endif

	return res
endfunction!
" }}}

function! phpcomplete#GetCurrentNameSpace(file_lines) " {{{
	let namespace_name_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
	let file_lines = reverse(copy(a:file_lines))
	let i = 0
	let file_length = len(file_lines)
	let imports = {}

	let current_namespace = '\'

	while i < file_length
		let line = file_lines[i]

		if line =~? '^\s*namespace\s*'.namespace_name_pattern
			let current_namespace = matchstr(line, '^\s*namespace\s*\zs'.namespace_name_pattern.'\ze')
			break
		endif

		if line =~? '^\s*use\>'
			if line =~? ';'
				let use_line = line
			else
				" try to find the next line containing ';'
				let l = i
				let search_line = line
				let use_line = line

				" add lines from the file until theres no ';' in them
				while search_line !~? ';' && l > 0
					" file lines are reversed so we need to go backwards
					let l -= 1
					let search_line = file_lines[l]
					let use_line .= ' '.substitute(search_line, '\(^\s\+\|\s\+$\)', '', 'g')
				endwhile
			endif
			let use_expression = matchstr(use_line, '^\s*use\s\+\zs.\{-}\ze;')
			let use_parts = map(split(use_expression, '\s*,\s*'), 'substitute(v:val, "\\s+", " ", "g")')
			for part in use_parts
				if part =~? '\s\+as\s\+'
					let [object, name] = split(part, '\s\+as\s\+')
					let object = substitute(object, '^\\', '', '')
					let name   = substitute(name, '^\\', '', '')
				else
					let object = part
					let name = part
					let object = substitute(object, '^\\', '', '')
					let name   = substitute(name, '^\\', '', '')
					if name =~? '\\'
						let	name = matchstr(name, '\\\zs[^\\]\+\ze$')
					endif
				endif
				" leading slash is not required use imports are always absolute
				let imports[name] = {'name': object, 'kind': ''}
			endfor

			" find kind flags from tags or built in methods for the objects we extracted
			" they can be either classes, interfaces or namespaces, no other thing is importable in php
			for [key, import] in items(imports)
				" if theres a \ in the name we have it's definetly not a built in thing, look for tags
				if import.name =~ '\\'
					let patched_ctags_detected = 0
					let [classname, namespace_for_classes] = phpcomplete#ExpandClassName(import.name, '\', {})
					let namespace_name_candidate = substitute(import.name, '\\', '\\\\', 'g')
					" can be a namespace name as is, or can be a tagname at the end with a namespace
					let tags = phpcomplete#GetTaglist('^\('.namespace_name_candidate.'\|'.classname.'\)$')
					if len(tags) > 0
						for tag in tags
							" if there's a namespace with the name of the import
							if tag.kind == 'n' && tag.name == import.name
								call extend(import, tag)
								let import['builtin'] = 0
								let patched_ctags_detected = 1
								break
							endif
							" if the name matches with the extracted classname and namespace
							if (tag.kind == 'c' || tag.kind == 'i') && tag.name == classname
								if has_key(tag, 'namespace')
									let patched_ctags_detected = 1
									if tag.namespace == namespace_for_classes
										call extend(import, tag)
										let import['builtin'] = 0
										break
									endif
								elseif !exists('no_namespace_candidate')
									" save the first namespacless match to be used if no better
									" candidate found later on
									let no_namespace_candidate = tag
								endif
							endif
						endfor
						" there were a namespacless class name match, if we think that the
						" tags are not generated with patched ctags we will take it as a match
						if exists('no_namespace_candidate') && !patched_ctags_detected
							call extend(import, no_namespace_candidate)
							let import['builtin'] = 0
						endif
					else
						" if no tags are found, extract the namespace from the name
						let ns = matchstr(import.name, '\c\zs[a-zA-Z0-9\\]\+\ze\\' . name)
						if len(ns) > 0
							let import['name'] = name
							let import['namespace'] = ns
							let import['builtin'] = 0
						endif
					endif
				else
					" if no \ in the name, it can be a built in class
					if has_key(g:php_builtin_classnames, tolower(import.name))
						let import['kind'] = 'c'
						let import['builtin'] = 1
					elseif has_key(g:php_builtin_interfacenames, tolower(import.name))
						let import['kind'] = 'i'
						let import['builtin'] = 1
					else
						" or can be a tag with exactly matchign name
						let tags = phpcomplete#GetTaglist('^'.import['name'].'$')
						for tag in tags
							" search for the first matchin namespace, class, interface with no namespace
							if !has_key(tag, 'namespace') && (tag.kind == 'n' || tag.kind == 'c' || tag.kind == 'i')
								call extend(import, tag)
								let import['builtin'] = 0
								break
							endif
						endfor
					endif
				endif
				if exists('no_namespace_candidate')
					unlet no_namespace_candidate
				endif
			endfor
		endif
		let i += 1
	endwhile
	let sorted_imports = {}
	for name in sort(keys(imports))
		let sorted_imports[name] = imports[name]
	endfor
	return [current_namespace, sorted_imports]
endfunction
" }}}

function! phpcomplete#GetCurrentFunctionBoundaries() " {{{
	let old_cursor_pos = [line('.'), col('.')]
	let current_line_no = old_cursor_pos[0]
	let function_pattern = '\c\(.*\%#\)\@!\_^\s*\zs\(abstract\s\+\|final\s\+\|private\s\+\|protected\s\+\|public\s\+\|static\s\+\)*function\_.\{-}(\_.\{-})\_.\{-}{'

	let func_start_pos = searchpos(function_pattern, 'Wbc')
	if func_start_pos == [0, 0]
		call cursor(old_cursor_pos[0], old_cursor_pos[1])
		return 0
	endif

	" get the line where the function declaration actually started
	call search('\cfunction\_.\{-}(\_.\{-})\_.\{-}{', 'Wce')

	" get the position of the function block's closing "}"
	let func_end_pos = searchpairpos('{', '', '}', 'W')
	if func_end_pos == [0, 0]
		" there is a function start but no end found, assume that we are in a
		" function but the user did not typed the closing "}" yet and the
		" function runs to the end of the file
		let func_end_pos = [line('$'), len(getline(line('$')))]
	endif

	" Decho func_start_pos[0].' <= '.current_line_no.' && '.current_line_no.' <= '.func_end_pos[0]
	if func_start_pos[0] <= current_line_no && current_line_no <= func_end_pos[0]
		call cursor(old_cursor_pos[0], old_cursor_pos[1])
		return [func_start_pos, func_end_pos]
	endif

	call cursor(old_cursor_pos[0], old_cursor_pos[1])
	return 0
endfunction
" }}}

function! phpcomplete#ExpandClassName(classname, current_namespace, imports) " {{{
	" if there's an imported class, just use that class's information
	if has_key(a:imports, a:classname) && (a:imports[a:classname].kind == 'c' || a:imports[a:classname].kind == 'i')
		let namespace = has_key(a:imports[a:classname], 'namespace') ? a:imports[a:classname].namespace : ''
		return [a:imports[a:classname].name, namespace]
	endif

	" try to find relative namespace in imports, imported names takes precedence over
	" current namespace when resolving relative namespaced class names
	if a:classname !~ '^\' && a:classname =~ '\\'
		let classname_parts = split(a:classname, '\\\+')
		if has_key(a:imports, classname_parts[0]) && a:imports[classname_parts[0]].kind == 'n'
			let classname_parts[0] = a:imports[classname_parts[0]].name
			let namespace = join(classname_parts[0:-2], '\')
			let classname = classname_parts[-1]
			return [classname, namespace]
		endif
	endif

	" no imported class or namespace matched, expand with the current namespace
	let namespace = ''
	let classname = a:classname
	" if the classname have namespaces in in or we are in a namespace
	if a:classname =~ '\\' || (a:current_namespace != '\' && a:current_namespace != '')
		" add current namespace to the a:classname
		if a:classname !~ '^\'
			let classname = a:current_namespace.'\'.substitute(a:classname, '^\\', '', '')
		else
			" remove leading \, tag files doesn't have those
			let classname = substitute(a:classname, '^\\', '', '')
		endif
		" split classname to classname and namespace
		let classname_parts = split(classname, '\\\+')
		if len(classname_parts) > 1
			let namespace = join(classname_parts[0:-2], '\')
			let classname = classname_parts[-1]
		endif
	endif
	return [classname, namespace]
endfunction
" }}}

function! phpcomplete#LoadData() " {{{
" Keywords/reserved words, all other special things
" Later it is possible to add some help to values, or type of defined variable
let g:php_keywords={'PHP_SELF':'','argv':'','argc':'','GATEWAY_INTERFACE':'','SERVER_ADDR':'','SERVER_NAME':'','SERVER_SOFTWARE':'','SERVER_PROTOCOL':'','REQUEST_METHOD':'','REQUEST_TIME':'','QUERY_STRING':'','DOCUMENT_ROOT':'','HTTP_ACCEPT':'','HTTP_ACCEPT_CHARSET':'','HTTP_ACCEPT_ENCODING':'','HTTP_ACCEPT_LANGUAGE':'','HTTP_CONNECTION':'','HTTP_POST':'','HTTP_REFERER':'','HTTP_USER_AGENT':'','HTTPS':'','REMOTE_ADDR':'','REMOTE_HOST':'','REMOTE_PORT':'','SCRIPT_FILENAME':'','SERVER_ADMIN':'','SERVER_PORT':'','SERVER_SIGNATURE':'','PATH_TRANSLATED':'','SCRIPT_NAME':'','REQUEST_URI':'','PHP_AUTH_DIGEST':'','PHP_AUTH_USER':'','PHP_AUTH_PW':'','AUTH_TYPE':'','and':'','or':'','xor':'','__FILE__':'','exception':'','__LINE__':'','as':'','break':'','case':'','class':'','const':'','continue':'','declare':'','default':'','do':'','echo':'','else':'','elseif':'','enddeclare':'','endfor':'','endforeach':'','endif':'','endswitch':'','endwhile':'','extends':'','for':'','foreach':'','function':'','global':'','if':'','new':'','static':'','switch':'','use':'','var':'','while':'','final':'','php_user_filter':'','interface':'','implements':'','public':'','private':'','protected':'','abstract':'','clone':'','try':'','catch':'','throw':'','cfunction':'','old_function':'','this':'','INI_USER': '','INI_PERDIR': '','INI_SYSTEM': '','INI_ALL': '','ABDAY_1': '','ABDAY_2': '','ABDAY_3': '','ABDAY_4': '','ABDAY_5': '','ABDAY_6': '','ABDAY_7': '','DAY_1': '','DAY_2': '','DAY_3': '','DAY_4': '','DAY_5': '','DAY_6': '','DAY_7': '','ABMON_1': '','ABMON_2': '','ABMON_3': '','ABMON_4': '','ABMON_5': '','ABMON_6': '','ABMON_7': '','ABMON_8': '','ABMON_9': '','ABMON_10': '','ABMON_11': '','ABMON_12': '','MON_1': '','MON_2': '','MON_3': '','MON_4': '','MON_5': '','MON_6': '','MON_7': '','MON_8': '','MON_9': '','MON_10': '','MON_11': '','MON_12': '','AM_STR': '','D_T_FMT': '','ALT_DIGITS': '',}
" One giant hash of all built-in function, class, interface and constant grouped by extension
let php_builtin = {'functions':{},'classes':{},'interfaces':{},'constants':{},}
let php_builtin['functions']['math']={'abs(':'mixed $number | number','acos(':'float $arg | float','acosh(':'float $arg | float','asin(':'float $arg | float','asinh(':'float $arg | float','atan(':'float $arg | float','atan2(':'float $y, float $x | float','atanh(':'float $arg | float','base_convert(':'string $number, int $frombase, int $tobase | string','bindec(':'string $binary_string | number','ceil(':'float $value | float','cos(':'float $arg | float','cosh(':'float $arg | float','decbin(':'int $number | string','dechex(':'int $number | string','decoct(':'int $number | string','deg2rad(':'float $number | float','exp(':'float $arg | float','expm1(':'float $arg | float','floor(':'float $value | float','fmod(':'float $x, float $y | float','getrandmax(':'void | int','hexdec(':'string $hex_string | number','hypot(':'float $x, float $y | float','is_finite(':'float $val | bool','is_infinite(':'float $val | bool','is_nan(':'float $val | bool','lcg_value(':'void | float','log(':'float $arg [, float $base = M_E] | float','log10(':'float $arg | float','log1p(':'float $number | float','max(':'array $values | mixed','min(':'array $values | mixed','mt_getrandmax(':'void | int','mt_rand(':'void | int','mt_srand(':'[ int $seed] | void','octdec(':'string $octal_string | number','pi(':'void | float','pow(':'number $base, number $exp | number','rad2deg(':'float $number | float','rand(':'void | int','round(':'float $val [, int $precision = 0 [, int $mode = PHP_ROUND_HALF_UP]] | float','sin(':'float $arg | float','sinh(':'float $arg | float','sqrt(':'float $arg | float','srand(':'[ int $seed] | void','tan(':'float $arg | float','tanh(':'float $arg | float',}
let php_builtin['functions']['strings']={'addcslashes(':'string $str, string $charlist | string','addslashes(':'string $str | string','bin2hex(':'string $str | string','chop(':'chop — Alias of rtrim()','chr(':'int $ascii | string','chunk_split(':'string $body [, int $chunklen = 76 [, string $end = "\r\n"]] | string','convert_cyr_string(':'string $str, string $from, string $to | string','convert_uudecode(':'string $data | string','convert_uuencode(':'string $data | string','count_chars(':'string $string [, int $mode = 0] | mixed','crc32(':'string $str | int','crypt(':'string $str [, string $salt] | string','echo(':'string $arg1 [, string $...] | void','explode(':'string $delimiter, string $string [, int $limit] | array','fprintf(':'resource $handle, string $format [, mixed $args [, mixed $...]] | int','get_html_translation_table(':'[ int $table = HTML_SPECIALCHARS [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'']]] | array','hebrev(':'string $hebrew_text [, int $max_chars_per_line = 0] | string','hebrevc(':'string $hebrew_text [, int $max_chars_per_line = 0] | string','hex2bin(':'string $data | string','html_entity_decode(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'']] | string','htmlentities(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'' [, bool $double_encode = true]]] | string','htmlspecialchars_decode(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401] | string','htmlspecialchars(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'' [, bool $double_encode = true]]] | string','implode(':'string $glue, array $pieces | string','join(':'join — Alias of implode()','lcfirst(':'string $str | string','levenshtein(':'string $str1, string $str2 | int','localeconv(':'void | array','ltrim(':'string $str [, string $character_mask] | string','md5_file(':'string $filename [, bool $raw_output = false] | string','md5(':'string $str [, bool $raw_output = false] | string','metaphone(':'string $str [, int $phonemes = 0] | string','money_format(':'string $format, float $number | string','nl_langinfo(':'int $item | string','nl2br(':'string $string [, bool $is_xhtml = true] | string','number_format(':'float $number [, int $decimals = 0] | string','ord(':'string $string | int','parse_str(':'string $str [, array &$arr] | void','print(':'string $arg | int','printf(':'string $format [, mixed $args [, mixed $...]] | int','quoted_printable_decode(':'string $str | string','quoted_printable_encode(':'string $str | string','quotemeta(':'string $str | string','rtrim(':'string $str [, string $character_mask] | string','setlocale(':'int $category, string $locale [, string $...] | string','sha1_file(':'string $filename [, bool $raw_output = false] | string','sha1(':'string $str [, bool $raw_output = false] | string','similar_text(':'string $first, string $second [, float &$percent] | int','soundex(':'string $str | string','sprintf(':'string $format [, mixed $args [, mixed $...]] | string','sscanf(':'string $str, string $format [, mixed &$...] | mixed','str_getcsv(':'string $input [, string $delimiter = '','' [, string $enclosure = ''"'' [, string $escape = ''\\'']]] | array','str_ireplace(':'mixed $search, mixed $replace, mixed $subject [, int &$count] | mixed','str_pad(':'string $input, int $pad_length [, string $pad_string = " " [, int $pad_type = STR_PAD_RIGHT]] | string','str_repeat(':'string $input, int $multiplier | string','str_replace(':'mixed $search, mixed $replace, mixed $subject [, int &$count] | mixed','str_rot13(':'string $str | string','str_shuffle(':'string $str | string','str_split(':'string $string [, int $split_length = 1] | array','str_word_count(':'string $string [, int $format = 0 [, string $charlist]] | mixed','strcasecmp(':'string $str1, string $str2 | int','strchr(':'strchr — Alias of strstr()','strcmp(':'string $str1, string $str2 | int','strcoll(':'string $str1, string $str2 | int','strcspn(':'string $str1, string $str2 [, int $start [, int $length]] | int','strip_tags(':'string $str [, string $allowable_tags] | string','stripcslashes(':'string $str | string','stripos(':'string $haystack, string $needle [, int $offset = 0] | int','stripslashes(':'string $str | string','stristr(':'string $haystack, mixed $needle [, bool $before_needle = false] | string','strlen(':'string $string | int','strnatcasecmp(':'string $str1, string $str2 | int','strnatcmp(':'string $str1, string $str2 | int','strncasecmp(':'string $str1, string $str2, int $len | int','strncmp(':'string $str1, string $str2, int $len | int','strpbrk(':'string $haystack, string $char_list | string','strpos(':'string $haystack, mixed $needle [, int $offset = 0] | mixed','strrchr(':'string $haystack, mixed $needle | string','strrev(':'string $string | string','strripos(':'string $haystack, string $needle [, int $offset = 0] | int','strrpos(':'string $haystack, string $needle [, int $offset = 0] | int','strspn(':'string $subject, string $mask [, int $start [, int $length]] | int','strstr(':'string $haystack, mixed $needle [, bool $before_needle = false] | string','strtok(':'string $str, string $token | string','strtolower(':'string $str | string','strtoupper(':'string $string | string','strtr(':'string $str, string $from, string $to | string','substr_compare(':'string $main_str, string $str, int $offset [, int $length [, bool $case_insensitivity = false]] | int','substr_count(':'string $haystack, string $needle [, int $offset = 0 [, int $length]] | int','substr_replace(':'mixed $string, mixed $replacement, mixed $start [, mixed $length] | mixed','substr(':'string $string, int $start [, int $length] | string','trim(':'string $str [, string $character_mask = " \t\n\r\0\x0B"] | string','ucfirst(':'string $str | string','ucwords(':'string $str | string','vfprintf(':'resource $handle, string $format, array $args | int','vprintf(':'string $format, array $args | int','vsprintf(':'string $format, array $args | string','wordwrap(':'string $str [, int $width = 75 [, string $break = "\n" [, bool $cut = false]]] | string',}
let php_builtin['functions']['apache']={'apache_child_terminate(':'void | bool','apache_get_modules(':'void | array','apache_get_version(':'void | string','apache_getenv(':'string $variable [, bool $walk_to_top = false] | string','apache_lookup_uri(':'string $filename | object','apache_note(':'string $note_name [, string $note_value = ""] | string','apache_request_headers(':'void | array','apache_reset_timeout(':'void | bool','apache_response_headers(':'void | array','apache_setenv(':'string $variable, string $value [, bool $walk_to_top = false] | bool','getallheaders(':'void | array','virtual(':'string $filename | bool',}
let php_builtin['functions']['arrays']={'array_change_key_case(':'array $array [, int $case = CASE_LOWER] | array','array_chunk(':'array $array, int $size [, bool $preserve_keys = false] | array','array_column(':'array $array, mixed $column_key [, mixed $index_key = null] | array','array_combine(':'array $keys, array $values | array','array_count_values(':'array $array | array','array_diff_assoc(':'array $array1, array $array2 [, array $...] | array','array_diff_key(':'array $array1, array $array2 [, array $...] | array','array_diff_uassoc(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_diff_ukey(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_diff(':'array $array1, array $array2 [, array $...] | array','array_fill_keys(':'array $keys, mixed $value | array','array_fill(':'int $start_index, int $num, mixed $value | array','array_filter(':'array $array [, callable $callback] | array','array_flip(':'array $array | array','array_intersect_assoc(':'array $array1, array $array2 [, array $...] | array','array_intersect_key(':'array $array1, array $array2 [, array $...] | array','array_intersect_uassoc(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_intersect_ukey(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_intersect(':'array $array1, array $array2 [, array $...] | array','array_key_exists(':'mixed $key, array $array | bool','array_keys(':'array $array [, mixed $search_value [, bool $strict = false]] | array','array_map(':'callable $callback, array $array1 [, array $...] | array','array_merge_recursive(':'array $array1 [, array $...] | array','array_merge(':'array $array1 [, array $...] | array','array_multisort(':'array &$array1 [, mixed $array1_sort_order = SORT_ASC [, mixed $array1_sort_flags = SORT_REGULAR [, mixed $...]]] | bool','array_pad(':'array $array, int $size, mixed $value | array','array_pop(':'array &$array | mixed','array_product(':'array $array | number','array_push(':'array &$array, mixed $value1 [, mixed $...] | int','array_rand(':'array $array [, int $num = 1] | mixed','array_reduce(':'array $array, callable $callback [, mixed $initial = NULL] | mixed','array_replace_recursive(':'array $array1, array $array2 [, array $...] | array','array_replace(':'array $array1, array $array2 [, array $...] | array','array_reverse(':'array $array [, bool $preserve_keys = false] | array','array_search(':'mixed $needle, array $haystack [, bool $strict = false] | mixed','array_shift(':'array &$array | mixed','array_slice(':'array $array, int $offset [, int $length = NULL [, bool $preserve_keys = false]] | array','array_splice(':'array &$input, int $offset [, int $length [, mixed $replacement = array()]] | array','array_sum(':'array $array | number','array_udiff_assoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_udiff_uassoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func [, callable $key_compare_func]]] | array','array_udiff(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_uintersect_assoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_uintersect_uassoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func [, callable $key_compare_func]]] | array','array_uintersect(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_unique(':'array $array [, int $sort_flags = SORT_STRING] | array','array_unshift(':'array &$array, mixed $value1 [, mixed $...] | int','array_values(':'array $array | array','array_walk_recursive(':'array &$array, callable $callback [, mixed $userdata = NULL] | bool','array_walk(':'array &$array, callable $callback [, mixed $userdata = NULL] | bool','array(':'[ mixed $...] | array','arsort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','asort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','compact(':'mixed $varname1 [, mixed $...] | array','count(':'mixed $array_or_countable [, int $mode = COUNT_NORMAL] | int','current(':'array &$array | mixed','each(':'array &$array | array','end(':'array &$array | mixed','extract(':'array &$array [, int $flags = EXTR_OVERWRITE [, string $prefix = NULL]] | int','in_array(':'mixed $needle, array $haystack [, bool $strict = FALSE] | bool','key_exists(':'key_exists — Alias of array_key_exists()','key(':'array &$array | mixed','krsort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','ksort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','list(':'mixed $var1 [, mixed $...] | array','natcasesort(':'array &$array | bool','natsort(':'array &$array | bool','next(':'array &$array | mixed','pos(':'pos — Alias of current()','prev(':'array &$array | mixed','range(':'mixed $start, mixed $end [, number $step = 1] | array','reset(':'array &$array | mixed','rsort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','shuffle(':'array &$array | bool','sizeof(':'sizeof — Alias of count()','sort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','uasort(':'array &$array, callable $value_compare_func | bool','uksort(':'array &$array, callable $key_compare_func | bool','usort(':'array &$array, callable $value_compare_func | bool',}
let php_builtin['functions']['php_options_info']={'assert_options(':'int $what [, mixed $value] | mixed','assert(':'mixed $assertion [, string $description] | bool','cli_get_process_title(':'void | string','cli_set_process_title(':'string $title | bool','dl(':'string $library | bool','extension_loaded(':'string $name | bool','gc_collect_cycles(':'void | int','gc_disable(':'void | void','gc_enable(':'void | void','gc_enabled(':'void | bool','get_cfg_var(':'string $option | string','get_current_user(':'void | string','get_defined_constants(':'[ bool $categorize = false] | array','get_extension_funcs(':'string $module_name | array','get_include_path(':'void | string','get_included_files(':'void | array','get_loaded_extensions(':'[ bool $zend_extensions = false] | array','get_magic_quotes_gpc(':'void | bool','get_magic_quotes_runtime(':'void | bool','get_required_files(':'get_required_files — Alias of get_included_files()','getenv(':'string $varname | string','getlastmod(':'void | int','getmygid(':'void | int','getmyinode(':'void | int','getmypid(':'void | int','getmyuid(':'void | int','getopt(':'string $options [, array $longopts] | array','getrusage(':'[ int $who = 0] | array','ini_alter(':'ini_alter — Alias of ini_set()','ini_get_all(':'[ string $extension [, bool $details = true]] | array','ini_get(':'string $varname | string','ini_restore(':'string $varname | void','ini_set(':'string $varname, string $newvalue | string','magic_quotes_runtime(':'magic_quotes_runtime — Alias of set_magic_quotes_runtime()','memory_get_peak_usage(':'[ bool $real_usage = false] | int','memory_get_usage(':'[ bool $real_usage = false] | int','php_ini_loaded_file(':'void | string','php_ini_scanned_files(':'void | string','php_logo_guid(':'void | string','php_sapi_name(':'void | string','php_uname(':'[ string $mode = "a"] | string','phpcredits(':'[ int $flag = CREDITS_ALL] | bool','phpinfo(':'[ int $what = INFO_ALL] | bool','phpversion(':'[ string $extension] | string','putenv(':'string $setting | bool','restore_include_path(':'void | void','set_include_path(':'string $new_include_path | string','set_magic_quotes_runtime(':'bool $new_setting | bool','set_time_limit(':'int $seconds | void','sys_get_temp_dir(':'void | string','version_compare(':'string $version1, string $version2 [, string $operator] | mixed','zend_logo_guid(':'void | string','zend_thread_id(':'void | int','zend_version(':'void | string',}
let php_builtin['functions']['classes_objects']={'__autoload(':'string $class | void','call_user_method_array(':'string $method_name, object &$obj, array $params | mixed','call_user_method(':'string $method_name, object &$obj [, mixed $parameter [, mixed $...]] | mixed','class_alias(':'string $original, string $alias [, bool $autoload = TRUE] | bool','class_exists(':'string $class_name [, bool $autoload = true] | bool','get_called_class(':'void | string','get_class_methods(':'mixed $class_name | array','get_class_vars(':'string $class_name | array','get_class(':'[ object $object = NULL] | string','get_declared_classes(':'void | array','get_declared_interfaces(':'void | array','get_declared_traits(':'void | array','get_object_vars(':'object $object | array','get_parent_class(':'[ mixed $object] | string','interface_exists(':'string $interface_name [, bool $autoload = true] | bool','is_a(':'object $object, string $class_name [, bool $allow_string = FALSE] | bool','is_subclass_of(':'mixed $object, string $class_name [, bool $allow_string = TRUE] | bool','method_exists(':'mixed $object, string $method_name | bool','property_exists(':'mixed $class, string $property | bool','trait_exists(':'string $traitname [, bool $autoload] | bool',}
let php_builtin['functions']['urls']={'base64_decode(':'string $data [, bool $strict = false] | string','base64_encode(':'string $data | string','get_headers(':'string $url [, int $format = 0] | array','get_meta_tags(':'string $filename [, bool $use_include_path = false] | array','http_build_query(':'mixed $query_data [, string $numeric_prefix [, string $arg_separator [, int $enc_type = PHP_QUERY_RFC1738]]] | string','parse_url(':'string $url [, int $component = -1] | mixed','rawurldecode(':'string $str | string','rawurlencode(':'string $str | string','urldecode(':'string $str | string','urlencode(':'string $str | string',}
let php_builtin['functions']['filesystem']={'basename(':'string $path [, string $suffix] | string','chgrp(':'string $filename, mixed $group | bool','chmod(':'string $filename, int $mode | bool','chown(':'string $filename, mixed $user | bool','clearstatcache(':'[ bool $clear_realpath_cache = false [, string $filename]] | void','copy(':'string $source, string $dest [, resource $context] | bool','dirname(':'string $path | string','disk_free_space(':'string $directory | float','disk_total_space(':'string $directory | float','diskfreespace(':'diskfreespace — Alias of disk_free_space()','fclose(':'resource $handle | bool','feof(':'resource $handle | bool','fflush(':'resource $handle | bool','fgetc(':'resource $handle | string','fgetcsv(':'resource $handle [, int $length = 0 [, string $delimiter = '','' [, string $enclosure = ''"'' [, string $escape = ''\\'']]]] | array','fgets(':'resource $handle [, int $length] | string','fgetss(':'resource $handle [, int $length [, string $allowable_tags]] | string','file_exists(':'string $filename | bool','file_get_contents(':'string $filename [, bool $use_include_path = false [, resource $context [, int $offset = -1 [, int $maxlen]]]] | string','file_put_contents(':'string $filename, mixed $data [, int $flags = 0 [, resource $context]] | int','file(':'string $filename [, int $flags = 0 [, resource $context]] | array','fileatime(':'string $filename | int','filectime(':'string $filename | int','filegroup(':'string $filename | int','fileinode(':'string $filename | int','filemtime(':'string $filename | int','fileowner(':'string $filename | int','fileperms(':'string $filename | int','filesize(':'string $filename | int','filetype(':'string $filename | string','flock(':'resource $handle, int $operation [, int &$wouldblock] | bool','fnmatch(':'string $pattern, string $string [, int $flags = 0] | bool','fopen(':'string $filename, string $mode [, bool $use_include_path = false [, resource $context]] | resource','fpassthru(':'resource $handle | int','fputcsv(':'resource $handle, array $fields [, string $delimiter = '','' [, string $enclosure = ''"'']] | int','fputs(':'fputs — Alias of fwrite()','fread(':'resource $handle, int $length | string','fscanf(':'resource $handle, string $format [, mixed &$...] | mixed','fseek(':'resource $handle, int $offset [, int $whence = SEEK_SET] | int','fstat(':'resource $handle | array','ftell(':'resource $handle | int','ftruncate(':'resource $handle, int $size | bool','fwrite(':'resource $handle, string $string [, int $length] | int','glob(':'string $pattern [, int $flags = 0] | array','is_dir(':'string $filename | bool','is_executable(':'string $filename | bool','is_file(':'string $filename | bool','is_link(':'string $filename | bool','is_readable(':'string $filename | bool','is_uploaded_file(':'string $filename | bool','is_writable(':'string $filename | bool','is_writeable(':'is_writeable — Alias of is_writable()','lchgrp(':'string $filename, mixed $group | bool','lchown(':'string $filename, mixed $user | bool','link(':'string $target, string $link | bool','linkinfo(':'string $path | int','lstat(':'string $filename | array','mkdir(':'string $pathname [, int $mode = 0777 [, bool $recursive = false [, resource $context]]] | bool','move_uploaded_file(':'string $filename, string $destination | bool','parse_ini_file(':'string $filename [, bool $process_sections = false [, int $scanner_mode = INI_SCANNER_NORMAL]] | array','parse_ini_string(':'string $ini [, bool $process_sections = false [, int $scanner_mode = INI_SCANNER_NORMAL]] | array','pathinfo(':'string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME] | mixed','pclose(':'resource $handle | int','popen(':'string $command, string $mode | resource','readfile(':'string $filename [, bool $use_include_path = false [, resource $context]] | int','readlink(':'string $path | string','realpath_cache_get(':'void | array','realpath_cache_size(':'void | int','realpath(':'string $path | string','rename(':'string $oldname, string $newname [, resource $context] | bool','rewind(':'resource $handle | bool','rmdir(':'string $dirname [, resource $context] | bool','set_file_buffer(':'set_file_buffer — Alias of stream_set_write_buffer()','stat(':'string $filename | array','symlink(':'string $target, string $link | bool','tempnam(':'string $dir, string $prefix | string','tmpfile(':'void | resource','touch(':'string $filename [, int $time = time() [, int $atime]] | bool','umask(':'[ int $mask] | int','unlink(':'string $filename [, resource $context] | bool',}
let php_builtin['functions']['variable_handling']={'boolval(':'mixed $var | boolean','debug_zval_dump(':'mixed $variable [, mixed $...] | void','doubleval(':'doubleval — Alias of floatval()','empty(':'mixed $var | bool','floatval(':'mixed $var | float','get_defined_vars(':'void | array','get_resource_type(':'resource $handle | string','gettype(':'mixed $var | string','import_request_variables(':'string $types [, string $prefix] | bool','intval(':'mixed $var [, int $base = 10] | int','is_array(':'mixed $var | bool','is_bool(':'mixed $var | bool','is_callable(':'callable $name [, bool $syntax_only = false [, string &$callable_name]] | bool','is_double(':'is_double — Alias of is_float()','is_float(':'mixed $var | bool','is_int(':'mixed $var | bool','is_integer(':'is_integer — Alias of is_int()','is_long(':'is_long — Alias of is_int()','is_null(':'mixed $var | bool','is_numeric(':'mixed $var | bool','is_object(':'mixed $var | bool','is_real(':'is_real — Alias of is_float()','is_resource(':'mixed $var | bool','is_scalar(':'mixed $var | bool','is_string(':'mixed $var | bool','isset(':'mixed $var [, mixed $...] | bool','print_r(':'mixed $expression [, bool $return = false] | mixed','serialize(':'mixed $value | string','settype(':'mixed &$var, string $type | bool','strval(':'mixed $var | string','unserialize(':'string $str | mixed','unset(':'mixed $var [, mixed $...] | void','var_dump(':'mixed $expression [, mixed $...] | void','var_export(':'mixed $expression [, bool $return = false] | mixed',}
let php_builtin['functions']['calendar']={'cal_days_in_month(':'int $calendar, int $month, int $year | int','cal_from_jd(':'int $jd, int $calendar | array','cal_info(':'[ int $calendar = -1] | array','cal_to_jd(':'int $calendar, int $month, int $day, int $year | int','easter_date(':'[ int $year] | int','easter_days(':'[ int $year [, int $method = CAL_EASTER_DEFAULT]] | int','frenchtojd(':'int $month, int $day, int $year | int','gregoriantojd(':'int $month, int $day, int $year | int','jddayofweek(':'int $julianday [, int $mode = CAL_DOW_DAYNO] | mixed','jdmonthname(':'int $julianday, int $mode | string','jdtofrench(':'int $juliandaycount | string','jdtogregorian(':'int $julianday | string','jdtojewish(':'int $juliandaycount [, bool $hebrew = false [, int $fl = 0]] | string','jdtojulian(':'int $julianday | string','jdtounix(':'int $jday | int','jewishtojd(':'int $month, int $day, int $year | int','juliantojd(':'int $month, int $day, int $year | int','unixtojd(':'[ int $timestamp = time()] | int',}
let php_builtin['functions']['function_handling']={'call_user_func_array(':'callable $callback, array $param_arr | mixed','call_user_func(':'callable $callback [, mixed $parameter [, mixed $...]] | mixed','create_function(':'string $args, string $code | string','forward_static_call_array(':'callable $function, array $parameters | mixed','forward_static_call(':'callable $function [, mixed $parameter [, mixed $...]] | mixed','func_get_arg(':'int $arg_num | mixed','func_get_args(':'void | array','func_num_args(':'void | int','function_exists(':'string $function_name | bool','get_defined_functions(':'void | array','register_shutdown_function(':'callable $callback [, mixed $parameter [, mixed $...]] | void','register_tick_function(':'callable $function [, mixed $arg [, mixed $...]] | bool','unregister_tick_function(':'string $function_name | void',}
let php_builtin['functions']['directories']={'chdir(':'string $directory | bool','chroot(':'string $directory | bool','closedir(':'[ resource $dir_handle] | void','dir(':'string $directory [, resource $context] | Directory','getcwd(':'void | string','opendir(':'string $path [, resource $context] | resource','readdir(':'[ resource $dir_handle] | string','rewinddir(':'[ resource $dir_handle] | void','scandir(':'string $directory [, int $sorting_order = SCANDIR_SORT_ASCENDING [, resource $context]] | array',}
let php_builtin['functions']['date_time']={'checkdate(':'int $month, int $day, int $year | bool','date_default_timezone_get(':'void | string','date_default_timezone_set(':'string $timezone_identifier | bool','date_parse_from_format(':'string $format, string $date | array','date_parse(':'string $date | array','date_sun_info(':'int $time, float $latitude, float $longitude | array','date_sunrise(':'int $timestamp [, int $format = SUNFUNCS_RET_STRING [, float $latitude = ini_get("date.default_latitude") [, float $longitude = ini_get("date.default_longitude") [, float $zenith = ini_get("date.sunrise_zenith") [, float $gmt_offset = 0]]]]] | mixed','date_sunset(':'int $timestamp [, int $format = SUNFUNCS_RET_STRING [, float $latitude = ini_get("date.default_latitude") [, float $longitude = ini_get("date.default_longitude") [, float $zenith = ini_get("date.sunset_zenith") [, float $gmt_offset = 0]]]]] | mixed','date(':'string $format [, int $timestamp = time()] | string','getdate(':'[ int $timestamp = time()] | array','gettimeofday(':'[ bool $return_float = false] | mixed','gmdate(':'string $format [, int $timestamp = time()] | string','gmmktime(':'[ int $hour = gmdate("H") [, int $minute = gmdate("i") [, int $second = gmdate("s") [, int $month = gmdate("n") [, int $day = gmdate("j") [, int $year = gmdate("Y") [, int $is_dst = -1]]]]]]] | int','gmstrftime(':'string $format [, int $timestamp = time()] | string','idate(':'string $format [, int $timestamp = time()] | int','localtime(':'[ int $timestamp = time() [, bool $is_associative = false]] | array','microtime(':'[ bool $get_as_float = false] | mixed','mktime(':'[ int $hour = date("H") [, int $minute = date("i") [, int $second = date("s") [, int $month = date("n") [, int $day = date("j") [, int $year = date("Y") [, int $is_dst = -1]]]]]]] | int','strftime(':'string $format [, int $timestamp = time()] | string','strptime(':'string $date, string $format | array','strtotime(':'string $time [, int $now = time()] | int','time(':'void | int','timezone_name_from_abbr(':'string $abbr [, int $gmtOffset = -1 [, int $isdst = -1]] | string','timezone_version_get(':'void | string',}
let php_builtin['functions']['network']={'checkdnsrr(':'string $host [, string $type = "MX"] | bool','closelog(':'void | bool','define_syslog_variables(':'void | void','dns_get_record(':'string $hostname [, int $type = DNS_ANY [, array &$authns [, array &$addtl [, bool &$raw = false]]]] | array','fsockopen(':'string $hostname [, int $port = -1 [, int &$errno [, string &$errstr [, float $timeout = ini_get("default_socket_timeout")]]]] | resource','gethostbyaddr(':'string $ip_address | string','gethostbyname(':'string $hostname | string','gethostbynamel(':'string $hostname | array','gethostname(':'void | string','getmxrr(':'string $hostname, array &$mxhosts [, array &$weight] | bool','getprotobyname(':'string $name | int','getprotobynumber(':'int $number | string','getservbyname(':'string $service, string $protocol | int','getservbyport(':'int $port, string $protocol | string','header_register_callback(':'callable $callback | bool','header_remove(':'[ string $name] | void','header(':'string $string [, bool $replace = true [, int $http_response_code]] | void','headers_list(':'void | array','headers_sent(':'[ string &$file [, int &$line]] | bool','http_response_code(':'[ int $response_code] | int','inet_ntop(':'string $in_addr | string','inet_pton(':'string $address | string','ip2long(':'string $ip_address | int','long2ip(':'string $proper_address | string','openlog(':'string $ident, int $option, int $facility | bool','pfsockopen(':'string $hostname [, int $port = -1 [, int &$errno [, string &$errstr [, float $timeout = ini_get("default_socket_timeout")]]]] | resource','setcookie(':'string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false]]]]]] | bool','setrawcookie(':'string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false]]]]]] | bool','socket_get_status(':'socket_get_status — Alias of stream_get_meta_data()','socket_set_blocking(':'socket_set_blocking — Alias of stream_set_blocking()','socket_set_timeout(':'socket_set_timeout — Alias of stream_set_timeout()','syslog(':'int $priority, string $message | bool',}
let php_builtin['functions']['spl']={'class_implements(':'mixed $class [, bool $autoload = true] | array','class_parents(':'mixed $class [, bool $autoload = true] | array','class_uses(':'mixed $class [, bool $autoload = true] | array','iterator_apply(':'Traversable $iterator, callable $function [, array $args] | int','iterator_count(':'Traversable $iterator | int','iterator_to_array(':'Traversable $iterator [, bool $use_keys = true] | array','spl_autoload_call(':'string $class_name | void','spl_autoload_extensions(':'[ string $file_extensions] | string','spl_autoload_functions(':'void | array','spl_autoload_register(':'[ callable $autoload_function [, bool $throw = true [, bool $prepend = false]]] | bool','spl_autoload_unregister(':'mixed $autoload_function | bool','spl_autoload(':'string $class_name [, string $file_extensions = spl_autoload_extensions()] | void','spl_classes(':'void | array','spl_object_hash(':'object $obj | string',}
let php_builtin['functions']['misc']={'connection_aborted(':'void | int','connection_status(':'void | int','connection_timeout(':'void | int','constant(':'string $name | mixed','define(':'string $name, mixed $value [, bool $case_insensitive = false] | bool','defined(':'string $name | bool','eval(':'string $code | mixed','exit(':'[ string $status] | void','get_browser(':'[ string $user_agent [, bool $return_array = false]] | mixed','__halt_compiler(':'void | void','highlight_file(':'string $filename [, bool $return = false] | mixed','highlight_string(':'string $str [, bool $return = false] | mixed','ignore_user_abort(':'[ string $value] | int','pack(':'string $format [, mixed $args [, mixed $...]] | string','php_check_syntax(':'string $filename [, string &$error_message] | bool','php_strip_whitespace(':'string $filename | string','show_source(':'show_source — Alias of highlight_file()','sleep(':'int $seconds | int','sys_getloadavg(':'void | array','time_nanosleep(':'int $seconds, int $nanoseconds | mixed','time_sleep_until(':'float $timestamp | bool','uniqid(':'[ string $prefix = "" [, bool $more_entropy = false]] | string','unpack(':'string $format, string $data | array','usleep(':'int $micro_seconds | void',}
let php_builtin['functions']['curl']={'curl_close(':'resource $ch | void','curl_copy_handle(':'resource $ch | resource','curl_errno(':'resource $ch | int','curl_error(':'resource $ch | string','curl_escape(':'resource $ch, string $str | string','curl_exec(':'resource $ch | mixed','curl_getinfo(':'resource $ch [, int $opt = 0] | mixed','curl_init(':'[ string $url = NULL] | resource','curl_multi_add_handle(':'resource $mh, resource $ch | int','curl_multi_close(':'resource $mh | void','curl_multi_exec(':'resource $mh, int &$still_running | int','curl_multi_getcontent(':'resource $ch | string','curl_multi_info_read(':'resource $mh [, int &$msgs_in_queue = NULL] | array','curl_multi_init(':'void | resource','curl_multi_remove_handle(':'resource $mh, resource $ch | int','curl_multi_select(':'resource $mh [, float $timeout = 1.0] | int','curl_multi_setopt(':'resource $mh, int $option, mixed $value | bool','curl_multi_strerror(':'int $errornum | string','curl_pause(':'resource $ch, int $bitmask | int','curl_reset(':'resource $ch | void','curl_setopt_array(':'resource $ch, array $options | bool','curl_setopt(':'resource $ch, int $option, mixed $value | bool','curl_share_close(':'resource $sh | void','curl_share_init(':'void | resource','curl_share_setopt(':'resource $sh, int $option, string $value | bool','curl_strerror(':'int $errornum | string','curl_unescape(':'resource $ch, string $str | string','curl_version(':'[ int $age = CURLVERSION_NOW] | array',}
let php_builtin['functions']['error_handling']={'debug_backtrace(':'[ int $options = DEBUG_BACKTRACE_PROVIDE_OBJECT [, int $limit = 0]] | array','debug_print_backtrace(':'[ int $options = 0 [, int $limit = 0]] | void','error_get_last(':'void | array','error_log(':'string $message [, int $message_type = 0 [, string $destination [, string $extra_headers]]] | bool','error_reporting(':'[ int $level] | int','restore_error_handler(':'void | bool','restore_exception_handler(':'void | bool','set_error_handler(':'callable $error_handler [, int $error_types = E_ALL | E_STRICT] | mixed','set_exception_handler(':'callable $exception_handler | callable','trigger_error(':'string $error_msg [, int $error_type = E_USER_NOTICE] | bool',}
let php_builtin['functions']['dom']={'dom_import_simplexml(':'SimpleXMLElement $node | DOMElement',}
let php_builtin['functions']['program_execution']={'escapeshellarg(':'string $arg | string','escapeshellcmd(':'string $command | string','exec(':'string $command [, array &$output [, int &$return_var]] | string','passthru(':'string $command [, int &$return_var] | void','proc_close(':'resource $process | int','proc_get_status(':'resource $process | array','proc_nice(':'int $increment | bool','proc_open(':'string $cmd, array $descriptorspec, array &$pipes [, string $cwd [, array $env [, array $other_options]]] | resource','proc_terminate(':'resource $process [, int $signal = 15] | bool','shell_exec(':'string $cmd | string','system(':'string $command [, int &$return_var] | string',}
let php_builtin['functions']['mail']={'ezmlm_hash(':'string $addr | int','mail(':'string $to, string $subject, string $message [, string $additional_headers [, string $additional_parameters]] | bool',}
let php_builtin['functions']['fastcgi_process_manager']={'fastcgi_finish_request(':'void | boolean',}
let php_builtin['functions']['filter']={'filter_has_var(':'int $type, string $variable_name | bool','filter_id(':'string $filtername | int','filter_input_array(':'int $type [, mixed $definition [, bool $add_empty = true]] | mixed','filter_input(':'int $type, string $variable_name [, int $filter = FILTER_DEFAULT [, mixed $options]] | mixed','filter_list(':'void | array','filter_var_array(':'array $data [, mixed $definition [, bool $add_empty = true]] | mixed','filter_var(':'mixed $variable [, int $filter = FILTER_DEFAULT [, mixed $options]] | mixed',}
let php_builtin['functions']['fileinfo']={'finfo_buffer(':'resource $finfo [, string $string = NULL [, int $options = FILEINFO_NONE [, resource $context = NULL]]] | string','finfo_close(':'resource $finfo | bool','finfo_file(':'resource $finfo [, string $file_name = NULL [, int $options = FILEINFO_NONE [, resource $context = NULL]]] | string','finfo_open(':'[ int $options = FILEINFO_NONE [, string $magic_file = NULL]] | resource','finfo_set_flags(':'resource $finfo, int $options | bool','mime_content_type(':'string $filename | string',}
let php_builtin['functions']['output_control']={'flush(':'void | void','ob_clean(':'void | void','ob_end_clean(':'void | bool','ob_end_flush(':'void | bool','ob_flush(':'void | void','ob_get_clean(':'void | string','ob_get_contents(':'void | string','ob_get_flush(':'void | string','ob_get_length(':'void | int','ob_get_level(':'void | int','ob_get_status(':'[ bool $full_status = FALSE] | array','ob_gzhandler(':'string $buffer, int $mode | string','ob_implicit_flush(':'[ int $flag = true] | void','ob_list_handlers(':'void | array','ob_start(':'[ callable $output_callback = NULL [, int $chunk_size = 0 [, int $flags = PHP_OUTPUT_HANDLER_STDFLAGS]]] | bool','output_add_rewrite_var(':'string $name, string $value | bool','output_reset_rewrite_vars(':'void | bool',}
let php_builtin['functions']['gd']={'gd_info(':'void | array','getimagesize(':'string $filename [, array &$imageinfo] | array','getimagesizefromstring(':'string $imagedata [, array &$imageinfo] | array','image_type_to_extension(':'int $imagetype [, bool $include_dot = TRUE] | string','image_type_to_mime_type(':'int $imagetype | string','image2wbmp(':'resource $image [, string $filename [, int $threshold]] | bool','imageaffine(':'resource $image, array $affine [, array $clip] | resource','imageaffinematrixconcat(':'array $m1, array $m2 | array','imageaffinematrixget(':'int $type [, mixed $options] | array','imagealphablending(':'resource $image, bool $blendmode | bool','imageantialias(':'resource $image, bool $enabled | bool','imagearc(':'resource $image, int $cx, int $cy, int $width, int $height, int $start, int $end, int $color | bool','imagechar(':'resource $image, int $font, int $x, int $y, string $c, int $color | bool','imagecharup(':'resource $image, int $font, int $x, int $y, string $c, int $color | bool','imagecolorallocate(':'resource $image, int $red, int $green, int $blue | int','imagecolorallocatealpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolorat(':'resource $image, int $x, int $y | int','imagecolorclosest(':'resource $image, int $red, int $green, int $blue | int','imagecolorclosestalpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolorclosesthwb(':'resource $image, int $red, int $green, int $blue | int','imagecolordeallocate(':'resource $image, int $color | bool','imagecolorexact(':'resource $image, int $red, int $green, int $blue | int','imagecolorexactalpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolormatch(':'resource $image1, resource $image2 | bool','imagecolorresolve(':'resource $image, int $red, int $green, int $blue | int','imagecolorresolvealpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolorset(':'resource $image, int $index, int $red, int $green, int $blue [, int $alpha = 0] | void','imagecolorsforindex(':'resource $image, int $index | array','imagecolorstotal(':'resource $image | int','imagecolortransparent(':'resource $image [, int $color] | int','imageconvolution(':'resource $image, array $matrix, float $div, float $offset | bool','imagecopy(':'resource $dst_im, resource $src_im, int $dst_x, int $dst_y, int $src_x, int $src_y, int $src_w, int $src_h | bool','imagecopymerge(':'resource $dst_im, resource $src_im, int $dst_x, int $dst_y, int $src_x, int $src_y, int $src_w, int $src_h, int $pct | bool','imagecopymergegray(':'resource $dst_im, resource $src_im, int $dst_x, int $dst_y, int $src_x, int $src_y, int $src_w, int $src_h, int $pct | bool','imagecopyresampled(':'resource $dst_image, resource $src_image, int $dst_x, int $dst_y, int $src_x, int $src_y, int $dst_w, int $dst_h, int $src_w, int $src_h | bool','imagecopyresized(':'resource $dst_image, resource $src_image, int $dst_x, int $dst_y, int $src_x, int $src_y, int $dst_w, int $dst_h, int $src_w, int $src_h | bool','imagecreate(':'int $width, int $height | resource','imagecreatefromgd(':'string $filename | resource','imagecreatefromgd2(':'string $filename | resource','imagecreatefromgd2part(':'string $filename, int $srcX, int $srcY, int $width, int $height | resource','imagecreatefromgif(':'string $filename | resource','imagecreatefromjpeg(':'string $filename | resource','imagecreatefrompng(':'string $filename | resource','imagecreatefromstring(':'string $image | resource','imagecreatefromwbmp(':'string $filename | resource','imagecreatefromwebp(':'string $filename | resource','imagecreatefromxbm(':'string $filename | resource','imagecreatefromxpm(':'string $filename | resource','imagecreatetruecolor(':'int $width, int $height | resource','imagecrop(':'resource $image, array $rect | resource','imagecropauto(':'resource $image [, int $mode = -1 [, float $threshold = .5 [, int $color = -1]]] | resource','imagedashedline(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imagedestroy(':'resource $image | bool','imageellipse(':'resource $image, int $cx, int $cy, int $width, int $height, int $color | bool','imagefill(':'resource $image, int $x, int $y, int $color | bool','imagefilledarc(':'resource $image, int $cx, int $cy, int $width, int $height, int $start, int $end, int $color, int $style | bool','imagefilledellipse(':'resource $image, int $cx, int $cy, int $width, int $height, int $color | bool','imagefilledpolygon(':'resource $image, array $points, int $num_points, int $color | bool','imagefilledrectangle(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imagefilltoborder(':'resource $image, int $x, int $y, int $border, int $color | bool','imagefilter(':'resource $image, int $filtertype [, int $arg1 [, int $arg2 [, int $arg3 [, int $arg4]]]] | bool','imageflip(':'resource $image, int $mode | bool','imagefontheight(':'int $font | int','imagefontwidth(':'int $font | int','imageftbbox(':'float $size, float $angle, string $fontfile, string $text [, array $extrainfo] | array','imagefttext(':'resource $image, float $size, float $angle, int $x, int $y, int $color, string $fontfile, string $text [, array $extrainfo] | array','imagegammacorrect(':'resource $image, float $inputgamma, float $outputgamma | bool','imagegd(':'resource $image [, string $filename] | bool','imagegd2(':'resource $image [, string $filename [, int $chunk_size [, int $type = IMG_GD2_RAW]]] | bool','imagegif(':'resource $image [, string $filename] | bool','imagegrabscreen(':'void | resource','imagegrabwindow(':'int $window_handle [, int $client_area = 0] | resource','imageinterlace(':'resource $image [, int $interlace = 0] | int','imageistruecolor(':'resource $image | bool','imagejpeg(':'resource $image [, string $filename [, int $quality]] | bool','imagelayereffect(':'resource $image, int $effect | bool','imageline(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imageloadfont(':'string $file | int','imagepalettecopy(':'resource $destination, resource $source | void','imagepalettetotruecolor(':'resource $src | bool','imagepng(':'resource $image [, string $filename [, int $quality [, int $filters]]] | bool','imagepolygon(':'resource $image, array $points, int $num_points, int $color | bool','imagepsbbox(':'string $text, resource $font, int $size | array','imagepsencodefont(':'resource $font_index, string $encodingfile | bool','imagepsextendfont(':'resource $font_index, float $extend | bool','imagepsfreefont(':'resource $font_index | bool','imagepsloadfont(':'string $filename | resource','imagepsslantfont(':'resource $font_index, float $slant | bool','imagepstext(':'resource $image, string $text, resource $font_index, int $size, int $foreground, int $background, int $x, int $y [, int $space = 0 [, int $tightness = 0 [, float $angle = 0.0 [, int $antialias_steps = 4]]]] | array','imagerectangle(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imagerotate(':'resource $image, float $angle, int $bgd_color [, int $ignore_transparent = 0] | resource','imagesavealpha(':'resource $image, bool $saveflag | bool','imagescale(':'resource $image, int $new_width [, int $new_height = -1 [, int $mode = IMG_BILINEAR_FIXED]] | resource','imagesetbrush(':'resource $image, resource $brush | bool','imagesetinterpolation(':'resource $image [, int $method = IMG_BILINEAR_FIXED] | bool','imagesetpixel(':'resource $image, int $x, int $y, int $color | bool','imagesetstyle(':'resource $image, array $style | bool','imagesetthickness(':'resource $image, int $thickness | bool','imagesettile(':'resource $image, resource $tile | bool','imagestring(':'resource $image, int $font, int $x, int $y, string $string, int $color | bool','imagestringup(':'resource $image, int $font, int $x, int $y, string $string, int $color | bool','imagesx(':'resource $image | int','imagesy(':'resource $image | int','imagetruecolortopalette(':'resource $image, bool $dither, int $ncolors | bool','imagettfbbox(':'float $size, float $angle, string $fontfile, string $text | array','imagettftext(':'resource $image, float $size, float $angle, int $x, int $y, int $color, string $fontfile, string $text | array','imagetypes(':'void | int','imagewbmp(':'resource $image [, string $filename [, int $foreground]] | bool','imagewebp(':'resource $image, string $filename | bool','imagexbm(':'resource $image, string $filename [, int $foreground] | bool','iptcembed(':'string $iptcdata, string $jpeg_file_name [, int $spool] | mixed','iptcparse(':'string $iptcblock | array','jpeg2wbmp(':'string $jpegname, string $wbmpname, int $dest_height, int $dest_width, int $threshold | bool','png2wbmp(':'string $pngname, string $wbmpname, int $dest_height, int $dest_width, int $threshold | bool',}
let php_builtin['functions']['iconv']={'iconv_get_encoding(':'[ string $type = "all"] | mixed','iconv_mime_decode_headers(':'string $encoded_headers [, int $mode = 0 [, string $charset = ini_get("iconv.internal_encoding")]] | array','iconv_mime_decode(':'string $encoded_header [, int $mode = 0 [, string $charset = ini_get("iconv.internal_encoding")]] | string','iconv_mime_encode(':'string $field_name, string $field_value [, array $preferences = NULL] | string','iconv_set_encoding(':'string $type, string $charset | bool','iconv_strlen(':'string $str [, string $charset = ini_get("iconv.internal_encoding")] | int','iconv_strpos(':'string $haystack, string $needle [, int $offset = 0 [, string $charset = ini_get("iconv.internal_encoding")]] | int','iconv_strrpos(':'string $haystack, string $needle [, string $charset = ini_get("iconv.internal_encoding")] | int','iconv_substr(':'string $str, int $offset [, int $length = iconv_strlen($str, $charset) [, string $charset = ini_get("iconv.internal_encoding")]] | string','iconv(':'string $in_charset, string $out_charset, string $str | string','ob_iconv_handler(':'string $contents, int $status | string',}
let php_builtin['functions']['json']={'json_decode(':'string $json [, bool $assoc = false [, int $depth = 512 [, int $options = 0]]] | mixed','json_encode(':'mixed $value [, int $options = 0 [, int $depth = 512]] | string','json_last_error_msg(':'void | string','json_last_error(':'void | int',}
let php_builtin['functions']['libxml']={'libxml_clear_errors(':'void | void','libxml_disable_entity_loader(':'[ bool $disable = true] | bool','libxml_get_errors(':'void | array','libxml_get_last_error(':'void | LibXMLError','libxml_set_external_entity_loader(':'callable $resolver_function | void','libxml_set_streams_context(':'resource $streams_context | void','libxml_use_internal_errors(':'[ bool $use_errors = false] | bool',}
let php_builtin['functions']['multibyte_string']={'mb_check_encoding(':'[ string $var = NULL [, string $encoding = mb_internal_encoding()]] | bool','mb_convert_case(':'string $str, int $mode [, string $encoding = mb_internal_encoding()] | string','mb_convert_encoding(':'string $str, string $to_encoding [, mixed $from_encoding = mb_internal_encoding()] | string','mb_convert_kana(':'string $str [, string $option = "KV" [, string $encoding = mb_internal_encoding()]] | string','mb_convert_variables(':'string $to_encoding, mixed $from_encoding, mixed &$vars [, mixed &$...] | string','mb_decode_mimeheader(':'string $str | string','mb_decode_numericentity(':'string $str, array $convmap [, string $encoding = mb_internal_encoding()] | string','mb_detect_encoding(':'string $str [, mixed $encoding_list = mb_detect_order() [, bool $strict = false]] | string','mb_detect_order(':'[ mixed $encoding_list = mb_detect_order()] | mixed','mb_encode_mimeheader(':'string $str [, string $charset = mb_internal_encoding() [, string $transfer_encoding = "B" [, string $linefeed = "\r\n" [, int $indent = 0]]]] | string','mb_encode_numericentity(':'string $str, array $convmap [, string $encoding = mb_internal_encoding() [, bool $is_hex = FALSE]] | string','mb_encoding_aliases(':'string $encoding | array','mb_ereg_match(':'string $pattern, string $string [, string $option = "msr"] | bool','mb_ereg_replace_callback(':'string $pattern, callable $callback, string $string [, string $option = "msr"] | string','mb_ereg_replace(':'string $pattern, string $replacement, string $string [, string $option = "msr"] | string','mb_ereg_search_getpos(':'void | int','mb_ereg_search_getregs(':'void | array','mb_ereg_search_init(':'string $string [, string $pattern [, string $option = "msr"]] | bool','mb_ereg_search_pos(':'[ string $pattern [, string $option = "ms"]] | array','mb_ereg_search_regs(':'[ string $pattern [, string $option = "ms"]] | array','mb_ereg_search_setpos(':'int $position | bool','mb_ereg_search(':'[ string $pattern [, string $option = "ms"]] | bool','mb_ereg(':'string $pattern, string $string [, array $regs] | int','mb_eregi_replace(':'string $pattern, string $replace, string $string [, string $option = "msri"] | string','mb_eregi(':'string $pattern, string $string [, array $regs] | int','mb_get_info(':'[ string $type = "all"] | mixed','mb_http_input(':'[ string $type = ""] | mixed','mb_http_output(':'[ string $encoding = mb_http_output()] | mixed','mb_internal_encoding(':'[ string $encoding = mb_internal_encoding()] | mixed','mb_language(':'[ string $language = mb_language()] | mixed','mb_list_encodings(':'void | array','mb_output_handler(':'string $contents, int $status | string','mb_parse_str(':'string $encoded_string [, array &$result] | bool','mb_preferred_mime_name(':'string $encoding | string','mb_regex_encoding(':'[ string $encoding = mb_regex_encoding()] | mixed','mb_regex_set_options(':'[ string $options = mb_regex_set_options()] | string','mb_send_mail(':'string $to, string $subject, string $message [, string $additional_headers = NULL [, string $additional_parameter = NULL]] | bool','mb_split(':'string $pattern, string $string [, int $limit = -1] | array','mb_strcut(':'string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] | string','mb_strimwidth(':'string $str, int $start, int $width [, string $trimmarker = "" [, string $encoding = mb_internal_encoding()]] | string','mb_stripos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_stristr(':'string $haystack, string $needle [, bool $before_needle = false [, string $encoding = mb_internal_encoding()]] | string','mb_strlen(':'string $str [, string $encoding = mb_internal_encoding()] | mixed','mb_strpos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_strrchr(':'string $haystack, string $needle [, bool $part = false [, string $encoding = mb_internal_encoding()]] | string','mb_strrichr(':'string $haystack, string $needle [, bool $part = false [, string $encoding = mb_internal_encoding()]] | string','mb_strripos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_strrpos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_strstr(':'string $haystack, string $needle [, bool $before_needle = false [, string $encoding = mb_internal_encoding()]] | string','mb_strtolower(':'string $str [, string $encoding = mb_internal_encoding()] | string','mb_strtoupper(':'string $str [, string $encoding = mb_internal_encoding()] | string','mb_strwidth(':'string $str [, string $encoding = mb_internal_encoding()] | int','mb_substitute_character(':'[ mixed $substrchar = mb_substitute_character()] | mixed','mb_substr_count(':'string $haystack, string $needle [, string $encoding = mb_internal_encoding()] | int','mb_substr(':'string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] | string',}
let php_builtin['functions']['mssql']={'mssql_bind(':'resource $stmt, string $param_name, mixed &$var, int $type [, bool $is_output = false [, bool $is_null = false [, int $maxlen = -1]]] | bool','mssql_close(':'[ resource $link_identifier] | bool','mssql_connect(':'[ string $servername [, string $username [, string $password [, bool $new_link = false]]]] | resource','mssql_data_seek(':'resource $result_identifier, int $row_number | bool','mssql_execute(':'resource $stmt [, bool $skip_results = false] | mixed','mssql_fetch_array(':'resource $result [, int $result_type = MSSQL_BOTH] | array','mssql_fetch_assoc(':'resource $result_id | array','mssql_fetch_batch(':'resource $result | int','mssql_fetch_field(':'resource $result [, int $field_offset = -1] | object','mssql_fetch_object(':'resource $result | object','mssql_fetch_row(':'resource $result | array','mssql_field_length(':'resource $result [, int $offset = -1] | int','mssql_field_name(':'resource $result [, int $offset = -1] | string','mssql_field_seek(':'resource $result, int $field_offset | bool','mssql_field_type(':'resource $result [, int $offset = -1] | string','mssql_free_result(':'resource $result | bool','mssql_free_statement(':'resource $stmt | bool','mssql_get_last_message(':'void | string','mssql_guid_string(':'string $binary [, bool $short_format = false] | string','mssql_init(':'string $sp_name [, resource $link_identifier] | resource','mssql_min_error_severity(':'int $severity | void','mssql_min_message_severity(':'int $severity | void','mssql_next_result(':'resource $result_id | bool','mssql_num_fields(':'resource $result | int','mssql_num_rows(':'resource $result | int','mssql_pconnect(':'[ string $servername [, string $username [, string $password [, bool $new_link = false]]]] | resource','mssql_query(':'string $query [, resource $link_identifier [, int $batch_size = 0]] | mixed','mssql_result(':'resource $result, int $row, mixed $field | string','mssql_rows_affected(':'resource $link_identifier | int','mssql_select_db(':'string $database_name [, resource $link_identifier] | bool',}
let php_builtin['functions']['mysql']={'mysql_affected_rows(':'[ resource $link_identifier = NULL] | int','mysql_client_encoding(':'[ resource $link_identifier = NULL] | string','mysql_close(':'[ resource $link_identifier = NULL] | bool','mysql_connect(':'[ string $server = ini_get("mysql.default_host") [, string $username = ini_get("mysql.default_user") [, string $password = ini_get("mysql.default_password") [, bool $new_link = false [, int $client_flags = 0]]]]] | resource','mysql_create_db(':'string $database_name [, resource $link_identifier = NULL] | bool','mysql_data_seek(':'resource $result, int $row_number | bool','mysql_db_name(':'resource $result, int $row [, mixed $field = NULL] | string','mysql_db_query(':'string $database, string $query [, resource $link_identifier = NULL] | resource','mysql_drop_db(':'string $database_name [, resource $link_identifier = NULL] | bool','mysql_errno(':'[ resource $link_identifier = NULL] | int','mysql_error(':'[ resource $link_identifier = NULL] | string','mysql_escape_string(':'string $unescaped_string | string','mysql_fetch_array(':'resource $result [, int $result_type = MYSQL_BOTH] | array','mysql_fetch_assoc(':'resource $result | array','mysql_fetch_field(':'resource $result [, int $field_offset = 0] | object','mysql_fetch_lengths(':'resource $result | array','mysql_fetch_object(':'resource $result [, string $class_name [, array $params]] | object','mysql_fetch_row(':'resource $result | array','mysql_field_flags(':'resource $result, int $field_offset | string','mysql_field_len(':'resource $result, int $field_offset | int','mysql_field_name(':'resource $result, int $field_offset | string','mysql_field_seek(':'resource $result, int $field_offset | bool','mysql_field_table(':'resource $result, int $field_offset | string','mysql_field_type(':'resource $result, int $field_offset | string','mysql_free_result(':'resource $result | bool','mysql_get_client_info(':'void | string','mysql_get_host_info(':'[ resource $link_identifier = NULL] | string','mysql_get_proto_info(':'[ resource $link_identifier = NULL] | int','mysql_get_server_info(':'[ resource $link_identifier = NULL] | string','mysql_info(':'[ resource $link_identifier = NULL] | string','mysql_insert_id(':'[ resource $link_identifier = NULL] | int','mysql_list_dbs(':'[ resource $link_identifier = NULL] | resource','mysql_list_fields(':'string $database_name, string $table_name [, resource $link_identifier = NULL] | resource','mysql_list_processes(':'[ resource $link_identifier = NULL] | resource','mysql_list_tables(':'string $database [, resource $link_identifier = NULL] | resource','mysql_num_fields(':'resource $result | int','mysql_num_rows(':'resource $result | int','mysql_pconnect(':'[ string $server = ini_get("mysql.default_host") [, string $username = ini_get("mysql.default_user") [, string $password = ini_get("mysql.default_password") [, int $client_flags = 0]]]] | resource','mysql_ping(':'[ resource $link_identifier = NULL] | bool','mysql_query(':'string $query [, resource $link_identifier = NULL] | mixed','mysql_real_escape_string(':'string $unescaped_string [, resource $link_identifier = NULL] | string','mysql_result(':'resource $result, int $row [, mixed $field = 0] | string','mysql_select_db(':'string $database_name [, resource $link_identifier = NULL] | bool','mysql_set_charset(':'string $charset [, resource $link_identifier = NULL] | bool','mysql_stat(':'[ resource $link_identifier = NULL] | string','mysql_tablename(':'resource $result, int $i | string','mysql_thread_id(':'[ resource $link_identifier = NULL] | int','mysql_unbuffered_query(':'string $query [, resource $link_identifier = NULL] | resource',}
let php_builtin['functions']['mysqli']={'mysqli_disable_reads_from_master(':'mysqli $link | bool','mysqli_disable_rpl_parse(':'mysqli $link | bool','mysqli_enable_reads_from_master(':'mysqli $link | bool','mysqli_enable_rpl_parse(':'mysqli $link | bool','mysqli_get_cache_stats(':'void | array','mysqli_master_query(':'mysqli $link, string $query | bool','mysqli_rpl_parse_enabled(':'mysqli $link | int','mysqli_rpl_probe(':'mysqli $link | bool','mysqli_slave_query(':'mysqli $link, string $query | bool',}
let php_builtin['functions']['password_hashing']={'password_get_info(':'string $hash | array','password_hash(':'string $password, integer $algo [, array $options] | string','password_needs_rehash(':'string $hash, string $algo [, string $options] | boolean','password_verify(':'string $password, string $hash | boolean',}
let php_builtin['functions']['postgresql']={'pg_affected_rows(':'resource $result | int','pg_cancel_query(':'resource $connection | bool','pg_client_encoding(':'[ resource $connection] | string','pg_close(':'[ resource $connection] | bool','pg_connect(':'string $connection_string [, int $connect_type] | resource','pg_connection_busy(':'resource $connection | bool','pg_connection_reset(':'resource $connection | bool','pg_connection_status(':'resource $connection | int','pg_convert(':'resource $connection, string $table_name, array $assoc_array [, int $options = 0] | array','pg_copy_from(':'resource $connection, string $table_name, array $rows [, string $delimiter [, string $null_as]] | bool','pg_copy_to(':'resource $connection, string $table_name [, string $delimiter [, string $null_as]] | array','pg_dbname(':'[ resource $connection] | string','pg_delete(':'resource $connection, string $table_name, array $assoc_array [, int $options = PGSQL_DML_EXEC] | mixed','pg_end_copy(':'[ resource $connection] | bool','pg_escape_bytea(':'[ resource $connection [, string $data]] | string','pg_escape_identifier(':'[ resource $connection [, string $data]] | string','pg_escape_literal(':'[ resource $connection [, string $data]] | string','pg_escape_string(':'[ resource $connection [, string $data]] | string','pg_execute(':'[ resource $connection [, string $stmtname [, array $params]]] | resource','pg_fetch_all_columns(':'resource $result [, int $column = 0] | array','pg_fetch_all(':'resource $result | array','pg_fetch_array(':'resource $result [, int $row [, int $result_type = PGSQL_BOTH]] | array','pg_fetch_assoc(':'resource $result [, int $row] | array','pg_fetch_object(':'resource $result [, int $row [, int $result_type = PGSQL_ASSOC]] | object','pg_fetch_result(':'resource $result, int $row, mixed $field | string','pg_fetch_row(':'resource $result [, int $row] | array','pg_field_is_null(':'resource $result, int $row, mixed $field | int','pg_field_name(':'resource $result, int $field_number | string','pg_field_num(':'resource $result, string $field_name | int','pg_field_prtlen(':'resource $result, int $row_number, mixed $field_name_or_number | int','pg_field_size(':'resource $result, int $field_number | int','pg_field_table(':'resource $result, int $field_number [, bool $oid_only = false] | mixed','pg_field_type_oid(':'resource $result, int $field_number | int','pg_field_type(':'resource $result, int $field_number | string','pg_free_result(':'resource $result | bool','pg_get_notify(':'resource $connection [, int $result_type] | array','pg_get_pid(':'resource $connection | int','pg_get_result(':'[ resource $connection] | resource','pg_host(':'[ resource $connection] | string','pg_insert(':'resource $connection, string $table_name, array $assoc_array [, int $options = PGSQL_DML_EXEC] | mixed','pg_last_error(':'[ resource $connection] | string','pg_last_notice(':'resource $connection | string','pg_last_oid(':'resource $result | string','pg_lo_close(':'resource $large_object | bool','pg_lo_create(':'[ resource $connection [, mixed $object_id]] | int','pg_lo_export(':'[ resource $connection [, int $oid [, string $pathname]]] | bool','pg_lo_import(':'[ resource $connection [, string $pathname [, mixed $object_id]]] | int','pg_lo_open(':'resource $connection, int $oid, string $mode | resource','pg_lo_read_all(':'resource $large_object | int','pg_lo_read(':'resource $large_object [, int $len = 8192] | string','pg_lo_seek(':'resource $large_object, int $offset [, int $whence = PGSQL_SEEK_CUR] | bool','pg_lo_tell(':'resource $large_object | int','pg_lo_truncate(':'resource $large_object, int $size | bool','pg_lo_unlink(':'resource $connection, int $oid | bool','pg_lo_write(':'resource $large_object, string $data [, int $len] | int','pg_meta_data(':'resource $connection, string $table_name [, bool $extended] | array','pg_num_fields(':'resource $result | int','pg_num_rows(':'resource $result | int','pg_options(':'[ resource $connection] | string','pg_parameter_status(':'[ resource $connection [, string $param_name]] | string','pg_pconnect(':'string $connection_string [, int $connect_type] | resource','pg_ping(':'[ resource $connection] | bool','pg_port(':'[ resource $connection] | int','pg_prepare(':'[ resource $connection [, string $stmtname [, string $query]]] | resource','pg_put_line(':'[ resource $connection [, string $data]] | bool','pg_query_params(':'[ resource $connection [, string $query [, array $params]]] | resource','pg_query(':'[ resource $connection [, string $query]] | resource','pg_result_error_field(':'resource $result, int $fieldcode | string','pg_result_error(':'resource $result | string','pg_result_seek(':'resource $result, int $offset | bool','pg_result_status(':'resource $result [, int $type = PGSQL_STATUS_LONG] | mixed','pg_select(':'resource $connection, string $table_name, array $assoc_array [, int $options = PGSQL_DML_EXEC] | mixed','pg_send_execute(':'resource $connection, string $stmtname, array $params | bool','pg_send_prepare(':'resource $connection, string $stmtname, string $query | bool','pg_send_query_params(':'resource $connection, string $query, array $params | bool','pg_send_query(':'resource $connection, string $query | bool','pg_set_client_encoding(':'[ resource $connection [, string $encoding]] | int','pg_set_error_verbosity(':'[ resource $connection [, int $verbosity]] | int','pg_trace(':'string $pathname [, string $mode = "w" [, resource $connection]] | bool','pg_transaction_status(':'resource $connection | int','pg_tty(':'[ resource $connection] | string','pg_unescape_bytea(':'string $data | string','pg_untrace(':'[ resource $connection] | bool','pg_update(':'resource $connection, string $table_name, array $data, array $condition [, int $options = PGSQL_DML_EXEC] | mixed','pg_version(':'[ resource $connection] | array',}
let php_builtin['functions']['pcre']={'preg_filter(':'mixed $pattern, mixed $replacement, mixed $subject [, int $limit = -1 [, int &$count]] | mixed','preg_grep(':'string $pattern, array $input [, int $flags = 0] | array','preg_last_error(':'void | int','preg_match_all(':'string $pattern, string $subject [, array &$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0]]] | int','preg_match(':'string $pattern, string $subject [, array &$matches [, int $flags = 0 [, int $offset = 0]]] | int','preg_quote(':'string $str [, string $delimiter = NULL] | string','preg_replace_callback(':'mixed $pattern, callable $callback, mixed $subject [, int $limit = -1 [, int &$count]] | mixed','preg_replace(':'mixed $pattern, mixed $replacement, mixed $subject [, int $limit = -1 [, int &$count]] | mixed','preg_split(':'string $pattern, string $subject [, int $limit = -1 [, int $flags = 0]] | array',}
let php_builtin['functions']['sessions']={'session_cache_expire(':'[ string $new_cache_expire] | int','session_cache_limiter(':'[ string $cache_limiter] | string','session_commit(':'session_commit — Alias of session_write_close()','session_decode(':'string $data | bool','session_destroy(':'void | bool','session_encode(':'void | string','session_get_cookie_params(':'void | array','session_id(':'[ string $id] | string','session_is_registered(':'string $name | bool','session_module_name(':'[ string $module] | string','session_name(':'[ string $name] | string','session_regenerate_id(':'[ bool $delete_old_session = false] | bool','session_register_shutdown(':'void | void','session_register(':'mixed $name [, mixed $...] | bool','session_save_path(':'[ string $path] | string','session_set_cookie_params(':'int $lifetime [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false]]]] | void','session_set_save_handler(':'callable $open, callable $close, callable $read, callable $write, callable $destroy, callable $gc | bool','session_start(':'void | bool','session_status(':'void | int','session_unregister(':'string $name | bool','session_unset(':'void | void','session_write_close(':'void | void',}
let php_builtin['functions']['streams']={'set_socket_blocking(':'set_socket_blocking — Alias of stream_set_blocking()','stream_bucket_append(':'resource $brigade, resource $bucket | void','stream_bucket_make_writeable(':'resource $brigade | object','stream_bucket_new(':'resource $stream, string $buffer | object','stream_bucket_prepend(':'resource $brigade, resource $bucket | void','stream_context_create(':'[ array $options [, array $params]] | resource','stream_context_get_default(':'[ array $options] | resource','stream_context_get_options(':'resource $stream_or_context | array','stream_context_get_params(':'resource $stream_or_context | array','stream_context_set_default(':'array $options | resource','stream_context_set_option(':'resource $stream_or_context, string $wrapper, string $option, mixed $value | bool','stream_context_set_params(':'resource $stream_or_context, array $params | bool','stream_copy_to_stream(':'resource $source, resource $dest [, int $maxlength = -1 [, int $offset = 0]] | int','stream_encoding(':'resource $stream [, string $encoding] | bool','stream_filter_append(':'resource $stream, string $filtername [, int $read_write [, mixed $params]] | resource','stream_filter_prepend(':'resource $stream, string $filtername [, int $read_write [, mixed $params]] | resource','stream_filter_register(':'string $filtername, string $classname | bool','stream_filter_remove(':'resource $stream_filter | bool','stream_get_contents(':'resource $handle [, int $maxlength = -1 [, int $offset = -1]] | string','stream_get_filters(':'void | array','stream_get_line(':'resource $handle, int $length [, string $ending] | string','stream_get_meta_data(':'resource $stream | array','stream_get_transports(':'void | array','stream_get_wrappers(':'void | array','stream_is_local(':'mixed $stream_or_url | bool','stream_notification_callback(':'int $notification_code, int $severity, string $message, int $message_code, int $bytes_transferred, int $bytes_max | void','stream_resolve_include_path(':'string $filename | string','stream_select(':'array &$read, array &$write, array &$except, int $tv_sec [, int $tv_usec = 0] | int','stream_set_blocking(':'resource $stream, int $mode | bool','stream_set_chunk_size(':'resource $fp, int $chunk_size | int','stream_set_read_buffer(':'resource $stream, int $buffer | int','stream_set_timeout(':'resource $stream, int $seconds [, int $microseconds = 0] | bool','stream_set_write_buffer(':'resource $stream, int $buffer | int','stream_socket_accept(':'resource $server_socket [, float $timeout = ini_get("default_socket_timeout") [, string &$peername]] | resource','stream_socket_client(':'string $remote_socket [, int &$errno [, string &$errstr [, float $timeout = ini_get("default_socket_timeout") [, int $flags = STREAM_CLIENT_CONNECT [, resource $context]]]]] | resource','stream_socket_enable_crypto(':'resource $stream, bool $enable [, int $crypto_type [, resource $session_stream]] | mixed','stream_socket_get_name(':'resource $handle, bool $want_peer | string','stream_socket_pair(':'int $domain, int $type, int $protocol | array','stream_socket_recvfrom(':'resource $socket, int $length [, int $flags = 0 [, string &$address]] | string','stream_socket_sendto(':'resource $socket, string $data [, int $flags = 0 [, string $address]] | int','stream_socket_server(':'string $local_socket [, int &$errno [, string &$errstr [, int $flags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN [, resource $context]]]] | resource','stream_socket_shutdown(':'resource $stream, int $how | bool','stream_supports_lock(':'resource $stream | bool','stream_wrapper_register(':'string $protocol, string $classname [, int $flags = 0] | bool','stream_wrapper_restore(':'string $protocol | bool','stream_wrapper_unregister(':'string $protocol | bool',}
let php_builtin['functions']['simplexml']={'simplexml_import_dom(':'DOMNode $node [, string $class_name = "SimpleXMLElement"] | SimpleXMLElement','simplexml_load_file(':'string $filename [, string $class_name = "SimpleXMLElement" [, int $options = 0 [, string $ns = "" [, bool $is_prefix = false]]]] | SimpleXMLElement','simplexml_load_string(':'string $data [, string $class_name = "SimpleXMLElement" [, int $options = 0 [, string $ns = "" [, bool $is_prefix = false]]]] | SimpleXMLElement',}
let php_builtin['functions']['xmlwriter']={'xmlwriter_end_attribute(':'resource $xmlwriter | bool','xmlwriter_end_cdata(':'resource $xmlwriter | bool','xmlwriter_end_comment(':'resource $xmlwriter | bool','xmlwriter_end_document(':'resource $xmlwriter | bool','xmlwriter_end_dtd_attlist(':'resource $xmlwriter | bool','xmlwriter_end_dtd_element(':'resource $xmlwriter | bool','xmlwriter_end_dtd_entity(':'resource $xmlwriter | bool','xmlwriter_end_dtd(':'resource $xmlwriter | bool','xmlwriter_end_element(':'resource $xmlwriter | bool','xmlwriter_end_pi(':'resource $xmlwriter | bool','xmlwriter_flush(':'resource $xmlwriter [, bool $empty = true] | mixed','xmlwriter_full_end_element(':'resource $xmlwriter | bool','xmlwriter_open_memory(':'void | resource','xmlwriter_open_uri(':'string $uri | resource','xmlwriter_output_memory(':'resource $xmlwriter [, bool $flush = true] | string','xmlwriter_set_indent_string(':'resource $xmlwriter, string $indentString | bool','xmlwriter_set_indent(':'resource $xmlwriter, bool $indent | bool','xmlwriter_start_attribute_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri | bool','xmlwriter_start_attribute(':'resource $xmlwriter, string $name | bool','xmlwriter_start_cdata(':'resource $xmlwriter | bool','xmlwriter_start_comment(':'resource $xmlwriter | bool','xmlwriter_start_document(':'resource $xmlwriter [, string $version = 1.0 [, string $encoding = NULL [, string $standalone]]] | bool','xmlwriter_start_dtd_attlist(':'resource $xmlwriter, string $name | bool','xmlwriter_start_dtd_element(':'resource $xmlwriter, string $qualifiedName | bool','xmlwriter_start_dtd_entity(':'resource $xmlwriter, string $name, bool $isparam | bool','xmlwriter_start_dtd(':'resource $xmlwriter, string $qualifiedName [, string $publicId [, string $systemId]] | bool','xmlwriter_start_element_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri | bool','xmlwriter_start_element(':'resource $xmlwriter, string $name | bool','xmlwriter_start_pi(':'resource $xmlwriter, string $target | bool','xmlwriter_text(':'resource $xmlwriter, string $content | bool','xmlwriter_write_attribute_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri, string $content | bool','xmlwriter_write_attribute(':'resource $xmlwriter, string $name, string $value | bool','xmlwriter_write_cdata(':'resource $xmlwriter, string $content | bool','xmlwriter_write_comment(':'resource $xmlwriter, string $content | bool','xmlwriter_write_dtd_attlist(':'resource $xmlwriter, string $name, string $content | bool','xmlwriter_write_dtd_element(':'resource $xmlwriter, string $name, string $content | bool','xmlwriter_write_dtd_entity(':'resource $xmlwriter, string $name, string $content, bool $pe, string $pubid, string $sysid, string $ndataid | bool','xmlwriter_write_dtd(':'resource $xmlwriter, string $name [, string $publicId [, string $systemId [, string $subset]]] | bool','xmlwriter_write_element_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri [, string $content] | bool','xmlwriter_write_element(':'resource $xmlwriter, string $name [, string $content] | bool','xmlwriter_write_pi(':'resource $xmlwriter, string $target, string $content | bool','xmlwriter_write_raw(':'resource $xmlwriter, string $content | bool',}
let php_builtin['functions']['zip']={'zip_close(':'resource $zip | void','zip_entry_close(':'resource $zip_entry | bool','zip_entry_compressedsize(':'resource $zip_entry | int','zip_entry_compressionmethod(':'resource $zip_entry | string','zip_entry_filesize(':'resource $zip_entry | int','zip_entry_name(':'resource $zip_entry | string','zip_entry_open(':'resource $zip, resource $zip_entry [, string $mode] | bool','zip_entry_read(':'resource $zip_entry [, int $length = 1024] | string','zip_open(':'string $filename | resource','zip_read(':'resource $zip | resource',}
let php_builtin['classes']['spl']={'appenditerator':{'name':'AppendIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'append':{'signature':'Iterator $iterator | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getArrayIterator':{'signature':'void | void','return_type':'void'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'getIteratorIndex':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'arrayiterator':{'name':'ArrayIterator','methods':{'append':{'signature':'mixed $value | void','return_type':'void'},'asort':{'signature':'void | void','return_type':'void'},'__construct':{'signature':'[ mixed $array = array() [, int $flags = 0]]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getArrayCopy':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | mixed','return_type':'mixed'},'ksort':{'signature':'void | void','return_type':'void'},'natcasesort':{'signature':'void | void','return_type':'void'},'natsort':{'signature':'void | void','return_type':'void'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'string $flags | void','return_type':'void'},'uasort':{'signature':'string $cmp_function | void','return_type':'void'},'uksort':{'signature':'string $cmp_function | void','return_type':'void'},'unserialize':{'signature':'string $serialized | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'arrayobject':{'name':'ArrayObject','constants':{'STD_PROP_LIST':'1','ARRAY_AS_PROPS':'2',},'methods':{'__construct':{'signature':'[ mixed $input = [] [, int $flags = 0 [, string $iterator_class = "ArrayIterator"]]]','return_type':''},'append':{'signature':'mixed $value | void','return_type':'void'},'asort':{'signature':'void | void','return_type':'void'},'count':{'signature':'void | int','return_type':'int'},'exchangeArray':{'signature':'mixed $input | array','return_type':'array'},'getArrayCopy':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | int','return_type':'int'},'getIterator':{'signature':'void | ArrayIterator','return_type':'ArrayIterator'},'getIteratorClass':{'signature':'void | string','return_type':'string'},'ksort':{'signature':'void | void','return_type':'void'},'natcasesort':{'signature':'void | void','return_type':'void'},'natsort':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'serialize':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setIteratorClass':{'signature':'string $iterator_class | void','return_type':'void'},'uasort':{'signature':'callable $cmp_function | void','return_type':'void'},'uksort':{'signature':'callable $cmp_function | void','return_type':'void'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},},},'badfunctioncallexception':{'name':'BadFunctionCallException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'badmethodcallexception':{'name':'BadMethodCallException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'cachingiterator':{'name':'CachingIterator','constants':{'CALL_TOSTRING':'1','CATCH_GET_CHILD':'16','TOSTRING_USE_KEY':'2','TOSTRING_USE_CURRENT':'4','TOSTRING_USE_INNER':'8','FULL_CACHE':'256',},'methods':{'__construct':{'signature':'Iterator $iterator [, string $flags = self::CALL_TOSTRING]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | void','return_type':'void'},'getCache':{'signature':'void | void','return_type':'void'},'getFlags':{'signature':'void | void','return_type':'void'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'hasNext':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | void','return_type':'void'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'bitmask $flags | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'callbackfilteriterator':{'name':'CallbackFilterIterator','methods':{'__construct':{'signature':'Iterator $iterator','return_type':''},'accept':{'signature':'void | bool','return_type':'bool'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'directoryiterator':{'name':'DirectoryIterator','methods':{'__construct':{'signature':'string $path','return_type':''},'current':{'signature':'void | DirectoryIterator','return_type':'DirectoryIterator'},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isDot':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | void','return_type':'void'},'__toString':{'signature':'void | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'domainexception':{'name':'DomainException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'emptyiterator':{'name':'EmptyIterator','methods':{'current':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | void','return_type':'void'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'filesystemiterator':{'name':'FilesystemIterator','constants':{'CURRENT_AS_PATHNAME':'32','CURRENT_AS_FILEINFO':'0','CURRENT_AS_SELF':'16','CURRENT_MODE_MASK':'240','KEY_AS_PATHNAME':'0','KEY_AS_FILENAME':'256','FOLLOW_SYMLINKS':'512','KEY_MODE_MASK':'3840','NEW_CURRENT_AND_KEY':'256','SKIP_DOTS':'4096','UNIX_PATHS':'8192',},'methods':{'__construct':{'signature':'string $path [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS]','return_type':''},'current':{'signature':'void | DirectoryIterator','return_type':'DirectoryIterator'},'getFlags':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'[ int $flags] | void','return_type':'void'},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isDot':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'seek':{'signature':'int $position | void','return_type':'void'},'__toString':{'signature':'void | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'filteriterator':{'name':'FilterIterator','methods':{'accept':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'Iterator $iterator','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'globiterator':{'name':'GlobIterator','methods':{'__construct':{'signature':'string $path [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getFlags':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'[ int $flags] | void','return_type':'void'},},},'infiniteiterator':{'name':'InfiniteIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'next':{'signature':'void | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'key':{'signature':'void | scalar','return_type':'scalar'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'invalidargumentexception':{'name':'InvalidArgumentException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'iteratoriterator':{'name':'IteratorIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'lengthexception':{'name':'LengthException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'limititerator':{'name':'LimitIterator','methods':{'__construct':{'signature':'Iterator $iterator [, int $offset = 0 [, int $count = -1]]','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'getPosition':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | int','return_type':'int'},'valid':{'signature':'void | bool','return_type':'bool'},},},'logicexception':{'name':'LogicException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'multipleiterator':{'name':'MultipleIterator','constants':{'MIT_NEED_ANY':'0','MIT_NEED_ALL':'1','MIT_KEYS_NUMERIC':'0','MIT_KEYS_ASSOC':'2',},'methods':{'__construct':{'signature':'[ int $flags = MultipleIterator::MIT_NEED_ALL|MultipleIterator::MIT_KEYS_NUMERIC]','return_type':''},'attachIterator':{'signature':'Iterator $iterator [, string $infos] | void','return_type':'void'},'containsIterator':{'signature':'Iterator $iterator | void','return_type':'void'},'countIterators':{'signature':'void | void','return_type':'void'},'current':{'signature':'void | array','return_type':'array'},'detachIterator':{'signature':'Iterator $iterator | void','return_type':'void'},'getFlags':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | array','return_type':'array'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'norewinditerator':{'name':'NoRewindIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'outofboundsexception':{'name':'OutOfBoundsException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'outofrangeexception':{'name':'OutOfRangeException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'overflowexception':{'name':'OverflowException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'parentiterator':{'name':'ParentIterator','methods':{'accept':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'RecursiveIterator $iterator','return_type':''},'getChildren':{'signature':'void | ParentIterator','return_type':'ParentIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},},},'rangeexception':{'name':'RangeException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'recursivearrayiterator':{'name':'RecursiveArrayIterator','methods':{'getChildren':{'signature':'void | RecursiveArrayIterator','return_type':'RecursiveArrayIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'append':{'signature':'mixed $value | void','return_type':'void'},'asort':{'signature':'void | void','return_type':'void'},'__construct':{'signature':'[ mixed $array = array() [, int $flags = 0]]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getArrayCopy':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | mixed','return_type':'mixed'},'ksort':{'signature':'void | void','return_type':'void'},'natcasesort':{'signature':'void | void','return_type':'void'},'natsort':{'signature':'void | void','return_type':'void'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'string $flags | void','return_type':'void'},'uasort':{'signature':'string $cmp_function | void','return_type':'void'},'uksort':{'signature':'string $cmp_function | void','return_type':'void'},'unserialize':{'signature':'string $serialized | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'recursivecachingiterator':{'name':'RecursiveCachingIterator','methods':{'__construct':{'signature':'Iterator $iterator [, string $flags = self::CALL_TOSTRING]','return_type':''},'getChildren':{'signature':'void | RecursiveCachingIterator','return_type':'RecursiveCachingIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | void','return_type':'void'},'getCache':{'signature':'void | void','return_type':'void'},'getFlags':{'signature':'void | void','return_type':'void'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'hasNext':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | void','return_type':'void'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'bitmask $flags | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'recursivecallbackfilteriterator':{'name':'RecursiveCallbackFilterIterator','methods':{'__construct':{'signature':'RecursiveIterator $iterator, string $callback','return_type':''},'getChildren':{'signature':'void | RecursiveCallbackFilterIterator','return_type':'RecursiveCallbackFilterIterator'},'hasChildren':{'signature':'void | void','return_type':'void'},'accept':{'signature':'void | string','return_type':'string'},},},'recursivedirectoryiterator':{'name':'RecursiveDirectoryIterator','methods':{'__construct':{'signature':'string $path [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS]','return_type':''},'getChildren':{'signature':'void | mixed','return_type':'mixed'},'getSubPath':{'signature':'void | string','return_type':'string'},'getSubPathname':{'signature':'void | string','return_type':'string'},'hasChildren':{'signature':'[ bool $allow_links = false] | bool','return_type':'bool'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getFlags':{'signature':'void | int','return_type':'int'},'setFlags':{'signature':'[ int $flags] | void','return_type':'void'},},},'recursivefilteriterator':{'name':'RecursiveFilterIterator','methods':{'__construct':{'signature':'Iterator $iterator','return_type':''},'getChildren':{'signature':'void | void','return_type':'void'},'hasChildren':{'signature':'void | void','return_type':'void'},'accept':{'signature':'void | bool','return_type':'bool'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'recursiveiteratoriterator':{'name':'RecursiveIteratorIterator','constants':{'LEAVES_ONLY':'0','SELF_FIRST':'1','CHILD_FIRST':'2','CATCH_GET_CHILD':'16',},'methods':{'beginChildren':{'signature':'void | void','return_type':'void'},'beginIteration':{'signature':'void | void','return_type':'void'},'callGetChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'callHasChildren':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'Traversable $iterator [, int $mode = RecursiveIteratorIterator::LEAVES_ONLY [, int $flags = 0]]','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'endChildren':{'signature':'void | void','return_type':'void'},'endIteration':{'signature':'void | void','return_type':'void'},'getDepth':{'signature':'void | int','return_type':'int'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'getMaxDepth':{'signature':'void | mixed','return_type':'mixed'},'getSubIterator':{'signature':'[ int $level] | RecursiveIterator','return_type':'RecursiveIterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'nextElement':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setMaxDepth':{'signature':'[ string $max_depth = -1] | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'recursiveregexiterator':{'name':'RecursiveRegexIterator','methods':{'__construct':{'signature':'RecursiveIterator $iterator, string $regex [, int $mode = self::MATCH [, int $flags = 0 [, int $preg_flags = 0]]]','return_type':''},'getChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'accept':{'signature':'void | bool','return_type':'bool'},'getFlags':{'signature':'void | int','return_type':'int'},'getMode':{'signature':'void | int','return_type':'int'},'getPregFlags':{'signature':'void | int','return_type':'int'},'getRegex':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMode':{'signature':'int $mode | void','return_type':'void'},'setPregFlags':{'signature':'int $preg_flags | void','return_type':'void'},},},'recursivetreeiterator':{'name':'RecursiveTreeIterator','constants':{'BYPASS_CURRENT':'4','BYPASS_KEY':'8','PREFIX_LEFT':'0','PREFIX_MID_HAS_NEXT':'1','PREFIX_MID_LAST':'2','PREFIX_END_HAS_NEXT':'3','PREFIX_END_LAST':'4','PREFIX_RIGHT':'5',},'methods':{'beginChildren':{'signature':'void | void','return_type':'void'},'beginIteration':{'signature':'void | void','return_type':'void'},'callGetChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'callHasChildren':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'Traversable $iterator [, int $mode = RecursiveIteratorIterator::LEAVES_ONLY [, int $flags = 0]]','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'endChildren':{'signature':'void | void','return_type':'void'},'endIteration':{'signature':'void | void','return_type':'void'},'getEntry':{'signature':'void | string','return_type':'string'},'getPostfix':{'signature':'void | void','return_type':'void'},'getPrefix':{'signature':'void | string','return_type':'string'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'nextElement':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setPrefixPart':{'signature':'int $part, string $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},'getDepth':{'signature':'void | int','return_type':'int'},'getInnerIterator':{'signature':'void | iterator','return_type':'iterator'},'getMaxDepth':{'signature':'void | mixed','return_type':'mixed'},'getSubIterator':{'signature':'[ int $level] | RecursiveIterator','return_type':'RecursiveIterator'},'setMaxDepth':{'signature':'[ string $max_depth = -1] | void','return_type':'void'},},},'regexiterator':{'name':'RegexIterator','constants':{'MATCH':'0','GET_MATCH':'1','ALL_MATCHES':'2','SPLIT':'3','REPLACE':'4','USE_KEY':'1',},'methods':{'__construct':{'signature':'Iterator $iterator','return_type':''},'accept':{'signature':'void | bool','return_type':'bool'},'getFlags':{'signature':'void | int','return_type':'int'},'getMode':{'signature':'void | int','return_type':'int'},'getPregFlags':{'signature':'void | int','return_type':'int'},'getRegex':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMode':{'signature':'int $mode | void','return_type':'void'},'setPregFlags':{'signature':'int $preg_flags | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'runtimeexception':{'name':'RuntimeException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'spldoublylinkedlist':{'name':'SplDoublyLinkedList','methods':{'__construct':{'signature':'void','return_type':''},'bottom':{'signature':'void | mixed','return_type':'mixed'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getIteratorMode':{'signature':'void | int','return_type':'int'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'pop':{'signature':'void | mixed','return_type':'mixed'},'prev':{'signature':'void | void','return_type':'void'},'push':{'signature':'mixed $value | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setIteratorMode':{'signature':'int $mode | void','return_type':'void'},'shift':{'signature':'void | mixed','return_type':'mixed'},'top':{'signature':'void | mixed','return_type':'mixed'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'unshift':{'signature':'mixed $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splfileinfo':{'name':'SplFileInfo','methods':{'__construct':{'signature':'string $file_name','return_type':''},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFileInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getLinkTarget':{'signature':'void | string','return_type':'string'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getRealPath':{'signature':'void | string','return_type':'string'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'openFile':{'signature':'[ string $open_mode = r [, bool $use_include_path = false [, resource $context = NULL]]] | SplFileObject','return_type':'SplFileObject'},'setFileClass':{'signature':'[ string $class_name] | void','return_type':'void'},'setInfoClass':{'signature':'[ string $class_name] | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},},},'splfileobject':{'name':'SplFileObject','constants':{'DROP_NEW_LINE':'1','READ_AHEAD':'2','SKIP_EMPTY':'4','READ_CSV':'8',},'methods':{'__construct':{'signature':'string $file_name','return_type':''},'current':{'signature':'void | string|array','return_type':'string|array'},'eof':{'signature':'void | bool','return_type':'bool'},'fflush':{'signature':'void | bool','return_type':'bool'},'fgetc':{'signature':'void | string','return_type':'string'},'fgetcsv':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | array','return_type':'array'},'fgets':{'signature':'void | string','return_type':'string'},'fgetss':{'signature':'[ string $allowable_tags] | string','return_type':'string'},'flock':{'signature':'int $operation [, int &$wouldblock] | bool','return_type':'bool'},'fpassthru':{'signature':'void | int','return_type':'int'},'fputcsv':{'signature':'array $fields [, string $delimiter = '','' [, string $enclosure = ''"'']] | int','return_type':'int'},'fscanf':{'signature':'string $format [, mixed &$...] | mixed','return_type':'mixed'},'fseek':{'signature':'int $offset [, int $whence = SEEK_SET] | int','return_type':'int'},'fstat':{'signature':'void | array','return_type':'array'},'ftell':{'signature':'void | int','return_type':'int'},'ftruncate':{'signature':'int $size | bool','return_type':'bool'},'fwrite':{'signature':'string $str [, int $length] | int','return_type':'int'},'getChildren':{'signature':'void | void','return_type':'void'},'getCsvControl':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | int','return_type':'int'},'getMaxLineLen':{'signature':'void | int','return_type':'int'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $line_pos | void','return_type':'void'},'setCsvControl':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMaxLineLen':{'signature':'int $max_len | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFileInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getLinkTarget':{'signature':'void | string','return_type':'string'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getRealPath':{'signature':'void | string','return_type':'string'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'openFile':{'signature':'[ string $open_mode = r [, bool $use_include_path = false [, resource $context = NULL]]] | SplFileObject','return_type':'SplFileObject'},'setFileClass':{'signature':'[ string $class_name] | void','return_type':'void'},'setInfoClass':{'signature':'[ string $class_name] | void','return_type':'void'},},},'splfixedarray':{'name':'SplFixedArray','methods':{'__construct':{'signature':'[ int $size = 0]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getSize':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'int $index | bool','return_type':'bool'},'offsetGet':{'signature':'int $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'int $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'int $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setSize':{'signature':'int $size | int','return_type':'int'},'toArray':{'signature':'void | array','return_type':'array'},'valid':{'signature':'void | bool','return_type':'bool'},'__wakeup':{'signature':'void | void','return_type':'void'},},'static_methods':{'fromArray':{'signature':'array $array [, bool $save_indexes = true] | SplFixedArray','return_type':'SplFixedArray'},},},'splheap':{'name':'SplHeap','methods':{'__construct':{'signature':'void','return_type':''},'compare':{'signature':'mixed $value1, mixed $value2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splmaxheap':{'name':'SplMaxHeap','methods':{'compare':{'signature':'mixed $value1, mixed $value2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splminheap':{'name':'SplMinHeap','methods':{'compare':{'signature':'mixed $value1, mixed $value2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splobjectstorage':{'name':'SplObjectStorage','methods':{'addAll':{'signature':'SplObjectStorage $storage | void','return_type':'void'},'attach':{'signature':'object $object [, mixed $data = NULL] | void','return_type':'void'},'contains':{'signature':'object $object | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | object','return_type':'object'},'detach':{'signature':'object $object | void','return_type':'void'},'getHash':{'signature':'object $object | string','return_type':'string'},'getInfo':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'object $object | bool','return_type':'bool'},'offsetGet':{'signature':'object $object | mixed','return_type':'mixed'},'offsetSet':{'signature':'object $object [, mixed $data = NULL] | void','return_type':'void'},'offsetUnset':{'signature':'object $object | void','return_type':'void'},'removeAll':{'signature':'SplObjectStorage $storage | void','return_type':'void'},'removeAllExcept':{'signature':'SplObjectStorage $storage | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setInfo':{'signature':'mixed $data | void','return_type':'void'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splpriorityqueue':{'name':'SplPriorityQueue','methods':{'__construct':{'signature':'void','return_type':''},'compare':{'signature':'mixed $priority1, mixed $priority2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value, mixed $priority | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setExtractFlags':{'signature':'int $flags | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splqueue':{'name':'SplQueue','methods':{'__construct':{'signature':'void','return_type':''},'dequeue':{'signature':'void | mixed','return_type':'mixed'},'enqueue':{'signature':'mixed $value | void','return_type':'void'},'setIteratorMode':{'signature':'int $mode | void','return_type':'void'},'bottom':{'signature':'void | mixed','return_type':'mixed'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getIteratorMode':{'signature':'void | int','return_type':'int'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'pop':{'signature':'void | mixed','return_type':'mixed'},'prev':{'signature':'void | void','return_type':'void'},'push':{'signature':'mixed $value | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'shift':{'signature':'void | mixed','return_type':'mixed'},'top':{'signature':'void | mixed','return_type':'mixed'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'unshift':{'signature':'mixed $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splstack':{'name':'SplStack','methods':{'__construct':{'signature':'void','return_type':''},'setIteratorMode':{'signature':'int $mode | void','return_type':'void'},'bottom':{'signature':'void | mixed','return_type':'mixed'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getIteratorMode':{'signature':'void | int','return_type':'int'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'pop':{'signature':'void | mixed','return_type':'mixed'},'prev':{'signature':'void | void','return_type':'void'},'push':{'signature':'mixed $value | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'shift':{'signature':'void | mixed','return_type':'mixed'},'top':{'signature':'void | mixed','return_type':'mixed'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'unshift':{'signature':'mixed $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'spltempfileobject':{'name':'SplTempFileObject','methods':{'__construct':{'signature':'string $filename [, string $open_mode = "r" [, bool $use_include_path = false [, resource $context]]]','return_type':''},'current':{'signature':'void | string|array','return_type':'string|array'},'eof':{'signature':'void | bool','return_type':'bool'},'fflush':{'signature':'void | bool','return_type':'bool'},'fgetc':{'signature':'void | string','return_type':'string'},'fgetcsv':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | array','return_type':'array'},'fgets':{'signature':'void | string','return_type':'string'},'fgetss':{'signature':'[ string $allowable_tags] | string','return_type':'string'},'flock':{'signature':'int $operation [, int &$wouldblock] | bool','return_type':'bool'},'fpassthru':{'signature':'void | int','return_type':'int'},'fputcsv':{'signature':'array $fields [, string $delimiter = '','' [, string $enclosure = ''"'']] | int','return_type':'int'},'fscanf':{'signature':'string $format [, mixed &$...] | mixed','return_type':'mixed'},'fseek':{'signature':'int $offset [, int $whence = SEEK_SET] | int','return_type':'int'},'fstat':{'signature':'void | array','return_type':'array'},'ftell':{'signature':'void | int','return_type':'int'},'ftruncate':{'signature':'int $size | bool','return_type':'bool'},'fwrite':{'signature':'string $str [, int $length] | int','return_type':'int'},'getChildren':{'signature':'void | void','return_type':'void'},'getCsvControl':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | int','return_type':'int'},'getMaxLineLen':{'signature':'void | int','return_type':'int'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $line_pos | void','return_type':'void'},'setCsvControl':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMaxLineLen':{'signature':'int $max_len | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'underflowexception':{'name':'UnderflowException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'unexpectedvalueexception':{'name':'UnexpectedValueException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},}
let php_builtin['classes']['predefined_interfaces_and_classes']={'closure':{'name':'Closure','methods':{'__construct':{'signature':'void','return_type':''},'bindTo':{'signature':'object $newthis [, mixed $newscope = ''static''] | Closure','return_type':'Closure'},},'static_methods':{'bind':{'signature':'Closure $closure, object $newthis [, mixed $newscope = ''static''] | Closure','return_type':'Closure'},},},'generator':{'name':'Generator','methods':{'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'send':{'signature':'mixed $value | mixed','return_type':'mixed'},'throw':{'signature':'Exception $exception | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},'__wakeup':{'signature':'void | void','return_type':'void'},},},}
let php_builtin['classes']['curl']={'curlfile':{'name':'CURLFile','properties': {'name':{'initializer':'','type':''},'mime':{'initializer':'','type':''},'postname':{'initializer':'','type':''},},'methods':{'__construct':{'signature':'string $filename [, string $mimetype [, string $postname]]','return_type':''},'getFilename':{'signature':'void | string','return_type':'string'},'getMimeType':{'signature':'void | string','return_type':'string'},'getPostFilename':{'signature':'void | string','return_type':'string'},'setMimeType':{'signature':'string $mime | void','return_type':'void'},'setPostFilename':{'signature':'string $postname | void','return_type':'void'},'__wakeup':{'signature':'void | void','return_type':'void'},},},}
let php_builtin['classes']['date_time']={'dateinterval':{'name':'DateInterval','properties': {'y':{'initializer':'','type':'integer'},'m':{'initializer':'','type':'integer'},'d':{'initializer':'','type':'integer'},'h':{'initializer':'','type':'integer'},'i':{'initializer':'','type':'integer'},'s':{'initializer':'','type':'integer'},'invert':{'initializer':'','type':'integer'},'days':{'initializer':'','type':'mixed'},},'methods':{'__construct':{'signature':'string $interval_spec','return_type':''},'format':{'signature':'string $format | string','return_type':'string'},},'static_methods':{'createFromDateString':{'signature':'string $time | DateInterval','return_type':'DateInterval'},},},'dateperiod':{'name':'DatePeriod','constants':{'EXCLUDE_START_DATE':'1',},'methods':{'__construct':{'signature':'string $isostr [, int $options]','return_type':''},},},'datetime':{'name':'DateTime','constants':{'ATOM':'"Y-m-d\TH:i:sP"','COOKIE':'"l, d-M-y H:i:s T"','ISO8601':'"Y-m-d\TH:i:sO"','RFC822':'"D, d M y H:i:s O"','RFC850':'"l, d-M-y H:i:s T"','RFC1036':'"D, d M y H:i:s O"','RFC1123':'"D, d M Y H:i:s O"','RFC2822':'"D, d M Y H:i:s O"','RFC3339':'"Y-m-d\TH:i:sP"','RSS':'"D, d M Y H:i:s O"','W3C':'"Y-m-d\TH:i:sP"',},'methods':{'__construct':{'signature':'[ string $time = "now" [, DateTimeZone $timezone = NULL]]','return_type':''},'add':{'signature':'DateInterval $interval | DateTime','return_type':'DateTime'},'modify':{'signature':'string $modify | DateTime','return_type':'DateTime'},'setDate':{'signature':'int $year, int $month, int $day | DateTime','return_type':'DateTime'},'setISODate':{'signature':'int $year, int $week [, int $day = 1] | DateTime','return_type':'DateTime'},'setTime':{'signature':'int $hour, int $minute [, int $second = 0] | DateTime','return_type':'DateTime'},'setTimestamp':{'signature':'int $unixtimestamp | DateTime','return_type':'DateTime'},'setTimezone':{'signature':'DateTimeZone $timezone | DateTime','return_type':'DateTime'},'sub':{'signature':'DateInterval $interval | DateTime','return_type':'DateTime'},'diff':{'signature':'DateTimeInterface $datetime2 [, bool $absolute = false] | DateInterval','return_type':'DateInterval'},'format':{'signature':'string $format | string','return_type':'string'},'getOffset':{'signature':'void | int','return_type':'int'},'getTimestamp':{'signature':'void | int','return_type':'int'},'getTimezone':{'signature':'void | DateTimeZone','return_type':'DateTimeZone'},'__wakeup':{'signature':'void','return_type':''},},'static_methods':{'createFromFormat':{'signature':'string $format, string $time [, DateTimeZone $timezone] | DateTime','return_type':'DateTime'},'getLastErrors':{'signature':'void | array','return_type':'array'},'__set_state':{'signature':'array $array | DateTime','return_type':'DateTime'},},},'datetimeimmutable':{'name':'DateTimeImmutable','methods':{'__construct':{'signature':'[ string $time = "now" [, DateTimeZone $timezone = NULL]]','return_type':''},'add':{'signature':'DateInterval $interval | DateTimeImmutable','return_type':'DateTimeImmutable'},'modify':{'signature':'string $modify | DateTimeImmutable','return_type':'DateTimeImmutable'},'setDate':{'signature':'int $year, int $month, int $day | DateTimeImmutable','return_type':'DateTimeImmutable'},'setISODate':{'signature':'int $year, int $week [, int $day = 1] | DateTimeImmutable','return_type':'DateTimeImmutable'},'setTime':{'signature':'int $hour, int $minute [, int $second = 0] | DateTimeImmutable','return_type':'DateTimeImmutable'},'setTimestamp':{'signature':'int $unixtimestamp | DateTimeImmutable','return_type':'DateTimeImmutable'},'setTimezone':{'signature':'DateTimeZone $timezone | DateTimeImmutable','return_type':'DateTimeImmutable'},'sub':{'signature':'DateInterval $interval | DateTimeImmutable','return_type':'DateTimeImmutable'},'diff':{'signature':'DateTimeInterface $datetime2 [, bool $absolute = false] | DateInterval','return_type':'DateInterval'},'format':{'signature':'string $format | string','return_type':'string'},'getOffset':{'signature':'void | int','return_type':'int'},'getTimestamp':{'signature':'void | int','return_type':'int'},'getTimezone':{'signature':'void | DateTimeZone','return_type':'DateTimeZone'},'__wakeup':{'signature':'void','return_type':''},},'static_methods':{'createFromFormat':{'signature':'string $format, string $time [, DateTimeZone $timezone] | DateTimeImmutable','return_type':'DateTimeImmutable'},'getLastErrors':{'signature':'void | array','return_type':'array'},'__set_state':{'signature':'array $array | DateTimeImmutable','return_type':'DateTimeImmutable'},},},'datetimezone':{'name':'DateTimeZone','constants':{'AFRICA':'1','AMERICA':'2','ANTARCTICA':'4','ARCTIC':'8','ASIA':'16','ATLANTIC':'32','AUSTRALIA':'64','EUROPE':'128','INDIAN':'256','PACIFIC':'512','UTC':'1024','ALL':'2047','ALL_WITH_BC':'4095','PER_COUNTRY':'4096',},'methods':{'__construct':{'signature':'string $timezone','return_type':''},'getLocation':{'signature':'void | array','return_type':'array'},'getName':{'signature':'void | string','return_type':'string'},'getOffset':{'signature':'DateTime $datetime | int','return_type':'int'},'getTransitions':{'signature':'[ int $timestamp_begin [, int $timestamp_end]] | array','return_type':'array'},},'static_methods':{'listAbbreviations':{'signature':'void | array','return_type':'array'},'listIdentifiers':{'signature':'[ int $what = DateTimeZone::ALL [, string $country = NULL]] | array','return_type':'array'},},},}
let php_builtin['classes']['directories']={'directory':{'name':'Directory','properties': {'path':{'initializer':'','type':'string'},'handle':{'initializer':'','type':'resource'},},'methods':{'close':{'signature':'[ resource $dir_handle] | void','return_type':'void'},'read':{'signature':'[ resource $dir_handle] | string','return_type':'string'},'rewind':{'signature':'[ resource $dir_handle] | void','return_type':'void'},},},}
let php_builtin['classes']['dom']={'domattr':{'name':'DOMAttr','properties': {'name':{'initializer':'','type':'string'},'ownerElement':{'initializer':'','type':'DOMElement'},'schemaTypeInfo':{'initializer':'','type':'bool'},'specified':{'initializer':'','type':'bool'},'value':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'string $name [, string $value]','return_type':''},'isId':{'signature':'void | bool','return_type':'bool'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domcdatasection':{'name':'DOMCdataSection','methods':{'__construct':{'signature':'string $value','return_type':''},'isWhitespaceInElementContent':{'signature':'void | bool','return_type':'bool'},'splitText':{'signature':'int $offset | DOMText','return_type':'DOMText'},},},'domcharacterdata':{'name':'DOMCharacterData','properties': {'data':{'initializer':'','type':'string'},'length':{'initializer':'','type':'int'},},'methods':{'appendData':{'signature':'string $data | void','return_type':'void'},'deleteData':{'signature':'int $offset, int $count | void','return_type':'void'},'insertData':{'signature':'int $offset, string $data | void','return_type':'void'},'replaceData':{'signature':'int $offset, int $count, string $data | void','return_type':'void'},'substringData':{'signature':'int $offset, int $count | string','return_type':'string'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domcomment':{'name':'DOMComment','methods':{'__construct':{'signature':'[ string $value]','return_type':''},'appendData':{'signature':'string $data | void','return_type':'void'},'deleteData':{'signature':'int $offset, int $count | void','return_type':'void'},'insertData':{'signature':'int $offset, string $data | void','return_type':'void'},'replaceData':{'signature':'int $offset, int $count, string $data | void','return_type':'void'},'substringData':{'signature':'int $offset, int $count | string','return_type':'string'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domdocument':{'name':'DOMDocument','properties': {'actualEncoding':{'initializer':'','type':'string'},'config':{'initializer':'','type':'DOMConfiguration'},'doctype':{'initializer':'','type':'DOMDocumentType'},'documentElement':{'initializer':'','type':'DOMElement'},'documentURI':{'initializer':'','type':'string'},'encoding':{'initializer':'','type':'string'},'formatOutput':{'initializer':'','type':'bool'},'implementation':{'initializer':'','type':'DOMImplementation'},'preserveWhiteSpace':{'initializer':'true','type':'bool'},'recover':{'initializer':'','type':'bool'},'resolveExternals':{'initializer':'','type':'bool'},'standalone':{'initializer':'','type':'bool'},'strictErrorChecking':{'initializer':'true','type':'bool'},'substituteEntities':{'initializer':'','type':'bool'},'validateOnParse':{'initializer':'false','type':'bool'},'version':{'initializer':'','type':'string'},'xmlEncoding':{'initializer':'','type':'string'},'xmlStandalone':{'initializer':'','type':'bool'},'xmlVersion':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'[ string $version [, string $encoding]]','return_type':''},'createAttribute':{'signature':'string $name | DOMAttr','return_type':'DOMAttr'},'createAttributeNS':{'signature':'string $namespaceURI, string $qualifiedName | DOMAttr','return_type':'DOMAttr'},'createCDATASection':{'signature':'string $data | DOMCDATASection','return_type':'DOMCDATASection'},'createComment':{'signature':'string $data | DOMComment','return_type':'DOMComment'},'createDocumentFragment':{'signature':'void | DOMDocumentFragment','return_type':'DOMDocumentFragment'},'createElement':{'signature':'string $name [, string $value] | DOMElement','return_type':'DOMElement'},'createElementNS':{'signature':'string $namespaceURI, string $qualifiedName [, string $value] | DOMElement','return_type':'DOMElement'},'createEntityReference':{'signature':'string $name | DOMEntityReference','return_type':'DOMEntityReference'},'createProcessingInstruction':{'signature':'string $target [, string $data] | DOMProcessingInstruction','return_type':'DOMProcessingInstruction'},'createTextNode':{'signature':'string $content | DOMText','return_type':'DOMText'},'getElementById':{'signature':'string $elementId | DOMElement','return_type':'DOMElement'},'getElementsByTagName':{'signature':'string $name | DOMNodeList','return_type':'DOMNodeList'},'getElementsByTagNameNS':{'signature':'string $namespaceURI, string $localName | DOMNodeList','return_type':'DOMNodeList'},'importNode':{'signature':'DOMNode $importedNode [, bool $deep] | DOMNode','return_type':'DOMNode'},'load':{'signature':'string $filename [, int $options = 0] | mixed','return_type':'mixed'},'loadHTML':{'signature':'string $source [, int $options = 0] | bool','return_type':'bool'},'loadHTMLFile':{'signature':'string $filename [, int $options = 0] | bool','return_type':'bool'},'loadXML':{'signature':'string $source [, int $options = 0] | mixed','return_type':'mixed'},'normalizeDocument':{'signature':'void | void','return_type':'void'},'registerNodeClass':{'signature':'string $baseclass, string $extendedclass | bool','return_type':'bool'},'relaxNGValidate':{'signature':'string $filename | bool','return_type':'bool'},'relaxNGValidateSource':{'signature':'string $source | bool','return_type':'bool'},'save':{'signature':'string $filename [, int $options] | int','return_type':'int'},'saveHTML':{'signature':'[ DOMNode $node = NULL] | string','return_type':'string'},'saveHTMLFile':{'signature':'string $filename | int','return_type':'int'},'saveXML':{'signature':'[ DOMNode $node [, int $options]] | string','return_type':'string'},'schemaValidate':{'signature':'string $filename [, int $flags] | bool','return_type':'bool'},'schemaValidateSource':{'signature':'string $source [, int $flags] | bool','return_type':'bool'},'validate':{'signature':'void | bool','return_type':'bool'},'xinclude':{'signature':'[ int $options] | int','return_type':'int'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domdocumentfragment':{'name':'DOMDocumentFragment','methods':{'appendXML':{'signature':'string $data | bool','return_type':'bool'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domdocumenttype':{'name':'DOMDocumentType','properties': {'publicId':{'initializer':'','type':'string'},'systemId':{'initializer':'','type':'string'},'name':{'initializer':'','type':'string'},'entities':{'initializer':'','type':'DOMNamedNodeMap'},'notations':{'initializer':'','type':'DOMNamedNodeMap'},'internalSubset':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domelement':{'name':'DOMElement','properties': {'schemaTypeInfo':{'initializer':'','type':'bool'},'tagName':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'string $name [, string $value [, string $namespaceURI]]','return_type':''},'getAttribute':{'signature':'string $name | string','return_type':'string'},'getAttributeNode':{'signature':'string $name | DOMAttr','return_type':'DOMAttr'},'getAttributeNodeNS':{'signature':'string $namespaceURI, string $localName | DOMAttr','return_type':'DOMAttr'},'getAttributeNS':{'signature':'string $namespaceURI, string $localName | string','return_type':'string'},'getElementsByTagName':{'signature':'string $name | DOMNodeList','return_type':'DOMNodeList'},'getElementsByTagNameNS':{'signature':'string $namespaceURI, string $localName | DOMNodeList','return_type':'DOMNodeList'},'hasAttribute':{'signature':'string $name | bool','return_type':'bool'},'hasAttributeNS':{'signature':'string $namespaceURI, string $localName | bool','return_type':'bool'},'removeAttribute':{'signature':'string $name | bool','return_type':'bool'},'removeAttributeNode':{'signature':'DOMAttr $oldnode | bool','return_type':'bool'},'removeAttributeNS':{'signature':'string $namespaceURI, string $localName | bool','return_type':'bool'},'setAttribute':{'signature':'string $name, string $value | DOMAttr','return_type':'DOMAttr'},'setAttributeNode':{'signature':'DOMAttr $attr | DOMAttr','return_type':'DOMAttr'},'setAttributeNodeNS':{'signature':'DOMAttr $attr | DOMAttr','return_type':'DOMAttr'},'setAttributeNS':{'signature':'string $namespaceURI, string $qualifiedName, string $value | void','return_type':'void'},'setIdAttribute':{'signature':'string $name, bool $isId | void','return_type':'void'},'setIdAttributeNode':{'signature':'DOMAttr $attr, bool $isId | void','return_type':'void'},'setIdAttributeNS':{'signature':'string $namespaceURI, string $localName, bool $isId | void','return_type':'void'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domentity':{'name':'DOMEntity','properties': {'publicId':{'initializer':'','type':'string'},'systemId':{'initializer':'','type':'string'},'notationName':{'initializer':'','type':'string'},'actualEncoding':{'initializer':'','type':'string'},'encoding':{'initializer':'','type':'string'},'version':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domentityreference':{'name':'DOMEntityReference','methods':{'__construct':{'signature':'string $name','return_type':''},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domexception':{'name':'DOMException','properties': {'code':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'domimplementation':{'name':'DOMImplementation','methods':{'__construct':{'signature':'void','return_type':''},'createDocument':{'signature':'[ string $namespaceURI = NULL [, string $qualifiedName = NULL [, DOMDocumentType $doctype = NULL]]] | DOMDocument','return_type':'DOMDocument'},'createDocumentType':{'signature':'[ string $qualifiedName = NULL [, string $publicId = NULL [, string $systemId = NULL]]] | DOMDocumentType','return_type':'DOMDocumentType'},'hasFeature':{'signature':'string $feature, string $version | bool','return_type':'bool'},},},'domnamednodemap':{'name':'DOMNamedNodeMap','properties': {'length':{'initializer':'','type':'int'},},'methods':{'getNamedItem':{'signature':'string $name | DOMNode','return_type':'DOMNode'},'getNamedItemNS':{'signature':'string $namespaceURI, string $localName | DOMNode','return_type':'DOMNode'},'item':{'signature':'int $index | DOMNode','return_type':'DOMNode'},},},'domnode':{'name':'DOMNode','properties': {'nodeName':{'initializer':'','type':'string'},'nodeValue':{'initializer':'','type':'string'},'nodeType':{'initializer':'','type':'int'},'parentNode':{'initializer':'','type':'DOMNode'},'childNodes':{'initializer':'','type':'DOMNodeList'},'firstChild':{'initializer':'','type':'DOMNode'},'lastChild':{'initializer':'','type':'DOMNode'},'previousSibling':{'initializer':'','type':'DOMNode'},'nextSibling':{'initializer':'','type':'DOMNode'},'attributes':{'initializer':'','type':'DOMNamedNodeMap'},'ownerDocument':{'initializer':'','type':'DOMDocument'},'namespaceURI':{'initializer':'','type':'string'},'prefix':{'initializer':'','type':'string'},'localName':{'initializer':'','type':'string'},'baseURI':{'initializer':'','type':'string'},'textContent':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domnodelist':{'name':'DOMNodeList','properties': {'length':{'initializer':'','type':'int'},},'methods':{'item':{'signature':'int $index | DOMNode','return_type':'DOMNode'},},},'domnotation':{'name':'DOMNotation','properties': {'publicId':{'initializer':'','type':'string'},'systemId':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domprocessinginstruction':{'name':'DOMProcessingInstruction','properties': {'target':{'initializer':'','type':'string'},'data':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'string $name [, string $value]','return_type':''},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domtext':{'name':'DOMText','properties': {'wholeText':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'[ string $value]','return_type':''},'isWhitespaceInElementContent':{'signature':'void | bool','return_type':'bool'},'splitText':{'signature':'int $offset | DOMText','return_type':'DOMText'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domxpath':{'name':'DOMXPath','properties': {'document':{'initializer':'','type':'DOMDocument'},},'methods':{'__construct':{'signature':'DOMDocument $doc','return_type':''},'evaluate':{'signature':'string $expression [, DOMNode $contextnode [, bool $registerNodeNS = true]] | mixed','return_type':'mixed'},'query':{'signature':'string $expression [, DOMNode $contextnode [, bool $registerNodeNS = true]] | DOMNodeList','return_type':'DOMNodeList'},'registerNamespace':{'signature':'string $prefix, string $namespaceURI | bool','return_type':'bool'},'registerPhpFunctions':{'signature':'[ mixed $restrict] | void','return_type':'void'},},},}
let php_builtin['classes']['predefined_exceptions']={'errorexception':{'name':'ErrorException','properties': {'severity':{'initializer':'','type':'int'},'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'__construct':{'signature':'[ string $message = "" [, int $code = 0 [, int $severity = 1 [, string $filename = __FILE__ [, int $lineno = __LINE__ [, Exception $previous = NULL]]]]]]','return_type':''},'getSeverity':{'signature':'void | int','return_type':'int'},'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'exception':{'name':'Exception','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'__construct':{'signature':'[ string $message = "" [, int $code = 0 [, Exception $previous = NULL]]]','return_type':''},'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},}
let php_builtin['classes']['libxml']={'libxmlerror':{'name':'libXMLError','properties': {'level':{'initializer':'','type':'int'},'code':{'initializer':'','type':'int'},'column':{'initializer':'','type':'int'},'message':{'initializer':'','type':'string'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},},}
let php_builtin['classes']['mysqli']={'mysqli_driver':{'name':'mysqli_driver','properties': {'client_info':{'initializer':'','type':'string'},'client_version':{'initializer':'','type':'string'},'driver_version':{'initializer':'','type':'string'},'embedded':{'initializer':'','type':'string'},'reconnect':{'initializer':'','type':'bool'},'report_mode':{'initializer':'','type':'int'},},'methods':{'embedded_server_end':{'signature':'void | void','return_type':'void'},'embedded_server_start':{'signature':'bool $start, array $arguments, array $groups | bool','return_type':'bool'},},},'mysqli_result':{'name':'mysqli_result','properties': {'current_field':{'initializer':'','type':'int'},'field_count':{'initializer':'','type':'int'},'lengths':{'initializer':'','type':'array'},'num_rows':{'initializer':'','type':'int'},},'methods':{'data_seek':{'signature':'int $offset | bool','return_type':'bool'},'fetch_all':{'signature':'[ int $resulttype = MYSQLI_NUM] | mixed','return_type':'mixed'},'fetch_array':{'signature':'[ int $resulttype = MYSQLI_BOTH] | mixed','return_type':'mixed'},'fetch_assoc':{'signature':'void | array','return_type':'array'},'fetch_field_direct':{'signature':'int $fieldnr | object','return_type':'object'},'fetch_field':{'signature':'void | object','return_type':'object'},'fetch_fields':{'signature':'void | array','return_type':'array'},'fetch_object':{'signature':'[ string $class_name [, array $params]] | object','return_type':'object'},'fetch_row':{'signature':'void | mixed','return_type':'mixed'},'field_seek':{'signature':'int $fieldnr | bool','return_type':'bool'},'free':{'signature':'void | void','return_type':'void'},},},'mysqli_sql_exception':{'name':'mysqli_sql_exception','properties': {'sqlstate':{'initializer':'','type':'string'},'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},},'mysqli_stmt':{'name':'mysqli_stmt','properties': {'affected_rows':{'initializer':'','type':'int'},'errno':{'initializer':'','type':'int'},'error_list':{'initializer':'','type':'array'},'error':{'initializer':'','type':'string'},'field_count':{'initializer':'','type':'int'},'insert_id':{'initializer':'','type':'int'},'num_rows':{'initializer':'','type':'int'},'param_count':{'initializer':'','type':'int'},'sqlstate':{'initializer':'','type':'string'},},'methods':{'attr_get':{'signature':'int $attr | int','return_type':'int'},'attr_set':{'signature':'int $attr, int $mode | bool','return_type':'bool'},'bind_param':{'signature':'string $types, mixed &$var1 [, mixed &$...] | bool','return_type':'bool'},'bind_result':{'signature':'mixed &$var1 [, mixed &$...] | bool','return_type':'bool'},'close':{'signature':'void | bool','return_type':'bool'},'data_seek':{'signature':'int $offset | void','return_type':'void'},'execute':{'signature':'void | bool','return_type':'bool'},'fetch':{'signature':'void | bool','return_type':'bool'},'free_result':{'signature':'void | void','return_type':'void'},'get_result':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'get_warnings':{'signature':'mysqli_stmt $stmt | object','return_type':'object'},'prepare':{'signature':'string $query | mixed','return_type':'mixed'},'reset':{'signature':'void | bool','return_type':'bool'},'result_metadata':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'send_long_data':{'signature':'int $param_nr, string $data | bool','return_type':'bool'},'store_result':{'signature':'void | bool','return_type':'bool'},},},'mysqli_warning':{'name':'mysqli_warning','properties': {'message':{'initializer':'','type':''},'sqlstate':{'initializer':'','type':''},'errno':{'initializer':'','type':''},},'methods':{'__construct':{'signature':'void','return_type':''},'next':{'signature':'void | void','return_type':'void'},},},'mysqli':{'name':'mysqli','properties': {'affected_rows':{'initializer':'','type':'int'},'client_info':{'initializer':'','type':'string'},'client_version':{'initializer':'','type':'int'},'connect_errno':{'initializer':'','type':'string'},'connect_error':{'initializer':'','type':'string'},'errno':{'initializer':'','type':'int'},'error_list':{'initializer':'','type':'array'},'error':{'initializer':'','type':'string'},'field_count':{'initializer':'','type':'int'},'host_info':{'initializer':'','type':'string'},'protocol_version':{'initializer':'','type':'string'},'server_info':{'initializer':'','type':'string'},'server_version':{'initializer':'','type':'int'},'info':{'initializer':'','type':'string'},'insert_id':{'initializer':'','type':'mixed'},'sqlstate':{'initializer':'','type':'string'},'thread_id':{'initializer':'','type':'int'},'warning_count':{'initializer':'','type':'int'},},'methods':{'__construct':{'signature':'[ string $host = ini_get("mysqli.default_host") [, string $username = ini_get("mysqli.default_user") [, string $passwd = ini_get("mysqli.default_pw") [, string $dbname = "" [, int $port = ini_get("mysqli.default_port") [, string $socket = ini_get("mysqli.default_socket")]]]]]]','return_type':''},'autocommit':{'signature':'bool $mode | bool','return_type':'bool'},'change_user':{'signature':'string $user, string $password, string $database | bool','return_type':'bool'},'character_set_name':{'signature':'void | string','return_type':'string'},'close':{'signature':'void | bool','return_type':'bool'},'commit':{'signature':'[ int $flags [, string $name]] | bool','return_type':'bool'},'debug':{'signature':'string $message | bool','return_type':'bool'},'dump_debug_info':{'signature':'void | bool','return_type':'bool'},'get_charset':{'signature':'void | object','return_type':'object'},'get_client_info':{'signature':'void | string','return_type':'string'},'get_connection_stats':{'signature':'void | bool','return_type':'bool'},'get_warnings':{'signature':'void | mysqli_warning','return_type':'mysqli_warning'},'init':{'signature':'void | mysqli','return_type':'mysqli'},'kill':{'signature':'int $processid | bool','return_type':'bool'},'more_results':{'signature':'void | bool','return_type':'bool'},'multi_query':{'signature':'string $query | bool','return_type':'bool'},'next_result':{'signature':'void | bool','return_type':'bool'},'options':{'signature':'int $option, mixed $value | bool','return_type':'bool'},'ping':{'signature':'void | bool','return_type':'bool'},'prepare':{'signature':'string $query | mysqli_stmt','return_type':'mysqli_stmt'},'query':{'signature':'string $query [, int $resultmode = MYSQLI_STORE_RESULT] | mixed','return_type':'mixed'},'real_connect':{'signature':'[ string $host [, string $username [, string $passwd [, string $dbname [, int $port [, string $socket [, int $flags]]]]]]] | bool','return_type':'bool'},'escape_string':{'signature':'string $escapestr | string','return_type':'string'},'real_query':{'signature':'string $query | bool','return_type':'bool'},'reap_async_query':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'refresh':{'signature':'int $options | bool','return_type':'bool'},'rollback':{'signature':'[ int $flags [, string $name]] | bool','return_type':'bool'},'rpl_query_type':{'signature':'string $query | int','return_type':'int'},'select_db':{'signature':'string $dbname | bool','return_type':'bool'},'send_query':{'signature':'string $query | bool','return_type':'bool'},'set_charset':{'signature':'string $charset | bool','return_type':'bool'},'set_local_infile_handler':{'signature':'mysqli $link, callable $read_func | bool','return_type':'bool'},'ssl_set':{'signature':'string $key, string $cert, string $ca, string $capath, string $cipher | bool','return_type':'bool'},'stat':{'signature':'void | string','return_type':'string'},'stmt_init':{'signature':'void | mysqli_stmt','return_type':'mysqli_stmt'},'store_result':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'use_result':{'signature':'void | mysqli_result','return_type':'mysqli_result'},},'static_methods':{'poll':{'signature':'array &$read, array &$error, array &$reject, int $sec [, int $usec] | int','return_type':'int'},},},}
let php_builtin['classes']['pdo']={'pdo':{'name':'PDO','constants':{'FETCH_ORI_ABS':'','ATTR_PERSISTENT':'','CLASS_CONSTANT':'','ATTR_DEFAULT_FETCH_MODE':'','FETCH_PROPS_LATE':'','FETCH_KEY_PAIR':'','FB_ATTR_DATE_FORMAT':'','FB_ATTR_TIME_FORMAT':'','FB_ATTR_TIMESTAMP_FORMAT':'','MYSQL_ATTR_READ_DEFAULT_FILE':'','MYSQL_ATTR_READ_DEFAULT_GROUP':'','ATTR_AUTOCOMMIT':'','FOURD_ATTR_CHARSET':'','FOURD_ATTR_PREFERRED_IMAGE_TYPES':'','PARAM_LOB':'','PARAM_BOOL':'','PARAM_NULL':'','PARAM_INT':'','PARAM_STR':'','PARAM_STMT':'','PARAM_INPUT_OUTPUT':'','FETCH_LAZY':'','FETCH_ASSOC':'','FETCH_NAMED':'','FETCH_NUM':'','FETCH_BOTH':'','FETCH_OBJ':'','FETCH_BOUND':'','FETCH_COLUMN':'','FETCH_CLASS':'','FETCH_INTO':'','FETCH_FUNC':'','FETCH_GROUP':'','FETCH_UNIQUE':'','FETCH_CLASSTYPE':'','FETCH_SERIALIZE':'','ATTR_PREFETCH':'','ATTR_TIMEOUT':'','ATTR_ERRMODE':'','ATTR_SERVER_VERSION':'','ATTR_CLIENT_VERSION':'','ATTR_SERVER_INFO':'','ATTR_CONNECTION_STATUS':'','ATTR_CASE':'','ATTR_CURSOR_NAME':'','ATTR_CURSOR':'','CURSOR_FWDONLY':'','CURSOR_SCROLL':'','ATTR_DRIVER_NAME':'','ATTR_ORACLE_NULLS':'','ATTR_STATEMENT_CLASS':'','ATTR_FETCH_CATALOG_NAMES':'','ATTR_FETCH_TABLE_NAMES':'','ATTR_STRINGIFY_FETCHES':'','ATTR_MAX_COLUMN_LEN':'','ATTR_EMULATE_PREPARES':'','ERRMODE_SILENT':'','ERRMODE_WARNING':'','ERRMODE_EXCEPTION':'','CASE_NATURAL':'','CASE_LOWER':'','CASE_UPPER':'','NULL_NATURAL':'','NULL_EMPTY_STRING':'','NULL_TO_STRING':'','FETCH_ORI_NEXT':'','FETCH_ORI_PRIOR':'','FETCH_ORI_FIRST':'','FETCH_ORI_LAST':'','FETCH_ORI_REL':'','ERR_NONE':'','PARAM_EVT_ALLOC':'','PARAM_EVT_FREE':'','PARAM_EVT_EXEC_PRE':'','PARAM_EVT_EXEC_POST':'','PARAM_EVT_FETCH_PRE':'','PARAM_EVT_FETCH_POST':'','PARAM_EVT_NORMALIZE':'','MYSQL_ATTR_INIT_COMMAND':'','MYSQL_ATTR_USE_BUFFERED_QUERY':'','MYSQL_ATTR_LOCAL_INFILE':'','MYSQL_ATTR_MAX_BUFFER_SIZE':'','MYSQL_ATTR_DIRECT_QUERY':'','MYSQL_ATTR_FOUND_ROWS':'','MYSQL_ATTR_IGNORE_SPACE':'','MYSQL_ATTR_COMPRESS':'','MYSQL_ATTR_SSL_CA':'','MYSQL_ATTR_SSL_CAPATH':'','MYSQL_ATTR_SSL_CERT':'','MYSQL_ATTR_SSL_CIPHER':'','MYSQL_ATTR_SSL_KEY':'','SQLSRV_TXN_READ_UNCOMMITTED':'','SQLSRV_TXN_READ_COMMITTED':'','SQLSRV_TXN_REPEATABLE_READ':'','SQLSRV_TXN_SNAPSHOT':'','SQLSRV_TXN_SERIALIZABLE':'','SQLSRV_ENCODING_BINARY':'','SQLSRV_ENCODING_SYSTEM':'','SQLSRV_ENCODING_UTF8':'','SQLSRV_ENCODING_DEFAULT':'','SQLSRV_ATTR_QUERY_TIMEOUT':'','SQLSRV_ATTR_DIRECT_QUERY':'',},'methods':{'__construct':{'signature':'string $dsn [, string $username [, string $password [, array $driver_options]]]','return_type':''},'beginTransaction':{'signature':'void | bool','return_type':'bool'},'commit':{'signature':'void | bool','return_type':'bool'},'errorCode':{'signature':'void | mixed','return_type':'mixed'},'errorInfo':{'signature':'void | array','return_type':'array'},'exec':{'signature':'string $statement | int','return_type':'int'},'getAttribute':{'signature':'int $attribute | mixed','return_type':'mixed'},'inTransaction':{'signature':'void | bool','return_type':'bool'},'lastInsertId':{'signature':'[ string $name = NULL] | string','return_type':'string'},'prepare':{'signature':'string $statement [, array $driver_options = array()] | PDOStatement','return_type':'PDOStatement'},'query':{'signature':'string $statement | PDOStatement','return_type':'PDOStatement'},'quote':{'signature':'string $string [, int $parameter_type = PDO::PARAM_STR] | string','return_type':'string'},'rollBack':{'signature':'void | bool','return_type':'bool'},'setAttribute':{'signature':'int $attribute, mixed $value | bool','return_type':'bool'},},'static_methods':{'getAvailableDrivers':{'signature':'void | array','return_type':'array'},},},'pdoexception':{'name':'PDOException','properties': {'errorInfo':{'initializer':'','type':'array'},'code':{'initializer':'','type':'int'},'message':{'initializer':'','type':'string'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'pdostatement':{'name':'PDOStatement','properties': {'queryString':{'initializer':'','type':'string'},},'methods':{'bindColumn':{'signature':'mixed $column, mixed &$param [, int $type [, int $maxlen [, mixed $driverdata]]] | bool','return_type':'bool'},'bindParam':{'signature':'mixed $parameter, mixed &$variable [, int $data_type = PDO::PARAM_STR [, int $length [, mixed $driver_options]]] | bool','return_type':'bool'},'bindValue':{'signature':'mixed $parameter, mixed $value [, int $data_type = PDO::PARAM_STR] | bool','return_type':'bool'},'closeCursor':{'signature':'void | bool','return_type':'bool'},'columnCount':{'signature':'void | int','return_type':'int'},'debugDumpParams':{'signature':'void | void','return_type':'void'},'errorCode':{'signature':'void | string','return_type':'string'},'errorInfo':{'signature':'void | array','return_type':'array'},'execute':{'signature':'[ array $input_parameters] | bool','return_type':'bool'},'fetch':{'signature':'[ int $fetch_style [, int $cursor_orientation = PDO::FETCH_ORI_NEXT [, int $cursor_offset = 0]]] | mixed','return_type':'mixed'},'fetchAll':{'signature':'[ int $fetch_style [, mixed $fetch_argument [, array $ctor_args = array()]]] | array','return_type':'array'},'fetchColumn':{'signature':'[ int $column_number = 0] | string','return_type':'string'},'fetchObject':{'signature':'[ string $class_name = "stdClass" [, array $ctor_args]] | mixed','return_type':'mixed'},'getAttribute':{'signature':'int $attribute | mixed','return_type':'mixed'},'getColumnMeta':{'signature':'int $column | array','return_type':'array'},'nextRowset':{'signature':'void | bool','return_type':'bool'},'rowCount':{'signature':'void | int','return_type':'int'},'setAttribute':{'signature':'int $attribute, mixed $value | bool','return_type':'bool'},'setFetchMode':{'signature':'int $mode | bool','return_type':'bool'},},},}
let php_builtin['classes']['phar']={'phar':{'name':'Phar','methods':{'addEmptyDir':{'signature':'string $dirname | void','return_type':'void'},'addFile':{'signature':'string $file [, string $localname] | void','return_type':'void'},'addFromString':{'signature':'string $localname, string $contents | void','return_type':'void'},'buildFromDirectory':{'signature':'string $base_dir [, string $regex] | array','return_type':'array'},'buildFromIterator':{'signature':'Iterator $iter [, string $base_directory] | array','return_type':'array'},'compress':{'signature':'int $compression [, string $extension] | object','return_type':'object'},'compressAllFilesBZIP2':{'signature':'void | bool','return_type':'bool'},'compressAllFilesGZ':{'signature':'void | bool','return_type':'bool'},'compressFiles':{'signature':'int $compression | void','return_type':'void'},'__construct':{'signature':'string $fname [, int $flags [, string $alias]]','return_type':''},'convertToData':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | PharData','return_type':'PharData'},'convertToExecutable':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | Phar','return_type':'Phar'},'copy':{'signature':'string $oldfile, string $newfile | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'decompress':{'signature':'[ string $extension] | object','return_type':'object'},'decompressFiles':{'signature':'void | bool','return_type':'bool'},'delMetadata':{'signature':'void | bool','return_type':'bool'},'delete':{'signature':'string $entry | bool','return_type':'bool'},'extractTo':{'signature':'string $pathto [, string|array $files [, bool $overwrite = false]] | bool','return_type':'bool'},'getMetadata':{'signature':'void | mixed','return_type':'mixed'},'getModified':{'signature':'void | bool','return_type':'bool'},'getSignature':{'signature':'void | array','return_type':'array'},'getStub':{'signature':'void | string','return_type':'string'},'getVersion':{'signature':'void | string','return_type':'string'},'hasMetadata':{'signature':'void | bool','return_type':'bool'},'isBuffering':{'signature':'void | bool','return_type':'bool'},'isCompressed':{'signature':'void | mixed','return_type':'mixed'},'isFileFormat':{'signature':'int $format | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'offsetExists':{'signature':'string $offset | bool','return_type':'bool'},'offsetGet':{'signature':'string $offset | int','return_type':'int'},'offsetSet':{'signature':'string $offset, string $value | void','return_type':'void'},'offsetUnset':{'signature':'string $offset | bool','return_type':'bool'},'setAlias':{'signature':'string $alias | bool','return_type':'bool'},'setDefaultStub':{'signature':'[ string $index [, string $webindex]] | bool','return_type':'bool'},'setMetadata':{'signature':'mixed $metadata | void','return_type':'void'},'setSignatureAlgorithm':{'signature':'int $sigtype [, string $privatekey] | void','return_type':'void'},'setStub':{'signature':'string $stub [, int $len = -1] | bool','return_type':'bool'},'startBuffering':{'signature':'void | void','return_type':'void'},'stopBuffering':{'signature':'void | void','return_type':'void'},'uncompressAllFiles':{'signature':'void | bool','return_type':'bool'},},'static_methods':{'apiVersion':{'signature':'void | string','return_type':'string'},'canCompress':{'signature':'[ int $type = 0] | bool','return_type':'bool'},'canWrite':{'signature':'void | bool','return_type':'bool'},'createDefaultStub':{'signature':'[ string $indexfile [, string $webindexfile]] | string','return_type':'string'},'getSupportedCompression':{'signature':'void | array','return_type':'array'},'getSupportedSignatures':{'signature':'void | array','return_type':'array'},'interceptFileFuncs':{'signature':'void | void','return_type':'void'},'isValidPharFilename':{'signature':'string $filename [, bool $executable = true] | bool','return_type':'bool'},'loadPhar':{'signature':'string $filename [, string $alias] | bool','return_type':'bool'},'mapPhar':{'signature':'[ string $alias [, int $dataoffset = 0]] | bool','return_type':'bool'},'mount':{'signature':'string $pharpath, string $externalpath | void','return_type':'void'},'mungServer':{'signature':'array $munglist | void','return_type':'void'},'running':{'signature':'[ bool $retphar = true] | string','return_type':'string'},'unlinkArchive':{'signature':'string $archive | bool','return_type':'bool'},'webPhar':{'signature':'[ string $alias [, string $index = "index.php" [, string $f404 [, array $mimetypes [, callable $rewrites]]]]] | void','return_type':'void'},},},'phardata':{'name':'PharData','methods':{'addEmptyDir':{'signature':'string $dirname | void','return_type':'void'},'addFile':{'signature':'string $file [, string $localname] | void','return_type':'void'},'addFromString':{'signature':'string $localname, string $contents | void','return_type':'void'},'buildFromDirectory':{'signature':'string $base_dir [, string $regex] | array','return_type':'array'},'buildFromIterator':{'signature':'Iterator $iter [, string $base_directory] | array','return_type':'array'},'compress':{'signature':'int $compression [, string $extension] | object','return_type':'object'},'compressFiles':{'signature':'int $compression | void','return_type':'void'},'__construct':{'signature':'string $fname [, int $flags [, string $alias]]','return_type':''},'convertToData':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | PharData','return_type':'PharData'},'convertToExecutable':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | Phar','return_type':'Phar'},'copy':{'signature':'string $oldfile, string $newfile | bool','return_type':'bool'},'decompress':{'signature':'[ string $extension] | object','return_type':'object'},'decompressFiles':{'signature':'void | bool','return_type':'bool'},'delMetadata':{'signature':'void | bool','return_type':'bool'},'delete':{'signature':'string $entry | bool','return_type':'bool'},'extractTo':{'signature':'string $pathto [, string|array $files [, bool $overwrite = false]] | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'offsetSet':{'signature':'string $offset, string $value | void','return_type':'void'},'offsetUnset':{'signature':'string $offset | bool','return_type':'bool'},'setAlias':{'signature':'string $alias | bool','return_type':'bool'},'setDefaultStub':{'signature':'[ string $index [, string $webindex]] | bool','return_type':'bool'},'setMetadata':{'signature':'mixed $metadata | void','return_type':'void'},'setSignatureAlgorithm':{'signature':'int $sigtype [, string $privatekey] | void','return_type':'void'},'setStub':{'signature':'string $stub [, int $len = -1] | bool','return_type':'bool'},'compressAllFilesBZIP2':{'signature':'void | bool','return_type':'bool'},'compressAllFilesGZ':{'signature':'void | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'getMetadata':{'signature':'void | mixed','return_type':'mixed'},'getModified':{'signature':'void | bool','return_type':'bool'},'getSignature':{'signature':'void | array','return_type':'array'},'getStub':{'signature':'void | string','return_type':'string'},'getVersion':{'signature':'void | string','return_type':'string'},'hasMetadata':{'signature':'void | bool','return_type':'bool'},'isBuffering':{'signature':'void | bool','return_type':'bool'},'isCompressed':{'signature':'void | mixed','return_type':'mixed'},'isFileFormat':{'signature':'int $format | bool','return_type':'bool'},'offsetExists':{'signature':'string $offset | bool','return_type':'bool'},'offsetGet':{'signature':'string $offset | int','return_type':'int'},'startBuffering':{'signature':'void | void','return_type':'void'},'stopBuffering':{'signature':'void | void','return_type':'void'},'uncompressAllFiles':{'signature':'void | bool','return_type':'bool'},},'static_methods':{'apiVersion':{'signature':'void | string','return_type':'string'},'canCompress':{'signature':'[ int $type = 0] | bool','return_type':'bool'},'canWrite':{'signature':'void | bool','return_type':'bool'},'createDefaultStub':{'signature':'[ string $indexfile [, string $webindexfile]] | string','return_type':'string'},'getSupportedCompression':{'signature':'void | array','return_type':'array'},'getSupportedSignatures':{'signature':'void | array','return_type':'array'},'interceptFileFuncs':{'signature':'void | void','return_type':'void'},'isValidPharFilename':{'signature':'string $filename [, bool $executable = true] | bool','return_type':'bool'},'loadPhar':{'signature':'string $filename [, string $alias] | bool','return_type':'bool'},'mapPhar':{'signature':'[ string $alias [, int $dataoffset = 0]] | bool','return_type':'bool'},'mount':{'signature':'string $pharpath, string $externalpath | void','return_type':'void'},'mungServer':{'signature':'array $munglist | void','return_type':'void'},'running':{'signature':'[ bool $retphar = true] | string','return_type':'string'},'unlinkArchive':{'signature':'string $archive | bool','return_type':'bool'},'webPhar':{'signature':'[ string $alias [, string $index = "index.php" [, string $f404 [, array $mimetypes [, callable $rewrites]]]]] | void','return_type':'void'},},},'pharexception':{'name':'PharException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'pharfileinfo':{'name':'PharFileInfo','methods':{'chmod':{'signature':'int $permissions | void','return_type':'void'},'compress':{'signature':'int $compression | bool','return_type':'bool'},'__construct':{'signature':'string $entry','return_type':''},'decompress':{'signature':'void | bool','return_type':'bool'},'delMetadata':{'signature':'void | bool','return_type':'bool'},'getCRC32':{'signature':'void | int','return_type':'int'},'getCompressedSize':{'signature':'void | int','return_type':'int'},'getMetadata':{'signature':'void | mixed','return_type':'mixed'},'getPharFlags':{'signature':'void | int','return_type':'int'},'hasMetadata':{'signature':'void | bool','return_type':'bool'},'isCRCChecked':{'signature':'void | bool','return_type':'bool'},'isCompressed':{'signature':'[ int $compression_type = 9021976] | bool','return_type':'bool'},'isCompressedBZIP2':{'signature':'void | bool','return_type':'bool'},'isCompressedGZ':{'signature':'void | bool','return_type':'bool'},'setCompressedBZIP2':{'signature':'void | bool','return_type':'bool'},'setCompressedGZ':{'signature':'void | bool','return_type':'bool'},'setMetadata':{'signature':'mixed $metadata | void','return_type':'void'},'setUncompressed':{'signature':'void | bool','return_type':'bool'},},},}
let php_builtin['classes']['streams']={'php_user_filter':{'name':'php_user_filter','properties': {'filtername':{'initializer':'','type':''},'params':{'initializer':'','type':''},},'methods':{'filter':{'signature':'resource $in, resource $out, int &$consumed, bool $closing | int','return_type':'int'},'onClose':{'signature':'void | void','return_type':'void'},'onCreate':{'signature':'void | bool','return_type':'bool'},},},}
let php_builtin['classes']['sessions']={'sessionhandler':{'name':'SessionHandler','methods':{'close':{'signature':'void | bool','return_type':'bool'},'destroy':{'signature':'string $session_id | bool','return_type':'bool'},'gc':{'signature':'int $maxlifetime | bool','return_type':'bool'},'open':{'signature':'string $save_path, string $session_id | bool','return_type':'bool'},'read':{'signature':'string $session_id | string','return_type':'string'},'write':{'signature':'string $session_id, string $session_data | bool','return_type':'bool'},},},'sessionhandlerinterface':{'name':'SessionHandlerInterface','methods':{'close':{'signature':'void | bool','return_type':'bool'},'destroy':{'signature':'string $session_id | bool','return_type':'bool'},'gc':{'signature':'string $maxlifetime | bool','return_type':'bool'},'open':{'signature':'string $save_path, string $name | bool','return_type':'bool'},'read':{'signature':'string $session_id | string','return_type':'string'},'write':{'signature':'string $session_id, string $session_data | bool','return_type':'bool'},},},}
let php_builtin['classes']['simplexml']={'simplexmlelement':{'name':'SimpleXMLElement','methods':{'__construct':{'signature':'string $data [, int $options = 0 [, bool $data_is_url = false [, string $ns = "" [, bool $is_prefix = false]]]]','return_type':''},'addAttribute':{'signature':'string $name [, string $value [, string $namespace]] | void','return_type':'void'},'addChild':{'signature':'string $name [, string $value [, string $namespace]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'asXML':{'signature':'[ string $filename] | mixed','return_type':'mixed'},'attributes':{'signature':'[ string $ns = NULL [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'children':{'signature':'[ string $ns [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'count':{'signature':'void | int','return_type':'int'},'getDocNamespaces':{'signature':'[ bool $recursive = false [, bool $from_root = true]] | array','return_type':'array'},'getName':{'signature':'void | string','return_type':'string'},'getNamespaces':{'signature':'[ bool $recursive = false] | array','return_type':'array'},'registerXPathNamespace':{'signature':'string $prefix, string $ns | bool','return_type':'bool'},'__toString':{'signature':'void | string','return_type':'string'},'xpath':{'signature':'string $path | array','return_type':'array'},},},'simplexmliterator':{'name':'SimpleXMLIterator','methods':{'current':{'signature':'void | mixed','return_type':'mixed'},'getChildren':{'signature':'void | SimpleXMLIterator','return_type':'SimpleXMLIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'string $data [, int $options = 0 [, bool $data_is_url = false [, string $ns = "" [, bool $is_prefix = false]]]]','return_type':''},'addAttribute':{'signature':'string $name [, string $value [, string $namespace]] | void','return_type':'void'},'addChild':{'signature':'string $name [, string $value [, string $namespace]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'asXML':{'signature':'[ string $filename] | mixed','return_type':'mixed'},'attributes':{'signature':'[ string $ns = NULL [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'children':{'signature':'[ string $ns [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'count':{'signature':'void | int','return_type':'int'},'getDocNamespaces':{'signature':'[ bool $recursive = false [, bool $from_root = true]] | array','return_type':'array'},'getName':{'signature':'void | string','return_type':'string'},'getNamespaces':{'signature':'[ bool $recursive = false] | array','return_type':'array'},'registerXPathNamespace':{'signature':'string $prefix, string $ns | bool','return_type':'bool'},'__toString':{'signature':'void | string','return_type':'string'},'xpath':{'signature':'string $path | array','return_type':'array'},},},}
let php_builtin['classes']['spl_types']={'splbool':{'name':'SplBool','constants':{'__default':'false','false':'false','true':'true',},'methods':{'getConstList':{'signature':'[ bool $include_default = false] | array','return_type':'array'},},},'splenum':{'name':'SplEnum','constants':{'__default':'null',},'methods':{'getConstList':{'signature':'[ bool $include_default = false] | array','return_type':'array'},'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'splfloat':{'name':'SplFloat','constants':{'__default':'0',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'splint':{'name':'SplInt','constants':{'__default':'0',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'splstring':{'name':'SplString','constants':{'__default':'0',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'spltype':{'name':'SplType','constants':{'__default':'null',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},}
let php_builtin['classes']['xmlreader']={'xmlreader':{'name':'XMLReader','constants':{'NONE':'0','ELEMENT':'1','ATTRIBUTE':'2','TEXT':'3','CDATA':'4','ENTITY_REF':'5','ENTITY':'6','PI':'7','COMMENT':'8','DOC':'9','DOC_TYPE':'10','DOC_FRAGMENT':'11','NOTATION':'12','WHITESPACE':'13','SIGNIFICANT_WHITESPACE':'14','END_ELEMENT':'15','END_ENTITY':'16','XML_DECLARATION':'17','LOADDTD':'1','DEFAULTATTRS':'2','VALIDATE':'3','SUBST_ENTITIES':'4',},'properties': {'attributeCount':{'initializer':'','type':'int'},'baseURI':{'initializer':'','type':'string'},'depth':{'initializer':'','type':'int'},'hasAttributes':{'initializer':'','type':'bool'},'hasValue':{'initializer':'','type':'bool'},'isDefault':{'initializer':'','type':'bool'},'isEmptyElement':{'initializer':'','type':'bool'},'localName':{'initializer':'','type':'string'},'name':{'initializer':'','type':'string'},'namespaceURI':{'initializer':'','type':'string'},'nodeType':{'initializer':'','type':'int'},'prefix':{'initializer':'','type':'string'},'value':{'initializer':'','type':'string'},'xmlLang':{'initializer':'','type':'string'},},'methods':{'close':{'signature':'void | bool','return_type':'bool'},'expand':{'signature':'[ DOMNode $basenode] | DOMNode','return_type':'DOMNode'},'getAttribute':{'signature':'string $name | string','return_type':'string'},'getAttributeNo':{'signature':'int $index | string','return_type':'string'},'getAttributeNs':{'signature':'string $localName, string $namespaceURI | string','return_type':'string'},'getParserProperty':{'signature':'int $property | bool','return_type':'bool'},'isValid':{'signature':'void | bool','return_type':'bool'},'lookupNamespace':{'signature':'string $prefix | bool','return_type':'bool'},'moveToAttribute':{'signature':'string $name | bool','return_type':'bool'},'moveToAttributeNo':{'signature':'int $index | bool','return_type':'bool'},'moveToAttributeNs':{'signature':'string $localName, string $namespaceURI | bool','return_type':'bool'},'moveToElement':{'signature':'void | bool','return_type':'bool'},'moveToFirstAttribute':{'signature':'void | bool','return_type':'bool'},'moveToNextAttribute':{'signature':'void | bool','return_type':'bool'},'next':{'signature':'[ string $localname] | bool','return_type':'bool'},'open':{'signature':'string $URI [, string $encoding [, int $options = 0]] | bool','return_type':'bool'},'read':{'signature':'void | bool','return_type':'bool'},'readInnerXML':{'signature':'void | string','return_type':'string'},'readOuterXML':{'signature':'void | string','return_type':'string'},'readString':{'signature':'void | string','return_type':'string'},'setParserProperty':{'signature':'int $property, bool $value | bool','return_type':'bool'},'setRelaxNGSchema':{'signature':'string $filename | bool','return_type':'bool'},'setRelaxNGSchemaSource':{'signature':'string $source | bool','return_type':'bool'},'setSchema':{'signature':'string $filename | bool','return_type':'bool'},'xml':{'signature':'string $source [, string $encoding [, int $options = 0]] | bool','return_type':'bool'},},},}
let php_builtin['classes']['xmlwriter'] = {'xmlwriter':{'name':'XMLWriter','methods':{'endAttribute':{'signature':'void | bool','return_type':'bool'},'endCData':{'signature':'void | bool','return_type':'bool'},'endComment':{'signature':'void | bool','return_type':'bool'},'endDocument':{'signature':'void | bool','return_type':'bool'},'endDTDAttlist':{'signature':'void | bool','return_type':'bool'},'endDTDElement':{'signature':'void | bool','return_type':'bool'},'endDTDEntity':{'signature':'void | bool','return_type':'bool'},'endDTD':{'signature':'void | bool','return_type':'bool'},'endElement':{'signature':'void | bool','return_type':'bool'},'endPI':{'signature':'void | bool','return_type':'bool'},'flush':{'signature':'[bool $empty = true] | bool','return_type':'bool'},'fullEndElement':{'signature':'void | bool','return_type':'bool'},'openMemory':{'signature':'void | bool','return_type':'bool'},'openURI':{'signature':'string $uri | bool','return_type':'bool'},'outputMemory':{'signature':'[bool $flush = true] | bool','return_type':'bool'},'setIndentString':{'signature':'string $indentString | bool','return_type':'bool'},'setIndent':{'signature':'bool $indent | bool','return_type':'bool'},'startAttributeNS':{'signature':'string $prefix, string $name, string $uri | bool','return_type':'bool'},'startAttribute':{'signature':'string $name | bool','return_type':'bool'},'startCData':{'signature':'void | bool','return_type':'bool'},'startComment':{'signature':'void | bool','return_type':'bool'},'startDocument':{'signature':'[string $version = 1.0 [, string $encoding = NULL [, string $standalone ]]] | bool','return_type':'bool'},'startDTDAttlist':{'signature':'string $name | bool','return_type':'bool'},'startDTDElement':{'signature':'string $qualifiedName | bool','return_type':'bool'},'startDTDEntity':{'signature':'string $name, bool $isparam | bool','return_type':'bool'},'startDTD':{'signature':'string $qualifiedName [, string $publicId [, string $systemId ]] | bool','return_type':'bool'},'startElementNS':{'signature':'string $prefix, string $name, string $uri | bool','return_type':'bool'},'startElement':{'signature':'string $name | bool','return_type':'bool'},'startPI':{'signature':'string $target | bool','return_type':'bool'},'text':{'signature':'string $content | bool','return_type':'bool'},'writeAttributeNS':{'signature':'string $prefix, string $name, string $uri, string $content | bool','return_type':'bool'},'writeAttribute':{'signature':'string $name, string $value | bool','return_type':'bool'},'writeCData':{'signature':'string $content | bool','return_type':'bool'},'writeComment':{'signature':'string $content | bool','return_type':'bool'},'writeDTDAttlist':{'signature':'string $name, string $content | bool','return_type':'bool'},'writeDTDElement':{'signature':'string $name, string $content | bool','return_type':'bool'},'writeDTDEntity':{'signature':'string $name, string $content, bool $pe, string $pubid, string $sysid, string $ndataid | bool','return_type':'bool'},'writeDTD':{'signature':'string $name [, string $publicId [, string $systemId [, string $subset ]]] | bool','return_type':'bool'},'writeElementNS':{'signature':'string $prefix, string $name, string $uri [, string $content ] | bool','return_type':'bool'},'writeElement':{'signature':'string $name [, string $content ] | bool','return_type':'bool'},'writePI':{'signature':'string $target, string $content | bool','return_type':'bool'},'writeRaw':{'signature':'string $content | bool','return_type':'bool'},},},}
let php_builtin['classes']['zip']={'ziparchive':{'name':'ZipArchive','properties': {'status':{'initializer':'','type':'int'},'statusSys':{'initializer':'','type':'int'},'numFiles':{'initializer':'','type':'int'},'filename':{'initializer':'','type':'string'},'comment':{'initializer':'','type':'string'},},'methods':{'addEmptyDir':{'signature':'string $dirname | bool','return_type':'bool'},'addFile':{'signature':'string $filename [, string $localname = NULL [, int $start = 0 [, int $length = 0]]] | bool','return_type':'bool'},'addFromString':{'signature':'string $localname, string $contents | bool','return_type':'bool'},'addGlob':{'signature':'string $pattern [, int $flags = 0 [, array $options = array()]] | bool','return_type':'bool'},'addPattern':{'signature':'string $pattern [, string $path = ''.'' [, array $options = array()]] | bool','return_type':'bool'},'close':{'signature':'void | bool','return_type':'bool'},'deleteIndex':{'signature':'int $index | bool','return_type':'bool'},'deleteName':{'signature':'string $name | bool','return_type':'bool'},'extractTo':{'signature':'string $destination [, mixed $entries] | bool','return_type':'bool'},'getArchiveComment':{'signature':'[ int $flags] | string','return_type':'string'},'getCommentIndex':{'signature':'int $index [, int $flags] | string','return_type':'string'},'getCommentName':{'signature':'string $name [, int $flags] | string','return_type':'string'},'getFromIndex':{'signature':'int $index [, int $length = 0 [, int $flags]] | string','return_type':'string'},'getFromName':{'signature':'string $name [, int $length = 0 [, int $flags]] | string','return_type':'string'},'getNameIndex':{'signature':'int $index [, int $flags] | string','return_type':'string'},'getStatusString':{'signature':'void | string','return_type':'string'},'getStream':{'signature':'string $name | resource','return_type':'resource'},'locateName':{'signature':'string $name [, int $flags] | int','return_type':'int'},'open':{'signature':'string $filename [, int $flags] | mixed','return_type':'mixed'},'renameIndex':{'signature':'int $index, string $newname | bool','return_type':'bool'},'renameName':{'signature':'string $name, string $newname | bool','return_type':'bool'},'setArchiveComment':{'signature':'string $comment | bool','return_type':'bool'},'setCommentIndex':{'signature':'int $index, string $comment | bool','return_type':'bool'},'setCommentName':{'signature':'string $name, string $comment | bool','return_type':'bool'},'statIndex':{'signature':'int $index [, int $flags] | array','return_type':'array'},'statName':{'signature':'string $name [, int $flags] | array','return_type':'array'},'unchangeAll':{'signature':'void | bool','return_type':'bool'},'unchangeArchive':{'signature':'void | bool','return_type':'bool'},'unchangeIndex':{'signature':'int $index | bool','return_type':'bool'},'unchangeName':{'signature':'string $name | bool','return_type':'bool'},},},}
let php_builtin['interfaces']['predefined_interfaces_and_classes']={'arrayaccess':{'name':'ArrayAccess','methods':{'offsetExists':{'signature':'mixed $offset | boolean','return_type':'boolean'},'offsetGet':{'signature':'mixed $offset | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $offset, mixed $value | void','return_type':'void'},'offsetUnset':{'signature':'mixed $offset | void','return_type':'void'},},},'iterator':{'name':'Iterator','methods':{'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'iteratoraggregate':{'name':'IteratorAggregate','methods':{'getIterator':{'signature':'void | Traversable','return_type':'Traversable'},},},'serializable':{'name':'Serializable','methods':{'serialize':{'signature':'void | string','return_type':'string'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},},},'traversable':{'name':'Traversable',},}
let php_builtin['interfaces']['spl']={'countable':{'name':'Countable','methods':{'count':{'signature':'void | int','return_type':'int'},},},'outeriterator':{'name':'OuterIterator','methods':{'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'recursiveiterator':{'name':'RecursiveIterator','methods':{'getChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'seekableiterator':{'name':'SeekableIterator','methods':{'seek':{'signature':'int $position | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'splobserver':{'name':'SplObserver','methods':{'update':{'signature':'SplSubject $subject | void','return_type':'void'},},},'splsubject':{'name':'SplSubject','methods':{'attach':{'signature':'SplObserver $observer | void','return_type':'void'},'detach':{'signature':'SplObserver $observer | void','return_type':'void'},'notify':{'signature':'void | void','return_type':'void'},},},}
let php_builtin['interfaces']['date_time']={'datetimeinterface':{'name':'DateTimeInterface','methods':{'diff':{'signature':'DateTimeInterface $datetime2 [, bool $absolute = false] | DateInterval','return_type':'DateInterval'},'format':{'signature':'string $format | string','return_type':'string'},'getOffset':{'signature':'void | int','return_type':'int'},'getTimestamp':{'signature':'void | int','return_type':'int'},'getTimezone':{'signature':'void | DateTimeZone','return_type':'DateTimeZone'},'__wakeup':{'signature':'void','return_type':''},},},}
let php_builtin['interfaces']['json']={'jsonserializable':{'name':'JsonSerializable','methods':{'jsonSerialize':{'signature':'void | mixed','return_type':'mixed'},},},}
let php_builtin['constants']['common']={'TRUE':'','FALSE':'','NULL':'','E_NOTICE':'','E_DEPRECATED':'','E_RECOVERABLE_ERROR':'','E_ALL':'','E_STRICT':'','E_WARNING':'','E_ERROR':'','E_PARSE':'','E_CORE_ERROR':'','E_CORE_WARNING':'','E_COMPILE_ERROR':'','E_COMPILE_WARNING':'','E_USER_ERROR':'','E_USER_WARNING':'','E_USER_NOTICE':'','E_USER_DEPRECATED':'','__COMPILER_HALT_OFFSET__':'','__FILE__':'','__LINE__':'','__DIR__':'','__FUNCTION__':'','__CLASS__':'','__TRAIT__':'','__METHOD__':'','__NAMESPACE__':'',}
let php_builtin['constants']['arrays']={'CASE_LOWER':'','CASE_UPPER':'','SORT_ASC':'','SORT_DESC':'','SORT_REGULAR':'','SORT_NUMERIC':'','SORT_STRING':'','SORT_LOCALE_STRING':'','SORT_NATURAL':'','SORT_FLAG_CASE':'','COUNT_NORMAL':'','COUNT_RECURSIVE':'','EXTR_OVERWRITE':'','EXTR_SKIP':'','EXTR_PREFIX_SAME':'','EXTR_PREFIX_ALL':'','EXTR_PREFIX_INVALID':'','EXTR_PREFIX_IF_EXISTS':'','EXTR_IF_EXISTS':'','EXTR_REFS':'',}
let php_builtin['constants']['calendar']={'CAL_GREGORIAN':'','CAL_JULIAN':'','CAL_JEWISH':'','CAL_FRENCH':'','CAL_NUM_CALS':'','CAL_DOW_DAYNO':'','CAL_DOW_SHORT':'','CAL_DOW_LONG':'','CAL_MONTH_GREGORIAN_SHORT':'','CAL_MONTH_GREGORIAN_LONG':'','CAL_MONTH_JULIAN_SHORT':'','CAL_MONTH_JULIAN_LONG':'','CAL_MONTH_JEWISH':'','CAL_MONTH_FRENCH':'','CAL_EASTER_DEFAULT':'','CAL_EASTER_ROMAN':'','CAL_EASTER_ALWAYS_GREGORIAN':'','CAL_EASTER_ALWAYS_JULIAN':'','CAL_JEWISH_ADD_ALAFIM_GERESH':'','CAL_JEWISH_ADD_ALAFIM':'','CAL_JEWISH_ADD_GERESHAYIM':'',}
let php_builtin['constants']['curl']={'CURLOPT_POSTFIELDS':'','CURLOPT_CAINFO':'','CURLOPT_AUTOREFERER':'','CURLOPT_COOKIESESSION':'','CURLOPT_DNS_USE_GLOBAL_CACHE':'','CURLOPT_DNS_CACHE_TIMEOUT':'','CURLOPT_FTP_SSL':'','CURLFTPSSL_TRY':'','CURLFTPSSL_ALL':'','CURLFTPSSL_CONTROL':'','CURLFTPSSL_NONE':'','CURLOPT_PRIVATE':'','CURLOPT_FTPSSLAUTH':'','CURLOPT_PORT':'','CURLOPT_FILE':'','CURLOPT_INFILE':'','CURLOPT_INFILESIZE':'','CURLOPT_URL':'','CURLOPT_PROXY':'','CURLOPT_VERBOSE':'','CURLOPT_HEADER':'','CURLOPT_HTTPHEADER':'','CURLOPT_NOPROGRESS':'','CURLOPT_NOBODY':'','CURLOPT_FAILONERROR':'','CURLOPT_UPLOAD':'','CURLOPT_POST':'','CURLOPT_FTPLISTONLY':'','CURLOPT_FTPAPPEND':'','CURLOPT_FTP_CREATE_MISSING_DIRS':'','CURLOPT_NETRC':'','CURLOPT_FOLLOWLOCATION':'','CURLOPT_FTPASCII':'','CURLOPT_PUT':'','CURLOPT_MUTE':'','CURLOPT_USERPWD':'','CURLOPT_PROXYUSERPWD':'','CURLOPT_RANGE':'','CURLOPT_TIMEOUT':'','CURLOPT_TIMEOUT_MS':'','CURLOPT_TCP_NODELAY':'','CURLOPT_PROGRESSFUNCTION':'','CURLOPT_REFERER':'','CURLOPT_USERAGENT':'','CURLOPT_FTPPORT':'','CURLOPT_FTP_USE_EPSV':'','CURLOPT_LOW_SPEED_LIMIT':'','CURLOPT_LOW_SPEED_TIME':'','CURLOPT_RESUME_FROM':'','CURLOPT_COOKIE':'','CURLOPT_SSLCERT':'','CURLOPT_SSLCERTPASSWD':'','CURLOPT_WRITEHEADER':'','CURLOPT_SSL_VERIFYHOST':'','CURLOPT_COOKIEFILE':'','CURLOPT_SSLVERSION':'','CURLOPT_TIMECONDITION':'','CURLOPT_TIMEVALUE':'','CURLOPT_CUSTOMREQUEST':'','CURLOPT_STDERR':'','CURLOPT_TRANSFERTEXT':'','CURLOPT_RETURNTRANSFER':'','CURLOPT_QUOTE':'','CURLOPT_POSTQUOTE':'','CURLOPT_INTERFACE':'','CURLOPT_KRB4LEVEL':'','CURLOPT_HTTPPROXYTUNNEL':'','CURLOPT_FILETIME':'','CURLOPT_WRITEFUNCTION':'','CURLOPT_READFUNCTION':'','CURLOPT_PASSWDFUNCTION':'','CURLOPT_HEADERFUNCTION':'','CURLOPT_MAXREDIRS':'','CURLOPT_MAXCONNECTS':'','CURLOPT_CLOSEPOLICY':'','CURLOPT_FRESH_CONNECT':'','CURLOPT_FORBID_REUSE':'','CURLOPT_RANDOM_FILE':'','CURLOPT_EGDSOCKET':'','CURLOPT_CONNECTTIMEOUT':'','CURLOPT_CONNECTTIMEOUT_MS':'','CURLOPT_SSL_VERIFYPEER':'','CURLOPT_CAPATH':'','CURLOPT_COOKIEJAR':'','CURLOPT_SSL_CIPHER_LIST':'','CURLOPT_BINARYTRANSFER':'','CURLOPT_NOSIGNAL':'','CURLOPT_PROXYTYPE':'','CURLOPT_BUFFERSIZE':'','CURLOPT_HTTPGET':'','CURLOPT_HTTP_VERSION':'','CURLOPT_SSLKEY':'','CURLOPT_SSLKEYTYPE':'','CURLOPT_SSLKEYPASSWD':'','CURLOPT_SSLENGINE':'','CURLOPT_SSLENGINE_DEFAULT':'','CURLOPT_SSLCERTTYPE':'','CURLOPT_CRLF':'','CURLOPT_ENCODING':'','CURLOPT_PROXYPORT':'','CURLOPT_UNRESTRICTED_AUTH':'','CURLOPT_FTP_USE_EPRT':'','CURLOPT_HTTP200ALIASES':'','CURLOPT_HTTPAUTH':'','CURLAUTH_BASIC':'','CURLAUTH_DIGEST':'','CURLAUTH_GSSNEGOTIATE':'','CURLAUTH_NTLM':'','CURLAUTH_ANY':'','CURLAUTH_ANYSAFE':'','CURLOPT_PROXYAUTH':'','CURLOPT_MAX_RECV_SPEED_LARGE':'','CURLOPT_MAX_SEND_SPEED_LARGE':'','CURLCLOSEPOLICY_LEAST_RECENTLY_USED':'','CURLCLOSEPOLICY_LEAST_TRAFFIC':'','CURLCLOSEPOLICY_SLOWEST':'','CURLCLOSEPOLICY_CALLBACK':'','CURLCLOSEPOLICY_OLDEST':'','CURLINFO_PRIVATE':'','CURLINFO_EFFECTIVE_URL':'','CURLINFO_HTTP_CODE':'','CURLINFO_HEADER_OUT':'','CURLINFO_HEADER_SIZE':'','CURLINFO_REQUEST_SIZE':'','CURLINFO_TOTAL_TIME':'','CURLINFO_NAMELOOKUP_TIME':'','CURLINFO_CONNECT_TIME':'','CURLINFO_PRETRANSFER_TIME':'','CURLINFO_SIZE_UPLOAD':'','CURLINFO_SIZE_DOWNLOAD':'','CURLINFO_SPEED_DOWNLOAD':'','CURLINFO_SPEED_UPLOAD':'','CURLINFO_FILETIME':'','CURLINFO_SSL_VERIFYRESULT':'','CURLINFO_CONTENT_LENGTH_DOWNLOAD':'','CURLINFO_CONTENT_LENGTH_UPLOAD':'','CURLINFO_STARTTRANSFER_TIME':'','CURLINFO_CONTENT_TYPE':'','CURLINFO_REDIRECT_TIME':'','CURLINFO_REDIRECT_COUNT':'','CURL_TIMECOND_IFMODSINCE':'','CURL_TIMECOND_IFUNMODSINCE':'','CURL_TIMECOND_LASTMOD':'','CURL_VERSION_IPV6':'','CURL_VERSION_KERBEROS4':'','CURL_VERSION_SSL':'','CURL_VERSION_LIBZ':'','CURLVERSION_NOW':'','CURLE_OK':'','CURLE_UNSUPPORTED_PROTOCOL':'','CURLE_FAILED_INIT':'','CURLE_URL_MALFORMAT':'','CURLE_URL_MALFORMAT_USER':'','CURLE_COULDNT_RESOLVE_PROXY':'','CURLE_COULDNT_RESOLVE_HOST':'','CURLE_COULDNT_CONNECT':'','CURLE_FTP_WEIRD_SERVER_REPLY':'','CURLE_FTP_ACCESS_DENIED':'','CURLE_FTP_USER_PASSWORD_INCORRECT':'','CURLE_FTP_WEIRD_PASS_REPLY':'','CURLE_FTP_WEIRD_USER_REPLY':'','CURLE_FTP_WEIRD_PASV_REPLY':'','CURLE_FTP_WEIRD_227_FORMAT':'','CURLE_FTP_CANT_GET_HOST':'','CURLE_FTP_CANT_RECONNECT':'','CURLE_FTP_COULDNT_SET_BINARY':'','CURLE_PARTIAL_FILE':'','CURLE_FTP_COULDNT_RETR_FILE':'','CURLE_FTP_WRITE_ERROR':'','CURLE_FTP_QUOTE_ERROR':'','CURLE_HTTP_NOT_FOUND':'','CURLE_WRITE_ERROR':'','CURLE_MALFORMAT_USER':'','CURLE_FTP_COULDNT_STOR_FILE':'','CURLE_READ_ERROR':'','CURLE_OUT_OF_MEMORY':'','CURLE_OPERATION_TIMEOUTED':'','CURLE_FTP_COULDNT_SET_ASCII':'','CURLE_FTP_PORT_FAILED':'','CURLE_FTP_COULDNT_USE_REST':'','CURLE_FTP_COULDNT_GET_SIZE':'','CURLE_HTTP_RANGE_ERROR':'','CURLE_HTTP_POST_ERROR':'','CURLE_SSL_CONNECT_ERROR':'','CURLE_FTP_BAD_DOWNLOAD_RESUME':'','CURLE_FILE_COULDNT_READ_FILE':'','CURLE_LDAP_CANNOT_BIND':'','CURLE_LDAP_SEARCH_FAILED':'','CURLE_LIBRARY_NOT_FOUND':'','CURLE_FUNCTION_NOT_FOUND':'','CURLE_ABORTED_BY_CALLBACK':'','CURLE_BAD_FUNCTION_ARGUMENT':'','CURLE_BAD_CALLING_ORDER':'','CURLE_HTTP_PORT_FAILED':'','CURLE_BAD_PASSWORD_ENTERED':'','CURLE_TOO_MANY_REDIRECTS':'','CURLE_UNKNOWN_TELNET_OPTION':'','CURLE_TELNET_OPTION_SYNTAX':'','CURLE_OBSOLETE':'','CURLE_SSL_PEER_CERTIFICATE':'','CURLE_GOT_NOTHING':'','CURLE_SSL_ENGINE_NOTFOUND':'','CURLE_SSL_ENGINE_SETFAILED':'','CURLE_SEND_ERROR':'','CURLE_RECV_ERROR':'','CURLE_SHARE_IN_USE':'','CURLE_SSL_CERTPROBLEM':'','CURLE_SSL_CIPHER':'','CURLE_SSL_CACERT':'','CURLE_BAD_CONTENT_ENCODING':'','CURLE_LDAP_INVALID_URL':'','CURLE_FILESIZE_EXCEEDED':'','CURLE_FTP_SSL_FAILED':'','CURLFTPAUTH_DEFAULT':'','CURLFTPAUTH_SSL':'','CURLFTPAUTH_TLS':'','CURLPROXY_HTTP':'','CURLPROXY_SOCKS5':'','CURL_NETRC_OPTIONAL':'','CURL_NETRC_IGNORED':'','CURL_NETRC_REQUIRED':'','CURL_HTTP_VERSION_NONE':'','CURL_HTTP_VERSION_1_0':'','CURL_HTTP_VERSION_1_1':'','CURLM_CALL_MULTI_PERFORM':'','CURLM_OK':'','CURLM_BAD_HANDLE':'','CURLM_BAD_EASY_HANDLE':'','CURLM_OUT_OF_MEMORY':'','CURLM_INTERNAL_ERROR':'','CURLMSG_DONE':'','CURLOPT_KEYPASSWD':'','CURLOPT_SSH_AUTH_TYPES':'','CURLOPT_SSH_HOST_PUBLIC_KEY_MD5':'','CURLOPT_SSH_PRIVATE_KEYFILE':'','CURLOPT_SSH_PUBLIC_KEYFILE':'','CURLMOPT_PIPELINING':'','CURLMOPT_MAXCONNECTS':'','CURLSSH_AUTH_ANY':'','CURLSSH_AUTH_DEFAULT':'','CURLSSH_AUTH_HOST':'','CURLSSH_AUTH_KEYBOARD':'','CURLSSH_AUTH_NONE':'','CURLSSH_AUTH_PASSWORD':'','CURLSSH_AUTH_PUBLICKEY':'','CURL_WRAPPERS_ENABLED':'','CURLPAUSE_ALL':'','CURLPAUSE_CONT':'','CURLPAUSE_RECV':'','CURLPAUSE_RECV_CONT':'','CURLPAUSE_SEND':'','CURLPAUSE_SEND_CONT':'','CURLM_XXX':'','CURLOPT_CERTINFO':'','CURLOPT_CONNECT_ONLY':'','CURLINFO_':'','CURLOPT_PROTOCOLS':'','CURLOPT_REDIR_PROTOCOLS':'','CURLOPT_IPRESOLVE':'','CURL_IPRESOLVE_WHATEVER':'','CURL_IPRESOLVE_V4':'','CURL_IPRESOLVE_V6':'','CURLOPT_SHARE':'','CURLSHOPT_SHARE':'','CURLSHOPT_UNSHARE':'','CURL_LOCK_DATA_COOKIE':'','CURL_LOCK_DATA_DNS':'','CURL_LOCK_DATA_SSL_SESSION':'',}
let php_builtin['constants']['date_time']={'DATE_ATOM':'','DATE_COOKIE':'','DATE_ISO8601':'','DATE_RFC822':'','DATE_RFC850':'','DATE_RFC1036':'','DATE_RFC1123':'','DATE_RFC2822':'','DATE_RFC3339':'','DATE_RSS':'','DATE_W3C':'','SUNFUNCS_RET_TIMESTAMP':'','SUNFUNCS_RET_STRING':'','SUNFUNCS_RET_DOUBLE':'','LC_TIME':'',}
let php_builtin['constants']['libxml']={'LIBXML_ERR_WARNING':'','LIBXML_ERR_ERROR':'','LIBXML_ERR_FATAL':'','LIBXML_NONET':'','LIBXML_COMPACT':'','LIBXML_DTDATTR':'','LIBXML_DTDLOAD':'','LIBXML_DTDVALID':'','LIBXML_HTML_NOIMPLIED':'','LIBXML_HTML_NODEFDTD':'','LIBXML_NOBLANKS':'','LIBXML_NOCDATA':'','LIBXML_NOEMPTYTAG':'','LIBXML_NOENT':'','LIBXML_NOERROR':'','LIBXML_NOWARNING':'','LIBXML_NOXMLDECL':'','LIBXML_NSCLEAN':'','LIBXML_PARSEHUGE':'','LIBXML_PEDANTIC':'','LIBXML_XINCLUDE':'','LIBXML_ERR_NONE':'','LIBXML_VERSION':'','LIBXML_DOTTED_VERSION':'','LIBXML_SCHEMA_CREATE':'',}
let php_builtin['constants']['mysqli']={'MYSQLI_REPORT_OFF':'','MYSQLI_REPORT_ALL':'','MYSQLI_REPORT_STRICT':'','MYSQLI_REPORT_ERROR':'','MYSQLI_REPORT_INDEX':'','MYSQLI_ASSOC':'','MYSQLI_NUM':'','MYSQLI_BOTH':'','PHP_INT_MAX':'','MYSQLI_READ_DEFAULT_GROUP':'','MYSQLI_READ_DEFAULT_FILE':'','MYSQLI_OPT_CONNECT_TIMEOUT':'','MYSQLI_OPT_LOCAL_INFILE':'','MYSQLI_INIT_COMMAND':'','MYSQLI_CLIENT_SSL':'','MYSQLI_CLIENT_COMPRESS':'','MYSQLI_CLIENT_INTERACTIVE':'','MYSQLI_CLIENT_IGNORE_SPACE':'','MYSQLI_CLIENT_NO_SCHEMA':'','MYSQLI_CLIENT_MULTI_QUERIES':'','MYSQLI_STORE_RESULT':'','MYSQLI_USE_RESULT':'','MYSQLI_NOT_NULL_FLAG':'','MYSQLI_PRI_KEY_FLAG':'','MYSQLI_UNIQUE_KEY_FLAG':'','MYSQLI_MULTIPLE_KEY_FLAG':'','MYSQLI_BLOB_FLAG':'','MYSQLI_UNSIGNED_FLAG':'','MYSQLI_ZEROFILL_FLAG':'','MYSQLI_AUTO_INCREMENT_FLAG':'','MYSQLI_TIMESTAMP_FLAG':'','MYSQLI_SET_FLAG':'','MYSQLI_NUM_FLAG':'','MYSQLI_PART_KEY_FLAG':'','MYSQLI_GROUP_FLAG':'','MYSQLI_TYPE_DECIMAL':'','MYSQLI_TYPE_NEWDECIMAL':'','MYSQLI_TYPE_BIT':'','MYSQLI_TYPE_TINY':'','MYSQLI_TYPE_SHORT':'','MYSQLI_TYPE_LONG':'','MYSQLI_TYPE_FLOAT':'','MYSQLI_TYPE_DOUBLE':'','MYSQLI_TYPE_NULL':'','MYSQLI_TYPE_TIMESTAMP':'','MYSQLI_TYPE_LONGLONG':'','MYSQLI_TYPE_INT24':'','MYSQLI_TYPE_DATE':'','MYSQLI_TYPE_TIME':'','MYSQLI_TYPE_DATETIME':'','MYSQLI_TYPE_YEAR':'','MYSQLI_TYPE_NEWDATE':'','MYSQLI_TYPE_INTERVAL':'','MYSQLI_TYPE_ENUM':'','MYSQLI_TYPE_SET':'','MYSQLI_TYPE_TINY_BLOB':'','MYSQLI_TYPE_MEDIUM_BLOB':'','MYSQLI_TYPE_LONG_BLOB':'','MYSQLI_TYPE_BLOB':'','MYSQLI_TYPE_VAR_STRING':'','MYSQLI_TYPE_STRING':'','MYSQLI_TYPE_CHAR':'','MYSQLI_TYPE_GEOMETRY':'','MYSQLI_NEED_DATA':'','MYSQLI_NO_DATA':'','MYSQLI_DATA_TRUNCATED':'','MYSQLI_ENUM_FLAG':'','MYSQLI_BINARY_FLAG':'','MYSQLI_CURSOR_TYPE_FOR_UPDATE':'','MYSQLI_CURSOR_TYPE_NO_CURSOR':'','MYSQLI_CURSOR_TYPE_READ_ONLY':'','MYSQLI_CURSOR_TYPE_SCROLLABLE':'','MYSQLI_STMT_ATTR_CURSOR_TYPE':'','MYSQLI_STMT_ATTR_PREFETCH_ROWS':'','MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH':'','MYSQLI_SET_CHARSET_NAME':'','MYSQLI_DEBUG_TRACE_ENABLED':'','MYSQLI_SERVER_QUERY_NO_GOOD_INDEX_USED':'','MYSQLI_SERVER_QUERY_NO_INDEX_USED':'','MYSQLI_REFRESH_GRANT':'','MYSQLI_REFRESH_LOG':'','MYSQLI_REFRESH_TABLES':'','MYSQLI_REFRESH_HOSTS':'','MYSQLI_REFRESH_STATUS':'','MYSQLI_REFRESH_THREADS':'','MYSQLI_REFRESH_SLAVE':'','MYSQLI_REFRESH_MASTER':'','MYSQLI_TRANS_COR_AND_CHAIN':'','MYSQLI_TRANS_COR_AND_NO_CHAIN':'','MYSQLI_TRANS_COR_RELEASE':'','MYSQLI_TRANS_COR_NO_RELEASE':'','MYSQL_READ_DEFAULT_FILE':'','MYSQLI_SERVER_PUBLIC_KEY':'','MYSQLI_NO_CHANGE_USER_ON_PCONNECT':'','MYSQLI_ASYNC':'','MYSQLI_OPT_INT_AND_FLOAT_NATIVE':'','MYSQLI_CLIENT_FOUND_ROWS':'','MULTI_STATEMENT':'','MYSQLI_RPL_MASTER':'','MYSQLI_RPL_SLAVE':'','MYSQLI_RPL_ADMIN':'',}
let php_builtin['constants']['spl']={'READ_AHEAD':'','MIT_NEED_ALL':'','MIT_KEYS_ASSOC':'','CALL_TOSTRING':'','CATCH_GET_CHILD':'','RIT_LEAVES_ONLY':'','LOCK_SH':'','LOCK_EX':'','LOCK_UN':'','LOCK_NB':'','SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','PHP_INT_MAX':'',}
let php_builtin['constants']['unknow']={'PHP_INI_ALL':'','PHP_INI_PERDIR':'','PHP_INI_SYSTEM':'','PHP_INI_USER':'','COUNTER_FLAG_PERSIST':'','COUNTER_FLAG_SAVE':'','COUNTER_FLAG_NO_OVERWRITE':'','COUNTER_META_NAME':'','COUNTER_META_IS_PERISTENT':'','COUNTER_RESET_NEVER':'','COUNTER_RESET_PER_LOAD':'','COUNTER_RESET_PER_REQUEST':'','PDO_PLACEHOLDER_NAMED':'','PDO_PLACEHOLDER_POSITIONAL':'','PDO_PLACEHOLDER_NONE':'','PDO_CASE_NATURAL':'','PDO_CASE_UPPER':'','PDO_CASE_LOWER':'','PDO_ATTR_CASE':'','PHP_COUNTER_API':'','PHPAPI':'','COMPILE_DL_COUNTER':'','ZEND_GET_MODULE':'','HAVE_COUNTER':'','COUNTER_G':'','TSRMLS_DC':'','TSRMLS_FETCH':'','STANDARD_MODULE_HEADER':'','STANDARD_MODULE_HEADER_EX':'','STANDARD_MODULE_PROPERTIES':'','STANDARD_MODULE_PROPERTIES_EX':'','ZEND_MODULE_API_NO':'','ZEND_DEBUG':'','USING_ZTS':'','NO_VERSION_YET':'','NO_MODULE_GLOBALS':'','PHP_MODULE_GLOBALS':'','IGNORE_PATH':'','USE_PATH':'','IGNORE_URL':'','IGNORE_URL_WIN':'','ENFORCE_SAFE_MODE':'','REPORT_ERRORS':'','STREAM_MUST_SEEK':'','STREAM_WILL_CAST':'',}
let php_builtin['constants']['directories']={'DIRECTORY_SEPARATOR':'','PATH_SEPARATOR':'','SCANDIR_SORT_ASCENDING':'','SCANDIR_SORT_DESCENDING':'','SCANDIR_SORT_NONE':'',}
let php_builtin['constants']['dom']={'XML_ELEMENT_NODE':'','XML_ATTRIBUTE_NODE':'','XML_TEXT_NODE':'','XML_CDATA_SECTION_NODE':'','XML_ENTITY_REF_NODE':'','XML_ENTITY_NODE':'','XML_PI_NODE':'','XML_COMMENT_NODE':'','XML_DOCUMENT_NODE':'','XML_DOCUMENT_TYPE_NODE':'','XML_DOCUMENT_FRAG_NODE':'','XML_NOTATION_NODE':'','XML_HTML_DOCUMENT_NODE':'','XML_DTD_NODE':'','XML_ELEMENT_DECL_NODE':'','XML_ATTRIBUTE_DECL_NODE':'','XML_ENTITY_DECL_NODE':'','XML_NAMESPACE_DECL_NODE':'','XML_ATTRIBUTE_CDATA':'','XML_ATTRIBUTE_ID':'','XML_ATTRIBUTE_IDREF':'','XML_ATTRIBUTE_IDREFS':'','XML_ATTRIBUTE_ENTITY':'','XML_ATTRIBUTE_NMTOKEN':'','XML_ATTRIBUTE_NMTOKENS':'','XML_ATTRIBUTE_ENUMERATION':'','XML_ATTRIBUTE_NOTATION':'','DOM_PHP_ERR':'','DOM_INDEX_SIZE_ERR':'','DOMSTRING_SIZE_ERR':'','DOM_HIERARCHY_REQUEST_ERR':'','DOM_WRONG_DOCUMENT_ERR':'','DOM_INVALID_CHARACTER_ERR':'','DOM_NO_DATA_ALLOWED_ERR':'','DOM_NO_MODIFICATION_ALLOWED_ERR':'','DOM_NOT_FOUND_ERR':'','DOM_NOT_SUPPORTED_ERR':'','DOM_INUSE_ATTRIBUTE_ERR':'','DOM_INVALID_STATE_ERR':'','DOM_SYNTAX_ERR':'','DOM_INVALID_MODIFICATION_ERR':'','DOM_NAMESPACE_ERR':'','DOM_INVALID_ACCESS_ERR':'','DOM_VALIDATION_ERR':'','DOM_NOT_FOUND_ERROR':'','DOM_NOT_FOUND':'',}
let php_builtin['constants']['command_line_usage']={'PHP_SAPI':'','STDIN':'','STDOUT':'','STDERR':'',}
let php_builtin['constants']['handling_file_uploads']={'UPLOAD_ERR_OK':'','UPLOAD_ERR_INI_SIZE':'','UPLOAD_ERR_FORM_SIZE':'','UPLOAD_ERR_PARTIAL':'','UPLOAD_ERR_NO_FILE':'','UPLOAD_ERR_NO_TMP_DIR':'','UPLOAD_ERR_CANT_WRITE':'','UPLOAD_ERR_EXTENSION':'',}
let php_builtin['constants']['fileinfo']={'FILEINFO_NONE':'','FILEINFO_SYMLINK':'','FILEINFO_MIME_TYPE':'','FILEINFO_MIME_ENCODING':'','FILEINFO_MIME':'','FILEINFO_COMPRESS':'','FILEINFO_DEVICES':'','FILEINFO_CONTINUE':'','FILEINFO_PRESERVE_ATIME':'','FILEINFO_RAW':'',}
let php_builtin['constants']['filesystem']={'SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','LOCK_SH':'','LOCK_EX':'','LOCK_UN':'','LOCK_NB':'','GLOB_BRACE':'','GLOB_ONLYDIR':'','GLOB_MARK':'','GLOB_NOSORT':'','GLOB_NOCHECK':'','GLOB_NOESCAPE':'','GLOB_AVAILABLE_FLAGS':'','PATHINFO_DIRNAME':'','PATHINFO_BASENAME':'','PATHINFO_EXTENSION':'','PATHINFO_FILENAME':'','FILE_USE_INCLUDE_PATH':'','FILE_NO_DEFAULT_CONTEXT':'','FILE_APPEND':'','FILE_IGNORE_NEW_LINES':'','FILE_SKIP_EMPTY_LINES':'','FILE_BINARY':'','FILE_TEXT':'','INI_SCANNER_NORMAL':'','INI_SCANNER_RAW':'','FNM_NOESCAPE':'','FNM_PATHNAME':'','FNM_PERIOD':'','FNM_CASEFOLD':'','GLOB_ERR':'',}
let php_builtin['constants']['filter']={'FILTER_FLAG_NO_ENCODE_QUOTES':'','INPUT_POST':'','INPUT_GET':'','INPUT_COOKIE':'','INPUT_ENV':'','INPUT_SERVER':'','INPUT_SESSION':'','INPUT_REQUEST':'','FILTER_FLAG_NONE':'','FILTER_REQUIRE_SCALAR':'','FILTER_REQUIRE_ARRAY':'','FILTER_FORCE_ARRAY':'','FILTER_NULL_ON_FAILURE':'','FILTER_VALIDATE_INT':'','FILTER_VALIDATE_BOOLEAN':'','FILTER_VALIDATE_FLOAT':'','FILTER_VALIDATE_REGEXP':'','FILTER_VALIDATE_URL':'','FILTER_VALIDATE_EMAIL':'','FILTER_VALIDATE_IP':'','FILTER_DEFAULT':'','FILTER_UNSAFE_RAW':'','FILTER_SANITIZE_STRING':'','FILTER_SANITIZE_STRIPPED':'','FILTER_SANITIZE_ENCODED':'','FILTER_SANITIZE_SPECIAL_CHARS':'','FILTER_SANITIZE_EMAIL':'','FILTER_SANITIZE_URL':'','FILTER_SANITIZE_NUMBER_INT':'','FILTER_SANITIZE_NUMBER_FLOAT':'','FILTER_SANITIZE_MAGIC_QUOTES':'','FILTER_CALLBACK':'','FILTER_FLAG_ALLOW_OCTAL':'','FILTER_FLAG_ALLOW_HEX':'','FILTER_FLAG_STRIP_LOW':'','FILTER_FLAG_STRIP_HIGH':'','FILTER_FLAG_ENCODE_LOW':'','FILTER_FLAG_ENCODE_HIGH':'','FILTER_FLAG_ENCODE_AMP':'','FILTER_FLAG_EMPTY_STRING_NULL':'','FILTER_FLAG_ALLOW_FRACTION':'','FILTER_FLAG_ALLOW_THOUSAND':'','FILTER_FLAG_ALLOW_SCIENTIFIC':'','FILTER_FLAG_PATH_REQUIRED':'','FILTER_FLAG_QUERY_REQUIRED':'','FILTER_FLAG_IPV4':'','FILTER_FLAG_IPV6':'','FILTER_FLAG_NO_RES_RANGE':'','FILTER_FLAG_NO_PRIV_RANGE':'','FILTER_SANITIZE_RAW':'','FILTER_SANITIZE_FULL_SPECIAL_CHARS':'','ENT_QUOTES':'',}
let php_builtin['constants']['php_options_info']={'ASSERT_CALLBACK':'','RUSAGE_CHILDREN':'','PHP_SAPI':'','PHP_OS':'','CREDITS_DOCS':'','CREDITS_GENERAL':'','CREDITS_GROUP':'','CREDITS_MODULES':'','CREDITS_FULLPAGE':'','PHP_VERSION_ID':'','PHP_VERSION':'','PATH_SEPARATOR':'','CREDITS_SAPI':'','CREDITS_QA':'','CREDITS_ALL':'','INFO_GENERAL':'','INFO_CREDITS':'','INFO_CONFIGURATION':'','INFO_MODULES':'','INFO_ENVIRONMENT':'','INFO_VARIABLES':'','INFO_LICENSE':'','INFO_ALL':'','ASSERT_ACTIVE':'','ASSERT_BAIL':'','ASSERT_WARNING':'','ASSERT_QUIET_EVAL':'','PHP_WINDOWS_VERSION_MAJOR':'','PHP_WINDOWS_VERSION_MINOR':'','PHP_WINDOWS_VERSION_BUILD':'','PHP_WINDOWS_VERSION_PLATFORM':'','PHP_WINDOWS_VERSION_SP_MAJOR':'','PHP_WINDOWS_VERSION_SP_MINOR':'','PHP_WINDOWS_VERSION_SUITEMASK':'','PHP_WINDOWS_VERSION_PRODUCTTYPE':'','PHP_WINDOWS_NT_DOMAIN_CONTROLLER':'','PHP_WINDOWS_NT_SERVER':'','PHP_WINDOWS_NT_WORKSTATION':'',}
let php_builtin['constants']['strings']={'CRYPT_SALT_LENGTH':'','CRYPT_STD_DES':'','CRYPT_EXT_DES':'','CRYPT_MD5':'','CRYPT_BLOWFISH':'','CRYPT_SHA256':'','CRYPT_SHA512':'','HTML_ENTITIES':'','HTML_SPECIALCHARS':'','ENT_COMPAT':'','ENT_QUOTES':'','ENT_NOQUOTES':'','ENT_HTML401':'','ENT_XML1':'','ENT_XHTML':'','ENT_HTML5':'','ENT_IGNORE':'','ENT_SUBSTITUTE':'','ENT_DISALLOWED':'','CHAR_MAX':'','LC_MONETARY':'','AM_STR':'','PM_STR':'','D_T_FMT':'','D_FMT':'','T_FMT':'','T_FMT_AMPM':'','ERA':'','ERA_YEAR':'','ERA_D_T_FMT':'','ERA_D_FMT':'','ERA_T_FMT':'','INT_CURR_SYMBOL':'','CURRENCY_SYMBOL':'','CRNCYSTR':'','MON_DECIMAL_POINT':'','MON_THOUSANDS_SEP':'','MON_GROUPING':'','POSITIVE_SIGN':'','NEGATIVE_SIGN':'','INT_FRAC_DIGITS':'','FRAC_DIGITS':'','P_CS_PRECEDES':'','P_SEP_BY_SPACE':'','N_CS_PRECEDES':'','N_SEP_BY_SPACE':'','P_SIGN_POSN':'','N_SIGN_POSN':'','DECIMAL_POINT':'','RADIXCHAR':'','THOUSANDS_SEP':'','THOUSEP':'','GROUPING':'','YESEXPR':'','NOEXPR':'','YESSTR':'','NOSTR':'','CODESET':'','LC_ALL':'','LC_COLLATE':'','LC_CTYPE':'','LC_NUMERIC':'','LC_TIME':'','LC_MESSAGES':'','PHP_INT_MAX':'','STR_PAD_RIGHT':'','STR_PAD_LEFT':'','STR_PAD_BOTH':'',}
let php_builtin['constants']['error_handling']={'DEBUG_BACKTRACE_PROVIDE_OBJECT':'','DEBUG_BACKTRACE_IGNORE_ARGS':'',}
let php_builtin['constants']['math']={'PHP_INT_MAX':'','M_PI':'','PHP_ROUND_HALF_UP':'','PHP_ROUND_HALF_DOWN':'','PHP_ROUND_HALF_EVEN':'','PHP_ROUND_HALF_ODD':'','M_E':'','M_LOG2E':'','M_LOG10E':'','M_LN2':'','M_LN10':'','M_PI_2':'','M_PI_4':'','M_1_PI':'','M_2_PI':'','M_SQRTPI':'','M_2_SQRTPI':'','M_SQRT2':'','M_SQRT3':'','M_SQRT1_2':'','M_LNPI':'','M_EULER':'','NAN':'','INF':'',}
let php_builtin['constants']['network']={'LOG_EMERG':'','LOG_ALERT':'','LOG_CRIT':'','LOG_ERR':'','LOG_WARNING':'','LOG_NOTICE':'','LOG_INFO':'','LOG_DEBUG':'','LOG_KERN':'','LOG_USER':'','LOG_MAIL':'','LOG_DAEMON':'','LOG_AUTH':'','LOG_SYSLOG':'','LOG_LPR':'','LOG_NEWS':'','LOG_CRON':'','LOG_AUTHPRIV':'','LOG_LOCAL0':'','LOG_LOCAL1':'','LOG_LOCAL2':'','LOG_LOCAL3':'','LOG_LOCAL4':'','LOG_LOCAL5':'','LOG_LOCAL6':'','LOG_LOCAL7':'','LOG_PID':'','LOG_CONS':'','LOG_ODELAY':'','LOG_NDELAY':'','LOG_NOWAIT':'','LOG_PERROR':'','DNS_A':'','DNS_CNAME':'','DNS_HINFO':'','DNS_MX':'','DNS_NS':'','DNS_PTR':'','DNS_SOA':'','DNS_TXT':'','DNS_AAAA':'','DNS_SRV':'','DNS_NAPTR':'','DNS_A6':'','DNS_ALL':'','DNS_ANY':'','SID':'','LOG_UUCP':'',}
let php_builtin['constants']['urls']={'PHP_QUERY_RFC1738':'','PHP_QUERY_RFC3986':'','PHP_URL_SCHEME':'','PHP_URL_HOST':'','PHP_URL_PORT':'','PHP_URL_USER':'','PHP_URL_PASS':'','PHP_URL_PATH':'','PHP_URL_QUERY':'','PHP_URL_FRAGMENT':'',}
let php_builtin['constants']['gd']={'IMAGETYPE_GIF':'','IMAGETYPE_JPEG':'','IMAGETYPE_PNG':'','IMAGETYPE_SWF':'','IMAGETYPE_PSD':'','IMAGETYPE_BMP':'','IMAGETYPE_TIFF_II':'','IMAGETYPE_TIFF_MM':'','IMAGETYPE_JPC':'','IMAGETYPE_JP2':'','IMAGETYPE_JPX':'','IMAGETYPE_JB2':'','IMAGETYPE_SWC':'','IMAGETYPE_IFF':'','IMAGETYPE_WBMP':'','IMAGETYPE_XBM':'','IMAGETYPE_ICO':'','IMG_CROP_THRESHOLD':'','IMG_ARC_PIE':'','IMG_ARC_CHORD':'','IMG_ARC_NOFILL':'','IMG_ARC_EDGED':'','IMG_FILTER_NEGATE':'','IMG_FILTER_GRAYSCALE':'','IMG_FILTER_BRIGHTNESS':'','IMG_FILTER_CONTRAST':'','IMG_FILTER_COLORIZE':'','IMG_FILTER_EDGEDETECT':'','IMG_FILTER_EMBOSS':'','IMG_FILTER_GAUSSIAN_BLUR':'','IMG_FILTER_SELECTIVE_BLUR':'','IMG_FILTER_MEAN_REMOVAL':'','IMG_FILTER_SMOOTH':'','IMG_FILTER_PIXELATE':'','IMG_FLIP_HORIZONTAL':'','IMG_FLIP_VERTICAL':'','IMG_FLIP_BOTH':'','IMG_GD2_RAW':'','IMG_GD2_COMPRESSED':'','IMG_EFFECT_REPLACE':'','IMG_EFFECT_ALPHABLEND':'','IMG_EFFECT_NORMAL':'','IMG_EFFECT_OVERLAY':'','PNG_NO_FILTER':'','PNG_ALL_FILTERS':'','IMG_NEAREST_NEIGHBOUR':'','IMG_BILINEAR_FIXED':'','IMG_BICUBIC':'','IMG_BICUBIC_FIXED':'','IMG_COLOR_BRUSHED':'','IMG_COLOR_STYLEDBRUSHED':'','IMG_BELL':'','IMG_BESSEL':'','IMG_BLACKMAN':'','IMG_BOX':'','IMG_BSPLINE':'','IMG_CATMULLROM':'','IMG_GAUSSIAN':'','IMG_GENERALIZED_CUBIC':'','IMG_HERMITE':'','IMG_HAMMING':'','IMG_HANNING':'','IMG_MITCHELL':'','IMG_POWER':'','IMG_QUADRATIC':'','IMG_SINC':'','IMG_WEIGHTED4':'','IMG_TRIANGLE':'','IMG_COLOR_STYLED':'','IMG_COLOR_TRANSPARENT':'','IMG_COLOR_TILED':'','IMG_GIF':'','IMG_JPG':'','IMG_PNG':'','IMG_WBMP':'','IMG_XPM':'','GD_VERSION':'','GD_MAJOR_VERSION':'','GD_MINOR_VERSION':'','GD_RELEASE_VERSION':'','GD_EXTRA_VERSION':'','GD_BUNDLED':'','IMG_JPEG':'','IMG_ARC_ROUNDED':'','IMAGETYPE_JPEG2000':'','PNG_FILTER_NONE':'','PNG_FILTER_SUB':'','PNG_FILTER_UP':'','PNG_FILTER_AVG':'','PNG_FILTER_PAETH':'',}
let php_builtin['constants']['json']={'JSON_BIGINT_AS_STRING':'','JSON_HEX_QUOT':'','JSON_HEX_TAG':'','JSON_HEX_AMP':'','JSON_HEX_APOS':'','JSON_NUMERIC_CHECK':'','JSON_PRETTY_PRINT':'','JSON_UNESCAPED_SLASHES':'','JSON_FORCE_OBJECT':'','JSON_UNESCAPED_UNICODE':'','JSON_ERROR_NONE':'','JSON_ERROR_DEPTH':'','JSON_ERROR_STATE_MISMATCH':'','JSON_ERROR_CTRL_CHAR':'','JSON_ERROR_SYNTAX':'','JSON_ERROR_UTF8':'','JSON_ERROR_RECURSION':'','JSON_ERROR_INF_OR_NAN':'','NAN':'','INF':'','JSON_ERROR_UNSUPPORTED_TYPE':'','JSON_PARTIAL_OUTPUT_ON_ERROR':'',}
let php_builtin['constants']['multibyte_string']={'MB_CASE_UPPER':'','MB_CASE_LOWER':'','MB_CASE_TITLE':'','MB_OVERLOAD_MAIL':'','MB_OVERLOAD_STRING':'','MB_OVERLOAD_REGEX':'',}
let php_builtin['constants']['mssql']={'SQLTEXT':'','SQLVARCHAR':'','SQLCHAR':'','SQLINT1':'','SQLINT2':'','SQLINT4':'','SQLBIT':'','SQLFLT4':'','SQLFLT8':'','SQLFLTN':'','MSSQL_ASSOC':'','MSSQL_NUM':'','MSSQL_BOTH':'',}
let php_builtin['constants']['mysql']={'MYSQL_CLIENT_SSL':'','MYSQL_CLIENT_COMPRESS':'','MYSQL_CLIENT_IGNORE_SPACE':'','MYSQL_CLIENT_INTERACTIVE':'','MYSQL_ASSOC':'','MYSQL_NUM':'','MYSQL_BOTH':'','MYSQL_PORT':'',}
let php_builtin['constants']['output_control']={'PHP_OUTPUT_HANDLER_STDFLAGS':'','PHP_OUTPUT_HANDLER_CLEANABLE':'','PHP_OUTPUT_HANDLER_FLUSHABLE':'','PHP_OUTPUT_HANDLER_REMOVABLE':'','PHP_OUTPUT_HANDLER_START':'','PHP_OUTPUT_HANDLER_WRITE':'','PHP_OUTPUT_HANDLER_FLUSH':'','PHP_OUTPUT_HANDLER_CLEAN':'','PHP_OUTPUT_HANDLER_FINAL':'','PHP_OUTPUT_HANDLER_CONT':'','PHP_OUTPUT_HANDLER_END':'',}
let php_builtin['constants']['password_hashing']={'PASSWORD_DEFAULT':'','PASSWORD_BCRYPT':'','CRYPT_BLOWFISH':'',}
let php_builtin['constants']['postgresql']={'PGSQL_CONNECT_FORCE_NEW':'','PGSQL_CONNECTION_OK':'','PGSQL_CONNECTION_BAD':'','PGSQL_CONV_IGNORE_DEFAULT':'','PGSQL_CONV_FORCE_NULL':'','PGSQL_CONV_IGNORE_NOT_NULL':'','PGSQL_DML_NO_CONV':'','PGSQL_DML_ESCAPE':'','PGSQL_DML_EXEC':'','PGSQL_DML_ASYNC':'','PGSQL_DML_STRING':'','PGSQL_ASSOC':'','PGSQL_NUM':'','PGSQL_BOTH':'','PGSQL_CONV_OPTS':'','INV_READ':'','INV_WRITE':'','INV_ARCHIVE':'','PGSQL_SEEK_SET':'','PGSQL_SEEK_CUR':'','PGSQL_SEEK_END':'','PGSQL_DIAG_SEVERITY':'','PGSQL_DIAG_SQLSTATE':'','PGSQL_DIAG_MESSAGE_PRIMARY':'','PGSQL_DIAG_MESSAGE_DETAIL':'','PGSQL_DIAG_MESSAGE_HINT':'','PGSQL_DIAG_STATEMENT_POSITION':'','PGSQL_DIAG_INTERNAL_POSITION':'','PGSQL_DIAG_INTERNAL_QUERY':'','PGSQL_DIAG_CONTEXT':'','PGSQL_DIAG_SOURCE_FILE':'','PGSQL_DIAG_SOURCE_LINE':'','PGSQL_DIAG_SOURCE_FUNCTION':'','PGSQL_STATUS_LONG':'','PGSQL_STATUS_STRING':'','PGSQL_EMPTY_QUERY':'','PGSQL_COMMAND_OK':'','PGSQL_TUPLES_OK':'','PGSQL_COPY_OUT':'','PGSQL_COPY_IN':'','PGSQL_BAD_RESPONSE':'','PGSQL_NONFATAL_ERROR':'','PGSQL_FATAL_ERROR':'','PGSQL_ERRORS_TERSE':'','PGSQL_ERRORS_DEFAULT':'','PGSQL_ERRORS_VERBOSE':'','PGSQL_TRANSACTION_IDLE':'','PGSQL_TRANSACTION_ACTIVE':'','PGSQL_TRANSACTION_INTRANS':'','PGSQL_TRANSACTION_INERROR':'','PGSQL_TRANSACTION_UNKNOWN':'','PG_DIAG_STATEMENT_POSITION':'','PG_DIAG_INTERNAL_QUERY':'',}
let php_builtin['constants']['pcre']={'PREG_GREP_INVERT':'','PREG_NO_ERROR':'','PREG_INTERNAL_ERROR':'','PREG_BACKTRACK_LIMIT_ERROR':'','PREG_RECURSION_LIMIT_ERROR':'','PREG_BAD_UTF8_ERROR':'','PREG_BAD_UTF8_OFFSET_ERROR':'','PREG_PATTERN_ORDER':'','PREG_SET_ORDER':'','PREG_OFFSET_CAPTURE':'','PREG_SPLIT_NO_EMPTY':'','PREG_SPLIT_DELIM_CAPTURE':'','PREG_SPLIT_OFFSET_CAPTURE':'','PCRE_VERSION':'',}
let php_builtin['constants']['program_execution']={'STDIN':'',}
let php_builtin['constants']['sessions']={'SID':'','PHP_SESSION_DISABLED':'','PHP_SESSION_NONE':'','PHP_SESSION_ACTIVE':'','UPLOAD_ERR_EXTENSION':'',}
let php_builtin['constants']['variable_handling']={'PHP_INT_MAX':'',}
let php_builtin['constants']['misc']={'WAIT_IO_COMPLETION':'','CONNECTION_ABORTED':'','CONNECTION_NORMAL':'','CONNECTION_TIMEOUT':'',}
let php_builtin['constants']['streams']={'STREAM_FILTER_READ':'','STREAM_FILTER_WRITE':'','STREAM_FILTER_ALL':'','PHP_INT_MAX':'','STREAM_CLIENT_CONNECT':'','STREAM_CLIENT_ASYNC_CONNECT':'','STREAM_CLIENT_PERSISTENT':'','STREAM_CRYPTO_METHOD_TLS_CLIENT':'','STREAM_CRYPTO_METHOD_TLS_SERVER':'','STREAM_PF_INET':'','STREAM_PF_INET6':'','STREAM_PF_UNIX':'','STREAM_SOCK_DGRAM':'','STREAM_SOCK_RAW':'','STREAM_SOCK_RDM':'','STREAM_SOCK_SEQPACKET':'','STREAM_SOCK_STREAM':'','STREAM_IPPROTO_ICMP':'','STREAM_IPPROTO_IP':'','STREAM_IPPROTO_RAW':'','STREAM_IPPROTO_TCP':'','STREAM_IPPROTO_UDP':'','STREAM_OOB':'','STREAM_PEEK':'','AF_INET':'','STREAM_SERVER_BIND':'','STREAM_SHUT_RD':'','STREAM_SHUT_WR':'','STREAM_SHUT_RDWR':'','STREAM_IS_URL':'','PSFS_PASS_ON':'','PSFS_FEED_ME':'','PSFS_ERR_FATAL':'','PSFS_FLAG_NORMAL':'','PSFS_FLAG_FLUSH_INC':'','PSFS_FLAG_FLUSH_CLOSE':'','STREAM_USE_PATH':'','STREAM_REPORT_ERRORS':'','STREAM_SERVER_LISTEN':'','STREAM_NOTIFY_RESOLVE':'','STREAM_NOTIFY_CONNECT':'','STREAM_NOTIFY_AUTH_REQUIRED':'','STREAM_NOTIFY_SEVERITY_ERR':'','STREAM_NOTIFY_MIME_TYPE_IS':'','STREAM_NOTIFY_FILE_SIZE_IS':'','STREAM_NOTIFY_REDIRECTED':'','STREAM_NOTIFY_PROGRESS':'','STREAM_NOTIFY_COMPLETED':'','STREAM_NOTIFY_FAILURE':'','STREAM_NOTIFY_AUTH_RESULT':'','STREAM_NOTIFY_SEVERITY_INFO':'','STREAM_NOTIFY_SEVERITY_WARN':'','STREAM_CAST_FOR_SELECT':'','STREAM_CAST_AS_STREAM':'','STREAM_META_TOUCH':'','STREAM_META_OWNER':'','STREAM_META_OWNER_NAME':'','STREAM_META_GROUP':'','STREAM_META_GROUP_NAME':'','STREAM_META_ACCESS':'','STREAM_MKDIR_RECURSIVE':'','LOCK_EX':'','LOCK_UN':'','LOCK_SH':'','LOCK_NB':'','SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','STREAM_OPTION_BLOCKING':'','STREAM_OPTION_READ_TIMEOUT':'','STREAM_OPTION_WRITE_BUFFER':'','STREAM_BUFFER_NONE':'','STREAM_BUFFER_FULL':'',}
let php_builtin['constants']['iconv']={'ICONV_IMPL':'','ICONV_VERSION':'','ICONV_MIME_DECODE_STRICT':'','ICONV_MIME_DECODE_CONTINUE_ON_ERROR':'',}
let php_builtin['constants']['phpini_directives']={'PATH_SEPARATOR':'','PHP_INI_SYSTEM':'',}
let php_builtin['constants']['types']={'NAN':'','PHP_INT_SIZE':'','PHP_INT_MAX':'',}
let php_builtin['constants']['pdo']={'PDO_PARAM_BOOL':'',}
let php_builtin['constants']['list_of_reserved_words']={'PHP_VERSION':'','PHP_MAJOR_VERSION':'','PHP_MINOR_VERSION':'','PHP_RELEASE_VERSION':'','PHP_VERSION_ID':'','PHP_EXTRA_VERSION':'','PHP_ZTS':'','PHP_DEBUG':'','PHP_MAXPATHLEN':'','PHP_OS':'','PHP_SAPI':'','PHP_EOL':'','PHP_INT_MAX':'','PHP_INT_SIZE':'','DEFAULT_INCLUDE_PATH':'','PEAR_INSTALL_DIR':'','PEAR_EXTENSION_DIR':'','PHP_EXTENSION_DIR':'','PHP_PREFIX':'','PHP_BINDIR':'','PHP_BINARY':'','PHP_MANDIR':'','PHP_LIBDIR':'','PHP_DATADIR':'','PHP_SYSCONFDIR':'','PHP_LOCALSTATEDIR':'','PHP_CONFIG_FILE_PATH':'','PHP_CONFIG_FILE_SCAN_DIR':'','PHP_SHLIB_SUFFIX':'',}
let php_builtin['constants']['php_type_comparison_tables']={'NAN':'',}

" Built in functions
let g:php_builtin_functions = {}
for [ext, data] in items(php_builtin['functions'])
	call extend(g:php_builtin_functions, data)
endfor

" Built in classs
let g:php_builtin_classes = {}
for [ext, data] in items(php_builtin['classes'])
	call extend(g:php_builtin_classes, data)
endfor

" Built in interfaces
let g:php_builtin_interfaces = {}
for [ext, data] in items(php_builtin['interfaces'])
	call extend(g:php_builtin_interfaces, data)
endfor

" Built in constants
let g:php_constants = {}
for [ext, data] in items(php_builtin['constants'])
	call extend(g:php_constants, data)
endfor

" When the classname not found or found but the tags dosen't contain that
" class we will try to complate any method of any builtin class. To speed up
" that lookup we compile a 'ClassName::MethodName':'info' dictionary from the
" builtin class informations
let g:php_builtin_object_functions = {}

" When completing for 'everyting imaginable' (no class context, not a
" variable) we need a list of built-in classes in a format of {'classname':''}
" for performance reasons we precompile this too
let g:php_builtin_classnames = {}

" In order to reduce file size, empty keys are omitted from class structures.
" To make the structure of in-memory hashes normalized we will add them in runtime
let required_class_hash_keys = ['constants', 'properties', 'static_properties', 'methods', 'static_methods']

for [classname, class_info] in items(g:php_builtin_classes)
	for property_name in required_class_hash_keys
		if !has_key(class_info, property_name)
			let class_info[property_name] = {}
		endif
	endfor

	let g:php_builtin_classnames[classname] = ''
	for [method_name, method_info] in items(class_info.methods)
		let g:php_builtin_object_functions[classname.'::'.method_name.'('] = method_info.signature
	endfor
	for [method_name, method_info] in items(class_info.static_methods)
		let g:php_builtin_object_functions[classname.'::'.method_name.'('] = method_info.signature
	endfor
endfor

let g:php_builtin_interfacenames = {}
for [interfacename, info] in items(g:php_builtin_interfaces)
	for property_name in required_class_hash_keys
		if !has_key(class_info, property_name)
			let class_info[property_name] = {}
		endif
	endfor

	let g:php_builtin_interfacenames[interfacename] = ''
	for [method_name, method_info] in items(class_info.methods)
		let g:php_builtin_object_functions[interfacename.'::'.method_name.'('] = method_info.signature
	endfor
	for [method_name, method_info] in items(class_info.static_methods)
		let g:php_builtin_object_functions[interfacename.'::'.method_name.'('] = method_info.signature
	endfor
endfor


" Add control structures (they are outside regular pattern of PHP functions)
let php_control = {
			\ 'include(': 'string filename | resource',
			\ 'include_once(': 'string filename | resource',
			\ 'require(': 'string filename | resource',
			\ 'require_once(': 'string filename | resource',
			\ }
call extend(g:php_builtin_functions, php_control)


" Built-in variables " {{{
let g:php_builtin_vars ={
			\ '$GLOBALS':'',
			\ '$_SERVER':'',
			\ '$_GET':'',
			\ '$_POST':'',
			\ '$_COOKIE':'',
			\ '$_FILES':'',
			\ '$_ENV':'',
			\ '$_REQUEST':'',
			\ '$_SESSION':'',
			\ '$HTTP_SERVER_VARS':'',
			\ '$HTTP_ENV_VARS':'',
			\ '$HTTP_COOKIE_VARS':'',
			\ '$HTTP_GET_VARS':'',
			\ '$HTTP_POST_VARS':'',
			\ '$HTTP_POST_FILES':'',
			\ '$HTTP_SESSION_VARS':'',
			\ '$php_errormsg':'',
			\ '$this':'',
			\ }
" }}}
endfunction
" }}}

" vim: foldmethod=marker:noexpandtab:ts=8:sts=4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " netrw.vim: Handles file transfer and remote directory listing across
"            AUTOLOAD SECTION
" Date:		May 13, 2014
" Version:	152
" Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
" GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
" Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
"               Permission is hereby granted to use and distribute this code,
"               with or without modifications, provided that this copyright
"               notice is copied with it. Like anything else that's free,
"               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
"               *as is* and come with no warranty of any kind, either
"               expressed or implied. By using this plugin, you agree that
"               in no event will the copyright holder be liable for any damages
"               resulting from the use of this software.
"redraw!|call DechoSep()|call inputsave()|call input("Press <cr> to continue")|call inputrestore()
"
"  But be doers of the Word, and not only hearers, deluding your own selves {{{1
"  (James 1:22 RSV)
" =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
" Load Once: {{{1
if &cp || exists("g:loaded_netrw")
  finish
endif
if v:version < 704 || !has("patch213")
 if !exists("s:needpatch213")
  echo "***sorry*** this version of netrw requires vim v7.4 with patch 213"
 endif
 let s:needpatch213= 1
 finish
endif
let g:loaded_netrw = "v152"
if !exists("s:NOTE")
 let s:NOTE    = 0
 let s:WARNING = 1
 let s:ERROR   = 2
endif

let s:keepcpo= &cpo
setl cpo&vim
"let g:dechofuncname=1
"DechoRemOn
"call Decho("doing autoload/netrw.vim version ".g:loaded_netrw)

" ======================
"  Netrw Variables: {{{1
" ======================

" ---------------------------------------------------------------------
" netrw#ErrorMsg: {{{2
"   0=note     = s:NOTE
"   1=warning  = s:WARNING
"   2=error    = s:ERROR
"  Apr 16, 2014 : max errnum currently is 97
fun! netrw#ErrorMsg(level,msg,errnum)
"  call Dfunc("netrw#ErrorMsg(level=".a:level." msg<".a:msg."> errnum=".a:errnum.") g:netrw_use_errorwindow=".g:netrw_use_errorwindow)

  if a:level < g:netrw_errorlvl
"   call Dret("netrw#ErrorMsg : suppressing level=".a:level." since g:netrw_errorlvl=".g:netrw_errorlvl)
   return
  endif

  if a:level == 1
   let level= "**warning** (netrw) "
  elseif a:level == 2
   let level= "**error** (netrw) "
  else
   let level= "**note** (netrw) "
  endif
"  call Decho("level=".level)

  if g:netrw_use_errorwindow
   " (default) netrw creates a one-line window to show error/warning
   " messages (reliably displayed)

   " record current window number for NetrwRestorePosn()'s benefit
   let s:winBeforeErr= winnr()
"   call Decho("s:winBeforeErr=".s:winBeforeErr)

   " getting messages out reliably is just plain difficult!
   " This attempt splits the current window, creating a one line window.
   if bufexists("NetrwMessage") && bufwinnr("NetrwMessage") > 0
"    call Decho("write to NetrwMessage buffer")
    exe bufwinnr("NetrwMessage")."wincmd w"
"    call Decho("setl ma noro")
    setl ma noro
    keepj call setline(line("$")+1,level.a:msg)
    keepj $
   else
"    call Decho("create a NetrwMessage buffer window")
    bo 1split
    sil! call s:NetrwEnew()
    sil! keepj call s:NetrwSafeOptions()
    setl bt=nofile
    keepj file NetrwMessage
"    call Decho("setl ma noro")
    setl ma noro
    call setline(line("$"),level.a:msg)
   endif
"   call Decho("wrote msg<".level.a:msg."> to NetrwMessage win#".winnr())
   if &fo !~ '[ta]'
    syn clear
    syn match netrwMesgNote	"^\*\*note\*\*"
    syn match netrwMesgWarning	"^\*\*warning\*\*"
    syn match netrwMesgError	"^\*\*error\*\*"
    hi link netrwMesgWarning WarningMsg
    hi link netrwMesgError   Error
   endif
"   call Decho("setl noma ro bh=wipe")
   setl ro nomod noma bh=wipe

  else
   " (optional) netrw will show messages using echomsg.  Even if the
   " message doesn't appear, at least it'll be recallable via :messages
"   redraw!
   if a:level == s:WARNING
    echohl WarningMsg
   elseif a:level == s:ERROR
    echohl Error
   endif
   echomsg level.a:msg
"   call Decho("echomsg ***netrw*** ".a:msg)
   echohl None
  endif

"  call Dret("netrw#ErrorMsg")
endfun

" ---------------------------------------------------------------------
" NetrwInit: initializes variables if they haven't been defined {{{2
"            Loosely,  varname = value.
fun s:NetrwInit(varname,value)
" call Decho("varname<".a:varname."> value=".a:value)
  if !exists(a:varname)
   if type(a:value) == 0
    exe "let ".a:varname."=".a:value
   elseif type(a:value) == 1 && a:value =~ '^[{[]'
    exe "let ".a:varname."=".a:value
   elseif type(a:value) == 1
    exe "let ".a:varname."="."'".a:value."'"
   else
    exe "let ".a:varname."=".a:value
   endif
  endif
endfun

" ---------------------------------------------------------------------
"  Netrw Constants: {{{2
call s:NetrwInit("g:netrw_dirhist_cnt",0)
if !exists("s:LONGLIST")
 call s:NetrwInit("s:THINLIST",0)
 call s:NetrwInit("s:LONGLIST",1)
 call s:NetrwInit("s:WIDELIST",2)
 call s:NetrwInit("s:TREELIST",3)
 call s:NetrwInit("s:MAXLIST" ,4)
endif

" ---------------------------------------------------------------------
" Default values for netrw's global protocol variables {{{2
call s:NetrwInit("g:netrw_use_errorwindow",1)

if !exists("g:netrw_dav_cmd")
 if executable("cadaver")
  let g:netrw_dav_cmd	= "cadaver"
 elseif executable("curl")
  let g:netrw_dav_cmd	= "curl"
 else
  let g:netrw_dav_cmd   = ""
 endif
endif
if !exists("g:netrw_fetch_cmd")
 if executable("fetch")
  let g:netrw_fetch_cmd	= "fetch -o"
 else
  let g:netrw_fetch_cmd	= ""
 endif
endif
if !exists("g:netrw_ftp_cmd")
  let g:netrw_ftp_cmd	= "ftp"
endif
let s:netrw_ftp_cmd= g:netrw_ftp_cmd
if !exists("g:netrw_ftp_options")
 let g:netrw_ftp_options= "-i -n"
endif
if !exists("g:netrw_http_cmd")
 if executable("elinks")
  let g:netrw_http_cmd = "elinks"
  call s:NetrwInit("g:netrw_http_xcmd","-source >")
 elseif executable("links")
  let g:netrw_http_cmd = "links"
  call s:NetrwInit("g:netrw_http_xcmd","-source >")
 elseif executable("curl")
  let g:netrw_http_cmd	= "curl"
  call s:NetrwInit("g:netrw_http_xcmd","-o")
 elseif executable("wget")
  let g:netrw_http_cmd	= "wget"
  call s:NetrwInit("g:netrw_http_xcmd","-q -O")
 elseif executable("fetch")
  let g:netrw_http_cmd	= "fetch"
  call s:NetrwInit("g:netrw_http_xcmd","-o")
 else
  let g:netrw_http_cmd	= ""
 endif
endif
call s:NetrwInit("g:netrw_http_put_cmd","curl -T")
call s:NetrwInit("g:netrw_rcp_cmd"  , "rcp")
call s:NetrwInit("g:netrw_rsync_cmd", "rsync")
if !exists("g:netrw_scp_cmd")
 if executable("scp")
  call s:NetrwInit("g:netrw_scp_cmd" , "scp -q")
 elseif executable("pscp")
  if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable('c:\private.ppk')
   call s:NetrwInit("g:netrw_scp_cmd", 'pscp -i c:\private.ppk')
  else
   call s:NetrwInit("g:netrw_scp_cmd", 'pscp -q')
  endif
 else
  call s:NetrwInit("g:netrw_scp_cmd" , "scp -q")
 endif
endif

call s:NetrwInit("g:netrw_sftp_cmd" , "sftp")
call s:NetrwInit("g:netrw_ssh_cmd"  , "ssh")

if (has("win32") || has("win95") || has("win64") || has("win16"))
  \ && exists("g:netrw_use_nt_rcp")
  \ && g:netrw_use_nt_rcp
  \ && executable( $SystemRoot .'/system32/rcp.exe')
 let s:netrw_has_nt_rcp = 1
 let s:netrw_rcpmode    = '-b'
else
 let s:netrw_has_nt_rcp = 0
 let s:netrw_rcpmode    = ''
endif

" ---------------------------------------------------------------------
" Default values for netrw's global variables {{{2
" Cygwin Detection ------- {{{3
if !exists("g:netrw_cygwin")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if  has("win32unix") && &shell =~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$'
   let g:netrw_cygwin= 1
  else
   let g:netrw_cygwin= 0
  endif
 else
  let g:netrw_cygwin= 0
 endif
endif
" Default values - a-c ---------- {{{3
call s:NetrwInit("g:netrw_alto"        , &sb)
call s:NetrwInit("g:netrw_altv"        , &spr)
call s:NetrwInit("g:netrw_banner"      , 1)
call s:NetrwInit("g:netrw_browse_split", 0)
call s:NetrwInit("g:netrw_bufsettings" , "noma nomod nonu nobl nowrap ro nornu")
call s:NetrwInit("g:netrw_chgwin"      , -1)
call s:NetrwInit("g:netrw_compress"    , "gzip")
call s:NetrwInit("g:netrw_ctags"       , "ctags")
if exists("g:netrw_cursorline") && !exists("g:netrw_cursor")
 call netrw#ErrorMsg(s:NOTE,'g:netrw_cursorline is deprecated; use g:netrw_cursor instead',77)
 let g:netrw_cursor= g:netrw_cursorline
endif
call s:NetrwInit("g:netrw_cursor"      , 2)
let s:netrw_usercul = &cursorline
let s:netrw_usercuc = &cursorcolumn
call s:NetrwInit("g:netrw_cygdrive","/cygdrive")
" Default values - d-g ---------- {{{3
call s:NetrwInit("s:didstarstar",0)
call s:NetrwInit("g:netrw_dirhist_cnt"      , 0)
call s:NetrwInit("g:netrw_decompress"       , '{ ".gz" : "gunzip", ".bz2" : "bunzip2", ".zip" : "unzip", ".tar" : "tar -xf", ".xz" : "unxz" }')
call s:NetrwInit("g:netrw_dirhistmax"       , 10)
call s:NetrwInit("g:netrw_errorlvl"  , s:NOTE)
call s:NetrwInit("g:netrw_fastbrowse"       , 1)
call s:NetrwInit("g:netrw_ftp_browse_reject", '^total\s\+\d\+$\|^Trying\s\+\d\+.*$\|^KERBEROS_V\d rejected\|^Security extensions not\|No such file\|: connect to address [0-9a-fA-F:]*: No route to host$')
if !exists("g:netrw_ftp_list_cmd")
 if has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin)
  let g:netrw_ftp_list_cmd     = "ls -lF"
  let g:netrw_ftp_timelist_cmd = "ls -tlF"
  let g:netrw_ftp_sizelist_cmd = "ls -slF"
 else
  let g:netrw_ftp_list_cmd     = "dir"
  let g:netrw_ftp_timelist_cmd = "dir"
  let g:netrw_ftp_sizelist_cmd = "dir"
 endif
endif
call s:NetrwInit("g:netrw_ftpmode",'binary')
" Default values - h-lh ---------- {{{3
call s:NetrwInit("g:netrw_hide",1)
if !exists("g:netrw_ignorenetrc")
 if &shell =~ '\c\<\%(cmd\|4nt\)\.exe$'
  let g:netrw_ignorenetrc= 1
 else
  let g:netrw_ignorenetrc= 0
 endif
endif
call s:NetrwInit("g:netrw_keepdir",1)
if !exists("g:netrw_list_cmd")
 if g:netrw_scp_cmd =~ '^pscp' && executable("pscp")
  if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable("c:\\private.ppk")
   " provide a pscp-based listing command
   let g:netrw_scp_cmd ="pscp -i C:\\private.ppk"
  endif
  let g:netrw_list_cmd= g:netrw_scp_cmd." -ls USEPORT HOSTNAME:"
 elseif executable(g:netrw_ssh_cmd)
  " provide a scp-based default listing command
  let g:netrw_list_cmd= g:netrw_ssh_cmd." USEPORT HOSTNAME ls -FLa"
 else
"  call Decho("g:netrw_ssh_cmd." is not executable")
  let g:netrw_list_cmd= ""
 endif
endif
call s:NetrwInit("g:netrw_list_hide","")
" Default values - lh-lz ---------- {{{3
if exists("g:netrw_local_copycmd")
 let g:netrw_localcopycmd= g:netrw_local_copycmd
 call netrw#ErrorMsg(s:NOTE,"g:netrw_local_copycmd is deprecated in favor of g:netrw_localcopycmd",84)
endif
if !exists("g:netrw_localcmdshell")
 let g:netrw_localcmdshell= ""
endif
if !exists("g:netrw_localcopycmd")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   let g:netrw_localcopycmd= "cp"
  else
   let g:netrw_localcopycmd= expand("$COMSPEC")." /c copy"
  endif
 elseif has("unix") || has("macunix")
  let g:netrw_localcopycmd= "cp"
 else
  let g:netrw_localcopycmd= ""
 endif
endif
if exists("g:netrw_local_mkdir")
 let g:netrw_localmkdir= g:netrw_local_mkdir
 call netrw#ErrorMsg(s:NOTE,"g:netrw_local_mkdir is deprecated in favor of g:netrw_localmkdir",87)
endif
if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   call s:NetrwInit("g:netrw_localmkdir","mkdir")
  else
   let g:netrw_localmkdir= expand("$COMSPEC")." /c mkdir"
  endif
else
 call s:NetrwInit("g:netrw_localmkdir","mkdir")
endif
call s:NetrwInit("g:netrw_remote_mkdir","mkdir")
if exists("g:netrw_local_movecmd")
 let g:netrw_localmovecmd= g:netrw_local_movecmd
 call netrw#ErrorMsg(s:NOTE,"g:netrw_local_movecmd is deprecated in favor of g:netrw_localmovecmd",88)
endif
if !exists("g:netrw_localmovecmd")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   let g:netrw_localmovecmd= "mv"
  else
   let g:netrw_localmovecmd= expand("$COMSPEC")." /c move"
  endif
 elseif has("unix") || has("macunix")
  let g:netrw_localmovecmd= "mv"
 else
  let g:netrw_localmovecmd= ""
 endif
endif
if exists("g:netrw_local_rmdir")
 let g:netrw_localrmdir= g:netrw_local_rmdir
 call netrw#ErrorMsg(s:NOTE,"g:netrw_local_rmdir is deprecated in favor of g:netrw_localrmdir",86)
endif
if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   call s:NetrwInit("g:netrw_localrmdir","rmdir")
  else
   let g:netrw_localrmdir= expand("$COMSPEC")." /c rmdir"
  endif
else
 call s:NetrwInit("g:netrw_localrmdir","rmdir")
endif
call s:NetrwInit("g:netrw_liststyle"  , s:THINLIST)
" sanity checks
if g:netrw_liststyle < 0 || g:netrw_liststyle >= s:MAXLIST
 let g:netrw_liststyle= s:THINLIST
endif
if g:netrw_liststyle == s:LONGLIST && g:netrw_scp_cmd !~ '^pscp'
 let g:netrw_list_cmd= g:netrw_list_cmd." -l"
endif
" Default values - m-r ---------- {{{3
call s:NetrwInit("g:netrw_markfileesc"   , '*./[\~')
call s:NetrwInit("g:netrw_maxfilenamelen", 32)
call s:NetrwInit("g:netrw_menu"          , 1)
call s:NetrwInit("g:netrw_mkdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME mkdir")
call s:NetrwInit("g:netrw_mousemaps"     , (exists("+mouse") && &mouse =~ '[anh]'))
call s:NetrwInit("g:netrw_retmap"        , 0)
if has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin)
 call s:NetrwInit("g:netrw_chgperm"       , "chmod PERM FILENAME")
elseif has("win32") || has("win95") || has("win64") || has("win16")
 call s:NetrwInit("g:netrw_chgperm"       , "cacls FILENAME /e /p PERM")
else
 call s:NetrwInit("g:netrw_chgperm"       , "chmod PERM FILENAME")
endif
call s:NetrwInit("g:netrw_preview"       , 0)
call s:NetrwInit("g:netrw_scpport"       , "-P")
call s:NetrwInit("g:netrw_sshport"       , "-p")
call s:NetrwInit("g:netrw_rename_cmd"    , g:netrw_ssh_cmd." USEPORT HOSTNAME mv")
call s:NetrwInit("g:netrw_rm_cmd"        , g:netrw_ssh_cmd." USEPORT HOSTNAME rm")
call s:NetrwInit("g:netrw_rmdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME rmdir")
call s:NetrwInit("g:netrw_rmf_cmd"       , g:netrw_ssh_cmd." USEPORT HOSTNAME rm -f ")
" Default values - q-s ---------- {{{3
call s:NetrwInit("g:netrw_quickhelp",0)
let s:QuickHelp= ["-:go up dir  D:delete  R:rename  s:sort-by  x:special",
   \              "%:create new file  d:create new directory",
   \              "o:split&open  v:vert-split&open",
   \              "i:style  qf:file info  O:obtain  r:reverse  p:preview",
   \              "mf:mark file  mt:set target  mm:move  mc:copy",
   \              "-bookmarks-  mb:make  mB:delete  qb:list  gb:go to",
   \              "-history-  qb:list  u:go up  U:go down",
   \              "-targets-  mt:target Tb:use bookmark  Th:use history"]
" g:netrw_sepchr: picking a character that doesn't appear in filenames that can be used to separate priority from filename
call s:NetrwInit("g:netrw_sepchr"        , (&enc == "euc-jp")? "\<Char-0x01>" : "\<Char-0xff>")
call s:NetrwInit("s:netrw_silentxfer"    , (exists("g:netrw_silent") && g:netrw_silent != 0)? "sil keepj " : "keepj ")
call s:NetrwInit("g:netrw_sort_by"       , "name") " alternatives: date                                      , size
call s:NetrwInit("g:netrw_sort_options"  , "")
call s:NetrwInit("g:netrw_sort_direction", "normal") " alternative: reverse  (z y x ...)
if !exists("g:netrw_sort_sequence")
 if has("unix")
  let g:netrw_sort_sequence= '[\/]$,\<core\%(\.\d\+\)\=\>,\.h$,\.c$,\.cpp$,\~\=\*$,*,\.o$,\.obj$,\.info$,\.swp$,\.bak$,\~$'
 else
  let g:netrw_sort_sequence= '[\/]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,\.info$,\.swp$,\.bak$,\~$'
 endif
endif
call s:NetrwInit("g:netrw_special_syntax"   , 0)
call s:NetrwInit("g:netrw_ssh_browse_reject", '^total\s\+\d\+$')
call s:NetrwInit("g:netrw_use_noswf"        , 1)
" Default values - t-w ---------- {{{3
call s:NetrwInit("g:netrw_timefmt","%c")
if !exists("g:netrw_xstrlen")
 if exists("g:Align_xstrlen")
  let g:netrw_xstrlen= g:Align_xstrlen
 elseif exists("g:drawit_xstrlen")
  let g:netrw_xstrlen= g:drawit_xstrlen
 elseif &enc == "latin1" || !has("multi_byte")
  let g:netrw_xstrlen= 0
 else
  let g:netrw_xstrlen= 1
 endif
endif
call s:NetrwInit("g:NetrwTopLvlMenu","Netrw.")
call s:NetrwInit("g:netrw_win95ftp",1)
call s:NetrwInit("g:netrw_winsize",50)
if g:netrw_winsize > 100|let g:netrw_winsize= 100|endif
" ---------------------------------------------------------------------
" Default values for netrw's script variables: {{{2
call s:NetrwInit("g:netrw_fname_escape",' ?&;%')
if has("win32") || has("win95") || has("win64") || has("win16")
 call s:NetrwInit("g:netrw_glob_escape",'*?`{[]$')
else
 call s:NetrwInit("g:netrw_glob_escape",'*[]?`{~$\')
endif
call s:NetrwInit("g:netrw_menu_escape",'.&? \')
call s:NetrwInit("g:netrw_tmpfile_escape",' &;')
call s:NetrwInit("s:netrw_map_escape","<|\n\r\\\<C-V>\"")
if has("gui_running") && (&enc == 'utf-8' || &enc == 'utf-16' || &enc == 'ucs-4')
 let s:treedepthstring= "│ "
else
 let s:treedepthstring= "| "
endif

" BufEnter event ignored by decho when following variable is true
"  Has a side effect that doau BufReadPost doesn't work, so
"  files read by network transfer aren't appropriately highlighted.
"let g:decho_bufenter = 1	"Decho

" ======================
"  Netrw Initialization: {{{1
" ======================
if v:version >= 700 && has("balloon_eval") && !exists("s:initbeval") && !exists("g:netrw_nobeval") && has("syntax") && exists("g:syntax_on")
" call Decho("installed beval events")
 let &l:bexpr = "netrw#BalloonHelp()"
 au FileType netrw	setl beval
 au WinLeave *		if &ft == "netrw" && exists("s:initbeval")|let &beval= s:initbeval|endif
 au VimEnter * 		let s:initbeval= &beval
"else " Decho
" if v:version < 700           | call Decho("did not install beval events: v:version=".v:version." < 700")     | endif
" if !has("balloon_eval")      | call Decho("did not install beval events: does not have balloon_eval")        | endif
" if exists("s:initbeval")     | call Decho("did not install beval events: s:initbeval exists")                | endif
" if exists("g:netrw_nobeval") | call Decho("did not install beval events: g:netrw_nobeval exists")            | endif
" if !has("syntax")            | call Decho("did not install beval events: does not have syntax highlighting") | endif
" if exists("g:syntax_on")     | call Decho("did not install beval events: g:syntax_on exists")                | endif
endif
au WinEnter *	if &ft == "netrw"|call s:NetrwInsureWinVars()|endif

" ==============================
"  Netrw Utility Functions: {{{1
" ==============================

" ---------------------------------------------------------------------
" netrw#BalloonHelp: {{{2
if v:version >= 700 && has("balloon_eval") && has("syntax") && exists("g:syntax_on") && !exists("g:netrw_nobeval")
" call Decho("loading netrw#BalloonHelp()")
 fun! netrw#BalloonHelp()
   if &ft != "netrw"
    return ""
   endif
   if !exists("w:netrw_bannercnt") || v:beval_lnum >= w:netrw_bannercnt || (exists("g:netrw_nobeval") && g:netrw_nobeval)
    let mesg= ""
   elseif     v:beval_text == "Netrw" || v:beval_text == "Directory" || v:beval_text == "Listing"
    let mesg = "i: thin-long-wide-tree  gh: quick hide/unhide of dot-files   qf: quick file info  %:open new file"
   elseif     getline(v:beval_lnum) =~ '^"\s*/'
    let mesg = "<cr>: edit/enter   o: edit/enter in horiz window   t: edit/enter in new tab   v:edit/enter in vert window"
   elseif     v:beval_text == "Sorted" || v:beval_text == "by"
    let mesg = 's: sort by name, time, or file size   r: reverse sorting order   mt: mark target'
   elseif v:beval_text == "Sort"   || v:beval_text == "sequence"
    let mesg = "S: edit sorting sequence"
   elseif v:beval_text == "Hiding" || v:beval_text == "Showing"
    let mesg = "a: hiding-showing-all   ctrl-h: editing hiding list   mh: hide/show by suffix"
   elseif v:beval_text == "Quick" || v:beval_text == "Help"
    let mesg = "Help: press <F1>"
   elseif v:beval_text == "Copy/Move" || v:beval_text == "Tgt"
    let mesg = "mt: mark target   mc: copy marked file to target   mm: move marked file to target"
   else
    let mesg= ""
   endif
   return mesg
 endfun
"else " Decho
" if v:version < 700            |call Decho("did not load netrw#BalloonHelp(): vim version ".v:version." < 700 -")|endif
" if !has("balloon_eval")       |call Decho("did not load netrw#BalloonHelp(): does not have balloon eval")       |endif
" if !has("syntax")             |call Decho("did not load netrw#BalloonHelp(): syntax disabled")                  |endif
" if !exists("g:syntax_on")     |call Decho("did not load netrw#BalloonHelp(): g:syntax_on=".g:syntax_on)         |endif
" if  exists("g:netrw_nobeval") |call Decho("did not load netrw#BalloonHelp(): g:netrw_nobeval exists")           |endif
endif

" ------------------------------------------------------------------------
" netrw#Explore: launch the local browser in the directory of the current file {{{2
"          indx:  == -1: Nexplore
"                 == -2: Pexplore
"                 ==  +: this is overloaded:
"                      * If Nexplore/Pexplore is in use, then this refers to the
"                        indx'th item in the w:netrw_explore_list[] of items which
"                        matched the */pattern **/pattern *//pattern **//pattern
"                      * If Hexplore or Vexplore, then this will override
"                        g:netrw_winsize to specify the qty of rows or columns the
"                        newly split window should have.
"          dosplit==0: the window will be split iff the current file has been modified and hidden not set
"          dosplit==1: the window will be split before running the local browser
"          style == 0: Explore     style == 1: Explore!
"                == 2: Hexplore    style == 3: Hexplore!
"                == 4: Vexplore    style == 5: Vexplore!
"                == 6: Texplore
fun! netrw#Explore(indx,dosplit,style,...)
"  call Dfunc("netrw#Explore(indx=".a:indx." dosplit=".a:dosplit." style=".a:style.",a:1<".a:1.">) &modified=".&modified." modifiable=".&modifiable." a:0=".a:0." win#".winnr()." buf#".bufnr("%"))
  if !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
"   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)")
  endif

  " record current file for Rexplore's benefit
  if &ft != "netrw"
   let w:netrw_rexfile= expand("%:p")
  endif

  " record current directory
  let curdir     = simplify(b:netrw_curdir)
  let curfiledir = substitute(expand("%:p"),'^\(.*[/\\]\)[^/\\]*$','\1','e')
  if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
   let curdir= substitute(curdir,'\','/','g')
  endif
"  call Decho("curdir<".curdir.">  curfiledir<".curfiledir.">")

  " using completion, directories with spaces in their names (thanks, Bill Gates, for a truly dumb idea)
  " will end up with backslashes here.  Solution: strip off backslashes that precede white space and
  " try Explore again.
  if a:0 > 0
"   call Decho('considering retry: a:1<'.a:1.'>: '.
     \ ((a:1 =~ "\\\s")?     'has backslash whitespace' : 'does not have backslash whitespace').', '.
     \ ((filereadable(a:1))? 'is readable'              : 'is not readable').', '.
     \ ((isdirectory(a:1))?  'is a directory'           : 'is not a directory'))
   if a:1 =~ "\\\s" && !filereadable(a:1) && !isdirectory(a:1)
"    call Decho("re-trying Explore with <".substitute(a:1,'\\\(\s\)','\1','g').">")
    call netrw#Explore(a:indx,a:dosplit,a:style,substitute(a:1,'\\\(\s\)','\1','g'))
"    call Dret("netrw#Explore : returning from retry")
    return
"   else " Decho
"    call Decho("retry not needed")
   endif
  endif

  " save registers
  if has("clipboard")
   sil! let keepregstar = @*
   sil! let keepregplus = @+
  endif
  sil! let keepregslash= @/

  " if   dosplit
  " -or- file has been modified AND file not hidden when abandoned
  " -or- Texplore used
  if a:dosplit || (&modified && &hidden == 0 && &bufhidden != "hide") || a:style == 6
"   call Decho("case dosplit=".a:dosplit." modified=".&modified." a:style=".a:style.": dosplit or file has been modified")
   call s:SaveWinVars()
   let winsz= g:netrw_winsize
   if a:indx > 0
    let winsz= a:indx
   endif

   if a:style == 0      " Explore, Sexplore
"    call Decho("style=0: Explore or Sexplore")
    let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "noswapfile ".winsz."wincmd s"
"    call Decho("exe noswapfile ".winsz."wincmd s")

   elseif a:style == 1  "Explore!, Sexplore!
"    call Decho("style=1: Explore! or Sexplore!")
    let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile ".winsz."wincmd v"
"    call Decho("exe keepalt noswapfile ".winsz."wincmd v")

   elseif a:style == 2  " Hexplore
"    call Decho("style=2: Hexplore")
    let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile bel ".winsz."wincmd s"
"    call Decho("exe keepalt noswapfile bel ".winsz."wincmd s")

   elseif a:style == 3  " Hexplore!
"    call Decho("style=3: Hexplore!")
    let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile abo ".winsz."wincmd s"
"    call Decho("exe keepalt noswapfile abo ".winsz."wincmd s")

   elseif a:style == 4  " Vexplore
"    call Decho("style=4: Vexplore")
    let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile lefta ".winsz."wincmd v"
"    call Decho("exe keepalt noswapfile lefta ".winsz."wincmd v")

   elseif a:style == 5  " Vexplore!
"    call Decho("style=5: Vexplore!")
    let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile rightb ".winsz."wincmd v"
"    call Decho("exe keepalt noswapfile rightb ".winsz."wincmd v")

   elseif a:style == 6  " Texplore
    call s:SaveBufVars()
"    call Decho("style  = 6: Texplore")
    exe "keepalt tabnew ".fnameescape(curdir)
"    call Decho("exe keepalt tabnew ".fnameescape(curdir))
    call s:RestoreBufVars()
   endif
   call s:RestoreWinVars()
"  else " Decho
"   call Decho("case a:dosplit=".a:dosplit." AND modified=".&modified." AND a:style=".a:style." is not 6")
  endif
  keepj norm! 0

  if a:0 > 0
"   call Decho("case [a:0=".a:0."] > 0: a:1<".a:1.">")
   if a:1 =~ '^\~' && (has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin))
"    call Decho("..case a:1<".a:1.">: starts with ~ and unix or cygwin")
    let dirname= simplify(substitute(a:1,'\~',expand("$HOME"),''))
"    call Decho("..using dirname<".dirname.">  (case: ~ && unix||cygwin)")
   elseif a:1 == '.'
"    call Decho("..case a:1<".a:1.">: matches .")
    let dirname= simplify(exists("b:netrw_curdir")? b:netrw_curdir : getcwd())
    if dirname !~ '/$'
     let dirname= dirname."/"
    endif
"    call Decho("..using dirname<".dirname.">  (case: ".(exists("b:netrw_curdir")? "b:netrw_curdir" : "getcwd()").")")
   elseif a:1 =~ '\$'
"    call Decho("..case a:1<".a:1.">: matches ending $")
    let dirname= simplify(expand(a:1))
"    call Decho("..using user-specified dirname<".dirname."> with $env-var")
   elseif a:1 !~ '^\*\{1,2}/' && a:1 !~ '^\a\{3,}://'
"    call Decho("..case a:1<".a:1.">: other, not pattern or filepattern")
    let dirname= simplify(a:1)
"    call Decho("..using user-specified dirname<".dirname.">")
   else
"    call Decho("..case a:1: pattern or filepattern")
    let dirname= a:1
   endif
  else
   " clear explore
"   call Decho("case a:0=".a:0.": clearing Explore list")
   call s:NetrwClearExplore()
"   call Dret("netrw#Explore : cleared list")
   return
  endif

"  call Decho("dirname<".dirname.">")
  if dirname =~ '\.\./\=$'
   let dirname= simplify(fnamemodify(dirname,':p:h'))
  elseif dirname =~ '\.\.' || dirname == '.'
   let dirname= simplify(fnamemodify(dirname,':p'))
  endif
"  call Decho("dirname<".dirname.">  (after simplify)")

  if dirname =~ '^\*//'
   " starpat=1: Explore *//pattern   (current directory only search for files containing pattern)
"   call Decho("case starpat=1: Explore *//pattern")
   let pattern= substitute(dirname,'^\*//\(.*\)$','\1','')
   let starpat= 1
"   call Decho("..Explore *//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">")
   if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

  elseif dirname =~ '^\*\*//'
   " starpat=2: Explore **//pattern  (recursive descent search for files containing pattern)
"   call Decho("case starpat=2: Explore **//pattern")
   let pattern= substitute(dirname,'^\*\*//','','')
   let starpat= 2
"   call Decho("..Explore **//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">")

  elseif dirname =~ '/\*\*/'
   " handle .../**/.../filepat
"   call Decho("case starpat=4: Explore .../**/.../filepat")
   let prefixdir= substitute(dirname,'^\(.\{-}\)\*\*.*$','\1','')
   if prefixdir =~ '^/' || (prefixdir =~ '^\a:/' && (has("win32") || has("win95") || has("win64") || has("win16")))
    let b:netrw_curdir = prefixdir
   else
    let b:netrw_curdir= getcwd().'/'.prefixdir
   endif
   let dirname= substitute(dirname,'^.\{-}\(\*\*/.*\)$','\1','')
   let starpat= 4
"   call Decho("..pwd<".getcwd()."> dirname<".dirname.">")
"   call Decho("..case Explore ../**/../filepat (starpat=".starpat.")")

  elseif dirname =~ '^\*/'
   " case starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
   let starpat= 3
"   call Decho("case starpat=3: Explore */filepat (starpat=".starpat.")")

  elseif dirname=~ '^\*\*/'
   " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
   let starpat= 4
"   call Decho("case starpat=4: Explore **/filepat (starpat=".starpat.")")

  else
   let starpat= 0
"   call Decho("case starpat=0: default")
  endif

  if starpat == 0 && a:indx >= 0
   " [Explore Hexplore Vexplore Sexplore] [dirname]
"   call Decho("case starpat==0 && a:indx=".a:indx.": dirname<".dirname.">, handles Explore Hexplore Vexplore Sexplore")
   if dirname == ""
    let dirname= curfiledir
"    call Decho("..empty dirname, using current file's directory<".dirname.">")
   endif
   if dirname =~ '^scp://' || dirname =~ '^ftp://'
    call netrw#Nread(2,dirname)
    "call s:NetrwBrowse(0,dirname)
   else
    if dirname == ""
     let dirname= getcwd()
    elseif (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
     " Windows : check for a drive specifier, or else for a remote share name ('\\Foo' or '//Foo', 
     " depending on whether backslashes have been converted to forward slashes by earlier code).
     if dirname !~ '^[a-zA-Z]:' && dirname !~ '^\\\\\w\+' && dirname !~ '^//\w\+'
      let dirname= b:netrw_curdir."/".dirname
     endif
    elseif dirname !~ '^/'
     let dirname= b:netrw_curdir."/".dirname
    endif
"    call Decho("..calling LocalBrowseCheck(dirname<".dirname.">)")
    call netrw#LocalBrowseCheck(dirname)
"    call Decho("win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
   endif
   if exists("w:netrw_bannercnt")
    " done to handle P08-Ingelrest. :Explore will _Always_ go to the line just after the banner.
    " If one wants to return the same place in the netrw window, use :Rex instead.
    exe w:netrw_bannercnt
   endif

"   call Decho("curdir<".curdir.">")
   " ---------------------------------------------------------------------
   " Jan 24, 2013: not sure why the following was present.  See P08-Ingelrest
"   if has("win32") || has("win95") || has("win64") || has("win16")
"    keepj call search('\<'.substitute(curdir,'^.*[/\\]','','e').'\>','cW')
"   else
"    keepj call search('\<'.substitute(curdir,'^.*/','','e').'\>','cW')
"   endif
   " ---------------------------------------------------------------------

  " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
  " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
  " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
  " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
  elseif a:indx <= 0
   " Nexplore, Pexplore, Explore: handle starpat
"   call Decho("case a:indx<=0: Nexplore, Pexplore, <s-down>, <s-up> starpat=".starpat." a:indx=".a:indx)
   if !mapcheck("<s-up>","n") && !mapcheck("<s-down>","n") && exists("b:netrw_curdir")
"    call Decho("..set up <s-up> and <s-down> maps")
    let s:didstarstar= 1
    nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
    nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
   endif

   if has("path_extra")
"    call Decho("..starpat=".starpat.": has +path_extra")
    if !exists("w:netrw_explore_indx")
     let w:netrw_explore_indx= 0
    endif

    let indx = a:indx
"    call Decho("..starpat=".starpat.": set indx= [a:indx=".indx."]")

    if indx == -1
     " Nexplore
"     call Decho("..case Nexplore with starpat=".starpat.": (indx=".indx.")")
     if !exists("w:netrw_explore_list") " sanity check
      keepj call netrw#ErrorMsg(s:WARNING,"using Nexplore or <s-down> improperly; see help for netrw-starstar",40)
      if has("clipboard")
       sil! let @* = keepregstar
       sil! let @+ = keepregstar
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore")
      return
     endif
     let indx= w:netrw_explore_indx
     if indx < 0                        | let indx= 0                           | endif
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
     let curfile= w:netrw_explore_list[indx]
"     call Decho("....indx=".indx." curfile<".curfile.">")
     while indx < w:netrw_explore_listlen && curfile == w:netrw_explore_list[indx]
      let indx= indx + 1
"      call Decho("....indx=".indx." (Nexplore while loop)")
     endwhile
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
"     call Decho("....Nexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx)

    elseif indx == -2
     " Pexplore
"     call Decho("case Pexplore with starpat=".starpat.": (indx=".indx.")")
     if !exists("w:netrw_explore_list") " sanity check
      keepj call netrw#ErrorMsg(s:WARNING,"using Pexplore or <s-up> improperly; see help for netrw-starstar",41)
      if has("clipboard")
       sil! let @* = keepregstar
       sil! let @+ = keepregstar
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore")
      return
     endif
     let indx= w:netrw_explore_indx
     if indx < 0                        | let indx= 0                           | endif
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
     let curfile= w:netrw_explore_list[indx]
"     call Decho("....indx=".indx." curfile<".curfile.">")
     while indx >= 0 && curfile == w:netrw_explore_list[indx]
      let indx= indx - 1
"      call Decho("....indx=".indx." (Pexplore while loop)")
     endwhile
     if indx < 0                        | let indx= 0                           | endif
"     call Decho("....Pexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx)

    else
     " Explore -- initialize
     " build list of files to Explore with Nexplore/Pexplore
"     call Decho("..starpat=".starpat.": case Explore: initialize (indx=".indx.")")
     keepj keepalt call s:NetrwClearExplore()
     let w:netrw_explore_indx= 0
     if !exists("b:netrw_curdir")
      let b:netrw_curdir= getcwd()
     endif
"     call Decho("....starpat=".starpat.": b:netrw_curdir<".b:netrw_curdir.">")

     " switch on starpat to build the w:netrw_explore_list of files
     if starpat == 1
      " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
"      call Decho("..case starpat=".starpat.": build *//pattern list  (curdir-only srch for files containing pattern)  &hls=".&hls)
"      call Decho("....pattern<".pattern.">")
      try
       exe "keepj noautocmd vimgrep /".pattern."/gj ".fnameescape(b:netrw_curdir)."/*"
      catch /^Vim\%((\a\+)\)\=:E480/
       keepalt call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pattern.">",76)
"       call Dret("netrw#Explore : unable to find pattern<".pattern.">")
       return
      endtry
      let w:netrw_explore_list = s:NetrwExploreListUniq(map(getqflist(),'bufname(v:val.bufnr)'))
      if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

     elseif starpat == 2
      " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
"      call Decho("..case starpat=".starpat.": build **//pattern list  (recursive descent files containing pattern)")
"      call Decho("....pattern<".pattern.">")
      try
       exe "sil keepj noautocmd keepalt vimgrep /".pattern."/gj "."**/*"
      catch /^Vim\%((\a\+)\)\=:E480/
       keepalt call netrw#ErrorMsg(s:WARNING,'no files matched pattern<'.pattern.'>',45)
       if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
       if has("clipboard")
        sil! let @* = keepregstar
        sil! let @+ = keepregstar
       endif
       sil! let @/ = keepregslash
"       call Dret("netrw#Explore : no files matched pattern")
       return
      endtry
      let s:netrw_curdir       = b:netrw_curdir
      let w:netrw_explore_list = getqflist()
      let w:netrw_explore_list = s:NetrwExploreListUniq(map(w:netrw_explore_list,'s:netrw_curdir."/".bufname(v:val.bufnr)'))
      if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

     elseif starpat == 3
      " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
"      call Decho("..case starpat=".starpat.": build */filepat list  (curdir-only srch filenames matching filepat)  &hls=".&hls)
      let filepat= substitute(dirname,'^\*/','','')
      let filepat= substitute(filepat,'^[%#<]','\\&','')
"      call Decho("....b:netrw_curdir<".b:netrw_curdir.">")
"      call Decho("....filepat<".filepat.">")
      let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".filepat),'\n'))
      if &hls | let keepregslash= s:ExplorePatHls(filepat) | endif

     elseif starpat == 4
      " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
"      call Decho("..case starpat=".starpat.": build **/filepat list  (recursive descent srch filenames matching filepat)  &hls=".&hls)
      let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".dirname),'\n'))
      if &hls | let keepregslash= s:ExplorePatHls(dirname) | endif
     endif " switch on starpat to build w:netrw_explore_list

     let w:netrw_explore_listlen = len(w:netrw_explore_list)
"     call Decho("....w:netrw_explore_list<".string(w:netrw_explore_list).">")
"     call Decho("....w:netrw_explore_listlen=".w:netrw_explore_listlen)

     if w:netrw_explore_listlen == 0 || (w:netrw_explore_listlen == 1 && w:netrw_explore_list[0] =~ '\*\*\/')
      keepalt keepj call netrw#ErrorMsg(s:WARNING,"no files matched",42)
      if has("clipboard")
       sil! let @* = keepregstar
       sil! let @+ = keepregstar
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore : no files matched")
      return
     endif
    endif  " if indx ... endif

    " NetrwStatusLine support - for exploring support
    let w:netrw_explore_indx= indx
"    call Decho("....w:netrw_explore_list<".join(w:netrw_explore_list,',')."> len=".w:netrw_explore_listlen)

    " wrap the indx around, but issue a note
    if indx >= w:netrw_explore_listlen || indx < 0
"     call Decho("....wrap indx (indx=".indx." listlen=".w:netrw_explore_listlen.")")
     let indx                = (indx < 0)? ( w:netrw_explore_listlen - 1 ) : 0
     let w:netrw_explore_indx= indx
     keepalt keepj call netrw#ErrorMsg(s:NOTE,"no more files match Explore pattern",43)
    endif

    exe "let dirfile= w:netrw_explore_list[".indx."]"
"    call Decho("....dirfile=w:netrw_explore_list[indx=".indx."]= <".dirfile.">")
    let newdir= substitute(dirfile,'/[^/]*$','','e')
"    call Decho("....newdir<".newdir.">")

"    call Decho("....calling LocalBrowseCheck(newdir<".newdir.">)")
    call netrw#LocalBrowseCheck(newdir)
    if !exists("w:netrw_liststyle")
     let w:netrw_liststyle= g:netrw_liststyle
    endif
    if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:LONGLIST
     keepalt keepj call search('^'.substitute(dirfile,"^.*/","","").'\>',"W")
    else
     keepalt keepj call search('\<'.substitute(dirfile,"^.*/","","").'\>',"w")
    endif
    let w:netrw_explore_mtchcnt = indx + 1
    let w:netrw_explore_bufnr   = bufnr("%")
    let w:netrw_explore_line    = line(".")
    keepalt keepj call s:SetupNetrwStatusLine('%f %h%m%r%=%9*%{NetrwStatusLine()}')
"    call Decho("....explore: mtchcnt=".w:netrw_explore_mtchcnt." bufnr=".w:netrw_explore_bufnr." line#".w:netrw_explore_line)

   else
"    call Decho("..your vim does not have +path_extra")
    if !exists("g:netrw_quiet")
     keepalt keepj call netrw#ErrorMsg(s:WARNING,"your vim needs the +path_extra feature for Exploring with **!",44)
    endif
    if has("clipboard")
     sil! let @* = keepregstar
     sil! let @+ = keepregstar
    endif
    sil! let @/ = keepregslash
"    call Dret("netrw#Explore : missing +path_extra")
    return
   endif

  else
"   call Decho("..default case: Explore newdir<".dirname.">")
   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && dirname =~ '/'
    sil! unlet w:netrw_treedict
    sil! unlet w:netrw_treetop
   endif
   let newdir= dirname
   if !exists("b:netrw_curdir")
    keepj call netrw#LocalBrowseCheck(getcwd())
   else
    keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,newdir))
   endif
  endif

  " visual display of **/ **// */ Exploration files
"  call Decho("w:netrw_explore_indx=".(exists("w:netrw_explore_indx")? w:netrw_explore_indx : "doesn't exist"))
"  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "n/a").">")
  if exists("w:netrw_explore_indx") && exists("b:netrw_curdir")
"   call Decho("s:explore_prvdir<".(exists("s:explore_prvdir")? s:explore_prvdir : "-doesn't exist-"))
   if !exists("s:explore_prvdir") || s:explore_prvdir != b:netrw_curdir
    " only update match list when current directory isn't the same as before
"    call Decho("only update match list when current directory not the same as before")
    let s:explore_prvdir = b:netrw_curdir
    let s:explore_match  = ""
    let dirlen           = strlen(b:netrw_curdir)
    if b:netrw_curdir !~ '/$'
     let dirlen= dirlen + 1
    endif
    let prvfname= ""
    for fname in w:netrw_explore_list
"     call Decho("fname<".fname.">")
     if fname =~ '^'.b:netrw_curdir
      if s:explore_match == ""
       let s:explore_match= '\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
      else
       let s:explore_match= s:explore_match.'\|\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
      endif
     elseif fname !~ '^/' && fname != prvfname
      if s:explore_match == ""
       let s:explore_match= '\<'.escape(fname,g:netrw_markfileesc).'\>'
      else
       let s:explore_match= s:explore_match.'\|\<'.escape(fname,g:netrw_markfileesc).'\>'
      endif
     endif
     let prvfname= fname
    endfor
"    call Decho("explore_match<".s:explore_match.">")
    exe "2match netrwMarkFile /".s:explore_match."/"
   endif
   echo "<s-up>==Pexplore  <s-down>==Nexplore"
  else
   2match none
   if exists("s:explore_match")  | unlet s:explore_match  | endif
   if exists("s:explore_prvdir") | unlet s:explore_prvdir | endif
   echo " "
"   call Decho("cleared explore match list")
  endif

  " since Explore may be used to initialize netrw's browser,
  " there's no danger of a late FocusGained event on initialization.
  " Consequently, set s:netrw_events to 2.
  let s:netrw_events= 2
  if has("clipboard")
   sil! let @* = keepregstar
   sil! let @+ = keepregstar
  endif
  sil! let @/ = keepregslash
"  call Dret("netrw#Explore : @/<".@/.">")
endfun

" ---------------------------------------------------------------------
" netrw#Lexplore: toggle Explorer window, keeping it on the left of the current tab {{{2
fun! netrw#Lexplore(...)
"  call Dfunc("netrw#Lexplore() a:0=".a:0)
  if a:0 > 0 && a:1 != ""
   " if a netrw window is already on the left-side of the tab
   " and a directory has been specified, explore with that
   " directory.
   let lexwinnr= winnr()
   exe "1wincmd w"
   if &ft == "netrw"
    exe "Explore ".fnameescape(a:1)
    exe lexwinnr."wincmd w"
   endif
   exe lexwinnr."wincmd w"
"   call Dret("netrw#Lexplore")
   return
  endif

  if exists("t:netrw_lexbufnr")
   " close down netrw explorer window
   let lexwinnr = bufwinnr(t:netrw_lexbufnr)
   if lexwinnr != -1
    let curwin   = winnr()
    exe lexwinnr."wincmd w"
    close
    exe curwin."wincmd w"
   endif
   unlet t:netrw_lexbufnr

  else
   " open netrw explorer window
   exe "1wincmd w"
   let keep_altv    = g:netrw_altv
   let g:netrw_altv = 0
   if a:0 > 0 && a:1 != ""
    exe "Vexplore ".fnameescape(a:1)
   else
    Vexplore .
   endif
   let g:netrw_altv     = keep_altv
   let t:netrw_lexbufnr = bufnr("%")
  endif
  if exists("g:netrw_chgwin") && g:netrw_chgwin == -1
   let g:netrw_chgwin= 2
  endif
"  call Dret("netrw#Lexplore")
endfun

" ---------------------------------------------------------------------
" netrw#Clean: remove netrw {{{2
" supports :NetrwClean  -- remove netrw from first directory on runtimepath
"          :NetrwClean! -- remove netrw from all directories on runtimepath
fun! netrw#Clean(sys)
"  call Dfunc("netrw#Clean(sys=".a:sys.")")

  if a:sys
   let choice= confirm("Remove personal and system copies of netrw?","&Yes\n&No")
  else
   let choice= confirm("Remove personal copy of netrw?","&Yes\n&No")
  endif
"  call Decho("choice=".choice)
  let diddel= 0
  let diddir= ""

  if choice == 1
   for dir in split(&rtp,',')
    if filereadable(dir."/plugin/netrwPlugin.vim")
"     call Decho("removing netrw-related files from ".dir)
     if s:NetrwDelete(dir."/plugin/netrwPlugin.vim")        |call netrw#ErrorMsg(1,"unable to remove ".dir."/plugin/netrwPlugin.vim",55)        |endif
     if s:NetrwDelete(dir."/autoload/netrwFileHandlers.vim")|call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwFileHandlers.vim",55)|endif
     if s:NetrwDelete(dir."/autoload/netrwSettings.vim")    |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwSettings.vim",55)    |endif
     if s:NetrwDelete(dir."/autoload/netrw.vim")            |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrw.vim",55)            |endif
     if s:NetrwDelete(dir."/syntax/netrw.vim")              |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrw.vim",55)              |endif
     if s:NetrwDelete(dir."/syntax/netrwlist.vim")          |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrwlist.vim",55)          |endif
     let diddir= dir
     let diddel= diddel + 1
     if !a:sys|break|endif
    endif
   endfor
  endif

   echohl WarningMsg
  if diddel == 0
   echomsg "netrw is either not installed or not removable"
  elseif diddel == 1
   echomsg "removed one copy of netrw from <".diddir.">"
  else
   echomsg "removed ".diddel." copies of netrw"
  endif
   echohl None

"  call Dret("netrw#Clean")
endfun

" ---------------------------------------------------------------------
" netrw#MakeTgt: make a target out of the directory name provided {{{2
fun! netrw#MakeTgt(dname)
"  call Dfunc("netrw#MakeTgt(dname<".a:dname.">)")
   " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
  let svpos               = netrw#SavePosn()
  let s:netrwmftgt_islocal= (a:dname !~ '^\a\+://')
"  call Decho("s:netrwmftgt_islocal=".s:netrwmftgt_islocal)
  if s:netrwmftgt_islocal
   let netrwmftgt= simplify(a:dname)
  else
   let netrwmftgt= a:dname
  endif
  if exists("s:netrwmftgt") && netrwmftgt == s:netrwmftgt
   " re-selected target, so just clear it
   unlet s:netrwmftgt s:netrwmftgt_islocal
  else
   let s:netrwmftgt= netrwmftgt
  endif
  if g:netrw_fastbrowse <= 1
   call s:NetrwRefresh((b:netrw_curdir !~ '\a\+://'),b:netrw_curdir)
  endif
  call netrw#RestorePosn(svpos)
"  call Dret("netrw#MakeTgt")
endfun

" ---------------------------------------------------------------------
" netrw#Obtain: {{{2
"   netrw#Obtain(islocal,fname[,tgtdirectory])
"     islocal=0  obtain from remote source
"            =1  obtain from local source
"     fname  :   a filename or a list of filenames
"     tgtdir :   optional place where files are to go  (not present, uses getcwd())
fun! netrw#Obtain(islocal,fname,...)
"  call Dfunc("netrw#Obtain(islocal=".a:islocal." fname<".((type(a:fname) == 1)? a:fname : string(a:fname)).">) a:0=".a:0)
  " NetrwStatusLine support - for obtaining support

  if type(a:fname) == 1
   let fnamelist= [ a:fname ]
  elseif type(a:fname) == 3
   let fnamelist= a:fname
  else
   call netrw#ErrorMsg(s:ERROR,"attempting to use NetrwObtain on something not a filename or a list",62)
"   call Dret("netrw#Obtain")
   return
  endif
"  call Decho("fnamelist<".string(fnamelist).">")
  if a:0 > 0
   let tgtdir= a:1
  else
   let tgtdir= getcwd()
  endif
"  call Decho("tgtdir<".tgtdir.">")

  if exists("b:netrw_islocal") && b:netrw_islocal
   " obtain a file from local b:netrw_curdir to (local) tgtdir
"   call Decho("obtain a file from local ".b:netrw_curdir." to ".tgtdir)
   if exists("b:netrw_curdir") && getcwd() != b:netrw_curdir
    let topath= s:ComposePath(tgtdir,"")
    if (has("win32") || has("win95") || has("win64") || has("win16"))
     " transfer files one at time
"     call Decho("transfer files one at a time")
     for fname in fnamelist
"      call Decho("system(".g:netrw_localcopycmd." ".shellescape(fname)." ".shellescape(topath).")")
      call system(g:netrw_localcopycmd." ".shellescape(fname)." ".shellescape(topath))
      if v:shell_error != 0
       call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
"       call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".shellescape(fname)." ".shellescape(topath))
       return
      endif
     endfor
    else
     " transfer files with one command
"     call Decho("transfer files with one command")
     let filelist= join(map(deepcopy(fnamelist),"shellescape(v:val)"))
"     call Decho("system(".g:netrw_localcopycmd." ".filelist." ".shellescape(topath).")")
     call system(g:netrw_localcopycmd." ".filelist." ".shellescape(topath))
     if v:shell_error != 0
      call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
"      call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".filelist." ".shellescape(topath))
      return
     endif
    endif
   elseif !exists("b:netrw_curdir")
    call netrw#ErrorMsg(s:ERROR,"local browsing directory doesn't exist!",36)
   else
    call netrw#ErrorMsg(s:WARNING,"local browsing directory and current directory are identical",37)
   endif

  else
   " obtain files from remote b:netrw_curdir to local tgtdir
"   call Decho("obtain a file from remote ".b:netrw_curdir." to ".tgtdir)
   if type(a:fname) == 1
    call s:SetupNetrwStatusLine('%f %h%m%r%=%9*Obtaining '.a:fname)
   endif
   call s:NetrwMethod(b:netrw_curdir)

   if b:netrw_method == 4
    " obtain file using scp
"    call Decho("obtain via scp (method#4)")
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
    if b:netrw_fname =~ '/'
     let path= substitute(b:netrw_fname,'^\(.*/\).\{-}$','\1','')
    else
     let path= ""
    endif
    let filelist= join(map(deepcopy(fnamelist),'shellescape(g:netrw_machine.":".path.v:val,1)'))
"    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".filelist." ".shellescape(tgtdir,1))
    exe s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".filelist." ".shellescape(tgtdir,1)

   elseif b:netrw_method == 2
    " obtain file using ftp + .netrc
"     call Decho("obtain via ftp+.netrc (method #2)")
     call s:SaveBufVars()|sil keepjumps new|call s:RestoreBufVars()
     let tmpbufnr= bufnr("%")
     setl ff=unix
     if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
      keepj put =g:netrw_ftpmode
"      call Decho("filter input: ".getline('$'))
     endif

     if exists("b:netrw_fname") && b:netrw_fname != ""
      call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"      call Decho("filter input: ".getline('$'))
     endif

     if exists("g:netrw_ftpextracmd")
      keepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'))
     endif
     for fname in fnamelist
      call setline(line("$")+1,'get "'.fname.'"')
"      call Decho("filter input: ".getline('$'))
     endfor
     if exists("g:netrw_port") && g:netrw_port != ""
"      call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
      exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
     else
"      call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
      exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep= &debug
      setl debug=msg
      call netrw#ErrorMsg(s:ERROR,getline(1),4)
      let &debug= debugkeep
     endif

   elseif b:netrw_method == 3
    " obtain with ftp + machine, id, passwd, and fname (ie. no .netrc)
"    call Decho("obtain via ftp+mipf (method #3)")
    call s:SaveBufVars()|sil keepjumps new|call s:RestoreBufVars()
    let tmpbufnr= bufnr("%")
    setl ff=unix

    if exists("g:netrw_port") && g:netrw_port != ""
     keepj put ='open '.g:netrw_machine.' '.g:netrw_port
"     call Decho("filter input: ".getline('$'))
    else
     keepj put ='open '.g:netrw_machine
"     call Decho("filter input: ".getline('$'))
    endif

    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      keepj put =g:netrw_uid
"      call Decho("filter input: ".getline('$'))
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       keepj put ='\"'.s:netrw_passwd.'\"'
      endif
"      call Decho("filter input: ".getline('$'))
     elseif exists("s:netrw_passwd")
      keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"      call Decho("filter input: ".getline('$'))
     endif
    endif

    if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
     keepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('$'))
    endif

    if exists("b:netrw_fname") && b:netrw_fname != ""
     keepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"     call Decho("filter input: ".getline('$'))
    endif

    if exists("g:netrw_ftpextracmd")
     keepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('$'))
    endif

    if exists("g:netrw_ftpextracmd")
     keepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('$'))
    endif
    for fname in fnamelist
     keepj call setline(line("$")+1,'get "'.fname.'"')
    endfor
"    call Decho("filter input: ".getline('$'))

    " perform ftp:
    " -i       : turns off interactive prompting from ftp
    " -n  unix : DON'T use <.netrc>, even though it exists
    " -n  win32: quit being obnoxious about password
    keepj norm! 1Gdd
"    call Decho("executing: %!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
"     call Decho("error<".getline(1).">")
     if !exists("g:netrw_quiet")
      keepj call netrw#ErrorMsg(s:ERROR,getline(1),5)
     endif
    endif

   elseif b:netrw_method == 9
    " obtain file using sftp
"    call Decho("obtain via sftp (method #9)")
    if a:fname =~ '/'
     let localfile= substitute(a:fname,'^.*/','','')
    else
     let localfile= a:fname
    endif
"    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1).shellescape(localfile)." ".shellescape(tgtdir))
    exe s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1).shellescape(localfile)." ".shellescape(tgtdir)

   elseif !exists("b:netrw_method") || b:netrw_method < 0
    " probably a badly formed url; protocol not recognized
"    call Dret("netrw#Obtain : unsupported method")
    return

   else
    " protocol recognized but not supported for Obtain (yet?)
    if !exists("g:netrw_quiet")
     keepj call netrw#ErrorMsg(s:ERROR,"current protocol not supported for obtaining file",97)
    endif
"    call Dret("netrw#Obtain : current protocol not supported for obtaining file")
    return
   endif

   " restore status line
   if type(a:fname) == 1 && exists("s:netrw_users_stl")
    keepj call s:SetupNetrwStatusLine(s:netrw_users_stl)
   endif

  endif

  " cleanup
  if exists("tmpbufnr")
   if bufnr("%") != tmpbufnr
    exe tmpbufnr."bw!"
   else
    q!
   endif
  endif

"  call Dret("netrw#Obtain")
endfun

" ---------------------------------------------------------------------
" netrw#Nread: save position, call netrw#NetRead(), and restore position {{{2
fun! netrw#Nread(mode,fname)
"  call Dfunc("netrw#Nread(mode=".a:mode." fname<".a:fname.">)")
  call netrw#SavePosn()
  call netrw#NetRead(a:mode,a:fname)
  call netrw#RestorePosn()

  if exists("w:netrw_liststyle") && w:netrw_liststyle != s:TREELIST
   if exists("w:netrw_bannercnt")
    " start with cursor just after the banner
    exe w:netrw_bannercnt
   endif
  endif
"  call Dret("netrw#Nread")
endfun

" ------------------------------------------------------------------------
" s:NetrwOptionRestore: restore options (based on prior s:NetrwOptionSave) {{{2
fun! s:NetrwOptionRestore(vt)
"  call Dfunc("s:NetrwOptionRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt)
  if !exists("{a:vt}netrw_optionsave")
   if exists("s:nbcd_curpos_{bufnr('%')}")
"    call Decho("restoring previous position  (s:nbcd_curpos_".bufnr('%')." exists)")
    keepj call netrw#RestorePosn(s:nbcd_curpos_{bufnr('%')})
"    call Decho("win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
"    call Decho("unlet s:nbcd_curpos_".bufnr('%'))
    unlet s:nbcd_curpos_{bufnr('%')}
   else
"    call Decho("no previous position")
   endif
"   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt)
"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"   call Dret("s:NetrwOptionRestore : ".a:vt."netrw_optionsave doesn't exist")
   return
  endif
  unlet {a:vt}netrw_optionsave

  if exists("+acd")
   if exists("{a:vt}netrw_acdkeep")
"    call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
    let curdir = getcwd()
    let &l:acd = {a:vt}netrw_acdkeep
    unlet {a:vt}netrw_acdkeep
    if &l:acd
     call s:NetrwLcd(curdir)
    endif
   endif
  endif
  if exists("{a:vt}netrw_aikeep")   |let &l:ai     = {a:vt}netrw_aikeep      |unlet {a:vt}netrw_aikeep   |endif
  if exists("{a:vt}netrw_awkeep")   |let &l:aw     = {a:vt}netrw_awkeep      |unlet {a:vt}netrw_awkeep   |endif
  if g:netrw_liststyle != s:TREELIST
   if exists("{a:vt}netrw_bhkeep")  |let &l:bh     = {a:vt}netrw_bhkeep      |unlet {a:vt}netrw_bhkeep   |endif
  endif
  if exists("{a:vt}netrw_blkeep")   |let &l:bl     = {a:vt}netrw_blkeep      |unlet {a:vt}netrw_blkeep   |endif
  if exists("{a:vt}netrw_btkeep")   |let &l:bt     = {a:vt}netrw_btkeep      |unlet {a:vt}netrw_btkeep   |endif
  if exists("{a:vt}netrw_bombkeep") |let &l:bomb   = {a:vt}netrw_bombkeep    |unlet {a:vt}netrw_bombkeep |endif
  if exists("{a:vt}netrw_cedit")    |let &cedit    = {a:vt}netrw_cedit       |unlet {a:vt}netrw_cedit    |endif
  if exists("{a:vt}netrw_cikeep")   |let &l:ci     = {a:vt}netrw_cikeep      |unlet {a:vt}netrw_cikeep   |endif
  if exists("{a:vt}netrw_cinkeep")  |let &l:cin    = {a:vt}netrw_cinkeep     |unlet {a:vt}netrw_cinkeep  |endif
  if exists("{a:vt}netrw_cinokeep") |let &l:cino   = {a:vt}netrw_cinokeep    |unlet {a:vt}netrw_cinokeep |endif
  if exists("{a:vt}netrw_comkeep")  |let &l:com    = {a:vt}netrw_comkeep     |unlet {a:vt}netrw_comkeep  |endif
  if exists("{a:vt}netrw_cpokeep")  |let &l:cpo    = {a:vt}netrw_cpokeep     |unlet {a:vt}netrw_cpokeep  |endif
  if exists("{a:vt}netrw_diffkeep") |let &l:diff   = {a:vt}netrw_diffkeep    |unlet {a:vt}netrw_diffkeep |endif
  if exists("{a:vt}netrw_fenkeep")  |let &l:fen    = {a:vt}netrw_fenkeep     |unlet {a:vt}netrw_fenkeep  |endif
  if exists("{a:vt}netrw_ffkeep")   |let &l:ff     = {a:vt}netrw_ffkeep      |unlet {a:vt}netrw_ffkeep   |endif
  if exists("{a:vt}netrw_fokeep")   |let &l:fo     = {a:vt}netrw_fokeep      |unlet {a:vt}netrw_fokeep   |endif
  if exists("{a:vt}netrw_gdkeep")   |let &l:gd     = {a:vt}netrw_gdkeep      |unlet {a:vt}netrw_gdkeep   |endif
  if exists("{a:vt}netrw_hidkeep")  |let &l:hidden = {a:vt}netrw_hidkeep     |unlet {a:vt}netrw_hidkeep  |endif
  if exists("{a:vt}netrw_imkeep")   |let &l:im     = {a:vt}netrw_imkeep      |unlet {a:vt}netrw_imkeep   |endif
  if exists("{a:vt}netrw_iskkeep")  |let &l:isk    = {a:vt}netrw_iskkeep     |unlet {a:vt}netrw_iskkeep  |endif
  if exists("{a:vt}netrw_lskeep")   |let &l:ls     = {a:vt}netrw_lskeep      |unlet {a:vt}netrw_lskeep   |endif
  if exists("{a:vt}netrw_makeep")   |let &l:ma     = {a:vt}netrw_makeep      |unlet {a:vt}netrw_makeep   |endif
  if exists("{a:vt}netrw_magickeep")|let &l:magic  = {a:vt}netrw_magickeep   |unlet {a:vt}netrw_magickeep|endif
  if exists("{a:vt}netrw_modkeep")  |let &l:mod    = {a:vt}netrw_modkeep     |unlet {a:vt}netrw_modkeep  |endif
  if exists("{a:vt}netrw_nukeep")   |let &l:nu     = {a:vt}netrw_nukeep      |unlet {a:vt}netrw_nukeep   |endif
  if exists("{a:vt}netrw_rnukeep")  |let &l:rnu    = {a:vt}netrw_rnukeep     |unlet {a:vt}netrw_rnukeep  |endif
  if exists("{a:vt}netrw_repkeep")  |let &l:report = {a:vt}netrw_repkeep     |unlet {a:vt}netrw_repkeep  |endif
  if exists("{a:vt}netrw_rokeep")   |let &l:ro     = {a:vt}netrw_rokeep      |unlet {a:vt}netrw_rokeep   |endif
  if exists("{a:vt}netrw_selkeep")  |let &l:sel    = {a:vt}netrw_selkeep     |unlet {a:vt}netrw_selkeep  |endif
  if exists("{a:vt}netrw_spellkeep")|let &l:spell  = {a:vt}netrw_spellkeep   |unlet {a:vt}netrw_spellkeep|endif
  if has("clipboard")
   if exists("{a:vt}netrw_starkeep") |let @*        = {a:vt}netrw_starkeep    |unlet {a:vt}netrw_starkeep |endif
  endif
  " Problem: start with liststyle=0; press <i> : result, following line resets l:ts.
"  if exists("{a:vt}netrw_tskeep")   |let &l:ts     = {a:vt}netrw_tskeep      |unlet {a:vt}netrw_tskeep   |endif
  if exists("{a:vt}netrw_twkeep")   |let &l:tw     = {a:vt}netrw_twkeep      |unlet {a:vt}netrw_twkeep   |endif
  if exists("{a:vt}netrw_wigkeep")  |let &l:wig    = {a:vt}netrw_wigkeep     |unlet {a:vt}netrw_wigkeep  |endif
  if exists("{a:vt}netrw_wrapkeep") |let &l:wrap   = {a:vt}netrw_wrapkeep    |unlet {a:vt}netrw_wrapkeep |endif
  if exists("{a:vt}netrw_writekeep")|let &l:write  = {a:vt}netrw_writekeep   |unlet {a:vt}netrw_writekeep|endif
  if exists("s:yykeep")             |let  @@       = s:yykeep                |unlet s:yykeep             |endif
  if exists("{a:vt}netrw_swfkeep")
   if &directory == ""
    " user hasn't specified a swapfile directory;
    " netrw will temporarily set the swapfile directory
    " to the current directory as returned by getcwd().
    let &l:directory= getcwd()
    sil! let &l:swf = {a:vt}netrw_swfkeep
    setl directory=
    unlet {a:vt}netrw_swfkeep
   elseif &l:swf != {a:vt}netrw_swfkeep
    " following line causes a Press ENTER in windows -- can't seem to work around it!!!
    sil! let &l:swf= {a:vt}netrw_swfkeep
    unlet {a:vt}netrw_swfkeep
   endif
  endif
  if exists("{a:vt}netrw_dirkeep") && isdirectory({a:vt}netrw_dirkeep) && g:netrw_keepdir
   let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
   if exists("{a:vt}netrw_dirkeep")
    call s:NetrwLcd(dirkeep)
    unlet {a:vt}netrw_dirkeep
   endif
  endif
  if has("clipboard")
   if exists("{a:vt}netrw_regstar") |sil! let @*= {a:vt}netrw_regstar |unlet {a:vt}netrw_regstar |endif
  endif
  if exists("{a:vt}netrw_regslash")|sil! let @/= {a:vt}netrw_regslash|unlet {a:vt}netrw_regslash|endif
  if exists("s:nbcd_curpos_{bufnr('%')}")
"   call Decho("restoring previous position  (s:nbcd_curpos_".bufnr('%')." exists)")
   keepj call netrw#RestorePosn(s:nbcd_curpos_{bufnr('%')})
"   call Decho("unlet s:nbcd_curpos_".bufnr('%'))
   if exists("s:nbcd_curpos_".bufnr('%'))
    unlet s:nbcd_curpos_{bufnr('%')}
   endif
  else
"   call Decho("no previous position")
  endif

"  call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"))
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"  call Decho("diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"))
"  call Decho("ts=".&l:ts)
  " Moved the filetype detect here from NetrwGetFile() because remote files
  " were having their filetype detect-generated settings overwritten by
  " NetrwOptionRestore.
  if &ft != "netrw"
"   call Decho("filetype detect  (ft=".&ft.")")
   filetype detect
  endif
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt)
"  call Dret("s:NetrwOptionRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
endfun

" ---------------------------------------------------------------------
" s:NetrwOptionSave: save options prior to setting to "netrw-buffer-standard" form {{{2
"             Options get restored by s:NetrwOptionRestore()
"  06/08/07 : removed call to NetrwSafeOptions(), either placed
"             immediately after NetrwOptionSave() calls in NetRead
"             and NetWrite, or after the s:NetrwEnew() call in
"             NetrwBrowse.
"             vt: normally its "w:" or "s:" (a variable type)
fun! s:NetrwOptionSave(vt)
"  call Dfunc("s:NetrwOptionSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
"  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt)

  if !exists("{a:vt}netrw_optionsave")
   let {a:vt}netrw_optionsave= 1
  else
"   call Dret("s:NetrwOptionSave : options already saved")
   return
  endif
"  call Decho("prior to save: fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff)

  " Save current settings and current directory
"  call Decho("saving current settings and current directory")
  let s:yykeep          = @@
  if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
  let {a:vt}netrw_aikeep    = &l:ai
  let {a:vt}netrw_awkeep    = &l:aw
  let {a:vt}netrw_bhkeep    = &l:bh
  let {a:vt}netrw_blkeep    = &l:bl
  let {a:vt}netrw_btkeep    = &l:bt
  let {a:vt}netrw_bombkeep  = &l:bomb
  let {a:vt}netrw_cedit     = &cedit
  let {a:vt}netrw_cikeep    = &l:ci
  let {a:vt}netrw_cinkeep   = &l:cin
  let {a:vt}netrw_cinokeep  = &l:cino
  let {a:vt}netrw_comkeep   = &l:com
  let {a:vt}netrw_cpokeep   = &l:cpo
  let {a:vt}netrw_diffkeep  = &l:diff
  let {a:vt}netrw_fenkeep   = &l:fen
  if !exists("g:netrw_ffkeep") || g:netrw_ffkeep == 1
   let {a:vt}netrw_ffkeep    = &l:ff
  endif
  let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
  let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
  let {a:vt}netrw_hidkeep   = &l:hidden
  let {a:vt}netrw_imkeep    = &l:im
  let {a:vt}netrw_iskkeep   = &l:isk
  let {a:vt}netrw_lskeep    = &l:ls
  let {a:vt}netrw_makeep    = &l:ma
  let {a:vt}netrw_magickeep = &l:magic
  let {a:vt}netrw_modkeep   = &l:mod
  let {a:vt}netrw_nukeep    = &l:nu
  let {a:vt}netrw_rnukeep   = &l:rnu
  let {a:vt}netrw_repkeep   = &l:report
  let {a:vt}netrw_rokeep    = &l:ro
  let {a:vt}netrw_selkeep   = &l:sel
  let {a:vt}netrw_spellkeep = &l:spell
  if g:netrw_use_noswf
   let {a:vt}netrw_swfkeep   = &l:swf
  endif
  if has("clipboard")
   let {a:vt}netrw_starkeep  = @*
  endif
  let {a:vt}netrw_tskeep    = &l:ts
  let {a:vt}netrw_twkeep    = &l:tw           " textwidth
  let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
  let {a:vt}netrw_wrapkeep  = &l:wrap
  let {a:vt}netrw_writekeep = &l:write

  " save a few selected netrw-related variables
"  call Decho("saving a few selected netrw-related variables")
  if g:netrw_keepdir
   let {a:vt}netrw_dirkeep  = getcwd()
  endif
  if has("clipboard")
   if &go =~# 'a' | sil! let {a:vt}netrw_regstar = @* | endif
  endif
  sil! let {a:vt}netrw_regslash= @/

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt)
"  call Dret("s:NetrwOptionSave : tab#".tabpagenr()." win#".winnr())
endfun

" ------------------------------------------------------------------------
" s:NetrwSafeOptions: sets options to help netrw do its job {{{2
"                     Use  s:NetrwSaveOptions() to save user settings
"                     Use  s:NetrwOptionRestore() to restore user settings
fun! s:NetrwSafeOptions()
"  call Dfunc("s:NetrwSafeOptions() win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
"  call Decho("win#".winnr()."'s ft=".&ft)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
  if exists("+acd") | setl noacd | endif
  setl noai
  setl noaw
  setl nobl
  setl nobomb
  setl bt=nofile
  setl noci
  setl nocin
  if g:netrw_liststyle == s:TREELIST
   setl bh=hide
  endif
  setl cino=
  setl com=
  setl cpo-=a
  setl cpo-=A
  setl fo=nroql2
  setl nohid
  setl noim
  setl isk+=@ isk+=* isk+=/
  setl magic
  if g:netrw_use_noswf
   setl noswf
  endif
  setl report=10000
  setl sel=inclusive
  setl nospell
  setl tw=0
  setl wig=
  setl cedit&
  call s:NetrwCursor()

  " allow the user to override safe options
"  call Decho("ft<".&ft."> ei=".&ei)
  if &ft == "netrw"
"   call Decho("do any netrw FileType autocmds (doau FileType netrw)")
   sil! keepalt keepj doau FileType netrw
  endif

"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"  call Dret("s:NetrwSafeOptions")
endfun

" ---------------------------------------------------------------------
" NetrwStatusLine: {{{2
fun! NetrwStatusLine()

" vvv NetrwStatusLine() debugging vvv
"  let g:stlmsg=""
"  if !exists("w:netrw_explore_bufnr")
"   let g:stlmsg="!X<explore_bufnr>"
"  elseif w:netrw_explore_bufnr != bufnr("%")
"   let g:stlmsg="explore_bufnr!=".bufnr("%")
"  endif
"  if !exists("w:netrw_explore_line")
"   let g:stlmsg=" !X<explore_line>"
"  elseif w:netrw_explore_line != line(".")
"   let g:stlmsg=" explore_line!={line(.)<".line(".").">"
"  endif
"  if !exists("w:netrw_explore_list")
"   let g:stlmsg=" !X<explore_list>"
"  endif
" ^^^ NetrwStatusLine() debugging ^^^

  if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
   " restore user's status line
   let &stl        = s:netrw_users_stl
   let &laststatus = s:netrw_users_ls
   if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
   if exists("w:netrw_explore_line") |unlet w:netrw_explore_line |endif
   return ""
  else
   return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
  endif
endfun

" ---------------------------------------------------------------------
"  Netrw Transfer Functions: {{{1
" ===============================

" ------------------------------------------------------------------------
" netrw#NetRead: responsible for reading a file over the net {{{2
"   mode: =0 read remote file and insert before current line
"         =1 read remote file and insert after current line
"         =2 replace with remote file
"         =3 obtain file, but leave in temporary format
fun! netrw#NetRead(mode,...)
"  call Dfunc("netrw#NetRead(mode=".a:mode.",...) a:0=".a:0." ".g:loaded_netrw.((a:0 > 0)? " a:1<".a:1.">" : ""))

  " NetRead: save options {{{3
  call s:NetrwOptionSave("w:")
  call s:NetrwSafeOptions()
  call s:RestoreCursorline()

  " NetRead: interpret mode into a readcmd {{{3
  if     a:mode == 0 " read remote file before current line
   let readcmd = "0r"
  elseif a:mode == 1 " read file after current line
   let readcmd = "r"
  elseif a:mode == 2 " replace with remote file
   let readcmd = "%r"
  elseif a:mode == 3 " skip read of file (leave as temporary)
   let readcmd = "t"
  else
   exe a:mode
   let readcmd = "r"
  endif
  let ichoice = (a:0 == 0)? 0 : 1
"  call Decho("readcmd<".readcmd."> ichoice=".ichoice)

  " NetRead: get temporary filename {{{3
  let tmpfile= s:GetTempfile("")
  if tmpfile == ""
"   call Dret("netrw#NetRead : unable to get a tempfile!")
   return
  endif

  while ichoice <= a:0

   " attempt to repeat with previous host-file-etc
   if exists("b:netrw_lastfile") && a:0 == 0
"    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">")
    let choice = b:netrw_lastfile
    let ichoice= ichoice + 1

   else
    exe "let choice= a:" . ichoice
"    call Decho("no lastfile: choice<" . choice . ">")

    if match(choice,"?") == 0
     " give help
     echomsg 'NetRead Usage:'
     echomsg ':Nread machine:path                         uses rcp'
     echomsg ':Nread "machine path"                       uses ftp   with <.netrc>'
     echomsg ':Nread "machine id password path"           uses ftp'
     echomsg ':Nread dav://machine[:port]/path            uses cadaver'
     echomsg ':Nread fetch://machine/path                 uses fetch'
     echomsg ':Nread ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
     echomsg ':Nread http://[user@]machine/path           uses http  wget'
     echomsg ':Nread https://[user@]machine/path          uses http  wget'
     echomsg ':Nread rcp://[user@]machine/path            uses rcp'
     echomsg ':Nread rsync://machine[:port]/path          uses rsync'
     echomsg ':Nread scp://[user@]machine[[:#]port]/path  uses scp'
     echomsg ':Nread sftp://[user@]machine[[:#]port]/path uses sftp'
     sleep 4
     break

    elseif match(choice,'^"') != -1
     " Reconstruct Choice if choice starts with '"'
"     call Decho("reconstructing choice")
     if match(choice,'"$') != -1
      " case "..."
      let choice= strpart(choice,1,strlen(choice)-2)
     else
       "  case "... ... ..."
      let choice      = strpart(choice,1,strlen(choice)-1)
      let wholechoice = ""

      while match(choice,'"$') == -1
       let wholechoice = wholechoice . " " . choice
       let ichoice     = ichoice + 1
       if ichoice > a:0
       	if !exists("g:netrw_quiet")
	 call netrw#ErrorMsg(s:ERROR,"Unbalanced string in filename '". wholechoice ."'",3)
	endif
"        call Dret("netrw#NetRead :2 getcwd<".getcwd().">")
        return
       endif
       let choice= a:{ichoice}
      endwhile
      let choice= strpart(wholechoice,1,strlen(wholechoice)-1) . " " . strpart(choice,0,strlen(choice)-1)
     endif
    endif
   endif

"   call Decho("choice<" . choice . ">")
   let ichoice= ichoice + 1

   " NetRead: Determine method of read (ftp, rcp, etc) {{{3
   call s:NetrwMethod(choice)
   if !exists("b:netrw_method") || b:netrw_method < 0
"    call Dfunc("netrw#NetRead : unsupported method")
    return
   endif
   let tmpfile= s:GetTempfile(b:netrw_fname) " apply correct suffix

   " Check whether or not NetrwBrowse() should be handling this request
"   call Decho("checking if NetrwBrowse() should handle choice<".choice."> with netrw_list_cmd<".g:netrw_list_cmd.">")
   if choice =~ "^.*[\/]$" && b:netrw_method != 5 && choice !~ '^https\=://'
"    call Decho("yes, choice matches '^.*[\/]$'")
    keepj call s:NetrwBrowse(0,choice)
"    call Dret("netrw#NetRead :3 getcwd<".getcwd().">")
    return
   endif

   " ============
   " NetRead: Perform Protocol-Based Read {{{3
   " ===========================
   if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1
    echo "(netrw) Processing your read request..."
   endif

   ".........................................
   " NetRead: (rcp)  NetRead Method #1 {{{3
   if  b:netrw_method == 1 " read with rcp
"    call Decho("read via rcp (method #1)")
   " ER: nothing done with g:netrw_uid yet?
   " ER: on Win2K" rcp machine[.user]:file tmpfile
   " ER: when machine contains '.' adding .user is required (use $USERNAME)
   " ER: the tmpfile is full path: rcp sees C:\... as host C
   if s:netrw_has_nt_rcp == 1
    if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
     let uid_machine = g:netrw_machine .'.'. g:netrw_uid
    else
     " Any way needed it machine contains a '.'
     let uid_machine = g:netrw_machine .'.'. $USERNAME
    endif
   else
    if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
     let uid_machine = g:netrw_uid .'@'. g:netrw_machine
    else
     let uid_machine = g:netrw_machine
    endif
   endif
"   call Decho("executing: !".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".shellescape(uid_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1))
   exe s:netrw_silentxfer."!".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".shellescape(uid_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1)
   let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
   let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (ftp + <.netrc>)  NetRead Method #2 {{{3
   elseif b:netrw_method  == 2		" read with ftp + <.netrc>
"     call Decho("read via ftp+.netrc (method #2)")
     let netrw_fname= b:netrw_fname
     keepj call s:SaveBufVars()|new|keepj call s:RestoreBufVars()
     let filtbuf= bufnr("%")
     setl ff=unix
     keepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline(line("$")))
     if exists("g:netrw_ftpextracmd")
      keepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline(line("$")))
     endif
     call setline(line("$")+1,'get "'.netrw_fname.'" '.tmpfile)
"     call Decho("filter input: ".getline(line("$")))
     if exists("g:netrw_port") && g:netrw_port != ""
"      call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
      exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
     else
"      call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
      exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep = &debug
      setl debug=msg
      keepj call netrw#ErrorMsg(s:ERROR,getline(1),4)
      let &debug    = debugkeep
     endif
     call s:SaveBufVars()
     bd!
     if bufname("%") == "" && getline("$") == "" && line('$') == 1
      " needed when one sources a file in a nolbl setting window via ftp
      q!
     endif
     call s:RestoreBufVars()
     let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
     let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (ftp + machine,id,passwd,filename)  NetRead Method #3 {{{3
   elseif b:netrw_method == 3		" read with ftp + machine, id, passwd, and fname
    " Construct execution string (four lines) which will be passed through filter
"    call Decho("read via ftp+mipf (method #3)")
    let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
    keepj call s:SaveBufVars()|new|keepj call s:RestoreBufVars()
    let filtbuf= bufnr("%")
    setl ff=unix
    if exists("g:netrw_port") && g:netrw_port != ""
     keepj put ='open '.g:netrw_machine.' '.g:netrw_port
"     call Decho("filter input: ".getline('.'))
    else
     keepj put ='open '.g:netrw_machine
"     call Decho("filter input: ".getline('.'))
    endif

    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      keepj put =g:netrw_uid
"       call Decho("filter input: ".getline('.'))
      if exists("s:netrw_passwd")
       keepj put ='\"'.s:netrw_passwd.'\"'
      endif
"      call Decho("filter input: ".getline('.'))
     elseif exists("s:netrw_passwd")
      keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"      call Decho("filter input: ".getline('.'))
     endif
    endif

    if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
     keepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('.'))
    endif
    if exists("g:netrw_ftpextracmd")
     keepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('.'))
    endif
    keepj put ='get \"'.netrw_fname.'\" '.tmpfile
"    call Decho("filter input: ".getline('.'))

    " perform ftp:
    " -i       : turns off interactive prompting from ftp
    " -n  unix : DON'T use <.netrc>, even though it exists
    " -n  win32: quit being obnoxious about password
    keepj norm! 1Gdd
"    call Decho("executing: %!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
"     call Decho("error<".getline(1).">")
     if !exists("g:netrw_quiet")
      call netrw#ErrorMsg(s:ERROR,getline(1),5)
     endif
    endif
    call s:SaveBufVars()|bd!|call s:RestoreBufVars()
    let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (scp) NetRead Method #4 {{{3
   elseif     b:netrw_method  == 4	" read with scp
"    call Decho("read via scp (method #4)")
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
"    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1))
    exe s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1)
    let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (http) NetRead Method #5 (wget) {{{3
   elseif     b:netrw_method  == 5
"    call Decho("read via http (method #5)")
    if g:netrw_http_cmd == ""
     if !exists("g:netrw_quiet")
      call netrw#ErrorMsg(s:ERROR,"neither the wget nor the fetch command is available",6)
     endif
"     call Dret("netrw#NetRead :4 getcwd<".getcwd().">")
     return
    endif

    if match(b:netrw_fname,"#") == -1 || exists("g:netrw_http_xcmd")
     " using g:netrw_http_cmd (usually elinks, links, curl, wget, or fetch)
"     call Decho('using '.g:netrw_http_cmd.' (# not in b:netrw_fname<'.b:netrw_fname.">)")
     if exists("g:netrw_http_xcmd")
"      call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".shellescape(tmpfile,1))
      exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".shellescape(tmpfile,1)
     else
"      call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1))
      exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1)
     endif
     let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)

    else
     " wget/curl/fetch plus a jump to an in-page marker (ie. http://abc/def.html#aMarker)
"     call Decho("wget/curl plus jump (# in b:netrw_fname<".b:netrw_fname.">)")
     let netrw_html= substitute(b:netrw_fname,"#.*$","","")
     let netrw_tag = substitute(b:netrw_fname,"^.*#","","")
"     call Decho("netrw_html<".netrw_html.">")
"     call Decho("netrw_tag <".netrw_tag.">")
"     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape(b:netrw_http."://".g:netrw_machine.netrw_html,1))
     exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape(b:netrw_http."://".g:netrw_machine.netrw_html,1)
     let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
"     call Decho('<\s*a\s*name=\s*"'.netrw_tag.'"/')
     exe 'keepj norm! 1G/<\s*a\s*name=\s*"'.netrw_tag.'"/'."\<CR>"
    endif
    let b:netrw_lastfile = choice
"    call Decho("setl ro")
    setl ro nomod

   ".........................................
   " NetRead: (dav) NetRead Method #6 {{{3
   elseif     b:netrw_method  == 6
"    call Decho("read via cadaver (method #6)")

    if !executable(g:netrw_dav_cmd)
     call netrw#ErrorMsg(s:ERROR,g:netrw_dav_cmd." is not executable",73)
"     call Dret("netrw#NetRead : ".g:netrw_dav_cmd." not executable")
     return
    endif
    if g:netrw_dav_cmd =~ "curl"
"     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_dav_cmd." ".shellescape("dav://".g:netrw_machine.b:netrw_fname,1)." ".shellescape(tmpfile,1))
     exe s:netrw_silentxfer."!".g:netrw_dav_cmd." ".shellescape("dav://".g:netrw_machine.b:netrw_fname,1)." ".shellescape(tmpfile,1)
    else
     " Construct execution string (four lines) which will be passed through filter
     let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
     new
     setl ff=unix
     if exists("g:netrw_port") && g:netrw_port != ""
      keepj put ='open '.g:netrw_machine.' '.g:netrw_port
     else
      keepj put ='open '.g:netrw_machine
     endif
     if exists("g:netrw_uid") && exists("s:netrw_passwd") && g:netrw_uid != ""
      keepj put ='user '.g:netrw_uid.' '.s:netrw_passwd
     endif
     keepj put ='get '.netrw_fname.' '.tmpfile
     keepj put ='quit'

     " perform cadaver operation:
     keepj norm! 1Gdd
"    call Decho("executing: %!".g:netrw_dav_cmd)
     exe s:netrw_silentxfer."%!".g:netrw_dav_cmd
     bd!
    endif
    let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (rsync) NetRead Method #7 {{{3
   elseif     b:netrw_method  == 7
"    call Decho("read via rsync (method #7)")
"    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1))
    exe s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1)
    let result		 = s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (fetch) NetRead Method #8 {{{3
   "    fetch://[user@]host[:http]/path
   elseif     b:netrw_method  == 8
"    call Decho("read via fetch (method #8)")
    if g:netrw_fetch_cmd == ""
     if !exists("g:netrw_quiet")
      keepj call netrw#ErrorMsg(s:ERROR,"fetch command not available",7)
     endif
"     call Dret("NetRead")
     return
    endif
    if exists("g:netrw_option") && g:netrw_option =~ ":https\="
     let netrw_option= "http"
    else
     let netrw_option= "ftp"
    endif
"    call Decho("read via fetch for ".netrw_option)

    if exists("g:netrw_uid") && g:netrw_uid != "" && exists("s:netrw_passwd") && s:netrw_passwd != ""
"     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".shellescape(tmpfile,1)." ".shellescape(netrw_option."://".g:netrw_uid.':'.s:netrw_passwd.'@'.g:netrw_machine."/".b:netrw_fname,1))
     exe s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".shellescape(tmpfile,1)." ".shellescape(netrw_option."://".g:netrw_uid.':'.s:netrw_passwd.'@'.g:netrw_machine."/".b:netrw_fname,1)
    else
"     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".shellescape(tmpfile,1)." ".shellescape(netrw_option."://".g:netrw_machine."/".b:netrw_fname,1))
     exe s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".shellescape(tmpfile,1)." ".shellescape(netrw_option."://".g:netrw_machine."/".b:netrw_fname,1)
    endif

    let result		= s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice
"    call Decho("setl ro")
    setl ro nomod

   ".........................................
   " NetRead: (sftp) NetRead Method #9 {{{3
   elseif     b:netrw_method  == 9
"    call Decho("read via sftp (method #9)")
"    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".tmpfile)
    exe s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".tmpfile
    let result		= s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: Complain {{{3
   else
    call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",8)
   endif
  endwhile

  " NetRead: cleanup {{{3
  if exists("b:netrw_method")
"   call Decho("cleanup b:netrw_method and b:netrw_fname")
   unlet b:netrw_method
   unlet b:netrw_fname
  endif
  if s:FileReadable(tmpfile) && tmpfile !~ '.tar.bz2$' && tmpfile !~ '.tar.gz$' && tmpfile !~ '.zip' && tmpfile !~ '.tar' && readcmd != 't' && tmpfile !~ '.tar.xz$' && tmpfile !~ '.txz'
"   call Decho("cleanup by deleting tmpfile<".tmpfile.">")
   keepj call s:NetrwDelete(tmpfile)
  endif
  keepj call s:NetrwOptionRestore("w:")

"  call Dret("netrw#NetRead :5 getcwd<".getcwd().">")
endfun

" ------------------------------------------------------------------------
" netrw#NetWrite: responsible for writing a file over the net {{{2
fun! netrw#NetWrite(...) range
"  call Dfunc("netrw#NetWrite(a:0=".a:0.") ".g:loaded_netrw)

  " NetWrite: option handling {{{3
  let mod= 0
  call s:NetrwOptionSave("w:")
  call s:NetrwSafeOptions()

  " NetWrite: Get Temporary Filename {{{3
  let tmpfile= s:GetTempfile("")
  if tmpfile == ""
"   call Dret("netrw#NetWrite : unable to get a tempfile!")
   return
  endif

  if a:0 == 0
   let ichoice = 0
  else
   let ichoice = 1
  endif

  let curbufname= expand("%")
"  call Decho("curbufname<".curbufname.">")
  if &binary
   " For binary writes, always write entire file.
   " (line numbers don't really make sense for that).
   " Also supports the writing of tar and zip files.
"   call Decho("(write entire file) sil exe w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile))
   exe "sil keepj w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
  elseif g:netrw_cygwin
   " write (selected portion of) file to temporary
   let cygtmpfile= substitute(tmpfile,g:netrw_cygdrive.'/\(.\)','\1:','')
"   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile))
   exe "sil keepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile)
  else
   " write (selected portion of) file to temporary
"   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile))
   exe "sil keepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
  endif

  if curbufname == ""
   " when the file is [No Name], and one attempts to Nwrite it, the buffer takes
   " on the temporary file's name.  Deletion of the temporary file during
   " cleanup then causes an error message.
   0file!
  endif

  " NetWrite: while choice loop: {{{3
  while ichoice <= a:0

   " Process arguments: {{{4
   " attempt to repeat with previous host-file-etc
   if exists("b:netrw_lastfile") && a:0 == 0
"    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">")
    let choice = b:netrw_lastfile
    let ichoice= ichoice + 1
   else
    exe "let choice= a:" . ichoice

    " Reconstruct Choice when choice starts with '"'
    if match(choice,"?") == 0
     echomsg 'NetWrite Usage:"'
     echomsg ':Nwrite machine:path                        uses rcp'
     echomsg ':Nwrite "machine path"                      uses ftp with <.netrc>'
     echomsg ':Nwrite "machine id password path"          uses ftp'
     echomsg ':Nwrite dav://[user@]machine/path           uses cadaver'
     echomsg ':Nwrite fetch://[user@]machine/path         uses fetch'
     echomsg ':Nwrite ftp://machine[#port]/path           uses ftp  (autodetects <.netrc>)'
     echomsg ':Nwrite rcp://machine/path                  uses rcp'
     echomsg ':Nwrite rsync://[user@]machine/path         uses rsync'
     echomsg ':Nwrite scp://[user@]machine[[:#]port]/path uses scp'
     echomsg ':Nwrite sftp://[user@]machine/path          uses sftp'
     sleep 4
     break

    elseif match(choice,"^\"") != -1
     if match(choice,"\"$") != -1
       " case "..."
      let choice=strpart(choice,1,strlen(choice)-2)
     else
      "  case "... ... ..."
      let choice      = strpart(choice,1,strlen(choice)-1)
      let wholechoice = ""

      while match(choice,"\"$") == -1
       let wholechoice= wholechoice . " " . choice
       let ichoice    = ichoice + 1
       if choice > a:0
       	if !exists("g:netrw_quiet")
	 call netrw#ErrorMsg(s:ERROR,"Unbalanced string in filename '". wholechoice ."'",13)
	endif
"        call Dret("netrw#NetWrite")
        return
       endif
       let choice= a:{ichoice}
      endwhile
      let choice= strpart(wholechoice,1,strlen(wholechoice)-1) . " " . strpart(choice,0,strlen(choice)-1)
     endif
    endif
   endif
   let ichoice= ichoice + 1
"   call Decho("choice<" . choice . "> ichoice=".ichoice)

   " Determine method of write (ftp, rcp, etc) {{{4
   keepj call s:NetrwMethod(choice)
   if !exists("b:netrw_method") || b:netrw_method < 0
"    call Dfunc("netrw#NetWrite : unsupported method")
    return
   endif

   " =============
   " NetWrite: Perform Protocol-Based Write {{{3
   " ============================
   if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1
    echo "(netrw) Processing your write request..."
"    call Decho("(netrw) Processing your write request...")
   endif

   ".........................................
   " NetWrite: (rcp) NetWrite Method #1 {{{3
   if  b:netrw_method == 1
"    call Decho("write via rcp (method #1)")
    if s:netrw_has_nt_rcp == 1
     if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
      let uid_machine = g:netrw_machine .'.'. g:netrw_uid
     else
      let uid_machine = g:netrw_machine .'.'. $USERNAME
     endif
    else
     if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
      let uid_machine = g:netrw_uid .'@'. g:netrw_machine
     else
      let uid_machine = g:netrw_machine
     endif
    endif
"    call Decho("executing: !".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".shellescape(tmpfile,1)." ".shellescape(uid_machine.":".b:netrw_fname,1))
    exe s:netrw_silentxfer."!".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".shellescape(tmpfile,1)." ".shellescape(uid_machine.":".b:netrw_fname,1)
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (ftp + <.netrc>) NetWrite Method #2 {{{3
   elseif b:netrw_method == 2
"    call Decho("write via ftp+.netrc (method #2)")
    let netrw_fname = b:netrw_fname

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let bhkeep      = &l:bh
    let curbuf      = bufnr("%")
    setl bh=hide
    keepalt enew

"    call Decho("filter input window#".winnr())
    setl ff=unix
    keepj put =g:netrw_ftpmode
"    call Decho("filter input: ".getline('$'))
    if exists("g:netrw_ftpextracmd")
     keepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline("$"))
    endif
    keepj call setline(line("$")+1,'put "'.tmpfile.'" "'.netrw_fname.'"')
"    call Decho("filter input: ".getline("$"))
    if exists("g:netrw_port") && g:netrw_port != ""
"     call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
     exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
    else
"     call Decho("filter input window#".winnr())
"     call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
     exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
    endif
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
     if !exists("g:netrw_quiet")
      keepj call netrw#ErrorMsg(s:ERROR,getline(1),14)
     endif
     let mod=1
    endif

    " remove enew buffer (quietly)
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh            = bhkeep
    exe filtbuf."bw!"

    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (ftp + machine, id, passwd, filename) NetWrite Method #3 {{{3
   elseif b:netrw_method == 3
    " Construct execution string (three or more lines) which will be passed through filter
"    call Decho("read via ftp+mipf (method #3)")
    let netrw_fname = b:netrw_fname
    let bhkeep      = &l:bh

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let curbuf      = bufnr("%")
    setl bh=hide
    keepalt enew
    setl ff=unix

    if exists("g:netrw_port") && g:netrw_port != ""
     keepj put ='open '.g:netrw_machine.' '.g:netrw_port
"     call Decho("filter input: ".getline('.'))
    else
     keepj put ='open '.g:netrw_machine
"     call Decho("filter input: ".getline('.'))
    endif
    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      keepj put =g:netrw_uid
"      call Decho("filter input: ".getline('.'))
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       keepj put ='\"'.s:netrw_passwd.'\"'
      endif
"      call Decho("filter input: ".getline('.'))
     elseif exists("s:netrw_passwd") && s:netrw_passwd != ""
      keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"      call Decho("filter input: ".getline('.'))
     endif
    endif
    keepj put =g:netrw_ftpmode
"    call Decho("filter input: ".getline('$'))
    if exists("g:netrw_ftpextracmd")
     keepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline("$"))
    endif
    keepj put ='put \"'.tmpfile.'\" \"'.netrw_fname.'\"'
"    call Decho("filter input: ".getline('.'))
    " save choice/id/password for future use
    let b:netrw_lastfile = choice

    " perform ftp:
    " -i       : turns off interactive prompting from ftp
    " -n  unix : DON'T use <.netrc>, even though it exists
    " -n  win32: quit being obnoxious about password
    keepj norm! 1Gdd
"    call Decho("executing: %!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
     if  !exists("g:netrw_quiet")
      call netrw#ErrorMsg(s:ERROR,getline(1),15)
     endif
     let mod=1
    endif

    " remove enew buffer (quietly)
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh= bhkeep
    exe filtbuf."bw!"

   ".........................................
   " NetWrite: (scp) NetWrite Method #4 {{{3
   elseif     b:netrw_method == 4
"    call Decho("write via scp (method #4)")
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".fnameescape(g:netrw_port)
    else
     let useport= ""
    endif
"    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".shellescape(tmpfile,1)." ".shellescape(g:netrw_machine.":".b:netrw_fname,1))
    exe s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".shellescape(tmpfile,1)." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (http) NetWrite Method #5 {{{3
   elseif     b:netrw_method == 5
"    call Decho("write via http (method #5)")
    let curl= substitute(g:netrw_http_put_cmd,'\s\+.*$',"","")
    if executable(curl)
     let url= g:netrw_choice
"     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_put_cmd." ".shellescape(tmpfile,1)." ".shellescape(url,1) )
     exe s:netrw_silentxfer."!".g:netrw_http_put_cmd." ".shellescape(tmpfile,1)." ".shellescape(url,1) 
    elseif !exists("g:netrw_quiet")
     call netrw#ErrorMsg(s:ERROR,"can't write to http using <".g:netrw_http_put_cmd".">".",16)
    endif

   ".........................................
   " NetWrite: (dav) NetWrite Method #6 (cadaver) {{{3
   elseif     b:netrw_method == 6
"    call Decho("write via cadaver (method #6)")

    " Construct execution string (four lines) which will be passed through filter
    let netrw_fname = escape(b:netrw_fname,g:netrw_fname_escape)
    let bhkeep      = &l:bh

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let curbuf      = bufnr("%")
    setl bh=hide
    keepalt enew

    setl ff=unix
    if exists("g:netrw_port") && g:netrw_port != ""
     keepj put ='open '.g:netrw_machine.' '.g:netrw_port
    else
     keepj put ='open '.g:netrw_machine
    endif
    if exists("g:netrw_uid") && exists("s:netrw_passwd") && g:netrw_uid != ""
     keepj put ='user '.g:netrw_uid.' '.s:netrw_passwd
    endif
    keepj put ='put '.tmpfile.' '.netrw_fname

    " perform cadaver operation:
    keepj norm! 1Gdd
"    call Decho("executing: %!".g:netrw_dav_cmd)
    exe s:netrw_silentxfer."%!".g:netrw_dav_cmd

    " remove enew buffer (quietly)
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh            = bhkeep
    exe filtbuf."bw!"

    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (rsync) NetWrite Method #7 {{{3
   elseif     b:netrw_method == 7
"    call Decho("write via rsync (method #7)")
"    call Decho("executing: !".g:netrw_rsync_cmd." ".shellescape(tmpfile,1)." ".shellescape(g:netrw_machine.":".b:netrw_fname,1))
    exe s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".shellescape(tmpfile,1)." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (sftp) NetWrite Method #9 {{{3
   elseif     b:netrw_method == 9
"    call Decho("write via sftp (method #9)")
    let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
    if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
     let uid_machine = g:netrw_uid .'@'. g:netrw_machine
    else
     let uid_machine = g:netrw_machine
    endif

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let bhkeep = &l:bh
    let curbuf = bufnr("%")
    setl bh=hide
    keepalt enew

    setl ff=unix
    call setline(1,'put "'.escape(tmpfile,'\').'" '.netrw_fname)
"    call Decho("filter input: ".getline('.'))
"    call Decho("executing: %!".g:netrw_sftp_cmd.' '.shellescape(uid_machine,1))
    let sftpcmd= substitute(g:netrw_sftp_cmd,"%TEMPFILE%",escape(tmpfile,'\'),"g")
    exe s:netrw_silentxfer."%!".sftpcmd.' '.shellescape(uid_machine,1)
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh            = bhkeep
    exe filtbuf."bw!"
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: Complain {{{3
   else
    call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",17)
    let leavemod= 1
   endif
  endwhile

  " NetWrite: Cleanup: {{{3
"  call Decho("cleanup")
  if s:FileReadable(tmpfile)
"   call Decho("tmpfile<".tmpfile."> readable, will now delete it")
   call s:NetrwDelete(tmpfile)
  endif
  call s:NetrwOptionRestore("w:")

  if a:firstline == 1 && a:lastline == line("$")
   " restore modifiability; usually equivalent to set nomod
   let &mod= mod
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
  elseif !exists("leavemod")
   " indicate that the buffer has not been modified since last written
"   call Decho("set nomod")
   setl nomod
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
  endif

"  call Dret("netrw#NetWrite")
endfun

" ---------------------------------------------------------------------
" netrw#NetSource: source a remotely hosted vim script {{{2
" uses NetRead to get a copy of the file into a temporarily file,
"              then sources that file,
"              then removes that file.
fun! netrw#NetSource(...)
"  call Dfunc("netrw#NetSource() a:0=".a:0)
  if a:0 > 0 && a:1 == '?'
   " give help
   echomsg 'NetSource Usage:'
   echomsg ':Nsource dav://machine[:port]/path            uses cadaver'
   echomsg ':Nsource fetch://machine/path                 uses fetch'
   echomsg ':Nsource ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
   echomsg ':Nsource http[s]://[user@]machine/path        uses http  wget'
   echomsg ':Nsource rcp://[user@]machine/path            uses rcp'
   echomsg ':Nsource rsync://machine[:port]/path          uses rsync'
   echomsg ':Nsource scp://[user@]machine[[:#]port]/path  uses scp'
   echomsg ':Nsource sftp://[user@]machine[[:#]port]/path uses sftp'
   sleep 4
  else
   let i= 1
   while i <= a:0
    call netrw#NetRead(3,a:{i})
"    call Decho("s:netread_tmpfile<".s:netrw_tmpfile.">")
    if s:FileReadable(s:netrw_tmpfile)
"     call Decho("exe so ".fnameescape(s:netrw_tmpfile))
     exe "so ".fnameescape(s:netrw_tmpfile)
"     call Decho("delete(".s:netrw_tmpfile.")")
     call delete(s:netrw_tmpfile)
     unlet s:netrw_tmpfile
    else
     call netrw#ErrorMsg(s:ERROR,"unable to source <".a:{i}.">!",48)
    endif
    let i= i + 1
   endwhile
  endif
"  call Dret("netrw#NetSource")
endfun

" ---------------------------------------------------------------------
" netrw#SetTreetop: resets the tree top to the current directory/specified directory {{{2
"                   (implements the :Ntree command)
fun! netrw#SetTreetop(...)
"  call Dfunc("netrw#SetTreetop(".((a:0 > 0)? a:1 : "").") a:0=".a:0)

  " clear out the current tree
  if exists("w:netrw_treetop")
"   call Decho("clearing out current tree")
   let inittreetop= w:netrw_treetop
   unlet w:netrw_treetop
  endif
  if exists("w:netrw_treedict")
"   call Decho("freeing w:netrw_treedict")
   unlet w:netrw_treedict
  endif

  if a:1 == "" && exists("inittreetop")
   let treedir= s:NetrwTreePath(inittreetop)
"   call Decho("treedir<".treedir.">")
  else
   if isdirectory(a:1)
"    call Decho("a:1<".a:1."> is a directory")
    let treedir= a:1
   elseif exists("b:netrw_curdir") && isdirectory(b:netrw_curdir."/".a:1)
    let treedir= b:netrw_curdir."/".a:1
"    call Decho("a:1<".a:1."> is NOT a directory, trying treedir<".treedir.">")
   else
    call netrw#ErrorMsg(s:ERROR,"sorry, ".a:1." doesn't seem to be a directory!",95)
    let treedir= "."
   endif
  endif
"  call Decho("treedir<".treedir.">")
  let islocal= expand("%") !~ '^\a\+://'
"  call Decho("islocal=".islocal)
  if islocal
   call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(islocal,treedir))
  else
   call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,treedir))
  endif
"  call Dret("netrw#SetTreetop")
endfun

" ===========================================
" s:NetrwGetFile: Function to read temporary file "tfile" with command "readcmd". {{{2
"    readcmd == %r : replace buffer with newly read file
"            == 0r : read file at top of buffer
"            == r  : read file after current line
"            == t  : leave file in temporary form (ie. don't read into buffer)
fun! s:NetrwGetFile(readcmd, tfile, method)
"  call Dfunc("NetrwGetFile(readcmd<".a:readcmd.">,tfile<".a:tfile."> method<".a:method.">)")

  " readcmd=='t': simply do nothing
  if a:readcmd == 't'
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"   call Dret("NetrwGetFile : skip read of <".a:tfile.">")
   return
  endif

  " get name of remote filename (ie. url and all)
  let rfile= bufname("%")
"  call Decho("rfile<".rfile.">")

  if exists("*NetReadFixup")
   " for the use of NetReadFixup (not otherwise used internally)
   let line2= line("$")
  endif

  if a:readcmd[0] == '%'
  " get file into buffer
"   call Decho("get file into buffer")

   " rename the current buffer to the temp file (ie. tfile)
   if g:netrw_cygwin
    let tfile= substitute(a:tfile,g:netrw_cygdrive.'/\(.\)','\1:','')
   else
    let tfile= a:tfile
   endif
"   call Decho("exe sil! keepalt file ".fnameescape(tfile))
   exe "sil! keepalt file ".fnameescape(tfile)

   " edit temporary file (ie. read the temporary file in)
   if     rfile =~ '\.zip$'
"    call Decho("handling remote zip file with zip#Browse(tfile<".tfile.">)")
    call zip#Browse(tfile)
   elseif rfile =~ '\.tar$'
"    call Decho("handling remote tar file with tar#Browse(tfile<".tfile.">)")
    call tar#Browse(tfile)
   elseif rfile =~ '\.tar\.gz$'
"    call Decho("handling remote gzip-compressed tar file")
    call tar#Browse(tfile)
   elseif rfile =~ '\.tar\.bz2$'
"    call Decho("handling remote bz2-compressed tar file")
    call tar#Browse(tfile)
   elseif rfile =~ '\.tar\.xz$'
"    call Decho("handling remote xz-compressed tar file")
    call tar#Browse(tfile)
   elseif rfile =~ '\.txz$'
"    call Decho("handling remote xz-compressed tar file (.txz)")
    call tar#Browse(tfile)
   else
"    call Decho("edit temporary file")
    e!
   endif

   " rename buffer back to remote filename
"   call Decho("exe sil! keepalt file ".fnameescape(rfile))
   exe "sil! keepj keepalt file ".fnameescape(rfile)

   " Detect filetype of local version of remote file.
   " Note that isk must not include a "/" for scripts.vim
   " to process this detection correctly.
"   call Decho("detect filetype of local version of remote file")
   let iskkeep= &l:isk
   setl isk-=/
   let &l:isk= iskkeep
"   call Dredir("renamed buffer back to remote filename<".rfile."> : expand(%)<".expand("%").">","ls!")
   let line1 = 1
   let line2 = line("$")

  elseif !&ma
   " attempting to read a file after the current line in the file, but the buffer is not modifiable
   keepj call netrw#ErrorMsg(s:WARNING,"attempt to read<".a:tfile."> into a non-modifiable buffer!",94)
"   call Dret("NetrwGetFile : attempt to read<".a:tfile."> into a non-modifiable buffer!") 
   return

  elseif s:FileReadable(a:tfile)
   " read file after current line
"   call Decho("read file<".a:tfile."> after current line")
   let curline = line(".")
   let lastline= line("$")
"   call Decho("exe<".a:readcmd." ".fnameescape(v:cmdarg)." ".fnameescape(a:tfile).">  line#".curline)
   exe "keepj ".a:readcmd." ".fnameescape(v:cmdarg)." ".fnameescape(a:tfile)
   let line1= curline + 1
   let line2= line("$") - lastline + 1

  else
   " not readable
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"   call Decho("tfile<".a:tfile."> not readable")
   keepj call netrw#ErrorMsg(s:WARNING,"file <".a:tfile."> not readable",9)
"   call Dret("NetrwGetFile : tfile<".a:tfile."> not readable")
   return
  endif

  " User-provided (ie. optional) fix-it-up command
  if exists("*NetReadFixup")
"   call Decho("calling NetReadFixup(method<".a:method."> line1=".line1." line2=".line2.")")
   keepj call NetReadFixup(a:method, line1, line2)
"  else " Decho
"   call Decho("NetReadFixup() not called, doesn't exist  (line1=".line1." line2=".line2.")")
  endif

  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   " update the Buffers menu
   keepj call s:UpdateBuffersMenu()
  endif

"  call Decho("readcmd<".a:readcmd."> cmdarg<".v:cmdarg."> tfile<".a:tfile."> readable=".s:FileReadable(a:tfile))

 " make sure file is being displayed
"  redraw!

"  call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"  call Dret("NetrwGetFile")
endfun

" ------------------------------------------------------------------------
" s:NetrwMethod:  determine method of transfer {{{2
" Input:
"   choice = url   [protocol:]//[userid@]hostname[:port]/[path-to-file]
" Output:
"  b:netrw_method= 1: rcp                                             
"                  2: ftp + <.netrc>                                  
"	           3: ftp + machine, id, password, and [path]filename 
"	           4: scp                                             
"	           5: http[s] (wget)                                     
"	           6: dav
"	           7: rsync                                           
"	           8: fetch                                           
"	           9: sftp                                            
"  g:netrw_machine= hostname
"  b:netrw_fname  = filename
"  g:netrw_port   = optional port number (for ftp)
"  g:netrw_choice = copy of input url (choice)
fun! s:NetrwMethod(choice)
"   call Dfunc("NetrwMethod(a:choice<".a:choice.">)")

   " sanity check: choice should have at least three slashes in it
   if strlen(substitute(a:choice,'[^/]','','g')) < 3
    call netrw#ErrorMsg(s:ERROR,"not a netrw-style url; netrw uses protocol://[user@]hostname[:port]/[path])",78)
    let b:netrw_method = -1
"    call Dret("NetrwMethod : incorrect url format<".a:choice.">")
    return
   endif

   " record current g:netrw_machine, if any
   " curmachine used if protocol == ftp and no .netrc
   if exists("g:netrw_machine")
    let curmachine= g:netrw_machine
"    call Decho("curmachine<".curmachine.">")
   else
    let curmachine= "N O T A HOST"
   endif
   if exists("g:netrw_port")
    let netrw_port= g:netrw_port
   endif

   " insure that netrw_ftp_cmd starts off every method determination
   " with the current g:netrw_ftp_cmd
   let s:netrw_ftp_cmd= g:netrw_ftp_cmd

  " initialization
  let b:netrw_method  = 0
  let g:netrw_machine = ""
  let b:netrw_fname   = ""
  let g:netrw_port    = ""
  let g:netrw_choice  = a:choice

  " Patterns:
  " mipf     : a:machine a:id password filename	     Use ftp
  " mf	    : a:machine filename		     Use ftp + <.netrc> or g:netrw_uid s:netrw_passwd
  " ftpurm   : ftp://[user@]host[[#:]port]/filename  Use ftp + <.netrc> or g:netrw_uid s:netrw_passwd
  " rcpurm   : rcp://[user@]host/filename	     Use rcp
  " rcphf    : [user@]host:filename		     Use rcp
  " scpurm   : scp://[user@]host[[#:]port]/filename  Use scp
  " httpurm  : http[s]://[user@]host/filename	     Use wget
  " davurm   : dav[s]://host[:port]/path             Use cadaver/curl
  " rsyncurm : rsync://host[:port]/path              Use rsync
  " fetchurm : fetch://[user@]host[:http]/filename   Use fetch (defaults to ftp, override for http)
  " sftpurm  : sftp://[user@]host/filename  Use scp
  let mipf     = '^\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\)$'
  let mf       = '^\(\S\+\)\s\+\(\S\+\)$'
"  let ftpurm   = '^ftp://\(\([^/@]\{-}\)@\)\=\([^/#:]\{-}\)\([#:]\d\+\)\=/\(.*\)$'
"  let rcpurm   = '^rcp://\%(\([^/@]\{-}\)@\)\=\([^/]\{-}\)/\(.*\)$'
"  let fetchurm = '^fetch://\(\([^/@]\{-}\)@\)\=\([^/#:]\{-}\)\(:http\)\=/\(.*\)$'
  let ftpurm   = '^ftp://\(\([^/]*\)@\)\=\([^/#:]\{-}\)\([#:]\d\+\)\=/\(.*\)$'
  let rcpurm   = '^rcp://\%(\([^/]*\)@\)\=\([^/]\{-}\)/\(.*\)$'
  let rcphf    = '^\(\(\h\w*\)@\)\=\(\h\w*\):\([^@]\+\)$'
  let scpurm   = '^scp://\([^/#:]\+\)\%([#:]\(\d\+\)\)\=/\(.*\)$'
  let httpurm  = '^https\=://\([^/]\{-}\)\(/.*\)\=$'
  let davurm   = '^davs\=://\([^/]\+\)/\(.*/\)\([-_.~[:alnum:]]\+\)$'
  let rsyncurm = '^rsync://\([^/]\{-}\)/\(.*\)\=$'
  let fetchurm = '^fetch://\(\([^/]*\)@\)\=\([^/#:]\{-}\)\(:http\)\=/\(.*\)$'
  let sftpurm  = '^sftp://\([^/]\{-}\)/\(.*\)\=$'

"  call Decho("determine method:")
  " Determine Method
  " Method#1: rcp://user@hostname/...path-to-file {{{3
  if match(a:choice,rcpurm) == 0
"   call Decho("rcp://...")
   let b:netrw_method  = 1
   let userid          = substitute(a:choice,rcpurm,'\1',"")
   let g:netrw_machine = substitute(a:choice,rcpurm,'\2',"")
   let b:netrw_fname   = substitute(a:choice,rcpurm,'\3',"")
   if userid != ""
    let g:netrw_uid= userid
   endif

  " Method#4: scp://user@hostname/...path-to-file {{{3
  elseif match(a:choice,scpurm) == 0
"   call Decho("scp://...")
   let b:netrw_method  = 4
   let g:netrw_machine = substitute(a:choice,scpurm,'\1',"")
   let g:netrw_port    = substitute(a:choice,scpurm,'\2',"")
   let b:netrw_fname   = substitute(a:choice,scpurm,'\3',"")

  " Method#5: http[s]://user@hostname/...path-to-file {{{3
  elseif match(a:choice,httpurm) == 0
"   call Decho("http[s]://...")
   let b:netrw_method = 5
   let g:netrw_machine= substitute(a:choice,httpurm,'\1',"")
   let b:netrw_fname  = substitute(a:choice,httpurm,'\2',"")
   let b:netrw_http   = (a:choice =~ '^https:')? "https" : "http"

  " Method#6: dav://hostname[:port]/..path-to-file.. {{{3
  elseif match(a:choice,davurm) == 0
"   call Decho("dav://...")
   let b:netrw_method= 6
   if a:choice =~ 'davs:'
    let g:netrw_machine= 'https://'.substitute(a:choice,davurm,'\1/\2',"")
   else
    let g:netrw_machine= 'http://'.substitute(a:choice,davurm,'\1/\2',"")
   endif
   let b:netrw_fname  = substitute(a:choice,davurm,'\3',"")

   " Method#7: rsync://user@hostname/...path-to-file {{{3
  elseif match(a:choice,rsyncurm) == 0
"   call Decho("rsync://...")
   let b:netrw_method = 7
   let g:netrw_machine= substitute(a:choice,rsyncurm,'\1',"")
   let b:netrw_fname  = substitute(a:choice,rsyncurm,'\2',"")

   " Methods 2,3: ftp://[user@]hostname[[:#]port]/...path-to-file {{{3
  elseif match(a:choice,ftpurm) == 0
"   call Decho("ftp://...")
   let userid	      = substitute(a:choice,ftpurm,'\2',"")
   let g:netrw_machine= substitute(a:choice,ftpurm,'\3',"")
   let g:netrw_port   = substitute(a:choice,ftpurm,'\4',"")
   let b:netrw_fname  = substitute(a:choice,ftpurm,'\5',"")
"   call Decho("g:netrw_machine<".g:netrw_machine.">")
   if userid != ""
    let g:netrw_uid= userid
   endif

   if curmachine != g:netrw_machine
    if exists("s:netwr_hup[".g:netrw_machine."]")
     call NetUserPass("ftp:".g:netrw_machine)
    elseif exists("s:netrw_passwd")
     " if there's a change in hostname, require password re-entry
     unlet s:netrw_passwd
    endif
    if exists("netrw_port")
     unlet netrw_port
    endif
   endif

   if exists("g:netrw_uid") && exists("s:netrw_passwd")
    let b:netrw_method = 3
   else
    let host= substitute(g:netrw_machine,'\..*$','','')
    if exists("s:netrw_hup[host]")
     call NetUserPass("ftp:".host)

    elseif (has("win32") || has("win95") || has("win64") || has("win16")) && s:netrw_ftp_cmd =~ '-[sS]:'
"     call Decho("has -s: : s:netrw_ftp_cmd<".s:netrw_ftp_cmd.">")
"     call Decho("          g:netrw_ftp_cmd<".g:netrw_ftp_cmd.">")
     if g:netrw_ftp_cmd =~ '-[sS]:\S*MACHINE\>'
      let s:netrw_ftp_cmd= substitute(g:netrw_ftp_cmd,'\<MACHINE\>',g:netrw_machine,'')
"      call Decho("s:netrw_ftp_cmd<".s:netrw_ftp_cmd.">")
     endif
     let b:netrw_method= 2
    elseif s:FileReadable(expand("$HOME/.netrc")) && !g:netrw_ignorenetrc
"     call Decho("using <".expand("$HOME/.netrc")."> (readable)")
     let b:netrw_method= 2
    else
     if !exists("g:netrw_uid") || g:netrw_uid == ""
      call NetUserPass()
     elseif !exists("s:netrw_passwd") || s:netrw_passwd == ""
      call NetUserPass(g:netrw_uid)
    " else just use current g:netrw_uid and s:netrw_passwd
     endif
     let b:netrw_method= 3
    endif
   endif

  " Method#8: fetch {{{3
  elseif match(a:choice,fetchurm) == 0
"   call Decho("fetch://...")
   let b:netrw_method = 8
   let g:netrw_userid = substitute(a:choice,fetchurm,'\2',"")
   let g:netrw_machine= substitute(a:choice,fetchurm,'\3',"")
   let b:netrw_option = substitute(a:choice,fetchurm,'\4',"")
   let b:netrw_fname  = substitute(a:choice,fetchurm,'\5',"")

   " Method#3: Issue an ftp : "machine id password [path/]filename" {{{3
  elseif match(a:choice,mipf) == 0
"   call Decho("(ftp) host id pass file")
   let b:netrw_method  = 3
   let g:netrw_machine = substitute(a:choice,mipf,'\1',"")
   let g:netrw_uid     = substitute(a:choice,mipf,'\2',"")
   let s:netrw_passwd  = substitute(a:choice,mipf,'\3',"")
   let b:netrw_fname   = substitute(a:choice,mipf,'\4',"")
   call NetUserPass(g:netrw_machine,g:netrw_uid,s:netrw_passwd)

  " Method#3: Issue an ftp: "hostname [path/]filename" {{{3
  elseif match(a:choice,mf) == 0
"   call Decho("(ftp) host file")
   if exists("g:netrw_uid") && exists("s:netrw_passwd")
    let b:netrw_method  = 3
    let g:netrw_machine = substitute(a:choice,mf,'\1',"")
    let b:netrw_fname   = substitute(a:choice,mf,'\2',"")

   elseif s:FileReadable(expand("$HOME/.netrc"))
    let b:netrw_method  = 2
    let g:netrw_machine = substitute(a:choice,mf,'\1',"")
    let b:netrw_fname   = substitute(a:choice,mf,'\2',"")
   endif

  " Method#9: sftp://user@hostname/...path-to-file {{{3
  elseif match(a:choice,sftpurm) == 0
"   call Decho("sftp://...")
   let b:netrw_method = 9
   let g:netrw_machine= substitute(a:choice,sftpurm,'\1',"")
   let b:netrw_fname  = substitute(a:choice,sftpurm,'\2',"")

  " Method#1: Issue an rcp: hostname:filename"  (this one should be last) {{{3
  elseif match(a:choice,rcphf) == 0
"   call Decho("(rcp) [user@]host:file) rcphf<".rcphf.">")
   let b:netrw_method  = 1
   let userid          = substitute(a:choice,rcphf,'\2',"")
   let g:netrw_machine = substitute(a:choice,rcphf,'\3',"")
   let b:netrw_fname   = substitute(a:choice,rcphf,'\4',"")
"   call Decho('\1<'.substitute(a:choice,rcphf,'\1',"").">")
"   call Decho('\2<'.substitute(a:choice,rcphf,'\2',"").">")
"   call Decho('\3<'.substitute(a:choice,rcphf,'\3',"").">")
"   call Decho('\4<'.substitute(a:choice,rcphf,'\4',"").">")
   if userid != ""
    let g:netrw_uid= userid
   endif

  " Cannot Determine Method {{{3
  else
   if !exists("g:netrw_quiet")
    call netrw#ErrorMsg(s:WARNING,"cannot determine method (format: protocol://[user@]hostname[:port]/[path])",45)
   endif
   let b:netrw_method  = -1
  endif
  "}}}3

  if g:netrw_port != ""
   " remove any leading [:#] from port number
   let g:netrw_port = substitute(g:netrw_port,'[#:]\+','','')
  elseif exists("netrw_port")
   " retain port number as implicit for subsequent ftp operations
   let g:netrw_port= netrw_port
  endif

"  call Decho("a:choice       <".a:choice.">")
"  call Decho("b:netrw_method <".b:netrw_method.">")
"  call Decho("g:netrw_machine<".g:netrw_machine.">")
"  call Decho("g:netrw_port   <".g:netrw_port.">")
"  if exists("g:netrw_uid")		"Decho
"   call Decho("g:netrw_uid    <".g:netrw_uid.">")
"  endif					"Decho
"  if exists("s:netrw_passwd")		"Decho
"   call Decho("s:netrw_passwd <".s:netrw_passwd.">")
"  endif					"Decho
"  call Decho("b:netrw_fname  <".b:netrw_fname.">")
"  call Dret("NetrwMethod : b:netrw_method=".b:netrw_method." g:netrw_port=".g:netrw_port)
endfun

" ------------------------------------------------------------------------
" NetReadFixup: this sort of function is typically written by the user {{{2
"               to handle extra junk that their system's ftp dumps
"               into the transfer.  This function is provided as an
"               example and as a fix for a Windows 95 problem: in my
"               experience, win95's ftp always dumped four blank lines
"               at the end of the transfer.
if has("win95") && exists("g:netrw_win95ftp") && g:netrw_win95ftp
 fun! NetReadFixup(method, line1, line2)
"   call Dfunc("NetReadFixup(method<".a:method."> line1=".a:line1." line2=".a:line2.")")

   " sanity checks -- attempt to convert inputs to integers
   let method = a:method + 0
   let line1  = a:line1 + 0
   let line2  = a:line2 + 0
   if type(method) != 0 || type(line1) != 0 || type(line2) != 0 || method < 0 || line1 <= 0 || line2 <= 0
"    call Dret("NetReadFixup")
    return
   endif

   if method == 3   " ftp (no <.netrc>)
    let fourblanklines= line2 - 3
    if fourblanklines >= line1
     exe "sil keepj ".fourblanklines.",".line2."g/^\s*$/d"
     call histdel("/",-1)
    endif
   endif

"   call Dret("NetReadFixup")
 endfun
endif

" ---------------------------------------------------------------------
" NetUserPass: set username and password for subsequent ftp transfer {{{2
"   Usage:  :call NetUserPass()		               -- will prompt for userid and password
"	    :call NetUserPass("uid")	               -- will prompt for password
"	    :call NetUserPass("uid","password")        -- sets global userid and password
"	    :call NetUserPass("ftp:host")              -- looks up userid and password using hup dictionary
"	    :call NetUserPass("host","uid","password") -- sets hup dictionary with host, userid, password
fun! NetUserPass(...)

" call Dfunc("NetUserPass() a:0=".a:0)

 if !exists('s:netrw_hup')
  let s:netrw_hup= {}
 endif

 if a:0 == 0
  " case: no input arguments

  " change host and username if not previously entered; get new password
  if !exists("g:netrw_machine")
   let g:netrw_machine= input('Enter hostname: ')
  endif
  if !exists("g:netrw_uid") || g:netrw_uid == ""
   " get username (user-id) via prompt
   let g:netrw_uid= input('Enter username: ')
  endif
  " get password via prompting
  let s:netrw_passwd= inputsecret("Enter Password: ")

  " set up hup database
  let host = substitute(g:netrw_machine,'\..*$','','')
  if !exists('s:netrw_hup[host]')
   let s:netrw_hup[host]= {}
  endif
  let s:netrw_hup[host].uid    = g:netrw_uid
  let s:netrw_hup[host].passwd = s:netrw_passwd

 elseif a:0 == 1
  " case: one input argument

  if a:1 =~ '^ftp:'
   " get host from ftp:... url
   " access userid and password from hup (host-user-passwd) dictionary
"   call Decho("case a:0=1: a:1<".a:1."> (get host from ftp:... url)")
   let host = substitute(a:1,'^ftp:','','')
   let host = substitute(host,'\..*','','')
   if exists("s:netrw_hup[host]")
    let g:netrw_uid    = s:netrw_hup[host].uid
    let s:netrw_passwd = s:netrw_hup[host].passwd
"    call Decho("get s:netrw_hup[".host."].uid   <".s:netrw_hup[host].uid.">")
"    call Decho("get s:netrw_hup[".host."].passwd<".s:netrw_hup[host].passwd.">")
   else
    let g:netrw_uid    = input("Enter UserId: ")
    let s:netrw_passwd = inputsecret("Enter Password: ")
   endif

  else
   " case: one input argument, not an url.  Using it as a new user-id.
"   call Decho("case a:0=1: a:1<".a:1."> (get host from input argument, not an url)")
   if exists("g:netrw_machine")
    if g:netrw_machine =~ '[0-9.]\+'
     let host= g:netrw_machine
    else
     let host= substitute(g:netrw_machine,'\..*$','','')
    endif
   else
    let g:netrw_machine= input('Enter hostname: ')
   endif
   let g:netrw_uid = a:1
"   call Decho("set g:netrw_uid= <".g:netrw_uid.">")
   if exists("g:netrw_passwd")
    " ask for password if one not previously entered
    let s:netrw_passwd= g:netrw_passwd
   else
    let s:netrw_passwd = inputsecret("Enter Password: ")
   endif
  endif

"  call Decho("host<".host.">")
  if exists("host")
   if !exists('s:netrw_hup[host]')
    let s:netrw_hup[host]= {}
   endif
   let s:netrw_hup[host].uid    = g:netrw_uid
   let s:netrw_hup[host].passwd = s:netrw_passwd
  endif

 elseif a:0 == 2
  let g:netrw_uid    = a:1
  let s:netrw_passwd = a:2

 elseif a:0 == 3
  " enter hostname, user-id, and password into the hup dictionary
  let host = substitute(a:1,'^\a\+:','','')
  let host = substitute(host,'\..*$','','')
  if !exists('s:netrw_hup[host]')
   let s:netrw_hup[host]= {}
  endif
  let s:netrw_hup[host].uid    = a:2
  let s:netrw_hup[host].passwd = a:3
  let g:netrw_uid              = s:netrw_hup[host].uid
  let s:netrw_passwd           = s:netrw_hup[host].passwd
"  call Decho("set s:netrw_hup[".host."].uid   <".s:netrw_hup[host].uid.">")
"  call Decho("set s:netrw_hup[".host."].passwd<".s:netrw_hup[host].passwd.">")
 endif

" call Dret("NetUserPass : uid<".g:netrw_uid."> passwd<".s:netrw_passwd.">")
endfun

" ===========================================
"  Shared Browsing Support:    {{{1
" ===========================================

" ---------------------------------------------------------------------
" s:ExplorePatHls: converts an Explore pattern into a regular expression search pattern {{{2
fun! s:ExplorePatHls(pattern)
"  call Dfunc("s:ExplorePatHls(pattern<".a:pattern.">)")
  let repat= substitute(a:pattern,'^**/\{1,2}','','')
"  call Decho("repat<".repat.">")
  let repat= escape(repat,'][.\')
"  call Decho("repat<".repat.">")
  let repat= '\<'.substitute(repat,'\*','\\(\\S\\+ \\)*\\S\\+','g').'\>'
"  call Dret("s:ExplorePatHls repat<".repat.">")
  return repat
endfun

" ---------------------------------------------------------------------
"  s:NetrwBookHistHandler: {{{2
"    0: (user: <mb>)   bookmark current directory
"    1: (user: <gb>)   change to the bookmarked directory
"    2: (user: <qb>)   list bookmarks
"    3: (browsing)     record current directory history
"    4: (user: <u>)    go up   (previous) bookmark
"    5: (user: <U>)    go down (next)     bookmark
"    6: (user: <mB>)   delete bookmark
fun! s:NetrwBookHistHandler(chg,curdir)
"  call Dfunc("s:NetrwBookHistHandler(chg=".a:chg." curdir<".a:curdir.">) cnt=".v:count." histcnt=".g:netrw_dirhist_cnt." histmax=".g:netrw_dirhistmax)
  if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
"   "  call Dret("s:NetrwBookHistHandler - suppressed due to g:netrw_dirhistmax")
   return
  endif

  let ykeep= @@
  if a:chg == 0
   " bookmark the current directory
"   call Decho("(user: <b>) bookmark the current directory")
   if !exists("g:netrw_bookmarklist")
    let g:netrw_bookmarklist= []
   endif
   if index(g:netrw_bookmarklist,a:curdir) == -1
    " curdir not currently in g:netrw_bookmarklist, so include it
    call add(g:netrw_bookmarklist,a:curdir)
    call sort(g:netrw_bookmarklist)
   endif
   echo "bookmarked the current directory"

  elseif a:chg == 1
   " change to the bookmarked directory
"   call Decho("(user: <".v:count."gb>) change to the bookmarked directory")
   if exists("g:netrw_bookmarklist[v:count-1]")
"    call Decho("(user: <".v:count."gb>) bookmarklist=".string(g:netrw_bookmarklist))
    exe "keepj e ".fnameescape(g:netrw_bookmarklist[v:count-1])
   else
    echomsg "Sorry, bookmark#".v:count." doesn't exist!"
   endif

  elseif a:chg == 2
"   redraw!
   let didwork= 0
   " list user's bookmarks
"   call Decho("(user: <q>) list user's bookmarks")
   if exists("g:netrw_bookmarklist")
"    call Decho('list '.len(g:netrw_bookmarklist).' bookmarks')
    let cnt= 1
    for bmd in g:netrw_bookmarklist
"     call Decho("Netrw Bookmark#".cnt.": ".g:netrw_bookmarklist[cnt-1])
     echo printf("Netrw Bookmark#%-2d: %s",cnt,g:netrw_bookmarklist[cnt-1])
     let didwork = 1
     let cnt     = cnt + 1
    endfor
   endif

   " list directory history
   let cnt     = g:netrw_dirhist_cnt
   let first   = 1
   let histcnt = 0
   if g:netrw_dirhistmax > 0
    while ( first || cnt != g:netrw_dirhist_cnt )
"    call Decho("first=".first." cnt=".cnt." dirhist_cnt=".g:netrw_dirhist_cnt)
     if exists("g:netrw_dirhist_{cnt}")
"     call Decho("Netrw  History#".histcnt.": ".g:netrw_dirhist_{cnt})
      echo printf("Netrw  History#%-2d: %s",histcnt,g:netrw_dirhist_{cnt})
      let didwork= 1
     endif
     let histcnt = histcnt + 1
     let first   = 0
     let cnt     = ( cnt - 1 ) % g:netrw_dirhistmax
     if cnt < 0
      let cnt= cnt + g:netrw_dirhistmax
     endif
    endwhile
   else
    let g:netrw_dirhist_cnt= 0
   endif
   if didwork
    call inputsave()|call input("Press <cr> to continue")|call inputrestore()
   endif

  elseif a:chg == 3
   " saves most recently visited directories (when they differ)
"   call Decho("(browsing) record curdir history")
   if !exists("g:netrw_dirhist_cnt") || !exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}") || g:netrw_dirhist_{g:netrw_dirhist_cnt} != a:curdir
    if g:netrw_dirhistmax > 0
     let g:netrw_dirhist_cnt                   = ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
     let g:netrw_dirhist_{g:netrw_dirhist_cnt} = a:curdir
    endif
"    call Decho("save dirhist#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
   endif

  elseif a:chg == 4
   " u: change to the previous directory stored on the history list
"   call Decho("(user: <u>) chg to prev dir from history")
   if g:netrw_dirhistmax > 0
    let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - v:count1 ) % g:netrw_dirhistmax
    if g:netrw_dirhist_cnt < 0
     let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
    endif
   else
    let g:netrw_dirhist_cnt= 0
   endif
   if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
"    call Decho("changedir u#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
     setl ma noro
"     call Decho("setl ma noro")
     sil! keepj %d
     setl nomod
"     call Decho("setl nomod")
"     call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
    endif
"    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}))
    exe "keepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
   else
    if g:netrw_dirhistmax > 0
     let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + v:count1 ) % g:netrw_dirhistmax
    else
     let g:netrw_dirhist_cnt= 0
    endif
    echo "Sorry, no predecessor directory exists yet"
   endif

  elseif a:chg == 5
   " U: change to the subsequent directory stored on the history list
"   call Decho("(user: <U>) chg to next dir from history")
   if g:netrw_dirhistmax > 0
    let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
    if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
"    call Decho("changedir U#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
     if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
"      call Decho("setl ma noro")
      setl ma noro
      sil! keepj %d
"      call Decho("removed all lines from buffer (%d)")
"      call Decho("setl nomod")
      setl nomod
"      call Decho("(set nomod)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
     endif
"    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}))
     exe "keepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
    else
     let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - 1 ) % g:netrw_dirhistmax
     if g:netrw_dirhist_cnt < 0
      let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
     endif
     echo "Sorry, no successor directory exists yet"
    endif
   else
    let g:netrw_dirhist_cnt= 0
    echo "Sorry, no successor directory exists yet (g:netrw_dirhistmax is ".g:netrw_dirhistmax.")"
   endif

  elseif a:chg == 6
   " delete the v:count'th bookmark
"   call Decho("delete bookmark#".v:count."<".g:netrw_bookmarklist[v:count-1].">")
   let savefile= s:NetrwHome()."/.netrwbook"
   if filereadable(savefile)
"    call Decho("merge bookmarks (active and file)")
    keepj call s:NetrwBookHistSave() " done here to merge bookmarks first
"    call Decho("bookmark delete savefile<".savefile.">")
    keepj call delete(savefile)
   endif
"   call Decho("remove g:netrw_bookmarklist[".(v:count-1)."]")
   keepj call remove(g:netrw_bookmarklist,v:count-1)
"   call Decho("resulting g:netrw_bookmarklist=".string(g:netrw_bookmarklist))
  endif
  call s:NetrwBookmarkMenu()
  call s:NetrwTgtMenu()
  let @@= ykeep
"  call Dret("s:NetrwBookHistHandler")
endfun

" ---------------------------------------------------------------------
" s:NetrwBookHistRead: this function reads bookmarks and history {{{2
"                      Sister function: s:NetrwBookHistSave()
fun! s:NetrwBookHistRead()
"  call Dfunc("s:NetrwBookHistRead()")
  if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
"   "  call Dret("s:NetrwBookHistRead - suppressed due to g:netrw_dirhistmax")
   return
  endif
  let ykeep= @@
  if !exists("s:netrw_initbookhist")
   let home    = s:NetrwHome()
   let savefile= home."/.netrwbook"
   if filereadable(savefile)
"    call Decho("sourcing .netrwbook")
    exe "keepalt keepj so ".savefile
   endif
   if g:netrw_dirhistmax > 0
    let savefile= home."/.netrwhist"
    if filereadable(savefile)
"    call Decho("sourcing .netrwhist")
     exe "keepalt keepj so ".savefile
    endif
    let s:netrw_initbookhist= 1
    au VimLeave * call s:NetrwBookHistSave()
   endif
  endif
  let @@= ykeep
"  call Dret("s:NetrwBookHistRead")
endfun

" ---------------------------------------------------------------------
" s:NetrwBookHistSave: this function saves bookmarks and history {{{2
"                      Sister function: s:NetrwBookHistRead()
"                      I used to do this via viminfo but that appears to
"                      be unreliable for long-term storage
fun! s:NetrwBookHistSave()
"  call Dfunc("s:NetrwBookHistSave() dirhistmax=".g:netrw_dirhistmax)
  if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
"   call Dret("s:NetrwBookHistSave : dirhistmax=".g:netrw_dirhistmax)
   return
  endif

  let savefile= s:NetrwHome()."/.netrwhist"
  1split
  call s:NetrwEnew()
  setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000 noswf
  setl nocin noai noci magic nospell nohid wig= noaw
  setl ma noro write
  if exists("+acd") | setl noacd | endif
  sil! keepj keepalt %d

  " save .netrwhist -- no attempt to merge
  sil! keepalt file .netrwhist
  call setline(1,"let g:netrw_dirhistmax  =".g:netrw_dirhistmax)
  call setline(2,"let g:netrw_dirhist_cnt =".g:netrw_dirhist_cnt)
  let lastline = line("$")
  let cnt      = 1
  while cnt <= g:netrw_dirhist_cnt
   call setline((cnt+lastline),'let g:netrw_dirhist_'.cnt."='".g:netrw_dirhist_{cnt}."'")
   let cnt= cnt + 1
  endwhile
  exe "sil! w! ".savefile

  sil keepj %d
  if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != []
   " merge and write .netrwbook
   let savefile= s:NetrwHome()."/.netrwbook"

   if filereadable(savefile)
    let booklist= deepcopy(g:netrw_bookmarklist)
    exe "sil keepj keepalt so ".savefile
    for bdm in booklist
     if index(g:netrw_bookmarklist,bdm) == -1
      call add(g:netrw_bookmarklist,bdm)
     endif
    endfor
    call sort(g:netrw_bookmarklist)
    exe "sil! w! ".savefile
   endif

   " construct and save .netrwbook
   call setline(1,"let g:netrw_bookmarklist= ".string(g:netrw_bookmarklist))
   exe "sil! w! ".savefile
  endif
  let bgone= bufnr("%")
  q!
  exe "keepalt ".bgone."bwipe!"

"  call Dret("s:NetrwBookHistSave")
endfun

" ---------------------------------------------------------------------
" s:NetrwBrowse: This function uses the command in g:netrw_list_cmd to provide a {{{2
"  list of the contents of a local or remote directory.  It is assumed that the
"  g:netrw_list_cmd has a string, USEPORT HOSTNAME, that needs to be substituted
"  with the requested remote hostname first.
fun! s:NetrwBrowse(islocal,dirname)
  if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
"  call Dfunc("s:NetrwBrowse(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".w:netrw_liststyle." ".g:loaded_netrw." buf#".bufnr("%")."<".bufname("%")."> win#".winnr())
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
"  call Dredir("ls!")

  " s:NetrwBrowse: initialize history {{{3
  if !exists("s:netrw_initbookhist")
   keepj call s:NetrwBookHistRead()
  endif

  " s:NetrwBrowse: simplify the dirname (especially for ".."s in dirnames) {{{3
  if a:dirname !~ '^\a\+://'
   let dirname= simplify(a:dirname)
  else
   let dirname= a:dirname
  endif

  if exists("s:netrw_skipbrowse")
   unlet s:netrw_skipbrowse
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." filename<".expand("%")."> win#".winnr()." ft<".&ft.">")
"   call Dret("s:NetrwBrowse : s:netrw_skipbrowse existed")
   return
  endif

  " s:NetrwBrowse: sanity checks: {{{3
  if !exists("*shellescape")
   keepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing shellescape()",69)
"   call Dret("s:NetrwBrowse : missing shellescape()")
   return
  endif
  if !exists("*fnameescape")
   keepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing fnameescape()",70)
"   call Dret("s:NetrwBrowse : missing fnameescape()")
   return
  endif

  " s:NetrwBrowse: save options: {{{3
  call s:NetrwOptionSave("w:")                                                                                                            

  " s:NetrwBrowse: re-instate any marked files {{{3
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
"   call Decho("clearing marked files")
   exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
  endif

  if a:islocal && exists("w:netrw_acdkeep") && w:netrw_acdkeep
   " s:NetrwBrowse: set up "safe" options for local directory/file {{{3
"   call Decho("handle w:netrw_acdkeep:")
"   call Decho("keepjumps lcd ".fnameescape(dirname)." (due to w:netrw_acdkeep=".w:netrw_acdkeep." - acd=".&acd.")")
   call s:NetrwLcd(dirname)
   call s:NetrwSafeOptions()
"   call Decho("getcwd<".getcwd().">")

  elseif !a:islocal && dirname !~ '[\/]$' && dirname !~ '^"'
   " s:NetrwBrowse: looks like a remote regular file, attempt transfer {{{3
"   call Decho("attempt transfer as regular file<".dirname.">")

   " remove any filetype indicator from end of dirname, except for the
   " "this is a directory" indicator (/).
   " There shouldn't be one of those here, anyway.
   let path= substitute(dirname,'[*=@|]\r\=$','','e')
"   call Decho("new path<".path.">")
   call s:RemotePathAnalysis(dirname)

   " s:NetrwBrowse: remote-read the requested file into current buffer {{{3
   keepj mark '
   call s:NetrwEnew(dirname)
   call s:NetrwSafeOptions()
   setl ma noro
"   call Decho("setl ma noro")
   let b:netrw_curdir = dirname
   let url            = s:method."://".s:user.s:machine.(s:port ? ":".s:port : "")."/".s:path
"   call Decho("exe sil! keepalt file ".fnameescape(url)." (bt=".&bt.")")
   exe "sil! keepj keepalt file ".fnameescape(url)
   exe "sil! keepj keepalt doau BufReadPre ".fnameescape(s:fname)
   sil call netrw#NetRead(2,url)
   " netrw.vim and tar.vim have already handled decompression of the tarball; avoiding gzip.vim error
"   call Decho("url<".url.">")
"   call Decho("s:path<".s:path.">")
"   call Decho("s:fname<".s:fname.">")
   if s:path =~ '.bz2'
    exe "sil keepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.bz2$','',''))
   elseif s:path =~ '.gz'
    exe "sil keepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.gz$','',''))
   elseif s:path =~ '.gz'
    exe "sil keepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.txz$','',''))
   else
    exe "sil keepj keepalt doau BufReadPost ".fnameescape(s:fname)
   endif

   " s:NetrwBrowse: save certain window-oriented variables into buffer-oriented variables {{{3
   call s:SetBufWinVars()
   call s:NetrwOptionRestore("w:")
"   call Decho("setl ma nomod")
   setl ma nomod
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")

"   call Dret("s:NetrwBrowse : file<".s:fname.">")
   return
  endif

  " use buffer-oriented WinVars if buffer variables exist but associated window variables don't {{{3
  call s:UseBufWinVars()

  " set up some variables {{{3
  let b:netrw_browser_active = 1
  let dirname                = dirname
  let s:last_sort_by         = g:netrw_sort_by

  " set up menu {{{3
  keepj call s:NetrwMenu(1)

  " get/set-up buffer {{{3
  let reusing= s:NetrwGetBuffer(a:islocal,dirname)
  " maintain markfile highlighting
  if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
"   call Decho("bufnr(%)=".bufnr('%'))
"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/")
   exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
  else
"   call Decho("2match none")
   2match none
  endif
  if reusing && line("$") > 1
   call s:NetrwOptionRestore("w:")
"   call Decho("setl noma nomod nowrap")
   setl noma nomod nowrap
"   call Decho("(set noma nomod nowrap)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"   call Dret("s:NetrwBrowse : re-using buffer")
   return
  endif

  " set b:netrw_curdir to the new directory name {{{3
"  call Decho("set b:netrw_curdir to the new directory name<".dirname."> (buf#".bufnr("%").")")
  let b:netrw_curdir= dirname
  if b:netrw_curdir =~ '[/\\]$'
   let b:netrw_curdir= substitute(b:netrw_curdir,'[/\\]$','','e')
  endif
  if b:netrw_curdir =~ '\a:$' && (has("win32") || has("win95") || has("win64") || has("win16"))
   let b:netrw_curdir= b:netrw_curdir."/"
  endif
  if b:netrw_curdir == ''
   if has("amiga")
    " On the Amiga, the empty string connotes the current directory
    let b:netrw_curdir= getcwd()
   else
    " under unix, when the root directory is encountered, the result
    " from the preceding substitute is an empty string.
    let b:netrw_curdir= '/'
   endif
  endif
  if !a:islocal && b:netrw_curdir !~ '/$'
   let b:netrw_curdir= b:netrw_curdir.'/'
  endif
"  call Decho("b:netrw_curdir<".b:netrw_curdir.">")

  " ------------
  " (local only) {{{3
  " ------------
  if a:islocal
"   call Decho("local only:")

   " Set up ShellCmdPost handling.  Append current buffer to browselist
   call s:LocalFastBrowser()

  " handle g:netrw_keepdir: set vim's current directory to netrw's notion of the current directory {{{3
   if !g:netrw_keepdir
"    call Decho("handle g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
"    call Decho("l:acd".(exists("&l:acd")? "=".&l:acd : " doesn't exist"))
    if !exists("&l:acd") || !&l:acd
     call s:NetrwLcd(b:netrw_curdir)
    endif
   endif

  " --------------------------------
  " remote handling: {{{3
  " --------------------------------
  else
"   call Decho("remote only:")

   " analyze dirname and g:netrw_list_cmd {{{3
"   call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist")."> dirname<".dirname.">")
   if dirname =~ "^NetrwTreeListing\>"
    let dirname= b:netrw_curdir
"    call Decho("(dirname was <NetrwTreeListing>) dirname<".dirname.">")
   elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
    let dirname= substitute(b:netrw_curdir,'\\','/','g')
    if dirname !~ '/$'
     let dirname= dirname.'/'
    endif
    let b:netrw_curdir = dirname
"    call Decho("(liststyle is TREELIST) dirname<".dirname.">")
   else
    let dirname = substitute(dirname,'\\','/','g')
"    call Decho("(normal) dirname<".dirname.">")
   endif

   let dirpat  = '^\(\w\{-}\)://\(\w\+@\)\=\([^/]\+\)/\(.*\)$'
   if dirname !~ dirpat
    if !exists("g:netrw_quiet")
     keepj call netrw#ErrorMsg(s:ERROR,"netrw doesn't understand your dirname<".dirname.">",20)
    endif
    keepj call s:NetrwOptionRestore("w:")
"    call Decho("setl noma nomod nowrap")
    setl noma nomod nowrap
"    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"    call Dret("s:NetrwBrowse : badly formatted dirname<".dirname.">")
    return
   endif
   let b:netrw_curdir= dirname
"   call Decho("b:netrw_curdir<".b:netrw_curdir."> (remote)")
  endif  " (additional remote handling)

  " -----------------------
  " Directory Listing: {{{3
  " -----------------------
  keepj call s:NetrwMaps(a:islocal)
  keepj call s:NetrwCommands(a:islocal)
  keepj call s:PerformListing(a:islocal)
  if v:version >= 700 && has("balloon_eval") && &beval == 0 && &l:bexpr == "" && !exists("g:netrw_nobeval")
   let &l:bexpr= "netrw#BalloonHelp()"
"   call Decho("set up balloon help: l:bexpr=".&l:bexpr)
   setl beval
  endif
  call s:NetrwOptionRestore("w:")

  " The s:LocalBrowseRefresh() function is called by an autocmd
  " installed by s:LocalFastBrowser() when g:netrw_fastbrowse <= 1 (ie. slow, medium speed).
  " However, s:NetrwBrowse() causes the FocusGained event to fire the firstt time.

"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"  call Dret("s:NetrwBrowse : did PerformListing  ft<".&ft.">")
  return
endfun

" ---------------------------------------------------------------------
" s:NetrwFileInfo: supports qf (query for file information) {{{2
fun! s:NetrwFileInfo(islocal,fname)
"  call Dfunc("s:NetrwFileInfo(islocal=".a:islocal." fname<".a:fname.">) b:netrw_curdir<".b:netrw_curdir.">")
  let ykeep= @@
  if a:islocal
   if (has("unix") || has("macunix")) && executable("/bin/ls")

    if getline(".") == "../"
     echo system("/bin/ls -lsad ".shellescape(".."))
"     call Decho("#1: echo system(/bin/ls -lsad ".shellescape(..).")")

    elseif w:netrw_liststyle == s:TREELIST && getline(".") !~ '^'.s:treedepthstring
     echo system("/bin/ls -lsad ".shellescape(b:netrw_curdir))
"     call Decho("#2: echo system(/bin/ls -lsad ".shellescape(b:netrw_curdir).")")

    elseif exists("b:netrw_curdir")
     if b:netrw_curdir =~ '/$'
      echo system("/bin/ls -lsad ".shellescape(b:netrw_curdir.a:fname))
"      call Decho("#3: echo system(/bin/ls -lsad ".shellescape(b:netrw_curdir.a:fname).")")

     else
      echo system("/bin/ls -lsad ".shellescape(b:netrw_curdir."/".a:fname))
"      call Decho("#4: echo system(/bin/ls -lsad ".shellescape(b:netrw_curdir."/".a:fname).")")
     endif

    else
"     call Decho('using ls '.a:fname." using cwd<".getcwd().">")
     echo system("/bin/ls -lsad ".shellescape(a:fname))
"     call Decho("#5: echo system(/bin/ls -lsad ".shellescape(a:fname).")")
    endif
   else
    " use vim functions to return information about file below cursor
"    call Decho("using vim functions to query for file info")
    if !isdirectory(a:fname) && !filereadable(a:fname) && a:fname =~ '[*@/]'
     let fname= substitute(a:fname,".$","","")
    else
     let fname= a:fname
    endif
    let t  = getftime(fname)
    let sz = getfsize(fname)
    echo a:fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(fname))
"    call Decho("fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(fname)))
   endif
  else
   echo "sorry, \"qf\" not supported yet for remote files"
  endif
  let @@= ykeep
"  call Dret("s:NetrwFileInfo")
endfun

" ---------------------------------------------------------------------
" s:NetrwGetBuffer: {{{2
"   returns 0=cleared buffer
"           1=re-used buffer
fun! s:NetrwGetBuffer(islocal,dirname)
"  call Dfunc("s:NetrwGetBuffer(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".g:netrw_liststyle)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
  let dirname= a:dirname

  " re-use buffer if possible {{{3
"  call Decho("--re-use a buffer if possible--")
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
   " find NetrwTreeList buffer if there is one
"   call Decho("case liststyle=treelist: find NetrwTreeList buffer if there is one")
   if exists("w:netrw_treebufnr") && w:netrw_treebufnr > 0
"    call Decho("  re-using w:netrw_treebufnr=".w:netrw_treebufnr)
    let eikeep= &ei
    setl ei=all
    exe "sil! noswapfile keepalt b ".w:netrw_treebufnr
    let &ei= eikeep
    setl ma
    sil! keepj %d
"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"    call Dret("s:NetrwGetBuffer 0<buffer cleared> : bufnum#".w:netrw_treebufnr."<NetrwTreeListing>")
    return 0
   endif
   let bufnum= -1
"   call Decho("  liststyle=TREE but w:netrw_treebufnr doesn't exist")

  else
   " find buffer number of buffer named precisely the same as dirname {{{3
"   call Decho("case listtyle not treelist: find buffer numnber of buffer named precisely the same as dirname--")
"   call Dredir("(NetrwGetBuffer) ls!","ls!")

   " get dirname and associated buffer number
   let bufnum  = bufnr(escape(dirname,'\'))
"   call Decho("  find buffer<".dirname.">'s number ")
"   call Decho("  bufnr(dirname<".escape(dirname,'\').">)=".bufnum)

   if bufnum < 0 && dirname !~ '/$'
    " try appending a trailing /
"    call Decho("  try appending a trailing / to dirname<".dirname.">")
    let bufnum= bufnr(escape(dirname.'/','\'))
    if bufnum > 0
     let dirname= dirname.'/'
    endif
   endif

   if bufnum < 0 && dirname =~ '/$'
    " try removing a trailing /
"    call Decho("  try removing a trailing / from dirname<".dirname.">")
    let bufnum= bufnr(escape(substitute(dirname,'/$','',''),'\'))
    if bufnum > 0
     let dirname= substitute(dirname,'/$','','')
    endif
   endif

"   call Decho("  findbuf1: bufnum=bufnr('".dirname."')=".bufnum." bufname(".bufnum.")<".bufname(bufnum)."> (initial)")
   " note: !~ was used just below, but that means using ../ to go back would match (ie. abc/def/  and abc/ matches)
   if bufnum > 0 && bufname(bufnum) != dirname && bufname(bufnum) != '.'
    " handle approximate matches
"    call Decho("  handling approx match: bufnum#".bufnum.">0 AND bufname<".bufname(bufnum).">!=dirname<".dirname."> AND bufname(".bufnum.")!='.'")
    let ibuf    = 1
    let buflast = bufnr("$")
"    call Decho("  findbuf2: buflast=bufnr($)=".buflast)
    while ibuf <= buflast
     let bname= substitute(bufname(ibuf),'\\','/','g')
     let bname= substitute(bname,'.\zs/$','','')
"     call Decho("  findbuf3: while [ibuf=",ibuf."]<=[buflast=".buflast."]: dirname<".dirname."> bname=bufname(".ibuf.")<".bname.">")
     if bname != '' && dirname =~ '/'.bname.'/\=$' && dirname !~ '^/'
      " bname is not empty
      " dirname ends with bname,
      " dirname doesn't start with /, so its not a absolute path
"      call Decho("  findbuf3a: passes test 1 : dirname<".dirname.'> =~ /'.bname.'/\=$ && dirname !~ ^/')
      break
     endif
     if bname =~ '^'.dirname.'/\=$'
      " bname begins with dirname
"      call Decho('  findbuf3b: passes test 2 : bname<'.bname.'>=~^'.dirname.'/\=$')
      break
     endif
     if dirname =~ '^'.bname.'/$'
"      call Decho('  findbuf3c: passes test 3 : dirname<'.dirname.'>=~^'.bname.'/$')
      break
     endif
     if bname != '' && dirname =~ '/'.bname.'$' && bname == bufname("%") && line("$") == 1
"      call Decho('  findbuf3d: passes test 4 : dirname<'.dirname.'>=~ /'.bname.'$')
      break
     endif
     let ibuf= ibuf + 1
    endwhile
    if ibuf > buflast
     let bufnum= -1
    else
     let bufnum= ibuf
    endif
"    call Decho("  findbuf4: bufnum=".bufnum." (ibuf=".ibuf." buflast=".buflast.")")
   endif
  endif

  " get enew buffer and name it -or- re-use buffer {{{3
"  call Decho("  get enew buffer and name it OR re-use buffer")
  sil! keepj keepalt mark '
  if bufnum < 0 || !bufexists(bufnum)
"   call Decho("--get enew buffer and name it  (bufnum#".bufnum."<0 OR bufexists(".bufnum.")=".bufexists(bufnum)."==0)")
   call s:NetrwEnew(dirname)
"   call Decho("  got enew buffer#".bufnr("%")." (altbuf<".expand("#").">)")
   " name the buffer
   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
    " Got enew buffer; transform into a NetrwTreeListing
"    call Decho("--transform enew buffer#".bufnr("%")." into a NetrwTreeListing --")
    if !exists("s:netrw_treelistnum")
     let s:netrw_treelistnum= 1
    else
     let s:netrw_treelistnum= s:netrw_treelistnum + 1
    endif
    let w:netrw_treebufnr= bufnr("%")
"    call Decho("  exe sil! keepalt file NetrwTreeListing ".fnameescape(s:netrw_treelistnum))
    exe 'sil! keepalt file NetrwTreeListing\ '.fnameescape(s:netrw_treelistnum)
    setl bt=nofile noswf
    nnoremap <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
    nnoremap <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
    nnoremap <silent> <buffer> [[       :sil call <SID>TreeListMove('[')<cr>
    nnoremap <silent> <buffer> ]]       :sil call <SID>TreeListMove(']')<cr>
"    call Decho("  tree listing#".s:netrw_treelistnum." bufnr=".w:netrw_treebufnr)
   else
"    let v:errmsg= "" " Decho
    let escdirname= fnameescape(dirname)
"    call Decho("  errmsg<".v:errmsg."> bufnr(escdirname<".escdirname.">)=".bufnr(escdirname)." bufname()<".bufname(bufnr(escdirname)).">")
"    call Decho('  exe sil! keepalt file '.escdirname)
"    let v:errmsg= "" " Decho
    exe 'sil! keepalt file '.escdirname
"    call Decho("  errmsg<".v:errmsg."> bufnr(".escdirname.")=".bufnr(escdirname)."<".bufname(bufnr(escdirname)).">")
   endif
"   call Decho("  named enew buffer#".bufnr("%")."<".bufname("%").">")

  else " Re-use the buffer
"   call Decho("--re-use buffer#".bufnum." (bufnum#".bufnum.">=0 AND bufexists(".bufnum.")=".bufexists(bufnum)."!=0)")
   let eikeep= &ei
   setl ei=all
   if getline(2) =~ '^" Netrw Directory Listing'
"    call Decho("  getline(2)<".getline(2).'> matches "Netrw Directory Listing" : using keepalt b '.bufnum)
    exe "sil! noswapfile keepalt b ".bufnum
   else
"    call Decho("  getline(2)<".getline(2).'> does not match "Netrw Directory Listing" : using b '.bufnum)
    exe "sil! noswapfile keepalt b ".bufnum
   endif
   if bufname("%") == '.'
"    call Decho("exe sil! keepalt file ".fnameescape(getcwd()))
    exe "sil! keepalt file ".fnameescape(getcwd())
   endif
   let &ei= eikeep
   if line("$") <= 1
    keepj call s:NetrwListSettings(a:islocal)
"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"    call Dret("s:NetrwGetBuffer 0<buffer empty> : re-using buffer#".bufnr("%").", but its empty, so refresh it")
    return 0
   elseif g:netrw_fastbrowse == 0 || (a:islocal && g:netrw_fastbrowse == 1)
    keepj call s:NetrwListSettings(a:islocal)
    sil keepj %d
"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but refreshing due to g:netrw_fastbrowse=".g:netrw_fastbrowse)
    return 0
   elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
"    call Decho("--re-use tree listing--")
"    call Decho("  clear buffer<".expand("%")."> with :%d")
    sil keepj %d
    keepj call s:NetrwListSettings(a:islocal)
"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but treelist mode always needs a refresh")
    return 0
   else
"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"    call Dret("s:NetrwGetBuffer 1<buffer not cleared> : buf#".bufnr("%"))
    return 1
   endif
  endif

  " do netrw settings: make this buffer not-a-file, modifiable, not line-numbered, etc {{{3
  "     fastbrowse  Local  Remote   Hiding a buffer implies it may be re-used (fast)
  "  slow   0         D      D      Deleting a buffer implies it will not be re-used (slow)
  "  med    1         D      H
  "  fast   2         H      H
"  call Decho("--do netrw settings: make this buffer#".bufnr("%")." not-a-file, modifiable, not line-numbered, etc--")
  let fname= expand("%")
  keepj call s:NetrwListSettings(a:islocal)
"  call Decho("exe sil! keepalt file ".fnameescape(fname))
  exe "sil! keepj keepalt file ".fnameescape(fname)

  " delete all lines from buffer {{{3
"  call Decho("--delete all lines from buffer--")
"  call Decho("  clear buffer<".expand("%")."> with :%d")
  sil! keepalt keepj %d

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"  call Dret("s:NetrwGetBuffer 0<cleared buffer> : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%"))
  return 0
endfun

" ---------------------------------------------------------------------
" s:NetrwGetcwd: get the current directory. {{{2
"   Change backslashes to forward slashes, if any.
"   If doesc is true, escape certain troublesome characters
fun! s:NetrwGetcwd(doesc)
"  call Dfunc("NetrwGetcwd(doesc=".a:doesc.")")
  let curdir= substitute(getcwd(),'\\','/','ge')
  if curdir !~ '[\/]$'
   let curdir= curdir.'/'
  endif
  if a:doesc
   let curdir= fnameescape(curdir)
  endif
"  call Dret("NetrwGetcwd <".curdir.">")
  return curdir
endfun

" ---------------------------------------------------------------------
"  s:NetrwGetWord: it gets the directory/file named under the cursor {{{2
fun! s:NetrwGetWord()
"  call Dfunc("s:NetrwGetWord() line#".line(".")." liststyle=".g:netrw_liststyle." virtcol=".virtcol("."))
  call s:UseBufWinVars()

  " insure that w:netrw_liststyle is set up
  if !exists("w:netrw_liststyle")
   if exists("g:netrw_liststyle")
    let w:netrw_liststyle= g:netrw_liststyle
   else
    let w:netrw_liststyle= s:THINLIST
   endif
"   call Decho("w:netrw_liststyle=".w:netrw_liststyle)
  endif

  if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
   " Active Banner support
"   call Decho("active banner handling")
   keepj norm! 0
   let dirname= "./"
   let curline= getline('.')

   if curline =~ '"\s*Sorted by\s'
    keepj norm s
    let s:netrw_skipbrowse= 1
    echo 'Pressing "s" also works'

   elseif curline =~ '"\s*Sort sequence:'
    let s:netrw_skipbrowse= 1
    echo 'Press "S" to edit sorting sequence'

   elseif curline =~ '"\s*Quick Help:'
    keepj norm ?
    let s:netrw_skipbrowse= 1
    echo 'Pressing "?" also works'

   elseif curline =~ '"\s*\%(Hiding\|Showing\):'
    keepj norm a
    let s:netrw_skipbrowse= 1
    echo 'Pressing "a" also works'

   elseif line("$") > w:netrw_bannercnt
    exe 'sil keepj '.w:netrw_bannercnt
   endif

  elseif w:netrw_liststyle == s:THINLIST
"   call Decho("thin column handling")
   keepj norm! 0
   let dirname= getline('.')

  elseif w:netrw_liststyle == s:LONGLIST
"   call Decho("long column handling")
   keepj norm! 0
   let dirname= substitute(getline('.'),'^\(\%(\S\+ \)*\S\+\).\{-}$','\1','e')

  elseif w:netrw_liststyle == s:TREELIST
"   call Decho("treelist handling")
   let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')

  else
"   call Decho("obtain word from wide listing")
   let dirname= getline('.')

   if !exists("b:netrw_cpf")
    let b:netrw_cpf= 0
    exe 'sil keepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
    call histdel("/",-1)
"   call Decho("computed cpf=".b:netrw_cpf)
   endif

"   call Decho("buf#".bufnr("%")."<".bufname("%").">")
   let filestart = (virtcol(".")/b:netrw_cpf)*b:netrw_cpf
"   call Decho("filestart= ([virtcol=".virtcol(".")."]/[b:netrw_cpf=".b:netrw_cpf."])*b:netrw_cpf=".filestart."  bannercnt=".w:netrw_bannercnt)
"   call Decho("1: dirname<".dirname.">")
   if filestart == 0
    keepj norm! 0ma
   else
    call cursor(line("."),filestart+1)
    keepj norm! ma
   endif
   let rega= @a
   let eofname= filestart + b:netrw_cpf + 1
   if eofname <= col("$")
    call cursor(line("."),filestart+b:netrw_cpf+1)
    keepj norm! "ay`a
   else
    keepj norm! "ay$
   endif
   let dirname = @a
   let @a      = rega
"   call Decho("2: dirname<".dirname.">")
   let dirname= substitute(dirname,'\s\+$','','e')
"   call Decho("3: dirname<".dirname.">")
  endif

  " symlinks are indicated by a trailing "@".  Remove it before further processing.
  let dirname= substitute(dirname,"@$","","")

  " executables are indicated by a trailing "*".  Remove it before further processing.
  let dirname= substitute(dirname,"\*$","","")

"  call Dret("s:NetrwGetWord <".dirname.">")
  return dirname
endfun

" ---------------------------------------------------------------------
" s:NetrwListSettings: make standard settings for a netrw listing {{{2
fun! s:NetrwListSettings(islocal)
"  call Dfunc("s:NetrwListSettings(islocal=".a:islocal.")")
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
  let fname= bufname("%")
"  "  call Decho("(NetrwListSettings) setl bt=nofile nobl ma nonu nowrap noro nornu")
  setl bt=nofile nobl ma nonu nowrap noro nornu
"  call Decho("(NetrwListSettings) exe sil! keepalt file ".fnameescape(fname))
  exe "sil! keepalt file ".fnameescape(fname)
  if g:netrw_use_noswf
   setl noswf
  endif
"  call Dredir("ls!")
"  call Decho("(NetrwListSettings) exe setl ts=".(g:netrw_maxfilenamelen+1))
  exe "setl ts=".(g:netrw_maxfilenamelen+1)
  setl isk+=.,~,-
  if g:netrw_fastbrowse > a:islocal
   setl bh=hide
  else
   setl bh=delete
  endif
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"  call Dret("s:NetrwListSettings")
endfun

" ---------------------------------------------------------------------
"  s:NetrwListStyle: {{{2
"  islocal=0: remote browsing
"         =1: local browsing
fun! s:NetrwListStyle(islocal)
"  call Dfunc("NetrwListStyle(islocal=".a:islocal.") w:netrw_liststyle=".w:netrw_liststyle)

  let ykeep             = @@
  let fname             = s:NetrwGetWord()
  if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
  let svpos            = netrw#SavePosn()
  let w:netrw_liststyle = (w:netrw_liststyle + 1) % s:MAXLIST
"  call Decho("fname<".fname.">")
"  call Decho("chgd w:netrw_liststyle to ".w:netrw_liststyle)
"  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist").">")

  if w:netrw_liststyle == s:THINLIST
   " use one column listing
"   call Decho("use one column list")
   let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')

  elseif w:netrw_liststyle == s:LONGLIST
   " use long list
"   call Decho("use long list")
   let g:netrw_list_cmd = g:netrw_list_cmd." -l"

  elseif w:netrw_liststyle == s:WIDELIST
   " give wide list
"   call Decho("use wide list")
   let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')

  elseif w:netrw_liststyle == s:TREELIST
"   call Decho("use tree list")
   let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')

  else
   keepj call netrw#ErrorMsg(s:WARNING,"bad value for g:netrw_liststyle (=".w:netrw_liststyle.")",46)
   let g:netrw_liststyle = s:THINLIST
   let w:netrw_liststyle = g:netrw_liststyle
   let g:netrw_list_cmd  = substitute(g:netrw_list_cmd,' -l','','ge')
  endif
  setl ma noro
"  call Decho("setl ma noro")

  " clear buffer - this will cause NetrwBrowse/LocalBrowseCheck to do a refresh
"  call Decho("clear buffer<".expand("%")."> with :%d")
  sil! keepj %d
  " following prevents tree listing buffer from being marked "modified"
"  call Decho("setl nomod")
  setl nomod
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")

  " refresh the listing
"  call Decho("refresh the listing")
  keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  keepj call s:NetrwCursor()

  " restore position; keep cursor on the filename
  keepj call netrw#RestorePosn(svpos)
  let @@= ykeep

"  call Dret("NetrwListStyle".(exists("w:netrw_liststyle")? ' : w:netrw_liststyle='.w:netrw_liststyle : ""))
endfun

" ---------------------------------------------------------------------
" s:NetrwBannerCtrl: toggles the display of the banner {{{2
fun! s:NetrwBannerCtrl(islocal)
"  call Dfunc("s:NetrwBannerCtrl(islocal=".a:islocal.") g:netrw_banner=".g:netrw_banner)

  let ykeep= @@
  " toggle the banner (enable/suppress)
  let g:netrw_banner= !g:netrw_banner

  " refresh the listing
  let svpos= netrw#SavePosn()
  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))

  " keep cursor on the filename
  let fname= s:NetrwGetWord()
  sil keepj $
  let result= search('\%(^\%(|\+\s\)\=\|\s\{2,}\)\zs'.escape(fname,'.\[]*$^').'\%(\s\{2,}\|$\)','bc')
"  call Decho("search result=".result." w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'N/A'))
  if result <= 0 && exists("w:netrw_bannercnt")
   exe "keepj ".w:netrw_bannercnt
  endif
  let @@= ykeep
"  call Dret("s:NetrwBannerCtrl : g:netrw_banner=".g:netrw_banner)
endfun

" ---------------------------------------------------------------------
" s:NetrwBookmarkMenu: Uses menu priorities {{{2
"                      .2.[cnt] for bookmarks, and
"                      .3.[cnt] for history
"                      (see s:NetrwMenu())
fun! s:NetrwBookmarkMenu()
  if !exists("s:netrw_menucnt")
   return
  endif
"  call Dfunc("NetrwBookmarkMenu()  histcnt=".g:netrw_dirhist_cnt." menucnt=".s:netrw_menucnt)

  " the following test assures that gvim is running, has menus available, and has menus enabled.
  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   if exists("g:NetrwTopLvlMenu")
"    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)")
    exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks'
    exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete'
   endif
   if !exists("s:netrw_initbookhist")
    call s:NetrwBookHistRead()
   endif

   " show bookmarked places
   if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
    let cnt= 1
    for bmd in g:netrw_bookmarklist
"     call Decho('sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmark.'.bmd.'	:e '.bmd)
     let bmd= escape(bmd,g:netrw_menu_escape)

     " show bookmarks for goto menu
     exe 'sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks.'.bmd.'	:e '.bmd."\<cr>"

     " show bookmarks for deletion menu
     exe 'sil! menu '.g:NetrwMenuPriority.".8.2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete.'.bmd.'	'.cnt."mB"
     let cnt= cnt + 1
    endfor

   endif

   " show directory browsing history
   if g:netrw_dirhistmax > 0
    let cnt     = g:netrw_dirhist_cnt
    let first   = 1
    let histcnt = 0
    while ( first || cnt != g:netrw_dirhist_cnt )
     let histcnt  = histcnt + 1
     let priority = g:netrw_dirhist_cnt + histcnt
     if exists("g:netrw_dirhist_{cnt}")
      let histdir= escape(g:netrw_dirhist_{cnt},g:netrw_menu_escape)
"     call Decho('sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir)
      exe 'sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir."\<cr>"
     endif
     let first = 0
     let cnt   = ( cnt - 1 ) % g:netrw_dirhistmax
     if cnt < 0
      let cnt= cnt + g:netrw_dirhistmax
     endif
    endwhile
   endif

  endif
"  call Dret("NetrwBookmarkMenu")
endfun

" ---------------------------------------------------------------------
"  s:NetrwBrowseChgDir: constructs a new directory based on the current {{{2
"                       directory and a new directory name.  Also, if the
"                       "new directory name" is actually a file,
"                       NetrwBrowseChgDir() edits the file.
fun! s:NetrwBrowseChgDir(islocal,newdir,...)
"  call Dfunc("s:NetrwBrowseChgDir(islocal=".a:islocal."> newdir<".a:newdir.">) a:0=".a:0." curpos<".string(getpos("."))."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "").">")
"  call Decho("win#".winnr())

  let ykeep= @@
  if !exists("b:netrw_curdir")
   " Don't try to change-directory: this can happen, for example, when netrw#ErrorMsg has been called
   " and the current window is the NetrwMessage window.
   let @@= ykeep
"   call Decho("b:netrw_curdir doesn't exist!")
"   call Decho("getcwd<".getcwd().">")
"   call Dredir("ls!")
"   call Dret("s:NetrwBrowseChgDir")
   return
  endif

  " NetrwBrowseChgDir: save options and initialize {{{3
"  call Decho("saving options")
  keepj call s:NetrwOptionSave("s:")
  keepj call s:NetrwSafeOptions()
  let nbcd_curpos                = netrw#SavePosn()
  let s:nbcd_curpos_{bufnr('%')} = nbcd_curpos
"  call Decho("setting s:nbcd_curpos_".bufnr('%')." to SavePosn")
  if (has("win32") || has("win95") || has("win64") || has("win16"))
   let dirname = substitute(b:netrw_curdir,'\\','/','ge')
  else
   let dirname = b:netrw_curdir
  endif
  let newdir    = a:newdir
  let dolockout = 0
  let dorestore = 1
"  call Decho("dirname<".dirname.">")

  " ignore <cr>s when done in the banner
  if g:netrw_banner
"   call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." line(.)#".line('.')." line($)#".line("#"))
   if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt && line("$") >= w:netrw_bannercnt
    if getline(".") =~ 'Quick Help'
"     call Decho("#1: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
     let g:netrw_quickhelp= (g:netrw_quickhelp + 1)%len(s:QuickHelp)
"     call Decho("#2: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
     setl ma noro nowrap
     keepj call setline(line('.'),'"   Quick Help: <F1>:help  '.s:QuickHelp[g:netrw_quickhelp])
     setl noma nomod nowrap
     keepj call netrw#RestorePosn(nbcd_curpos)
     keepj call s:NetrwOptionRestore("s:")
"     call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
    endif
   endif
"  else " Decho
"   call Decho("(s:NetrwBrowseChgdir) g:netrw_banner=".g:netrw_banner." (no banner)")
  endif

  " set up o/s-dependent directory recognition pattern
"  call Decho("set up o/s-dependent directory recognition pattern")
  if has("amiga")
   let dirpat= '[\/:]$'
  else
   let dirpat= '[\/]$'
  endif
"  call Decho("dirname<".dirname.">  dirpat<".dirpat.">")

  if dirname !~ dirpat
   " apparently vim is "recognizing" that it is in a directory and
   " is removing the trailing "/".  Bad idea, so let's put it back.
   let dirname= dirname.'/'
"   call Decho("adjusting dirname<".dirname.">")
  endif

  if newdir !~ dirpat
   " ------------------------------
   " NetrwBrowseChgDir: edit a file {{{3
   " ------------------------------
"   call Decho('edit-a-file: case "handling a file": newdir<'.newdir.'> !~ dirpat<'.dirpat.">")

   " save position for benefit of Rexplore
   let s:rexposn_{bufnr("%")}= netrw#SavePosn()

"   call Decho("edit-a-file: setting s:rexposn_".bufnr("%")." to SavePosn")
"   call Decho("edit-a-file: win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft)
"   call Decho("edit-a-file: w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a')." w:netrw_treedict:".(exists("w:netrw_treedict")? "exists" : 'n/a')." newdir<".newdir.">")

   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict") && newdir !~ '^\(/\|\a:\)'
"    call Decho("edit-a-file: handle tree listing: w:netrw_treedict<".(exists("w:netrw_treedict")? string(w:netrw_treedict) : 'n/a').">")
"    call Decho("edit-a-file: newdir<".newdir.">")
    let dirname= s:NetrwTreeDir()
    if dirname =~ '/$'
     let dirname= dirname.newdir
    else
     let dirname= dirname."/".newdir
    endif
"    call Decho("edit-a-file: dirname<".dirname.">")
"    call Decho("edit-a-file: tree listing")
   elseif newdir =~ '^\(/\|\a:\)'
    let dirname= newdir
   else
    let dirname= s:ComposePath(dirname,newdir)
   endif
"   call Decho("edit-a-file: handling a file: dirname<".dirname."> (a:0=".a:0.")")
   " this lets NetrwBrowseX avoid the edit
   if a:0 < 1
"    call Decho("edit-a-file: set up windows for editing<".fnameescape(dirname).">  didsplit=".(exists("s:didsplit")? s:didsplit : "doesn't exist"))
    keepj call s:NetrwOptionRestore("s:")
    if !exists("s:didsplit")
"     call Decho("edit-a-file: s:didsplit does not exist; g:netrw_browse_split=".g:netrw_browse_split." win#".winnr())
     if     g:netrw_browse_split == 1
      " horizontally splitting the window first
      keepalt new
      if !&ea
       keepalt wincmd _
      endif
     elseif g:netrw_browse_split == 2
      " vertically splitting the window first
      keepalt rightb vert new
      if !&ea
       keepalt wincmd |
      endif
     elseif g:netrw_browse_split == 3
      " open file in new tab
      keepalt tabnew
     elseif g:netrw_browse_split == 4
      " act like "P" (ie. open previous window)
      if s:NetrwPrevWinOpen(2) == 3
       let @@= ykeep
"       call Dret("s:NetrwBrowseChgDir")
       return
      endif
     else
      " handling a file, didn't split, so remove menu
"      call Decho("edit-a-file: handling a file+didn't split, so remove menu")
      call s:NetrwMenu(0)
      " optional change to window
      if g:netrw_chgwin >= 1
       if winnr("$")+1 == g:netrw_chgwin
	" if g:netrw_chgwin is set to one more than the last window, then
	" vertically split the last window to make that window available.
	let curwin= winnr()
	exe "keepj keepalt ".g:netrw_chgwin."wincmd ".winnr("$")
	vs
	exe "keepj keepalt ".g:netrw_chgwin."wincmd ".curwin
       endif
       exe "keepj keepalt ".g:netrw_chgwin."wincmd w"
      endif
     endif
    endif

    " the point where netrw actually edits the (local) file
    " if its local only: LocalBrowseCheck() doesn't edit a file, but NetrwBrowse() will
    " no keepalt to support  :e #  to return to a directory listing
    if a:islocal
"     call Decho("edit-a-file: edit local file: exe e! ".fnameescape(dirname))
     " some like c-^ to return to the last edited file
     " others like c-^ to return to the netrw buffer
     if exists("g:netrw_altfile") && g:netrw_altfile
      exe "keepj keepalt e! ".fnameescape(dirname)
     else
      exe "keepj e! ".fnameescape(dirname)
     endif
"     call Decho("after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
     call s:NetrwCursor()
"     call Decho("COMBAK#1: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
     if &hidden || &bufhidden == "hide"
      " file came from vim's hidden storage.  Don't "restore" options with it.
      let dorestore= 0
     endif
    else
"     call Decho("edit-a-file: remote file: NetrwBrowse will edit it")
    endif
    let dolockout= 1
"     call Decho("COMBAK#2: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)

    " handle g:Netrw_funcref -- call external-to-netrw functions
    "   This code will handle g:Netrw_funcref as an individual function reference
    "   or as a list of function references.  It will ignore anything that's not
    "   a function reference.  See  :help Funcref  for information about function references.
    if exists("g:Netrw_funcref")
"     call Decho("edit-a-file: handle optional Funcrefs")
     if type(g:Netrw_funcref) == 2
"      call Decho("edit-a-file: handling a g:Netrw_funcref")
      keepj call g:Netrw_funcref()
     elseif type(g:Netrw_funcref) == 3
"      call Decho("edit-a-file: handling a list of g:Netrw_funcrefs")
      for Fncref in g:Netrw_funcref
       if type(FncRef) == 2
        keepj call FncRef()
       endif
      endfor
     endif
    endif
   endif

  elseif newdir =~ '^/'
   " ----------------------------------------------------
   " NetrwBrowseChgDir: just go to the new directory spec {{{3
   " ----------------------------------------------------
"   call Decho('goto-newdir: case "just go to new directory spec": newdir<'.newdir.'>')
   let dirname    = newdir
   keepj call s:SetRexDir(a:islocal,dirname)
   keepj call s:NetrwOptionRestore("s:")

  elseif newdir == './'
   " ---------------------------------------------
   " NetrwBrowseChgDir: refresh the directory list {{{3
   " ---------------------------------------------
"   call Decho('refresh-dirlist: case "refresh directory listing": newdir == "./"')
   keepj call s:SetRexDir(a:islocal,dirname)

  elseif newdir == '../'
   " --------------------------------------
   " NetrwBrowseChgDir: go up one directory {{{3
   " --------------------------------------
"   call Decho('go-up: case "go up one directory": newdir == "../"')

   if w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
    " force a refresh
"    call Decho("go-up: clear buffer<".expand("%")."> with :%d")
"    call Decho("go-up: setl noro ma")
    setl noro ma
    keepj %d
   endif

   if has("amiga")
    " amiga
"    call Decho('go-up: case "go up one directory": newdir == "../" and amiga')
    if a:islocal
     let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+$\)','\1','')
     let dirname= substitute(dirname,'/$','','')
    else
     let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+/$\)','\1','')
    endif
"    call Decho("go-up: amiga: dirname<".dirname."> (go up one dir)")

   elseif !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    " windows
    if a:islocal
     let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
     if dirname == ""
      let dirname= '/'
     endif
    else
     let dirname= substitute(dirname,'^\(\a\+://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
    endif
    if dirname =~ '^\a:$'
     let dirname= dirname.'/'
    endif
"    call Decho("go-up: windows: dirname<".dirname."> (go up one dir)")

   else
    " unix or cygwin
"    call Decho('go-up: case "go up one directory": newdir == "../" and unix or cygwin')
    if a:islocal
     let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
     if dirname == ""
      let dirname= '/'
     endif
    else
     let dirname= substitute(dirname,'^\(\a\+://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
    endif
"    call Decho("go-up: unix: dirname<".dirname."> (go up one dir)")
   endif
   keepj call s:SetRexDir(a:islocal,dirname)

  elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " --------------------------------------
   " NetrwBrowseChgDir: Handle Tree Listing {{{3
   " --------------------------------------
"   call Decho('tree-list: case liststyle is TREELIST and w:netrw_treedict exists')
   " force a refresh (for TREELIST, wait for NetrwTreeDir() to force the refresh)
"   call Decho("tree-list: setl noro ma")
   setl noro ma
   if !(exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir"))
"    call Decho("tree-list: clear buffer<".expand("%")."> with :%d")
    keepj %d
   endif
   let treedir      = s:NetrwTreeDir()
   let s:treecurpos = nbcd_curpos
   let haskey= 0
"   call Decho("tree-list: w:netrw_treedict<".string(w:netrw_treedict).">")

   " search treedict for tree dir as-is
   if has_key(w:netrw_treedict,treedir)
"    call Decho('tree-list: ....searched for treedir<'.treedir.'> : found it!')
    let haskey= 1
   else
"    call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found')
   endif

   " search treedict for treedir with a / appended
   if !haskey && treedir !~ '/$'
    if has_key(w:netrw_treedict,treedir."/")
     let treedir= treedir."/"
"     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!')
     let haskey = 1
    else
"     call Decho('tree-list: ....searched for treedir<'.treedir.'/> : not found')
    endif
   endif

   " search treedict for treedir with any trailing / elided
   if !haskey && treedir =~ '/$'
    let treedir= substitute(treedir,'/$','','')
    if has_key(w:netrw_treedict,treedir)
"     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!')
     let haskey = 1
    else
"     call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found')
    endif
   endif

   if haskey
    " close tree listing for selected subdirectory
"    call Decho("tree-list: closing selected subdirectory<".dirname.">")
    call remove(w:netrw_treedict,treedir)
"    call Decho("tree-list: removed     entry<".treedir."> from treedict")
"    call Decho("tree-list: yielding treedict<".string(w:netrw_treedict).">")
    let dirname= w:netrw_treetop
   else
    " go down one directory
    let dirname= substitute(treedir,'/*$','/','')
"    call Decho("tree-list: go down one dir: treedir<".treedir.">")
   endif
   keepj call s:SetRexDir(a:islocal,dirname)
   let s:treeforceredraw = 1

  else
   " ----------------------------------------
   " NetrwBrowseChgDir: Go down one directory {{{3
   " ----------------------------------------
   let dirname    = s:ComposePath(dirname,newdir)
"   call Decho("go down one dir: dirname<".dirname."> newdir<".newdir.">")
   keepj call s:SetRexDir(a:islocal,dirname)
  endif

 " --------------------------------------
 " NetrwBrowseChgDir: Restore and Cleanup {{{3
 " --------------------------------------
"  call Decho("COMBAK#3: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
  if dorestore
   " dorestore is zero'd when a local file was hidden or bufhidden;
   " in such a case, we want to keep whatever settings it may have.
"   call Decho("doing option restore (dorestore=".dorestore.")")
   keepj call s:NetrwOptionRestore("s:")
"  else " Decho
"   call Decho("skipping option restore (dorestore==0): hidden=".&hidden." bufhidden=".&bufhidden." mod=".&mod)
  endif
"  call Decho("COMBAK#4: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
  if dolockout && dorestore
"   call Decho("restore: filewritable(dirname<".dirname.">)=".filewritable(dirname))
   if filewritable(dirname)
"    call Decho("restore: doing modification lockout settings: ma nomod noro")
"    call Decho("restore: setl ma nomod noro")
    setl ma noro nomod
"    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
   else
"    call Decho("restore: doing modification lockout settings: ma nomod ro")
"    call Decho("restore: setl ma nomod noro")
    setl ma ro nomod
"    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
   endif
  endif
"  call Decho("COMBAK#5: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
  let @@= ykeep

"  call Dret("s:NetrwBrowseChgDir <".dirname."> : curpos<".string(getpos(".")).">")
  return dirname
endfun

" ---------------------------------------------------------------------
" s:NetrwBrowseUpDir: implements the "-" mappings {{{2
"    for thin, long, and wide: cursor placed just after banner
"    for tree, keeps cursor on current filename
fun! s:NetrwBrowseUpDir(islocal)
"  call Dfunc("s:NetrwBrowseUpDir(islocal=".a:islocal.")")
  norm! 0
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
"   call Decho("ftp + treestyle")
   let curline= getline(".")
   let swwline= winline() - 1
   if exists("w:netrw_treetop")
    let b:netrw_curdir= w:netrw_treetop
   endif
   if a:islocal
    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
   else
    call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
   endif
   if !search('\c^'.s:treedepthstring.curline,'cw')
    if !search('\c^'.curline,'cw')
     sil! keepj 1
    endif
   endif
   exe "sil! keepj norm! z\<cr>"
   while winline() < swwline
    let curwinline= winline()
    exe "sil! keepj norm! \<c-y>"
    if curwinline == winline()
     break
    endif
   endwhile
  else
"   call Decho("ftp + not treestyle")
   if a:islocal
    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
   else
    call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
   endif
   if exists("w:netrw_bannercnt")
"    call Decho("moving to line#".w:netrw_bannercnt)
    exe w:netrw_bannercnt
   else
    1
   endif
  endif
"  call Dret("s:NetrwBrowseUpDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwBrowseX:  (implements "x") executes a special "viewer" script or program for the {{{2
"              given filename; typically this means given their extension.
"              0=local, 1=remote
fun! netrw#NetrwBrowseX(fname,remote)
"  call Dfunc("NetrwBrowseX(fname<".a:fname."> remote=".a:remote.")")

  let ykeep      = @@
  let screenposn = netrw#SavePosn()

  " special core dump handler
  if a:fname =~ '/core\(\.\d\+\)\=$'
   if exists("g:Netrw_corehandler")
    if type(g:Netrw_corehandler) == 2
     " g:Netrw_corehandler is a function reference (see :help Funcref)
"     call Decho("g:Netrw_corehandler is a funcref")
     call g:Netrw_corehandler(a:fname)
    elseif type(g:Netrw_corehandler) == 3
     " g:Netrw_corehandler is a List of function references (see :help Funcref)
"     call Decho("g:Netrw_corehandler is a List")
     for Fncref in g:Netrw_corehandler
      if type(FncRef) == 2
       call FncRef(a:fname)
      endif
     endfor
    endif
    call netrw#RestorePosn(screenposn)
    let @@= ykeep
"    call Dret("NetrwBrowseX : coredump handler invoked")
    return
   endif
  endif

  " set up the filename
  " (lower case the extension, make a local copy of a remote file)
  let exten= substitute(a:fname,'.*\.\(.\{-}\)','\1','e')
  if has("win32") || has("win95") || has("win64") || has("win16")
   let exten= substitute(exten,'^.*$','\L&\E','')
  endif
"  call Decho("exten<".exten.">")

  " seems kde systems often have gnome-open due to dependencies, even though
  " gnome-open's subsidiary display tools are largely absent.  Kde systems
  " usually have "kdeinit" running, though...  (tnx Mikolaj Machowski)
  if !exists("s:haskdeinit")
   if has("unix") && executable("ps") && !has("win32unix")
    let s:haskdeinit= system("ps -e") =~ 'kdeinit' 
    if v:shell_error
     let s:haskdeinit = 0
    endif
   else
    let s:haskdeinit= 0
   endif
"   call Decho("setting s:haskdeinit=".s:haskdeinit)
  endif

  if a:remote == 1
   " create a local copy
"   call Decho("remote: a:remote=".a:remote.": create a local copy of <".a:fname.">")
   setl bh=delete
   call netrw#NetRead(3,a:fname)
   " attempt to rename tempfile
   let basename= substitute(a:fname,'^\(.*\)/\(.*\)\.\([^.]*\)$','\2','')
   let newname = substitute(s:netrw_tmpfile,'^\(.*\)/\(.*\)\.\([^.]*\)$','\1/'.basename.'.\3','')
"   call Decho("basename<".basename.">")
"   call Decho("newname <".newname.">")
   if rename(s:netrw_tmpfile,newname) == 0
    " renaming succeeded
    let fname= newname
   else
    " renaming failed
    let fname= s:netrw_tmpfile
   endif
  else
"   call Decho("local: a:remote=".a:remote.": handling local copy of <".a:fname.">")
   let fname= a:fname
   " special ~ handler for local
   if fname =~ '^\~' && expand("$HOME") != ""
"    call Decho('invoking special ~ handler')
    let fname= substitute(fname,'^\~',expand("$HOME"),'')
   endif
  endif
"  call Decho("fname<".fname.">")
"  call Decho("exten<".exten."> "."netrwFileHandlers#NFH_".exten."():exists=".exists("*netrwFileHandlers#NFH_".exten))

  " set up redirection
  if &srr =~ "%s"
   if (has("win32") || has("win95") || has("win64") || has("win16"))
    let redir= substitute(&srr,"%s","nul","")
   else
    let redir= substitute(&srr,"%s","/dev/null","")
   endif
  elseif (has("win32") || has("win95") || has("win64") || has("win16"))
   let redir= &srr . "nul"
  else
   let redir= &srr . "/dev/null"
  endif
"  call Decho("set up redirection: redir{".redir."} srr{".&srr."}")

  " extract any viewing options.  Assumes that they're set apart by quotes.
"  call Decho("extract any viewing options")
  if exists("g:netrw_browsex_viewer")
"   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">")
   if g:netrw_browsex_viewer =~ '\s'
    let viewer  = substitute(g:netrw_browsex_viewer,'\s.*$','','')
    let viewopt = substitute(g:netrw_browsex_viewer,'^\S\+\s*','','')." "
    let oviewer = ''
    let cnt     = 1
    while !executable(viewer) && viewer != oviewer
     let viewer  = substitute(g:netrw_browsex_viewer,'^\(\(^\S\+\s\+\)\{'.cnt.'}\S\+\)\(.*\)$','\1','')
     let viewopt = substitute(g:netrw_browsex_viewer,'^\(\(^\S\+\s\+\)\{'.cnt.'}\S\+\)\(.*\)$','\3','')." "
     let cnt     = cnt + 1
     let oviewer = viewer
"     call Decho("!exe: viewer<".viewer.">  viewopt<".viewopt.">")
    endwhile
   else
    let viewer  = g:netrw_browsex_viewer
    let viewopt = ""
   endif
"   call Decho("viewer<".viewer.">  viewopt<".viewopt.">")
  endif

  " execute the file handler
"  call Decho("execute the file handler (if any)")
  if exists("g:netrw_browsex_viewer") && g:netrw_browsex_viewer == '-'
"   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">")
   let ret= netrwFileHandlers#Invoke(exten,fname)

  elseif exists("g:netrw_browsex_viewer") && executable(viewer)
"   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">")
"   call Decho("exe sil !".viewer." ".viewopt.shellescape(fname,1).redir)
   exe "sil !".viewer." ".viewopt.shellescape(fname,1).redir
   let ret= v:shell_error

  elseif has("win32") || has("win64")
"   call Decho("windows")
   if executable("start")
"    call Decho('exe sil !start rundll32 url.dll,FileProtocolHandler '.shellescape(fname,1))
    exe 'sil !start rundll32 url.dll,FileProtocolHandler '.shellescape(fname,1)
   elseif executable("rundll32")
"    call Decho('exe sil !rundll32 url.dll,FileProtocolHandler '.shellescape(fname,1))
    exe 'sil !rundll32 url.dll,FileProtocolHandler '.shellescape(fname,1)
   else
    call netrw#ErrorMsg(s:WARNING,"rundll32 not on path",74)
   endif
   call inputsave()|call input("Press <cr> to continue")|call inputrestore()
   let ret= v:shell_error

  elseif has("win32unix")
   let winfname= 'c:\cygwin'.substitute(fname,'/','\\','g')
"   call Decho("cygwin: winfname<".shellescape(winfname,1).">")
   if executable("start")
"    call Decho('exe sil !start rundll32 url.dll,FileProtocolHandler '.shellescape(winfname,1))
    exe 'sil !start rundll32 url.dll,FileProtocolHandler '.shellescape(winfname,1)
   elseif executable("rundll32")
"    call Decho('exe sil !rundll32 url.dll,FileProtocolHandler '.shellescape(winfname,1))
    exe 'sil !rundll32 url.dll,FileProtocolHandler '.shellescape(winfname,1)
   else
    call netrw#ErrorMsg(s:WARNING,"rundll32 not on path",74)
   endif
   call inputsave()|call input("Press <cr> to continue")|call inputrestore()
   let ret= v:shell_error

  elseif has("unix") && executable("xdg-open") && !s:haskdeinit
"   call Decho("unix and xdg-open")
"   call Decho("exe sil !xdg-open ".shellescape(fname,1)." ".redir)
   exe "sil !xdg-open ".shellescape(fname,1).redir
   let ret= v:shell_error

  elseif has("unix") && executable("kfmclient") && s:haskdeinit
"   call Decho("unix and kfmclient")
"   call Decho("exe sil !kfmclient exec ".shellescape(fname,1)." ".redir)
   exe "sil !kfmclient exec ".shellescape(fname,1)." ".redir
   let ret= v:shell_error

  elseif has("macunix") && executable("open")
"   call Decho("macunix and open")
"   call Decho("exe sil !open ".shellescape(fname,1)." ".redir)
   exe "sil !open ".shellescape(fname,1)." ".redir
   let ret= v:shell_error

  else
   " netrwFileHandlers#Invoke() always returns 0
   let ret= netrwFileHandlers#Invoke(exten,fname)
  endif

  " if unsuccessful, attempt netrwFileHandlers#Invoke()
  if ret
   let ret= netrwFileHandlers#Invoke(exten,fname)
  endif

  " restoring redraw! after external file handlers
  redraw!

  " cleanup: remove temporary file,
  "          delete current buffer if success with handler,
  "          return to prior buffer (directory listing)
  "          Feb 12, 2008: had to de-activiate removal of
  "          temporary file because it wasn't getting seen.
"  if a:remote == 1 && fname != a:fname
""   call Decho("deleting temporary file<".fname.">")
"   call s:NetrwDelete(fname)
"  endif

  if a:remote == 1
   setl bh=delete bt=nofile
   if g:netrw_use_noswf
    setl noswf
   endif
   exe "sil! keepj norm! \<c-o>"
"   redraw!
  endif
  call netrw#RestorePosn(screenposn)
  let @@= ykeep

"  call Dret("NetrwBrowseX")
endfun

" ---------------------------------------------------------------------
" s:NetrwChgPerm: (implements "gp") change file permission {{{2
fun! s:NetrwChgPerm(islocal,curdir)
"  call Dfunc("s:NetrwChgPerm(islocal=".a:islocal." curdir<".a:curdir.">)")
  let ykeep  = @@
  call inputsave()
  let newperm= input("Enter new permission: ")
  call inputrestore()
  let chgperm= substitute(g:netrw_chgperm,'\<FILENAME\>',shellescape(expand("<cfile>")),'')
  let chgperm= substitute(chgperm,'\<PERM\>',shellescape(newperm),'')
"  call Decho("chgperm<".chgperm.">")
  call system(chgperm)
  if v:shell_error != 0
   keepj call netrw#ErrorMsg(1,"changing permission on file<".expand("<cfile>")."> seems to have failed",75)
  endif
  if a:islocal
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  endif
  let @@= ykeep
"  call Dret("s:NetrwChgPerm")
endfun

" ---------------------------------------------------------------------
" s:NetrwClearExplore: clear explore variables (if any) {{{2
fun! s:NetrwClearExplore()
"  call Dfunc("s:NetrwClearExplore()")
  2match none
  if exists("s:explore_match")        |unlet s:explore_match        |endif
  if exists("s:explore_indx")         |unlet s:explore_indx         |endif
  if exists("s:netrw_explore_prvdir") |unlet s:netrw_explore_prvdir |endif
  if exists("s:dirstarstar")          |unlet s:dirstarstar          |endif
  if exists("s:explore_prvdir")       |unlet s:explore_prvdir       |endif
  if exists("w:netrw_explore_indx")   |unlet w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_listlen")|unlet w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_list")   |unlet w:netrw_explore_list   |endif
  if exists("w:netrw_explore_bufnr")  |unlet w:netrw_explore_bufnr  |endif
"   redraw!
  echo " "
  echo " "
"  call Dret("s:NetrwClearExplore")
endfun

" ---------------------------------------------------------------------
" s:NetrwExploreListUniq: {{{2
fun! s:NetrwExploreListUniq(explist)
"  call Dfunc("s:NetrwExploreListUniq(explist<".string(a:explist).">)")

  " this assumes that the list is already sorted
  let newexplist= []
  for member in a:explist
   if !exists("uniqmember") || member != uniqmember
    let uniqmember = member
    let newexplist = newexplist + [ member ]
   endif
  endfor

"  call Dret("s:NetrwExploreListUniq newexplist<".string(newexplist).">")
  return newexplist
endfun

" ---------------------------------------------------------------------
" s:NetrwForceChgDir: (gd support) Force treatment as a directory {{{2
fun! s:NetrwForceChgDir(islocal,newdir)
"  call Dfunc("s:NetrwForceChgDir(islocal=".a:islocal." newdir<".a:newdir.">)")
  let ykeep= @@
  if a:newdir !~ '/$'
   " ok, looks like force is needed to get directory-style treatment
   if a:newdir =~ '@$'
    let newdir= substitute(a:newdir,'@$','/','')
   elseif a:newdir =~ '[*=|\\]$'
    let newdir= substitute(a:newdir,'.$','/','')
   else
    let newdir= a:newdir.'/'
   endif
"   call Decho("adjusting newdir<".newdir."> due to gd")
  else
   " should already be getting treatment as a directory
   let newdir= a:newdir
  endif
  let newdir= s:NetrwBrowseChgDir(a:islocal,newdir)
  call s:NetrwBrowse(a:islocal,newdir)
  let @@= ykeep
"  call Dret("s:NetrwForceChgDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwForceFile: (gf support) Force treatment as a file {{{2
fun! s:NetrwForceFile(islocal,newfile)
"  call Dfunc("s:NetrwForceFile(islocal=".a:islocal." newdir<".a:newfile.">)")
  if a:newfile =~ '[/@*=|\\]$'
   let newfile= substitute(a:newfile,'.$','','')
  else
   let newfile= a:newfile
  endif
  if a:islocal
   call s:NetrwBrowseChgDir(a:islocal,newfile)
  else
   call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,newfile))
  endif
"  call Dret("s:NetrwForceFile")
endfun

" ---------------------------------------------------------------------
" s:NetrwHide: this function is invoked by the "a" map for browsing {{{2
"          and switches the hiding mode.  The actual hiding is done by
"          s:NetrwListHide().
"             g:netrw_hide= 0: show all
"                           1: show not-hidden files
"                           2: show hidden files only
fun! s:NetrwHide(islocal)
"  call Dfunc("NetrwHide(islocal=".a:islocal.") g:netrw_hide=".g:netrw_hide)
  let ykeep= @@
  let svpos= netrw#SavePosn()

  if exists("s:netrwmarkfilelist_{bufnr('%')}")
"   call Decho("((g:netrw_hide == 1)? "unhide" : "hide")." files in markfilelist<".string(s:netrwmarkfilelist_{bufnr("%")}).">")
"   call Decho("g:netrw_list_hide<".g:netrw_list_hide.">")

   " hide the files in the markfile list
   for fname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("match(g:netrw_list_hide<".g:netrw_list_hide.'> fname<\<'.fname.'\>>)='.match(g:netrw_list_hide,'\<'.fname.'\>')." l:isk=".&l:isk)
    if match(g:netrw_list_hide,'\<'.fname.'\>') != -1
     " remove fname from hiding list
     let g:netrw_list_hide= substitute(g:netrw_list_hide,'..\<'.escape(fname,g:netrw_fname_escape).'\>..','','')
     let g:netrw_list_hide= substitute(g:netrw_list_hide,',,',',','g')
     let g:netrw_list_hide= substitute(g:netrw_list_hide,'^,\|,$','','')
"     call Decho("unhide: g:netrw_list_hide<".g:netrw_list_hide.">")
    else
     " append fname to hiding list
     if exists("g:netrw_list_hide") && g:netrw_list_hide != ""
      let g:netrw_list_hide= g:netrw_list_hide.',\<'.escape(fname,g:netrw_fname_escape).'\>'
     else
      let g:netrw_list_hide= '\<'.escape(fname,g:netrw_fname_escape).'\>'
     endif
"     call Decho("hide: g:netrw_list_hide<".g:netrw_list_hide.">")
    endif
   endfor
   keepj call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
   let g:netrw_hide= 1

  else

   " switch between show-all/show-not-hidden/show-hidden
   let g:netrw_hide=(g:netrw_hide+1)%3
   exe "keepj norm! 0"
   if g:netrw_hide && g:netrw_list_hide == ""
    keepj call netrw#ErrorMsg(s:WARNING,"your hiding list is empty!",49)
    let @@= ykeep
"    call Dret("NetrwHide")
    return
   endif
  endif

  keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  keepj call netrw#RestorePosn(svpos)
  let @@= ykeep
"  call Dret("NetrwHide")
endfun

" ---------------------------------------------------------------------
" s:NetrwHidden: invoked by "gh" {{{2
fun! s:NetrwHidden(islocal)
"  call Dfunc("s:NetrwHidden()")
  let ykeep= @@
  "  save current position
  let svpos= netrw#SavePosn()

  if g:netrw_list_hide =~ '\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+'
   " remove pattern from hiding list
   let g:netrw_list_hide= substitute(g:netrw_list_hide,'\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+','','')
  elseif s:Strlen(g:netrw_list_hide) >= 1
   let g:netrw_list_hide= g:netrw_list_hide . ',\(^\|\s\s\)\zs\.\S\+'
  else
   let g:netrw_list_hide= '\(^\|\s\s\)\zs\.\S\+'
  endif

  " refresh screen and return to saved position
  keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  keepj call netrw#RestorePosn(svpos)
  let @@= ykeep
"  call Dret("s:NetrwHidden")
endfun

" ---------------------------------------------------------------------
"  s:NetrwHome: this function determines a "home" for saving bookmarks and history {{{2
fun! s:NetrwHome()
  if exists("g:netrw_home")
   let home= g:netrw_home
  else
   " go to vim plugin home
   for home in split(&rtp,',') + ['']
    if isdirectory(home) && filewritable(home) | break | endif
     let basehome= substitute(home,'[/\\]\.vim$','','')
    if isdirectory(basehome) && filewritable(basehome)
     let home= basehome."/.vim"
     break
    endif
   endfor
   if home == ""
    " just pick the first directory
    let home= substitute(&rtp,',.*$','','')
   endif
   if (has("win32") || has("win95") || has("win64") || has("win16"))
    let home= substitute(home,'/','\\','g')
   endif
  endif
  " insure that the home directory exists
  if g:netrw_dirhistmax > 0 && !isdirectory(home)
   if exists("g:netrw_mkdir")
    call system(g:netrw_mkdir." ".shellescape(home))
   else
    call mkdir(home)
   endif
  endif
  let g:netrw_home= home
  return home
endfun

" ---------------------------------------------------------------------
" s:NetrwLeftmouse: handles the <leftmouse> when in a netrw browsing window {{{2
fun! s:NetrwLeftmouse(islocal)
  if exists("s:netrwdrag")
   return
  endif
"  call Dfunc("s:NetrwLeftmouse(islocal=".a:islocal.")")

  let ykeep= @@
  " check if the status bar was clicked on instead of a file/directory name
  while getchar(0) != 0
   "clear the input stream
  endwhile
  call feedkeys("\<LeftMouse>")
  let c          = getchar()
  let mouse_lnum = v:mouse_lnum
  let wlastline  = line('w$')
  let lastline   = line('$')
"  call Decho("v:mouse_lnum=".mouse_lnum." line(w$)=".wlastline." line($)=".lastline." v:mouse_win=".v:mouse_win." winnr#".winnr())
"  call Decho("v:mouse_col =".v:mouse_col."     col=".col(".")."  wincol =".wincol()." winwidth   =".winwidth(0))
  if mouse_lnum >= wlastline + 1 || v:mouse_win != winnr()
   " appears to be a status bar leftmouse click
   let @@= ykeep
"   call Dret("s:NetrwLeftmouse : detected a status bar leftmouse click")
   return
  endif
   " NOTE: following test is preventing leftmouse selection/deselection of directories and files in treelist mode (Dec 04, 2013)
   " Windows are separated by vertical separator bars - but the mouse seems to be doing what it should when dragging that bar
   " without this test.
"  if v:mouse_col != col('.')
"   let @@= ykeep
"   call Dret("s:NetrwLeftmouse : detected a vertical separator bar leftmouse click")
"   return
"  endif

  if a:islocal
   if exists("b:netrw_curdir")
    keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   endif
  else
   if exists("b:netrw_curdir")
    keepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   endif
  endif
  let @@= ykeep
"  call Dret("s:NetrwLeftmouse")
endfun

" ---------------------------------------------------------------------
" s:NetrwSLeftmouse: marks the file under the cursor.  May be dragged to select additional files {{{2
fun! s:NetrwSLeftmouse(islocal)
"  call Dfunc("s:NetrwSLeftmouse(islocal=".a:islocal.")")
  
  let s:ngw= s:NetrwGetWord()
  call s:NetrwMarkFile(a:islocal,s:ngw)

"  call Dret("s:NetrwSLeftmouse")
endfun

" ---------------------------------------------------------------------
" s:NetrwSLeftdrag: invoked via a shift-leftmouse and dragging {{{2
"                   Used to mark multiple files.
fun! s:NetrwSLeftdrag(islocal)
"  call Dfunc("s:NetrwSLeftdrag(islocal=".a:islocal.")")
  if !exists("s:netrwdrag")
   let s:netrwdrag = winnr()
   if a:islocal
    nno <silent> <s-leftrelease> <leftmouse>:<c-u>call <SID>NetrwSLeftrelease(1)<cr>
   else
    nno <silent> <s-leftrelease> <leftmouse>:<c-u>call <SID>NetrwSLeftrelease(0)<cr>
   endif
  endif
  let ngw = s:NetrwGetWord()
  if !exists("s:ngw") || s:ngw != ngw
   call s:NetrwMarkFile(a:islocal,ngw)
  endif
  let s:ngw= ngw
"  call Dret("s:NetrwSLeftdrag : s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
endfun

" ---------------------------------------------------------------------
" s:NetrwSLeftrelease: terminates shift-leftmouse dragging {{{2
fun! s:NetrwSLeftrelease(islocal)
"  call Dfunc("s:NetrwSLeftrelease(islocal=".a:islocal.") s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
  if exists("s:netrwdrag")
   nunmap <s-leftrelease>
   let ngw = s:NetrwGetWord()
   if !exists("s:ngw") || s:ngw != ngw
    call s:NetrwMarkFile(a:islocal,ngw)
   endif
   if exists("s:ngw")
    unlet s:ngw
   endif
   unlet s:netrwdrag
  endif
"  call Dret("s:NetrwSLeftrelease")
endfun

" ---------------------------------------------------------------------
" s:NetrwListHide: uses [range]g~...~d to delete files that match comma {{{2
" separated patterns given in g:netrw_list_hide
fun! s:NetrwListHide()
"  call Dfunc("NetrwListHide() g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
  let ykeep= @@

  " find a character not in the "hide" string to use as a separator for :g and :v commands
  " How-it-works: take the hiding command, convert it into a range.  Duplicate
  " characters don't matter.  Remove all such characters from the '/~...90'
  " string.  Use the first character left as a separator character.
  let listhide= g:netrw_list_hide
  let sep     = strpart(substitute('/~@#$%^&*{};:,<.>?|1234567890','['.escape(listhide,'-]^\').']','','ge'),1,1)
"  call Decho("sep=".sep)

  while listhide != ""
   if listhide =~ ','
    let hide     = substitute(listhide,',.*$','','e')
    let listhide = substitute(listhide,'^.\{-},\(.*\)$','\1','e')
   else
    let hide     = listhide
    let listhide = ""
   endif

   " Prune the list by hiding any files which match
   if g:netrw_hide == 1
"    call Decho("hiding<".hide."> listhide<".listhide.">")
    exe 'sil! keepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'d'
   elseif g:netrw_hide == 2
"    call Decho("showing<".hide."> listhide<".listhide.">")
    exe 'sil! keepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'s@^@ /-KEEP-/ @'
   endif
  endwhile
  if g:netrw_hide == 2
   exe 'sil! keepj '.w:netrw_bannercnt.',$v@^ /-KEEP-/ @d'
   exe 'sil! keepj '.w:netrw_bannercnt.',$s@^\%( /-KEEP-/ \)\+@@e'
  endif

  " remove any blank lines that have somehow remained.
  " This seems to happen under Windows.
  exe 'sil! keepj 1,$g@^\s*$@d'

  let @@= ykeep
"  call Dret("NetrwListHide")
endfun

" ---------------------------------------------------------------------
" NetrwHideEdit: allows user to edit the file/directory hiding list
fun! s:NetrwHideEdit(islocal)
"  call Dfunc("NetrwHideEdit(islocal=".a:islocal.")")

  let ykeep= @@
  " save current cursor position
  let svpos= netrw#SavePosn()

  " get new hiding list from user
  call inputsave()
  let newhide= input("Edit Hiding List: ",g:netrw_list_hide)
  call inputrestore()
  let g:netrw_list_hide= newhide
"  call Decho("new g:netrw_list_hide<".g:netrw_list_hide.">")

  " refresh the listing
  sil keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,"./"))

  " restore cursor position
  call netrw#RestorePosn(svpos)
  let @@= ykeep

"  call Dret("NetrwHideEdit")
endfun

" ---------------------------------------------------------------------
" NetSortSequence: allows user to edit the sorting sequence
fun! s:NetSortSequence(islocal)
"  call Dfunc("NetSortSequence(islocal=".a:islocal.")")

  let ykeep= @@
  let svpos= netrw#SavePosn()
  call inputsave()
  let newsortseq= input("Edit Sorting Sequence: ",g:netrw_sort_sequence)
  call inputrestore()

  " refresh the listing
  let g:netrw_sort_sequence= newsortseq
  keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  keepj call netrw#RestorePosn(svpos)
  let @@= ykeep

"  call Dret("NetSortSequence")
endfun

" ---------------------------------------------------------------------
" s:NetrwMakeDir: this function makes a directory (both local and remote) {{{2
fun! s:NetrwMakeDir(usrhost)
"  call Dfunc("s:NetrwMakeDir(usrhost<".a:usrhost.">)")

  let ykeep= @@
  " get name of new directory from user.  A bare <CR> will skip.
  " if its currently a directory, also request will be skipped, but with
  " a message.
  call inputsave()
  let newdirname= input("Please give directory name: ")
  call inputrestore()
"  call Decho("newdirname<".newdirname.">")

  if newdirname == ""
   let @@= ykeep
"   call Dret("s:NetrwMakeDir : user aborted with bare <cr>")
   return
  endif

  if a:usrhost == ""
"   call Decho("local mkdir")

   " Local mkdir:
   " sanity checks
   let fullnewdir= b:netrw_curdir.'/'.newdirname
"   call Decho("fullnewdir<".fullnewdir.">")
   if isdirectory(fullnewdir)
    if !exists("g:netrw_quiet")
     keepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a directory!",24)
    endif
    let @@= ykeep
"    call Dret("s:NetrwMakeDir : directory<".newdirname."> exists previously")
    return
   endif
   if s:FileReadable(fullnewdir)
    if !exists("g:netrw_quiet")
     keepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a file!",25)
    endif
    let @@= ykeep
"    call Dret("s:NetrwMakeDir : file<".newdirname."> exists previously")
    return
   endif

   " requested new local directory is neither a pre-existing file or
   " directory, so make it!
   if exists("*mkdir")
    if has("unix")
     call mkdir(fullnewdir,"p",xor(0777, system("umask")))
    else
     call mkdir(fullnewdir,"p")
    endif
   else
    let netrw_origdir= s:NetrwGetcwd(1)
    call s:NetrwLcd(b:netrw_curdir)
"    call Decho("netrw_origdir<".netrw_origdir.">: lcd b:netrw_curdir<".fnameescape(b:netrw_curdir).">")
"    call Decho("exe sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1))
    exe "sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1)
    if v:shell_error != 0
     let @@= ykeep
     call netrw#ErrorMsg(s:ERROR,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
"     call Dret("s:NetrwMakeDir : failed: sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1))
     return
    endif
    if !g:netrw_keepdir
"     call Decho("restoring netrw_origdir since g:netrw_keepdir=".g:netrw_keepdir)
     call s:NetrwLcd(netrw_origdir)
    endif
   endif

   if v:shell_error == 0
    " refresh listing
"    call Decho("refresh listing")
    let svpos= netrw#SavePosn()
    call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
    call netrw#RestorePosn(svpos)
   elseif !exists("g:netrw_quiet")
    call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",26)
   endif
"   redraw!

  elseif !exists("b:netrw_method") || b:netrw_method == 4
   " Remote mkdir:  using ssh
"   call Decho("remote mkdir")
   let mkdircmd  = s:MakeSshCmd(g:netrw_mkdir_cmd)
   let newdirname= substitute(b:netrw_curdir,'^\%(.\{-}/\)\{3}\(.*\)$','\1','').newdirname
"   call Decho("exe sil! !".mkdircmd." ".shellescape(newdirname,1))
   exe "sil! !".mkdircmd." ".shellescape(newdirname,1)
   if v:shell_error == 0
    " refresh listing
    let svpos= netrw#SavePosn()
    keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
    keepj call netrw#RestorePosn(svpos)
   elseif !exists("g:netrw_quiet")
    keepj call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",27)
   endif
"   redraw!

  elseif b:netrw_method == 2
   " Remote mkdir:  using ftp+.netrc
   let svpos= netrw#SavePosn()
"   call Decho("b:netrw_curdir<".b:netrw_curdir.">")
   if exists("b:netrw_fname")
"    call Decho("b:netrw_fname<".b:netrw_fname.">")
    let remotepath= b:netrw_fname
   else
    let remotepath= ""
   endif
   call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
   keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
   keepj call netrw#RestorePosn(svpos)

  elseif b:netrw_method == 3
   " Remote mkdir: using ftp + machine, id, passwd, and fname (ie. no .netrc)
   let svpos= netrw#SavePosn()
"   call Decho("b:netrw_curdir<".b:netrw_curdir.">")
   if exists("b:netrw_fname")
"    call Decho("b:netrw_fname<".b:netrw_fname.">")
    let remotepath= b:netrw_fname
   else
    let remotepath= ""
   endif
   call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
   keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
   keepj call netrw#RestorePosn(svpos)
  endif

  let @@= ykeep
"  call Dret("s:NetrwMakeDir")
endfun

" ---------------------------------------------------------------------
" s:TreeSqueezeDir: allows a shift-cr (gvim only) to squeeze the current tree-listing directory {{{2
fun! s:TreeSqueezeDir(islocal)
"  call Dfunc("s:TreeSqueezeDir(islocal=".a:islocal.")")
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " its a tree-listing style
   let curdepth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
   let iline    = line(".") - 1
   let stopline = (exists("w:netrw_bannercnt")? (w:netrw_bannercnt + 1) : 1)
"   call Decho("curdepth=".curdepth)
"   call Decho("stopline#".stopline)
"   call Decho("starting with line#".line(".").": ".getline('.'))
   while iline > stopline
    " find a line that has less depth
    let depth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
"    call Decho("considering  line#".line(".").": ".getline('.'))
    if depth < curdepth
     break
    endif
    norm! k
   endwhile
"   call Decho("squeezing at line#".line(".").": ".getline('.'))
   call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,s:NetrwGetWord()))
  endif
"  call Dret("s:TreeSqueezeDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwMaps: {{{2
fun! s:NetrwMaps(islocal)
"  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")

  if g:netrw_mousemaps && g:netrw_retmap
"   call Decho("set up Rexplore 2-leftmouse")
   if !hasmapto("<Plug>NetrwReturn")
    if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
"     call Decho("making map for 2-leftmouse")
     nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
    elseif maparg("<c-leftmouse>","n") == ""
"     call Decho("making map for c-leftmouse")
     nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
    endif
   endif
   nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
"   call Decho("made <Plug>NetrwReturn map")
  endif

  if a:islocal
"   call Decho("make local maps")
   " local normal-mode maps
   nnoremap <buffer> <silent> a		:call <SID>NetrwHide(1)<cr>
   nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(1)<cr>
   nnoremap <buffer> <silent> c		:call <SID>NetrwLcd(b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> C		:<c-u>call <SID>NetrwSetChgwin()<cr>
   nnoremap <buffer> <silent> <cr>	:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
   nnoremap <buffer> <silent> <s-cr>	:call <SID>TreeSqueezeDir(1)<cr>
   nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("")<cr>
   nnoremap <buffer> <silent> -		:call <SID>NetrwBrowseUpDir(1)<cr>
   nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
   nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
   nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(1)<cr>
   nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
   nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
   nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
   nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
   nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
   nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
   nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
   nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
   nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
   nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
   nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
   nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
   nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
   nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
   nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
   nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(1)<cr>
   nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(3)<cr>
   nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(1)<cr>
   nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
   nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(1)<cr>
   nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(1)<cr>
   nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(4)<cr>
   nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
   nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
   nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
   nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
   nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(5)<cr>
   nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   nnoremap <buffer> <silent> X		:call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
   " local insert-mode maps
   inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(1)<cr>
   inoremap <buffer> <silent> c		<c-o>:exe "keepjumps lcd ".fnameescape(b:netrw_curdir)<cr>
   inoremap <buffer> <silent> c		<c-o>:call <SID>NetrwLcd(b:netrw_curdir)<cr>
   inoremap <buffer> <silent> C		<c-o>:call <SID>NetrwSetChgwin()<cr>
   inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(1)<cr>
   inoremap <buffer> <silent> -		<c-o>:call <SID>NetrwBrowseUpDir(1)<cr>
   inoremap <buffer> <silent> <cr>	<c-o>:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
   inoremap <buffer> <silent> <s-cr>	<c-o>:call <SID>TreeSqueezeDir(1)<cr>
   inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("")<cr>
   inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(1)<cr>
   inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
   inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(1)<cr>
   inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
   inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
   inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
   inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
   inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
   inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
   inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
   inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
   inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
   inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
   inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
   inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
   inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
   inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
   inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
   inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(1)<cr>
   inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(3)<cr>
   inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
   inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
   inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
   inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(1)<cr>
   inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(1)<cr>
   inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(4)<cr>
   inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
   inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
   inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
   inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
   inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(5)<cr>
   inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   if !hasmapto('<Plug>NetrwHideEdit')
    nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
    imap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
   endif
   nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(1)<cr>
   if !hasmapto('<Plug>NetrwRefresh')
    nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
    imap <buffer> <unique> <c-l> <Plug>NetrwRefresh
   endif
   nnoremap <buffer> <silent> <Plug>NetrwRefresh		:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   if s:didstarstar || !mapcheck("<s-down>","n")
    nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
    inoremap <buffer> <silent> <s-down>	:Nexplore<cr>
   endif
   if s:didstarstar || !mapcheck("<s-up>","n")
    nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
    inoremap <buffer> <silent> <s-up>	:Pexplore<cr>
   endif
   let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
   if g:netrw_mousemaps == 1
    nmap <buffer> <leftmouse>   	<Plug>NetrwLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwLeftmouse		<leftmouse>:call <SID>NetrwLeftmouse(1)<cr>
    nmap <buffer> <middlemouse>		<Plug>NetrwMiddlemouse
    nno  <buffer> <silent>		<Plug>NetrwMiddlemouse		<leftmouse>:call <SID>NetrwPrevWinOpen(1)<cr>
    nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 		<leftmouse>:call <SID>NetrwSLeftmouse(1)<cr>
    nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
    nno  <buffer> <silent>		<Plug>NetrwSLeftdrag		<leftmouse>:call <SID>NetrwSLeftdrag(1)<cr>
    nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
    nmap <buffer> <silent>		<Plug>Netrw2Leftmouse		-
    imap <buffer> <leftmouse>		<Plug>ILeftmouse
    ino  <buffer> <silent>		<Plug>ILeftmouse		<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(1)<cr>
    imap <buffer> <middlemouse>		<Plug>IMiddlemouse
    ino  <buffer> <silent>		<Plug>IMiddlemouse		<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
    imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
    ino  <buffer> <silent>		<Plug>ISLeftmouse		<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
    exe 'nnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    exe 'vnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    exe 'inoremap <buffer> <silent> <rightmouse>  <c-o><leftmouse><c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   endif
   exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("")<cr>'
   exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   exe 'inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("")<cr>'
   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>

  else " remote
"   call Decho("make remote maps")
   call s:RemotePathAnalysis(b:netrw_curdir)
   " remote normal-mode maps
   nnoremap <buffer> <silent> <cr>	:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
   nnoremap <buffer> <silent> <s-cr>	:call <SID>TreeSqueezeDir(0)<cr>
   nnoremap <buffer> <silent> <c-l>	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   nnoremap <buffer> <silent> -		:call <SID>NetrwBrowseUpDir(0)<cr>
   nnoremap <buffer> <silent> a		:call <SID>NetrwHide(0)<cr>
   nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
   nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
   nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
   nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
   nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
   nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
   nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
   nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
   nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
   nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
   nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
   nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
   nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
   nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
   nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
   nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
   nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> C		:<c-u>call <SID>NetrwSetChgwin()<cr>
   nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(0)<cr>
   nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
   nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(0)<cr>
   nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(0)<cr>
   nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(0)<cr>
   nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
   nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(0)<cr>
   nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(0)<cr>
   nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(1)<cr>
   nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
   nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
   nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(2)<cr>
   nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
   nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(0)<cr>
   " remote insert-mode maps
   inoremap <buffer> <silent> <cr>	<c-o>:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
   inoremap <buffer> <silent> <c-l>	<c-o>:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   inoremap <buffer> <silent> <s-cr>	<c-o>:call <SID>TreeSqueezeDir(0)<cr>
   inoremap <buffer> <silent> -		<c-o>:call <SID>NetrwBrowseUpDir(0)<cr>
   inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(0)<cr>
   inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
   inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
   inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
   inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
   inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
   inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
   inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
   inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
   inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
   inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
   inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
   inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
   inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
   inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
   inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
   inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
   inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(0)<cr>
   inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> C		<c-o>:call <SID>NetrwSetChgwin()<cr>
   inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(0)<cr>
   inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
   inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(0)<cr>
   inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(0)<cr>
   inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
   inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
   inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
   inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(0)<cr>
   inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(0)<cr>
   inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(1)<cr>
   inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
   inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
   inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(2)<cr>
   inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
   inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(0)<cr>
   if !hasmapto('<Plug>NetrwHideEdit')
    nmap <buffer> <c-h> <Plug>NetrwHideEdit
    imap <buffer> <c-h> <Plug>NetrwHideEdit
   endif
   nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
   if !hasmapto('<Plug>NetrwRefresh')
    nmap <buffer> <c-l> <Plug>NetrwRefresh
    imap <buffer> <c-l> <Plug>NetrwRefresh
   endif

   let mapsafepath     = escape(s:path, s:netrw_map_escape)
   let mapsafeusermach = escape(s:user.s:machine, s:netrw_map_escape)

   nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   if g:netrw_mousemaps == 1
    nmap <leftmouse>		<Plug>NetrwLeftmouse
    nno <buffer> <silent>	<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(0)<cr>
    nmap <buffer> <leftdrag>	<Plug>NetrwLeftdrag
    nno  <buffer> <silent>	<Plug>NetrwLeftdrag	:call <SID>NetrwLeftdrag(0)<cr>
    nmap <buffer> <s-leftmouse>	<Plug>NetrwSLeftmouse
    nno  <buffer> <silent>	<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(0)<cr>
    nmap <buffer> <s-leftdrag>	<Plug>NetrwSLeftdrag
    nno  <buffer> <silent>	<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(0)<cr>
    nmap <middlemouse>		<Plug>NetrwMiddlemouse
    nno  <buffer> <silent>	<middlemouse>		<Plug>NetrwMiddlemouse <leftmouse>:call <SID>NetrwPrevWinOpen(0)<cr>
    nmap <buffer> <2-leftmouse>	<Plug>Netrw2Leftmouse
    nmap <buffer> <silent>	<Plug>Netrw2Leftmouse	-
    imap <buffer> <leftmouse>	<Plug>ILeftmouse
    ino  <buffer> <silent>	<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(0)<cr>
    imap <buffer> <middlemouse>	<Plug>IMiddlemouse
    ino  <buffer> <silent>	<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
    imap <buffer> <s-leftmouse>	<Plug>ISLeftmouse
    ino  <buffer> <silent>	<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
    exe 'nnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
    exe 'vnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
    exe 'inoremap <buffer> <silent> <rightmouse> <c-o><leftmouse><c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   endif
   exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
   exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
   exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
   inoremap <buffer> <F1>			<c-o>:he netrw-quickhelp<cr>
  endif

  keepj call s:SetRexDir(a:islocal,b:netrw_curdir)

"  call Dret("s:NetrwMaps")
endfun

" ---------------------------------------------------------------------
" s:NetrwCommands: sets up commands available only in the netrw buffer windows {{{2
fun! s:NetrwCommands(islocal)
"  call Dfunc("s:NetrwCommands(islocal=".a:islocal.")")

  com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"not a former netrw window",79)|endif
  if a:islocal
   com! -buffer -nargs=+ -complete=file MF	call s:NetrwMarkFiles(1,<f-args>)
  else
   com! -buffer -nargs=+ -complete=file MF	call s:NetrwMarkFiles(0,<f-args>)
  endif
  com! -buffer -nargs=? -complete=file MT	call s:NetrwMarkTarget(<q-args>)

"  call Dret("s:NetrwCommands")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFiles: apply s:NetrwMarkFile() to named file(s) {{{2
"                   glob()ing only works with local files
fun! s:NetrwMarkFiles(islocal,...)
"  call Dfunc("s:NetrwMarkFiles(islocal=".a:islocal."...) a:0=".a:0)
  let i = 1
  while i <= a:0
   if a:islocal
    let mffiles= glob(a:{i},0,1)
   else
    let mffiles= [a:{i}]
   endif
"   call Decho("mffiles".string(mffiles))
   for mffile in mffiles
"    call Decho("mffile<".mffile.">")
    call s:NetrwMarkFile(a:islocal,mffile)
   endfor
   let i= i + 1
  endwhile
"  call Dret("s:NetrwMarkFiles")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkTarget: {{{2
fun! s:NetrwMarkTarget(...)
"  call Dfunc("s:NetrwMarkTarget() a:0=".a:0)
  if a:0 == 0 || (a:0 == 1 && a:1 == "")
   let tgt= b:netrw_curdir
  else
   let tgt= a:1
  endif
"  call Decho("tgt<".tgt.">")
  let s:netrwmftgt         = tgt
  let s:netrwmftgt_islocal = tgt !~ '^\a\+://'
  let curislocal           = b:netrw_curdir !~ '^\a\+://'
  let svpos                = netrw#SavePosn()
  call s:NetrwRefresh(curislocal,s:NetrwBrowseChgDir(curislocal,'./'))
  call netrw#RestorePosn(svpos)
"  call Dret("s:NetrwMarkTarget")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFile: (invoked by mf) This function is used to both {{{2
"                  mark and unmark files.  If a markfile list exists,
"                  then the rename and delete functions will use it instead
"                  of whatever may happen to be under the cursor at that
"                  moment.  When the mouse and gui are available,
"                  shift-leftmouse may also be used to mark files.
"
"  Creates two lists
"    s:netrwmarkfilelist    -- holds complete paths to all marked files
"    s:netrwmarkfilelist_#  -- holds list of marked files in current-buffer's directory (#==bufnr())
"
"  Creates a marked file match string
"    s:netrwmarfilemtch_#   -- used with 2match to display marked files
"
"  Creates a buffer version of islocal
"    b:netrw_islocal
fun! s:NetrwMarkFile(islocal,fname)
"  call Dfunc("s:NetrwMarkFile(islocal=".a:islocal." fname<".a:fname.">)")

  " sanity check
  if empty(a:fname)
"   call Dret("s:NetrwMarkFile : emtpy fname")
   return
  endif

  let ykeep   = @@
  let curbufnr= bufnr("%")
  let curdir  = b:netrw_curdir
  if a:fname =~ '^\a'
   let leader= '\<'
  else
   let leader= ''
  endif
  if a:fname =~ '\a$'
   let trailer = '\>[@=|\/\*]\=\ze\%(  \|\t\|$\)'
  else
   let trailer = '[@=|\/\*]\=\ze\%(  \|\t\|$\)'
  endif

  if exists("s:netrwmarkfilelist_{curbufnr}")
   " markfile list pre-exists
"   call Decho("starting s:netrwmarkfilelist_{curbufnr}<".string(s:netrwmarkfilelist_{curbufnr}).">")
"   call Decho("starting s:netrwmarkfilemtch_{curbufnr}<".s:netrwmarkfilemtch_{curbufnr}.">")
   let b:netrw_islocal= a:islocal

   if index(s:netrwmarkfilelist_{curbufnr},a:fname) == -1
    " append filename to buffer's markfilelist
"    call Decho("append filename<".a:fname."> to local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">")
    call add(s:netrwmarkfilelist_{curbufnr},a:fname)
    let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(a:fname,g:netrw_markfileesc).trailer

   else
    " remove filename from buffer's markfilelist
"    call Decho("remove filename<".a:fname."> from local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">")
    call filter(s:netrwmarkfilelist_{curbufnr},'v:val != a:fname')
    if s:netrwmarkfilelist_{curbufnr} == []
     " local markfilelist is empty; remove it entirely
"     call Decho("markfile list now empty")
     call s:NetrwUnmarkList(curbufnr,curdir)
    else
     " rebuild match list to display markings correctly
"     call Decho("rebuild s:netrwmarkfilemtch_".curbufnr)
     let s:netrwmarkfilemtch_{curbufnr}= ""
     let first                         = 1
     for fname in s:netrwmarkfilelist_{curbufnr}
      if first
       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.leader.escape(fname,g:netrw_markfileesc).trailer
      else
       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(fname,g:netrw_markfileesc).trailer
      endif
      let first= 0
     endfor
"     call Decho("ending s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">")
    endif
   endif

  else
   " initialize new markfilelist

"   call Decho("add fname<".a:fname."> to new markfilelist_".curbufnr)
   let s:netrwmarkfilelist_{curbufnr}= []
   call add(s:netrwmarkfilelist_{curbufnr},a:fname)
"   call Decho("ending s:netrwmarkfilelist_{curbufnr}<".string(s:netrwmarkfilelist_{curbufnr}).">")

   " build initial markfile matching pattern
   if a:fname =~ '/$'
    let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc)
   else
    let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc).trailer
   endif
"   call Decho("ending s:netrwmarkfilemtch_".curbufnr."<".s:netrwmarkfilemtch_{curbufnr}.">")
  endif

  " handle global markfilelist
  if exists("s:netrwmarkfilelist")
   let dname= s:ComposePath(b:netrw_curdir,a:fname)
   if index(s:netrwmarkfilelist,dname) == -1
    " append new filename to global markfilelist
    call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
"    call Decho("append filename<".a:fname."> to global markfilelist<".string(s:netrwmarkfilelist).">")
   else
    " remove new filename from global markfilelist
"    call Decho("filter(".string(s:netrwmarkfilelist).",'v:val != '.".dname.")")
    call filter(s:netrwmarkfilelist,'v:val != "'.dname.'"')
"    call Decho("ending s:netrwmarkfilelist  <".string(s:netrwmarkfilelist).">")
    if s:netrwmarkfilelist == []
     unlet s:netrwmarkfilelist
    endif
   endif
  else
   " initialize new global-directory markfilelist
   let s:netrwmarkfilelist= []
   call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
"   call Decho("init s:netrwmarkfilelist<".string(s:netrwmarkfilelist).">")
  endif

  " set up 2match'ing to netrwmarkfilemtch list
  if exists("s:netrwmarkfilemtch_{curbufnr}") && s:netrwmarkfilemtch_{curbufnr} != ""
"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/")
   if exists("g:did_drchip_netrwlist_syntax")
    exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/"
   endif
  else
"   call Decho("2match none")
   2match none
  endif
  let @@= ykeep
"  call Dret("s:NetrwMarkFile : s:netrwmarkfilelist_".curbufnr."<".(exists("s:netrwmarkfilelist_{curbufnr}")? string(s:netrwmarkfilelist_{curbufnr}) : " doesn't exist").">")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileCompress: (invoked by mz) This function is used to {{{2
"                          compress/decompress files using the programs
"                          in g:netrw_compress and g:netrw_uncompress,
"                          using g:netrw_compress_suffix to know which to
"                          do.  By default:
"                            g:netrw_compress        = "gzip"
"                            g:netrw_decompress      = { ".gz" : "gunzip" , ".bz2" : "bunzip2" , ".zip" : "unzip" , ".tar" : "tar -xf", ".xz" : "unxz"}
fun! s:NetrwMarkFileCompress(islocal)
"  call Dfunc("s:NetrwMarkFileCompress(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileCompress")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist_{curbufnr}") && exists("g:netrw_compress") && exists("g:netrw_decompress")

   " for every filename in the marked list
   for fname in s:netrwmarkfilelist_{curbufnr}
    let sfx= substitute(fname,'^.\{-}\(\.\a\+\)$','\1','')
"    call Decho("extracted sfx<".sfx.">")
    if exists("g:netrw_decompress['".sfx."']")
     " fname has a suffix indicating that its compressed; apply associated decompression routine
     let exe= g:netrw_decompress[sfx]
"     call Decho("fname<".fname."> is compressed so decompress with <".exe.">")
     let exe= netrw#WinPath(exe)
     if a:islocal
      if g:netrw_keepdir
       let fname= shellescape(s:ComposePath(curdir,fname))
      endif
     else
      let fname= shellescape(b:netrw_curdir.fname,1)
     endif
     if executable(exe)
      if a:islocal
       call system(exe." ".fname)
      else
       keepj call s:RemoteSystem(exe." ".fname)
      endif
     else
      keepj call netrw#ErrorMsg(s:WARNING,"unable to apply<".exe."> to file<".fname.">",50)
     endif
    endif
    unlet sfx

    if exists("exe")
     unlet exe
    elseif a:islocal
     " fname not a compressed file, so compress it
     call system(netrw#WinPath(g:netrw_compress)." ".shellescape(s:ComposePath(b:netrw_curdir,fname)))
    else
     " fname not a compressed file, so compress it
     keepj call s:RemoteSystem(netrw#WinPath(g:netrw_compress)." ".shellescape(fname))
    endif
   endfor	" for every file in the marked list

   call s:NetrwUnmarkList(curbufnr,curdir)
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   keepj call netrw#RestorePosn(svpos)
  endif
"  call Dret("s:NetrwMarkFileCompress")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileCopy: (invoked by mc) copy marked files to target {{{2
"                      If no marked files, then set up directory as the
"                      target.  Currently does not support copying entire
"                      directories.  Uses the local-buffer marked file list.
"                      Returns 1=success  (used by NetrwMarkFileMove())
"                              0=failure
fun! s:NetrwMarkFileCopy(islocal,...)
"  call Dfunc("s:NetrwMarkFileCopy(islocal=".a:islocal.") target<".(exists("s:netrwmftgt")? s:netrwmftgt : '---')."> a:0=".a:0)

  if !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
"   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)")
  endif
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileCopy")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if !exists("s:netrwmftgt")
   keepj call netrw#ErrorMsg(s:ERROR,"your marked file target is empty! (:help netrw-mt)",67)
"   call Dret("s:NetrwMarkFileCopy 0")
   return 0
  endif
"  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">")

  if      a:islocal &&  s:netrwmftgt_islocal
   " Copy marked files, local directory to local directory
"   call Decho("copy from local to local")
   if !executable(g:netrw_localcopycmd) && g:netrw_localcopycmd !~ '^'.expand("$COMSPEC").'\s'
    call netrw#ErrorMsg(s:ERROR,"g:netrw_localcopycmd<".g:netrw_localcopycmd."> not executable on your system, aborting",91)
"    call Dfunc("s:NetrwMarkFileMove : g:netrw_localcopycmd<".g:netrw_localcopycmd."> n/a!")
    return
   endif

   " copy marked files while within the same directory (ie. allow renaming)
   if simplify(s:netrwmftgt) == simplify(b:netrw_curdir)
    if len(s:netrwmarkfilelist_{bufnr('%')}) == 1
     " only one marked file
     let args    = shellescape(b:netrw_curdir."/".s:netrwmarkfilelist_{bufnr('%')}[0])
     let oldname = s:netrwmarkfilelist_{bufnr('%')}[0]
    elseif a:0 == 1
     " this happens when the next case was used to recursively call s:NetrwMarkFileCopy()
     let args    = shellescape(b:netrw_curdir."/".a:1)
     let oldname = a:1
    else
     " copy multiple marked files inside the same directory
     let s:recursive= 1
     for oldname in s:netrwmarkfilelist_{bufnr("%")}
      let ret= s:NetrwMarkFileCopy(a:islocal,oldname)
      if ret == 0
       break
      endif
     endfor
     unlet s:recursive
     call s:NetrwUnmarkList(curbufnr,curdir)
"     call Dret("s:NetrwMarkFileCopy ".ret)
     return ret
    endif

    call inputsave()
    let newname= input("Copy ".oldname." to : ",oldname,"file")
    call inputrestore()
    if newname == ""
"     call Dret("s:NetrwMarkFileCopy 0")
     return 0
    endif
    let args= shellescape(oldname)
    let tgt = shellescape(s:netrwmftgt.'/'.newname)
   else
    let args= join(map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),"shellescape(b:netrw_curdir.\"/\".v:val)"))
    let tgt = shellescape(s:netrwmftgt)
   endif
   if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    let args= substitute(args,'/','\\','g')
    let tgt = substitute(tgt, '/','\\','g')
   endif
   if g:netrw_localcopycmd =~ '\s'
    let copycmd     = substitute(g:netrw_localcopycmd,'\s.*$','','')
    let copycmdargs = substitute(g:netrw_localcopycmd,'^.\{-}\(\s.*\)$','\1','')
    let copycmd     = netrw#WinPath(copycmd).copycmdargs
   else
    let copycmd = netrw#WinPath(g:netrw_localcopycmd)
   endif
"   call Decho("args   <".args.">")
"   call Decho("tgt    <".tgt.">")
"   call Decho("copycmd<".copycmd.">")
"   call Decho("system(".copycmd." ".args." ".tgt.")")
   call system(copycmd." ".args." ".tgt)
   if v:shell_error != 0
    call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localcopycmd<".g:netrw_localcopycmd.">; it doesn't work!",80)
"    call Dret("s:NetrwMarkFileCopy 0 : failed: system(".g:netrw_localcopycmd." ".args." ".shellescape(s:netrwmftgt))
    return 0
   endif

  elseif  a:islocal && !s:netrwmftgt_islocal
   " Copy marked files, local directory to remote directory
"   call Decho("copy from local to remote")
   keepj call s:NetrwUpload(s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)

  elseif !a:islocal &&  s:netrwmftgt_islocal
   " Copy marked files, remote directory to local directory
"   call Decho("copy from remote to local")
   keepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)

  elseif !a:islocal && !s:netrwmftgt_islocal
   " Copy marked files, remote directory to remote directory
"   call Decho("copy from remote to remote")
   let curdir = getcwd()
   let tmpdir = s:GetTempfile("")
   if tmpdir !~ '/'
    let tmpdir= curdir."/".tmpdir
   endif
   if exists("*mkdir")
    call mkdir(tmpdir)
   else
    exe "sil! !".g:netrw_localmkdir.' '.shellescape(tmpdir,1)
    if v:shell_error != 0
     call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
"     call Dret("s:NetrwMarkFileCopy : failed: sil! !".g:netrw_localmkdir.' '.shellescape(tmpdir,1) )
     return
    endif
   endif
   if isdirectory(tmpdir)
    call s:NetrwLcd(tmpdir)
    keepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},tmpdir)
    let localfiles= map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),'substitute(v:val,"^.*/","","")')
    keepj call s:NetrwUpload(localfiles,s:netrwmftgt)
    if getcwd() == tmpdir
     for fname in s:netrwmarkfilelist_{bufnr('%')}
      keepj call s:NetrwDelete(fname)
     endfor
     call s:NetrwLcd(curdir)
     exe "sil !".g:netrw_localrmdir." ".shellescape(tmpdir,1)
     if v:shell_error != 0
      call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localrmdir<".g:netrw_localrmdir."> to something that works",80)
"      call Dret("s:NetrwMarkFileCopy : failed: sil !".g:netrw_localrmdir." ".shellescape(tmpdir,1) )
      return
     endif
    else
     call s:NetrwLcd(curdir)
    endif
   endif
  endif

  " -------
  " cleanup
  " -------
"   call Decho("cleanup")
  if !exists("s:recursive")
   " remove markings from local buffer
   call s:NetrwUnmarkList(curbufnr,curdir)
  endif

  " refresh buffers
  if !s:netrwmftgt_islocal
   call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
  endif
  if a:islocal
   keepj call s:NetrwRefreshDir(a:islocal,curdir)
  endif
  if g:netrw_fastbrowse <= 1
   keepj call s:LocalBrowseRefresh()
  endif
  
"  call Dret("s:NetrwMarkFileCopy 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileDiff: (invoked by md) This function is used to {{{2
"                      invoke vim's diff mode on the marked files.
"                      Either two or three files can be so handled.
"                      Uses the global marked file list.
fun! s:NetrwMarkFileDiff(islocal)
"  call Dfunc("s:NetrwMarkFileDiff(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileDiff")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist_{".curbufnr."}")
   let cnt    = 0
   let curdir = b:netrw_curdir
   for fname in s:netrwmarkfilelist
    let cnt= cnt + 1
    if cnt == 1
"     call Decho("diffthis: fname<".fname.">")
     exe "e ".fnameescape(fname)
     diffthis
    elseif cnt == 2 || cnt == 3
     vsplit
     wincmd l
"     call Decho("diffthis: ".fname)
     exe "e ".fnameescape(fname)
     diffthis
    else
     break
    endif
   endfor
   call s:NetrwUnmarkList(curbufnr,curdir)
  endif

"  call Dret("s:NetrwMarkFileDiff")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileEdit: (invoked by me) put marked files on arg list and start editing them {{{2
"                       Uses global markfilelist
fun! s:NetrwMarkFileEdit(islocal)
"  call Dfunc("s:NetrwMarkFileEdit(islocal=".a:islocal.")")

  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileEdit")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist_{curbufnr}")
   call s:SetRexDir(a:islocal,curdir)
   let flist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
   " unmark markedfile list
"   call s:NetrwUnmarkList(curbufnr,curdir)
   call s:NetrwUnmarkAll()
"   call Decho("exe sil args ".flist)
   exe "sil args ".flist
  endif
  echo "(use :bn, :bp to navigate files; :Rex to return)"
  
"  call Dret("s:NetrwMarkFileEdit")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileQFEL: convert a quickfix-error list into a marked file list {{{2
fun! s:NetrwMarkFileQFEL(islocal,qfel)
"  call Dfunc("s:NetrwMarkFileQFEL(islocal=".a:islocal.",qfel)")
  call s:NetrwUnmarkAll()
  let curbufnr= bufnr("%")

  if !empty(a:qfel)
   for entry in a:qfel
    let bufnmbr= entry["bufnr"]
"    call Decho("bufname(".bufnmbr.")<".bufname(bufnmbr)."> line#".entry["lnum"]." text=".entry["text"])
    if !exists("s:netrwmarkfilelist_{curbufnr}")
"     call Decho("case: no marked file list")
     call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
    elseif index(s:netrwmarkfilelist_{curbufnr},bufname(bufnmbr)) == -1
     " s:NetrwMarkFile will remove duplicate entries from the marked file list.
     " So, this test lets two or more hits on the same pattern to be ignored.
"     call Decho("case: ".bufname(bufnmbr)." not currently in marked file list")
     call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
    else
"     call Decho("case: ".bufname(bufnmbr)." already in marked file list")
    endif
   endfor
   echo "(use me to edit marked files)"
  else
   call netrw#ErrorMsg(s:WARNING,"can't convert quickfix error list; its empty!",92)
  endif

"  call Dret("s:NetrwMarkFileQFEL")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileExe: (invoked by mx) execute arbitrary system command on marked files, one at a time {{{2
"                     Uses the local marked-file list.
fun! s:NetrwMarkFileExe(islocal)
"  call Dfunc("s:NetrwMarkFileExe(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileExe")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist_{curbufnr}")
   " get the command
   call inputsave()
   let cmd= input("Enter command: ","","file")
   call inputrestore()
"   call Decho("cmd<".cmd.">")
   if cmd == ""
"    "   call Dret("s:NetrwMarkFileExe : early exit, empty command")
    return
   endif

   " apply command to marked files.  Substitute: filename -> %
   " If no %, then append a space and the filename to the command
   for fname in s:netrwmarkfilelist_{curbufnr}
    if a:islocal
     if g:netrw_keepdir
      let fname= shellescape(netrw#WinPath(s:ComposePath(curdir,fname)))
     endif
    else
     let fname= shellescape(netrw#WinPath(b:netrw_curdir.fname))
    endif
    if cmd =~ '%'
     let xcmd= substitute(cmd,'%',fname,'g')
    else
     let xcmd= cmd.' '.fname
    endif
    if a:islocal
"     call Decho("local: xcmd<".xcmd.">")
     let ret= system(xcmd)
    else
"     call Decho("remote: xcmd<".xcmd.">")
     let ret= s:RemoteSystem(xcmd)
    endif
    if v:shell_error < 0
     keepj call netrw#ErrorMsg(s:ERROR,"command<".xcmd."> failed, aborting",54)
     break
    else
     echo ret
    endif
   endfor

   " unmark marked file list
   call s:NetrwUnmarkList(curbufnr,curdir)

   " refresh the listing
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   keepj call netrw#RestorePosn(svpos)
  else
   keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif
  
"  call Dret("s:NetrwMarkFileExe")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
"                  as the marked file(s) (toggles suffix presence)
"                  Uses the local marked file list.
fun! s:NetrwMarkHideSfx(islocal)
"  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curbufnr = bufnr("%")

  " s:netrwmarkfilelist_{curbufnr}: the List of marked files
  if exists("s:netrwmarkfilelist_{curbufnr}")

   for fname in s:netrwmarkfilelist_{curbufnr}
"     call Decho("s:NetrwMarkFileCopy: fname<".fname.">")
     " construct suffix pattern
     if fname =~ '\.'
      let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
     else
      let sfxpat= '^\%(\%(\.\)\@!.\)*$'
     endif
     " determine if its in the hiding list or not
     let inhidelist= 0
     if g:netrw_list_hide != ""
      let itemnum = 0
      let hidelist= split(g:netrw_list_hide,',')
      for hidepat in hidelist
       if sfxpat == hidepat
        let inhidelist= 1
        break
       endif
       let itemnum= itemnum + 1
      endfor
     endif
"     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">")
     if inhidelist
      " remove sfxpat from list
      call remove(hidelist,itemnum)
      let g:netrw_list_hide= join(hidelist,",")
     elseif g:netrw_list_hide != ""
      " append sfxpat to non-empty list
      let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
     else
      " set hiding list to sfxpat
      let g:netrw_list_hide= sfxpat
     endif
    endfor

   " refresh the listing
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   keepj call netrw#RestorePosn(svpos)
  else
   keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

"  call Dret("s:NetrwMarkHideSfx")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileVimCmd: (invoked by mX) execute arbitrary vim command on marked files, one at a time {{{2
"                     Uses the local marked-file list.
fun! s:NetrwMarkFileVimCmd(islocal)
"  call Dfunc("s:NetrwMarkFileVimCmd(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileVimCmd")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist_{curbufnr}")
   " get the command
   call inputsave()
   let cmd= input("Enter vim command: ","","file")
   call inputrestore()
"   call Decho("cmd<".cmd.">")
   if cmd == ""
"    "   call Dret("s:NetrwMarkFileVimCmd : early exit, empty command")
    return
   endif

   " apply command to marked files.  Substitute: filename -> %
   " If no %, then append a space and the filename to the command
   for fname in s:netrwmarkfilelist_{curbufnr}
"    call Decho("fname<".fname.">")
    if a:islocal
     1split
     exe "sil! keepalt e ".fnameescape(fname)
"     call Decho("local<".fname.">: exe ".cmd)
     exe cmd
     exe "sil! keepalt wq!"
    else
"     call Decho("remote<".fname.">: exe ".cmd." : NOT SUPPORTED YET")
     echo "sorry, \"mX\" not supported yet for remote files"
    endif
   endfor

   " unmark marked file list
   call s:NetrwUnmarkList(curbufnr,curdir)

   " refresh the listing
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   keepj call netrw#RestorePosn(svpos)
  else
   keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif
  
"  call Dret("s:NetrwMarkFileVimCmd")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
"                  as the marked file(s) (toggles suffix presence)
"                  Uses the local marked file list.
fun! s:NetrwMarkHideSfx(islocal)
"  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curbufnr = bufnr("%")

  " s:netrwmarkfilelist_{curbufnr}: the List of marked files
  if exists("s:netrwmarkfilelist_{curbufnr}")

   for fname in s:netrwmarkfilelist_{curbufnr}
"     call Decho("s:NetrwMarkFileCopy: fname<".fname.">")
     " construct suffix pattern
     if fname =~ '\.'
      let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
     else
      let sfxpat= '^\%(\%(\.\)\@!.\)*$'
     endif
     " determine if its in the hiding list or not
     let inhidelist= 0
     if g:netrw_list_hide != ""
      let itemnum = 0
      let hidelist= split(g:netrw_list_hide,',')
      for hidepat in hidelist
       if sfxpat == hidepat
        let inhidelist= 1
        break
       endif
       let itemnum= itemnum + 1
      endfor
     endif
"     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">")
     if inhidelist
      " remove sfxpat from list
      call remove(hidelist,itemnum)
      let g:netrw_list_hide= join(hidelist,",")
     elseif g:netrw_list_hide != ""
      " append sfxpat to non-empty list
      let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
     else
      " set hiding list to sfxpat
      let g:netrw_list_hide= sfxpat
     endif
    endfor

   " refresh the listing
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   keepj call netrw#RestorePosn(svpos)
  else
   keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

"  call Dret("s:NetrwMarkHideSfx")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileGrep: (invoked by mg) This function applies vimgrep to marked files {{{2
"                     Uses the global markfilelist
fun! s:NetrwMarkFileGrep(islocal)
"  call Dfunc("s:NetrwMarkFileGrep(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curbufnr = bufnr("%")

  if exists("s:netrwmarkfilelist")
"  call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">")
   let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
   call s:NetrwUnmarkAll()
  else
"   call Decho('no marked files, using "*"')
   let netrwmarkfilelist= "*"
  endif

  " ask user for pattern
  call inputsave()
  let pat= input("Enter pattern: ","")
  call inputrestore()
  let patbang = ""
  if pat =~ '^!'
   let patbang = "!"
   let pat= strpart(pat,2)
  endif
  if pat =~ '^\i'
   let pat    = escape(pat,'/')
   let pat    = '/'.pat.'/'
  else
   let nonisi = pat[0]
  endif

  " use vimgrep for both local and remote
"  call Decho("exe vimgrep".patbang." ".pat." ".netrwmarkfilelist)
  try
   exe "keepj noautocmd vimgrep".patbang." ".pat." ".netrwmarkfilelist
  catch /^Vim\%((\a\+)\)\=:E480/
   keepj call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pat.">",76)
"   call Dret("s:NetrwMarkFileGrep : unable to find pattern<".pat.">")
   return
  endtry
  echo "(use :cn, :cp to navigate, :Rex to return)"

  2match none
  keepj call netrw#RestorePosn(svpos)

  if exists("nonisi")
   " original, user-supplied pattern did not begin with a character from isident
"   call Decho("looking for trailing nonisi<".nonisi."> followed by a j, gj, or jg")
   if pat =~ nonisi.'j$\|'.nonisi.'gj$\|'.nonisi.'jg$'
    call s:NetrwMarkFileQFEL(a:islocal,getqflist())
   endif
  endif

"  call Dret("s:NetrwMarkFileGrep")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileMove: (invoked by mm) execute arbitrary command on marked files, one at a time {{{2
"                      uses the global marked file list
"                      s:netrwmfloc= 0: target directory is remote
"                                  = 1: target directory is local
fun! s:NetrwMarkFileMove(islocal)
"  call Dfunc("s:NetrwMarkFileMove(islocal=".a:islocal.")")
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileMove")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if !exists("s:netrwmftgt")
   keepj call netrw#ErrorMsg(2,"your marked file target is empty! (:help netrw-mt)",67)
"   call Dret("s:NetrwMarkFileCopy 0")
   return 0
  endif
"  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">")

  if      a:islocal &&  s:netrwmftgt_islocal
   " move: local -> local
"   call Decho("move from local to local")
"   call Decho("local to local move")
   if !executable(g:netrw_localmovecmd) && g:netrw_localmovecmd !~ '^'.expand("$COMSPEC").'\s'
    call netrw#ErrorMsg(s:ERROR,"g:netrw_localmovecmd<".g:netrw_localmovecmd."> not executable on your system, aborting",90)
"    call Dfunc("s:NetrwMarkFileMove : g:netrw_localmovecmd<".g:netrw_localmovecmd."> n/a!")
    return
   endif
   let tgt         = shellescape(s:netrwmftgt)
"   call Decho("tgt<".tgt.">")
   if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    let tgt         = substitute(tgt, '/','\\','g')
"    call Decho("windows exception: tgt<".tgt.">")
    if g:netrw_localmovecmd =~ '\s'
     let movecmd     = substitute(g:netrw_localmovecmd,'\s.*$','','')
     let movecmdargs = substitute(g:netrw_localmovecmd,'^.\{-}\(\s.*\)$','\1','')
     let movecmd     = netrw#WinPath(movecmd).movecmdargs
"     call Decho("windows exception: movecmd<".movecmd."> (#1: had a space)")
    else
     let movecmd = netrw#WinPath(movecmd)
"     call Decho("windows exception: movecmd<".movecmd."> (#2: no space)")
    endif
   else
    let movecmd = netrw#WinPath(g:netrw_localmovecmd)
"    call Decho("movecmd<".movecmd."> (#3 linux or cygwin)")
   endif
   for fname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("system(".movecmd." ".shellescape(fname)." ".tgt.")")
    if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
     let fname= substitute(fname,'/','\\','g')
    endif
    let ret= system(g:netrw_localmovecmd." ".shellescape(fname)." ".tgt)
    if v:shell_error != 0
     call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localmovecmd<".g:netrw_localmovecmd.">; it doesn't work!",54)
     break
    endif
   endfor

  elseif  a:islocal && !s:netrwmftgt_islocal
   " move: local -> remote
"   call Decho("move from local to remote")
"   call Decho("copy")
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   keepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove")
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwLocalRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist

  elseif !a:islocal &&  s:netrwmftgt_islocal
   " move: remote -> local
"   call Decho("move from remote to local")
"   call Decho("copy")
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   keepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove")
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist

  elseif !a:islocal && !s:netrwmftgt_islocal
   " move: remote -> remote
"   call Decho("move from remote to remote")
"   call Decho("copy")
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   keepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove")
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist
  endif

  " -------
  " cleanup
  " -------
"  call Decho("cleanup")

  " remove markings from local buffer
  call s:NetrwUnmarkList(curbufnr,curdir)                   " remove markings from local buffer

  " refresh buffers
  if !s:netrwmftgt_islocal
"   call Decho("refresh netrwmftgt<".s:netrwmftgt.">")
   keepj call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
  endif
  if a:islocal
"   call Decho("refresh b:netrw_curdir<".b:netrw_curdir.">")
   keepj call s:NetrwRefreshDir(a:islocal,b:netrw_curdir)
  endif
  if g:netrw_fastbrowse <= 1
"   call Decho("since g:netrw_fastbrowse=".g:netrw_fastbrowse.", perform shell cmd refresh")
   keepj call s:LocalBrowseRefresh()
  endif
  
"  call Dret("s:NetrwMarkFileMove")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFilePrint: (invoked by mp) This function prints marked files {{{2
"                       using the hardcopy command.  Local marked-file list only.
fun! s:NetrwMarkFilePrint(islocal)
"  call Dfunc("s:NetrwMarkFilePrint(islocal=".a:islocal.")")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFilePrint")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
  if exists("s:netrwmarkfilelist_{curbufnr}")
   let netrwmarkfilelist = s:netrwmarkfilelist_{curbufnr}
   let curdir            = b:netrw_curdir
   call s:NetrwUnmarkList(curbufnr,curdir)
   for fname in netrwmarkfilelist
    if a:islocal
     if g:netrw_keepdir
      let fname= s:ComposePath(curdir,fname)
     endif
    else
     let fname= curdir.fname
    endif
    1split
    " the autocmds will handle both local and remote files
"    call Decho("exe sil e ".escape(fname,' '))
    exe "sil e ".fnameescape(fname)
"    call Decho("hardcopy")
    hardcopy
    q
   endfor
   2match none
  endif
"  call Dret("s:NetrwMarkFilePrint")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileRegexp: (invoked by mr) This function is used to mark {{{2
"                        files when given a regexp (for which a prompt is
"                        issued) (matches to name of files).
fun! s:NetrwMarkFileRegexp(islocal)
"  call Dfunc("s:NetrwMarkFileRegexp(islocal=".a:islocal.")")

  " get the regular expression
  call inputsave()
  let regexp= input("Enter regexp: ","","file")
  call inputrestore()

  if a:islocal
   " get the matching list of files using local glob()
"   call Decho("handle local regexp")
   let dirname = escape(b:netrw_curdir,g:netrw_glob_escape)
   let files   = glob(s:ComposePath(dirname,regexp))
"   call Decho("files<".files.">")
   let filelist= split(files,"\n")

  " mark the list of files
  for fname in filelist
"   call Decho("fname<".fname.">")
   keepj call s:NetrwMarkFile(a:islocal,substitute(fname,'^.*/','',''))
  endfor

  else
"   call Decho("handle remote regexp")

   " convert displayed listing into a filelist
   let eikeep = &ei
   let areg   = @a
   sil keepj %y a
   setl ei=all ma
"   call Decho("setl ei=all ma")
   1split
   keepj call s:NetrwEnew()
   keepj call s:NetrwSafeOptions()
   sil keepj norm! "ap
   keepj 2
   let bannercnt= search('^" =====','W')
   exe "sil keepj 1,".bannercnt."d"
   setl bt=nofile
   if     g:netrw_liststyle == s:LONGLIST
    sil keepj %s/\s\{2,}\S.*$//e
    call histdel("/",-1)
   elseif g:netrw_liststyle == s:WIDELIST
    sil keepj %s/\s\{2,}/\r/ge
    call histdel("/",-1)
   elseif g:netrw_liststyle == s:TREELIST
    exe 'sil keepj %s/^'.s:treedepthstring.' //e'
    sil! keepj g/^ .*$/d
    call histdel("/",-1)
    call histdel("/",-1)
   endif
   " convert regexp into the more usual glob-style format
   let regexp= substitute(regexp,'\*','.*','g')
"   call Decho("regexp<".regexp.">")
   exe "sil! keepj v/".escape(regexp,'/')."/d"
   call histdel("/",-1)
   let filelist= getline(1,line("$"))
   q!
   for filename in filelist
    keepj call s:NetrwMarkFile(a:islocal,substitute(filename,'^.*/','',''))
   endfor
   unlet filelist
   let @a  = areg
   let &ei = eikeep
  endif
  echo "  (use me to edit marked files)"

"  call Dret("s:NetrwMarkFileRegexp")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileSource: (invoked by ms) This function sources marked files {{{2
"                        Uses the local marked file list.
fun! s:NetrwMarkFileSource(islocal)
"  call Dfunc("s:NetrwMarkFileSource(islocal=".a:islocal.")")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileSource")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
  if exists("s:netrwmarkfilelist_{curbufnr}")
   let netrwmarkfilelist = s:netrwmarkfilelist_{bufnr("%")}
   let curdir            = b:netrw_curdir
   call s:NetrwUnmarkList(curbufnr,curdir)
   for fname in netrwmarkfilelist
    if a:islocal
     if g:netrw_keepdir
      let fname= s:ComposePath(curdir,fname)
     endif
    else
     let fname= curdir.fname
    endif
    " the autocmds will handle sourcing both local and remote files
"    call Decho("exe so ".fnameescape(fname))
    exe "so ".fnameescape(fname)
   endfor
   2match none
  endif
"  call Dret("s:NetrwMarkFileSource")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileTag: (invoked by mT) This function applies g:netrw_ctags to marked files {{{2
"                     Uses the global markfilelist
fun! s:NetrwMarkFileTag(islocal)
"  call Dfunc("s:NetrwMarkFileTag(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileTag")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist")
"   call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">")
   let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "shellescape(v:val,".!a:islocal.")"))
   call s:NetrwUnmarkAll()

   if a:islocal
    if executable(g:netrw_ctags)
"     call Decho("call system(".g:netrw_ctags." ".netrwmarkfilelist.")")
     call system(g:netrw_ctags." ".netrwmarkfilelist)
    else
     call netrw#ErrorMsg(s:ERROR,"g:netrw_ctags<".g:netrw_ctags."> is not executable!",51)
    endif
   else
    let cmd   = s:RemoteSystem(g:netrw_ctags." ".netrwmarkfilelist)
    call netrw#Obtain(a:islocal,"tags")
    let curdir= b:netrw_curdir
    1split
    e tags
    let path= substitute(curdir,'^\(.*\)/[^/]*$','\1/','')
"    call Decho("curdir<".curdir."> path<".path.">")
    exe 'keepj %s/\t\(\S\+\)\t/\t'.escape(path,"/\n\r\\").'\1\t/e'
    call histdel("/",-1)
    wq!
   endif
   2match none
   call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   call netrw#RestorePosn(svpos)
  endif

"  call Dret("s:NetrwMarkFileTag")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileTgt:  (invoked by mt) This function sets up a marked file target {{{2
"   Sets up two variables, 
"     s:netrwmftgt         : holds the target directory
"     s:netrwmftgt_islocal : 0=target directory is remote
"                            1=target directory is local
fun! s:NetrwMarkFileTgt(islocal)
"  call Dfunc("s:NetrwMarkFileTgt(islocal=".a:islocal.")")
  let svpos  = netrw#SavePosn()
  let curdir = b:netrw_curdir
  let hadtgt = exists("s:netrwmftgt")
  if !exists("w:netrw_bannercnt")
   let w:netrw_bannercnt= b:netrw_bannercnt
  endif

  " set up target
  if line(".") < w:netrw_bannercnt
   " if cursor in banner region, use b:netrw_curdir for the target unless its already the target
   if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal") && s:netrwmftgt == b:netrw_curdir
"    call Decho("cursor in banner region, and target already is <".b:netrw_curdir.">: removing target")
    unlet s:netrwmftgt s:netrwmftgt_islocal
    if g:netrw_fastbrowse <= 1
     call s:LocalBrowseRefresh()
    endif
    call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
    call netrw#RestorePosn(svpos)
"    call Dret("s:NetrwMarkFileTgt : removed target")
    return
   else
    let s:netrwmftgt= b:netrw_curdir
"    call Decho("inbanner: s:netrwmftgt<".s:netrwmftgt.">")
   endif

  else
   " get word under cursor.
   "  * If directory, use it for the target.
   "  * If file, use b:netrw_curdir for the target
   let curword= s:NetrwGetWord()
   let tgtdir = s:ComposePath(curdir,curword)
   if a:islocal && isdirectory(tgtdir)
    let s:netrwmftgt = tgtdir
"    call Decho("local isdir: s:netrwmftgt<".s:netrwmftgt.">")
   elseif !a:islocal && tgtdir =~ '/$'
    let s:netrwmftgt = tgtdir
"    call Decho("remote isdir: s:netrwmftgt<".s:netrwmftgt.">")
   else
    let s:netrwmftgt = curdir
"    call Decho("isfile: s:netrwmftgt<".s:netrwmftgt.">")
   endif
  endif
  if a:islocal
   " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
   let s:netrwmftgt= simplify(s:netrwmftgt)
"   call Decho("simplify: s:netrwmftgt<".s:netrwmftgt.">")
  endif
  if g:netrw_cygwin
   let s:netrwmftgt= substitute(system("cygpath ".shellescape(s:netrwmftgt)),'\n$','','')
   let s:netrwmftgt= substitute(s:netrwmftgt,'\n$','','')
  endif
  let s:netrwmftgt_islocal= a:islocal

  if g:netrw_fastbrowse <= 1
   call s:LocalBrowseRefresh()
  endif
  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  call netrw#RestorePosn(svpos)
  if !hadtgt
   sil! keepj norm! j
  endif

"  call Dret("s:NetrwMarkFileTgt : netrwmftgt<".(exists("s:netrwmftgt")? s:netrwmftgt : "").">")
endfun

" ---------------------------------------------------------------------
" s:NetrwOpenFile: query user for a filename and open it {{{2
fun! s:NetrwOpenFile(islocal)
"  call Dfunc("s:NetrwOpenFile(islocal=".a:islocal.")")
  let ykeep= @@
  call inputsave()
  let fname= input("Enter filename: ")
  call inputrestore()
  if fname !~ '[/\\]'
   if exists("b:netrw_curdir")
    if exists("g:netrw_quiet")
     let netrw_quiet_keep = g:netrw_quiet
    endif
    let g:netrw_quiet    = 1
    if b:netrw_curdir =~ '/$'
     exe "e ".fnameescape(b:netrw_curdir.fname)
    else
     exe "e ".fnameescape(b:netrw_curdir."/".fname)
    endif
    if exists("netrw_quiet_keep")
     let g:netrw_quiet= netrw_quiet_keep
    else
     unlet g:netrw_quiet
    endif
   endif
  else
   exe "e ".fnameescape(fname)
  endif
  let @@= ykeep
"  call Dret("s:NetrwOpenFile")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkList: delete local marked file lists and remove their contents from the global marked-file list {{{2
"   User access provided by the <mu> mapping. (see :help netrw-mu)
"   Used by many MarkFile functions.
fun! s:NetrwUnmarkList(curbufnr,curdir)
"  call Dfunc("s:NetrwUnmarkList(curbufnr=".a:curbufnr." curdir<".a:curdir.">)")

  "  remove all files in local marked-file list from global list
  if exists("s:netrwmarkfilelist_{a:curbufnr}")
   for mfile in s:netrwmarkfilelist_{a:curbufnr}
    let dfile = s:ComposePath(a:curdir,mfile)       " prepend directory to mfile
    let idx   = index(s:netrwmarkfilelist,dfile)    " get index in list of dfile
    call remove(s:netrwmarkfilelist,idx)            " remove from global list
   endfor
   if s:netrwmarkfilelist == []
    unlet s:netrwmarkfilelist
   endif
 
   " getting rid of the local marked-file lists is easy
   unlet s:netrwmarkfilelist_{a:curbufnr}
  endif
  if exists("s:netrwmarkfilemtch_{a:curbufnr}")
   unlet s:netrwmarkfilemtch_{a:curbufnr}
  endif
  2match none
"  call Dret("s:NetrwUnmarkList")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkAll: remove the global marked file list and all local ones {{{2
fun! s:NetrwUnmarkAll()
"  call Dfunc("s:NetrwUnmarkAll()")
  if exists("s:netrwmarkfilelist")
   unlet s:netrwmarkfilelist
  endif
  sil call s:NetrwUnmarkAll2()
  2match none
"  call Dret("s:NetrwUnmarkAll")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkAll2: unmark all files from all buffers {{{2
fun! s:NetrwUnmarkAll2()
"  call Dfunc("s:NetrwUnmarkAll2()")
  redir => netrwmarkfilelist_let
  let
  redir END
  let netrwmarkfilelist_list= split(netrwmarkfilelist_let,'\n')          " convert let string into a let list
  call filter(netrwmarkfilelist_list,"v:val =~ '^s:netrwmarkfilelist_'") " retain only those vars that start as s:netrwmarkfilelist_ 
  call map(netrwmarkfilelist_list,"substitute(v:val,'\\s.*$','','')")    " remove what the entries are equal to
  for flist in netrwmarkfilelist_list
   let curbufnr= substitute(flist,'s:netrwmarkfilelist_','','')
   unlet s:netrwmarkfilelist_{curbufnr}
   unlet s:netrwmarkfilemtch_{curbufnr}
  endfor
"  call Dret("s:NetrwUnmarkAll2")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnMarkFile: {{{2
fun! s:NetrwUnMarkFile(islocal)
"  call Dfunc("s:NetrwUnMarkFile(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curbufnr = bufnr("%")

  " unmark marked file list (although I expect s:NetrwUpload()
  " to do it, I'm just making sure)
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
"   call Decho("unlet'ing: s:netrwmarkfile[list|mtch]_".bufnr("%"))
   unlet s:netrwmarkfilelist
   unlet s:netrwmarkfilelist_{curbufnr}
   unlet s:netrwmarkfilemtch_{curbufnr}
   2match none
  endif

"  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  call netrw#RestorePosn(svpos)
"  call Dret("s:NetrwUnMarkFile")
endfun

" ---------------------------------------------------------------------
" s:NetrwMenu: generates the menu for gvim and netrw {{{2
fun! s:NetrwMenu(domenu)

  if !exists("g:NetrwMenuPriority")
   let g:NetrwMenuPriority= 80
  endif

  if has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
"   call Dfunc("NetrwMenu(domenu=".a:domenu.")")

   if !exists("s:netrw_menu_enabled") && a:domenu
"    call Decho("initialize menu")
    let s:netrw_menu_enabled= 1
    exe 'sil! menu '.g:NetrwMenuPriority.'.1      '.g:NetrwTopLvlMenu.'Help<tab><F1>	<F1>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.5      '.g:NetrwTopLvlMenu.'-Sep1-	:'
    exe 'sil! menu '.g:NetrwMenuPriority.'.6      '.g:NetrwTopLvlMenu.'Go\ Up\ Directory<tab>-	-'
    exe 'sil! menu '.g:NetrwMenuPriority.'.7      '.g:NetrwTopLvlMenu.'Apply\ Special\ Viewer<tab>x	x'
    if g:netrw_dirhistmax > 0
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.1   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Current\ Directory<tab>mb	mb'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.4   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Prev\ Dir\ (History)<tab>u	u'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.5   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Next\ Dir\ (History)<tab>U	U'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.6   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.List<tab>qb	qb'
    else
     exe 'sil! menu '.g:NetrwMenuPriority.'.8     '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History	:echo "(disabled)"'."\<cr>"
    endif
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.1    '.g:NetrwTopLvlMenu.'Browsing\ Control.Horizontal\ Split<tab>o	o'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.2    '.g:NetrwTopLvlMenu.'Browsing\ Control.Vertical\ Split<tab>v	v'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.3    '.g:NetrwTopLvlMenu.'Browsing\ Control.New\ Tab<tab>t	t'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.4    '.g:NetrwTopLvlMenu.'Browsing\ Control.Preview<tab>p	p'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.5    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ File\ Hiding\ List<tab><ctrl-h>'."	\<c-h>'"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.6    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ Sorting\ Sequence<tab>S	S'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.7    '.g:NetrwTopLvlMenu.'Browsing\ Control.Quick\ Hide/Unhide\ Dot\ Files<tab>'."gh	gh"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.8    '.g:NetrwTopLvlMenu.'Browsing\ Control.Refresh\ Listing<tab>'."<ctrl-l>	\<c-l>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.9    '.g:NetrwTopLvlMenu.'Browsing\ Control.Settings/Options<tab>:NetrwSettings	'.":NetrwSettings\<cr>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.10     '.g:NetrwTopLvlMenu.'Delete\ File/Directory<tab>D	D'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Create\ New\ File<tab>%	%'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Current\ Window<tab><cr>	'."\<cr>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.2   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Preview\ File/Directory<tab>p	p'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.3   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Previous\ Window<tab>P	P'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.4   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Window<tab>o	o'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Vertical\ Window<tab>v	v'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.1   '.g:NetrwTopLvlMenu.'Explore.Directory\ Name	:Explore '
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (curdir\ only)<tab>:Explore\ */	:Explore */'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (+subdirs)<tab>:Explore\ **/	:Explore **/'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.3   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (curdir\ only)<tab>:Explore\ *//	:Explore *//'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (+subdirs)<tab>:Explore\ **//	:Explore **//'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Next\ Match<tab>:Nexplore	:Nexplore<cr>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Prev\ Match<tab>:Pexplore	:Pexplore<cr>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.13     '.g:NetrwTopLvlMenu.'Make\ Subdirectory<tab>d	d'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.1   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ File<tab>mf	mf'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.2   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ Files\ by\ Regexp<tab>mr	mr'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.3   '.g:NetrwTopLvlMenu.'Marked\ Files.Hide-Show-List\ Control<tab>a	a'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.4   '.g:NetrwTopLvlMenu.'Marked\ Files.Copy\ To\ Target<tab>mc	mc'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.5   '.g:NetrwTopLvlMenu.'Marked\ Files.Delete<tab>D	D'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.6   '.g:NetrwTopLvlMenu.'Marked\ Files.Diff<tab>md	md'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.7   '.g:NetrwTopLvlMenu.'Marked\ Files.Edit<tab>me	me'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.8   '.g:NetrwTopLvlMenu.'Marked\ Files.Exe\ Cmd<tab>mx	mx'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.9   '.g:NetrwTopLvlMenu.'Marked\ Files.Move\ To\ Target<tab>mm	mm'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.10  '.g:NetrwTopLvlMenu.'Marked\ Files.Obtain<tab>O	O'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.11  '.g:NetrwTopLvlMenu.'Marked\ Files.Print<tab>mp	mp'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.12  '.g:NetrwTopLvlMenu.'Marked\ Files.Replace<tab>R	R'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.13  '.g:NetrwTopLvlMenu.'Marked\ Files.Set\ Target<tab>mt	mt'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.14  '.g:NetrwTopLvlMenu.'Marked\ Files.Tag<tab>mT	mT'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.15  '.g:NetrwTopLvlMenu.'Marked\ Files.Zip/Unzip/Compress/Uncompress<tab>mz	mz'
    exe 'sil! menu '.g:NetrwMenuPriority.'.15     '.g:NetrwTopLvlMenu.'Obtain\ File<tab>O	O'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.thin<tab>i	:let w:netrw_liststyle=0<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.long<tab>i	:let w:netrw_liststyle=1<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.wide<tab>i	:let w:netrw_liststyle=2<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.tree<tab>i	:let w:netrw_liststyle=3<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.1 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Show\ All<tab>a	:let g:netrw_hide=0<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.3 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Normal<tab>a	:let g:netrw_hide=1<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.2 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Hidden\ Only<tab>a	:let g:netrw_hide=2<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.3   '.g:NetrwTopLvlMenu.'Style.Reverse\ Sorting\ Order<tab>'."r	r"
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.1 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Name<tab>s       :let g:netrw_sort_by="name"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.2 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Time<tab>s       :let g:netrw_sort_by="time"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Size<tab>s       :let g:netrw_sort_by="size"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.17     '.g:NetrwTopLvlMenu.'Rename\ File/Directory<tab>R	R'
    exe 'sil! menu '.g:NetrwMenuPriority.'.18     '.g:NetrwTopLvlMenu.'Set\ Current\ Directory<tab>c	c'
    let s:netrw_menucnt= 28
    call s:NetrwBookmarkMenu() " provide some history!  uses priorities 2,3, reserves 4, 8.2.x
    call s:NetrwTgtMenu()      " let bookmarks and history be easy targets

   elseif !a:domenu
    let s:netrwcnt = 0
    let curwin     = winnr()
    windo if getline(2) =~ "Netrw" | let s:netrwcnt= s:netrwcnt + 1 | endif
    exe curwin."wincmd w"

    if s:netrwcnt <= 1
"     call Decho("clear menus")
     exe 'sil! unmenu '.g:NetrwTopLvlMenu
"     call Decho('exe sil! unmenu '.g:NetrwTopLvlMenu.'*')
     sil! unlet s:netrw_menu_enabled
    endif
   endif
"   call Dret("NetrwMenu")
   return
  endif

endfun

" ---------------------------------------------------------------------
" s:NetrwObtain: obtain file under cursor or from markfile list {{{2
"                Used by the O maps (as <SID>NetrwObtain())
fun! s:NetrwObtain(islocal)
"  call Dfunc("NetrwObtain(islocal=".a:islocal.")")

  let ykeep= @@
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   let islocal= s:netrwmarkfilelist_{bufnr('%')}[1] !~ '^\a\+://'
   call netrw#Obtain(islocal,s:netrwmarkfilelist_{bufnr('%')})
   call s:NetrwUnmarkList(bufnr('%'),b:netrw_curdir)
  else
   call netrw#Obtain(a:islocal,expand("<cWORD>"))
  endif
  let @@= ykeep

"  call Dret("NetrwObtain")
endfun

" ---------------------------------------------------------------------
" s:NetrwPrevWinOpen: open file/directory in previous window.  {{{2
"   If there's only one window, then the window will first be split.
"   Returns:
"     choice = 0 : didn't have to choose
"     choice = 1 : saved modified file in window first
"     choice = 2 : didn't save modified file, opened window
"     choice = 3 : cancel open
fun! s:NetrwPrevWinOpen(islocal)
"  call Dfunc("s:NetrwPrevWinOpen(islocal=".a:islocal.")")

  let ykeep= @@
  " grab a copy of the b:netrw_curdir to pass it along to newly split windows
  let curdir = b:netrw_curdir

  " get last window number and the word currently under the cursor
  let origwin   = winnr()
  let lastwinnr = winnr("$")
  let curword   = s:NetrwGetWord()
  let choice    = 0
  let s:treedir = s:NetrwTreeDir()
  let curdir    = s:treedir
"  call Decho("winnr($)#".lastwinnr." curword<".curword.">")

  let didsplit = 0
  if lastwinnr == 1
   " if only one window, open a new one first
"   call Decho("only one window, so open a new one (g:netrw_alto=".g:netrw_alto.")")
   if g:netrw_preview
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
"    call Decho("exe ".(g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s")
    exe (g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s"
   else
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
"    call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
    exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   endif
   let didsplit = 1
"   call Decho("did split")

  else
   keepj call s:SaveBufVars()
   let eikeep= &ei
   setl ei=all
   wincmd p
"   call Decho("wincmd p  (now in win#".winnr().") curdir<".curdir.">")

   " prevwinnr: the window number of the "prev" window
   " prevbufnr: the buffer number of the buffer in the "prev" window
   " bnrcnt   : the qty of windows open on the "prev" buffer
   let prevwinnr   = winnr()
   let prevbufnr   = bufnr("%")
   let prevbufname = bufname("%")
   let prevmod     = &mod
   let bnrcnt      = 0
   keepj call s:RestoreBufVars()
"   call Decho("after wincmd p: win#".winnr()." win($)#".winnr("$")." origwin#".origwin." &mod=".&mod." bufname(%)<".bufname("%")."> prevbufnr=".prevbufnr)

   " if the previous window's buffer has been changed (ie. its modified flag is set),
   " and it doesn't appear in any other extant window, then ask the
   " user if s/he wants to abandon modifications therein.
   if prevmod
"    call Decho("detected that prev window's buffer has been modified: prevbufnr=".prevbufnr." winnr()#".winnr())
    windo if winbufnr(0) == prevbufnr | let bnrcnt=bnrcnt+1 | endif
"    call Decho("prevbufnr=".prevbufnr." bnrcnt=".bnrcnt." buftype=".&bt." winnr()=".winnr()." prevwinnr#".prevwinnr)
    exe prevwinnr."wincmd w"

    if bnrcnt == 1 && &hidden == 0
     " only one copy of the modified buffer in a window, and
     " hidden not set, so overwriting will lose the modified file.  Ask first...
     let choice = confirm("Save modified buffer<".prevbufname."> first?","&Yes\n&No\n&Cancel")
"     call Decho("(NetrwPrevWinOpen) prevbufname<".prevbufname."> choice=".choice." current-winnr#".winnr())
     let &ei= eikeep

     if choice == 1
      " Yes -- write file & then browse
      let v:errmsg= ""
      sil w
      if v:errmsg != ""
       call netrw#ErrorMsg(s:ERROR,"unable to write <".prevbufname.">!",30)
       exe origwin."wincmd w"
       let &ei = eikeep
       let @@  = ykeep
"       call Dret("s:NetrwPrevWinOpen ".choice." : unable to write <".prevbufname.">")
       return choice
      endif

     elseif choice == 2
      " No -- don't worry about changed file, just browse anyway
"      call Decho("don't worry about chgd file, just browse anyway (winnr($)#".winnr("$").")")
      echomsg "**note** changes to ".prevbufname." abandoned"

     else
      " Cancel -- don't do this
"      call Decho("cancel, don't browse, switch to win#".origwin)
      exe origwin."wincmd w"
      let &ei= eikeep
      let @@ = ykeep
"      call Dret("s:NetrwPrevWinOpen ".choice." : cancelled")
      return choice
     endif
    endif
   endif
   let &ei= eikeep
  endif

  " restore b:netrw_curdir (window split/enew may have lost it)
  let b:netrw_curdir= curdir
  if a:islocal < 2
   if a:islocal
    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(a:islocal,curword))
   else
    call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,curword))
   endif
  endif
  let @@= ykeep
"  call Dret("s:NetrwPrevWinOpen ".choice)
  return choice
endfun

" ---------------------------------------------------------------------
" s:NetrwUpload: load fname to tgt (used by NetrwMarkFileCopy()) {{{2
"                Always assumed to be local -> remote
"                call s:NetrwUpload(filename, target)
"                call s:NetrwUpload(filename, target, fromdirectory)
fun! s:NetrwUpload(fname,tgt,...)
"  call Dfunc("s:NetrwUpload(fname<".((type(a:fname) == 1)? a:fname : string(a:fname))."> tgt<".a:tgt.">) a:0=".a:0)

  if a:tgt =~ '^\a\+://'
   let tgtdir= substitute(a:tgt,'^\a\+://[^/]\+/\(.\{-}\)$','\1','')
  else
   let tgtdir= substitute(a:tgt,'^\(.*\)/[^/]*$','\1','')
  endif
"  call Decho("tgtdir<".tgtdir.">")

  if a:0 > 0
   let fromdir= a:1
  else
   let fromdir= getcwd()
  endif
"  call Decho("fromdir<".fromdir.">")

  if type(a:fname) == 1
   " handle uploading a single file using NetWrite
"   call Decho("handle uploading a single file via NetWrite")
   1split
"   call Decho("exe e ".fnameescape(a:fname))
   exe "e ".fnameescape(a:fname)
"   call Decho("now locally editing<".expand("%").">, has ".line("$")." lines")
   if a:tgt =~ '/$'
    let wfname= substitute(a:fname,'^.*/','','')
"    call Decho("exe w! ".fnameescape(wfname))
    exe "w! ".fnameescape(a:tgt.wfname)
   else
"    call Decho("writing local->remote: exe w ".fnameescape(a:tgt))
    exe "w ".fnameescape(a:tgt)
"    call Decho("done writing local->remote")
   endif
   q!

  elseif type(a:fname) == 3
   " handle uploading a list of files via scp
"   call Decho("handle uploading a list of files via scp")
   let curdir= getcwd()
   if a:tgt =~ '^scp:'
    call s:NetrwLcd(fromdir)
    let filelist= deepcopy(s:netrwmarkfilelist_{bufnr('%')})
    let args    = join(map(filelist,"shellescape(v:val, 1)"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
    let machine = substitute(a:tgt,'^scp://\([^/:]\+\).*$','\1','')
    let tgt     = substitute(a:tgt,'^scp://[^/]\+/\(.*\)$','\1','')
"    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".args." ".shellescape(machine.":".tgt,1))
    exe s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".args." ".shellescape(machine.":".tgt,1)
    call s:NetrwLcd(curdir)

   elseif a:tgt =~ '^ftp:'
    call s:NetrwMethod(a:tgt)

    if b:netrw_method == 2
     " handle uploading a list of files via ftp+.netrc
     let netrw_fname = b:netrw_fname
     sil keepj new
"     call Decho("filter input window#".winnr())

     keepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('$'))

     if exists("g:netrw_ftpextracmd")
      keepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'))
     endif

     keepj call setline(line("$")+1,'lcd "'.fromdir.'"')
"     call Decho("filter input: ".getline('$'))

     if tgtdir == ""
      let tgtdir= '/'
     endif
     keepj call setline(line("$")+1,'cd "'.tgtdir.'"')
"     call Decho("filter input: ".getline('$'))

     for fname in a:fname
      keepj call setline(line("$")+1,'put "'.fname.'"')
"      call Decho("filter input: ".getline('$'))
     endfor

     if exists("g:netrw_port") && g:netrw_port != ""
"      call Decho("executing: ".s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
      exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
     else
"      call Decho("filter input window#".winnr())
"      call Decho("executing: ".s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
      exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     sil keepj g/Local directory now/d
     call histdel("/",-1)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      call netrw#ErrorMsg(s:ERROR,getline(1),14)
     else
      bw!|q
     endif

    elseif b:netrw_method == 3
     " upload with ftp + machine, id, passwd, and fname (ie. no .netrc)
     let netrw_fname= b:netrw_fname
     keepj call s:SaveBufVars()|sil keepj new|keepj call s:RestoreBufVars()
     let tmpbufnr= bufnr("%")
     setl ff=unix

     if exists("g:netrw_port") && g:netrw_port != ""
      keepj put ='open '.g:netrw_machine.' '.g:netrw_port
"      call Decho("filter input: ".getline('$'))
     else
      keepj put ='open '.g:netrw_machine
"      call Decho("filter input: ".getline('$'))
     endif

     if exists("g:netrw_uid") && g:netrw_uid != ""
      if exists("g:netrw_ftp") && g:netrw_ftp == 1
       keepj put =g:netrw_uid
"       call Decho("filter input: ".getline('$'))
       if exists("s:netrw_passwd")
        keepj call setline(line("$")+1,'"'.s:netrw_passwd.'"')
       endif
"       call Decho("filter input: ".getline('$'))
      elseif exists("s:netrw_passwd")
       keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"       call Decho("filter input: ".getline('$'))
      endif
     endif

     keepj call setline(line("$")+1,'lcd "'.fromdir.'"')
"     call Decho("filter input: ".getline('$'))

     if exists("b:netrw_fname") && b:netrw_fname != ""
      keepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"      call Decho("filter input: ".getline('$'))
     endif

     if exists("g:netrw_ftpextracmd")
      keepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'))
     endif

     for fname in a:fname
      keepj call setline(line("$")+1,'put "'.fname.'"')
"      call Decho("filter input: ".getline('$'))
     endfor

     " perform ftp:
     " -i       : turns off interactive prompting from ftp
     " -n  unix : DON'T use <.netrc>, even though it exists
     " -n  win32: quit being obnoxious about password
     keepj norm! 1Gdd
"     call Decho("executing: ".s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
     exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     sil keepj g/Local directory now/d
     call histdel("/",-1)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep= &debug
      setl debug=msg
      call netrw#ErrorMsg(s:ERROR,getline(1),15)
      let &debug = debugkeep
      let mod    = 1
     else
      bw!|q
     endif
    elseif !exists("b:netrw_method") || b:netrw_method < 0
"     call Dfunc("netrw#NetrwUpload : unsupported method")
     return
    endif
   else
    call netrw#ErrorMsg(s:ERROR,"can't obtain files with protocol from<".a:tgt.">",63)
   endif
  endif

"  call Dret("s:NetrwUpload")
endfun

" ---------------------------------------------------------------------
" s:NetrwPreview: {{{2
fun! s:NetrwPreview(path) range
"  call Dfunc("NetrwPreview(path<".a:path.">)")
  let ykeep= @@
  keepj call s:NetrwOptionSave("s:")
  keepj call s:NetrwSafeOptions()
  if has("quickfix")
   if !isdirectory(a:path)
    if g:netrw_preview && !g:netrw_alto
     let pvhkeep = &pvh
     let winsz   = (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
     let &pvh    = winwidth(0) - winsz
    endif
    exe (g:netrw_alto? "top " : "bot ").(g:netrw_preview? "vert " : "")."pedit ".fnameescape(a:path)
    if exists("pvhkeep")
     let &pvh= pvhkeep
    endif
   elseif !exists("g:netrw_quiet")
    keepj call netrw#ErrorMsg(s:WARNING,"sorry, cannot preview a directory such as <".a:path.">",38)
   endif
  elseif !exists("g:netrw_quiet")
   keepj call netrw#ErrorMsg(s:WARNING,"sorry, to preview your vim needs the quickfix feature compiled in",39)
  endif
  keepj call s:NetrwOptionRestore("s:")
  let @@= ykeep
"  call Dret("NetrwPreview")
endfun

" ---------------------------------------------------------------------
" s:NetrwRefresh: {{{2
fun! s:NetrwRefresh(islocal,dirname)
"  call Dfunc("NetrwRefresh(islocal<".a:islocal.">,dirname=".a:dirname.") hide=".g:netrw_hide." sortdir=".g:netrw_sort_direction)
  " at the current time (Mar 19, 2007) all calls to NetrwRefresh() call NetrwBrowseChgDir() first.
  setl ma noro
"  call Decho("setl ma noro")
"  call Decho("clear buffer<".expand("%")."> with :%d")
  let ykeep      = @@

  " save the cursor position before refresh.
  let screenposn = netrw#SavePosn()
"  call Decho("win#".winnr().": ".winheight(0)."x".winwidth(0)." curfile<".expand("%").">")
"  call Decho("clearing buffer prior to refresh")
  sil! keepj %d
  if a:islocal
   keepj call netrw#LocalBrowseCheck(a:dirname)
  else
   keepj call s:NetrwBrowse(a:islocal,a:dirname)
  endif

  " restore position
  keepj call netrw#RestorePosn(screenposn)

  " restore file marks
  if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/")
   exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
  else
"   call Decho("2match none")
   2match none
  endif

"  restore
  let @@= ykeep
"  call Dret("NetrwRefresh")
endfun

" ---------------------------------------------------------------------
" s:NetrwRefreshDir: refreshes a directory by name {{{2
"                    Called by NetrwMarkFileCopy()
"                    Interfaces to s:NetrwRefresh() and s:LocalBrowseRefresh()
fun! s:NetrwRefreshDir(islocal,dirname)
"  call Dfunc("s:NetrwRefreshDir(islocal=".a:islocal." dirname<".a:dirname.">) g:netrw_fastbrowse=".g:netrw_fastbrowse)
  if g:netrw_fastbrowse == 0
   " slowest mode (keep buffers refreshed, local or remote)
"   call Decho("slowest mode: keep buffers refreshed, local or remote")
   let tgtwin= bufwinnr(a:dirname)
"   call Decho("tgtwin= bufwinnr(".a:dirname.")=".tgtwin)

   if tgtwin > 0
    " tgtwin is being displayed, so refresh it
    let curwin= winnr()
"    call Decho("refresh tgtwin#".tgtwin." (curwin#".curwin.")")
    exe tgtwin."wincmd w"
    keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./')) 
    exe curwin."wincmd w"

   elseif bufnr(a:dirname) > 0
    let bn= bufnr(a:dirname)
"    call Decho("bd bufnr(".a:dirname.")=".bn)
    exe "sil bd ".bn
   endif

  elseif g:netrw_fastbrowse <= 1
"   call Decho("medium-speed mode: refresh local buffers only")
   keepj call s:LocalBrowseRefresh()
  endif
"  call Dret("s:NetrwRefreshDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwSetChgwin: set g:netrw_chgwin; a <cr> will use the specified
" window number to do its editing in.
" Supports   [count]C  where the count, if present, is used to specify
" a window to use for editing via the <cr> mapping.
fun! s:NetrwSetChgwin()
"  call Dfunc("s:NetrwSetChgwin() v:count=".v:count)
  if v:count > 0
   let g:netrw_chgwin= v:count
  else
   let g:netrw_chgwin= winnr()
  endif
"  call Dret("s:NetrwSetChgwin")
endfun

" ---------------------------------------------------------------------
" s:NetrwSetSort: sets up the sort based on the g:netrw_sort_sequence {{{2
"          What this function does is to compute a priority for the patterns
"          in the g:netrw_sort_sequence.  It applies a substitute to any
"          "files" that satisfy each pattern, putting the priority / in
"          front.  An "*" pattern handles the default priority.
fun! s:NetrwSetSort()
"  call Dfunc("SetSort() bannercnt=".w:netrw_bannercnt)
  let ykeep= @@
  if w:netrw_liststyle == s:LONGLIST
   let seqlist  = substitute(g:netrw_sort_sequence,'\$','\\%(\t\\|\$\\)','ge')
  else
   let seqlist  = g:netrw_sort_sequence
  endif
  " sanity check -- insure that * appears somewhere
  if seqlist == ""
   let seqlist= '*'
  elseif seqlist !~ '\*'
   let seqlist= seqlist.',*'
  endif
  let priority = 1
  while seqlist != ""
   if seqlist =~ ','
    let seq     = substitute(seqlist,',.*$','','e')
    let seqlist = substitute(seqlist,'^.\{-},\(.*\)$','\1','e')
   else
    let seq     = seqlist
    let seqlist = ""
   endif
   if priority < 10
    let spriority= "00".priority.g:netrw_sepchr
   elseif priority < 100
    let spriority= "0".priority.g:netrw_sepchr
   else
    let spriority= priority.g:netrw_sepchr
   endif
"   call Decho("priority=".priority." spriority<".spriority."> seq<".seq."> seqlist<".seqlist.">")

   " sanity check
   if w:netrw_bannercnt > line("$")
    " apparently no files were left after a Hiding pattern was used
"    call Dret("SetSort : no files left after hiding")
    return
   endif
   if seq == '*'
    let starpriority= spriority
   else
    exe 'sil keepj '.w:netrw_bannercnt.',$g/'.seq.'/s/^/'.spriority.'/'
    call histdel("/",-1)
    " sometimes multiple sorting patterns will match the same file or directory.
    " The following substitute is intended to remove the excess matches.
    exe 'sil keepj '.w:netrw_bannercnt.',$g/^\d\{3}'.g:netrw_sepchr.'\d\{3}\//s/^\d\{3}'.g:netrw_sepchr.'\(\d\{3}\/\).\@=/\1/e'
    keepj call histdel("/",-1)
   endif
   let priority = priority + 1
  endwhile
  if exists("starpriority")
   exe 'sil keepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/e'
   keepj call histdel("/",-1)
  endif

  " Following line associated with priority -- items that satisfy a priority
  " pattern get prefixed by ###/ which permits easy sorting by priority.
  " Sometimes files can satisfy multiple priority patterns -- only the latest
  " priority pattern needs to be retained.  So, at this point, these excess
  " priority prefixes need to be removed, but not directories that happen to
  " be just digits themselves.
  exe 'sil keepj '.w:netrw_bannercnt.',$s/^\(\d\{3}'.g:netrw_sepchr.'\)\%(\d\{3}'.g:netrw_sepchr.'\)\+\ze./\1/e'
  keepj call histdel("/",-1)
  let @@= ykeep

"  call Dret("SetSort")
endfun

" ---------------------------------------------------------------------
" s:NetrwSetTgt: sets the target to the specified choice index {{{2
"    Implements [count]Tb  (bookhist<b>)
"               [count]Th  (bookhist<h>)
"               See :help netrw-qb for how to make the choice.
fun! s:NetrwSetTgt(bookhist,choice)
"  call Dfunc("s:NetrwSetTgt(bookhist<".a:bookhist."> choice#".a:choice.")")

  if     a:bookhist == 'b'
   " supports choosing a bookmark as a target using a qb-generated list
   let choice= a:choice - 1
   if exists("g:netrw_bookmarklist[".choice."]")
    call netrw#MakeTgt(g:netrw_bookmarklist[choice])
   else
    echomsg "Sorry, bookmark#".a:choice." doesn't exist!"
   endif

  elseif a:bookhist == 'h'
   " supports choosing a history stack entry as a target using a qb-generated list
   let choice= (a:choice % g:netrw_dirhistmax) + 1
   if exists("g:netrw_dirhist_".choice)
    let histentry = g:netrw_dirhist_{choice}
    call netrw#MakeTgt(histentry)
   else
    echomsg "Sorry, history#".a:choice." not available!"
   endif
  endif

"  call Dret("s:NetrwSetTgt")
endfun

" =====================================================================
" s:NetrwSortStyle: change sorting style (name - time - size) and refresh display {{{2
fun! s:NetrwSortStyle(islocal)
"  call Dfunc("s:NetrwSortStyle(islocal=".a:islocal.") netrw_sort_by<".g:netrw_sort_by.">")
  keepj call s:NetrwSaveWordPosn()
  let svpos= netrw#SavePosn()

  let g:netrw_sort_by= (g:netrw_sort_by =~ 'n')? 'time' : (g:netrw_sort_by =~ 't')? 'size' : 'name'
  keepj norm! 0
  keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  keepj call netrw#RestorePosn(svpos)

"  call Dret("s:NetrwSortStyle : netrw_sort_by<".g:netrw_sort_by.">")
endfun

" ---------------------------------------------------------------------
" s:NetrwSplit: mode {{{2
"           =0 : net   and o
"           =1 : net   and t
"           =2 : net   and v
"           =3 : local and o
"           =4 : local and t
"           =5 : local and v
fun! s:NetrwSplit(mode)
"  call Dfunc("s:NetrwSplit(mode=".a:mode.") alto=".g:netrw_alto." altv=".g:netrw_altv)

  let ykeep= @@
  call s:SaveWinVars()

  if a:mode == 0
   " remote and o
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
   exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   let s:didsplit= 1
   keepj call s:RestoreWinVars()
   keepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 1
   " remote and t
   let newdir  = s:NetrwBrowseChgDir(0,s:NetrwGetWord())
"   call Decho("tabnew")
   tabnew
   let s:didsplit= 1
   keepj call s:RestoreWinVars()
   keepj call s:NetrwBrowse(0,newdir)
   unlet s:didsplit

  elseif a:mode == 2
   " remote and v
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v")
   exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
   let s:didsplit= 1
   keepj call s:RestoreWinVars()
   keepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 3
   " local and o
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
   exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   let s:didsplit= 1
   keepj call s:RestoreWinVars()
   keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 4
   " local and t
   let cursorword  = s:NetrwGetWord()
   let eikeep      = &ei
   let netrw_winnr = winnr()
   let netrw_line  = line(".")
   let netrw_col   = virtcol(".")
   keepj norm! H0
   let netrw_hline = line(".")
   setl ei=all
   exe "keepj norm! ".netrw_hline."G0z\<CR>"
   exe "keepj norm! ".netrw_line."G0".netrw_col."\<bar>"
   let &ei= eikeep
   let netrw_curdir= s:NetrwTreeDir()
"   call Decho("tabnew")
   tabnew
   let b:netrw_curdir = netrw_curdir
   let s:didsplit     = 1
   keepj call s:RestoreWinVars()
   keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,cursorword))
   if &ft == "netrw"
    setl ei=all
    exe "keepj norm! ".netrw_hline."G0z\<CR>"
    exe "keepj norm! ".netrw_line."G0".netrw_col."\<bar>"
    let &ei= eikeep
   endif
   unlet s:didsplit

  elseif a:mode == 5
   " local and v
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v")
   exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
   let s:didsplit= 1
   keepj call s:RestoreWinVars()
   keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   unlet s:didsplit

  else
   keepj call netrw#ErrorMsg(s:ERROR,"(NetrwSplit) unsupported mode=".a:mode,45)
  endif

  let @@= ykeep
"  call Dret("s:NetrwSplit")
endfun

" ---------------------------------------------------------------------
" s:NetrwTgtMenu: {{{2
fun! s:NetrwTgtMenu()
  if !exists("s:netrw_menucnt")
   return
  endif
"  call Dfunc("s:NetrwTgtMenu()")

  " the following test assures that gvim is running, has menus available, and has menus enabled.
  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   if exists("g:NetrwTopLvlMenu")
"    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)")
    exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Targets'
   endif
   if !exists("s:netrw_initbookhist")
    call s:NetrwBookHistRead()
   endif

   " target bookmarked places
   if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
"    call Decho("installing bookmarks as easy targets")
    let cnt= 1
    for bmd in g:netrw_bookmarklist
     let ebmd= escape(bmd,g:netrw_menu_escape)
     " show bookmarks for goto menu
"     call Decho("menu: Targets: ".bmd)
     exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#MakeTgt('".bmd."')\<cr>"
     let cnt= cnt + 1
    endfor
   endif

   " target directory browsing history
   if exists("g:netrw_dirhistmax") && g:netrw_dirhistmax > 0
"    call Decho("installing history as easy targets (histmax=".g:netrw_dirhistmax.")")
    let histcnt = 1
    while histcnt <= g:netrw_dirhistmax
     let priority = g:netrw_dirhist_cnt + histcnt
     if exists("g:netrw_dirhist_{histcnt}")
      let histentry  = g:netrw_dirhist_{histcnt}
      let ehistentry = escape(histentry,g:netrw_menu_escape)
"      call Decho("menu: Targets: ".histentry)
      exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#MakeTgt('".histentry."')\<cr>"
     endif
     let histcnt = histcnt + 1
    endwhile
   endif
  endif
"  call Dret("s:NetrwTgtMenu")
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeDir: determine tree directory given current cursor position {{{2
" (full path directory with trailing slash returned)
fun! s:NetrwTreeDir()
"  call Dfunc("s:NetrwTreeDir() getline(".line(".").")"."<".getline('.')."> b:netrw_curdir<".b:netrw_curdir."> tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft)

  if exists("s:treedir")
   " s:NetrwPrevWinOpen opens a "previous" window -- and thus needs to and does call s:NetrwTreeDir early
   let treedir= s:treedir
   unlet s:treedir
"   call Dret("s:NetrwTreeDir ".treedir)
   return treedir
  endif
  if !exists("b:netrw_curdir") || b:netrw_curdir == ""
   let b:netrw_curdir= getcwd()
  endif
  let treedir = b:netrw_curdir
"  call Decho("set initial treedir<".treedir.">")
  let s:treecurpos= netrw#SavePosn()

  if w:netrw_liststyle == s:TREELIST
"   call Decho("w:netrw_liststyle is TREELIST:")
"   call Decho("line#".line(".")." getline(.)<".getline('.')."> treecurpos<".string(s:treecurpos).">")

   " extract tree directory if on a line specifying a subdirectory (ie. ends with "/")
   if getline('.') =~ '/$'
"    call Decho("extract tree subdirectory from current line")
    let treedir= substitute(getline('.'),'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
"    call Decho("treedir<".treedir.">")
   else
"    call Decho("do not extract tree subdirectory from current line and set treedir to empty")
    let treedir= ""
   endif

   " detect user attempting to close treeroot
"   call Decho("win#".winnr()." buf#".bufnr("%")."<".bufname("%").">")
"   call Decho("getline(".line(".").")<".getline('.').'> '.((getline('.') =~ '^'.s:treedepthstring)? '=~' : '!~').' ^'.s:treedepthstring)
   if getline('.') !~ '^'.s:treedepthstring && getline('.') != '..'
"    call Decho("user may have attempted to close treeroot")
    " now force a refresh
"    call Decho("clear buffer<".expand("%")."> with :%d")
    sil! keepj %d
"    call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".string(s:treecurpos).">")
    return b:netrw_curdir
"   else " Decho
"    call Decho("user did not attempt to close treeroot")
   endif

   let treedir = s:NetrwTreePath(w:netrw_treetop)
  endif

  " sanity maintenance: keep those //s away...
  let treedir= substitute(treedir,'//$','/','')

"  call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".string(s:treecurpos).">")
  return treedir
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeDisplay: recursive tree display {{{2
fun! s:NetrwTreeDisplay(dir,depth)
"  call Dfunc("NetrwTreeDisplay(dir<".a:dir."> depth<".a:depth.">)")

  " insure that there are no folds
  setl nofen

  " install ../ and shortdir
  if a:depth == ""
   call setline(line("$")+1,'../')
"   call Decho("setline#".line("$")." ../ (depth is zero)")
  endif
  if a:dir =~ '^\a\+://'
   if a:dir == w:netrw_treetop
    let shortdir= a:dir
   else
    let shortdir= substitute(a:dir,'^.*/\([^/]\+\)/$','\1/','e')
   endif
   call setline(line("$")+1,a:depth.shortdir)
  else
   let shortdir= substitute(a:dir,'^.*/','','e')
   call setline(line("$")+1,a:depth.shortdir.'/')
  endif
"  call Decho("setline#".line("$")." shortdir<".a:depth.shortdir.">")

  " append a / to dir if its missing one
  let dir= a:dir
  if dir !~ '/$'
   let dir= dir.'/'
  endif

  " display subtrees (if any)
  let depth= s:treedepthstring.a:depth

"  call Decho("display subtrees with depth<".depth."> and current leaves")
  for entry in w:netrw_treedict[a:dir]
   let direntry= substitute(dir.entry,'/$','','e')
"   call Decho("dir<".dir."> entry<".entry."> direntry<".direntry.">")
   if entry =~ '/$' && has_key(w:netrw_treedict,direntry)
"    call Decho("<".direntry."> is a key in treedict - display subtree for it")
    keepj call s:NetrwTreeDisplay(direntry,depth)
   elseif entry =~ '/$' && has_key(w:netrw_treedict,direntry.'/')
"    call Decho("<".direntry."/> is a key in treedict - display subtree for it")
    keepj call s:NetrwTreeDisplay(direntry.'/',depth)
   else
"    call Decho("<".entry."> is not a key in treedict (no subtree)")
    sil! keepj call setline(line("$")+1,depth.entry)
   endif
  endfor

"  call Dret("NetrwTreeDisplay")
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeListing: displays tree listing from treetop on down, using NetrwTreeDisplay() {{{2
fun! s:NetrwTreeListing(dirname)
  if w:netrw_liststyle == s:TREELIST
"   call Dfunc("NetrwTreeListing() bufname<".expand("%").">")
"   call Decho("curdir<".a:dirname.">")
"   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exist")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"))
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

   " update the treetop
"   call Decho("update the treetop")
   if !exists("w:netrw_treetop")
    let w:netrw_treetop= a:dirname
"    call Decho("w:netrw_treetop<".w:netrw_treetop."> (reusing)")
   elseif (w:netrw_treetop =~ ('^'.a:dirname) && s:Strlen(a:dirname) < s:Strlen(w:netrw_treetop)) || a:dirname !~ ('^'.w:netrw_treetop)
    let w:netrw_treetop= a:dirname
"    call Decho("w:netrw_treetop<".w:netrw_treetop."> (went up)")
   endif

   " insure that we have at least an empty treedict
   if !exists("w:netrw_treedict")
    let w:netrw_treedict= {}
   endif

   " update the directory listing for the current directory
"   call Decho("updating dictionary with ".a:dirname.":[..directory listing..]")
"   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." line($)=".line("$"))
   exe "sil! keepj ".w:netrw_bannercnt.',$g@^\.\.\=/$@d'
   let w:netrw_treedict[a:dirname]= getline(w:netrw_bannercnt,line("$"))
"   call Decho("w:treedict[".a:dirname."]= ".string(w:netrw_treedict[a:dirname]))
   exe "sil! keepj ".w:netrw_bannercnt.",$d"

   " if past banner, record word
   if exists("w:netrw_bannercnt") && line(".") > w:netrw_bannercnt
    let fname= expand("<cword>")
   else
    let fname= ""
   endif
"   call Decho("fname<".fname.">")
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

   " display from treetop on down
   keepj call s:NetrwTreeDisplay(w:netrw_treetop,"")
"   call Decho("s:NetrwTreeDisplay) setl noma nomod ro")

   " remove any blank line remaining as line#1 (happens in treelisting mode with banner suppressed)
   while getline(1) =~ '^\s*$' && byte2line(1) > 0
"    call Decho("deleting blank line")
    1d
   endwhile

   exe "setl ".g:netrw_bufsettings

"   call Dret("NetrwTreeListing : bufname<".expand("%").">")
   return
  endif
endfun

" ---------------------------------------------------------------------
" s:NetrwTreePath: returns path to current file in tree listing {{{2
"                  Normally, treetop is w:netrw_treetop, but a
"                  user of the function ( netrw#SetTreetop() )
"                  wipes that out prior to calling this function
fun! s:NetrwTreePath(treetop)
"  call Dfunc("s:NetrwTreePath() line#".line(".")."<".getline(".").">")
  let depth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
"  call Decho("(s:NetrwTreePath) depth<".depth."> 1st subst")
  let depth = substitute(depth,'^'.s:treedepthstring,'','')
"  call Decho("(s:NetrwTreePath) depth<".depth."> 2nd subst (first depth removed)")
  if getline('.') =~ '/$'
"   call Decho("extract tree directory from current line")
   let treedir= substitute(getline('.'),'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
"   call Decho("(s:NetrwTreePath) treedir<".treedir.">")
  else
"   call Decho("(s:NetrwTreePath) do not extract tree directory from current line and set treedir to empty")
   let treedir= ""
  endif
  " construct treedir by searching backwards at correct depth
"  call Decho("(s:NetrwTreePath) construct treedir by searching backwards for correct depth")
"  call Decho("(s:NetrwTreePath) initial      treedir<".treedir."> depth<".depth.">")
  while depth != "" && search('^'.depth.'[^'.s:treedepthstring.'].\{-}/$','bW')
   let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
   let treedir= dirname.treedir
   let depth  = substitute(depth,'^'.s:treedepthstring,'','')
"   call Decho("(s:NetrwTreePath) constructing treedir<".treedir.">: dirname<".dirname."> while depth<".depth.">")
  endwhile
  if a:treetop =~ '/$'
   let treedir= a:treetop.treedir
  else
   let treedir= a:treetop.'/'.treedir
  endif
  let treedir= substitute(treedir,'//$','/','')
"  call Dret("s:NetrwTreePath <".treedir.">")
  return treedir
endfun

" ---------------------------------------------------------------------
" s:NetrwWideListing: {{{2
fun! s:NetrwWideListing()

  if w:netrw_liststyle == s:WIDELIST
"   call Dfunc("NetrwWideListing() w:netrw_liststyle=".w:netrw_liststyle.' fo='.&fo.' l:fo='.&l:fo)
   " look for longest filename (cpf=characters per filename)
   " cpf: characters per filename
   " fpl: filenames per line
   " fpc: filenames per column
   setl ma noro
"   call Decho("setl ma noro")
   let b:netrw_cpf= 0
   if line("$") >= w:netrw_bannercnt
    exe 'sil keepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
    keepj call histdel("/",-1)
   else
"    call Dret("NetrwWideListing")
    return
   endif
   let b:netrw_cpf= b:netrw_cpf + 2
"   call Decho("b:netrw_cpf=max_filename_length+2=".b:netrw_cpf)

   " determine qty files per line (fpl)
   let w:netrw_fpl= winwidth(0)/b:netrw_cpf
   if w:netrw_fpl <= 0
    let w:netrw_fpl= 1
   endif
"   call Decho("fpl= [winwidth=".winwidth(0)."]/[b:netrw_cpf=".b:netrw_cpf.']='.w:netrw_fpl)

   " make wide display
   exe 'sil keepj '.w:netrw_bannercnt.',$s/^.*$/\=escape(printf("%-'.b:netrw_cpf.'s",submatch(0)),"\\")/'
   keepj call histdel("/",-1)
   let fpc         = (line("$") - w:netrw_bannercnt + w:netrw_fpl)/w:netrw_fpl
   let newcolstart = w:netrw_bannercnt + fpc
   let newcolend   = newcolstart + fpc - 1
"   call Decho("bannercnt=".w:netrw_bannercnt." fpl=".w:netrw_fpl." fpc=".fpc." newcol[".newcolstart.",".newcolend."]")
   if has("clipboard")
    sil! let keepregstar = @*
   endif
   while line("$") >= newcolstart
    if newcolend > line("$") | let newcolend= line("$") | endif
    let newcolqty= newcolend - newcolstart
    exe newcolstart
    if newcolqty == 0
     exe "sil! keepj norm! 0\<c-v>$hx".w:netrw_bannercnt."G$p"
    else
     exe "sil! keepj norm! 0\<c-v>".newcolqty.'j$hx'.w:netrw_bannercnt.'G$p'
    endif
    exe "sil! keepj ".newcolstart.','.newcolend.'d'
    exe 'sil! keepj '.w:netrw_bannercnt
   endwhile
   if has("clipboard")
    sil! let @*= keepregstar
   endif
   exe "sil! keepj ".w:netrw_bannercnt.',$s/\s\+$//e'
   keepj call histdel("/",-1)
   exe "nmap <buffer> <silent> w	/^\\\\|\\s\\s\\zs\\S/\<cr>"
   exe "nmap <buffer> <silent> b	?^\\\\|\\s\\s\\zs\\S?\<cr>"
"   call Decho("NetrwWideListing) setl noma nomod ro")
   exe "setl ".g:netrw_bufsettings
"   call Decho("(NetrwWideListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"   call Dret("NetrwWideListing")
   return
  else
   if hasmapto("w","n")
    sil! nunmap <buffer> w
   endif
   if hasmapto("b","n")
    sil! nunmap <buffer> b
   endif
  endif

endfun

" ---------------------------------------------------------------------
" s:PerformListing: {{{2
fun! s:PerformListing(islocal)
"  call Dfunc("s:PerformListing(islocal=".a:islocal.") bufnr(%)=".bufnr("%")."<".bufname("%").">")
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (enter)")

  " set up syntax highlighting {{{3
"  call Decho("set up syntax highlighting")
  if has("syntax")
   if !exists("g:syntax_on") || !g:syntax_on
"    call Decho("but g:syntax_on".(exists("g:syntax_on")? "=".g:syntax_on : "<doesn't exist>"))
    setl ft=
   elseif &ft != "netrw"
"    call Decho("setl ft=netrw")
    setl ft=netrw
   endif
  endif

  keepj call s:NetrwSafeOptions()
  setl noro ma
"  call Decho("setl noro ma bh=".&bh)

"  if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1	" Decho
"   call Decho("(netrw) Processing your browsing request...")
"  endif								" Decho

"  call Decho('w:netrw_liststyle='.(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'))
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " force a refresh for tree listings
"   call Decho("force refresh for treelisting: clear buffer<".expand("%")."> with :%d")
   sil! keepj %d
  endif

  " save current directory on directory history list
  keepj call s:NetrwBookHistHandler(3,b:netrw_curdir)

  " Set up the banner {{{3
  if g:netrw_banner
"   call Decho("set up banner")
   keepj call setline(1,'" ============================================================================')
   keepj call setline(2,'" Netrw Directory Listing                                        (netrw '.g:loaded_netrw.')')
   if exists("g:netrw_bannerbackslash") && g:netrw_bannerbackslash
    keepj call setline(3,'"   '.substitute(b:netrw_curdir,'/','\\','g'))
   else
    keepj call setline(3,'"   '.b:netrw_curdir)
   endif
   let w:netrw_bannercnt= 3
   keepj exe "sil! keepj ".w:netrw_bannercnt
  else
   keepj 1
   let w:netrw_bannercnt= 1
  endif
"  call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." win#".winnr())

  let sortby= g:netrw_sort_by
  if g:netrw_sort_direction =~ "^r"
   let sortby= sortby." reversed"
  endif

  " Sorted by... {{{3
  if g:netrw_banner
"   call Decho("handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">")
   if g:netrw_sort_by =~ "^n"
"   call Decho("directories will be sorted by name")
    " sorted by name
    keepj put ='\"   Sorted by      '.sortby
    keepj put ='\"   Sort sequence: '.g:netrw_sort_sequence
    let w:netrw_bannercnt= w:netrw_bannercnt + 2
   else
"   call Decho("directories will be sorted by size or time")
    " sorted by size or date
    keepj put ='\"   Sorted by '.sortby
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   endif
   exe "sil! keepj ".w:netrw_bannercnt
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
  endif

  " show copy/move target, if any
  if g:netrw_banner
   if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal")
"    call Decho("show copy/move target<".s:netrwmftgt.">")
    keepj put =''
    if s:netrwmftgt_islocal
     sil! keepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (local)')
    else
     sil! keepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (remote)')
    endif
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   else
"    call Decho("s:netrwmftgt does not exist, don't make Copy/Move Tgt")
   endif
   exe "sil! keepj ".w:netrw_bannercnt
  endif

  " Hiding...  -or-  Showing... {{{3
  if g:netrw_banner
"   call Decho("handle hiding/showing (g:netrw_hide=".g:netrw_list_hide." g:netrw_list_hide<".g:netrw_list_hide.">)")
   if g:netrw_list_hide != "" && g:netrw_hide
    if g:netrw_hide == 1
     keepj put ='\"   Hiding:        '.g:netrw_list_hide
    else
     keepj put ='\"   Showing:       '.g:netrw_list_hide
    endif
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   endif
   exe "keepjumps ".w:netrw_bannercnt

"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
   let quickhelp   = g:netrw_quickhelp%len(s:QuickHelp)
"   call Decho("quickhelp   =".quickhelp)
   keepj put ='\"   Quick Help: <F1>:help  '.s:QuickHelp[quickhelp]
"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
   keepj put ='\" =============================================================================='
   let w:netrw_bannercnt= w:netrw_bannercnt + 2
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
  endif

  " bannercnt should index the line just after the banner
  if g:netrw_banner
   let w:netrw_bannercnt= w:netrw_bannercnt + 1
   exe "sil! keepj ".w:netrw_bannercnt
"   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"))
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
  endif

  " get list of files
"  call Decho("Get list of files - islocal=".a:islocal)
  if a:islocal
   keepj call s:LocalListing()
  else " remote
   keepj let badresult= s:NetrwRemoteListing()
   if badresult
"    call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." win#".winnr()." buf#".bufnr("%")."<".bufname("%").">")
"    call Dret("s:PerformListing : error detected by NetrwRemoteListing")
    return
   endif
  endif

  " manipulate the directory listing (hide, sort) {{{3
  if !exists("w:netrw_bannercnt")
   let w:netrw_bannercnt= 0
  endif
"  call Decho("g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)")
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

  if !g:netrw_banner || line("$") >= w:netrw_bannercnt
"   call Decho("manipulate directory listing (hide)")
"   call Decho("g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
   if g:netrw_hide && g:netrw_list_hide != ""
    keepj call s:NetrwListHide()
   endif
   if !g:netrw_banner || line("$") >= w:netrw_bannercnt
"    call Decho("manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">")

    if g:netrw_sort_by =~ "^n"
     " sort by name
     keepj call s:NetrwSetSort()

     if !g:netrw_banner || w:netrw_bannercnt < line("$")
"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")")
      if g:netrw_sort_direction =~ 'n'
       " normal direction sorting
       exe 'sil keepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
      else
       " reverse direction sorting
       exe 'sil keepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
      endif
     endif
     " remove priority pattern prefix
"     call Decho("remove priority pattern prefix")
     exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{3}'.g:netrw_sepchr.'//e'
     keepj call histdel("/",-1)

    elseif a:islocal
     if !g:netrw_banner || w:netrw_bannercnt < line("$")
"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction)
      if g:netrw_sort_direction =~ 'n'
"       call Decho('exe sil keepjumps '.w:netrw_bannercnt.',$sort')
       exe 'sil! keepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
      else
"       call Decho('exe sil keepjumps '.w:netrw_bannercnt.',$sort!')
       exe 'sil! keepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
      endif
     exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{-}\///e'
     keepj call histdel("/",-1)
     endif
    endif

   elseif g:netrw_sort_direction =~ 'r'
"    call Decho('(s:PerformListing) reverse the sorted listing')
    if !g:netrw_banner || w:netrw_bannercnt < line('$')
     exe 'sil! keepj '.w:netrw_bannercnt.',$g/^/m '.w:netrw_bannercnt
     call histdel("/",-1)
    endif
   endif
  endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

  " convert to wide/tree listing {{{3
"  call Decho("modify display if wide/tree listing style")
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#1)")
  keepj call s:NetrwWideListing()
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#2)")
  keepj call s:NetrwTreeListing(b:netrw_curdir)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#3)")

  if exists("w:netrw_bannercnt") && (line("$") > w:netrw_bannercnt || !g:netrw_banner)
   " place cursor on the top-left corner of the file listing
"   call Decho("place cursor on top-left corner of file listing")
   exe 'sil! keepj '.w:netrw_bannercnt
   sil! keepj norm! 0
  endif

  " record previous current directory
  let w:netrw_prvdir= b:netrw_curdir
"  call Decho("record netrw_prvdir<".w:netrw_prvdir.">")

  " save certain window-oriented variables into buffer-oriented variables {{{3
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#4)")
  keepj call s:SetBufWinVars()
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#5)")
  keepj call s:NetrwOptionRestore("w:")
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#6)")

  " set display to netrw display settings
"  call Decho("set display to netrw display settings (".g:netrw_bufsettings.")")
  exe "setl ".g:netrw_bufsettings
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#7)")
  if g:netrw_liststyle == s:LONGLIST
"   call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1))
   exe "setl ts=".(g:netrw_maxfilenamelen+1)
  endif

  if exists("s:treecurpos")
"   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#8)")
   keepj call netrw#RestorePosn(s:treecurpos)
   unlet s:treecurpos
  endif

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (return)")
"  call Dret("s:PerformListing : curpos<".string(getpos(".")).">")
endfun

" ---------------------------------------------------------------------
" s:SetupNetrwStatusLine: {{{2
fun! s:SetupNetrwStatusLine(statline)
"  call Dfunc("SetupNetrwStatusLine(statline<".a:statline.">)")

  if !exists("s:netrw_setup_statline")
   let s:netrw_setup_statline= 1
"   call Decho("do first-time status line setup")

   if !exists("s:netrw_users_stl")
    let s:netrw_users_stl= &stl
   endif
   if !exists("s:netrw_users_ls")
    let s:netrw_users_ls= &laststatus
   endif

   " set up User9 highlighting as needed
   let keepa= @a
   redir @a
   try
    hi User9
   catch /^Vim\%((\a\+)\)\=:E411/
    if &bg == "dark"
     hi User9 ctermfg=yellow ctermbg=blue guifg=yellow guibg=blue
    else
     hi User9 ctermbg=yellow ctermfg=blue guibg=yellow guifg=blue
    endif
   endtry
   redir END
   let @a= keepa
  endif

  " set up status line (may use User9 highlighting)
  " insure that windows have a statusline
  " make sure statusline is displayed
  let &stl=a:statline
  setl laststatus=2
"  call Decho("stl=".&stl)
  redraw

"  call Dret("SetupNetrwStatusLine : stl=".&stl)
endfun

" ---------------------------------------------------------------------
"  Remote Directory Browsing Support:    {{{1
" ===========================================

" ---------------------------------------------------------------------
" s:NetrwRemoteFtpCmd: unfortunately, not all ftp servers honor options for ls {{{2
"  This function assumes that a long listing will be received.  Size, time,
"  and reverse sorts will be requested of the server but not otherwise
"  enforced here.
fun! s:NetrwRemoteFtpCmd(path,listcmd)
"  call Dfunc("NetrwRemoteFtpCmd(path<".a:path."> listcmd<".a:listcmd.">) w:netrw_method=".(exists("w:netrw_method")? w:netrw_method : (exists("b:netrw_method")? b:netrw_method : "???")))
"  call Decho("line($)=".line("$")." w:netrw_bannercnt=".w:netrw_bannercnt)
  " sanity check: {{{3
  if !exists("w:netrw_method")
   if exists("b:netrw_method")
    let w:netrw_method= b:netrw_method
   else
    call netrw#ErrorMsg(2,"(s:NetrwRemoteFtpCmd) internal netrw error",93)
"    call Dret("NetrwRemoteFtpCmd")
    return
   endif
  endif

  " WinXX ftp uses unix style input, so set ff to unix	" {{{3
  let ffkeep= &ff
  setl ma ff=unix noro
"  call Decho("setl ma ff=unix noro")

  " clear off any older non-banner lines	" {{{3
  " note that w:netrw_bannercnt indexes the line after the banner
"  call Decho('exe sil! keepjumps '.w:netrw_bannercnt.",$d  (clear off old non-banner lines)")
  exe "sil! keepjumps ".w:netrw_bannercnt.",$d"

  ".........................................
  if w:netrw_method == 2 || w:netrw_method == 5	" {{{3
   " ftp + <.netrc>:  Method #2
   if a:path != ""
    keepj put ='cd \"'.a:path.'\"'
   endif
   if exists("g:netrw_ftpextracmd")
    keepj put =g:netrw_ftpextracmd
"    call Decho("filter input: ".getline('.'))
   endif
   keepj call setline(line("$")+1,a:listcmd)
"   exe "keepjumps ".w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."))'
   if exists("g:netrw_port") && g:netrw_port != ""
"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
    exe s:netrw_silentxfer." keepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
   else
"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
    exe s:netrw_silentxfer." keepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
   endif

  ".........................................
  elseif w:netrw_method == 3	" {{{3
   " ftp + machine,id,passwd,filename:  Method #3
    setl ff=unix
    if exists("g:netrw_port") && g:netrw_port != ""
     keepj put ='open '.g:netrw_machine.' '.g:netrw_port
    else
     keepj put ='open '.g:netrw_machine
    endif

    " handle userid and password
    let host= substitute(g:netrw_machine,'\..*$','','')
"    call Decho("host<".host.">")
    if exists("s:netrw_hup") && exists("s:netrw_hup[host]")
     call NetUserPass("ftp:".host)
    endif
    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      keepj put =g:netrw_uid
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       keepj put ='\"'.s:netrw_passwd.'\"'
      endif
     elseif exists("s:netrw_passwd")
      keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
     endif
    endif

   if a:path != ""
    keepj put ='cd \"'.a:path.'\"'
   endif
   if exists("g:netrw_ftpextracmd")
    keepj put =g:netrw_ftpextracmd
"    call Decho("filter input: ".getline('.'))
   endif
   keepj call setline(line("$")+1,a:listcmd)

   " perform ftp:
   " -i       : turns off interactive prompting from ftp
   " -n  unix : DON'T use <.netrc>, even though it exists
   " -n  win32: quit being obnoxious about password
   if exists("w:netrw_bannercnt")
"    exe w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."))'
"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    exe s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
"   else " Decho
"    call Decho("WARNING: w:netrw_bannercnt doesn't exist!")
"    g/^./call Decho("SKIPPING ftp#".line(".").": ".getline(".")) " COMBAK
   endif

  ".........................................
  elseif w:netrw_method == 9	" {{{3
   " sftp username@machine: Method #9
   " s:netrw_sftp_cmd
   setl ff=unix

   " restore settings
   let &ff= ffkeep
"   call Dret("NetrwRemoteFtpCmd")
   return

  ".........................................
  else	" {{{3
   keepj call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . bufname("%") . ">",23)
  endif

  " cleanup for Windows " {{{3
  if has("win32") || has("win95") || has("win64") || has("win16")
   sil! keepj %s/\r$//e
   keepj call histdel("/",-1)
  endif
  if a:listcmd == "dir"
   " infer directory/link based on the file permission string
   sil! keepj g/d\%([-r][-w][-x]\)\{3}/keepj s@$@/@e
   sil! keepj g/l\%([-r][-w][-x]\)\{3}/keepj s/$/@/e
   keepj call histdel("/",-1)
   keepj call histdel("/",-1)
   if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || w:netrw_liststyle == s:TREELIST
    exe "sil! keepj ".w:netrw_bannercnt.',$s/^\%(\S\+\s\+\)\{8}//e'
    keepj call histdel("/",-1)
   endif
  endif

  " ftp's listing doesn't seem to include ./ or ../ " {{{3
  if !search('^\.\/$\|\s\.\/$','wn')
   exe 'keepj '.w:netrw_bannercnt
   keepj put ='./'
  endif
  if !search('^\.\.\/$\|\s\.\.\/$','wn')
   exe 'keepj '.w:netrw_bannercnt
   keepj put ='../'
  endif

  " restore settings " {{{3
  let &ff= ffkeep
"  call Dret("NetrwRemoteFtpCmd")
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteListing: {{{2
fun! s:NetrwRemoteListing()
"  call Dfunc("s:NetrwRemoteListing() b:netrw_curdir<".b:netrw_curdir.">)")

  if !exists("w:netrw_bannercnt") && exists("s:bannercnt")
   let w:netrw_bannercnt= s:bannercnt
  endif
  if !exists("w:netrw_bannercnt") && exists("b:bannercnt")
   let w:netrw_bannercnt= s:bannercnt
  endif

  call s:RemotePathAnalysis(b:netrw_curdir)

  " sanity check:
  if exists("b:netrw_method") && b:netrw_method =~ '[235]'
"   call Decho("b:netrw_method=".b:netrw_method)
   if !executable("ftp")
"    call Decho("ftp is not executable")
    if !exists("g:netrw_quiet")
     call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ftp",18)
    endif
    call s:NetrwOptionRestore("w:")
"    call Dret("s:NetrwRemoteListing -1")
    return -1
   endif

  elseif !exists("g:netrw_list_cmd") || g:netrw_list_cmd == ''
"   call Decho("g:netrw_list_cmd<",(exists("g:netrw_list_cmd")? 'n/a' : "-empty-").">")
   if !exists("g:netrw_quiet")
    if g:netrw_list_cmd == ""
     keepj call netrw#ErrorMsg(s:ERROR,"your g:netrw_list_cmd is empty; perhaps ".g:netrw_ssh_cmd." is not executable on your system",47)
    else
     keepj call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ".g:netrw_list_cmd,19)
    endif
   endif

   keepj call s:NetrwOptionRestore("w:")
"   call Dret("s:NetrwRemoteListing -1")
   return -1
  endif  " (remote handling sanity check)
"  call Decho("passed remote listing sanity checks")

  if exists("b:netrw_method")
"   call Decho("setting w:netrw_method to b:netrw_method<".b:netrw_method.">")
   let w:netrw_method= b:netrw_method
  endif

  if s:method == "ftp"
   " use ftp to get remote file listing {{{3
"   call Decho("use ftp to get remote file listing")
   let s:method  = "ftp"
   let listcmd = g:netrw_ftp_list_cmd
   if g:netrw_sort_by =~ '^t'
    let listcmd= g:netrw_ftp_timelist_cmd
   elseif g:netrw_sort_by =~ '^s'
    let listcmd= g:netrw_ftp_sizelist_cmd
   endif
"   call Decho("listcmd<".listcmd."> (using g:netrw_ftp_list_cmd)")
   call s:NetrwRemoteFtpCmd(s:path,listcmd)
"   exe "sil! keepalt keepj ".w:netrw_bannercnt.',$g/^./call Decho("raw listing: ".getline("."))'

   " report on missing file or directory messages
   if search('[Nn]o such file or directory\|Failed to change directory')
    let mesg= getline(".")
    if exists("w:netrw_bannercnt")
     setl ma
     exe w:netrw_bannercnt.",$d"
     setl noma
    endif
    keepj call s:NetrwOptionRestore("w:")
    call netrw#ErrorMsg(s:WARNING,mesg,96)
"    call Dret("s:NetrwRemoteListing : -1")
    return -1
   endif

   if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || w:netrw_liststyle == s:TREELIST
    " shorten the listing
"    call Decho("generate short listing")
    exe "sil! keepalt keepj ".w:netrw_bannercnt

    " cleanup
    if g:netrw_ftp_browse_reject != ""
     exe "sil! keepalt keepj g/".g:netrw_ftp_browse_reject."/keepj d"
     keepj call histdel("/",-1)
    endif
    sil! keepj %s/\r$//e
    keepj call histdel("/",-1)

    " if there's no ../ listed, then put ../ in
    let line1= line(".")
    exe "sil! keepj ".w:netrw_bannercnt
    let line2= search('\.\.\/\%(\s\|$\)','cnW')
"    call Decho("search(".'\.\.\/\%(\s\|$\)'."','cnW')=".line2."  w:netrw_bannercnt=".w:netrw_bannercnt)
    if line2 == 0
"     call Decho("netrw is putting ../ into listing")
     sil! keepj put='../'
    endif
    exe "sil! keepj ".line1
    sil! keepj norm! 0

"    call Decho("line1=".line1." line2=".line2." line(.)=".line("."))
    if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
"     call Decho("M$ ftp cleanup")
     exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+//'
     keepj call histdel("/",-1)
    else " normal ftp cleanup
"     call Decho("normal ftp cleanup")
     exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2/e'
     exe "sil! keepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*/$#/#e'
     exe "sil! keepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*$#/#e'
     keepj call histdel("/",-1)
     keepj call histdel("/",-1)
     keepj call histdel("/",-1)
    endif
   endif

   else
   " use ssh to get remote file listing {{{3
"   call Decho("use ssh to get remote file listing: s:path<".s:path.">")
   let listcmd= s:MakeSshCmd(g:netrw_list_cmd)
"   call Decho("listcmd<".listcmd."> (using g:netrw_list_cmd)")
   if g:netrw_scp_cmd =~ '^pscp'
"    call Decho("1: exe sil r! ".shellescape(listcmd.s:path, 1))
    exe "sil! keepj r! ".listcmd.shellescape(s:path, 1)
    " remove rubbish and adjust listing format of 'pscp' to 'ssh ls -FLa' like
    sil! keepj g/^Listing directory/keepj d
    sil! keepj g/^d[-rwx][-rwx][-rwx]/keepj s+$+/+e
    sil! keepj g/^l[-rwx][-rwx][-rwx]/keepj s+$+@+e
    keepj call histdel("/",-1)
    keepj call histdel("/",-1)
    keepj call histdel("/",-1)
    if g:netrw_liststyle != s:LONGLIST
     sil! keepj g/^[dlsp-][-rwx][-rwx][-rwx]/keepj s/^.*\s\(\S\+\)$/\1/e
     keepj call histdel("/",-1)
    endif
   else
    if s:path == ""
"     call Decho("2: exe sil r! ".listcmd)
     exe "sil! keepj keepalt r! ".listcmd
    else
"     call Decho("3: exe sil r! ".listcmd.' '.shellescape(fnameescape(s:path),1))
     exe "sil! keepj keepalt r! ".listcmd.' '.shellescape(fnameescape(s:path),1)
"     call Decho("listcmd<".listcmd."> path<".s:path.">")
    endif
   endif

   " cleanup
   if g:netrw_ssh_browse_reject != ""
"    call Decho("cleanup: exe sil! g/".g:netrw_ssh_browse_reject."/keepjumps d")
    exe "sil! g/".g:netrw_ssh_browse_reject."/keepj d"
    keepj call histdel("/",-1)
   endif
  endif

  if w:netrw_liststyle == s:LONGLIST
   " do a long listing; these substitutions need to be done prior to sorting {{{3
"   call Decho("fix long listing:")

   if s:method == "ftp"
    " cleanup
    exe "sil! keepj ".w:netrw_bannercnt
    while getline('.') =~ g:netrw_ftp_browse_reject
     sil! keepj d
    endwhile
    " if there's no ../ listed, then put ../ in
    let line1= line(".")
    sil! keepj 1
    sil! keepj call search('^\.\.\/\%(\s\|$\)','W')
    let line2= line(".")
    if line2 == 0
     if b:netrw_curdir != '/'
      exe 'sil! keepj '.w:netrw_bannercnt."put='../'"
     endif
    endif
    exe "sil! keepj ".line1
    sil! keepj norm! 0
   endif

   if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
"    call Decho("M$ ftp site listing cleanup")
    exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\(\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+\)\(\w.*\)$/\2\t\1/'
   elseif exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$")
"    call Decho("normal ftp site listing cleanup: bannercnt=".w:netrw_bannercnt." line($)=".line("$"))
    exe 'sil keepj '.w:netrw_bannercnt.',$s/ -> .*$//e'
    exe 'sil keepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2\t\1/e'
    exe 'sil keepj '.w:netrw_bannercnt
    keepj call histdel("/",-1)
    keepj call histdel("/",-1)
    keepj call histdel("/",-1)
   endif
  endif

"  if exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$") " Decho
"   exe "keepj ".w:netrw_bannercnt.',$g/^./call Decho("listing: ".getline("."))'
"  endif " Decho

"  call Dret("s:NetrwRemoteListing 0")
  return 0
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRm: remove/delete a remote file or directory {{{2
fun! s:NetrwRemoteRm(usrhost,path) range
"  call Dfunc("s:NetrwRemoteRm(usrhost<".a:usrhost."> path<".a:path.">) virtcol=".virtcol("."))
"  call Decho("firstline=".a:firstline." lastline=".a:lastline)
  let svpos= netrw#SavePosn()

  let all= 0
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   " remove all marked files
"   call Decho("remove all marked files with bufnr#".bufnr("%"))
   for fname in s:netrwmarkfilelist_{bufnr("%")}
    let ok= s:NetrwRemoteRmFile(a:path,fname,all)
    if ok =~ 'q\%[uit]'
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
   endfor
   call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)

  else
   " remove files specified by range
"   call Decho("remove files specified by range")

   " preparation for removing multiple files/directories
   let ctr= a:firstline

   " remove multiple files and directories
   while ctr <= a:lastline
    exe "keepj ".ctr
    let ok= s:NetrwRemoteRmFile(a:path,s:NetrwGetWord(),all)
    if ok =~ 'q\%[uit]'
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
    let ctr= ctr + 1
   endwhile
  endif

  " refresh the (remote) directory listing
"  call Decho("refresh remote directory listing")
  keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
  keepj call netrw#RestorePosn(svpos)

"  call Dret("s:NetrwRemoteRm")
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRmFile: {{{2
fun! s:NetrwRemoteRmFile(path,rmfile,all)
"  call Dfunc("s:NetrwRemoteRmFile(path<".a:path."> rmfile<".a:rmfile.">) all=".a:all)

  let all= a:all
  let ok = ""

  if a:rmfile !~ '^"' && (a:rmfile =~ '@$' || a:rmfile !~ '[\/]$')
   " attempt to remove file
"    call Decho("attempt to remove file (all=".all.")")
   if !all
    echohl Statement
"    call Decho("case all=0:")
    call inputsave()
    let ok= input("Confirm deletion of file<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    echohl NONE
    if ok == ""
     let ok="no"
    endif
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~ 'y\%[es]' || ok == ""
"    call Decho("case all=".all." or ok<".ok.">".(exists("w:netrw_method")? ': netrw_method='.w:netrw_method : ""))
    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
"     call Decho("case ftp:")
     let path= a:path
     if path =~ '^\a\+://'
      let path= substitute(path,'^\a\+://[^/]\+/','','')
     endif
     sil! keepj .,$d
     call s:NetrwRemoteFtpCmd(path,"delete ".'"'.a:rmfile.'"')
    else
"     call Decho("case ssh: g:netrw_rm_cmd<".g:netrw_rm_cmd.">")
     let netrw_rm_cmd= s:MakeSshCmd(g:netrw_rm_cmd)
"     call Decho("netrw_rm_cmd<".netrw_rm_cmd.">")
     if !exists("b:netrw_curdir")
      keepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
      let ok="q"
     else
      let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
"      call Decho("netrw_rm_cmd<".netrw_rm_cmd.">")
"      call Decho("remotedir<".remotedir.">")
"      call Decho("rmfile<".a:rmfile.">")
      if remotedir != ""
       let netrw_rm_cmd= netrw_rm_cmd." ".shellescape(fnameescape(remotedir.a:rmfile))
      else
       let netrw_rm_cmd= netrw_rm_cmd." ".shellescape(fnameescape(a:rmfile))
      endif
"      call Decho("call system(".netrw_rm_cmd.")")
      let ret= system(netrw_rm_cmd)
      if ret != 0
       keepj call netrw#ErrorMsg(s:WARNING,"cmd<".netrw_rm_cmd."> failed",60)
      endif
"      call Decho("returned=".ret." errcode=".v:shell_error)
     endif
    endif
   elseif ok =~ 'q\%[uit]'
"    call Decho("ok==".ok)
   endif

  else
   " attempt to remove directory
"    call Decho("attempt to remove directory")
   if !all
    call inputsave()
    let ok= input("Confirm deletion of directory<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    if ok == ""
     let ok="no"
    endif
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~ 'y\%[es]' || ok == ""
    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     keepj call s:NetrwRemoteFtpCmd(a:path,"rmdir ".a:rmfile)
    else
     let rmfile          = substitute(a:path.a:rmfile,'/$','','')
     let netrw_rmdir_cmd = s:MakeSshCmd(netrw#WinPath(g:netrw_rmdir_cmd)).' '.shellescape(netrw#WinPath(rmfile))
"      call Decho("attempt to remove dir: system(".netrw_rmdir_cmd.")")
     let ret= system(netrw_rmdir_cmd)
"      call Decho("returned=".ret." errcode=".v:shell_error)

     if v:shell_error != 0
"      call Decho("v:shell_error not 0")
      let netrw_rmf_cmd= s:MakeSshCmd(netrw#WinPath(g:netrw_rmf_cmd)).' '.shellescape(netrw#WinPath(substitute(rmfile,'[\/]$','','e')))
"      call Decho("2nd attempt to remove dir: system(".netrw_rmf_cmd.")")
      let ret= system(netrw_rmf_cmd)
"      call Decho("returned=".ret." errcode=".v:shell_error)

      if v:shell_error != 0 && !exists("g:netrw_quiet")
      	keepj call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",22)
      endif
     endif
    endif

   elseif ok =~ 'q\%[uit]'
"    call Decho("ok==".ok)
   endif
  endif

"  call Dret("s:NetrwRemoteRmFile ".ok)
  return ok
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRename: rename a remote file or directory {{{2
fun! s:NetrwRemoteRename(usrhost,path) range
"  call Dfunc("NetrwRemoteRename(usrhost<".a:usrhost."> path<".a:path.">)")

  " preparation for removing multiple files/directories
  let svpos      = netrw#SavePosn()
  let ctr        = a:firstline
  let rename_cmd = s:MakeSshCmd(g:netrw_rename_cmd)

  " rename files given by the markfilelist
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   for oldname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("oldname<".oldname.">")
    if exists("subfrom")
     let newname= substitute(oldname,subfrom,subto,'')
"     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
    else
     call inputsave()
     let newname= input("Moving ".oldname." to : ",oldname)
     call inputrestore()
     if newname =~ '^s/'
      let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
      let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
      let newname = substitute(oldname,subfrom,subto,'')
"      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
     endif
    endif
   
    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     keepj call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
    else
     let oldname= shellescape(a:path.oldname)
     let newname= shellescape(a:path.newname)
"     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")")
     let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
    endif

   endfor
   call s:NetrwUnMarkFile(1)

  else

  " attempt to rename files/directories
   while ctr <= a:lastline
    exe "keepj ".ctr

    let oldname= s:NetrwGetWord()
"   call Decho("oldname<".oldname.">")

    call inputsave()
    let newname= input("Moving ".oldname." to : ",oldname)
    call inputrestore()

    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
    else
     let oldname= shellescape(a:path.oldname)
     let newname= shellescape(a:path.newname)
"     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")")
     let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
    endif

    let ctr= ctr + 1
   endwhile
  endif

  " refresh the directory
  keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
  keepj call netrw#RestorePosn(svpos)

"  call Dret("NetrwRemoteRename")
endfun

" ---------------------------------------------------------------------
"  Local Directory Browsing Support:    {{{1
" ==========================================

" ---------------------------------------------------------------------
" netrw#FileUrlRead: handles reading file://* files {{{2
"   Should accept:   file://localhost/etc/fstab
"                    file:///etc/fstab
"                    file:///c:/WINDOWS/clock.avi
"                    file:///c|/WINDOWS/clock.avi
"                    file://localhost/c:/WINDOWS/clock.avi
"                    file://localhost/c|/WINDOWS/clock.avi
"                    file://c:/foo.txt
"                    file:///c:/foo.txt
" and %XX (where X is [0-9a-fA-F] is converted into a character with the given hexadecimal value
fun! netrw#FileUrlRead(fname)
"  call Dfunc("netrw#FileUrlRead(fname<".a:fname.">)")
  let fname = a:fname
  if fname =~ '^file://localhost/'
"   call Decho('converting file://localhost/   -to-  file:///')
   let fname= substitute(fname,'^file://localhost/','file:///','')
"   call Decho("fname<".fname.">")
  endif
  if (has("win32") || has("win95") || has("win64") || has("win16"))
   if fname  =~ '^file:///\=\a[|:]/'
"    call Decho('converting file:///\a|/   -to-  file://\a:/')
    let fname = substitute(fname,'^file:///\=\(\a\)[|:]/','file://\1:/','')
"    call Decho("fname<".fname.">")
   endif
  endif
  let fname2396 = netrw#RFC2396(fname)
  let fname2396e= fnameescape(fname2396)
  let plainfname= substitute(fname2396,'file://\(.*\)','\1',"")
  if (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows exception for plainfname")
   if plainfname =~ '^/\+\a:'
"    call Decho('removing leading "/"s')
    let plainfname= substitute(plainfname,'^/\+\(\a:\)','\1','')
   endif
  endif
"  call Decho("fname2396<".fname2396.">")
"  call Decho("plainfname<".plainfname.">")
  exe "sil doau BufReadPre ".fname2396e
  exe 'keepj r '.plainfname
  exe 'sil! bdelete '.plainfname
  exe 'keepalt file! '.plainfname
  keepj 1d
"  call Decho("setl nomod")
  setl nomod
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"  call Dret("netrw#FileUrlRead")
  exe "sil doau BufReadPost ".fname2396e
endfun

" ---------------------------------------------------------------------
" netrw#LocalBrowseCheck: {{{2
fun! netrw#LocalBrowseCheck(dirname)
  " unfortunate interaction -- split window debugging can't be
  " used here, must use D-echoRemOn or D-echoTabOn -- the BufEnter
  " event triggers another call to LocalBrowseCheck() when attempts
  " to write to the DBG buffer are made.
  " The &ft == "netrw" test was installed because the BufEnter event
  " would hit when re-entering netrw windows, creating unexpected
  " refreshes (and would do so in the middle of NetrwSaveOptions(), too)
"  call Dfunc("netrw#LocalBrowseCheck(dirname<".a:dirname.">")
"  call Decho("isdir<".a:dirname.">=".isdirectory(a:dirname).((exists("s:treeforceredraw")? " treeforceredraw" : "")))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"  call Dredir("ls!","ls!")

  let ykeep= @@
  if isdirectory(a:dirname)
"   call Decho("is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse)
   let svposn= netrw#SavePosn()
   if &ft != "netrw" || (exists("b:netrw_curdir") && b:netrw_curdir != a:dirname) || g:netrw_fastbrowse <= 1
"    call Decho("case 1 : ft=".&ft)
    sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
    keepalt call netrw#RestorePosn(svposn)

   elseif &ft == "netrw" && line("$") == 1
"    call Decho("case 2 (ft≡netrw && line($)≡1)")
    sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
    keepalt call netrw#RestorePosn(svposn)

   elseif exists("s:treeforceredraw")
"    call Decho("case 3 (treeforceredraw)")
    unlet s:treeforceredraw
    sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
    keepalt call netrw#RestorePosn(svposn)
   endif

"   call Dret("netrw#LocalBrowseCheck")
   return
  endif

  " following code wipes out currently unused netrw buffers
  "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
  "   AND IF the listing style is not a tree listing
  if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
"   call Decho("wiping out currently unused netrw buffers")
   let ibuf    = 1
   let buflast = bufnr("$")
   while ibuf <= buflast
    if bufwinnr(ibuf) == -1 && isdirectory(bufname(ibuf))
     exe "sil! keepalt ".ibuf."bw!"
    endif
    let ibuf= ibuf + 1
   endwhile
  endif
  let @@= ykeep
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
  " not a directory, ignore it
"  call Dret("netrw#LocalBrowseCheck : not a directory, ignoring it; dirname<".a:dirname.">")
endfun

" ---------------------------------------------------------------------
" s:LocalBrowseRefresh: this function is called after a user has {{{2
" performed any shell command.  The idea is to cause all local-browsing
" buffers to be refreshed after a user has executed some shell command,
" on the chance that s/he removed/created a file/directory with it.
fun! s:LocalBrowseRefresh()
"  call Dfunc("s:LocalBrowseRefresh() tabpagenr($)=".tabpagenr("$"))
"  call Decho("s:netrw_browselist =".(exists("s:netrw_browselist")?  string(s:netrw_browselist)  : '<n/a>'))
"  call Decho("w:netrw_bannercnt  =".(exists("w:netrw_bannercnt")?   string(w:netrw_bannercnt)   : '<n/a>'))

  " determine which buffers currently reside in a tab
  if !exists("s:netrw_browselist")
"   call Dret("s:LocalBrowseRefresh : browselist is empty")
   return
  endif
  if !exists("w:netrw_bannercnt")
"   call Dret("s:LocalBrowseRefresh : don't refresh when focus not on netrw window")
   return
  endif
  if exists("s:netrw_events") && s:netrw_events == 1
   " s:LocalFastBrowser gets called (indirectly) from a
   let s:netrw_events= 2
"   call Dret("s:LocalBrowseRefresh : avoid initial double refresh")
   return
  endif
  let itab       = 1
  let buftablist = []
  let ykeep      = @@
  while itab <= tabpagenr("$")
   let buftablist = buftablist + tabpagebuflist()
   let itab       = itab + 1
   tabn
  endwhile
"  call Decho("buftablist".string(buftablist))
"  call Decho("s:netrw_browselist<".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "").">")
  "  GO through all buffers on netrw_browselist (ie. just local-netrw buffers):
  "   | refresh any netrw window
  "   | wipe out any non-displaying netrw buffer
  let curwin = winnr()
  let ibl    = 0
  for ibuf in s:netrw_browselist
"   call Decho("bufwinnr(".ibuf.") index(buftablist,".ibuf.")=".index(buftablist,ibuf))
   if bufwinnr(ibuf) == -1 && index(buftablist,ibuf) == -1
    " wipe out any non-displaying netrw buffer
"    call Decho("wiping  buf#".ibuf,"<".bufname(ibuf).">")
    exe "sil! bd ".fnameescape(ibuf)
    call remove(s:netrw_browselist,ibl)
"    call Decho("browselist=".string(s:netrw_browselist))
    continue
   elseif index(tabpagebuflist(),ibuf) != -1
    " refresh any netrw buffer
"    call Decho("refresh buf#".ibuf.'-> win#'.bufwinnr(ibuf))
    exe bufwinnr(ibuf)."wincmd w"
    if getline(".") =~ 'Quick Help'
     " decrement g:netrw_quickhelp to prevent refresh from changing g:netrw_quickhelp
     " (counteracts s:NetrwBrowseChgDir()'s incrementing)
     let g:netrw_quickhelp= g:netrw_quickhelp - 1
    endif
"    call Decho("#3: quickhelp=".g:netrw_quickhelp)
    keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
   endif
   let ibl= ibl + 1
  endfor
  exe curwin."wincmd w"
  let @@= ykeep

"  call Dret("s:LocalBrowseRefresh")
endfun

" ---------------------------------------------------------------------
" s:LocalFastBrowser: handles setting up/taking down fast browsing for the local browser {{{2
"
"     g:netrw_    Directory Is
"     fastbrowse  Local  Remote   
"  slow   0         D      D      D=Deleting a buffer implies it will not be re-used (slow)
"  med    1         D      H      H=Hiding a buffer implies it may be re-used        (fast)
"  fast   2         H      H      
"
"  Deleting a buffer means that it will be re-loaded when examined, hence "slow".
"  Hiding   a buffer means that it will be re-used   when examined, hence "fast".
"                       (re-using a buffer may not be as accurate)
"
"  s:netrw_events : doesn't exist, s:LocalFastBrowser() will install autocmds whena med or fast browsing
"                   =1: autocmds installed, but ignore next FocusGained event to avoid initial double-refresh of listing.
"                       BufEnter may be first event, then a FocusGained event.  Ignore the first FocusGained event.
"                       If :Explore used: it sets s:netrw_events to 2, so no FocusGained events are ignored.
"                   =2: autocmds installed (doesn't ignore any FocusGained events)
fun! s:LocalFastBrowser()
"  call Dfunc("LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse)
"  call Decho("s:netrw_events        ".(exists("s:netrw_events")? "exists"    : 'n/a'))
"  call Decho("autocmd: ShellCmdPost ".(exists("#ShellCmdPost")?  "installed" : "not installed"))
"  call Decho("autocmd: FocusGained  ".(exists("#FocusGained")?   "installed" : "not installed"))

  " initialize browselist, a list of buffer numbers that the local browser has used
  if !exists("s:netrw_browselist")
"   call Decho("initialize s:netrw_browselist")
   let s:netrw_browselist= []
  endif

  " append current buffer to fastbrowse list
  if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
"   call Decho("appendng current buffer to browselist")
   call add(s:netrw_browselist,bufnr("%"))
"   call Decho("browselist=".string(s:netrw_browselist))
  endif

  " enable autocmd events to handle refreshing/removing local browser buffers
  "    If local browse buffer is currently showing: refresh it
  "    If local browse buffer is currently hidden : wipe it
  "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
  "                      =1 : medium speed, re-use directory listing for remote only
  "                      =2 : fast   speed, always re-use directory listing when possible
  if g:netrw_fastbrowse <= 1 && !exists("#ShellCmdPost") && !exists("s:netrw_events")
   let s:netrw_events= 1
   augroup AuNetrwEvent
    au!
    if (has("win32") || has("win95") || has("win64") || has("win16"))
"     call Decho("installing autocmd: ShellCmdPost")
     au ShellCmdPost			*	call s:LocalBrowseRefresh()
    else
"     call Decho("installing autocmds: ShellCmdPost FocusGained")
     au ShellCmdPost,FocusGained	*	call s:LocalBrowseRefresh()
    endif
   augroup END

  " user must have changed fastbrowse to its fast setting, so remove
  " the associated autocmd events
  elseif g:netrw_fastbrowse > 1 && exists("#ShellCmdPost") && exists("s:netrw_events")
"   call Decho("remove AuNetrwEvent autcmd group")
   unlet s:netrw_events
   augroup AuNetrwEvent
    au!
   augroup END
   augroup! AuNetrwEvent
  endif

"  call Dret("LocalFastBrowser : browselist<".string(s:netrw_browselist).">")
endfun

" ---------------------------------------------------------------------
"  s:LocalListing: does the job of "ls" for local directories {{{2
fun! s:LocalListing()
"  call Dfunc("s:LocalListing()")
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)

"  if exists("b:netrw_curdir") |call Decho('b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("b:netrw_curdir doesn't exist") |endif
"  if exists("g:netrw_sort_by")|call Decho('g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("g:netrw_sort_by doesn't exist")|endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

  " get the list of files contained in the current directory
  let dirname    = b:netrw_curdir
  let dirnamelen = strlen(b:netrw_curdir)
  let filelist   = glob(s:ComposePath(dirname,"*"),0,1)
  let filelist   = filelist + glob(s:ComposePath(dirname,".*"),0,1)
"  call Decho("filelist=".filelist)

  if g:netrw_cygwin == 0 && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("filelist=".string(filelist))
  elseif index(filelist,'..') == -1 && b:netrw_curdir !~ '/'
    " include ../ in the glob() entry if its missing
"   call Decho("forcibly including on \"..\"")
   let filelist= filelist+[s:ComposePath(b:netrw_curdir,"../")]
"   call Decho("filelist=".string(filelist))
  endif

"  call Decho("before while: dirname<".dirname.">")
"  call Decho("before while: dirnamelen<".dirnamelen.">")
"  call Decho("before while: filelist=".string(filelist))

  if get(g:, 'netrw_dynamic_maxfilenamelen', 0)
   let filelistcopy           = map(deepcopy(filelist),'fnamemodify(v:val, ":t")')
   let g:netrw_maxfilenamelen = max(map(filelistcopy,'len(v:val)')) + 1
"   call Decho("dynamic_maxfilenamelen: filenames             =".string(filelistcopy))
"   call Decho("dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen)
  endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

  for filename in filelist
"   call Decho(" ")
"   call Decho("for filename in filelist: filename<".filename.">")

   if getftype(filename) == "link"
    " indicate a symbolic link
"    call Decho("indicate <".filename."> is a symbolic link with trailing @")
    let pfile= filename."@"

   elseif getftype(filename) == "socket"
    " indicate a socket
"    call Decho("indicate <".filename."> is a socket with trailing =")
    let pfile= filename."="

   elseif getftype(filename) == "fifo"
    " indicate a fifo
"    call Decho("indicate <".filename."> is a fifo with trailing |")
    let pfile= filename."|"

   elseif isdirectory(filename)
    " indicate a directory
"    call Decho("indicate <".filename."> is a directory with trailing /")
    let pfile= filename."/"

   elseif exists("b:netrw_curdir") && b:netrw_curdir !~ '^.*://' && !isdirectory(filename)
    if (has("win32") || has("win95") || has("win64") || has("win16"))
     if filename =~ '\.[eE][xX][eE]$' || filename =~ '\.[cC][oO][mM]$' || filename =~ '\.[bB][aA][tT]$'
      " indicate an executable
"      call Decho("indicate <".filename."> is executable with trailing *")
      let pfile= filename."*"
     else
      " normal file
      let pfile= filename
     endif
    elseif executable(filename)
     " indicate an executable
"     call Decho("indicate <".filename."> is executable with trailing *")
     let pfile= filename."*"
    else
     " normal file
     let pfile= filename
    endif

   else
    " normal file
    let pfile= filename
   endif
"   call Decho("pfile<".pfile."> (after *@/ appending)")

   if pfile =~ '//$'
    let pfile= substitute(pfile,'//$','/','e')
"    call Decho("change // to /: pfile<".pfile.">")
   endif
   let pfile= strpart(pfile,dirnamelen)
   let pfile= substitute(pfile,'^[/\\]','','e')
"   call Decho("filename<".filename.">")
"   call Decho("pfile   <".pfile.">")

   if w:netrw_liststyle == s:LONGLIST
    let sz   = getfsize(filename)
    let fsz  = strpart("               ",1,15-strlen(sz)).sz
    let pfile= pfile."\t".fsz." ".strftime(g:netrw_timefmt,getftime(filename))
"    call Decho("sz=".sz." fsz=".fsz)
   endif

   if     g:netrw_sort_by =~ "^t"
    " sort by time (handles time up to 1 quintillion seconds, US)
"    call Decho("getftime(".filename.")=".getftime(filename))
    let t  = getftime(filename)
    let ft = strpart("000000000000000000",1,18-strlen(t)).t
"    call Decho("exe keepjumps put ='".ft.'/'.filename."'")
    let ftpfile= ft.'/'.pfile
    sil! keepj put=ftpfile

   elseif g:netrw_sort_by =~ "^s"
    " sort by size (handles file sizes up to 1 quintillion bytes, US)
"    call Decho("getfsize(".filename.")=".getfsize(filename))
    let sz   = getfsize(filename)
    let fsz  = strpart("000000000000000000",1,18-strlen(sz)).sz
"    call Decho("exe keepj put ='".fsz.'/'.filename."'")
    let fszpfile= fsz.'/'.pfile
    sil! keepj put =fszpfile

   else
    " sort by name
"    call Decho("exe keepjumps put ='".pfile."'")
    sil! keepj put=pfile
   endif
  endfor

  " cleanup any windows mess at end-of-line
  sil! keepj g/^$/d
  sil! keepj %s/\r$//e
  call histdel("/",-1)
"  call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1))
  exe "setl ts=".(g:netrw_maxfilenamelen+1)

"  call Dret("s:LocalListing")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalExecute: uses system() to execute command under cursor ("X" command support) {{{2
fun! s:NetrwLocalExecute(cmd)
"  call Dfunc("s:NetrwLocalExecute(cmd<".a:cmd.">)")
  let ykeep= @@
  " sanity check
  if !executable(a:cmd)
   call netrw#ErrorMsg(s:ERROR,"the file<".a:cmd."> is not executable!",89)
   let @@= ykeep
"   call Dret("s:NetrwLocalExecute")
   return
  endif

  let optargs= input(":!".a:cmd,"","file")
"  call Decho("optargs<".optargs.">")
  let result= system(a:cmd.optargs)
"  call Decho("result)

  " strip any ansi escape sequences off
  let result = substitute(result,"\e\\[[0-9;]*m","","g")

  " show user the result(s)
  echomsg result
  let @@= ykeep

"  call Dret("s:NetrwLocalExecute")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRename: rename a remote file or directory {{{2
fun! s:NetrwLocalRename(path) range
"  call Dfunc("NetrwLocalRename(path<".a:path.">)")

  " preparation for removing multiple files/directories
  let ykeep = @@
  let ctr   = a:firstline
  let svpos = netrw#SavePosn()

  " rename files given by the markfilelist
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   for oldname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("oldname<".oldname.">")
    if exists("subfrom")
     let newname= substitute(oldname,subfrom,subto,'')
"     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
    else
     call inputsave()
     let newname= input("Moving ".oldname." to : ",oldname)
     call inputrestore()
     if newname =~ '^s/'
      let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
      let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
"      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
      let newname = substitute(oldname,subfrom,subto,'')
     endif
    endif
    call rename(oldname,newname)
   endfor
   call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
  
  else

   " attempt to rename files/directories
   while ctr <= a:lastline
    exe "keepj ".ctr

    " sanity checks
    if line(".") < w:netrw_bannercnt
     let ctr= ctr + 1
     continue
    endif
    let curword= s:NetrwGetWord()
    if curword == "./" || curword == "../"
     let ctr= ctr + 1
     continue
    endif

    keepj norm! 0
    let oldname= s:ComposePath(a:path,curword)
"   call Decho("oldname<".oldname.">")

    call inputsave()
    let newname= input("Moving ".oldname." to : ",substitute(oldname,'/*$','','e'))
    call inputrestore()

    call rename(oldname,newname)
"   call Decho("renaming <".oldname."> to <".newname.">")

    let ctr= ctr + 1
   endwhile
  endif

  " refresh the directory
"  call Decho("refresh the directory listing")
  keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
  keepj call netrw#RestorePosn(svpos)
  let @@= ykeep

"  call Dret("NetrwLocalRename")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRm: {{{2
fun! s:NetrwLocalRm(path) range
"  call Dfunc("s:NetrwLocalRm(path<".a:path.">)")
"  call Decho("firstline=".a:firstline." lastline=".a:lastline)

  " preparation for removing multiple files/directories
  let ykeep = @@
  let ret   = 0
  let all   = 0
  let svpos = netrw#SavePosn()

  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   " remove all marked files
"   call Decho("remove all marked files")
   for fname in s:netrwmarkfilelist_{bufnr("%")}
    let ok= s:NetrwLocalRmFile(a:path,fname,all)
    if ok =~ 'q\%[uit]' || ok == "no"
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
   endfor
   call s:NetrwUnMarkFile(1)

  else
  " remove (multiple) files and directories
"   call Decho("remove files in range [".a:firstline.",".a:lastline."]")

   let ctr = a:firstline
   while ctr <= a:lastline
    exe "keepj ".ctr

    " sanity checks
    if line(".") < w:netrw_bannercnt
     let ctr= ctr + 1
     continue
    endif
    let curword= s:NetrwGetWord()
    if curword == "./" || curword == "../"
     let ctr= ctr + 1
     continue
    endif
    let ok= s:NetrwLocalRmFile(a:path,curword,all)
    if ok =~ 'q\%[uit]' || ok == "no"
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
    let ctr= ctr + 1
   endwhile
  endif

  " refresh the directory
"  call Decho("bufname<".bufname("%").">")
  if bufname("%") != "NetrwMessage"
   keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
   keepj call netrw#RestorePosn(svpos)
  endif
  let @@= ykeep

"  call Dret("s:NetrwLocalRm")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRmFile: remove file fname given the path {{{2
"                     Give confirmation prompt unless all==1
fun! s:NetrwLocalRmFile(path,fname,all)
"  call Dfunc("s:NetrwLocalRmFile(path<".a:path."> fname<".a:fname."> all=".a:all)
  
  let all= a:all
  let ok = ""
  keepj norm! 0
  let rmfile= s:ComposePath(a:path,a:fname)
"  call Decho("rmfile<".rmfile.">")

  if rmfile !~ '^"' && (rmfile =~ '@$' || rmfile !~ '[\/]$')
   " attempt to remove file
"   call Decho("attempt to remove file<".rmfile.">")
   if !all
    echohl Statement
    call inputsave()
    let ok= input("Confirm deletion of file<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    echohl NONE
    if ok == ""
     let ok="no"
    endif
"    call Decho("response: ok<".ok.">")
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
"    call Decho("response: ok<".ok."> (after sub)")
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~ 'y\%[es]' || ok == ""
    let ret= s:NetrwDelete(rmfile)
"    call Decho("errcode=".v:shell_error." ret=".ret)
   endif

  else
   " attempt to remove directory
   if !all
    echohl Statement
    call inputsave()
    let ok= input("Confirm deletion of directory<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok == ""
     let ok="no"
    endif
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif
   let rmfile= substitute(rmfile,'[\/]$','','e')

   if all || ok =~ 'y\%[es]' || ok == ""
"    call Decho("1st attempt: system(netrw#WinPath(".g:netrw_localrmdir.') '.shellescape(rmfile).')')
    call system(netrw#WinPath(g:netrw_localrmdir).' '.shellescape(rmfile))
"    call Decho("v:shell_error=".v:shell_error)

    if v:shell_error != 0
"     call Decho("2nd attempt to remove directory<".rmfile.">")
     let errcode= s:NetrwDelete(rmfile)
"     call Decho("errcode=".errcode)

     if errcode != 0
      if has("unix")
"       call Decho("3rd attempt to remove directory<".rmfile.">")
       call system("rm ".shellescape(rmfile))
       if v:shell_error != 0 && !exists("g:netrw_quiet")
        call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",34)
	let ok="no"
       endif
      elseif !exists("g:netrw_quiet")
       call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",35)
       let ok="no"
      endif
     endif
    endif
   endif
  endif

"  call Dret("s:NetrwLocalRmFile ".ok)
  return ok
endfun

" ---------------------------------------------------------------------
" Support Functions: {{{1

" ---------------------------------------------------------------------
" netrw#Access: intended to provide access to variable values for netrw's test suite {{{2
"   0: marked file list of current buffer
"   1: marked file target
fun! netrw#Access(ilist)
  if     a:ilist == 0
   if exists("s:netrwmarkfilelist_".bufnr('%'))
    return s:netrwmarkfilelist_{bufnr('%')}
   else
    return "no-list-buf#".bufnr('%')
   endif
  elseif a:ilist == 1
   return s:netrwmftgt
endfun

" ------------------------------------------------------------------------
" netrw#RestorePosn: restores the cursor and file position as saved by NetrwSavePosn() {{{2
fun! netrw#RestorePosn(...)
"  call Dfunc("netrw#RestorePosn() a:0=".a:0." winnr=".(exists("w:netrw_winnr")? w:netrw_winnr : -1)." line=".(exists("w:netrw_line")? w:netrw_line : -1)." col=".(exists("w:netrw_col")? w:netrw_col : -1)." hline=".(exists("w:netrw_hline")? w:netrw_hline : -1))
  let eikeep= &ei
  setl ei=all
  if expand("%") == "NetrwMessage"
   if exists("s:winBeforeErr")
    exe s:winBeforeErr."wincmd w"
   endif
  endif

  if a:0 > 0
   exe "keepj ".a:1
  endif
"  call Decho("a:1             = ".((a:0 > 0)?              a:1       : 'n/a'))
"  call Decho("liststyle       = ".(exists("liststyle")?    liststyle : 'n/a'). " w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'))
  if exists("liststyle") && exists("w:netrw_liststyle") && liststyle != w:netrw_liststyle
   let usesrch= 1
  else
   let usesrch= 0
  endif

"  call Decho("winh            = ".(exists("w:netrw_winh")?    w:netrw_winh    : -1))
"  call Decho("winw            = ".(exists("w:netrw_winw")?    w:netrw_winw    : -1))
"  call Decho("cur    winheight=".winheight(0)." winwidth=".winwidth(0))
"  call Decho("w:netrw_winfile = ".(exists("w:netrw_winfile")? w:netrw_winfile : 'n/a'))

  " restore window
  if exists("w:netrw_winnr")
"   call Decho("restore window: exe sil! ".w:netrw_winnr."wincmd w")
   exe "sil! ".w:netrw_winnr."wincmd w"
  endif
  if v:shell_error == 0
   " as suggested by Bram M: redraw on no error
   " allows protocol error messages to remain visible
"   redraw!
  endif

  " restore top-of-screen line
  if exists("w:netrw_hline")
"   call Decho("restore topofscreen: exe keepj norm! ".w:netrw_hline."G0z")
   exe "keepj norm! ".w:netrw_hline."G0z\<CR>"
  endif

  " restore position
  " when the window's height x width has changed, the line,col is no longer useful
  if w:netrw_winh == winheight(0) && w:netrw_winw == winwidth(0) && exists("w:netrw_line") && exists("w:netrw_col") && !usesrch
"   call Decho("using posn: exe keepj norm! ".w:netrw_line."G0".w:netrw_col."|")
   exe "keepj norm! ".w:netrw_line."G0".w:netrw_col."\<bar>"

  elseif exists("w:netrw_winfile")
   if !search('\<'.escape(w:netrw_winfile,g:netrw_fname_escape),'cw')
    if exists("w:netrw_bannercnt")
"     call Decho("using bannercnt: win#".winnr()." ".winheight(0)."x".winwidth(0)." w:netrw_winfile<".w:netrw_winfile.">")
     exe "keepj ".w:netrw_bannercnt
     norm! 0
    else
     " go to upper left corner
"     call Decho("goto ulc: win#".winnr()." ".winheight(0)."x".winwidth(0)." w:netrw_winfile<".w:netrw_winfile.">")
     keepj 1
     norm! 0
    endif
   else
"    call Decho("used search: w:netrw_winfile<".w:netrw_winfile.">")
   endif

  else
"   call Decho("goto ulc: win#".winnr()." ".winheight(0)."x".winwidth(0))
   keepj 1
   norm! 0
  endif

  let &ei= eikeep
"  call Dret("netrw#RestorePosn : line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
endfun

" ---------------------------------------------------------------------
"  netrw#RFC2396: converts %xx into characters {{{2
fun! netrw#RFC2396(fname)
"  call Dfunc("netrw#RFC2396(fname<".a:fname.">)")
  let fname = escape(substitute(a:fname,'%\(\x\x\)','\=nr2char("0x".submatch(1))','ge')," \t")
"  call Dret("netrw#RFC2396 ".fname)
  return fname
endfun

" ---------------------------------------------------------------------
" netrw#SavePosn: saves position of cursor on screen {{{2
fun! netrw#SavePosn()
"  call Dfunc("netrw#SavePosn() line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
  " Save current line and column
  let w:netrw_winnr= winnr()
  let w:netrw_line = line(".")
  let w:netrw_col  = virtcol(".")
"  call Decho("currently, win#".w:netrw_winnr." line#".w:netrw_line." col#".w:netrw_col)

  " save filename under cursor
"  call Decho("line#".line(".")." w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a'))
  if exists("w:netrw_bannercnt") && line(".") >= w:netrw_bannercnt && &ft == "netrw"
   let winfile = "|let w:netrw_winfile='".s:NetrwGetWord()."'"
  else
   let winfile= ""
  endif
"  call Decho("winfile<".winfile.">")
  if exists("w:netrw_liststyle")
   let liststyle = "|let liststyle=".w:netrw_liststyle
  else
   let liststyle= ""
  endif
"  call Decho("liststyle=".liststyle)

  " Save top-of-screen line
  keepj norm! H0
  let w:netrw_hline= line(".")

  " save up alternate position information
  " use this when window height x width has changed
  let w:netrw_winh = winheight(0)
  let w:netrw_winw = winwidth(0)

  " set up string holding position parameters
  let ret          = "let w:netrw_winnr=".w:netrw_winnr."|let w:netrw_line=".w:netrw_line."|let w:netrw_col=".w:netrw_col."|let w:netrw_hline=".w:netrw_hline."|let w:netrw_winh=".w:netrw_winh."|let w:netrw_winw=".w:netrw_winw.liststyle.winfile

  keepj call netrw#RestorePosn()
"  call Dret("netrw#SavePosn : winnr=".(exists("w:netrw_winnr")? w:netrw_winnr : "n/a")." line=".(exists("w:netrw_line")? w:netrw_line : "n/a")." col=".(exists("w:netrw_col")? w:netrw_col : "n/a")." hline=".(exists("w:netrw_hline")? w:netrw_hline : "n/a"))
  return ret
endfun

" ---------------------------------------------------------------------
" netrw#WinPath: tries to insure that the path is windows-acceptable, whether cygwin is used or not {{{2
fun! netrw#WinPath(path)
"  call Dfunc("netrw#WinPath(path<".a:path.">)")
  if (!g:netrw_cygwin || &shell !~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$') && (has("win32") || has("win95") || has("win64") || has("win16"))
   " remove cygdrive prefix, if present
   let path = substitute(a:path,g:netrw_cygdrive.'/\(.\)','\1:','')
   " remove trailing slash (Win95)
   let path = substitute(path, '\(\\\|/\)$', '', 'g')
   " remove escaped spaces
   let path = substitute(path, '\ ', ' ', 'g')
   " convert slashes to backslashes
   let path = substitute(path, '/', '\', 'g')
  else
   let path= a:path
  endif
"  call Dret("netrw#WinPath <".path.">")
  return path
endfun

" ---------------------------------------------------------------------
"  s:ComposePath: Appends a new part to a path taking different systems into consideration {{{2
fun! s:ComposePath(base,subdir)
"  call Dfunc("s:ComposePath(base<".a:base."> subdir<".a:subdir.">)")

  if has("amiga")
"   call Decho("amiga")
   let ec = a:base[s:Strlen(a:base)-1]
   if ec != '/' && ec != ':'
    let ret = a:base . "/" . a:subdir
   else
    let ret = a:base . a:subdir
   endif

  elseif a:subdir =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows")
   let ret= a:subdir

  elseif a:base =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows")
   if a:base =~ '[/\\]$'
    let ret= a:base.a:subdir
   else
    let ret= a:base."/".a:subdir
   endif

  elseif a:base =~ '^\a\+://'
"   call Decho("remote linux/macos")
   let urlbase = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\1','')
   let curpath = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\2','')
   if a:subdir == '../'
    if curpath =~ '[^/]/[^/]\+/$'
     let curpath= substitute(curpath,'[^/]\+/$','','')
    else
     let curpath=""
    endif
    let ret= urlbase.curpath
   else
    let ret= urlbase.curpath.a:subdir
   endif
"   call Decho("urlbase<".urlbase.">")
"   call Decho("curpath<".curpath.">")
"   call Decho("ret<".ret.">")

  else
"   call Decho("local linux/macos")
   let ret = substitute(a:base."/".a:subdir,"//","/","g")
   if a:base =~ '^//'
    " keeping initial '//' for the benefit of network share listing support
    let ret= '/'.ret
   endif
   let ret= simplify(ret)
  endif

"  call Dret("s:ComposePath ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:FileReadable: o/s independent filereadable {{{2
fun! s:FileReadable(fname)
"  call Dfunc("s:FileReadable(fname<".a:fname.">)")

  if g:netrw_cygwin
   let ret= filereadable(substitute(a:fname,g:netrw_cygdrive.'/\(.\)','\1:/',''))
  else
   let ret= filereadable(a:fname)
  endif

"  call Dret("s:FileReadable ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
"  s:GetTempfile: gets a tempname that'll work for various o/s's {{{2
"                 Places correct suffix on end of temporary filename,
"                 using the suffix provided with fname
fun! s:GetTempfile(fname)
"  call Dfunc("s:GetTempfile(fname<".a:fname.">)")

  if !exists("b:netrw_tmpfile")
   " get a brand new temporary filename
   let tmpfile= tempname()
"   call Decho("tmpfile<".tmpfile."> : from tempname()")

   let tmpfile= substitute(tmpfile,'\','/','ge')
"   call Decho("tmpfile<".tmpfile."> : chgd any \\ -> /")

   " sanity check -- does the temporary file's directory exist?
   if !isdirectory(substitute(tmpfile,'[^/]\+$','','e'))
"    call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
    keepj call netrw#ErrorMsg(s:ERROR,"your <".substitute(tmpfile,'[^/]\+$','','e')."> directory is missing!",2)
"    call Dret("s:GetTempfile getcwd<".getcwd().">")
    return ""
   endif

   " let netrw#NetSource() know about the tmpfile
   let s:netrw_tmpfile= tmpfile " used by netrw#NetSource() and netrw#NetrwBrowseX()
"   call Decho("tmpfile<".tmpfile."> s:netrw_tmpfile<".s:netrw_tmpfile.">")

   " o/s dependencies
   if g:netrw_cygwin != 0
    let tmpfile = substitute(tmpfile,'^\(\a\):',g:netrw_cygdrive.'/\1','e')
   elseif has("win32") || has("win95") || has("win64") || has("win16")
    if !exists("+shellslash") || !&ssl
     let tmpfile = substitute(tmpfile,'/','\','g')
    endif
   else
    let tmpfile = tmpfile
   endif
   let b:netrw_tmpfile= tmpfile
"   call Decho("o/s dependent fixed tempname<".tmpfile.">")
  else
   " re-use temporary filename
   let tmpfile= b:netrw_tmpfile
"   call Decho("tmpfile<".tmpfile."> re-using")
  endif

  " use fname's suffix for the temporary file
  if a:fname != ""
   if a:fname =~ '\.[^./]\+$'
"    call Decho("using fname<".a:fname.">'s suffix")
    if a:fname =~ '\.tar\.gz$' || a:fname =~ '\.tar\.bz2$' || a:fname =~ '\.tar\.xz$'
     let suffix = ".tar".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    elseif a:fname =~ '.txz$'
     let suffix = ".txz".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    else
     let suffix = substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    endif
"    call Decho("suffix<".suffix.">")
    let tmpfile= substitute(tmpfile,'\.tmp$','','e')
"    call Decho("chgd tmpfile<".tmpfile."> (removed any .tmp suffix)")
    let tmpfile .= suffix
"    call Decho("chgd tmpfile<".tmpfile."> (added ".suffix." suffix) netrw_fname<".b:netrw_fname.">")
    let s:netrw_tmpfile= tmpfile " supports netrw#NetSource()
   endif
  endif

"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"  call Dret("s:GetTempfile <".tmpfile.">")
  return tmpfile
endfun

" ---------------------------------------------------------------------
" s:MakeSshCmd: transforms input command using USEPORT HOSTNAME into {{{2
"               a correct command for use with a system() call
fun! s:MakeSshCmd(sshcmd)
"  call Dfunc("s:MakeSshCmd(sshcmd<".a:sshcmd.">) user<".s:user."> machine<".s:machine.">")
  if s:user == ""
   let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:machine,'')
  else
   let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:user."@".s:machine,'')
  endif
  if exists("g:netrw_port") && g:netrw_port != ""
   let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.g:netrw_port,'')
  elseif exists("s:port") && s:port != ""
   let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.s:port,'')
  else
   let sshcmd= substitute(sshcmd,"USEPORT ",'','')
  endif
"  call Dret("s:MakeSshCmd <".sshcmd.">")
  return sshcmd
endfun

" ---------------------------------------------------------------------
" s:NetrwBMShow: {{{2
fun! s:NetrwBMShow()
"  call Dfunc("s:NetrwBMShow()")
  redir => bmshowraw
   menu
  redir END
  let bmshowlist = split(bmshowraw,'\n')
  if bmshowlist != []
   let bmshowfuncs= filter(bmshowlist,'v:val =~ "<SNR>\\d\\+_BMShow()"')
   if bmshowfuncs != []
    let bmshowfunc = substitute(bmshowfuncs[0],'^.*:\(call.*BMShow()\).*$','\1','')
    if bmshowfunc =~ '^call.*BMShow()'
     exe "sil! keepj ".bmshowfunc
    endif
   endif
  endif
"  call Dret("s:NetrwBMShow : bmshowfunc<".(exists("bmshowfunc")? bmshowfunc : 'n/a').">")
endfun

" ---------------------------------------------------------------------
" s:NetrwCursor: responsible for setting cursorline/cursorcolumn based upon g:netrw_cursor {{{2
fun! s:NetrwCursor()
  if !exists("w:netrw_liststyle")
   let w:netrw_liststyle= g:netrw_liststyle
  endif
"  call Dfunc("s:NetrwCursor() ft<".&ft."> liststyle=".w:netrw_liststyle." g:netrw_cursor=".g:netrw_cursor." s:netrw_usercuc=".s:netrw_usercuc." s:netrw_usercul=".s:netrw_usercul)

  if &ft != "netrw"
   " if the current window isn't a netrw directory listing window, then use user cursorline/column
   " settings.  Affects when netrw is used to read/write a file using scp/ftp/etc.
"   call Decho("case ft!=netrw: use user cul,cuc")
   let &l:cursorline   = s:netrw_usercul
   let &l:cursorcolumn = s:netrw_usercuc

  elseif g:netrw_cursor == 4
   " all styles: cursorline, cursorcolumn
"   call Decho("case g:netrw_cursor==4: setl cul cuc")
   setl cursorline
   setl cursorcolumn

  elseif g:netrw_cursor == 3
   " thin-long-tree: cursorline, user's cursorcolumn
   " wide          : cursorline, cursorcolumn
   if w:netrw_liststyle == s:WIDELIST
"    call Decho("case g:netrw_cursor==3 and wide: setl cul cuc")
    setl cursorline
    setl cursorcolumn
   else
"    call Decho("case g:netrw_cursor==3 and not wide: setl cul (use user's cuc)")
    setl cursorline
    let &l:cursorcolumn   = s:netrw_usercuc
   endif

  elseif g:netrw_cursor == 2
   " thin-long-tree: cursorline, user's cursorcolumn
   " wide          : cursorline, user's cursorcolumn
"   call Decho("case g:netrw_cursor==2: setl cuc (use user's cul)")
   let &l:cursorcolumn = s:netrw_usercuc
   setl cursorline

  elseif g:netrw_cursor == 1
   " thin-long-tree: user's cursorline, user's cursorcolumn
   " wide          : cursorline,        user's cursorcolumn
   let &l:cursorcolumn = s:netrw_usercuc
   if w:netrw_liststyle == s:WIDELIST
"    call Decho("case g:netrw_cursor==2 and wide: setl cul (use user's cuc)")
    setl cursorline
   else
"    call Decho("case g:netrw_cursor==2 and not wide: (use user's cul,cuc)")
    let &l:cursorline   = s:netrw_usercul
   endif

  else
   " all styles: user's cursorline, user's cursorcolumn
"   call Decho("default: (use user's cul,cuc)")
   let &l:cursorline   = s:netrw_usercul
   let &l:cursorcolumn = s:netrw_usercuc
  endif

"  call Dret("s:NetrwCursor : l:cursorline=".&l:cursorline." l:cursorcolumn=".&l:cursorcolumn)
endfun

" ---------------------------------------------------------------------
" s:RestoreCursorline: restores cursorline/cursorcolumn to original user settings {{{2
fun! s:RestoreCursorline()
"  call Dfunc("s:RestoreCursorline() currently, cul=".&l:cursorline." cuc=".&l:cursorcolumn." win#".winnr()." buf#".bufnr("%"))
  if exists("s:netrw_usercul")
   let &l:cursorline   = s:netrw_usercul
  endif
  if exists("s:netrw_usercuc")
   let &l:cursorcolumn = s:netrw_usercuc
  endif
"  call Dret("s:RestoreCursorline : restored cul=".&l:cursorline." cuc=".&l:cursorcolumn)
endfun

" ---------------------------------------------------------------------
" s:NetrwDelete: Deletes a file. {{{2
"           Uses Steve Hall's idea to insure that Windows paths stay
"           acceptable.  No effect on Unix paths.
"  Examples of use:  let result= s:NetrwDelete(path)
fun! s:NetrwDelete(path)
"  call Dfunc("s:NetrwDelete(path<".a:path.">)")

  let path = netrw#WinPath(a:path)
  if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
   if exists("+shellslash")
    let sskeep= &shellslash
    setl noshellslash
    let result      = delete(path)
    let &shellslash = sskeep
   else
"    call Decho("exe let result= ".a:cmd."('".path."')")
    let result= delete(path)
   endif
  else
"   call Decho("let result= delete(".path.")")
   let result= delete(path)
  endif
  if result < 0
   keepj call netrw#ErrorMsg(s:WARNING,"delete(".path.") failed!",71)
  endif

"  call Dret("s:NetrwDelete ".result)
  return result
endfun

" ---------------------------------------------------------------------
" s:NetrwEnew: opens a new buffer, passes netrw buffer variables through {{{2
fun! s:NetrwEnew(...)
"  call Dfunc("s:NetrwEnew() a:0=".a:0." bufnr($)=".bufnr("$"))
"  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">")

  " grab a function-local-variable copy of buffer variables
"  call Decho("make function-local copy of netrw variables")
  if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
  if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
  if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
  if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
  if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
  if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
  if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
  if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
  if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
  if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
  if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
  if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
  if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
  if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
  if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
  if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif

  keepj call s:NetrwOptionRestore("w:")
"  call Decho("generate a buffer with keepjumps keepalt enew!")
  let netrw_keepdiff= &l:diff
  noswapfile keepj keepalt enew!
  let &l:diff= netrw_keepdiff
"  call Decho("bufnr($)=".bufnr("$")." winnr($)=".winnr("$"))
  keepj call s:NetrwOptionSave("w:")

  " copy function-local-variables to buffer variable equivalents
"  call Decho("copy function-local variables back to buffer netrw variables")
  if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
  if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
  if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
  if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
  if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
  if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
  if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
  if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
  if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
  if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
  if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
  if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
  if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
  if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
  if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
  if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif

  if a:0 > 0
   let b:netrw_curdir= a:1
   if b:netrw_curdir =~ '/$'
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
     file NetrwTreeListing
     setl bt=nowrite noswf bh=hide
     nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
     nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
    else
     exe "sil! keepalt file ".fnameescape(b:netrw_curdir)
    endif
   endif
  endif

"  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh." win#".winnr()." winnr($)#".winnr("$"))
endfun

" ---------------------------------------------------------------------
" s:NetrwInsureWinVars: insure that a netrw buffer has its w: variables in spite of a wincmd v or s {{{2
fun! s:NetrwInsureWinVars()
"  call Dfunc("s:NetrwInsureWinVars() win#".winnr())
  if !exists("w:netrw_liststyle")
   let curbuf = bufnr("%")
   let curwin = winnr()
   let iwin   = 1
   while iwin <= winnr("$")
    exe iwin."wincmd w"
    if winnr() != curwin && bufnr("%") == curbuf && exists("w:netrw_liststyle")
     " looks like ctrl-w_s or ctrl-w_v was used to split a netrw buffer
     let winvars= w:
     break
    endif
    let iwin= iwin + 1
   endwhile
   exe "keepalt ".curwin."wincmd w"
   if exists("winvars")
"    call Decho("copying w#".iwin." window variables to w#".curwin)
    for k in keys(winvars)
     let w:{k}= winvars[k]
    endfor
   endif
  endif
"  call Dret("s:NetrwInsureWinVars win#".winnr())
endfun

" ---------------------------------------------------------------------
" s:NetrwLcd: handles changing the (local) directory {{{2
fun! s:NetrwLcd(newdir)
"  call Dfunc("s:NetrwLcd(newdir<".a:newdir.">)")

  try
   exe 'keepj sil lcd '.fnameescape(a:newdir)
  catch /^Vim\%((\a\+)\)\=:E344/
     " Vim's lcd fails with E344 when attempting to go above the 'root' of a Windows share.
     " Therefore, detect if a Windows share is present, and if E344 occurs, just settle at
     " 'root' (ie. '\').  The share name may start with either backslashes ('\\Foo') or 
     " forward slashes ('//Foo'), depending on whether backslashes have been converted to
     " forward slashes by earlier code; so check for both.
     if (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
       if a:newdir =~ '^\\\\\w\+' || a:newdir =~ '^//\w\+'
         let dirname = '\'
	 exe 'keepj sil lcd '.fnameescape(dirname)
       endif
     endif
  catch /^Vim\%((\a\+)\)\=:E472/
   call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".a:newdir."> (permissions?)",61)
   if exists("w:netrw_prvdir")
    let a:newdir= w:netrw_prvdir
   else
    call s:NetrwOptionRestore("w:")
"    call Decho("setl noma nomod nowrap")
    exe "setl ".g:netrw_bufsettings
"    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
    let a:newdir= dirname
"    call Dret("s:NetrwBrowse : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
    return
   endif
  endtry

"  call Dret("s:NetrwLcd")
endfun

" ------------------------------------------------------------------------
" s:NetrwSaveWordPosn: used to keep cursor on same word after refresh, {{{2
" changed sorting, etc.  Also see s:NetrwRestoreWordPosn().
fun! s:NetrwSaveWordPosn()
"  call Dfunc("NetrwSaveWordPosn()")
  let s:netrw_saveword= '^'.fnameescape(getline('.')).'$'
"  call Dret("NetrwSaveWordPosn : saveword<".s:netrw_saveword.">")
endfun

" ---------------------------------------------------------------------
" s:NetrwRestoreWordPosn: used to keep cursor on same word after refresh, {{{2
"  changed sorting, etc.  Also see s:NetrwSaveWordPosn().
fun! s:NetrwRestoreWordPosn()
"  call Dfunc("NetrwRestoreWordPosn()")
  sil! call search(s:netrw_saveword,'w')
"  call Dret("NetrwRestoreWordPosn")
endfun

" ---------------------------------------------------------------------
" s:RestoreBufVars: {{{2
fun! s:RestoreBufVars()
"  call Dfunc("s:RestoreBufVars()")

  if exists("s:netrw_curdir")        |let b:netrw_curdir         = s:netrw_curdir        |endif
  if exists("s:netrw_lastfile")      |let b:netrw_lastfile       = s:netrw_lastfile      |endif
  if exists("s:netrw_method")        |let b:netrw_method         = s:netrw_method        |endif
  if exists("s:netrw_fname")         |let b:netrw_fname          = s:netrw_fname         |endif
  if exists("s:netrw_machine")       |let b:netrw_machine        = s:netrw_machine       |endif
  if exists("s:netrw_browser_active")|let b:netrw_browser_active = s:netrw_browser_active|endif

"  call Dret("s:RestoreBufVars")
endfun

" ---------------------------------------------------------------------
" s:RemotePathAnalysis: {{{2
fun! s:RemotePathAnalysis(dirname)
"  call Dfunc("s:RemotePathAnalysis(a:dirname<".a:dirname.">)")

  "                method   ://    user  @      machine      :port            /path
  let dirpat  = '^\(\w\{-}\)://\(\(\w\+\)@\)\=\([^/:#]\+\)\%([:#]\(\d\+\)\)\=/\(.*\)$'
  let s:method  = substitute(a:dirname,dirpat,'\1','')
  let s:user    = substitute(a:dirname,dirpat,'\3','')
  let s:machine = substitute(a:dirname,dirpat,'\4','')
  let s:port    = substitute(a:dirname,dirpat,'\5','')
  let s:path    = substitute(a:dirname,dirpat,'\6','')
  let s:fname   = substitute(s:path,'^.*/\ze.','','')
  if s:machine =~ '@'
   let dirpat    = '^\(.*\)@\(.\{-}\)$'
   let s:user    = s:user.'@'.substitute(s:machine,dirpat,'\1','')
   let s:machine = substitute(s:machine,dirpat,'\2','')
  endif

"  call Decho("set up s:method <".s:method .">")
"  call Decho("set up s:user   <".s:user   .">")
"  call Decho("set up s:machine<".s:machine.">")
"  call Decho("set up s:port   <".s:port.">")
"  call Decho("set up s:path   <".s:path   .">")
"  call Decho("set up s:fname  <".s:fname  .">")

"  call Dret("s:RemotePathAnalysis")
endfun

" ---------------------------------------------------------------------
" s:RemoteSystem: runs a command on a remote host using ssh {{{2
"                 Returns status
" Runs system() on
"    [cd REMOTEDIRPATH;] a:cmd
" Note that it doesn't do shellescape(a:cmd)!
fun! s:RemoteSystem(cmd)
"  call Dfunc("s:RemoteSystem(cmd<".a:cmd.">)")
  if !executable(g:netrw_ssh_cmd)
   keepj call netrw#ErrorMsg(s:ERROR,"g:netrw_ssh_cmd<".g:netrw_ssh_cmd."> is not executable!",52)
  elseif !exists("b:netrw_curdir")
   keepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
  else
   let cmd      = s:MakeSshCmd(g:netrw_ssh_cmd." USEPORT HOSTNAME")
   let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
   if remotedir != ""
    let cmd= cmd.' cd '.shellescape(remotedir).";"
   else
    let cmd= cmd.' '
   endif
   let cmd= cmd.a:cmd
"   call Decho("call system(".cmd.")")
   let ret= system(cmd)
  endif
"  call Dret("s:RemoteSystem ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:RestoreWinVars: (used by Explore() and NetrwSplit()) {{{2
fun! s:RestoreWinVars()
"  call Dfunc("s:RestoreWinVars()")
  if exists("s:bannercnt")      |let w:netrw_bannercnt       = s:bannercnt      |unlet s:bannercnt      |endif
  if exists("s:col")            |let w:netrw_col             = s:col            |unlet s:col            |endif
  if exists("s:curdir")         |let w:netrw_curdir          = s:curdir         |unlet s:curdir         |endif
  if exists("s:explore_bufnr")  |let w:netrw_explore_bufnr   = s:explore_bufnr  |unlet s:explore_bufnr  |endif
  if exists("s:explore_indx")   |let w:netrw_explore_indx    = s:explore_indx   |unlet s:explore_indx   |endif
  if exists("s:explore_line")   |let w:netrw_explore_line    = s:explore_line   |unlet s:explore_line   |endif
  if exists("s:explore_listlen")|let w:netrw_explore_listlen = s:explore_listlen|unlet s:explore_listlen|endif
  if exists("s:explore_list")   |let w:netrw_explore_list    = s:explore_list   |unlet s:explore_list   |endif
  if exists("s:explore_mtchcnt")|let w:netrw_explore_mtchcnt = s:explore_mtchcnt|unlet s:explore_mtchcnt|endif
  if exists("s:fpl")            |let w:netrw_fpl             = s:fpl            |unlet s:fpl            |endif
  if exists("s:hline")          |let w:netrw_hline           = s:hline          |unlet s:hline          |endif
  if exists("s:line")           |let w:netrw_line            = s:line           |unlet s:line           |endif
  if exists("s:liststyle")      |let w:netrw_liststyle       = s:liststyle      |unlet s:liststyle      |endif
  if exists("s:method")         |let w:netrw_method          = s:method         |unlet s:method         |endif
  if exists("s:prvdir")         |let w:netrw_prvdir          = s:prvdir         |unlet s:prvdir         |endif
  if exists("s:treedict")       |let w:netrw_treedict        = s:treedict       |unlet s:treedict       |endif
  if exists("s:treetop")        |let w:netrw_treetop         = s:treetop        |unlet s:treetop        |endif
  if exists("s:winnr")          |let w:netrw_winnr           = s:winnr          |unlet s:winnr          |endif
"  call Dret("s:RestoreWinVars")
endfun

" ---------------------------------------------------------------------
" s:Rexplore: implements returning from a buffer to a netrw directory {{{2
"
"             s:SetRexDir() sets up <2-leftmouse> maps (if g:netrw_retmap
"             is true) and a command, :Rexplore, which call this function.
"
"             s:nbcd_curpos_{bufnr('%')} is set up by s:NetrwBrowseChgDir()
fun! s:NetrwRexplore(islocal,dirname)
  if exists("s:netrwdrag")
   return
  endif
"  call Dfunc("s:NetrwRexplore() w:netrw_rexlocal=".w:netrw_rexlocal." w:netrw_rexdir<".w:netrw_rexdir.">")
"  call Decho("ft=".&ft." win#".winnr()." w:netrw_rexfile<".(exists("w:netrw_rexfile")? w:netrw_rexfile : 'n/a').">")

  if &ft == "netrw" && exists("w:netrw_rexfile") && w:netrw_rexfile != ""
"   call Decho("in netrw buffer, will edit file<".w:netrw_rexfile.">")
   exe "e ".w:netrw_rexfile
   unlet w:netrw_rexfile
"   call Dret("s:NetrwRexplore returning from netrw to buf#".bufnr("%")."<".bufname("%").">  (ft=".&ft.")")
   return
  endif

  " record current file so :Rex can return to it from netrw
  let w:netrw_rexfile= expand("%")

  if !exists("w:netrw_rexlocal")
"   call Dret("s:NetrwRexplore w:netrw_rexlocal doesn't exist (".&ft.")")
   return
  endif
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
  if w:netrw_rexlocal
   keepj call netrw#LocalBrowseCheck(w:netrw_rexdir)
  else
   keepj call s:NetrwBrowse(0,w:netrw_rexdir)
  endif
  if exists("s:initbeval")
   setl beval
  endif
  if exists("s:rexposn_".bufnr("%"))
"   call Decho("restore posn, then unlet s:rexposn_".bufnr('%'))
   keepj call netrw#RestorePosn(s:rexposn_{bufnr('%')})
   unlet s:rexposn_{bufnr('%')}
  else
"   call Decho("s:rexposn_".bufnr('%')." doesn't exist")
  endif

  if exists("s:explore_match")
   exe "2match netrwMarkFile /".s:explore_match."/"
  endif

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"  call Dret("s:NetrwRexplore : ft=".&ft)
endfun

" ---------------------------------------------------------------------
" s:SaveBufVars: save selected b: variables to s: variables {{{2
"                use s:RestoreBufVars() to restore b: variables from s: variables
fun! s:SaveBufVars()
"  call Dfunc("s:SaveBufVars() buf#".bufnr("%"))

  if exists("b:netrw_curdir")        |let s:netrw_curdir         = b:netrw_curdir        |endif
  if exists("b:netrw_lastfile")      |let s:netrw_lastfile       = b:netrw_lastfile      |endif
  if exists("b:netrw_method")        |let s:netrw_method         = b:netrw_method        |endif
  if exists("b:netrw_fname")         |let s:netrw_fname          = b:netrw_fname         |endif
  if exists("b:netrw_machine")       |let s:netrw_machine        = b:netrw_machine       |endif
  if exists("b:netrw_browser_active")|let s:netrw_browser_active = b:netrw_browser_active|endif

"  call Dret("s:SaveBufVars")
endfun

" ---------------------------------------------------------------------
" s:SaveWinVars: (used by Explore() and NetrwSplit()) {{{2
fun! s:SaveWinVars()
"  call Dfunc("s:SaveWinVars() win#".winnr())
  if exists("w:netrw_bannercnt")      |let s:bannercnt       = w:netrw_bannercnt      |endif
  if exists("w:netrw_col")            |let s:col             = w:netrw_col            |endif
  if exists("w:netrw_curdir")         |let s:curdir          = w:netrw_curdir         |endif
  if exists("w:netrw_explore_bufnr")  |let s:explore_bufnr   = w:netrw_explore_bufnr  |endif
  if exists("w:netrw_explore_indx")   |let s:explore_indx    = w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_line")   |let s:explore_line    = w:netrw_explore_line   |endif
  if exists("w:netrw_explore_listlen")|let s:explore_listlen = w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_list")   |let s:explore_list    = w:netrw_explore_list   |endif
  if exists("w:netrw_explore_mtchcnt")|let s:explore_mtchcnt = w:netrw_explore_mtchcnt|endif
  if exists("w:netrw_fpl")            |let s:fpl             = w:netrw_fpl            |endif
  if exists("w:netrw_hline")          |let s:hline           = w:netrw_hline          |endif
  if exists("w:netrw_line")           |let s:line            = w:netrw_line           |endif
  if exists("w:netrw_liststyle")      |let s:liststyle       = w:netrw_liststyle      |endif
  if exists("w:netrw_method")         |let s:method          = w:netrw_method         |endif
  if exists("w:netrw_prvdir")         |let s:prvdir          = w:netrw_prvdir         |endif
  if exists("w:netrw_treedict")       |let s:treedict        = w:netrw_treedict       |endif
  if exists("w:netrw_treetop")        |let s:treetop         = w:netrw_treetop        |endif
  if exists("w:netrw_winnr")          |let s:winnr           = w:netrw_winnr          |endif
"  call Dret("s:SaveWinVars")
endfun

" ---------------------------------------------------------------------
" s:SetBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck()) {{{2
"   To allow separate windows to have their own activities, such as
"   Explore **/pattern, several variables have been made window-oriented.
"   However, when the user splits a browser window (ex: ctrl-w s), these
"   variables are not inherited by the new window.  SetBufWinVars() and
"   UseBufWinVars() get around that.
fun! s:SetBufWinVars()
"  call Dfunc("s:SetBufWinVars() win#".winnr())
  if exists("w:netrw_liststyle")      |let b:netrw_liststyle      = w:netrw_liststyle      |endif
  if exists("w:netrw_bannercnt")      |let b:netrw_bannercnt      = w:netrw_bannercnt      |endif
  if exists("w:netrw_method")         |let b:netrw_method         = w:netrw_method         |endif
  if exists("w:netrw_prvdir")         |let b:netrw_prvdir         = w:netrw_prvdir         |endif
  if exists("w:netrw_explore_indx")   |let b:netrw_explore_indx   = w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_listlen")|let b:netrw_explore_listlen= w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt= w:netrw_explore_mtchcnt|endif
  if exists("w:netrw_explore_bufnr")  |let b:netrw_explore_bufnr  = w:netrw_explore_bufnr  |endif
  if exists("w:netrw_explore_line")   |let b:netrw_explore_line   = w:netrw_explore_line   |endif
  if exists("w:netrw_explore_list")   |let b:netrw_explore_list   = w:netrw_explore_list   |endif
"  call Dret("s:SetBufWinVars")
endfun

" ---------------------------------------------------------------------
" s:SetRexDir: set directory for :Rexplore {{{2
fun! s:SetRexDir(islocal,dirname)
"  call Dfunc("s:SetRexDir(islocal=".a:islocal." dirname<".a:dirname.">)")
  let w:netrw_rexdir   = a:dirname
  let w:netrw_rexlocal = a:islocal
"  call Dret("s:SetRexDir : win#".winnr()." ".(a:islocal? "local" : "remote")." dir: ".a:dirname)
endfun

" ---------------------------------------------------------------------
" s:Strlen: this function returns the length of a string, even if its using multi-byte characters. {{{2
"           Solution from Nicolai Weibull, vim docs (:help strlen()),
"           Tony Mechelynck, and my own invention.
fun! s:Strlen(x)
"  "" call Dfunc("s:Strlen(x<".a:x."> g:Align_xstrlen=".g:Align_xstrlen.")")

  if v:version >= 703 && exists("*strdisplaywidth")
   let ret= strdisplaywidth(a:x)
 
  elseif type(g:Align_xstrlen) == 1
   " allow user to specify a function to compute the string length  (ie. let g:Align_xstrlen="mystrlenfunc")
   exe "let ret= ".g:Align_xstrlen."('".substitute(a:x,"'","''","g")."')"
 
  elseif g:Align_xstrlen == 1
   " number of codepoints (Latin a + combining circumflex is two codepoints)
   " (comment from TM, solution from NW)
   let ret= strlen(substitute(a:x,'.','c','g'))
 
  elseif g:Align_xstrlen == 2
   " number of spacing codepoints (Latin a + combining circumflex is one spacing
   " codepoint; a hard tab is one; wide and narrow CJK are one each; etc.)
   " (comment from TM, solution from TM)
   let ret=strlen(substitute(a:x, '.\Z', 'x', 'g'))
 
  elseif g:Align_xstrlen == 3
   " virtual length (counting, for instance, tabs as anything between 1 and
   " 'tabstop', wide CJK as 2 rather than 1, Arabic alif as zero when immediately
   " preceded by lam, one otherwise, etc.)
   " (comment from TM, solution from me)
   let modkeep= &l:mod
   exe "norm! o\<esc>"
   call setline(line("."),a:x)
   let ret= virtcol("$") - 1
   d
   keepj norm! k
   let &l:mod= modkeep
 
  else
   " at least give a decent default
    let ret= strlen(a:x)
  endif
"  "" call Dret("s:Strlen ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:TreeListMove: {{{2
fun! s:TreeListMove(dir)
"  call Dfunc("s:TreeListMove(dir<".a:dir.">)")
  let curline  = getline('.')
  let prvline  = (line(".") > 1)?         getline(line(".")-1) : ''
  let nxtline  = (line(".") < line("$"))? getline(line(".")+1) : ''
  let curindent= substitute(curline,'^\([| ]*\).\{-}$','\1','')
  let indentm1 = substitute(curindent,'^'.s:treedepthstring.' ','','')
"  call Decho("prvline  <".prvline."> #".line(".")-1)
"  call Decho("curline  <".curline."> #".line("."))
"  call Decho("nxtline  <".nxtline."> #".line(".")+1)
"  call Decho("curindent<".curindent.">")
"  call Decho("indentm1 <".indentm1.">")

  if curline !~ '/$'
"   call Decho('regfile')
   if     a:dir == '[' && prvline != ''
    keepj norm! 0
    let nl = search('^'.indentm1.'[^'.s:treedepthstring.']','bWe')    " search backwards from regular file
"    call Decho("regfile srch back: ".nl)
   elseif a:dir == ']' && nxtline != ''
    keepj norm! $
    let nl = search('^'.indentm1.'[^'.s:treedepthstring.']','We')     " search forwards from regular file
"    call Decho("regfile srch fwd: ".nl)
   endif

  elseif a:dir == '[' && prvline != ''
   keepj norm! 0
   let curline= line(".")
   let nl     = search('^'.curindent.'[^'.s:treedepthstring.']','bWe') " search backwards From directory, same indentation
"   call Decho("dir srch back ind: ".nl)
   if nl != 0
    if line(".") == curline-1
     let nl= search('^'.indentm1.'[^'.s:treedepthstring.']','bWe')     " search backwards from directory, indentation - 1
"     call Decho("dir srch back ind-1: ".nl)
    endif
   endif

  elseif a:dir == ']' && nxtline != ''
   keepj norm! $
   let curline = line(".")
   let nl      = search('^'.curindent.'[^'.s:treedepthstring.']','We') " search forwards from directory, same indentation
"   call Decho("dir srch fwd ind: ".nl)
   if nl != 0
    if line(".") == curline+1
     let nl= search('^'.indentm1.'[^'.s:treedepthstring.']','We')         " search forwards from directory, indentation - 1
"     call Decho("dir srch fwd ind-1: ".nl)
    endif
   endif

  endif

"  call Dret("s:TreeListMove")
endfun

" ---------------------------------------------------------------------
" s:UpdateBuffersMenu: does emenu Buffers.Refresh (but due to locale, the menu item may not be called that) {{{2
"                      The Buffers.Refresh menu calls s:BMShow(); unfortunately, that means that that function
"                      can't be called except via emenu.  But due to locale, that menu line may not be called
"                      Buffers.Refresh; hence, s:NetrwBMShow() utilizes a "cheat" to call that function anyway.
fun! s:UpdateBuffersMenu()
"  call Dfunc("s:UpdateBuffersMenu()")
  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   try
    sil emenu Buffers.Refresh\ menu
   catch /^Vim\%((\a\+)\)\=:E/
    let v:errmsg= ""
    sil keepj call s:NetrwBMShow()
   endtry
  endif
"  call Dret("s:UpdateBuffersMenu")
endfun

" ---------------------------------------------------------------------
" s:UseBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck() {{{2
"              Matching function to s:SetBufWinVars()
fun! s:UseBufWinVars()
"  call Dfunc("s:UseBufWinVars()")
  if exists("b:netrw_liststyle")       && !exists("w:netrw_liststyle")      |let w:netrw_liststyle       = b:netrw_liststyle      |endif
  if exists("b:netrw_bannercnt")       && !exists("w:netrw_bannercnt")      |let w:netrw_bannercnt       = b:netrw_bannercnt      |endif
  if exists("b:netrw_method")          && !exists("w:netrw_method")         |let w:netrw_method          = b:netrw_method         |endif
  if exists("b:netrw_prvdir")          && !exists("w:netrw_prvdir")         |let w:netrw_prvdir          = b:netrw_prvdir         |endif
  if exists("b:netrw_explore_indx")    && !exists("w:netrw_explore_indx")   |let w:netrw_explore_indx    = b:netrw_explore_indx   |endif
  if exists("b:netrw_explore_listlen") && !exists("w:netrw_explore_listlen")|let w:netrw_explore_listlen = b:netrw_explore_listlen|endif
  if exists("b:netrw_explore_mtchcnt") && !exists("w:netrw_explore_mtchcnt")|let w:netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
  if exists("b:netrw_explore_bufnr")   && !exists("w:netrw_explore_bufnr")  |let w:netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
  if exists("b:netrw_explore_line")    && !exists("w:netrw_explore_line")   |let w:netrw_explore_line    = b:netrw_explore_line   |endif
  if exists("b:netrw_explore_list")    && !exists("w:netrw_explore_list")   |let w:netrw_explore_list    = b:netrw_explore_list   |endif
"  call Dret("s:UseBufWinVars")
endfun

" ---------------------------------------------------------------------
" Settings Restoration: {{{1
let &cpo= s:keepcpo
unlet s:keepcpo

" ------------------------------------------------------------------------
" Modelines: {{{1
" vim:ts=8 fdm=marker
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim support file to detect file types
"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2014 Oct 09

" Listen very carefully, I will say this only once
if exists("did_load_filetypes")
  finish
endif
let did_load_filetypes = 1

" Line continuation is used here, remove 'C' from 'cpoptions'
let s:cpo_save = &cpo
set cpo&vim

augroup filetypedetect

" Ignored extensions
if exists("*fnameescape")
au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew
	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
au BufNewFile,BufRead *~
	\ let s:name = expand("<afile>") |
	\ let s:short = substitute(s:name, '\~$', '', '') |
	\ if s:name != s:short && s:short != "" |
	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
	\ endif |
	\ unlet! s:name s:short
au BufNewFile,BufRead ?\+.in
	\ if expand("<afile>:t") != "configure.in" |
	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
	\ endif
elseif &verbose > 0
  echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
endif

" Pattern used to match file names which should not be inspected.
" Currently finds compressed files.
if !exists("g:ft_ignore_pat")
  let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
endif

" Function used for patterns that end in a star: don't set the filetype if the
" file name matches ft_ignore_pat.
func! s:StarSetf(ft)
  if expand("<amatch>") !~ g:ft_ignore_pat
    exe 'setf ' . a:ft
  endif
endfunc

" Abaqus or Trasys
au BufNewFile,BufRead *.inp			call s:Check_inp()

func! s:Check_inp()
  if getline(1) =~ '^\*'
    setf abaqus
  else
    let n = 1
    if line("$") > 500
      let nmax = 500
    else
      let nmax = line("$")
    endif
    while n <= nmax
      if getline(n) =~? "^header surface data"
	setf trasys
	break
      endif
      let n = n + 1
    endwhile
  endif
endfunc

" A-A-P recipe
au BufNewFile,BufRead *.aap			setf aap

" A2ps printing utility
au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps

" ABAB/4
au BufNewFile,BufRead *.abap			setf abap

" ABC music notation
au BufNewFile,BufRead *.abc			setf abc

" ABEL
au BufNewFile,BufRead *.abl			setf abel

" AceDB
au BufNewFile,BufRead *.wrm			setf acedb

" Ada (83, 9X, 95)
au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
if has("vms")
  au BufNewFile,BufRead *.gpr,*.ada_m,*.adc	setf ada
else
  au BufNewFile,BufRead *.gpr			setf ada
endif

" AHDL
au BufNewFile,BufRead *.tdf			setf ahdl

" AMPL
au BufNewFile,BufRead *.run			setf ampl

" Ant
au BufNewFile,BufRead build.xml			setf ant

" Arduino
au BufNewFile,BufRead *.ino,*.pde		setf arduino

" Apache style config file
au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')

" Apache config file
au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache

" XA65 MOS6510 cross assembler
au BufNewFile,BufRead *.a65			setf a65

" Applescript
au BufNewFile,BufRead *.scpt			setf applescript

" Applix ELF
au BufNewFile,BufRead *.am
	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif

" ALSA configuration
au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf

" Arc Macro Language
au BufNewFile,BufRead *.aml			setf aml

" APT config file
au BufNewFile,BufRead apt.conf		       setf aptconf
au BufNewFile,BufRead */.aptitude/config       setf aptconf
au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf

" Arch Inventory file
au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch

" ART*Enterprise (formerly ART-IM)
au BufNewFile,BufRead *.art			setf art

" AsciiDoc
au BufNewFile,BufRead *.asciidoc		setf asciidoc

" ASN.1
au BufNewFile,BufRead *.asn,*.asn1		setf asn

" Active Server Pages (with Visual Basic Script)
au BufNewFile,BufRead *.asa
	\ if exists("g:filetype_asa") |
	\   exe "setf " . g:filetype_asa |
	\ else |
	\   setf aspvbs |
	\ endif

" Active Server Pages (with Perl or Visual Basic Script)
au BufNewFile,BufRead *.asp
	\ if exists("g:filetype_asp") |
	\   exe "setf " . g:filetype_asp |
	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
	\   setf aspperl |
	\ else |
	\   setf aspvbs |
	\ endif

" Grub (must be before catch *.lst)
au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub

" Assembly (all kinds)
" *.lst is not pure assembly, it has two extra columns (address, byte codes)
au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call s:FTasm()

" This function checks for the kind of assembly that is wanted by the user, or
" can be detected from the first five lines of the file.
func! s:FTasm()
  " make sure b:asmsyntax exists
  if !exists("b:asmsyntax")
    let b:asmsyntax = ""
  endif

  if b:asmsyntax == ""
    call s:FTasmsyntax()
  endif

  " if b:asmsyntax still isn't set, default to asmsyntax or GNU
  if b:asmsyntax == ""
    if exists("g:asmsyntax")
      let b:asmsyntax = g:asmsyntax
    else
      let b:asmsyntax = "asm"
    endif
  endif

  exe "setf " . fnameescape(b:asmsyntax)
endfunc

func! s:FTasmsyntax()
  " see if file contains any asmsyntax=foo overrides. If so, change
  " b:asmsyntax appropriately
  let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
	\" ".getline(5)." "
  let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
  if match != ''
    let b:asmsyntax = match
  elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
    let b:asmsyntax = "vmasm"
  endif
endfunc

" Macro (VAX)
au BufNewFile,BufRead *.mar			setf vmasm

" Atlas
au BufNewFile,BufRead *.atl,*.as		setf atlas

" Autoit v3
au BufNewFile,BufRead *.au3			setf autoit

" Autohotkey
au BufNewFile,BufRead *.ahk			setf autohotkey

" Automake
au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake

" Autotest .at files are actually m4
au BufNewFile,BufRead *.at			setf m4

" Avenue
au BufNewFile,BufRead *.ave			setf ave

" Awk
au BufNewFile,BufRead *.awk			setf awk

" B
au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b

" BASIC or Visual Basic
au BufNewFile,BufRead *.bas			call s:FTVB("basic")

" Check if one of the first five lines contains "VB_Name".  In that case it is
" probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
func! s:FTVB(alt)
  if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
    setf vb
  else
    exe "setf " . a:alt
  endif
endfunc

" Visual Basic Script (close to Visual Basic) or Visual Basic .NET
au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb

" IBasic file (similar to QBasic)
au BufNewFile,BufRead *.iba,*.ibi		setf ibasic

" FreeBasic file (similar to QBasic)
au BufNewFile,BufRead *.fb,*.bi			setf freebasic

" Batch file for MSDOS.
au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
" *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
au BufNewFile,BufRead *.cmd
	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif

" Batch file for 4DOS
au BufNewFile,BufRead *.btm			call s:FTbtm()
func! s:FTbtm()
  if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
    setf dosbatch
  else
    setf btm
  endif
endfunc

" BC calculator
au BufNewFile,BufRead *.bc			setf bc

" BDF font
au BufNewFile,BufRead *.bdf			setf bdf

" BibTeX bibliography database file
au BufNewFile,BufRead *.bib			setf bib

" BibTeX Bibliography Style
au BufNewFile,BufRead *.bst			setf bst

" BIND configuration
au BufNewFile,BufRead named.conf,rndc.conf	setf named

" BIND zone
au BufNewFile,BufRead named.root		setf bindzone
au BufNewFile,BufRead *.db			call s:BindzoneCheck('')

func! s:BindzoneCheck(default)
  if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
    setf bindzone
  elseif a:default != ''
    exe 'setf ' . a:default
  endif
endfunc

" Blank
au BufNewFile,BufRead *.bl			setf blank

" Blkid cache file
au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml

" C or lpc
au BufNewFile,BufRead *.c			call s:FTlpc()

func! s:FTlpc()
  if exists("g:lpc_syntax_for_c")
    let lnum = 1
    while lnum <= 12
      if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
	setf lpc
	return
      endif
      let lnum = lnum + 1
    endwhile
  endif
  setf c
endfunc

" Calendar
au BufNewFile,BufRead calendar			setf calendar

" C#
au BufNewFile,BufRead *.cs			setf cs

" CSDL
au BufNewFile,BufRead *.csdl			setf csdl

" Cabal
au BufNewFile,BufRead *.cabal			setf cabal

" Cdrdao TOC
au BufNewFile,BufRead *.toc			setf cdrtoc

" Cdrdao config
au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf

" Cfengine
au BufNewFile,BufRead cfengine.conf		setf cfengine

" ChaiScript
au BufRead,BufNewFile *.chai			setf chaiscript

" Comshare Dimension Definition Language
au BufNewFile,BufRead *.cdl			setf cdl

" Conary Recipe
au BufNewFile,BufRead *.recipe			setf conaryrecipe

" Controllable Regex Mutilator
au BufNewFile,BufRead *.crm			setf crm

" Cyn++
au BufNewFile,BufRead *.cyn			setf cynpp

" Cynlib
" .cc and .cpp files can be C++ or Cynlib.
au BufNewFile,BufRead *.cc
	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
au BufNewFile,BufRead *.cpp
	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif

" C++
au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
if has("fname_case")
  au BufNewFile,BufRead *.C,*.H setf cpp
endif

" .h files can be C, Ch C++, ObjC or ObjC++.
" Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
" detected automatically.
au BufNewFile,BufRead *.h			call s:FTheader()

func! s:FTheader()
  if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
    if exists("g:c_syntax_for_h")
      setf objc
    else
      setf objcpp
    endif
  elseif exists("g:c_syntax_for_h")
    setf c
  elseif exists("g:ch_syntax_for_h")
    setf ch
  else
    setf cpp
  endif
endfunc

" Ch (CHscript)
au BufNewFile,BufRead *.chf			setf ch

" TLH files are C++ headers generated by Visual C++'s #import from typelibs
au BufNewFile,BufRead *.tlh			setf cpp

" Cascading Style Sheets
au BufNewFile,BufRead *.css			setf css

" Century Term Command Scripts (*.cmd too)
au BufNewFile,BufRead *.con			setf cterm

" Changelog
au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
					\	setf debchangelog

au BufNewFile,BufRead [cC]hange[lL]og
	\  if getline(1) =~ '; urgency='
	\|   setf debchangelog
	\| else
	\|   setf changelog
	\| endif

au BufNewFile,BufRead NEWS
	\  if getline(1) =~ '; urgency='
	\|   setf debchangelog
	\| endif

" CHILL
au BufNewFile,BufRead *..ch			setf chill

" Changes for WEB and CWEB or CHILL
au BufNewFile,BufRead *.ch			call s:FTchange()

" This function checks if one of the first ten lines start with a '@'.  In
" that case it is probably a change file.
" If the first line starts with # or ! it's probably a ch file.
" If a line has "main", "include", "//" ir "/*" it's probably ch.
" Otherwise CHILL is assumed.
func! s:FTchange()
  let lnum = 1
  while lnum <= 10
    if getline(lnum)[0] == '@'
      setf change
      return
    endif
    if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
      setf ch
      return
    endif
    if getline(lnum) =~ "MODULE"
      setf chill
      return
    endif
    if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
      setf ch
      return
    endif
    let lnum = lnum + 1
  endwhile
  setf chill
endfunc

" ChordPro
au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro

" Clean
au BufNewFile,BufRead *.dcl,*.icl		setf clean

" Clever
au BufNewFile,BufRead *.eni			setf cl

" Clever or dtd
au BufNewFile,BufRead *.ent			call s:FTent()

func! s:FTent()
  " This function checks for valid cl syntax in the first five lines.
  " Look for either an opening comment, '#', or a block start, '{".
  " If not found, assume SGML.
  let lnum = 1
  while lnum < 6
    let line = getline(lnum)
    if line =~ '^\s*[#{]'
      setf cl
      return
    elseif line !~ '^\s*$'
      " Not a blank line, not a comment, and not a block start,
      " so doesn't look like valid cl code.
      break
    endif
    let lnum = lnum + 1
  endw
  setf dtd
endfunc

" Clipper (or FoxPro; could also be eviews)
au BufNewFile,BufRead *.prg
	\ if exists("g:filetype_prg") |
	\   exe "setf " . g:filetype_prg |
	\ else |
	\   setf clipper |
	\ endif

" Clojure
au BufNewFile,BufRead *.clj,*.cljs		setf clojure

" Cmake
au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake

" Cmusrc
au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc

" Cobol
au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
"   cobol or zope form controller python script? (heuristic)
au BufNewFile,BufRead *.cpy
	\ if getline(1) =~ '^##' |
	\   setf python |
	\ else |
	\   setf cobol |
	\ endif

" Coco/R
au BufNewFile,BufRead *.atg			setf coco

" Cold Fusion
au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf

" Configure scripts
au BufNewFile,BufRead configure.in,configure.ac setf config

" CUDA  Cumpute Unified Device Architecture
au BufNewFile,BufRead *.cu			setf cuda

" Dockerfile
au BufNewFile,BufRead Dockerfile		setf dockerfile

" WildPackets EtherPeek Decoder
au BufNewFile,BufRead *.dcd			setf dcd

" Enlightenment configuration files
au BufNewFile,BufRead *enlightenment/*.cfg	setf c

" Eterm
au BufNewFile,BufRead *Eterm/*.cfg		setf eterm

" Euphoria 3 or 4
au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
if has("fname_case")
   au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
endif

func! s:EuphoriaCheck()
  if exists('g:filetype_euphoria')
    exe 'setf ' . g:filetype_euphoria
  else
    setf euphoria3
  endif
endfunc

" Lynx config files
au BufNewFile,BufRead lynx.cfg			setf lynx

" Quake
au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake

" Quake C
au BufNewFile,BufRead *.qc			setf c

" Configure files
au BufNewFile,BufRead *.cfg			setf cfg

" Cucumber
au BufNewFile,BufRead *.feature			setf cucumber

" Communicating Sequential Processes
au BufNewFile,BufRead *.csp,*.fdr		setf csp

" CUPL logic description and simulation
au BufNewFile,BufRead *.pld			setf cupl
au BufNewFile,BufRead *.si			setf cuplsim

" Debian Control
au BufNewFile,BufRead */debian/control		setf debcontrol
au BufNewFile,BufRead control
	\  if getline(1) =~ '^Source:'
	\|   setf debcontrol
	\| endif

" Debian Sources.list
au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources

" Deny hosts
au BufNewFile,BufRead denyhosts.conf		setf denyhosts

" dnsmasq(8) configuration files
au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq

" ROCKLinux package description
au BufNewFile,BufRead *.desc			setf desc

" the D language or dtrace
au BufNewFile,BufRead *.d			call s:DtraceCheck()

func! s:DtraceCheck()
  let lines = getline(1, min([line("$"), 100]))
  if match(lines, '^module\>\|^import\>') > -1
    " D files often start with a module and/or import statement.
    setf d
  elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
    setf dtrace
  else
    setf d
  endif
endfunc

" Desktop files
au BufNewFile,BufRead *.desktop,.directory	setf desktop

" Dict config
au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf

" Dictd config
au BufNewFile,BufRead dictd.conf		setf dictdconf

" Diff files
au BufNewFile,BufRead *.diff,*.rej,*.patch	setf diff

" Dircolors
au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors

" Diva (with Skill) or InstallShield
au BufNewFile,BufRead *.rul
	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
	\   setf ishd |
	\ else |
	\   setf diva |
	\ endif

" DCL (Digital Command Language - vms) or DNS zone file
au BufNewFile,BufRead *.com			call s:BindzoneCheck('dcl')

" DOT
au BufNewFile,BufRead *.dot			setf dot

" Dylan - lid files
au BufNewFile,BufRead *.lid			setf dylanlid

" Dylan - intr files (melange)
au BufNewFile,BufRead *.intr			setf dylanintr

" Dylan
au BufNewFile,BufRead *.dylan			setf dylan

" Microsoft Module Definition
au BufNewFile,BufRead *.def			setf def

" Dracula
au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula

" Datascript
au BufNewFile,BufRead *.ds			setf datascript

" dsl
au BufNewFile,BufRead *.dsl			setf dsl

" DTD (Document Type Definition for XML)
au BufNewFile,BufRead *.dtd			setf dtd

" DTS/DSTI (device tree files)
au BufNewFile,BufRead *.dts,*.dtsi		setf dts

" EDIF (*.edf,*.edif,*.edn,*.edo)
au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)	setf edif

" Embedix Component Description
au BufNewFile,BufRead *.ecd			setf ecd

" Eiffel or Specman or Euphoria
au BufNewFile,BufRead *.e,*.E			call s:FTe()

" Elinks configuration
au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks

func! s:FTe()
  if exists('g:filetype_euphoria')
    exe 'setf ' . g:filetype_euphoria
  else
    let n = 1
    while n < 100 && n < line("$")
      if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
        setf specman
        return
      endif
      let n = n + 1
    endwhile
    setf eiffel
  endif
endfunc

" ERicsson LANGuage; Yaws is erlang too
au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang

" Elm Filter Rules file
au BufNewFile,BufRead filter-rules		setf elmfilt

" ESMTP rc file
au BufNewFile,BufRead *esmtprc			setf esmtprc

" ESQL-C
au BufNewFile,BufRead *.ec,*.EC			setf esqlc

" Esterel
au BufNewFile,BufRead *.strl			setf esterel

" Essbase script
au BufNewFile,BufRead *.csc			setf csc

" Exim
au BufNewFile,BufRead exim.conf			setf exim

" Expect
au BufNewFile,BufRead *.exp			setf expect

" Exports
au BufNewFile,BufRead exports			setf exports

" Falcon
au BufNewFile,BufRead *.fal			setf falcon

" Fantom
au BufNewFile,BufRead *.fan,*.fwt		setf fan

" Factor
au BufNewFile,BufRead *.factor			setf factor

" Fetchmail RC file
au BufNewFile,BufRead .fetchmailrc		setf fetchmail

" FlexWiki - disabled, because it has side effects when a .wiki file
" is not actually FlexWiki
"au BufNewFile,BufRead *.wiki			setf flexwiki

" Focus Executable
au BufNewFile,BufRead *.fex,*.focexec		setf focexec

" Focus Master file (but not for auto.master)
au BufNewFile,BufRead auto.master		setf conf
au BufNewFile,BufRead *.mas,*.master		setf master

" Forth
au BufNewFile,BufRead *.fs,*.ft			setf forth

" Reva Forth
au BufNewFile,BufRead *.frt			setf reva

" Fortran
if has("fname_case")
  au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
endif
au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran

" Framescript
au BufNewFile,BufRead *.fsl			setf framescript

" FStab
au BufNewFile,BufRead fstab,mtab		setf fstab

" GDB command files
au BufNewFile,BufRead .gdbinit			setf gdb

" GDMO
au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo

" Gedcom
au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom

" Git
au BufNewFile,BufRead *.git/COMMIT_EDITMSG	setf gitcommit
au BufNewFile,BufRead *.git/MERGE_MSG		setf gitcommit
au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
au BufNewFile,BufRead *.git/modules/*/COMMIT_EDITMSG setf gitcommit
au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
au BufNewFile,BufRead */.config/git/config	setf gitconfig
au BufNewFile,BufRead git-rebase-todo		setf gitrebase
au BufNewFile,BufRead .msg.[0-9]*
      \ if getline(1) =~ '^From.*# This line is ignored.$' |
      \   setf gitsendemail |
      \ endif
au BufNewFile,BufRead *.git/*
      \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
      \   setf git |
      \ endif

" Gkrellmrc
au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc

" GP scripts (2.0 and onward)
au BufNewFile,BufRead *.gp,.gprc		setf gp

" GPG
au BufNewFile,BufRead */.gnupg/options		setf gpg
au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg

" gnash(1) configuration files
au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash

" Gitolite
au BufNewFile,BufRead gitolite.conf		setf gitolite
au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl

" Gnuplot scripts
au BufNewFile,BufRead *.gpi			setf gnuplot

" Go (Google)
au BufNewFile,BufRead *.go			setf go

" GrADS scripts
au BufNewFile,BufRead *.gs			setf grads

" Gretl
au BufNewFile,BufRead *.gretl			setf gretl

" Groovy
au BufNewFile,BufRead *.groovy			setf groovy

" GNU Server Pages
au BufNewFile,BufRead *.gsp			setf gsp

" Group file
au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group

" GTK RC
au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc

" Haml
au BufNewFile,BufRead *.haml			setf haml

" Hamster Classic | Playground files
au BufNewFile,BufRead *.hsc,*.hsm		setf hamster

" Haskell
au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
au BufNewFile,BufRead *.lhs			setf lhaskell
au BufNewFile,BufRead *.chs			setf chaskell

" Haste
au BufNewFile,BufRead *.ht			setf haste
au BufNewFile,BufRead *.htpp			setf hastepreproc

" Hercules
au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum	setf hercules

" HEX (Intel)
au BufNewFile,BufRead *.hex,*.h32		setf hex

" Tilde (must be before HTML)
au BufNewFile,BufRead *.t.html			setf tilde

" HTML (.shtml and .stm for server side)
au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()

" Distinguish between HTML, XHTML and Django
func! s:FThtml()
  let n = 1
  while n < 10 && n < line("$")
    if getline(n) =~ '\<DTD\s\+XHTML\s'
      setf xhtml
      return
    endif
    if getline(n) =~ '{%\s*\(extends\|block\|load\)\>'
      setf htmldjango
      return
    endif
    let n = n + 1
  endwhile
  setf html
endfunc

" HTML with Ruby - eRuby
au BufNewFile,BufRead *.erb,*.rhtml		setf eruby

" HTML with M4
au BufNewFile,BufRead *.html.m4			setf htmlm4

" HTML Cheetah template
au BufNewFile,BufRead *.tmpl			setf htmlcheetah

" Host config
au BufNewFile,BufRead */etc/host.conf		setf hostconf

" Hosts access
au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess

" Hyper Builder
au BufNewFile,BufRead *.hb			setf hb

" Httest
au BufNewFile,BufRead *.htt,*.htb		setf httest

" Icon
au BufNewFile,BufRead *.icn			setf icon

" IDL (Interface Description Language)
au BufNewFile,BufRead *.idl			call s:FTidl()

" Distinguish between standard IDL and MS-IDL
func! s:FTidl()
  let n = 1
  while n < 50 && n < line("$")
    if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
      setf msidl
      return
    endif
    let n = n + 1
  endwhile
  setf idl
endfunc

" Microsoft IDL (Interface Description Language)  Also *.idl
" MOF = WMI (Windows Management Instrumentation) Managed Object Format
au BufNewFile,BufRead *.odl,*.mof		setf msidl

" Icewm menu
au BufNewFile,BufRead */.icewm/menu		setf icemenu

" Indent profile (must come before IDL *.pro!)
au BufNewFile,BufRead .indent.pro		setf indent
au BufNewFile,BufRead indent.pro		call s:ProtoCheck('indent')

" IDL (Interactive Data Language)
au BufNewFile,BufRead *.pro			call s:ProtoCheck('idlang')

" Distinguish between "default" and Cproto prototype file. */
func! s:ProtoCheck(default)
  " Cproto files have a comment in the first line and a function prototype in
  " the second line, it always ends in ";".  Indent files may also have
  " comments, thus we can't match comments to see the difference.
  " IDL files can have a single ';' in the second line, require at least one
  " chacter before the ';'.
  if getline(2) =~ '.;$'
    setf cpp
  else
    exe 'setf ' . a:default
  endif
endfunc


" Indent RC
au BufNewFile,BufRead indentrc			setf indent

" Inform
au BufNewFile,BufRead *.inf,*.INF		setf inform

" Initng
au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng

" Innovation Data Processing
au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c 	setf upstreamlog
au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog

" Ipfilter
au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter

" Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl

" .INI file for MSDOS
au BufNewFile,BufRead *.ini			setf dosini

" SysV Inittab
au BufNewFile,BufRead inittab			setf inittab

" Inno Setup
au BufNewFile,BufRead *.iss			setf iss

" J
au BufNewFile,BufRead *.ijs			setf j

" JAL
au BufNewFile,BufRead *.jal,*.JAL		setf jal

" Jam
au BufNewFile,BufRead *.jpl,*.jpr		setf jam

" Java
au BufNewFile,BufRead *.java,*.jav		setf java

" JavaCC
au BufNewFile,BufRead *.jj,*.jjt		setf javacc

" JavaScript, ECMAScript
au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript

" Java Server Pages
au BufNewFile,BufRead *.jsp			setf jsp

" Java Properties resource file (note: doesn't catch font.properties.pl)
au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')

" Jess
au BufNewFile,BufRead *.clp			setf jess

" Jgraph
au BufNewFile,BufRead *.jgr			setf jgraph

" Jovial
au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial

" JSON
au BufNewFile,BufRead *.json,*.jsonp		setf json

" Kixtart
au BufNewFile,BufRead *.kix			setf kix

" Kimwitu[++]
au BufNewFile,BufRead *.k			setf kwt

" Kivy
au BufNewFile,BufRead *.kv			setf kivy

" KDE script
au BufNewFile,BufRead *.ks			setf kscript

" Kconfig
au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig

" Lace (ISE)
au BufNewFile,BufRead *.ace,*.ACE		setf lace

" Latte
au BufNewFile,BufRead *.latte,*.lte		setf latte

" Limits
au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits

" LambdaProlog (*.mod too, see Modsim)
au BufNewFile,BufRead *.sig			setf lprolog

" LDAP LDIF
au BufNewFile,BufRead *.ldif			setf ldif

" Ld loader
au BufNewFile,BufRead *.ld			setf ld

" Lex
au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex

" Libao
au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao

" Libsensors
au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors

" LFTP
au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp

" Lifelines (or Lex for C++!)
au BufNewFile,BufRead *.ll			setf lifelines

" Lilo: Linux loader
au BufNewFile,BufRead lilo.conf			setf lilo

" Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
if has("fname_case")
  au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
else
  au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
endif

" SBCL implementation of Common Lisp
au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp

" Liquid
au BufNewFile,BufRead *.liquid			setf liquid

" Lite
au BufNewFile,BufRead *.lite,*.lt		setf lite

" LiteStep RC files
au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep

" Login access
au BufNewFile,BufRead */etc/login.access	setf loginaccess

" Login defs
au BufNewFile,BufRead */etc/login.defs		setf logindefs

" Logtalk
au BufNewFile,BufRead *.lgt			setf logtalk

" LOTOS
au BufNewFile,BufRead *.lot,*.lotos		setf lotos

" Lout (also: *.lt)
au BufNewFile,BufRead *.lou,*.lout		setf lout

" Lua
au BufNewFile,BufRead *.lua			setf lua

" Luarocks
au BufNewFile,BufRead *.rockspec		setf lua

" Linden Scripting Language (Second Life)
au BufNewFile,BufRead *.lsl			setf lsl

" Lynx style file (or LotusScript!)
au BufNewFile,BufRead *.lss			setf lss

" M4
au BufNewFile,BufRead *.m4
	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif

" MaGic Point
au BufNewFile,BufRead *.mgp			setf mgp

" Mail (for Elm, trn, mutt, muttng, rn, slrn)
au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail

" Mail aliases
au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases

" Mailcap configuration file
au BufNewFile,BufRead .mailcap,mailcap		setf mailcap

" Makefile
au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make

" MakeIndex
au BufNewFile,BufRead *.ist,*.mst		setf ist

" Mallard
au BufNewFile,BufRead *.page			setf mallard

" Manpage
au BufNewFile,BufRead *.man			setf man

" Man config
au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf

" Maple V
au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple

" Map (UMN mapserver config file)
au BufNewFile,BufRead *.map			setf map

" Markdown
au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown

" Mason
au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason

" Matlab or Objective C
au BufNewFile,BufRead *.m			call s:FTm()

func! s:FTm()
  let n = 1
  while n < 10
    let line = getline(n)
    if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\|//\)'
      setf objc
      return
    endif
    if line =~ '^\s*%'
      setf matlab
      return
    endif
    if line =~ '^\s*(\*'
      setf mma
      return
    endif
    let n = n + 1
  endwhile
  if exists("g:filetype_m")
    exe "setf " . g:filetype_m
  else
    setf matlab
  endif
endfunc

" Mathematica notebook
au BufNewFile,BufRead *.nb			setf mma

" Maya Extension Language
au BufNewFile,BufRead *.mel			setf mel

" Mercurial (hg) commit file
au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit

" Mercurial config (looks like generic config file)
au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg

" Messages (logs mostly)
au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages

" Metafont
au BufNewFile,BufRead *.mf			setf mf

" MetaPost
au BufNewFile,BufRead *.mp			setf mp

" MGL
au BufNewFile,BufRead *.mgl			setf mgl

" MIX - Knuth assembly
au BufNewFile,BufRead *.mix,*.mixal		setf mix

" MMIX or VMS makefile
au BufNewFile,BufRead *.mms			call s:FTmms()

" Symbian meta-makefile definition (MMP)
au BufNewFile,BufRead *.mmp			setf mmp

func! s:FTmms()
  let n = 1
  while n < 10
    let line = getline(n)
    if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
      setf mmix
      return
    endif
    if line =~ '^\s*#'
      setf make
      return
    endif
    let n = n + 1
  endwhile
  setf mmix
endfunc


" Modsim III (or LambdaProlog)
au BufNewFile,BufRead *.mod
	\ if getline(1) =~ '\<module\>' |
	\   setf lprolog |
	\ else |
	\   setf modsim3 |
	\ endif

" Modula 2  (.md removed in favor of Markdown)
au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2

" Modula 3 (.m3, .i3, .mg, .ig)
au BufNewFile,BufRead *.[mi][3g]		setf modula3

" Monk
au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk

" MOO
au BufNewFile,BufRead *.moo			setf moo

" Modconf
au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf

" Mplayer config
au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf

" Moterola S record
au BufNewFile,BufRead *.s19,*.s28,*.s37		setf srec

" Mrxvtrc
au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc

" Msql
au BufNewFile,BufRead *.msql			setf msql

" Mysql
au BufNewFile,BufRead *.mysql			setf mysql

" Mutt setup files (must be before catch *.rc)
au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')

" M$ Resource files
au BufNewFile,BufRead *.rc,*.rch		setf rc

" MuPAD source
au BufRead,BufNewFile *.mu			setf mupad

" Mush
au BufNewFile,BufRead *.mush			setf mush

" Mutt setup file (also for Muttng)
au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc

" Nano
au BufNewFile,BufRead */etc/nanorc,.nanorc	setf nanorc

" Nastran input/DMAP
"au BufNewFile,BufRead *.dat			setf nastran

" Natural
au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural

" Netrc
au BufNewFile,BufRead .netrc			setf netrc

" Ninja file
au BufNewFile,BufRead *.ninja			setf ninja

" Novell netware batch files
au BufNewFile,BufRead *.ncf			setf ncf

" Nroff/Troff (*.ms and *.t are checked below)
au BufNewFile,BufRead *.me
	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
	\   setf nroff |
	\ endif
au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
au BufNewFile,BufRead *.[1-9]			call s:FTnroff()

" This function checks if one of the first five lines start with a dot.  In
" that case it is probably an nroff file: 'filetype' is set and 1 is returned.
func! s:FTnroff()
  if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
    setf nroff
    return 1
  endif
  return 0
endfunc

" Nroff or Objective C++
au BufNewFile,BufRead *.mm			call s:FTmm()

func! s:FTmm()
  let n = 1
  while n < 10
    let line = getline(n)
    if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\)'
      setf objcpp
      return
    endif
    let n = n + 1
  endwhile
  setf nroff
endfunc

" Not Quite C
au BufNewFile,BufRead *.nqc			setf nqc

" NSIS
au BufNewFile,BufRead *.nsi,*.nsh		setf nsis

" OCAML
au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml

" Occam
au BufNewFile,BufRead *.occ			setf occam

" Omnimark
au BufNewFile,BufRead *.xom,*.xin		setf omnimark

" OpenROAD
au BufNewFile,BufRead *.or			setf openroad

" OPL
au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl

" Oracle config file
au BufNewFile,BufRead *.ora			setf ora

" Packet filter conf
au BufNewFile,BufRead pf.conf			setf pf

" Pam conf
au BufNewFile,BufRead */etc/pam.conf		setf pamconf

" PApp
au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp

" Password file
au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd

" Pascal (also *.p)
au BufNewFile,BufRead *.pas			setf pascal

" Delphi project file
au BufNewFile,BufRead *.dpr			setf pascal

" PDF
au BufNewFile,BufRead *.pdf			setf pdf

" Perl
if has("fname_case")
  au BufNewFile,BufRead *.pl,*.PL		call s:FTpl()
else
  au BufNewFile,BufRead *.pl			call s:FTpl()
endif
au BufNewFile,BufRead *.plx,*.al		setf perl
au BufNewFile,BufRead *.p6,*.pm6		setf perl6

func! s:FTpl()
  if exists("g:filetype_pl")
    exe "setf " . g:filetype_pl
  else
    " recognize Prolog by specific text in the first non-empty line
    " require a blank after the '%' because Perl uses "%list" and "%translate"
    let l = getline(nextnonblank(1))
    if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
      setf prolog
    else
      setf perl
    endif
  endif
endfunc

" Perl, XPM or XPM2
au BufNewFile,BufRead *.pm
	\ if getline(1) =~ "XPM2" |
	\   setf xpm2 |
	\ elseif getline(1) =~ "XPM" |
	\   setf xpm |
	\ else |
	\   setf perl |
	\ endif

" Perl POD
au BufNewFile,BufRead *.pod			setf pod

" Php, php3, php4, etc.
" Also Phtml (was used for PHP 2 in the past)
" Also .ctp for Cake template file
au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php

" Pike
au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike

" Pinfo config
au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo

" Palm Resource compiler
au BufNewFile,BufRead *.rcp			setf pilrc

" Pine config
au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine

" PL/1, PL/I
au BufNewFile,BufRead *.pli,*.pl1		setf pli

" PL/M (also: *.inp)
au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm

" PL/SQL
au BufNewFile,BufRead *.pls,*.plsql		setf plsql

" PLP
au BufNewFile,BufRead *.plp			setf plp

" PO and PO template (GNU gettext)
au BufNewFile,BufRead *.po,*.pot		setf po

" Postfix main config
au BufNewFile,BufRead main.cf			setf pfmain

" PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr

" PostScript Printer Description
au BufNewFile,BufRead *.ppd			setf ppd

" Povray
au BufNewFile,BufRead *.pov			setf pov

" Povray configuration
au BufNewFile,BufRead .povrayrc			setf povini

" Povray, PHP or assembly
au BufNewFile,BufRead *.inc			call s:FTinc()

func! s:FTinc()
  if exists("g:filetype_inc")
    exe "setf " . g:filetype_inc
  else
    let lines = getline(1).getline(2).getline(3)
    if lines =~? "perlscript"
      setf aspperl
    elseif lines =~ "<%"
      setf aspvbs
    elseif lines =~ "<?"
      setf php
    else
      call s:FTasmsyntax()
      if exists("b:asmsyntax")
	exe "setf " . fnameescape(b:asmsyntax)
      else
	setf pov
      endif
    endif
  endif
endfunc

" Printcap and Termcap
au BufNewFile,BufRead *printcap
	\ let b:ptcap_type = "print" | setf ptcap
au BufNewFile,BufRead *termcap
	\ let b:ptcap_type = "term" | setf ptcap

" PCCTS / ANTRL
"au BufNewFile,BufRead *.g			setf antrl
au BufNewFile,BufRead *.g			setf pccts

" PPWizard
au BufNewFile,BufRead *.it,*.ih			setf ppwiz

" Obj 3D file format
" TODO: is there a way to avoid MS-Windows Object files?
au BufNewFile,BufRead *.obj			setf obj

" Oracle Pro*C/C++
au BufNewFile,BufRead *.pc			setf proc

" Privoxy actions file
au BufNewFile,BufRead *.action			setf privoxy

" Procmail
au BufNewFile,BufRead .procmail,.procmailrc	setf procmail

" Progress or CWEB
au BufNewFile,BufRead *.w			call s:FTprogress_cweb()

func! s:FTprogress_cweb()
  if exists("g:filetype_w")
    exe "setf " . g:filetype_w
    return
  endif
  if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
    setf progress
  else
    setf cweb
  endif
endfunc

" Progress or assembly
au BufNewFile,BufRead *.i			call s:FTprogress_asm()

func! s:FTprogress_asm()
  if exists("g:filetype_i")
    exe "setf " . g:filetype_i
    return
  endif
  " This function checks for an assembly comment the first ten lines.
  " If not found, assume Progress.
  let lnum = 1
  while lnum <= 10 && lnum < line('$')
    let line = getline(lnum)
    if line =~ '^\s*;' || line =~ '^\*'
      call s:FTasm()
      return
    elseif line !~ '^\s*$' || line =~ '^/\*'
      " Not an empty line: Doesn't look like valid assembly code.
      " Or it looks like a Progress /* comment
      break
    endif
    let lnum = lnum + 1
  endw
  setf progress
endfunc

" Progress or Pascal
au BufNewFile,BufRead *.p			call s:FTprogress_pascal()

func! s:FTprogress_pascal()
  if exists("g:filetype_p")
    exe "setf " . g:filetype_p
    return
  endif
  " This function checks for valid Pascal syntax in the first ten lines.
  " Look for either an opening comment or a program start.
  " If not found, assume Progress.
  let lnum = 1
  while lnum <= 10 && lnum < line('$')
    let line = getline(lnum)
    if line =~ '^\s*\(program\|unit\|procedure\|function\|const\|type\|var\)\>'
	\ || line =~ '^\s*{' || line =~ '^\s*(\*'
      setf pascal
      return
    elseif line !~ '^\s*$' || line =~ '^/\*'
      " Not an empty line: Doesn't look like valid Pascal code.
      " Or it looks like a Progress /* comment
      break
    endif
    let lnum = lnum + 1
  endw
  setf progress
endfunc


" Software Distributor Product Specification File (POSIX 1387.2-1995)
au BufNewFile,BufRead *.psf			setf psf
au BufNewFile,BufRead INDEX,INFO
	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
	\   setf psf |
	\ endif

" Prolog
au BufNewFile,BufRead *.pdb			setf prolog

" Promela
au BufNewFile,BufRead *.pml			setf promela

" Google protocol buffers
au BufNewFile,BufRead *.proto			setf proto

" Protocols
au BufNewFile,BufRead */etc/protocols		setf protocols

" Pyrex
au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex

" Python
au BufNewFile,BufRead *.py,*.pyw		setf python

" Quixote (Python-based web framework)
au BufNewFile,BufRead *.ptl			setf python

" Radiance
au BufNewFile,BufRead *.rad,*.mat		setf radiance

" Ratpoison config/command files
au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison

" RCS file
au BufNewFile,BufRead *\,v			setf rcs

" Readline
au BufNewFile,BufRead .inputrc,inputrc		setf readline

" Registry for MS-Windows
au BufNewFile,BufRead *.reg
	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif

" Renderman Interface Bytestream
au BufNewFile,BufRead *.rib			setf rib

" Rexx
au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx

" R (Splus)
if has("fname_case")
  au BufNewFile,BufRead *.s,*.S			setf r
else
  au BufNewFile,BufRead *.s			setf r
endif

" R Help file
if has("fname_case")
  au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
else
  au BufNewFile,BufRead *.rd			setf rhelp
endif

" R noweb file
if has("fname_case")
  au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
else
  au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
endif

" R Markdown file
if has("fname_case")
  au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
else
  au BufNewFile,BufRead *.rmd,*.smd			setf rmd
endif

" R reStructuredText file
if has("fname_case")
  au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
else
  au BufNewFile,BufRead *.rrst,*.srst			setf rrst
endif

" Rexx, Rebol or R
au BufNewFile,BufRead *.r,*.R			call s:FTr()

func! s:FTr()
  let max = line("$") > 50 ? 50 : line("$")

  for n in range(1, max)
    " Rebol is easy to recognize, check for that first
    if getline(n) =~? '\<REBOL\>'
      setf rebol
      return
    endif
  endfor

  for n in range(1, max)
    " R has # comments
    if getline(n) =~ '^\s*#'
      setf r
      return
    endif
    " Rexx has /* comments */
    if getline(n) =~ '^\s*/\*'
      setf rexx
      return
    endif
  endfor

  " Nothing recognized, use user default or assume Rexx
  if exists("g:filetype_r")
    exe "setf " . g:filetype_r
  else
    " Rexx used to be the default, but R appears to be much more popular.
    setf r
  endif
endfunc

" Remind
au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind

" Resolv.conf
au BufNewFile,BufRead resolv.conf		setf resolv

" Relax NG Compact
au BufNewFile,BufRead *.rnc			setf rnc

" Relax NG XML
au BufNewFile,BufRead *.rng			setf rng

" RPL/2
au BufNewFile,BufRead *.rpl			setf rpl

" Robots.txt
au BufNewFile,BufRead robots.txt		setf robots

" Rpcgen
au BufNewFile,BufRead *.x			setf rpcgen

" reStructuredText Documentation Format
au BufNewFile,BufRead *.rst			setf rst

" RTF
au BufNewFile,BufRead *.rtf			setf rtf

" Interactive Ruby shell
au BufNewFile,BufRead .irbrc,irbrc		setf ruby

" Ruby
au BufNewFile,BufRead *.rb,*.rbw		setf ruby

" RubyGems
au BufNewFile,BufRead *.gemspec			setf ruby

" Rackup
au BufNewFile,BufRead *.ru			setf ruby

" Bundler
au BufNewFile,BufRead Gemfile			setf ruby

" Ruby on Rails
au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby

" Rantfile and Rakefile is like Ruby
au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby

" S-lang (or shader language, or SmallLisp)
au BufNewFile,BufRead *.sl			setf slang

" Samba config
au BufNewFile,BufRead smb.conf			setf samba

" SAS script
au BufNewFile,BufRead *.sas			setf sas

" Sass
au BufNewFile,BufRead *.sass			setf sass

" Sather
au BufNewFile,BufRead *.sa			setf sather

" Scilab
au BufNewFile,BufRead *.sci,*.sce		setf scilab

" SCSS
au BufNewFile,BufRead *.scss			setf scss

" SD: Streaming Descriptors
au BufNewFile,BufRead *.sd			setf sd

" SDL
au BufNewFile,BufRead *.sdl,*.pr		setf sdl

" sed
au BufNewFile,BufRead *.sed			setf sed

" Sieve (RFC 3028)
au BufNewFile,BufRead *.siv			setf sieve

" Sendmail
au BufNewFile,BufRead sendmail.cf		setf sm

" Sendmail .mc files are actually m4.  Could also be MS Message text file.
au BufNewFile,BufRead *.mc			call s:McSetf()

func! s:McSetf()
  " Rely on the file to start with a comment.
  " MS message text files use ';', Sendmail files use '#' or 'dnl'
  for lnum in range(1, min([line("$"), 20]))
    let line = getline(lnum)
    if line =~ '^\s*\(#\|dnl\)'
      setf m4  " Sendmail .mc file
      return
    elseif line =~ '^\s*;'
      setf msmessages  " MS Message text file
      return
    endif
  endfor
  setf m4  " Default: Sendmail .mc file
endfunc

" Services
au BufNewFile,BufRead */etc/services		setf services

" Service Location config
au BufNewFile,BufRead */etc/slp.conf		setf slpconf

" Service Location registration
au BufNewFile,BufRead */etc/slp.reg		setf slpreg

" Service Location SPI
au BufNewFile,BufRead */etc/slp.spi		setf slpspi

" Setserial config
au BufNewFile,BufRead */etc/serial.conf		setf setserial

" SGML
au BufNewFile,BufRead *.sgm,*.sgml
	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
	\   setf sgmllnx |
	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
	\   let b:docbk_type = "sgml" |
	\   let b:docbk_ver = 4 |
	\   setf docbk |
	\ else |
	\   setf sgml |
	\ endif

" SGMLDECL
au BufNewFile,BufRead *.decl,*.dcl,*.dec
	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
	\    setf sgmldecl |
	\ endif

" SGML catalog file
au BufNewFile,BufRead catalog			setf catalog
au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')

" Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
" Gentoo ebuilds are actually bash scripts
au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")
au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))

" Also called from scripts.vim.
func! SetFileTypeSH(name)
  if expand("<amatch>") =~ g:ft_ignore_pat
    return
  endif
  if a:name =~ '\<csh\>'
    " Some .sh scripts contain #!/bin/csh.
    call SetFileTypeShell("csh")
    return
  elseif a:name =~ '\<tcsh\>'
    " Some .sh scripts contain #!/bin/tcsh.
    call SetFileTypeShell("tcsh")
    return
  elseif a:name =~ '\<zsh\>'
    " Some .sh scripts contain #!/bin/zsh.
    call SetFileTypeShell("zsh")
    return
  elseif a:name =~ '\<ksh\>'
    let b:is_kornshell = 1
    if exists("b:is_bash")
      unlet b:is_bash
    endif
    if exists("b:is_sh")
      unlet b:is_sh
    endif
  elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
    let b:is_bash = 1
    if exists("b:is_kornshell")
      unlet b:is_kornshell
    endif
    if exists("b:is_sh")
      unlet b:is_sh
    endif
  elseif a:name =~ '\<sh\>'
    let b:is_sh = 1
    if exists("b:is_kornshell")
      unlet b:is_kornshell
    endif
    if exists("b:is_bash")
      unlet b:is_bash
    endif
  endif
  call SetFileTypeShell("sh")
endfunc

" For shell-like file types, check for an "exec" command hidden in a comment,
" as used for Tcl.
" Also called from scripts.vim, thus can't be local to this script.
func! SetFileTypeShell(name)
  if expand("<amatch>") =~ g:ft_ignore_pat
    return
  endif
  let l = 2
  while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
    " Skip empty and comment lines.
    let l = l + 1
  endwhile
  if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
    " Found an "exec" line after a comment with continuation
    let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
    if n =~ '\<tclsh\|\<wish'
      setf tcl
      return
    endif
  endif
  exe "setf " . a:name
endfunc

" tcsh scripts
au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call SetFileTypeShell("tcsh")

" csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()

func! s:CSH()
  if exists("g:filetype_csh")
    call SetFileTypeShell(g:filetype_csh)
  elseif &shell =~ "tcsh"
    call SetFileTypeShell("tcsh")
  else
    call SetFileTypeShell("csh")
  endif
endfunc

" Z-Shell script
au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
au BufNewFile,BufRead *.zsh			setf zsh

" Scheme
au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme

" Screen RC
au BufNewFile,BufRead .screenrc,screenrc	setf screen

" Simula
au BufNewFile,BufRead *.sim			setf simula

" SINDA
au BufNewFile,BufRead *.sin,*.s85		setf sinda

" SiSU
au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu

" SKILL
au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill

" SLRN
au BufNewFile,BufRead .slrnrc			setf slrnrc
au BufNewFile,BufRead *.score			setf slrnsc

" Smalltalk (and TeX)
au BufNewFile,BufRead *.st			setf st
au BufNewFile,BufRead *.cls
	\ if getline(1) =~ '^%' |
	\  setf tex |
	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
	\  setf rexx |
	\ else |
	\  setf st |
	\ endif

" Smarty templates
au BufNewFile,BufRead *.tpl			setf smarty

" SMIL or XML
au BufNewFile,BufRead *.smil
	\ if getline(1) =~ '<?\s*xml.*?>' |
	\   setf xml |
	\ else |
	\   setf smil |
	\ endif

" SMIL or SNMP MIB file
au BufNewFile,BufRead *.smi
	\ if getline(1) =~ '\<smil\>' |
	\   setf smil |
	\ else |
	\   setf mib |
	\ endif

" SMITH
au BufNewFile,BufRead *.smt,*.smith		setf smith

" Snobol4 and spitbol
au BufNewFile,BufRead *.sno,*.spt		setf snobol4

" SNMP MIB files
au BufNewFile,BufRead *.mib,*.my		setf mib

" Snort Configuration
au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
au BufNewFile,BufRead *.rules			call s:FTRules()

let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
func! s:FTRules()
  let path = expand('<amatch>:p')
  if path =~ '^/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
    setf udevrules
    return
  endif
  if path =~ '^/etc/ufw/'
    setf conf  " Better than hog
    return
  endif
  try
    let config_lines = readfile('/etc/udev/udev.conf')
  catch /^Vim\%((\a\+)\)\=:E484/
    setf hog
    return
  endtry
  let dir = expand('<amatch>:p:h')
  for line in config_lines
    if line =~ s:ft_rules_udev_rules_pattern
      let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
      if dir == udev_rules
        setf udevrules
      endif
      break
    endif
  endfor
  setf hog
endfunc


" Spec (Linux RPM)
au BufNewFile,BufRead *.spec			setf spec

" Speedup (AspenTech plant simulator)
au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup

" Slice
au BufNewFile,BufRead *.ice			setf slice

" Spice
au BufNewFile,BufRead *.sp,*.spice		setf spice

" Spyce
au BufNewFile,BufRead *.spy,*.spi		setf spyce

" Squid
au BufNewFile,BufRead squid.conf		setf squid

" SQL for Oracle Designer
au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql

" SQL
au BufNewFile,BufRead *.sql			call s:SQL()

func! s:SQL()
  if exists("g:filetype_sql")
    exe "setf " . g:filetype_sql
  else
    setf sql
  endif
endfunc

" SQLJ
au BufNewFile,BufRead *.sqlj			setf sqlj

" SQR
au BufNewFile,BufRead *.sqr,*.sqi		setf sqr

" OpenSSH configuration
au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig

" OpenSSH server configuration
au BufNewFile,BufRead sshd_config		setf sshdconfig

" Stata
au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata

" SMCL
au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl

" Stored Procedures
au BufNewFile,BufRead *.stp			setf stp

" Standard ML
au BufNewFile,BufRead *.sml			setf sml

" Sratus VOS command macro
au BufNewFile,BufRead *.cm			setf voscm

" Sysctl
au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl

" Synopsys Design Constraints
au BufNewFile,BufRead *.sdc			setf sdc

" Sudoers
au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers

" SVG (Scalable Vector Graphics)
au BufNewFile,BufRead *.svg			setf svg

" If the file has an extension of 't' and is in a directory 't' or 'xt' then
" it is almost certainly a Perl test file.
" If the first line starts with '#' and contains 'perl' it's probably a Perl
" file.
" (Slow test) If a file contains a 'use' statement then it is almost certainly
" a Perl file.
func! s:FTperl()
  let dirname = expand("%:p:h:t")
  if expand("%:e") == 't' && (dirname == 't' || dirname == 'xt')
    setf perl
    return 1
  endif
  if getline(1)[0] == '#' && getline(1) =~ 'perl'
    setf perl
    return 1
  endif
  if search('^use\s\s*\k', 'nc', 30)
    setf perl
    return 1
  endif
  return 0
endfunc

" Tads (or Nroff or Perl test file)
au BufNewFile,BufRead *.t
	\ if !s:FTnroff() && !s:FTperl() | setf tads | endif

" Tags
au BufNewFile,BufRead tags			setf tags

" TAK
au BufNewFile,BufRead *.tak			setf tak

" Task
au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
au BufRead,BufNewFile *.task			setf taskedit

" Tcl (JACL too)
au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl

" TealInfo
au BufNewFile,BufRead *.tli			setf tli

" Telix Salt
au BufNewFile,BufRead *.slt			setf tsalt

" Terminfo
au BufNewFile,BufRead *.ti			setf terminfo

" TeX
au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
au BufNewFile,BufRead *.tex			call s:FTtex()

" Choose context, plaintex, or tex (LaTeX) based on these rules:
" 1. Check the first line of the file for "%&<format>".
" 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
" 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
func! s:FTtex()
  let firstline = getline(1)
  if firstline =~ '^%&\s*\a\+'
    let format = tolower(matchstr(firstline, '\a\+'))
    let format = substitute(format, 'pdf', '', '')
    if format == 'tex'
      let format = 'plain'
    endif
  else
    " Default value, may be changed later:
    let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
    " Save position, go to the top of the file, find first non-comment line.
    let save_cursor = getpos('.')
    call cursor(1,1)
    let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
    if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
      let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>\|part\>\|chapter\>\|section\>\|subsection\>\|subsubsection\>\|paragraph\>\|subparagraph\>\|subsubparagraph'
      let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
      let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
			      \ 'cnp', firstNC + 1000)
      if kwline == 1	" lpat matched
	let format = 'latex'
      elseif kwline == 2	" cpat matched
	let format = 'context'
      endif		" If neither matched, keep default set above.
      " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
      " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
      " if cline > 0
      "   let format = 'context'
      " endif
      " if lline > 0 && (cline == 0 || cline > lline)
      "   let format = 'tex'
      " endif
    endif " firstNC
    call setpos('.', save_cursor)
  endif " firstline =~ '^%&\s*\a\+'

  " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
  if format == 'plain'
    setf plaintex
  elseif format == 'context'
    setf context
  else " probably LaTeX
    setf tex
  endif
  return
endfunc

" ConTeXt
au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context

" Texinfo
au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo

" TeX configuration
au BufNewFile,BufRead texmf.cnf			setf texmf

" Tidy config
au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy

" TF mud client
au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf

" TPP - Text Presentation Program
au BufNewFile,BufReadPost *.tpp			setf tpp

" Treetop
au BufRead,BufNewFile *.treetop			setf treetop

" Trustees
au BufNewFile,BufRead trustees.conf		setf trustees

" TSS - Geometry
au BufNewFile,BufReadPost *.tssgm		setf tssgm

" TSS - Optics
au BufNewFile,BufReadPost *.tssop		setf tssop

" TSS - Command Line (temporary)
au BufNewFile,BufReadPost *.tsscl		setf tsscl

" TWIG files
au BufNewFile,BufReadPost *.twig		setf twig

" Motif UIT/UIL files
au BufNewFile,BufRead *.uit,*.uil		setf uil

" Udev conf
au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf

" Udev permissions
au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
"
" Udev symlinks config
au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh

" UnrealScript
au BufNewFile,BufRead *.uc			setf uc

" Updatedb
au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb

" Upstart (init(8)) config files
au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart

" Vera
au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera

" Verilog HDL
au BufNewFile,BufRead *.v			setf verilog

" Verilog-AMS HDL
au BufNewFile,BufRead *.va,*.vams		setf verilogams

" SystemVerilog
au BufNewFile,BufRead *.sv,*.svh		setf systemverilog

" VHDL
au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')

" Vim script
au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim

" Viminfo file
au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo

" Virata Config Script File or Drupal module
au BufRead,BufNewFile *.hw,*.module,*.pkg
	\ if getline(1) =~ '<?php' |
	\   setf php |
	\ else |
	\   setf virata |
	\ endif

" Visual Basic (also uses *.bas) or FORM
au BufNewFile,BufRead *.frm			call s:FTVB("form")

" SaxBasic is close to Visual Basic
au BufNewFile,BufRead *.sba			setf vb

" Vgrindefs file
au BufNewFile,BufRead vgrindefs			setf vgrindefs

" VRML V1.0c
au BufNewFile,BufRead *.wrl			setf vrml

" Vroom (vim testing and executable documentation)
au BufNewFile,BufRead *.vroom			setf vroom

" Webmacro
au BufNewFile,BufRead *.wm			setf webmacro

" Wget config
au BufNewFile,BufRead .wgetrc,wgetrc		setf wget

" Website MetaLanguage
au BufNewFile,BufRead *.wml			setf wml

" Winbatch
au BufNewFile,BufRead *.wbt			setf winbatch

" WSML
au BufNewFile,BufRead *.wsml			setf wsml

" WvDial
au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial

" CVS RC file
au BufNewFile,BufRead .cvsrc			setf cvsrc

" CVS commit file
au BufNewFile,BufRead cvs\d\+			setf cvs

" WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
" lines in a WEB file).
au BufNewFile,BufRead *.web
	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
	\   setf web |
	\ else |
	\   setf winbatch |
	\ endif

" Windows Scripting Host and Windows Script Component
au BufNewFile,BufRead *.ws[fc]			setf wsh

" XHTML
au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml

" X Pixmap (dynamically sets colors, use BufEnter to make it work better)
au BufEnter *.xpm
	\ if getline(1) =~ "XPM2" |
	\   setf xpm2 |
	\ else |
	\   setf xpm |
	\ endif
au BufEnter *.xpm2				setf xpm2

" XFree86 config
au BufNewFile,BufRead XF86Config
	\ if getline(1) =~ '\<XConfigurator\>' |
	\   let b:xf86conf_xfree86_version = 3 |
	\ endif |
	\ setf xf86conf
au BufNewFile,BufRead */xorg.conf.d/*.conf
	\ let b:xf86conf_xfree86_version = 4 |
	\ setf xf86conf

" Xorg config
au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf

" Xinetd conf
au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd

" XS Perl extension interface language
au BufNewFile,BufRead *.xs			setf xs

" X resources file
au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults

" Xmath
au BufNewFile,BufRead *.msc,*.msf		setf xmath
au BufNewFile,BufRead *.ms
	\ if !s:FTnroff() | setf xmath | endif

" XML  specific variants: docbk and xbl
au BufNewFile,BufRead *.xml			call s:FTxml()

func! s:FTxml()
  let n = 1
  while n < 100 && n < line("$")
    let line = getline(n)
    " DocBook 4 or DocBook 5.
    let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
    let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
    if is_docbook4 || is_docbook5
      let b:docbk_type = "xml"
      if is_docbook5
	let b:docbk_ver = 5
      else
	let b:docbk_ver = 4
      endif
      setf docbk
      return
    endif
    if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
      setf xbl
      return
    endif
    let n += 1
  endwhile
  setf xml
endfunc

" XMI (holding UML models) is also XML
au BufNewFile,BufRead *.xmi			setf xml

" CSPROJ files are Visual Studio.NET's XML-based project config files
au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml

" Qt Linguist translation source and Qt User Interface Files are XML
au BufNewFile,BufRead *.ts,*.ui			setf xml

" TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
au BufNewFile,BufRead *.tpm			setf xml

" Xdg menus
au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml

" ATI graphics driver configuration
au BufNewFile,BufRead fglrxrc			setf xml

" XLIFF (XML Localisation Interchange File Format) is also XML
au BufNewFile,BufRead *.xlf			setf xml
au BufNewFile,BufRead *.xliff			setf xml

" XML User Interface Language
au BufNewFile,BufRead *.xul			setf xml

" X11 xmodmap (also see below)
au BufNewFile,BufRead *Xmodmap			setf xmodmap

" Xquery
au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery

" XSD
au BufNewFile,BufRead *.xsd			setf xsd

" Xslt
au BufNewFile,BufRead *.xsl,*.xslt		setf xslt

" Yacc
au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc

" Yacc or racc
au BufNewFile,BufRead *.y			call s:FTy()

func! s:FTy()
  let n = 1
  while n < 100 && n < line("$")
    let line = getline(n)
    if line =~ '^\s*%'
      setf yacc
      return
    endif
    if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
      setf racc
      return
    endif
    let n = n + 1
  endwhile
  setf yacc
endfunc


" Yaml
au BufNewFile,BufRead *.yaml,*.yml		setf yaml

" yum conf (close enough to dosini)
au BufNewFile,BufRead */etc/yum.conf		setf dosini

" Zimbu
au BufNewFile,BufRead *.zu			setf zimbu

" Zope
"   dtml (zope dynamic template markup language), pt (zope page template),
"   cpt (zope form controller page template)
au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call s:FThtml()
"   zsql (zope sql method)
au BufNewFile,BufRead *.zsql			call s:SQL()

" Z80 assembler asz80
au BufNewFile,BufRead *.z8a			setf z8a

augroup END


" Source the user-specified filetype file, for backwards compatibility with
" Vim 5.x.
if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
  execute "source " . myfiletypefile
endif


" Check for "*" after loading myfiletypefile, so that scripts.vim is only used
" when there are no matching file name extensions.
" Don't do this for compressed files.
augroup filetypedetect
au BufNewFile,BufRead *
	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
	\ | runtime! scripts.vim | endif
au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif


" Extra checks for when no filetype has been detected now.  Mostly used for
" patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
" script file.
" Most of these should call s:StarSetf() to avoid names ending in .gz and the
" like are used.

" More Apache config files
au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')

" Asterisk config file
au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')

" Bazaar version control
au BufNewFile,BufRead bzr_log.*			setf bzr

" BIND zone
au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')

" Calendar
au BufNewFile,BufRead */.calendar/*,
	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
	\					call s:StarSetf('calendar')

" Changelog
au BufNewFile,BufRead [cC]hange[lL]og*
	\ if getline(1) =~ '; urgency='
	\|  call s:StarSetf('debchangelog')
	\|else
	\|  call s:StarSetf('changelog')
	\|endif

" Crontab
au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')

" dnsmasq(8) configuration
au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')

" Dracula
au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')

" Fvwm
au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
au BufNewFile,BufRead *fvwm2rc*
	\ if expand("<afile>:e") == "m4"
	\|  call s:StarSetf('fvwm2m4')
	\|else
	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
	\|endif

" Gedcom
au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')

" GTK RC
au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')

" Jam
au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')

" Jargon
au! BufNewFile,BufRead *jarg*
	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
	\|  call s:StarSetf('jargon')
	\|endif

" Kconfig
au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')

" Lilo: Linux loader
au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')

" Logcheck
au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')

" Makefile
au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')

" Ruby Makefile
au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')

" Mail (also matches muttrc.vim, so this is below the other checks)
au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}	setf mail

" Modconf
au BufNewFile,BufRead */etc/modutils/*
	\ if executable(expand("<afile>")) != 1
	\|  call s:StarSetf('modconf')
	\|endif
au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')

" Mutt setup file
au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')

" Nroff macros
au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')

" Pam conf
au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')

" Printcap and Termcap
au BufNewFile,BufRead *printcap*
	\ if !did_filetype()
	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
	\|endif
au BufNewFile,BufRead *termcap*
	\ if !did_filetype()
	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
	\|endif

" ReDIF
" Only used when the .rdf file was not detected to be XML.
au BufRead,BufNewFile *.rdf			call s:Redif()
func! s:Redif()
  let lnum = 1
  while lnum <= 5 && lnum < line('$')
    if getline(lnum) =~ "^\ctemplate-type:"
      setf redif
      return
    endif
    let lnum = lnum + 1
  endwhile
endfunc

" Remind
au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')

" Vim script
au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')

" Subversion commit file
au BufNewFile,BufRead svn-commit*.tmp		setf svn

" X resources file
au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')

" XFree86 config
au BufNewFile,BufRead XF86Config-4*
	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
au BufNewFile,BufRead XF86Config*
	\ if getline(1) =~ '\<XConfigurator\>'
	\|  let b:xf86conf_xfree86_version = 3
	\|endif
	\|call s:StarSetf('xf86conf')

" X11 xmodmap
au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')

" Xinetd conf
au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')

" yum conf (close enough to dosini)
au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')

" Z-Shell script
au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')


" Plain text files, needs to be far down to not override others.  This avoids
" the "conf" type being used if there is a line starting with '#'.
au BufNewFile,BufRead *.txt,*.text,README	setf text


" Use the filetype detect plugins.  They may overrule any of the previously
" detected filetypes.
runtime! ftdetect/*.vim

" NOTE: The above command could have ended the filetypedetect autocmd group
" and started another one. Let's make sure it has ended to get to a consistent
" state.
augroup END

" Generic configuration file (check this last, it's just guessing!)
au filetypedetect BufNewFile,BufRead,StdinReadPost *
	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
	\   setf conf |
	\ endif


" If the GUI is already running, may still need to install the Syntax menu.
" Don't do it when the 'M' flag is included in 'guioptions'.
if has("menu") && has("gui_running")
      \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
  source <sfile>:p:h/menu.vim
endif

" Function called for testing all functions defined here.  These are
" script-local, thus need to be executed here.
" Returns a string with error messages (hopefully empty).
func! TestFiletypeFuncs(testlist)
  let output = ''
  for f in a:testlist
    try
      exe f
    catch
      let output = output . "\n" . f . ": " . v:exception
    endtry
  endfor
  return output
endfunc

" Restore 'cpoptions'
let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   [rFuvǖG;Ye$+Vl@I"T ${Rd*?\(t~{u/q0pphd8{'YUwє3EW'ox)^Uh.eEXGsYN?u?Eir+&t*K_r7&f.3I$(/˦e,,AB8JJVcmG۴w>O3R߇,:ʗ/?/U{Ll
qgYX
.lgc{(3oj"5Qɨ)z<7,"$4H*d<D:LX2s*z4L<p-ʉ96g>lv0=_XqXԢU]ul=JF"edQ7i,-^]K.r)9,.x e߰lwVQư/d_ƮsUUNrGYyn,)|6K|*V'Ȑ"/$8gMOϥT<f?W(A#{TeLRD!,*o21m_{/E6$BzC?4r_8VFc# baQ7	bFf-[B^Հ2kOE_g$75ɁBdI~ ^UddCEN$&eC7eVػ7"?s,"u:i5y!]WwFNoY|ݯR 4EYzh}~EvǦu\tBEx%QAzE8!痉~4e=Q)2QUlaEsQZf1IR*Z]?BȾ\ yFY8#XF~F(CyHT2 O#X-{7plc> Zf̚ gX4}DbY]yA6F
gZ|x##گKrToۯsd4UyPRgsR&/P4(	<mA3wWX=aT7Вq=?u#/~o!V3}{Vl=rIu`>DCTVVHȪ-8$fz O4*&uZwms Y])u9wksjh*^w.n% ">))Y-RaxAL	<o\\͌	4g/"-XԧI3Ʃ+Ԫ:k(r5*eYam43
$+##Ts`~zxg2Z%zŒ(U(s&l**10z-Ȣo}C~a;p&Zv+JB^+\YBO;-~r~`m5^UwAXEfś6t,o=pc$FPLdy^*O׆e)mMO4`%aT'OPxzj=o #}uYn+b´(/	QpD*$ 9fKnʴAF:Y{67}6smKֱ	&2(EE2]3(~7%\sZBfL@*ho82Ql=s{18K1A|%(UJNQF1a!gdbprtxUfQvLՕ 'ãI7xKI|qv@=vAWfp[ Ӓ܂GW%cLkh&PԟvuߠU3Xtߛɺ79ukudD\_I1ANW5	7wd8\{0GpVQ(eo)S'Gy6MfчoO,)_q?o]JS'zdg!$v=
e{;&!Xn9*9ۚp{Nm"Jab.ZZ,ZAwHk8ee9fFeWi|MCv!@e2iVUË7w:Dǵ}ՌfQHϨ굝h틬IXƫo˭Þ#vkVNuIzJۤoӳp<aN4-xL!.ʙM<7JSVZˣcK:abk0e@EU9(FETӳtA7yL$R A,o;Y".hm	lSm=$3M)fN
SIF%1M$EJF08	WlDp`5VEMۥw1qo2L@jЀ>WJ^2e۷HT\5%]&zZ5rv1"yo
2\<:\7`*H]ƢD,Y;EmɖjX#2wAu9=NL|$LcQ]hhXf~5\}~A{O&gx1>&Oj@PH"y\גbR_(&Rɑ*dxDEvQC=;FS.{E5 XatP¹@-hnefe8nsaQs{b`*-AI2*&KdӜ2?^R־ۈGDV>,LtLЇfm͇lDV!AiDX^s	=Y%O'rpullnͲpʮoאfhd=QS!m?PY@oK`4FMB ]``̑a.a>䟞֋01>թ'ļF{o_l(eƸ :NOnGC=Mͼi4&'^b&?˯LUcݿ*huʷhh:,x]EbrQKPQ֊޽c 5ZpO*н,WX^|~
CnVK`C9M	8d}	2D=dfY7FSgf?]^\m|g4!4E}>7/Sp$|bs,:T"+('ԱMJE}wĖQa>~8)kN}/G#+WMIVB(ƳmoCɋdQt)5dIv7!ߞ
4*:ɟRз|W|"pBr[c%Ց-o,S]yYKģl?upr=wM8n'PCk\[>94ieOޞeDݳ=ngơ#Ŵ<k6Jjjñ߳Ƨ4r'Ey34H"1^W#Ѽ9ҷݕ
0@ZTd:׉8Dtbx_^	s"dRQ}z=@$,W+:{hoK5 jsi@vY;ȡP;@Cz2q?SݸEIrDdzY,D)/r*&	!LNbyBQ7!pXc2.LRQ0HAK̠j3չ_>a#L!SSQ**}T1>E=1ˢxBUh% 
hwEjyZ$LI 	25JC<{sfn`Kz
Jao(枵[Q9j @sUGG8v,_W5B5VBiniw;|sw4Mww}TXw'x47TٔP+.G~nx D	ĺQ:zu-=$	nqʀTN/؀M/N X^cޱ=5zz/%ZI\kJ8ޖX>C`?V)u1;U;(X!:̲獛~0l{GZ^+7|y.Gc;4N駻stGD";:Eo4~2\ oYytW+"O]U {6ݵoduQs[${y?ya$,/
U&l}x:(Ur,wlkgF|1~L1^P~uaLqn8WŇ1|t5y$tՉ"CWmGW;&TbsBŌT3cBb5믚"ڽHEPܼW\<X٧R.	%2N<#^O߼==|w49-Mc,I(ǚ9nӰ|wDp|uUOM0VDa'|  &	hnw>LzuzZsMUsiB\\N9Ne-BL l_Ns`"pȍN3Ř|!jI~hMtr-AK N%Ü˴$keuvsj|m,|%nۆ|a=r#.=D"RTY5G,EM>OQCU-Hj]	mT;|/1"($*X"p(z+eNWb,;:4U7__=%궾fd`Uc-
!*U\{U$u節Zq_k(B[ħ,m+_\Bw}x 6Sx"b:r߯ҟuajY#5zFȸэX&*;'++tp~}f	_s'}n)%[`s;)pJo Qi3$rFFQ&9}OR*Af$w9a^I47 `@_CJֽ1t޻JJZ& º[+u	rƴW6]??X\F%i{*,"C=i+PFe{p^c4kEOԅ9NanaJ'y/i2ɢ=zM)\[s{JpװtǦ[y``#ENVXT1hzvس yt:5NЩ|q];i豆Ń;,K{}3 ScTm|i[@w]}iuyˮ=*N_~wp3I޴h
GXm"ԝ9`>EG5;Z1SQ'wCEȞйR&k$oS%Ց
AB:Gn.EM ||~qKm+K LT\Z&GPj n;?nJD{=BYtJh#t>C>5d)u@ZS ҩH~^ozyZ"${08yVum۶V\9=KC#.3!c>Ct/_=={go}G=*}ݖ$,˽AoLMAe)čy(1UM$Tx/grp@Np2fJ\guY7[$q0kC?F Qwx'0lvA	Ʊ*תyԖvpZ/Ҹ|('(\h7"=W*)CkLu;{~([u5扆iM'>qD+l?l֓k̖\K|J7^m0jZW9h
Mgw褟h=dB"^wUk%UެRY
x7^_(]Z
]ސDTt/<p:HI"G/Faҳrn$
J
+.[T9|8܀L^My~"JEu<^#^kd:`~)Y4Ahi7	T`,콐&]!ˠr!V7	Iv
o%&̰
Vݺ-$6$D
m5y:hX9᤭ B fs\GTM=@]e[3K0vM`YK:Vh,poHYNiߵ5U=AsglDMa$4fA1diK$j@r!+_I	&T~Qj
':A7H>!ȁJ~5*NgfbčpXHfd[r$^FG_(a.-nB'
=Qm.)we~r6L(Sra,9R<l4i(]!z|;13Ӳ>.0#]7u!W&ő(^$ehWhXpS`b*
	WXNFߊ"$%3pZa.}@jf`q2{{hS}{+'/ə_:]rlo4jJHX!
}qGl=۾E9I♓ :Q0wg/_yIJ@N8>l+,+gԗ,nn',vw`.&3%nAs05lLP˛P %֘ATUFC$CP :OPzw~qçZuuvi_v;jM3jmE|'TJ'7Dc6tkŴ`TY@\/G|-LD\DkDAL}y8'g.#;л`N^3%
Bh!^ODDkm<&}dybڍmjGC-oS]7*1K#j(+7/;{RQu%$6l\K6Od9mZc\h{A^? 5)+E*¶	JF_-ޠo+SM:)Z^LVJu {ŭL#4;jRM88>=Qh4Ũ\L8Dr)%ǜsu ' w`%|xum8GK%Zj7U00LS-䰖	V])%x*	b}>%-':>!X3gA\.}Y!$BʫFӾذau[AVaԟNQc! B&Q),ɺx$KyD"$I{7V 6
(ZdK!p/ߟ<&B1\zXkRY6%~1?~.vsL1 ;j ߾=pɷgoO]}`{=aHk܌HPڦ)9ZO	a\
3IeԈǩpP|7E+Ba`V1s9r~a	V.^eⓥ؈r9|+B~2sY&fMʃ[XGC5XX!Y42'L<NTRTξ΃8yiY(vKt),ɓ$\ $#V֌]㢎#j`[W
O0f΍nX )~i=\MדiA$Mf93pz]ϦV%X0x?NR'GY}W}+)2Yǝo[,{\)b ;4}*Aɦ@Hx
մ	m%"fm:GzL͖D0l,޷ j%]~5KYy%ApC$P{D/!1mpyPJ0*9?Gk?xNPv w,[h4iCZՠ'NdDbiEwii$1{^Anv?8J1;z².X٥kQ(j?&"lx&kn&
nŒ_9f|Ajy& O\'ɾǀd1Q|1~a>tPxx	*򉪳~fJs @pEZ{)7Mj:pDm_p:Qd	sLxKB\Wz$oŴfwiBd5tXz|qѪξvPTj~#[8cWr)ls$6O˫0 GZHٝcS1suZdE1}ywҔ<hxQ~,A7	9_@+subf`&/]]s-	,T 2K[Ǎ$w/
b'O72@N!aĖ*iEN.=,A<|G9|Afi#$}$܍l;9=A|A yNd.D`7xL`Y:7䡍.g:Yu3mnAo83B)äw,qQoM&i/bMY/a/zYU:Vm¸?iw|]Mش
+gܮ\av8;s73GdX|ݱ=&N	vB<"BOY6*\
>@"W.Z߱=wcL]Bv˘0&N-cZ,2h+.OnBo14N:5qDJtr
M.wūqNU R/I6cxKsUJŝ&`#[HƓNפ$]pracM4Ec21m	:BIS9}EصAMT]Fh0 EɰQFM!?~"b`멈l?렽v{a´lPh9wjBr1>-0i٥k ;g9VQ)AH@њ7(Pp̅YNvI~Gq?wIF3\ڰUf$ny:шO8I°,Gz!c7?083R\go>pVcCg.>Eoj+8QǕ'fO^8~gz'afG<	35^larg:իbڿwjHm;^[
`+X䰁4}=T9:x(R$·b!ſo_W(/[55vޖGA	+yr^k?H`ϔLwoտm\h.V;Z]*Z Pdrp®EHnw.FJ]	N?롯c^gb)F&Dq7`XL	K^$'nCCVX{tDb(;P3s8iPl-XH3:XFRL/M	X5	|cδ5$#PDO_?C|6Y-dۈܹ{<Gx:	.hko3< ,~uTIH+s8<U9	+(O`,LiU	JKtiR(g!	^ťEH}8d
{Pn!g~>T(;O]I*5~NҼIU(g iq~H/xxZ~Sd5a7ۯO
*0M<rPJb܀ѸD+ k01n 4ݶnbn1<Fsl;_؂%$)6 ̙AT&aOvI07e.̜#Xgd;4څջM"S_хކKnנ"`%Qx(MNMw!ܴ?%]\fi5ۂ|<ȓ_ȿ+)-"5 BL<,/RPR[TUöEtK'x`k W f_YG_l*sKHWˤx$q(Xߟ|"<znwP=qŇ6sc	3v޸'Na+訢@v7!o`ZLӱaow"f)QIe!4u$'cy{ζ`I[-=D?{dIjCX9qpi#Qcx6jQǣQ")PwQD.녺ZH̰۶uL<Ny^.6s;cK>rL? |'9h<VrܡkU_b:vNNS@(ߺ}T7Z;I&D7Z?6M}x,
.e;?"I_?P#քw\`BYYf,KZ#;#a_$AuYĝOwD]zW|,&ŸǇ90`VB#\7
&P"td!qy}U⻭QV{
Z0Ш5?Ot
g%]f^y%GiO~׊5|Ac:.6cVJBIjR,2^mZg~qQ;zS`O}D3"߱ \𻲚9ǃtS)8c+Z9-C/I~bȎeRKȼ7O#Mi>JY	1řWv-+Z_7ᠬIELxXx6µ(ʮ{4uuuF֨o^<vS	
$}K~f")jnuA@&VGEMsPjYگI)]q/@s0tntVֺt:!UA悟~>}K#&ct!	ۯMh[W>wA)5wCX 8B"DnAL/-$e[Gߦ iyz +ƽI?~lpW#%L`bD	DBF*~;JA5ճ7`Z 9rcS~C-=ᨈBl)_)NxZf&+n0DsI F|=e`ф"ș;ҥ,18ʤwt;
Us54ESѵ۲How	jB$pbHFkJAbc|NBJQ\iSrkZ!DLzĉyeY/1nfVM2tmծs\?ǾxVYKE1±.c޴q.g6߹h%dpij4/QC>ݲy^c/7h'1`at*0B$!#˼Tlf*ˈ$ =s![d&Yc\v`4`ĀQpRsnΊWo:'C2W?dn.{n q>HLܠ3Ի_vsPܐ{i@^	e9)Ib5aMq38w\[31Q\KƔ~x}#ÇwnQkOQ0~@=7ngL1$btc;^m5m6Br.&}u-,UѠ۟&GͦQ#%'J%,D`%OHJˍ\*f
eN7`|&R|i'bR6E% P:bqQ]>sX	n<\t.Cy */%8Iؐߑbܝ'$;lvITh3&u2ФF;Ncy{s[Tz2e뜌(-v!^XJ!i"I@%Qaߍ:ݗ=i^b%9R^_?oKh$a4MX_b#Qq>$]!͋)H{)x8MwťKird?EޔA~h
-ܚ)F)魮l`ڈ0<ݸ+$J@GIn2GT}5G*F*	Ak.zd|\#6jNNը1:;#Y&c6^$#bէ(2>4c Y|ڰnF9,n_6[ƚ} _5$:LEe(YZwzS Ls6b`7#tߟ1m},gXZܮm,TPfA"Re4bs]H$tsTr:amX3lڅRP1?s!ma]%奅1jP4ڔ_0kiY.)x2V
1U;kcu(u6s+bƒ:ba<l!I|kR8H$r<\8jKxUlow熨TůE?SKCm3(uþ
b2}2Ug.M}Yjqyp̽_*C]Y`<#_uT"ڠ_O4f8 B!ȩwOF K·qҐF	{wJN' o2K]1h/n[0Zӥ:,dFCs/ZM&:Eԫp%MW݋,M/?=÷oߟ=}pqFE9<,(a1ș&,[]-ce<w
rb9Ucd	^Q'o}?7;|~Eăր/WEl;NtEE [,eB1Hm|SbC@'1ẋ!Og~4暄{`zQӻ +Hܿ#nLh5,Q7NØq*8IFx#wN-q<-dDJOFO%6d/JsfFQʪ	їG@c [F^hi(ȡZH!HQ*ʹ63}"$3);ҌuS(ej)`_Zr ""H#A3g85(Sj</7,3SD:yZPS:-4<J*`7?W6o=Wn:
bͿ!sA8"NI_1&
OT+b-DƤ;3r	 zIFkT4nP碎FcSĘgWSKXR{ʑoǍJDd4D 290*>-QSmJld*d?Le>mW@ ~e W	im[ \ܔsIlXP3[[6>/%ŪvUl+똀*	P{PYuN8!k	ƶ!2I?(	/hp|	6P+f[*FF軋{L-#:NO=٫wY!FliZ,ͦ 0;k~*[|&gnA[VBf7uvR,!?zWN?|!ê"țX(#Xʣg1V.5A^EqPWr!NQ1kS
eV怺4Kg
NPZ<.
mMW䗥 "V`'x<p{rE98YW*YkFݨjOe D߫$DE#!BM8
Ы	ՠFI@!RJV̦͡>{O2JzR+0]۳`3z롧0Vkx(.]琱HJ);"
ໆ=+:
64p!/ͳOž|XI@'MpaݳaxF")0d!xQ{~E7: iĀ8Xs$7 ?l䉇UQSWd9;QYZ8!|R8\ԫ;Sdx=c"$YE9 )3ݮ)>)bbV0`[yByϿ9nӇbySL(Vǲ-1{`ܙvȷuCO&6	_J=瞔8[\:n7*+f!9GBE.b_D9MvL
lÄ#:iieDHНq#3'w(\/+&A
Mv╩)/2SDnVL9MP%XQw8wæf!6ll|	cXr"֏hQa\RJ\lO}I¤J>/>|/
fZJpVkuvZیjs-ĸ5ǉ6!0vhOH)g
|/Sh|6:~ǋb6ӕ0[fi[**W?ޯe%Bbur+ziPo+BDD༅ኊ[YHC$G@Lmϵ#b!+ٍb{zYLC,fBtt~!}43eLH߂6HڷO![
_`fؔD+3YuL0˂( +5Άi-nлb2;
Gp{9L&%Lcx)[ch7FGeaqTQ6loRRگ%irUa8FjB-ҁ;_
1Zv3_7kEqh&X /ޣQ8E&ɨ*6(M	+'Ol@X*IFx~ngjLyBY )HN/VhRab%Z/a`{oھ =Q:]r|a N/&:6?' n3wVucEP꺀;h-B$01*J:ig.uBYmf+I\z#Acui꿓=M5f0׾
TpJv򦁗>utwmeiӏpԑp5Tد(o<}6Ԁ`H1{biV%KQ$ybWn1[HeM^Nkl&zA|j3EZn|Xo|m(S0ZIb8/5QTLCP\0EX{OLcx !;MD%4 aіcf(a6
j;uMSk/D^&[ג$uvL1xaj=ٸ{JF9Q#f'u$ؤgrYC0Ψ:%B0 6'/XVv1H.:hPBb	.6U$9jGy^z(<XpΧ-;ijfUs4fm1XZNd-y0t+UYmKXib?"x|b u6^Ύ5XͼrӒa E=]%vB9cW_ZiEWm&^W[4T ]&#ܐsdr&`Z8WUzSܐ))<R	N*T+R=<ɳN#0z_aYZɖ,c	BO?3
ΑjyÒn+}MD09
8`uئX:>#:K>0I~~M֩04Qs;qٜ/AӸiSx2]:Im(zL󀲎_c;^ts1vG6o mG?$X`8QDӓnWiODnb%Ķ]F`]!ĩpWTpAمiaj v Jm؍GyU4WLxn dTNvpa]]`lpwt^(M@NK%H2>,wZaݑQ'$J?sYE5IP}pp9,Ah>N<,;~/Lf4k[92PғR-[
-:JQ^\_#{Zfݼuyu-S·GҴ[?qџaQ
Ts?t"Mp
솢d͂I ,){FHF
[8}ǌ§}K.M``2YGH3'Hj`?)F*߂ʱѹUN'Ķ}S'°>V/aimEܞ؏@N4;vlrzܓΓW1=`'b*q>}F.+vב+Sxp8[.Z=gc<\5|H4
}K!|yL07D.uX%^XPnn)lpJ0_aמ%f4;y7̎0FPF1[ۂl2=e"Tna6 j%&lo7=#ĉtp{[gV}7T?p$T͝Xiآעf7o?{W^Y{qI?>	'gŬMMaCTt+'P˗pWT\)-vWqz1/Eחnu]:lWVTj6
48GUOf_,PD
QлR<
e^$-O(۬F(=zrfr5ChUE0
TBn}W`(&<>ײw>k]]-Z
Γ[0r"RV6k.MG|ZA$D-mh*!s>^1@aEO';ks/.cK؃(
Fr&#TگV@svb
uzP4ӕFtjy~Ѯ#PBS0HShs8hiA(s~^cvΉ
n?Z./[@?^f$ƒ]pL숔Kx*ywI<̦SaWg(z=>¸/_|/0(l'N>,bVVzIX|'oAE7Wж\{,W6PQD~m/PY_&d~3b0ژO-+eK91ס֮P:$Il}2e6w3$_/cCsrb>Z~ܼUt|gY%ax7IUu=9fP(yS"+|^eM(0=y8қ5B+rkH]Al=c 34\V_-@=y}-9cL%Q2NU|9.bJiwwӇ7j|ǭrl?J8
9>)v@U-IւC0q@֔7,WbQLYR]rߠ}zedhـ΢F]}!!ILYص*6$ww`>fr0UL7-,i1ų2ր.tEHN7r`T$tnC9՛p2Lyu	l&v$isܣ:@%';Iɉ89u[}\΅R+z6&GkQ
dISM@T-_|^Lri;r|<˯WUyKc
clWs]ٍϸ(5+oȷbzIL	ڤcwj;mwlDvVR؎/uwOVtCLطg&/3ӿ[)؅?dD@˝8dAC[D0^S5Bf)> 1p/xQ-VGx9T-|uQiA=l		1C.eqo.*dT
֠#0^Xq:ͳTtz=nBjeU]8K͔HgHk,ҫa;S̈́p~Cm?Bգ`3jӊizC@;)VG |V^pbL89jq?q5jjj█0P;/pi-3I@@k
pb5^/"WJjdz1Eo8D'nQChR7V3#iɧ}.7&E9*Lo쇗ߟ0؅fjW)|rɀ;Rs	ʿ\"Z^Xc*A0ہIt|mY.L^bJ@YNQaJ}r&m6Rtq総=I΢bqDC
Q~20`EJFm$QJ7lY%5ۏ6A351G)-Y:_&R\8;ړ"" To)5&h#IZ?Jzq18BD;
_'űsmAh7'=p?bPW_=Jj#Ur_[oa0ns+)L[^xrcDsOx:c-UWWe:_/N&#33$|VD/3,5!r t5ʂtЙ8|gEjTy`5X{`fRK\p	N p"p"joۄKJ0^P3k<3lp/U(Ů)]{(Mʝ^jJ|o7Gm[7Z	G莒huF[S[HL:~>Eea<;p)|@ܡ*R2Hv^Ͳpt`\X723sO#03ݛ[B'Z,e容@Rl
.in"`iG|fи XD .n/\{=:ё0,a-[s&5`IA-u/z. wfO6Fpwت;9JD2K0!)7')+wȲC9n4x S^/eqPɕ@:me2<^Ɂ=u<yw'"2L-CRHR'Ua*OF]oVR5vݱ뙖xEiiv{mwQi M茞z9=(V#˹s>4tmEҴY'dC;;Y({7-Tj{+CV6={$3hɢ S18$	D ~ӫ-ͶF`5ˍ,7XjFQS\nvƲj*FbE6&,@B4Ȉr<#AZH*8&x@&p0F^O&l!'tBn@R
0$]^šѫp/-iPb/
Jb)ellK;'*+J{(2㠩XH "(Ra
&ŮQQȏϱŤY5N`?rG4J;,fb+hTWEֱ2kmƴ:X:A{h;Kʹ I+m5[] #/:=E=L'5u/uCр2S$~b2Q5K9du;?1
᭦cq]bH#-;d`߉/-QF?&\Xؑab^T ݤjbV>GʳG1~婝*7j1{`]hp8=OӞ	k{P1EA[>4;ᥟkW+Kavxk(c
>CbVbRǉ=s1al0H#"GDrqܯ(jҌ>1Fgt]b)/RĚ"V[Ȫe9PA՚4D,d|f@'byh>6Bh,`èrÊj}r6{HeQ$4,6D:9c|emX?C;ބŋ մȩMT.TX\iX8}jAӱL;:jWxx/oSj8||dЬ-8GNdRStzmJ;7@;"vi9h{WZ${e{ɒTjl6SwRxL̍:w<MQ(+C)jݺ0e>!s)7>5~E4!lZTO,kzUc%I@JwoJXQP}V,f5}T(4]$?uO^β 9_M?Hͯ|!Z2|fU/zh0[9:8=Kn.7υNBg(cٻmG[J ysk4͜~mKp6የ͏9|^mi!7HwM.4UJedS^,`M*^k6m/'vpY>;pEq㚒I/M!I0Auf5a }.	^7חmw_󟸭tAY;h(9\CὪK#0]D5;-7`$o.>FQg|v~@+;MYYS% >,5~iӐџӸ!hS.XH[sC/CW'K~'MVEe*,1KHg䳚hWku4ǎ*Ə Ex)M01QZԦs$1Qh+\oz}K0ڄK/7|O*0҂>agUpp8F 3'cN9~?E4 R[Iqm',BA}L)#E2U-AV6:nxׇqJ`ar/&78CtG3)۬"0P%a;@~7	<l$WA:_UU<K4*oDA3ď ^"(:;JNzu7f)6}rN5ẍo/4g7P>1^P6س{K_?ΎjIj~g!K}n[<Ȫ4?>YJxK,ަ+>f9
b>l7څ1ӫ^mQfMƱr1]˱d?#$XDdPx\8Ÿ7@!ET::ؼd9+pܩirpX/6Vۡaj9ok
4"Ef7 aG8"TRRzb 91'} 9U7STVFyn=m͵a":gE)L.sAuR- 7,sj?g I3RA܀Z.˥4b6&x) ƨڎƶ1xIDwݔle;j-thd/ˍs'AebR4Fn&Lrw0a0!x	&gҡd^.:q}%a:p]00Nytkk Ǐc\5{ӣr(R,13۶8$esR-nJx˭`ߣ"ΉcZ~Z%Bn.~T@>iWۃ/.8sxW: W(>m)F@ѳ=:|{:&5979]bFqk#5Wn V		W|`TK?Kr
'fe18V~^W@HڄѹvA>d9ՍG``Yˌ֗qvCJRRE"G 849ɽ]6j 搪6{.Ԅ"rԥ1\*ώjvL5vV.ܰ+(+_Rf킸wդkقԡ%Ztv]#m5p@f܋=j:8_$' pqzduUǣ+}bjHCSsMiOE|{[17Q䘈Gs`OgYvxg9yڨGمQd@SKiO,_P'?.p"8EX-,o{6F@-(5r=uFv	zEv/FF8Ek
AE:Wkﮈy\ú,*I%:h]IQu|\OLaH儉cg,ƍ}oŤq S3 e{m1r×.9>ëm2ʎ͗9!2=Yβ[+bf~\AmǮ>br\=$dFcNaOچF;kFa6EIǻa֣s/;Q) 8W~ALM&%4p]CμjhMh`wkm|R(<f9~T9Fg ~
Sa-H\9Gsk8 Koq	U42ly+IHOmWb߻wQL'G:]Ugx| M1[yWU]/̃3?]-厎dDw25|G9S=lz&3"7RfӖ9/JtM$5aXlf
<$ng ;q#aa⁽QG}qZ|ޓx*p	Nݰ 3|ٯX
3;!LGF˵Q<^q-%iЬ0|n24i}\OStde1Gft:[#xU,p'=qF֚͐ˏbz?45tjrD|sy]#4G4Ԋr wi ځ
,sUh9V<[u7:;R`QSi3@Mbl.9>F2wɦ	MSnMS'LjrÙR
krVb L42w׹a #ZJ'}C2MjwƤ;AvÁ6!>5ak㍮8MC\o1ku-ОuS `KsDNǃM9՜w4>
a	$>5p'J=#=svcjr!Wh ~V[DN)q3Kyڏ iXg\GE/WyJFsEy@x<vU:]D\aҋ5B	\7$8.^	֖ƿ%"HO@nH)g1Ǵ,#V^rOq*}尐&ca5W6C+IZehOɪCp/vS\`
 *q,uwo,/<Wܚ@(8{`l6⬪<gS%΋H#㓦%pN)]	Ǯ%گ,^w&1Uu\r: qPLȀ^Ak&\h~ilUE3ZʹxlQR'vѩcOՈNJM"w3)Ju$?lHFj6dEA@n~?Sˢ>Sp]	G%=@#48xwC^VUKJ_]0Q1#0)qLg',Ϛ*T{Jw)@B
\PWl#=uiUs$)`CꔟC37qwR TTc,Q'X;1Fh/rPR)}/_?s;WF+SNk'S[T]3Цgd}P7@wZf<Q;OprysZ}6QHfIOGg@9IH~cԔl[[[Z6,Zu0gh/>)5%`6|:w ptk$;a7wW
H1Shwʹeu:hFvC{^;hVbB_BܵΔՙ=ܓP咉IASwS5A"N圣xiG#ӱSeI- `DZEӥ6+Ba1MWbMbyITYitu`.pI`3p](
|ym9cR3,rUV-M#;7EJ'^(zd|_Qgp>hb~fh]Nq3)VvqeuPGUˣ+n}M0Մŝw&)&`:Wl<g4«h6Qnr톇(XH@
6,?_-狲S%PDذ(MiR!ܕ)yn[AecĠ( [*\4)gBgL_}IV5?qDǿ9r?aڨ0|Њ9fFE	2{WR\'6È/	ͽCiK~ܨQfQ0ْps:ѢV0L|^b}UkZ3ɲ	yH~6ik؆05YaY}޻KU߄*zS`Dy	J*,voK>mBT+H	N_Z;2nM&WƘA׀=c\S[yuh+*0G0(KAԞQ-27Ǫk|Wdpq¦w@t+%*xi[ދ2X]1_T^.mZ:	"HC/LgOAsXO
q.g&[~iH M	r=o"CB|:p5%JMrpXGD~?ѹ:p/npb9y%g=,ȌSC"3lP͐%#vaj8,M}"[F)6wRp`6"h~Ȋ"85]Hr7L\؅d\,PlaS$;q۪%Su`+ڝ;*!5Od=	e=]jLaxϴO"uM/m+s#Vr547 hs߃M3Hzf<*Iÿ(e]݆RVj8}k<Q72yX񫳘_Pmn\=Oc;9Af)_\hof4ZhGf~`pCDbgnq9M|suFe_4J)HzWUXj{]D+a!^Io-"Cq]m.^ƨ(9T^u9F_+wvwo_S7\ȍw"HīXK4zO\{gS ӇgOٞ=ǌ+OJw0|pSct)a?c::(dMgVA}rQ`(9܈c,PNqϝӪY/*F9SRXԸ~Q;O2;u&Ω?csE3n=9ʂ7+ܴ >Cfv6mOgU}6ΐ
#
ZHu_jFR=O:I$Ɣ̤j+nA8usf[KV]14"&C7e4/U#@T+MٹZCu_sb*bWX364".f+zT }-Ƒd)v0:pQ̛/s
Y}ɂi|\?)s,2J.޼},v%dM1b[J^7[M6ۃp].1Nٕ9;d.M
SlI<3nbJw&,ҏbt7oXзFQKpf52T'`G-tWXa/Z1+rbjc<εpӑ6g~04GJ@C%_-ޟMAx&!%XY"\rgهAT~#PZ[+	9a$$3'x8cN}sP܆剉>eCxeڙxKƖ&LE0ym[O=+3\
KӬ܄XZ6ܯ~l!Sq	'0_q]bUN0Q5:2-z{QR>[XXCj7UMsZvΝλG^ogbvGȘ,*Gu>m֭W%yhH}^rh
3X-Tu}[ =nih|v૵}dEUb8Ю$J8mDݳŹ;~$^|Cr(Zn6wrKO	,*X"4^,AiQP*KtΌ1<iKx&qF%AuO{m}0]ƒF\e;\O
)FViuIBr"d +Ge]wc~3qf8\8H9alrGE)UdD26G٤pCj$JEQe+Gރ<F{ujأX1 {R|r<L~TZb^\s4EqL0C|xxU	]zHb^2Zjr
XQc,-|/-C,?~/*flo͸./t^cs2u)A+hW%e&m]{Psk6
W 5b[RV{V3ba¬>7b.1,˙ȭ\fa88paq=n
~$_O~1'~ޭӂ[ eb<DA"181k;G&Ysuޝb-Dם0b7Uj{bZ$W`ܯJ@ξy-V(M(yW<.%tޑ7MOOjq^F;bL좐&Abݷo㻡+#=@95%%w^DT]{0웨ev'@7@mڪe+jGƨqS;:n!B̐z0ML{֥wkQ=Go@ʵQ*gVxs\9R~B<~BEV\-1Ndf:l^Ds	aƈ]فZcN7ܤNfq\p:q܉N4n&S9>~TPQނJ.!J*bkGn[%U	tl*q!)w(li՗ќCSS/kۅ1,ܔv

KcsC.')h"6@Ej5Fv3	\ؓ4aOAuI݅r53we0Oћ
tYBx~{PJ ]bOT{.rI*eňO?ySy~ii;b@-ɥyWYG숔7^(v"wSԶ@<p/غa
õ(lDׂ˪m,!ڙT2EuT#9o<NYS{I(.%a`l0ǠKBg,abX6;eL0SU 8Vw ;s$z[P(:F[J7%4oKGڪ +A:*zwq\&\45]n`@'˅L&I4w<0!leu͔bQqu\ 5guxus{FG/
M]l/\"<XwS+r1oAD4u_MgWW?GmKWZ$
aIף'/2:. {rg}oVgQp^Krud;M,_ğSHk{un;ZO9@{X,xٓ_zz݇oߜ,,	/T?.I8?R#m{r+`e.n<o^oA6J%~0}y|g3iu;6bir(cgVX["!tqBUa8B,\:Dg7J<`^kڨ5s9=.B 4#9AM~qaU%z=~Eq_븮%ƚF@NMmDI٪:/FaS\~!fT)y.fHI_]iu{Ip06-ag9>U#bKr$^+֕ud2\vi{48XDo*#Vϧs#Rqy_1Mk<iٞ)<]+Kùoywe߂#;jZA/^_$fd,<.U!2dˆe%6 <&Z0 
;p-cTF0#8Xz9uҸIbKzV3
s_23wwu ؖvPu>"G.fb9fzf%8&Y
P ̂W&&1__vAW.NNO	^MX;cB*k.淽M~O~Mlt#')/t7Dfܬq3ɲ'KL:ML+aUrgYwu Cjl/zyUykxC+؄0΢q&MAD27%Uor*q뀝%Mfo28froG!;P_t혺.\.*2J\|iacel.$DO~C'Z/sx'ejTnE19`fєӄqPT0n_#>a6s1%\}&ad8BE8SP{
F#9vIaa0=,&u`T~	<6	xAAmEZ~.sҋq Dl
0&|~7SlUU/LŊ87AjRol7Pf١?unsvgAȋdW+6c1=AM S0
mޢZr4&	VDӒc#ōӶ6T:V}XQmg8SQqL\1<-Q=3m`E3\c>
K;P|B_IrdK+ݳv|; iQ;f7T¤(arƅ`ϴo:yI\C-JPrEtx'Vbb:%.-8[
UvLj>l\׮js7jG+ysvѱY6Z͍q,PڬV!0SqJrfa=AِmԧYBzR«ӳBwZ?.7^43WbᔃcU/d61G6Lu$8:sMZ)#p9Q}sE7.'sL+7Q9 }䯑^HvZ! W)"$Ly71=(Vb{Ih%,(Jhc=<d@t?Bu
:07	Tt80Cv9vbJCCMl	]H{5|k1P}\zTC/Ǖq7s,aLp\M7~gx0G\^փG={=6D`@7p5ƈDI˼coޡTr8_Op"	?;q7pY?B; ǱRa(N`܏Ps@2܆Ĵr5#A9680Kef+,	vԚsyxl/gb&\7.}c,χeu6P	,'B:Hޤӗ?kZ~&,9㥩c34(8?3,fUZn5*M3Ԧ-Bؿ}UuIǫ8ߠaS	0a-y&C]S{X-llW2v,68M..;a4v$)pxvQdUNn-e!Hu"`Z<=r0v-u'auz_p[ʫ4/d#ci>r7A>uؘ$N\lNG&bnY9S*\g/6p%8
fif|sd["RbK>w(ul,UG,])Emd}p}0~Q*YvKGդ'T2[XjpK
"?N&Ґh||UsX$3X
cMM5ZҳWbݳ:D?Y7DJOkegبP>ءМxtb-us۰04bzzE
D=8ʚkUs£K!Xm{ӮDOHhJrCRsaī@3H}cN@u>vdH(rm8k2ߐhaUT~e/6 j-g+\ܴjrUՑC򢮽-3a<rsPx|[qCnw B%0cx7YI ,lr$=XQF$?IN5&<zׂڎEU	7#	Тpᒎ'if3'^eqZꆜa,FWłjEӈ0Mw7	h#vn4W#Щ$`~b$~7Ibz^칏wh)V#В]b	@ZBB"@3n65pm﬑r_qnbA^R{2[An'-'x$ҽ/'ȽTk]Bǆ{pT[lF.j5	T"w<͒8{w++US C/-hK4諱)IRA1~^b^TOs('W5iE+kog7[ $,ZbjV+%(]9F0c"Dr9	ף>7_I~	uF*wm7Sw0=m9
鷊Kn1HD|*8XXZe2mh`HPJ=Raa]a^O0]"t^vֿgvyX~J!2UԪwv5g=PtL3 .3lsLSWX3@ya|Ux	QMg%LGc5Be~#fLj#{Pn2XV1.@˅hf!p%tĹ^l_fYRkJst96 ҇-89AqK5ϰ!^b=xӂ*K>	dOVשi:wR!~k9gM~F 8(QŉcQ!oLg̈́&dLՊt[9DR[n0+]uFg%a/K=7Pksz(Qe364u/տȫZK)ݣj1pr6tX.@ wKG>'k}-NgG\Vy>l.$W.t00Un7519R٠ 
ζTXأٮ`#Q9X^l3A}a>@ϛnPVLo8(?2b(
#?Az`#~
+XWIqp(WR`y%"ӷGor2V&P/4\/ѕ8tp{=wpANosr#mI7tP-/'1Υ; (HqoՎO%IgaثD ^sQ@MT~xNͩ-iBLؙU<z_E֫ZhD04V..X&X|[7$5Cv)Rz?jI%Q4ω4mx]$Bh9:s*5$곝y7zjsΓ%5\NdOjacq(I.boEam*MIAX>xUib67.LSJ;V/<I/*95u/{8%][^zx;+ZxH`@0)*+BQY;R2F;PP=Oa jYNDhO8
QDnwB+IȌ-G0. JsJ-d2H?#+i)^ma#sɽP}DZu19ˈPbv.<d:J87 4`Z]cR-]W!%2Fzja F%yh%#+in?y'8{ju(v8@Zv"\M;aXu|[{LYLA\(̍rMOw+xk[s[ Cg#w3GaP}a%#[mJ8N&Y٥ªNx힙vbf_YUۢbR1~L˳C;Bs'91\wrO}hMi&}~R:\IM٤Hf)Skunm7>.:)rHpAez)GΔZy=(S#_I($6ɓʓy庡`7@?^kYw:Yv6xivնY=ZʢsSr,}8YKXr.=Ngìcw<^S4KυO6-/Z3&h{JJ|&`qvۂS6II_4	-##&ӕP#?0)j 
v5$gu"9<|u!D2ww>"IeEI|6*G;OH8"3g<9sd>w&ypϬg|qAxŽ؀Ub)֚O]Ë1ȡ.Awp,vtb{=wJ/z`f}Ǟ} #ۈ^Ap ֩,Wx ÷)8Sn|Mni/}9sM梬M&Q8j,߭{{-~hna{=_*}JCܵ,vݙ,lI#[Z!t؛h r<TMBw_J[:a|t|YAvaoT哵*!exA	dlE˿y͚n,Zwd1nG[AjҎɟ>unw,:Qpvh)@1^Ъ`LSjOC?Eyfպ*5`<;Ɲ\
Cp{;B2/'32ʸ,kDL	خaOVf7\>8_,1gY,Om+$?F&Suqg	HBΌtwH0DвB^]CaEv:LWkxͱC@tr6/i l"AՆxO7g[I`~8٦Gx*&#`Mf5BD<_9hk?=wϰqbj5:8|cLkƱt1֜꽦jkmN#RIz;2﷦zrGxm5mH>b㉄4d7ԃxz✀XJm`f&(D*]2
n@o@n@?oܪH; N@	@ijXz_l9zt,L0!Ce%7m\vt.s+*Ӝ(_tV+بQJ;\L"
GHϋ\ C{EJ-vtWӰqǺ6ʐ9=Fۭ4~~ۧ:ӋZjM"h^0I?vfٴTgðqK\]`/vKaJ]v^)c >
:n]	ź8*rbjtn~z|GzN$VjTh{uBnv:xgVߏi̮u?Yx
BN.F9+ב&~6]7 v%* 1r'б4Y.XtI&vK'QSb#22|4aJG,N@F3>9mw!VQMޮ @ٻN={Xq{qMAA^g7EuX?^.:hN=*ׅT. -vz;.}cXR]ȻF"^wEz堑ޮ7z_$Xv/Y][N/xeEsVP%]WYeOۢ2Itð&nJ$rȝ1i,PMJ%ے-c2lKHtu{	Q%E6!Zwb̚!@7.(j-c61B7¸
߳gL`,,L3|^k+n"+&(ǖ}9U9Wf~D`Vbۣ#"`qQY?9IX}*9%ڋȪj*M=C,xܽ'm>e.}8[BD^0흲H䨮i`G47\N;ȚQ9+)ڳ$\plI ">C(Ŏn{1@HK9{#>Z=ը\#C\;ԾTG-UkuĽA[nsPiZ?
&5ϐf|	fEUtsvѱ#m@:o.kW!ZT|}īA%է&y	X\'>;囗x" *r^b={7O;/؎#.16n'&GsIgU=IMUZhC\8IӌX6Oz]c)!h4%vUc[wInL~Eqatړ}>ˍe`sWckYK3WAp}eऎVrE:?r>E	Ι^OHyȂĊ!ߙ`p"&0ڷ?t#2'Z过\
ׁX3HY{<<j$(Q Q@j<쨱o'DQl+玓-ISRզm<|}iR&ⱦP#(-h8odVAB><gE$jɃ2>5Zϯ>Q{ ŞKXU^i;TVt7Zk)5B9
.ۿ]27.?~#IL#`|arSA]m/28d84;}s.&ᧉx$\r81D|sHэq|4#b=ٖ[&|wyߎu02&@I"(4zTX,*v[=?
*)>Ʌ
y;`>EP:b%vhW( Q=-%?~to$ff|$z%`$_
$|cެnrFB.tWm,ȋ1]~2j.(mU~| qF2b[ 2QiS4ɜi<8;G~հ(7rlt	NMF򣸀:eT7_2$xKjώ/KʟBqL3|_P5]egA(~O%2-eʅs!\.\sO_k}<ޮN9+Xp^85n8IN\^g<n9n_Ol#u05blS &n܄z6 =3XYKRIA<nDP(5;xXڍr9 09h] IN޾~:_,=Al6Em+nG~E̓:Ϋl?<~q7
|yX./^O2.:`ob6EztTj_6^~B`8:$ؒ1E;^ٟ=VN\	`Q_*9||MD[BRH81 i>	(~φ;a lg5c"!8̶L4]7L5O7kQTN+c`Y`0e8R*iݰsvmniȝ.5765<^N:,%`37D7&UVBэ$)O=yWǇ~U=jY\#еg_o|k>4VԆjN_hyRh&`rbj=%+N%s7}|{^!ۈeQag}~HSx5aCB#Q\wK㍐4}/"l|äX\A9Pǵ Җ\v#GGkJp=Q69]:8踜	nt AG^H'򭧤_kK}_ϰm0LP&Gڗ;N'kQ^[n͋^ƿ⹗"GA䞀?ӵ]PIϱg|'[>xx=O8
[̋6Q>*xĈ_Vy>>!J4DNz->X`2u7/.0rATpUK#NlW'kh0;ǝa]`w&s[u͐W>g8"Ɔpm7+	XBT	b8{Ow}AQ|x,Ӻ|GE#ӟ$?SVۍQȑfs]#}?٫ws'?Xm:t)U8X} Okwe|=
7ֹ)}9ܧE?f5A/㚀ng5G0b&9j~]fnzbV<bO!$ɟwR>KWԩ*mp5옽,@%8ezvJ\>Yk><IYػ{$IEvgk~Vm Zm戃\[GjQ1k恣*l|/ωڅYCS^ٌg5vQ#)s|fR2lNp[lͪHD6Ⱦ1"ε<etı}7]ùSa]0N0մ!nb<6˙ߏPGUmpr z`~Iuxo;̽Ǹ	^$d6z0C߉ =e=R&һ_)w09S~	8=6)7sL:NXGB=^*cW	yk^}	wyE{KiPDuAxB6pE;'5~/IBj;C@+dIcd]@waflڎ),JZaYOڴ	iC1ےBj3S(R'EҎG6?UI͒0ԊzuE}\5|̺/(.'kԮv~?~fJj)Lc~3 NE7b̼a3l3Vbdc+-A([blCS9_"GCl"BϪV?NJ";8!?3O:o%ѽΛ{gXɺZC9UCLhܪ0=d4QbO{{O-KXF-'C%V"Szk2eb{	VEn&MgBDqvRWRܟ`2&<V4ʊ4k)c|JE>xf,zt&Mw*$n/RGPXM/KÇI<ޞ&AHeqkzGhl*(?yM{]_Fo5Y``ٌ)-%ȉ}:X}?4#QEQ5/+MUw[TQ1ݰـ߬MѮNL>;hkb5F{!H[KvgJ[#"W.m:`pI{p#I
Rp$wϨ	Rz9|TkXb~O"#E{j4A,k\yKsa&V^?u^sU&&݈ 4Y8FM4o,\Jm}\CvO:pba n5t:XUE*7t.j.~8٥jB&!q0m
d="0`y0M}kpk4άͯ=#3*,8NtWku΋a+b&r9)g؊Gqֈb`ƀm
R~T 0Nl~uTǾ7ݣ7!J[T=UG$I'4%0v5Ä:IN?tﳒXS͢-"O̍DQ`1N[۠]=\%'`A;L_Wz]wוﶸpÂbY<Bn?uHV%y!*Rb( \,1D8g,M
~1tgݗ
lpE^{8%ޒG&QOKgitE-OX.`Kv؅M,	$h$">fex)miKPW]z3cyr;Ȣ{*}9gz4ːG&1Gc;~)v)'S[3>x6_R?twk¾sa<h<l8q**/lד	8aB0*FSj\[{bß~8rA	
[qaޘR%80@jmHܕ#Ê7vEqLC3ϑ8GX$pV^RMk'pC}ۏ^IWݮ.W\TŁ8X`k
A71cC>@:-g;4q~AmFIדY?kv^V,K .sH6:h{N(lGU8.wӥ遟R9n 8t?:opmbɸHZՊr9{\Nn;A>*=~}h1WY]L,S{:vaH6߇<H\yu5!=3%q ޭA8L{̝*R&w7JEXn6g^}E +-h+	Fם$_psK:H1=)սXKh ֔Ƣ u{:2P8RDȢԘ1Dϐڟd[Z8b؏kK(ާ0tN8pq踤JlZBagfh)(844VtT$kxiٖ஠,P^?q:膵vf[%R 
Ξ|ӳ>|洦֝D[qS,\8JMjMF,1j @K;)Eb;kC"KJǔY9Ao> De	CD..TdpϿC1Hk+B
s9g"jQb.WgʹIh$;BӕstCJ?-@UzKqBU1vN5}0OG^dr9\7l[u'FP{LEǶwǐ<'i?ymwb:^7(@qMZ&J[3:۬kn+GyӮ]B.$ՂmX6DFDm%v#tt҃G\&tp++#R^;0`ޟ4i]:d1+7w¹n+-c
ͪ=rWlڡNn$Ɩb<'UEHzq]B*6[Mݡ&wCr9	/+dcV2AWTɣDHwϨ0Z rPX"XP7D>%Wߖƹ㐹yQ胧_(U3;VzyLzu]߭T[b`wT2YTSFs!p̮iuGRP+B	dZt<GԓMWZ3V_b!{?=Gݑ."-app(ߺ1+>B,ckF09exW
fL{_PnµZBXL,l]رwgβ<P9^rSXeUU0Ǟw3˶m<A!qG%O+QJ7mg\Uq,I0AZ4VwlP$`D;ndR4SzX
V}Tn$0((i^~rasgX_^Fʀ"wI7OxnzZVө"Nc	OaϘ ʚ`?a"p;ȋ<]iSKR.8-ÅK^456YTAEi	Lؓ%t]\%D	R&Id=$AƽN"'|F׽04DUQ>$FuA`WMP`&i"`'f4Wyu2'ͶӰέ9'g'\Xr}`АNX/0R1da-Me/N ݁6[: EN;۰ #:jpߣ	Qa{sQńIc:u2/Y׋L1ד(M0{d)|ɷoCY:MKWt)A¬R7K='˶Pvz>RaOWSN>J]W̍d'岞e]2(I9Tv!oI6_ogCFgJ~K^yxϑ:\@?
&uQҸa5oar,'Fn>L4.k%JX],C{MVgoD'0&dr7T_jݺ3-t:U+=]2rV
Φε?o6rVVnr%ܹ
Ϊ+V<uӴW:n|ˋ
竝+].`$q\5;<c`FL"txZ$wZ"{/k!noʩ9
EY]c(of!vN}-J"gCRt>mSbzanB!Mrrvc$Iboj'+6>D޾4?f]^IVHI$W!JkN'"Ȩ>	~ݎrM,[#8!D%q3+nNx`C=Ibdm6ZJMB)wɝdÛwGr`b`dZMk>m-*OJWv\|ގ71VsFM(ށUBknsyTñ+߭"*?zQ(x LMP=6bUrE"?5΄7#aYdGi9	f_~0*>Ӧ-2H];02;@
Fv_8A)^)-^ܲ!w<\B7_Fm8XU:VDڦ|nڼn%."x0#bJHrK2SujK,*JQ<Oݘzc$4OHN'{VX]*M~
OފJH/LSd;k,k)x%9T*P[\#[[>ٚ7d7r|qP,3*ͱi6&a";C:ݻJ/@(d -||V	DNB.lކWwT[<p"4b+-ۏO]g,=]rh}vM\o.&NeW}ٍE7y}؀E_Z+V/HIM)\xObřs6YM1^W@}B7uauCu#zQ'H׭gVX&L(s.$Ffw_/xYhT@CU0-J sM	
IJK4K[+؉&&m|̌{-{|ANpQݴIs',5V	y=8dٿ/	EgY"ƴhv1%-I]e^W;*[/+} 0L}xF>2i#\4- 6?AԺ9xyfKl")~6
{@3F97n΋XOPd![k
c1]7W<E$_OZ޶Xu[ĦTѪY;r1xNL|)w"5l̰ۧ?^$<\.bL~VDvp4`Q8a/4pko0RvڻPQІd:Pr+b7-G[n/WĵN7Ҭ\ɱ{a C$aa,⛵1tXcZF!|9+6H%0JJQhPI[*9qE}X:l5RuSaS8uˍG#f`?3RqHt_*3)Z RorYp9Av{`l0x_2x{ɫ_eWYx+*9,tscX-Dj'ֺ#<hG=Ye$z!M
9Ǭs4^봕{6*P7qAQp9rVbЈ ? :!x#T&lYX`:M>gm_l	-\^BM3Αݲl&uu%[a`YmG.'|l8qv.wkd蚟~90r(fI?˝"{GO8[ZnVqUf܋پ4ej}J/@d]0ˉŃXak7`rrwSжI<x#KI64Uyȹ+ sSAO}%g%AܐF1W92Ž32g˞󉼜xvAiRSwkF
T
3a N9[|0YVԣںE{$;_zCӻ;$1t0T1`q 
}C

DdR1bJq?G#x7HǓ>.wzwPP1N	0hy[jF6ʃ[Xs[+X}fjuN`i&	Jr6%7L<:^k|ol4:Jx\L]!riGLPtO
=>"=G+ttq|vQ"	!_W[LM|YzwɖO{=6Z͆1[$ߢȒA1"mZ0䪖$BƼ#<4?D>33^G8i>ʃQ0n9߭!d>	oS""15~^qx}v/	A|DyѽY$}4n_X_$kӥ-KxL 217t&BK[ޞ<~<~%qр*9fi% !xǱ΍]⩝2Ւ0;Ln1XHOdF>_SH3ʂHRX9	Z-A6w0Λ_x*
C9]S)عf_R98اr?}-hu Έ$OjƊ*uM$Q\y&[OUѡ?

N0%y9	өsuǇ"΍{ϙՋb3mL@^.*hC$Moe5V,(>tFϯl|(!'+ߴ:'o~	4att-h-7wPW(2j%)hun_nTN>~O[o5tP qRV ojo=%4͛Bn8%xd,-a-Yp	?$Kv!V52/tFS+B67D-¥	,$Y0Bx"zFuP%{e]6[½@;3
`E>ubuDdVm8JR/?#-d%j=T]$xP|Q=/'h|準oƻMYJl@j;lOWFbrXlK18	tm.q.#F,UKSY!0`>eU}Z 0swt+gd,@	DA,Tv:%^Dk8BeD1ZoX_X*P/l;5j*S)@m,\#.
̿./t̬%AZ#q͔=c1(2O?ASMM~+b#zd;@<u-Z2/9q}\'X3ʛAUBVeZhwb`!I\fszUJO s^qߖK|	vo"HgVAgy٢i<#ƃY^5: #Ac$h-CzG:9ms]: v}ȋ{\.QwQNOH@b5"R;&*^۬g>qŚ)Lx3ݎLv_8i8W	.F&0g)F>g(/1d'lXRЕ_\@JoBfr:-ȝA(e$-8wL"brRV˒g悜8D9bK%/8WfvjKArzSlF8o{8޽ЬTO;f>Bb@zPZή̆By'}ψ'R!8ގ"Q+6ƾ1 >7uWe OҎ)u=r14_iG`v0yf԰%r:e=4zp\N'Ŕru͊n@
mkNV%*;DR?"R@D{aa\	\%YkFaV_KjGSF\1gQџH?Jr0lK&m|!1v(jEP>xMUAa&	QX@b׿CO6+z0W_z)]B",[u<.`ࣲ͌ZI{^3iMVѿ9WbQ*D+VU%1ZtsEXS@;)r&W >2`*WLW s-uIO$\_yd;qρAPUMp\8W5K;}I"fh/:뇛d\ zmo;ǜtɩ	=*:\9 p$CIA@WSA'z$,-rV:^/?EJ/7*0	^`!sW9c^WeؒpIB ^:2A̤^{1UEZ,a_ `'6߱3hj=jg]~ bt-K=A(IFW:擅 yv(lpB;EcinQ?HjS8Je֞/+kkk8V#ුQăDdA s)Y	8Z	U'䝠Fۿcr`R.t:pnVNv؃LEH+j%u]^sR!.t\__Q,*{x\\\_}A9S:*C[>z̟J5>V~A9L&,FleȼKlcCF?X2To0lT%e?DI\XfZ9.MC8%֫e,YuHwvZ)[dYu~)cxܧ"rhhVB^`!#mqגixQ%6чiGxOZ6cHĹ
	g Q4kޯE,btI1aTtq]LOcmkQef7x'{WgˍhnncVjB6}8}JЅ3WlJ?HQHV5%y\[il`NFf?HPS\W."H\q)#97K1tҌ,ّzPkvvYқU-۲EZjz3U~1Di	 KI#i&|!u̪jRQf8*ɚ59&?m*L՗ն6L8+-`켍_k̑Mcd-!"6p#@K$7(VcXkGNMn]zGsM{P4S_H2~Nb]xڤp8<BM#,b~bz题5G'<7$qD&iG O<OCA'A,|_={RqeBtrڎ90*Eq0 
187G1Z  8*|#VɿHgktЬuyfX8)sF.^Mq,8ǿ.5IuN2uBtp
e4oUv@%ZG6t|;\)Ɛ(m#0$Fm#mS9G}["42㰽'+>L	Μ[Dc0E4sx#ON֒v@ijO"gO`GWj6R@m;y|r{W%y)؄Q5	f7"QsCEKPėR`\wSsnc`ː*,]t\mW-L6kEƣI$q@FiD U\P	mvPP>RM2`W|f_M6:˳Yq
<j$$Pk2r絥)숳P7FWy9& HTETp:>*=W1vC{IUZvW7]ѝ³xDx_hOW<UPAoḣ7zr,9GOrk72pN,w;'pW3D MǍ8x'̥LGq͈(~Hy?=Wؐ3幕#kJOݻ!_>
 @GB󠜳Qn76,ryd.Up|.E$K3\'xʐ Yŏ2ִ1A"~	x2YK)bON1"4!6?-	X,tEbV$9o\ӎH5 ,l,k5к"<	]! de"io,H,ZPs_Xkm@䠍bUY13ftmfona@QtO8/lq3eәO&b6Vebn{*,_3~t	*ȸug*ڗFJONN.4Sn Qږe2vR
?`L!-եr6
}'6h{r)kz[KZB {jslUw]7ew$;fL$C˫|Ȓ+s<J~.3uH}Kta(6L$}s/#TK+ 蕁Yum2kj9ڼpbPsGZ2ʪ4	 )}UT&k*7WtXw["T<Stt)Tˑ-!ܑLHD9VVb(4CiQb1Cd1mp(l/Ftcj]	ӖUͥ4҈rvE<i\@VȚ=(U/1*Ln aC@9Q{Ҿ y._ex_oW6fQТ`oCآNrx-3unFhh^䗳?j	<gm	VO,#>=;0.	wtA҆59mBX>Jq
J{xuUKꝇD0hW;tQğBvƘU0".RC=@BsAkGלlct IX)٥Vfg߱d}TD0MX~8 ƌ,Vw SZgL؏<?nF걜FUgdU5bEA׏:UA|[\pj}G6N0`
v蔰(_!)4*?b(;ʚ0Bd$
qIF%Xnk)x!A%C'~	Ooz)!@
~at<7o?{͋ 
I;~}Ѷ6oBޅFtzP$cZ#8cg'g?@d7SdbԎ?>,WOr~x&84-{T.k"!KAW9)DZDu:1%PZGݲpҩV-?0顚XNUhQ03)b=ZV9RT)h˰fbGt5S4u_h01u_q0&8;;gX)Z/Ihi8gX2ETͦG!bn%HVsY"#9~\A/HJo?7cyeQ$łO?$l&*y2W;|iܩV~2
/;M;q܁}y]s7{g"Xv4&Is.fFx4io m-,%IlB}"#Э9RE6bZONeE9ƸZ~Vc7AOD܀9G
l1P%؜yIKհԲ\WY[Y8ω*/z/Pk`F1}J]N'[l.Qll&=?G)$"k4b|lH[߷y^*sUsv?o1Д,IEv+2Z/k~R`M㜷GѲAvp"-HcI"xS!,rQݔLQFo( 6	P#"Ïd{稗&B.3!qaKԯDwD]BQcV$k	1 )Y]Sƾk7UT4G jJ7cvً`M|ܪ{Ke,cA$jM
:JҶ)ԓiWl[s0@IHPǦ3oU|@Z+|"*Tv:y%0&>%ض4]؈b\83~x7(g)3*'ba+x;TZ|%2[-b@#ψƽW&E)MW&\B$b"3qY#`Nh(Y5ڃ2-VOK?1DRikGm71wW30,y5{o7.QT -+GٺfRTQfaé-rM/'x?dڥ\{se?/J"9uC<[PLϮX_鵏GX|H S'9N\?
t9ek1_	Vѱ6;I?"l #T7s6Hi1ϬdrqJ\ɓ 7uDs{qDy+T7Ҧhq
Sj1|BlGSjQdtSX-CCz,H	ny^|緼i-T$u(7m.܌lsM( jB#=	ѱW5gX$w F(ͨb}M%qFi^z	V?d`0jas0	wN^&YaIZ⺕a0pYm1Fq5opn|t⾶Dœa3ո#7]Ю# T6N//"1WRlS
x"akHEko>Sj+Ab2UïPaFoEy9Ѻ
; ģX̀3େ/ɰgO3y@*2+\.C#UT4/1Ly`~1iŤg>ޞU琢!EpLn/f8jVyۉZ`f6'7&)b#L^[D@yPcel'=5]%։d|끀FypeeXChvwqX)cTȹhwCStWK:kSD]oŲ`p1'GJDU;C&V_0l34E[Y `Қ Ik.4)AP-xh;#$ 蘩uv:C	
@jƷU#4Y/ITZ̖RKmBuT>ٗ;WhPjTx0W'i;ӡVPzb2u$Fx(.kSHZL7gZlaz'%cnJuWl8Gn	C\K.hijc,!!`bw5G~OV^ޑ,ofkC?].XYpQ> qB{Cp̉kSp}:WbG'c	c'3Neiq?<~pز8
.A33d׵LW'H3Fl7o<7pFx%	<p;ozgx2oѢ]`I	bmJA">T6@_Ȇ51ʆflȑr|W)NԐsWfu}|dNF?Yc Me)o13Kʁ`r+eS J)3;%uؕT?~uBpŋbvst|To؂UO\1GV̈҃P4	sꢒ7}ʠ8l5>Ss0'p9qgwz^A#<zhbsQIŏr[Ǡ*gn&ŕ?FV_sW;|`
#?|\zvR+Uda7΋1c(^U<qCN5"wRCj볩:寯mǩl}"}I\<s_d|lп5Dɯjr;zTnPhzQ^imeIq R)Yc7ޮj!B #WYQBݎ	OAreg-ѻ{5LKzLХY凘T'Ufثij2NuBiKv
ci}KٹrA[j"Ndܳό5f8e`t}OiIRS8Rm`3@ZJFne$ߴ.DA1]Kbpǧ'/_:	])nq00wrXБn^Z'>J93,˅.v[,X=N)Qxɿjn/#]<0[Ci㳖Pkj(w;xOP0AlSib 8'd6:ZtwYuxl|AYyy#Lb,Qф(Ԕo=/-Y	]J'QU~gS7J\>lCk\ckղ`iȿ[Gno8Qt(0;rZ1-695j:.,l3&pup:3ye&Ȟ_3)8}*L07uv
UP8Sur}+`. L椒yZ!S'~,Ɖ<^F&"i@1μy"1,[*xGp}%pCHB:p^$w.H
 V+Ęr5е(O:;JЉ%#-mudgkmJJ8hA+"0ΟZ?XEQ&i3R(y6ev
\Kk0EZmXpFU$x2k NFvqw7vHHz].)tJs ]s
<M3[u5~qS
4
TXUxELaG5R^F&V&!(Asxk\
,Xhٸ送fXZ>Lh'j}0&Ē^!$Oэs)E&,dp)qWxvA9U&9r$*O{ Ժ>=R2}1rvʤ5~U:_r땮?>^ζ?_
_9c!fɻ-.{V>ȥZˆ^?HjO[~x+^֌:orbbV胪ɡb8> NF͟!3Z\.r3Y#n ͤ7S M7`Ksur|$EỎ+δ3Ptda>Uj/mo)icCe=Bp[*Y}k7d#<`W'~db5x3X~(z?|bO	JJm^'1bJ^|iW")=B^ck1HrQ3nrb-u#t)3u'vxOTUCTpEDQWY3,=p*nN޾ӗo޿őDڞ_xmO5>7Ze-0A,QHBtÑ 1H@yITMh?Wfhʣ~gg,I?(dS ae*lQ}vcRL+ֿ,U	p@ )cZeA&$esz;.rS_N75!ATEPo	  8v,%MiG.	րphE5C\pCr|;HHJ, y[50	,Vm
oʸ#!<`x-
c)9۔-ٜQL;zru[TJ$msAcJnk" Cb2u/Zٖ;d8BP_~%|~
_,kYaYEBcxo74W	pu:apH7,WkBbAr;1ͷ?ZI2Td6\`pHS{2_w|uF_g'pKif.L),RV/<,|/L;:W6GR!`>T`ڎV?&ZX^
q~/w~,'?%suA 
ގ7da^e{A=0Ȁ	Z}#|&*|Mݠv/ Ƙ	SQ;qΘAK+is W-lЎ\vY:'`)eREHh<Rδk\&.]4Uw:0.䇬2/Z5|(*yWM+UP0F1*6!*7=bw01[=XÆ3k)V#k/_}~ez_+R1.q/@ax[QmHhmkDdn)Uak&$7[D"q~B[XUL|$N|Zkڃy#*Ɂ,yȨF=^HMS؄Xb=)(*=d
׸anj9Ka^sB~KǴӜ7`a $$FUUȯipU| l/KL)mȳt 4t
}oϥ7a}AwoⷸJILpk;$)^.o:2c1/\Y26$d +qS/p(:dVLQb+Ɉi20ZGF[hCtPi8]"B~VmWءI	j̖5tQ'c	
nE)Ϣ!=Xw8eM,&.h-i<ާ)D-ʩ8%dpoFHES{0(vBBO1ފu77wD;iL 6xo,C }B\Gc6+"Z5k:V*Ғ$62*v&Қtbaig;Si=F/E>/^E (&Kٶ:ٰi7VrD7F,9a$L+vBeUAcg &lv%2W9:Y_d1D͊UM|=EeF_~ANvY"@A4	-sCIipSvW!j7geUm&^^vMc,3ihM31D%J< ͙B8 yݮ&uDuG26U8G Q,ekoճjGm{{FR=/+udU{><
ΕPUW9bM0kۂ$]?bYUY+/[*0QR}(7|+z,0GخbnɉyU )ډpo:.Gg3FCOc0)dAK*Ά6!&sNgTxvU[^LZjvɟމƣhƬ*f\
SLҪbF;*YvYCmǨ@  Djx4DB:e?yS艳Ynm:t;ްF&C,P2l݆?ӆ>Uč;M֒\7i%W[`f+Tg7'L40 wX$}_x>||ФGZ>G6~d$oݭ`d8+>"Pe3T!YX0iD\2@22pӬpqǅ
$MPU]2IOuyu:[^!
N^xOgS-p	d!F3	WE뭼<8ZvSԔxZȹ/_e&Ϫ rLQ%߮:׍!L7[+t(aKu@<8ܜ^	&3;UC'O_jp:bF@&]z'ω"~k>XrөtXk,#1vW˽/iD]B4&	
̦fnGr`~>pby|PonE݃Sv&8b^(JʩSW_]B4axzmN.*,ܶ `CrP:e>Ǘwl5pl&EtL-2\lgv[VsB0ٕ`IleNk+f%58~}{ƮvTbb0H1ATXyt;8ƞ@n'Ҙfm񱵋2<0e&,Z'7qahd'w׳ZppH풗E*5aJ4oГe{䏽X~*@ĄN g%0-H9kNab-,A{=z(o6$Ԧv.r(u>A躏0VX.b
y{I6A>Zb)/R!#$uZ#\<eEU?q/ DB6OvK0fLۇ0 =pl56|N6S\7%Ƚ<}2-́w[FZX땚+m(jzdZRCAj9ҫO9qت;꠴s*'<ch".7ZEDJya-[Y֨aFŒ2jbP߭Jy.8Λ2B'bc< 1#>De\_<Nܞ'KS?h/5(&Aw\0*1QkƧ/Zx8®-
nhY#7+YCV{)3IxN+zv-9p|-b7C$Hұ+s㷊G8z 'YwZag\p`L9礔Y( j}cf;yGeQjq,:\Yfj<qمcAZdՇ]n3dIU/uN	_ׅ
GE61;f;z2SQvlƕ)u2d4\=nfyԎx^`VL7n<kF'.;;rԡ&"$l[4-SvQsoтxAbd+˷qSKtT]$z=Eqjxoda[{:f&LS-M8N>{lja׼~U.jH.ǬQQt@$FHxbe9ByXmVz|]Y91:uJi#jM[i>GDNz`HDNATĘQ!O1 #jH`_˳IRK%7yݡǁG;Tc*cD
DV@nܦ t|t@^Le?&`|OQDN\prRb"2w, ͪ4;xU @枣ƨwhHV9`$X욿']<#X(Ge,r.=vIvr[v6RN%G}&R2K"_^։sTmHó=l?Qp5F>0vkT@ڿOAj|+y
x9rlT<)eGG5DB~"i)]76R߀: 6/bͫA[T9)	g92wGb"e	>?iz$YTEg5m"{/'[T'7X.['F+8薥ذ;%a(9AԕwQ6KO9HO/j+6~T&ڜ-*+3e0/Tٟ.[FKt8@њ45bhf]oPKIaZ4wY j	-21$5r=~n7e!)-B9 s/ԭf&8ߧ䰑!mi'o_kJn4w/x怏C<G|r+vM8~=iϗk1xbGm]2s8ZZ
*K+[:Wel}hoO#7#oO-DPAWb3P3t"/Sx3{mQ|pPw8pܢ^;@OUp*jIfa7fvFWI!UXU8 r>P&+W~%E0<rQ/Q 0i)O$T~c@dѩG<ā]X?wଃeɑx`ڕ/hd,6tvQzz`<oQKM(v@ƛ`\@=NQv*33I\2=ǆb=4rL!]sUX^,W8:!p\OE+
ǃZ^	!%Q?>>>Z?<~V-:qb-;퉁s4MO{zq#ʃ1n'1Լf"ఌ*5^ɬlnzmt|%Ȇalio#^?%-Z(V!0t!If@gd[=
<A-Ypqo,_(^sϽB]}>Nݍ*l d$^HDOqA[eV|8(o1gʁ\9~qB5#^~	vc8_<-n?[KC9r,hbr9!+kzuAhǯ7\@׫Ѓ:棡aRx[{f¦5+;q$КnO;tv$z*-j	=jN+j[5ma'';BIaY̓	qA,\j*FWF_ߔ{t?bQ=a<E"%`!d~ILK3l[d@N9Qy9#EjtƥVHT2ɒ56=0Y vLuGN`FxXN8
OOԗ8۔#>\3IGn
)2|sonј}t*}9!LuS͑MY`08xOͬ,{"fY@ί}AHsʬZ}׋U^,Qz.abx4CB/<
p.fo`)~+zBhac(R~~A5DmZjfBQ)+r<d0WL)iBVۨ4jt4Dҗ|}]Se7]w5dc<EPԾ(
5vNѦ'ۯf{9_u?J}iƕI! kdk%7( 	aVfHό#u@Pu,yX#Ďtmz[ũu	1Ki^# @iWf.Z^,RtMd{b.hN4[W|V/d^ ^-$[j<s؎@GwqM`n~#e	$vNyZ	=	wQH{>:*"I^$%9{3&ӎ?ڠ}r55HDoqr"E<MEUZ$Fo40F)^crK,XƂ䎰;(o<[keBwfS&bW[^&]IB!3Y-g;PW7Yi5J2;N0Hd0=Jf3=Q?-&0L (D묁ڔDt5zdr.I@lf$Ȟ@ޘڿthc?(/ Î R}?ťY?ܛ˱{ĺ:<	=plNy>ݕ<Aߌ"!A2qO+
_f4;
:-PrmV-}g4,/rJ+C(r	DyvK(/aujфrBH#zʖ.]JV7۳N7<戎qwyAxh4պyXk~W/ijK ~~pl1U5CRcO5q4?hǋL-_b+0p	-7Ի{Wy/:ץ	tWH
uN+V',zNa0NL-xM"cK5=6sAP-zSQ+1]DlM*y79CRÃi̡feVXaC^`\0ϸK)$BtO6
yp%c)C1Y6$>.iozH]/h^rCOO57,҅5!ʧ2EzMV) q~]!M;R*Hawf-vuw{G\;t Q^*CݤgcF@Wk9uAX5L7k`cj wvjXR̲^"$?=N;mx$'eHM>VJ>^Y-^$ n8MJyJJrá]ҿFtkeGA#?jazV p	X>W($7̸ ]5kH2!mQ}
u+C	/?okm12(Q*	١ͫb'$A;Ȇ!4xE NS5?
X[pkdH^I-$mA pÓ}o!pZ};tݣi2̗&[DW!NIO0)ֳ!g{n?j\±d*޳AUU*%2;-H
߹ZWPF}̹`,|6>jo,7.{[`]+7SH`Z
5daRw$HKkK$)@.sblkjFe1	%$?oY_ŕր8!CZ"*ZN]HKeb[m4Mot\KquU0kKgOxnr# :xP{q9Sag|.XHʀb	+_B$D#w
A>B?Z-Z7[mRK2ɣH3~'	cgӍŨ ;Ғ|F`ІȬ3\Zcિ%f+*#)usn8dlc7> d^]PԶI1bK|PkivFSąl"YjݥJ6Q+3>r#]/7(j5 {H0EYu	zktx]`),yEE;ˮo_>S~U;D;b^Øm@ꖜو~F$6)k2c*DFd:BXur>ͷ'M\cd6Ww%dۂ5GFĆ"ژ*r)oWFtW`Lc'sv9r!@s@pȓlsN"|9PQU3v-И-CǴ#U]N[m?_j޺L#ç0~gsn4S`RDO&!os< #"m(QQpN;*e:Q	x$4V|E7*ރ`5Szj\agh?I/S{jIXt0E :` ظ=+
:@([U޷CWE#X+x۰ppv{zp\Aob cf 7^7 AZmi~M%LJS|,CjOeYQo
xCOstjtJ"B8vŬu}:Q8`QPŴ_ʿf@^R= ը:2
3ΟYs]E$JQ4r;0)E v%یZArfa%=/P"
4&} AA"tt`P|rKuH\F0nE7q`	'!-gq/חi	iE8o.5ǭ\w>@~qux0pۀ,ʺ?=L!:\_s!'e@MDTBeNM (3}ZCs}O(fv-/\jL?nw\jQUgmWuݡ,=STvb801KL$+AFFBՀdi"άٲNt)5$ZysҊNbFh'NRgx\mE# eNfeh[/m:ms$qjGmjΦ0QOԋnUATu34em0Jy(G鴧:6kglKdYyӠo'ru1햠a{A}hT$"4_dsךf?=cb	ҁ| L۩
GCjDO/J)'&g̔VL9Y '4YaK8&i%p	PJ裊jd\%LKD^$o^M)WUQ}	w #F#ԿIWѬ&˦IR*p=s	k9oF>kMkPߤȼĕ%]!c=N!ŇTJq'RgyI3jM+m71o0+wQDxl{'GI<f_`n
./8FK:>S4-%6hcÁHgpVy̖጑GMUv0	oPsy'eg9{^qvqBJ:R^,</*kiKB)%YH66!5<[t;
S~mWЎtR\i}Q%RR+޾frv[MWxHP&}kń
{nU|,m`͙vryh(z<dȌyP>v:fդ@j -2<sQtwyBTUˑda+UpT[)QnN/7O`uV)vVNJKD3蠅xܙ<pjRfDm^[_@ѡc|U  ĐuI $u)ΥOsͷЃZ\8w1ww}++;fk:ڹ6DNOl@۝Wvg="]/  t@
Z#ئ0J4iޢGF6-[R b;N٤]*ao@bX4;1e?1m,t_:=b3),x7Fn͈NՅw-smР18t|K㮄B1fZ5M}z
Fh1з{1Ȱ|/.<fjVn"KőkeH9G@IyUHI
2uW0J1E	󤠪iks8)L@V?92h1lIV*)OP.
S Js5tof6S5E6$хfH.r&5*LW^`XXCF&+SLv̥}5DDe	ny%tҠ2JMW3nC:~Fp]cX?Dd}IȎ\d.g>2,7h4hƌ[PV)L;)::^	٬ڍ[%!nyJHl,G14A=nf3o.tdۆ{ޡfk[F}<{mPPvL"$Pgrmők6}fDVDsƭJ~Seb8^KVpI`lиLX
`i4<<eMa<'	U͍bMZƾV2C'0ThOߨ5QCjH~7>nݨ%JWwVazIh{'W	D9ݭ6*b1S`ю/-+ZmOkE͕_ꂴq<pTɨEtAʩM`LJh.d@8^ C^j	!u	.ؽIT^ԬN|Zon:{-AMٯ.YW`&d1g̨ez:zK\ǘll&3Gr,׿xQ1L`M$bթ9zo{&0ls+ĉ~O/D+5/"pA_Yf"(?i1z'͟tNo;.+N􉶢4^QƖh"-9P5L9Q$Ǒ&>^bJ}̓hnA%H'$ |*=ÛA-m(MB#zSb$
tTwe#8U?6^NSVj%kfO}A+eB
U;<u|)lfk\!dg5PT5 Q6o6h~3<@5Gt3+&-A_uL_.}{H:?؍'PaىYŲup$3X)6C4*\ pG!
].02dl͈sAI	+n$^Qts`F0A5IgP C/CG2+끒"$~ɦ~Fk)~[~BOGP(ֶ-o-OX=M*P8zdѽyDR^ȺHD?-ȽۯPMmWJk}ux3QFMDn;wiԽܶlc+(Ap
m+a.,_s8	7
&B{@@Xs'~iz&|=DNLyE]0EQ7<梨l0L1t5A):[T/VXo?Z8 qjG0g2&F
hBRb9+ٿ<f 5tOҵv4[{u4c2m$][EjQxRNbSl8VN
ݚl8* u]c-+ CMT;9LW۶/%*k	E@.m,#|Pj?0jƟ~;i EQSPag@r&#<ġz;NTT0%ܽN76"?dKelֳ:$.	9+F]~k'0RhNoS{|kLguGyVEM;VejvA)D=iu*zP}c1zZ*DI rvuMj^T++븅Yh_]2bv]veHz~Sg\٦NaPٔ)D:[gSրpJscN.kO97h/*7VC# %~А'Y5bk{
,ܣc^H*tG_&*-:HZ-)c: s$oȷDB"Kf&l5/hlP|x0B}+C}bѨD6^۹Hdص+,S1iIz;G^Z)-3dNWD,B3&dU*FKp}"SYu0(K ŘcPPE
i5IƻdZgG"kx61taŲɽn>o-RaӚv f+'G[:;JeWD-x{IKJڀ-PJ}aC.'	Nm6
c@xEQHN['q2"_^ RrN 6[!p)d?
FB񓚗kM*{Fm	49.Os8nS#A8R*0~@8OEYx޷fϩJNk]vj4۴
^ܜĢ%u=G-ۢ `5=0qoRZ6i@XX(~݋u8bS=A%e dzir\'is'BS!_Q24?f2:^p)j%!zR1`={.$W#+aq&#:dgF.C`@⮨ZJݞdEA[D#J7KYJ'XJ xCy 9)H7:oG_ЏpNp}|IZpiIJS]C8GŴQH#'k#]rs?vDyȌA7nLs A<|ԑ hcᑨђG%v_z5}o$gdM:haIAxpZTjLuծp9[ @Qdjhu*E?~N|S.VC_ySxa]<{BIIΘσU.R1'V˕1֧ǆ_8oIprvb34_;,g$0o._ q\qi&ŗ4Gw!KTh{muá=l{w=/7Nh]GF;Lͪb)͐yR `dFCIw@\
P?vlvu{ZA ̌^gov#5pX#E)#_lR)z*
XYqN[sɡB%PA<0X?(KNCeU4X3k6@k*8B]gjv ur	^fz7k%W.8XuyEZ%DRdeZȣE%b5\3m~?OΓ#G^iC%-ё;:eW^9װu$L5|jԩ@.g&~ϱ2f9T_ڃU"T~n95t"ڡU*  GB?<Zv=,p@Ú.1Kn]E;>bl_l
`-nFjZ}
/H=C\ H,gp9$>iyz&GJ-hX!B|qE#y"	M\YIE`0yB;YFf`H!ry-ar	;% VDS§3KBNT~qC.r\2ε(?3F^d)MN
p0*
W&yP`Nᨋ2$Z8b\)onl z/(;PAFhڙ-ї]
ôX4.BQ0&#p4/!%&ԿyO-vb_ 0KN-k;_r.NS;؁ L+8qBx0%?lFq7bղ7>HF^EX0'AC'pX^'A!U%C<q3F[xN6y£b`r.[B
x,EWWa@Ao:h~x03Ϸ},TerzZE`ߓkWFu,5U?e!+5+]
xǘeD(n#/+>{aAAdH8&֙PV3C#f3=@<֍[M)4K
Wa?=0) L*+o(}%].vp!$[N]J3)&E.ᕮqz_W:J<7BCcqp-n2;q[|)A|$s3$H'4XAU-Rƣ^ūcWR[xxCTԳ U5[{gzvAA+gZ	YVxrWܻ^ٓ<ֵ֚m5gUQي50۵TYޣޤ%rcj _duKC+ֹ7,eB'8wg~b@FEj@	si5qlM!IW]PHjl2`:RF& Bgө$%vp`du[m&"y4xyJE"]6e=.;hmj$¹D	_
RvMzD%8wnRPp[H םʎuvc-6eT͜geӽrl$%Z{M=,	`A©vƃCc+!`#OyUvO[ AFιuRc͢g&EC:oxܡ8tZf1_<+Dw)!m])S	ʩQ%Cھ,W5,XZCMz\WȐo`~oژfwS &VmR
_-	){"YՌhLQ]byy,u8jNl9mP @mvYaWJ:$U4CJEL\7ɣ#Y O}Sv]f'Ys8qbo)?WSuDM=ȿc9f6|EeXoׂ7ޢ#D	"!8fS1aCtCYpVOc\uB7jʔظNRQl~BK,I/9$u6s'x]E*Gau8g4풒v&J3 ޔJ⤞}"$hR^dzm~$ 2!tBhntmpRP_2}A1]!:my7':|gyO"~R(v%p4UDUtB\e&e&IźXDKi%׭`n4u,T1|~akAuqHZF&Oj&~pY&a1cѡah[N\0!+&)N- tSCeKF4w1<+zտdDaO4.WʅrYځV4t.q5Kv{ugȯFCgC*}$J!e{	i'TEAYd̢;!xLXNd_ :՚XqV8Hj	w9yը^y~3 LB֢fu"|fDAh2c<sh!1K$jT2B@^?}װ-{}ݓi4Ez0@;چ;Q:p	QA@bZ^*]7j>QV"kw^ߞ-*MN R,/O@%
%~SJ+A}:	(#˲ =36-+`!p /+k1[$eMB%BMx^^xMO-_g8rf\t5X~|=Kަ8ѳLɄVwk]Ć0*.:J MhȱIv{݀E~ax	AiT[ NlmwY%J 5֨CGnRGezS@$M̻w}%ZԺ+`M-rsd9h=|,a@È:+
u1l	9
ȹP7ScҨ7&QϘPh"9HxE@MZʂ:*ZUmǨ<nw>r](juuS[F3S-!*h:0w!8+#<}{nr'ݰ99cU6>¤&<;@ Vn=0ś_LBc1o2ށ>'FRӛB4tb|UٝRB%!T{KU1->h%jB1	UF:+KB:|P}"4(j-[]zJ9D&r~>ݓD' K~p{G^lrUzfrs_zNpq0r;<xd:ͰǂZ bjEAngkGڠ*k׬}im9oG^N [+MwXW5k$I8Z)-{ÎIu|q"|/@y.7uD~=TqMg0VŃ)/D;C؃97g%wכN6oQ{;EeM,_gN6|qo85+@Y	ۣсFzuqugFm}ۄ$vLar&y<d@8,c\lb==0RWە:_ZG&;栣?<<Xuׇݪ;<Y(ƽnpvwj8\KeOc\;u]fG㎲3{иr0;O=-x<=Πw)*+f:pc	{V/ &gƣVax6os4+Sl0ơ =>n.(JlR <x[Ć(r Cᛑ#ԑ5!.{5?d`\QvAs⼼R}O"P<8Osg)w<,6f.@NZLmA NB5&]k[Ge^02$]3kg(lmFVoCVhXw#38RׯĞZG~CΖzezX҅tX3,w>XÊ*ZNO]\ːb;&7^&wz&{qgvuͰvi+/o*7{ه-u?&F폻aMsSRQXR?Iy1+3v
P#{6䃮̾;kڳ22fX	uǝz~)t.q@+HWIpT7GIA0:18{8?}Yd4jŵ} 7Bs(٥+,sO]/"P9y#w5;<STHiJΰvTeU {FQW+p$JEN:⃾rߡګ_FHlU[~[4h(Ma e޾9, B}3Roe
cVFyzPo.X씍V7|#LlX@#NvR~WL*gЋL%P=&W,: (ɡӌTMuNZ9l&1Ѿ;pQw%O>@eN> \&eW#DCa퓾}sx DaoL渷>鶸\"ZCR>.6r{GHSC}#/b6jǀJSSOwC5$&~aB"cGջx` 9xH*'n]y8jcTK S{RƉ1ou*[ߧ_|o.|PL(d
U$j+
nN3YN)uեӣ|uz=1*uztLjjp:h6$OaKNܧX׫ Ϲ\h)C&Qp0
΅+qHli&aEdƹ&5bJB~=A.%8ꤚSt5CTLD?L4]!i=W{6?sS1CQxC	Pˀ]*A\lΥ#hT[%ܔΨY>Ev'"\6]100l't_xr=r4rouƝHAdS#&5S`"J*ktހq
PTy!,[:rfj;#-q|^o-x0;- T79T]/5]1USTX׎!p
IԚƌ{ CvORmB_AEOO';cQ$+PL7\`7W,m`ѷٮ0DnE7-{<Gs~8*5!IKd|VHHFۍ:^'z1ևp1/Q#u'̔q{gDD_4|M<v䢀	ҼKL]#zͶHނѕ3"^^oMgGp*/Qvw1HOevOWp0]MT6iE.Nt(n["JmO##4/f)6QVڨ tV{1HdanpLGF}DQV(qP\08A;:)
+oiη*X(HBhA ͣJ3 ǘ=~{_^vkFl.nwoF_e_3aFpY 4A;Mx~8MF8Va֍zU;pҤXf޺rݨ!U=|7jNSt>P߽/UJl6*X9M#R_ *Y6wwm>~^z@┼5	Nm;ٮt9xB4/4.PsNb퉶TɷDUYábs&8j_eG+rN65d8q9	=M~K:l 䍸4zCR&Kf=7wd+]n]>0pRO%GO~,b`ԍ`
^14^l}@:%jtq;?cnz=})x.%iP>/P'S:Ng0Lv6Wl9:,UnDTej.1Wp`~'3pUJ9P<CLP^?ͤVM&\vAc8F>haDtK6[!ofx2_f{uVJmN[Q5h/t<ƕ{0P_+XAx[%{ʲ+)Jp#1pJ⎥\"ƀU)[3a<G`/
}H,6:nGx"(*ƾ98b<weöVO-&Z}LVk9^j)
<bd#mn#eh[/.TGߌ:|S8$l4CiLZ9#WI3bUw #?	|q~#؃ý\$FSaNͰm̋W<rtr^R$tۘSc.k<)$!WwEPr;I|I$&u#]V7NHu|͔pDg(5P0)*[Y~CY2?3ZAa)03ETx?콋1T꺚Sx/kё0dި:Nq~*\WHCܠF!w*Aݶb-
Mӳ1DJcj6x,K4Mm6=Xfdu*Q:ꜷ#xvK<q	un]wY]q4 @p
v^ٯשrPS	D
 LyI;TVcޠ;=ԫs}"`D%cϕ^ܩ9]YGdi;bBvXA#<wQ|hK9ZX$,p$,WIHj=ĞґQϟVVM$+yx&#qOzNM[M>9;5gwimCnBER	
Fbjgdo:&dd+E=|3@ZRXT#f8YW0pf=nad=w!s_V|5ij8,u]a~khȉ`?VSա91Tn"PKכVlZb_FBV8W7Q80CY#t`n{W9їދ!6ӎ3vn<`Rb	飬SN"]dv{w:&Bt1QE2ǉ%$~â]QD#$ک(>cR #ĬmЈW6ۧl"Ns(Y"E<y-Z:/RHuǯʁ^e7	@hoL|q*'AX](+
^pvL InU1iU҈YkydӗlH^ݺgiq7"NgQL
l$z)VV:bC}sK-n4k+W\ y(O"-fP)K|>&'vއC)9ADIE(rxuP U7`,@ #VЯl Kָ	CH	/w: iQ?slK1a|j\-=2ᛚӖ]̹DtG栧ѯ!\G.mN|XpB4hfLd?{OG<rnz}@V?J9*>3T7W{xuYSƽax٭2=Yϥxϳt<ق@Ēӄ"mupFSS7) .a4A0$Cȶjlq(VOD;~̮5/ M<Pxے1%Z]0BM%v*|py	d>dL"8\}[Mt'ꖱZ1+W4ʀTyHrkDYdwS/<sA8ۦ<h+0rKDgt2OL #*eG";t8af(rg(>c+\;?; bϧ_^|Xar^8uךlH	W.~<׮L5:ҭR&Q7:]O?Ha>jA}e,:QpHɉ
u:9]!2$]68MB<awLjC({RǌW3 CDz(sاx4a/Eu"+~8OT(.5 Ӳ{\Һ]"satf(Pʜm:d1KT!+h8h$Ӑ=j}Lp,,L=chFa{[V	>Syzūƿtqv) D4OC1uuO1$ڛ1L'?6]VqFZi0ˠvhq1lzo>\*Idڳ
W=XFFLЄs.L4N7/ԩ㵭sّ^/<;&i܇j@8cZq$ˀach=Q2lT4Y A1**֎y2>haNDa(8#\vS.{2֠G$VAuޡ O+<~>;Dg`Ev:߹rY3cuB,!-T^wŽLUh>u4Fu d j	MhaܴsdPJf!ȩP=QS9R@?*PFqY8l>
<m<v`3o>s0wEpɂBv(..({h:|,=>=`0N(XN;ӟ]h=s)gL\-513'ǥ<Mbߚ;k[n`!lX VQcp+9rφL9zֲ,lvm#\D~(<]'lqjW=8}dRva5n$[@w8P-g'QA͌u3VrkO'er|[&mr)tbSbxo_I*H0ul&E{k jHc18y^!Ĳ0[A"S^UPK[apYRO*Xt.~oiR*8}ܝ<~q_n]y"cHf禭V$o:ڧj&	ՅXϏ(u9Xcz:N~ڭ֤\9_)\_:߅f/7c[N|殩?f\óGi,ʳ)Fj6BH[ aXJgG{ÆI=|6cFrn+$ukYk"3	ax)_6~hѣezBRdkx˻\_fhv20 X,Ǧ&m"@:nC,QUWR_MςO/VrUuՅ' $h}gF$`Pؐ-'f,h 1}@Q|i$jIP}39^</q =Ȃ{0>{7jǥg+;JiV:PbN=)I7em hG=E.oOUtk';,$ۇBE/u9fJꪝ4&RA
\d&VofC㠭0o/(lkK;*<hWI_T,xG_]XU?.,ַ1:ohp<CP?Vi eث,J+jQD٘vؐߩ:V@(hn|L/qɝw7'`TG~d!YLx۪?" kt(wft
o!|8510XJ^
0K/An¬,$-arnT">Tv2ߊ:JjZdTbI?0Vtjh#A)q@XiJUOunȕ4/8<6s9ngv+Bz+gd&]IEuu躘!L%B+H`H/$j͑3mw$zRIpZȷ)7\	6CmҬM:yZ1ky>i9O-inmY1|ڪ1,^meS;h
r&TeiKbT>8UJM?!`d0_F־r^$Eyb^pOx[p&~Gc\X{!px#dF.`!+N3:3nfy&C%G:qG 5i M"`qBĎH?AZ1i;Xm
>Oajw&(QQњ47B@GäC}$MITg'E:Vס9"dT`o F%OI˗od7|G"dzŮ9 V.=&u]Bwu @aWck#a:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     f (map->cached)
		memcpy(to, (char *)map->cached + from, len);
	else
		memcpy_fromio(to, map->virt + from, len);
}

static inline void inline_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
{
	memcpy_toio(map->virt + to, from, len);
}

#ifdef CONFIG_MTD_COMPLEX_MAPPINGS
#define map_read(map, ofs) (map)->read(map, ofs)
#define map_copy_from(map, to, from, len) (map)->copy_from(map, to, from, len)
#define map_write(map, datum, ofs) (map)->write(map, datum, ofs)
#define map_copy_to(map, to, from, len) (map)->copy_to(map, to, from, len)

extern void simple_map_init(struct map_info *);
#define map_is_linear(map) (map->phys != NO_XIP)

#else
#define map_read(map, ofs) inline_map_read(map, ofs)
#define map_copy_from(map, to, from, len) inline_map_copy_from(map, to, from, len)
#define map_write(map, datum, ofs) inline_map_write(map, datum, ofs)
#define map_copy_to(map, to, from, len) inline_map_copy_to(map, to, from, len)


#define simple_map_init(map) BUG_ON(!map_bankwidth_supported((map)->bankwidth))
#define map_is_linear(map) ({ (void)(map); 1; })

#endif /* !CONFIG_MTD_COMPLEX_MAPPINGS */

#endif /* __LINUX_MTD_MAP_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * Copyright © 2000-2010 David Woodhouse <dwmw2@infradead.org> et al.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#ifndef __MTD_CFI_H__
#define __MTD_CFI_H__

#include <linux/delay.h>
#include <linux/types.h>
#include <linux/bug.h>
#include <linux/interrupt.h>
#include <linux/mtd/flashchip.h>
#include <linux/mtd/map.h>
#include <linux/mtd/cfi_endian.h>
#include <linux/mtd/xip.h>

#ifdef CONFIG_MTD_CFI_I1
#define cfi_interleave(cfi) 1
#define cfi_interleave_is_1(cfi) (cfi_interleave(cfi) == 1)
#else
#define cfi_interleave_is_1(cfi) (0)
#endif

#ifdef CONFIG_MTD_CFI_I2
# ifdef cfi_interleave
#  undef cfi_interleave
#  define cfi_interleave(cfi) ((cfi)->interleave)
# else
#  define cfi_interleave(cfi) 2
# endif
#define cfi_interleave_is_2(cfi) (cfi_interleave(cfi) == 2)
#else
#define cfi_interleave_is_2(cfi) (0)
#endif

#ifdef CONFIG_MTD_CFI_I4
# ifdef cfi_interleave
#  undef cfi_interleave
#  define cfi_interleave(cfi) ((cfi)->interleave)
# else
#  define cfi_interleave(cfi) 4
# endif
#define cfi_interleave_is_4(cfi) (cfi_interleave(cfi) == 4)
#else
#define cfi_interleave_is_4(cfi) (0)
#endif

#ifdef CONFIG_MTD_CFI_I8
# ifdef cfi_interleave
#  undef cfi_interleave
#  define cfi_interleave(cfi) ((cfi)->interleave)
# else
#  define cfi_interleave(cfi) 8
# endif
#define cfi_interleave_is_8(cfi) (cfi_interleave(cfi) == 8)
#else
#define cfi_interleave_is_8(cfi) (0)
#endif

#ifndef cfi_interleave
#warning No CONFIG_MTD_CFI_Ix selected. No NOR chip support can work.
static inline int cfi_interleave(void *cfi)
{
	BUG();
	return 0;
}
#endif

static inline int cfi_interleave_supported(int i)
{
	switch (i) {
#ifdef CONFIG_MTD_CFI_I1
	case 1:
#endif
#ifdef CONFIG_MTD_CFI_I2
	case 2:
#endif
#ifdef CONFIG_MTD_CFI_I4
	case 4:
#endif
#ifdef CONFIG_MTD_CFI_I8
	case 8:
#endif
		return 1;

	default:
		return 0;
	}
}


/* NB: these values must represents the number of bytes needed to meet the
 *     device type (x8, x16, x32).  Eg. a 32 bit device is 4 x 8 bytes.
 *     These numbers are used in calculations.
 */
#define CFI_DEVICETYPE_X8  (8 / 8)
#define CFI_DEVICETYPE_X16 (16 / 8)
#define CFI_DEVICETYPE_X32 (32 / 8)
#define CFI_DEVICETYPE_X64 (64 / 8)


/* Device Interface Code Assignments from the "Common Flash Memory Interface
 * Publication 100" dated December 1, 2001.
 */
#define CFI_INTERFACE_X8_ASYNC		0x0000
#define CFI_INTERFACE_X16_ASYNC		0x0001
#define CFI_INTERFACE_X8_BY_X16_ASYNC	0x0002
#define CFI_INTERFACE_X32_ASYNC		0x0003
#define CFI_INTERFACE_X16_BY_X32_ASYNC	0x0005
#define CFI_INTERFACE_NOT_ALLOWED	0xffff


/* NB: We keep these structures in memory in HOST byteorder, except
 * where individually noted.
 */

/* Basic Query Structure */
struct cfi_ident {
	uint8_t  qry[3];
	uint16_t P_ID;
	uint16_t P_ADR;
	uint16_t A_ID;
	uint16_t A_ADR;
	uint8_t  VccMin;
	uint8_t  VccMax;
	uint8_t  VppMin;
	uint8_t  VppMax;
	uint8_t  WordWriteTimeoutTyp;
	uint8_t  BufWriteTimeoutTyp;
	uint8_t  BlockEraseTimeoutTyp;
	uint8_t  ChipEraseTimeoutTyp;
	uint8_t  WordWriteTimeoutMax;
	uint8_t  BufWriteTimeoutMax;
	uint8_t  BlockEraseTimeoutMax;
	uint8_t  ChipEraseTimeoutMax;
	uint8_t  DevSize;
	uint16_t InterfaceDesc;
	uint16_t MaxBufWriteSize;
	uint8_t  NumEraseRegions;
	uint32_t EraseRegionInfo[0]; /* Not host ordered */
} __packed;

/* Extended Query Structure for both PRI and ALT */

struct cfi_extquery {
	uint8_t  pri[3];
	uint8_t  MajorVersion;
	uint8_t  MinorVersion;
} __packed;

/* Vendor-Specific PRI for Intel/Sharp Extended Command Set (0x0001) */

struct cfi_pri_intelext {
	uint8_t  pri[3];
	uint8_t  MajorVersion;
	uint8_t  MinorVersion;
	uint32_t FeatureSupport; /* if bit 31 is set then an additional uint32_t feature
				    block follows - FIXME - not currently supported */
	uint8_t  SuspendCmdSupport;
	uint16_t BlkStatusRegMask;
	uint8_t  VccOptimal;
	uint8_t  VppOptimal;
	uint8_t  NumProtectionFields;
	uint16_t ProtRegAddr;
	uint8_t  FactProtRegSize;
	uint8_t  UserProtRegSize;
	uint8_t  extra[0];
} __packed;

struct cfi_intelext_otpinfo {
	uint32_t ProtRegAddr;
	uint16_t FactGroups;
	uint8_t  FactProtRegSize;
	uint16_t UserGroups;
	uint8_t  UserProtRegSize;
} __packed;

struct cfi_intelext_blockinfo {
	uint16_t NumIdentBlocks;
	uint16_t BlockSize;
	uint16_t MinBlockEraseCycles;
	uint8_t  BitsPerCell;
	uint8_t  BlockCap;
} __packed;

struct cfi_intelext_regioninfo {
	uint16_t NumIdentPartitions;
	uint8_t  NumOpAllowed;
	uint8_t  NumOpAllowedSimProgMode;
	uint8_t  NumOpAllowedSimEraMode;
	uint8_t  NumBlockTypes;
	struct cfi_intelext_blockinfo BlockTypes[1];
} __packed;

struct cfi_intelext_programming_regioninfo {
	uint8_t  ProgRegShift;
	uint8_t  Reserved1;
	uint8_t  ControlValid;
	uint8_t  Reserved2;
	uint8_t  ControlInvalid;
	uint8_t  Reserved3;
} __packed;

/* Vendor-Specific PRI for AMD/Fujitsu Extended Command Set (0x0002) */

struct cfi_pri_amdstd {
	uint8_t  pri[3];
	uint8_t  MajorVersion;
	uint8_t  MinorVersion;
	uint8_t  SiliconRevision; /* bits 1-0: Address Sensitive Unlock */
	uint8_t  EraseSuspend;
	uint8_t  BlkProt;
	uint8_t  TmpBlkUnprotect;
	uint8_t  BlkProtUnprot;
	uint8_t  SimultaneousOps;
	uint8_t  BurstMode;
	uint8_t  PageMode;
	uint8_t  VppMin;
	uint8_t  VppMax;
	uint8_t  TopBottom;
} __packed;

/* Vendor-Specific PRI for Atmel chips (command set 0x0002) */

struct cfi_pri_atmel {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint8_t Features;
	uint8_t BottomBoot;
	uint8_t BurstMode;
	uint8_t PageMode;
} __packed;

struct cfi_pri_query {
	uint8_t  NumFields;
	uint32_t ProtField[1]; /* Not host ordered */
} __packed;

struct cfi_bri_query {
	uint8_t  PageModeReadCap;
	uint8_t  NumFields;
	uint32_t ConfField[1]; /* Not host ordered */
} __packed;

#define P_ID_NONE               0x0000
#define P_ID_INTEL_EXT          0x0001
#define P_ID_AMD_STD            0x0002
#define P_ID_INTEL_STD          0x0003
#define P_ID_AMD_EXT            0x0004
#define P_ID_WINBOND            0x0006
#define P_ID_ST_ADV             0x0020
#define P_ID_MITSUBISHI_STD     0x0100
#define P_ID_MITSUBISHI_EXT     0x0101
#define P_ID_SST_PAGE           0x0102
#define P_ID_SST_OLD            0x0701
#define P_ID_INTEL_PERFORMANCE  0x0200
#define P_ID_INTEL_DATA         0x0210
#define P_ID_RESERVED           0xffff


#define CFI_MODE_CFI	1
#define CFI_MODE_JEDEC	0

struct cfi_private {
	uint16_t cmdset;
	void *cmdset_priv;
	int interleave;
	int device_type;
	int cfi_mode;		/* Are we a JEDEC device pretending to be CFI? */
	int addr_unlock1;
	int addr_unlock2;
	struct mtd_info *(*cmdset_setup)(struct map_info *);
	struct cfi_ident *cfiq; /* For now only one. We insist that all devs
				  must be of the same type. */
	int mfr, id;
	int numchips;
	map_word sector_erase_cmd;
	unsigned long chipshift; /* Because they're of the same type */
	const char *im_name;	 /* inter_module name for cmdset_setup */
	struct flchip chips[0];  /* per-chip data structure for each chip */
};

/*
 * Returns the command address according to the given geometry.
 */
static inline uint32_t cfi_build_cmd_addr(uint32_t cmd_ofs,
				struct map_info *map, struct cfi_private *cfi)
{
	unsigned bankwidth = map_bankwidth(map);
	unsigned interleave = cfi_interleave(cfi);
	unsigned type = cfi->device_type;
	uint32_t addr;
	
	addr = (cmd_ofs * type) * interleave;

	/* Modify the unlock address if we are in compatibility mode.
	 * For 16bit devices on 8 bit busses
	 * and 32bit devices on 16 bit busses
	 * set the low bit of the alternating bit sequence of the address.
	 */
	if (((type * interleave) > bankwidth) && ((cmd_ofs & 0xff) == 0xaa))
		addr |= (type >> 1)*interleave;

	return  addr;
}

/*
 * Transforms the CFI command for the given geometry (bus width & interleave).
 * It looks too long to be inline, but in the common case it should almost all
 * get optimised away.
 */
static inline map_word cfi_build_cmd(u_long cmd, struct map_info *map, struct cfi_private *cfi)
{
	map_word val = { {0} };
	int wordwidth, words_per_bus, chip_mode, chips_per_word;
	unsigned long onecmd;
	int i;

	/* We do it this way to give the compiler a fighting chance
	   of optimising away all the crap for 'bankwidth' larger than
	   an unsigned long, in the common case where that support is
	   disabled */
	if (map_bankwidth_is_large(map)) {
		wordwidth = sizeof(unsigned long);
		words_per_bus = (map_bankwidth(map)) / wordwidth; // i.e. normally 1
	} else {
		wordwidth = map_bankwidth(map);
		words_per_bus = 1;
	}

	chip_mode = map_bankwidth(map) / cfi_interleave(cfi);
	chips_per_word = wordwidth * cfi_interleave(cfi) / map_bankwidth(map);

	/* First, determine what the bit-pattern should be for a single
	   device, according to chip mode and endianness... */
	switch (chip_mode) {
	default: BUG();
	case 1:
		onecmd = cmd;
		break;
	case 2:
		onecmd = cpu_to_cfi16(map, cmd);
		break;
	case 4:
		onecmd = cpu_to_cfi32(map, cmd);
		break;
	}

	/* Now replicate it across the size of an unsigned long, or
	   just to the bus width as appropriate */
	switch (chips_per_word) {
	default: BUG();
#if BITS_PER_LONG >= 64
	case 8:
		onecmd |= (onecmd << (chip_mode * 32));
#endif
	case 4:
		onecmd |= (onecmd << (chip_mode * 16));
	case 2:
		onecmd |= (onecmd << (chip_mode * 8));
	case 1:
		;
	}

	/* And finally, for the multi-word case, replicate it
	   in all words in the structure */
	for (i=0; i < words_per_bus; i++) {
		val.x[i] = onecmd;
	}

	return val;
}
#define CMD(x)  cfi_build_cmd((x), map, cfi)


static inline unsigned long cfi_merge_status(map_word val, struct map_info *map,
					   struct cfi_private *cfi)
{
	int wordwidth, words_per_bus, chip_mode, chips_per_word;
	unsigned long onestat, res = 0;
	int i;

	/* We do it this way to give the compiler a fighting chance
	   of optimising away all the crap for 'bankwidth' larger than
	   an unsigned long, in the common case where that support is
	   disabled */
	if (map_bankwidth_is_large(map)) {
		wordwidth = sizeof(unsigned long);
		words_per_bus = (map_bankwidth(map)) / wordwidth; // i.e. normally 1
	} else {
		wordwidth = map_bankwidth(map);
		words_per_bus = 1;
	}

	chip_mode = map_bankwidth(map) / cfi_interleave(cfi);
	chips_per_word = wordwidth * cfi_interleave(cfi) / map_bankwidth(map);

	onestat = val.x[0];
	/* Or all status words together */
	for (i=1; i < words_per_bus; i++) {
		onestat |= val.x[i];
	}

	res = onestat;
	switch(chips_per_word) {
	default: BUG();
#if BITS_PER_LONG >= 64
	case 8:
		res |= (onestat >> (chip_mode * 32));
#endif
	case 4:
		res |= (onestat >> (chip_mode * 16));
	case 2:
		res |= (onestat >> (chip_mode * 8));
	case 1:
		;
	}

	/* Last, determine what the bit-pattern should be for a single
	   device, according to chip mode and endianness... */
	switch (chip_mode) {
	case 1:
		break;
	case 2:
		res = cfi16_to_cpu(map, res);
		break;
	case 4:
		res = cfi32_to_cpu(map, res);
		break;
	default: BUG();
	}
	return res;
}

#define MERGESTATUS(x) cfi_merge_status((x), map, cfi)


/*
 * Sends a CFI command to a bank of flash for the given geometry.
 *
 * Returns the offset in flash where the command was written.
 * If prev_val is non-null, it will be set to the value at the command address,
 * before the command was written.
 */
static inline uint32_t cfi_send_gen_cmd(u_char cmd, uint32_t cmd_addr, uint32_t base,
				struct map_info *map, struct cfi_private *cfi,
				int type, map_word *prev_val)
{
	map_word val;
	uint32_t addr = base + cfi_build_cmd_addr(cmd_addr, map, cfi);
	val = cfi_build_cmd(cmd, map, cfi);

	if (prev_val)
		*prev_val = map_read(map, addr);

	map_write(map, val, addr);

	return addr - base;
}

static inline uint8_t cfi_read_query(struct map_info *map, uint32_t addr)
{
	map_word val = map_read(map, addr);

	if (map_bankwidth_is_1(map)) {
		return val.x[0];
	} else if (map_bankwidth_is_2(map)) {
		return cfi16_to_cpu(map, val.x[0]);
	} else {
		/* No point in a 64-bit byteswap since that would just be
		   swapping the responses from different chips, and we are
		   only interested in one chip (a representative sample) */
		return cfi32_to_cpu(map, val.x[0]);
	}
}

static inline uint16_t cfi_read_query16(struct map_info *map, uint32_t addr)
{
	map_word val = map_read(map, addr);

	if (map_bankwidth_is_1(map)) {
		return val.x[0] & 0xff;
	} else if (map_bankwidth_is_2(map)) {
		return cfi16_to_cpu(map, val.x[0]);
	} else {
		/* No point in a 64-bit byteswap since that would just be
		   swapping the responses from different chips, and we are
		   only interested in one chip (a representative sample) */
		return cfi32_to_cpu(map, val.x[0]);
	}
}

static inline void cfi_udelay(int us)
{
	if (us >= 1000) {
		msleep((us+999)/1000);
	} else {
		udelay(us);
		cond_resched();
	}
}

int __xipram cfi_qry_present(struct map_info *map, __u32 base,
			     struct cfi_private *cfi);
int __xipram cfi_qry_mode_on(uint32_t base, struct map_info *map,
			     struct cfi_private *cfi);
void __xipram cfi_qry_mode_off(uint32_t base, struct map_info *map,
			       struct cfi_private *cfi);

struct cfi_extquery *cfi_read_pri(struct map_info *map, uint16_t adr, uint16_t size,
			     const char* name);
struct cfi_fixup {
	uint16_t mfr;
	uint16_t id;
	void (*fixup)(struct mtd_info *mtd);
};

#define CFI_MFR_ANY		0xFFFF
#define CFI_ID_ANY		0xFFFF
#define CFI_MFR_CONTINUATION	0x007F

#define CFI_MFR_AMD		0x0001
#define CFI_MFR_AMIC		0x0037
#define CFI_MFR_ATMEL		0x001F
#define CFI_MFR_EON		0x001C
#define CFI_MFR_FUJITSU		0x0004
#define CFI_MFR_HYUNDAI		0x00AD
#define CFI_MFR_INTEL		0x0089
#define CFI_MFR_MACRONIX	0x00C2
#define CFI_MFR_NEC		0x0010
#define CFI_MFR_PMC		0x009D
#define CFI_MFR_SAMSUNG		0x00EC
#define CFI_MFR_SHARP		0x00B0
#define CFI_MFR_SST		0x00BF
#define CFI_MFR_ST		0x0020 /* STMicroelectronics */
#define CFI_MFR_TOSHIBA		0x0098
#define CFI_MFR_WINBOND		0x00DA

void cfi_fixup(struct mtd_info *mtd, struct cfi_fixup* fixups);

typedef int (*varsize_frob_t)(struct map_info *map, struct flchip *chip,
			      unsigned long adr, int len, void *thunk);

int cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,
	loff_t ofs, size_t len, void *thunk);


#endif /* __MTD_CFI_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * Copyright © 2010 ST Microelectronics
 * Shiraz Hashim <shiraz.linux.kernel@gmail.com>
 *
 * This file is licensed under the terms of the GNU General Public
 * License version 2. This program is licensed "as is" without any
 * warranty of any kind, whether express or implied.
 */

#ifndef __MTD_SPEAR_SMI_H
#define __MTD_SPEAR_SMI_H

#include <linux/types.h>
#include <linux/mtd/mtd.h>
#include <linux/mtd/partitions.h>
#include <linux/platform_device.h>
#include <linux/of.h>

/* max possible slots for serial-nor flash chip in the SMI controller */
#define MAX_NUM_FLASH_CHIP	4

/* macro to define partitions for flash devices */
#define DEFINE_PARTS(n, of, s)		\
{					\
	.name = n,			\
	.offset = of,			\
	.size = s,			\
}

/**
 * struct spear_smi_flash_info - platform structure for passing flash
 * information
 *
 * name: name of the serial nor flash for identification
 * mem_base: the memory base on which the flash is mapped
 * size: size of the flash in bytes
 * partitions: parition details
 * nr_partitions: number of partitions
 * fast_mode: whether flash supports fast mode
 */

struct spear_smi_flash_info {
	char *name;
	unsigned long mem_base;
	unsigned long size;
	struct mtd_partition *partitions;
	int nr_partitions;
	u8 fast_mode;
};

/**
 * struct spear_smi_plat_data - platform structure for configuring smi
 *
 * clk_rate: clk rate at which SMI must operate
 * num_flashes: number of flashes present on board
 * board_flash_info: specific details of each flash present on board
 */
struct spear_smi_plat_data {
	unsigned long clk_rate;
	int num_flashes;
	struct spear_smi_flash_info *board_flash_info;
	struct device_node *np[MAX_NUM_FLASH_CHIP];
};

#endif /* __MTD_SPEAR_SMI_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 *  drivers/mtd/nand_ecc.h
 *
 *  Copyright (C) 2000-2010 Steven J. Hill <sjhill@realitydiluted.com>
 *			    David Woodhouse <dwmw2@infradead.org>
 *			    Thomas Gleixner <tglx@linutronix.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This file is the header for the ECC algorithm.
 */

#ifndef __MTD_NAND_ECC_H__
#define __MTD_NAND_ECC_H__

struct mtd_info;

/*
 * Calculate 3 byte ECC code for eccsize byte block
 */
void __nand_calculate_ecc(const u_char *dat, unsigned int eccsize,
				u_char *ecc_code);

/*
 * Calculate 3 byte ECC code for 256/512 byte block
 */
int nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code);

/*
 * Detect and correct a 1 bit error for eccsize byte block
 */
int __nand_correct_data(u_char *dat, u_char *read_ecc, u_char *calc_ecc,
			unsigned int eccsize);

/*
 * Detect and correct a 1 bit error for 256/512 byte block
 */
int nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc);

#endif /* __MTD_NAND_ECC_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * OMAP GPIO handling defines and functions
 *
 * Copyright (C) 2003-2005 Nokia Corporation
 *
 * Written by Juha Yrjölä <juha.yrjola@nokia.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */

#ifndef __ASM_ARCH_OMAP_GPIO_H
#define __ASM_ARCH_OMAP_GPIO_H

#include <linux/io.h>
#include <linux/platform_device.h>

#define OMAP1_MPUIO_BASE			0xfffb5000

/*
 * These are the omap15xx/16xx offsets. The omap7xx offset are
 * OMAP_MPUIO_ / 2 offsets below.
 */
#define OMAP_MPUIO_INPUT_LATCH		0x00
#define OMAP_MPUIO_OUTPUT		0x04
#define OMAP_MPUIO_IO_CNTL		0x08
#define OMAP_MPUIO_KBR_LATCH		0x10
#define OMAP_MPUIO_KBC			0x14
#define OMAP_MPUIO_GPIO_EVENT_MODE	0x18
#define OMAP_MPUIO_GPIO_INT_EDGE	0x1c
#define OMAP_MPUIO_KBD_INT		0x20
#define OMAP_MPUIO_GPIO_INT		0x24
#define OMAP_MPUIO_KBD_MASKIT		0x28
#define OMAP_MPUIO_GPIO_MASKIT		0x2c
#define OMAP_MPUIO_GPIO_DEBOUNCING	0x30
#define OMAP_MPUIO_LATCH		0x34

#define OMAP34XX_NR_GPIOS		6

/*
 * OMAP1510 GPIO registers
 */
#define OMAP1510_GPIO_DATA_INPUT	0x00
#define OMAP1510_GPIO_DATA_OUTPUT	0x04
#define OMAP1510_GPIO_DIR_CONTROL	0x08
#define OMAP1510_GPIO_INT_CONTROL	0x0c
#define OMAP1510_GPIO_INT_MASK		0x10
#define OMAP1510_GPIO_INT_STATUS	0x14
#define OMAP1510_GPIO_PIN_CONTROL	0x18

#define OMAP1510_IH_GPIO_BASE		64

/*
 * OMAP1610 specific GPIO registers
 */
#define OMAP1610_GPIO_REVISION		0x0000
#define OMAP1610_GPIO_SYSCONFIG		0x0010
#define OMAP1610_GPIO_SYSSTATUS		0x0014
#define OMAP1610_GPIO_IRQSTATUS1	0x0018
#define OMAP1610_GPIO_IRQENABLE1	0x001c
#define OMAP1610_GPIO_WAKEUPENABLE	0x0028
#define OMAP1610_GPIO_DATAIN		0x002c
#define OMAP1610_GPIO_DATAOUT		0x0030
#define OMAP1610_GPIO_DIRECTION		0x0034
#define OMAP1610_GPIO_EDGE_CTRL1	0x0038
#define OMAP1610_GPIO_EDGE_CTRL2	0x003c
#define OMAP1610_GPIO_CLEAR_IRQENABLE1	0x009c
#define OMAP1610_GPIO_CLEAR_WAKEUPENA	0x00a8
#define OMAP1610_GPIO_CLEAR_DATAOUT	0x00b0
#define OMAP1610_GPIO_SET_IRQENABLE1	0x00dc
#define OMAP1610_GPIO_SET_WAKEUPENA	0x00e8
#define OMAP1610_GPIO_SET_DATAOUT	0x00f0

/*
 * OMAP7XX specific GPIO registers
 */
#define OMAP7XX_GPIO_DATA_INPUT		0x00
#define OMAP7XX_GPIO_DATA_OUTPUT	0x04
#define OMAP7XX_GPIO_DIR_CONTROL	0x08
#define OMAP7XX_GPIO_INT_CONTROL	0x0c
#define OMAP7XX_GPIO_INT_MASK		0x10
#define OMAP7XX_GPIO_INT_STATUS		0x14

/*
 * omap2+ specific GPIO registers
 */
#define OMAP24XX_GPIO_REVISION		0x0000
#define OMAP24XX_GPIO_IRQSTATUS1	0x0018
#define OMAP24XX_GPIO_IRQSTATUS2	0x0028
#define OMAP24XX_GPIO_IRQENABLE2	0x002c
#define OMAP24XX_GPIO_IRQENABLE1	0x001c
#define OMAP24XX_GPIO_WAKE_EN		0x0020
#define OMAP24XX_GPIO_CTRL		0x0030
#define OMAP24XX_GPIO_OE		0x0034
#define OMAP24XX_GPIO_DATAIN		0x0038
#define OMAP24XX_GPIO_DATAOUT		0x003c
#define OMAP24XX_GPIO_LEVELDETECT0	0x0040
#define OMAP24XX_GPIO_LEVELDETECT1	0x0044
#define OMAP24XX_GPIO_RISINGDETECT	0x0048
#define OMAP24XX_GPIO_FALLINGDETECT	0x004c
#define OMAP24XX_GPIO_DEBOUNCE_EN	0x0050
#define OMAP24XX_GPIO_DEBOUNCE_VAL	0x0054
#define OMAP24XX_GPIO_CLEARIRQENABLE1	0x0060
#define OMAP24XX_GPIO_SETIRQENABLE1	0x0064
#define OMAP24XX_GPIO_CLEARWKUENA	0x0080
#define OMAP24XX_GPIO_SETWKUENA		0x0084
#define OMAP24XX_GPIO_CLEARDATAOUT	0x0090
#define OMAP24XX_GPIO_SETDATAOUT	0x0094

#define OMAP4_GPIO_REVISION		0x0000
#define OMAP4_GPIO_EOI			0x0020
#define OMAP4_GPIO_IRQSTATUSRAW0	0x0024
#define OMAP4_GPIO_IRQSTATUSRAW1	0x0028
#define OMAP4_GPIO_IRQSTATUS0		0x002c
#define OMAP4/.
/usr
/usr/bin
/usr/bin/vimtutor
/usr/share
/usr/share/vim
/usr/share/vim/registry
/usr/share/vim/registry/vim-runtime.yaml
/usr/share/vim/addons
/usr/share/vim/addons/doc
/usr/share/vim/addons/plugin
/usr/share/vim/vim74
/usr/share/vim/vim74/optwin.vim
/usr/share/vim/vim74/lang
/usr/share/vim/vim74/lang/menu_sr_yu.iso_8859-2.vim
/usr/share/vim/vim74/lang/menu_zh.cp936.vim
/usr/share/vim/vim74/lang/menu_uk_ua.koi8-u.vim
/usr/share/vim/vim74/lang/menu_cs_cz.cp1250.vim
/usr/share/vim/vim74/lang/menu_hu.iso_8859-2.vim
/usr/share/vim/vim74/lang/menu_uk_ua.cp1251.vim
/usr/share/vim/vim74/lang/menu_de_de.utf-8.vim
/usr/share/vim/vim74/lang/no
/usr/share/vim/vim74/lang/no/LC_MESSAGES
/usr/share/vim/vim74/lang/no/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/pt_BR
/usr/share/vim/vim74/lang/pt_BR/LC_MESSAGES
/usr/share/vim/vim74/lang/pt_BR/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_sr_rs.iso_8859-2.vim
/usr/share/vim/vim74/lang/menu_nl_nl.utf-8.vim
/usr/share/vim/vim74/lang/menu_ja_jp.euc-jp.vim
/usr/share/vim/vim74/lang/ja.euc-jp
/usr/share/vim/vim74/lang/ja.euc-jp/LC_MESSAGES
/usr/share/vim/vim74/lang/ja.euc-jp/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_nl.latin1.vim
/usr/share/vim/vim74/lang/uk.cp1251
/usr/share/vim/vim74/lang/uk.cp1251/LC_MESSAGES
/usr/share/vim/vim74/lang/uk.cp1251/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_spanish_spain.850.vim
/usr/share/vim/vim74/lang/menu_sv.latin1.vim
/usr/share/vim/vim74/lang/menu_eo_eo.utf-8.vim
/usr/share/vim/vim74/lang/menu_pt_br.vim
/usr/share/vim/vim74/lang/menu_sl_si.latin2.vim
/usr/share/vim/vim74/lang/pl
/usr/share/vim/vim74/lang/pl/LC_MESSAGES
/usr/share/vim/vim74/lang/pl/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_hu_hu.utf-8.vim
/usr/share/vim/vim74/lang/menu_pl_pl.iso_8859-2.vim
/usr/share/vim/vim74/lang/menu_es.utf-8.vim
/usr/share/vim/vim74/lang/menu_sr_yu.iso_8859-5.vim
/usr/share/vim/vim74/lang/cs
/usr/share/vim/vim74/lang/cs/LC_MESSAGES
/usr/share/vim/vim74/lang/cs/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_no_no.utf-8.vim
/usr/share/vim/vim74/lang/uk
/usr/share/vim/vim74/lang/uk/LC_MESSAGES
/usr/share/vim/vim74/lang/uk/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_cs_cz.iso_8859-2.vim
/usr/share/vim/vim74/lang/menu_es.latin1.vim
/usr/share/vim/vim74/lang/menu_sv_se.utf-8.vim
/usr/share/vim/vim74/lang/menu_zh.big5.vim
/usr/share/vim/vim74/lang/ja
/usr/share/vim/vim74/lang/ja/LC_MESSAGES
/usr/share/vim/vim74/lang/ja/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/es
/usr/share/vim/vim74/lang/es/LC_MESSAGES
/usr/share/vim/vim74/lang/es/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_nl.utf-8.vim
/usr/share/vim/vim74/lang/menu_chinese_gb.936.vim
/usr/share/vim/vim74/lang/menu_sk_sk.iso_8859-2.vim
/usr/share/vim/vim74/lang/menu_ja_jp.cp932.vim
/usr/share/vim/vim74/lang/vi
/usr/share/vim/vim74/lang/vi/LC_MESSAGES
/usr/share/vim/vim74/lang/vi/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/ko
/usr/share/vim/vim74/lang/ko/LC_MESSAGES
/usr/share/vim/vim74/lang/ko/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_sk_sk.cp1250.vim
/usr/share/vim/vim74/lang/sk.cp1250
/usr/share/vim/vim74/lang/sk.cp1250/LC_MESSAGES
/usr/share/vim/vim74/lang/sk.cp1250/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_hu.utf-8.vim
/usr/share/vim/vim74/lang/nb
/usr/share/vim/vim74/lang/nb/LC_MESSAGES
/usr/share/vim/vim74/lang/nb/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/zh_TW
/usr/share/vim/vim74/lang/zh_TW/LC_MESSAGES
/usr/share/vim/vim74/lang/zh_TW/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_eo_xx.utf-8.vim
/usr/share/vim/vim74/lang/af
/usr/share/vim/vim74/lang/af/LC_MESSAGES
/usr/share/vim/vim74/lang/af/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_ko_kr.vim
/usr/share/vim/vim74/lang/menu_english_united_kingdom.1252.vim
/usr/share/vim/vim74/lang/menu_ca.utf-8.vim
/usr/share/vim/vim74/lang/menu_it.utf-8.vim
/usr/share/vim/vim74/lang/menu_fi.utf-8.vim
/usr/share/vim/vim74/lang/menu_fr.utf-8.vim
/usr/share/vim/vim74/lang/menu_cs.latin1.vim
/usr/share/vim/vim74/lang/menu_it.latin1.vim
/usr/share/vim/vim74/lang/menu_chinese(taiwan)_taiwan.950.vim
/usr/share/vim/vim74/lang/menu_ja.utf-8.vim
/usr/share/vim/vim74/lang/fi
/usr/share/vim/vim74/lang/fi/LC_MESSAGES
/usr/share/vim/vim74/lang/fi/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_af_af.latin1.vim
/usr/share/vim/vim74/lang/menu_pl_pl.utf-8.vim
/usr/share/vim/vim74/lang/menu_sr_rs.ascii.vim
/usr/share/vim/vim74/lang/menu_de.utf-8.vim
/usr/share/vim/vim74/lang/menu_pt_pt.latin1.vim
/usr/share/vim/vim74/lang/menu_sl_si.cp1250.vim
/usr/share/vim/vim74/lang/menu_sr_yu.utf-8.vim
/usr/share/vim/vim74/lang/menu_fr.latin1.vim
/usr/share/vim/vim74/lang/menu_polish_poland.1250.vim
/usr/share/vim/vim74/lang/cs.cp1250
/usr/share/vim/vim74/lang/cs.cp1250/LC_MESSAGES
/usr/share/vim/vim74/lang/cs.cp1250/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_fi_fi.latin1.vim
/usr/share/vim/vim74/lang/menu_zh_tw.big5.vim
/usr/share/vim/vim74/lang/menu_cs_cz.latin1.vim
/usr/share/vim/vim74/lang/menu_zh_tw.cp950.vim
/usr/share/vim/vim74/lang/menu_zh_cn.cp936.vim
/usr/share/vim/vim74/lang/menu_af_af.utf-8.vim
/usr/share/vim/vim74/lang/ca
/usr/share/vim/vim74/lang/ca/LC_MESSAGES
/usr/share/vim/vim74/lang/ca/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/zh_CN.cp936
/usr/share/vim/vim74/lang/zh_CN.cp936/LC_MESSAGES
/usr/share/vim/vim74/lang/zh_CN.cp936/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/ja.sjis
/usr/share/vim/vim74/lang/ja.sjis/LC_MESSAGES
/usr/share/vim/vim74/lang/ja.sjis/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_ja.ujis.vim
/usr/share/vim/vim74/lang/menu_chinese(gb)_gb.936.vim
/usr/share/vim/vim74/lang/fr
/usr/share/vim/vim74/lang/fr/LC_MESSAGES
/usr/share/vim/vim74/lang/fr/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_sr_yu.ascii.vim
/usr/share/vim/vim74/lang/menu_japanese_japan.932.vim
/usr/share/vim/vim74/lang/menu_no.utf-8.vim
/usr/share/vim/vim74/lang/menu_sr_rs.iso_8859-5.vim
/usr/share/vim/vim74/lang/menu_fi.latin1.vim
/usr/share/vim/vim74/lang/menu_chinese_taiwan.950.vim
/usr/share/vim/vim74/lang/menu_ru_ru.vim
/usr/share/vim/vim74/lang/menu_ca_es.latin1.vim
/usr/share/vim/vim74/lang/menu_slovak_slovak_republic.1250.vim
/usr/share/vim/vim74/lang/menu_czech_czech_republic.1252.vim
/usr/share/vim/vim74/lang/menu_ca.latin1.vim
/usr/share/vim/vim74/lang/menu_es_es.latin1.vim
/usr/share/vim/vim74/lang/menu_sr.utf-8.vim
/usr/share/vim/vim74/lang/menu_ko_kr.utf-8.vim
/usr/share/vim/vim74/lang/en_GB
/usr/share/vim/vim74/lang/en_GB/LC_MESSAGES
/usr/share/vim/vim74/lang/en_GB/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_ko_kr.euckr.vim
/usr/share/vim/vim74/lang/pl.cp1250
/usr/share/vim/vim74/lang/pl.cp1250/LC_MESSAGES
/usr/share/vim/vim74/lang/pl.cp1250/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_zh_cn.18030.vim
/usr/share/vim/vim74/lang/menu_cs.cp1250.vim
/usr/share/vim/vim74/lang/ru.cp1251
/usr/share/vim/vim74/lang/ru.cp1251/LC_MESSAGES
/usr/share/vim/vim74/lang/ru.cp1251/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_en_gb.latin1.vim
/usr/share/vim/vim74/lang/menu_ja_jp.utf-8.vim
/usr/share/vim/vim74/lang/menu_ru.utf-8.vim
/usr/share/vim/vim74/lang/menu_ru_ru.utf-8.vim
/usr/share/vim/vim74/lang/menu_sk_sk.vim
/usr/share/vim/vim74/lang/menu_german_germany.1252.vim
/usr/share/vim/vim74/lang/menu_zh_cn.utf-8.vim
/usr/share/vim/vim74/lang/menu_pl.cp1250.vim
/usr/share/vim/vim74/lang/menu_no_no.latin1.vim
/usr/share/vim/vim74/lang/menu_sl_si.utf-8.vim
/usr/share/vim/vim74/lang/menu_zh_tw.utf-8.vim
/usr/share/vim/vim74/lang/menu_zh.gb2312.vim
/usr/share/vim/vim74/lang/menu_cs_cz.utf-8.vim
/usr/share/vim/vim74/lang/sk
/usr/share/vim/vim74/lang/sk/LC_MESSAGES
/usr/share/vim/vim74/lang/sk/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_sr_rs.utf-8.vim
/usr/share/vim/vim74/lang/de
/usr/share/vim/vim74/lang/de/LC_MESSAGES
/usr/share/vim/vim74/lang/de/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_nl_nl.latin1.vim
/usr/share/vim/vim74/lang/menu_it_it.utf-8.vim
/usr/share/vim/vim74/lang/zh_CN.UTF-8
/usr/share/vim/vim74/lang/zh_CN.UTF-8/LC_MESSAGES
/usr/share/vim/vim74/lang/zh_CN.UTF-8/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_it_it.latin1.vim
/usr/share/vim/vim74/lang/menu_de_de.latin1.vim
/usr/share/vim/vim74/lang/menu_zh_cn.gb2312.vim
/usr/share/vim/vim74/lang/menu_zh.cp950.vim
/usr/share/vim/vim74/lang/menu_ca_es.utf-8.vim
/usr/share/vim/vim74/lang/menu_ja_jp.ujis.vim
/usr/share/vim/vim74/lang/menu_eo.utf-8.vim
/usr/share/vim/vim74/lang/sv
/usr/share/vim/vim74/lang/sv/LC_MESSAGES
/usr/share/vim/vim74/lang/sv/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_pt_br.latin1.vim
/usr/share/vim/vim74/lang/menu_fr_fr.latin1.vim
/usr/share/vim/vim74/lang/nl
/usr/share/vim/vim74/lang/nl/LC_MESSAGES
/usr/share/vim/vim74/lang/nl/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_pt_pt.vim
/usr/share/vim/vim74/lang/menu_finnish_finland.1252.vim
/usr/share/vim/vim74/lang/menu_af.latin1.vim
/usr/share/vim/vim74/lang/menu_sk.cp1250.vim
/usr/share/vim/vim74/lang/zh_CN
/usr/share/vim/vim74/lang/zh_CN/LC_MESSAGES
/usr/share/vim/vim74/lang/zh_CN/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/ga
/usr/share/vim/vim74/lang/ga/LC_MESSAGES
/usr/share/vim/vim74/lang/ga/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_sv_se.latin1.vim
/usr/share/vim/vim74/lang/menu_pt_pt.utf-8.vim
/usr/share/vim/vim74/lang/menu_de.latin1.vim
/usr/share/vim/vim74/lang/menu_en_gb.utf-8.vim
/usr/share/vim/vim74/lang/pl.UTF-8
/usr/share/vim/vim74/lang/pl.UTF-8/LC_MESSAGES
/usr/share/vim/vim74/lang/pl.UTF-8/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_ja.cp932.vim
/usr/share/vim/vim74/lang/menu_no.latin1.vim
/usr/share/vim/vim74/lang/zh_TW.UTF-8
/usr/share/vim/vim74/lang/zh_TW.UTF-8/LC_MESSAGES
/usr/share/vim/vim74/lang/zh_TW.UTF-8/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_fi_fi.utf-8.vim
/usr/share/vim/vim74/lang/menu_fr_fr.utf-8.vim
/usr/share/vim/vim74/lang/menu_zh_cn.gbk.vim
/usr/share/vim/vim74/lang/menu_pt_br.utf-8.vim
/usr/share/vim/vim74/lang/menu_ja.eucjp.vim
/usr/share/vim/vim74/lang/ru
/usr/share/vim/vim74/lang/ru/LC_MESSAGES
/usr/share/vim/vim74/lang/ru/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_hu_hu.iso_8859-2.vim
/usr/share/vim/vim74/lang/eo
/usr/share/vim/vim74/lang/eo/LC_MESSAGES
/usr/share/vim/vim74/lang/eo/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/ko.UTF-8
/usr/share/vim/vim74/lang/ko.UTF-8/LC_MESSAGES
/usr/share/vim/vim74/lang/ko.UTF-8/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_af.utf-8.vim
/usr/share/vim/vim74/lang/menu_french_france.1252.vim
/usr/share/vim/vim74/lang/menu_czech_czech_republic.1250.vim
/usr/share/vim/vim74/lang/menu_ja.euc-jp.vim
/usr/share/vim/vim74/lang/menu_sv.utf-8.vim
/usr/share/vim/vim74/lang/menu_es_es.utf-8.vim
/usr/share/vim/vim74/lang/menu_vi_vn.vim
/usr/share/vim/vim74/lang/menu_ru_ru.koi8-r.vim
/usr/share/vim/vim74/lang/menu_czech_czech_republic.ascii.vim
/usr/share/vim/vim74/lang/menu_ko.utf-8.vim
/usr/share/vim/vim74/lang/menu_pl_pl.cp1250.vim
/usr/share/vim/vim74/lang/menu_ja_jp.eucjp.vim
/usr/share/vim/vim74/lang/README.txt
/usr/share/vim/vim74/lang/it
/usr/share/vim/vim74/lang/it/LC_MESSAGES
/usr/share/vim/vim74/lang/it/LC_MESSAGES/vim.mo
/usr/share/vim/vim74/lang/menu_italian_italy.1252.vim
/usr/share/vim/vim74/lang/menu_sk_sk.1250.vim
/usr/share/vim/vim74/lang/menu_english_united_kingdom.ascii.vim
/usr/share/vim/vim74/ftplugin
/usr/share/vim/vim74/ftplugin/a2ps.vim
/usr/share/vim/vim74/ftplugin/art.vim
/usr/share/vim/vim74/ftplugin/xslt.vim
/usr/share/vim/vim74/ftplugin/pascal.vim
/usr/share/vim/vim74/ftplugin/loginaccess.vim
/usr/share/vim/vim74/ftplugin/vroom.vim
/usr/share/vim/vim74/ftplugin/objc.vim
/usr/share/vim/vim74/ftplugin/kwt.vim
/usr/share/vim/vim74/ftplugin/lftp.vim
/usr/share/vim/vim74/ftplugin/clojure.vim
/usr/share/vim/vim74/ftplugin/debchangelog.vim
/usr/share/vim/vim74/ftplugin/rmd.vim
/usr/share/vim/vim74/ftplugin/rpl.vim
/usr/share/vim/vim74/ftplugin/config.vim
/usr/share/vim/vim74/ftplugin/ruby.vim
/usr/share/vim/vim74/ftplugin/eterm.vim
/usr/share/vim/vim74/ftplugin/pyrex.vim
/usr/share/vim/vim74/ftplugin/arch.vim
/usr/share/vim/vim74/ftplugin/text.vim
/usr/share/vim/vim74/ftplugin/muttrc.vim
/usr/share/vim/vim74/ftplugin/initex.vim
/usr/share/vim/vim74/ftplugin/go.vim
/usr/share/vim/vim74/ftplugin/occam.vim
/usr/share/vim/vim74/ftplugin/treetop.vim
/usr/share/vim/vim74/ftplugin/xhtml.vim
/usr/share/vim/vim74/ftplugin/php.vim
/usr/share/vim/vim74/ftplugin/zsh.vim
/usr/share/vim/vim74/ftplugin/zimbu.vim
/usr/share/vim/vim74/ftplugin/pinfo.vim
/usr/share/vim/vim74/ftplugin/html.vim
/usr/share/vim/vim74/ftplugin/udevrules.vim
/usr/share/vim/vim74/ftplugin/lua.vim
/usr/share/vim/vim74/ftplugin/indent.vim
/usr/share/vim/vim74/ftplugin/dtd.vim
/usr/share/vim/vim74/ftplugin/cucumber.vim
/usr/share/vim/vim74/ftplugin/ada.vim
/usr/share/vim/vim74/ftplugin/slpspi.vim
/usr/share/vim/vim74/ftplugin/c.vim
/usr/share/vim/vim74/ftplugin/postscr.vim
/usr/share/vim/vim74/ftplugin/hostconf.vim
/usr/share/vim/vim74/ftplugin/xmodmap.vim
/usr/share/vim/vim74/ftplugin/gitcommit.vim
/usr/share/vim/vim74/ftplugin/tcsh.vim
/usr/share/vim/vim74/ftplugin/sh.vim
/usr/share/vim/vim74/ftplugin/hamster.vim
/usr/share/vim/vim74/ftplugin/aap.vim
/usr/share/vim/vim74/ftplugin/erlang.vim
/usr/share/vim/vim74/ftplugin/markdown.vim
/usr/share/vim/vim74/ftplugin/rnoweb.vim
/usr/share/vim/vim74/ftplugin/tcl.vim
/usr/share/vim/vim74/ftplugin/fvwm.vim
/usr/share/vim/vim74/ftplugin/modconf.vim
/usr/share/vim/vim74/ftplugin/dircolors.vim
/usr/share/vim/vim74/ftplugin/mailcap.vim
/usr/share/vim/vim74/ftplugin/lisp.vim
/usr/share/vim/vim74/ftplugin/dictdconf.vim
/usr/share/vim/vim74/ftplugin/qf.vim
/usr/share/vim/vim74/ftplugin/man.vim
/usr/share/vim/vim74/ftplugin/haskell.vim
/usr/share/vim/vim74/ftplugin/conf.vim
/usr/share/vim/vim74/ftplugin/mailaliases.vim
/usr/share/vim/vim74/ftplugin/csc.vim
/usr/share/vim/vim74/ftplugin/svg.vim
/usr/share/vim/vim74/ftplugin/cvsrc.vim
/usr/share/vim/vim74/ftplugin/scheme.vim
/usr/share/vim/vim74/ftplugin/btm.vim
/usr/share/vim/vim74/ftplugin/sshconfig.vim
/usr/share/vim/vim74/ftplugin/flexwiki.vim
/usr/share/vim/vim74/ftplugin/gitconfig.vim
/usr/share/vim/vim74/ftplugin/r.vim
/usr/share/vim/vim74/ftplugin/mail.vim
/usr/share/vim/vim74/ftplugin/java.vim
/usr/share/vim/vim74/ftplugin/matlab.vim
/usr/share/vim/vim74/ftplugin/abap.vim
/usr/share/vim/vim74/ftplugin/pamconf.vim
/usr/share/vim/vim74/ftplugin/scss.vim
/usr/share/vim/vim74/ftplugin/tex.vim
/usr/share/vim/vim74/ftplugin/perl6.vim
/usr/share/vim/vim74/ftplugin/haml.vim
/usr/share/vim/vim74/ftplugin/m4.vim
/usr/share/vim/vim74/ftplugin/plaintex.vim
/usr/share/vim/vim74/ftplugin/kconfig.vim
/usr/share/vim/vim74/ftplugin/pdf.vim
/usr/share/vim/vim74/ftplugin/manconf.vim
/usr/share/vim/vim74/ftplugin/rst.vim
/usr/share/vim/vim74/ftplugin/logcheck.vim
/usr/share/vim/vim74/ftplugin/jsp.vim
/usr/share/vim/vim74/ftplugin/logtalk.vim
/usr/share/vim/vim74/ftplugin/dosbatch.vim
/usr/share/vim/vim74/ftplugin/automake.vim
/usr/share/vim/vim74/ftplugin/xf86conf.vim
/usr/share/vim/vim74/ftplugin/diff.vim
/usr/share/vim/vim74/ftplugin/updatedb.vim
/usr/share/vim/vim74/ftplugin/cpp.vim
/usr/share/vim/vim74/ftplugin/nsis.vim
/usr/share/vim/vim74/ftplugin/denyhosts.vim
/usr/share/vim/vim74/ftplugin/udevperm.vim
/usr/share/vim/vim74/ftplugin/sensors.vim
/usr/share/vim/vim74/ftplugin/group.vim
/usr/share/vim/vim74/ftplugin/gpg.vim
/usr/share/vim/vim74/ftplugin/mplayerconf.vim
/usr/share/vim/vim74/ftplugin/ch.vim
/usr/share/vim/vim74/ftplugin/quake.vim
/usr/share/vim/vim74/ftplugin/ishd.vim
/usr/share/vim/vim74/ftplugin/msmessages.vim
/usr/share/vim/vim74/ftplugin/netrc.vim
/usr/share/vim/vim74/ftplugin/sudoers.vim
/usr/share/vim/vim74/ftplugin/dosini.vim
/usr/share/vim/vim74/ftplugin/alsaconf.vim
/usr/share/vim/vim74/ftplugin/slpconf.vim
/usr/share/vim/vim74/ftplugin/yaml.vim
/usr/share/vim/vim74/ftplugin/htmldjango.vim
/usr/share/vim/vim74/ftplugin/aspvbs.vim
/usr/share/vim/vim74/ftplugin/procmail.vim
/usr/share/vim/vim74/ftplugin/ocaml.vim
/usr/share/vim/vim74/ftplugin/xdefaults.vim
/usr/share/vim/vim74/ftplugin/xs.vim
/usr/share/vim/vim74/ftplugin/reva.vim
/usr/share/vim/vim74/ftplugin/j.vim
/usr/share/vim/vim74/ftplugin/ld.vim
/usr/share/vim/vim74/ftplugin/rhelp.vim
/usr/share/vim/vim74/ftplugin/registry.vim
/usr/share/vim/vim74/ftplugin/lprolog.vim
/usr/share/vim/vim74/ftplugin/verilog.vim
/usr/share/vim/vim74/ftplugin/cs.vim
/usr/share/vim/vim74/ftplugin/racc.vim
/usr/share/vim/vim74/ftplugin/bst.vim
/usr/share/vim/vim74/ftplugin/mp.vim
/usr/share/vim/vim74/ftplugin/gitsendemail.vim
/usr/share/vim/vim74/ftplugin/sass.vim
/usr/share/vim/vim74/ftplugin/vb.vim
/usr/share/vim/vim74/ftplugin/sysctl.vim
/usr/share/vim/vim74/ftplugin/dtrace.vim
/usr/share/vim/vim74/ftplugin/jproperties.vim
/usr/share/vim/vim74/ftplugin/debcontrol.vim
/usr/share/vim/vim74/ftplugin/python.vim
/usr/share/vim/vim74/ftplugin/dockerfile.vim
/usr/share/vim/vim74/ftplugin/elinks.vim
/usr/share/vim/vim74/ftplugin/hostsaccess.vim
/usr/share/vim/vim74/ftplugin/vim.vim
/usr/share/vim/vim74/ftplugin/screen.vim
/usr/share/vim/vim74/ftplugin/limits.vim
/usr/share/vim/vim74/ftplugin/mrxvtrc.vim
/usr/share/vim/vim74/ftplugin/perl.vim
/usr/share/vim/vim74/ftplugin/slpreg.vim
/usr/share/vim/vim74/ftplugin/bdf.vim
/usr/share/vim/vim74/ftplugin/docbk.vim
/usr/share/vim/vim74/ftplugin/udevconf.vim
/usr/share/vim/vim74/ftplugin/abaqus.vim
/usr/share/vim/vim74/ftplugin/crm.vim
/usr/share/vim/vim74/ftplugin/sql.vim
/usr/share/vim/vim74/ftplugin/protocols.vim
/usr/share/vim/vim74/ftplugin/csh.vim
/usr/share/vim/vim74/ftplugin/setserial.vim
/usr/share/vim/vim74/ftplugin/logtalk.dict
/usr/share/vim/vim74/ftplugin/cobol.vim
/usr/share/vim/vim74/ftplugin/dictconf.vim
/usr/share/vim/vim74/ftplugin/tt2html.vim
/usr/share/vim/vim74/ftplugin/falcon.vim
/usr/share/vim/vim74/ftplugin/gitrebase.vim
/usr/share/vim/vim74/ftplugin/xsd.vim
/usr/share/vim/vim74/ftplugin/eruby.vim
/usr/share/vim/vim74/ftplugin/git.vim
/usr/share/vim/vim74/ftplugin/nanorc.vim
/usr/share/vim/vim74/ftplugin/gprof.vim
/usr/share/vim/vim74/ftplugin/xml.vim
/usr/share/vim/vim74/ftplugin/terminfo.vim
/usr/share/vim/vim74/ftplugin/fortran.vim
/usr/share/vim/vim74/ftplugin/libao.vim
/usr/share/vim/vim74/ftplugin/services.vim
/usr/share/vim/vim74/ftplugin/grub.vim
/usr/share/vim/vim74/ftplugin/mf.vim
/usr/share/vim/vim74/ftplugin/xinetd.vim
/usr/share/vim/vim74/ftplugin/framescript.vim
/usr/share/vim/vim74/ftplugin/sieve.vim
/usr/share/vim/vim74/ftplugin/readline.vim
/usr/share/vim/vim74/ftplugin/make.vim
/usr/share/vim/vim74/ftplugin/fetchmail.vim
/usr/share/vim/vim74/ftplugin/prolog.vim
/usr/share/vim/vim74/ftplugin/cdrdaoconf.vim
/usr/share/vim/vim74/ftplugin/javascript.vim
/usr/share/vim/vim74/ftplugin/spec.vim
/usr/share/vim/vim74/ftplugin/ant.vim
/usr/share/vim/vim74/ftplugin/passwd.vim
/usr/share/vim/vim74/ftplugin/logindefs.vim
/usr/share/vim/vim74/ftplugin/json.vim
/usr/share/vim/vim74/ftplugin/vhdl.vim
/usr/share/vim/vim74/ftplugin/rrst.vim
/usr/share/vim/vim74/ftplugin/calendar.vim
/usr/share/vim/vim74/ftplugin/help.vim
/usr/share/vim/vim74/ftplugin/css.vim
/usr/share/vim/vim74/ftplugin/context.vim
/usr/share/vim/vim74/ftplugin/sgml.vim
/usr/share/vim/vim74/ftplugin/systemverilog.vim
/usr/share/vim/vim74/ftplugin/liquid.vim
/usr/share/vim/vim74/ftplugin/README.txt
/usr/share/vim/vim74/ftplugin/rnc.vim
/usr/share/vim/vim74/ftplugin/changelog.vim
/usr/share/vim/vim74/ftplugin.vim
/usr/share/vim/vim74/gvimrc_example.vim
/usr/share/vim/vim74/mswin.vim
/usr/share/vim/vim74/indoff.vim
/usr/share/vim/vim74/indent.vim
/usr/share/vim/vim74/indent
/usr/share/vim/vim74/indent/mma.vim
/usr/share/vim/vim74/indent/xslt.vim
/usr/share/vim/vim74/indent/pascal.vim
/usr/share/vim/vim74/indent/vroom.vim
/usr/share/vim/vim74/indent/objc.vim
/usr/share/vim/vim74/indent/clojure.vim
/usr/share/vim/vim74/indent/rmd.vim
/usr/share/vim/vim74/indent/rpl.vim
/usr/share/vim/vim74/indent/config.vim
/usr/share/vim/vim74/indent/ruby.vim
/usr/share/vim/vim74/indent/eterm.vim
/usr/share/vim/vim74/indent/pyrex.vim
/usr/share/vim/vim74/indent/tilde.vim
/usr/share/vim/vim74/indent/go.vim
/usr/share/vim/vim74/indent/occam.vim
/usr/share/vim/vim74/indent/treetop.vim
/usr/share/vim/vim74/indent/xhtml.vim
/usr/share/vim/vim74/indent/php.vim
/usr/share/vim/vim74/indent/bib.vim
/usr/share/vim/vim74/indent/zsh.vim
/usr/share/vim/vim74/indent/awk.vim
/usr/share/vim/vim74/indent/zimbu.vim
/usr/share/vim/vim74/indent/html.vim
/usr/share/vim/vim74/indent/yacc.vim
/usr/share/vim/vim74/indent/lua.vim
/usr/share/vim/vim74/indent/dtd.vim
/usr/share/vim/vim74/indent/cucumber.vim
/usr/share/vim/vim74/indent/ada.vim
/usr/share/vim/vim74/indent/c.vim
/usr/share/vim/vim74/indent/postscr.vim
/usr/share/vim/vim74/indent/tcsh.vim
/usr/share/vim/vim74/indent/sh.vim
/usr/share/vim/vim74/indent/hamster.vim
/usr/share/vim/vim74/indent/aap.vim
/usr/share/vim/vim74/indent/erlang.vim
/usr/share/vim/vim74/indent/rnoweb.vim
/usr/share/vim/vim74/indent/tcl.vim
/usr/share/vim/vim74/indent/lisp.vim
/usr/share/vim/vim74/indent/pov.vim
/usr/share/vim/vim74/indent/dictdconf.vim
/usr/share/vim/vim74/indent/scheme.vim
/usr/share/vim/vim74/indent/gitconfig.vim
/usr/share/vim/vim74/indent/r.vim
/usr/share/vim/vim74/indent/mail.vim
/usr/share/vim/vim74/indent/java.vim
/usr/share/vim/vim74/indent/matlab.vim
/usr/share/vim/vim74/indent/scss.vim
/usr/share/vim/vim74/indent/tex.vim
/usr/share/vim/vim74/indent/perl6.vim
/usr/share/vim/vim74/indent/haml.vim
/usr/share/vim/vim74/indent/dylan.vim
/usr/share/vim/vim74/indent/rst.vim
/usr/share/vim/vim74/indent/jsp.vim
/usr/share/vim/vim74/indent/sml.vim
/usr/share/vim/vim74/indent/logtalk.vim
/usr/share/vim/vim74/indent/automake.vim
/usr/share/vim/vim74/indent/xf86conf.vim
/usr/share/vim/vim74/indent/cpp.vim
/usr/share/vim/vim74/indent/ch.vim
/usr/share/vim/vim74/indent/ishd.vim
/usr/share/vim/vim74/indent/cdl.vim
/usr/share/vim/vim74/indent/yaml.vim
/usr/share/vim/vim74/indent/htmldjango.vim
/usr/share/vim/vim74/indent/ocaml.vim
/usr/share/vim/vim74/indent/j.vim
/usr/share/vim/vim74/indent/chaiscript.vim
/usr/share/vim/vim74/indent/ld.vim
/usr/share/vim/vim74/indent/rhelp.vim
/usr/share/vim/vim74/indent/cuda.vim
/usr/share/vim/vim74/indent/verilog.vim
/usr/share/vim/vim74/indent/cs.vim
/usr/share/vim/vim74/indent/bst.vim
/usr/share/vim/vim74/indent/cmake.vim
/usr/share/vim/vim74/indent/sqlanywhere.vim
/usr/share/vim/vim74/indent/mp.vim
/usr/share/vim/vim74/indent/sass.vim
/usr/share/vim/vim74/indent/vb.vim
/usr/share/vim/vim74/indent/dtrace.vim
/usr/share/vim/vim74/indent/python.vim
/usr/share/vim/vim74/indent/vim.vim
/usr/share/vim/vim74/indent/eiffel.vim
/usr/share/vim/vim74/indent/perl.vim
/usr/share/vim/vim74/indent/docbk.vim
/usr/share/vim/vim74/indent/sql.vim
/usr/share/vim/vim74/indent/cobol.vim
/usr/share/vim/vim74/indent/dictconf.vim
/usr/share/vim/vim74/indent/falcon.vim
/usr/share/vim/vim74/indent/xsd.vim
/usr/share/vim/vim74/indent/eruby.vim
/usr/share/vim/vim74/indent/sdl.vim
/usr/share/vim/vim74/indent/xml.vim
/usr/share/vim/vim74/indent/fortran.vim
/usr/share/vim/vim74/indent/xinetd.vim
/usr/share/vim/vim74/indent/framescript.vim
/usr/share/vim/vim74/indent/lifelines.vim
/usr/share/vim/vim74/indent/idlang.vim
/usr/share/vim/vim74/indent/tf.vim
/usr/share/vim/vim74/indent/readline.vim
/usr/share/vim/vim74/indent/make.vim
/usr/share/vim/vim74/indent/prolog.vim
/usr/share/vim/vim74/indent/javascript.vim
/usr/share/vim/vim74/indent/ant.vim
/usr/share/vim/vim74/indent/d.vim
/usr/share/vim/vim74/indent/json.vim
/usr/share/vim/vim74/indent/vhdl.vim
/usr/share/vim/vim74/indent/rrst.vim
/usr/share/vim/vim74/indent/css.vim
/usr/share/vim/vim74/indent/systemverilog.vim
/usr/share/vim/vim74/indent/liquid.vim
/usr/share/vim/vim74/indent/README.txt
/usr/share/vim/vim74/indent/changelog.vim
/usr/share/vim/vim74/indent/gitolite.vim
/usr/share/vim/vim74/keymap
/usr/share/vim/vim74/keymap/serbian_iso-8859-2.vim
/usr/share/vim/vim74/keymap/croatian.vim
/usr/share/vim/vim74/keymap/polish-slash.vim
/usr/share/vim/vim74/keymap/polish-slash_utf-8.vim
/usr/share/vim/vim74/keymap/polish-slash_cp852.vim
/usr/share/vim/vim74/keymap/serbian.vim
/usr/share/vim/vim74/keymap/persian-iranian_utf-8.vim
/usr/share/vim/vim74/keymap/hebrew_cp1255.vim
/usr/share/vim/vim74/keymap/dvorak.vim
/usr/share/vim/vim74/keymap/greek_cp737.vim
/usr/share/vim/vim74/keymap/magyar_utf-8.vim
/usr/share/vim/vim74/keymap/russian-yawerty.vim
/usr/share/vim/vim74/keymap/polish-slash_iso-8859-2.vim
/usr/share/vim/vim74/keymap/persian.vim
/usr/share/vim/vim74/keymap/bulgarian-phonetic.vim
/usr/share/vim/vim74/keymap/polish-slash_cp1250.vim
/usr/share/vim/vim74/keymap/lithuanian-baltic.vim
/usr/share/vim/vim74/keymap/thaana-phonetic_utf-8.vim
/usr/share/vim/vim74/keymap/greek_iso-8859-7.vim
/usr/share/vim/vim74/keymap/belarusian-jcuken.vim
/usr/share/vim/vim74/keymap/esperanto.vim
/usr/share/vim/vim74/keymap/kana.vim
/usr/share/vim/vim74/keymap/sinhala.vim
/usr/share/vim/vim74/keymap/hebrewp_utf-8.vim
/usr/share/vim/vim74/keymap/ukrainian-jcuken.vim
/usr/share/vim/vim74/keymap/croatian_utf-8.vim
/usr/share/vim/vim74/keymap/bulgarian-bds.vim
/usr/share/vim/vim74/keymap/mongolian_utf-8.vim
/usr/share/vim/vim74/keymap/hebrewp.vim
/usr/share/vim/vim74/keymap/accents.vim
/usr/share/vim/vim74/keymap/serbian_utf-8.vim
/usr/share/vim/vim74/keymap/hebrew.vim
/usr/share/vim/vim74/keymap/hebrewp_iso-8859-8.vim
/usr/share/vim/vim74/keymap/croatian_iso-8859-2.vim
/usr/share/vim/vim74/keymap/hebrew_utf-8.vim
/usr/share/vim/vim74/keymap/russian-jcukenwin.vim
/usr/share/vim/vim74/keymap/greek_cp1253.vim
/usr/share/vim/vim74/keymap/esperanto_utf-8.vim
/usr/share/vim/vim74/keymap/serbian-latin_utf-8.vim
/usr/share/vim/vim74/keymap/czech_utf-8.vim
/usr/share/vim/vim74/keymap/arabic.vim
/usr/share/vim/vim74/keymap/serbian-latin.vim
/usr/share/vim/vim74/keymap/russian-jcuken.vim
/usr/share/vim/vim74/keymap/serbian_iso-8859-5.vim
/usr/share/vim/vim74/keymap/slovak_cp1250.vim
/usr/share/vim/vim74/keymap/sinhala-phonetic_utf-8.vim
/usr/share/vim/vim74/keymap/slovak_iso-8859-2.vim
/usr/share/vim/vim74/keymap/russian-dvorak.vim
/usr/share/vim/vim74/keymap/tamil_tscii.vim
/usr/share/vim/vim74/keymap/hebrewp_cp1255.vim
/usr/share/vim/vim74/keymap/vietnamese-viqr_utf-8.vim
/usr/share/vim/vim74/keymap/serbian_cp1250.vim
/usr/share/vim/vim74/keymap/ukrainian-dvorak.vim
/usr/share/vim/vim74/keymap/thaana.vim
/usr/share/vim/vim74/keymap/slovak_utf-8.vim
/usr/share/vim/vim74/keymap/pinyin.vim
/usr/share/vim/vim74/keymap/greek.vim
/usr/share/vim/vim74/keymap/arabic_utf-8.vim
/usr/share/vim/vim74/keymap/serbian_cp1251.vim
/usr/share/vim/vim74/keymap/hebrew_iso-8859-8.vim
/usr/share/vim/vim74/keymap/czech.vim
/usr/share/vim/vim74/keymap/slovak.vim
/usr/share/vim/vim74/keymap/canfr-win.vim
/usr/share/vim/vim74/keymap/README.txt
/usr/share/vim/vim74/keymap/croatian_cp1250.vim
/usr/share/vim/vim74/keymap/greek_utf-8.vim
/usr/share/vim/vim74/ftoff.vim
/usr/share/vim/vim74/synmenu.vim
/usr/share/vim/vim74/macros
/usr/share/vim/vim74/macros/dvorak
/usr/share/vim/vim74/macros/shellmenu.vim
/usr/share/vim/vim74/macros/hanoi
/usr/share/vim/vim74/macros/hanoi/click.me
/usr/share/vim/vim74/macros/hanoi/poster
/usr/share/vim/vim74/macros/hanoi/hanoi.vim
/usr/share/vim/vim74/macros/matchit.vim
/usr/share/vim/vim74/macros/matchit.txt
/usr/share/vim/vim74/macros/life
/usr/share/vim/vim74/macros/life/click.me
/usr/share/vim/vim74/macros/life/life.vim
/usr/share/vim/vim74/macros/editexisting.vim
/usr/share/vim/vim74/macros/less.vim
/usr/share/vim/vim74/macros/maze
/usr/share/vim/vim74/macros/maze/poster
/usr/share/vim/vim74/macros/maze/mazeansi.c
/usr/share/vim/vim74/macros/maze/maze_5.78
/usr/share/vim/vim74/macros/maze/main.aap
/usr/share/vim/vim74/macros/maze/Makefile
/usr/share/vim/vim74/macros/maze/maze_mac
/usr/share/vim/vim74/macros/maze/mazeclean.c
/usr/share/vim/vim74/macros/maze/maze.c
/usr/share/vim/vim74/macros/maze/README.txt
/usr/share/vim/vim74/macros/swapmous.vim
/usr/share/vim/vim74/macros/less.bat
/usr/share/vim/vim74/macros/justify.vim
/usr/share/vim/vim74/macros/urm
/usr/share/vim/vim74/macros/urm/examples
/usr/share/vim/vim74/macros/urm/urm.vim
/usr/share/vim/vim74/macros/urm/urm
/usr/share/vim/vim74/macros/urm/README.txt
/usr/share/vim/vim74/macros/less.sh
/usr/share/vim/vim74/macros/README.txt
/usr/share/vim/vim74/evim.vim
/usr/share/vim/vim74/compiler
/usr/share/vim/vim74/compiler/fortran_F.vim
/usr/share/vim/vim74/compiler/icc.vim
/usr/share/vim/vim74/compiler/xmlwf.vim
/usr/share/vim/vim74/compiler/ruby.vim
/usr/share/vim/vim74/compiler/rubyunit.vim
/usr/share/vim/vim74/compiler/rake.vim
/usr/share/vim/vim74/compiler/fortran_elf90.vim
/usr/share/vim/vim74/compiler/mipspro_cpp.vim
/usr/share/vim/vim74/compiler/go.vim
/usr/share/vim/vim74/compiler/php.vim
/usr/share/vim/vim74/compiler/mipspro_c89.vim
/usr/share/vim/vim74/compiler/splint.vim
/usr/share/vim/vim74/compiler/irix5_c.vim
/usr/share/vim/vim74/compiler/cucumber.vim
/usr/share/vim/vim74/compiler/fortran_g77.vim
/usr/share/vim/vim74/compiler/msbuild.vim
/usr/share/vim/vim74/compiler/erlang.vim
/usr/share/vim/vim74/compiler/tcl.vim
/usr/share/vim/vim74/compiler/se.vim
/usr/share/vim/vim74/compiler/intel.vim
/usr/share/vim/vim74/compiler/jikes.vim
/usr/share/vim/vim74/compiler/irix5_cpp.vim
/usr/share/vim/vim74/compiler/tex.vim
/usr/share/vim/vim74/compiler/haml.vim
/usr/share/vim/vim74/compiler/checkstyle.vim
/usr/share/vim/vim74/compiler/hp_acc.vim
/usr/share/vim/vim74/compiler/rst.vim
/usr/share/vim/vim74/compiler/dot.vim
/usr/share/vim/vim74/compiler/fortran_lf95.vim
/usr/share/vim/vim74/compiler/pbx.vim
/usr/share/vim/vim74/compiler/pyunit.vim
/usr/share/vim/vim74/compiler/neato.vim
/usr/share/vim/vim74/compiler/xmllint.vim
/usr/share/vim/vim74/compiler/mips_c.vim
/usr/share/vim/vim74/compiler/javac.vim
/usr/share/vim/vim74/compiler/fortran_cv.vim
/usr/share/vim/vim74/compiler/msvc.vim
/usr/share/vim/vim74/compiler/gfortran.vim
/usr/share/vim/vim74/compiler/onsgmls.vim
/usr/share/vim/vim74/compiler/g95.vim
/usr/share/vim/vim74/compiler/ocaml.vim
/usr/share/vim/vim74/compiler/mcs.vim
/usr/share/vim/vim74/compiler/cs.vim
/usr/share/vim/vim74/compiler/modelsim_vcom.vim
/usr/share/vim/vim74/compiler/sass.vim
/usr/share/vim/vim74/compiler/perl.vim
/usr/share/vim/vim74/compiler/bdf.vim
/usr/share/vim/vim74/compiler/fpc.vim
/usr/share/vim/vim74/compiler/xbuild.vim
/usr/share/vim/vim74/compiler/rspec.vim
/usr/share/vim/vim74/compiler/eruby.vim
/usr/share/vim/vim74/compiler/gcc.vim
/usr/share/vim/vim74/compiler/gnat.vim
/usr/share/vim/vim74/compiler/ant.vim
/usr/share/vim/vim74/compiler/bcc.vim
/usr/share/vim/vim74/compiler/ifort.vim
/usr/share/vim/vim74/compiler/tidy.vim
/usr/share/vim/vim74/compiler/decada.vim
/usr/share/vim/vim74/compiler/README.txt
/usr/share/vim/vim74/scripts.vim
/usr/share/vim/vim74/syntax
/usr/share/vim/vim74/syntax/mma.vim
/usr/share/vim/vim74/syntax/a2ps.vim
/usr/share/vim/vim74/syntax/art.vim
/usr/share/vim/vim74/syntax/xslt.vim
/usr/share/vim/vim74/syntax/snobol4.vim
/usr/share/vim/vim74/syntax/nasm.vim
/usr/share/vim/vim74/syntax/grads.vim
/usr/share/vim/vim74/syntax/pascal.vim
/usr/share/vim/vim74/syntax/loginaccess.vim
/usr/share/vim/vim74/syntax/sindaout.vim
/usr/share/vim/vim74/syntax/elmfilt.vim
/usr/share/vim/vim74/syntax/vroom.vim
/usr/share/vim/vim74/syntax/mmp.vim
/usr/share/vim/vim74/syntax/objc.vim
/usr/share/vim/vim74/syntax/sl.vim
/usr/share/vim/vim74/syntax/kwt.vim
/usr/share/vim/vim74/syntax/elf.vim
/usr/share/vim/vim74/syntax/lftp.vim
/usr/share/vim/vim74/syntax/wsh.vim
/usr/share/vim/vim74/syntax/bc.vim
/usr/share/vim/vim74/syntax/cupl.vim
/usr/share/vim/vim74/syntax/a65.vim
/usr/share/vim/vim74/syntax/mib.vim
/usr/share/vim/vim74/syntax/clojure.vim
/usr/share/vim/vim74/syntax/asm68k.vim
/usr/share/vim/vim74/syntax/debchangelog.vim
/usr/share/vim/vim74/syntax/rmd.vim
/usr/share/vim/vim74/syntax/sshdconfig.vim
/usr/share/vim/vim74/syntax/valgrind.vim
/usr/share/vim/vim74/syntax/rpl.vim
/usr/share/vim/vim74/syntax/config.vim
/usr/share/vim/vim74/syntax/svn.vim
/usr/share/vim/vim74/syntax/viminfo.vim
/usr/share/vim/vim74/syntax/ruby.vim
/usr/share/vim/vim74/syntax/taskdata.vim
/usr/share/vim/vim74/syntax/aml.vim
/usr/share/vim/vim74/syntax/xkb.vim
/usr/share/vim/vim74/syntax/eterm.vim
/usr/share/vim/vim74/syntax/hgcommit.vim
/usr/share/vim/vim74/syntax/pyrex.vim
/usr/share/vim/vim74/syntax/prescribe.vim
/usr/share/vim/vim74/syntax/pike.vim
/usr/share/vim/vim74/syntax/arch.vim
/usr/share/vim/vim74/syntax/gp.vim
/usr/share/vim/vim74/syntax/cheetah.vim
/usr/share/vim/vim74/syntax/papp.vim
/usr/share/vim/vim74/syntax/snnsnet.vim
/usr/share/vim/vim74/syntax/ninja.vim
/usr/share/vim/vim74/syntax/muttrc.vim
/usr/share/vim/vim74/syntax/gsp.vim
/usr/share/vim/vim74/syntax/antlr.vim
/usr/share/vim/vim74/syntax/samba.vim
/usr/share/vim/vim74/syntax/pli.vim
/usr/share/vim/vim74/syntax/rexx.vim
/usr/share/vim/vim74/syntax/snnspat.vim
/usr/share/vim/vim74/syntax/promela.vim
/usr/share/vim/vim74/syntax/tilde.vim
/usr/share/vim/vim74/syntax/kscript.vim
/usr/share/vim/vim74/syntax/model.vim
/usr/share/vim/vim74/syntax/lotos.vim
/usr/share/vim/vim74/syntax/monk.vim
/usr/share/vim/vim74/syntax/chordpro.vim
/usr/share/vim/vim74/syntax/sas.vim
/usr/share/vim/vim74/syntax/initex.vim
/usr/share/vim/vim74/syntax/cynlib.vim
/usr/share/vim/vim74/syntax/go.vim
/usr/share/vim/vim74/syntax/sendpr.vim
/usr/share/vim/vim74/syntax/aflex.vim
/usr/share/vim/vim74/syntax/javacc.vim
/usr/share/vim/vim74/syntax/def.vim
/usr/share/vim/vim74/syntax/purifylog.vim
/usr/share/vim/vim74/syntax/gnash.vim
/usr/share/vim/vim74/syntax/nroff.vim
/usr/share/vim/vim74/syntax/obj.vim
/usr/share/vim/vim74/syntax/occam.vim
/usr/share/vim/vim74/syntax/rtf.vim
/usr/share/vim/vim74/syntax/treetop.vim
/usr/share/vim/vim74/syntax/esterel.vim
/usr/share/vim/vim74/syntax/xhtml.vim
/usr/share/vim/vim74/syntax/spyce.vim
/usr/share/vim/vim74/syntax/php.vim
/usr/share/vim/vim74/syntax/hb.vim
/usr/share/vim/vim74/syntax/psf.vim
/usr/share/vim/vim74/syntax/dtml.vim
/usr/share/vim/vim74/syntax/bib.vim
/usr/share/vim/vim74/syntax/zsh.vim
/usr/share/vim/vim74/syntax/awk.vim
/usr/share/vim/vim74/syntax/hitest.vim
/usr/share/vim/vim74/syntax/maxima.vim
/usr/share/vim/vim74/syntax/zimbu.vim
/usr/share/vim/vim74/syntax/rcslog.vim
/usr/share/vim/vim74/syntax/pinfo.vim
/usr/share/vim/vim74/syntax/splint.vim
/usr/share/vim/vim74/syntax/iss.vim
/usr/share/vim/vim74/syntax/html.vim
/usr/share/vim/vim74/syntax/verilogams.vim
/usr/share/vim/vim74/syntax/yacc.vim
/usr/share/vim/vim74/syntax/whitespace.vim
/usr/share/vim/vim74/syntax/udevrules.vim
/usr/share/vim/vim74/syntax/lua.vim
/usr/share/vim/vim74/syntax/resolv.vim
/usr/share/vim/vim74/syntax/indent.vim
/usr/share/vim/vim74/syntax/mupad.vim
/usr/share/vim/vim74/syntax/asciidoc.vim
/usr/share/vim/vim74/syntax/mason.vim
/usr/share/vim/vim74/syntax/dtd.vim
/usr/share/vim/vim74/syntax/cucumber.vim
/usr/share/vim/vim74/syntax/ada.vim
/usr/share/vim/vim74/syntax/autohotkey.vim
/usr/share/vim/vim74/syntax/slpspi.vim
/usr/share/vim/vim74/syntax/c.vim
/usr/share/vim/vim74/syntax/postscr.vim
/usr/share/vim/vim74/syntax/ayacc.vim
/usr/share/vim/vim74/syntax/hostconf.vim
/usr/share/vim/vim74/syntax/cvs.vim
/usr/share/vim/vim74/syntax/xmodmap.vim
/usr/share/vim/vim74/syntax/fasm.vim
/usr/share/vim/vim74/syntax/pic.vim
/usr/share/vim/vim74/syntax/gitcommit.vim
/usr/share/vim/vim74/syntax/tcsh.vim
/usr/share/vim/vim74/syntax/sh.vim
/usr/share/vim/vim74/syntax/ora.vim
/usr/share/vim/vim74/syntax/bzr.vim
/usr/share/vim/vim74/syntax/hamster.vim
/usr/share/vim/vim74/syntax/tsscl.vim
/usr/share/vim/vim74/syntax/aap.vim
/usr/share/vim/vim74/syntax/erlang.vim
/usr/share/vim/vim74/syntax/markdown.vim
/usr/share/vim/vim74/syntax/mallard.vim
/usr/share/vim/vim74/syntax/b.vim
/usr/share/vim/vim74/syntax/tt2js.vim
/usr/share/vim/vim74/syntax/rnoweb.vim
/usr/share/vim/vim74/syntax/ibasic.vim
/usr/share/vim/vim74/syntax/plp.vim
/usr/share/vim/vim74/syntax/modsim3.vim
/usr/share/vim/vim74/syntax/xxd.vim
/usr/share/vim/vim74/syntax/mush.vim
/usr/share/vim/vim74/syntax/tpp.vim
/usr/share/vim/vim74/syntax/tcl.vim
/usr/share/vim/vim74/syntax/fvwm.vim
/usr/share/vim/vim74/syntax/modconf.vim
/usr/share/vim/vim74/syntax/dircolors.vim
/usr/share/vim/vim74/syntax/mailcap.vim
/usr/share/vim/vim74/syntax/lisp.vim
/usr/share/vim/vim74/syntax/pfmain.vim
/usr/share/vim/vim74/syntax/syncolor.vim
/usr/share/vim/vim74/syntax/sed.vim
/usr/share/vim/vim74/syntax/pov.vim
/usr/share/vim/vim74/syntax/exim.vim
/usr/share/vim/vim74/syntax/inform.vim
/usr/share/vim/vim74/syntax/doxygen.vim
/usr/share/vim/vim74/syntax/dictdconf.vim
/usr/share/vim/vim74/syntax/pcap.vim
/usr/share/vim/vim74/syntax/usw2kagtlog.vim
/usr/share/vim/vim74/syntax/fstab.vim
/usr/share/vim/vim74/syntax/qf.vim
/usr/share/vim/vim74/syntax/taskedit.vim
/usr/share/vim/vim74/syntax/man.vim
/usr/share/vim/vim74/syntax/haskell.vim
/usr/share/vim/vim74/syntax/jam.vim
/usr/share/vim/vim74/syntax/conf.vim
/usr/share/vim/vim74/syntax/sisu.vim
/usr/share/vim/vim74/syntax/tssgm.vim
/usr/share/vim/vim74/syntax/ratpoison.vim
/usr/share/vim/vim74/syntax/winbatch.vim
/usr/share/vim/vim74/syntax/redif.vim
/usr/share/vim/vim74/syntax/xpm.vim
/usr/share/vim/vim74/syntax/mailaliases.vim
/usr/share/vim/vim74/syntax/csc.vim
/usr/share/vim/vim74/syntax/svg.vim
/usr/share/vim/vim74/syntax/cvsrc.vim
/usr/share/vim/vim74/syntax/plm.vim
/usr/share/vim/vim74/syntax/gkrellmrc.vim
/usr/share/vim/vim74/syntax/scheme.vim
/usr/share/vim/vim74/syntax/btm.vim
/usr/share/vim/vim74/syntax/sshconfig.vim
/usr/share/vim/vim74/syntax/dylanintr.vim
/usr/share/vim/vim74/syntax/ist.vim
/usr/share/vim/vim74/syntax/flexwiki.vim
/usr/share/vim/vim74/syntax/progress.vim
/usr/share/vim/vim74/syntax/desktop.vim
/usr/share/vim/vim74/syntax/gitconfig.vim
/usr/share/vim/vim74/syntax/plsql.vim
/usr/share/vim/vim74/syntax/lscript.vim
/usr/share/vim/vim74/syntax/upstart.vim
/usr/share/vim/vim74/syntax/cuplsim.vim
/usr/share/vim/vim74/syntax/r.vim
/usr/share/vim/vim74/syntax/asm.vim
/usr/share/vim/vim74/syntax/squid.vim
/usr/share/vim/vim74/syntax/pf.vim
/usr/share/vim/vim74/syntax/jargon.vim
/usr/share/vim/vim74/syntax/form.vim
/usr/share/vim/vim74/syntax/mail.vim
/usr/share/vim/vim74/syntax/java.vim
/usr/share/vim/vim74/syntax/matlab.vim
/usr/share/vim/vim74/syntax/wvdial.vim
/usr/share/vim/vim74/syntax/hex.vim
/usr/share/vim/vim74/syntax/abap.vim
/usr/share/vim/vim74/syntax/gretl.vim
/usr/share/vim/vim74/syntax/pamconf.vim
/usr/share/vim/vim74/syntax/omnimark.vim
/usr/share/vim/vim74/syntax/scss.vim
/usr/share/vim/vim74/syntax/tex.vim
/usr/share/vim/vim74/syntax/focexec.vim
/usr/share/vim/vim74/syntax/conaryrecipe.vim
/usr/share/vim/vim74/syntax/hog.vim
/usr/share/vim/vim74/syntax/netrw.vim
/usr/share/vim/vim74/syntax/pod.vim
/usr/share/vim/vim74/syntax/perl6.vim
/usr/share/vim/vim74/syntax/ctrlh.vim
/usr/share/vim/vim74/syntax/haml.vim
/usr/share/vim/vim74/syntax/m4.vim
/usr/share/vim/vim74/syntax/mmix.vim
/usr/share/vim/vim74/syntax/dylan.vim
/usr/share/vim/vim74/syntax/objcpp.vim
/usr/share/vim/vim74/syntax/manual.vim
/usr/share/vim/vim74/syntax/csdl.vim
/usr/share/vim/vim74/syntax/plaintex.vim
/usr/share/vim/vim74/syntax/kconfig.vim
/usr/share/vim/vim74/syntax/pdf.vim
/usr/share/vim/vim74/syntax/usserverlog.vim
/usr/share/vim/vim74/syntax/tags.vim
/usr/share/vim/vim74/syntax/synload.vim
/usr/share/vim/vim74/syntax/godoc.vim
/usr/share/vim/vim74/syntax/modula2.vim
/usr/share/vim/vim74/syntax/slrnsc.vim
/usr/share/vim/vim74/syntax/clean.vim
/usr/share/vim/vim74/syntax/tssop.vim
/usr/share/vim/vim74/syntax/nosyntax.vim
/usr/share/vim/vim74/syntax/manconf.vim
/usr/share/vim/vim74/syntax/texmf.vim
/usr/share/vim/vim74/syntax/rst.vim
/usr/share/vim/vim74/syntax/esmtprc.vim
/usr/share/vim/vim74/syntax/acedb.vim
/usr/share/vim/vim74/syntax/esqlc.vim
/usr/share/vim/vim74/syntax/mgl.vim
/usr/share/vim/vim74/syntax/dot.vim
/usr/share/vim/vim74/syntax/colortest.vim
/usr/share/vim/vim74/syntax/tsalt.vim
/usr/share/vim/vim74/syntax/jsp.vim
/usr/share/vim/vim74/syntax/sml.vim
/usr/share/vim/vim74/syntax/voscm.vim
/usr/share/vim/vim74/syntax/gdmo.vim
/usr/share/vim/vim74/syntax/skill.vim
/usr/share/vim/vim74/syntax/cabal.vim
/usr/share/vim/vim74/syntax/logtalk.vim
/usr/share/vim/vim74/syntax/dosbatch.vim
/usr/share/vim/vim74/syntax/dnsmasq.vim
/usr/share/vim/vim74/syntax/smil.vim
/usr/share/vim/vim74/syntax/gedcom.vim
/usr/share/vim/vim74/syntax/texinfo.vim
/usr/share/vim/vim74/syntax/latte.vim
/usr/share/vim/vim74/syntax/st.vim
/usr/share/vim/vim74/syntax/automake.vim
/usr/share/vim/vim74/syntax/xf86conf.vim
/usr/share/vim/vim74/syntax/diff.vim
/usr/share/vim/vim74/syntax/django.vim
/usr/share/vim/vim74/syntax/spice.vim
/usr/share/vim/vim74/syntax/xbl.vim
/usr/share/vim/vim74/syntax/privoxy.vim
/usr/share/vim/vim74/syntax/jgraph.vim
/usr/share/vim/vim74/syntax/sindacmp.vim
/usr/share/vim/vim74/syntax/amiga.vim
/usr/share/vim/vim74/syntax/wml.vim
/usr/share/vim/vim74/syntax/updatedb.vim
/usr/share/vim/vim74/syntax/lsl.vim
/usr/share/vim/vim74/syntax/datascript.vim
/usr/share/vim/vim74/syntax/cdrtoc.vim
/usr/share/vim/vim74/syntax/cpp.vim
/usr/share/vim/vim74/syntax/tasm.vim
/usr/share/vim/vim74/syntax/arduino.vim
/usr/share/vim/vim74/syntax/nsis.vim
/usr/share/vim/vim74/syntax/denyhosts.vim
/usr/share/vim/vim74/syntax/scilab.vim
/usr/share/vim/vim74/syntax/asterisk.vim
/usr/share/vim/vim74/syntax/clipper.vim
/usr/share/vim/vim74/syntax/master.vim
/usr/share/vim/vim74/syntax/sather.vim
/usr/share/vim/vim74/syntax/udevperm.vim
/usr/share/vim/vim74/syntax/euphoria3.vim
/usr/share/vim/vim74/syntax/sensors.vim
/usr/share/vim/vim74/syntax/cfg.vim
/usr/share/vim/vim74/syntax/group.vim
/usr/share/vim/vim74/syntax/gpg.vim
/usr/share/vim/vim74/syntax/sm.vim
/usr/share/vim/vim74/syntax/opl.vim
/usr/share/vim/vim74/syntax/smcl.vim
/usr/share/vim/vim74/syntax/takcmp.vim
/usr/share/vim/vim74/syntax/autoit.vim
/usr/share/vim/vim74/syntax/wsml.vim
/usr/share/vim/vim74/syntax/dcd.vim
/usr/share/vim/vim74/syntax/xpm2.vim
/usr/share/vim/vim74/syntax/smarty.vim
/usr/share/vim/vim74/syntax/mplayerconf.vim
/usr/share/vim/vim74/syntax/icon.vim
/usr/share/vim/vim74/syntax/cynpp.vim
/usr/share/vim/vim74/syntax/ch.vim
/usr/share/vim/vim74/syntax/pilrc.vim
/usr/share/vim/vim74/syntax/quake.vim
/usr/share/vim/vim74/syntax/ishd.vim
/usr/share/vim/vim74/syntax/rcs.vim
/usr/share/vim/vim74/syntax/syntax.vim
/usr/share/vim/vim74/syntax/msmessages.vim
/usr/share/vim/vim74/syntax/slang.vim
/usr/share/vim/vim74/syntax/netrc.vim
/usr/share/vim/vim74/syntax/haste.vim
/usr/share/vim/vim74/syntax/maple.vim
/usr/share/vim/vim74/syntax/remind.vim
/usr/share/vim/vim74/syntax/lex.vim
/usr/share/vim/vim74/syntax/sudoers.vim
/usr/share/vim/vim74/syntax/dosini.vim
/usr/share/vim/vim74/syntax/chill.vim
/usr/share/vim/vim74/syntax/proto.vim
/usr/share/vim/vim74/syntax/ia64.vim
/usr/share/vim/vim74/syntax/alsaconf.vim
/usr/share/vim/vim74/syntax/simula.vim
/usr/share/vim/vim74/syntax/aspperl.vim
/usr/share/vim/vim74/syntax/cdl.vim
/usr/share/vim/vim74/syntax/lss.vim
/usr/share/vim/vim74/syntax/slpconf.vim
/usr/share/vim/vim74/syntax/yaml.vim
/usr/share/vim/vim74/syntax/jovial.vim
/usr/share/vim/vim74/syntax/htmldjango.vim
/usr/share/vim/vim74/syntax/aspvbs.vim
/usr/share/vim/vim74/syntax/ampl.vim
/usr/share/vim/vim74/syntax/procmail.vim
/usr/share/vim/vim74/syntax/ocaml.vim
/usr/share/vim/vim74/syntax/xdefaults.vim
/usr/share/vim/vim74/syntax/povini.vim
/usr/share/vim/vim74/syntax/named.vim
/usr/share/vim/vim74/syntax/xs.vim
/usr/share/vim/vim74/syntax/reva.vim
/usr/share/vim/vim74/syntax/j.vim
/usr/share/vim/vim74/syntax/chaiscript.vim
/usr/share/vim/vim74/syntax/ld.vim
/usr/share/vim/vim74/syntax/cl.vim
/usr/share/vim/vim74/syntax/xquery.vim
/usr/share/vim/vim74/syntax/rhelp.vim
/usr/share/vim/vim74/syntax/slice.vim
/usr/share/vim/vim74/syntax/dracula.vim
/usr/share/vim/vim74/syntax/ldapconf.vim
/usr/share/vim/vim74/syntax/po.vim
/usr/share/vim/vim74/syntax/chaskell.vim
/usr/share/vim/vim74/syntax/cweb.vim
/usr/share/vim/vim74/syntax/spup.vim
/usr/share/vim/vim74/syntax/registry.vim
/usr/share/vim/vim74/syntax/snnsres.vim
/usr/share/vim/vim74/syntax/modula3.vim
/usr/share/vim/vim74/syntax/stata.vim
/usr/share/vim/vim74/syntax/lprolog.vim
/usr/share/vim/vim74/syntax/cuda.vim
/usr/share/vim/vim74/syntax/nqc.vim
/usr/share/vim/vim74/syntax/sgmllnx.vim
/usr/share/vim/vim74/syntax/verilog.vim
/usr/share/vim/vim74/syntax/hercules.vim
/usr/share/vim/vim74/syntax/cs.vim
/usr/share/vim/vim74/syntax/racc.vim
/usr/share/vim/vim74/syntax/bst.vim
/usr/share/vim/vim74/syntax/diva.vim
/usr/share/vim/vim74/syntax/web.vim
/usr/share/vim/vim74/syntax/cmake.vim
/usr/share/vim/vim74/syntax/sqlanywhere.vim
/usr/share/vim/vim74/syntax/mp.vim
/usr/share/vim/vim74/syntax/debsources.vim
/usr/share/vim/vim74/syntax/euphoria4.vim
/usr/share/vim/vim74/syntax/catalog.vim
/usr/share/vim/vim74/syntax/dns.vim
/usr/share/vim/vim74/syntax/docbksgml.vim
/usr/share/vim/vim74/syntax/gitsendemail.vim
/usr/share/vim/vim74/syntax/mysql.vim
/usr/share/vim/vim74/syntax/msql.vim
/usr/share/vim/vim74/syntax/sass.vim
/usr/share/vim/vim74/syntax/htmlcheetah.vim
/usr/share/vim/vim74/syntax/vb.vim
/usr/share/vim/vim74/syntax/upstreaminstalllog.vim
/usr/share/vim/vim74/syntax/sysctl.vim
/usr/share/vim/vim74/syntax/dtrace.vim
/usr/share/vim/vim74/syntax/jproperties.vim
/usr/share/vim/vim74/syntax/rpcgen.vim
/usr/share/vim/vim74/syntax/debcontrol.vim
/usr/share/vim/vim74/syntax/python.vim
/usr/share/vim/vim74/syntax/dockerfile.vim
/usr/share/vim/vim74/syntax/gtkrc.vim
/usr/share/vim/vim74/syntax/sgmldecl.vim
/usr/share/vim/vim74/syntax/groff.vim
/usr/share/vim/vim74/syntax/elinks.vim
/usr/share/vim/vim74/syntax/fan.vim
/usr/share/vim/vim74/syntax/abel.vim
/usr/share/vim/vim74/syntax/wget.vim
/usr/share/vim/vim74/syntax/webmacro.vim
/usr/share/vim/vim74/syntax/ptcap.vim
/usr/share/vim/vim74/syntax/ave.vim
/usr/share/vim/vim74/syntax/sqlhana.vim
/usr/share/vim/vim74/syntax/hostsaccess.vim
/usr/share/vim/vim74/syntax/messages.vim
/usr/share/vim/vim74/syntax/tads.vim
/usr/share/vim/vim74/syntax/vgrindefs.vim
/usr/share/vim/vim74/syntax/vim.vim
/usr/share/vim/vim74/syntax/dsl.vim
/usr/share/vim/vim74/syntax/screen.vim
/usr/share/vim/vim74/syntax/limits.vim
/usr/share/vim/vim74/syntax/mrxvtrc.vim
/usr/share/vim/vim74/syntax/expect.vim
/usr/share/vim/vim74/syntax/eiffel.vim
/usr/share/vim/vim74/syntax/fdcc.vim
/usr/share/vim/vim74/syntax/trasys.vim
/usr/share/vim/vim74/syntax/sqlforms.vim
/usr/share/vim/vim74/syntax/perl.vim
/usr/share/vim/vim74/syntax/slpreg.vim
/usr/share/vim/vim74/syntax/bdf.vim
/usr/share/vim/vim74/syntax/sqlinformix.vim
/usr/share/vim/vim74/syntax/dylanlid.vim
/usr/share/vim/vim74/syntax/docbk.vim
/usr/share/vim/vim74/syntax/udevconf.vim
/usr/share/vim/vim74/syntax/abaqus.vim
/usr/share/vim/vim74/syntax/crontab.vim
/usr/share/vim/vim74/syntax/jal.vim
/usr/share/vim/vim74/syntax/cterm.vim
/usr/share/vim/vim74/syntax/crm.vim
/usr/share/vim/vim74/syntax/lilo.vim
/usr/share/vim/vim74/syntax/sql.vim
/usr/share/vim/vim74/syntax/protocols.vim
/usr/share/vim/vim74/syntax/mel.vim
/usr/share/vim/vim74/syntax/uc.vim
/usr/share/vim/vim74/syntax/natural.vim
/usr/share/vim/vim74/syntax/csh.vim
/usr/share/vim/vim74/syntax/nastran.vim
/usr/share/vim/vim74/syntax/setserial.vim
/usr/share/vim/vim74/syntax/z8a.vim
/usr/share/vim/vim74/syntax/groovy.vim
/usr/share/vim/vim74/syntax/asmh8300.vim
/usr/share/vim/vim74/syntax/edif.vim
/usr/share/vim/vim74/syntax/sinda.vim
/usr/share/vim/vim74/syntax/cmusrc.vim
/usr/share/vim/vim74/syntax/cobol.vim
/usr/share/vim/vim74/syntax/dictconf.vim
/usr/share/vim/vim74/syntax/tt2html.vim
/usr/share/vim/vim74/syntax/upstreamdat.vim
/usr/share/vim/vim74/syntax/atlas.vim
/usr/share/vim/vim74/syntax/initng.vim
/usr/share/vim/vim74/syntax/falcon.vim
/usr/share/vim/vim74/syntax/gitrebase.vim
/usr/share/vim/vim74/syntax/xsd.vim
/usr/share/vim/vim74/syntax/fvwm2m4.vim
/usr/share/vim/vim74/syntax/ahdl.vim
/usr/share/vim/vim74/syntax/eruby.vim
/usr/share/vim/vim74/syntax/litestep.vim
/usr/share/vim/vim74/syntax/kivy.vim
/usr/share/vim/vim74/syntax/git.vim
/usr/share/vim/vim74/syntax/lynx.vim
/usr/share/vim/vim74/syntax/sdl.vim
/usr/share/vim/vim74/syntax/ipfilter.vim
/usr/share/vim/vim74/syntax/smith.vim
/usr/share/vim/vim74/syntax/nanorc.vim
/usr/share/vim/vim74/syntax/moo.vim
/usr/share/vim/vim74/syntax/basic.vim
/usr/share/vim/vim74/syntax/sqlj.vim
/usr/share/vim/vim74/syntax/gprof.vim
/usr/share/vim/vim74/syntax/xml.vim
/usr/share/vim/vim74/syntax/csp.vim
/usr/share/vim/vim74/syntax/lite.vim
/usr/share/vim/vim74/syntax/terminfo.vim
/usr/share/vim/vim74/syntax/abc.vim
/usr/share/vim/vim74/syntax/xmath.vim
/usr/share/vim/vim74/syntax/inittab.vim
/usr/share/vim/vim74/syntax/fortran.vim
/usr/share/vim/vim74/syntax/rib.vim
/usr/share/vim/vim74/syntax/libao.vim
/usr/share/vim/vim74/syntax/tar.vim
/usr/share/vim/vim74/syntax/virata.vim
/usr/share/vim/vim74/syntax/stp.vim
/usr/share/vim/vim74/syntax/services.vim
/usr/share/vim/vim74/syntax/openroad.vim
/usr/share/vim/vim74/syntax/pine.vim
/usr/share/vim/vim74/syntax/exports.vim
/usr/share/vim/vim74/syntax/radiance.vim
/usr/share/vim/vim74/syntax/grub.vim
/usr/share/vim/vim74/syntax/dts.vim
/usr/share/vim/vim74/syntax/trustees.vim
/usr/share/vim/vim74/syntax/pccts.vim
/usr/share/vim/vim74/syntax/mf.vim
/usr/share/vim/vim74/syntax/aptconf.vim
/usr/share/vim/vim74/syntax/lhaskell.vim
/usr/share/vim/vim74/syntax/xinetd.vim
/usr/share/vim/vim74/syntax/phtml.vim
/usr/share/vim/vim74/syntax/framescript.vim
/usr/share/vim/vim74/syntax/kix.vim
/usr/share/vim/vim74/syntax/htmlos.vim
/usr/share/vim/vim74/syntax/sieve.vim
/usr/share/vim/vim74/syntax/lifelines.vim
/usr/share/vim/vim74/syntax/apachestyle.vim
/usr/share/vim/vim74/syntax/apache.vim
/usr/share/vim/vim74/syntax/vera.vim
/usr/share/vim/vim74/syntax/idlang.vim
/usr/share/vim/vim74/syntax/baan.vim
/usr/share/vim/vim74/syntax/strace.vim
/usr/share/vim/vim74/syntax/slrnrc.vim
/usr/share/vim/vim74/syntax/sqr.vim
/usr/share/vim/vim74/syntax/tf.vim
/usr/share/vim/vim74/syntax/dirpager.vim
/usr/share/vim/vim74/syntax/change.vim
/usr/share/vim/vim74/syntax/readline.vim
/usr/share/vim/vim74/syntax/make.vim
/usr/share/vim/vim74/syntax/ppwiz.vim
/usr/share/vim/vim74/syntax/wdiff.vim
/usr/share/vim/vim74/syntax/icemenu.vim
/usr/share/vim/vim74/syntax/lout.vim
/usr/share/vim/vim74/syntax/jess.vim
/usr/share/vim/vim74/syntax/foxpro.vim
/usr/share/vim/vim74/syntax/freebasic.vim
/usr/share/vim/vim74/syntax/gdb.vim
/usr/share/vim/vim74/syntax/fetchmail.vim
/usr/share/vim/vim74/syntax/cf.vim
/usr/share/vim/vim74/syntax/prolog.vim
/usr/share/vim/vim74/syntax/cdrdaoconf.vim
/usr/share/vim/vim74/syntax/javascript.vim
/usr/share/vim/vim74/syntax/lace.vim
/usr/share/vim/vim74/syntax/forth.vim
/usr/share/vim/vim74/syntax/vsejcl.vim
/usr/share/vim/vim74/syntax/mgp.vim
/usr/share/vim/vim74/syntax/rng.vim
/usr/share/vim/vim74/syntax/rebol.vim
/usr/share/vim/vim74/syntax/spec.vim
/usr/share/vim/vim74/syntax/takout.vim
/usr/share/vim/vim74/syntax/ant.vim
/usr/share/vim/vim74/syntax/ldif.vim
/usr/share/vim/vim74/syntax/tt2.vim
/usr/share/vim/vim74/syntax/tli.vim
/usr/share/vim/vim74/syntax/sqloracle.vim
/usr/share/vim/vim74/syntax/passwd.vim
/usr/share/vim/vim74/syntax/docbkxml.vim
/usr/share/vim/vim74/syntax/sd.vim
/usr/share/vim/vim74/syntax/d.vim
/usr/share/vim/vim74/syntax/dcl.vim
/usr/share/vim/vim74/syntax/rc.vim
/usr/share/vim/vim74/syntax/logindefs.vim
/usr/share/vim/vim74/syntax/fgl.vim
/usr/share/vim/vim74/syntax/json.vim
/usr/share/vim/vim74/syntax/sdc.vim
/usr/share/vim/vim74/syntax/upstreamlog.vim
/usr/share/vim/vim74/syntax/idl.vim
/usr/share/vim/vim74/syntax/vhdl.vim
/usr/share/vim/vim74/syntax/ncf.vim
/usr/share/vim/vim74/syntax/rrst.vim
/usr/share/vim/vim74/syntax/calendar.vim
/usr/share/vim/vim74/syntax/specman.vim
/usr/share/vim/vim74/syntax/vrml.vim
/usr/share/vim/vim74/syntax/help.vim
/usr/share/vim/vim74/syntax/mix.vim
/usr/share/vim/vim74/syntax/css.vim
/usr/share/vim/vim74/syntax/2html.vim
/usr/share/vim/vim74/syntax/hastepreproc.vim
/usr/share/vim/vim74/syntax/desc.vim
/usr/share/vim/vim74/syntax/coco.vim
/usr/share/vim/vim74/syntax/context.vim
/usr/share/vim/vim74/syntax/sgml.vim
/usr/share/vim/vim74/syntax/robots.vim
/usr/share/vim/vim74/syntax/lpc.vim
/usr/share/vim/vim74/syntax/ecd.vim
/usr/share/vim/vim74/syntax/tidy.vim
/usr/share/vim/vim74/syntax/systemverilog.vim
/usr/share/vim/vim74/syntax/masm.vim
/usr/share/vim/vim74/syntax/sicad.vim
/usr/share/vim/vim74/syntax/asteriskvm.vim
/usr/share/vim/vim74/syntax/liquid.vim
/usr/share/vim/vim74/syntax/README.txt
/usr/share/vim/vim74/syntax/tak.vim
/usr/share/vim/vim74/syntax/asn.vim
/usr/share/vim/vim74/syntax/rnc.vim
/usr/share/vim/vim74/syntax/htmlm4.vim
/usr/share/vim/vim74/syntax/blank.vim
/usr/share/vim/vim74/syntax/changelog.vim
/usr/share/vim/vim74/syntax/msidl.vim
/usr/share/vim/vim74/syntax/gitolite.vim
/usr/share/vim/vim74/syntax/uil.vim
/usr/share/vim/vim74/syntax/vmasm.vim
/usr/share/vim/vim74/syntax/ppd.vim
/usr/share/vim/vim74/syntax/bindzone.vim
/usr/share/vim/vim74/syntax/eviews.vim
/usr/share/vim/vim74/syntax/gnuplot.vim
/usr/share/vim/vim74/spell
/usr/share/vim/vim74/spell/yi.vim
/usr/share/vim/vim74/spell/en.latin1.spl
/usr/share/vim/vim74/spell/en.latin1.sug
/usr/share/vim/vim74/spell/en.utf-8.sug
/usr/share/vim/vim74/spell/fixdup.vim
/usr/share/vim/vim74/spell/en.ascii.sug
/usr/share/vim/vim74/spell/spell.vim
/usr/share/vim/vim74/spell/en.utf-8.spl
/usr/share/vim/vim74/spell/he.vim
/usr/share/vim/vim74/spell/check_locales.vim
/usr/share/vim/vim74/spell/en.ascii.spl
/usr/share/vim/vim74/spell/cleanadd.vim
/usr/share/vim/vim74/vimrc_example.vim
/usr/share/vim/vim74/doc
/usr/share/vim/vim74/doc/editing.txt
/usr/share/vim/vim74/doc/os_os2.txt
/usr/share/vim/vim74/doc/usr_42.txt
/usr/share/vim/vim74/doc/quotes.txt
/usr/share/vim/vim74/doc/scroll.txt
/usr/share/vim/vim74/doc/usr_12.txt
/usr/share/vim/vim74/doc/if_mzsch.txt
/usr/share/vim/vim74/doc/usr_09.txt
/usr/share/vim/vim74/doc/gui_x11.txt
/usr/share/vim/vim74/doc/insert.txt
/usr/share/vim/vim74/doc/os_qnx.txt
/usr/share/vim/vim74/doc/if_perl.txt
/usr/share/vim/vim74/doc/usr_31.txt
/usr/share/vim/vim74/doc/recover.txt
/usr/share/vim/vim74/doc/usr_04.txt
/usr/share/vim/vim74/doc/arabic.txt
/usr/share/vim/vim74/doc/tips.txt
/usr/share/vim/vim74/doc/motion.txt
/usr/share/vim/vim74/doc/filetype.txt
/usr/share/vim/vim74/doc/usr_11.txt
/usr/share/vim/vim74/doc/usr_20.txt
/usr/share/vim/vim74/doc/rileft.txt
/usr/share/vim/vim74/doc/windows.txt
/usr/share/vim/vim74/doc/gui_w16.txt
/usr/share/vim/vim74/doc/sponsor.txt
/usr/share/vim/vim74/doc/os_msdos.txt
/usr/share/vim/vim74/doc/autocmd.txt
/usr/share/vim/vim74/doc/pi_tar.txt
/usr/share/vim/vim74/doc/pi_getscript.txt
/usr/share/vim/vim74/doc/pi_gzip.txt
/usr/share/vim/vim74/doc/if_ole.txt
/usr/share/vim/vim74/doc/develop.txt
/usr/share/vim/vim74/doc/os_risc.txt
/usr/share/vim/vim74/doc/usr_32.txt
/usr/share/vim/vim74/doc/change.txt
/usr/share/vim/vim74/doc/usr_40.txt
/usr/share/vim/vim74/doc/helphelp.txt
/usr/share/vim/vim74/doc/todo.txt
/usr/share/vim/vim74/doc/sign.txt
/usr/share/vim/vim74/doc/version4.txt
/usr/share/vim/vim74/doc/usr_toc.txt
/usr/share/vim/vim74/doc/tabpage.txt
/usr/share/vim/vim74/doc/os_390.txt
/usr/share/vim/vim74/doc/quickref.txt
/usr/share/vim/vim74/doc/workshop.txt
/usr/share/vim/vim74/doc/debugger.txt
/usr/share/vim/vim74/doc/if_cscop.txt
/usr/share/vim/vim74/doc/netbeans.txt
/usr/share/vim/vim74/doc/usr_01.txt
/usr/share/vim/vim74/doc/os_beos.txt
/usr/share/vim/vim74/doc/undo.txt
/usr/share/vim/vim74/doc/various.txt
/usr/share/vim/vim74/doc/version5.txt
/usr/share/vim/vim74/doc/usr_90.txt
/usr/share/vim/vim74/doc/hangulin.txt
/usr/share/vim/vim74/doc/gui.txt
/usr/share/vim/vim74/doc/fold.txt
/usr/share/vim/vim74/doc/if_pyth.txt
/usr/share/vim/vim74/doc/os_win32.txt
/usr/share/vim/vim74/doc/russian.txt
/usr/share/vim/vim74/doc/usr_03.txt
/usr/share/vim/vim74/doc/usr_25.txt
/usr/share/vim/vim74/doc/intro.txt
/usr/share/vim/vim74/doc/pi_netrw.txt
/usr/share/vim/vim74/doc/map.txt
/usr/share/vim/vim74/doc/hebrew.txt
/usr/share/vim/vim74/doc/index.txt
/usr/share/vim/vim74/doc/visual.txt
/usr/share/vim/vim74/doc/debug.txt
/usr/share/vim/vim74/doc/usr_45.txt
/usr/share/vim/vim74/doc/os_mac.txt
/usr/share/vim/vim74/doc/usr_27.txt
/usr/share/vim/vim74/doc/if_sniff.txt
/usr/share/vim/vim74/doc/indent.txt
/usr/share/vim/vim74/doc/mbyte.txt
/usr/share/vim/vim74/doc/cmdline.txt
/usr/share/vim/vim74/doc/term.txt
/usr/share/vim/vim74/doc/diff.txt
/usr/share/vim/vim74/doc/usr_43.txt
/usr/share/vim/vim74/doc/pi_zip.txt
/usr/share/vim/vim74/doc/pattern.txt
/usr/share/vim/vim74/doc/usr_08.txt
/usr/share/vim/vim74/doc/os_amiga.txt
/usr/share/vim/vim74/doc/starting.txt
/usr/share/vim/vim74/doc/version6.txt
/usr/share/vim/vim74/doc/help.txt
/usr/share/vim/vim74/doc/usr_41.txt
/usr/share/vim/vim74/doc/os_unix.txt
/usr/share/vim/vim74/doc/usr_02.txt
/usr/share/vim/vim74/doc/pi_spec.txt
/usr/share/vim/vim74/doc/farsi.txt
/usr/share/vim/vim74/doc/usr_23.txt
/usr/share/vim/vim74/doc/if_lua.txt
/usr/share/vim/vim74/doc/usr_26.txt
/usr/share/vim/vim74/doc/if_tcl.txt
/usr/share/vim/vim74/doc/remote.txt
/usr/share/vim/vim74/doc/pi_paren.txt
/usr/share/vim/vim74/doc/ft_sql.txt
/usr/share/vim/vim74/doc/digraph.txt
/usr/share/vim/vim74/doc/os_dos.txt
/usr/share/vim/vim74/doc/uganda.txt
/usr/share/vim/vim74/doc/if_ruby.txt
/usr/share/vim/vim74/doc/usr_06.txt
/usr/share/vim/vim74/doc/usr_21.txt
/usr/share/vim/vim74/doc/ft_ada.txt
/usr/share/vim/vim74/doc/usr_30.txt
/usr/share/vim/vim74/doc/howto.txt
/usr/share/vim/vim74/doc/vim2html.pl
/usr/share/vim/vim74/doc/spell.txt
/usr/share/vim/vim74/doc/mlang.txt
/usr/share/vim/vim74/doc/gui_w32.txt
/usr/share/vim/vim74/doc/syntax.txt
/usr/share/vim/vim74/doc/usr_07.txt
/usr/share/vim/vim74/doc/usr_22.txt
/usr/share/vim/vim74/doc/usr_44.txt
/usr/share/vim/vim74/doc/options.txt
/usr/share/vim/vim74/doc/vi_diff.txt
/usr/share/vim/vim74/doc/usr_28.txt
/usr/share/vim/vim74/doc/quickfix.txt
/usr/share/vim/vim74/doc/eval.txt
/usr/share/vim/vim74/doc/usr_29.txt
/usr/share/vim/vim74/doc/message.txt
/usr/share/vim/vim74/doc/usr_10.txt
/usr/share/vim/vim74/doc/version7.txt
/usr/share/vim/vim74/doc/os_mint.txt
/usr/share/vim/vim74/doc/repeat.txt
/usr/share/vim/vim74/doc/tags
/usr/share/vim/vim74/doc/tagsrch.txt
/usr/share/vim/vim74/doc/print.txt
/usr/share/vim/vim74/doc/usr_05.txt
/usr/share/vim/vim74/doc/os_vms.txt
/usr/share/vim/vim74/doc/usr_24.txt
/usr/share/vim/vim74/doc/pi_vimball.txt
/usr/share/vim/vim74/menu.vim
/usr/share/vim/vim74/bugreport.vim
/usr/share/vim/vim74/autoload
/usr/share/vim/vim74/autoload/xmlcomplete.vim
/usr/share/vim/vim74/autoload/getscript.vim
/usr/share/vim/vim74/autoload/htmlcomplete.vim
/usr/share/vim/vim74/autoload/rubycomplete.vim
/usr/share/vim/vim74/autoload/netrw_gitignore.vim
/usr/share/vim/vim74/autoload/adacomplete.vim
/usr/share/vim/vim74/autoload/netrwFileHandlers.vim
/usr/share/vim/vim74/autoload/ada.vim
/usr/share/vim/vim74/autoload/syntaxcomplete.vim
/usr/share/vim/vim74/autoload/javascriptcomplete.vim
/usr/share/vim/vim74/autoload/csscomplete.vim
/usr/share/vim/vim74/autoload/paste.vim
/usr/share/vim/vim74/autoload/spellfile.vim
/usr/share/vim/vim74/autoload/phpcomplete.vim
/usr/share/vim/vim74/autoload/python3complete.vim
/usr/share/vim/vim74/autoload/zip.vim
/usr/share/vim/vim74/autoload/netrw.vim
/usr/share/vim/vim74/autoload/clojurecomplete.vim
/usr/share/vim/vim74/autoload/netrwSettings.vim
/usr/share/vim/vim74/autoload/gzip.vim
/usr/share/vim/vim74/autoload/tohtml.vim
/usr/share/vim/vim74/autoload/sqlcomplete.vim
/usr/share/vim/vim74/autoload/xml
/usr/share/vim/vim74/autoload/xml/html401f.vim
/usr/share/vim/vim74/autoload/xml/html40s.vim
/usr/share/vim/vim74/autoload/xml/html32.vim
/usr/share/vim/vim74/autoload/xml/html40f.vim
/usr/share/vim/vim74/autoload/xml/html401t.vim
/usr/share/vim/vim74/autoload/xml/html40t.vim
/usr/share/vim/vim74/autoload/xml/xhtml10f.vim
/usr/share/vim/vim74/autoload/xml/xhtml10t.vim
/usr/share/vim/vim74/autoload/xml/html401s.vim
/usr/share/vim/vim74/autoload/xml/xsd.vim
/usr/share/vim/vim74/autoload/xml/xsl.vim
/usr/share/vim/vim74/autoload/xml/xhtml10s.vim
/usr/share/vim/vim74/autoload/xml/xhtml11.vim
/usr/share/vim/vim74/autoload/ccomplete.vim
/usr/share/vim/vim74/autoload/tar.vim
/usr/share/vim/vim74/autoload/vimball.vim
/usr/share/vim/vim74/autoload/gnat.vim
/usr/share/vim/vim74/autoload/decada.vim
/usr/share/vim/vim74/autoload/README.txt
/usr/share/vim/vim74/autoload/pythoncomplete.vim
/usr/share/vim/vim74/plugin
/usr/share/vim/vim74/plugin/tarPlugin.vim
/usr/share/vim/vim74/plugin/matchparen.vim
/usr/share/vim/vim74/plugin/rrhelper.vim
/usr/share/vim/vim74/plugin/zipPlugin.vim
/usr/share/vim/vim74/plugin/getscriptPlugin.vim
/usr/share/vim/vim74/plugin/spellfile.vim
/usr/share/vim/vim74/plugin/gzip.vim
/usr/share/vim/vim74/plugin/tohtml.vim
/usr/share/vim/vim74/plugin/netrwPlugin.vim
/usr/share/vim/vim74/plugin/vimballPlugin.vim
/usr/share/vim/vim74/plugin/README.txt
/usr/share/vim/vim74/rgb.txt
/usr/share/vim/vim74/colors
/usr/share/vim/vim74/colors/koehler.vim
/usr/share/vim/vim74/colors/slate.vim
/usr/share/vim/vim74/colors/murphy.vim
/usr/share/vim/vim74/colors/evening.vim
/usr/share/vim/vim74/colors/torte.vim
/usr/share/vim/vim74/colors/blue.vim
/usr/share/vim/vim74/colors/industry.vim
/usr/share/vim/vim74/colors/peachpuff.vim
/usr/share/vim/vim74/colors/delek.vim
/usr/share/vim/vim74/colors/shine.vim
/usr/share/vim/vim74/colors/default.vim
/usr/share/vim/vim74/colors/elflord.vim
/usr/share/vim/vim74/colors/zellner.vim
/usr/share/vim/vim74/colors/morning.vim
/usr/share/vim/vim74/colors/desert.vim
/usr/share/vim/vim74/colors/ron.vim
/usr/share/vim/vim74/colors/pablo.vim
/usr/share/vim/vim74/colors/darkblue.vim
/usr/share/vim/vim74/colors/README.txt
/usr/share/vim/vim74/ftplugof.vim
/usr/share/vim/vim74/filetype.vim
/usr/share/vim/vim74/delmenu.vim
/usr/share/vim/vim74/print
/usr/share/vim/vim74/print/iso-8859-7.ps
/usr/share/vim/vim74/print/cp1255.ps
/usr/share/vim/vim74/print/gb_roman.ps
/usr/share/vim/vim74/print/cns_roman.ps
/usr/share/vim/vim74/print/iso-8859-13.ps
/usr/share/vim/vim74/print/koi8-r.ps
/usr/share/vim/vim74/print/dec-mcs.ps
/usr/share/vim/vim74/print/iso-8859-2.ps
/usr/share/vim/vim74/print/prolog.ps
/usr/share/vim/vim74/print/cp1254.ps
/usr/share/vim/vim74/print/mac-roman.ps
/usr/share/vim/vim74/print/iso-8859-9.ps
/usr/share/vim/vim74/print/iso-8859-5.ps
/usr/share/vim/vim74/print/cp1250.ps
/usr/share/vim/vim74/print/hp-roman8.ps
/usr/share/vim/vim74/print/ks_roman.ps
/usr/share/vim/vim74/print/iso-8859-15.ps
/usr/share/vim/vim74/print/koi8-u.ps
/usr/share/vim/vim74/print/ascii.ps
/usr/share/vim/vim74/print/cp1251.ps
/usr/share/vim/vim74/print/iso-8859-10.ps
/usr/share/vim/vim74/print/cp1257.ps
/usr/share/vim/vim74/print/iso-8859-14.ps
/usr/share/vim/vim74/print/iso-8859-11.ps
/usr/share/vim/vim74/print/cidfont.ps
/usr/share/vim/vim74/print/cp1252.ps
/usr/share/vim/vim74/print/iso-8859-3.ps
/usr/share/vim/vim74/print/iso-8859-4.ps
/usr/share/vim/vim74/print/cp1253.ps
/usr/share/vim/vim74/print/ebcdic-uk.ps
/usr/share/vim/vim74/print/iso-8859-8.ps
/usr/share/vim/vim74/print/jis_roman.ps
/usr/share/vim/vim74/print/latin1.ps
/usr/share/vim/vim74/tutor
/usr/share/vim/vim74/tutor/tutor.bar
/usr/share/vim/vim74/tutor/tutor.nl.utf-8
/usr/share/vim/vim74/tutor/tutor.nb.utf-8
/usr/share/vim/vim74/tutor/README.el.cp737.txt
/usr/share/vim/vim74/tutor/tutor.sr.cp1250
/usr/share/vim/vim74/tutor/tutor.hu.utf-8
/usr/share/vim/vim74/tutor/tutor.eo
/usr/share/vim/vim74/tutor/tutor.eo.utf-8
/usr/share/vim/vim74/tutor/tutor.zh_tw.utf-8
/usr/share/vim/vim74/tutor/tutor.ko.euc
/usr/share/vim/vim74/tutor/tutor.zh_cn.utf-8
/usr/share/vim/vim74/tutor/tutor.ko.utf-8
/usr/share/vim/vim74/tutor/tutor.pl
/usr/share/vim/vim74/tutor/tutor.tr.iso9
/usr/share/vim/vim74/tutor/tutor.no
/usr/share/vim/vim74/tutor/tutor.tr.utf-8
/usr/share/vim/vim74/tutor/tutor.pl.cp1250
/usr/share/vim/vim74/tutor/tutor.es.utf-8
/usr/share/vim/vim74/tutor/tutor.ca
/usr/share/vim/vim74/tutor/tutor.sk.utf-8
/usr/share/vim/vim74/tutor/tutor.zh.euc
/usr/share/vim/vim74/tutor/tutor.hr
/usr/share/vim/vim74/tutor/tutor.hu.cp1250
/usr/share/vim/vim74/tutor/tutor.pt
/usr/share/vim/vim74/tutor/tutor.el
/usr/share/vim/vim74/tutor/tutor.vi.utf-8
/usr/share/vim/vim74/tutor/tutor.ja.euc
/usr/share/vim/vim74/tutor/tutor.sk.cp1250
/usr/share/vim/vim74/tutor/tutor.bar.utf-8
/usr/share/vim/vim74/tutor/tutor.hr.cp1250
/usr/share/vim/vim74/tutor/tutor.hr.utf-8
/usr/share/vim/vim74/tutor/tutor.sv.utf-8
/usr/share/vim/vim74/tutor/tutor.zh.big5
/usr/share/vim/vim74/tutor/tutor.sr.utf-8
/usr/share/vim/vim74/tutor/tutor.it
/usr/share/vim/vim74/tutor/tutor.ca.utf-8
/usr/share/vim/vim74/tutor/tutor.el.cp737
/usr/share/vim/vim74/tutor/tutor.fr
/usr/share/vim/vim74/tutor/tutor.sk
/usr/share/vim/vim74/tutor/tutor.ru.cp1251
/usr/share/vim/vim74/tutor/tutor.el.utf-8
/usr/share/vim/vim74/tutor/tutor.de.utf-8
/usr/share/vim/vim74/tutor/tutor.es
/usr/share/vim/vim74/tutor/tutor.cs
/usr/share/vim/vim74/tutor/tutor.hu
/usr/share/vim/vim74/tutor/tutor.de
/usr/share/vim/vim74/tutor/tutor.fr.utf-8
/usr/share/vim/vim74/tutor/tutor.no.utf-8
/usr/share/vim/vim74/tutor/tutor.zh.utf-8
/usr/share/vim/vim74/tutor/tutor.ja.utf-8
/usr/share/vim/vim74/tutor/tutor.cs.utf-8
/usr/share/vim/vim74/tutor/tutor.nb
/usr/share/vim/vim74/tutor/tutor.sv
/usr/share/vim/vim74/tutor/tutor.cs.cp1250
/usr/share/vim/vim74/tutor/tutor.vim
/usr/share/vim/vim74/tutor/tutor.it.utf-8
/usr/share/vim/vim74/tutor/tutor.ru.utf-8
/usr/share/vim/vim74/tutor/tutor.ja.sjis
/usr/share/vim/vim74/tutor/tutor.ru
/usr/share/vim/vim74/tutor/README.el.txt
/usr/share/vim/vim74/tutor/tutor.pl.utf-8
/usr/share/vim/vim74/tutor/tutor.pt.utf-8
/usr/share/vim/vim74/tutor/tutor.nl
/usr/share/vim/vim74/tutor/tutor.utf-8
/usr/share/vim/vim74/tutor/README.txt
/usr/share/vim/vim74/tutor/tutor
/usr/share/doc
/usr/share/doc/vim-runtime
/usr/share/doc/vim-runtime/NEWS.Debian.gz
/usr/share/doc/vim-runtime/copyright
/usr/share/doc/vim-runtime/changelog.Debian.gz
/usr/share/man
/usr/share/man/pl
/usr/share/man/pl/man1
/usr/share/man/pl/man1/vimtutor.1.gz
/usr/share/man/ja
/usr/share/man/ja/man1
/usr/share/man/ja/man1/vimtutor.1.gz
/usr/share/man/fr
/usr/share/man/fr/man1
/usr/share/man/fr/man1/vimtutor.1.gz
/usr/share/man/man1
/usr/share/man/man1/vimtutor.1.gz
/usr/share/man/ru
/usr/share/man/ru/man1
/usr/share/man/ru/man1/vimtutor.1.gz
/usr/share/man/it
/usr/share/man/it/man1
/usr/share/man/it/man1/vimtutor.1.gz
/usr/share/vim/addons/doc/matchit.txt
/usr/share/vim/addons/plugin/matchit.vim
/usr/share/vim/addons/plugin/editexisting.vim
/usr/share/vim/addons/plugin/justify.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ELF          (    8 4   =  4   	 (     p8  8  8                 4   4   4                  T  T  T                             D  D           8 8 8 H7            P P P 0  0           p  p  p  D   D         Qtd                          Rtd8 8 8 Z  Z        /lib/ld-linux-armhf.so.3             GNU                        GNU ̙y~e'	           P* 4 BI5T$!-X@ F  
0M P0D   		R Mpl=  KBX@!>!(`2	DD@CǹLݱB1RA<pl͹ T@Y 1)   ">e     0!    b]@02"("G(G
 `    Ai)D*$ 
@P P8 0R$   0H.'!0q`!R 8  
Q	Ot$  Ђq"HRPVDIdCX7 C-; ٌx&=XK30Sa	dҦֹF9hWF@rL @A   p@C%BTNŀ"!t	 4    AĞDJ@&$q (@                                                                                          	                                   !  #  %              '          (          *  +      .  0  4              6      7      8  9  :          ;      <      =  @  A  C  D      E      G  L      O      P  Q  R  T  V      W  X  [          ]  _  a      b  c  d  f      g  i          l              m  o  p  r      t      u  v  x  y  z      {  }  ~                                                                                                                                                                                              	                          !      "  $  %  '      (  )  *  .  /  1  2      3      5  7      9          <  =  >      ?      D      G      H  K      L  N  O      P  Q  T  W  Z  \  `  b  d  h  k  l  m  n      q  r  u  v  w      y  {  }                                                                                                                                                                                                                                                                                                                         
                                                     !  "  $      %  &  '  )          +  ,  -  /  0  2  5  6      7  9      ;  <  =      >  ?  B      D  F  H  J  L  M  Q  R  T  Y          Z  [      \  ^      _  c  f  h  m          o  p  u  v      w  z  |      ~                                                          dHmw0<_do%$Wץ$Y|[TnI$j;sF6K}ͣmK-PV'z:KZ	۟)i~Q.8cD8Kr|5fҟ-W]VKC1s1Fk;˭ֳhSdW)`
Pcc)%'AX
4uCf0(.5x!!©.5xlBB`>=nttp`!c
|u*C<|q||biǜiSf>M[|vo8x% W8aL|M:|I//`T6b拷RDº5'ḋC
ާ|!*A3NSJ|ɡFgRS5/ʳBcߦSpibd	]8\{+l?Uϝ|` #2r!|*|0*ʹfi?t/|)|IuBU	5"+2vͳK;|Dr9쩏_W➖Bk/1TN=ܒ?|I|K|LsN/7WNI>E|)nO|F|.{Y2AP|}WS[CEU|/MHV|HFV|! ƓL !IY|[|
389(5]|؄ݷ͏ޡCή431gdHG	vͪ__|i|pf];<d|uf/IFPd?MҥM"򛢎Q9Kn|㞜i8tm2J۝zeX[̋c9u|u|b<w|}M 6z|q|
kvDSO0KV@UbG0)09{|X{|1%}||bSNlAq|UTIVҌ|
H|l͚0*>i+W'@@|Z>uuġBS)O|\{p@lki9lf@%lUY0"|pd0|^sd1 4O9um-|&A᠖&GwT<|H|gal#|̖l&-'O||s$Ͽǌ#T,z:Z=tt'}Ul p=󪍹5rK|B[@|v||2{|r'53 x\$STHY%®Q`:ssG|ރ애W|"F]
,M71.]uG"F? 9 )WW|Hjˋ5O|mV$uk[tP=BC<1̭@2:,R9||Sm=|/Woص&Vh|о+:#
_kW=+(
@ipD_fw@ݪ7:/f$5B W79`ƹHj[WX9OQU	!S|u\H^:o puf98޺4(cSS|ۃ#_g~ |92%u}΁_?nC$dci!SXy|kۥl+V`L\$/pzdvHMH޲wA͉1B +zX%0|Ctgu&r $ҫj oFQ|~4=/K$<{Tds{zNoҢY$8\~?7W/a|iuo\zc
M|]ySN|,$k|pS'L1/NKKJ׺6k	Cְ˥EH|4ΪLebw`IgnvJ8 w¡=?c0!Nb3!6>W0">;lˌ!yf3K 2>8G$$Y	Vr|pYH$WAN5V4v38!.Tt%{|W%/+ԸiTǘŰ=?#rf˖lP»|z,ᣪ_-%76qP'w<>̀CU AH&"tلQ4|cLC,96j|aY||u^H%簌1 >Ɯ*A7Ǚ5Nߺ	jj,вk/e؊Uo̅ZdH87@h	3r
n,apP뷸vo4z=o5lyO1qk4qsdvGd5EZWqX(#'pkÕ8|ǖ}ZlCQf*LvkSè4O *0me2                    T            @                                                                                                                 K             0                                                    &          "                o                          |                                         F                                                                  j                          \             K             a                                                                 0             =                                       %                                                                   }                                                     "                                       d                          j             6                          Q                                                                              B                                                                                           m                                                                  k                          u                          >             `                                                                                                                       W                                       E                                                                   |             d                           P                          Y                                                                  4                                                    '               d                                       7                          1                           }                                       5                                                                                                        <                          s              C                                                    N             Z                                                                                                                       X                          )                                                       x                           $                                                     D             U                           "             G             _                                                    |             f                          ?                        !                                          6                                                                    `                          {                          /                                                    n                           J                            i                           g             =                                       !                          v                          +             .                          r             Q                                       t                                        C             ]             e                                         1             x               6      ~        @          <5              !  8        \         4                         <        T<      #  :      
  Ȣ        D      	  P6      n  <        3        x        `:      #	  t      "  x/        -              R        a  ȥ      c  H3 +       x      |  6      M                5        !        	  D| p*      3      6  :        d <     "  P      Z           X      +  ̟        @                 L      6        !  8             y        &  h              0	        t        >  <2      	                        !  :               i           2      j  H      	  6 &             P          T                8                x      x                1  p      
   ,     l  Ԟ              	          D;       8        x        5      E#  P        l                       x1      (  |                D        `                40      +  :        8 %             g          d      
                  :                H      v          d         \      l  t      [         	   0 4               ,        / '     M  б      
  :      @  X      9                        	        
  Ȯ      2  Ԯ              !  ,        4        d<                L        Ȭ        3      9   8      #          p      
          :      U  P      ]	  x6      
        M           $      `
  :      v                  D        X      3  |      {        F  0 )     "  8                              	                           `        /        8: '       d      <  (        u        Ȥ      S  ĥ        ı      O  `8      "  :        Ԥ              !  :      h          0      4         G  p      x  5              #  h         x        	 @              @      
  2 (             "        A        i                <  <       5
  P0 9               P        ؝         |      #          / *              R
  ܢ      
        v
  |      Y  :        ܠ      
        X                                 !  Ⱦ 0      4              (        `!  8      ,  Ю      7  (      t"  l<        ȟ      `  9 F               7 %              o!  4      2"  (                ̝      	        J  :                |8      Q                W  P      )  8        5      h          \u d     q	           X5      L  0      h  l7 .       X<               s        N                        ?  p                `      2        #  L      m        R  X        L9      S        "  D        x      g	        "  4         T      "  ğ        7      8        Q                D        g  ̥      !  $      ^  L.      G          `<                9      6          ̤      (  l      f  H              1          @        7      H  T        ( $               `        H        (        \      e"  t5        X                3        X.      y          8      #        0        C  h      !   6 /               P      _  @                                a        ?          ܝ      X   H.      !  4        f     ;  :              m          . I     a  2 #       ܱ        Ƞ      2  .      ^         ?!  О      !  П        9 A     ^  X                 t      A          `        4      R  Ա                .        $      
          x:      O  <       6        G  ̱      R                        !        J#  T        T        L        X                 :      
        9  Ȟ      2          :                $        @        `              m        m        6  t3 2        T    O        	  5 $       1                0      W                          ܞ        @                0  x<      0        c          :      "  ( d            c          ̮        8                X        l                L                X      '#  4      
  ,        6      4  H      w                                                 p  خ        ,        6      j
                        8          P        :        9        \         \<      ,"  $                |      "  <      "                  <      t                        4         (  D      o          H        p      n          84       M  d      a          $2      !          d      8  0                7 "     K
  Т        2      F        #  H        x      `        d                Q!        U        l  5 4     +  @              ?          l      C  ؟        \      @  P      	        G	  ĝ      
  :      m"  4        Į        t<        / %       7        |      `  47        1                 0 '       2      .  1                        Н        ,9        p<      "  @                         0               ȱ      W
                -                *  0               
        c            ܮ      )
  L        |                      "           d9                4 +     v        i  X       	  D.        P:	 X     "  t4      d  $      u  Р        p=      	        D  ؠ      B
  ̢              
  1              P#  X4         (      %          :        D        ܤ        <      L"          \      7  T                L7      7        t!                          h                h      
  P.      "  7        ؤ                ,      z  \      r                }        ]   ; P      :        <      R  8      N  h<      L        ]  X         ,        |<      (!  :      {                        Z        \                        2  p ,       t              :  L        08      F        B   t      7"  x        Ĭ         T.      
        /   `         ԟ      _"  0              {  (        X        ̠        L      _         [        {  Ĥ      0#  x                                                |9      ,  H              	  |                 l        `        3 /     g  . 5       h $     D  1              [  T $             #  |2        \      q                  `      !        i  X              G  :        L               !  ̞              t        '  d6        -      j        	          @1 8        @        :      )   4      Y  <      q  X         Ġ      T          \/                                T      V  8     g  $        <                $      h           \2      
          |                         /              t        4      o           0      d  H        ȝ                              N  8        D8      	  0                P      -  8      H  ԝ      	  Ģ      I  0        (        ,        P      X         x  4/ %                      H  ؞        d              "        q  1 6               ?  ܟ        ĭ              h        !                }  (        ر      '          P<        h              W        C  <       W  4      m        ;          u       7!  0      b  D      $  @              t   T      {	        	          Ğ              (        &  d      Y"  ,        Ф        p      H        ;	  4        <                Ԡ       libm.so.6 _ITM_deregisterTMCloneTable __gmon_start__ _Jv_RegisterClasses _ITM_registerTMCloneTable acos sinh fmod sqrt ceil pow log tanh cosh asin floor atan2 atan log10 libtinfo.so.5 UP tgetnum BC ospeed tgetstr tgetent PC tputs tgetflag tgoto libselinux.so.1 is_selinux_enabled getfilecon setfilecon freecon libacl.so.1 acl_get_file acl_set_file acl_free libgpm.so.2 Gpm_Close Gpm_GetEvent gpm_flag gpm_fd Gpm_Open libdl.so.2 dlsym dlerror dlclose dlopen libc.so.6 socket __stpcpy_chk mkdtemp fflush strcpy execl sprintf _IO_putc setlocale srand towlower strncmp getpwent strrchr __longjmp_chk pipe __isoc99_sscanf dcgettext connect getpwuid __fdelt_chk closedir nanosleep fchdir ftell strncpy fork __stack_chk_fail unlink putchar mkdir realloc fsync towupper stdin memchr strpbrk getpid kill bind_textdomain_codeset strftime chmod __assert_fail rewind strtod strtok endpwent strtol isatty feof fgets getpwnam strlen ungetc sigemptyset memset strstr rmdir __errno_location tcsetattr fseek memcmp dup2 __fxstat64 _setjmp ctime iswupper fchown stdout fputc fseeko64 fputs sigaltstack memcpy fclose __memmove_chk malloc strcat umask strcasecmp ftello64 raise getgid __lxstat64 nl_langinfo opendir __xstat64 __ctype_b_loc getenv stderr ioctl alarm gethostbyname dup __memset_chk getuid readlink execvp strncasecmp strncat fileno sigset getcwd fwrite fread iconv_close gettimeofday rename sigaction __memcpy_chk tcflush waitpid localtime lseek64 strchr fprintf utime mblen iconv fdopen readdir64 qsort iconv_open tcgetattr __ctype_toupper_loc __strcpy_chk __ctype_tolower_loc __cxa_finalize setsid fcntl getrlimit64 __sprintf_chk memmove uname _nl_msg_cat_cntr fopen64 bindtextdomain access _IO_getc sysinfo __strcat_chk strcmp strerror __libc_start_main setpwent ferror stpcpy setenv sysconf __environ ld-linux-armhf.so.3 __stack_chk_guard __data_start _edata __bss_start __bss_start__ __bss_end__ __end__ _end did_syncbind __libc_csu_fini e_exists ScreenLinesUC p_cp msg_row p_ve swb_flags p_tbs p_mls didset_vimruntime save_p_ls p_tm p_hh output_conv autocmd_no_enter p_sbo p_sft globaldir save_p_wmh e_readonly p_wmw p_bkc swap_exists_action e_noalt p_ch VIsual_reselect quit_more e_positive p_ws p_sh want_garbage_collect mb_char2len emsg_severe longVersion p_siso p_wiw p_wc keep_msg_more e_sandbox p_wa e_nogroup redraw_cmdline p_lpl compiled_sys allow_keys TabPageIdxs need_check_timestamps e_nomatch fdo_flags do_redraw did_throw p_pmcs p_sws e_noname mouse_row e_maxmempat exmode_active screen_Rows cmp_flags get_c_indent sc_col all_lflags netbeansSuppressNoLines time_fd p_hkmap e_screenmode ScreenAttrs e_nbreadonly p_report VIsual p_sp textlock fill_vert current_SID cterm_normal_fg_color e_umark stl_syntax lcs_conceal p_ttym bkc_flags diff_need_scrollbind decl p_fp p_bk lines_left p_sr p_lcs screen_Columns p_kp p_bg get_expr_indent maptick caught_stack p_ww lcs_ext p_sj p_ttm p_mat no_smartcase curscript p_write did_cursorhold p_awa lc_jump_env mb_ptr2char lcs_tab1 ignoredp e_invrange ssop_flags mb_ptr2len e_cmdwin e_marknotset termcap_active e_endif p_sta e_invalidreg p_timeout p_vdir get_lisp_indent debug_did_msg term_strings p_re p_vb e_number_exp msg_didany p_guicursor p_para p_title au_pending_free_buf g_do_tagpreview p_sections p_slm default_vim_dir p_fcs p_csre edit_submode km_startsel search_match_endcol p_cwh ru_wid rc_did_emsg e_notset updating_screen where_paste_started undo_off emsg_on_display p_lispwords p_bdir p_bs p_aleph p_rdt e_nesting msg_no_more LineWraps VIsual_mode e_endwhile silent_mode call_func_retstr keep_msg_attr compiled_user p_ru e_endfor need_highlight_changed no_lines_msg end_comment_pending intr_char mb_char2cells curwin p_isf mouse_past_bottom p_acd really_exiting p_ph Insstart restricted highlight_user WantQueryMouse did_emsg_syntax p_iconstring p_tgst p_ek got_int redir_off p_js p_enc msg_didout p_ar highlight_stlnc e_invaddr global_alist e_trailing e_invarg2 prevwin all_cflags redir_vname top_bot_msg msg_scrolled_ign e_for scriptout no_hlsearch p_ea p_ei e_emptybuf msg_scroll e_nolastcmd e_markinval e_nomap e_guarded p_debug info_message p_opfunc p_shm e_loclist ScreenLines2 cedit_key p_cst msg_scrolled p_spr no_abbr p_bex ScreenLinesC p_altkeymap p_tenc p_warn cmdmsg_rl p_csqf lcs_prec redir_fd typebuf_was_filled p_efm p_prompt getexline input_conv e_secure mb_ptr2cells p_udir no_wait_return km_stopsel NameBuff autocmd_fname p_ffs max_alist_id e_zerocount vop_flags lastwin p_bsk term_is_xterm need_cursor_line_redraw p_mousem no_u_sync starting KeyStuffed e_noroom sys_menu cmd_silent has_mbyte e_nobang p_sb e_norange p_mm p_stal p_vfile need_key_msg p_ccv p_mco newline_on_exit default_vimruntime_dir last_changedtick_buf p_mouse wim_flags suppress_errthrow new_last_cmdline did_si e_endtry postponed_split screen_cleared starttime p_isp firstbuf p_paste e_null p_mfd p_fic search_match_lines farsi_text_3 scriptin repeat_cmdline farsi_text_5 saved_cursor cmdwin_result autocmd_match p_tf trylevel p_more mod_mask readonlymode vimvardict empty_option p_dex e_notread p_fkmap e_prev_dir ex_keep_indent p_shcf did_filetype bot_top_msg ex_nesting_level p_exrc edit_submode_highl p_srr e_toomany can_si chartab p_titlestring ScreenLines e_readerrf p_pmfn check_cstack last_changedtick p_smd p_fencs p_verbose cmdmod au_pending_free_win msg_nowait p_lz force_abort p_deco p_tbidi p_csto IObuff read_cmd_fd e_noprevre globvardict p_cm mapped_ctrl_c p_ri debug_tick orig_line_count p_tr p_pex need_maketitle topframe ex_no_reprint KeyTyped vim_tempdir enc_unicode p_tl p_hi e_internal p_pm p_msm e_libcall p_arshape mf_dont_release may_garbage_collect t_colors p_tbi did_outofmem_msg hash_removed lastbuf need_clr_eos compl_interrupted p_sbr ctrl_x_mode p_gd e_modifiable vgetc_busy e_backslash fill_diff p_wd e_while p_hkmapp autocmd_no_leave p_wh mb_bytelen_tab __libc_csu_init e_isadir2 ex_normal_lock p_cmp e_notopen p_wiv p_wb cmdline_star e_patnotf p_fdo p_sol reg_do_extmatch redir_reg e_interr skip_redraw e_nogvim first_tabpage no_mapping need_start_insertmode au_new_curbuf e_wildexpand p_swb Recording curtab clear_cmdline ignored p_header called_emsg p_wig e_invarg netbeansForcedQuit p_sm p_so dy_flags autocmd_busy e_swapclose netbeansReadFile p_wim p_rtp p_wic cmdline_row p_tags did_wait_return call_func_retlist printer_page_num lcs_eol msg_col exec_from_reg e_winheight cmdwin_type p_km p_ss p_fs p_uc p_gp e_toomsbra p_mmd p_su p_mmp p_ead p_fdls enc_dbcs p_mmt p_hid p_terse p_langmap sub_nlines printer_opts highlight_match p_titleold curbuf_lock garbage_collect_at_exit did_ai e_noinstext p_breakat p_fcl p_ari modified_was_set full_screen e_re_damg p_inc p_scs lc_signal e_shellempty p_ttyscroll arg_had_last replace_offset lcs_trail e_failed lcs_nbsp e_curdir lcs_tab2 need_rethrow getsourceline p_stl p_tpm VIsual_active p_sxe p_window vr_lines_changed escape_chars p_cot dollar_vcol fill_stlnc highlight_attr listcmd_busy didset_vim p_sxq mouse_col p_remap mb_ptr2len_len opcount fill_stl ai_col ex_normal_busy p_tal e_nowrtmsg last_cursormoved virtual_op e_quickfix p_titlelen getnextac p_confirm e_bufloaded msg_hist_off emsg_off mb_off2cells p_csverbose p_isi current_exception p_magic e_readonlysbx p_popt must_redraw finish_op p_ep need_fileinfo get_func_line root_menu did_endif e_notcreate p_wmnu p_icon e_longname e_intern2 do_profiling sub_nsubs p_pexpr get_menu_names msg_list p_wop stop_insert_mode p_shq p_ed debug_break_level ttym_flags no_check_timestamps p_ef p_eb diff_context p_mef p_pvh langmap_mapchar postponed_split_tab emsg_skip p_tsr mb_char2bytes restart_edit can_si_back e_argreq e_tagstack p_ic e_invexpr2 p_hls Exec_reg netbeansFireChanges e_write ru_col edit_submode_extra arrow_used e_scroll LineOffset mouse_past_eol e_usingsid ve_flags p_wcm sourcing_lnum Screen_mco autocmd_fname_full p_penc recoverymode p_sps e_invalpat postponed_split_flags sourcing_name edit_submode_pre e_re_corr need_wait_return re_extmatch_in p_gefm no_zero_mapping e_nomatch2 incl re_extmatch_out p_dip p_aw p_secure typebuf e_readonlyvar e_winwidth e_noprev did_check_timestamps p_path p_ur p_im ins_at_eol p_vop global_busy p_ambw u_sync_once aucmd_win p_stmp did_swapwrite_msg ignore_script p_pfn scroll_region keep_msg e_outofmem p_sc e_invcmd cterm_normal_bg_color State p_ut p_is p_dict p_mp use_viminfo p_cedit p_ul RedrawingDisabled Insstart_orig p_mouset e_toocompl p_ssop mb_head_off redo_VIsual_busy emsg_silent e_openerrf p_viminfo p_def fill_fold ctrl_c_interrupts enc_latin1like p_csprg wild_menu_showing keep_help_flag aucmd_win_used p_dg allbuf_lock mode_displayed msg_buf p_hf breakat_flags p_dir getexmodeline cur_tmode e_nopresub redraw_tabline lc_active ex_exitval compl_length searchcmdlen e_noabbr e_nowrtmsg_nobang p_sel p_ta cterm_normal_fg_bold display_tick p_hlg p_cpo e_notmp p_cspc mb_ptr2cells_len spell_redraw_lnum firstwin mouse_dragging diff_foldcolumn p_cdpath VIsual_select compl_cont_status p_ttimeout p_dy enc_utf8 p_hl p_to keep_filetype autocmd_bufnr bangredo swap_exists_did_quit p_pt p_ruf e_patnotf2 ACL_1.0 GLIBC_2.4 GLIBC_2.11 GLIBC_2.7 GLIBC_2.15                                                                                                                                                                                        	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    7         P$   [#                 ii   c#        	         ii   c#                  ii   c#                   	 m#     ii   x#        #     ii   c#      8    <    D    H    P    T    X    \    `    h    l    p    t    x    |                                                                                                                     (    ,    4    8    @    D    L    P    X    \    d    h    p    t    |                                                                                                                 $    (    0    4    <    @    H    L    T    X    `    d    l    p    x    |                                                                                                                  $    ,    0    8    <    D    H    P    T    \    `    h    l    t    x                                                                                            	    	    	    	    	     	    (	    ,	    4	    8	    @	    D	    L	    P	    X	    \	    d	    h	    p	    t	    |	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	    	     
    
    
    
    
    
    $
    (
    0
    4
    <
    @
    H
    L
    T
    X
    `
    d
    l
    p
    x
    |
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
                              $    ,    0    8    <    D    H    P    T    \    `    h    l    t    x                                                                                                                     (    ,    4    8    @    D    L    P    X    \    d    h    p    t    |                                                                                                                 $    (    0    4    <    @    H    L    T    X    `    d    l    p    x    |                                                                                                                  $    ,    0    8    <    D    H    P    T    \    `    h    l    t    x                                                                                                                     (    ,    4    8    @    D    L    P    X    \    d    h    p    t    |                                                                                                                 $    (    0    4    <    @    H    L    T    X    `    d    l    p    x    |                                                                                                                  $    ,    0    8    <    D    H    P    T    \    `    h    l    t    x                                                                                                                     (    ,    4    8    @    D    L    P    T    X    \    `    d    h    l    p    t    x    |                                                                                                                                                                          $    (    ,    0    4    8    <    @    D    H    L    P    T    X    \    `    d    h    l    p    t    x    |                                                                                                                                                                      $    (    ,    0    4    8    <    @    D    H    L    P    T    X    \    `    d    h    l    p    t    x    |                                                                                                                                                                  ,    8    D    P    \    h    t                                                            (    ,    0    4    8    <    @    D    H    L    P    T    X    `    h    p    x                                                                                          (    0    8    @    H    P    X    d    h    l    p    t    x    |                                                                                                    $    ,    4    <    D    L    T    \    d    l    t    |                                                                                    $    ,    4    <    D    L    T    \    d    l    t    |                                                                                    $    ,    4    <    D    L    T    d    h    l    p    t    x    |                                                                         ,    8    D    P    \    `    d    h    p    x                                                                                          (    0    8    @    H    P    X    `    h    p    x                                                                                          (    0    8    @    H    P    X    `    h    p    x                                                                                          (    0    8    @    H    P    X    `    h    p    x                                                                                          (    0    8    @    H    P    X    `    h    p    x                                                                        ,     8     D     P     \     h     t                                                            !    !    !    (!    4!    @!    L!    X!    d!    p!    |!    !    !    !    !    !    !    !    !    !    !     "    "    "    $"    0"    <"    H"    T"    `"    l"    x"    "    "    "    "    "    "    "    "    "    "    "    "    "    "    "    "    #    #    #    #    $#    ,#    4#    <#    D#    L#    T#    \#    d#    l#    t#    |#    #    #    #    #    #    #    #    #    #    #    #    #    #    #    #    #    $    $    $    $    $$    ,$    4$    <$    D$    L$    T$    \$    l$    p$    t$    x$    |$    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    $    %    %     %    ,%    8%    D%    P%    \%    h%    t%    %    %    %    %    %    %    %    %    %    %    %    %    %    %    %     &    &    &    &    &    &    &    &     &    $&    (&    ,&    0&    4&    8&    <&    @&    D&    H&    L&    T&    X&    \&    `&    d&    h&    l&    p&    t&    x&    |&    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &    &     '    '    '    '    $'    0'    <'    H'    T'    `'    l'    x'    '    '    '    '    '    '    '    '    '    '    '    '    '     (    (    (    (    (    (    (    (     (    $(    ((    ,(    0(    4(    8(    <(    @(    D(    H(    L(    P(    T(    X(    \(    `(    d(    h(    l(    p(    t(    x(    |(    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (     )    )    )    )    )    )    )    )     )    $)    ()    4)    <)    D)    L)    T)    \)    d)    l)    t)    |)    )    )    )    )    )    )    )    )    )    )    )    )    )    )    )    )    *    *    *    *    $*    ,*    4*    <*    D*    L*    T*    \*    d*    l*    t*    |*    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *     +    +    +    +    +    +    +    +     +    $+    (+    ,+    0+    4+    8+    <+    @+    D+    H+    L+    P+    T+    X+    \+    `+    d+    h+    l+    p+    t+    x+    |+    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +    +     ,    ,    ,    ,    ,    ,    ,    ,     ,    $,    (,    ,,    0,    4,    8,    <,    @,    D,    H,    L,    P,    T,    X,    \,    `,    d,    h,    l,    p,    t,    x,    |,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,    ,     -    -    -    -    $-    (-    ,-    8-    <-    @-    D-    X-    \-    `-    d-    p-    t-    x-    |-    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    .    .    .    .    .     .    (.    ,.    4.    8.    @.    D.    L.    P.    X.    \.    d.    h.    p.    t.    |.    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .    .     /    /    /    /    /    /    $/    (/    0/    4/    </    @/    H/    L/    T/    X/    `/    d/    l/    p/    x/    |/    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /    /     0    0    0    0    0     0    $0    ,0    00    80    <0    D0    H0    P0    T0    \0    `0    h0    l0    t0    x0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    1    1    1    1    1     1    (1    ,1    41    81    @1    D1    L1    P1    X1    \1    d1    h1    p1    t1    |1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1     2    2    2    2    2    2    $2    (2    02    42    <2    @2    H2    L2    T2    X2    `2    d2    l2    p2    x2    |2    2    2    2    2    2    2    2    2    2    2    2    2    2    2    2    2    2    2    2    2    2     3    3    3    3    3     3    $3    ,3    03    83    <3    D3    H3    P3    T3    \3    `3    h3    l3    t3    x3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    3    4    4    4    4    4     4    (4    ,4    44    84    @4    D4    L4    P4    X4    \4    d4    h4    p4    t4    |4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4    4     5    5    5    5    5    5    $5    (5    05    45    <5    @5    H5    L5    T5    X5    `5    d5    l5    p5    x5    |5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5    5     6    6    6    6    6     6    $6    ,6    06    86    <6    D6    H6    P6    T6    \6    `6    h6    l6    t6    x6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    6    7    7    7    7    7     7    (7    ,7    47    87    @7    D7    L7    P7    X7    \7    d7    h7    p7    t7    |7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7    7     8    8    8    8    8    8    $8    (8    08    48    <8    @8    H8    L8    T8    X8    `8    d8    l8    p8    x8    |8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8    8     9    9    9    9    9     9    $9    ,9    09    89    <9    D9    H9    P9    T9    \9    `9    h9    l9    t9    x9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    9    :    :    :    :    :     :    (:    ,:    4:    8:    @:    D:    L:    P:    X:    \:    d:    h:    p:    t:    |:    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :    :     ;    ;    ;    ;    ;    ;    $;    (;    0;    4;    <;    @;    H;    L;    T;    X;    `;    d;    l;    p;    x;    |;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;    ;     <    <    <    <    <     <    $<    ,<    0<    8<    <<    D<    H<    P<    T<    \<    `<    h<    l<    t<    x<    <    <    <    <    <    <    <    <    <    <    <    <    <    <    <    <    <    <    <    <    <    <    =    =    =    =    =     =    (=    ,=    4=    8=    @=    D=    L=    P=    X=    \=    d=    h=    p=    t=    |=    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =    =     >    >    >    >    >    >    $>    (>    0>    4>    <>    @>    H>    L>    T>    X>    `>    d>    l>    p>    x>    |>    >    >    >    >    >    >    >    >    >    >    >    >    >    >    >    >    >    >    >    >    >     ?    ?    ?    ?    ?     ?    $?    ,?    0?    8?    <?    D?    H?    P?    T?    \?    `?    h?    l?    t?    x?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    @    @    @    @    @     @    (@    ,@    4@    8@    @@    D@    L@    P@    X@    \@    d@    h@    p@    t@    |@    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @     A    A    A    A    A    A    $A    (A    0A    4A    <A    @A    HA    LA    TA    XA    `A    dA    lA    pA    xA    |A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A     B    B    B    B    B     B    $B    ,B    0B    8B    <B    DB    HB    PB    TB    \B    `B    hB    lB    tB    xB    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    B    C    C    C    C    C     C    (C    ,C    4C    8C    @C    DC    LC    PC    XC    \C    dC    hC    pC    tC    |C    C    C    C    C    C    C    C    C    C    C    C    C    C    C    C    C    C    C    C    C    C     D    D    D    D    D    D    $D    (D    0D    4D    <D    @D    HD    LD    TD    XD    `D    dD    lD    pD    xD    |D    D    D    D    D    D    D    D    D    D    D    D    D    D    D    D    D    D    D    D    D    D     E    E    E    E    E     E    $E    ,E    0E    8E    <E    DE    HE    PE    TE    \E    `E    hE    lE    tE    xE    E    E    E    E    E    E    E    E    E    E    E    E    E    E    E    E    E    E    E    E    E    E    F    F    F    F    F     F    (F    ,F    8F    HF    XF    hF    xF    F    F    F    F    F    F    F    G    G    (G    8G    HG    XG    hG    xG    G    G    G    G    G    G    G    G    G    H    H    H    (H    4H    @H    LH    XH    dH    pH    |H    H    H    H    H    H    H    H    H    H    H     I    I    I    $I    0I    <I    HI    TI    `I    lI    xI    I    I    I    I    I    I    I    I    I    I    I    J    J     J    ,J    8J    DJ    PJ    \J    hJ    tJ    J    J    J    J    J    J    J    J    J    J    J    K    K    K    (K    4K    @K    LK    XK    dK    pK    |K    K    K    K    K    K    K    K    K    K    K     L    L    L    $L    0L    <L    HL    TL    `L    lL    xL    L    L    L    L    L    L    L    L    L    L    L    M    M     M    ,M    8M    DM    PM    \M    hM    tM    M    M    M    M    M    M    M    M    M    M    M    N    N    N    (N    4N    @N    LN    XN    dN    pN    |N    N    N    N    N    N    N    N    N    N    N     O    O    O    $O    0O    <O    HO    TO    `O    lO    xO    O    O    O    O    O    O    O    O    O    O    O    P    P     P    ,P    8P    DP    PP    \P    hP    tP    P    T    T    T    T    T    T     U    U    U    U    U    U    U     U    $U    (U    ,U    0U    4U    8U    <U    @U    DU    HU    LU    PU    TU    XU    \U    `U    dU    hU    lU    pU    tU    xU    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U    U     V    V    V    V    V    V    V    V     V    $V    (V    0V    4V    8V    <V    @V    DV    HV    LV    PV    TV    XV    \V    `V    dV    hV    lV    pV    tV    xV    |V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V    V     W    W    W    W    W    W    W    W     W    $W    (W    ,W    0W    4W    8W    <W    @W    DW    HW    LW    PW    TW    XW    \W    `W    dW    hW    lW    pW    tW    xW    |W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W    W     X    X    X    X    X    X    X    X     X    $X    (X    ,X    0X    4X    8X    <X    @X    DX    HX    LX    PX    TX    XX    \X    `X    dX    hX    lX    pX    tX    xX    |X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X    X     Y    Y    Y    Y    Y    Y    Y    Y     Y    $Y    (Y    ,Y    0Y    4Y    8Y    <Y    @Y    DY    HY    LY    PY    TY    XY    \Y    `Y    dY    hY    lY    pY    tY    xY    |Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y    Y     Z    Z    Z    Z    Z    Z    Z    Z     Z    (Z    ,Z    0Z    4Z    8Z    <Z    @Z    DZ    HZ    LZ    PZ    TZ    XZ    \Z    `Z    dZ    hZ    lZ    pZ    tZ    xZ    |Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    Z    [    [    [    [    [    [    [     [    $[    ([    ,[    0[    4[    8[    <[    @[    D[    H[    L[    P[    T[    X[    \[    `[    d[    h[    l[    p[    t[    x[    |[    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [    [     \    \    \    \    \    \    \    \     \    $\    (\    ,\    0\    4\    8\    <\    @\    D\    H\    L\    P\    T\    X\    \\    `\    d\    h\    l\    p\    t\    x\    |\    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \    \     ]    ]    ]    ]    ]    ]    ]    ]     ]    $]    (]    ,]    0]    4]    8]    <]    @]    D]    H]    L]    P]    T]    X]    \]    `]    d]    h]    l]    p]    t]    x]    |]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]    ]     ^    ^    ^    ^    ^    ^    ^    ^     ^    $^    (^    ,^    0^    4^    8^    <^    @^    D^    H^    L^    P^    T^    X^    \^    `^    d^    l^    p^    t^    x^    |^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^     _    _    _    _    _    _    _    _     _    $_    ,_    0_    4_    8_    <_    @_    D_    H_    L_    P_    T_    X_    \_    `_    d_    h_    l_    p_    t_    x_    |_    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    `    Л         X        Ȝ         8    p                P                0    h        ؟        H                (    `        С        @    x                 X        ȣ         8    p                P                0    h        ئ        H                (    `        ب    ܨ                                     t    x    |                                 8    P    h                                                Ī    ̪    Ԫ    ت    ܪ                                                     (    ,    4    @    D    L    P    X    \    d    h    p    t    |                                            ī 