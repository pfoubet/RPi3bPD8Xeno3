  47,    75,    30,    33,
     101,    34,    48,    51,    46,    47,    61,    45,    46,    38,
      42,    48,    53,    71,    77,    78,    92,    93,    94,    95,
      46,     1,    91,    75,    38,    42,    48,    71,    83,    84,
      49,    49,    49,    49,    74,    64,    96,     1,    79,    80,
      81,    82,    35,    46,    99,    95,     1,    38,    77,    35,
      77,    96,    34,    48,    45,    47,     1,    42,    83,    83,
      34,    48,    45,    31,    51,    86,    87,    49,    49,    37,
      47,    49,    49,     1,    79,    94,    49,    49,     1,    79,
      35,    37,    82,    49,    49,    49,    49
};

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		(-2)
#define YYEOF		0

#define YYACCEPT	goto yyacceptlab
#define YYABORT		goto yyabortlab
#define YYERROR		goto yyerrorlab


/* Like YYERROR except do call yyerror.  This remains here temporarily
   to ease the transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  However,
   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
   discussed.  */

#define YYFAIL		goto yyerrlab
#if defined YYFAIL
  /* This is here to suppress warnings from the GCC cpp's
     -Wunused-macros.  Normally we don't worry about that warning, but
     some users do, and we want to make it easy for users to remove
     YYFAIL uses, which will produce warnings from Bison 2.5.  */
#endif

#define YYRECOVERING()  (!!yyerrstatus)

#define YYBACKUP(Token, Value)                                  \
do                                                              \
  if (yychar == YYEMPTY)                                        \
    {                                                           \
      yychar = (Token);                                         \
      yylval = (Value);                                         \
      YYPOPSTACK (yylen);                                       \
      yystate = *yyssp;                                         \
      goto yybackup;                                            \
    }                                                           \
  else                                                          \
    {                                                           \
      yyerror (YY_("syntax error: cannot back up")); \
      YYERROR;							\
    }								\
while (YYID (0))


#define YYTERROR	1
#define YYERRCODE	256


/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
   If N is 0, then set CURRENT to the empty location which ends
   the previous symbol: RHS[0] (always defined).  */

#define YYRHSLOC(Rhs, K) ((Rhs)[K])
#ifndef YYLLOC_DEFAULT
# define YYLLOC_DEFAULT(Current, Rhs, N)				\
    do									\
      if (YYID (N))                                                    \
	{								\
	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
	}								\
      else								\
	{								\
	  (Current).first_line   = (Current).last_line   =		\
	    YYRHSLOC (Rhs, 0).last_line;				\
	  (Current).first_column = (Current).last_column =		\
	    YYRHSLOC (Rhs, 0).last_column;				\
	}								\
    while (YYID (0))
#endif


/* This macro is provided for backward compatibility. */

#ifndef YY_LOCATION_PRINT
# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
#endif


/* YYLEX -- calling `yylex' with the right arguments.  */

#ifdef YYLEX_PARAM
# define YYLEX yylex (YYLEX_PARAM)
#else
# define YYLEX yylex ()
#endif

/* Enable debugging if requested.  */
#if YYDEBUG

# ifndef YYFPRINTF
#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)			\
do {						\
  if (yydebug)					\
    YYFPRINTF Args;				\
} while (YYID (0))

# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
do {									  \
  if (yydebug)								  \
    {									  \
      YYFPRINTF (stderr, "%s ", Title);					  \
      yy_symbol_print (stderr,						  \
		  Type, Value); \
      YYFPRINTF (stderr, "\n");						  \
    }									  \
} while (YYID (0))


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

/*ARGSUSED*/
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
#else
static void
yy_symbol_value_print (yyoutput, yytype, yyvaluep)
    FILE *yyoutput;
    int yytype;
    YYSTYPE const * const yyvaluep;
#endif
{
  FILE *yyo = yyoutput;
  YYUSE (yyo);
  if (!yyvaluep)
    return;
# ifdef YYPRINT
  if (yytype < YYNTOKENS)
    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
# else
  YYUSE (yyoutput);
# endif
  switch (yytype)
    {
      default:
	break;
    }
}


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
#else
static void
yy_symbol_print (yyoutput, yytype, yyvaluep)
    FILE *yyoutput;
    int yytype;
    YYSTYPE const * const yyvaluep;
#endif
{
  if (yytype < YYNTOKENS)
    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
  else
    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);

  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
  YYFPRINTF (yyoutput, ")");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
#else
static void
yy_stack_print (yybottom, yytop)
    yytype_int16 *yybottom;
    yytype_int16 *yytop;
#endif
{
  YYFPRINTF (stderr, "Stack now");
  for (; yybottom <= yytop; yybottom++)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, " %d", yybot);
    }
  YYFPRINTF (stderr, "\n");
}

# define YY_STACK_PRINT(Bottom, Top)				\
do {								\
  if (yydebug)							\
    yy_stack_print ((Bottom), (Top));				\
} while (YYID (0))


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
#else
static void
yy_reduce_print (yyvsp, yyrule)
    YYSTYPE *yyvsp;
    int yyrule;
#endif
{
  int yynrhs = yyr2[yyrule];
  int yyi;
  unsigned long int yylno = yyrline[yyrule];
  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
	     yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi++)
    {
      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
		       &(yyvsp[(yyi + 1) - (yynrhs)])
		       		       );
      YYFPRINTF (stderr, "\n");
    }
}

# define YY_REDUCE_PRINT(Rule)		\
do {					\
  if (yydebug)				\
    yy_reduce_print (yyvsp, Rule); \
} while (YYID (0))

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef	YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif


#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined __GLIBC__ && defined _STRING_H
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static YYSIZE_T
yystrlen (const char *yystr)
#else
static YYSIZE_T
yystrlen (yystr)
    const char *yystr;
#endif
{
  YYSIZE_T yylen;
  for (yylen = 0; yystr[yylen]; yylen++)
    continue;
  return yylen;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static char *
yystpcpy (char *yydest, const char *yysrc)
#else
static char *
yystpcpy (yydest, yysrc)
    char *yydest;
    const char *yysrc;
#endif
{
  char *yyd = yydest;
  const char *yys = yysrc;

  while ((*yyd++ = *yys++) != '\0')
    continue;

  return yyd - 1;
}
#  endif
# endif

# ifndef yytnamerr
/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
   quotes and backslashes, so that it's suitable for yyerror.  The
   heuristic is that double-quoting is unnecessary unless the string
   contains an apostrophe, a comma, or backslash (other than
   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
   null, do not copy; instead, return the length of what the result
   would have been.  */
static YYSIZE_T
yytnamerr (char *yyres, const char *yystr)
{
  if (*yystr == '"')
    {
      YYSIZE_T yyn = 0;
      char const *yyp = yystr;

      for (;;)
	switch (*++yyp)
	  {
	  case '\'':
	  case ',':
	    goto do_not_strip_quotes;

	  case '\\':
	    if (*++yyp != '\\')
	      goto do_not_strip_quotes;
	    /* Fall through.  */
	  default:
	    if (yyres)
	      yyres[yyn] = *yyp;
	    yyn++;
	    break;

	  case '"':
	    if (yyres)
	      yyres[yyn] = '\0';
	    return yyn;
	  }
    do_not_strip_quotes: ;
    }

  if (! yyres)
    return yystrlen (yystr);

  return yystpcpy (yyres, yystr) - yyres;
}
# endif

/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
   about the unexpected token YYTOKEN for the state stack whose top is
   YYSSP.

   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
   not large enough to hold the message.  In that case, also set
   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
   required number of bytes is too large to store.  */
static int
yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
                yytype_int16 *yyssp, int yytoken)
{
  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);
  YYSIZE_T yysize = yysize0;
  YYSIZE_T yysize1;
  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
  /* Internationalized format string. */
  const char *yyformat = YY_NULL;
  /* Arguments of yyformat. */
  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
  /* Number of reported tokens (one for the "unexpected", one per
     "expected"). */
  int yycount = 0;

  /* There are many possibilities here to consider:
     - Assume YYFAIL is not used.  It's too flawed to consider.  See
       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
       for details.  YYERROR is fine as it does not invoke this
       function.
     - If this state is a consistent state with a default action, then
       the only way this function was invoked is if the default action
       is an error action.  In that case, don't check for expected
       tokens because there are none.
     - The only way there can be no lookahead present (in yychar) is if
       this state is a consistent state with a default action.  Thus,
       detecting the absence of a lookahead is sufficient to determine
       that there is no unexpected or expected token to report.  In that
       case, just report a simple "syntax error".
     - Don't assume there isn't a lookahead just because this state is a
       consistent state with a default action.  There might have been a
       previous inconsistent state, consistent state with a non-default
       action, or user semantic action that manipulated yychar.
     - Of course, the expected token list depends on states to have
       correct lookahead information, and it depends on the parser not
       to perform extra reductions after fetching a lookahead from the
       scanner and before detecting a syntax error.  Thus, state merging
       (from LALR or IELR) and default reductions corrupt the expected
       token list.  However, the list is correct for canonical LR with
       one exception: it will still contain any token that will not be
       accepted due to an error action in a later state.
  */
  if (yytoken != YYEMPTY)
    {
      int yyn = yypact[*yyssp];
      yyarg[yycount++] = yytname[yytoken];
      if (!yypact_value_is_default (yyn))
        {
          /* Start YYX at -YYN if negative to avoid negative indexes in
             YYCHECK.  In other words, skip the first -YYN actions for
             this state because they are default actions.  */
          int yyxbegin = yyn < 0 ? -yyn : 0;
          /* Stay within bounds of both yycheck and yytname.  */
          int yychecklim = YYLAST - yyn + 1;
          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
          int yyx;

          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
                && !yytable_value_is_error (yytable[yyx + yyn]))
              {
                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
                  {
                    yycount = 1;
                    yysize = yysize0;
                    break;
                  }
                yyarg[yycount++] = yytname[yyx];
                yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);
                if (! (yysize <= yysize1
                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
                  return 2;
                yysize = yysize1;
              }
        }
    }

  switch (yycount)
    {
# define YYCASE_(N, S)                      \
      case N:                               \
        yyformat = S;                       \
      break
      YYCASE_(0, YY_("syntax error"));
      YYCASE_(1, YY_("syntax error, unexpected %s"));
      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
# undef YYCASE_
    }

  yysize1 = yysize + yystrlen (yyformat);
  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
    return 2;
  yysize = yysize1;

  if (*yymsg_alloc < yysize)
    {
      *yymsg_alloc = 2 * yysize;
      if (! (yysize <= *yymsg_alloc
             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
      return 1;
    }

  /* Avoid sprintf, as that infringes on the user's name space.
     Don't have undefined behavior even if the translation
     produced a string with the wrong number of "%s"s.  */
  {
    char *yyp = *yymsg;
    int yyi = 0;
    while ((*yyp = *yyformat) != '\0')
      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        {
          yyp += yytnamerr (yyp, yyarg[yyi++]);
          yyformat += 2;
        }
      else
        {
          yyp++;
          yyformat++;
        }
  }
  return 0;
}
#endif /* YYERROR_VERBOSE */

/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/

/*ARGSUSED*/
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
#else
static void
yydestruct (yymsg, yytype, yyvaluep)
    const char *yymsg;
    int yytype;
    YYSTYPE *yyvaluep;
#endif
{
  YYUSE (yyvaluep);

  if (!yymsg)
    yymsg = "Deleting";
  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);

  switch (yytype)
    {

      default:
	break;
    }
}


/* Prevent warnings from -Wmissing-prototypes.  */
#ifdef YYPARSE_PARAM
#if defined __STDC__ || defined __cplusplus
int yyparse (void *YYPARSE_PARAM);
#else
int yyparse ();
#endif
#else /* ! YYPARSE_PARAM */
#if defined __STDC__ || defined __cplusplus
int yyparse (void);
#else
int yyparse ();
#endif
#endif /* ! YYPARSE_PARAM */


/* The lookahead symbol.  */
int yychar;

/* The semantic value of the lookahead symbol.  */
YYSTYPE yylval;

/* Number of syntax errors so far.  */
int yynerrs;


/*----------.
| yyparse.  |
`----------*/

#ifdef YYPARSE_PARAM
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
int
yyparse (void *YYPARSE_PARAM)
#else
int
yyparse (YYPARSE_PARAM)
    void *YYPARSE_PARAM;
#endif
#else /* ! YYPARSE_PARAM */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
int
yyparse (void)
#else
int
yyparse ()

#endif
#endif
{
    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       `yyss': related to states.
       `yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yytoken = 0;
  yyss = yyssa;
  yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, "Starting parse\n"));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */
  yyssp = yyss;
  yyvsp = yyvs;

  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
	/* Give user a chance to reallocate the stack.  Use copies of
	   these so that the &'s don't force the real ones into
	   memory.  */
	YYSTYPE *yyvs1 = yyvs;
	yytype_int16 *yyss1 = yyss;

	/* Each stack pointer address is followed by the size of the
	   data in use in that stack, in bytes.  This used to be a
	   conditional around just the two extra args, but that might
	   be undefined if yyoverflow is a macro.  */
	yyoverflow (YY_("memory exhausted"),
		    &yyss1, yysize * sizeof (*yyssp),
		    &yyvs1, yysize * sizeof (*yyvsp),
		    &yystacksize);

	yyss = yyss1;
	yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
	goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
	yystacksize = YYMAXDEPTH;

      {
	yytype_int16 *yyss1 = yyss;
	union yyalloc *yyptr =
	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
	if (! yyptr)
	  goto yyexhaustedlab;
	YYSTACK_RELOCATE (yyss_alloc, yyss);
	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
	if (yyss1 != yyssa)
	  YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
		  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
	YYABORT;
    }

  YYDPRINTF ((stderr, "Entering state %d\n", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, "Reading a token: "));
      yychar = YYLEX;
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, "Now at end of input.\n"));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  *++yyvsp = yylval;

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     `$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 4:

    { is_typedef = 0; is_extern = 0; current_name = NULL; decl_spec = NULL; }
    break;

  case 5:

    { free_list(*(yyvsp[(2) - (2)]), NULL); *(yyvsp[(2) - (2)]) = NULL; }
    break;

  case 6:

    { is_typedef = 1; }
    break;

  case 7:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 8:

    { is_typedef = 1; }
    break;

  case 9:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 14:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 15:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 16:

    { if (current_name) {
		    struct string_list *decl = (*(yyvsp[(3) - (3)]))->next;
		    (*(yyvsp[(3) - (3)]))->next = NULL;
		    add_symbol(current_name,
			       is_typedef ? SYM_TYPEDEF : SYM_NORMAL,
			       decl, is_extern);
		    current_name = NULL;
		  }
		  (yyval) = (yyvsp[(3) - (3)]);
		}
    break;

  case 17:

    { (yyval) = NULL; }
    break;

  case 19:

    { struct string_list *decl = *(yyvsp[(1) - (1)]);
		  *(yyvsp[(1) - (1)]) = NULL;
		  add_symbol(current_name,
			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
		  current_name = NULL;
		  (yyval) = (yyvsp[(1) - (1)]);
		}
    break;

  case 20:

    { struct string_list *decl = *(yyvsp[(3) - (3)]);
		  *(yyvsp[(3) - (3)]) = NULL;
		  free_list(*(yyvsp[(2) - (3)]), NULL);
		  *(yyvsp[(2) - (3)]) = decl_spec;
		  add_symbol(current_name,
			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
		  current_name = NULL;
		  (yyval) = (yyvsp[(3) - (3)]);
		}
    break;

  case 21:

    { (yyval) = (yyvsp[(4) - (4)]) ? (yyvsp[(4) - (4)]) : (yyvsp[(3) - (4)]) ? (yyvsp[(3) - (4)]) : (yyvsp[(2) - (4)]) ? (yyvsp[(2) - (4)]) : (yyvsp[(1) - (4)]); }
    break;

  case 22:

    { decl_spec = NULL; }
    break;

  case 24:

    { decl_spec = *(yyvsp[(1) - (1)]); }
    break;

  case 25:

    { decl_spec = *(yyvsp[(2) - (2)]); }
    break;

  case 26:

    { /* Version 2 checksumming ignores storage class, as that
		     is really irrelevant to the linkage.  */
		  remove_node((yyvsp[(1) - (1)]));
		  (yyval) = (yyvsp[(1) - (1)]);
		}
    break;

  case 31:

    { is_extern = 1; (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 32:

    { is_extern = 0; (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 37:

    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_STRUCT; (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 38:

    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_UNION; (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 39:

    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_ENUM; (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 40:

    { record_compound((yyvsp[(1) - (3)]), (yyvsp[(2) - (3)]), (yyvsp[(3) - (3)]), SYM_STRUCT); (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 41:

    { record_compound((yyvsp[(1) - (3)]), (yyvsp[(2) - (3)]), (yyvsp[(3) - (3)]), SYM_UNION); (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 42:

    { record_compound((yyvsp[(1) - (3)]), (yyvsp[(2) - (3)]), (yyvsp[(3) - (3)]), SYM_ENUM); (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 43:

    { add_symbol(NULL, SYM_ENUM, NULL, 0); (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 44:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 45:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 56:

    { (*(yyvsp[(1) - (1)]))->tag = SYM_TYPEDEF; (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 57:

    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); }
    break;

  case 58:

    { (yyval) = NULL; }
    break;

  case 61:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 65:

    { /* restrict has no effect in prototypes so ignore it */
		  remove_node((yyvsp[(1) - (1)]));
		  (yyval) = (yyvsp[(1) - (1)]);
		}
    break;

  case 66:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 68:

    { if (current_name != NULL) {
		    error_with_pos("unexpected second declaration name");
		    YYERROR;
		  } else {
		    current_name = (*(yyvsp[(1) - (1)]))->string;
		    (yyval) = (yyvsp[(1) - (1)]);
		  }
		}
    break;

  case 69:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 70:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 71:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 72:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 73:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 74:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 78:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 79:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 80:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 81:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 82:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 83:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 85:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 86:

    { (yyval) = NULL; }
    break;

  case 89:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 90:

    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); }
    break;

  case 91:

    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); }
    break;

  case 93:

    { (yyval) = NULL; }
    break;

  case 94:

    { /* For version 2 checksums, we don't want to remember
		     private parameter names.  */
		  remove_node((yyvsp[(1) - (1)]));
		  (yyval) = (yyvsp[(1) - (1)]);
		}
    break;

  case 95:

    { remove_node((yyvsp[(1) - (1)]));
		  (yyval) = (yyvsp[(1) - (1)]);
		}
    break;

  case 96:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 97:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 98:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 99:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 100:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 101:

    { struct string_list *decl = *(yyvsp[(2) - (3)]);
		  *(yyvsp[(2) - (3)]) = NULL;
		  add_symbol(current_name, SYM_NORMAL, decl, is_extern);
		  (yyval) = (yyvsp[(3) - (3)]);
		}
    break;

  case 102:

    { (yyval) = NULL; }
    break;

  case 104:

    { remove_list((yyvsp[(2) - (2)]), &(*(yyvsp[(1) - (2)]))->next); (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 105:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 106:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 107:

    { (yyval) = NULL; }
    break;

  case 110:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 111:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 112:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 113:

    { (yyval) = NULL; }
    break;

  case 116:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 117:

    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); }
    break;

  case 118:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 120:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 121:

    { (yyval) = NULL; }
    break;

  case 123:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 124:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 127:

    {
			const char *name = strdup((*(yyvsp[(1) - (1)]))->string);
			add_symbol(name, SYM_ENUM_CONST, NULL, 0);
		}
    break;

  case 128:

    {
			const char *name = strdup((*(yyvsp[(1) - (3)]))->string);
			struct string_list *expr = copy_list_range(*(yyvsp[(3) - (3)]), *(yyvsp[(2) - (3)]));
			add_symbol(name, SYM_ENUM_CONST, expr, 0);
		}
    break;

  case 129:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 130:

    { (yyval) = NULL; }
    break;

  case 132:

    { export_symbol((*(yyvsp[(3) - (5)]))->string); (yyval) = (yyvsp[(5) - (5)]); }
    break;



      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now `shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*------------------------------------.
| yyerrlab -- here on detecting error |
`------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (YY_("syntax error"));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_("syntax error");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
	 error, discard it.  */

      if (yychar <= YYEOF)
	{
	  /* Return failure if at end of input.  */
	  if (yychar == YYEOF)
	    YYABORT;
	}
      else
	{
	  yydestruct ("Error: discarding",
		      yytoken, &yylval);
	  yychar = YYEMPTY;
	}
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule which action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;	/* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
	{
	  yyn += YYTERROR;
	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
	    {
	      yyn = yytable[yyn];
	      if (0 < yyn)
		break;
	    }
	}

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
	YYABORT;


      yydestruct ("Error: popping",
		  yystos[yystate], yyvsp);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  *++yyvsp = yylval;


  /* Shift the error token.  */
  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (YY_("memory exhausted"));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ("Cleanup: discarding lookahead",
                  yytoken, &yylval);
    }
  /* Do not reclaim the symbols of the rule which action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ("Cleanup: popping",
		  yystos[*yyssp], yyvsp);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#endif
  /* Make sure YYID is used.  */
  return YYID (yyresult);
}





static void
yyerror(const char *e)
{
  error_with_pos("%s", e);
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /* A Bison parser, made by GNU Bison 2.5.1.  */

/* Bison implementation for Yacc-like parsers in C
   
      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
   
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.
   
   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */

/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted "INFRINGES ON
   USER NAME SPACE" below.  */

/* Identify Bison output.  */
#define YYBISON 1

/* Bison version.  */
#define YYBISON_VERSION "2.5.1"

/* Skeleton name.  */
#define YYSKELETON_NAME "yacc.c"

/* Pure parsers.  */
#define YYPURE 0

/* Push parsers.  */
#define YYPUSH 0

/* Pull parsers.  */
#define YYPULL 1

/* Using locations.  */
#define YYLSP_NEEDED 0



/* Copy the first part of user declarations.  */



#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "genksyms.h"

static int is_typedef;
static int is_extern;
static char *current_name;
static struct string_list *decl_spec;

static void yyerror(const char *);

static inline void
remove_node(struct string_list **p)
{
  struct string_list *node = *p;
  *p = node->next;
  free_node(node);
}

static inline void
remove_list(struct string_list **pb, struct string_list **pe)
{
  struct string_list *b = *pb, *e = *pe;
  *pb = e;
  free_list(b, e);
}

/* Record definition of a struct/union/enum */
static void record_compound(struct string_list **keyw,
		       struct string_list **ident,
		       struct string_list **body,
		       enum symbol_type type)
{
	struct string_list *b = *body, *i = *ident, *r;

	if (i->in_source_file) {
		remove_node(keyw);
		(*ident)->tag = type;
		remove_list(body, ident);
		return;
	}
	r = copy_node(i); r->tag = type;
	r->next = (*keyw)->next; *body = r; (*keyw)->next = NULL;
	add_symbol(i->string, type, b, is_extern);
}




# ifndef YY_NULL
#  if defined __cplusplus && 201103L <= __cplusplus
#   define YY_NULL nullptr
#  else
#   define YY_NULL 0
#  endif
# endif

/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 1
#endif

/* Enabling verbose error messages.  */
#ifdef YYERROR_VERBOSE
# undef YYERROR_VERBOSE
# define YYERROR_VERBOSE 1
#else
# define YYERROR_VERBOSE 0
#endif

/* Enabling the token table.  */
#ifndef YYTOKEN_TABLE
# define YYTOKEN_TABLE 0
#endif


/* Tokens.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
   /* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */
   enum yytokentype {
     ASM_KEYW = 258,
     ATTRIBUTE_KEYW = 259,
     AUTO_KEYW = 260,
     BOOL_KEYW = 261,
     CHAR_KEYW = 262,
     CONST_KEYW = 263,
     DOUBLE_KEYW = 264,
     ENUM_KEYW = 265,
     EXTERN_KEYW = 266,
     EXTENSION_KEYW = 267,
     FLOAT_KEYW = 268,
     INLINE_KEYW = 269,
     INT_KEYW = 270,
     LONG_KEYW = 271,
     REGISTER_KEYW = 272,
     RESTRICT_KEYW = 273,
     SHORT_KEYW = 274,
     SIGNED_KEYW = 275,
     STATIC_KEYW = 276,
     STRUCT_KEYW = 277,
     TYPEDEF_KEYW = 278,
     UNION_KEYW = 279,
     UNSIGNED_KEYW = 280,
     VOID_KEYW = 281,
     VOLATILE_KEYW = 282,
     TYPEOF_KEYW = 283,
     EXPORT_SYMBOL_KEYW = 284,
     ASM_PHRASE = 285,
     ATTRIBUTE_PHRASE = 286,
     TYPEOF_PHRASE = 287,
     BRACE_PHRASE = 288,
     BRACKET_PHRASE = 289,
     EXPRESSION_PHRASE = 290,
     CHAR = 291,
     DOTS = 292,
     IDENT = 293,
     INT = 294,
     REAL = 295,
     STRING = 296,
     TYPE = 297,
     OTHER = 298,
     FILENAME = 299
   };
#endif



#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
#endif


/* Copy the second part of user declarations.  */



#ifdef short
# undef short
#endif

#ifdef YYTYPE_UINT8
typedef YYTYPE_UINT8 yytype_uint8;
#else
typedef unsigned char yytype_uint8;
#endif

#ifdef YYTYPE_INT8
typedef YYTYPE_INT8 yytype_int8;
#elif (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
typedef signed char yytype_int8;
#else
typedef short int yytype_int8;
#endif

#ifdef YYTYPE_UINT16
typedef YYTYPE_UINT16 yytype_uint16;
#else
typedef unsigned short int yytype_uint16;
#endif

#ifdef YYTYPE_INT16
typedef YYTYPE_INT16 yytype_int16;
#else
typedef short int yytype_int16;
#endif

#ifndef YYSIZE_T
# ifdef __SIZE_TYPE__
#  define YYSIZE_T __SIZE_TYPE__
# elif defined size_t
#  define YYSIZE_T size_t
# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  define YYSIZE_T size_t
# else
#  define YYSIZE_T unsigned int
# endif
#endif

#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)

#ifndef YY_
# if defined YYENABLE_NLS && YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
#   define YY_(msgid) dgettext ("bison-runtime", msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(msgid) msgid
# endif
#endif

/* Suppress unused-variable warnings by "using" E.  */
#if ! defined lint || defined __GNUC__
# define YYUSE(e) ((void) (e))
#else
# define YYUSE(e) /* empty */
#endif

/* Identity function, used to suppress warnings about constant conditions.  */
#ifndef lint
# define YYID(n) (n)
#else
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static int
YYID (int yyi)
#else
static int
YYID (yyi)
    int yyi;
#endif
{
  return yyi;
}
#endif

#if ! defined yyoverflow || YYERROR_VERBOSE

/* The parser invokes alloca or malloc; define the necessary symbols.  */

# ifdef YYSTACK_USE_ALLOCA
#  if YYSTACK_USE_ALLOCA
#   ifdef __GNUC__
#    define YYSTACK_ALLOC __builtin_alloca
#   elif defined __BUILTIN_VA_ARG_INCR
#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
#   elif defined _AIX
#    define YYSTACK_ALLOC __alloca
#   elif defined _MSC_VER
#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
#    define alloca _alloca
#   else
#    define YYSTACK_ALLOC alloca
#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
#     ifndef EXIT_SUCCESS
#      define EXIT_SUCCESS 0
#     endif
#    endif
#   endif
#  endif
# endif

# ifdef YYSTACK_ALLOC
   /* Pacify GCC's `empty if-body' warning.  */
#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
#  ifndef YYSTACK_ALLOC_MAXIMUM
    /* The OS might guarantee only one guard page at the bottom of the stack,
       and a page size can be as small as 4096 bytes.  So we cannot safely
       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
       to allow for a few compiler-allocated temporary stack slots.  */
#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
#  endif
# else
#  define YYSTACK_ALLOC YYMALLOC
#  define YYSTACK_FREE YYFREE
#  ifndef YYSTACK_ALLOC_MAXIMUM
#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
#  endif
#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
       && ! ((defined YYMALLOC || defined malloc) \
	     && (defined YYFREE || defined free)))
#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
#   ifndef EXIT_SUCCESS
#    define EXIT_SUCCESS 0
#   endif
#  endif
#  ifndef YYMALLOC
#   define YYMALLOC malloc
#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
#  ifndef YYFREE
#   define YYFREE free
#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
void free (void *); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
# endif
#endif /* ! defined yyoverflow || YYERROR_VERBOSE */


#if (! defined yyoverflow \
     && (! defined __cplusplus \
	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))

/* A type that is properly aligned for any stack member.  */
union yyalloc
{
  yytype_int16 yyss_alloc;
  YYSTYPE yyvs_alloc;
};

/* The size of the maximum gap between one aligned stack and the next.  */
# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)

/* The size of an array large to enough to hold all stacks, each with
   N elements.  */
# define YYSTACK_BYTES(N) \
     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
      + YYSTACK_GAP_MAXIMUM)

# define YYCOPY_NEEDED 1

/* Relocate STACK from its old location to the new one.  The
   local variables YYSIZE and YYSTACKSIZE give the old and new number of
   elements in the stack, and YYPTR gives the new location of the
   stack.  Advance YYPTR to a properly aligned location for the next
   stack.  */
# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
    do									\
      {									\
	YYSIZE_T yynewbytes;						\
	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
	Stack = &yyptr->Stack_alloc;					\
	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
	yyptr += yynewbytes / sizeof (*yyptr);				\
      }									\
    while (YYID (0))

#endif

#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
/* Copy COUNT objects from SRC to DST.  The source and destination do
   not overlap.  */
# ifndef YYCOPY
#  if defined __GNUC__ && 1 < __GNUC__
#   define YYCOPY(Dst, Src, Count) \
      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
#  else
#   define YYCOPY(Dst, Src, Count)              \
      do                                        \
        {                                       \
          YYSIZE_T yyi;                         \
          for (yyi = 0; yyi < (Count); yyi++)   \
            (Dst)[yyi] = (Src)[yyi];            \
        }                                       \
      while (YYID (0))
#  endif
# endif
#endif /* !YYCOPY_NEEDED */

/* YYFINAL -- State number of the termination state.  */
#define YYFINAL  4
/* YYLAST -- Last index in YYTABLE.  */
#define YYLAST   514

/* YYNTOKENS -- Number of terminals.  */
#define YYNTOKENS  54
/* YYNNTS -- Number of nonterminals.  */
#define YYNNTS  49
/* YYNRULES -- Number of rules.  */
#define YYNRULES  132
/* YYNRULES -- Number of states.  */
#define YYNSTATES  187

/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
#define YYUNDEFTOK  2
#define YYMAXUTOK   299

#define YYTRANSLATE(YYX)						\
  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)

/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
static const yytype_uint8 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      48,    49,    50,     2,    47,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,    53,    45,
       2,    51,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,    52,     2,    46,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44
};

#if YYDEBUG
/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
   YYRHS.  */
static const yytype_uint16 yyprhs[] =
{
       0,     0,     3,     5,     8,     9,    12,    13,    18,    19,
      23,    25,    27,    29,    31,    34,    37,    41,    42,    44,
      46,    50,    55,    56,    58,    60,    63,    65,    67,    69,
      71,    73,    75,    77,    79,    81,    86,    88,    91,    94,
      97,   101,   105,   109,   112,   115,   118,   120,   122,   124,
     126,   128,   130,   132,   134,   136,   138,   140,   143,   144,
     146,   148,   151,   153,   155,   157,   159,   162,   164,   166,
     171,   176,   179,   183,   187,   190,   192,   194,   196,   201,
     206,   209,   213,   217,   220,   222,   226,   227,   229,   231,
     235,   238,   241,   243,   244,   246,   248,   253,   258,   261,
     265,   269,   273,   274,   276,   279,   283,   287,   288,   290,
     292,   295,   299,   302,   303,   305,   307,   311,   314,   317,
     319,   322,   323,   326,   330,   335,   337,   341,   343,   347,
     350,   351,   353
};

/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
static const yytype_int8 yyrhs[] =
{
      55,     0,    -1,    56,    -1,    55,    56,    -1,    -1,    57,
      58,    -1,    -1,    12,    23,    59,    61,    -1,    -1,    23,
      60,    61,    -1,    61,    -1,    85,    -1,   100,    -1,   102,
      -1,     1,    45,    -1,     1,    46,    -1,    65,    62,    45,
      -1,    -1,    63,    -1,    64,    -1,    63,    47,    64,    -1,
      75,   101,    96,    86,    -1,    -1,    66,    -1,    67,    -1,
      66,    67,    -1,    68,    -1,    69,    -1,     5,    -1,    17,
      -1,    21,    -1,    11,    -1,    14,    -1,    70,    -1,    74,
      -1,    28,    48,    82,    49,    -1,    32,    -1,    22,    38,
      -1,    24,    38,    -1,    10,    38,    -1,    22,    38,    88,
      -1,    24,    38,    88,    -1,    10,    38,    97,    -1,    10,
      97,    -1,    22,    88,    -1,    24,    88,    -1,     7,    -1,
      19,    -1,    15,    -1,    16,    -1,    20,    -1,    25,    -1,
      13,    -1,     9,    -1,    26,    -1,     6,    -1,    42,    -1,
      50,    72,    -1,    -1,    73,    -1,    74,    -1,    73,    74,
      -1,     8,    -1,    27,    -1,    31,    -1,    18,    -1,    71,
      75,    -1,    76,    -1,    38,    -1,    76,    48,    79,    49,
      -1,    76,    48,     1,    49,    -1,    76,    34,    -1,    48,
      75,    49,    -1,    48,     1,    49,    -1,    71,    77,    -1,
      78,    -1,    38,    -1,    42,    -1,    78,    48,    79,    49,
      -1,    78,    48,     1,    49,    -1,    78,    34,    -1,    48,
      77,    49,    -1,    48,     1,    49,    -1,    80,    37,    -1,
      80,    -1,    81,    47,    37,    -1,    -1,    81,    -1,    82,
      -1,    81,    47,    82,    -1,    66,    83,    -1,    71,    83,
      -1,    84,    -1,    -1,    38,    -1,    42,    -1,    84,    48,
      79,    49,    -1,    84,    48,     1,    49,    -1,    84,    34,
      -1,    48,    83,    49,    -1,    48,     1,    49,    -1,    65,
      75,    33,    -1,    -1,    87,    -1,    51,    35,    -1,    52,
      89,    46,    -1,    52,     1,    46,    -1,    -1,    90,    -1,
      91,    -1,    90,    91,    -1,    65,    92,    45,    -1,     1,
      45,    -1,    -1,    93,    -1,    94,    -1,    93,    47,    94,
      -1,    77,    96,    -1,    38,    95,    -1,    95,    -1,    53,
      35,    -1,    -1,    96,    31,    -1,    52,    98,    46,    -1,
      52,    98,    47,    46,    -1,    99,    -1,    98,    47,    99,
      -1,    38,    -1,    38,    51,    35,    -1,    30,    45,    -1,
      -1,    30,    -1,    29,    48,    38,    49,    45,    -1
};

/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
static const yytype_uint16 yyrline[] =
{
       0,   124,   124,   125,   129,   129,   135,   135,   137,   137,
     139,   140,   141,   142,   143,   144,   148,   162,   163,   167,
     175,   188,   194,   195,   199,   200,   204,   210,   214,   215,
     216,   217,   218,   222,   223,   224,   225,   229,   231,   233,
     237,   239,   241,   246,   249,   250,   254,   255,   256,   257,
     258,   259,   260,   261,   262,   263,   264,   268,   273,   274,
     278,   279,   283,   283,   283,   284,   292,   293,   297,   306,
     308,   310,   312,   314,   321,   322,   326,   327,   328,   330,
     332,   334,   336,   341,   342,   343,   347,   348,   352,   353,
     358,   363,   365,   369,   370,   378,   382,   384,   386,   388,
     390,   395,   404,   405,   410,   415,   416,   420,   421,   425,
     426,   430,   432,   437,   438,   442,   443,   447,   448,   449,
     453,   457,   458,   462,   463,   467,   468,   471,   476,   484,
     488,   489,   493
};
#endif

#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
static const char *const yytname[] =
{
  "$end", "error", "$undefined", "ASM_KEYW", "ATTRIBUTE_KEYW",
  "AUTO_KEYW", "BOOL_KEYW", "CHAR_KEYW", "CONST_KEYW", "DOUBLE_KEYW",
  "ENUM_KEYW", "EXTERN_KEYW", "EXTENSION_KEYW", "FLOAT_KEYW",
  "INLINE_KEYW", "INT_KEYW", "LONG_KEYW", "REGISTER_KEYW", "RESTRICT_KEYW",
  "SHORT_KEYW", "SIGNED_KEYW", "STATIC_KEYW", "STRUCT_KEYW",
  "TYPEDEF_KEYW", "UNION_KEYW", "UNSIGNED_KEYW", "VOID_KEYW",
  "VOLATILE_KEYW", "TYPEOF_KEYW", "EXPORT_SYMBOL_KEYW", "ASM_PHRASE",
  "ATTRIBUTE_PHRASE", "TYPEOF_PHRASE", "BRACE_PHRASE", "BRACKET_PHRASE",
  "EXPRESSION_PHRASE", "CHAR", "DOTS", "IDENT", "INT", "REAL", "STRING",
  "TYPE", "OTHER", "FILENAME", "';'", "'}'", "','", "'('", "')'", "'*'",
  "'='", "'{'", "':'", "$accept", "declaration_seq", "declaration", "$@1",
  "declaration1", "$@2", "$@3", "simple_declaration",
  "init_declarator_list_opt", "init_declarator_list", "init_declarator",
  "decl_specifier_seq_opt", "decl_specifier_seq", "decl_specifier",
  "storage_class_specifier", "type_specifier", "simple_type_specifier",
  "ptr_operator", "cvar_qualifier_seq_opt", "cvar_qualifier_seq",
  "cvar_qualifier", "declarator", "direct_declarator", "nested_declarator",
  "direct_nested_declarator", "parameter_declaration_clause",
  "parameter_declaration_list_opt", "parameter_declaration_list",
  "parameter_declaration", "m_abstract_declarator",
  "direct_m_abstract_declarator", "function_definition", "initializer_opt",
  "initializer", "class_body", "member_specification_opt",
  "member_specification", "member_declaration",
  "member_declarator_list_opt", "member_declarator_list",
  "member_declarator", "member_bitfield_declarator", "attribute_opt",
  "enum_body", "enumerator_list", "enumerator", "asm_definition",
  "asm_phrase_opt", "export_definition", YY_NULL
};
#endif

# ifdef YYPRINT
/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
   token YYLEX-NUM.  */
static const yytype_uint16 yytoknum[] =
{
       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
     295,   296,   297,   298,   299,    59,   125,    44,    40,    41,
      42,    61,   123,    58
};
# endif

/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
static const yytype_uint8 yyr1[] =
{
       0,    54,    55,    55,    57,    56,    59,    58,    60,    58,
      58,    58,    58,    58,    58,    58,    61,    62,    62,    63,
      63,    64,    65,    65,    66,    66,    67,    67,    68,    68,
      68,    68,    68,    69,    69,    69,    69,    69,    69,    69,
      69,    69,    69,    69,    69,    69,    70,    70,    70,    70,
      70,    70,    70,    70,    70,    70,    70,    71,    72,    72,
      73,    73,    74,    74,    74,    74,    75,    75,    76,    76,
      76,    76,    76,    76,    77,    77,    78,    78,    78,    78,
      78,    78,    78,    79,    79,    79,    80,    80,    81,    81,
      82,    83,    83,    84,    84,    84,    84,    84,    84,    84,
      84,    85,    86,    86,    87,    88,    88,    89,    89,    90,
      90,    91,    91,    92,    92,    93,    93,    94,    94,    94,
      95,    96,    96,    97,    97,    98,    98,    99,    99,   100,
     101,   101,   102
};

/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
static const yytype_uint8 yyr2[] =
{
       0,     2,     1,     2,     0,     2,     0,     4,     0,     3,
       1,     1,     1,     1,     2,     2,     3,     0,     1,     1,
       3,     4,     0,     1,     1,     2,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     4,     1,     2,     2,     2,
       3,     3,     3,     2,     2,     2,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     2,     0,     1,
       1,     2,     1,     1,     1,     1,     2,     1,     1,     4,
       4,     2,     3,     3,     2,     1,     1,     1,     4,     4,
       2,     3,     3,     2,     1,     3,     0,     1,     1,     3,
       2,     2,     1,     0,     1,     1,     4,     4,     2,     3,
       3,     3,     0,     1,     2,     3,     3,     0,     1,     1,
       2,     3,     2,     0,     1,     1,     3,     2,     2,     1,
       2,     0,     2,     3,     4,     1,     3,     1,     3,     2,
       0,     1,     5
};

/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
   Performed when YYTABLE doesn't specify something else to do.  Zero
   means the default is an error.  */
static const yytype_uint8 yydefact[] =
{
       4,     4,     2,     0,     1,     3,     0,    28,    55,    46,
      62,    53,     0,    31,     0,    52,    32,    48,    49,    29,
      65,    47,    50,    30,     0,     8,     0,    51,    54,    63,
       0,     0,     0,    64,    36,    56,     5,    10,    17,    23,
      24,    26,    27,    33,    34,    11,    12,    13,    14,    15,
      39,     0,    43,     6,    37,     0,    44,    22,    38,    45,
       0,     0,   129,    68,     0,    58,     0,    18,    19,     0,
     130,    67,    25,    42,   127,     0,   125,    22,    40,     0,
     113,     0,     0,   109,     9,    17,    41,    93,     0,     0,
       0,     0,    57,    59,    60,    16,     0,    66,   131,   101,
     121,    71,     0,     0,   123,     0,     7,   112,   106,    76,
      77,     0,     0,     0,   121,    75,     0,   114,   115,   119,
     105,     0,   110,   130,    94,    56,     0,    93,    90,    92,
      35,     0,    73,    72,    61,    20,   102,     0,     0,    84,
      87,    88,   128,   124,   126,   118,     0,    76,     0,   120,
      74,   117,    80,     0,   111,     0,     0,    95,     0,    91,
      98,     0,   132,   122,     0,    21,   103,    70,    69,    83,
       0,    82,    81,     0,     0,   116,   100,    99,     0,     0,
     104,    85,    89,    79,    78,    97,    96
};

/* YYDEFGOTO[NTERM-NUM].  */
static const yytype_int16 yydefgoto[] =
{
      -1,     1,     2,     3,    36,    77,    57,    37,    66,    67,
      68,    80,    39,    40,    41,    42,    43,    69,    92,    93,
      44,   123,    71,   114,   115,   138,   139,   140,   141,   128,
     129,    45,   165,   166,    56,    81,    82,    83,   116,   117,
     118,   119,   136,    52,    75,    76,    46,   100,    47
};

/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
   STATE-NUM.  */
#define YYPACT_NINF -140
static const yytype_int16 yypact[] =
{
    -140,    29,  -140,   207,  -140,  -140,    40,  -140,  -140,  -140,
    -140,  -140,   -27,  -140,    44,  -140,  -140,  -140,  -140,  -140,
    -140,  -140,  -140,  -140,   -22,  -140,   -18,  -140,  -140,  -140,
      -9,    22,    28,  -140,  -140,  -140,  -140,  -140,    42,   472,
    -140,  -140,  -140,  -140,  -140,  -140,  -140,  -140,  -140,  -140,
      46,    43,  -140,  -140,    47,   107,  -140,   472,    47,  -140,
     472,    62,  -140,  -140,    16,    -3,    57,    56,  -140,    42,
      35,   -11,  -140,  -140,    53,    48,  -140,   472,  -140,    51,
      21,    59,   157,  -140,  -140,    42,  -140,   388,    58,    60,
      70,    81,  -140,    -3,  -140,  -140,    42,  -140,  -140,  -140,
    -140,  -140,   253,    71,  -140,   -20,  -140,  -140,  -140,    83,
    -140,     5,   102,    34,  -140,    12,    95,    94,  -140,  -140,
    -140,    97,  -140,   113,  -140,  -140,     2,    41,  -140,    27,
    -140,    99,  -140,  -140,  -140,  -140,   -24,    98,   101,   109,
     104,  -140,  -140,  -140,  -140,  -140,   105,  -140,   110,  -140,
    -140,   117,  -140,   298,  -140,    21,   112,  -140,   120,  -140,
    -140,   343,  -140,  -140,   121,  -140,  -140,  -140,  -140,  -140,
     434,  -140,  -140,   131,   137,  -140,  -140,  -140,   138,   141,
    -140,  -140,  -140,  -140,  -140,  -140,  -140
};

/* YYPGOTO[NTERM-NUM].  */
static const yytype_int16 yypgoto[] =
{
    -140,  -140,   190,  -140,  -140,  -140,  -140,   -45,  -140,  -140,
      96,     1,   -60,   -31,  -140,  -140,  -140,   -78,  -140,  -140,
     -55,    -7,  -140,   -92,  -140,  -139,  -140,  -140,   -59,   -39,
    -140,  -140,  -140,  -140,   -13,  -140,  -140,   111,  -140,  -140,
      39,    87,    84,   147,  -140,   106,  -140,  -140,  -140
};

/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
   positive, shift that token.  If negative, reduce the rule which
   number is the opposite.  If YYTABLE_NINF, syntax error.  */
#define YYTABLE_NINF -109
static const yytype_int16 yytable[] =
{
      87,    88,   113,   156,    38,    10,   146,   163,    72,   127,
      94,    50,    84,    59,   174,    20,    54,    90,    74,   148,
      58,   150,   179,   101,    29,    51,   143,   164,    33,     4,
      55,    70,   106,   113,    55,   113,   -93,   102,   134,    60,
     124,    78,    87,   147,   157,    86,   152,   110,   127,   127,
     126,   -93,    65,   111,    63,    65,    72,    91,    85,   109,
     153,   160,    97,   110,    64,    98,    65,    53,    99,   111,
      61,    65,   147,    62,   112,   161,   110,   113,    85,   124,
      63,    74,   111,   157,    65,    48,    49,   158,   159,   126,
      64,    65,    65,    87,   104,   105,   107,   108,    51,    55,
      89,    87,    95,    96,   103,   120,   142,   130,    79,   131,
      87,   182,     7,     8,     9,    10,    11,    12,    13,   132,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
     133,    26,    27,    28,    29,    30,   112,   149,    33,    34,
     154,   155,   107,    98,   162,   -22,   169,   167,   163,    35,
     168,   170,   -22,  -107,   171,   -22,   180,   -22,   121,   172,
     -22,   176,     7,     8,     9,    10,    11,    12,    13,   177,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
     183,    26,    27,    28,    29,    30,   184,   185,    33,    34,
     186,     5,   135,   122,   175,   -22,   145,    73,   151,    35,
       0,     0,   -22,  -108,     0,   -22,     0,   -22,     6,     0,
     -22,   144,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
       0,     0,     0,     0,     0,   -22,     0,     0,     0,    35,
       0,     0,   -22,     0,   137,   -22,     0,   -22,     7,     8,
       9,    10,    11,    12,    13,     0,    15,    16,    17,    18,
      19,    20,    21,    22,    23,    24,     0,    26,    27,    28,
      29,    30,     0,     0,    33,    34,     0,     0,     0,     0,
     -86,     0,     0,     0,     0,    35,     0,     0,     0,   173,
       0,     0,   -86,     7,     8,     9,    10,    11,    12,    13,
       0,    15,    16,    17,    18,    19,    20,    21,    22,    23,
      24,     0,    26,    27,    28,    29,    30,     0,     0,    33,
      34,     0,     0,     0,     0,   -86,     0,     0,     0,     0,
      35,     0,     0,     0,   178,     0,     0,   -86,     7,     8,
       9,    10,    11,    12,    13,     0,    15,    16,    17,    18,
      19,    20,    21,    22,    23,    24,     0,    26,    27,    28,
      29,    30,     0,     0,    33,    34,     0,     0,     0,     0,
     -86,     0,     0,     0,     0,    35,     0,     0,     0,     0,
       0,     0,   -86,     7,     8,     9,    10,    11,    12,    13,
       0,    15,    16,    17,    18,    19,    20,    21,    22,    23,
      24,     0,    26,    27,    28,    29,    30,     0,     0,    33,
      34,     0,     0,     0,     0,     0,   124,     0,     0,     0,
     125,     0,     0,     0,     0,     0,   126,     0,    65,     7,
       8,     9,    10,    11,    12,    13,     0,    15,    16,    17,
      18,    19,    20,    21,    22,    23,    24,     0,    26,    27,
      28,    29,    30,     0,     0,    33,    34,     0,     0,     0,
       0,   181,     0,     0,     0,     0,    35,     7,     8,     9,
      10,    11,    12,    13,     0,    15,    16,    17,    18,    19,
      20,    21,    22,    23,    24,     0,    26,    27,    28,    29,
      30,     0,     0,    33,    34,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    35
};

#define yypact_value_is_default(yystate) \
  ((yystate) == (-140))

#define yytable_value_is_error(yytable_value) \
  YYID (0)

static const yytype_int16 yycheck[] =
{
      60,    60,    80,     1,     3,     8,     1,    31,    39,    87,
      65,    38,    57,    26,   153,    18,    38,     1,    38,   111,
      38,   113,   161,    34,    27,    52,    46,    51,    31,     0,
      52,    38,    77,   111,    52,   113,    34,    48,    93,    48,
      38,    54,   102,    38,    42,    58,    34,    42,   126,   127,
      48,    49,    50,    48,    38,    50,    87,    64,    57,    38,
      48,    34,    69,    42,    48,    30,    50,    23,    33,    48,
      48,    50,    38,    45,    53,    48,    42,   155,    77,    38,
      38,    38,    48,    42,    50,    45,    46,   126,   127,    48,
      48,    50,    50,   153,    46,    47,    45,    46,    52,    52,
      38,   161,    45,    47,    51,    46,    35,    49,     1,    49,
     170,   170,     5,     6,     7,     8,     9,    10,    11,    49,
      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
      49,    24,    25,    26,    27,    28,    53,    35,    31,    32,
      45,    47,    45,    30,    45,    38,    37,    49,    31,    42,
      49,    47,    45,    46,    49,    48,    35,    50,     1,    49,
      53,    49,     5,     6,     7,     8,     9,    10,    11,    49,
      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
      49,    24,    25,    26,    27,    28,    49,    49,    31,    32,
      49,     1,    96,    82,   155,    38,   109,    50,   114,    42,
      -1,    -1,    45,    46,    -1,    48,    -1,    50,     1,    -1,
      53,   105,     5,     6,     7,     8,     9,    10,    11,    12,
      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
      -1,    -1,    -1,    -1,    -1,    38,    -1,    -1,    -1,    42,
      -1,    -1,    45,    -1,     1,    48,    -1,    50,     5,     6,
       7,     8,     9,    10,    11,    -1,    13,    14,    15,    16,
      17,    18,    19,    20,    21,    22,    -1,    24,    25,    26,
      27,    28,    -1,    -1,    31,    32,    -1,    -1,    -1,    -1,
      37,    -1,    -1,    -1,    -1,    42,    -1,    -1,    -1,     1,
      -1,    -1,    49,     5,     6,     7,     8,     9,    10,    11,
      -1,    13,    14,    15,    16,    17,    18,    19,    20,    21,
      22,    -1,    24,    25,    26,    27,    28,    -1,    -1,    31,
      32,    -1,    -1,    -1,    -1,    37,    -1,    -1,    -1,    -1,
      42,    -1,    -1,    -1,     1,    -1,    -1,    49,     5,     6,
       7,     8,     9,    10,    11,    -1,    13,    14,    15,    16,
      17,    18,    19,    20,    21,    22,    -1,    24,    25,    26,
      27,    28,    -1,    -1,    31,    32,    -1,    -1,    -1,    -1,
      37,    -1,    -1,    -1,    -1,    42,    -1,    -1,    -1,    -1,
      -1,    -1,    49,     5,     6,     7,     8,     9,    10,    11,
      -1,    13,    14,    15,    16,    17,    18,    19,    20,    21,
      22,    -1,    24,    25,    26,    27,    28,    -1,    -1,    31,
      32,    -1,    -1,    -1,    -1,    -1,    38,    -1,    -1,    -1,
      42,    -1,    -1,    -1,    -1,    -1,    48,    -1,    50,     5,
       6,     7,     8,     9,    10,    11,    -1,    13,    14,    15,
      16,    17,    18,    19,    20,    21,    22,    -1,    24,    25,
      26,    27,    28,    -1,    -1,    31,    32,    -1,    -1,    -1,
      -1,    37,    -1,    -1,    -1,    -1,    42,     5,     6,     7,
       8,     9,    10,    11,    -1,    13,    14,    15,    16,    17,
      18,    19,    20,    21,    22,    -1,    24,    25,    26,    27,
      28,    -1,    -1,    31,    32,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    42
};

/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
   symbol of state STATE-NUM.  */
static const yytype_uint8 yystos[] =
{
       0,    55,    56,    57,     0,    56,     1,     5,     6,     7,
       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
      28,    29,    30,    31,    32,    42,    58,    61,    65,    66,
      67,    68,    69,    70,    74,    85,   100,   102,    45,    46,
      38,    52,    97,    23,    38,    52,    88,    60,    38,    88,
      48,    48,    45,    38,    48,    50,    62,    63,    64,    71,
      75,    76,    67,    97,    38,    98,    99,    59,    88,     1,
      65,    89,    90,    91,    61,    65,    88,    66,    82,    38,
       1,    75,    72,    73,    74,    45,    47,    75,    30,    33,
     101,    34,    48,    51,    46,    47,    61,    45,    46,    38,
      42,    48,    53,    71,    77,    78,    92,    93,    94,    95,
      46,     1,    91,    75,    38,    42,    48,    71,    83,    84,
      49,    49,    49,    49,    74,    64,    96,     1,    79,    80,
      81,    82,    35,    46,    99,    95,     1,    38,    77,    35,
      77,    96,    34,    48,    45,    47,     1,    42,    83,    83,
      34,    48,    45,    31,    51,    86,    87,    49,    49,    37,
      47,    49,    49,     1,    79,    94,    49,    49,     1,    79,
      35,    37,    82,    49,    49,    49,    49
};

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		(-2)
#define YYEOF		0

#define YYACCEPT	goto yyacceptlab
#define YYABORT		goto yyabortlab
#define YYERROR		goto yyerrorlab


/* Like YYERROR except do call yyerror.  This remains here temporarily
   to ease the transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  However,
   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
   discussed.  */

#define YYFAIL		goto yyerrlab
#if defined YYFAIL
  /* This is here to suppress warnings from the GCC cpp's
     -Wunused-macros.  Normally we don't worry about that warning, but
     some users do, and we want to make it easy for users to remove
     YYFAIL uses, which will produce warnings from Bison 2.5.  */
#endif

#define YYRECOVERING()  (!!yyerrstatus)

#define YYBACKUP(Token, Value)                                  \
do                                                              \
  if (yychar == YYEMPTY)                                        \
    {                                                           \
      yychar = (Token);                                         \
      yylval = (Value);                                         \
      YYPOPSTACK (yylen);                                       \
      yystate = *yyssp;                                         \
      goto yybackup;                                            \
    }                                                           \
  else                                                          \
    {                                                           \
      yyerror (YY_("syntax error: cannot back up")); \
      YYERROR;							\
    }								\
while (YYID (0))


#define YYTERROR	1
#define YYERRCODE	256


/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
   If N is 0, then set CURRENT to the empty location which ends
   the previous symbol: RHS[0] (always defined).  */

#define YYRHSLOC(Rhs, K) ((Rhs)[K])
#ifndef YYLLOC_DEFAULT
# define YYLLOC_DEFAULT(Current, Rhs, N)				\
    do									\
      if (YYID (N))                                                    \
	{								\
	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
	}								\
      else								\
	{								\
	  (Current).first_line   = (Current).last_line   =		\
	    YYRHSLOC (Rhs, 0).last_line;				\
	  (Current).first_column = (Current).last_column =		\
	    YYRHSLOC (Rhs, 0).last_column;				\
	}								\
    while (YYID (0))
#endif


/* This macro is provided for backward compatibility. */

#ifndef YY_LOCATION_PRINT
# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
#endif


/* YYLEX -- calling `yylex' with the right arguments.  */

#ifdef YYLEX_PARAM
# define YYLEX yylex (YYLEX_PARAM)
#else
# define YYLEX yylex ()
#endif

/* Enable debugging if requested.  */
#if YYDEBUG

# ifndef YYFPRINTF
#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)			\
do {						\
  if (yydebug)					\
    YYFPRINTF Args;				\
} while (YYID (0))

# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
do {									  \
  if (yydebug)								  \
    {									  \
      YYFPRINTF (stderr, "%s ", Title);					  \
      yy_symbol_print (stderr,						  \
		  Type, Value); \
      YYFPRINTF (stderr, "\n");						  \
    }									  \
} while (YYID (0))


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

/*ARGSUSED*/
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
#else
static void
yy_symbol_value_print (yyoutput, yytype, yyvaluep)
    FILE *yyoutput;
    int yytype;
    YYSTYPE const * const yyvaluep;
#endif
{
  FILE *yyo = yyoutput;
  YYUSE (yyo);
  if (!yyvaluep)
    return;
# ifdef YYPRINT
  if (yytype < YYNTOKENS)
    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
# else
  YYUSE (yyoutput);
# endif
  switch (yytype)
    {
      default:
	break;
    }
}


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
#else
static void
yy_symbol_print (yyoutput, yytype, yyvaluep)
    FILE *yyoutput;
    int yytype;
    YYSTYPE const * const yyvaluep;
#endif
{
  if (yytype < YYNTOKENS)
    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
  else
    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);

  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
  YYFPRINTF (yyoutput, ")");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
#else
static void
yy_stack_print (yybottom, yytop)
    yytype_int16 *yybottom;
    yytype_int16 *yytop;
#endif
{
  YYFPRINTF (stderr, "Stack now");
  for (; yybottom <= yytop; yybottom++)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, " %d", yybot);
    }
  YYFPRINTF (stderr, "\n");
}

# define YY_STACK_PRINT(Bottom, Top)				\
do {								\
  if (yydebug)							\
    yy_stack_print ((Bottom), (Top));				\
} while (YYID (0))


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
#else
static void
yy_reduce_print (yyvsp, yyrule)
    YYSTYPE *yyvsp;
    int yyrule;
#endif
{
  int yynrhs = yyr2[yyrule];
  int yyi;
  unsigned long int yylno = yyrline[yyrule];
  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
	     yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi++)
    {
      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
		       &(yyvsp[(yyi + 1) - (yynrhs)])
		       		       );
      YYFPRINTF (stderr, "\n");
    }
}

# define YY_REDUCE_PRINT(Rule)		\
do {					\
  if (yydebug)				\
    yy_reduce_print (yyvsp, Rule); \
} while (YYID (0))

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef	YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif


#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined __GLIBC__ && defined _STRING_H
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static YYSIZE_T
yystrlen (const char *yystr)
#else
static YYSIZE_T
yystrlen (yystr)
    const char *yystr;
#endif
{
  YYSIZE_T yylen;
  for (yylen = 0; yystr[yylen]; yylen++)
    continue;
  return yylen;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static char *
yystpcpy (char *yydest, const char *yysrc)
#else
static char *
yystpcpy (yydest, yysrc)
    char *yydest;
    const char *yysrc;
#endif
{
  char *yyd = yydest;
  const char *yys = yysrc;

  while ((*yyd++ = *yys++) != '\0')
    continue;

  return yyd - 1;
}
#  endif
# endif

# ifndef yytnamerr
/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
   quotes and backslashes, so that it's suitable for yyerror.  The
   heuristic is that double-quoting is unnecessary unless the string
   contains an apostrophe, a comma, or backslash (other than
   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
   null, do not copy; instead, return the length of what the result
   would have been.  */
static YYSIZE_T
yytnamerr (char *yyres, const char *yystr)
{
  if (*yystr == '"')
    {
      YYSIZE_T yyn = 0;
      char const *yyp = yystr;

      for (;;)
	switch (*++yyp)
	  {
	  case '\'':
	  case ',':
	    goto do_not_strip_quotes;

	  case '\\':
	    if (*++yyp != '\\')
	      goto do_not_strip_quotes;
	    /* Fall through.  */
	  default:
	    if (yyres)
	      yyres[yyn] = *yyp;
	    yyn++;
	    break;

	  case '"':
	    if (yyres)
	      yyres[yyn] = '\0';
	    return yyn;
	  }
    do_not_strip_quotes: ;
    }

  if (! yyres)
    return yystrlen (yystr);

  return yystpcpy (yyres, yystr) - yyres;
}
# endif

/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
   about the unexpected token YYTOKEN for the state stack whose top is
   YYSSP.

   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
   not large enough to hold the message.  In that case, also set
   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
   required number of bytes is too large to store.  */
static int
yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
                yytype_int16 *yyssp, int yytoken)
{
  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);
  YYSIZE_T yysize = yysize0;
  YYSIZE_T yysize1;
  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
  /* Internationalized format string. */
  const char *yyformat = YY_NULL;
  /* Arguments of yyformat. */
  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
  /* Number of reported tokens (one for the "unexpected", one per
     "expected"). */
  int yycount = 0;

  /* There are many possibilities here to consider:
     - Assume YYFAIL is not used.  It's too flawed to consider.  See
       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
       for details.  YYERROR is fine as it does not invoke this
       function.
     - If this state is a consistent state with a default action, then
       the only way this function was invoked is if the default action
       is an error action.  In that case, don't check for expected
       tokens because there are none.
     - The only way there can be no lookahead present (in yychar) is if
       this state is a consistent state with a default action.  Thus,
       detecting the absence of a lookahead is sufficient to determine
       that there is no unexpected or expected token to report.  In that
       case, just report a simple "syntax error".
     - Don't assume there isn't a lookahead just because this state is a
       consistent state with a default action.  There might have been a
       previous inconsistent state, consistent state with a non-default
       action, or user semantic action that manipulated yychar.
     - Of course, the expected token list depends on states to have
       correct lookahead information, and it depends on the parser not
       to perform extra reductions after fetching a lookahead from the
       scanner and before detecting a syntax error.  Thus, state merging
       (from LALR or IELR) and default reductions corrupt the expected
       token list.  However, the list is correct for canonical LR with
       one exception: it will still contain any token that will not be
       accepted due to an error action in a later state.
  */
  if (yytoken != YYEMPTY)
    {
      int yyn = yypact[*yyssp];
      yyarg[yycount++] = yytname[yytoken];
      if (!yypact_value_is_default (yyn))
        {
          /* Start YYX at -YYN if negative to avoid negative indexes in
             YYCHECK.  In other words, skip the first -YYN actions for
             this state because they are default actions.  */
          int yyxbegin = yyn < 0 ? -yyn : 0;
          /* Stay within bounds of both yycheck and yytname.  */
          int yychecklim = YYLAST - yyn + 1;
          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
          int yyx;

          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
                && !yytable_value_is_error (yytable[yyx + yyn]))
              {
                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
                  {
                    yycount = 1;
                    yysize = yysize0;
                    break;
                  }
                yyarg[yycount++] = yytname[yyx];
                yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);
                if (! (yysize <= yysize1
                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
                  return 2;
                yysize = yysize1;
              }
        }
    }

  switch (yycount)
    {
# define YYCASE_(N, S)                      \
      case N:                               \
        yyformat = S;                       \
      break
      YYCASE_(0, YY_("syntax error"));
      YYCASE_(1, YY_("syntax error, unexpected %s"));
      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
# undef YYCASE_
    }

  yysize1 = yysize + yystrlen (yyformat);
  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
    return 2;
  yysize = yysize1;

  if (*yymsg_alloc < yysize)
    {
      *yymsg_alloc = 2 * yysize;
      if (! (yysize <= *yymsg_alloc
             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
      return 1;
    }

  /* Avoid sprintf, as that infringes on the user's name space.
     Don't have undefined behavior even if the translation
     produced a string with the wrong number of "%s"s.  */
  {
    char *yyp = *yymsg;
    int yyi = 0;
    while ((*yyp = *yyformat) != '\0')
      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        {
          yyp += yytnamerr (yyp, yyarg[yyi++]);
          yyformat += 2;
        }
      else
        {
          yyp++;
          yyformat++;
        }
  }
  return 0;
}
#endif /* YYERROR_VERBOSE */

/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/

/*ARGSUSED*/
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
static void
yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
#else
static void
yydestruct (yymsg, yytype, yyvaluep)
    const char *yymsg;
    int yytype;
    YYSTYPE *yyvaluep;
#endif
{
  YYUSE (yyvaluep);

  if (!yymsg)
    yymsg = "Deleting";
  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);

  switch (yytype)
    {

      default:
	break;
    }
}


/* Prevent warnings from -Wmissing-prototypes.  */
#ifdef YYPARSE_PARAM
#if defined __STDC__ || defined __cplusplus
int yyparse (void *YYPARSE_PARAM);
#else
int yyparse ();
#endif
#else /* ! YYPARSE_PARAM */
#if defined __STDC__ || defined __cplusplus
int yyparse (void);
#else
int yyparse ();
#endif
#endif /* ! YYPARSE_PARAM */


/* The lookahead symbol.  */
int yychar;

/* The semantic value of the lookahead symbol.  */
YYSTYPE yylval;

/* Number of syntax errors so far.  */
int yynerrs;


/*----------.
| yyparse.  |
`----------*/

#ifdef YYPARSE_PARAM
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
int
yyparse (void *YYPARSE_PARAM)
#else
int
yyparse (YYPARSE_PARAM)
    void *YYPARSE_PARAM;
#endif
#else /* ! YYPARSE_PARAM */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
int
yyparse (void)
#else
int
yyparse ()

#endif
#endif
{
    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       `yyss': related to states.
       `yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yytoken = 0;
  yyss = yyssa;
  yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, "Starting parse\n"));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */
  yyssp = yyss;
  yyvsp = yyvs;

  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
	/* Give user a chance to reallocate the stack.  Use copies of
	   these so that the &'s don't force the real ones into
	   memory.  */
	YYSTYPE *yyvs1 = yyvs;
	yytype_int16 *yyss1 = yyss;

	/* Each stack pointer address is followed by the size of the
	   data in use in that stack, in bytes.  This used to be a
	   conditional around just the two extra args, but that might
	   be undefined if yyoverflow is a macro.  */
	yyoverflow (YY_("memory exhausted"),
		    &yyss1, yysize * sizeof (*yyssp),
		    &yyvs1, yysize * sizeof (*yyvsp),
		    &yystacksize);

	yyss = yyss1;
	yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
	goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
	yystacksize = YYMAXDEPTH;

      {
	yytype_int16 *yyss1 = yyss;
	union yyalloc *yyptr =
	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
	if (! yyptr)
	  goto yyexhaustedlab;
	YYSTACK_RELOCATE (yyss_alloc, yyss);
	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
	if (yyss1 != yyssa)
	  YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
		  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
	YYABORT;
    }

  YYDPRINTF ((stderr, "Entering state %d\n", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, "Reading a token: "));
      yychar = YYLEX;
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, "Now at end of input.\n"));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  *++yyvsp = yylval;

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     `$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 4:

    { is_typedef = 0; is_extern = 0; current_name = NULL; decl_spec = NULL; }
    break;

  case 5:

    { free_list(*(yyvsp[(2) - (2)]), NULL); *(yyvsp[(2) - (2)]) = NULL; }
    break;

  case 6:

    { is_typedef = 1; }
    break;

  case 7:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 8:

    { is_typedef = 1; }
    break;

  case 9:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 14:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 15:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 16:

    { if (current_name) {
		    struct string_list *decl = (*(yyvsp[(3) - (3)]))->next;
		    (*(yyvsp[(3) - (3)]))->next = NULL;
		    add_symbol(current_name,
			       is_typedef ? SYM_TYPEDEF : SYM_NORMAL,
			       decl, is_extern);
		    current_name = NULL;
		  }
		  (yyval) = (yyvsp[(3) - (3)]);
		}
    break;

  case 17:

    { (yyval) = NULL; }
    break;

  case 19:

    { struct string_list *decl = *(yyvsp[(1) - (1)]);
		  *(yyvsp[(1) - (1)]) = NULL;
		  add_symbol(current_name,
			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
		  current_name = NULL;
		  (yyval) = (yyvsp[(1) - (1)]);
		}
    break;

  case 20:

    { struct string_list *decl = *(yyvsp[(3) - (3)]);
		  *(yyvsp[(3) - (3)]) = NULL;
		  free_list(*(yyvsp[(2) - (3)]), NULL);
		  *(yyvsp[(2) - (3)]) = decl_spec;
		  add_symbol(current_name,
			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
		  current_name = NULL;
		  (yyval) = (yyvsp[(3) - (3)]);
		}
    break;

  case 21:

    { (yyval) = (yyvsp[(4) - (4)]) ? (yyvsp[(4) - (4)]) : (yyvsp[(3) - (4)]) ? (yyvsp[(3) - (4)]) : (yyvsp[(2) - (4)]) ? (yyvsp[(2) - (4)]) : (yyvsp[(1) - (4)]); }
    break;

  case 22:

    { decl_spec = NULL; }
    break;

  case 24:

    { decl_spec = *(yyvsp[(1) - (1)]); }
    break;

  case 25:

    { decl_spec = *(yyvsp[(2) - (2)]); }
    break;

  case 26:

    { /* Version 2 checksumming ignores storage class, as that
		     is really irrelevant to the linkage.  */
		  remove_node((yyvsp[(1) - (1)]));
		  (yyval) = (yyvsp[(1) - (1)]);
		}
    break;

  case 31:

    { is_extern = 1; (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 32:

    { is_extern = 0; (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 37:

    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_STRUCT; (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 38:

    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_UNION; (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 39:

    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_ENUM; (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 40:

    { record_compound((yyvsp[(1) - (3)]), (yyvsp[(2) - (3)]), (yyvsp[(3) - (3)]), SYM_STRUCT); (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 41:

    { record_compound((yyvsp[(1) - (3)]), (yyvsp[(2) - (3)]), (yyvsp[(3) - (3)]), SYM_UNION); (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 42:

    { record_compound((yyvsp[(1) - (3)]), (yyvsp[(2) - (3)]), (yyvsp[(3) - (3)]), SYM_ENUM); (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 43:

    { add_symbol(NULL, SYM_ENUM, NULL, 0); (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 44:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 45:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 56:

    { (*(yyvsp[(1) - (1)]))->tag = SYM_TYPEDEF; (yyval) = (yyvsp[(1) - (1)]); }
    break;

  case 57:

    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); }
    break;

  case 58:

    { (yyval) = NULL; }
    break;

  case 61:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 65:

    { /* restrict has no effect in prototypes so ignore it */
		  remove_node((yyvsp[(1) - (1)]));
		  (yyval) = (yyvsp[(1) - (1)]);
		}
    break;

  case 66:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 68:

    { if (current_name != NULL) {
		    error_with_pos("unexpected second declaration name");
		    YYERROR;
		  } else {
		    current_name = (*(yyvsp[(1) - (1)]))->string;
		    (yyval) = (yyvsp[(1) - (1)]);
		  }
		}
    break;

  case 69:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 70:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 71:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 72:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 73:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 74:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 78:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 79:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 80:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 81:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 82:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 83:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 85:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 86:

    { (yyval) = NULL; }
    break;

  case 89:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 90:

    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); }
    break;

  case 91:

    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); }
    break;

  case 93:

    { (yyval) = NULL; }
    break;

  case 94:

    { /* For version 2 checksums, we don't want to remember
		     private parameter names.  */
		  remove_node((yyvsp[(1) - (1)]));
		  (yyval) = (yyvsp[(1) - (1)]);
		}
    break;

  case 95:

    { remove_node((yyvsp[(1) - (1)]));
		  (yyval) = (yyvsp[(1) - (1)]);
		}
    break;

  case 96:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 97:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 98:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 99:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 100:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 101:

    { struct string_list *decl = *(yyvsp[(2) - (3)]);
		  *(yyvsp[(2) - (3)]) = NULL;
		  add_symbol(current_name, SYM_NORMAL, decl, is_extern);
		  (yyval) = (yyvsp[(3) - (3)]);
		}
    break;

  case 102:

    { (yyval) = NULL; }
    break;

  case 104:

    { remove_list((yyvsp[(2) - (2)]), &(*(yyvsp[(1) - (2)]))->next); (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 105:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 106:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 107:

    { (yyval) = NULL; }
    break;

  case 110:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 111:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 112:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 113:

    { (yyval) = NULL; }
    break;

  case 116:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 117:

    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); }
    break;

  case 118:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 120:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 121:

    { (yyval) = NULL; }
    break;

  case 123:

    { (yyval) = (yyvsp[(3) - (3)]); }
    break;

  case 124:

    { (yyval) = (yyvsp[(4) - (4)]); }
    break;

  case 127:

    {
			const char *name = strdup((*(yyvsp[(1) - (1)]))->string);
			add_symbol(name, SYM_ENUM_CONST, NULL, 0);
		}
    break;

  case 128:

    {
			const char *name = strdup((*(yyvsp[(1) - (3)]))->string);
			struct string_list *expr = copy_list_range(*(yyvsp[(3) - (3)]), *(yyvsp[(2) - (3)]));
			add_symbol(name, SYM_ENUM_CONST, expr, 0);
		}
    break;

  case 129:

    { (yyval) = (yyvsp[(2) - (2)]); }
    break;

  case 130:

    { (yyval) = NULL; }
    break;

  case 132:

    { export_symbol((*(yyvsp[(3) - (5)]))->string); (yyval) = (yyvsp[(5) - (5)]); }
    break;



      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now `shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*------------------------------------.
| yyerrlab -- here on detecting error |
`------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (YY_("syntax error"));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_("syntax error");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
	 error, discard it.  */

      if (yychar <= YYEOF)
	{
	  /* Return failure if at end of input.  */
	  if (yychar == YYEOF)
	    YYABORT;
	}
      else
	{
	  yydestruct ("Error: discarding",
		      yytoken, &yylval);
	  yychar = YYEMPTY;
	}
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule which action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;	/* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
	{
	  yyn += YYTERROR;
	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
	    {
	      yyn = yytable[yyn];
	      if (0 < yyn)
		break;
	    }
	}

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
	YYABORT;


      yydestruct ("Error: popping",
		  yystos[yystate], yyvsp);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  *++yyvsp = yylval;


  /* Shift the error token.  */
  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (YY_("memory exhausted"));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ("Cleanup: discarding lookahead",
                  yytoken, &yylval);
    }
  /* Do not reclaim the symbols of the rule which action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ("Cleanup: popping",
		  yystos[*yyssp], yyvsp);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#endif
  /* Make sure YYID is used.  */
  return YYID (yyresult);
}





static void
yyerror(const char *e)
{
  error_with_pos("%s", e);
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        config MIPS
	bool
	default y
	select ARCH_MIGHT_HAVE_PC_PARPORT
	select ARCH_MIGHT_HAVE_PC_SERIO
	select HAVE_CONTEXT_TRACKING
	select HAVE_GENERIC_DMA_COHERENT
	select HAVE_IDE
	select HAVE_OPROFILE
	select HAVE_PERF_EVENTS
	select PERF_USE_VMALLOC
	select HAVE_ARCH_KGDB
	select HAVE_ARCH_SECCOMP_FILTER
	select HAVE_ARCH_TRACEHOOK
	select HAVE_BPF_JIT if !CPU_MICROMIPS
	select ARCH_HAVE_CUSTOM_GPIO_H
	select HAVE_FUNCTION_TRACER
	select HAVE_DYNAMIC_FTRACE
	select HAVE_FTRACE_MCOUNT_RECORD
	select HAVE_C_RECORDMCOUNT
	select HAVE_FUNCTION_GRAPH_TRACER
	select HAVE_KPROBES
	select HAVE_KRETPROBES
	select HAVE_DEBUG_KMEMLEAK
	select HAVE_SYSCALL_TRACEPOINTS
	select ARCH_HAS_ELF_RANDOMIZE
	select HAVE_ARCH_TRANSPARENT_HUGEPAGE if CPU_SUPPORTS_HUGEPAGES && 64BIT
	select RTC_LIB if !MACH_LOONGSON
	select GENERIC_ATOMIC64 if !64BIT
	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
	select HAVE_DMA_ATTRS
	select HAVE_DMA_CONTIGUOUS
	select HAVE_DMA_API_DEBUG
	select GENERIC_IRQ_PROBE
	select GENERIC_IRQ_SHOW
	select GENERIC_PCI_IOMAP
	select HAVE_ARCH_JUMP_LABEL
	select ARCH_WANT_IPC_PARSE_VERSION
	select IRQ_FORCED_THREADING
	select HAVE_MEMBLOCK
	select HAVE_MEMBLOCK_NODE_MAP
	select ARCH_DISCARD_MEMBLOCK
	select GENERIC_SMP_IDLE_THREAD
	select BUILDTIME_EXTABLE_SORT
	select GENERIC_CLOCKEVENTS
	select GENERIC_SCHED_CLOCK if !CAVIUM_OCTEON_SOC
	select GENERIC_CMOS_UPDATE
	select HAVE_MOD_ARCH_SPECIFIC
	select VIRT_TO_BUS
	select MODULES_USE_ELF_REL if MODULES
	select MODULES_USE_ELF_RELA if MODULES && 64BIT
	select CLONE_BACKWARDS
	select HAVE_DEBUG_STACKOVERFLOW
	select HAVE_CC_STACKPROTECTOR
	select CPU_PM if CPU_IDLE
	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
	select ARCH_BINFMT_ELF_STATE
	select SYSCTL_EXCEPTION_TRACE
	select HAVE_VIRT_CPU_ACCOUNTING_GEN
	select HAVE_IRQ_TIME_ACCOUNTING

menu "Machine selection"

choice
	prompt "System type"
	default SGI_IP22

config MIPS_ALCHEMY
	bool "Alchemy processor based machines"
	select ARCH_PHYS_ADDR_T_64BIT
	select CEVT_R4K
	select CSRC_R4K
	select IRQ_CPU
	select DMA_MAYBE_COHERENT	# Au1000,1500,1100 aren't, rest is
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_APM_EMULATION
	select ARCH_REQUIRE_GPIOLIB
	select SYS_SUPPORTS_ZBOOT
	select COMMON_CLK

config AR7
	bool "Texas Instruments AR7"
	select BOOT_ELF32
	select DMA_NONCOHERENT
	select CEVT_R4K
	select CSRC_R4K
	select IRQ_CPU
	select NO_EXCEPT_FILL
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select SYS_SUPPORTS_ZBOOT_UART16550
	select ARCH_REQUIRE_GPIOLIB
	select VLYNQ
	select HAVE_CLK
	help
	  Support for the Texas Instruments AR7 System-on-a-Chip
	  family: TNETD7100, 7200 and 7300.

config ATH25
	bool "Atheros AR231x/AR531x SoC support"
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select IRQ_CPU
	select IRQ_DOMAIN
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_HAS_EARLY_PRINTK
	help
	  Support for Atheros AR231x and Atheros AR531x based boards

config ATH79
	bool "Atheros AR71XX/AR724X/AR913X based boards"
	select ARCH_REQUIRE_GPIOLIB
	select BOOT_RAW
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select HAVE_CLK
	select CLKDEV_LOOKUP
	select IRQ_CPU
	select MIPS_MACHINE
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_MIPS16
	help
	  Support for the Atheros AR71XX/AR724X/AR913X SoCs.

config BMIPS_GENERIC
	bool "Broadcom Generic BMIPS kernel"
	select BOOT_RAW
	select NO_EXCEPT_FILL
	select USE_OF
	select CEVT_R4K
	select CSRC_R4K
	select SYNC_R4K
	select COMMON_CLK
	select BCM7038_L1_IRQ
	select BCM7120_L2_IRQ
	select BRCMSTB_L2_IRQ
	select IRQ_CPU
	select RAW_IRQ_ACCESSORS
	select DMA_NONCOHERENT
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_HAS_CPU_BMIPS32_3300
	select SYS_HAS_CPU_BMIPS4350
	select SYS_HAS_CPU_BMIPS4380
	select SYS_HAS_CPU_BMIPS5000
	select SWAP_IO_SPACE
	select USB_EHCI_BIG_ENDIAN_DESC if CPU_BIG_ENDIAN
	select USB_EHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN
	select USB_OHCI_BIG_ENDIAN_DESC if CPU_BIG_ENDIAN
	select USB_OHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN
	help
	  Build a generic DT-based kernel image that boots on select
	  BCM33xx cable modem chips, BCM63xx DSL chips, and BCM7xxx set-top
	  box chips.  Note that CONFIG_CPU_BIG_ENDIAN/CONFIG_CPU_LITTLE_ENDIAN
	  must be set appropriately for your board.

config BCM47XX
	bool "Broadcom BCM47XX based boards"
	select ARCH_WANT_OPTIONAL_GPIOLIB
	select BOOT_RAW
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select HW_HAS_PCI
	select IRQ_CPU
	select SYS_HAS_CPU_MIPS32_R1
	select NO_EXCEPT_FILL
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select SYS_HAS_EARLY_PRINTK
	select USE_GENERIC_EARLY_PRINTK_8250
	select GPIOLIB
	select LEDS_GPIO_REGISTER
	help
	 Support for BCM47XX based boards

config BCM63XX
	bool "Broadcom BCM63XX based boards"
	select BOOT_RAW
	select CEVT_R4K
	select CSRC_R4K
	select SYNC_R4K
	select DMA_NONCOHERENT
	select IRQ_CPU
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_HAS_EARLY_PRINTK
	select SWAP_IO_SPACE
	select ARCH_REQUIRE_GPIOLIB
	select HAVE_CLK
	select MIPS_L1_CACHE_SHIFT_4
	help
	 Support for BCM63XX based boards

config MIPS_COBALT
	bool "Cobalt Server"
	select CEVT_R4K
	select CSRC_R4K
	select CEVT_GT641XX
	select DMA_NONCOHERENT
	select HW_HAS_PCI
	select I8253
	select I8259
	select IRQ_CPU
	select IRQ_GT641XX
	select PCI_GT64XXX_PCI0
	select PCI
	select SYS_HAS_CPU_NEVADA
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select USE_GENERIC_EARLY_PRINTK_8250

config MACH_DECSTATION
	bool "DECstations"
	select BOOT_ELF32
	select CEVT_DS1287
	select CEVT_R4K if CPU_R4X00
	select CSRC_IOASIC
	select CSRC_R4K if CPU_R4X00
	select CPU_DADDI_WORKAROUNDS if 64BIT
	select CPU_R4000_WORKAROUNDS if 64BIT
	select CPU_R4400_WORKAROUNDS if 64BIT
	select DMA_NONCOHERENT
	select NO_IOPORT_MAP
	select IRQ_CPU
	select SYS_HAS_CPU_R3000
	select SYS_HAS_CPU_R4X00
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_128HZ
	select SYS_SUPPORTS_256HZ
	select SYS_SUPPORTS_1024HZ
	select MIPS_L1_CACHE_SHIFT_4
	help
	  This enables support for DEC's MIPS based workstations.  For details
	  see the Linux/MIPS FAQ on <http://www.linux-mips.org/> and the
	  DECstation porting pages on <http://decstation.unix-ag.org/>.

	  If you have one of the following DECstation Models you definitely
	  want to choose R4xx0 for the CPU Type:

		DECstation 5000/50
		DECstation 5000/150
		DECstation 5000/260
		DECsystem 5900/260

	  otherwise choose R3000.

config MACH_JAZZ
	bool "Jazz family of machines"
	select FW_ARC
	select FW_ARC32
	select ARCH_MAY_HAVE_PC_FDC
	select CEVT_R4K
	select CSRC_R4K
	select DEFAULT_SGI_PARTITION if CPU_BIG_ENDIAN
	select GENERIC_ISA_DMA
	select HAVE_PCSPKR_PLATFORM
	select IRQ_CPU
	select I8253
	select I8259
	select ISA
	select SYS_HAS_CPU_R4X00
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_100HZ
	help
	 This a family of machines based on the MIPS R4030 chipset which was
	 used by several vendors to build RISC/os and Windows NT workstations.
	 Members include the Acer PICA, MIPS Magnum 4000, MIPS Millennium and
	 Olivetti M700-10 workstations.

config MACH_JZ4740
	bool "Ingenic JZ4740 based machines"
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_ZBOOT_UART16550
	select DMA_NONCOHERENT
	select IRQ_CPU
	select ARCH_REQUIRE_GPIOLIB
	select SYS_HAS_EARLY_PRINTK
	select HAVE_CLK
	select GENERIC_IRQ_CHIP

config LANTIQ
	bool "Lantiq based platforms"
	select DMA_NONCOHERENT
	select IRQ_CPU
	select CEVT_R4K
	select CSRC_R4K
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_MIPS16
	select SYS_SUPPORTS_MULTITHREADING
	select SYS_HAS_EARLY_PRINTK
	select ARCH_REQUIRE_GPIOLIB
	select SWAP_IO_SPACE
	select BOOT_RAW
	select HAVE_MACH_CLKDEV
	select CLKDEV_LOOKUP
	select USE_OF
	select PINCTRL
	select PINCTRL_LANTIQ
	select ARCH_HAS_RESET_CONTROLLER
	select RESET_CONTROLLER

config LASAT
	bool "LASAT Networks platforms"
	select CEVT_R4K
	select CRC32
	select CSRC_R4K
	select DMA_NONCOHERENT
	select SYS_HAS_EARLY_PRINTK
	select HW_HAS_PCI
	select IRQ_CPU
	select PCI_GT64XXX_PCI0
	select MIPS_NILE4
	select R5000_CPU_SCACHE
	select SYS_HAS_CPU_R5000
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL if BROKEN
	select SYS_SUPPORTS_LITTLE_ENDIAN

config MACH_LOONGSON
	bool "Loongson family of machines"
	select SYS_SUPPORTS_ZBOOT
	help
	  This enables the support of Loongson family of machines.

	  Loongson is a family of general-purpose MIPS-compatible CPUs.
	  developed at Institute of Computing Technology (ICT),
	  Chinese Academy of Sciences (CAS) in the People's Republic
	  of China. The chief architect is Professor Weiwu Hu.

config MACH_LOONGSON1
	bool "Loongson 1 family of machines"
	select SYS_SUPPORTS_ZBOOT
	help
	  This enables support for the Loongson 1 based machines.

	  Loongson 1 is a family of 32-bit MIPS-compatible SoCs developed by
	  the ICT (Institute of Computing Technology) and the Chinese Academy
	  of Sciences.

config MACH_PISTACHIO
	bool "IMG Pistachio SoC based boards"
	select ARCH_REQUIRE_GPIOLIB
	select BOOT_ELF32
	select BOOT_RAW
	select CEVT_R4K
	select CLKSRC_MIPS_GIC
	select COMMON_CLK
	select CSRC_R4K
	select DMA_MAYBE_COHERENT
	select IRQ_CPU
	select LIBFDT
	select MFD_SYSCON
	select MIPS_CPU_SCACHE
	select MIPS_GIC
	select PINCTRL
	select REGULATOR
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MIPS_CPS
	select SYS_SUPPORTS_MULTITHREADING
	select SYS_SUPPORTS_ZBOOT
	select USE_OF
	help
	  This enables support for the IMG Pistachio SoC platform.

config MIPS_MALTA
	bool "MIPS Malta board"
	select ARCH_MAY_HAVE_PC_FDC
	select BOOT_ELF32
	select BOOT_RAW
	select CEVT_R4K
	select CSRC_R4K
	select CLKSRC_MIPS_GIC
	select DMA_MAYBE_COHERENT
	select GENERIC_ISA_DMA
	select HAVE_PCSPKR_PLATFORM
	select IRQ_CPU
	select MIPS_GIC
	select HW_HAS_PCI
	select I8253
	select I8259
	select MIPS_BONITO64
	select MIPS_CPU_SCACHE
	select MIPS_L1_CACHE_SHIFT_6
	select PCI_GT64XXX_PCI0
	select MIPS_MSC
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_HAS_CPU_MIPS32_R3_5
	select SYS_HAS_CPU_MIPS32_R5
	select SYS_HAS_CPU_MIPS32_R6
	select SYS_HAS_CPU_MIPS64_R1
	select SYS_HAS_CPU_MIPS64_R2
	select SYS_HAS_CPU_MIPS64_R6
	select SYS_HAS_CPU_NEVADA
	select SYS_HAS_CPU_RM7000
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MICROMIPS
	select SYS_SUPPORTS_MIPS_CMP
	select SYS_SUPPORTS_MIPS_CPS
	select SYS_SUPPORTS_MIPS16
	select SYS_SUPPORTS_MULTITHREADING
	select SYS_SUPPORTS_SMARTMIPS
	select SYS_SUPPORTS_ZBOOT
	help
	  This enables support for the MIPS Technologies Malta evaluation
	  board.

config MIPS_SEAD3
	bool "MIPS SEAD3 board"
	select BOOT_ELF32
	select BOOT_RAW
	select BUILTIN_DTB
	select CEVT_R4K
	select CSRC_R4K
	select CLKSRC_MIPS_GIC
	select CPU_MIPSR2_IRQ_VI
	select CPU_MIPSR2_IRQ_EI
	select DMA_NONCOHERENT
	select IRQ_CPU
	select MIPS_GIC
	select LIBFDT
	select MIPS_MSC
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_HAS_CPU_MIPS64_R1
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_SMARTMIPS
	select SYS_SUPPORTS_MICROMIPS
	select SYS_SUPPORTS_MIPS16
	select USB_EHCI_BIG_ENDIAN_DESC
	select USB_EHCI_BIG_ENDIAN_MMIO
	select USE_OF
	help
	  This enables support for the MIPS Technologies SEAD3 evaluation
	  board.

config NEC_MARKEINS
	bool "NEC EMMA2RH Mark-eins board"
	select SOC_EMMA2RH
	select HW_HAS_PCI
	help
	  This enables support for the NEC Electronics Mark-eins boards.

config MACH_VR41XX
	bool "NEC VR4100 series based machines"
	select CEVT_R4K
	select CSRC_R4K
	select SYS_HAS_CPU_VR41XX
	select SYS_SUPPORTS_MIPS16
	select ARCH_REQUIRE_GPIOLIB

config NXP_STB220
	bool "NXP STB220 board"
	select SOC_PNX833X
	help
	 Support for NXP Semiconductors STB220 Development Board.

config NXP_STB225
	bool "NXP 225 board"
	select SOC_PNX833X
	select SOC_PNX8335
	help
	 Support for NXP Semiconductors STB225 Development Board.

config PMC_MSP
	bool "PMC-Sierra MSP chipsets"
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select SWAP_IO_SPACE
	select NO_EXCEPT_FILL
	select BOOT_RAW
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select IRQ_CPU
	select SERIAL_8250
	select SERIAL_8250_CONSOLE
	select USB_EHCI_BIG_ENDIAN_MMIO
	select USB_EHCI_BIG_ENDIAN_DESC
	help
	  This adds support for the PMC-Sierra family of Multi-Service
	  Processor System-On-A-Chips.  These parts include a number
	  of integrated peripherals, interfaces and DSPs in addition to
	  a variety of MIPS cores.

config RALINK
	bool "Ralink based machines"
	select CEVT_R4K
	select CSRC_R4K
	select BOOT_RAW
	select DMA_NONCOHERENT
	select IRQ_CPU
	select USE_OF
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select SYS_HAS_EARLY_PRINTK
	select HAVE_MACH_CLKDEV
	select CLKDEV_LOOKUP
	select ARCH_HAS_RESET_CONTROLLER
	select RESET_CONTROLLER

config SGI_IP22
	bool "SGI IP22 (Indy/Indigo2)"
	select FW_ARC
	select FW_ARC32
	select BOOT_ELF32
	select CEVT_R4K
	select CSRC_R4K
	select DEFAULT_SGI_PARTITION
	select DMA_NONCOHERENT
	select HW_HAS_EISA
	select I8253
	select I8259
	select IP22_CPU_SCACHE
	select IRQ_CPU
	select GENERIC_ISA_DMA_SUPPORT_BROKEN
	select SGI_HAS_I8042
	select SGI_HAS_INDYDOG
	select SGI_HAS_HAL2
	select SGI_HAS_SEEQ
	select SGI_HAS_WD93
	select SGI_HAS_ZILOG
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_R4X00
	select SYS_HAS_CPU_R5000
	#
	# Disable EARLY_PRINTK for now since it leads to overwritten prom
	# memory during early boot on some machines.
	#
	# See http://www.linux-mips.org/cgi-bin/mesg.cgi?a=linux-mips&i=20091119164009.GA15038%40deprecation.cyrius.com
	# for a more details discussion
	#
	# select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select MIPS_L1_CACHE_SHIFT_7
	help
	  This are the SGI Indy, Challenge S and Indigo2, as well as certain
	  OEM variants like the Tandem CMN B006S. To compile a Linux kernel
	  that runs on these, say Y here.

config SGI_IP27
	bool "SGI IP27 (Origin200/2000)"
	select FW_ARC
	select FW_ARC64
	select BOOT_ELF64
	select DEFAULT_SGI_PARTITION
	select DMA_COHERENT
	select SYS_HAS_EARLY_PRINTK
	select HW_HAS_PCI
	select NR_CPUS_DEFAULT_64
	select SYS_HAS_CPU_R10000
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_NUMA
	select SYS_SUPPORTS_SMP
	select MIPS_L1_CACHE_SHIFT_7
	help
	  This are the SGI Origin 200, Origin 2000 and Onyx 2 Graphics
	  workstations.  To compile a Linux kernel that runs on these, say Y
	  here.

config SGI_IP28
	bool "SGI IP28 (Indigo2 R10k)"
	select FW_ARC
	select FW_ARC64
	select BOOT_ELF64
	select CEVT_R4K
	select CSRC_R4K
	select DEFAULT_SGI_PARTITION
	select DMA_NONCOHERENT
	select GENERIC_ISA_DMA_SUPPORT_BROKEN
	select IRQ_CPU
	select HW_HAS_EISA
	select I8253
	select I8259
	select SGI_HAS_I8042
	select SGI_HAS_INDYDOG
	select SGI_HAS_HAL2
	select SGI_HAS_SEEQ
	select SGI_HAS_WD93
	select SGI_HAS_ZILOG
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_R10000
	#
	# Disable EARLY_PRINTK for now since it leads to overwritten prom
	# memory during early boot on some machines.
	#
	# See http://www.linux-mips.org/cgi-bin/mesg.cgi?a=linux-mips&i=20091119164009.GA15038%40deprecation.cyrius.com
	# for a more details discussion
	#
	# select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select MIPS_L1_CACHE_SHIFT_7
      help
        This is the SGI Indigo2 with R10000 processor.  To compile a Linux
        kernel that runs on these, say Y here.

config SGI_IP32
	bool "SGI IP32 (O2)"
	select FW_ARC
	select FW_ARC32
	select BOOT_ELF32
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select HW_HAS_PCI
	select IRQ_CPU
	select R5000_CPU_SCACHE
	select RM7000_CPU_SCACHE
	select SYS_HAS_CPU_R5000
	select SYS_HAS_CPU_R10000 if BROKEN
	select SYS_HAS_CPU_RM7000
	select SYS_HAS_CPU_NEVADA
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	help
	  If you want this kernel to run on SGI O2 workstation, say Y here.

config SIBYTE_CRHINE
	bool "Sibyte BCM91120C-CRhine"
	select BOOT_ELF32
	select DMA_COHERENT
	select SIBYTE_BCM1120
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_CARMEL
	bool "Sibyte BCM91120x-Carmel"
	select BOOT_ELF32
	select DMA_COHERENT
	select SIBYTE_BCM1120
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_CRHONE
	bool "Sibyte BCM91125C-CRhone"
	select BOOT_ELF32
	select DMA_COHERENT
	select SIBYTE_BCM1125
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_RHONE
	bool "Sibyte BCM91125E-Rhone"
	select BOOT_ELF32
	select DMA_COHERENT
	select SIBYTE_BCM1125H
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_SWARM
	bool "Sibyte BCM91250A-SWARM"
	select BOOT_ELF32
	select DMA_COHERENT
	select HAVE_PATA_PLATFORM
	select SIBYTE_SB1250
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select ZONE_DMA32 if 64BIT

config SIBYTE_LITTLESUR
	bool "Sibyte BCM91250C2-LittleSur"
	select BOOT_ELF32
	select DMA_COHERENT
	select HAVE_PATA_PLATFORM
	select SIBYTE_SB1250
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_SENTOSA
	bool "Sibyte BCM91250E-Sentosa"
	select BOOT_ELF32
	select DMA_COHERENT
	select SIBYTE_SB1250
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN

config SIBYTE_BIGSUR
	bool "Sibyte BCM91480B-BigSur"
	select BOOT_ELF32
	select DMA_COHERENT
	select NR_CPUS_DEFAULT_4
	select SIBYTE_BCM1x80
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_SB1
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select ZONE_DMA32 if 64BIT

config SNI_RM
	bool "SNI RM200/300/400"
	select FW_ARC if CPU_LITTLE_ENDIAN
	select FW_ARC32 if CPU_LITTLE_ENDIAN
	select FW_SNIPROM if CPU_BIG_ENDIAN
	select ARCH_MAY_HAVE_PC_FDC
	select BOOT_ELF32
	select CEVT_R4K
	select CSRC_R4K
	select DEFAULT_SGI_PARTITION if CPU_BIG_ENDIAN
	select DMA_NONCOHERENT
	select GENERIC_ISA_DMA
	select HAVE_PCSPKR_PLATFORM
	select HW_HAS_EISA
	select HW_HAS_PCI
	select IRQ_CPU
	select I8253
	select I8259
	select ISA
	select SWAP_IO_SPACE if CPU_BIG_ENDIAN
	select SYS_HAS_CPU_R4X00
	select SYS_HAS_CPU_R5000
	select SYS_HAS_CPU_R10000
	select R5000_CPU_SCACHE
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select SYS_SUPPORTS_LITTLE_ENDIAN
	help
	  The SNI RM200/300/400 are MIPS-based machines manufactured by
	  Siemens Nixdorf Informationssysteme (SNI), parent company of Pyramid
	  Technology and now in turn merged with Fujitsu.  Say Y here to
	  support this machine type.

config MACH_TX39XX
	bool "Toshiba TX39 series based machines"

config MACH_TX49XX
	bool "Toshiba TX49 series based machines"

config MIKROTIK_RB532
	bool "Mikrotik RB532 boards"
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select HW_HAS_PCI
	select IRQ_CPU
	select SYS_HAS_CPU_MIPS32_R1
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SWAP_IO_SPACE
	select BOOT_RAW
	select ARCH_REQUIRE_GPIOLIB
	select MIPS_L1_CACHE_SHIFT_4
	help
	  Support the Mikrotik(tm) RouterBoard 532 series,
	  based on the IDT RC32434 SoC.

config CAVIUM_OCTEON_SOC
	bool "Cavium Networks Octeon SoC based boards"
	select CEVT_R4K
	select ARCH_PHYS_ADDR_T_64BIT
	select DMA_COHERENT
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select EDAC_SUPPORT
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_HOTPLUG_CPU if CPU_BIG_ENDIAN
	select SYS_HAS_EARLY_PRINTK
	select SYS_HAS_CPU_CAVIUM_OCTEON
	select SWAP_IO_SPACE
	select HW_HAS_PCI
	select ZONE_DMA32
	select HOLES_IN_ZONE
	select ARCH_REQUIRE_GPIOLIB
	select LIBFDT
	select USE_OF
	select ARCH_SPARSEMEM_ENABLE
	select SYS_SUPPORTS_SMP
	select NR_CPUS_DEFAULT_16
	select BUILTIN_DTB
	select MTD_COMPLEX_MAPPINGS
	help
	  This option supports all of the Octeon reference boards from Cavium
	  Networks. It builds a kernel that dynamically determines the Octeon
	  CPU type and supports all known board reference implementations.
	  Some of the supported boards are:
		EBT3000
		EBH3000
		EBH3100
		Thunder
		Kodama
		Hikari
	  Say Y here for most Octeon reference boards.

config NLM_XLR_BOARD
	bool "Netlogic XLR/XLS based systems"
	select BOOT_ELF32
	select NLM_COMMON
	select SYS_HAS_CPU_XLR
	select SYS_SUPPORTS_SMP
	select HW_HAS_PCI
	select SWAP_IO_SPACE
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select ARCH_PHYS_ADDR_T_64BIT
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select DMA_COHERENT
	select NR_CPUS_DEFAULT_32
	select CEVT_R4K
	select CSRC_R4K
	select IRQ_CPU
	select ZONE_DMA32 if 64BIT
	select SYNC_R4K
	select SYS_HAS_EARLY_PRINTK
	select SYS_SUPPORTS_ZBOOT
	select SYS_SUPPORTS_ZBOOT_UART16550
	help
	  Support for systems based on Netlogic XLR and XLS processors.
	  Say Y here if you have a XLR or XLS based board.

config NLM_XLP_BOARD
	bool "Netlogic XLP based systems"
	select BOOT_ELF32
	select NLM_COMMON
	select SYS_HAS_CPU_XLP
	select SYS_SUPPORTS_SMP
	select HW_HAS_PCI
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select ARCH_PHYS_ADDR_T_64BIT
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_HIGHMEM
	select DMA_COHERENT
	select NR_CPUS_DEFAULT_32
	select CEVT_R4K
	select CSRC_R4K
	select IRQ_CPU
	select ZONE_DMA32 if 64BIT
	select SYNC_R4K
	select SYS_HAS_EARLY_PRINTK
	select USE_OF
	select SYS_SUPPORTS_ZBOOT
	select SYS_SUPPORTS_ZBOOT_UART16550
	help
	  This board is based on Netlogic XLP Processor.
	  Say Y here if you have a XLP based board.

config MIPS_PARAVIRT
	bool "Para-Virtualized guest system"
	select CEVT_R4K
	select CSRC_R4K
	select DMA_COHERENT
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_SMP
	select NR_CPUS_DEFAULT_4
	select SYS_HAS_EARLY_PRINTK
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_HAS_CPU_MIPS64_R2
	select SYS_HAS_CPU_CAVIUM_OCTEON
	select HW_HAS_PCI
	select SWAP_IO_SPACE
	help
	  This option supports guest running under ????

endchoice

source "arch/mips/alchemy/Kconfig"
source "arch/mips/ath25/Kconfig"
source "arch/mips/ath79/Kconfig"
source "arch/mips/bcm47xx/Kconfig"
source "arch/mips/bcm63xx/Kconfig"
source "arch/mips/bmips/Kconfig"
source "arch/mips/jazz/Kconfig"
source "arch/mips/jz4740/Kconfig"
source "arch/mips/lantiq/Kconfig"
source "arch/mips/lasat/Kconfig"
source "arch/mips/pmcs-msp71xx/Kconfig"
source "arch/mips/ralink/Kconfig"
source "arch/mips/sgi-ip27/Kconfig"
source "arch/mips/sibyte/Kconfig"
source "arch/mips/txx9/Kconfig"
source "arch/mips/vr41xx/Kconfig"
source "arch/mips/cavium-octeon/Kconfig"
source "arch/mips/loongson/Kconfig"
source "arch/mips/loongson1/Kconfig"
source "arch/mips/netlogic/Kconfig"
source "arch/mips/paravirt/Kconfig"

endmenu

config RWSEM_GENERIC_SPINLOCK
	bool
	default y

config RWSEM_XCHGADD_ALGORITHM
	bool

config ARCH_HAS_ILOG2_U32
	bool
	default n

config ARCH_HAS_ILOG2_U64
	bool
	default n

config GENERIC_HWEIGHT
	bool
	default y

config GENERIC_CALIBRATE_DELAY
	bool
	default y

config SCHED_OMIT_FRAME_POINTER
	bool
	default y

#
# Select some configuration options automatically based on user selections.
#
config FW_ARC
	bool

config ARCH_MAY_HAVE_PC_FDC
	bool

config BOOT_RAW
	bool

config CEVT_BCM1480
	bool

config CEVT_DS1287
	bool

config CEVT_GT641XX
	bool

config CEVT_R4K
	bool

config CEVT_SB1250
	bool

config CEVT_TXX9
	bool

config CSRC_BCM1480
	bool

config CSRC_IOASIC
	bool

config CSRC_R4K
	bool

config CSRC_SB1250
	bool

config GPIO_TXX9
	select ARCH_REQUIRE_GPIOLIB
	bool

config FW_CFE
	bool

config ARCH_DMA_ADDR_T_64BIT
	def_bool (HIGHMEM && ARCH_PHYS_ADDR_T_64BIT) || 64BIT

config DMA_MAYBE_COHERENT
	select DMA_NONCOHERENT
	bool

config DMA_COHERENT
	bool

config DMA_NONCOHERENT
	bool
	select NEED_DMA_MAP_STATE

config NEED_DMA_MAP_STATE
	bool

config SYS_HAS_EARLY_PRINTK
	bool

config HOTPLUG_CPU
	bool "Support for hot-pluggable CPUs"
	depends on SMP && SYS_SUPPORTS_HOTPLUG_CPU
	help
	  Say Y here to allow turning CPUs off and on. CPUs can be
	  controlled through /sys/devices/system/cpu.
	  (Note: power management support will enable this option
	    automatically on SMP systems. )
	  Say N if you want to disable CPU hotplug.

config SYS_SUPPORTS_HOTPLUG_CPU
	bool

config I8259
	bool
	select IRQ_DOMAIN

config MIPS_BONITO64
	bool

config MIPS_MSC
	bool

config MIPS_NILE4
	bool

config SYNC_R4K
	bool

config MIPS_MACHINE
	def_bool n

config NO_IOPORT_MAP
	def_bool n

config GENERIC_CSUM
	bool

config GENERIC_ISA_DMA
	bool
	select ZONE_DMA if GENERIC_ISA_DMA_SUPPORT_BROKEN=n
	select ISA_DMA_API

config GENERIC_ISA_DMA_SUPPORT_BROKEN
	bool
	select GENERIC_ISA_DMA

config ISA_DMA_API
	bool

config HOLES_IN_ZONE
	bool

#
# Endianness selection.  Sufficiently obscure so many users don't know what to
# answer,so we try hard to limit the available choices.  Also the use of a
# choice statement should be more obvious to the user.
#
choice
	prompt "Endianness selection"
	help
	  Some MIPS machines can be configured for either little or big endian
	  byte order. These modes require different kernels and a different
	  Linux distribution.  In general there is one preferred byteorder for a
	  particular system but some systems are just as commonly used in the
	  one or the other endianness.

config CPU_BIG_ENDIAN
	bool "Big endian"
	depends on SYS_SUPPORTS_BIG_ENDIAN

config CPU_LITTLE_ENDIAN
	bool "Little endian"
	depends on SYS_SUPPORTS_LITTLE_ENDIAN

endchoice

config EXPORT_UASM
	bool

config SYS_SUPPORTS_APM_EMULATION
	bool

config SYS_SUPPORTS_BIG_ENDIAN
	bool

config SYS_SUPPORTS_LITTLE_ENDIAN
	bool

config SYS_SUPPORTS_HUGETLBFS
	bool
	depends on CPU_SUPPORTS_HUGEPAGES && 64BIT
	default y

config MIPS_HUGE_TLB_SUPPORT
	def_bool HUGETLB_PAGE || TRANSPARENT_HUGEPAGE

config IRQ_CPU
	bool
	select IRQ_DOMAIN

config IRQ_CPU_RM7K
	bool

config IRQ_MSP_SLP
	bool

config IRQ_MSP_CIC
	bool

config IRQ_TXX9
	bool

config IRQ_GT641XX
	bool

config PCI_GT64XXX_PCI0
	bool

config NO_EXCEPT_FILL
	bool

config SOC_EMMA2RH
	bool
	select CEVT_R4K
	select CSRC_R4K
	select DMA_NONCOHERENT
	select IRQ_CPU
	select SWAP_IO_SPACE
	select SYS_HAS_CPU_R5500
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_64BIT_KERNEL
	select SYS_SUPPORTS_BIG_ENDIAN

config SOC_PNX833X
	bool
	select CEVT_R4K
	select CSRC_R4K
	select IRQ_CPU
	select DMA_NONCOHERENT
	select SYS_HAS_CPU_MIPS32_R2
	select SYS_SUPPORTS_32BIT_KERNEL
	select SYS_SUPPORTS_LITTLE_ENDIAN
	select SYS_SUPPORTS_BIG_ENDIAN
	select SYS_SUPPORTS_MIPS16
	select CPU_MIPSR2_IRQ_VI

config SOC_PNX8335
	bool
	select SOC_PNX833X

config MIPS_SPRAM
	bool

config SWAP_IO_SPACE
	bool

config SGI_HAS_INDYDOG
	bool

config SGI_HAS_HAL2
	bool

config SGI_HAS_SEEQ
	bool

config SGI_HAS_WD93
	bool

config SGI_HAS_ZILOG
	bool

config SGI_HAS_I8042
	bool

config DEFAULT_SGI_PARTITION
	bool

config FW_ARC32
	bool

config FW_SNIPROM
	bool

config BOOT_ELF32
	bool

config MIPS_L1_CACHE_SHIFT_4
	bool

config MIPS_L1_CACHE_SHIFT_5
	bool

config MIPS_L1_CACHE_SHIFT_6
	bool

config MIPS_L1_CACHE_SHIFT_7
	bool

config MIPS_L1_CACHE_SHIFT
	int
	default "7" if MIPS_L1_CACHE_SHIFT_7
	default "6" if MIPS_L1_CACHE_SHIFT_6
	default "5" if MIPS_L1_CACHE_SHIFT_5
	default "4" if MIPS_L1_CACHE_SHIFT_4
	default "5"

config HAVE_STD_PC_SERIAL_PORT
	bool

config ARC_CONSOLE
	bool "ARC console support"
	depends on SGI_IP22 || SGI_IP28 || (SNI_RM && CPU_LITTLE_ENDIAN)

config ARC_MEMORY
	bool
	depends on MACH_JAZZ || SNI_RM || SGI_IP32
	default y

config ARC_PROMLIB
	bool
	depends on MACH_JAZZ || SNI_RM || SGI_IP22 || SGI_IP28 || SGI_IP32
	default y

config FW_ARC64
	bool

config BOOT_ELF64
	bool

menu "CPU selection"

choice
	prompt "CPU type"
	default CPU_R4X00

config CPU_LOONGSON3
	bool "Loongson 3 CPU"
	depends on SYS_HAS_CPU_LOONGSON3
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	select WEAK_ORDERING
	select WEAK_REORDERING_BEYOND_LLSC
	select ARCH_REQUIRE_GPIOLIB
	help
		The Loongson 3 processor implements the MIPS64R2 instruction
		set with many extensions.

config CPU_LOONGSON2E
	bool "Loongson 2E"
	depends on SYS_HAS_CPU_LOONGSON2E
	select CPU_LOONGSON2
	help
	  The Loongson 2E processor implements the MIPS III instruction set
	  with many extensions.

	  It has an internal FPGA northbridge, which is compatible to
	  bonito64.

config CPU_LOONGSON2F
	bool "Loongson 2F"
	depends on SYS_HAS_CPU_LOONGSON2F
	select CPU_LOONGSON2
	select ARCH_REQUIRE_GPIOLIB
	help
	  The Loongson 2F processor implements the MIPS III instruction set
	  with many extensions.

	  Loongson2F have built-in DDR2 and PCIX controller. The PCIX controller
	  have a similar programming interface with FPGA northbridge used in
	  Loongson2E.

config CPU_LOONGSON1B
	bool "Loongson 1B"
	depends on SYS_HAS_CPU_LOONGSON1B
	select CPU_LOONGSON1
	help
	  The Loongson 1B is a 32-bit SoC, which implements the MIPS32
	  release 2 instruction set.

config CPU_MIPS32_R1
	bool "MIPS32 Release 1"
	depends on SYS_HAS_CPU_MIPS32_R1
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	help
	  Choose this option to build a kernel for release 1 or later of the
	  MIPS32 architecture.  Most modern embedded systems with a 32-bit
	  MIPS processor are based on a MIPS32 processor.  If you know the
	  specific type of processor in your system, choose those that one
	  otherwise CPU_MIPS32_R1 is a safe bet for any MIPS32 system.
	  Release 2 of the MIPS32 architecture is available since several
	  years so chances are you even have a MIPS32 Release 2 processor
	  in which case you should choose CPU_MIPS32_R2 instead for better
	  performance.

config CPU_MIPS32_R2
	bool "MIPS32 Release 2"
	depends on SYS_HAS_CPU_MIPS32_R2
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_MSA
	select HAVE_KVM
	help
	  Choose this option to build a kernel for release 2 or later of the
	  MIPS32 architecture.  Most modern embedded systems with a 32-bit
	  MIPS processor are based on a MIPS32 processor.  If you know the
	  specific type of processor in your system, choose those that one
	  otherwise CPU_MIPS32_R1 is a safe bet for any MIPS32 system.

config CPU_MIPS32_R6
	bool "MIPS32 Release 6 (EXPERIMENTAL)"
	depends on SYS_HAS_CPU_MIPS32_R6
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_MSA
	select GENERIC_CSUM
	select HAVE_KVM
	select MIPS_O32_FP64_SUPPORT
	help
	  Choose this option to build a kernel for release 6 or later of the
	  MIPS32 architecture.  New MIPS processors, starting with the Warrior
	  family, are based on a MIPS32r6 processor. If you own an older
	  processor, you probably need to select MIPS32r1 or MIPS32r2 instead.

config CPU_MIPS64_R1
	bool "MIPS64 Release 1"
	depends on SYS_HAS_CPU_MIPS64_R1
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	help
	  Choose this option to build a kernel for release 1 or later of the
	  MIPS64 architecture.  Many modern embedded systems with a 64-bit
	  MIPS processor are based on a MIPS64 processor.  If you know the
	  specific type of processor in your system, choose those that one
	  otherwise CPU_MIPS64_R1 is a safe bet for any MIPS64 system.
	  Release 2 of the MIPS64 architecture is available since several
	  years so chances are you even have a MIPS64 Release 2 processor
	  in which case you should choose CPU_MIPS64_R2 instead for better
	  performance.

config CPU_MIPS64_R2
	bool "MIPS64 Release 2"
	depends on SYS_HAS_CPU_MIPS64_R2
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	select CPU_SUPPORTS_MSA
	help
	  Choose this option to build a kernel for release 2 or later of the
	  MIPS64 architecture.  Many modern embedded systems with a 64-bit
	  MIPS processor are based on a MIPS64 processor.  If you know the
	  specific type of processor in your system, choose those that one
	  otherwise CPU_MIPS64_R1 is a safe bet for any MIPS64 system.

config CPU_MIPS64_R6
	bool "MIPS64 Release 6 (EXPERIMENTAL)"
	depends on SYS_HAS_CPU_MIPS64_R6
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_MSA
	select GENERIC_CSUM
	select MIPS_O32_FP64_SUPPORT if MIPS32_O32
	help
	  Choose this option to build a kernel for release 6 or later of the
	  MIPS64 architecture.  New MIPS processors, starting with the Warrior
	  family, are based on a MIPS64r6 processor. If you own an older
	  processor, you probably need to select MIPS64r1 or MIPS64r2 instead.

config CPU_R3000
	bool "R3000"
	depends on SYS_HAS_CPU_R3000
	select CPU_HAS_WB
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	help
	  Please make sure to pick the right CPU type. Linux/MIPS is not
	  designed to be generic, i.e. Kernels compiled for R3000 CPUs will
	  *not* work on R4000 machines and vice versa.  However, since most
	  of the supported machines have an R4000 (or similar) CPU, R4x00
	  might be a safe bet.  If the resulting kernel does not work,
	  try to recompile with R3000.

config CPU_TX39XX
	bool "R39XX"
	depends on SYS_HAS_CPU_TX39XX
	select CPU_SUPPORTS_32BIT_KERNEL

config CPU_VR41XX
	bool "R41xx"
	depends on SYS_HAS_CPU_VR41XX
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	help
	  The options selects support for the NEC VR4100 series of processors.
	  Only choose this option if you have one of these processors as a
	  kernel built with this option will not run on any other type of
	  processor or vice versa.

config CPU_R4300
	bool "R4300"
	depends on SYS_HAS_CPU_R4300
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	help
	  MIPS Technologies R4300-series processors.

config CPU_R4X00
	bool "R4x00"
	depends on SYS_HAS_CPU_R4X00
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES
	help
	  MIPS Technologies R4000-series processors other than 4300, including
	  the R4000, R4400, R4600, and 4700.

config CPU_TX49XX
	bool "R49XX"
	depends on SYS_HAS_CPU_TX49XX
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES

config CPU_R5000
	bool "R5000"
	depends on SYS_HAS_CPU_R5000
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES
	help
	  MIPS Technologies R5000-series processors other than the Nevada.

config CPU_R5432
	bool "R5432"
	depends on SYS_HAS_CPU_R5432
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES

config CPU_R5500
	bool "R5500"
	depends on SYS_HAS_CPU_R5500
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES
	help
	  NEC VR5500 and VR5500A series processors implement 64-bit MIPS IV
	  instruction set.

config CPU_R6000
	bool "R6000"
	depends on SYS_HAS_CPU_R6000
	select CPU_SUPPORTS_32BIT_KERNEL
	help
	  MIPS Technologies R6000 and R6000A series processors.  Note these
	  processors are extremely rare and the support for them is incomplete.

config CPU_NEVADA
	bool "RM52xx"
	depends on SYS_HAS_CPU_NEVADA
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HUGEPAGES
	help
	  QED / PMC-Sierra RM52xx-series ("Nevada") processors.

config CPU_R8000
	bool "R8000"
	depends on SYS_HAS_CPU_R8000
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_64BIT_KERNEL
	help
	  MIPS Technologies R8000 processors.  Note these processors are
	  uncommon and the support for them is incomplete.

config CPU_R10000
	bool "R10000"
	depends on SYS_HAS_CPU_R10000
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	help
	  MIPS Technologies R10000-series processors.

config CPU_RM7000
	bool "RM7000"
	depends on SYS_HAS_CPU_RM7000
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES

config CPU_SB1
	bool "SB1"
	depends on SYS_HAS_CPU_SB1
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	select WEAK_ORDERING

config CPU_CAVIUM_OCTEON
	bool "Cavium Octeon processor"
	depends on SYS_HAS_CPU_CAVIUM_OCTEON
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_64BIT_KERNEL
	select WEAK_ORDERING
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	select USB_EHCI_BIG_ENDIAN_MMIO
	select MIPS_L1_CACHE_SHIFT_7
	help
	  The Cavium Octeon processor is a highly integrated chip containing
	  many ethernet hardware widgets for networking tasks. The processor
	  can have up to 16 Mips64v2 cores and 8 integrated gigabit ethernets.
	  Full details can be found at http://www.caviumnetworks.com.

config CPU_BMIPS
	bool "Broadcom BMIPS"
	depends on SYS_HAS_CPU_BMIPS
	select CPU_MIPS32
	select CPU_BMIPS32_3300 if SYS_HAS_CPU_BMIPS32_3300
	select CPU_BMIPS4350 if SYS_HAS_CPU_BMIPS4350
	select CPU_BMIPS4380 if SYS_HAS_CPU_BMIPS4380
	select CPU_BMIPS5000 if SYS_HAS_CPU_BMIPS5000
	select CPU_SUPPORTS_32BIT_KERNEL
	select DMA_NONCOHERENT
	select IRQ_CPU
	select SWAP_IO_SPACE
	select WEAK_ORDERING
	select CPU_SUPPORTS_HIGHMEM
	select CPU_HAS_PREFETCH
	help
	  Support for BMIPS32/3300/4350/4380 and BMIPS5000 processors.

config CPU_XLR
	bool "Netlogic XLR SoC"
	depends on SYS_HAS_CPU_XLR
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES
	select WEAK_ORDERING
	select WEAK_REORDERING_BEYOND_LLSC
	help
	  Netlogic Microsystems XLR/XLS processors.

config CPU_XLP
	bool "Netlogic XLP SoC"
	depends on SYS_HAS_CPU_XLP
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select WEAK_ORDERING
	select WEAK_REORDERING_BEYOND_LLSC
	select CPU_HAS_PREFETCH
	select CPU_MIPSR2
	select CPU_SUPPORTS_HUGEPAGES
	help
	  Netlogic Microsystems XLP processors.
endchoice

config CPU_MIPS32_3_5_FEATURES
	bool "MIPS32 Release 3.5 Features"
	depends on SYS_HAS_CPU_MIPS32_R3_5
	depends on CPU_MIPS32_R2 || CPU_MIPS32_R6
	help
	  Choose this option to build a kernel for release 2 or later of the
	  MIPS32 architecture including features from the 3.5 release such as
	  support for Enhanced Virtual Addressing (EVA).

config CPU_MIPS32_3_5_EVA
	bool "Enhanced Virtual Addressing (EVA)"
	depends on CPU_MIPS32_3_5_FEATURES
	select EVA
	default y
	help
	  Choose this option if you want to enable the Enhanced Virtual
	  Addressing (EVA) on your MIPS32 core (such as proAptiv).
	  One of its primary benefits is an increase in the maximum size
	  of lowmem (up to 3GB). If unsure, say 'N' here.

config CPU_MIPS32_R5_FEATURES
	bool "MIPS32 Release 5 Features"
	depends on SYS_HAS_CPU_MIPS32_R5
	depends on CPU_MIPS32_R2
	help
	  Choose this option to build a kernel for release 2 or later of the
	  MIPS32 architecture including features from release 5 such as
	  support for Extended Physical Addressing (XPA).

config CPU_MIPS32_R5_XPA
	bool "Extended Physical Addressing (XPA)"
	depends on CPU_MIPS32_R5_FEATURES
	depends on !EVA
	depends on !PAGE_SIZE_4KB
	depends on SYS_SUPPORTS_HIGHMEM
	select XPA
	select HIGHMEM
	select ARCH_PHYS_ADDR_T_64BIT
	default n
	help
	  Choose this option if you want to enable the Extended Physical
	  Addressing (XPA) on your MIPS32 core (such as P5600 series). The
	  benefit is to increase physical addressing equal to or greater
	  than 40 bits. Note that this has the side effect of turning on
	  64-bit addressing which in turn makes the PTEs 64-bit in size.
	  If unsure, say 'N' here.

if CPU_LOONGSON2F
config CPU_NOP_WORKAROUNDS
	bool

config CPU_JUMP_WORKAROUNDS
	bool

config CPU_LOONGSON2F_WORKAROUNDS
	bool "Loongson 2F Workarounds"
	default y
	select CPU_NOP_WORKAROUNDS
	select CPU_JUMP_WORKAROUNDS
	help
	  Loongson 2F01 / 2F02 processors have the NOP & JUMP issues which
	  require workarounds.  Without workarounds the system may hang
	  unexpectedly.  For more information please refer to the gas
	  -mfix-loongson2f-nop and -mfix-loongson2f-jump options.

	  Loongson 2F03 and later have fixed these issues and no workarounds
	  are needed.  The workarounds have no significant side effect on them
	  but may decrease the performance of the system so this option should
	  be disabled unless the kernel is intended to be run on 2F01 or 2F02
	  systems.

	  If unsure, please say Y.
endif # CPU_LOONGSON2F

config SYS_SUPPORTS_ZBOOT
	bool
	select HAVE_KERNEL_GZIP
	select HAVE_KERNEL_BZIP2
	select HAVE_KERNEL_LZ4
	select HAVE_KERNEL_LZMA
	select HAVE_KERNEL_LZO
	select HAVE_KERNEL_XZ

config SYS_SUPPORTS_ZBOOT_UART16550
	bool
	select SYS_SUPPORTS_ZBOOT

config CPU_LOONGSON2
	bool
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_64BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_HUGEPAGES

config CPU_LOONGSON1
	bool
	select CPU_MIPS32
	select CPU_MIPSR2
	select CPU_HAS_PREFETCH
	select CPU_SUPPORTS_32BIT_KERNEL
	select CPU_SUPPORTS_HIGHMEM
	select CPU_SUPPORTS_CPUFREQ

config CPU_BMIPS32_3300
	select SMP_UP if SMP
	bool

config CPU_BMIPS4350
	bool
	select SYS_SUPPORTS_SMP
	select SYS_SUPPORTS_HOTPLUG_CPU

config CPU_BMIPS4380
	bool
	select MIPS_L1_CACHE_SHIFT_6
	select SYS_SUPPORTS_SMP
	select SYS_SUPPORTS_HOTPLUG_CPU

config CPU_BMIPS5000
	bool
	select MIPS_CPU_SCACHE
	select MIPS_L1_CACHE_SHIFT_7
	select SYS_SUPPORTS_SMP
	select SYS_SUPPORTS_HOTPLUG_CPU

config SYS_HAS_CPU_LOONGSON3
	bool
	select CPU_SUPPORTS_CPUFREQ

config SYS_HAS_CPU_LOONGSON2E
	bool

config SYS_HAS_CPU_LOONGSON2F
	bool
	select CPU_SUPPORTS_CPUFREQ
	select CPU_SUPPORTS_ADDRWINCFG if 64BIT
	select CPU_SUPPORTS_UNCACHED_ACCELERATED

config SYS_HAS_CPU_LOONGSON1B
	bool

config SYS_HAS_CPU_MIPS32_R1
	bool

config SYS_HAS_CPU_MIPS32_R2
	bool

config SYS_HAS_CPU_MIPS32_R3_5
	bool

config SYS_HAS_CPU_MIPS32_R5
	bool

config SYS_HAS_CPU_MIPS32_R6
	bool

config SYS_HAS_CPU_MIPS64_R1
	bool

config SYS_HAS_CPU_MIPS64_R2
	bool

config SYS_HAS_CPU_MIPS64_R6
	bool

config SYS_HAS_CPU_R3000
	bool

config SYS_HAS_CPU_TX39XX
	bool

config SYS_HAS_CPU_VR41XX
	bool

config SYS_HAS_CPU_R4300
	bool

config SYS_HAS_CPU_R4X00
	bool

config SYS_HAS_CPU_TX49XX
	bool

config SYS_HAS_CPU_R5000
	bool

config SYS_HAS_CPU_R5432
	bool

config SYS_HAS_CPU_R5500
	bool

config SYS_HAS_CPU_R6000
	bool

config SYS_HAS_CPU_NEVADA
	bool

config SYS_HAS_CPU_R8000
	bool

config SYS_HAS_CPU_R10000
	bool

config SYS_HAS_CPU_RM7000
	bool

config SYS_HAS_CPU_SB1
	bool

config SYS_HAS_CPU_CAVIUM_OCTEON
	bool

config SYS_HAS_CPU_BMIPS
	bool

config SYS_HAS_CPU_BMIPS32_3300
	bool
	select SYS_HAS_CPU_BMIPS

config SYS_HAS_CPU_BMIPS4350
	bool
	select SYS_HAS_CPU_BMIPS

config SYS_HAS_CPU_BMIPS4380
	bool
	select SYS_HAS_CPU_BMIPS

config SYS_HAS_CPU_BMIPS5000
	bool
	select SYS_HAS_CPU_BMIPS

config SYS_HAS_CPU_XLR
	bool

config SYS_HAS_CPU_XLP
	bool

config MIPS_MALTA_PM
	depends on MIPS_MALTA
	depends on PCI
	bool
	default y

#
# CPU may reorder R->R, R->W, W->R, W->W
# Reordering beyond LL and SC is handled in WEAK_REORDERING_BEYOND_LLSC
#
config WEAK_ORDERING
	bool

#
# CPU may reorder reads and writes beyond LL/SC
# CPU may reorder R->LL, R->LL, W->LL, W->LL, R->SC, R->SC, W->SC, W->SC
#
config WEAK_REORDERING_BEYOND_LLSC
	bool
endmenu

#
# These two indicate any level of the MIPS32 and MIPS64 architecture
#
config CPU_MIPS32
	bool
	default y if CPU_MIPS32_R1 || CPU_MIPS32_R2 || CPU_MIPS32_R6

config CPU_MIPS64
	bool
	default y if CPU_MIPS64_R1 || CPU_MIPS64_R2 || CPU_MIPS64_R6

#
# These two indicate the revision of the architecture, either Release 1 or Release 2
#
config CPU_MIPSR1
	bool
	default y if CPU_MIPS32_R1 || CPU_MIPS64_R1

config CPU_MIPSR2
	bool
	default y if CPU_MIPS32_R2 || CPU_MIPS64_R2 || CPU_CAVIUM_OCTEON
	select MIPS_SPRAM

config CPU_MIPSR6
	bool
	default y if CPU_MIPS32_R6 || CPU_MIPS64_R6
	select MIPS_SPRAM

config EVA
	bool

config XPA
	bool

config SYS_SUPPORTS_32BIT_KERNEL
	bool
config SYS_SUPPORTS_64BIT_KERNEL
	bool
config CPU_SUPPORTS_32BIT_KERNEL
	bool
config CPU_SUPPORTS_64BIT_KERNEL
	bool
config CPU_SUPPORTS_CPUFREQ
	bool
config CPU_SUPPORTS_ADDRWINCFG
	bool
config CPU_SUPPORTS_HUGEPAGES
	bool
config CPU_SUPPORTS_UNCACHED_ACCELERATED
	bool
config MIPS_PGD_C0_CONTEXT
	bool
	default y if 64BIT && CPU_MIPSR2 && !CPU_XLP

#
# Set to y for ptrace access to watch registers.
#
config HARDWARE_WATCHPOINTS
       bool
       default y if CPU_MIPSR1 || CPU_MIPSR2

menu "Kernel type"

choice
	prompt "Kernel code model"
	help
	  You should only select this option if you have a workload that
	  actually benefits from 64-bit processing or if your machine has
	  large memory.  You will only be presented a single option in this
	  menu if your system does not support both 32-bit and 64-bit kernels.

config 32BIT
	bool "32-bit kernel"
	depends on CPU_SUPPORTS_32BIT_KERNEL && SYS_SUPPORTS_32BIT_KERNEL
	select TRAD_SIGNALS
	help
	  Select this option if you want to build a 32-bit kernel.
config 64BIT
	bool "64-bit kernel"
	depends on CPU_SUPPORTS_64BIT_KERNEL && SYS_SUPPORTS_64BIT_KERNEL
	help
	  Select this option if you want to build a 64-bit kernel.

endchoice

config KVM_GUEST
	bool "KVM Guest Kernel"
	depends on BROKEN_ON_SMP
	help
	  Select this option if building a guest kernel for KVM (Trap & Emulate) mode

config KVM_GUEST_TIMER_FREQ
	int "Count/Compare Timer Frequency (MHz)"
	depends on KVM_GUEST
	default 100
	help
	  Set this to non-zero if building a guest kernel for KVM to skip RTC
	  emulation when determining guest CPU Frequency. Instead, the guest's
	  timer frequency is specified directly.

choice
	prompt "Kernel page size"
	default PAGE_SIZE_4KB

config PAGE_SIZE_4KB
	bool "4kB"
	depends on !CPU_LOONGSON2 && !CPU_LOONGSON3
	help
	 This option select the standard 4kB Linux page size.  On some
	 R3000-family processors this is the only available page size.  Using
	 4kB page size will minimize memory consumption and is therefore
	 recommended for low memory systems.

config PAGE_SIZE_8KB
	bool "8kB"
	depends on CPU_R8000 || CPU_CAVIUM_OCTEON
	help
	  Using 8kB page size will result in higher performance kernel at
	  the price of higher memory consumption.  This option is available
	  only on R8000 and cnMIPS processors.  Note that you will need a
	  suitable Linux distribution to support this.

config PAGE_SIZE_16KB
	bool "16kB"
	depends on !CPU_R3000 && !CPU_TX39XX
	help
	  Using 16kB page size will result in higher performance kernel at
	  the price of higher memory consumption.  This option is available on
	  all non-R3000 family processors.  Note that you will need a suitable
	  Linux distribution to support this.

config PAGE_SIZE_32KB
	bool "32kB"
	depends on CPU_CAVIUM_OCTEON
	help
	  Using 32kB page size will result in higher performance kernel at
	  the price of higher memory consumption.  This option is available
	  only on cnMIPS cores.  Note that you will need a suitable Linux
	  distribution to support this.

config PAGE_SIZE_64KB
	bool "64kB"
	depends on !CPU_R3000 && !CPU_TX39XX
	help
	  Using 64kB page size will result in higher performance kernel at
	  the price of higher memory consumption.  This option is available on
	  all non-R3000 family processor.  Not that at the time of this
	  writing this option is still high experimental.

endchoice

config FORCE_MAX_ZONEORDER
	int "Maximum zone order"
	range 14 64 if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_64KB
	default "14" if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_64KB
	range 13 64 if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_32KB
	default "13" if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_32KB
	range 12 64 if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_16KB
	default "12" if MIPS_HUGE_TLB_SUPPORT && PAGE_SIZE_16KB
	range 11 64
	default "11"
	help
	  The kernel memory allocator divides physically contiguous memory
	  blocks into "zones", where each zone is a power of two number of
	  pages.  This option selects the largest power of two that the kernel
	  keeps in the memory allocator.  If you need to allocate very large
	  blocks of physically contiguous memory, then you may need to
	  increase this value.

	  This config option is actually maximum order plus one. For example,
	  a value of 11 means that the largest free memory block is 2^10 pages.

	  The page size is not necessarily 4KB.  Keep this in mind
	  when choosing a value for this option.

config BOARD_SCACHE
	bool

config IP22_CPU_SCACHE
	bool
	select BOARD_SCACHE

#
# Support for a MIPS32 / MIPS64 style S-caches
#
config MIPS_CPU_SCACHE
	bool
	select BOARD_SCACHE

config R5000_CPU_SCACHE
	bool
	select BOARD_SCACHE

config RM7000_CPU_SCACHE
	bool
	select BOARD_SCACHE

config SIBYTE_DMA_PAGEOPS
	bool "Use DMA to clear/copy pages"
	depends on CPU_SB1
	help
	  Instead of using the CPU to zero and copy pages, use a Data Mover
	  channel.  These DMA channels are otherwise unused by the standard
	  SiByte Linux port.  Seems to give a small performance benefit.

config CPU_HAS_PREFETCH
	bool

config CPU_GENERIC_DUMP_TLB
	bool
	default y if !(CPU_R3000 || CPU_R6000 || CPU_R8000 || CPU_TX39XX)

config CPU_R4K_FPU
	bool
	default y if !(CPU_R3000 || CPU_R6000 || CPU_TX39XX || CPU_CAVIUM_OCTEON)

config CPU_R4K_CACHE_TLB
	bool
	default y if !(CPU_R3000 || CPU_R8000 || CPU_SB1 || CPU_TX39XX || CPU_CAVIUM_OCTEON)

config MIPS_MT_SMP
	bool "MIPS MT SMP support (1 TC on each available VPE)"
	depends on SYS_SUPPORTS_MULTITHREADING && !CPU_MIPSR6
	select CPU_MIPSR2_IRQ_VI
	select CPU_MIPSR2_IRQ_EI
	select SYNC_R4K
	select MIPS_GIC_IPI if MIPS_GIC
	select MIPS_MT
	select SMP
	select SMP_UP
	select SYS_SUPPORTS_SMP
	select SYS_SUPPORTS_SCHED_SMT
	select MIPS_PERF_SHARED_TC_COUNTERS
	help
	  This is a kernel model which is known as SMVP. This is supported
	  on cores with the MT ASE and uses the available VPEs to implement
	  virtual processors which supports SMP. This is equivalent to the
	  Intel Hyperthreading feature. For further information go to
	  <http://www.imgtec.com/mips/mips-multithreading.asp>.

config MIPS_MT
	bool

config SCHED_SMT
	bool "SMT (multithreading) scheduler support"
	depends on SYS_SUPPORTS_SCHED_SMT
	default n
	help
	  SMT scheduler support improves the CPU scheduler's decision making
	  when dealing with MIPS MT enabled cores at a cost of slightly
	  increased overhead in some places. If unsure say N here.

config SYS_SUPPORTS_SCHED_SMT
	bool

config SYS_SUPPORTS_MULTITHREADING
	bool

config MIPS_MT_FPAFF
	bool "Dynamic FPU affinity for FP-intensive threads"
	default y
	depends on MIPS_MT_SMP

config MIPSR2_TO_R6_EMULATOR
	bool "MIPS R2-to-R6 emulator"
	depends on CPU_MIPSR6 && !SMP
	default y
	help
	  Choose this option if you want to run non-R6 MIPS userland code.
	  Even if you say 'Y' here, the emulator will still be disabled by
	  default. You can enable it using the 'mipsr2emu' kernel option.
	  The only reason this is a build-time option is to save ~14K from the
	  final kernel image.
comment "MIPS R2-to-R6 emulator is only available for UP kernels"
	depends on SMP && CPU_MIPSR6

config MIPS_VPE_LOADER
	bool "VPE loader support."
	depends on SYS_SUPPORTS_MULTITHREADING && MODULES
	select CPU_MIPSR2_IRQ_VI
	select CPU_MIPSR2_IRQ_EI
	select MIPS_MT
	help
	  Includes a loader for loading an elf relocatable object
	  onto another VPE and running it.

config MIPS_VPE_LOADER_CMP
	bool
	default "y"
	depends on MIPS_VPE_LOADER && MIPS_CMP

config MIPS_VPE_LOADER_MT
	bool
	default "y"
	depends on MIPS_VPE_LOADER && !MIPS_CMP

config MIPS_VPE_LOADER_TOM
	bool "Load VPE program into memory hidden from linux"
	depends on MIPS_VPE_LOADER
	default y
	help
	  The loader can use memory that is present but has been hidden from
	  Linux using the kernel command line option "mem=xxMB". It's up to
	  you to ensure the amount you put in the option and the space your
	  program requires is less or equal to the amount physically present.

config MIPS_VPE_APSP_API
	bool "Enable support for AP/SP API (RTLX)"
	depends on MIPS_VPE_LOADER
	help

config MIPS_VPE_APSP_API_CMP
	bool
	default "y"
	depends on MIPS_VPE_APSP_API && MIPS_CMP

config MIPS_VPE_APSP_API_MT
	bool
	default "y"
	depends on MIPS_VPE_APSP_API && !MIPS_CMP

config MIPS_CMP
	bool "MIPS CMP framework support (DEPRECATED)"
	depends on SYS_SUPPORTS_MIPS_CMP && !CPU_MIPSR6
	select MIPS_GIC_IPI if MIPS_GIC
	select SMP
	select SYNC_R4K
	select SYS_SUPPORTS_SMP
	select WEAK_ORDERING
	default n
	help
	  Select this if you are using a bootloader which implements the "CMP
	  framework" protocol (ie. YAMON) and want your kernel to make use of
	  its ability to start secondary CPUs.

	  Unless you have a specific need, you should use CONFIG_MIPS_CPS
	  instead of this.

config MIPS_CPS
	bool "MIPS Coherent Processing System support"
	depends on SYS_SUPPORTS_MIPS_CPS && !CPU_MIPSR6
	select MIPS_CM
	select MIPS_CPC
	select MIPS_CPS_PM if HOTPLUG_CPU
	select MIPS_GIC_IPI if MIPS_GIC
	select SMP
	select SYNC_R4K if (CEVT_R4K || CSRC_R4K)
	select SYS_SUPPORTS_HOTPLUG_CPU
	select SYS_SUPPORTS_SMP
	select WEAK_ORDERING
	help
	  Select this if you wish to run an SMP kernel across multiple cores
	  within a MIPS Coherent Processing System. When this option is
	  enabled the kernel will probe for other cores and boot them with
	  no external assistance. It is safe to enable this when hardware
	  support is unavailable.

config MIPS_CPS_PM
	depends on MIPS_CPS
	select MIPS_CPC
	bool

config MIPS_GIC_IPI
	depends on MIPS_GIC
	bool

config MIPS_CM
	bool

config MIPS_CPC
	bool

config SB1_PASS_1_WORKAROUNDS
	bool
	depends on CPU_SB1_PASS_1
	default y

config SB1_PASS_2_WORKAROUNDS
	bool
	depends on CPU_SB1 && (CPU_SB1_PASS_2_2 || CPU_SB1_PASS_2)
	default y

config SB1_PASS_2_1_WORKAROUNDS
	bool
	depends on CPU_SB1 && CPU_SB1_PASS_2
	default y


config ARCH_PHYS_ADDR_T_64BIT
       bool

choice
	prompt "SmartMIPS or microMIPS ASE support"

config CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS
	bool "None"
	help
	  Select this if you want neither microMIPS nor SmartMIPS support

config CPU_HAS_SMARTMIPS
	depends on SYS_SUPPORTS_SMARTMIPS
	bool "SmartMIPS"
	help
	  SmartMIPS is a extension of the MIPS32 architecture aimed at
	  increased security at both hardware and software level for
	  smartcards.  Enabling this option will allow proper use of the
	  SmartMIPS instructions by Linux applications.  However a kernel with
	  this option will not work on a MIPS core without SmartMIPS core.  If
	  you don't know you probably don't have SmartMIPS and should say N
	  here.

config CPU_MICROMIPS
	depends on 32BIT && SYS_SUPPORTS_MICROMIPS && !CPU_MIPSR6
	bool "microMIPS"
	help
	  When this option is enabled the kernel will be built using the
	  microMIPS ISA

endchoice

config CPU_HAS_MSA
	bool "Support for the MIPS SIMD Architecture (EXPERIMENTAL)"
	depends on CPU_SUPPORTS_MSA
	depends on 64BIT || MIPS_O32_FP64_SUPPORT
	help
	  MIPS SIMD Architecture (MSA) introduces 128 bit wide vector registers
	  and a set of SIMD instructions to operate on them. When this option
	  is enabled the kernel will support allocating & switching MSA
	  vector register contexts. If you know that your kernel will only be
	  running on CPUs which do not support MSA or that your userland will
	  not be making use of it then you may wish to say N here to reduce
	  the size & complexity of your kernel.

	  If unsure, say Y.

config CPU_HAS_WB
	bool

config XKS01
	bool

#
# Vectored interrupt mode is an R2 feature
#
config CPU_MIPSR2_IRQ_VI
	bool

#
# Extended interrupt mode is an R2 feature
#
config CPU_MIPSR2_IRQ_EI
	bool

config CPU_HAS_SYNC
	bool
	depends on !CPU_R3000
	default y

#
# CPU non-features
#
config CPU_DADDI_WORKAROUNDS
	bool

config CPU_R4000_WORKAROUNDS
	bool
	select CPU_R4400_WORKAROUNDS

config CPU_R4400_WORKAROUNDS
	bool

#
# - Highmem only makes sense for the 32-bit kernel.
# - The current highmem code will only work properly on physically indexed
#   caches such as R3000, SB1, R7000 or those that look like they're virtually
#   indexed such as R4000/R4400 SC and MC versions or R10000.  So for the
#   moment we protect the user and offer the highmem option only on machines
#   where it's known to be safe.  This will not offer highmem on a few systems
#   such as MIPS32 and MIPS64 CPUs which may have virtual and physically
#   indexed CPUs but we're playing safe.
# - We use SYS_SUPPORTS_HIGHMEM to offer highmem only for systems where we
#   know they might have memory configurations that could make use of highmem
#   support.
#
config HIGHMEM
	bool "High Memory Support"
	depends on 32BIT && CPU_SUPPORTS_HIGHMEM && SYS_SUPPORTS_HIGHMEM && !CPU_MIPS32_3_5_EVA

config CPU_SUPPORTS_HIGHMEM
	bool

config SYS_SUPPORTS_HIGHMEM
	bool

config SYS_SUPPORTS_SMARTMIPS
	bool

config SYS_SUPPORTS_MICROMIPS
	bool

config SYS_SUPPORTS_MIPS16
	bool
	help
	  This option must be set if a kernel might be executed on a MIPS16-
	  enabled CPU even if MIPS16 is not actually being used.  In other
	  words, it makes the kernel MIPS16-tolerant.

config CPU_SUPPORTS_MSA
	bool

config ARCH_FLATMEM_ENABLE
	def_bool y
	depends on !NUMA && !CPU_LOONGSON2

config ARCH_DISCONTIGMEM_ENABLE
	bool
	default y if SGI_IP27
	help
	  Say Y to support efficient handling of discontiguous physical memory,
	  for architectures which are either NUMA (Non-Uniform Memory Access)
	  or have huge holes in the physical address space for other reasons.
	  See <file:Documentation/vm/numa> for more.

config ARCH_SPARSEMEM_ENABLE
	bool
	select SPARSEMEM_STATIC

config NUMA
	bool "NUMA Support"
	depends on SYS_SUPPORTS_NUMA
	help
	  Say Y to compile the kernel to support NUMA (Non-Uniform Memory
	  Access).  This option improves performance on systems with more
	  than two nodes; on two node systems it is generally better to
	  leave it disabled; on single node systems disable this option
	  disabled.

config SYS_SUPPORTS_NUMA
	bool

config NODES_SHIFT
	int
	default "6"
	depends on NEED_MULTIPLE_NODES

config HW_PERF_EVENTS
	bool "Enable hardware performance counter support for perf events"
	depends on PERF_EVENTS && OPROFILE=n && (CPU_MIPS32 || CPU_MIPS64 || CPU_R10000 || CPU_SB1 || CPU_CAVIUM_OCTEON || CPU_XLP || CPU_LOONGSON3)
	default y
	help
	  Enable hardware performance counter support for perf events. If
	  disabled, perf events will use software events only.

source "mm/Kconfig"

config SMP
	bool "Multi-Processing support"
	depends on SYS_SUPPORTS_SMP
	help
	  This enables support for systems with more than one CPU. If you have
	  a system with only one CPU, say N. If you have a system with more
	  than one CPU, say Y.

	  If you say N here, the kernel will run on uni- and multiprocessor
	  machines, but will use only one CPU of a multiprocessor machine. If
	  you say Y here, the kernel will run on many, but not all,
	  uniprocessor machines. On a uniprocessor machine, the kernel
	  will run faster if you say N here.

	  People using multiprocessor machines who say Y here should also say
	  Y to "Enhanced Real Time Clock Support", below.

	  See also the SMP-HOWTO available at
	  <http://www.tldp.org/docs.html#howto>.

	  If you don't know what to do here, say N.

config SMP_UP
	bool

config SYS_SUPPORTS_MIPS_CMP
	bool

config SYS_SUPPORTS_MIPS_CPS
	bool

config SYS_SUPPORTS_SMP
	bool

config NR_CPUS_DEFAULT_4
	bool

config NR_CPUS_DEFAULT_8
	bool

config NR_CPUS_DEFAULT_16
	bool

config NR_CPUS_DEFAULT_32
	bool

config NR_CPUS_DEFAULT_64
	bool

config NR_CPUS
	int "Maximum number of CPUs (2-256)"
	range 2 256
	depends on SMP
	default "4" if NR_CPUS_DEFAULT_4
	default "8" if NR_CPUS_DEFAULT_8
	default "16" if NR_CPUS_DEFAULT_16
	default "32" if NR_CPUS_DEFAULT_32
	default "64" if NR_CPUS_DEFAULT_64
	help
	  This allows you to specify the maximum number of CPUs which this
	  kernel will support.  The maximum supported value is 32 for 32-bit
	  kernel and 64 for 64-bit kernels; the minimum value which makes
	  sense is 1 for Qemu (useful only for kernel debugging purposes)
	  and 2 for all others.

	  This is purely to save memory - each supported CPU adds
	  approximately eight kilobytes to the kernel image.  For best
	  performance should round up your number of processors to the next
	  power of two.

config MIPS_PERF_SHARED_TC_COUNTERS
	bool

#
# Timer Interrupt Frequency Configuration
#

choice
	prompt "Timer frequency"
	default HZ_250
	help
	 Allows the configuration of the timer frequency.

	config HZ_48
		bool "48 HZ" if SYS_SUPPORTS_48HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_100
		bool "100 HZ" if SYS_SUPPORTS_100HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_128
		bool "128 HZ" if SYS_SUPPORTS_128HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_250
		bool "250 HZ" if SYS_SUPPORTS_250HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_256
		bool "256 HZ" if SYS_SUPPORTS_256HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_1000
		bool "1000 HZ" if SYS_SUPPORTS_1000HZ || SYS_SUPPORTS_ARBIT_HZ

	config HZ_1024
		bool "1024 HZ" if SYS_SUPPORTS_1024HZ || SYS_SUPPORTS_ARBIT_HZ

endchoice

config SYS_SUPPORTS_48HZ
	bool

config SYS_SUPPORTS_100HZ
	bool

config SYS_SUPPORTS_128HZ
	bool

config SYS_SUPPORTS_250HZ
	bool

config SYS_SUPPORTS_256HZ
	bool

config SYS_SUPPORTS_1000HZ
	bool

config SYS_SUPPORTS_1024HZ
	bool

config SYS_SUPPORTS_ARBIT_HZ
	bool
	default y if !SYS_SUPPORTS_48HZ && !SYS_SUPPORTS_100HZ && \
		     !SYS_SUPPORTS_128HZ && !SYS_SUPPORTS_250HZ && \
		     !SYS_SUPPORTS_256HZ && !SYS_SUPPORTS_1000HZ && \
		     !SYS_SUPPORTS_1024HZ

config HZ
	int
	default 48 if HZ_48
	default 100 if HZ_100
	default 128 if HZ_128
	default 250 if HZ_250
	default 256 if HZ_256
	default 1000 if HZ_1000
	default 1024 if HZ_1024

config SCHED_HRTICK
	def_bool HIGH_RES_TIMERS

source "kernel/Kconfig.preempt"

config KEXEC
	bool "Kexec system call"
	help
	  kexec is a system call that implements the ability to shutdown your
	  current kernel, and to start another kernel.  It is like a reboot
	  but it is independent of the system firmware.   And like a reboot
	  you can start any kernel with it, not just Linux.

	  The name comes from the similarity to the exec system call.

	  It is an ongoing process to be certain the hardware in a machine
	  is properly shutdown, so do not be surprised if this code does not
	  initially work for you.  As of this writing the exact hardware
	  interface is strongly in flux, so no good recommendation can be
	  made.

config CRASH_DUMP
	  bool "Kernel crash dumps"
	  help
	  Generate crash dump after being started by kexec.
	  This should be normally only set in special crash dump kernels
	  which are loaded in the main kernel with kexec-tools into
	  a specially reserved region and then later executed after
	  a crash by kdump/kexec. The crash dump kernel must be compiled
	  to a memory address not used by the main kernel or firmware using
	  PHYSICAL_START.

config PHYSICAL_START
	  hex "Physical address where the kernel is loaded"
	  default "0xffffffff84000000" if 64BIT
	  default "0x84000000" if 32BIT
	  depends on CRASH_DUMP
	  help
	  This gives the CKSEG0 or KSEG0 address where the kernel is loaded.
	  If you plan to use kernel for capturing the crash dump change
	  this value to start of the reserved region (the "X" value as
	  specified in the "crashkernel=YM@XM" command line boot parameter
	  passed to the panic-ed kernel).

config SECCOMP
	bool "Enable seccomp to safely compute untrusted bytecode"
	depends on PROC_FS
	default y
	help
	  This kernel feature is useful for number crunching applications
	  that may need to compute untrusted bytecode during their
	  execution. By using pipes or other transports made available to
	  the process as file descriptors supporting the read/write
	  syscalls, it's possible to isolate those applications in
	  their own address space using seccomp. Once seccomp is
	  enabled via /proc/<pid>/seccomp, it cannot be disabled
	  and the task is only allowed to execute a few safe syscalls
	  defined by each seccomp mode.

	  If unsure, say Y. Only embedded should say N here.

config MIPS_O32_FP64_SUPPORT
	bool "Support for O32 binaries using 64-bit FP (EXPERIMENTAL)"
	depends on 32BIT || MIPS32_O32
	help
	  When this is enabled, the kernel will support use of 64-bit floating
	  point registers with binaries using the O32 ABI along with the
	  EF_MIPS_FP64 ELF header flag (typically built with -mfp64). On
	  32-bit MIPS systems this support is at the cost of increasing the
	  size and complexity of the compiled FPU emulator. Thus if you are
	  running a MIPS32 system and know that none of your userland binaries
	  will require 64-bit floating point, you may wish to reduce the size
	  of your kernel & potentially improve FP emulation performance by
	  saying N here.

	  Although binutils currently supports use of this flag the details
	  concerning its effect upon the O32 ABI in userland are still being
	  worked on. In order to avoid userland becoming dependant upon current
	  behaviour before the details have been finalised, this option should
	  be considered experimental and only enabled by those working upon
	  said details.

	  If unsure, say N.

config USE_OF
	bool
	select OF
	select OF_EARLY_FLATTREE
	select IRQ_DOMAIN

config BUILTIN_DTB
	bool

endmenu

config LOCKDEP_SUPPORT
	bool
	default y

config STACKTRACE_SUPPORT
	bool
	default y

config PGTABLE_LEVELS
	int
	default 3 if 64BIT && !PAGE_SIZE_64KB
	default 2

source "init/Kconfig"

source "kernel/Kconfig.freezer"

menu "Bus options (PCI, PCMCIA, EISA, ISA, TC)"

config HW_HAS_EISA
	bool
config HW_HAS_PCI
	bool

config PCI
	bool "Support for PCI controller"
	depends on HW_HAS_PCI
	select PCI_DOMAINS
	select NO_GENERIC_PCI_IOPORT_MAP
	help
	  Find out whether you have a PCI motherboard. PCI is the name of a
	  bus system, i.e. the way the CPU talks to the other stuff inside
	  your box. Other bus systems are ISA, EISA, or VESA. If you have PCI,
	  say Y, otherwise N.

config HT_PCI
	bool "Support for HT-linked PCI"
	default y
	depends on CPU_LOONGSON3
	select PCI
	select PCI_DOMAINS
	help
	  Loongson family machines use Hyper-Transport bus for inter-core
	  connection and device connection. The PCI bus is a subordinate
	  linked at HT. Choose Y for Loongson-3 based machines.

config PCI_DOMAINS
	bool

source "drivers/pci/Kconfig"

source "drivers/pci/pcie/Kconfig"

#
# ISA support is now enabled via select.  Too many systems still have the one
# or other ISA chip on the board that users don't know about so don't expect
# users to choose the right thing ...
#
config ISA
	bool

config EISA
	bool "EISA support"
	depends on HW_HAS_EISA
	select ISA
	select GENERIC_ISA_DMA
	---help---
	  The Extended Industry Standard Architecture (EISA) bus was
	  developed as an open alternative to the IBM MicroChannel bus.

	  The EISA bus provided some of the features of the IBM MicroChannel
	  bus while maintaining backward compatibility with cards made for
	  the older ISA bus.  The EISA bus saw limited use between 1988 and
	  1995 when it was made obsolete by the PCI bus.

	  Say Y here if you are building a kernel for an EISA-based machine.

	  Otherwise, say N.

source "drivers/eisa/Kconfig"

config TC
	bool "TURBOchannel support"
	depends on MACH_DECSTATION
	help
	  TURBOchannel is a DEC (now Compaq (now HP)) bus for Alpha and MIPS
	  processors.  TURBOchannel programming specifications are available
	  at:
	  <ftp://ftp.hp.com/pub/alphaserver/archive/triadd/>
	  and:
	  <http://www.computer-refuge.org/classiccmp/ftp.digital.com/pub/DEC/TriAdd/>
	  Linux driver support status is documented at:
	  <http://www.linux-mips.org/wiki/DECstation>

config MMU
	bool
	default y

config I8253
	bool
	select CLKSRC_I8253
	select CLKEVT_I8253
	select MIPS_EXTERNAL_TIMER

config ZONE_DMA
	bool

config ZONE_DMA32
	bool

source "drivers/pcmcia/Kconfig"

source "drivers/pci/hotplug/Kconfig"

config RAPIDIO
	tristate "RapidIO support"
	depends on PCI
	default n
	help
	  If you say Y here, the kernel will include drivers and
	  infrastructure code to support RapidIO interconnect devices.

source "drivers/rapidio/Kconfig"

endmenu

menu "Executable file formats"

source "fs/Kconfig.binfmt"

config TRAD_SIGNALS
	bool

config MIPS32_COMPAT
	bool

config COMPAT
	bool

config SYSVIPC_COMPAT
	bool

config MIPS32_O32
	bool "Kernel support for o32 binaries"
	depends on 64BIT
	select ARCH_WANT_OLD_COMPAT_IPC
	select COMPAT
	select MIPS32_COMPAT
	select SYSVIPC_COMPAT if SYSVIPC
	help
	  Select this option if you want to run o32 binaries.  These are pure
	  32-bit binaries as used by the 32-bit Linux/MIPS port.  Most of
	  existing binaries are in this format.

	  If unsure, say Y.

config MIPS32_N32
	bool "Kernel support for n32 binaries"
	depends on 64BIT
	select COMPAT
	select MIPS32_COMPAT
	select SYSVIPC_COMPAT if SYSVIPC
	help
	  Select this option if you want to run n32 binaries.  These are
	  64-bit binaries using 32-bit quantities for addressing and certain
	  data that would normally be 64-bit.  They are used in special
	  cases.

	  If unsure, say N.

config BINFMT_ELF32
	bool
	default y if MIPS32_O32 || MIPS32_N32

endmenu

menu "Power management options"

config ARCH_HIBERNATION_POSSIBLE
	def_bool y
	depends on SYS_SUPPORTS_HOTPLUG_CPU || !SMP

config ARCH_SUSPEND_POSSIBLE
	def_bool y
	depends on SYS_SUPPORTS_HOTPLUG_CPU || !SMP

source "kernel/power/Kconfig"

endmenu

config MIPS_EXTERNAL_TIMER
	bool

menu "CPU Power Management"

if CPU_SUPPORTS_CPUFREQ && MIPS_EXTERNAL_TIMER
source "drivers/cpufreq/Kconfig"
endif

source "drivers/cpuidle/Kconfig"

endmenu

source "net/Kconfig"

source "drivers/Kconfig"

source "drivers/firmware/Kconfig"

source "fs/Kconfig"

source "arch/mips/Kconfig.debug"

source "security/Kconfig"

source "crypto/Kconfig"

source "lib/Kconfig"

source "arch/mips/kvm/Kconfig"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 *	FILE    	SA-1100.h
 *
 *	Version 	1.2
 *	Author  	Copyright (c) Marc A. Viredaz, 1998
 *	        	DEC Western Research Laboratory, Palo Alto, CA
 *	Date    	January 1998 (April 1997)
 *	System  	StrongARM SA-1100
 *	Language	C or ARM Assembly
 *	Purpose 	Definition of constants related to the StrongARM
 *	        	SA-1100 microprocessor (Advanced RISC Machine (ARM)
 *	        	architecture version 4). This file is based on the
 *	        	StrongARM SA-1100 data sheet version 2.2.
 *
 */


/* Be sure that virtual mapping is defined right */
#ifndef __ASM_ARCH_HARDWARE_H
#error You must include hardware.h not SA-1100.h
#endif

#include "bitfield.h"

/*
 * SA1100 CS line to physical address
 */

#define SA1100_CS0_PHYS	0x00000000
#define SA1100_CS1_PHYS	0x08000000
#define SA1100_CS2_PHYS	0x10000000
#define SA1100_CS3_PHYS	0x18000000
#define SA1100_CS4_PHYS	0x40000000
#define SA1100_CS5_PHYS	0x48000000

/*
 * Personal Computer Memory Card International Association (PCMCIA) sockets
 */

#define PCMCIAPrtSp	0x04000000	/* PCMCIA Partition Space [byte]   */
#define PCMCIASp	(4*PCMCIAPrtSp)	/* PCMCIA Space [byte]             */
#define PCMCIAIOSp	PCMCIAPrtSp	/* PCMCIA I/O Space [byte]         */
#define PCMCIAAttrSp	PCMCIAPrtSp	/* PCMCIA Attribute Space [byte]   */
#define PCMCIAMemSp	PCMCIAPrtSp	/* PCMCIA Memory Space [byte]      */

#define PCMCIA0Sp	PCMCIASp	/* PCMCIA 0 Space [byte]           */
#define PCMCIA0IOSp	PCMCIAIOSp	/* PCMCIA 0 I/O Space [byte]       */
#define PCMCIA0AttrSp	PCMCIAAttrSp	/* PCMCIA 0 Attribute Space [byte] */
#define PCMCIA0MemSp	PCMCIAMemSp	/* PCMCIA 0 Memory Space [byte]    */

#define PCMCIA1Sp	PCMCIASp	/* PCMCIA 1 Space [byte]           */
#define PCMCIA1IOSp	PCMCIAIOSp	/* PCMCIA 1 I/O Space [byte]       */
#define PCMCIA1AttrSp	PCMCIAAttrSp	/* PCMCIA 1 Attribute Space [byte] */
#define PCMCIA1MemSp	PCMCIAMemSp	/* PCMCIA 1 Memory Space [byte]    */

#define _PCMCIA(Nb)	        	/* PCMCIA [0..1]                   */ \
                	(0x20000000 + (Nb)*PCMCIASp)
#define _PCMCIAIO(Nb)	_PCMCIA (Nb)	/* PCMCIA I/O [0..1]               */
#define _PCMCIAAttr(Nb)	        	/* PCMCIA Attribute [0..1]         */ \
                	(_PCMCIA (Nb) + 2*PCMCIAPrtSp)
#define _PCMCIAMem(Nb)	        	/* PCMCIA Memory [0..1]            */ \
                	(_PCMCIA (Nb) + 3*PCMCIAPrtSp)

#define _PCMCIA0	_PCMCIA (0)	/* PCMCIA 0                        */
#define _PCMCIA0IO	_PCMCIAIO (0)	/* PCMCIA 0 I/O                    */
#define _PCMCIA0Attr	_PCMCIAAttr (0)	/* PCMCIA 0 Attribute              */
#define _PCMCIA0Mem	_PCMCIAMem (0)	/* PCMCIA 0 Memory                 */

#define _PCMCIA1	_PCMCIA (1)	/* PCMCIA 1                        */
#define _PCMCIA1IO	_PCMCIAIO (1)	/* PCMCIA 1 I/O                    */
#define _PCMCIA1Attr	_PCMCIAAttr (1)	/* PCMCIA 1 Attribute              */
#define _PCMCIA1Mem	_PCMCIAMem (1)	/* PCMCIA 1 Memory                 */


/*
 * Universal Serial Bus (USB) Device Controller (UDC) control registers
 *
 * Registers
 *    Ser0UDCCR 	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Control Register (read/write).
 *    Ser0UDCAR 	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Address Register (read/write).
 *    Ser0UDCOMP	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Output Maximum Packet size register
 *              	(read/write).
 *    Ser0UDCIMP	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Input Maximum Packet size register
 *              	(read/write).
 *    Ser0UDCCS0	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Control/Status register end-point 0
 *              	(read/write).
 *    Ser0UDCCS1	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Control/Status register end-point 1
 *              	(output, read/write).
 *    Ser0UDCCS2	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Control/Status register end-point 2
 *              	(input, read/write).
 *    Ser0UDCD0 	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Data register end-point 0
 *              	(read/write).
 *    Ser0UDCWC 	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Write Count register end-point 0
 *              	(read).
 *    Ser0UDCDR 	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Data Register (read/write).
 *    Ser0UDCSR 	Serial port 0 Universal Serial Bus (USB) Device
 *              	Controller (UDC) Status Register (read/write).
 */

#define Ser0UDCCR	__REG(0x80000000)  /* Ser. port 0 UDC Control Reg. */
#define Ser0UDCAR	__REG(0x80000004)  /* Ser. port 0 UDC Address Reg. */
#define Ser0UDCOMP	__REG(0x80000008)  /* Ser. port 0 UDC Output Maximum Packet size reg. */
#define Ser0UDCIMP	__REG(0x8000000C)  /* Ser. port 0 UDC Input Maximum Packet size reg. */
#define Ser0UDCCS0	__REG(0x80000010)  /* Ser. port 0 UDC Control/Status reg. end-point 0 */
#define Ser0UDCCS1	__REG(0x80000014)  /* Ser. port 0 UDC Control/Status reg. end-point 1 (output) */
#define Ser0UDCCS2	__REG(0x80000018)  /* Ser. port 0 UDC Control/Status reg. end-point 2 (input) */
#define Ser0UDCD0	__REG(0x8000001C)  /* Ser. port 0 UDC Data reg. end-point 0 */
#define Ser0UDCWC	__REG(0x80000020)  /* Ser. port 0 UDC Write Count reg. end-point 0 */
#define Ser0UDCDR	__REG(0x80000028)  /* Ser. port 0 UDC Data Reg. */
#define Ser0UDCSR	__REG(0x80000030)  /* Ser. port 0 UDC Status Reg. */

#define UDCCR_UDD	0x00000001	/* UDC Disable                     */
#define UDCCR_UDA	0x00000002	/* UDC Active (read)               */
#define UDCCR_RESIM	0x00000004	/* Resume Interrupt Mask, per errata */
#define UDCCR_EIM	0x00000008	/* End-point 0 Interrupt Mask      */
                	        	/* (disable)                       */
#define UDCCR_RIM	0x00000010	/* Receive Interrupt Mask          */
                	        	/* (disable)                       */
#define UDCCR_TIM	0x00000020	/* Transmit Interrupt Mask         */
                	        	/* (disable)                       */
#define UDCCR_SRM	0x00000040	/* Suspend/Resume interrupt Mask   */
                	        	/* (disable)                       */
#define UDCCR_SUSIM	UDCCR_SRM	/* Per errata, SRM just masks suspend */
#define UDCCR_REM	0x00000080	/* REset interrupt Mask (disable)  */

#define UDCAR_ADD	Fld (7, 0)	/* function ADDress                */

#define UDCOMP_OUTMAXP	Fld (8, 0)	/* OUTput MAXimum Packet size - 1  */
                	        	/* [byte]                          */
#define UDCOMP_OutMaxPkt(Size)  	/* Output Maximum Packet size      */ \
                	        	/* [1..256 byte]                   */ \
                	(((Size) - 1) << FShft (UDCOMP_OUTMAXP))

#define UDCIMP_INMAXP	Fld (8, 0)	/* INput MAXimum Packet size - 1   */
                	        	/* [byte]                          */
#define UDCIMP_InMaxPkt(Size)   	/* Input Maximum Packet size       */ \
                	        	/* [1..256 byte]                   */ \
                	(((Size) - 1) << FShft (UDCIMP_INMAXP))

#define UDCCS0_OPR	0x00000001	/* Output Packet Ready (read)      */
#define UDCCS0_IPR	0x00000002	/* Input Packet Ready              */
#define UDCCS0_SST	0x00000004	/* Sent STall                      */
#define UDCCS0_FST	0x00000008	/* Force STall                     */
#define UDCCS0_DE	0x00000010	/* Data End                        */
#define UDCCS0_SE	0x00000020	/* Setup End (read)                */
#define UDCCS0_SO	0x00000040	/* Serviced Output packet ready    */
                	        	/* (write)                         */
#define UDCCS0_SSE	0x00000080	/* Serviced Setup End (write)      */

#define UDCCS1_RFS	0x00000001	/* Receive FIFO 12-bytes or more   */
                	        	/* Service request (read)          */
#define UDCCS1_RPC	0x00000002	/* Receive Packet Complete         */
#define UDCCS1_RPE	0x00000004	/* Receive Packet Error (read)     */
#define UDCCS1_SST	0x00000008	/* Sent STall                      */
#define UDCCS1_FST	0x00000010	/* Force STall                     */
#define UDCCS1_RNE	0x00000020	/* Receive FIFO Not Empty (read)   */

#define UDCCS2_TFS	0x00000001	/* Transmit FIFO 8-bytes or less   */
                	        	/* Service request (read)          */
#define UDCCS2_TPC	0x00000002	/* Transmit Packet Complete        */
#define UDCCS2_TPE	0x00000004	/* Transmit Packet Error (read)    */
#define UDCCS2_TUR	0x00000008	/* Transmit FIFO Under-Run         */
#define UDCCS2_SST	0x00000010	/* Sent STall                      */
#define UDCCS2_FST	0x00000020	/* Force STall                     */

#define UDCD0_DATA	Fld (8, 0)	/* receive/transmit DATA FIFOs     */

#define UDCWC_WC	Fld (4, 0)	/* Write Count                     */

#define UDCDR_DATA	Fld (8, 0)	/* receive/transmit DATA FIFOs     */

#define UDCSR_EIR	0x00000001	/* End-point 0 Interrupt Request   */
#define UDCSR_RIR	0x00000002	/* Receive Interrupt Request       */
#define UDCSR_TIR	0x00000004	/* Transmit Interrupt Request      */
#define UDCSR_SUSIR	0x00000008	/* SUSpend Interrupt Request       */
#define UDCSR_RESIR	0x00000010	/* RESume Interrupt Request        */
#define UDCSR_RSTIR	0x00000020	/* ReSeT Interrupt Request         */


/*
 * Universal Asynchronous Receiver/Transmitter (UART) control registers
 *
 * Registers
 *    Ser1UTCR0 	Serial port 1 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 0
 *              	(read/write).
 *    Ser1UTCR1 	Serial port 1 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 1
 *              	(read/write).
 *    Ser1UTCR2 	Serial port 1 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 2
 *              	(read/write).
 *    Ser1UTCR3 	Serial port 1 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 3
 *              	(read/write).
 *    Ser1UTDR  	Serial port 1 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Data Register
 *              	(read/write).
 *    Ser1UTSR0 	Serial port 1 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Status Register 0
 *              	(read/write).
 *    Ser1UTSR1 	Serial port 1 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Status Register 1 (read).
 *
 *    Ser2UTCR0 	Serial port 2 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 0
 *              	(read/write).
 *    Ser2UTCR1 	Serial port 2 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 1
 *              	(read/write).
 *    Ser2UTCR2 	Serial port 2 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 2
 *              	(read/write).
 *    Ser2UTCR3 	Serial port 2 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 3
 *              	(read/write).
 *    Ser2UTCR4 	Serial port 2 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 4
 *              	(read/write).
 *    Ser2UTDR  	Serial port 2 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Data Register
 *              	(read/write).
 *    Ser2UTSR0 	Serial port 2 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Status Register 0
 *              	(read/write).
 *    Ser2UTSR1 	Serial port 2 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Status Register 1 (read).
 *
 *    Ser3UTCR0 	Serial port 3 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 0
 *              	(read/write).
 *    Ser3UTCR1 	Serial port 3 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 1
 *              	(read/write).
 *    Ser3UTCR2 	Serial port 3 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 2
 *              	(read/write).
 *    Ser3UTCR3 	Serial port 3 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Control Register 3
 *              	(read/write).
 *    Ser3UTDR  	Serial port 3 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Data Register
 *              	(read/write).
 *    Ser3UTSR0 	Serial port 3 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Status Register 0
 *              	(read/write).
 *    Ser3UTSR1 	Serial port 3 Universal Asynchronous
 *              	Receiver/Transmitter (UART) Status Register 1 (read).
 *
 * Clocks
 *    fxtl, Txtl	Frequency, period of the system crystal (3.6864 MHz
 *              	or 3.5795 MHz).
 *    fua, Tua  	Frequency, period of the UART communication.
 */

#define _UTCR0(Nb)	__REG(0x80010000 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 0 [1..3] */
#define _UTCR1(Nb)	__REG(0x80010004 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 1 [1..3] */
#define _UTCR2(Nb)	__REG(0x80010008 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 2 [1..3] */
#define _UTCR3(Nb)	__REG(0x8001000C + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 3 [1..3] */
#define _UTCR4(Nb)	__REG(0x80010010 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 4 [2] */
#define _UTDR(Nb)	__REG(0x80010014 + ((Nb) - 1)*0x00020000)  /* UART Data Reg. [1..3] */
#define _UTSR0(Nb)	__REG(0x8001001C + ((Nb) - 1)*0x00020000)  /* UART Status Reg. 0 [1..3] */
#define _UTSR1(Nb)	__REG(0x80010020 + ((Nb) - 1)*0x00020000)  /* UART Status Reg. 1 [1..3] */

#define Ser1UTCR0	_UTCR0 (1)	/* Ser. port 1 UART Control Reg. 0 */
#define Ser1UTCR1	_UTCR1 (1)	/* Ser. port 1 UART Control Reg. 1 */
#define Ser1UTCR2	_UTCR2 (1)	/* Ser. port 1 UART Control Reg. 2 */
#define Ser1UTCR3	_UTCR3 (1)	/* Ser. port 1 UART Control Reg. 3 */
#define Ser1UTDR	_UTDR (1)	/* Ser. port 1 UART Data Reg.      */
#define Ser1UTSR0	_UTSR0 (1)	/* Ser. port 1 UART Status Reg. 0  */
#define Ser1UTSR1	_UTSR1 (1)	/* Ser. port 1 UART Status Reg. 1  */

#define Ser2UTCR0	_UTCR0 (2)	/* Ser. port 2 UART Control Reg. 0 */
#define Ser2UTCR1	_UTCR1 (2)	/* Ser. port 2 UART Control Reg. 1 */
#define Ser2UTCR2	_UTCR2 (2)	/* Ser. port 2 UART Control Reg. 2 */
#define Ser2UTCR3	_UTCR3 (2)	/* Ser. port 2 UART Control Reg. 3 */
#define Ser2UTCR4	_UTCR4 (2)	/* Ser. port 2 UART Control Reg. 4 */
#define Ser2UTDR	_UTDR (2)	/* Ser. port 2 UART Data Reg.      */
#define Ser2UTSR0	_UTSR0 (2)	/* Ser. port 2 UART Status Reg. 0  */
#define Ser2UTSR1	_UTSR1 (2)	/* Ser. port 2 UART Status Reg. 1  */

#define Ser3UTCR0	_UTCR0 (3)	/* Ser. port 3 UART Control Reg. 0 */
#define Ser3UTCR1	_UTCR1 (3)	/* Ser. port 3 UART Control Reg. 1 */
#define Ser3UTCR2	_UTCR2 (3)	/* Ser. port 3 UART Control Reg. 2 */
#define Ser3UTCR3	_UTCR3 (3)	/* Ser. port 3 UART Control Reg. 3 */
#define Ser3UTDR	_UTDR (3)	/* Ser. port 3 UART Data Reg.      */
#define Ser3UTSR0	_UTSR0 (3)	/* Ser. port 3 UART Status Reg. 0  */
#define Ser3UTSR1	_UTSR1 (3)	/* Ser. port 3 UART Status Reg. 1  */

/* Those are still used in some places */
#define _Ser1UTCR0	__PREG(Ser1UTCR0)
#define _Ser2UTCR0	__PREG(Ser2UTCR0)
#define _Ser3UTCR0	__PREG(Ser3UTCR0)

/* Register offsets */
#define UTCR0		0x00
#define UTCR1		0x04
#define UTCR2		0x08
#define UTCR3		0x0c
#define UTDR		0x14
#define UTSR0		0x1c
#define UTSR1		0x20

#define UTCR0_PE	0x00000001	/* Parity Enable                   */
#define UTCR0_OES	0x00000002	/* Odd/Even parity Select          */
#define UTCR0_OddPar	(UTCR0_OES*0)	/*  Odd Parity                     */
#define UTCR0_EvenPar	(UTCR0_OES*1)	/*  Even Parity                    */
#define UTCR0_SBS	0x00000004	/* Stop Bit Select                 */
#define UTCR0_1StpBit	(UTCR0_SBS*0)	/*  1 Stop Bit per frame           */
#define UTCR0_2StpBit	(UTCR0_SBS*1)	/*  2 Stop Bits per frame          */
#define UTCR0_DSS	0x00000008	/* Data Size Select                */
#define UTCR0_7BitData	(UTCR0_DSS*0)	/*  7-Bit Data                     */
#define UTCR0_8BitData	(UTCR0_DSS*1)	/*  8-Bit Data                     */
#define UTCR0_SCE	0x00000010	/* Sample Clock Enable             */
                	        	/* (ser. port 1: GPIO [18],        */
                	        	/* ser. port 3: GPIO [20])         */
#define UTCR0_RCE	0x00000020	/* Receive Clock Edge select       */
#define UTCR0_RcRsEdg	(UTCR0_RCE*0)	/*  Receive clock Rising-Edge      */
#define UTCR0_RcFlEdg	(UTCR0_RCE*1)	/*  Receive clock Falling-Edge     */
#define UTCR0_TCE	0x00000040	/* Transmit Clock Edge select      */
#define UTCR0_TrRsEdg	(UTCR0_TCE*0)	/*  Transmit clock Rising-Edge     */
#define UTCR0_TrFlEdg	(UTCR0_TCE*1)	/*  Transmit clock Falling-Edge    */
#define UTCR0_Ser2IrDA	        	/* Ser. port 2 IrDA settings       */ \
                	(UTCR0_1StpBit + UTCR0_8BitData)

#define UTCR1_BRD	Fld (4, 0)	/* Baud Rate Divisor/16 - 1 [11:8] */
#define UTCR2_BRD	Fld (8, 0)	/* Baud Rate Divisor/16 - 1  [7:0] */
                	        	/* fua = fxtl/(16*(BRD[11:0] + 1)) */
                	        	/* Tua = 16*(BRD [11:0] + 1)*Txtl  */
#define UTCR1_BdRtDiv(Div)      	/*  Baud Rate Divisor [16..65536]  */ \
                	(((Div) - 16)/16 >> FSize (UTCR2_BRD) << \
                	 FShft (UTCR1_BRD))
#define UTCR2_BdRtDiv(Div)      	/*  Baud Rate Divisor [16..65536]  */ \
                	(((Div) - 16)/16 & FAlnMsk (UTCR2_BRD) << \
                	 FShft (UTCR2_BRD))
                	        	/*  fua = fxtl/(16*Floor (Div/16)) */
                	        	/*  Tua = 16*Floor (Div/16)*Txtl   */
#define UTCR1_CeilBdRtDiv(Div)  	/*  Ceil. of BdRtDiv [16..65536]   */ \
                	(((Div) - 1)/16 >> FSize (UTCR2_BRD) << \
                	 FShft (UTCR1_BRD))
#define UTCR2_CeilBdRtDiv(Div)  	/*  Ceil. of BdRtDiv [16..65536]   */ \
                	(((Div) - 1)/16 & FAlnMsk (UTCR2_BRD) << \
                	 FShft (UTCR2_BRD))
                	        	/*  fua = fxtl/(16*Ceil (Div/16))  */
                	        	/*  Tua = 16*Ceil (Div/16)*Txtl    */

#define UTCR3_RXE	0x00000001	/* Receive Enable                  */
#define UTCR3_TXE	0x00000002	/* Transmit Enable                 */
#define UTCR3_BRK	0x00000004	/* BReaK mode                      */
#define UTCR3_RIE	0x00000008	/* Receive FIFO 1/3-to-2/3-full or */
                	        	/* more Interrupt Enable           */
#define UTCR3_TIE	0x00000010	/* Transmit FIFO 1/2-full or less  */
                	        	/* Interrupt Enable                */
#define UTCR3_LBM	0x00000020	/* Look-Back Mode                  */
#define UTCR3_Ser2IrDA	        	/* Ser. port 2 IrDA settings (RIE, */ \
                	        	/* TIE, LBM can be set or cleared) */ \
                	(UTCR3_RXE + UTCR3_TXE)

#define UTCR4_HSE	0x00000001	/* Hewlett-Packard Serial InfraRed */
                	        	/* (HP-SIR) modulation Enable      */
#define UTCR4_NRZ	(UTCR4_HSE*0)	/*  Non-Return to Zero modulation  */
#define UTCR4_HPSIR	(UTCR4_HSE*1)	/*  HP-SIR modulation              */
#define UTCR4_LPM	0x00000002	/* Low-Power Mode                  */
#define UTCR4_Z3_16Bit	(UTCR4_LPM*0)	/*  Zero pulse = 3/16 Bit time     */
#define UTCR4_Z1_6us	(UTCR4_LPM*1)	/*  Zero pulse = 1.6 us            */

#define UTDR_DATA	Fld (8, 0)	/* receive/transmit DATA FIFOs     */
#if 0           	        	/* Hidden receive FIFO bits        */
#define UTDR_PRE	0x00000100	/*  receive PaRity Error (read)    */
#define UTDR_FRE	0x00000200	/*  receive FRaming Error (read)   */
#define UTDR_ROR	0x00000400	/*  Receive FIFO Over-Run (read)   */
#endif /* 0 */

#define UTSR0_TFS	0x00000001	/* Transmit FIFO 1/2-full or less  */
                	        	/* Service request (read)          */
#define UTSR0_RFS	0x00000002	/* Receive FIFO 1/3-to-2/3-full or */
                	        	/* more Service request (read)     */
#define UTSR0_RID	0x00000004	/* Receiver IDle                   */
#define UTSR0_RBB	0x00000008	/* Receive Beginning of Break      */
#define UTSR0_REB	0x00000010	/* Receive End of Break            */
#define UTSR0_EIF	0x00000020	/* Error In FIFO (read)            */

#define UTSR1_TBY	0x00000001	/* Transmitter BusY (read)         */
#define UTSR1_RNE	0x00000002	/* Receive FIFO Not Empty (read)   */
#define UTSR1_TNF	0x00000004	/* Transmit FIFO Not Full (read)   */
#define UTSR1_PRE	0x00000008	/* receive PaRity Error (read)     */
#define UTSR1_FRE	0x00000010	/* receive FRaming Error (read)    */
#define UTSR1_ROR	0x00000020	/* Receive FIFO Over-Run (read)    */


/*
 * Synchronous Data Link Controller (SDLC) control registers
 *
 * Registers
 *    Ser1SDCR0 	Serial port 1 Synchronous Data Link Controller (SDLC)
 *              	Control Register 0 (read/write).
 *    Ser1SDCR1 	Serial port 1 Synchronous Data Link Controller (SDLC)
 *              	Control Register 1 (read/write).
 *    Ser1SDCR2 	Serial port 1 Synchronous Data Link Controller (SDLC)
 *              	Control Register 2 (read/write).
 *    Ser1SDCR3 	Serial port 1 Synchronous Data Link Controller (SDLC)
 *              	Control Register 3 (read/write).
 *    Ser1SDCR4 	Serial port 1 Synchronous Data Link Controller (SDLC)
 *              	Control Register 4 (read/write).
 *    Ser1SDDR  	Serial port 1 Synchronous Data Link Controller (SDLC)
 *              	Data Register (read/write).
 *    Ser1SDSR0 	Serial port 1 Synchronous Data Link Controller (SDLC)
 *              	Status Register 0 (read/write).
 *    Ser1SDSR1 	Serial port 1 Synchronous Data Link Controller (SDLC)
 *              	Status Register 1 (read/write).
 *
 * Clocks
 *    fxtl, Txtl	Frequency, period of the system crystal (3.6864 MHz
 *              	or 3.5795 MHz).
 *    fsd, Tsd  	Frequency, period of the SDLC communication.
 */

#define Ser1SDCR0	__REG(0x80020060)  /* Ser. port 1 SDLC Control Reg. 0 */
#define Ser1SDCR1	__REG(0x80020064)  /* Ser. port 1 SDLC Control Reg. 1 */
#define Ser1SDCR2	__REG(0x80020068)  /* Ser. port 1 SDLC Control Reg. 2 */
#define Ser1SDCR3	__REG(0x8002006C)  /* Ser. port 1 SDLC Control Reg. 3 */
#define Ser1SDCR4	__REG(0x80020070)  /* Ser. port 1 SDLC Control Reg. 4 */
#define Ser1SDDR	__REG(0x80020078)  /* Ser. port 1 SDLC Data Reg.      */
#define Ser1SDSR0	__REG(0x80020080)  /* Ser. port 1 SDLC Status Reg. 0  */
#define Ser1SDSR1	__REG(0x80020084)  /* Ser. port 1 SDLC Status Reg. 1  */

#define SDCR0_SUS	0x00000001	/* SDLC/UART Select                */
#define SDCR0_SDLC	(SDCR0_SUS*0)	/*  SDLC mode (TXD1 & RXD1)        */
#define SDCR0_UART	(SDCR0_SUS*1)	/*  UART mode (TXD1 & RXD1)        */
#define SDCR0_SDF	0x00000002	/* Single/Double start Flag select */
#define SDCR0_SglFlg	(SDCR0_SDF*0)	/*  Single start Flag              */
#define SDCR0_DblFlg	(SDCR0_SDF*1)	/*  Double start Flag              */
#define SDCR0_LBM	0x00000004	/* Look-Back Mode                  */
#define SDCR0_BMS	0x00000008	/* Bit Modulation Select           */
#define SDCR0_FM0	(SDCR0_BMS*0)	/*  Freq. Modulation zero (0)      */
#define SDCR0_NRZ	(SDCR0_BMS*1)	/*  Non-Return to Zero modulation  */
#define SDCR0_SCE	0x00000010	/* Sample Clock Enable (GPIO [16]) */
#define SDCR0_SCD	0x00000020	/* Sample Clock Direction select   */
                	        	/* (GPIO [16])                     */
#define SDCR0_SClkIn	(SDCR0_SCD*0)	/*  Sample Clock Input             */
#define SDCR0_SClkOut	(SDCR0_SCD*1)	/*  Sample Clock Output            */
#define SDCR0_RCE	0x00000040	/* Receive Clock Edge select       */
#define SDCR0_RcRsEdg	(SDCR0_RCE*0)	/*  Receive clock Rising-Edge      */
#define SDCR0_RcFlEdg	(SDCR0_RCE*1)	/*  Receive clock Falling-Edge     */
#define SDCR0_TCE	0x00000080	/* Transmit Clock Edge select      */
#define SDCR0_TrRsEdg	(SDCR0_TCE*0)	/*  Transmit clock Rising-Edge     */
#define SDCR0_TrFlEdg	(SDCR0_TCE*1)	/*  Transmit clock Falling-Edge    */

#define SDCR1_AAF	0x00000001	/* Abort After Frame enable        */
                	        	/* (GPIO [17])                     */
#define SDCR1_TXE	0x00000002	/* Transmit Enable                 */
#define SDCR1_RXE	0x00000004	/* Receive Enable                  */
#define SDCR1_RIE	0x00000008	/* Receive FIFO 1/3-to-2/3-full or */
                	        	/* more Interrupt Enable           */
#define SDCR1_TIE	0x00000010	/* Transmit FIFO 1/2-full or less  */
                	        	/* Interrupt Enable                */
#define SDCR1_AME	0x00000020	/* Address Match Enable            */
#define SDCR1_TUS	0x00000040	/* Transmit FIFO Under-run Select  */
#define SDCR1_EFrmURn	(SDCR1_TUS*0)	/*  End Frame on Under-Run         */
#define SDCR1_AbortURn	(SDCR1_TUS*1)	/*  Abort on Under-Run             */
#define SDCR1_RAE	0x00000080	/* Receive Abort interrupt Enable  */

#define SDCR2_AMV	Fld (8, 0)	/* Address Match Value             */

#define SDCR3_BRD	Fld (4, 0)	/* Baud Rate Divisor/16 - 1 [11:8] */
#define SDCR4_BRD	Fld (8, 0)	/* Baud Rate Divisor/16 - 1  [7:0] */
                	        	/* fsd = fxtl/(16*(BRD[11:0] + 1)) */
                	        	/* Tsd = 16*(BRD[11:0] + 1)*Txtl   */
#define SDCR3_BdRtDiv(Div)      	/*  Baud Rate Divisor [16..65536]  */ \
                	(((Div) - 16)/16 >> FSize (SDCR4_BRD) << \
                	 FShft (SDCR3_BRD))
#define SDCR4_BdRtDiv(Div)      	/*  Baud Rate Divisor [16..65536]  */ \
                	(((Div) - 16)/16 & FAlnMsk (SDCR4_BRD) << \
                	 FShft (SDCR4_BRD))
                	        	/*  fsd = fxtl/(16*Floor (Div/16)) */
                	        	/*  Tsd = 16*Floor (Div/16)*Txtl   */
#define SDCR3_CeilBdRtDiv(Div)  	/*  Ceil. of BdRtDiv [16..65536]   */ \
                	(((Div) - 1)/16 >> FSize (SDCR4_BRD) << \
                	 FShft (SDCR3_BRD))
#define SDCR4_CeilBdRtDiv(Div)  	/*  Ceil. of BdRtDiv [16..65536]   */ \
                	(((Div) - 1)/16 & FAlnMsk (SDCR4_BRD) << \
                	 FShft (SDCR4_BRD))
                	        	/*  fsd = fxtl/(16*Ceil (Div/16))  */
                	        	/*  Tsd = 16*Ceil (Div/16)*Txtl    */

#define SDDR_DATA	Fld (8, 0)	/* receive/transmit DATA FIFOs     */
#if 0           	        	/* Hidden receive FIFO bits        */
#define SDDR_EOF	0x00000100	/*  receive End-Of-Frame (read)    */
#define SDDR_CRE	0x00000200	/*  receive CRC Error (read)       */
#define SDDR_ROR	0x00000400	/*  Receive FIFO Over-Run (read)   */
#endif /* 0 */

#define SDSR0_EIF	0x00000001	/* Error In FIFO (read)            */
#define SDSR0_TUR	0x00000002	/* Transmit FIFO Under-Run         */
#define SDSR0_RAB	0x00000004	/* Receive ABort                   */
#define SDSR0_TFS	0x00000008	/* Transmit FIFO 1/2-full or less  */
                	        	/* Service request (read)          */
#define SDSR0_RFS	0x00000010	/* Receive FIFO 1/3-to-2/3-full or */
                	        	/* more Service request (read)     */

#define SDSR1_RSY	0x00000001	/* Receiver SYnchronized (read)    */
#define SDSR1_TBY	0x00000002	/* Transmitter BusY (read)         */
#define SDSR1_RNE	0x00000004	/* Receive FIFO Not Empty (read)   */
#define SDSR1_TNF	0x00000008	/* Transmit FIFO Not Full (read)   */
#define SDSR1_RTD	0x00000010	/* Receive Transition Detected     */
#define SDSR1_EOF	0x00000020	/* receive End-Of-Frame (read)     */
#define SDSR1_CRE	0x00000040	/* receive CRC Error (read)        */
#define SDSR1_ROR	0x00000080	/* Receive FIFO Over-Run (read)    */


/*
 * High-Speed Serial to Parallel controller (HSSP) control registers
 *
 * Registers
 *    Ser2HSCR0 	Serial port 2 High-Speed Serial to Parallel
 *              	controller (HSSP) Control Register 0 (read/write).
 *    Ser2HSCR1 	Serial port 2 High-Speed Serial to Parallel
 *              	controller (HSSP) Control Register 1 (read/write).
 *    Ser2HSDR  	Serial port 2 High-Speed Serial to Parallel
 *              	controller (HSSP) Data Register (read/write).
 *    Ser2HSSR0 	Serial port 2 High-Speed Serial to Parallel
 *              	controller (HSSP) Status Register 0 (read/write).
 *    Ser2HSSR1 	Serial port 2 High-Speed Serial to Parallel
 *              	controller (HSSP) Status Register 1 (read).
 *    Ser2HSCR2 	Serial port 2 High-Speed Serial to Parallel
 *              	controller (HSSP) Control Register 2 (read/write).
 *              	[The HSCR2 register is only implemented in
 *              	versions 2.0 (rev. = 8) and higher of the StrongARM
 *              	SA-1100.]
 */

#define Ser2HSCR0	__REG(0x80040060)  /* Ser. port 2 HSSP Control Reg. 0 */
#define Ser2HSCR1	__REG(0x80040064)  /* Ser. port 2 HSSP Control Reg. 1 */
#define Ser2HSDR	__REG(0x8004006C)  /* Ser. port 2 HSSP Data Reg.      */
#define Ser2HSSR0	__REG(0x80040074)  /* Ser. port 2 HSSP Status Reg. 0  */
#define Ser2HSSR1	__REG(0x80040078)  /* Ser. port 2 HSSP Status Reg. 1  */
#define Ser2HSCR2	__REG(0x90060028)  /* Ser. port 2 HSSP Control Reg. 2 */

#define HSCR0_ITR	0x00000001	/* IrDA Transmission Rate          */
#define HSCR0_UART	(HSCR0_ITR*0)	/*  UART mode (115.2 kb/s if IrDA) */
#define HSCR0_HSSP	(HSCR0_ITR*1)	/*  HSSP mode (4 Mb/s)             */
#define HSCR0_LBM	0x00000002	/* Look-Back Mode                  */
#define HSCR0_TUS	0x00000004	/* Transmit FIFO Under-run Select  */
#define HSCR0_EFrmURn	(HSCR0_TUS*0)	/*  End Frame on Under-Run         */
#define HSCR0_AbortURn	(HSCR0_TUS*1)	/*  Abort on Under-Run             */
#define HSCR0_TXE	0x00000008	/* Transmit Enable                 */
#define HSCR0_RXE	0x00000010	/* Receive Enable                  */
#define HSCR0_RIE	0x00000020	/* Receive FIFO 2/5-to-3/5-full or */
                	        	/* more Interrupt Enable           */
#define HSCR0_TIE	0x00000040	/* Transmit FIFO 1/2-full or less  */
                	        	/* Interrupt Enable                */
#define HSCR0_AME	0x00000080	/* Address Match Enable            */

#define HSCR1_AMV	Fld (8, 0)	/* Address Match Value             */

#define HSDR_DATA	Fld (8, 0)	/* receive/transmit DATA FIFOs     */
#if 0           	        	/* Hidden receive FIFO bits        */
#define HSDR_EOF	0x00000100	/*  receive End-Of-Frame (read)    */
#define HSDR_CRE	0x00000200	/*  receive CRC Error (read)       */
#define HSDR_ROR	0x00000400	/*  Receive FIFO Over-Run (read)   */
#endif /* 0 */

#define HSSR0_EIF	0x00000001	/* Error In FIFO (read)            */
#define HSSR0_TUR	0x00000002	/* Transmit FIFO Under-Run         */
#define HSSR0_RAB	0x00000004	/* Receive ABort                   */
#define HSSR0_TFS	0x00000008	/* Transmit FIFO 1/2-full or less  */
                	        	/* Service request (read)          */
#define HSSR0_RFS	0x00000010	/* Receive FIFO 2/5-to-3/5-full or */
                	        	/* more Service request (read)     */
#define HSSR0_FRE	0x00000020	/* receive FRaming Error           */

#define HSSR1_RSY	0x00000001	/* Receiver SYnchronized (read)    */
#define HSSR1_TBY	0x00000002	/* Transmitter BusY (read)         */
#define HSSR1_RNE	0x00000004	/* Receive FIFO Not Empty (read)   */
#define HSSR1_TNF	0x00000008	/* Transmit FIFO Not Full (read)   */
#define HSSR1_EOF	0x00000010	/* receive End-Of-Frame (read)     */
#define HSSR1_CRE	0x00000020	/* receive CRC Error (read)        */
#define HSSR1_ROR	0x00000040	/* Receive FIFO Over-Run (read)    */

#define HSCR2_TXP	0x00040000	/* Transmit data Polarity (TXD_2)  */
#define HSCR2_TrDataL	(HSCR2_TXP*0)	/*  Transmit Data active Low       */
                	        	/*  (inverted)                     */
#define HSCR2_TrDataH	(HSCR2_TXP*1)	/*  Transmit Data active High      */
                	        	/*  (non-inverted)                 */
#define HSCR2_RXP	0x00080000	/* Receive data Polarity (RXD_2)   */
#define HSCR2_RcDataL	(HSCR2_RXP*0)	/*  Receive Data active Low        */
                	        	/*  (inverted)                     */
#define HSCR2_RcDataH	(HSCR2_RXP*1)	/*  Receive Data active High       */
                	        	/*  (non-inverted)                 */


/*
 * Multi-media Communications Port (MCP) control registers
 *
 * Registers
 *    Ser4MCCR0 	Serial port 4 Multi-media Communications Port (MCP)
 *              	Control Register 0 (read/write).
 *    Ser4MCDR0 	Serial port 4 Multi-media Communications Port (MCP)
 *              	Data Register 0 (audio, read/write).
 *    Ser4MCDR1 	Serial port 4 Multi-media Communications Port (MCP)
 *              	Data Register 1 (telecom, read/write).
 *    Ser4MCDR2 	Serial port 4 Multi-media Communications Port (MCP)
 *              	Data Register 2 (CODEC registers, read/write).
 *    Ser4MCSR  	Serial port 4 Multi-media Communications Port (MCP)
 *              	Status Register (read/write).
 *    Ser4MCCR1 	Serial port 4 Multi-media Communications Port (MCP)
 *              	Control Register 1 (read/write).
 *              	[The MCCR1 register is only implemented in
 *              	versions 2.0 (rev. = 8) and higher of the StrongARM
 *              	SA-1100.]
 *
 * Clocks
 *    fmc, Tmc  	Frequency, period of the MCP communication (10 MHz,
 *              	12 MHz, or GPIO [21]).
 *    faud, Taud	Frequency, period of the audio sampling.
 *    ftcm, Ttcm	Frequency, period of the telecom sampling.
 */

#define Ser4MCCR0	__REG(0x80060000)  /* Ser. port 4 MCP Control Reg. 0 */
#define Ser4MCDR0	__REG(0x80060008)  /* Ser. port 4 MCP Data Reg. 0 (audio) */
#define Ser4MCDR1	__REG(0x8006000C)  /* Ser. port 4 MCP Data Reg. 1 (telecom) */
#define Ser4MCDR2	__REG(0x80060010)  /* Ser. port 4 MCP Data Reg. 2 (CODEC reg.) */
#define Ser4MCSR	__REG(0x80060018)  /* Ser. port 4 MCP Status Reg. */
#define Ser4MCCR1	__REG(0x90060030)  /* Ser. port 4 MCP Control Reg. 1 */

#define MCCR0_ASD	Fld (7, 0)	/* Audio Sampling rate Divisor/32  */
                	        	/* [6..127]                        */
                	        	/* faud = fmc/(32*ASD)             */
                	        	/* Taud = 32*ASD*Tmc               */
#define MCCR0_AudSmpDiv(Div)    	/*  Audio Sampling rate Divisor    */ \
                	        	/*  [192..4064]                    */ \
                	((Div)/32 << FShft (MCCR0_ASD))
                	        	/*  faud = fmc/(32*Floor (Div/32)) */
                	        	/*  Taud = 32*Floor (Div/32)*Tmc   */
#define MCCR0_CeilAudSmpDiv(Div)	/*  Ceil. of AudSmpDiv [192..4064] */ \
                	(((Div) + 31)/32 << FShft (MCCR0_ASD))
                	        	/*  faud = fmc/(32*Ceil (Div/32))  */
                	        	/*  Taud = 32*Ceil (Div/32)*Tmc    */
#define MCCR0_TSD	Fld (7, 8)	/* Telecom Sampling rate           */
                	        	/* Divisor/32 [16..127]            */
                	        	/* ftcm = fmc/(32*TSD)             */
                	        	/* Ttcm = 32*TSD*Tmc               */
#define MCCR0_TcmSmpDiv(Div)    	/*  Telecom Sampling rate Divisor  */ \
                	        	/*  [512..4064]                    */ \
                	((Div)/32 << FShft (MCCR0_TSD))
                	        	/*  ftcm = fmc/(32*Floor (Div/32)) */
                	        	/*  Ttcm = 32*Floor (Div/32)*Tmc   */
#define MCCR0_CeilTcmSmpDiv(Div)	/*  Ceil. of TcmSmpDiv [512..4064] */ \
                	(((Div) + 31)/32 << FShft (MCCR0_TSD))
                	        	/*  ftcm = fmc/(32*Ceil (Div/32))  */
                	        	/*  Ttcm = 32*Ceil (Div/32)*Tmc    */
#define MCCR0_MCE	0x00010000	/* MCP Enable                      */
#define MCCR0_ECS	0x00020000	/* External Clock Select           */
#define MCCR0_IntClk	(MCCR0_ECS*0)	/*  Internal Clock (10 or 12 MHz)  */
#define MCCR0_ExtClk	(MCCR0_ECS*1)	/*  External Clock (GPIO [21])     */
#define MCCR0_ADM	0x00040000	/* A/D (audio/telecom) data        */
                	        	/* sampling/storing Mode           */
#define MCCR0_VldBit	(MCCR0_ADM*0)	/*  Valid Bit storing mode         */
#define MCCR0_SmpCnt	(MCCR0_ADM*1)	/*  Sampling Counter storing mode  */
#define MCCR0_TTE	0x00080000	/* Telecom Transmit FIFO 1/2-full  */
                	        	/* or less interrupt Enable        */
#define MCCR0_TRE	0x00100000	/* Telecom Receive FIFO 1/2-full   */
                	        	/* or more interrupt Enable        */
#define MCCR0_ATE	0x00200000	/* Audio Transmit FIFO 1/2-full    */
                	        	/* or less interrupt Enable        */
#define MCCR0_ARE	0x00400000	/* Audio Receive FIFO 1/2-full or  */
                	        	/* more interrupt Enable           */
#define MCCR0_LBM	0x00800000	/* Look-Back Mode                  */
#define MCCR0_ECP	Fld (2, 24)	/* External Clock Prescaler - 1    */
#define MCCR0_ExtClkDiv(Div)    	/*  External Clock Divisor [1..4]  */ \
                	(((Div) - 1) << FShft (MCCR0_ECP))

#define MCDR0_DATA	Fld (12, 4)	/* receive/transmit audio DATA     */
                	        	/* FIFOs                           */

#define MCDR1_DATA	Fld (14, 2)	/* receive/transmit telecom DATA   */
                	        	/* FIFOs                           */

                	        	/* receive/transmit CODEC reg.     */
                	        	/* FIFOs:                          */
#define MCDR2_DATA	Fld (16, 0)	/*  reg. DATA                      */
#define MCDR2_RW	0x00010000	/*  reg. Read/Write (transmit)     */
#define MCDR2_Rd	(MCDR2_RW*0)	/*   reg. Read                     */
#define MCDR2_Wr	(MCDR2_RW*1)	/*   reg. Write                    */
#define MCDR2_ADD	Fld (4, 17)	/*  reg. ADDress                   */

#define MCSR_ATS	0x00000001	/* Audio Transmit FIFO 1/2-full    */
                	        	/* or less Service request (read)  */
#define MCSR_ARS	0x00000002	/* Audio Receive FIFO 1/2-full or  */
                	        	/* more Service request (read)     */
#define MCSR_TTS	0x00000004	/* Telecom Transmit FIFO 1/2-full  */
                	        	/* or less Service request (read)  */
#define MCSR_TRS	0x00000008	/* Telecom Receive FIFO 1/2-full   */
                	        	/* or more Service request (read)  */
#define MCSR_ATU	0x00000010	/* Audio Transmit FIFO Under-run   */
#define MCSR_ARO	0x00000020	/* Audio Receive FIFO Over-run     */
#define MCSR_TTU	0x00000040	/* Telecom Transmit FIFO Under-run */
#define MCSR_TRO	0x00000080	/* Telecom Receive FIFO Over-run   */
#define MCSR_ANF	0x00000100	/* Audio transmit FIFO Not Full    */
                	        	/* (read)                          */
#define MCSR_ANE	0x00000200	/* Audio receive FIFO Not Empty    */
                	        	/* (read)                          */
#define MCSR_TNF	0x00000400	/* Telecom transmit FIFO Not Full  */
                	        	/* (read)                          */
#define MCSR_TNE	0x00000800	/* Telecom receive FIFO Not Empty  */
                	        	/* (read)                          */
#define MCSR_CWC	0x00001000	/* CODEC register Write Completed  */
                	        	/* (read)                          */
#define MCSR_CRC	0x00002000	/* CODEC register Read Completed   */
                	        	/* (read)                          */
#define MCSR_ACE	0x00004000	/* Audio CODEC Enabled (read)      */
#define MCSR_TCE	0x00008000	/* Telecom CODEC Enabled (read)    */

#define MCCR1_CFS	0x00100000	/* Clock Freq. Select              */
#define MCCR1_F12MHz	(MCCR1_CFS*0)	/*  Freq. (fmc) = ~ 12 MHz         */
                	        	/*  (11.981 MHz)                   */
#define MCCR1_F10MHz	(MCCR1_CFS*1)	/*  Freq. (fmc) = ~ 10 MHz         */
                	        	/*  (9.585 MHz)                    */


/*
 * Synchronous Serial Port (SSP) control registers
 *
 * Registers
 *    Ser4SSCR0 	Serial port 4 Synchronous Serial Port (SSP) Control
 *              	Register 0 (read/write).
 *    Ser4SSCR1 	Serial port 4 Synchronous Serial Port (SSP) Control
 *              	Register 1 (read/write).
 *              	[Bits SPO and SP are only implemented in versions 2.0
 *              	(rev. = 8) and higher of the StrongARM SA-1100.]
 *    Ser4SSDR  	Serial port 4 Synchronous Serial Port (SSP) Data
 *              	Register (read/write).
 *    Ser4SSSR  	Serial port 4 Synchronous Serial Port (SSP) Status
 *              	Register (read/write).
 *
 * Clocks
 *    fxtl, Txtl	Frequency, period of the system crystal (3.6864 MHz
 *              	or 3.5795 MHz).
 *    fss, Tss  	Frequency, period of the SSP communication.
 */

#define Ser4SSCR0	__REG(0x80070060)  /* Ser. port 4 SSP Control Reg. 0 */
#define Ser4SSCR1	__REG(0x80070064)  /* Ser. port 4 SSP Control Reg. 1 */
#define Ser4SSDR	__REG(0x8007006C)  /* Ser. port 4 SSP Data Reg. */
#define Ser4SSSR	__REG(0x80070074)  /* Ser. port 4 SSP Status Reg. */

#define SSCR0_DSS	Fld (4, 0)	/* Data Size - 1 Select [3..15]    */
#define SSCR0_DataSize(Size)    	/*  Data Size Select [4..16]       */ \
                	(((Size) - 1) << FShft (SSCR0_DSS))
#define SSCR0_FRF	Fld (2, 4)	/* FRame Format                    */
#define SSCR0_Motorola	        	/*  Motorola Serial Peripheral     */ \
                	        	/*  Interface (SPI) format         */ \
                	(0 << FShft (SSCR0_FRF))
#define SSCR0_TI	        	/*  Texas Instruments Synchronous  */ \
                	        	/*  Serial format                  */ \
                	(1 << FShft (SSCR0_FRF))
#define SSCR0_National	        	/*  National Microwire format      */ \
                	(2 << FShft (SSCR0_FRF))
#define SSCR0_SSE	0x00000080	/* SSP Enable                      */
#define SSCR0_SCR	Fld (8, 8)	/* Serial Clock Rate divisor/2 - 1 */
                	        	/* fss = fxtl/(2*(SCR + 1))        */
                	        	/* Tss = 2*(SCR + 1)*Txtl          */
#define SSCR0_SerClkDiv(Div)    	/*  Serial Clock Divisor [2..512]  */ \
                	(((Div) - 2)/2 << FShft (SSCR0_SCR))
                	        	/*  fss = fxtl/(2*Floor (Div/2))   */
                	        	/*  Tss = 2*Floor (Div/2)*Txtl     */
#define SSCR0_CeilSerClkDiv(Div)	/*  Ceil. of SerClkDiv [2..512]    */ \
                	(((Div) - 1)/2 << FShft (SSCR0_SCR))
                	        	/*  fss = fxtl/(2*Ceil (Div/2))    */
                	        	/*  Tss = 2*Ceil (Div/2)*Txtl      */

#define SSCR1_RIE	0x00000001	/* Receive FIFO 1/2-full or more   */
                	        	/* Interrupt Enable                */
#define SSCR1_TIE	0x00000002	/* Transmit FIFO 1/2-full or less  */
                	        	/* Interrupt Enable                */
#define SSCR1_LBM	0x00000004	/* Look-Back Mode                  */
#define SSCR1_SPO	0x00000008	/* Sample clock (SCLK) POlarity    */
#define SSCR1_SClkIactL	(SSCR1_SPO*0)	/*  Sample Clock Inactive Low      */
#define SSCR1_SClkIactH	(SSCR1_SPO*1)	/*  Sample Clock Inactive High     */
#define SSCR1_SP	0x00000010	/* Sample clock (SCLK) Phase       */
#define SSCR1_SClk1P	(SSCR1_SP*0)	/*  Sample Clock active 1 Period   */
                	        	/*  after frame (SFRM, 1st edge)   */
#define SSCR1_SClk1_2P	(SSCR1_SP*1)	/*  Sample Clock active 1/2 Period */
                	        	/*  after frame (SFRM, 1st edge)   */
#define SSCR1_ECS	0x00000020	/* External Clock Select           */
#define SSCR1_IntClk	(SSCR1_ECS*0)	/*  Internal Clock                 */
#define SSCR1_ExtClk	(SSCR1_ECS*1)	/*  External Clock (GPIO [19])     */

#define SSDR_DATA	Fld (16, 0)	/* receive/transmit DATA FIFOs     */

#define SSSR_TNF	0x00000002	/* Transmit FIFO Not Full (read)   */
#define SSSR_RNE	0x00000004	/* Receive FIFO Not Empty (read)   */
#define SSSR_BSY	0x00000008	/* SSP BuSY (read)                 */
#define SSSR_TFS	0x00000010	/* Transmit FIFO 1/2-full or less  */
                	        	/* Service request (read)          */
#define SSSR_RFS	0x00000020	/* Receive FIFO 1/2-full or more   */
                	        	/* Service request (read)          */
#define SSSR_ROR	0x00000040	/* Receive FIFO Over-Run           */


/*
 * Operating System (OS) timer control registers
 *
 * Registers
 *    OSMR0     	Operating System (OS) timer Match Register 0
 *              	(read/write).
 *    OSMR1     	Operating System (OS) timer Match Register 1
 *              	(read/write).
 *    OSMR2     	Operating System (OS) timer Match Register 2
 *              	(read/write).
 *    OSMR3     	Operating System (OS) timer Match Register 3
 *              	(read/write).
 *    OSCR      	Operating System (OS) timer Counter Register
 *              	(read/write).
 *    OSSR      	Operating System (OS) timer Status Register
 *              	(read/write).
 *    OWER      	Operating System (OS) timer Watch-dog Enable Register
 *              	(read/write).
 *    OIER      	Operating System (OS) timer Interrupt Enable Register
 *              	(read/write).
 */

#define OSMR0  		io_p2v(0x90000000)  /* OS timer Match Reg. 0 */
#define OSMR1  		io_p2v(0x90000004)  /* OS timer Match Reg. 1 */
#define OSMR2  		io_p2v(0x90000008)  /* OS timer Match Reg. 2 */
#define OSMR3  		io_p2v(0x9000000c)  /* OS timer Match Reg. 3 */
#define OSCR   		io_p2v(0x90000010)  /* OS timer Counter Reg. */
#define OSSR   		io_p2v(0x90000014)  /* OS timer Status Reg. */
#define OWER   		io_p2v(0x90000018)  /* OS timer Watch-dog Enable Reg. */
#define OIER  	 	io_p2v(0x9000001C)  /* OS timer Interrupt Enable Reg. */

#define OSSR_M(Nb)	        	/* Match detected [0..3]           */ \
                	(0x00000001 << (Nb))
#define OSSR_M0 	OSSR_M (0)	/* Match detected 0                */
#define OSSR_M1 	OSSR_M (1)	/* Match detected 1                */
#define OSSR_M2 	OSSR_M (2)	/* Match detected 2                */
#define OSSR_M3 	OSSR_M (3)	/* Match detected 3                */

#define OWER_WME	0x00000001	/* Watch-dog Match Enable          */
                	        	/* (set only)                      */

#define OIER_E(Nb)	        	/* match interrupt Enable [0..3]   */ \
                	(0x00000001 << (Nb))
#define OIER_E0 	OIER_E (0)	/* match interrupt Enable 0        */
#define OIER_E1 	OIER_E (1)	/* match interrupt Enable 1        */
#define OIER_E2 	OIER_E (2)	/* match interrupt Enable 2        */
#define OIER_E3 	OIER_E (3)	/* match interrupt Enable 3        */


/*
 * Real-Time Clock (RTC) control registers
 *
 * Registers
 *    RTAR      	Real-Time Clock (RTC) Alarm Register (read/write).
 *    RCNR      	Real-Time Clock (RTC) CouNt Register (read/write).
 *    RTTR      	Real-Time Clock (RTC) Trim Register (read/write).
 *    RTSR      	Real-Time Clock (RTC) Status Register (read/write).
 *
 * Clocks
 *    frtx, Trtx	Frequency, period of the real-time clock crystal
 *              	(32.768 kHz nominal).
 *    frtc, Trtc	Frequency, period of the real-time clock counter
 *              	(1 Hz nominal).
 */

#define RTAR		__REG(0x90010000)  /* RTC Alarm Reg. */
#define RCNR		__REG(0x90010004)  /* RTC CouNt Reg. */
#define RTTR		__REG(0x90010008)  /* RTC Trim Reg. */
#define RTSR		__REG(0x90010010)  /* RTC Status Reg. */

#define RTTR_C  	Fld (16, 0)	/* clock divider Count - 1         */
#define RTTR_D  	Fld (10, 16)	/* trim Delete count               */
                	        	/* frtc = (1023*(C + 1) - D)*frtx/ */
                	        	/*        (1023*(C + 1)^2)         */
                	        	/* Trtc = (1023*(C + 1)^2)*Trtx/   */
                	        	/*        (1023*(C + 1) - D)       */

#define RTSR_AL 	0x00000001	/* ALarm detected                  */
#define RTSR_HZ 	0x00000002	/* 1 Hz clock detected             */
#define RTSR_ALE	0x00000004	/* ALarm interrupt Enable          */
#define RTSR_HZE	0x00000008	/* 1 Hz clock interrupt Enable     */


/*
 * Power Manager (PM) control registers
 *
 * Registers
 *    PMCR      	Power Manager (PM) Control Register (read/write).
 *    PSSR      	Power Manager (PM) Sleep Status Register (read/write).
 *    PSPR      	Power Manager (PM) Scratch-Pad Register (read/write).
 *    PWER      	Power Manager (PM) Wake-up Enable Register
 *              	(read/write).
 *    PCFR      	Power Manager (PM) general ConFiguration Register
 *              	(read/write).
 *    PPCR      	Power Manager (PM) Phase-Locked Loop (PLL)
 *              	Configuration Register (read/write).
 *    PGSR      	Power Manager (PM) General-Purpose Input/Output (GPIO)
 *              	Sleep state Register (read/write, see GPIO pins).
 *    POSR      	Power Manager (PM) Oscillator Status Register (read).
 *
 * Clocks
 *    fxtl, Txtl	Frequency, period of the system crystal (3.6864 MHz
 *              	or 3.5795 MHz).
 *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
 */

#define PMCR		__REG(0x90020000)  /* PM Control Reg. */
#define PSSR		__REG(0x90020004)  /* PM Sleep Status Reg. */
#define PSPR		__REG(0x90020008)  /* PM Scratch-Pad Reg. */
#define PWER		__REG(0x9002000C)  /* PM Wake-up Enable Reg. */
#define PCFR		__REG(0x90020010)  /* PM general ConFiguration Reg. */
#define PPCR		__REG(0x90020014)  /* PM PLL Configuration Reg. */
#define PGSR		__REG(0x90020018)  /* PM GPIO Sleep state Reg. */
#define POSR		__REG(0x9002001C)  /* PM Oscillator Status Reg. */

#define PMCR_SF 	0x00000001	/* Sleep Force (set only)          */

#define PSSR_SS 	0x00000001	/* Software Sleep                  */
#define PSSR_BFS	0x00000002	/* Battery Fault Status            */
                	        	/* (BATT_FAULT)                    */
#define PSSR_VFS	0x00000004	/* Vdd Fault Status (VDD_FAULT)    */
#define PSSR_DH 	0x00000008	/* DRAM control Hold               */
#define PSSR_PH 	0x00000010	/* Peripheral control Hold         */

#define PWER_GPIO(Nb)	GPIO_GPIO (Nb)	/* GPIO [0..27] wake-up enable     */
#define PWER_GPIO0	PWER_GPIO (0)	/* GPIO  [0] wake-up enable        */
#define PWER_GPIO1	PWER_GPIO (1)	/* GPIO  [1] wake-up enable        */
#define PWER_GPIO2	PWER_GPIO (2)	/* GPIO  [2] wake-up enable        */
#define PWER_GPIO3	PWER_GPIO (3)	/* GPIO  [3] wake-up enable        */
#define PWER_GPIO4	PWER_GPIO (4)	/* GPIO  [4] wake-up enable        */
#define PWER_GPIO5	PWER_GPIO (5)	/* GPIO  [5] wake-up enable        */
#define PWER_GPIO6	PWER_GPIO (6)	/* GPIO  [6] wake-up enable        */
#define PWER_GPIO7	PWER_GPIO (7)	/* GPIO  [7] wake-up enable        */
#define PWER_GPIO8	PWER_GPIO (8)	/* GPIO  [8] wake-up enable        */
#define PWER_GPIO9	PWER_GPIO (9)	/* GPIO  [9] wake-up enable        */
#define PWER_GPIO10	PWER_GPIO (10)	/* GPIO [10] wake-up enable        */
#define PWER_GPIO11	PWER_GPIO (11)	/* GPIO [11] wake-up enable        */
#define PWER_GPIO12	PWER_GPIO (12)	/* GPIO [12] wake-up enable        */
#define PWER_GPIO13	PWER_GPIO (13)	/* GPIO [13] wake-up enable        */
#define PWER_GPIO14	PWER_GPIO (14)	/* GPIO [14] wake-up enable        */
#define PWER_GPIO15	PWER_GPIO (15)	/* GPIO [15] wake-up enable        */
#define PWER_GPIO16	PWER_GPIO (16)	/* GPIO [16] wake-up enable        */
#define PWER_GPIO17	PWER_GPIO (17)	/* GPIO [17] wake-up enable        */
#define PWER_GPIO18	PWER_GPIO (18)	/* GPIO [18] wake-up enable        */
#define PWER_GPIO19	PWER_GPIO (19)	/* GPIO [19] wake-up enable        */
#define PWER_GPIO20	PWER_GPIO (20)	/* GPIO [20] wake-up enable        */
#define PWER_GPIO21	PWER_GPIO (21)	/* GPIO [21] wake-up enable        */
#define PWER_GPIO22	PWER_GPIO (22)	/* GPIO [22] wake-up enable        */
#define PWER_GPIO23	PWER_GPIO (23)	/* GPIO [23] wake-up enable        */
#define PWER_GPIO24	PWER_GPIO (24)	/* GPIO [24] wake-up enable        */
#define PWER_GPIO25	PWER_GPIO (25)	/* GPIO [25] wake-up enable        */
#define PWER_GPIO26	PWER_GPIO (26)	/* GPIO [26] wake-up enable        */
#define PWER_GPIO27	PWER_GPIO (27)	/* GPIO [27] wake-up enable        */
#define PWER_RTC	0x80000000	/* RTC alarm wake-up enable        */

#define PCFR_OPDE	0x00000001	/* Oscillator Power-Down Enable    */
#define PCFR_ClkRun	(PCFR_OPDE*0)	/*  Clock Running in sleep mode    */
#define PCFR_ClkStp	(PCFR_OPDE*1)	/*  Clock Stopped in sleep mode    */
#define PCFR_FP 	0x00000002	/* Float PCMCIA pins               */
#define PCFR_PCMCIANeg	(PCFR_FP*0)	/*  PCMCIA pins Negated (1)        */
#define PCFR_PCMCIAFlt	(PCFR_FP*1)	/*  PCMCIA pins Floating           */
#define PCFR_FS 	0x00000004	/* Float Static memory pins        */
#define PCFR_StMemNeg	(PCFR_FS*0)	/*  Static Memory pins Negated (1) */
#define PCFR_StMemFlt	(PCFR_FS*1)	/*  Static Memory pins Floating    */
#define PCFR_FO 	0x00000008	/* Force RTC oscillator            */
                	        	/* (32.768 kHz) enable On          */

#define PPCR_CCF	Fld (5, 0)	/* CPU core Clock (CCLK) Freq.     */
#define PPCR_Fx16	        	/*  Freq. x 16 (fcpu = 16*fxtl)    */ \
                	(0x00 << FShft (PPCR_CCF))
#define PPCR_Fx20	        	/*  Freq. x 20 (fcpu = 20*fxtl)    */ \
                	(0x01 << FShft (PPCR_CCF))
#define PPCR_Fx24	        	/*  Freq. x 24 (fcpu = 24*fxtl)    */ \
                	(0x02 << FShft (PPCR_CCF))
#define PPCR_Fx28	        	/*  Freq. x 28 (fcpu = 28*fxtl)    */ \
                	(0x03 << FShft (PPCR_CCF))
#define PPCR_Fx32	        	/*  Freq. x 32 (fcpu = 32*fxtl)    */ \
                	(0x04 << FShft (PPCR_CCF))
#define PPCR_Fx36	        	/*  Freq. x 36 (fcpu = 36*fxtl)    */ \
                	(0x05 << FShft (PPCR_CCF))
#define PPCR_Fx40	        	/*  Freq. x 40 (fcpu = 40*fxtl)    */ \
                	(0x06 << FShft (PPCR_CCF))
#define PPCR_Fx44	        	/*  Freq. x 44 (fcpu = 44*fxtl)    */ \
                	(0x07 << FShft (PPCR_CCF))
#define PPCR_Fx48	        	/*  Freq. x 48 (fcpu = 48*fxtl)    */ \
                	(0x08 << FShft (PPCR_CCF))
#define PPCR_Fx52	        	/*  Freq. x 52 (fcpu = 52*fxtl)    */ \
                	(0x09 << FShft (PPCR_CCF))
#define PPCR_Fx56	        	/*  Freq. x 56 (fcpu = 56*fxtl)    */ \
                	(0x0A << FShft (PPCR_CCF))
#define PPCR_Fx60	        	/*  Freq. x 60 (fcpu = 60*fxtl)    */ \
                	(0x0B << FShft (PPCR_CCF))
#define PPCR_Fx64	        	/*  Freq. x 64 (fcpu = 64*fxtl)    */ \
                	(0x0C << FShft (PPCR_CCF))
#define PPCR_Fx68	        	/*  Freq. x 68 (fcpu = 68*fxtl)    */ \
                	(0x0D << FShft (PPCR_CCF))
#define PPCR_Fx72	        	/*  Freq. x 72 (fcpu = 72*fxtl)    */ \
                	(0x0E << FShft (PPCR_CCF))
#define PPCR_Fx76	        	/*  Freq. x 76 (fcpu = 76*fxtl)    */ \
                	(0x0F << FShft (PPCR_CCF))
                	        	/*  3.6864 MHz crystal (fxtl):     */
#define PPCR_F59_0MHz	PPCR_Fx16	/*   Freq. (fcpu) =  59.0 MHz      */
#define PPCR_F73_7MHz	PPCR_Fx20	/*   Freq. (fcpu) =  73.7 MHz      */
#define PPCR_F88_5MHz	PPCR_Fx24	/*   Freq. (fcpu) =  88.5 MHz      */
#define PPCR_F103_2MHz	PPCR_Fx28	/*   Freq. (fcpu) = 103.2 MHz      */
#define PPCR_F118_0MHz	PPCR_Fx32	/*   Freq. (fcpu) = 118.0 MHz      */
#define PPCR_F132_7MHz	PPCR_Fx36	/*   Freq. (fcpu) = 132.7 MHz      */
#define PPCR_F147_5MHz	PPCR_Fx40	/*   Freq. (fcpu) = 147.5 MHz      */
#define PPCR_F162_2MHz	PPCR_Fx44	/*   Freq. (fcpu) = 162.2 MHz      */
#define PPCR_F176_9MHz	PPCR_Fx48	/*   Freq. (fcpu) = 176.9 MHz      */
#define PPCR_F191_7MHz	PPCR_Fx52	/*   Freq. (fcpu) = 191.7 MHz      */
#define PPCR_F206_4MHz	PPCR_Fx56	/*   Freq. (fcpu) = 206.4 MHz      */
#define PPCR_F221_2MHz	PPCR_Fx60	/*   Freq. (fcpu) = 221.2 MHz      */
#define PPCR_F239_6MHz	PPCR_Fx64	/*   Freq. (fcpu) = 239.6 MHz      */
#define PPCR_F250_7MHz	PPCR_Fx68	/*   Freq. (fcpu) = 250.7 MHz      */
#define PPCR_F265_4MHz	PPCR_Fx72	/*   Freq. (fcpu) = 265.4 MHz      */
#define PPCR_F280_2MHz	PPCR_Fx76	/*   Freq. (fcpu) = 280.2 MHz      */
                	        	/*  3.5795 MHz crystal (fxtl):     */
#define PPCR_F57_3MHz	PPCR_Fx16	/*   Freq. (fcpu) =  57.3 MHz      */
#define PPCR_F71_6MHz	PPCR_Fx20	/*   Freq. (fcpu) =  71.6 MHz      */
#define PPCR_F85_9MHz	PPCR_Fx24	/*   Freq. (fcpu) =  85.9 MHz      */
#define PPCR_F100_2MHz	PPCR_Fx28	/*   Freq. (fcpu) = 100.2 MHz      */
#define PPCR_F114_5MHz	PPCR_Fx32	/*   Freq. (fcpu) = 114.5 MHz      */
#define PPCR_F128_9MHz	PPCR_Fx36	/*   Freq. (fcpu) = 128.9 MHz      */
#define PPCR_F143_2MHz	PPCR_Fx40	/*   Freq. (fcpu) = 143.2 MHz      */
#define PPCR_F157_5MHz	PPCR_Fx44	/*   Freq. (fcpu) = 157.5 MHz      */
#define PPCR_F171_8MHz	PPCR_Fx48	/*   Freq. (fcpu) = 171.8 MHz      */
#define PPCR_F186_1MHz	PPCR_Fx52	/*   Freq. (fcpu) = 186.1 MHz      */
#define PPCR_F200_5MHz	PPCR_Fx56	/*   Freq. (fcpu) = 200.5 MHz      */
#define PPCR_F214_8MHz	PPCR_Fx60	/*   Freq. (fcpu) = 214.8 MHz      */
#define PPCR_F229_1MHz	PPCR_Fx64	/*   Freq. (fcpu) = 229.1 MHz      */
#define PPCR_F243_4MHz	PPCR_Fx68	/*   Freq. (fcpu) = 243.4 MHz      */
#define PPCR_F257_7MHz	PPCR_Fx72	/*   Freq. (fcpu) = 257.7 MHz      */
#define PPCR_F272_0MHz	PPCR_Fx76	/*   Freq. (fcpu) = 272.0 MHz      */

#define POSR_OOK	0x00000001	/* RTC Oscillator (32.768 kHz) OK  */


/*
 * Reset Controller (RC) control registers
 *
 * Registers
 *    RSRR      	Reset Controller (RC) Software Reset Register
 *              	(read/write).
 *    RCSR      	Reset Controller (RC) Status Register (read/write).
 */

#define RSRR		__REG(0x90030000)  /* RC Software Reset Reg. */
#define RCSR		__REG(0x90030004)  /* RC Status Reg. */

#define RSRR_SWR	0x00000001	/* SoftWare Reset (set only)       */

#define RCSR_HWR	0x00000001	/* HardWare Reset                  */
#define RCSR_SWR	0x00000002	/* SoftWare Reset                  */
#define RCSR_WDR	0x00000004	/* Watch-Dog Reset                 */
#define RCSR_SMR	0x00000008	/* Sleep-Mode Reset                */


/*
 * Test unit control registers
 *
 * Registers
 *    TUCR      	Test Unit Control Register (read/write).
 */

#define TUCR		__REG(0x90030008)  /* Test Unit Control Reg. */

#define TUCR_TIC	0x00000040	/* TIC mode                        */
#define TUCR_TTST	0x00000080	/* Trim TeST mode                  */
#define TUCR_RCRC	0x00000100	/* Richard's Cyclic Redundancy     */
                	        	/* Check                           */
#define TUCR_PMD	0x00000200	/* Power Management Disable        */
#define TUCR_MR 	0x00000400	/* Memory Request mode             */
#define TUCR_NoMB	(TUCR_MR*0)	/*  No Memory Bus request & grant  */
#define TUCR_MBGPIO	(TUCR_MR*1)	/*  Memory Bus request (MBREQ) &   */
                	        	/*  grant (MBGNT) on GPIO [22:21]  */
#define TUCR_CTB	Fld (3, 20)	/* Clock Test Bits                 */
#define TUCR_FDC	0x00800000	/* RTC Force Delete Count          */
#define TUCR_FMC	0x01000000	/* Force Michelle's Control mode   */
#define TUCR_TMC	0x02000000	/* RTC Trimmer Multiplexer Control */
#define TUCR_DPS	0x04000000	/* Disallow Pad Sleep              */
#define TUCR_TSEL	Fld (3, 29)	/* clock Test SELect on GPIO [27]  */
#define TUCR_32_768kHz	        	/*  32.768 kHz osc. on GPIO [27]   */ \
                	(0 << FShft (TUCR_TSEL))
#define TUCR_3_6864MHz	        	/*  3.6864 MHz osc. on GPIO [27]   */ \
                	(1 << FShft (TUCR_TSEL))
#define TUCR_VDD	        	/*  VDD ring osc./16 on GPIO [27]  */ \
                	(2 << FShft (TUCR_TSEL))
#define TUCR_96MHzPLL	        	/*  96 MHz PLL/4 on GPIO [27]      */ \
                	(3 << FShft (TUCR_TSEL))
#define TUCR_Clock	        	/*  internal (fcpu/2) & 32.768 kHz */ \
                	        	/*  Clocks on GPIO [26:27]         */ \
                	(4 << FShft (TUCR_TSEL))
#define TUCR_3_6864MHzA	        	/*  3.6864 MHz osc. on GPIO [27]   */ \
                	        	/*  (Alternative)                  */ \
                	(5 << FShft (TUCR_TSEL))
#define TUCR_MainPLL	        	/*  Main PLL/16 on GPIO [27]       */ \
                	(6 << FShft (TUCR_TSEL))
#define TUCR_VDDL	        	/*  VDDL ring osc./4 on GPIO [27]  */ \
                	(7 << FShft (TUCR_TSEL))


/*
 * General-Purpose Input/Output (GPIO) control registers
 *
 * Registers
 *    GPLR      	General-Purpose Input/Output (GPIO) Pin Level
 *              	Register (read).
 *    GPDR      	General-Purpose Input/Output (GPIO) Pin Direction
 *              	Register (read/write).
 *    GPSR      	General-Purpose Input/Output (GPIO) Pin output Set
 *              	Register (write).
 *    GPCR      	General-Purpose Input/Output (GPIO) Pin output Clear
 *              	Register (write).
 *    GRER      	General-Purpose Input/Output (GPIO) Rising-Edge
 *              	detect Register (read/write).
 *    GFER      	General-Purpose Input/Output (GPIO) Falling-Edge
 *              	detect Register (read/write).
 *    GEDR      	General-Purpose Input/Output (GPIO) Edge Detect
 *              	status Register (read/write).
 *    GAFR      	General-Purpose Input/Output (GPIO) Alternate
 *              	Function Register (read/write).
 *
 * Clock
 *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
 */

#define GPLR		__REG(0x90040000)  /* GPIO Pin Level Reg.             */
#define GPDR		__REG(0x90040004)  /* GPIO Pin Direction Reg.         */
#define GPSR		__REG(0x90040008)  /* GPIO Pin output Set Reg.        */
#define GPCR		__REG(0x9004000C)  /* GPIO Pin output Clear Reg.      */
#define GRER		__REG(0x90040010)  /* GPIO Rising-Edge detect Reg.    */
#define GFER		__REG(0x90040014)  /* GPIO Falling-Edge detect Reg.   */
#define GEDR		__REG(0x90040018)  /* GPIO Edge Detect status Reg.    */
#define GAFR		__REG(0x9004001C)  /* GPIO Alternate Function Reg.    */

#define GPIO_MIN	(0)
#define GPIO_MAX	(27)

#define GPIO_GPIO(Nb)	        	/* GPIO [0..27]                    */ \
                	(0x00000001 << (Nb))
#define GPIO_GPIO0	GPIO_GPIO (0)	/* GPIO  [0]                       */
#define GPIO_GPIO1	GPIO_GPIO (1)	/* GPIO  [1]                       */
#define GPIO_GPIO2	GPIO_GPIO (2)	/* GPIO  [2]                       */
#define GPIO_GPIO3	GPIO_GPIO (3)	/* GPIO  [3]                       */
#define GPIO_GPIO4	GPIO_GPIO (4)	/* GPIO  [4]                       */
#define GPIO_GPIO5	GPIO_GPIO (5)	/* GPIO  [5]                       */
#define GPIO_GPIO6	GPIO_GPIO (6)	/* GPIO  [6]                       */
#define GPIO_GPIO7	GPIO_GPIO (7)	/* GPIO  [7]                       */
#define GPIO_GPIO8	GPIO_GPIO (8)	/* GPIO  [8]                       */
#define GPIO_GPIO9	GPIO_GPIO (9)	/* GPIO  [9]                       */
#define GPIO_GPIO10	GPIO_GPIO (10)	/* GPIO [10]                       */
#define GPIO_GPIO11	GPIO_GPIO (11)	/* GPIO [11]                       */
#define GPIO_GPIO12	GPIO_GPIO (12)	/* GPIO [12]                       */
#define GPIO_GPIO13	GPIO_GPIO (13)	/* GPIO [13]                       */
#define GPIO_GPIO14	GPIO_GPIO (14)	/* GPIO [14]                       */
#define GPIO_GPIO15	GPIO_GPIO (15)	/* GPIO [15]                       */
#define GPIO_GPIO16	GPIO_GPIO (16)	/* GPIO [16]                       */
#define GPIO_GPIO17	GPIO_GPIO (17)	/* GPIO [17]                       */
#define GPIO_GPIO18	GPIO_GPIO (18)	/* GPIO [18]                       */
#define GPIO_GPIO19	GPIO_GPIO (19)	/* GPIO [19]                       */
#define GPIO_GPIO20	GPIO_GPIO (20)	/* GPIO [20]                       */
#define GPIO_GPIO21	GPIO_GPIO (21)	/* GPIO [21]                       */
#define GPIO_GPIO22	GPIO_GPIO (22)	/* GPIO [22]                       */
#define GPIO_GPIO23	GPIO_GPIO (23)	/* GPIO [23]                       */
#define GPIO_GPIO24	GPIO_GPIO (24)	/* GPIO [24]                       */
#define GPIO_GPIO25	GPIO_GPIO (25)	/* GPIO [25]                       */
#define GPIO_GPIO26	GPIO_GPIO (26)	/* GPIO [26]                       */
#define GPIO_GPIO27	GPIO_GPIO (27)	/* GPIO [27]                       */

#define GPIO_LDD(Nb)	        	/* LCD Data [8..15] (O)            */ \
                	GPIO_GPIO ((Nb) - 6)
#define GPIO_LDD8	GPIO_LDD (8)	/* LCD Data  [8] (O)               */
#define GPIO_LDD9	GPIO_LDD (9)	/* LCD Data  [9] (O)               */
#define GPIO_LDD10	GPIO_LDD (10)	/* LCD Data [10] (O)               */
#define GPIO_LDD11	GPIO_LDD (11)	/* LCD Data [11] (O)               */
#define GPIO_LDD12	GPIO_LDD (12)	/* LCD Data [12] (O)               */
#define GPIO_LDD13	GPIO_LDD (13)	/* LCD Data [13] (O)               */
#define GPIO_LDD14	GPIO_LDD (14)	/* LCD Data [14] (O)               */
#define GPIO_LDD15	GPIO_LDD (15)	/* LCD Data [15] (O)               */
                	        	/* ser. port 4:                    */
#define GPIO_SSP_TXD	GPIO_GPIO (10)	/*  SSP Transmit Data (O)          */
#define GPIO_SSP_RXD	GPIO_GPIO (11)	/*  SSP Receive Data (I)           */
#define GPIO_SSP_SCLK	GPIO_GPIO (12)	/*  SSP Sample CLocK (O)           */
#define GPIO_SSP_SFRM	GPIO_GPIO (13)	/*  SSP Sample FRaMe (O)           */
                	        	/* ser. port 1:                    */
#define GPIO_UART_TXD	GPIO_GPIO (14)	/*  UART Transmit Data (O)         */
#define GPIO_UART_RXD	GPIO_GPIO (15)	/*  UART Receive Data (I)          */
#define GPIO_SDLC_SCLK	GPIO_GPIO (16)	/*  SDLC Sample CLocK (I/O)        */
#define GPIO_SDLC_AAF	GPIO_GPIO (17)	/*  SDLC Abort After Frame (O)     */
#define GPIO_UART_SCLK1	GPIO_GPIO (18)	/*  UART Sample CLocK 1 (I)        */
                	        	/* ser. port 4:                    */
#define GPIO_SSP_CLK	GPIO_GPIO (19)	/*  SSP external CLocK (I)         */
                	        	/* ser. port 3:                    */
#define GPIO_UART_SCLK3	GPIO_GPIO (20)	/*  UART Sample CLocK 3 (I)        */
                	        	/* ser. port 4:                    */
#define GPIO_MCP_CLK	GPIO_GPIO (21)	/*  MCP CLocK (I)                  */
                	        	/* test controller:                */
#define GPIO_TIC_ACK	GPIO_GPIO (21)	/*  TIC ACKnowledge (O)            */
#define GPIO_MBGNT	GPIO_GPIO (21)	/*  Memory Bus GraNT (O)           */
#define GPIO_TREQA	GPIO_GPIO (22)	/*  TIC REQuest A (I)              */
#define GPIO_MBREQ	GPIO_GPIO (22)	/*  Memory Bus REQuest (I)         */
#define GPIO_TREQB	GPIO_GPIO (23)	/*  TIC REQuest B (I)              */
#define GPIO_1Hz	GPIO_GPIO (25)	/* 1 Hz clock (O)                  */
#define GPIO_RCLK	GPIO_GPIO (26)	/* internal (R) CLocK (O, fcpu/2)  */
#define GPIO_32_768kHz	GPIO_GPIO (27)	/* 32.768 kHz clock (O, RTC)       */

#define GPDR_In 	0       	/* Input                           */
#define GPDR_Out	1       	/* Output                          */


/*
 * Interrupt Controller (IC) control registers
 *
 * Registers
 *    ICIP      	Interrupt Controller (IC) Interrupt ReQuest (IRQ)
 *              	Pending register (read).
 *    ICMR      	Interrupt Controller (IC) Mask Register (read/write).
 *    ICLR      	Interrupt Controller (IC) Level Register (read/write).
 *    ICCR      	Interrupt Controller (IC) Control Register
 *              	(read/write).
 *              	[The ICCR register is only implemented in versions 2.0
 *              	(rev. = 8) and higher of the StrongARM SA-1100.]
 *    ICFP      	Interrupt Controller (IC) Fast Interrupt reQuest
 *              	(FIQ) Pending register (read).
 *    ICPR      	Interrupt Controller (IC) Pending Register (read).
 *              	[The ICPR register is active low (inverted) in
 *              	versions 1.0 (rev. = 1) and 1.1 (rev. = 2) of the
 *              	StrongARM SA-1100, it is active high (non-inverted) in
 *              	versions 2.0 (rev. = 8) and higher.]
 */

#define ICIP		__REG(0x90050000)  /* IC IRQ Pending reg.             */
#define ICMR		__REG(0x90050004)  /* IC Mask Reg.                    */
#define ICLR		__REG(0x90050008)  /* IC Level Reg.                   */
#define ICCR		__REG(0x9005000C)  /* IC Control Reg.                 */
#define ICFP		__REG(0x90050010)  /* IC FIQ Pending reg.             */
#define ICPR		__REG(0x90050020)  /* IC Pending Reg.                 */

#define IC_GPIO(Nb)	        	/* GPIO [0..10]                    */ \
                	(0x00000001 << (Nb))
#define IC_GPIO0	IC_GPIO (0)	/* GPIO  [0]                       */
#define IC_GPIO1	IC_GPIO (1)	/* GPIO  [1]                       */
#define IC_GPIO2	IC_GPIO (2)	/* GPIO  [2]                       */
#define IC_GPIO3	IC_GPIO (3)	/* GPIO  [3]                       */
#define IC_GPIO4	IC_GPIO (4)	/* GPIO  [4]                       */
#define IC_GPIO5	IC_GPIO (5)	/* GPIO  [5]                       */
#define IC_GPIO6	IC_GPIO (6)	/* GPIO  [6]                       */
#define IC_GPIO7	IC_GPIO (7)	/* GPIO  [7]                       */
#define IC_GPIO8	IC_GPIO (8)	/* GPIO  [8]                       */
#define IC_GPIO9	IC_GPIO (9)	/* GPIO  [9]                       */
#define IC_GPIO10	IC_GPIO (10)	/* GPIO [10]                       */
#define IC_GPIO11_27	0x00000800	/* GPIO [11:27] (ORed)             */
#define IC_LCD  	0x00001000	/* LCD controller                  */
#define IC_Ser0UDC	0x00002000	/* Ser. port 0 UDC                 */
#define IC_Ser1SDLC	0x00004000	/* Ser. port 1 SDLC                */
#define IC_Ser1UART	0x00008000	/* Ser. port 1 UART                */
#define IC_Ser2ICP	0x00010000	/* Ser. port 2 ICP                 */
#define IC_Ser3UART	0x00020000	/* Ser. port 3 UART                */
#define IC_Ser4MCP	0x00040000	/* Ser. port 4 MCP                 */
#define IC_Ser4SSP	0x00080000	/* Ser. port 4 SSP                 */
#define IC_DMA(Nb)	        	/* DMA controller channel [0..5]   */ \
                	(0x00100000 << (Nb))
#define IC_DMA0 	IC_DMA (0)	/* DMA controller channel 0        */
#define IC_DMA1 	IC_DMA (1)	/* DMA controller channel 1        */
#define IC_DMA2 	IC_DMA (2)	/* DMA controller channel 2        */
#define IC_DMA3 	IC_DMA (3)	/* DMA controller channel 3        */
#define IC_DMA4 	IC_DMA (4)	/* DMA controller channel 4        */
#define IC_DMA5 	IC_DMA (5)	/* DMA controller channel 5        */
#define IC_OST(Nb)	        	/* OS Timer match [0..3]           */ \
                	(0x04000000 << (Nb))
#define IC_OST0 	IC_OST (0)	/* OS Timer match 0                */
#define IC_OST1 	IC_OST (1)	/* OS Timer match 1                */
#define IC_OST2 	IC_OST (2)	/* OS Timer match 2                */
#define IC_OST3 	IC_OST (3)	/* OS Timer match 3                */
#define IC_RTC1Hz	0x40000000	/* RTC 1 Hz clock                  */
#define IC_RTCAlrm	0x80000000	/* RTC Alarm                       */

#define ICLR_IRQ	0       	/* Interrupt ReQuest               */
#define ICLR_FIQ	1       	/* Fast Interrupt reQuest          */

#define ICCR_DIM	0x00000001	/* Disable Idle-mode interrupt     */
                	        	/* Mask                            */
#define ICCR_IdleAllInt	(ICCR_DIM*0)	/*  Idle-mode All Interrupt enable */
                	        	/*  (ICMR ignored)                 */
#define ICCR_IdleMskInt	(ICCR_DIM*1)	/*  Idle-mode non-Masked Interrupt */
                	        	/*  enable (ICMR used)             */


/*
 * Peripheral Pin Controller (PPC) control registers
 *
 * Registers
 *    PPDR      	Peripheral Pin Controller (PPC) Pin Direction
 *              	Register (read/write).
 *    PPSR      	Peripheral Pin Controller (PPC) Pin State Register
 *              	(read/write).
 *    PPAR      	Peripheral Pin Controller (PPC) Pin Assignment
 *              	Register (read/write).
 *    PSDR      	Peripheral Pin Controller (PPC) Sleep-mode pin
 *              	Direction Register (read/write).
 *    PPFR      	Peripheral Pin Controller (PPC) Pin Flag Register
 *              	(read).
 */

#define PPDR		__REG(0x90060000)  /* PPC Pin Direction Reg.          */
#define PPSR		__REG(0x90060004)  /* PPC Pin State Reg.              */
#define PPAR		__REG(0x90060008)  /* PPC Pin Assignment Reg.         */
#define PSDR		__REG(0x9006000C)  /* PPC Sleep-mode pin Direction Reg. */
#define PPFR		__REG(0x90060010)  /* PPC Pin Flag Reg.               */

#define PPC_LDD(Nb)	        	/* LCD Data [0..7]                 */ \
                	(0x00000001 << (Nb))
#define PPC_LDD0	PPC_LDD (0)	/* LCD Data [0]                    */
#define PPC_LDD1	PPC_LDD (1)	/* LCD Data [1]                    */
#define PPC_LDD2	PPC_LDD (2)	/* LCD Data [2]                    */
#define PPC_LDD3	PPC_LDD (3)	/* LCD Data [3]                    */
#define PPC_LDD4	PPC_LDD (4)	/* LCD Data [4]                    */
#define PPC_LDD5	PPC_LDD (5)	/* LCD Data [5]                    */
#define PPC_LDD6	PPC_LDD (6)	/* LCD Data [6]                    */
#define PPC_LDD7	PPC_LDD (7)	/* LCD Data [7]                    */
#define PPC_L_PCLK	0x00000100	/* LCD Pixel CLocK                 */
#define PPC_L_LCLK	0x00000200	/* LCD Line CLocK                  */
#define PPC_L_FCLK	0x00000400	/* LCD Frame CLocK                 */
#define PPC_L_BIAS	0x00000800	/* LCD AC BIAS                     */
                	        	/* ser. port 1:                    */
#define PPC_TXD1	0x00001000	/*  SDLC/UART Transmit Data 1      */
#define PPC_RXD1	0x00002000	/*  SDLC/UART Receive Data 1       */
                	        	/* ser. port 2:                    */
#define PPC_TXD2	0x00004000	/*  IPC Transmit Data 2            */
#define PPC_RXD2	0x00008000	/*  IPC Receive Data 2             */
                	        	/* ser. port 3:                    */
#define PPC_TXD3	0x00010000	/*  UART Transmit Data 3           */
#define PPC_RXD3	0x00020000	/*  UART Receive Data 3            */
                	        	/* ser. port 4:                    */
#define PPC_TXD4	0x00040000	/*  MCP/SSP Transmit Data 4        */
#define PPC_RXD4	0x00080000	/*  MCP/SSP Receive Data 4         */
#define PPC_SCLK	0x00100000	/*  MCP/SSP Sample CLocK           */
#define PPC_SFRM	0x00200000	/*  MCP/SSP Sample FRaMe           */

#define PPDR_In 	0       	/* Input                           */
#define PPDR_Out	1       	/* Output                          */

                	        	/* ser. port 1:                    */
#define PPAR_UPR	0x00001000	/*  UART Pin Reassignment          */
#define PPAR_UARTTR	(PPAR_UPR*0)	/*   UART on TXD_1 & RXD_1         */
#define PPAR_UARTGPIO	(PPAR_UPR*1)	/*   UART on GPIO [14:15]          */
                	        	/* ser. port 4:                    */
#define PPAR_SPR	0x00040000	/*  SSP Pin Reassignment           */
#define PPAR_SSPTRSS	(PPAR_SPR*0)	/*   SSP on TXD_C, RXD_C, SCLK_C,  */
                	        	/*   & SFRM_C                      */
#define PPAR_SSPGPIO	(PPAR_SPR*1)	/*   SSP on GPIO [10:13]           */

#define PSDR_OutL	0       	/* Output Low in sleep mode        */
#define PSDR_Flt	1       	/* Floating (input) in sleep mode  */

#define PPFR_LCD	0x00000001	/* LCD controller                  */
#define PPFR_SP1TX	0x00001000	/* Ser. Port 1 SDLC/UART Transmit  */
#define PPFR_SP1RX	0x00002000	/* Ser. Port 1 SDLC/UART Receive   */
#define PPFR_SP2TX	0x00004000	/* Ser. Port 2 ICP Transmit        */
#define PPFR_SP2RX	0x00008000	/* Ser. Port 2 ICP Receive         */
#define PPFR_SP3TX	0x00010000	/* Ser. Port 3 UART Transmit       */
#define PPFR_SP3RX	0x00020000	/* Ser. Port 3 UART Receive        */
#define PPFR_SP4	0x00040000	/* Ser. Port 4 MCP/SSP             */
#define PPFR_PerEn	0       	/* Peripheral Enabled              */
#define PPFR_PPCEn	1       	/* PPC Enabled                     */


/*
 * Dynamic Random-Access Memory (DRAM) control registers
 *
 * Registers
 *    MDCNFG    	Memory system: Dynamic Random-Access Memory (DRAM)
 *              	CoNFiGuration register (read/write).
 *    MDCAS0    	Memory system: Dynamic Random-Access Memory (DRAM)
 *              	Column Address Strobe (CAS) shift register 0
 *              	(read/write).
 *    MDCAS1    	Memory system: Dynamic Random-Access Memory (DRAM)
 *              	Column Address Strobe (CAS) shift register 1
 *              	(read/write).
 *    MDCAS2    	Memory system: Dynamic Random-Access Memory (DRAM)
 *              	Column Address Strobe (CAS) shift register 2
 *              	(read/write).
 *
 * Clocks
 *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
 *    fmem, Tmem	Frequency, period of the memory clock (fmem = fcpu/2).
 *    fcas, Tcas	Frequency, period of the DRAM CAS shift registers.
 */

#define MDCNFG		__REG(0xA0000000)  /*  DRAM CoNFiGuration reg. */
#define MDCAS0		__REG(0xA0000004)  /* DRAM CAS shift reg. 0 */
#define MDCAS1		__REG(0xA0000008)  /* DRAM CAS shift reg. 1 */
#define MDCAS2		__REG(0xA000000c)  /* DRAM CAS shift reg. 2 */

/* SA1100 MDCNFG values */
#define MDCNFG_DE(Nb)	        	/* DRAM Enable bank [0..3]         */ \
                	(0x00000001 << (Nb))
#define MDCNFG_DE0	MDCNFG_DE (0)	/* DRAM Enable bank 0              */
#define MDCNFG_DE1	MDCNFG_DE (1)	/* DRAM Enable bank 1              */
#define MDCNFG_DE2	MDCNFG_DE (2)	/* DRAM Enable bank 2              */
#define MDCNFG_DE3	MDCNFG_DE (3)	/* DRAM Enable bank 3              */
#define MDCNFG_DRAC	Fld (2, 4)	/* DRAM Row Address Count - 9      */
#define MDCNFG_RowAdd(Add)      	/*  Row Address count [9..12]      */ \
                	(((Add) - 9) << FShft (MDCNFG_DRAC))
#define MDCNFG_CDB2	0x00000040	/* shift reg. Clock Divide By 2    */
                	        	/* (fcas = fcpu/2)                 */
#define MDCNFG_TRP	Fld (4, 7)	/* Time RAS Pre-charge - 1 [Tmem]  */
#define MDCNFG_PrChrg(Tcpu)     	/*  Pre-Charge time [2..32 Tcpu]   */ \
                	(((Tcpu) - 2)/2 << FShft (MDCNFG_TRP))
#define MDCNFG_CeilPrChrg(Tcpu) 	/*  Ceil. of PrChrg [2..32 Tcpu]   */ \
                	(((Tcpu) - 1)/2 << FShft (MDCNFG_TRP))
#define MDCNFG_TRASR	Fld (4, 11)	/* Time RAS Refresh - 1 [Tmem]     */
#define MDCNFG_Ref(Tcpu)        	/*  Refresh time [2..32 Tcpu]      */ \
                	(((Tcpu) - 2)/2 << FShft (MDCNFG_TRASR))
#define MDCNFG_CeilRef(Tcpu)    	/*  Ceil. of Ref [2..32 Tcpu]      */ \
                	(((Tcpu) - 1)/2 << FShft (MDCNFG_TRASR))
#define MDCNFG_TDL	Fld (2, 15)	/* Time Data Latch [Tcpu]          */
#define MDCNFG_DataLtch(Tcpu)   	/*  Data Latch delay [0..3 Tcpu]   */ \
                	((Tcpu) << FShft (MDCNFG_TDL))
#define MDCNFG_DRI	Fld (15, 17)	/* min. DRAM Refresh Interval/4    */
                	        	/* [Tmem]                          */
#define MDCNFG_RefInt(Tcpu)     	/*  min. Refresh Interval          */ \
                	        	/*  [0..262136 Tcpu]               */ \
                	((Tcpu)/8 << FShft (MDCNFG_DRI))

/* SA1110 MDCNFG values */
#define MDCNFG_SA1110_DE0	0x00000001	/* DRAM Enable bank 0        */
#define MDCNFG_SA1110_DE1	0x00000002 	/* DRAM Enable bank 1        */
#define MDCNFG_SA1110_DTIM0	0x00000004	/* DRAM timing type 0/1      */
#define MDCNFG_SA1110_DWID0	0x00000008	/* DRAM bus width 0/1        */
#define MDCNFG_SA1110_DRAC0	Fld(3, 4)	/* DRAM row addr bit count   */
                	        		/* bank 0/1                  */
#define MDCNFG_SA1110_CDB20	0x00000080	/* Mem Clock divide by 2 0/1 */
#define MDCNFG_SA1110_TRP0	Fld(3, 8)	/* RAS precharge 0/1         */
#define MDCNFG_SA1110_TDL0	Fld(2, 12)	/* Data input latch after CAS*/
                	        		/* deassertion 0/1           */
#define MDCNFG_SA1110_TWR0	Fld(2, 14)	/* SDRAM write recovery 0/1  */
#define MDCNFG_SA1110_DE2	0x00010000	/* DRAM Enable bank 0        */
#define MDCNFG_SA1110_DE3	0x00020000 	/* DRAM Enable bank 1        */
#define MDCNFG_SA1110_DTIM2	0x00040000	/* DRAM timing type 0/1      */
#define MDCNFG_SA1110_DWID2	0x00080000	/* DRAM bus width 0/1        */
#define MDCNFG_SA1110_DRAC2	Fld(3, 20)	/* DRAM row addr bit count   */
                	        		/* bank 0/1                  */
#define MDCNFG_SA1110_CDB22	0x00800000	/* Mem Clock divide by 2 0/1 */
#define MDCNFG_SA1110_TRP2	Fld(3, 24)	/* RAS precharge 0/1         */
#define MDCNFG_SA1110_TDL2	Fld(2, 28)	/* Data input latch after CAS*/
                	        		/* deassertion 0/1           */
#define MDCNFG_SA1110_TWR2	Fld(2, 30)	/* SDRAM write recovery 0/1  */


/*
 * Static memory control registers
 *
 * Registers
 *    MSC0      	Memory system: Static memory Control register 0
 *              	(read/write).
 *    MSC1      	Memory system: Static memory Control register 1
 *              	(read/write).
 *
 * Clocks
 *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
 *    fmem, Tmem	Frequency, period of the memory clock (fmem = fcpu/2).
 */

#define MSC0		__REG(0xa0000010)  /* Static memory Control reg. 0 */
#define MSC1		__REG(0xa0000014)  /* Static memory Control reg. 1 */
#define MSC2		__REG(0xa000002c)  /* Static memory Control reg. 2, not contiguous   */

#define MSC_Bnk(Nb)	        	/* static memory Bank [0..3]       */ \
                	Fld (16, ((Nb) Modulo 2)*16)
#define MSC0_Bnk0	MSC_Bnk (0)	/* static memory Bank 0            */
#define MSC0_Bnk1	MSC_Bnk (1)	/* static memory Bank 1            */
#define MSC1_Bnk2	MSC_Bnk (2)	/* static memory Bank 2            */
#define MSC1_Bnk3	MSC_Bnk (3)	/* static memory Bank 3            */

#define MSC_RT  	Fld (2, 0)	/* ROM/static memory Type          */
#define MSC_NonBrst	        	/*  Non-Burst static memory        */ \
                	(0 << FShft (MSC_RT))
#define MSC_SRAM	        	/*  32-bit byte-writable SRAM      */ \
                	(1 << FShft (MSC_RT))
#define MSC_Brst4	        	/*  Burst-of-4 static memory       */ \
                	(2 << FShft (MSC_RT))
#define MSC_Brst8	        	/*  Burst-of-8 static memory       */ \
                	(3 << FShft (MSC_RT))
#define MSC_RBW 	0x0004  	/* ROM/static memory Bus Width     */
#define MSC_32BitStMem	(MSC_RBW*0)	/*  32-Bit Static Memory           */
#define MSC_16BitStMem	(MSC_RBW*1)	/*  16-Bit Static Memory           */
#define MSC_RDF 	Fld (5, 3)	/* ROM/static memory read Delay    */
                	        	/* First access - 1(.5) [Tmem]     */
#define MSC_1stRdAcc(Tcpu)      	/*  1st Read Access time (burst    */ \
                	        	/*  static memory) [3..65 Tcpu]    */ \
                	((((Tcpu) - 3)/2) << FShft (MSC_RDF))
#define MSC_Ceil1stRdAcc(Tcpu)  	/*  Ceil. of 1stRdAcc [3..65 Tcpu] */ \
                	((((Tcpu) - 2)/2) << FShft (MSC_RDF))
#define MSC_RdAcc(Tcpu)	        	/*  Read Access time (non-burst    */ \
                	        	/*  static memory) [2..64 Tcpu]    */ \
                	((((Tcpu) - 2)/2) << FShft (MSC_RDF))
#define MSC_CeilRdAcc(Tcpu)     	/*  Ceil. of RdAcc [2..64 Tcpu]    */ \
                	((((Tcpu) - 1)/2) << FShft (MSC_RDF))
#define MSC_RDN 	Fld (5, 8)	/* ROM/static memory read Delay    */
                	        	/* Next access - 1 [Tmem]          */
#define MSC_NxtRdAcc(Tcpu)      	/*  Next Read Access time (burst   */ \
                	        	/*  static memory) [2..64 Tcpu]    */ \
                	((((Tcpu) - 2)/2) << FShft (MSC_RDN))
#define MSC_CeilNxtRdAcc(Tcpu)  	/*  Ceil. of NxtRdAcc [2..64 Tcpu] */ \
                	((((Tcpu) - 1)/2) << FShft (MSC_RDN))
#define MSC_WrAcc(Tcpu)	        	/*  Write Access time (non-burst   */ \
                	        	/*  static memory) [2..64 Tcpu]    */ \
                	((((Tcpu) - 2)/2) << FShft (MSC_RDN))
#define MSC_CeilWrAcc(Tcpu)     	/*  Ceil. of WrAcc [2..64 Tcpu]    */ \
                	((((Tcpu) - 1)/2) << FShft (MSC_RDN))
#define MSC_RRR 	Fld (3, 13)	/* ROM/static memory RecoveRy      */
                	        	/* time/2 [Tmem]                   */
#define MSC_Rec(Tcpu)	        	/*  Recovery time [0..28 Tcpu]     */ \
                	(((Tcpu)/4) << FShft (MSC_RRR))
#define MSC_CeilRec(Tcpu)       	/*  Ceil. of Rec [0..28 Tcpu]      */ \
                	((((Tcpu) + 3)/4) << FShft (MSC_RRR))


/*
 * Personal Computer Memory Card International Association (PCMCIA) control
 * register
 *
 * Register
 *    MECR      	Memory system: Expansion memory bus (PCMCIA)
 *              	Configuration Register (read/write).
 *
 * Clocks
 *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
 *    fmem, Tmem	Frequency, period of the memory clock (fmem = fcpu/2).
 *    fbclk, Tbclk	Frequency, period of the PCMCIA clock (BCLK).
 */

                	        	/* Memory system:                  */
#define MECR		__REG(0xA0000018)  /*  Expansion memory bus (PCMCIA) Configuration Reg.             */

#define MECR_PCMCIA(Nb)	        	/* PCMCIA [0..1]                   */ \
                	Fld (15, (Nb)*16)
#define MECR_PCMCIA0	MECR_PCMCIA (0)	/* PCMCIA 0                        */
#define MECR_PCMCIA1	MECR_PCMCIA (1)	/* PCMCIA 1                        */

#define MECR_BSIO	Fld (5, 0)	/* BCLK Select I/O - 1 [Tmem]      */
#define MECR_IOClk(Tcpu)        	/*  I/O Clock [2..64 Tcpu]         */ \
                	((((Tcpu) - 2)/2) << FShft (MECR_BSIO))
#define MECR_CeilIOClk(Tcpu)    	/*  Ceil. of IOClk [2..64 Tcpu]    */ \
                	((((Tcpu) - 1)/2) << FShft (MECR_BSIO))
#define MECR_BSA	Fld (5, 5)	/* BCLK Select Attribute - 1       */
                	        	/* [Tmem]                          */
#define MECR_AttrClk(Tcpu)      	/*  Attribute Clock [2..64 Tcpu]   */ \
                	((((Tcpu) - 2)/2) << FShft (MECR_BSA))
#define MECR_CeilAttrClk(Tcpu)  	/*  Ceil. of AttrClk [2..64 Tcpu]  */ \
                	((((Tcpu) - 1)/2) << FShft (MECR_BSA))
#define MECR_BSM	Fld (5, 10)	/* BCLK Select Memory - 1 [Tmem]   */
#define MECR_MemClk(Tcpu)       	/*  Memory Clock [2..64 Tcpu]      */ \
                	((((Tcpu) - 2)/2) << FShft (MECR_BSM))
#define MECR_CeilMemClk(Tcpu)   	/*  Ceil. of MemClk [2..64 Tcpu]   */ \
                	((((Tcpu) - 1)/2) << FShft (MECR_BSM))

/*
 * On SA1110 only
 */

#define MDREFR		__REG(0xA000001C)

#define MDREFR_TRASR		Fld (4, 0)
#define MDREFR_DRI		Fld (12, 4)
#define MDREFR_E0PIN		(1 << 16)
#define MDREFR_K0RUN		(1 << 17)
#define MDREFR_K0DB2		(1 << 18)
#define MDREFR_E1PIN		(1 << 20)
#define MDREFR_K1RUN		(1 << 21)
#define MDREFR_K1DB2		(1 << 22)
#define MDREFR_K2RUN		(1 << 25)
#define MDREFR_K2DB2		(1 << 26)
#define MDREFR_EAPD		(1 << 28)
#define MDREFR_KAPD		(1 << 29)
#define MDREFR_SLFRSH		(1 << 31)


/*
 * Direct Memory Access (DMA) control registers
 */
#define DMA_SIZE	(6 * 0x20)
#define DMA_PHYS	0xb0000000


/*
 * Liquid Crystal Display (LCD) control registers
 *
 * Registers
 *    LCCR0     	Liquid Crystal Display (LCD) Control Register 0
 *              	(read/write).
 *              	[Bits LDM, BAM, and ERM are only implemented in
 *              	versions 2.0 (rev. = 8) and higher of the StrongARM
 *              	SA-1100.]
 *    LCSR      	Liquid Crystal Display (LCD) Status Register
 *              	(read/write).
 *              	[Bit LDD can be only read in versions 1.0 (rev. = 1)
 *              	and 1.1 (rev. = 2) of the StrongARM SA-1100, it can be
 *              	read and written (cleared) in versions 2.0 (rev. = 8)
 *              	and higher.]
 *    DBAR1     	Liquid Crystal Display (LCD) Direct Memory Access
 *              	(DMA) Base Address Register channel 1 (read/write).
 *    DCAR1     	Liquid Crystal Display (LCD) Direct Memory Access
 *              	(DMA) Current Address Register channel 1 (read).
 *    DBAR2     	Liquid Crystal Display (LCD) Direct Memory Access
 *              	(DMA) Base Address Register channel 2 (read/write).
 *    DCAR2     	Liquid Crystal Display (LCD) Direct Memory Access
 *              	(DMA) Current Address Register channel 2 (read).
 *    LCCR1     	Liquid Crystal Display (LCD) Control Register 1
 *              	(read/write).
 *              	[The LCCR1 register can be only written in
 *              	versions 1.0 (rev. = 1) and 1.1 (rev. = 2) of the
 *              	StrongARM SA-1100, it can be written and read in
 *              	versions 2.0 (rev. = 8) and higher.]
 *    LCCR2     	Liquid Crystal Display (LCD) Control Register 2
 *              	(read/write).
 *              	[The LCCR1 register can be only written in
 *              	versions 1.0 (rev. = 1) and 1.1 (rev. = 2) of the
 *              	StrongARM SA-1100, it can be written and read in
 *              	versions 2.0 (rev. = 8) and higher.]
 *    LCCR3     	Liquid Crystal Display (LCD) Control Register 3
 *              	(read/write).
 *              	[The LCCR1 register can be only written in
 *              	versions 1.0 (rev. = 1) and 1.1 (rev. = 2) of the
 *              	StrongARM SA-1100, it can be written and read in
 *              	versions 2.0 (rev. = 8) and higher. Bit PCP is only
 *              	implemented in versions 2.0 (rev. = 8) and higher of
 *              	the StrongARM SA-1100.]
 *
 * Clocks
 *    fcpu, Tcpu	Frequency, period of the CPU core clock (CCLK).
 *    fmem, Tmem	Frequency, period of the memory clock (fmem = fcpu/2).
 *    fpix, Tpix	Frequency, period of the pixel clock.
 *    fln, Tln  	Frequency, period of the line clock.
 *    fac, Tac  	Frequency, period of the AC bias clock.
 */

#define LCD_PEntrySp	2       	/* LCD Palette Entry Space [byte]  */
#define LCD_4BitPSp	        	/* LCD 4-Bit pixel Palette Space   */ \
                	        	/* [byte]                          */ \
                	(16*LCD_PEntrySp)
#define LCD_8BitPSp	        	/* LCD 8-Bit pixel Palette Space   */ \
                	        	/* [byte]                          */ \
                	(256*LCD_PEntrySp)
#define LCD_12_16BitPSp	        	/* LCD 12/16-Bit pixel             */ \
                	        	/* dummy-Palette Space [byte]      */ \
                	(16*LCD_PEntrySp)

#define LCD_PGrey	Fld (4, 0)	/* LCD Palette entry Grey value    */
#define LCD_PBlue	Fld (4, 0)	/* LCD Palette entry Blue value    */
#define LCD_PGreen	Fld (4, 4)	/* LCD Palette entry Green value   */
#define LCD_PRed	Fld (4, 8)	/* LCD Palette entry Red value     */
#define LCD_PBS 	Fld (2, 12)	/* LCD Pixel Bit Size              */
#define LCD_4Bit	        	/*  LCD 4-Bit pixel mode           */ \
                	(0 << FShft (LCD_PBS))
#define LCD_8Bit	        	/*  LCD 8-Bit pixel mode           */ \
                	(1 << FShft (LCD_PBS))
#define LCD_12_16Bit	        	/*  LCD 12/16-Bit pixel mode       */ \
                	(2 << FShft (LCD_PBS))

#define LCD_Int0_0	0x0     	/* LCD Intensity =   0.0% =  0     */
#define LCD_Int11_1	0x1     	/* LCD Intensity =  11.1% =  1/9   */
#define LCD_Int20_0	0x2     	/* LCD Intensity =  20.0% =  1/5   */
#define LCD_Int26_7	0x3     	/* LCD Intensity =  26.7% =  4/15  */
#define LCD_Int33_3	0x4     	/* LCD Intensity =  33.3% =  3/9   */
#define LCD_Int40_0	0x5     	/* LCD Intensity =  40.0% =  2/5   */
#define LCD_Int44_4	0x6     	/* LCD Intensity =  44.4% =  4/9   */
#define LCD_Int50_0	0x7     	/* LCD Intensity =  50.0% =  1/2   */
#define LCD_Int55_6	0x8     	/* LCD Intensity =  55.6% =  5/9   */
#define LCD_Int60_0	0x9     	/* LCD Intensity =  60.0% =  3/5   */
#define LCD_Int66_7	0xA     	/* LCD Intensity =  66.7% =  6/9   */
#define LCD_Int73_3	0xB     	/* LCD Intensity =  73.3% = 11/15  */
#define LCD_Int80_0	0xC     	/* LCD Intensity =  80.0% =  4/5   */
#define LCD_Int88_9	0xD     	/* LCD Intensity =  88.9% =  8/9   */
#define LCD_Int100_0	0xE     	/* LCD Intensity = 100.0% =  1     */
#define LCD_Int100_0A	0xF     	/* LCD Intensity = 100.0% =  1     */
                	        	/* (Alternative)                   */

#define LCCR0_LEN	0x00000001	/* LCD ENable                      */
#define LCCR0_CMS	0x00000002	/* Color/Monochrome display Select */
#define LCCR0_Color	(LCCR0_CMS*0)	/*  Color display                  */
#define LCCR0_Mono	(LCCR0_CMS*1)	/*  Monochrome display             */
#define LCCR0_SDS	0x00000004	/* Single/Dual panel display       */
                	        	/* Select                          */
#define LCCR0_Sngl	(LCCR0_SDS*0)	/*  Single panel display           */
#define LCCR0_Dual	(LCCR0_SDS*1)	/*  Dual panel display             */
#define LCCR0_LDM	0x00000008	/* LCD Disable done (LDD)          */
                	        	/* interrupt Mask (disable)        */
#define LCCR0_BAM	0x00000010	/* Base Address update (BAU)       */
                	        	/* interrupt Mask (disable)        */
#define LCCR0_ERM	0x00000020	/* LCD ERror (BER, IOL, IUL, IOU,  */
                	        	/* IUU, OOL, OUL, OOU, and OUU)    */
                	        	/* interrupt Mask (disable)        */
#define LCCR0_PAS	0x00000080	/* Passive/Active display Select   */
#define LCCR0_Pas	(LCCR0_PAS*0)	/*  Passive display (STN)          */
#define LCCR0_Act	(LCCR0_PAS*1)	/*  Active display (TFT)           */
#define LCCR0_BLE	0x00000100	/* Big/Little Endian select        */
#define LCCR0_LtlEnd	(LCCR0_BLE*0)	/*  Little Endian frame buffer     */
#define LCCR0_BigEnd	(LCCR0_BLE*1)	/*  Big Endian frame buffer        */
#define LCCR0_DPD	0x00000200	/* Double Pixel Data (monochrome   */
                	        	/* display mode)                   */
#define LCCR0_4PixMono	(LCCR0_DPD*0)	/*  4-Pixel/clock Monochrome       */
                	        	/*  display                        */
#define LCCR0_8PixMono	(LCCR0_DPD*1)	/*  8-Pixel/clock Monochrome       */
                	        	/*  display                        */
#define LCCR0_PDD	Fld (8, 12)	/* Palette DMA request Delay       */
                	        	/* [Tmem]                          */
#define LCCR0_DMADel(Tcpu)      	/*  palette DMA request Delay      */ \
                	        	/*  [0..510 Tcpu]                  */ \
                	((Tcpu)/2 << FShft (LCCR0_PDD))

#define LCSR_LDD	0x00000001	/* LCD Disable Done                */
#define LCSR_BAU	0x00000002	/* Base Address Update (read)      */
#define LCSR_BER	0x00000004	/* Bus ERror                       */
#define LCSR_ABC	0x00000008	/* AC Bias clock Count             */
#define LCSR_IOL	0x00000010	/* Input FIFO Over-run Lower       */
                	        	/* panel                           */
#define LCSR_IUL	0x00000020	/* Input FIFO Under-run Lower      */
                	        	/* panel                           */
#define LCSR_IOU	0x00000040	/* Input FIFO Over-run Upper       */
                	        	/* panel                           */
#define LCSR_IUU	0x00000080	/* Input FIFO Under-run Upper      */
                	        	/* panel                           */
#define LCSR_OOL	0x00000100	/* Output FIFO Over-run Lower      */
                	        	/* panel                           */
#define LCSR_OUL	0x00000200	/* Output FIFO Under-run Lower     */
                	        	/* panel                           */
#define LCSR_OOU	0x00000400	/* Output FIFO Over-run Upper      */
                	        	/* panel                           */
#define LCSR_OUU	0x00000800	/* Output FIFO Under-run Upper     */
                	        	/* panel                           */

#define LCCR1_PPL	Fld (6, 4)	/* Pixels Per Line/16 - 1          */
#define LCCR1_DisWdth(Pixel)    	/*  Display Width [16..1024 pix.]  */ \
                	(((Pixel) - 16)/16 << FShft (LCCR1_PPL))
#define LCCR1_HSW	Fld (6, 10)	/* Horizontal Synchronization      */
                	        	/* pulse Width - 1 [Tpix] (L_LCLK) */
#define LCCR1_HorSnchWdth(Tpix) 	/*  Horizontal Synchronization     */ \
                	        	/*  pulse Width [1..64 Tpix]       */ \
                	(((Tpix) - 1) << FShft (LCCR1_HSW))
#define LCCR1_ELW	Fld (8, 16)	/* End-of-Line pixel clock Wait    */
                	        	/* count - 1 [Tpix]                */
#define LCCR1_EndLnDel(Tpix)    	/*  End-of-Line Delay              */ \
                	        	/*  [1..256 Tpix]                  */ \
                	(((Tpix) - 1) << FShft (LCCR1_ELW))
#define LCCR1_BLW	Fld (8, 24)	/* Beginning-of-Line pixel clock   */
                	        	/* Wait count - 1 [Tpix]           */
#define LCCR1_BegLnDel(Tpix)    	/*  Beginning-of-Line Delay        */ \
                	        	/*  [1..256 Tpix]                  */ \
                	(((Tpix) - 1) << FShft (LCCR1_BLW))

#define LCCR2_LPP	Fld (10, 0)	/* Line Per Panel - 1              */
#define LCCR2_DisHght(Line)     	/*  Display Height [1..1024 lines] */ \
                	(((Line) - 1) << FShft (LCCR2_LPP))
#define LCCR2_VSW	Fld (6, 10)	/* Vertical Synchronization pulse  */
                	        	/* Width - 1 [Tln] (L_FCLK)        */
#define LCCR2_VrtSnchWdth(Tln)  	/*  Vertical Synchronization pulse */ \
                	        	/*  Width [1..64 Tln]              */ \
                	(((Tln) - 1) << FShft (LCCR2_VSW))
#define LCCR2_EFW	Fld (8, 16)	/* End-of-Frame line clock Wait    */
                	        	/* count [Tln]                     */
#define LCCR2_EndFrmDel(Tln)    	/*  End-of-Frame Delay             */ \
                	        	/*  [0..255 Tln]                   */ \
                	((Tln) << FShft (LCCR2_EFW))
#define LCCR2_BFW	Fld (8, 24)	/* Beginning-of-Frame line clock   */
                	        	/* Wait count [Tln]                */
#define LCCR2_BegFrmDel(Tln)    	/*  Beginning-of-Frame Delay       */ \
                	        	/*  [0..255 Tln]                   */ \
                	((Tln) << FShft (LCCR2_BFW))

#define LCCR3_PCD	Fld (8, 0)	/* Pixel Clock Divisor/2 - 2       */
                	        	/* [1..255] (L_PCLK)               */
                	        	/* fpix = fcpu/(2*(PCD + 2))       */
                	        	/* Tpix = 2*(PCD + 2)*Tcpu         */
#define LCCR3_PixClkDiv(Div)    	/*  Pixel Clock Divisor [6..514]   */ \
                	(((Div) - 4)/2 << FShft (LCCR3_PCD))
                	        	/*  fpix = fcpu/(2*Floor (Div/2))  */
                	        	/*  Tpix = 2*Floor (Div/2)*Tcpu    */
#define LCCR3_CeilPixClkDiv(Div)	/*  Ceil. of PixClkDiv [6..514]    */ \
                	(((Div) - 3)/2 << FShft (LCCR3_PCD))
                	        	/*  fpix = fcpu/(2*Ceil (Div/2))   */
                	        	/*  Tpix = 2*Ceil (Div/2)*Tcpu     */
#define LCCR3_ACB	Fld (8, 8)	/* AC Bias clock half period - 1   */
                	        	/* [Tln] (L_BIAS)                  */
#define LCCR3_ACBsDiv(Div)      	/*  AC Bias clock Divisor [2..512] */ \
                	(((Div) - 2)/2 << FShft (LCCR3_ACB))
                	        	/*  fac = fln/(2*Floor (Div/2))    */
                	        	/*  Tac = 2*Floor (Div/2)*Tln      */
#define LCCR3_CeilACBsDiv(Div)  	/*  Ceil. of ACBsDiv [2..512]      */ \
                	(((Div) - 1)/2 << FShft (LCCR3_ACB))
                	        	/*  fac = fln/(2*Ceil (Div/2))     */
                	        	/*  Tac = 2*Ceil (Div/2)*Tln       */
#define LCCR3_API	Fld (4, 16)	/* AC bias Pin transitions per     */
                	        	/* Interrupt                       */
#define LCCR3_ACBsCntOff        	/*  AC Bias clock transition Count */ \
                	        	/*  Off                            */ \
                	(0 << FShft (LCCR3_API))
#define LCCR3_ACBsCnt(Trans)    	/*  AC Bias clock transition Count */ \
                	        	/*  [1..15]                        */ \
                	((Trans) << FShft (LCCR3_API))
#define LCCR3_VSP	0x00100000	/* Vertical Synchronization pulse  */
                	        	/* Polarity (L_FCLK)               */
#define LCCR3_VrtSnchH	(LCCR3_VSP*0)	/*  Vertical Synchronization pulse */
                	        	/*  active High                    */
#define LCCR3_VrtSnchL	(LCCR3_VSP*1)	/*  Vertical Synchronization pulse */
                	        	/*  active Low                     */
#define LCCR3_HSP	0x00200000	/* Horizontal Synchronization      */
                	        	/* pulse Polarity (L_LCLK)         */
#define LCCR3_HorSnchH	(LCCR3_HSP*0)	/*  Horizontal Synchronization     */
                	        	/*  pulse active High              */
#define LCCR3_HorSnchL	(LCCR3_HSP*1)	/*  Horizontal Synchronization     */
                	        	/*  pulse active Low               */
#define LCCR3_PCP	0x00400000	/* Pixel Clock Polarity (L_PCLK)   */
#define LCCR3_PixRsEdg	(LCCR3_PCP*0)	/*  Pixel clock Rising-Edge        */
#define LCCR3_PixFlEdg	(LCCR3_PCP*1)	/*  Pixel clock Falling-Edge       */
#define LCCR3_OEP	0x00800000	/* Output Enable Polarity (L_BIAS, */
                	        	/* active display mode)            */
#define LCCR3_OutEnH	(LCCR3_OEP*0)	/*  Output Enable active High      */
#define LCCR3_OutEnL	(LCCR3_OEP*1)	/*  Output Enable active Low       */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Select 32 or 64 bit
config 64BIT
	bool "64-bit kernel" if ARCH = "x86"
	default ARCH != "i386"
	---help---
	  Say yes to build a 64-bit kernel - formerly known as x86_64
	  Say no to build a 32-bit kernel - formerly known as i386

config X86_32
	def_bool y
	depends on !64BIT
	select IPIPE_WANT_CLOCKSOURCE if IPIPE
	select CLKSRC_I8253
	select HAVE_UID16

config X86_64
	def_bool y
	depends on 64BIT
	select X86_DEV_DMA_OPS
	select ARCH_USE_CMPXCHG_LOCKREF
	select HAVE_LIVEPATCH

### Arch settings
config X86
	def_bool y
	select ACPI_SYSTEM_POWER_STATES_SUPPORT if ACPI
	select IPIPE_HAVE_HOSTRT if IPIPE
	select IPIPE_HAVE_VM_NOTIFIER if IPIPE
	select IPIPE_HAVE_SAFE_THREAD_INFO if X86_64
	select IPIPE_WANT_PTE_PINNING if IPIPE
	select ARCH_MIGHT_HAVE_ACPI_PDC if ACPI
	select ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS
	select ARCH_HAS_FAST_MULTIPLIER
	select ARCH_HAS_GCOV_PROFILE_ALL
	select ARCH_MIGHT_HAVE_PC_PARPORT
	select ARCH_MIGHT_HAVE_PC_SERIO
	select HAVE_AOUT if X86_32
	select HAVE_UNSTABLE_SCHED_CLOCK
	select ARCH_SUPPORTS_NUMA_BALANCING if X86_64
	select ARCH_SUPPORTS_INT128 if X86_64
	select HAVE_IDE
	select HAVE_OPROFILE
	select HAVE_PCSPKR_PLATFORM
	select HAVE_PERF_EVENTS
	select HAVE_IOREMAP_PROT
	select HAVE_KPROBES
	select HAVE_MEMBLOCK
	select HAVE_MEMBLOCK_NODE_MAP
	select ARCH_DISCARD_MEMBLOCK
	select ARCH_WANT_OPTIONAL_GPIOLIB
	select ARCH_WANT_FRAME_POINTERS
	select HAVE_DMA_ATTRS
	select HAVE_DMA_CONTIGUOUS
	select HAVE_KRETPROBES
	select GENERIC_EARLY_IOREMAP
	select HAVE_OPTPROBES
	select HAVE_KPROBES_ON_FTRACE
	select HAVE_FTRACE_MCOUNT_RECORD
	select HAVE_FENTRY if X86_64
	select HAVE_C_RECORDMCOUNT
	select HAVE_DYNAMIC_FTRACE
	select HAVE_DYNAMIC_FTRACE_WITH_REGS
	select HAVE_FUNCTION_TRACER
	select HAVE_FUNCTION_GRAPH_TRACER
	select HAVE_FUNCTION_GRAPH_FP_TEST
	select HAVE_SYSCALL_TRACEPOINTS
	select SYSCTL_EXCEPTION_TRACE
	select HAVE_KVM
	select HAVE_ARCH_KGDB
	select HAVE_ARCH_TRACEHOOK
	select HAVE_GENERIC_DMA_COHERENT if X86_32
	select HAVE_EFFICIENT_UNALIGNED_ACCESS
	select USER_STACKTRACE_SUPPORT
	select HAVE_REGS_AND_STACK_ACCESS_API
	select HAVE_DMA_API_DEBUG
	select HAVE_KERNEL_GZIP
	select HAVE_KERNEL_BZIP2
	select HAVE_KERNEL_LZMA
	select HAVE_KERNEL_XZ
	select HAVE_KERNEL_LZO
	select HAVE_KERNEL_LZ4
	select HAVE_HW_BREAKPOINT
	select HAVE_MIXED_BREAKPOINTS_REGS
	select PERF_EVENTS
	select HAVE_PERF_EVENTS_NMI
	select HAVE_PERF_REGS
	select HAVE_PERF_USER_STACK_DUMP
	select HAVE_DEBUG_KMEMLEAK
	select ANON_INODES
	select HAVE_ALIGNED_STRUCT_PAGE if SLUB
	select HAVE_CMPXCHG_LOCAL
	select HAVE_CMPXCHG_DOUBLE
	select HAVE_ARCH_KMEMCHECK
	select HAVE_ARCH_KASAN if X86_64 && SPARSEMEM_VMEMMAP
	select HAVE_USER_RETURN_NOTIFIER
	select ARCH_HAS_ELF_RANDOMIZE
	select HAVE_ARCH_JUMP_LABEL
	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
	select SPARSE_IRQ
	select GENERIC_FIND_FIRST_BIT
	select GENERIC_IRQ_PROBE
	select GENERIC_PENDING_IRQ if SMP
	select GENERIC_IRQ_SHOW
	select GENERIC_CLOCKEVENTS_MIN_ADJUST
	select IRQ_FORCED_THREADING
	select HAVE_BPF_JIT if X86_64
	select HAVE_ARCH_TRANSPARENT_HUGEPAGE
	select HAVE_ARCH_HUGE_VMAP if X86_64 || (X86_32 && X86_PAE)
	select ARCH_HAS_SG_CHAIN
	select CLKEVT_I8253
	select ARCH_HAVE_NMI_SAFE_CMPXCHG
	select GENERIC_IOMAP
	select DCACHE_WORD_ACCESS
	select GENERIC_SMP_IDLE_THREAD
	select ARCH_WANT_IPC_PARSE_VERSION if X86_32
	select HAVE_ARCH_SECCOMP_FILTER
	select BUILDTIME_EXTABLE_SORT
	select GENERIC_CMOS_UPDATE
	select HAVE_ARCH_SOFT_DIRTY if X86_64
	select CLOCKSOURCE_WATCHDOG
	select GENERIC_CLOCKEVENTS
	select ARCH_CLOCKSOURCE_DATA
	select CLOCKSOURCE_VALIDATE_LAST_CYCLE
	select GENERIC_CLOCKEVENTS_BROADCAST if X86_64 || (X86_32 && X86_LOCAL_APIC)
	select GENERIC_TIME_VSYSCALL
	select GENERIC_STRNCPY_FROM_USER
	select GENERIC_STRNLEN_USER
	select HAVE_CONTEXT_TRACKING if X86_64 && !IPIPE
	select HAVE_IRQ_TIME_ACCOUNTING
	select VIRT_TO_BUS
	select MODULES_USE_ELF_REL if X86_32
	select MODULES_USE_ELF_RELA if X86_64
	select CLONE_BACKWARDS if X86_32
	select ARCH_USE_BUILTIN_BSWAP
	select ARCH_USE_QUEUE_RWLOCK
	select OLD_SIGSUSPEND3 if X86_32 || IA32_EMULATION
	select OLD_SIGACTION if X86_32
	select COMPAT_OLD_SIGACTION if IA32_EMULATION
	select RTC_LIB
	select HAVE_DEBUG_STACKOVERFLOW
	select HAVE_IRQ_EXIT_ON_IRQ_STACK if X86_64
	select HAVE_CC_STACKPROTECTOR
	select GENERIC_CPU_AUTOPROBE
	select HAVE_ARCH_AUDITSYSCALL
	select ARCH_SUPPORTS_ATOMIC_RMW
	select HAVE_ACPI_APEI if ACPI
	select HAVE_ACPI_APEI_NMI if ACPI
	select ACPI_LEGACY_TABLES_LOOKUP if ACPI
	select X86_FEATURE_NAMES if PROC_FS
	select SRCU

config INSTRUCTION_DECODER
	def_bool y
	depends on KPROBES || PERF_EVENTS || UPROBES

config PERF_EVENTS_INTEL_UNCORE
	def_bool y
	depends on PERF_EVENTS && CPU_SUP_INTEL && PCI

config OUTPUT_FORMAT
	string
	default "elf32-i386" if X86_32
	default "elf64-x86-64" if X86_64

config ARCH_DEFCONFIG
	string
	default "arch/x86/configs/i386_defconfig" if X86_32
	default "arch/x86/configs/x86_64_defconfig" if X86_64

config LOCKDEP_SUPPORT
	def_bool y

config STACKTRACE_SUPPORT
	def_bool y

config HAVE_LATENCYTOP_SUPPORT
	def_bool y

config MMU
	def_bool y

config SBUS
	bool

config NEED_DMA_MAP_STATE
	def_bool y
	depends on X86_64 || INTEL_IOMMU || DMA_API_DEBUG || SWIOTLB

config NEED_SG_DMA_LENGTH
	def_bool y

config GENERIC_ISA_DMA
	def_bool y
	depends on ISA_DMA_API

config GENERIC_BUG
	def_bool y
	depends on BUG
	select GENERIC_BUG_RELATIVE_POINTERS if X86_64

config GENERIC_BUG_RELATIVE_POINTERS
	bool

config GENERIC_HWEIGHT
	def_bool y

config ARCH_MAY_HAVE_PC_FDC
	def_bool y
	depends on ISA_DMA_API

config RWSEM_XCHGADD_ALGORITHM
	def_bool y

config GENERIC_CALIBRATE_DELAY
	def_bool y

config ARCH_HAS_CPU_RELAX
	def_bool y

config ARCH_HAS_CACHE_LINE_SIZE
	def_bool y

config HAVE_SETUP_PER_CPU_AREA
	def_bool y

config NEED_PER_CPU_EMBED_FIRST_CHUNK
	def_bool y

config NEED_PER_CPU_PAGE_FIRST_CHUNK
	def_bool y

config ARCH_HIBERNATION_POSSIBLE
	def_bool y

config ARCH_SUSPEND_POSSIBLE
	def_bool y

config ARCH_WANT_HUGE_PMD_SHARE
	def_bool y

config ARCH_WANT_GENERAL_HUGETLB
	def_bool y

config ZONE_DMA32
	def_bool y if X86_64

config AUDIT_ARCH
	def_bool y if X86_64

config ARCH_SUPPORTS_OPTIMIZED_INLINING
	def_bool y

config ARCH_SUPPORTS_DEBUG_PAGEALLOC
	def_bool y

config HAVE_INTEL_TXT
	def_bool y
	depends on INTEL_IOMMU && ACPI

config X86_32_SMP
	def_bool y
	depends on X86_32 && SMP

config X86_64_SMP
	def_bool y
	depends on X86_64 && SMP

config X86_HT
	def_bool y
	depends on SMP

config X86_32_LAZY_GS
	def_bool y
	depends on X86_32 && !CC_STACKPROTECTOR

config ARCH_HWEIGHT_CFLAGS
	string
	default "-fcall-saved-ecx -fcall-saved-edx" if X86_32
	default "-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11" if X86_64

config ARCH_SUPPORTS_UPROBES
	def_bool y

config FIX_EARLYCON_MEM
	def_bool y

config PGTABLE_LEVELS
	int
	default 4 if X86_64
	default 3 if X86_PAE
	default 2

source "init/Kconfig"
source "kernel/Kconfig.freezer"

menu "Processor type and features"

config ZONE_DMA
	bool "DMA memory allocation support" if EXPERT
	default y
	help
	  DMA memory allocation support allows devices with less than 32-bit
	  addressing to allocate within the first 16MB of address space.
	  Disable if no such devices will be used.

	  If unsure, say Y.

config SMP
	bool "Symmetric multi-processing support"
	---help---
	  This enables support for systems with more than one CPU. If you have
	  a system with only one CPU, say N. If you have a system with more
	  than one CPU, say Y.

	  If you say N here, the kernel will run on uni- and multiprocessor
	  machines, but will use only one CPU of a multiprocessor machine. If
	  you say Y here, the kernel will run on many, but not all,
	  uniprocessor machines. On a uniprocessor machine, the kernel
	  will run faster if you say N here.

	  Note that if you say Y here and choose architecture "586" or
	  "Pentium" under "Processor family", the kernel will not work on 486
	  architectures. Similarly, multiprocessor kernels for the "PPro"
	  architecture may not work on all Pentium based boards.

	  People using multiprocessor machines who say Y here should also say
	  Y to "Enhanced Real Time Clock Support", below. The "Advanced Power
	  Management" code will be disabled if you say Y here.

	  See also <file:Documentation/x86/i386/IO-APIC.txt>,
	  <file:Documentation/nmi_watchdog.txt> and the SMP-HOWTO available at
	  <http://www.tldp.org/docs.html#howto>.

	  If you don't know what to do here, say N.

config X86_FEATURE_NAMES
	bool "Processor feature human-readable names" if EMBEDDED
	default y
	---help---
	  This option compiles in a table of x86 feature bits and corresponding
	  names.  This is required to support /proc/cpuinfo and a few kernel
	  messages.  You can disable this to save space, at the expense of
	  making those few kernel messages show numeric feature bits instead.

	  If in doubt, say Y.

config X86_X2APIC
	bool "Support x2apic"
	depends on X86_LOCAL_APIC && X86_64 && IRQ_REMAP
	---help---
	  This enables x2apic support on CPUs that have this feature.

	  This allows 32-bit apic IDs (so it can support very large systems),
	  and accesses the local apic via MSRs not via mmio.

	  If you don't know what to do here, say N.

config X86_MPPARSE
	bool "Enable MPS table" if ACPI || SFI
	default y
	depends on X86_LOCAL_APIC
	---help---
	  For old smp systems that do not have proper acpi support. Newer systems
	  (esp with 64bit cpus) with acpi support, MADT and DSDT will override it

config X86_BIGSMP
	bool "Support for big SMP systems with more than 8 CPUs"
	depends on X86_32 && SMP
	---help---
	  This option is needed for the systems that have more than 8 CPUs

config GOLDFISH
       def_bool y
       depends on X86_GOLDFISH

if X86_32
config X86_EXTENDED_PLATFORM
	bool "Support for extended (non-PC) x86 platforms"
	default y
	---help---
	  If you disable this option then the kernel will only support
	  standard PC platforms. (which covers the vast majority of
	  systems out there.)

	  If you enable this option then you'll be able to select support
	  for the following (non-PC) 32 bit x86 platforms:
		Goldfish (Android emulator)
		AMD Elan
		RDC R-321x SoC
		SGI 320/540 (Visual Workstation)
		STA2X11-based (e.g. Northville)
		Moorestown MID devices

	  If you have one of these systems, or if you want to build a
	  generic distribution kernel, say Y here - otherwise say N.
endif

if X86_64
config X86_EXTENDED_PLATFORM
	bool "Support for extended (non-PC) x86 platforms"
	default y
	---help---
	  If you disable this option then the kernel will only support
	  standard PC platforms. (which covers the vast majority of
	  systems out there.)

	  If you enable this option then you'll be able to select support
	  for the following (non-PC) 64 bit x86 platforms:
		Numascale NumaChip
		ScaleMP vSMP
		SGI Ultraviolet

	  If you have one of these systems, or if you want to build a
	  generic distribution kernel, say Y here - otherwise say N.
endif
# This is an alphabetically sorted list of 64 bit extended platforms
# Please maintain the alphabetic order if and when there are additions
config X86_NUMACHIP
	bool "Numascale NumaChip"
	depends on X86_64
	depends on X86_EXTENDED_PLATFORM
	depends on NUMA
	depends on SMP
	depends on X86_X2APIC
	depends on PCI_MMCONFIG
	---help---
	  Adds support for Numascale NumaChip large-SMP systems. Needed to
	  enable more than ~168 cores.
	  If you don't have one of these, you should say N here.

config X86_VSMP
	bool "ScaleMP vSMP"
	select HYPERVISOR_GUEST
	select PARAVIRT
	depends on X86_64 && PCI
	depends on X86_EXTENDED_PLATFORM
	depends on SMP
	---help---
	  Support for ScaleMP vSMP systems.  Say 'Y' here if this kernel is
	  supposed to run on these EM64T-based machines.  Only choose this option
	  if you have one of these machines.

config X86_UV
	bool "SGI Ultraviolet"
	depends on X86_64
	depends on X86_EXTENDED_PLATFORM
	depends on NUMA
	depends on X86_X2APIC
	---help---
	  This option is needed in order to support SGI Ultraviolet systems.
	  If you don't have one of these, you should say N here.

# Following is an alphabetically sorted list of 32 bit extended platforms
# Please maintain the alphabetic order if and when there are additions

config X86_GOLDFISH
       bool "Goldfish (Virtual Platform)"
       depends on X86_EXTENDED_PLATFORM
       ---help---
	 Enable support for the Goldfish virtual platform used primarily
	 for Android development. Unless you are building for the Android
	 Goldfish emulator say N here.

config X86_INTEL_CE
	bool "CE4100 TV platform"
	depends on PCI
	depends on PCI_GODIRECT
	depends on X86_IO_APIC
	depends on X86_32
	depends on X86_EXTENDED_PLATFORM
	select X86_REBOOTFIXUPS
	select OF
	select OF_EARLY_FLATTREE
	select IRQ_DOMAIN
	---help---
	  Select for the Intel CE media processor (CE4100) SOC.
	  This option compiles in support for the CE4100 SOC for settop
	  boxes and media devices.

config X86_INTEL_MID
	bool "Intel MID platform support"
	depends on X86_32
	depends on X86_EXTENDED_PLATFORM
	depends on X86_PLATFORM_DEVICES
	depends on PCI
	depends on PCI_GOANY
	depends on X86_IO_APIC
	select SFI
	select I2C
	select DW_APB_TIMER
	select APB_TIMER
	select INTEL_SCU_IPC
	select MFD_INTEL_MSIC
	---help---
	  Select to build a kernel capable of supporting Intel MID (Mobile
	  Internet Device) platform systems which do not have the PCI legacy
	  interfaces. If you are building for a PC class system say N here.

	  Intel MID platforms are based on an Intel processor and chipset which
	  consume less power than most of the x86 derivatives.

config X86_INTEL_QUARK
	bool "Intel Quark platform support"
	depends on X86_32
	depends on X86_EXTENDED_PLATFORM
	depends on X86_PLATFORM_DEVICES
	depends on X86_TSC
	depends on PCI
	depends on PCI_GOANY
	depends on X86_IO_APIC
	select IOSF_MBI
	select INTEL_IMR
	select COMMON_CLK
	---help---
	  Select to include support for Quark X1000 SoC.
	  Say Y here if you have a Quark based system such as the Arduino
	  compatible Intel Galileo.

config X86_INTEL_LPSS
	bool "Intel Low Power Subsystem Support"
	depends on ACPI
	select COMMON_CLK
	select PINCTRL
	---help---
	  Select to build support for Intel Low Power Subsystem such as
	  found on Intel Lynxpoint PCH. Selecting this option enables
	  things like clock tree (common clock framework) and pincontrol
	  which are needed by the LPSS peripheral drivers.

config X86_AMD_PLATFORM_DEVICE
	bool "AMD ACPI2Platform devices support"
	depends on ACPI
	select COMMON_CLK
	select PINCTRL
	---help---
	  Select to interpret AMD specific ACPI device to platform device
	  such as I2C, UART, GPIO found on AMD Carrizo and later chipsets.
	  I2C and UART depend on COMMON_CLK to set clock. GPIO driver is
	  implemented under PINCTRL subsystem.

config IOSF_MBI
	tristate "Intel SoC IOSF Sideband support for SoC platforms"
	depends on PCI
	---help---
	  This option enables sideband register access support for Intel SoC
	  platforms. On these platforms the IOSF sideband is used in lieu of
	  MSR's for some register accesses, mostly but not limited to thermal
	  and power. Drivers may query the availability of this device to
	  determine if they need the sideband in order to work on these
	  platforms. The sideband is available on the following SoC products.
	  This list is not meant to be exclusive.
	   - BayTrail
	   - Braswell
	   - Quark

	  You should say Y if you are running a kernel on one of these SoC's.

config IOSF_MBI_DEBUG
	bool "Enable IOSF sideband access through debugfs"
	depends on IOSF_MBI && DEBUG_FS
	---help---
	  Select this option to expose the IOSF sideband access registers (MCR,
	  MDR, MCRX) through debugfs to write and read register information from
	  different units on the SoC. This is most useful for obtaining device
	  state information for debug and analysis. As this is a general access
	  mechanism, users of this option would have specific knowledge of the
	  device they want to access.

	  If you don't require the option or are in doubt, say N.

config X86_RDC321X
	bool "RDC R-321x SoC"
	depends on X86_32
	depends on X86_EXTENDED_PLATFORM
	select M486
	select X86_REBOOTFIXUPS
	---help---
	  This option is needed for RDC R-321x system-on-chip, also known
	  as R-8610-(G).
	  If you don't have one of these chips, you should say N here.

config X86_32_NON_STANDARD
	bool "Support non-standard 32-bit SMP architectures"
	depends on X86_32 && SMP
	depends on X86_EXTENDED_PLATFORM
	---help---
	  This option compiles in the bigsmp and STA2X11 default
	  subarchitectures.  It is intended for a generic binary
	  kernel. If you select them all, kernel will probe it one by
	  one and will fallback to default.

# Alphabetically sorted list of Non standard 32 bit platforms

config X86_SUPPORTS_MEMORY_FAILURE
	def_bool y
	# MCE code calls memory_failure():
	depends on X86_MCE
	# On 32-bit this adds too big of NODES_SHIFT and we run out of page flags:
	# On 32-bit SPARSEMEM adds too big of SECTIONS_WIDTH:
	depends on X86_64 || !SPARSEMEM
	select ARCH_SUPPORTS_MEMORY_FAILURE

config STA2X11
	bool "STA2X11 Companion Chip Support"
	depends on X86_32_NON_STANDARD && PCI
	select X86_DEV_DMA_OPS
	select X86_DMA_REMAP
	select SWIOTLB
	select MFD_STA2X11
	select ARCH_REQUIRE_GPIOLIB
	default n
	---help---
	  This adds support for boards based on the STA2X11 IO-Hub,
	  a.k.a. "ConneXt". The chip is used in place of the standard
	  PC chipset, so all "standard" peripherals are missing. If this
	  option is selected the kernel will still be able to boot on
	  standard PC machines.

config X86_32_IRIS
	tristate "Eurobraille/Iris poweroff module"
	depends on X86_32
	---help---
	  The Iris machines from EuroBraille do not have APM or ACPI support
	  to shut themselves down properly.  A special I/O sequence is
	  needed to do so, which is what this module does at
	  kernel shutdown.

	  This is only for Iris machines from EuroBraille.

	  If unused, say N.

config SCHED_OMIT_FRAME_POINTER
	def_bool y
	prompt "Single-depth WCHAN output"
	depends on X86
	---help---
	  Calculate simpler /proc/<PID>/wchan values. If this option
	  is disabled then wchan values will recurse back to the
	  caller function. This provides more accurate wchan values,
	  at the expense of slightly more scheduling overhead.

	  If in doubt, say "Y".

menuconfig HYPERVISOR_GUEST
	bool "Linux guest support"
	---help---
	  Say Y here to enable options for running Linux under various hyper-
	  visors. This option enables basic hypervisor detection and platform
	  setup.

	  If you say N, all options in this submenu will be skipped and
	  disabled, and Linux guest support won't be built in.

if HYPERVISOR_GUEST

config PARAVIRT
	bool "Enable paravirtualization code"
	depends on !IPIPE
	---help---
	  This changes the kernel so it can modify itself when it is run
	  under a hypervisor, potentially improving performance significantly
	  over full virtualization.  However, when run without a hypervisor
	  the kernel is theoretically slower and slightly larger.

config PARAVIRT_DEBUG
	bool "paravirt-ops debugging"
	depends on PARAVIRT && DEBUG_KERNEL
	---help---
	  Enable to debug paravirt_ops internals.  Specifically, BUG if
	  a paravirt_op is missing when it is called.

config PARAVIRT_SPINLOCKS
	bool "Paravirtualization layer for spinlocks"
	depends on PARAVIRT && SMP
	select UNINLINE_SPIN_UNLOCK
	---help---
	  Paravirtualized spinlocks allow a pvops backend to replace the
	  spinlock implementation with something virtualization-friendly
	  (for example, block the virtual CPU rather than spinning).

	  It has a minimal impact on native kernels and gives a nice performance
	  benefit on paravirtualized KVM / Xen kernels.

	  If you are unsure how to answer this question, answer Y.

source "arch/x86/xen/Kconfig"

config KVM_GUEST
	bool "KVM Guest support (including kvmclock)"
	depends on PARAVIRT
	select PARAVIRT_CLOCK
	default y
	---help---
	  This option enables various optimizations for running under the KVM
	  hypervisor. It includes a paravirtualized clock, so that instead
	  of relying on a PIT (or probably other) emulation by the
	  underlying device model, the host provides the guest with
	  timing infrastructure such as time of day, and system time

config KVM_DEBUG_FS
	bool "Enable debug information for KVM Guests in debugfs"
	depends on KVM_GUEST && DEBUG_FS
	default n
	---help---
	  This option enables collection of various statistics for KVM guest.
	  Statistics are displayed in debugfs filesystem. Enabling this option
	  may incur significant overhead.

source "arch/x86/lguest/Kconfig"

config PARAVIRT_TIME_ACCOUNTING
	bool "Paravirtual steal time accounting"
	depends on PARAVIRT
	default n
	---help---
	  Select this option to enable fine granularity task steal time
	  accounting. Time spent executing other tasks in parallel with
	  the current vCPU is discounted from the vCPU power. To account for
	  that, there can be a small performance impact.

	  If in doubt, say N here.

config PARAVIRT_CLOCK
	bool

endif #HYPERVISOR_GUEST

config NO_BOOTMEM
	def_bool y

source "arch/x86/Kconfig.cpu"

config HPET_TIMER
	def_bool X86_64
	prompt "HPET Timer Support" if X86_32
	---help---
	  Use the IA-PC HPET (High Precision Event Timer) to manage
	  time in preference to the PIT and RTC, if a HPET is
	  present.
	  HPET is the next generation timer replacing legacy 8254s.
	  The HPET provides a stable time base on SMP
	  systems, unlike the TSC, but it is more expensive to access,
	  as it is off-chip.  You can find the HPET spec at
	  <http://www.intel.com/hardwaredesign/hpetspec_1.pdf>.

	  You can safely choose Y here.  However, HPET will only be
	  activated if the platform and the BIOS support this feature.
	  Otherwise the 8254 will be used for timing services.

	  Choose N to continue using the legacy 8254 timer.

config HPET_EMULATE_RTC
	def_bool y
	depends on HPET_TIMER && (RTC=y || RTC=m || RTC_DRV_CMOS=m || RTC_DRV_CMOS=y)

config APB_TIMER
       def_bool y if X86_INTEL_MID
       prompt "Intel MID APB Timer Support" if X86_INTEL_MID
       select DW_APB_TIMER
       depends on X86_INTEL_MID && SFI
       help
         APB timer is the replacement for 8254, HPET on X86 MID platforms.
         The APBT provides a stable time base on SMP
         systems, unlike the TSC, but it is more expensive to access,
         as it is off-chip. APB timers are always running regardless of CPU
         C states, they are used as per CPU clockevent device when possible.

# Mark as expert because too many people got it wrong.
# The code disables itself when not needed.
config DMI
	default y
	select DMI_SCAN_MACHINE_NON_EFI_FALLBACK
	bool "Enable DMI scanning" if EXPERT
	---help---
	  Enabled scanning of DMI to identify machine quirks. Say Y
	  here unless you have verified that your setup is not
	  affected by entries in the DMI blacklist. Required by PNP
	  BIOS code.

config GART_IOMMU
	bool "Old AMD GART IOMMU support"
	select SWIOTLB
	depends on X86_64 && PCI && AMD_NB
	---help---
	  Provides a driver for older AMD Athlon64/Opteron/Turion/Sempron
	  GART based hardware IOMMUs.

	  The GART supports full DMA access for devices with 32-bit access
	  limitations, on systems with more than 3 GB. This is usually needed
	  for USB, sound, many IDE/SATA chipsets and some other devices.

	  Newer systems typically have a modern AMD IOMMU, supported via
	  the CONFIG_AMD_IOMMU=y config option.

	  In normal configurations this driver is only active when needed:
	  there's more than 3 GB of memory and the system contains a
	  32-bit limited device.

	  If unsure, say Y.

config CALGARY_IOMMU
	bool "IBM Calgary IOMMU support"
	select SWIOTLB
	depends on X86_64 && PCI
	---help---
	  Support for hardware IOMMUs in IBM's xSeries x366 and x460
	  systems. Needed to run systems with more than 3GB of memory
	  properly with 32-bit PCI devices that do not support DAC
	  (Double Address Cycle). Calgary also supports bus level
	  isolation, where all DMAs pass through the IOMMU.  This
	  prevents them from going anywhere except their intended
	  destination. This catches hard-to-find kernel bugs and
	  mis-behaving drivers and devices that do not use the DMA-API
	  properly to set up their DMA buffers.  The IOMMU can be
	  turned off at boot time with the iommu=off parameter.
	  Normally the kernel will make the right choice by itself.
	  If unsure, say Y.

config CALGARY_IOMMU_ENABLED_BY_DEFAULT
	def_bool y
	prompt "Should Calgary be enabled by default?"
	depends on CALGARY_IOMMU
	---help---
	  Should Calgary be enabled by default? if you choose 'y', Calgary
	  will be used (if it exists). If you choose 'n', Calgary will not be
	  used even if it exists. If you choose 'n' and would like to use
	  Calgary anyway, pass 'iommu=calgary' on the kernel command line.
	  If unsure, say Y.

# need this always selected by IOMMU for the VIA workaround
config SWIOTLB
	def_bool y if X86_64
	---help---
	  Support for software bounce buffers used on x86-64 systems
	  which don't have a hardware IOMMU. Using this PCI devices
	  which can only access 32-bits of memory can be used on systems
	  with more than 3 GB of memory.
	  If unsure, say Y.

config IOMMU_HELPER
	def_bool y
	depends on CALGARY_IOMMU || GART_IOMMU || SWIOTLB || AMD_IOMMU

config MAXSMP
	bool "Enable Maximum number of SMP Processors and NUMA Nodes"
	depends on X86_64 && SMP && DEBUG_KERNEL
	select CPUMASK_OFFSTACK
	---help---
	  Enable maximum number of CPUS and NUMA Nodes for this architecture.
	  If unsure, say N.

config NR_CPUS
	int "Maximum number of CPUs" if SMP && !MAXSMP
	range 2 8 if SMP && X86_32 && !X86_BIGSMP
	range 2 512 if SMP && !MAXSMP && !CPUMASK_OFFSTACK
	range 2 8192 if SMP && !MAXSMP && CPUMASK_OFFSTACK && X86_64
	default "1" if !SMP
	default "8192" if MAXSMP
	default "32" if SMP && X86_BIGSMP
	default "8" if SMP
	---help---
	  This allows you to specify the maximum number of CPUs which this
	  kernel will support.  If CPUMASK_OFFSTACK is enabled, the maximum
	  supported value is 4096, otherwise the maximum value is 512.  The
	  minimum value which makes sense is 2.

	  This is purely to save memory - each supported CPU adds
	  approximately eight kilobytes to the kernel image.

config SCHED_SMT
	bool "SMT (Hyperthreading) scheduler support"
	depends on X86_HT
	---help---
	  SMT scheduler support improves the CPU scheduler's decision making
	  when dealing with Intel Pentium 4 chips with HyperThreading at a
	  cost of slightly increased overhead in some places. If unsure say
	  N here.

config SCHED_MC
	def_bool y
	prompt "Multi-core scheduler support"
	depends on X86_HT
	---help---
	  Multi-core scheduler support improves the CPU scheduler's decision
	  making when dealing with multi-core CPU chips at a cost of slightly
	  increased overhead in some places. If unsure say N here.

source "kernel/Kconfig.preempt"

source "kernel/ipipe/Kconfig"

config UP_LATE_INIT
       def_bool y
       depends on !SMP && X86_LOCAL_APIC

config X86_UP_APIC
	bool "Local APIC support on uniprocessors" if !PCI_MSI
	default PCI_MSI
	depends on X86_32 && !SMP && !X86_32_NON_STANDARD
	---help---
	  A local APIC (Advanced Programmable Interrupt Controller) is an
	  integrated interrupt controller in the CPU. If you have a single-CPU
	  system which has a processor with a local APIC, you can say Y here to
	  enable and use it. If you say Y here even though your machine doesn't
	  have a local APIC, then the kernel will still run with no slowdown at
	  all. The local APIC supports CPU-generated self-interrupts (timer,
	  performance counters), and the NMI watchdog which detects hard
	  lockups.

config X86_UP_IOAPIC
	bool "IO-APIC support on uniprocessors"
	depends on X86_UP_APIC
	---help---
	  An IO-APIC (I/O Advanced Programmable Interrupt Controller) is an
	  SMP-capable replacement for PC-style interrupt controllers. Most
	  SMP systems and many recent uniprocessor systems have one.

	  If you have a single-CPU system with an IO-APIC, you can say Y here
	  to use it. If you say Y here even though your machine doesn't have
	  an IO-APIC, then the kernel will still run with no slowdown at all.

config X86_LOCAL_APIC
	def_bool y
	depends on X86_64 || SMP || X86_32_NON_STANDARD || X86_UP_APIC || PCI_MSI
	select GENERIC_IRQ_LEGACY_ALLOC_HWIRQ

config X86_IO_APIC
	def_bool y
	depends on X86_LOCAL_APIC || X86_UP_IOAPIC
	select IRQ_DOMAIN

config X86_REROUTE_FOR_BROKEN_BOOT_IRQS
	bool "Reroute for broken boot IRQs"
	depends on X86_IO_APIC
	---help---
	  This option enables a workaround that fixes a source of
	  spurious interrupts. This is recommended when threaded
	  interrupt handling is used on systems where the generation of
	  superfluous "boot interrupts" cannot be disabled.

	  Some chipsets generate a legacy INTx "boot IRQ" when the IRQ
	  entry in the chipset's IO-APIC is masked (as, e.g. the RT
	  kernel does during interrupt handling). On chipsets where this
	  boot IRQ generation cannot be disabled, this workaround keeps
	  the original IRQ line masked so that only the equivalent "boot
	  IRQ" is delivered to the CPUs. The workaround also tells the
	  kernel to set up the IRQ handler on the boot IRQ line. In this
	  way only one interrupt is delivered to the kernel. Otherwise
	  the spurious second interrupt may cause the kernel to bring
	  down (vital) interrupt lines.

	  Only affects "broken" chipsets. Interrupt sharing may be
	  increased on these systems.

config X86_MCE
	bool "Machine Check / overheating reporting"
	default y
	---help---
	  Machine Check support allows the processor to notify the
	  kernel if it detects a problem (e.g. overheating, data corruption).
	  The action the kernel takes depends on the severity of the problem,
	  ranging from warning messages to halting the machine.

config X86_MCE_INTEL
	def_bool y
	prompt "Intel MCE features"
	depends on X86_MCE && X86_LOCAL_APIC
	---help---
	   Additional support for intel specific MCE features such as
	   the thermal monitor.

config X86_MCE_AMD
	def_bool y
	prompt "AMD MCE features"
	depends on X86_MCE && X86_LOCAL_APIC
	---help---
	   Additional support for AMD specific MCE features such as
	   the DRAM Error Threshold.

config X86_ANCIENT_MCE
	bool "Support for old Pentium 5 / WinChip machine checks"
	depends on X86_32 && X86_MCE
	---help---
	  Include support for machine check handling on old Pentium 5 or WinChip
	  systems. These typically need to be enabled explicitly on the command
	  line.

config X86_MCE_THRESHOLD
	depends on X86_MCE_AMD || X86_MCE_INTEL
	def_bool y

config X86_MCE_INJECT
	depends on X86_MCE
	tristate "Machine check injector support"
	---help---
	  Provide support for injecting machine checks for testing purposes.
	  If you don't know what a machine check is and you don't do kernel
	  QA it is safe to say n.

config X86_THERMAL_VECTOR
	def_bool y
	depends on X86_MCE_INTEL

config VM86
	bool "Enable VM86 support" if EXPERT
	default y
	depends on X86_32
	---help---
	  This option is required by programs like DOSEMU to run
	  16-bit real mode legacy code on x86 processors. It also may
	  be needed by software like XFree86 to initialize some video
	  cards via BIOS. Disabling this option saves about 6K.

config X86_16BIT
	bool "Enable support for 16-bit segments" if EXPERT
	default y
	---help---
	  This option is required by programs like Wine to run 16-bit
	  protected mode legacy code on x86 processors.  Disabling
	  this option saves about 300 bytes on i386, or around 6K text
	  plus 16K runtime memory on x86-64,

config X86_ESPFIX32
	def_bool y
	depends on X86_16BIT && X86_32

config X86_ESPFIX64
	def_bool y
	depends on X86_16BIT && X86_64

config X86_VSYSCALL_EMULATION
       bool "Enable vsyscall emulation" if EXPERT
       default y
       depends on X86_64
       ---help---
	 This enables emulation of the legacy vsyscall page.  Disabling
	 it is roughly equivalent to booting with vsyscall=none, except
	 that it will also disable the helpful warning if a program
	 tries to use a vsyscall.  With this option set to N, offending
	 programs will just segfault, citing addresses of the form
	 0xffffffffff600?00.

	 This option is required by many programs built before 2013, and
	 care should be used even with newer programs if set to N.

	 Disabling this option saves about 7K of kernel size and
	 possibly 4K of additional runtime pagetable memory.

config TOSHIBA
	tristate "Toshiba Laptop support"
	depends on X86_32
	---help---
	  This adds a driver to safely access the System Management Mode of
	  the CPU on Toshiba portables with a genuine Toshiba BIOS. It does
	  not work on models with a Phoenix BIOS. The System Management Mode
	  is used to set the BIOS and power saving options on Toshiba portables.

	  For information on utilities to make use of this driver see the
	  Toshiba Linux utilities web site at:
	  <http://www.buzzard.org.uk/toshiba/>.

	  Say Y if you intend to run this kernel on a Toshiba portable.
	  Say N otherwise.

config I8K
	tristate "Dell laptop support"
	select HWMON
	---help---
	  This adds a driver to safely access the System Management Mode
	  of the CPU on the Dell Inspiron 8000. The System Management Mode
	  is used to read cpu temperature and cooling fan status and to
	  control the fans on the I8K portables.

	  This driver has been tested only on the Inspiron 8000 but it may
	  also work with other Dell laptops. You can force loading on other
	  models by passing the parameter `force=1' to the module. Use at
	  your own risk.

	  For information on utilities to make use of this driver see the
	  I8K Linux utilities web site at:
	  <http://people.debian.org/~dz/i8k/>

	  Say Y if you intend to run this kernel on a Dell Inspiron 8000.
	  Say N otherwise.

config X86_REBOOTFIXUPS
	bool "Enable X86 board specific fixups for reboot"
	depends on X86_32
	---help---
	  This enables chipset and/or board specific fixups to be done
	  in order to get reboot to work correctly. This is only needed on
	  some combinations of hardware and BIOS. The symptom, for which
	  this config is intended, is when reboot ends with a stalled/hung
	  system.

	  Currently, the only fixup is for the Geode machines using
	  CS5530A and CS5536 chipsets and the RDC R-321x SoC.

	  Say Y if you want to enable the fixup. Currently, it's safe to
	  enable this option even if you don't need it.
	  Say N otherwise.

config MICROCODE
	tristate "CPU microcode loading support"
	depends on CPU_SUP_AMD || CPU_SUP_INTEL
	select FW_LOADER
	---help---

	  If you say Y here, you will be able to update the microcode on
	  certain Intel and AMD processors. The Intel support is for the
	  IA32 family, e.g. Pentium Pro, Pentium II, Pentium III, Pentium 4,
	  Xeon etc. The AMD support is for families 0x10 and later. You will
	  obviously need the actual microcode binary data itself which is not
	  shipped with the Linux kernel.

	  This option selects the general module only, you need to select
	  at least one vendor specific module as well.

	  To compile this driver as a module, choose M here: the module
	  will be called microcode.

config MICROCODE_INTEL
	bool "Intel microcode loading support"
	depends on MICROCODE
	default MICROCODE
	select FW_LOADER
	---help---
	  This options enables microcode patch loading support for Intel
	  processors.

	  For the current Intel microcode data package go to
	  <https://downloadcenter.intel.com> and search for
	  'Linux Processor Microcode Data File'.

config MICROCODE_AMD
	bool "AMD microcode loading support"
	depends on MICROCODE
	select FW_LOADER
	---help---
	  If you select this option, microcode patch loading support for AMD
	  processors will be enabled.

config MICROCODE_OLD_INTERFACE
	def_bool y
	depends on MICROCODE

config MICROCODE_INTEL_EARLY
	bool

config MICROCODE_AMD_EARLY
	bool

config MICROCODE_EARLY
	bool "Early load microcode"
	depends on MICROCODE=y && BLK_DEV_INITRD
	select MICROCODE_INTEL_EARLY if MICROCODE_INTEL
	select MICROCODE_AMD_EARLY if MICROCODE_AMD
	default y
	help
	  This option provides functionality to read additional microcode data
	  at the beginning of initrd image. The data tells kernel to load
	  microcode to CPU's as early as possible. No functional change if no
	  microcode data is glued to the initrd, therefore it's safe to say Y.

config X86_MSR
	tristate "/dev/cpu/*/msr - Model-specific register support"
	---help---
	  This device gives privileged processes access to the x86
	  Model-Specific Registers (MSRs).  It is a character device with
	  major 202 and minors 0 to 31 for /dev/cpu/0/msr to /dev/cpu/31/msr.
	  MSR accesses are directed to a specific CPU on multi-processor
	  systems.

config X86_CPUID
	tristate "/dev/cpu/*/cpuid - CPU information support"
	---help---
	  This device gives processes access to the x86 CPUID instruction to
	  be executed on a specific processor.  It is a character device
	  with major 203 and minors 0 to 31 for /dev/cpu/0/cpuid to
	  /dev/cpu/31/cpuid.

choice
	prompt "High Memory Support"
	default HIGHMEM4G
	depends on X86_32

config NOHIGHMEM
	bool "off"
	---help---
	  Linux can use up to 64 Gigabytes of physical memory on x86 systems.
	  However, the address space of 32-bit x86 processors is only 4
	  Gigabytes large. That means that, if you have a large amount of
	  physical memory, not all of it can be "permanently mapped" by the
	  kernel. The physical memory that's not permanently mapped is called
	  "high memory".

	  If you are compiling a kernel which will never run on a machine with
	  more than 1 Gigabyte total physical RAM, answer "off" here (default
	  choice and suitable for most users). This will result in a "3GB/1GB"
	  split: 3GB are mapped so that each process sees a 3GB virtual memory
	  space and the remaining part of the 4GB virtual memory space is used
	  by the kernel to permanently map as much physical memory as
	  possible.

	  If the machine has between 1 and 4 Gigabytes physical RAM, then
	  answer "4GB" here.

	  If more than 4 Gigabytes is used then answer "64GB" here. This
	  selection turns Intel PAE (Physical Address Extension) mode on.
	  PAE implements 3-level paging on IA32 processors. PAE is fully
	  supported by Linux, PAE mode is implemented on all recent Intel
	  processors (Pentium Pro and better). NOTE: If you say "64GB" here,
	  then the kernel will not boot on CPUs that don't support PAE!

	  The actual amount of total physical memory will either be
	  auto detected or can be forced by using a kernel command line option
	  such as "mem=256M". (Try "man bootparam" or see the documentation of
	  your boot loader (lilo or loadlin) about how to pass options to the
	  kernel at boot time.)

	  If unsure, say "off".

config HIGHMEM4G
	bool "4GB"
	---help---
	  Select this if you have a 32-bit processor and between 1 and 4
	  gigabytes of physical RAM.

config HIGHMEM64G
	bool "64GB"
	depends on !M486
	select X86_PAE
	---help---
	  Select this if you have a 32-bit processor and more than 4
	  gigabytes of physical RAM.

endchoice

choice
	prompt "Memory split" if EXPERT
	default VMSPLIT_3G
	depends on X86_32
	---help---
	  Select the desired split between kernel and user memory.

	  If the address range available to the kernel is less than the
	  physical memory installed, the remaining memory will be available
	  as "high memory". Accessing high memory is a little more costly
	  than low memory, as it needs to be mapped into the kernel first.
	  Note that increasing the kernel address space limits the range
	  available to user programs, making the address space there
	  tighter.  Selecting anything other than the default 3G/1G split
	  will also likely make your kernel incompatible with binary-only
	  kernel modules.

	  If you are not absolutely sure what you are doing, leave this
	  option alone!

	config VMSPLIT_3G
		bool "3G/1G user/kernel split"
	config VMSPLIT_3G_OPT
		depends on !X86_PAE
		bool "3G/1G user/kernel split (for full 1G low memory)"
	config VMSPLIT_2G
		bool "2G/2G user/kernel split"
	config VMSPLIT_2G_OPT
		depends on !X86_PAE
		bool "2G/2G user/kernel split (for full 2G low memory)"
	config VMSPLIT_1G
		bool "1G/3G user/kernel split"
endchoice

config PAGE_OFFSET
	hex
	default 0xB0000000 if VMSPLIT_3G_OPT
	default 0x80000000 if VMSPLIT_2G
	default 0x78000000 if VMSPLIT_2G_OPT
	default 0x40000000 if VMSPLIT_1G
	default 0xC0000000
	depends on X86_32

config HIGHMEM
	def_bool y
	depends on X86_32 && (HIGHMEM64G || HIGHMEM4G)

config X86_PAE
	bool "PAE (Physical Address Extension) Support"
	depends on X86_32 && !HIGHMEM4G
	---help---
	  PAE is required for NX support, and furthermore enables
	  larger swapspace support for non-overcommit purposes. It
	  has the cost of more pagetable lookup overhead, and also
	  consumes more pagetable space per process.

config ARCH_PHYS_ADDR_T_64BIT
	def_bool y
	depends on X86_64 || X86_PAE

config ARCH_DMA_ADDR_T_64BIT
	def_bool y
	depends on X86_64 || HIGHMEM64G

config X86_DIRECT_GBPAGES
	def_bool y
	depends on X86_64 && !DEBUG_PAGEALLOC && !KMEMCHECK
	---help---
	  Certain kernel features effectively disable kernel
	  linear 1 GB mappings (even if the CPU otherwise
	  supports them), so don't confuse the user by printing
	  that we have them enabled.

# Common NUMA Features
config NUMA
	bool "Numa Memory Allocation and Scheduler Support"
	depends on SMP
	depends on X86_64 || (X86_32 && HIGHMEM64G && X86_BIGSMP)
	default y if X86_BIGSMP
	---help---
	  Enable NUMA (Non Uniform Memory Access) support.

	  The kernel will try to allocate memory used by a CPU on the
	  local memory controller of the CPU and add some more
	  NUMA awareness to the kernel.

	  For 64-bit this is recommended if the system is Intel Core i7
	  (or later), AMD Opteron, or EM64T NUMA.

	  For 32-bit this is only needed if you boot a 32-bit
	  kernel on a 64-bit NUMA platform.

	  Otherwise, you should say N.

config AMD_NUMA
	def_bool y
	prompt "Old style AMD Opteron NUMA detection"
	depends on X86_64 && NUMA && PCI
	---help---
	  Enable AMD NUMA node topology detection.  You should say Y here if
	  you have a multi processor AMD system. This uses an old method to
	  read the NUMA configuration directly from the builtin Northbridge
	  of Opteron. It is recommended to use X86_64_ACPI_NUMA instead,
	  which also takes priority if both are compiled in.

config X86_64_ACPI_NUMA
	def_bool y
	prompt "ACPI NUMA detection"
	depends on X86_64 && NUMA && ACPI && PCI
	select ACPI_NUMA
	---help---
	  Enable ACPI SRAT based node topology detection.

# Some NUMA nodes have memory ranges that span
# other nodes.  Even though a pfn is valid and
# between a node's start and end pfns, it may not
# reside on that node.  See memmap_init_zone()
# for details.
config NODES_SPAN_OTHER_NODES
	def_bool y
	depends on X86_64_ACPI_NUMA

config NUMA_EMU
	bool "NUMA emulation"
	depends on NUMA
	---help---
	  Enable NUMA emulation. A flat machine will be split
	  into virtual nodes when booted with "numa=fake=N", where N is the
	  number of nodes. This is only useful for debugging.

config NODES_SHIFT
	int "Maximum NUMA Nodes (as a power of 2)" if !MAXSMP
	range 1 10
	default "10" if MAXSMP
	default "6" if X86_64
	default "3"
	depends on NEED_MULTIPLE_NODES
	---help---
	  Specify the maximum number of NUMA Nodes available on the target
	  system.  Increases memory reserved to accommodate various tables.

config ARCH_HAVE_MEMORY_PRESENT
	def_bool y
	depends on X86_32 && DISCONTIGMEM

config NEED_NODE_MEMMAP_SIZE
	def_bool y
	depends on X86_32 && (DISCONTIGMEM || SPARSEMEM)

config ARCH_FLATMEM_ENABLE
	def_bool y
	depends on X86_32 && !NUMA

config ARCH_DISCONTIGMEM_ENABLE
	def_bool y
	depends on NUMA && X86_32

config ARCH_DISCONTIGMEM_DEFAULT
	def_bool y
	depends on NUMA && X86_32

config ARCH_SPARSEMEM_ENABLE
	def_bool y
	depends on X86_64 || NUMA || X86_32 || X86_32_NON_STANDARD
	select SPARSEMEM_STATIC if X86_32
	select SPARSEMEM_VMEMMAP_ENABLE if X86_64

config ARCH_SPARSEMEM_DEFAULT
	def_bool y
	depends on X86_64

config ARCH_SELECT_MEMORY_MODEL
	def_bool y
	depends on ARCH_SPARSEMEM_ENABLE

config ARCH_MEMORY_PROBE
	bool "Enable sysfs memory/probe interface"
	depends on X86_64 && MEMORY_HOTPLUG
	help
	  This option enables a sysfs memory/probe interface for testing.
	  See Documentation/memory-hotplug.txt for more information.
	  If you are unsure how to answer this question, answer N.

config ARCH_PROC_KCORE_TEXT
	def_bool y
	depends on X86_64 && PROC_KCORE

config ILLEGAL_POINTER_VALUE
       hex
       default 0 if X86_32
       default 0xdead000000000000 if X86_64

source "mm/Kconfig"

config X86_PMEM_LEGACY
	bool "Support non-standard NVDIMMs and ADR protected memory"
	help
	  Treat memory marked using the non-standard e820 type of 12 as used
	  by the Intel Sandy Bridge-EP reference BIOS as protected memory.
	  The kernel will offer these regions to the 'pmem' driver so
	  they can be used for persistent storage.

	  Say Y if unsure.

config HIGHPTE
	bool "Allocate 3rd-level pagetables from highmem"
	depends on HIGHMEM
	---help---
	  The VM uses one page table entry for each page of physical memory.
	  For systems with a lot of RAM, this can be wasteful of precious
	  low memory.  Setting this option will put user-space page table
	  entries in high memory.

config X86_CHECK_BIOS_CORRUPTION
	bool "Check for low memory corruption"
	---help---
	  Periodically check for memory corruption in low memory, which
	  is suspected to be caused by BIOS.  Even when enabled in the
	  configuration, it is disabled at runtime.  Enable it by
	  setting "memory_corruption_check=1" on the kernel command
	  line.  By default it scans the low 64k of memory every 60
	  seconds; see the memory_corruption_check_size and
	  memory_corruption_check_period parameters in
	  Documentation/kernel-parameters.txt to adjust this.

	  When enabled with the default parameters, this option has
	  almost no overhead, as it reserves a relatively small amount
	  of memory and scans it infrequently.  It both detects corruption
	  and prevents it from affecting the running system.

	  It is, however, intended as a diagnostic tool; if repeatable
	  BIOS-originated corruption always affects the same memory,
	  you can use memmap= to prevent the kernel from using that
	  memory.

config X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK
	bool "Set the default setting of memory_corruption_check"
	depends on X86_CHECK_BIOS_CORRUPTION
	default y
	---help---
	  Set whether the default state of memory_corruption_check is
	  on or off.

config X86_RESERVE_LOW
	int "Amount of low memory, in kilobytes, to reserve for the BIOS"
	default 64
	range 4 640
	---help---
	  Specify the amount of low memory to reserve for the BIOS.

	  The first page contains BIOS data structures that the kernel
	  must not use, so that page must always be reserved.

	  By default we reserve the first 64K of physical RAM, as a
	  number of BIOSes are known to corrupt that memory range
	  during events such as suspend/resume or monitor cable
	  insertion, so it must not be used by the kernel.

	  You can set this to 4 if you are absolutely sure that you
	  trust the BIOS to get all its memory reservations and usages
	  right.  If you know your BIOS have problems beyond the
	  default 64K area, you can set this to 640 to avoid using the
	  entire low memory range.

	  If you have doubts about the BIOS (e.g. suspend/resume does
	  not work or there's kernel crashes after certain hardware
	  hotplug events) then you might want to enable
	  X86_CHECK_BIOS_CORRUPTION=y to allow the kernel to check
	  typical corruption patterns.

	  Leave this to the default value of 64 if you are unsure.

config MATH_EMULATION
	bool
	prompt "Math emulation" if X86_32
	---help---
	  Linux can emulate a math coprocessor (used for floating point
	  operations) if you don't have one. 486DX and Pentium processors have
	  a math coprocessor built in, 486SX and 386 do not, unless you added
	  a 487DX or 387, respectively. (The messages during boot time can
	  give you some hints here ["man dmesg"].) Everyone needs either a
	  coprocessor or this emulation.

	  If you don't have a math coprocessor, you need to say Y here; if you
	  say Y here even though you have a coprocessor, the coprocessor will
	  be used nevertheless. (This behavior can be changed with the kernel
	  command line option "no387", which comes handy if your coprocessor
	  is broken. Try "man bootparam" or see the documentation of your boot
	  loader (lilo or loadlin) about how to pass options to the kernel at
	  boot time.) This means that it is a good idea to say Y here if you
	  intend to use this kernel on different machines.

	  More information about the internals of the Linux math coprocessor
	  emulation can be found in <file:arch/x86/math-emu/README>.

	  If you are not sure, say Y; apart from resulting in a 66 KB bigger
	  kernel, it won't hurt.

config MTRR
	def_bool y
	prompt "MTRR (Memory Type Range Register) support" if EXPERT
	---help---
	  On Intel P6 family processors (Pentium Pro, Pentium II and later)
	  the Memory Type Range Registers (MTRRs) may be used to control
	  processor access to memory ranges. This is most useful if you have
	  a video (VGA) card on a PCI or AGP bus. Enabling write-combining
	  allows bus write transfers to be combined into a larger transfer
	  before bursting over the PCI/AGP bus. This can increase performance
	  of image write operations 2.5 times or more. Saying Y here creates a
	  /proc/mtrr file which may be used to manipulate your processor's
	  MTRRs. Typically the X server should use this.

	  This code has a reasonably generic interface so that similar
	  control registers on other processors can be easily supported
	  as well:

	  The Cyrix 6x86, 6x86MX and M II processors have Address Range
	  Registers (ARRs) which provide a similar functionality to MTRRs. For
	  these, the ARRs are used to emulate the MTRRs.
	  The AMD K6-2 (stepping 8 and above) and K6-3 processors have two
	  MTRRs. The Centaur C6 (WinChip) has 8 MCRs, allowing
	  write-combining. All of these processors are supported by this code
	  and it makes sense to say Y here if you have one of them.

	  Saying Y here also fixes a problem with buggy SMP BIOSes which only
	  set the MTRRs for the boot CPU and not for the secondary CPUs. This
	  can lead to all sorts of problems, so it's good to say Y here.

	  You can safely say Y even if your machine doesn't have MTRRs, you'll
	  just add about 9 KB to your kernel.

	  See <file:Documentation/x86/mtrr.txt> for more information.

config MTRR_SANITIZER
	def_bool y
	prompt "MTRR cleanup support"
	depends on MTRR
	---help---
	  Convert MTRR layout from continuous to discrete, so X drivers can
	  add writeback entries.

	  Can be disabled with disable_mtrr_cleanup on the kernel command line.
	  The largest mtrr entry size for a continuous block can be set with
	  mtrr_chunk_size.

	  If unsure, say Y.

config MTRR_SANITIZER_ENABLE_DEFAULT
	int "MTRR cleanup enable value (0-1)"
	range 0 1
	default "0"
	depends on MTRR_SANITIZER
	---help---
	  Enable mtrr cleanup default value

config MTRR_SANITIZER_SPARE_REG_NR_DEFAULT
	int "MTRR cleanup spare reg num (0-7)"
	range 0 7
	default "1"
	depends on MTRR_SANITIZER
	---help---
	  mtrr cleanup spare entries default, it can be changed via
	  mtrr_spare_reg_nr=N on the kernel command line.

config X86_PAT
	def_bool y
	prompt "x86 PAT support" if EXPERT
	depends on MTRR
	---help---
	  Use PAT attributes to setup page level cache control.

	  PATs are the modern equivalents of MTRRs and are much more
	  flexible than MTRRs.

	  Say N here if you see bootup problems (boot crash, boot hang,
	  spontaneous reboots) or a non-working video driver.

	  If unsure, say Y.

config ARCH_USES_PG_UNCACHED
	def_bool y
	depends on X86_PAT

config ARCH_RANDOM
	def_bool y
	prompt "x86 architectural random number generator" if EXPERT
	---help---
	  Enable the x86 architectural RDRAND instruction
	  (Intel Bull Mountain technology) to generate random numbers.
	  If supported, this is a high bandwidth, cryptographically
	  secure hardware random number generator.

config X86_SMAP
	def_bool y
	prompt "Supervisor Mode Access Prevention" if EXPERT
	---help---
	  Supervisor Mode Access Prevention (SMAP) is a security
	  feature in newer Intel processors.  There is a small
	  performance cost if this enabled and turned on; there is
	  also a small increase in the kernel size if this is enabled.

	  If unsure, say Y.

config X86_INTEL_MPX
	prompt "Intel MPX (Memory Protection Extensions)"
	def_bool n
	depends on CPU_SUP_INTEL
	---help---
	  MPX provides hardware features that can be used in
	  conjunction with compiler-instrumented code to check
	  memory references.  It is designed to detect buffer
	  overflow or underflow bugs.

	  This option enables running applications which are
	  instrumented or otherwise use MPX.  It does not use MPX
	  itself inside the kernel or to protect the kernel
	  against bad memory references.

	  Enabling this option will make the kernel larger:
	  ~8k of kernel text and 36 bytes of data on a 64-bit
	  defconfig.  It adds a long to the 'mm_struct' which
	  will increase the kernel memory overhead of each
	  process and adds some branches to paths used during
	  exec() and munmap().

	  For details, see Documentation/x86/intel_mpx.txt

	  If unsure, say N.

config EFI
	bool "EFI runtime service support"
	depends on ACPI
	select UCS2_STRING
	select EFI_RUNTIME_WRAPPERS
	---help---
	  This enables the kernel to use EFI runtime services that are
	  available (such as the EFI variable services).

	  This option is only useful on systems that have EFI firmware.
	  In addition, you should use the latest ELILO loader available
	  at <http://elilo.sourceforge.net> in order to take advantage
	  of EFI runtime services. However, even with this option, the
	  resultant kernel should continue to boot on existing non-EFI
	  platforms.

config EFI_STUB
       bool "EFI stub support"
       depends on EFI && !X86_USE_3DNOW
       select RELOCATABLE
       ---help---
          This kernel feature allows a bzImage to be loaded directly
	  by EFI firmware without the use of a bootloader.

	  See Documentation/efi-stub.txt for more information.

config EFI_MIXED
	bool "EFI mixed-mode support"
	depends on EFI_STUB && X86_64
	---help---
	   Enabling this feature allows a 64-bit kernel to be booted
	   on a 32-bit firmware, provided that your CPU supports 64-bit
	   mode.

	   Note that it is not possible to boot a mixed-mode enabled
	   kernel via the EFI boot stub - a bootloader that supports
	   the EFI handover protocol must be used.

	   If unsure, say N.

config SECCOMP
	def_bool y
	prompt "Enable seccomp to safely compute untrusted bytecode"
	---help---
	  This kernel feature is useful for number crunching applications
	  that may need to compute untrusted bytecode during their
	  execution. By using pipes or other transports made available to
	  the process as file descriptors supporting the read/write
	  syscalls, it's possible to isolate those applications in
	  their own address space using seccomp. Once seccomp is
	  enabled via prctl(PR_SET_SECCOMP), it cannot be disabled
	  and the task is only allowed to execute a few safe syscalls
	  defined by each seccomp mode.

	  If unsure, say Y. Only embedded should say N here.

source kernel/Kconfig.hz

config KEXEC
	bool "kexec system call"
	---help---
	  kexec is a system call that implements the ability to shutdown your
	  current kernel, and to start another kernel.  It is like a reboot
	  but it is independent of the system firmware.   And like a reboot
	  you can start any kernel with it, not just Linux.

	  The name comes from the similarity to the exec system call.

	  It is an ongoing process to be certain the hardware in a machine
	  is properly shutdown, so do not be surprised if this code does not
	  initially work for you.  As of this writing the exact hardware
	  interface is strongly in flux, so no good recommendation can be
	  made.

config KEXEC_FILE
	bool "kexec file based system call"
	select BUILD_BIN2C
	depends on KEXEC
	depends on X86_64
	depends on CRYPTO=y
	depends on CRYPTO_SHA256=y
	---help---
	  This is new version of kexec system call. This system call is
	  file based and takes file descriptors as system call argument
	  for kernel and initramfs as opposed to list of segments as
	  accepted by previous system call.

config KEXEC_VERIFY_SIG
	bool "Verify kernel signature during kexec_file_load() syscall"
	depends on KEXEC_FILE
	---help---
	  This option makes kernel signature verification mandatory for
	  the kexec_file_load() syscall.

	  In addition to that option, you need to enable signature
	  verification for the corresponding kernel image type being
	  loaded in order for this to work.

config KEXEC_BZIMAGE_VERIFY_SIG
	bool "Enable bzImage signature verification support"
	depends on KEXEC_VERIFY_SIG
	depends on SIGNED_PE_FILE_VERIFICATION
	select SYSTEM_TRUSTED_KEYRING
	---help---
	  Enable bzImage signature verification support.

config CRASH_DUMP
	bool "kernel crash dumps"
	depends on X86_64 || (X86_32 && HIGHMEM)
	---help---
	  Generate crash dump after being started by kexec.
	  This should be normally only set in special crash dump kernels
	  which are loaded in the main kernel with kexec-tools into
	  a specially reserved region and then later executed after
	  a crash by kdump/kexec. The crash dump kernel must be compiled
	  to a memory address not used by the main kernel or BIOS using
	  PHYSICAL_START, or it must be built as a relocatable image
	  (CONFIG_RELOCATABLE=y).
	  For more details see Documentation/kdump/kdump.txt

config KEXEC_JUMP
	bool "kexec jump"
	depends on KEXEC && HIBERNATION
	---help---
	  Jump between original kernel and kexeced kernel and invoke
	  code in physical address mode via KEXEC

config PHYSICAL_START
	hex "Physical address where the kernel is loaded" if (EXPERT || CRASH_DUMP)
	default "0x1000000"
	---help---
	  This gives the physical address where the kernel is loaded.

	  If kernel is a not relocatable (CONFIG_RELOCATABLE=n) then
	  bzImage will decompress itself to above physical address and
	  run from there. Otherwise, bzImage will run from the address where
	  it has been loaded by the boot loader and will ignore above physical
	  address.

	  In normal kdump cases one does not have to set/change this option
	  as now bzImage can be compiled as a completely relocatable image
	  (CONFIG_RELOCATABLE=y) and be used to load and run from a different
	  address. This option is mainly useful for the folks who don't want
	  to use a bzImage for capturing the crash dump and want to use a
	  vmlinux instead. vmlinux is not relocatable hence a kernel needs
	  to be specifically compiled to run from a specific memory area
	  (normally a reserved region) and this option comes handy.

	  So if you are using bzImage for capturing the crash dump,
	  leave the value here unchanged to 0x1000000 and set
	  CONFIG_RELOCATABLE=y.  Otherwise if you plan to use vmlinux
	  for capturing the crash dump change this value to start of
	  the reserved region.  In other words, it can be set based on
	  the "X" value as specified in the "crashkernel=YM@XM"
	  command line boot parameter passed to the panic-ed
	  kernel. Please take a look at Documentation/kdump/kdump.txt
	  for more details about crash dumps.

	  Usage of bzImage for capturing the crash dump is recommended as
	  one does not have to build two kernels. Same kernel can be used
	  as production kernel and capture kernel. Above option should have
	  gone away after relocatable bzImage support is introduced. But it
	  is present because there are users out there who continue to use
	  vmlinux for dump capture. This option should go away down the
	  line.

	  Don't change this unless you know what you are doing.

config RELOCATABLE
	bool "Build a relocatable kernel"
	default y
	---help---
	  This builds a kernel image that retains relocation information
	  so it can be loaded someplace besides the default 1MB.
	  The relocations tend to make the kernel binary about 10% larger,
	  but are discarded at runtime.

	  One use is for the kexec on panic case where the recovery kernel
	  must live at a different physical address than the primary
	  kernel.

	  Note: If CONFIG_RELOCATABLE=y, then the kernel runs from the address
	  it has been loaded at and the compile time physical address
	  (CONFIG_PHYSICAL_START) is used as the minimum location.

config RANDOMIZE_BASE
	bool "Randomize the address of the kernel image"
	depends on RELOCATABLE
	default n
	---help---
	   Randomizes the physical and virtual address at which the
	   kernel image is decompressed, as a security feature that
	   deters exploit attempts relying on knowledge of the location
	   of kernel internals.

	   Entropy is generated using the RDRAND instruction if it is
	   supported. If RDTSC is supported, it is used as well. If
	   neither RDRAND nor RDTSC are supported, then randomness is
	   read from the i8254 timer.

	   The kernel will be offset by up to RANDOMIZE_BASE_MAX_OFFSET,
	   and aligned according to PHYSICAL_ALIGN. Since the kernel is
	   built using 2GiB addressing, and PHYSICAL_ALGIN must be at a
	   minimum of 2MiB, only 10 bits of entropy is theoretically
	   possible. At best, due to page table layouts, 64-bit can use
	   9 bits of entropy and 32-bit uses 8 bits.

	   If unsure, say N.

config RANDOMIZE_BASE_MAX_OFFSET
	hex "Maximum kASLR offset allowed" if EXPERT
	depends on RANDOMIZE_BASE
	range 0x0 0x20000000 if X86_32
	default "0x20000000" if X86_32
	range 0x0 0x40000000 if X86_64
	default "0x40000000" if X86_64
	---help---
	  The lesser of RANDOMIZE_BASE_MAX_OFFSET and available physical
	  memory is used to determine the maximal offset in bytes that will
	  be applied to the kernel when kernel Address Space Layout
	  Randomization (kASLR) is active. This must be a multiple of
	  PHYSICAL_ALIGN.

	  On 32-bit this is limited to 512MiB by page table layouts. The
	  default is 512MiB.

	  On 64-bit this is limited by how the kernel fixmap page table is
	  positioned, so this cannot be larger than 1GiB currently. Without
	  RANDOMIZE_BASE, there is a 512MiB to 1.5GiB split between kernel
	  and modules. When RANDOMIZE_BASE_MAX_OFFSET is above 512MiB, the
	  modules area will shrink to compensate, up to the current maximum
	  1GiB to 1GiB split. The default is 1GiB.

	  If unsure, leave at the default value.

# Relocation on x86 needs some additional build support
config X86_NEED_RELOCS
	def_bool y
	depends on RANDOMIZE_BASE || (X86_32 && RELOCATABLE)

config PHYSICAL_ALIGN
	hex "Alignment value to which kernel should be aligned"
	default "0x200000"
	range 0x2000 0x1000000 if X86_32
	range 0x200000 0x1000000 if X86_64
	---help---
	  This value puts the alignment restrictions on physical address
	  where kernel is loaded and run from. Kernel is compiled for an
	  address which meets above alignment restriction.

	  If bootloader loads the kernel at a non-aligned address and
	  CONFIG_RELOCATABLE is set, kernel will move itself to nearest
	  address aligned to above value and run from there.

	  If bootloader loads the kernel at a non-aligned address and
	  CONFIG_RELOCATABLE is not set, kernel will ignore the run time
	  load address and decompress itself to the address it has been
	  compiled for and run from there. The address for which kernel is
	  compiled already meets above alignment restrictions. Hence the
	  end result is that kernel runs from a physical address meeting
	  above alignment restrictions.

	  On 32-bit this value must be a multiple of 0x2000. On 64-bit
	  this value must be a multiple of 0x200000.

	  Don't change this unless you know what you are doing.

config HOTPLUG_CPU
	bool "Support for hot-pluggable CPUs"
	depends on SMP
	---help---
	  Say Y here to allow turning CPUs off and on. CPUs can be
	  controlled through /sys/devices/system/cpu.
	  ( Note: power management support will enable this option
	    automatically on SMP systems. )
	  Say N if you want to disable CPU hotplug.

config BOOTPARAM_HOTPLUG_CPU0
	bool "Set default setting of cpu0_hotpluggable"
	default n
	depends on HOTPLUG_CPU
	---help---
	  Set whether default state of cpu0_hotpluggable is on or off.

	  Say Y here to enable CPU0 hotplug by default. If this switch
	  is turned on, there is no need to give cpu0_hotplug kernel
	  parameter and the CPU0 hotplug feature is enabled by default.

	  Please note: there are two known CPU0 dependencies if you want
	  to enable the CPU0 hotplug feature either by this switch or by
	  cpu0_hotplug kernel parameter.

	  First, resume from hibernate or suspend always starts from CPU0.
	  So hibernate and suspend are prevented if CPU0 is offline.

	  Second dependency is PIC interrupts always go to CPU0. CPU0 can not
	  offline if any interrupt can not migrate out of CPU0. There may
	  be other CPU0 dependencies.

	  Please make sure the dependencies are under your control before
	  you enable this feature.

	  Say N if you don't want to enable CPU0 hotplug feature by default.
	  You still can enable the CPU0 hotplug feature at boot by kernel
	  parameter cpu0_hotplug.

config DEBUG_HOTPLUG_CPU0
	def_bool n
	prompt "Debug CPU0 hotplug"
	depends on HOTPLUG_CPU
	---help---
	  Enabling this option offlines CPU0 (if CPU0 can be offlined) as
	  soon as possible and boots up userspace with CPU0 offlined. User
	  can online CPU0 back after boot time.

	  To debug CPU0 hotplug, you need to enable CPU0 offline/online
	  feature by either turning on CONFIG_BOOTPARAM_HOTPLUG_CPU0 during
	  compilation or giving cpu0_hotplug kernel parameter at boot.

	  If unsure, say N.

config COMPAT_VDSO
	def_bool n
	prompt "Disable the 32-bit vDSO (needed for glibc 2.3.3)"
	depends on X86_32 || IA32_EMULATION
	---help---
	  Certain buggy versions of glibc will crash if they are
	  presented with a 32-bit vDSO that is not mapped at the address
	  indicated in its segment table.

	  The bug was introduced by f866314b89d56845f55e6f365e18b31ec978ec3a
	  and fixed by 3b3ddb4f7db98ec9e912ccdf54d35df4aa30e04a and
	  49ad572a70b8aeb91e57483a11dd1b77e31c4468.  Glibc 2.3.3 is
	  the only released version with the bug, but OpenSUSE 9
	  contains a buggy "glibc 2.3.2".

	  The symptom of the bug is that everything crashes on startup, saying:
	  dl_main: Assertion `(void *) ph->p_vaddr == _rtld_local._dl_sysinfo_dso' failed!

	  Saying Y here changes the default value of the vdso32 boot
	  option from 1 to 0, which turns off the 32-bit vDSO entirely.
	  This works around the glibc bug but hurts performance.

	  If unsure, say N: if you are compiling your own kernel, you
	  are unlikely to be using a buggy version of glibc.

config CMDLINE_BOOL
	bool "Built-in kernel command line"
	---help---
	  Allow for specifying boot arguments to the kernel at
	  build time.  On some systems (e.g. embedded ones), it is
	  necessary or convenient to provide some or all of the
	  kernel boot arguments with the kernel itself (that is,
	  to not rely on the boot loader to provide them.)

	  To compile command line arguments into the kernel,
	  set this option to 'Y', then fill in the
	  the boot arguments in CONFIG_CMDLINE.

	  Systems with fully functional boot loaders (i.e. non-embedded)
	  should leave this option set to 'N'.

config CMDLINE
	string "Built-in kernel command string"
	depends on CMDLINE_BOOL
	default ""
	---help---
	  Enter arguments here that should be compiled into the kernel
	  image and used at boot time.  If the boot loader provides a
	  command line at boot time, it is appended to this string to
	  form the full kernel command line, when the system boots.

	  However, you can use the CONFIG_CMDLINE_OVERRIDE option to
	  change this behavior.

	  In most cases, the command line (whether built-in or provided
	  by the boot loader) should specify the device for the root
	  file system.

config CMDLINE_OVERRIDE
	bool "Built-in command line overrides boot loader arguments"
	depends on CMDLINE_BOOL
	---help---
	  Set this option to 'Y' to have the kernel ignore the boot loader
	  command line, and use ONLY the built-in command line.

	  This is used to work around broken boot loaders.  This should
	  be set to 'N' under normal conditions.

source "kernel/livepatch/Kconfig"

endmenu

config ARCH_ENABLE_MEMORY_HOTPLUG
	def_bool y
	depends on X86_64 || (X86_32 && HIGHMEM)

config ARCH_ENABLE_MEMORY_HOTREMOVE
	def_bool y
	depends on MEMORY_HOTPLUG

config USE_PERCPU_NUMA_NODE_ID
	def_bool y
	depends on NUMA

config ARCH_ENABLE_SPLIT_PMD_PTLOCK
	def_bool y
	depends on X86_64 || X86_PAE

config ARCH_ENABLE_HUGEPAGE_MIGRATION
	def_bool y
	depends on X86_64 && HUGETLB_PAGE && MIGRATION

menu "Power management and ACPI options"

config ARCH_HIBERNATION_HEADER
	def_bool y
	depends on X86_64 && HIBERNATION

source "kernel/power/Kconfig"

source "drivers/acpi/Kconfig"

source "drivers/sfi/Kconfig"

config X86_APM_BOOT
	def_bool y
	depends on APM

menuconfig APM
	tristate "APM (Advanced Power Management) BIOS support"
	depends on X86_32 && PM_SLEEP
	---help---
	  APM is a BIOS specification for saving power using several different
	  techniques. This is mostly useful for battery powered laptops with
	  APM compliant BIOSes. If you say Y here, the system time will be
	  reset after a RESUME operation, the /proc/apm device will provide
	  battery status information, and user-space programs will receive
	  notification of APM "events" (e.g. battery status change).

	  If you select "Y" here, you can disable actual use of the APM
	  BIOS by passing the "apm=off" option to the kernel at boot time.

	  Note that the APM support is almost completely disabled for
	  machines with more than one CPU.

	  In order to use APM, you will need supporting software. For location
	  and more information, read <file:Documentation/power/apm-acpi.txt>
	  and the Battery Powered Linux mini-HOWTO, available from
	  <http://www.tldp.org/docs.html#howto>.

	  This driver does not spin down disk drives (see the hdparm(8)
	  manpage ("man 8 hdparm") for that), and it doesn't turn off
	  VESA-compliant "green" monitors.

	  This driver does not support the TI 4000M TravelMate and the ACER
	  486/DX4/75 because they don't have compliant BIOSes. Many "green"
	  desktop machines also don't have compliant BIOSes, and this driver
	  may cause those machines to panic during the boot phase.

	  Generally, if you don't have a battery in your machine, there isn't
	  much point in using this driver and you should say N. If you get
	  random kernel OOPSes or reboots that don't seem to be related to
	  anything, try disabling/enabling this option (or disabling/enabling
	  APM in your BIOS).

	  Some other things you should try when experiencing seemingly random,
	  "weird" problems:

	  1) make sure that you have enough swap space and that it is
	  enabled.
	  2) pass the "no-hlt" option to the kernel
	  3) switch on floating point emulation in the kernel and pass
	  the "no387" option to the kernel
	  4) pass the "floppy=nodma" option to the kernel
	  5) pass the "mem=4M" option to the kernel (thereby disabling
	  all but the first 4 MB of RAM)
	  6) make sure that the CPU is not over clocked.
	  7) read the sig11 FAQ at <http://www.bitwizard.nl/sig11/>
	  8) disable the cache from your BIOS settings
	  9) install a fan for the video card or exchange video RAM
	  10) install a better fan for the CPU
	  11) exchange RAM chips
	  12) exchange the motherboard.

	  To compile this driver as a module, choose M here: the
	  module will be called apm.

if APM

config APM_IGNORE_USER_SUSPEND
	bool "Ignore USER SUSPEND"
	---help---
	  This option will ignore USER SUSPEND requests. On machines with a
	  compliant APM BIOS, you want to say N. However, on the NEC Versa M
	  series notebooks, it is necessary to say Y because of a BIOS bug.

config APM_DO_ENABLE
	bool "Enable PM at boot time"
	---help---
	  Enable APM features at boot time. From page 36 of the APM BIOS
	  specification: "When disabled, the APM BIOS does not automatically
	  power manage devices, enter the Standby State, enter the Suspend
	  State, or take power saving steps in response to CPU Idle calls."
	  This driver will make CPU Idle calls when Linux is idle (unless this
	  feature is turned off -- see "Do CPU IDLE calls", below). This
	  should always save battery power, but more complicated APM features
	  will be dependent on your BIOS implementation. You may need to turn
	  this option off if your computer hangs at boot time when using APM
	  support, or if it beeps continuously instead of suspending. Turn
	  this off if you have a NEC UltraLite Versa 33/C or a Toshiba
	  T400CDT. This is off by default since most machines do fine without
	  this feature.

config APM_CPU_IDLE
	depends on CPU_IDLE
	bool "Make CPU Idle calls when idle"
	---help---
	  Enable calls to APM CPU Idle/CPU Busy inside the kernel's idle loop.
	  On some machines, this can activate improved power savings, such as
	  a slowed CPU clock rate, when the machine is idle. These idle calls
	  are made after the idle loop has run for some length of time (e.g.,
	  333 mS). On some machines, this will cause a hang at boot time or
	  whenever the CPU becomes idle. (On machines with more than one CPU,
	  this option does nothing.)

config APM_DISPLAY_BLANK
	bool "Enable console blanking using APM"
	---help---
	  Enable console blanking using the APM. Some laptops can use this to
	  turn off the LCD backlight when the screen blanker of the Linux
	  virtual console blanks the screen. Note that this is only used by
	  the virtual console screen blanker, and won't turn off the backlight
	  when using the X Window system. This also doesn't have anything to
	  do with your VESA-compliant power-saving monitor. Further, this
	  option doesn't work for all laptops -- it might not turn off your
	  backlight at all, or it might print a lot of errors to the console,
	  especially if you are using gpm.

config APM_ALLOW_INTS
	bool "Allow interrupts during APM BIOS calls"
	---help---
	  Normally we disable external interrupts while we are making calls to
	  the APM BIOS as a measure to lessen the effects of a badly behaving
	  BIOS implementation.  The BIOS should reenable interrupts if it
	  needs to.  Unfortunately, some BIOSes do not -- especially those in
	  many of the newer IBM Thinkpads.  If you experience hangs when you
	  suspend, try setting this to Y.  Otherwise, say N.

endif # APM

source "drivers/cpufreq/Kconfig"

source "drivers/cpuidle/Kconfig"

source "drivers/idle/Kconfig"

endmenu


menu "Bus options (PCI etc.)"

config PCI
	bool "PCI support"
	default y
	---help---
	  Find out whether you have a PCI motherboard. PCI is the name of a
	  bus system, i.e. the way the CPU talks to the other stuff inside
	  your box. Other bus systems are ISA, EISA, MicroChannel (MCA) or
	  VESA. If you have PCI, say Y, otherwise N.

choice
	prompt "PCI access mode"
	depends on X86_32 && PCI
	default PCI_GOANY
	---help---
	  On PCI systems, the BIOS can be used to detect the PCI devices and
	  determine their configuration. However, some old PCI motherboards
	  have BIOS bugs and may crash if this is done. Also, some embedded
	  PCI-based systems don't have any BIOS at all. Linux can also try to
	  detect the PCI hardware directly without using the BIOS.

	  With this option, you can specify how Linux should detect the
	  PCI devices. If you choose "BIOS", the BIOS will be used,
	  if you choose "Direct", the BIOS won't be used, and if you
	  choose "MMConfig", then PCI Express MMCONFIG will be used.
	  If you choose "Any", the kernel will try MMCONFIG, then the
	  direct access method and falls back to the BIOS if that doesn't
	  work. If unsure, go with the default, which is "Any".

config PCI_GOBIOS
	bool "BIOS"

config PCI_GOMMCONFIG
	bool "MMConfig"

config PCI_GODIRECT
	bool "Direct"

config PCI_GOOLPC
	bool "OLPC XO-1"
	depends on OLPC

config PCI_GOANY
	bool "Any"

endchoice

config PCI_BIOS
	def_bool y
	depends on X86_32 && PCI && (PCI_GOBIOS || PCI_GOANY)

# x86-64 doesn't support PCI BIOS access from long mode so always go direct.
config PCI_DIRECT
	def_bool y
	depends on PCI && (X86_64 || (PCI_GODIRECT || PCI_GOANY || PCI_GOOLPC || PCI_GOMMCONFIG))

config PCI_MMCONFIG
	def_bool y
	depends on X86_32 && PCI && (ACPI || SFI) && (PCI_GOMMCONFIG || PCI_GOANY)

config PCI_OLPC
	def_bool y
	depends on PCI && OLPC && (PCI_GOOLPC || PCI_GOANY)

config PCI_XEN
	def_bool y
	depends on PCI && XEN
	select SWIOTLB_XEN

config PCI_DOMAINS
	def_bool y
	depends on PCI

config PCI_MMCONFIG
	bool "Support mmconfig PCI config space access"
	depends on X86_64 && PCI && ACPI

config PCI_CNB20LE_QUIRK
	bool "Read CNB20LE Host Bridge Windows" if EXPERT
	depends on PCI
	help
	  Read the PCI windows out of the CNB20LE host bridge. This allows
	  PCI hotplug to work on systems with the CNB20LE chipset which do
	  not have ACPI.

	  There's no public spec for this chipset, and this functionality
	  is known to be incomplete.

	  You should say N unless you know you need this.

source "drivers/pci/pcie/Kconfig"

source "drivers/pci/Kconfig"

# x86_64 have no ISA slots, but can have ISA-style DMA.
config ISA_DMA_API
	bool "ISA-style DMA support" if (X86_64 && EXPERT)
	default y
	help
	  Enables ISA-style DMA support for devices requiring such controllers.
	  If unsure, say Y.

if X86_32

config ISA
	bool "ISA support"
	---help---
	  Find out whether you have ISA slots on your motherboard.  ISA is the
	  name of a bus system, i.e. the way the CPU talks to the other stuff
	  inside your box.  Other bus systems are PCI, EISA, MicroChannel
	  (MCA) or VESA.  ISA is an older system, now being displaced by PCI;
	  newer boards don't support it.  If you have ISA, say Y, otherwise N.

config EISA
	bool "EISA support"
	depends on ISA
	---help---
	  The Extended Industry Standard Architecture (EISA) bus was
	  developed as an open alternative to the IBM MicroChannel bus.

	  The EISA bus provided some of the features of the IBM MicroChannel
	  bus while maintaining backward compatibility with cards made for
	  the older ISA bus.  The EISA bus saw limited use between 1988 and
	  1995 when it was made obsolete by the PCI bus.

	  Say Y here if you are building a kernel for an EISA-based machine.

	  Otherwise, say N.

source "drivers/eisa/Kconfig"

config SCx200
	tristate "NatSemi SCx200 support"
	---help---
	  This provides basic support for National Semiconductor's
	  (now AMD's) Geode processors.  The driver probes for the
	  PCI-IDs of several on-chip devices, so its a good dependency
	  for other scx200_* drivers.

	  If compiled as a module, the driver is named scx200.

config SCx200HR_TIMER
	tristate "NatSemi SCx200 27MHz High-Resolution Timer Support"
	depends on SCx200
	default y
	---help---
	  This driver provides a clocksource built upon the on-chip
	  27MHz high-resolution timer.  Its also a workaround for
	  NSC Geode SC-1100's buggy TSC, which loses time when the
	  processor goes idle (as is done by the scheduler).  The
	  other workaround is idle=poll boot option.

config OLPC
	bool "One Laptop Per Child support"
	depends on !X86_PAE
	select GPIOLIB
	select OF
	select OF_PROMTREE
	select IRQ_DOMAIN
	---help---
	  Add support for detecting the unique features of the OLPC
	  XO hardware.

config OLPC_XO1_PM
	bool "OLPC XO-1 Power Management"
	depends on OLPC && MFD_CS5535 && PM_SLEEP
	select MFD_CORE
	---help---
	  Add support for poweroff and suspend of the OLPC XO-1 laptop.

config OLPC_XO1_RTC
	bool "OLPC XO-1 Real Time Clock"
	depends on OLPC_XO1_PM && RTC_DRV_CMOS
	---help---
	  Add support for the XO-1 real time clock, which can be used as a
	  programmable wakeup source.

config OLPC_XO1_SCI
	bool "OLPC XO-1 SCI extras"
	depends on OLPC && OLPC_XO1_PM
	depends on INPUT=y
	select POWER_SUPPLY
	select GPIO_CS5535
	select MFD_CORE
	---help---
	  Add support for SCI-based features of the OLPC XO-1 laptop:
	   - EC-driven system wakeups
	   - Power button
	   - Ebook switch
	   - Lid switch
	   - AC adapter status updates
	   - Battery status updates

config OLPC_XO15_SCI
	bool "OLPC XO-1.5 SCI extras"
	depends on OLPC && ACPI
	select POWER_SUPPLY
	---help---
	  Add support for SCI-based features of the OLPC XO-1.5 laptop:
	   - EC-driven system wakeups
	   - AC adapter status updates
	   - Battery status updates

config ALIX
	bool "PCEngines ALIX System Support (LED setup)"
	select GPIOLIB
	---help---
	  This option enables system support for the PCEngines ALIX.
	  At present this just sets up LEDs for GPIO control on
	  ALIX2/3/6 boards.  However, other system specific setup should
	  get added here.

	  Note: You must still enable the drivers for GPIO and LED support
	  (GPIO_CS5535 & LEDS_GPIO) to actually use the LEDs

	  Note: You have to set alix.force=1 for boards with Award BIOS.

config NET5501
	bool "Soekris Engineering net5501 System Support (LEDS, GPIO, etc)"
	select GPIOLIB
	---help---
	  This option enables system support for the Soekris Engineering net5501.

config GEOS
	bool "Traverse Technologies GEOS System Support (LEDS, GPIO, etc)"
	select GPIOLIB
	depends on DMI
	---help---
	  This option enables system support for the Traverse Technologies GEOS.

config TS5500
	bool "Technologic Systems TS-5500 platform support"
	depends on MELAN
	select CHECK_SIGNATURE
	select NEW_LEDS
	select LEDS_CLASS
	---help---
	  This option enables system support for the Technologic Systems TS-5500.

endif # X86_32

config AMD_NB
	def_bool y
	depends on CPU_SUP_AMD && PCI

source "drivers/pcmcia/Kconfig"

source "drivers/pci/hotplug/Kconfig"

config RAPIDIO
	tristate "RapidIO support"
	depends on PCI
	default n
	help
	  If enabled this option will include drivers and the core
	  infrastructure code to support RapidIO interconnect devices.

source "drivers/rapidio/Kconfig"

config X86_SYSFB
	bool "Mark VGA/VBE/EFI FB as generic system framebuffer"
	help
	  Firmwares often provide initial graphics framebuffers so the BIOS,
	  bootloader or kernel can show basic video-output during boot for
	  user-guidance and debugging. Historically, x86 used the VESA BIOS
	  Extensions and EFI-framebuffers for this, which are mostly limited
	  to x86.
	  This option, if enabled, marks VGA/VBE/EFI framebuffers as generic
	  framebuffers so the new generic system-framebuffer drivers can be
	  used on x86. If the framebuffer is not compatible with the generic
	  modes, it is adverticed as fallback platform framebuffer so legacy
	  drivers like efifb, vesafb and uvesafb can pick it up.
	  If this option is not selected, all system framebuffers are always
	  marked as fallback platform framebuffers as usual.

	  Note: Legacy fbdev drivers, including vesafb, efifb, uvesafb, will
	  not be able to pick up generic system framebuffers if this option
	  is selected. You are highly encouraged to enable simplefb as
	  replacement if you select this option. simplefb can correctly deal
	  with generic system framebuffers. But you should still keep vesafb
	  and others enabled as fallback if a system framebuffer is
	  incompatible with simplefb.

	  If unsure, say Y.

endmenu


menu "Executable file formats / Emulations"

source "fs/Kconfig.binfmt"

config IA32_EMULATION
	bool "IA32 Emulation"
	depends on X86_64
	select BINFMT_ELF
	select COMPAT_BINFMT_ELF
	select HAVE_UID16
	---help---
	  Include code to run legacy 32-bit programs under a
	  64-bit kernel. You should likely turn this on, unless you're
	  100% sure that you don't have any 32-bit programs left.

config IA32_AOUT
	tristate "IA32 a.out support"
	depends on IA32_EMULATION
	---help---
	  Support old a.out binaries in the 32bit emulation.

config X86_X32
	bool "x32 ABI for 64-bit mode"
	depends on X86_64 && IA32_EMULATION
	---help---
	  Include code to run binaries for the x32 native 32-bit ABI
	  for 64-bit processors.  An x32 process gets access to the
	  full 64-bit register file and wide data path while leaving
	  pointers at 32 bits for smaller memory footprint.

	  You will need a recent binutils (2.22 or later) with
	  elf32_x86_64 support enabled to compile a kernel with this
	  option set.

config COMPAT
	def_bool y
	depends on IA32_EMULATION || X86_X32
	select ARCH_WANT_OLD_COMPAT_IPC

if COMPAT
config COMPAT_FOR_U64_ALIGNMENT
	def_bool y

config SYSVIPC_COMPAT
	def_bool y
	depends on SYSVIPC

config KEYS_COMPAT
	def_bool y
	depends on KEYS
endif

endmenu


config HAVE_ATOMIC_IOMAP
	def_bool y
	depends on X86_32

config X86_DEV_DMA_OPS
	bool
	depends on X86_64 || STA2X11

config X86_DMA_REMAP
	bool
	depends on STA2X11

config PMC_ATOM
	def_bool y
        depends on PCI

source "net/Kconfig"

source "drivers/Kconfig"

source "drivers/firmware/Kconfig"

source "fs/Kconfig"

source "arch/x86/Kconfig.debug"

source "security/Kconfig"

source "crypto/Kconfig"

source "arch/x86/kvm/Kconfig"

source "lib/Kconfig"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef __PLATFORM_DATA_VIDEO_S3C
#define __PLATFORM_DATA_VIDEO_S3C

/* S3C_FB_MAX_WIN
 * Set to the maximum number of windows that any of the supported hardware
 * can use. Since the platform data uses this for an array size, having it
 * set to the maximum of any version of the hardware can do is safe.
 */
#define S3C_FB_MAX_WIN	(5)

/**
 * struct s3c_fb_pd_win - per window setup data
 * @xres     : The window X size.
 * @yres     : The window Y size.
 * @virtual_x: The virtual X size.
 * @virtual_y: The virtual Y size.
 */
struct s3c_fb_pd_win {
	unsigned short		default_bpp;
	unsigned short		max_bpp;
	unsigned short		xres;
	unsigned short		yres;
	unsigned short		virtual_x;
	unsigned short		virtual_y;
};

/**
 * struct s3c_fb_platdata -  S3C driver platform specific information
 * @setup_gpio: Setup the external GPIO pins to the right state to transfer
 *		the data from the display system to the connected display
 *		device.
 * @vidcon0: The base vidcon0 values to control the panel data format.
 * @vidcon1: The base vidcon1 values to control the panel data output.
 * @vtiming: Video timing when connected to a RGB type panel.
 * @win: The setup data for each hardware window, or NULL for unused.
 * @display_mode: The LCD output display mode.
 *
 * The platform data supplies the video driver with all the information
 * it requires to work with the display(s) attached to the machine. It
 * controls the initial mode, the number of display windows (0 is always
 * the base framebuffer) that are initialised etc.
 *
 */
struct s3c_fb_platdata {
	void	(*setup_gpio)(void);

	struct s3c_fb_pd_win	*win[S3C_FB_MAX_WIN];
	struct fb_videomode     *vtiming;

	u32			 vidcon0;
	u32			 vidcon1;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 *      intel-mid_wdt: generic Intel MID SCU watchdog driver
 *
 *      Copyright (C) 2014 Intel Corporation. All rights reserved.
 *      Contact: David Cohen <david.a.cohen@linux.intel.com>
 *
 *      This program is free software; you can redistribute it and/or
 *      modify it under the terms of version 2 of the GNU General
 *      Public License as published by the Free Software Foundation.
 */

#ifndef __INTEL_MID_WDT_H__
#define __INTEL_MID_WDT_H__

#include <linux/platform_device.h>

struct intel_mid_wdt_pdata {
	int irq;
	int (*probe)(struct platform_device *pdev);
};

#endif /*__INTEL_MID_WDT_H__*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * Copyright 2005 Simtec Electronics
 *	Ben Dooks <ben@simtec.co.uk>
 *	http://armlinux.simtec.co.uk/
 *
 * S3C - HWMon interface for ADC
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

#ifndef __HWMON_S3C_H__
#define __HWMON_S3C_H__

/**
 * s3c_hwmon_chcfg - channel configuration
 * @name: The name to give this channel.
 * @mult: Multiply the ADC value read by this.
 * @div: Divide the value from the ADC by this.
 *
 * The value read from the ADC is converted to a value that
 * hwmon expects (mV) by result = (value_read * @mult) / @div.
 */
struct s3c_hwmon_chcfg {
	const char	*name;
	unsigned int	mult;
	unsigned int	div;
};

/**
 * s3c_hwmon_pdata - HWMON platform data
 * @in: One configuration for each possible channel used.
 */
struct s3c_hwmon_pdata {
	struct s3c_hwmon_chcfg	*in[8];
};

/**
 * s3c_hwmon_set_platdata - Set platform data for S3C HWMON device
 * @pd: Platform data to register to device.
 *
 * Register the given platform data for use with the S3C HWMON device.
 * The call will copy the platform data, so the board definitions can
 * make the structure itself __initdata.
 */
extern void __init s3c_hwmon_set_platdata(struct s3c_hwmon_pdata *pd);

#endif /* __HWMON_S3C_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  void __init u300_clk_init(void __iomem *base);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Copyright (C) 2011 Marvell International Ltd. All rights reserved.
 *
 * This program is free software; you can redistribute  it and/or modify it
 * under  the terms of  the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the  License, or (at your
 * option) any later version.
 */

#ifndef __MV_PLATFORM_USB_H
#define __MV_PLATFORM_USB_H

enum pxa_ehci_type {
	EHCI_UNDEFINED = 0,
	PXA_U2OEHCI,	/* pxa 168, 9xx */
	PXA_SPH,	/* pxa 168, 9xx SPH */
	MMP3_HSIC,	/* mmp3 hsic */
	MMP3_FSIC,	/* mmp3 fsic */
};

enum {
	MV_USB_MODE_OTG,
	MV_USB_MODE_HOST,
};

enum {
	VBUS_LOW	= 0,
	VBUS_HIGH	= 1 << 0,
};

struct mv_usb_addon_irq {
	unsigned int	irq;
	int		(*poll)(void);
};

struct mv_usb_platform_data {
	struct mv_usb_addon_irq	*id;	/* Only valid for OTG. ID pin change*/
	struct mv_usb_addon_irq	*vbus;	/* valid for OTG/UDC. VBUS change*/

	/* only valid for HCD. OTG or Host only*/
	unsigned int		mode;

	/* This flag is used for that needs id pin checked by otg */
	unsigned int    disable_otg_clock_gating:1;
	/* Force a_bus_req to be asserted */
	 unsigned int    otg_force_a_bus_req:1;

	int	(*phy_init)(void __iomem *regbase);
	void	(*phy_deinit)(void __iomem *regbase);
	int	(*set_vbus)(unsigned int vbus);
	int     (*private_init)(void __iomem *opregs, void __iomem *phyregs);
};
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef ASMARM_ARCH_MMC_H
#define ASMARM_ARCH_MMC_H

#include <linux/mmc/host.h>

struct device;

/* board specific SDHC data, optional.
 * If not present, a writable card with 3,3V is assumed.
 */
struct imxmmc_platform_data {
	/* Return values for the get_ro callback should be:
	 *   0 for a read/write card
	 *   1 for a read-only card
	 *   -ENOSYS when not supported (equal to NULL callback)
	 *   or a negative errno value when something bad happened
	 */
	int (*get_ro)(struct device *);

	/* board specific hook to (de)initialize the SD slot.
	 * The board code can call 'handler' on a card detection
	 * change giving data as argument.
	 */
	int (*init)(struct device *dev, irq_handler_t handler, void *data);
	void (*exit)(struct device *dev, void *data);

	/* available voltages. If not given, assume
	 * MMC_VDD_32_33 | MMC_VDD_33_34
	 */
	unsigned int ocr_avail;

	/* adjust slot voltage */
	void (*setpower)(struct device *, unsigned int vdd);

	/* enable card detect using DAT3 */
	int dat3_card_detect;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * Driver for the High Speed UART DMA
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef _PLATFORM_DATA_DMA_HSU_H
#define _PLATFORM_DATA_DMA_HSU_H

#include <linux/device.h>

struct hsu_dma_slave {
	struct device	*dma_dev;
	int		chan_id;
};

struct hsu_dma_platform_data {
	unsigned short	nr_channels;
};

#endif /* _PLATFORM_DATA_DMA_HSU_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * PXA3xx U2D header
 *
 * Copyright (C) 2010 CompuLab Ltd.
 *
 * Igor Grinberg <grinberg@compulab.co.il>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#ifndef __PXA310_U2D__
#define __PXA310_U2D__

#include <linux/usb/ulpi.h>

struct pxa3xx_u2d_platform_data {

#define ULPI_SER_6PIN	(1 << 0)
#define ULPI_SER_3PIN	(1 << 1)
	unsigned int ulpi_mode;

	int (*init)(struct device *);
	void (*exit)(struct device *);
};


/* Start PXA3xx U2D host */
int pxa3xx_u2d_start_hc(struct usb_bus *host);
/* Stop PXA3xx U2D host */
void pxa3xx_u2d_stop_hc(struct usb_bus *host);

extern void pxa3xx_set_u2d_info(struct pxa3xx_u2d_platform_data *info);

#endif /* __PXA310_U2D__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * simplefb.h - Simple Framebuffer Device
 *
 * Copyright (C) 2013 David Herrmann <dh.herrmann@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef __PLATFORM_DATA_SIMPLEFB_H__
#define __PLATFORM_DATA_SIMPLEFB_H__

#include <drm/drm_fourcc.h>
#include <linux/fb.h>
#include <linux/kernel.h>

/* format array, use it to initialize a "struct simplefb_format" array */
#define SIMPLEFB_FORMATS \
{ \
	{ "r5g6b5", 16, {11, 5}, {5, 6}, {0, 5}, {0, 0}, DRM_FORMAT_RGB565 }, \
	{ "x1r5g5b5", 16, {10, 5}, {5, 5}, {0, 5}, {0, 0}, DRM_FORMAT_XRGB1555 }, \
	{ "a1r5g5b5", 16, {10, 5}, {5, 5}, {0, 5}, {15, 1}, DRM_FORMAT_ARGB1555 }, \
	{ "r8g8b8", 24, {16, 8}, {8, 8}, {0, 8}, {0, 0}, DRM_FORMAT_RGB888 }, \
	{ "x8r8g8b8", 32, {16, 8}, {8, 8}, {0, 8}, {0, 0}, DRM_FORMAT_XRGB8888 }, \
	{ "a8r8g8b8", 32, {16, 8}, {8, 8}, {0, 8}, {24, 8}, DRM_FORMAT_ARGB8888 }, \
	{ "a8b8g8r8", 32, {0, 8}, {8, 8}, {16, 8}, {24, 8}, DRM_FORMAT_ABGR8888 }, \
	{ "x2r10g10b10", 32, {20, 10}, {10, 10}, {0, 10}, {0, 0}, DRM_FORMAT_XRGB2101010 }, \
	{ "a2r10g10b10", 32, {20, 10}, {10, 10}, {0, 10}, {30, 2}, DRM_FORMAT_ARGB2101010 }, \
}

/*
 * Data-Format for Simple-Framebuffers
 * @name: unique 0-terminated name that can be used to identify the mode
 * @red,green,blue: Offsets and sizes of the single RGB parts
 * @transp: Offset and size of the alpha bits. length=0 means no alpha
 * @fourcc: 32bit DRM four-CC code (see drm_fourcc.h)
 */
struct simplefb_format {
	const char *name;
	u32 bits_per_pixel;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	u32 fourcc;
};

/*
 * Simple-Framebuffer description
 * If the arch-boot code creates simple-framebuffers without DT support, it
 * can pass the width, height, stride and format via this platform-data object.
 * The framebuffer location must be given as IORESOURCE_MEM resource.
 * @format must be a format as described in "struct simplefb_format" above.
 */
struct simplefb_platform_data {
	u32 width;
	u32 height;
	u32 stride;
	const char *format;
};

#endif /* __PLATFORM_DATA_SIMPLEFB_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * DRM/KMS platform data for TI OMAP platforms
 *
 * Copyright (C) 2012 Texas Instruments
 * Author: Rob Clark <rob.clark@linaro.org>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __PLATFORM_DATA_OMAP_DRM_H__
#define __PLATFORM_DATA_OMAP_DRM_H__

/*
 * Optional platform data to configure the default configuration of which
 * pipes/overlays/CRTCs are used.. if this is not provided, then instead the
 * first CONFIG_DRM_OMAP_NUM_CRTCS are used, and they are each connected to
 * one manager, with priority given to managers that are connected to
 * detected devices.  Remaining overlays are used as video planes.  This
 * should be a good default behavior for most cases, but yet there still
 * might be times when you wish to do something different.
 */
struct omap_kms_platform_data {
	/* overlays to use as CRTCs: */
	int ovl_cnt;
	const int *ovl_ids;

	/* overlays to use as video planes: */
	int pln_cnt;
	const int *pln_ids;

	int mgr_cnt;
	const int *mgr_ids;

	int dev_cnt;
	const char **dev_names;
};

struct omap_drm_platform_data {
	uint32_t omaprev;
	struct omap_kms_platform_data *kms_pdata;
};

#endif /* __PLATFORM_DATA_OMAP_DRM_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * Platform data for Renesas R-Car VIN soc-camera driver
 *
 * Copyright (C) 2011-2013 Renesas Solutions Corp.
 * Copyright (C) 2013 Cogent Embedded, Inc., <source@cogentembedded.com>
 *
 * This program is free software; you can redistribute  it and/or modify it
 * under  the terms of  the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the  License, or (at your
 * option) any later version.
 */

#ifndef __CAMERA_RCAR_H_
#define __CAMERA_RCAR_H_

#define RCAR_VIN_HSYNC_ACTIVE_LOW	(1 << 0)
#define RCAR_VIN_VSYNC_ACTIVE_LOW	(1 << 1)
#define RCAR_VIN_BT601			(1 << 2)
#define RCAR_VIN_BT656			(1 << 3)

struct rcar_vin_platform_data {
	unsigned int flags;
};

#endif /* __CAMERA_RCAR_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * Copyright (c) 2004 Simtec Electronics
 *	Ben Dooks <ben@simtec.co.uk>
 *
 * S3C2410 - NAND device controller platform_device info
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

#ifndef __MTD_NAND_S3C2410_H
#define __MTD_NAND_S3C2410_H

/**
 * struct s3c2410_nand_set - define a set of one or more nand chips
 * @disable_ecc:	Entirely disable ECC - Dangerous
 * @flash_bbt: 		Openmoko u-boot can create a Bad Block Table
 *			Setting this flag will allow the kernel to
 *			look for it at boot time and also skip the NAND
 *			scan.
 * @options:		Default value to set into 'struct nand_chip' options.
 * @nr_chips:		Number of chips in this set
 * @nr_partitions:	Number of partitions pointed to by @partitions
 * @name:		Name of set (optional)
 * @nr_map:		Map for low-layer logical to physical chip numbers (option)
 * @partitions:		The mtd partition list
 *
 * define a set of one or more nand chips registered with an unique mtd. Also
 * allows to pass flag to the underlying NAND layer. 'disable_ecc' will trigger
 * a warning at boot time.
 */
struct s3c2410_nand_set {
	unsigned int		disable_ecc:1;
	unsigned int		flash_bbt:1;

	unsigned int		options;
	int			nr_chips;
	int			nr_partitions;
	char			*name;
	int			*nr_map;
	struct mtd_partition	*partitions;
	struct nand_ecclayout	*ecc_layout;
};

struct s3c2410_platform_nand {
	/* timing information for controller, all times in nanoseconds */

	int	tacls;	/* time for active CLE/ALE to nWE/nOE */
	int	twrph0;	/* active time for nWE/nOE */
	int	twrph1;	/* time for release CLE/ALE from nWE/nOE inactive */

	unsigned int	ignore_unset_ecc:1;

	int			nr_sets;
	struct s3c2410_nand_set *sets;

	void			(*select_chip)(struct s3c2410_nand_set *,
					       int chip);
};

/**
 * s3c_nand_set_platdata() - register NAND platform data.
 * @nand: The NAND platform data to register with s3c_device_nand.
 *
 * This function copies the given NAND platform data, @nand and registers
 * it with the s3c_device_nand. This allows @nand to be __initdata.
*/
extern void s3c_nand_set_platdata(struct s3c2410_platform_nand *nand);

#endif /*__MTD_NAND_S3C2410_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * AD7266/65 SPI ADC driver
 *
 * Copyright 2012 Analog Devices Inc.
 *
 * Licensed under the GPL-2.
 */

#ifndef __IIO_ADC_AD7266_H__
#define __IIO_ADC_AD7266_H__

/**
 * enum ad7266_range - AD7266 reference voltage range
 * @AD7266_RANGE_VREF: Device is configured for input range 0V - VREF
 *			(RANGE pin set to low)
 * @AD7266_RANGE_2VREF: Device is configured for input range 0V - 2VREF
 *			(RANGE pin set to high)
 */
enum ad7266_range {
	AD7266_RANGE_VREF,
	AD7266_RANGE_2VREF,
};

/**
 * enum ad7266_mode - AD7266 sample mode
 * @AD7266_MODE_DIFF: Device is configured for full differential mode
 *				(SGL/DIFF pin set to low, AD0 pin set to low)
 * @AD7266_MODE_PSEUDO_DIFF: Device is configured for pseudo differential mode
 *				(SGL/DIFF pin set to low, AD0 pin set to high)
 * @AD7266_MODE_SINGLE_ENDED: Device is configured for single-ended mode
 *				(SGL/DIFF pin set to high)
 */
enum ad7266_mode {
	AD7266_MODE_DIFF,
	AD7266_MODE_PSEUDO_DIFF,
	AD7266_MODE_SINGLE_ENDED,
};

/**
 * struct ad7266_platform_data - Platform data for the AD7266 driver
 * @range: Reference voltage range the device is configured for
 * @mode: Sample mode the device is configured for
 * @fixed_addr: Whether the address pins are hard-wired
 * @addr_gpios: GPIOs used for controlling the address pins, only used if
 *		fixed_addr is set to false.
 */
struct ad7266_platform_data {
	enum ad7266_range range;
	enum ad7266_mode mode;
	bool fixed_addr;
	unsigned int addr_gpios[3];
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * LP8727 Micro/Mini USB IC with integrated charger
 *
 *			Copyright (C) 2011 Texas Instruments
 *			Copyright (C) 2011 National Semiconductor
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef _LP8727_H
#define _LP8727_H

enum lp8727_eoc_level {
	LP8727_EOC_5P,
	LP8727_EOC_10P,
	LP8727_EOC_16P,
	LP8727_EOC_20P,
	LP8727_EOC_25P,
	LP8727_EOC_33P,
	LP8727_EOC_50P,
};

enum lp8727_ichg {
	LP8727_ICHG_90mA,
	LP8727_ICHG_100mA,
	LP8727_ICHG_400mA,
	LP8727_ICHG_450mA,
	LP8727_ICHG_500mA,
	LP8727_ICHG_600mA,
	LP8727_ICHG_700mA,
	LP8727_ICHG_800mA,
	LP8727_ICHG_900mA,
	LP8727_ICHG_1000mA,
};

/**
 * struct lp8727_chg_param
 * @eoc_level : end of charge level setting
 * @ichg      : charging current
 */
struct lp8727_chg_param {
	enum lp8727_eoc_level eoc_level;
	enum lp8727_ichg ichg;
};

/**
 * struct lp8727_platform_data
 * @get_batt_present  : check battery status - exists or not
 * @get_batt_level    : get battery voltage (mV)
 * @get_batt_capacity : get battery capacity (%)
 * @get_batt_temp     : get battery temperature
 * @ac                : charging parameters for AC type charger
 * @usb               : charging parameters for USB type charger
 * @debounce_msec     : interrupt debounce time
 */
struct lp8727_platform_data {
	u8 (*get_batt_present)(void);
	u16 (*get_batt_level)(void);
	u8 (*get_batt_capacity)(void);
	u8 (*get_batt_temp)(void);
	struct lp8727_chg_param *ac;
	struct lp8727_chg_param *usb;
	unsigned int debounce_msec;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * AD7792/AD7793 SPI ADC driver
 *
 * Copyright 2011 Analog Devices Inc.
 *
 * Licensed under the GPL-2.
 */
#ifndef __LINUX_PLATFORM_DATA_AD7793_H__
#define __LINUX_PLATFORM_DATA_AD7793_H__

/**
 * enum ad7793_clock_source - AD7793 clock source selection
 * @AD7793_CLK_SRC_INT: Internal 64 kHz clock, not available at the CLK pin.
 * @AD7793_CLK_SRC_INT_CO: Internal 64 kHz clock, available at the CLK pin.
 * @AD7793_CLK_SRC_EXT: Use external clock.
 * @AD7793_CLK_SRC_EXT_DIV2: Use external clock divided by 2.
 */
enum ad7793_clock_source {
	AD7793_CLK_SRC_INT,
	AD7793_CLK_SRC_INT_CO,
	AD7793_CLK_SRC_EXT,
	AD7793_CLK_SRC_EXT_DIV2,
};

/**
 * enum ad7793_bias_voltage - AD7793 bias voltage selection
 * @AD7793_BIAS_VOLTAGE_DISABLED: Bias voltage generator disabled
 * @AD7793_BIAS_VOLTAGE_AIN1: Bias voltage connected to AIN1(-).
 * @AD7793_BIAS_VOLTAGE_AIN2: Bias voltage connected to AIN2(-).
 * @AD7793_BIAS_VOLTAGE_AIN3: Bias voltage connected to AIN3(-).
 *	Only valid for AD7795/AD7796.
 */
enum ad7793_bias_voltage {
	AD7793_BIAS_VOLTAGE_DISABLED,
	AD7793_BIAS_VOLTAGE_AIN1,
	AD7793_BIAS_VOLTAGE_AIN2,
	AD7793_BIAS_VOLTAGE_AIN3,
};

/**
 * enum ad7793_refsel - AD7793 reference voltage selection
 * @AD7793_REFSEL_REFIN1: External reference applied between REFIN1(+)
 *	and REFIN1(-).
 * @AD7793_REFSEL_REFIN2: External reference applied between REFIN2(+) and
 *	and REFIN1(-). Only valid for AD7795/AD7796.
 * @AD7793_REFSEL_INTERNAL: Internal 1.17 V reference.
 */
enum ad7793_refsel {
	AD7793_REFSEL_REFIN1 = 0,
	AD7793_REFSEL_REFIN2 = 1,
	AD7793_REFSEL_INTERNAL = 2,
};

/**
 * enum ad7793_current_source_direction - AD7793 excitation current direction
 * @AD7793_IEXEC1_IOUT1_IEXEC2_IOUT2: Current source IEXC1 connected to pin
 *	IOUT1, current source IEXC2 connected to pin IOUT2.
 * @AD7793_IEXEC1_IOUT2_IEXEC2_IOUT1: Current source IEXC2 connected to pin
 *	IOUT1, current source IEXC1 connected to pin IOUT2.
 * @AD7793_IEXEC1_IEXEC2_IOUT1: Both current sources connected to pin IOUT1.
 *	Only valid when the current sources are set to 10 uA or 210 uA.
 * @AD7793_IEXEC1_IEXEC2_IOUT2: Both current sources connected to Pin IOUT2.
 *	Only valid when the current ources are set to 10 uA or 210 uA.
 */
enum ad7793_current_source_direction {
	AD7793_IEXEC1_IOUT1_IEXEC2_IOUT2 = 0,
	AD7793_IEXEC1_IOUT2_IEXEC2_IOUT1 = 1,
	AD7793_IEXEC1_IEXEC2_IOUT1 = 2,
	AD7793_IEXEC1_IEXEC2_IOUT2 = 3,
};

/**
 * enum ad7793_excitation_current - AD7793 excitation current selection
 * @AD7793_IX_DISABLED: Excitation current Disabled.
 * @AD7793_IX_10uA: Enable 10 micro-ampere excitation current.
 * @AD7793_IX_210uA: Enable 210 micro-ampere excitation current.
 * @AD7793_IX_1mA: Enable 1 milli-Ampere excitation current.
 */
enum ad7793_excitation_current {
	AD7793_IX_DISABLED = 0,
	AD7793_IX_10uA = 1,
	AD7793_IX_210uA = 2,
	AD7793_IX_1mA = 3,
};

/**
 * struct ad7793_platform_data - AD7793 platform data
 * @clock_src: Clock source selection
 * @burnout_current: If set to true the 100nA burnout current is enabled.
 * @boost_enable: Enable boost for the bias voltage generator.
 * @buffered: If set to true configure the device for buffered input mode.
 * @unipolar: If set to true sample in unipolar mode, if set to false sample in
 *		bipolar mode.
 * @refsel: Reference voltage selection
 * @bias_voltage: Bias voltage selection
 * @exitation_current: Excitation current selection
 * @current_source_direction: Excitation current direction selection
 */
struct ad7793_platform_data {
	enum ad7793_clock_source clock_src;
	bool burnout_current;
	bool boost_enable;
	bool buffered;
	bool unipolar;

	enum ad7793_refsel refsel;
	enum ad7793_bias_voltage bias_voltage;
	enum ad7793_excitation_current exitation_current;
	enum ad7793_current_source_direction current_source_direction;
};

#endif /* IIO_ADC_AD7793_H_ */
                                                                                                                                                                                                                                                                      /*
 * LP8755 High Performance Power Management Unit Driver:System Interface Driver
 *
 *			Copyright (C) 2012 Texas Instruments
 *
 * Author: Daniel(Geon Si) Jeong <daniel.jeong@ti.com>
 *             G.Shark Jeong <gshark.jeong@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 */

#ifndef _LP8755_H
#define _LP8755_H

#include <linux/regulator/consumer.h>

#define LP8755_NAME "lp8755-regulator"
/*
 *PWR FAULT : power fault detected
 *OCP : over current protect activated
 *OVP : over voltage protect activated
 *TEMP_WARN : thermal warning
 *TEMP_SHDN : thermal shutdonw detected
 *I_LOAD : current measured
 */
#define LP8755_EVENT_PWR_FAULT REGULATOR_EVENT_FAIL
#define LP8755_EVENT_OCP REGULATOR_EVENT_OVER_CURRENT
#define LP8755_EVENT_OVP 0x10000
#define LP8755_EVENT_TEMP_WARN 0x2000
#define LP8755_EVENT_TEMP_SHDN REGULATOR_EVENT_OVER_TEMP
#define LP8755_EVENT_I_LOAD	0x40000

enum lp8755_bucks {
	LP8755_BUCK0 = 0,
	LP8755_BUCK1,
	LP8755_BUCK2,
	LP8755_BUCK3,
	LP8755_BUCK4,
	LP8755_BUCK5,
	LP8755_BUCK_MAX,
};

/**
 * multiphase configuration options
 */
enum lp8755_mphase_config {
	MPHASE_CONF0,
	MPHASE_CONF1,
	MPHASE_CONF2,
	MPHASE_CONF3,
	MPHASE_CONF4,
	MPHASE_CONF5,
	MPHASE_CONF6,
	MPHASE_CONF7,
	MPHASE_CONF8,
	MPHASE_CONF_MAX
};

/**
 * struct lp8755_platform_data
 * @mphase_type : Multiphase Switcher Configurations.
 * @buck_data   : buck0~6 init voltage in uV
 */
struct lp8755_platform_data {
	int mphase;
	struct regulator_init_data *buck_data[LP8755_BUCK_MAX];
};
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Copyright (C) 2008
 * Guennadi Liakhovetski, DENX Software Engineering, <lg@denx.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef __ASM_ARCH_MX3FB_H__
#define __ASM_ARCH_MX3FB_H__

#include <linux/device.h>
#include <linux/fb.h>

/* Proprietary FB_SYNC_ flags */
#define FB_SYNC_OE_ACT_HIGH	0x80000000
#define FB_SYNC_CLK_INVERT	0x40000000
#define FB_SYNC_DATA_INVERT	0x20000000
#define FB_SYNC_CLK_IDLE_EN	0x10000000
#define FB_SYNC_SHARP_MODE	0x08000000
#define FB_SYNC_SWAP_RGB	0x04000000
#define FB_SYNC_CLK_SEL_EN	0x02000000

/*
 * Specify the way your display is connected. The IPU can arbitrarily
 * map the internal colors to the external data lines. We only support
 * the following mappings at the moment.
 */
enum disp_data_mapping {
	/* blue -> d[0..5], green -> d[6..11], red -> d[12..17] */
	IPU_DISP_DATA_MAPPING_RGB666,
	/* blue -> d[0..4], green -> d[5..10], red -> d[11..15] */
	IPU_DISP_DATA_MAPPING_RGB565,
	/* blue -> d[0..7], green -> d[8..15], red -> d[16..23] */
	IPU_DISP_DATA_MAPPING_RGB888,
};

/**
 * struct mx3fb_platform_data - mx3fb platform data
 *
 * @dma_dev:	pointer to the dma-device, used for dma-slave connection
 * @mode:	pointer to a platform-provided per mxc_register_fb() videomode
 */
struct mx3fb_platform_data {
	struct device			*dma_dev;
	const char			*name;
	const struct fb_videomode	*mode;
	int				num_modes;
	enum disp_data_mapping		disp_data_fmt;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * Internal shared definitions for various MSM framebuffer parts.
 *
 * Copyright (C) 2007 Google Incorporated
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#ifndef _MSM_FB_H_
#define _MSM_FB_H_

#include <linux/device.h>

struct mddi_info;

struct msm_fb_data {
	int xres;	/* x resolution in pixels */
	int yres;	/* y resolution in pixels */
	int width;	/* disply width in mm */
	int height;	/* display height in mm */
	unsigned output_format;
};

struct msmfb_callback {
	void (*func)(struct msmfb_callback *);
};

enum {
	MSM_MDDI_PMDH_INTERFACE,
	MSM_MDDI_EMDH_INTERFACE,
	MSM_EBI2_INTERFACE,
};

#define MSMFB_CAP_PARTIAL_UPDATES	(1 << 0)

struct msm_panel_data {
	/* turns off the fb memory */
	int (*suspend)(struct msm_panel_data *);
	/* turns on the fb memory */
	int (*resume)(struct msm_panel_data *);
	/* turns off the panel */
	int (*blank)(struct msm_panel_data *);
	/* turns on the panel */
	int (*unblank)(struct msm_panel_data *);
	void (*wait_vsync)(struct msm_panel_data *);
	void (*request_vsync)(struct msm_panel_data *, struct msmfb_callback *);
	void (*clear_vsync)(struct msm_panel_data *);
	/* from the enum above */
	unsigned interface_type;
	/* data to be passed to the fb driver */
	struct msm_fb_data *fb_data;

	/* capabilities supported by the panel */
	uint32_t caps;
};

struct msm_mddi_client_data {
	void (*suspend)(struct msm_mddi_client_data *);
	void (*resume)(struct msm_mddi_client_data *);
	void (*activate_link)(struct msm_mddi_client_data *);
	void (*remote_write)(struct msm_mddi_client_data *, uint32_t val,
			     uint32_t reg);
	uint32_t (*remote_read)(struct msm_mddi_client_data *, uint32_t reg);
	void (*auto_hibernate)(struct msm_mddi_client_data *, int);
	/* custom data that needs to be passed from the board file to a 
	 * particular client */
	void *private_client_data;
	struct resource *fb_resource;
	/* from the list above */
	unsigned interface_type;
};

struct msm_mddi_platform_data {
	unsigned int clk_rate;
	void (*power_client)(struct msm_mddi_client_data *, int on);

	/* fixup the mfr name, product id */
	void (*fixup)(uint16_t *mfr_name, uint16_t *product_id);

	struct resource *fb_resource; /*optional*/
	/* number of clients in the list that follows */
	int num_clients;
	/* array of client information of clients */
	struct {
		unsigned product_id; /* mfr id in top 16 bits, product id
				      * in lower 16 bits
				      */
		char *name;	/* the device name will be the platform
				 * device name registered for the client,
				 * it should match the name of the associated
				 * driver
				 */
		unsigned id;	/* id for mddi client device node, will also
				 * be used as device id of panel devices, if
				 * the client device will have multiple panels
				 * space must be left here for them
				 */
		void *client_data;	/* required private client data */
		unsigned int clk_rate;	/* optional: if the client requires a
					* different mddi clk rate
					*/
	} client_platform_data[];
};

struct mdp_blit_req;
struct fb_info;
struct mdp_device {
	struct device dev;
	void (*dma)(struct mdp_device *mpd, uint32_t addr,
		    uint32_t stride, uint32_t w, uint32_t h, uint32_t x,
		    uint32_t y, struct msmfb_callback *callback, int interface);
	void (*dma_wait)(struct mdp_device *mdp);
	int (*blit)(struct mdp_device *mdp, struct fb_info *fb,
		    struct mdp_blit_req *req);
	void (*set_grp_disp)(struct mdp_device *mdp, uint32_t disp_id);
};

struct class_interface;
int register_mdp_client(struct class_interface *class_intf);

/**** private client data structs go below this line ***/

struct msm_mddi_bridge_platform_data {
	/* from board file */
	int (*init)(struct msm_mddi_bridge_platform_data *,
		    struct msm_mddi_client_data *);
	int (*uninit)(struct msm_mddi_bridge_platform_data *,
		      struct msm_mddi_client_data *);
	/* passed to panel for use by the fb driver */
	int (*blank)(struct msm_mddi_bridge_platform_data *,
		     struct msm_mddi_client_data *);
	int (*unblank)(struct msm_mddi_bridge_platform_data *,
		       struct msm_mddi_client_data *);
	struct msm_fb_data fb_data;
};



#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #ifndef ASMARM_ARCH_OHCI_H
#define ASMARM_ARCH_OHCI_H

struct device;

struct pxaohci_platform_data {
	int (*init)(struct device *);
	void (*exit)(struct device *);

	unsigned long flags;
#define ENABLE_PORT1		(1 << 0)
#define ENABLE_PORT2		(1 << 1)
#define ENABLE_PORT3		(1 << 2)
#define ENABLE_PORT_ALL		(ENABLE_PORT1 | ENABLE_PORT2 | ENABLE_PORT3)

#define POWER_SENSE_LOW		(1 << 3)
#define POWER_CONTROL_LOW	(1 << 4)
#define NO_OC_PROTECTION	(1 << 5)
#define OC_MODE_GLOBAL		(0 << 6)
#define OC_MODE_PERPORT		(1 << 6)

	int power_on_delay;	/* Power On to Power Good time - in ms
				 * HCD must wait for this duration before
				 * accessing a powered on port
				 */
	int port_mode;
#define PMM_NPS_MODE           1
#define PMM_GLOBAL_MODE        2
#define PMM_PERPORT_MODE       3

	int power_budget;
};

extern void pxa_set_ohci_info(struct pxaohci_platform_data *info);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * BCH Error Location Module
 *
 * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 */

#ifndef __ELM_H
#define __ELM_H

enum bch_ecc {
	BCH4_ECC = 0,
	BCH8_ECC,
	BCH16_ECC,
};

/* ELM support 8 error syndrome process */
#define ERROR_VECTOR_MAX		8

/**
 * struct elm_errorvec - error vector for elm
 * @error_reported:		set true for vectors error is reported
 * @error_uncorrectable:	number of uncorrectable errors
 * @error_count:		number of correctable errors in the sector
 * @error_loc:			buffer for error location
 *
 */
struct elm_errorvec {
	bool error_reported;
	bool error_uncorrectable;
	int error_count;
	int error_loc[16];
};

#if IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH)
void elm_decode_bch_error_page(struct device *dev, u8 *ecc_calc,
		struct elm_errorvec *err_vec);
int elm_config(struct device *dev, enum bch_ecc bch_type,
	int ecc_steps, int ecc_step_size, int ecc_syndrome_size);
#else
static inline void
elm_decode_bch_error_page(struct device *dev, u8 *ecc_calc,
			  struct elm_errorvec *err_vec)
{
}

static inline int elm_config(struct device *dev, enum bch_ecc bch_type,
			     int ecc_steps, int ecc_step_size,
			     int ecc_syndrome_size)
{
	return -ENOSYS;
}
#endif /* CONFIG_MTD_NAND_ECC_BCH */

#endif /* __ELM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * SSM2518 amplifier audio driver
 *
 * Copyright 2013 Analog Devices Inc.
 *  Author: Lars-Peter Clausen <lars@metafoo.de>
 *
 * Licensed under the GPL-2.
 */

#ifndef __LINUX_PLATFORM_DATA_SSM2518_H__
#define __LINUX_PLATFORM_DATA_SSM2518_H__

/**
 * struct ssm2518_platform_data - Platform data for the ssm2518 driver
 * @enable_gpio: GPIO connected to the nSD pin. Set to -1 if the nSD pin is
 *            hardwired.
 */
struct ssm2518_platform_data {
	int enable_gpio;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #ifndef _ARCH_MCI_H
#define _ARCH_MCI_H

/**
 * struct s3c24xx_mci_pdata - sd/mmc controller platform data
 * @no_wprotect: Set this to indicate there is no write-protect switch.
 * @no_detect: Set this if there is no detect switch.
 * @wprotect_invert: Invert the default sense of the write protect switch.
 * @detect_invert: Invert the default sense of the write protect switch.
 * @use_dma: Set to allow the use of DMA.
 * @gpio_detect: GPIO number for the card detect line.
 * @gpio_wprotect: GPIO number for the write protect line.
 * @ocr_avail: The mask of the available power states, non-zero to use.
 * @set_power: Callback to control the power mode.
 *
 * The @gpio_detect is used for card detection when @no_wprotect is unset,
 * and the default sense is that 0 returned from gpio_get_value() means
 * that a card is inserted. If @detect_invert is set, then the value from
 * gpio_get_value() is inverted, which makes 1 mean card inserted.
 *
 * The driver will use @gpio_wprotect to signal whether the card is write
 * protected if @no_wprotect is not set. A 0 returned from gpio_get_value()
 * means the card is read/write, and 1 means read-only. The @wprotect_invert
 * will invert the value returned from gpio_get_value().
 *
 * Card power is set by @ocr_availa, using MCC_VDD_ constants if it is set
 * to a non-zero value, otherwise the default of 3.2-3.4V is used.
 */
struct s3c24xx_mci_pdata {
	unsigned int	no_wprotect:1;
	unsigned int	no_detect:1;
	unsigned int	wprotect_invert:1;
	unsigned int	detect_invert:1;	/* set => detect active high */
	unsigned int	use_dma:1;

	unsigned int	gpio_detect;
	unsigned int	gpio_wprotect;
	unsigned long	ocr_avail;
	void		(*set_power)(unsigned char power_mode,
				     unsigned short vdd);
};

/**
 * s3c24xx_mci_set_platdata - set platform data for mmc/sdi device
 * @pdata: The platform data
 *
 * Copy the platform data supplied by @pdata so that this can be marked
 * __initdata.
 */
extern void s3c24xx_mci_set_platdata(struct s3c24xx_mci_pdata *pdata);

#endif /* _ARCH_NCI_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**
 * omap-twl4030.h - ASoC machine driver for TI SoC based boards with twl4030
 *		    codec, header.
 *
 * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */

#ifndef _OMAP_TWL4030_H_
#define _OMAP_TWL4030_H_

/* To select if only one channel is connected in a stereo port */
#define OMAP_TWL4030_LEFT	(1 << 0)
#define OMAP_TWL4030_RIGHT	(1 << 1)

struct omap_tw4030_pdata {
	const char *card_name;
	/* Voice port is connected to McBSP3 */
	bool voice_connected;

	/* The driver will parse the connection flags if this flag is set */
	bool	custom_routing;
	/* Flags to indicate connected audio ports. */
	u8	has_hs;
	u8	has_hf;
	u8	has_predriv;
	u8	has_carkit;
	bool	has_ear;

	bool	has_mainmic;
	bool	has_submic;
	bool	has_hsmic;
	bool	has_carkitmic;
	bool	has_digimic0;
	bool	has_digimic1;
	u8	has_linein;

	/* Jack detect GPIO or  <= 0 if it is not implemented */
	int jack_detect;
};

#endif /* _OMAP_TWL4030_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Driver for Texas Instruments INA219, INA226 power monitor chips
 *
 * Copyright (C) 2012 Lothar Felten <l-felten@ti.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * For further information, see the Documentation/hwmon/ina2xx file.
 */

/**
 * struct ina2xx_platform_data - ina2xx info
 * @shunt_uohms		shunt resistance in microohms
 */
struct ina2xx_platform_data {
	long shunt_uohms;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef PLATFORM_DATA_SYSCON_H
#define PLATFORM_DATA_SYSCON_H

struct syscon_platform_data {
	const char *label;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * Copyright (C) 2014 Sensirion AG, Switzerland
 * Author: Johannes Winkelmann <johannes.winkelmann@sensirion.com>
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#ifndef __SHTC1_H_
#define __SHTC1_H_

struct shtc1_platform_data {
	bool blocking_io;
	bool high_precision;
};
#endif /* __SHTC1_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * Copyright (C) 2011-2013 Renesas Electronics Corporation
 * Copyright (C) 2013 Cogent Embedded, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * as published by the Free Software Foundation.
 */

#ifndef __DMA_RCAR_HPBDMA_H
#define __DMA_RCAR_HPBDMA_H

#include <linux/bitops.h>
#include <linux/types.h>

/* Transmit sizes and respective register values */
enum {
	XMIT_SZ_8BIT	= 0,
	XMIT_SZ_16BIT	= 1,
	XMIT_SZ_32BIT	= 2,
	XMIT_SZ_MAX
};

/* DMA control register (DCR) bits */
#define HPB_DMAE_DCR_DTAMD		(1u << 26)
#define HPB_DMAE_DCR_DTAC		(1u << 25)
#define HPB_DMAE_DCR_DTAU		(1u << 24)
#define HPB_DMAE_DCR_DTAU1		(1u << 23)
#define HPB_DMAE_DCR_SWMD		(1u << 22)
#define HPB_DMAE_DCR_BTMD		(1u << 21)
#define HPB_DMAE_DCR_PKMD		(1u << 20)
#define HPB_DMAE_DCR_CT			(1u << 18)
#define HPB_DMAE_DCR_ACMD		(1u << 17)
#define HPB_DMAE_DCR_DIP		(1u << 16)
#define HPB_DMAE_DCR_SMDL		(1u << 13)
#define HPB_DMAE_DCR_SPDAM		(1u << 12)
#define HPB_DMAE_DCR_SDRMD_MASK		(3u << 10)
#define HPB_DMAE_DCR_SDRMD_MOD		(0u << 10)
#define HPB_DMAE_DCR_SDRMD_AUTO		(1u << 10)
#define HPB_DMAE_DCR_SDRMD_TIMER	(2u << 10)
#define HPB_DMAE_DCR_SPDS_MASK		(3u << 8)
#define HPB_DMAE_DCR_SPDS_8BIT		(0u << 8)
#define HPB_DMAE_DCR_SPDS_16BIT		(1u << 8)
#define HPB_DMAE_DCR_SPDS_32BIT		(2u << 8)
#define HPB_DMAE_DCR_DMDL		(1u << 5)
#define HPB_DMAE_DCR_DPDAM		(1u << 4)
#define HPB_DMAE_DCR_DDRMD_MASK		(3u << 2)
#define HPB_DMAE_DCR_DDRMD_MOD		(0u << 2)
#define HPB_DMAE_DCR_DDRMD_AUTO		(1u << 2)
#define HPB_DMAE_DCR_DDRMD_TIMER	(2u << 2)
#define HPB_DMAE_DCR_DPDS_MASK		(3u << 0)
#define HPB_DMAE_DCR_DPDS_8BIT		(0u << 0)
#define HPB_DMAE_DCR_DPDS_16BIT		(1u << 0)
#define HPB_DMAE_DCR_DPDS_32BIT		(2u << 0)

/* Asynchronous reset register (ASYNCRSTR) bits */
#define HPB_DMAE_ASYNCRSTR_ASRST41	BIT(10)
#define HPB_DMAE_ASYNCRSTR_ASRST40	BIT(9)
#define HPB_DMAE_ASYNCRSTR_ASRST39	BIT(8)
#define HPB_DMAE_ASYNCRSTR_ASRST27	BIT(7)
#define HPB_DMAE_ASYNCRSTR_ASRST26	BIT(6)
#define HPB_DMAE_ASYNCRSTR_ASRST25	BIT(5)
#define HPB_DMAE_ASYNCRSTR_ASRST24	BIT(4)
#define HPB_DMAE_ASYNCRSTR_ASRST23	BIT(3)
#define HPB_DMAE_ASYNCRSTR_ASRST22	BIT(2)
#define HPB_DMAE_ASYNCRSTR_ASRST21	BIT(1)
#define HPB_DMAE_ASYNCRSTR_ASRST20	BIT(0)

struct hpb_dmae_slave_config {
	unsigned int	id;
	dma_addr_t	addr;
	u32		dcr;
	u32		port;
	u32		rstr;
	u32		mdr;
	u32		mdm;
	u32		flags;
#define	HPB_DMAE_SET_ASYNC_RESET	BIT(0)
#define	HPB_DMAE_SET_ASYNC_MODE		BIT(1)
	u32		dma_ch;
};

#define HPB_DMAE_CHANNEL(_irq, _s_id)	\
{					\
	.ch_irq		= _irq,		\
	.s_id		= _s_id,	\
}

struct hpb_dmae_channel {
	unsigned int	ch_irq;
	unsigned int	s_id;
};

struct hpb_dmae_pdata {
	const struct hpb_dmae_slave_config *slaves;
	int num_slaves;
	const struct hpb_dmae_channel *channels;
	int num_channels;
	const unsigned int ts_shift[XMIT_SZ_MAX];
	int num_hw_channels;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * bd6107.h - Rohm BD6107 LEDs Driver
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#ifndef __BD6107_H__
#define __BD6107_H__

struct device;

struct bd6107_platform_data {
	struct device *fbdev;
	int reset;			/* Reset GPIO */
	unsigned int def_value;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * Renesas IRQC Driver
 *
 *  Copyright (C) 2013 Magnus Damm
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef __IRQ_RENESAS_IRQC_H__
#define __IRQ_RENESAS_IRQC_H__

struct renesas_irqc_config {
	unsigned int irq_base;
};

#endif /* __IRQ_RENESAS_IRQC_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef _LINUX_PCA953X_H
#define _LINUX_PCA953X_H

#include <linux/types.h>
#include <linux/i2c.h>

/* platform data for the PCA9539 16-bit I/O expander driver */

struct pca953x_platform_data {
	/* number of the first GPIO */
	unsigned	gpio_base;

	/* initial polarity inversion setting */
	u32		invert;

	/* interrupt base */
	int		irq_base;

	void		*context;	/* param to setup/teardown */

	int		(*setup)(struct i2c_client *client,
				unsigned gpio, unsigned ngpio,
				void *context);
	int		(*teardown)(struct i2c_client *client,
				unsigned gpio, unsigned ngpio,
				void *context);
	const char	*const *names;
};

#endif /* _LINUX_PCA953X_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef __PLATFORM_DATA_ASOC_MX27VIS_H
#define __PLATFORM_DATA_ASOC_MX27VIS_H

struct snd_mx27vis_platform_data {
	int amp_gain0_gpio;
	int amp_gain1_gpio;
	int amp_mutel_gpio;
	int amp_muter_gpio;
};

#endif /* __PLATFORM_DATA_ASOC_MX27VIS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /* drivers/input/touchscreen/zforce.c
 *
 * Copyright (C) 2012-2013 MundoReader S.L.
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#ifndef _LINUX_INPUT_ZFORCE_TS_H
#define _LINUX_INPUT_ZFORCE_TS_H

struct zforce_ts_platdata {
	int gpio_int;
	int gpio_rst;

	unsigned int x_max;
	unsigned int y_max;
};

#endif /* _LINUX_INPUT_ZFORCE_TS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * MMC definitions for OMAP2
 *
 * Copyright (C) 2006 Nokia Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

/*
 * struct omap_hsmmc_dev_attr.flags possibilities
 *
 * OMAP_HSMMC_SUPPORTS_DUAL_VOLT: Some HSMMC controller instances can
 *    operate with either 1.8Vdc or 3.0Vdc card voltages; this flag
 *    should be set if this is the case.  See for example Section 22.5.3
 *    "MMC/SD/SDIO1 Bus Voltage Selection" of the OMAP34xx Multimedia
 *    Device Silicon Revision 3.1.x Revision ZR (July 2011) (SWPU223R).
 *
 * OMAP_HSMMC_BROKEN_MULTIBLOCK_READ: Multiple-block read transfers
 *    don't work correctly on some MMC controller instances on some
 *    OMAP3 SoCs; this flag should be set if this is the case.  See
 *    for example Advisory 2.1.1.128 "MMC: Multiple Block Read
 *    Operation Issue" in _OMAP3530/3525/3515/3503 Silicon Errata_
 *    Revision F (October 2010) (SPRZ278F).
 */
#define OMAP_HSMMC_SUPPORTS_DUAL_VOLT		BIT(0)
#define OMAP_HSMMC_BROKEN_MULTIBLOCK_READ	BIT(1)
#define OMAP_HSMMC_SWAKEUP_MISSING		BIT(2)

struct omap_hsmmc_dev_attr {
	u8 flags;
};

struct mmc_card;

struct omap_hsmmc_platform_data {
	/* back-link to device */
	struct device *dev;

	/* set if your board has components or wiring that limits the
	 * maximum frequency on the MMC bus */
	unsigned int max_freq;

	/* Integrating attributes from the omap_hwmod layer */
	u8 controller_flags;

	/* Register offset deviation */
	u16 reg_offset;

	/*
	 * 4/8 wires and any additional host capabilities
	 * need to OR'd all capabilities (ref. linux/mmc/host.h)
	 */
	u32 caps;	/* Used for the MMC driver on 2430 and later */
	u32 pm_caps;	/* PM capabilities of the mmc */

	/* use the internal clock */
	unsigned internal_clock:1;

	/* nonremovable e.g. eMMC */
	unsigned nonremovable:1;

	/* eMMC does not handle power off when not in sleep state */
	unsigned no_regulator_off_init:1;

	/* we can put the features above into this variable */
#define HSMMC_HAS_PBIAS		(1 << 0)
#define HSMMC_HAS_UPDATED_RESET	(1 << 1)
#define HSMMC_HAS_HSPE_SUPPORT	(1 << 2)
	unsigned features;

	int gpio_cd;			/* gpio (card detect) */
	int gpio_cod;			/* gpio (cover detect) */
	int gpio_wp;			/* gpio (write protect) */

	int (*set_power)(struct device *dev, int power_on, int vdd);
	void (*remux)(struct device *dev, int power_on);
	/* Call back before enabling / disabling regulators */
	void (*before_set_reg)(struct device *dev, int power_on, int vdd);
	/* Call back after enabling / disabling regulators */
	void (*after_set_reg)(struct device *dev, int power_on, int vdd);
	/* if we have special card, init it using this callback */
	void (*init_card)(struct mmc_card *card);

	const char *name;
	u32 ocr_mask;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * Driver for ADAU1761/ADAU1461/ADAU1761/ADAU1961/ADAU1781/ADAU1781 codecs
 *
 * Copyright 2011-2014 Analog Devices Inc.
 * Author: Lars-Peter Clausen <lars@metafoo.de>
 *
 * Licensed under the GPL-2 or later.
 */

#ifndef __LINUX_PLATFORM_DATA_ADAU17X1_H__
#define __LINUX_PLATFORM_DATA_ADAU17X1_H__

/**
 * enum adau17x1_micbias_voltage - Microphone bias voltage
 * @ADAU17X1_MICBIAS_0_90_AVDD: 0.9 * AVDD
 * @ADAU17X1_MICBIAS_0_65_AVDD: 0.65 * AVDD
 */
enum adau17x1_micbias_voltage {
	ADAU17X1_MICBIAS_0_90_AVDD = 0,
	ADAU17X1_MICBIAS_0_65_AVDD = 1,
};

/**
 * enum adau1761_digmic_jackdet_pin_mode - Configuration of the JACKDET/MICIN pin
 * @ADAU1761_DIGMIC_JACKDET_PIN_MODE_NONE: Disable the pin
 * @ADAU1761_DIGMIC_JACKDET_PIN_MODE_DIGMIC: Configure the pin for usage as
 *   digital microphone input.
 * @ADAU1761_DIGMIC_JACKDET_PIN_MODE_JACKDETECT: Configure the pin for jack
 *  insertion detection.
 */
enum adau1761_digmic_jackdet_pin_mode {
	ADAU1761_DIGMIC_JACKDET_PIN_MODE_NONE,
	ADAU1761_DIGMIC_JACKDET_PIN_MODE_DIGMIC,
	ADAU1761_DIGMIC_JACKDET_PIN_MODE_JACKDETECT,
};

/**
 * adau1761_jackdetect_debounce_time - Jack insertion detection debounce time
 * @ADAU1761_JACKDETECT_DEBOUNCE_5MS: 5 milliseconds
 * @ADAU1761_JACKDETECT_DEBOUNCE_10MS: 10 milliseconds
 * @ADAU1761_JACKDETECT_DEBOUNCE_20MS: 20 milliseconds
 * @ADAU1761_JACKDETECT_DEBOUNCE_40MS: 40 milliseconds
 */
enum adau1761_jackdetect_debounce_time {
	ADAU1761_JACKDETECT_DEBOUNCE_5MS = 0,
	ADAU1761_JACKDETECT_DEBOUNCE_10MS = 1,
	ADAU1761_JACKDETECT_DEBOUNCE_20MS = 2,
	ADAU1761_JACKDETECT_DEBOUNCE_40MS = 3,
};

/**
 * enum adau1761_output_mode - Output mode configuration
 * @ADAU1761_OUTPUT_MODE_HEADPHONE: Headphone output
 * @ADAU1761_OUTPUT_MODE_HEADPHONE_CAPLESS: Capless headphone output
 * @ADAU1761_OUTPUT_MODE_LINE: Line output
 */
enum adau1761_output_mode {
	ADAU1761_OUTPUT_MODE_HEADPHONE,
	ADAU1761_OUTPUT_MODE_HEADPHONE_CAPLESS,
	ADAU1761_OUTPUT_MODE_LINE,
};

/**
 * struct adau1761_platform_data - ADAU1761 Codec driver platform data
 * @input_differential: If true the input pins will be configured in
 *  differential mode.
 * @lineout_mode: Output mode for the LOUT/ROUT pins
 * @headphone_mode: Output mode for the LHP/RHP pins
 * @digmic_jackdetect_pin_mode: JACKDET/MICIN pin configuration
 * @jackdetect_debounce_time: Jack insertion detection debounce time.
 *  Note: This value will only be used, if the JACKDET/MICIN pin is configured
 *  for jack insertion detection.
 * @jackdetect_active_low: If true the jack insertion detection is active low.
 *  Othwise it will be active high.
 * @micbias_voltage: Microphone voltage bias
 */
struct adau1761_platform_data {
	bool input_differential;
	enum adau1761_output_mode lineout_mode;
	enum adau1761_output_mode headphone_mode;

	enum adau1761_digmic_jackdet_pin_mode digmic_jackdetect_pin_mode;

	enum adau1761_jackdetect_debounce_time jackdetect_debounce_time;
	bool jackdetect_active_low;

	enum adau17x1_micbias_voltage micbias_voltage;
};

/**
 * struct adau1781_platform_data - ADAU1781 Codec driver platform data
 * @left_input_differential: If true configure the left input as
 * differential input.
 * @right_input_differential: If true configure the right input as differntial
 *  input.
 * @use_dmic: If true configure the MIC pins as digital microphone pins instead
 *  of analog microphone pins.
 * @micbias_voltage: Microphone voltage bias
 */
struct adau1781_platform_data {
	bool left_input_differential;
	bool right_input_differential;

	bool use_dmic;

	enum adau17x1_micbias_voltage micbias_voltage;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Copyright (C) ST Ericsson SA 2011
 *
 * License Terms: GNU General Public License v2
 *
 * STE Ux500 Watchdog platform data
 */
#ifndef __UX500_WDT_H
#define __UX500_WDT_H

/**
 * struct ux500_wdt_data
 */
struct ux500_wdt_data {
	unsigned int timeout;
	bool has_28_bits_resolution;
};

#endif /* __UX500_WDT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #ifndef __KEYPAD_EP93XX_H
#define __KEYPAD_EP93XX_H

struct matrix_keymap_data;

/* flags for the ep93xx_keypad driver */
#define EP93XX_KEYPAD_DISABLE_3_KEY	(1<<0)	/* disable 3-key reset */
#define EP93XX_KEYPAD_DIAG_MODE		(1<<1)	/* diagnostic mode */
#define EP93XX_KEYPAD_BACK_DRIVE	(1<<2)	/* back driving mode */
#define EP93XX_KEYPAD_TEST_MODE		(1<<3)	/* scan only column 0 */
#define EP93XX_KEYPAD_KDIV		(1<<4)	/* 1/4 clock or 1/16 clock */
#define EP93XX_KEYPAD_AUTOREPEAT	(1<<5)	/* enable key autorepeat */

/**
 * struct ep93xx_keypad_platform_data - platform specific device structure
 * @keymap_data:	pointer to &matrix_keymap_data
 * @debounce:		debounce start count; terminal count is 0xff
 * @prescale:		row/column counter pre-scaler load value
 * @flags:		see above
 */
struct ep93xx_keypad_platform_data {
	struct matrix_keymap_data *keymap_data;
	unsigned int	debounce;
	unsigned int	prescale;
	unsigned int	flags;
};

#define EP93XX_MATRIX_ROWS		(8)
#define EP93XX_MATRIX_COLS		(8)

#endif	/* __KEYPAD_EP93XX_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * Copyright (C) ST-Ericsson SA 2007-2010
 * Author: Per Forlin <per.forlin@stericsson.com> for ST-Ericsson
 * Author: Jonas Aaberg <jonas.aberg@stericsson.com> for ST-Ericsson
 * License terms: GNU General Public License (GPL) version 2
 */


#ifndef STE_DMA40_H
#define STE_DMA40_H

#include <linux/dmaengine.h>
#include <linux/scatterlist.h>
#include <linux/workqueue.h>
#include <linux/interrupt.h>

/*
 * Maxium size for a single dma descriptor
 * Size is limited to 16 bits.
 * Size is in the units of addr-widths (1,2,4,8 bytes)
 * Larger transfers will be split up to multiple linked desc
 */
#define STEDMA40_MAX_SEG_SIZE 0xFFFF

/* dev types for memcpy */
#define STEDMA40_DEV_DST_MEMORY (-1)
#define	STEDMA40_DEV_SRC_MEMORY (-1)

enum stedma40_mode {
	STEDMA40_MODE_LOGICAL = 0,
	STEDMA40_MODE_PHYSICAL,
	STEDMA40_MODE_OPERATION,
};

enum stedma40_mode_opt {
	STEDMA40_PCHAN_BASIC_MODE = 0,
	STEDMA40_LCHAN_SRC_LOG_DST_LOG = 0,
	STEDMA40_PCHAN_MODULO_MODE,
	STEDMA40_PCHAN_DOUBLE_DST_MODE,
	STEDMA40_LCHAN_SRC_PHY_DST_LOG,
	STEDMA40_LCHAN_SRC_LOG_DST_PHY,
};

#define STEDMA40_ESIZE_8_BIT  0x0
#define STEDMA40_ESIZE_16_BIT 0x1
#define STEDMA40_ESIZE_32_BIT 0x2
#define STEDMA40_ESIZE_64_BIT 0x3

/* The value 4 indicates that PEN-reg shall be set to 0 */
#define STEDMA40_PSIZE_PHY_1  0x4
#define STEDMA40_PSIZE_PHY_2  0x0
#define STEDMA40_PSIZE_PHY_4  0x1
#define STEDMA40_PSIZE_PHY_8  0x2
#define STEDMA40_PSIZE_PHY_16 0x3

/*
 * The number of elements differ in logical and
 * physical mode
 */
#define STEDMA40_PSIZE_LOG_1  STEDMA40_PSIZE_PHY_2
#define STEDMA40_PSIZE_LOG_4  STEDMA40_PSIZE_PHY_4
#define STEDMA40_PSIZE_LOG_8  STEDMA40_PSIZE_PHY_8
#define STEDMA40_PSIZE_LOG_16 STEDMA40_PSIZE_PHY_16

/* Maximum number of possible physical channels */
#define STEDMA40_MAX_PHYS 32

enum stedma40_flow_ctrl {
	STEDMA40_NO_FLOW_CTRL,
	STEDMA40_FLOW_CTRL,
};

/**
 * struct stedma40_half_channel_info - dst/src channel configuration
 *
 * @big_endian: true if the src/dst should be read as big endian
 * @data_width: Data width of the src/dst hardware
 * @p_size: Burst size
 * @flow_ctrl: Flow control on/off.
 */
struct stedma40_half_channel_info {
	bool big_endian;
	enum dma_slave_buswidth data_width;
	int psize;
	enum stedma40_flow_ctrl flow_ctrl;
};

/**
 * struct stedma40_chan_cfg - Structure to be filled by client drivers.
 *
 * @dir: MEM 2 MEM, PERIPH 2 MEM , MEM 2 PERIPH, PERIPH 2 PERIPH
 * @high_priority: true if high-priority
 * @realtime: true if realtime mode is to be enabled.  Only available on DMA40
 * version 3+, i.e DB8500v2+
 * @mode: channel mode: physical, logical, or operation
 * @mode_opt: options for the chosen channel mode
 * @dev_type: src/dst device type (driver uses dir to figure out which)
 * @src_info: Parameters for dst half channel
 * @dst_info: Parameters for dst half channel
 * @use_fixed_channel: if true, use physical channel specified by phy_channel
 * @phy_channel: physical channel to use, only if use_fixed_channel is true
 *
 * This structure has to be filled by the client drivers.
 * It is recommended to do all dma configurations for clients in the machine.
 *
 */
struct stedma40_chan_cfg {
	enum dma_transfer_direction		 dir;
	bool					 high_priority;
	bool					 realtime;
	enum stedma40_mode			 mode;
	enum stedma40_mode_opt			 mode_opt;
	int					 dev_type;
	struct stedma40_half_channel_info	 src_info;
	struct stedma40_half_channel_info	 dst_info;

	bool					 use_fixed_channel;
	int					 phy_channel;
};

/**
 * struct stedma40_platform_data - Configuration struct for the dma device.
 *
 * @dev_tx: mapping between destination event line and io address
 * @dev_rx: mapping between source event line and io address
 * @disabled_channels: A vector, ending with -1, that marks physical channels
 * that are for different reasons not available for the driver.
 * @soft_lli_chans: A vector, that marks physical channels will use LLI by SW
 * which avoids HW bug that exists in some versions of the controller.
 * SoftLLI introduces relink overhead that could impact performace for
 * certain use cases.
 * @num_of_soft_lli_chans: The number of channels that needs to be configured
 * to use SoftLLI.
 * @use_esram_lcla: flag for mapping the lcla into esram region
 * @num_of_memcpy_chans: The number of channels reserved for memcpy.
 * @num_of_phy_chans: The number of physical channels implemented in HW.
 * 0 means reading the number of channels from DMA HW but this is only valid
 * for 'multiple of 4' channels, like 8.
 */
struct stedma40_platform_data {
	int				 disabled_channels[STEDMA40_MAX_PHYS];
	int				*soft_lli_chans;
	int				 num_of_soft_lli_chans;
	bool				 use_esram_lcla;
	int				 num_of_memcpy_chans;
	int				 num_of_phy_chans;
};

#ifdef CONFIG_STE_DMA40

/**
 * stedma40_filter() - Provides stedma40_chan_cfg to the
 * ste_dma40 dma driver via the dmaengine framework.
 * does some checking of what's provided.
 *
 * Never directly called by client. It used by dmaengine.
 * @chan: dmaengine handle.
 * @data: Must be of type: struct stedma40_chan_cfg and is
 * the configuration of the framework.
 *
 *
 */

bool stedma40_filter(struct dma_chan *chan, void *data);

/**
 * stedma40_slave_mem() - Transfers a raw data buffer to or from a slave
 * (=device)
 *
 * @chan: dmaengine handle
 * @addr: source or destination physicall address.
 * @size: bytes to transfer
 * @direction: direction of transfer
 * @flags: is actually enum dma_ctrl_flags. See dmaengine.h
 */

static inline struct
dma_async_tx_descriptor *stedma40_slave_mem(struct dma_chan *chan,
					    dma_addr_t addr,
					    unsigned int size,
					    enum dma_transfer_direction direction,
					    unsigned long flags)
{
	struct scatterlist sg;
	sg_init_table(&sg, 1);
	sg.dma_address = addr;
	sg.length = size;

	return dmaengine_prep_slave_sg(chan, &sg, 1, direction, flags);
}

#else
static inline bool stedma40_filter(struct dma_chan *chan, void *data)
{
	return false;
}

static inline struct
dma_async_tx_descriptor *stedma40_slave_mem(struct dma_chan *chan,
					    dma_addr_t addr,
					    unsigned int size,
					    enum dma_transfer_direction direction,
					    unsigned long flags)
{
	return NULL;
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * Generic platform data for the NXP NCI NFC chips.
 *
 * Copyright (C) 2014  NXP Semiconductors  All rights reserved.
 *
 * Authors: Clment Perrochaud <clement.perrochaud@nxp.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */

#ifndef _NXP_NCI_H_
#define _NXP_NCI_H_

struct nxp_nci_nfc_platform_data {
	unsigned int gpio_en;
	unsigned int gpio_fw;
	unsigned int irq;
};

#endif /* _NXP_NCI_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #ifndef __MACH_MXC_SDMA_H__
#define __MACH_MXC_SDMA_H__

/**
 * struct sdma_script_start_addrs - SDMA script start pointers
 *
 * start addresses of the different functions in the physical
 * address space of the SDMA engine.
 */
struct sdma_script_start_addrs {
	s32 ap_2_ap_addr;
	s32 ap_2_bp_addr;
	s32 ap_2_ap_fixed_addr;
	s32 bp_2_ap_addr;
	s32 loopback_on_dsp_side_addr;
	s32 mcu_interrupt_only_addr;
	s32 firi_2_per_addr;
	s32 firi_2_mcu_addr;
	s32 per_2_firi_addr;
	s32 mcu_2_firi_addr;
	s32 uart_2_per_addr;
	s32 uart_2_mcu_addr;
	s32 per_2_app_addr;
	s32 mcu_2_app_addr;
	s32 per_2_per_addr;
	s32 uartsh_2_per_addr;
	s32 uartsh_2_mcu_addr;
	s32 per_2_shp_addr;
	s32 mcu_2_shp_addr;
	s32 ata_2_mcu_addr;
	s32 mcu_2_ata_addr;
	s32 app_2_per_addr;
	s32 app_2_mcu_addr;
	s32 shp_2_per_addr;
	s32 shp_2_mcu_addr;
	s32 mshc_2_mcu_addr;
	s32 mcu_2_mshc_addr;
	s32 spdif_2_mcu_addr;
	s32 mcu_2_spdif_addr;
	s32 asrc_2_mcu_addr;
	s32 ext_mem_2_ipu_addr;
	s32 descrambler_addr;
	s32 dptc_dvfs_addr;
	s32 utra_addr;
	s32 ram_code_start_addr;
	/* End of v1 array */
	s32 mcu_2_ssish_addr;
	s32 ssish_2_mcu_addr;
	s32 hdmi_dma_addr;
	/* End of v2 array */
	s32 zcanfd_2_mcu_addr;
	s32 zqspi_2_mcu_addr;
	/* End of v3 array */
};

/**
 * struct sdma_platform_data - platform specific data for SDMA engine
 *
 * @fw_name		The firmware name
 * @script_addrs	SDMA scripts addresses in SDMA ROM
 */
struct sdma_platform_data {
	char *fw_name;
	struct sdma_script_start_addrs *script_addrs;
};

#endif /* __MACH_MXC_SDMA_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Platform data for DRV260X haptics driver family
 *
 * Author: Dan Murphy <dmurphy@ti.com>
 *
 * Copyright:   (C) 2014 Texas Instruments, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 */

#ifndef _LINUX_DRV260X_PDATA_H
#define _LINUX_DRV260X_PDATA_H

struct drv260x_platform_data {
	u32 library_selection;
	u32 mode;
	u32 vib_rated_voltage;
	u32 vib_overdrive_voltage;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * usb-omap.h - Platform data for the various OMAP USB IPs
 *
 * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com
 *
 * This software is distributed under the terms of the GNU General Public
 * License ("GPL") version 2, as published by the Free Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define OMAP3_HS_USB_PORTS	3

enum usbhs_omap_port_mode {
	OMAP_USBHS_PORT_MODE_UNUSED,
	OMAP_EHCI_PORT_MODE_PHY,
	OMAP_EHCI_PORT_MODE_TLL,
	OMAP_EHCI_PORT_MODE_HSIC,
	OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0,
	OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM,
	OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0,
	OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM,
	OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0,
	OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM,
	OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0,
	OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM,
	OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0,
	OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM
};

struct usbtll_omap_platform_data {
	enum usbhs_omap_port_mode		port_mode[OMAP3_HS_USB_PORTS];
};

struct ehci_hcd_omap_platform_data {
	enum usbhs_omap_port_mode	port_mode[OMAP3_HS_USB_PORTS];
	int				reset_gpio_port[OMAP3_HS_USB_PORTS];
	struct regulator		*regulator[OMAP3_HS_USB_PORTS];
	unsigned			phy_reset:1;
};

struct ohci_hcd_omap_platform_data {
	enum usbhs_omap_port_mode	port_mode[OMAP3_HS_USB_PORTS];
	unsigned			es2_compatibility:1;
};

struct usbhs_omap_platform_data {
	int				nports;
	enum usbhs_omap_port_mode	port_mode[OMAP3_HS_USB_PORTS];
	int				reset_gpio_port[OMAP3_HS_USB_PORTS];
	struct regulator		*regulator[OMAP3_HS_USB_PORTS];

	struct ehci_hcd_omap_platform_data	*ehci_data;
	struct ohci_hcd_omap_platform_data	*ohci_data;

	/* OMAP3 <= ES2.1 have a single ulpi bypass control bit */
	unsigned single_ulpi_bypass:1;
	unsigned es2_compatibility:1;
	unsigned phy_reset:1;
};

/*-------------------------------------------------------------------------*/

struct omap_musb_board_data {
	u8	interface_type;
	u8	mode;
	u16	power;
	unsigned extvbus:1;
	void	(*set_phy_power)(u8 on);
	void	(*clear_irq)(void);
	void	(*set_mode)(u8 mode);
	void	(*reset)(void);
};

enum musb_interface {
	MUSB_INTERFACE_ULPI,
	MUSB_INTERFACE_UTMI
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * OMAP2+ WDTIMER-specific function prototypes
 *
 * Copyright (C) 2012 Texas Instruments, Inc.
 * Paul Walmsley
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef __LINUX_PLATFORM_DATA_OMAP_WD_TIMER_H
#define __LINUX_PLATFORM_DATA_OMAP_WD_TIMER_H

#include <linux/types.h>

/*
 * Standardized OMAP reset source bits
 *
 * This is a subset of the ones listed in arch/arm/mach-omap2/prm.h
 * and are the only ones needed in the watchdog driver.
 */
#define OMAP_MPU_WD_RST_SRC_ID_SHIFT				3

/**
 * struct omap_wd_timer_platform_data - WDTIMER integration to the host SoC
 * @read_reset_sources - fn ptr for the SoC to indicate the last reset cause
 *
 * The function pointed to by @read_reset_sources must return its data
 * in a standard format - search for RST_SRC_ID_SHIFT in
 * arch/arm/mach-omap2
 */
struct omap_wd_timer_platform_data {
	u32 (*read_reset_sources)(void);
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 *  Copyright (C) 2010 Broadcom
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef _PLAT_BCM2708_DMA_H
#define _PLAT_BCM2708_DMA_H

/* DMA CS Control and Status bits */
#define BCM2708_DMA_ACTIVE	BIT(0)
#define BCM2708_DMA_INT		BIT(2)
#define BCM2708_DMA_ISPAUSED	BIT(4)  /* Pause requested or not active */
#define BCM2708_DMA_ISHELD	BIT(5)  /* Is held by DREQ flow control */
#define BCM2708_DMA_ERR		BIT(8)
#define BCM2708_DMA_ABORT	BIT(30) /* stop current CB, go to next, WO */
#define BCM2708_DMA_RESET	BIT(31) /* WO, self clearing */

/* DMA control block "info" field bits */
#define BCM2708_DMA_INT_EN	BIT(0)
#define BCM2708_DMA_TDMODE	BIT(1)
#define BCM2708_DMA_WAIT_RESP	BIT(3)
#define BCM2708_DMA_D_INC	BIT(4)
#define BCM2708_DMA_D_WIDTH	BIT(5)
#define BCM2708_DMA_D_DREQ	BIT(6)
#define BCM2708_DMA_S_INC	BIT(8)
#define BCM2708_DMA_S_WIDTH	BIT(9)
#define BCM2708_DMA_S_DREQ	BIT(10)

#define	BCM2708_DMA_BURST(x)	(((x) & 0xf) << 12)
#define	BCM2708_DMA_PER_MAP(x)	((x) << 16)
#define	BCM2708_DMA_WAITS(x)	(((x) & 0x1f) << 21)

#define BCM2708_DMA_DREQ_EMMC	11
#define BCM2708_DMA_DREQ_SDHOST	13

#define BCM2708_DMA_CS		0x00 /* Control and Status */
#define BCM2708_DMA_ADDR	0x04
/* the current control block appears in the following registers - read only */
#define BCM2708_DMA_INFO	0x08
#define BCM2708_DMA_SOURCE_AD	0x0c
#define BCM2708_DMA_DEST_AD	0x10
#define BCM2708_DMA_NEXTCB	0x1C
#define BCM2708_DMA_DEBUG	0x20

#define BCM2708_DMA4_CS		(BCM2708_DMA_CHAN(4) + BCM2708_DMA_CS)
#define BCM2708_DMA4_ADDR	(BCM2708_DMA_CHAN(4) + BCM2708_DMA_ADDR)

#define BCM2708_DMA_TDMODE_LEN(w, h) ((h) << 16 | (w))

/* When listing features we can ask for when allocating DMA channels give
   those with higher priority smaller ordinal numbers */
#define BCM_DMA_FEATURE_FAST_ORD	0
#define BCM_DMA_FEATURE_BULK_ORD	1
#define BCM_DMA_FEATURE_NORMAL_ORD	2
#define BCM_DMA_FEATURE_LITE_ORD	3
#define BCM_DMA_FEATURE_FAST		BIT(BCM_DMA_FEATURE_FAST_ORD)
#define BCM_DMA_FEATURE_BULK		BIT(BCM_DMA_FEATURE_BULK_ORD)
#define BCM_DMA_FEATURE_NORMAL		BIT(BCM_DMA_FEATURE_NORMAL_ORD)
#define BCM_DMA_FEATURE_LITE		BIT(BCM_DMA_FEATURE_LITE_ORD)
#define BCM_DMA_FEATURE_COUNT		4

struct bcm2708_dma_cb {
	unsigned long info;
	unsigned long src;
	unsigned long dst;
	unsigned long length;
	unsigned long stride;
	unsigned long next;
	unsigned long pad[2];
};

struct scatterlist;

#ifdef CONFIG_DMA_BCM2708_LEGACY

int bcm_sg_suitable_for_dma(struct scatterlist *sg_ptr, int sg_len);
void bcm_dma_start(void __iomem *dma_chan_base, dma_addr_t control_block);
void bcm_dma_wait_idle(void __iomem *dma_chan_base);
bool bcm_dma_is_busy(void __iomem *dma_chan_base);
int bcm_dma_abort(void __iomem *dma_chan_base);

/* return channel no or -ve error */
int bcm_dma_chan_alloc(unsigned preferred_feature_set,
		       void __iomem **out_dma_base, int *out_dma_irq);
int bcm_dma_chan_free(int channel);

#else /* CONFIG_DMA_BCM2708_LEGACY */

static inline int bcm_sg_suitable_for_dma(struct scatterlist *sg_ptr,
					  int sg_len)
{
	return 0;
}

static inline void bcm_dma_start(void __iomem *dma_chan_base,
				 dma_addr_t control_block) { }

static inline void bcm_dma_wait_idle(void __iomem *dma_chan_base) { }

static inline bool bcm_dma_is_busy(void __iomem *dma_chan_base)
{
	return false;
}

static inline int bcm_dma_abort(void __iomem *dma_chan_base)
{
	return -EINVAL;
}

static inline int bcm_dma_chan_alloc(unsigned preferred_feature_set,
				     void __iomem **out_dma_base,
				     int *out_dma_irq)
{
	return -EINVAL;
}

static inline int bcm_dma_chan_free(int channel)
{
	return -EINVAL;
}

#endif /* CONFIG_DMA_BCM2708_LEGACY */

#endif /* _PLAT_BCM2708_DMA_H */
                                                                                                                                                                                                                                                                                  #ifndef __LINUX_CRYPTO_ATMEL_H
#define __LINUX_CRYPTO_ATMEL_H

#include <linux/platform_data/dma-atmel.h>

/**
 * struct crypto_dma_data - DMA data for AES/TDES/SHA
 */
struct crypto_dma_data {
	struct at_dma_slave	txdata;
	struct at_dma_slave	rxdata;
};

/**
 * struct crypto_platform_data - board-specific AES/TDES/SHA configuration
 * @dma_slave: DMA slave interface to use in data transfers.
 */
struct crypto_platform_data {
	struct crypto_dma_data	*dma_slave;
};

#endif /* __LINUX_CRYPTO_ATMEL_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * i2c.h - i.MX I2C driver header file
 *
 * Copyright (c) 2008, Darius Augulis <augulis.darius@gmail.com>
 *
 * This file is released under the GPLv2
 */

#ifndef __ASM_ARCH_I2C_H_
#define __ASM_ARCH_I2C_H_

/**
 * struct imxi2c_platform_data - structure of platform data for MXC I2C driver
 * @bitrate:	Bus speed measured in Hz
 *
 **/
struct imxi2c_platform_data {
	u32 bitrate;
};

#endif /* __ASM_ARCH_I2C_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * i2c-cbus-gpio.h - CBUS I2C platform_data definition
 *
 * Copyright (C) 2004-2009 Nokia Corporation
 *
 * Written by Felipe Balbi and Aaro Koskinen.
 *
 * This file is subject to the terms and conditions of the GNU General
 * Public License. See the file "COPYING" in the main directory of this
 * archive for more details.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */

#ifndef __INCLUDE_LINUX_I2C_CBUS_GPIO_H
#define __INCLUDE_LINUX_I2C_CBUS_GPIO_H

struct i2c_cbus_platform_data {
	int dat_gpio;
	int clk_gpio;
	int sel_gpio;
};

#endif /* __INCLUDE_LINUX_I2C_CBUS_GPIO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * omap iommu: main structures
 *
 * Copyright (C) 2008-2009 Nokia Corporation
 *
 * Written by Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <linux/platform_device.h>

#define MMU_REG_SIZE		256

/**
 * struct iommu_arch_data - omap iommu private data
 * @name: name of the iommu device
 * @iommu_dev: handle of the iommu device
 *
 * This is an omap iommu private data object, which binds an iommu user
 * to its iommu device. This object should be placed at the iommu user's
 * dev_archdata so generic IOMMU API can be used without having to
 * utilize omap-specific plumbing anymore.
 */
struct omap_iommu_arch_data {
	const char *name;
	struct omap_iommu *iommu_dev;
};

/**
 * struct omap_mmu_dev_attr - OMAP mmu device attributes for omap_hwmod
 * @nr_tlb_entries:	number of entries supported by the translation
 *			look-aside buffer (TLB).
 */
struct omap_mmu_dev_attr {
	int nr_tlb_entries;
};

struct iommu_platform_data {
	const char *name;
	const char *reset_name;
	int nr_tlb_entries;

	int (*assert_reset)(struct platform_device *pdev, const char *name);
	int (*deassert_reset)(struct platform_device *pdev, const char *name);
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#ifndef ASMARM_ARCH_UART_H
#define ASMARM_ARCH_UART_H

#define IMXUART_HAVE_RTSCTS (1<<0)

struct imxuart_platform_data {
	unsigned int flags;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * include/linux/platform_data/uio_pruss.h
 *
 * Platform data for uio_pruss driver
 *
 * Copyright (C) 2010-11 Texas Instruments Incorporated - http://www.ti.com/
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation version 2.
 *
 * This program is distributed "as is" WITHOUT ANY WARRANTY of any
 * kind, whether express or implied; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#ifndef _UIO_PRUSS_H_
#define _UIO_PRUSS_H_

/* To configure the PRUSS INTC base offset for UIO driver */
struct uio_pruss_pdata {
	u32		pintc_base;
	struct gen_pool *sram_pool;
};
#endif /* _UIO_PRUSS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * irq:		optional wake-up interrupt
 * rearm:	optional soc specific rearm function
 *
 * Note that the irq and rearm setup should come from device
 * tree except for omap where there are still some dependencies
 * to the legacy PRM code.
 */
struct pcs_pdata {
	int irq;
	void (*rearm)(void);
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * Copyright 2009 Texas Instruments.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef __ARCH_ARM_DAVINCI_SPI_H
#define __ARCH_ARM_DAVINCI_SPI_H

#include <linux/platform_data/edma.h>

#define SPI_INTERN_CS	0xFF

enum {
	SPI_VERSION_1, /* For DM355/DM365/DM6467 */
	SPI_VERSION_2, /* For DA8xx */
};

/**
 * davinci_spi_platform_data - Platform data for SPI master device on DaVinci
 *
 * @version:	version of the SPI IP. Different DaVinci devices have slightly
 *		varying versions of the same IP.
 * @num_chipselect: number of chipselects supported by this SPI master
 * @intr_line:	interrupt line used to connect the SPI IP to the ARM interrupt
 *		controller withn the SoC. Possible values are 0 and 1.
 * @chip_sel:	list of GPIOs which can act as chip-selects for the SPI.
 *		SPI_INTERN_CS denotes internal SPI chip-select. Not necessary
 *		to populate if all chip-selects are internal.
 * @cshold_bug:	set this to true if the SPI controller on your chip requires
 *		a write to CSHOLD bit in between transfers (like in DM355).
 * @dma_event_q: DMA event queue to use if SPI_IO_TYPE_DMA is used for any
 *		device on the bus.
 */
struct davinci_spi_platform_data {
	u8			version;
	u8			num_chipselect;
	u8			intr_line;
	u8			*chip_sel;
	bool			cshold_bug;
	enum dma_event_q	dma_event_q;
};

/**
 * davinci_spi_config - Per-chip-select configuration for SPI slave devices
 *
 * @wdelay:	amount of delay between transmissions. Measured in number of
 *		SPI module clocks.
 * @odd_parity:	polarity of parity flag at the end of transmit data stream.
 *		0 - odd parity, 1 - even parity.
 * @parity_enable: enable transmission of parity at end of each transmit
 *		data stream.
 * @io_type:	type of IO transfer. Choose between polled, interrupt and DMA.
 * @timer_disable: disable chip-select timers (setup and hold)
 * @c2tdelay:	chip-select setup time. Measured in number of SPI module clocks.
 * @t2cdelay:	chip-select hold time. Measured in number of SPI module clocks.
 * @t2edelay:	transmit data finished to SPI ENAn pin inactive time. Measured
 *		in number of SPI clocks.
 * @c2edelay:	chip-select active to SPI ENAn signal active time. Measured in
 *		number of SPI clocks.
 */
struct davinci_spi_config {
	u8	wdelay;
	u8	odd_parity;
	u8	parity_enable;
#define SPI_IO_TYPE_INTR	0
#define SPI_IO_TYPE_POLL	1
#define SPI_IO_TYPE_DMA		2
	u8	io_type;
	u8	timer_disable;
	u8	c2tdelay;
	u8	t2cdelay;
	u8	t2edelay;
	u8	c2edelay;
};

#endif	/* __ARCH_ARM_DAVINCI_SPI_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
 * Copyright 2008 Sascha Hauer, kernel@pengutronix.de
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#ifndef __ASM_ARCH_NAND_H
#define __ASM_ARCH_NAND_H

#include <linux/mtd/partitions.h>

struct mxc_nand_platform_data {
	unsigned int width;	/* data bus width in bytes */
	unsigned int hw_ecc:1;	/* 0 if suppress hardware ECC */
	unsigned int flash_bbt:1; /* set to 1 to use a flash based bbt */
	struct mtd_partition *parts;	/* partition table */
	int nr_parts;			/* size of parts */
};
#endif /* __ASM_ARCH_NAND_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * USB related definitions
 *
 * Copyright (C) 2009 MontaVista Software, Inc. <source@mvista.com>
 *
 * This file is licensed under the terms of the GNU General Public License
 * version 2. This program is licensed "as is" without any warranty of any
 * kind, whether express or implied.
 */

#ifndef __ASM_ARCH_USB_H
#define __ASM_ARCH_USB_H

/* DA8xx CFGCHIP2 (USB 2.0 PHY Control) register bits */
#define CFGCHIP2_PHYCLKGD	(1 << 17)
#define CFGCHIP2_VBUSSENSE	(1 << 16)
#define CFGCHIP2_RESET		(1 << 15)
#define CFGCHIP2_OTGMODE	(3 << 13)
#define CFGCHIP2_NO_OVERRIDE	(0 << 13)
#define CFGCHIP2_FORCE_HOST	(1 << 13)
#define CFGCHIP2_FORCE_DEVICE 	(2 << 13)
#define CFGCHIP2_FORCE_HOST_VBUS_LOW (3 << 13)
#define CFGCHIP2_USB1PHYCLKMUX	(1 << 12)
#define CFGCHIP2_USB2PHYCLKMUX	(1 << 11)
#define CFGCHIP2_PHYPWRDN	(1 << 10)
#define CFGCHIP2_OTGPWRDN	(1 << 9)
#define CFGCHIP2_DATPOL 	(1 << 8)
#define CFGCHIP2_USB1SUSPENDM	(1 << 7)
#define CFGCHIP2_PHY_PLLON	(1 << 6)	/* override PLL suspend */
#define CFGCHIP2_SESENDEN	(1 << 5)	/* Vsess_end comparator */
#define CFGCHIP2_VBDTCTEN	(1 << 4)	/* Vbus comparator */
#define CFGCHIP2_REFFREQ	(0xf << 0)
#define CFGCHIP2_REFFREQ_12MHZ	(1 << 0)
#define CFGCHIP2_REFFREQ_24MHZ	(2 << 0)
#define CFGCHIP2_REFFREQ_48MHZ	(3 << 0)

struct	da8xx_ohci_root_hub;

typedef void (*da8xx_ocic_handler_t)(struct da8xx_ohci_root_hub *hub,
				     unsigned port);

/* Passed as the platform data to the OHCI driver */
struct	da8xx_ohci_root_hub {
	/* Switch the port power on/off */
	int	(*set_power)(unsigned port, int on);
	/* Read the port power status */
	int	(*get_power)(unsigned port);
	/* Read the port over-current indicator */
	int	(*get_oci)(unsigned port);
	/* Over-current indicator change notification (pass NULL to disable) */
	int	(*ocic_notify)(da8xx_ocic_handler_t handler);

	/* Time from power on to power good (in 2 ms units) */
	u8	potpgt;
};

void davinci_setup_usb(unsigned mA, unsigned potpgt_ms);

#endif	/* ifndef __ASM_ARCH_USB_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #ifndef __PLATFORM_DATA_SDHCI_S3C_H
#define __PLATFORM_DATA_SDHCI_S3C_H

struct platform_device;

enum cd_types {
	S3C_SDHCI_CD_INTERNAL,	/* use mmc internal CD line */
	S3C_SDHCI_CD_EXTERNAL,	/* use external callback */
	S3C_SDHCI_CD_GPIO,	/* use external gpio pin for CD line */
	S3C_SDHCI_CD_NONE,	/* no CD line, use polling to detect card */
	S3C_SDHCI_CD_PERMANENT,	/* no CD line, card permanently wired to host */
};

/**
 * struct s3c_sdhci_platdata() - Platform device data for Samsung SDHCI
 * @max_width: The maximum number of data bits supported.
 * @host_caps: Standard MMC host capabilities bit field.
 * @host_caps2: The second standard MMC host capabilities bit field.
 * @cd_type: Type of Card Detection method (see cd_types enum above)
 * @ext_cd_init: Initialize external card detect subsystem. Called on
 *		 sdhci-s3c driver probe when cd_type == S3C_SDHCI_CD_EXTERNAL.
 *		 notify_func argument is a callback to the sdhci-s3c driver
 *		 that triggers the card detection event. Callback arguments:
 *		 dev is pointer to platform device of the host controller,
 *		 state is new state of the card (0 - removed, 1 - inserted).
 * @ext_cd_cleanup: Cleanup external card detect subsystem. Called on
 *		 sdhci-s3c driver remove when cd_type == S3C_SDHCI_CD_EXTERNAL.
 *		 notify_func argument is the same callback as for ext_cd_init.
 * @ext_cd_gpio: gpio pin used for external CD line, valid only if
 *		 cd_type == S3C_SDHCI_CD_GPIO
 * @ext_cd_gpio_invert: invert values for external CD gpio line
 * @cfg_gpio: Configure the GPIO for a specific card bit-width
 *
 * Initialisation data specific to either the machine or the platform
 * for the device driver to use or call-back when configuring gpio or
 * card speed information.
*/
struct s3c_sdhci_platdata {
	unsigned int	max_width;
	unsigned int	host_caps;
	unsigned int	host_caps2;
	unsigned int	pm_caps;
	enum cd_types	cd_type;

	int		ext_cd_gpio;
	bool		ext_cd_gpio_invert;
	int	(*ext_cd_init)(void (*notify_func)(struct platform_device *,
						   int state));
	int	(*ext_cd_cleanup)(void (*notify_func)(struct platform_device *,
						      int state));

	void	(*cfg_gpio)(struct platform_device *dev, int width);
};


#endif /* __PLATFORM_DATA_SDHCI_S3C_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * ntc_thermistor.h - NTC Thermistors
 *
 *  Copyright (C) 2010 Samsung Electronics
 *  MyungJoo Ham <myungjoo.ham@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#ifndef _LINUX_NTC_H
#define _LINUX_NTC_H

struct iio_channel;

enum ntc_thermistor_type {
	TYPE_NCPXXWB473,
	TYPE_NCPXXWL333,
	TYPE_B57330V2103,
};

struct ntc_thermistor_platform_data {
	/*
	 * One (not both) of read_uV and read_ohm should be provided and only
	 * one of the two should be provided.
	 * Both functions should return negative value for an error case.
	 *
	 * pullup_uV, pullup_ohm, pulldown_ohm, and connect are required to use
	 * read_uV()
	 *
	 * How to setup pullup_ohm, pulldown_ohm, and connect is
	 * described at Documentation/hwmon/ntc_thermistor
	 *
	 * pullup/down_ohm: 0 for infinite / not-connected
	 *
	 * chan: iio_channel pointer to communicate with the ADC which the
	 * thermistor is using for conversion of the analog values.
	 */
	int (*read_uv)(struct ntc_thermistor_platform_data *);
	unsigned int pullup_uv;

	unsigned int pullup_ohm;
	unsigned int pulldown_ohm;
	enum { NTC_CONNECTED_POSITIVE, NTC_CONNECTED_GROUND } connect;
	struct iio_channel *chan;

	int (*read_ohm)(void);
};

#endif /* _LINUX_NTC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * shmob_drm.h  --  SH Mobile DRM driver
 *
 * Copyright (C) 2012 Renesas Corporation
 *
 * Laurent Pinchart (laurent.pinchart@ideasonboard.com)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef __SHMOB_DRM_H__
#define __SHMOB_DRM_H__

#include <linux/kernel.h>

#include <drm/drm_mode.h>

struct sh_mobile_meram_cfg;
struct sh_mobile_meram_info;

enum shmob_drm_clk_source {
	SHMOB_DRM_CLK_BUS,
	SHMOB_DRM_CLK_PERIPHERAL,
	SHMOB_DRM_CLK_EXTERNAL,
};

enum shmob_drm_interface {
	SHMOB_DRM_IFACE_RGB8,		/* 24bpp, 8:8:8 */
	SHMOB_DRM_IFACE_RGB9,		/* 18bpp, 9:9 */
	SHMOB_DRM_IFACE_RGB12A,		/* 24bpp, 12:12 */
	SHMOB_DRM_IFACE_RGB12B,		/* 12bpp */
	SHMOB_DRM_IFACE_RGB16,		/* 16bpp */
	SHMOB_DRM_IFACE_RGB18,		/* 18bpp */
	SHMOB_DRM_IFACE_RGB24,		/* 24bpp */
	SHMOB_DRM_IFACE_YUV422,		/* 16bpp */
	SHMOB_DRM_IFACE_SYS8A,		/* 24bpp, 8:8:8 */
	SHMOB_DRM_IFACE_SYS8B,		/* 18bpp, 8:8:2 */
	SHMOB_DRM_IFACE_SYS8C,		/* 18bpp, 2:8:8 */
	SHMOB_DRM_IFACE_SYS8D,		/* 16bpp, 8:8 */
	SHMOB_DRM_IFACE_SYS9,		/* 18bpp, 9:9 */
	SHMOB_DRM_IFACE_SYS12,		/* 24bpp, 12:12 */
	SHMOB_DRM_IFACE_SYS16A,		/* 16bpp */
	SHMOB_DRM_IFACE_SYS16B,		/* 18bpp, 16:2 */
	SHMOB_DRM_IFACE_SYS16C,		/* 18bpp, 2:16 */
	SHMOB_DRM_IFACE_SYS18,		/* 18bpp */
	SHMOB_DRM_IFACE_SYS24,		/* 24bpp */
};

struct shmob_drm_backlight_data {
	const char *name;
	int max_brightness;
	int (*get_brightness)(void);
	int (*set_brightness)(int brightness);
};

struct shmob_drm_panel_data {
	unsigned int width_mm;		/* Panel width in mm */
	unsigned int height_mm;		/* Panel height in mm */
	struct drm_mode_modeinfo mode;
};

struct shmob_drm_sys_interface_data {
	unsigned int read_latch:6;
	unsigned int read_setup:8;
	unsigned int read_cycle:8;
	unsigned int read_strobe:8;
	unsigned int write_setup:8;
	unsigned int write_cycle:8;
	unsigned int write_strobe:8;
	unsigned int cs_setup:3;
	unsigned int vsync_active_high:1;
	unsigned int vsync_dir_input:1;
};

#define SHMOB_DRM_IFACE_FL_DWPOL (1 << 0) /* Rising edge dot clock data latch */
#define SHMOB_DRM_IFACE_FL_DIPOL (1 << 1) /* Active low display enable */
#define SHMOB_DRM_IFACE_FL_DAPOL (1 << 2) /* Active low display data */
#define SHMOB_DRM_IFACE_FL_HSCNT (1 << 3) /* Disable HSYNC during VBLANK */
#define SHMOB_DRM_IFACE_FL_DWCNT (1 << 4) /* Disable dotclock during blanking */

struct shmob_drm_interface_data {
	enum shmob_drm_interface interface;
	struct shmob_drm_sys_interface_data sys;
	unsigned int clk_div;
	unsigned int flags;
};

struct shmob_drm_platform_data {
	enum shmob_drm_clk_source clk_source;
	struct shmob_drm_interface_data iface;
	struct shmob_drm_panel_data panel;
	struct shmob_drm_backlight_data backlight;
	const struct sh_mobile_meram_cfg *meram;
};

#endif /* __SHMOB_DRM_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /* sh_ipmmu.h
 *
 * Copyright (C) 2012  Hideki EIRAKU
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 */

#ifndef __SH_IPMMU_H__
#define __SH_IPMMU_H__

struct shmobile_ipmmu_platform_data {
	const char * const *dev_names;
	unsigned int num_dev_names;
};

#endif /* __SH_IPMMU_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * This structure describes the machine which we are running on.
 */
#ifndef __MACH_IMXFB_H__
#define __MACH_IMXFB_H__

#include <linux/fb.h>

#define PCR_TFT		(1 << 31)
#define PCR_COLOR	(1 << 30)
#define PCR_PBSIZ_1	(0 << 28)
#define PCR_PBSIZ_2	(1 << 28)
#define PCR_PBSIZ_4	(2 << 28)
#define PCR_PBSIZ_8	(3 << 28)
#define PCR_BPIX_1	(0 << 25)
#define PCR_BPIX_2	(1 << 25)
#define PCR_BPIX_4	(2 << 25)
#define PCR_BPIX_8	(3 << 25)
#define PCR_BPIX_12	(4 << 25)
#define PCR_BPIX_16	(5 << 25)
#define PCR_BPIX_18	(6 << 25)
#define PCR_PIXPOL	(1 << 24)
#define PCR_FLMPOL	(1 << 23)
#define PCR_LPPOL	(1 << 22)
#define PCR_CLKPOL	(1 << 21)
#define PCR_OEPOL	(1 << 20)
#define PCR_SCLKIDLE	(1 << 19)
#define PCR_END_SEL	(1 << 18)
#define PCR_END_BYTE_SWAP (1 << 17)
#define PCR_REV_VS	(1 << 16)
#define PCR_ACD_SEL	(1 << 15)
#define PCR_ACD(x)	(((x) & 0x7f) << 8)
#define PCR_SCLK_SEL	(1 << 7)
#define PCR_SHARP	(1 << 6)
#define PCR_PCD(x)	((x) & 0x3f)

#define PWMR_CLS(x)	(((x) & 0x1ff) << 16)
#define PWMR_LDMSK	(1 << 15)
#define PWMR_SCR1	(1 << 10)
#define PWMR_SCR0	(1 << 9)
#define PWMR_CC_EN	(1 << 8)
#define PWMR_PW(x)	((x) & 0xff)

#define LSCR1_PS_RISE_DELAY(x)    (((x) & 0x7f) << 26)
#define LSCR1_CLS_RISE_DELAY(x)   (((x) & 0x3f) << 16)
#define LSCR1_REV_TOGGLE_DELAY(x) (((x) & 0xf) << 8)
#define LSCR1_GRAY2(x)            (((x) & 0xf) << 4)
#define LSCR1_GRAY1(x)            (((x) & 0xf))

#define DMACR_BURST	(1 << 31)
#define DMACR_HM(x)	(((x) & 0xf) << 16)
#define DMACR_TM(x)	((x) & 0xf)

struct imx_fb_videomode {
	struct fb_videomode mode;
	u32 pcr;
	unsigned char	bpp;
};

struct imx_fb_platform_data {
	struct imx_fb_videomode *mode;
	int		num_modes;

	u_int		pwmr;
	u_int		lscr1;
	u_int		dmacr;

	int (*init)(struct platform_device *);
	void (*exit)(struct platform_device *);
};

#endif /* ifndef __MACH_IMXFB_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * at24.h - platform_data for the at24 (generic eeprom) driver
 * (C) Copyright 2008 by Pengutronix
 * (C) Copyright 2012 by Wolfram Sang
 * same license as the driver
 */

#ifndef _LINUX_AT24_H
#define _LINUX_AT24_H

#include <linux/types.h>
#include <linux/memory.h>

/**
 * struct at24_platform_data - data to set up at24 (generic eeprom) driver
 * @byte_len: size of eeprom in byte
 * @page_size: number of byte which can be written in one go
 * @flags: tunable options, check AT24_FLAG_* defines
 * @setup: an optional callback invoked after eeprom is probed; enables kernel
	code to access eeprom via memory_accessor, see example
 * @context: optional parameter passed to setup()
 *
 * If you set up a custom eeprom type, please double-check the parameters.
 * Especially page_size needs extra care, as you risk data loss if your value
 * is bigger than what the chip actually supports!
 *
 * An example in pseudo code for a setup() callback:
 *
 * void get_mac_addr(struct memory_accessor *mem_acc, void *context)
 * {
 *	u8 *mac_addr = ethernet_pdata->mac_addr;
 *	off_t offset = context;
 *
 *	// Read MAC addr from EEPROM
 *	if (mem_acc->read(mem_acc, mac_addr, offset, ETH_ALEN) == ETH_ALEN)
 *		pr_info("Read MAC addr from EEPROM: %pM\n", mac_addr);
 * }
 *
 * This function pointer and context can now be set up in at24_platform_data.
 */

struct at24_platform_data {
	u32		byte_len;		/* size (sum of all addr) */
	u16		page_size;		/* for writes */
	u8		flags;
#define AT24_FLAG_ADDR16	0x80	/* address pointer is 16 bit */
#define AT24_FLAG_READONLY	0x40	/* sysfs-entry will be read-only */
#define AT24_FLAG_IRUGO		0x20	/* sysfs-entry will be world-readable */
#define AT24_FLAG_TAKE8ADDR	0x10	/* take always 8 addresses (24c00) */

	void		(*setup)(struct memory_accessor *, void *context);
	void		*context;
};

#endif /* _LINUX_AT24_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * max6697.h
 *     Copyright (c) 2012 Guenter Roeck <linux@roeck-us.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef MAX6697_H
#define MAX6697_H

#include <linux/types.h>

/*
 * For all bit masks:
 * bit 0:    local temperature
 * bit 1..7: remote temperatures
 */
struct max6697_platform_data {
	bool smbus_timeout_disable;	/* set to disable SMBus timeouts */
	bool extended_range_enable;	/* set to enable extended temp range */
	bool beta_compensation;		/* set to enable beta compensation */
	u8 alert_mask;			/* set bit to 1 to disable alert */
	u8 over_temperature_mask;	/* set bit to 1 to disable */
	u8 resistance_cancellation;	/* set bit to 0 to disable
					 * bit mask for MAX6581,
					 * boolean for other chips
					 */
	u8 ideality_mask;		/* set bit to 0 to disable */
	u8 ideality_value;		/* transistor ideality as per
					 * MAX6581 datasheet
					 */
};

#endif /* MAX6697_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * Copyright (C) ST-Ericsson SA 2010
 *
 * License Terms: GNU General Public License v2
 * Author: Naveen Kumar Gaddipati <naveen.gaddipati@stericsson.com>
 *
 * ux500 Scroll key and Keypad Encoder (SKE) header
 */

#ifndef __SKE_H
#define __SKE_H

#include <linux/input/matrix_keypad.h>

/* register definitions for SKE peripheral */
#define SKE_CR		0x00
#define SKE_VAL0	0x04
#define SKE_VAL1	0x08
#define SKE_DBCR	0x0C
#define SKE_IMSC	0x10
#define SKE_RIS		0x14
#define SKE_MIS		0x18
#define SKE_ICR		0x1C

/*
 * Keypad module
 */

/**
 * struct keypad_platform_data - structure for platform specific data
 * @init:	pointer to keypad init function
 * @exit:	pointer to keypad deinitialisation function
 * @keymap_data: matrix scan code table for keycodes
 * @krow:	maximum number of rows
 * @kcol:	maximum number of columns
 * @debounce_ms: platform specific debounce time
 * @no_autorepeat: flag for auto repetition
 * @wakeup_enable: allow waking up the system
 */
struct ske_keypad_platform_data {
	int (*init)(void);
	int (*exit)(void);
	const struct matrix_keymap_data *keymap_data;
	u8 krow;
	u8 kcol;
	u8 debounce_ms;
	bool no_autorepeat;
	bool wakeup_enable;
};
#endif	/*__SKE_KPD_H*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * Copyright (c) 2009 Nuvoton technology corporation.
 *
 * Wan ZongShun <mcuos.com@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation;version 2 of the License.
 *
 */

#ifndef __SPI_NUC900_H
#define __SPI_NUC900_H

extern void mfp_set_groupg(struct device *dev, const char *subname);

struct nuc900_spi_info {
	unsigned int num_cs;
	unsigned int lsb;
	unsigned int txneg;
	unsigned int rxneg;
	unsigned int divider;
	unsigned int sleep;
	unsigned int txnum;
	unsigned int txbitlen;
	int bus_num;
};

struct nuc900_spi_chip {
	unsigned char bits_per_word;
};

#endif /* __SPI_NUC900_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * Clock definitions for ux500 platforms
 *
 * Copyright (C) 2012 ST-Ericsson SA
 * Author: Ulf Hansson <ulf.hansson@linaro.org>
 *
 * License terms: GNU General Public License (GPL) version 2
 */

#ifndef __CLK_UX500_H
#define __CLK_UX500_H

void u8500_of_clk_init(u32 clkrst1_base, u32 clkrst2_base, u32 clkrst3_base,
		       u32 clkrst5_base, u32 clkrst6_base);

void u8500_clk_init(u32 clkrst1_base, u32 clkrst2_base, u32 clkrst3_base,
		    u32 clkrst5_base, u32 clkrst6_base);
void u9540_clk_init(u32 clkrst1_base, u32 clkrst2_base, u32 clkrst3_base,
		    u32 clkrst5_base, u32 clkrst6_base);
void u8540_clk_init(u32 clkrst1_base, u32 clkrst2_base, u32 clkrst3_base,
		    u32 clkrst5_base, u32 clkrst6_base);

#endif /* __CLK_UX500_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Analog Devices AD7303 DAC driver
 *
 * Copyright 2013 Analog Devices Inc.
 *
 * Licensed under the GPL-2.
 */

#ifndef __IIO_ADC_AD7303_H__
#define __IIO_ADC_AD7303_H__

/**
 * struct ad7303_platform_data - AD7303 platform data
 * @use_external_ref: If set to true use an external voltage reference connected
 * to the REF pin, otherwise use the internal reference derived from Vdd.
 */
struct ad7303_platform_data {
	bool use_external_ref;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      void realview_clk_init(void __iomem *sysbase, bool is_pb1176);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 *  TI EDMA definitions
 *
 *  Copyright (C) 2006-2013 Texas Instruments.
 *
 *  This program is free software; you can redistribute  it and/or modify it
 *  under  the terms of  the GNU General  Public License as published by the
 *  Free Software Foundation;  either version 2 of the  License, or (at your
 *  option) any later version.
 */

/*
 * This EDMA3 programming framework exposes two basic kinds of resource:
 *
 *  Channel	Triggers transfers, usually from a hardware event but
 *		also manually or by "chaining" from DMA completions.
 *		Each channel is coupled to a Parameter RAM (PaRAM) slot.
 *
 *  Slot	Each PaRAM slot holds a DMA transfer descriptor (PaRAM
 *		"set"), source and destination addresses, a link to a
 *		next PaRAM slot (if any), options for the transfer, and
 *		instructions for updating those addresses.  There are
 *		more than twice as many slots as event channels.
 *
 * Each PaRAM set describes a sequence of transfers, either for one large
 * buffer or for several discontiguous smaller buffers.  An EDMA transfer
 * is driven only from a channel, which performs the transfers specified
 * in its PaRAM slot until there are no more transfers.  When that last
 * transfer completes, the "link" field may be used to reload the channel's
 * PaRAM slot with a new transfer descriptor.
 *
 * The EDMA Channel Controller (CC) maps requests from channels into physical
 * Transfer Controller (TC) requests when the channel triggers (by hardware
 * or software events, or by chaining).  The two physical DMA channels provided
 * by the TCs are thus shared by many logical channels.
 *
 * DaVinci hardware also has a "QDMA" mechanism which is not currently
 * supported through this interface.  (DSP firmware uses it though.)
 */

#ifndef EDMA_H_
#define EDMA_H_

/* PaRAM slots are laid out like this */
struct edmacc_param {
	u32 opt;
	u32 src;
	u32 a_b_cnt;
	u32 dst;
	u32 src_dst_bidx;
	u32 link_bcntrld;
	u32 src_dst_cidx;
	u32 ccnt;
} __packed;

/* fields in edmacc_param.opt */
#define SAM		BIT(0)
#define DAM		BIT(1)
#define SYNCDIM		BIT(2)
#define STATIC		BIT(3)
#define EDMA_FWID	(0x07 << 8)
#define TCCMODE		BIT(11)
#define EDMA_TCC(t)	((t) << 12)
#define TCINTEN		BIT(20)
#define ITCINTEN	BIT(21)
#define TCCHEN		BIT(22)
#define ITCCHEN		BIT(23)

/*ch_status paramater of callback function possible values*/
#define EDMA_DMA_COMPLETE 1
#define EDMA_DMA_CC_ERROR 2
#define EDMA_DMA_TC1_ERROR 3
#define EDMA_DMA_TC2_ERROR 4

enum address_mode {
	INCR = 0,
	FIFO = 1
};

enum fifo_width {
	W8BIT = 0,
	W16BIT = 1,
	W32BIT = 2,
	W64BIT = 3,
	W128BIT = 4,
	W256BIT = 5
};

enum dma_event_q {
	EVENTQ_0 = 0,
	EVENTQ_1 = 1,
	EVENTQ_2 = 2,
	EVENTQ_3 = 3,
	EVENTQ_DEFAULT = -1
};

enum sync_dimension {
	ASYNC = 0,
	ABSYNC = 1
};

#define EDMA_CTLR_CHAN(ctlr, chan)	(((ctlr) << 16) | (chan))
#define EDMA_CTLR(i)			((i) >> 16)
#define EDMA_CHAN_SLOT(i)		((i) & 0xffff)

#define EDMA_CHANNEL_ANY		-1	/* for edma_alloc_channel() */
#define EDMA_SLOT_ANY			-1	/* for edma_alloc_slot() */
#define EDMA_CONT_PARAMS_ANY		 1001
#define EDMA_CONT_PARAMS_FIXED_EXACT	 1002
#define EDMA_CONT_PARAMS_FIXED_NOT_EXACT 1003

#define EDMA_MAX_CC               2

/* alloc/free DMA channels and their dedicated parameter RAM slots */
int edma_alloc_channel(int channel,
	void (*callback)(unsigned channel, u16 ch_status, void *data),
	void *data, enum dma_event_q);
void edma_free_channel(unsigned channel);

/* alloc/free parameter RAM slots */
int edma_alloc_slot(unsigned ctlr, int slot);
void edma_free_slot(unsigned slot);

/* alloc/free a set of contiguous parameter RAM slots */
int edma_alloc_cont_slots(unsigned ctlr, unsigned int id, int slot, int count);
int edma_free_cont_slots(unsigned slot, int count);

/* calls that operate on part of a parameter RAM slot */
void edma_set_src(unsigned slot, dma_addr_t src_port,
				enum address_mode mode, enum fifo_width);
void edma_set_dest(unsigned slot, dma_addr_t dest_port,
				 enum address_mode mode, enum fifo_width);
dma_addr_t edma_get_position(unsigned slot, bool dst);
void edma_set_src_index(unsigned slot, s16 src_bidx, s16 src_cidx);
void edma_set_dest_index(unsigned slot, s16 dest_bidx, s16 dest_cidx);
void edma_set_transfer_params(unsigned slot, u16 acnt, u16 bcnt, u16 ccnt,
		u16 bcnt_rld, enum sync_dimension sync_mode);
void edma_link(unsigned from, unsigned to);
void edma_unlink(unsigned from);

/* calls that operate on an entire parameter RAM slot */
void edma_write_slot(unsigned slot, const struct edmacc_param *params);
void edma_read_slot(unsigned slot, struct edmacc_param *params);

/* channel control operations */
int edma_start(unsigned channel);
void edma_stop(unsigned channel);
void edma_clean_channel(unsigned channel);
void edma_clear_event(unsigned channel);
void edma_pause(unsigned channel);
void edma_resume(unsigned channel);

void edma_assign_channel_eventq(unsigned channel, enum dma_event_q eventq_no);

struct edma_rsv_info {

	const s16	(*rsv_chans)[2];
	const s16	(*rsv_slots)[2];
};

/* platform_data for EDMA driver */
struct edma_soc_info {
	/*
	 * Default queue is expected to be a low-priority queue.
	 * This way, long transfers on the default queue started
	 * by the codec engine will not cause audio defects.
	 */
	enum dma_event_q	default_queue;

	/* Resource reservation for other cores */
	struct edma_rsv_info	*rsv;

	s8	(*queue_priority_mapping)[2];
	const s16	(*xbar_chans)[2];
};

int edma_trigger_channel(unsigned);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Driver include for the PN544 NFC chip.
 *
 * Copyright (C) Nokia Corporation
 *
 * Author: Jari Vanhala <ext-jari.vanhala@nokia.com>
 * Contact: Matti Aaltoenn <matti.j.aaltonen@nokia.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _PN544_H_
#define _PN544_H_

#include <linux/i2c.h>

enum {
	NFC_GPIO_ENABLE,
	NFC_GPIO_FW_RESET,
	NFC_GPIO_IRQ
};

/* board config */
struct pn544_nfc_platform_data {
	int (*request_resources) (struct i2c_client *client);
	void (*free_resources) (void);
	void (*enable) (int fw);
	int (*test) (void);
	void (*disable) (void);
	int (*get_gpio)(int type);
};

#endif /* _PN544_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * sky81452.h	SKY81452 backlight driver
 *
 * Copyright 2014 Skyworks Solutions Inc.
 * Author : Gyungoh Yoo <jack.yoo@skyworksinc.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _SKY81452_BACKLIGHT_H
#define _SKY81452_BACKLIGHT_H

/**
 * struct sky81452_platform_data
 * @name:	backlight driver name.
		If it is not defined, default name is lcd-backlight.
 * @gpio_enable:GPIO number which control EN pin
 * @enable:	Enable mask for current sink channel 1, 2, 3, 4, 5 and 6.
 * @ignore_pwm:	true if DPWMI should be ignored.
 * @dpwm_mode:	true is DPWM dimming mode, otherwise Analog dimming mode.
 * @phase_shift:true is phase shift mode.
 * @short_detecion_threshold:	It should be one of 4, 5, 6 and 7V.
 * @boost_current_limit:	It should be one of 2300, 2750mA.
 */
struct sky81452_bl_platform_data {
	const char *name;
	int gpio_enable;
	unsigned int enable;
	bool ignore_pwm;
	bool dpwm_mode;
	bool phase_shift;
	unsigned int short_detection_threshold;
	unsigned int boost_current_limit;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
* Copyright (C) 2012 Texas Instruments
*
* License Terms: GNU General Public License v2
*
* Simple driver for Texas Instruments LM3642 LED driver chip
*
* Author: G.Shark Jeong <gshark.jeong@gmail.com>
*         Daniel Jeong <daniel.jeong@ti.com>
*/

#ifndef __LINUX_LM3642_H
#define __LINUX_LM3642_H

#define LM3642_NAME "leds-lm3642"

enum lm3642_torch_pin_enable {
	LM3642_TORCH_PIN_DISABLE = 0x00,
	LM3642_TORCH_PIN_ENABLE = 0x10,
};

enum lm3642_strobe_pin_enable {
	LM3642_STROBE_PIN_DISABLE = 0x00,
	LM3642_STROBE_PIN_ENABLE = 0x20,
};

enum lm3642_tx_pin_enable {
	LM3642_TX_PIN_DISABLE = 0x00,
	LM3642_TX_PIN_ENABLE = 0x40,
};

struct lm3642_platform_data {
	enum lm3642_torch_pin_enable torch_pin;
	enum lm3642_strobe_pin_enable strobe_pin;
	enum lm3642_tx_pin_enable tx_pin;
};

#endif /* __LINUX_LM3642_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * This file is part of Nokia H4P bluetooth driver
 *
 * Copyright (C) 2010 Nokia Corporation.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */


/**
 * struct hci_h4p_platform data - hci_h4p Platform data structure
 */
struct hci_h4p_platform_data {
	int chip_type;
	int bt_sysclk;
	unsigned int bt_wakeup_gpio;
	unsigned int host_wakeup_gpio;
	unsigned int reset_gpio;
	int reset_gpio_shared;
	unsigned int uart_irq;
	phys_addr_t uart_base;
	const char *uart_iclk;
	const char *uart_fclk;
	void (*set_pm_limits)(struct device *dev, bool set);
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * board initialization should put one of these structures into platform_data
 * and place the bfin-rotary onto platform_bus named "bfin-rotary".
 *
 * Copyright 2008-2010 Analog Devices Inc.
 *
 * Licensed under the GPL-2 or later.
 */

#ifndef _BFIN_ROTARY_H
#define _BFIN_ROTARY_H

/* mode bitmasks */
#define ROT_QUAD_ENC	CNTMODE_QUADENC	/* quadrature/grey code encoder mode */
#define ROT_BIN_ENC	CNTMODE_BINENC	/* binary encoder mode */
#define ROT_UD_CNT	CNTMODE_UDCNT	/* rotary counter mode */
#define ROT_DIR_CNT	CNTMODE_DIRCNT	/* direction counter mode */

#define ROT_DEBE	DEBE		/* Debounce Enable */

#define ROT_CDGINV	CDGINV		/* CDG Pin Polarity Invert */
#define ROT_CUDINV	CUDINV		/* CUD Pin Polarity Invert */
#define ROT_CZMINV	CZMINV		/* CZM Pin Polarity Invert */

struct bfin_rotary_platform_data {
	/* set rotary UP KEY_### or BTN_### in case you prefer
	 * bfin-rotary to send EV_KEY otherwise set 0
	 */
	unsigned int rotary_up_key;
	/* set rotary DOWN KEY_### or BTN_### in case you prefer
	 * bfin-rotary to send EV_KEY otherwise set 0
	 */
	unsigned int rotary_down_key;
	/* set rotary BUTTON KEY_### or BTN_### */
	unsigned int rotary_button_key;
	/* set rotary Relative Axis REL_### in case you prefer
	 * bfin-rotary to send EV_REL otherwise set 0
	 */
	unsigned int rotary_rel_code;
	unsigned short debounce;	/* 0..17 */
	unsigned short mode;
	unsigned short pm_wakeup;
	unsigned short *pin_list;
};

/* CNT_CONFIG bitmasks */
#define CNTE		(1 << 0)	/* Counter Enable */
#define DEBE		(1 << 1)	/* Debounce Enable */
#define CDGINV		(1 << 4)	/* CDG Pin Polarity Invert */
#define CUDINV		(1 << 5)	/* CUD Pin Polarity Invert */
#define CZMINV		(1 << 6)	/* CZM Pin Polarity Invert */
#define CNTMODE_SHIFT	8
#define CNTMODE		(0x7 << CNTMODE_SHIFT)	/* Counter Operating Mode */
#define ZMZC		(1 << 1)	/* CZM Zeroes Counter Enable */
#define BNDMODE_SHIFT	12
#define BNDMODE		(0x3 << BNDMODE_SHIFT)	/* Boundary register Mode */
#define INPDIS		(1 << 15)	/* CUG and CDG Input Disable */

#define CNTMODE_QUADENC	(0 << CNTMODE_SHIFT)	/* quadrature encoder mode */
#define CNTMODE_BINENC	(1 << CNTMODE_SHIFT)	/* binary encoder mode */
#define CNTMODE_UDCNT	(2 << CNTMODE_SHIFT)	/* up/down counter mode */
#define CNTMODE_DIRCNT	(4 << CNTMODE_SHIFT)	/* direction counter mode */
#define CNTMODE_DIRTMR	(5 << CNTMODE_SHIFT)	/* direction timer mode */

#define BNDMODE_COMP	(0 << BNDMODE_SHIFT)	/* boundary compare mode */
#define BNDMODE_ZERO	(1 << BNDMODE_SHIFT)	/* boundary compare and zero mode */
#define BNDMODE_CAPT	(2 << BNDMODE_SHIFT)	/* boundary capture mode */
#define BNDMODE_AEXT	(3 << BNDMODE_SHIFT)	/* boundary auto-extend mode */

/* CNT_IMASK bitmasks */
#define ICIE		(1 << 0)	/* Illegal Gray/Binary Code Interrupt Enable */
#define UCIE		(1 << 1)	/* Up count Interrupt Enable */
#define DCIE		(1 << 2)	/* Down count Interrupt Enable */
#define MINCIE		(1 << 3)	/* Min Count Interrupt Enable */
#define MAXCIE		(1 << 4)	/* Max Count Interrupt Enable */
#define COV31IE		(1 << 5)	/* Bit 31 Overflow Interrupt Enable */
#define COV15IE		(1 << 6)	/* Bit 15 Overflow Interrupt Enable */
#define CZEROIE		(1 << 7)	/* Count to Zero Interrupt Enable */
#define CZMIE		(1 << 8)	/* CZM Pin Interrupt Enable */
#define CZMEIE		(1 << 9)	/* CZM Error Interrupt Enable */
#define CZMZIE		(1 << 10)	/* CZM Zeroes Counter Interrupt Enable */

/* CNT_STATUS bitmasks */
#define ICII		(1 << 0)	/* Illegal Gray/Binary Code Interrupt Identifier */
#define UCII		(1 << 1)	/* Up count Interrupt Identifier */
#define DCII		(1 << 2)	/* Down count Interrupt Identifier */
#define MINCII		(1 << 3)	/* Min Count Interrupt Identifier */
#define MAXCII		(1 << 4)	/* Max Count Interrupt Identifier */
#define COV31II		(1 << 5)	/* Bit 31 Overflow Interrupt Identifier */
#define COV15II		(1 << 6)	/* Bit 15 Overflow Interrupt Identifier */
#define CZEROII		(1 << 7)	/* Count to Zero Interrupt Identifier */
#define CZMII		(1 << 8)	/* CZM Pin Interrupt Identifier */
#define CZMEII		(1 << 9)	/* CZM Error Interrupt Identifier */
#define CZMZII		(1 << 10)	/* CZM Zeroes Counter Interrupt Identifier */

/* CNT_COMMAND bitmasks */
#define W1LCNT		0xf		/* Load Counter Register */
#define W1LMIN		0xf0		/* Load Min Register */
#define W1LMAX		0xf00		/* Load Max Register */
#define W1ZMONCE	(1 << 12)	/* Enable CZM Clear Counter Once */

#define W1LCNT_ZERO	(1 << 0)	/* write 1 to load CNT_COUNTER with zero */
#define W1LCNT_MIN	(1 << 2)	/* write 1 to load CNT_COUNTER from CNT_MIN */
#define W1LCNT_MAX	(1 << 3)	/* write 1 to load CNT_COUNTER from CNT_MAX */

#define W1LMIN_ZERO	(1 << 4)	/* write 1 to load CNT_MIN with zero */
#define W1LMIN_CNT	(1 << 5)	/* write 1 to load CNT_MIN from CNT_COUNTER */
#define W1LMIN_MAX	(1 << 7)	/* write 1 to load CNT_MIN from CNT_MAX */

#define W1LMAX_ZERO	(1 << 8)	/* write 1 to load CNT_MAX with zero */
#define W1LMAX_CNT	(1 << 9)	/* write 1 to load CNT_MAX from CNT_COUNTER */
#define W1LMAX_MIN	(1 << 10)	/* write 1 to load CNT_MAX from CNT_MIN */

/* CNT_DEBOUNCE bitmasks */
#define DPRESCALE	0xf		/* Load Counter Register */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * AD5415, AD5426, AD5429, AD5432, AD5439, AD5443, AD5449 Digital to Analog
 * Converter driver.
 *
 * Copyright 2012 Analog Devices Inc.
 *  Author: Lars-Peter Clausen <lars@metafoo.de>
 *
 * Licensed under the GPL-2.
 */

#ifndef __LINUX_PLATFORM_DATA_AD5449_H__
#define __LINUX_PLATFORM_DATA_AD5449_H__

/**
 * enum ad5449_sdo_mode - AD5449 SDO pin configuration
 * @AD5449_SDO_DRIVE_FULL: Drive the SDO pin with full strength.
 * @AD5449_SDO_DRIVE_WEAK: Drive the SDO pin with not full strength.
 * @AD5449_SDO_OPEN_DRAIN: Operate the SDO pin in open-drain mode.
 * @AD5449_SDO_DISABLED: Disable the SDO pin, in this mode it is not possible to
 *			read back from the device.
 */
enum ad5449_sdo_mode {
	AD5449_SDO_DRIVE_FULL = 0x0,
	AD5449_SDO_DRIVE_WEAK = 0x1,
	AD5449_SDO_OPEN_DRAIN = 0x2,
	AD5449_SDO_DISABLED = 0x3,
};

/**
 * struct ad5449_platform_data - Platform data for the ad5449 DAC driver
 * @sdo_mode: SDO pin mode
 * @hardware_clear_to_midscale: Whether asserting the hardware CLR pin sets the
 *			outputs to midscale (true) or to zero scale(false).
 */
struct ad5449_platform_data {
	enum ad5449_sdo_mode sdo_mode;
	bool hardware_clear_to_midscale;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * This file is licensed under the terms of the GNU General Public
 * License version 2.  This program is licensed "as is" without any
 * warranty of any kind, whether express or implied.
 */

#ifndef __USB_EHCI_ORION_H
#define __USB_EHCI_ORION_H

#include <linux/mbus.h>

enum orion_ehci_phy_ver {
	EHCI_PHY_ORION,
	EHCI_PHY_DD,
	EHCI_PHY_KW,
	EHCI_PHY_NA,
};

struct orion_ehci_data {
	enum orion_ehci_phy_ver phy_version;
};


#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * Defines for Multi-Channel Buffered Serial Port
 *
 * Copyright (C) 2002 RidgeRun, Inc.
 * Author: Steve Johnson
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
#ifndef __ASOC_TI_MCBSP_H
#define __ASOC_TI_MCBSP_H

#include <linux/spinlock.h>
#include <linux/clk.h>

#define MCBSP_CONFIG_TYPE2	0x2
#define MCBSP_CONFIG_TYPE3	0x3
#define MCBSP_CONFIG_TYPE4	0x4

/* Platform specific configuration */
struct omap_mcbsp_ops {
	void (*request)(unsigned int);
	void (*free)(unsigned int);
};

struct omap_mcbsp_platform_data {
	struct omap_mcbsp_ops *ops;
	u16 buffer_size;
	u8 reg_size;
	u8 reg_step;

	/* McBSP platform and instance specific features */
	bool has_wakeup; /* Wakeup capability */
	bool has_ccr; /* Transceiver has configuration control registers */
	int (*enable_st_clock)(unsigned int, bool);
};

/**
 * omap_mcbsp_dev_attr - OMAP McBSP device attributes for omap_hwmod
 * @sidetone: name of the sidetone device
 */
struct omap_mcbsp_dev_attr {
	const char *sidetone;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * Copyright (C) 2010 ST Microelectronics
 * Rajeev Kumar<rajeev-dlh.kumar@st.com>
 *
 * This file is licensed under the terms of the GNU General Public
 * License version 2. This program is licensed "as is" without any
 * warranty of any kind, whether express or implied.
 */

#ifndef __PLAT_KEYBOARD_H
#define __PLAT_KEYBOARD_H

#include <linux/bitops.h>
#include <linux/input.h>
#include <linux/input/matrix_keypad.h>
#include <linux/types.h>

#define DECLARE_9x9_KEYMAP(_name) \
int _name[] = { \
	KEY(0, 0, KEY_ESC), \
	KEY(0, 1, KEY_1), \
	KEY(0, 2, KEY_2), \
	KEY(0, 3, KEY_3), \
	KEY(0, 4, KEY_4), \
	KEY(0, 5, KEY_5), \
	KEY(0, 6, KEY_6), \
	KEY(0, 7, KEY_7), \
	KEY(0, 8, KEY_8), \
	KEY(1, 0, KEY_9), \
	KEY(1, 1, KEY_MINUS), \
	KEY(1, 2, KEY_EQUAL), \
	KEY(1, 3, KEY_BACKSPACE), \
	KEY(1, 4, KEY_TAB), \
	KEY(1, 5, KEY_Q), \
	KEY(1, 6, KEY_W), \
	KEY(1, 7, KEY_E), \
	KEY(1, 8, KEY_R), \
	KEY(2, 0, KEY_T), \
	KEY(2, 1, KEY_Y), \
	KEY(2, 2, KEY_U), \
	KEY(2, 3, KEY_I), \
	KEY(2, 4, KEY_O), \
	KEY(2, 5, KEY_P), \
	KEY(2, 6, KEY_LEFTBRACE), \
	KEY(2, 7, KEY_RIGHTBRACE), \
	KEY(2, 8, KEY_ENTER), \
	KEY(3, 0, KEY_LEFTCTRL), \
	KEY(3, 1, KEY_A), \
	KEY(3, 2, KEY_S), \
	KEY(3, 3, KEY_D), \
	KEY(3, 4, KEY_F), \
	KEY(3, 5, KEY_G), \
	KEY(3, 6, KEY_H), \
	KEY(3, 7, KEY_J), \
	KEY(3, 8, KEY_K), \
	KEY(4, 0, KEY_L), \
	KEY(4, 1, KEY_SEMICOLON), \
	KEY(4, 2, KEY_APOSTROPHE), \
	KEY(4, 3, KEY_GRAVE), \
	KEY(4, 4, KEY_LEFTSHIFT), \
	KEY(4, 5, KEY_BACKSLASH), \
	KEY(4, 6, KEY_Z), \
	KEY(4, 7, KEY_X), \
	KEY(4, 8, KEY_C), \
	KEY(5, 0, KEY_V), \
	KEY(5, 1, KEY_B), \
	KEY(5, 2, KEY_N), \
	KEY(5, 3, KEY_M), \
	KEY(5, 4, KEY_COMMA), \
	KEY(5, 5, KEY_DOT), \
	KEY(5, 6, KEY_SLASH), \
	KEY(5, 7, KEY_RIGHTSHIFT), \
	KEY(5, 8, KEY_KPASTERISK), \
	KEY(6, 0, KEY_LEFTALT), \
	KEY(6, 1, KEY_SPACE), \
	KEY(6, 2, KEY_CAPSLOCK), \
	KEY(6, 3, KEY_F1), \
	KEY(6, 4, KEY_F2), \
	KEY(6, 5, KEY_F3), \
	KEY(6, 6, KEY_F4), \
	KEY(6, 7, KEY_F5), \
	KEY(6, 8, KEY_F6), \
	KEY(7, 0, KEY_F7), \
	KEY(7, 1, KEY_F8), \
	KEY(7, 2, KEY_F9), \
	KEY(7, 3, KEY_F10), \
	KEY(7, 4, KEY_NUMLOCK), \
	KEY(7, 5, KEY_SCROLLLOCK), \
	KEY(7, 6, KEY_KP7), \
	KEY(7, 7, KEY_KP8), \
	KEY(7, 8, KEY_KP9), \
	KEY(8, 0, KEY_KPMINUS), \
	KEY(8, 1, KEY_KP4), \
	KEY(8, 2, KEY_KP5), \
	KEY(8, 3, KEY_KP6), \
	KEY(8, 4, KEY_KPPLUS), \
	KEY(8, 5, KEY_KP1), \
	KEY(8, 6, KEY_KP2), \
	KEY(8, 7, KEY_KP3), \
	KEY(8, 8, KEY_KP0), \
}

#define DECLARE_6x6_KEYMAP(_name) \
int _name[] = { \
	KEY(0, 0, KEY_RESERVED), \
	KEY(0, 1, KEY_1), \
	KEY(0, 2, KEY_2), \
	KEY(0, 3, KEY_3), \
	KEY(0, 4, KEY_4), \
	KEY(0, 5, KEY_5), \
	KEY(1, 0, KEY_Q), \
	KEY(1, 1, KEY_W), \
	KEY(1, 2, KEY_E), \
	KEY(1, 3, KEY_R), \
	KEY(1, 4, KEY_T), \
	KEY(1, 5, KEY_Y), \
	KEY(2, 0, KEY_D), \
	KEY(2, 1, KEY_F), \
	KEY(2, 2, KEY_G), \
	KEY(2, 3, KEY_H), \
	KEY(2, 4, KEY_J), \
	KEY(2, 5, KEY_K), \
	KEY(3, 0, KEY_B), \
	KEY(3, 1, KEY_N), \
	KEY(3, 2, KEY_M), \
	KEY(3, 3, KEY_COMMA), \
	KEY(3, 4, KEY_DOT), \
	KEY(3, 5, KEY_SLASH), \
	KEY(4, 0, KEY_F6), \
	KEY(4, 1, KEY_F7), \
	KEY(4, 2, KEY_F8), \
	KEY(4, 3, KEY_F9), \
	KEY(4, 4, KEY_F10), \
	KEY(4, 5, KEY_NUMLOCK), \
	KEY(5, 0, KEY_KP2), \
	KEY(5, 1, KEY_KP3), \
	KEY(5, 2, KEY_KP0), \
	KEY(5, 3, KEY_KPDOT), \
	KEY(5, 4, KEY_RO), \
	KEY(5, 5, KEY_ZENKAKUHANKAKU), \
}

#define KEYPAD_9x9     0
#define KEYPAD_6x6     1
#define KEYPAD_2x2     2

/**
 * struct kbd_platform_data - spear keyboard platform data
 * keymap: pointer to keymap data (table and size)
 * rep: enables key autorepeat
 * mode: choose keyboard support(9x9, 6x6, 2x2)
 * suspended_rate: rate at which keyboard would operate in suspended mode
 *
 * This structure is supposed to be used by platform code to supply
 * keymaps to drivers that implement keyboards.
 */
struct kbd_platform_data {
	const struct matrix_keymap_data *keymap;
	bool rep;
	unsigned int mode;
	unsigned int suspended_rate;
};

#endif /* __PLAT_KEYBOARD_H */
                                                                                                                                                                                                            /*
 * Copyright(c) 2014 Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */

#ifndef GPIO_DW_APB_H
#define GPIO_DW_APB_H

struct dwapb_port_property {
	struct device_node *node;
	const char	*name;
	unsigned int	idx;
	unsigned int	ngpio;
	unsigned int	gpio_base;
	unsigned int	irq;
	bool		irq_shared;
};

struct dwapb_platform_data {
	struct dwapb_port_property *properties;
	unsigned int nports;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Driver include for the PN544 NFC chip.
 *
 * Copyright (C) 2011 Tieto Poland
 * Copyright (C) 2012 Intel Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#ifndef _MICROREAD_H
#define _MICROREAD_H

#include <linux/i2c.h>

#define MICROREAD_DRIVER_NAME	"microread"

/* board config platform data for microread */
struct microread_nfc_platform_data {
	unsigned int rst_gpio;
	unsigned int irq_gpio;
	unsigned int ioh_gpio;
};

#endif /* _MICROREAD_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Copyright (c) 2014 Samsung Electronics Co., Ltd.
 *              http://www.samsung.com
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

#ifndef __CPUIDLE_EXYNOS_H
#define __CPUIDLE_EXYNOS_H

struct cpuidle_exynos_data {
	int (*cpu0_enter_aftr)(void);
	int (*cpu1_powerdown)(void);
	void (*pre_enter_aftr)(void);
	void (*post_enter_aftr)(void);
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Platform data for NXP SC18IS602/603
 *
 * Copyright (C) 2012 Guenter Roeck <linux@roeck-us.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * For further information, see the Documentation/spi/sc18is602 file.
 */

/**
 * struct sc18is602_platform_data - sc18is602 info
 * @clock_frequency		SC18IS603 oscillator frequency
 */
struct sc18is602_platform_data {
	u32 clock_frequency;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Platform data for OMAP1 USB
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License. See the file "COPYING" in the main directory of this archive for
 * more details.
 */
#ifndef __LINUX_USB_OMAP1_H
#define __LINUX_USB_OMAP1_H

#include <linux/platform_device.h>

struct omap_usb_config {
	/* Configure drivers according to the connectors on your board:
	 *  - "A" connector (rectagular)
	 *	... for host/OHCI use, set "register_host".
	 *  - "B" connector (squarish) or "Mini-B"
	 *	... for device/gadget use, set "register_dev".
	 *  - "Mini-AB" connector (very similar to Mini-B)
	 *	... for OTG use as device OR host, initialize "otg"
	 */
	unsigned	register_host:1;
	unsigned	register_dev:1;
	u8		otg;	/* port number, 1-based:  usb1 == 2 */

	const char	*extcon;	/* extcon device for OTG */

	u8		hmc_mode;

	/* implicitly true if otg:  host supports remote wakeup? */
	u8		rwc;

	/* signaling pins used to talk to transceiver on usbN:
	 *  0 == usbN unused
	 *  2 == usb0-only, using internal transceiver
	 *  3 == 3 wire bidirectional
	 *  4 == 4 wire bidirectional
	 *  6 == 6 wire unidirectional (or TLL)
	 */
	u8		pins[3];

	struct platform_device *udc_device;
	struct platform_device *ohci_device;
	struct platform_device *otg_device;

	u32 (*usb0_init)(unsigned nwires, unsigned is_device);
	u32 (*usb1_init)(unsigned nwires);
	u32 (*usb2_init)(unsigned nwires, unsigned alt_pingroup);

	int (*ocpi_enable)(void);
};

#endif /* __LINUX_USB_OMAP1_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #ifndef __ASM_MACH_EP93XX_SPI_H
#define __ASM_MACH_EP93XX_SPI_H

struct spi_device;

/**
 * struct ep93xx_spi_info - EP93xx specific SPI descriptor
 * @num_chipselect: number of chip selects on this board, must be
 *                  at least one
 * @use_dma: use DMA for the transfers
 */
struct ep93xx_spi_info {
	int	num_chipselect;
	bool	use_dma;
};

/**
 * struct ep93xx_spi_chip_ops - operation callbacks for SPI slave device
 * @setup: setup the chip select mechanism
 * @cleanup: cleanup the chip select mechanism
 * @cs_control: control the device chip select
 */
struct ep93xx_spi_chip_ops {
	int	(*setup)(struct spi_device *spi);
	void	(*cleanup)(struct spi_device *spi);
	void	(*cs_control)(struct spi_device *spi, int value);
};

#endif /* __ASM_MACH_EP93XX_SPI_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * Copyright (C) 2013 Renesas Solutions Corp.
 * Copyright (C) 2013 Cogent Embedded, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef __USB_RCAR_PHY_H
#define __USB_RCAR_PHY_H

#include <linux/types.h>

struct rcar_phy_platform_data {
	bool ferrite_bead:1;	/* (R8A7778 only)			*/

	bool port1_func:1;	/* true: port 1 used by function, false: host */
	unsigned penc1:1;	/* Output of the PENC1 pin in function mode */
	struct {		/* Overcurrent pin control for ports 0..2 */
		bool select_3_3v:1; /* true: USB_OVCn pin, false: OVCn pin */
				/* Set to false on port 1 in function mode */
		bool active_high:1; /* true: active  high, false: active low */
				/* Set to true  on port 1 in function mode */
	} ovc_pin[3];		/* (R8A7778 only has 2 ports)		*/
};

#endif /* __USB_RCAR_PHY_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #ifndef LINUX_MMC_SH_MOBILE_SDHI_H
#define LINUX_MMC_SH_MOBILE_SDHI_H

#include <linux/types.h>

#define SH_MOBILE_SDHI_IRQ_CARD_DETECT	"card_detect"
#define SH_MOBILE_SDHI_IRQ_SDCARD	"sdcard"
#define SH_MOBILE_SDHI_IRQ_SDIO		"sdio"

#endif /* LINUX_MMC_SH_MOBILE_SDHI_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 *  include/linux/mmc/sdio_func.h
 *
 *  Copyright 2007-2008 Pierre Ossman
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 */

#ifndef LINUX_MMC_SDIO_FUNC_H
#define LINUX_MMC_SDIO_FUNC_H

#include <linux/device.h>
#include <linux/mod_devicetable.h>

#include <linux/mmc/pm.h>

struct mmc_card;
struct sdio_func;

typedef void (sdio_irq_handler_t)(struct sdio_func *);

/*
 * SDIO function CIS tuple (unknown to the core)
 */
struct sdio_func_tuple {
	struct sdio_func_tuple *next;
	unsigned char code;
	unsigned char size;
	unsigned char data[0];
};

/*
 * SDIO function devices
 */
struct sdio_func {
	struct mmc_card		*card;		/* the card this device belongs to */
	struct device		dev;		/* the device */
	sdio_irq_handler_t	*irq_handler;	/* IRQ callback */
	unsigned int		num;		/* function number */

	unsigned char		class;		/* standard interface class */
	unsigned short		vendor;		/* vendor id */
	unsigned short		device;		/* device id */

	unsigned		max_blksize;	/* maximum block size */
	unsigned		cur_blksize;	/* current block size */

	unsigned		enable_timeout;	/* max enable timeout in msec */

	unsigned int		state;		/* function state */
#define SDIO_STATE_PRESENT	(1<<0)		/* present in sysfs */

	u8			tmpbuf[4];	/* DMA:able scratch buffer */

	unsigned		num_info;	/* number of info strings */
	const char		**info;		/* info strings */

	struct sdio_func_tuple *tuples;
};

#define sdio_func_present(f)	((f)->state & SDIO_STATE_PRESENT)

#define sdio_func_set_present(f) ((f)->state |= SDIO_STATE_PRESENT)

#define sdio_func_id(f)		(dev_name(&(f)->dev))

#define sdio_get_drvdata(f)	dev_get_drvdata(&(f)->dev)
#define sdio_set_drvdata(f,d)	dev_set_drvdata(&(f)->dev, d)
#define dev_to_sdio_func(d)	container_of(d, struct sdio_func, dev)

/*
 * SDIO function device driver
 */
struct sdio_driver {
	char *name;
	const struct sdio_device_id *id_table;

	int (*probe)(struct sdio_func *, const struct sdio_device_id *);
	void (*remove)(struct sdio_func *);

	struct device_driver drv;
};

/**
 * SDIO_DEVICE - macro used to describe a specific SDIO device
 * @vend: the 16 bit manufacturer code
 * @dev: the 16 bit function id
 *
 * This macro is used to create a struct sdio_device_id that matches a
 * specific device. The class field will be set to SDIO_ANY_ID.
 */
#define SDIO_DEVICE(vend,dev) \
	.class = SDIO_ANY_ID, \
	.vendor = (vend), .device = (dev)

/**
 * SDIO_DEVICE_CLASS - macro used to describe a specific SDIO device class
 * @dev_class: the 8 bit standard interface code
 *
 * This macro is used to create a struct sdio_device_id that matches a
 * specific standard SDIO function type.  The vendor and device fields will
 * be set to SDIO_ANY_ID.
 */
#define SDIO_DEVICE_CLASS(dev_class) \
	.class = (dev_class), \
	.vendor = SDIO_ANY_ID, .device = SDIO_ANY_ID

extern int sdio_register_driver(struct sdio_driver *);
extern void sdio_unregister_driver(struct sdio_driver *);

/*
 * SDIO I/O operations
 */
extern void sdio_claim_host(struct sdio_func *func);
extern void sdio_release_host(struct sdio_func *func);

extern int sdio_enable_func(struct sdio_func *func);
extern int sdio_disable_func(struct sdio_func *func);

extern int sdio_set_block_size(struct sdio_func *func, unsigned blksz);

extern int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler);
extern int sdio_release_irq(struct sdio_func *func);

extern unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz);

extern u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret);
extern u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret);
extern u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret);

extern int sdio_memcpy_fromio(struct sdio_func *func, void *dst,
	unsigned int addr, int count);
extern int sdio_readsb(struct sdio_func *func, void *dst,
	unsigned int addr, int count);

extern void sdio_writeb(struct sdio_func *func, u8 b,
	unsigned int addr, int *err_ret);
extern void sdio_writew(struct sdio_func *func, u16 b,
	unsigned int addr, int *err_ret);
extern void sdio_writel(struct sdio_func *func, u32 b,
	unsigned int addr, int *err_ret);

extern u8 sdio_writeb_readb(struct sdio_func *func, u8 write_byte,
	unsigned int addr, int *err_ret);

extern int sdio_memcpy_toio(struct sdio_func *func, unsigned int addr,
	void *src, int count);
extern int sdio_writesb(struct sdio_func *func, unsigned int addr,
	void *src, int count);

extern unsigned char sdio_f0_readb(struct sdio_func *func,
	unsigned int addr, int *err_ret);
extern void sdio_f0_writeb(struct sdio_func *func, unsigned char b,
	unsigned int addr, int *err_ret);

extern mmc_pm_flag_t sdio_get_host_pm_caps(struct sdio_func *func);
extern int sdio_set_host_pm_flags(struct sdio_func *func, mmc_pm_flag_t flags);

#endif /* LINUX_MMC_SDIO_FUNC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 *  linux/include/linux/mmc/core.h
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#ifndef LINUX_MMC_CORE_H
#define LINUX_MMC_CORE_H

#include <linux/interrupt.h>
#include <linux/completion.h>

struct request;
struct mmc_data;
struct mmc_request;

struct mmc_command {
	u32			opcode;
	u32			arg;
#define MMC_CMD23_ARG_REL_WR	(1 << 31)
#define MMC_CMD23_ARG_PACKED	((0 << 31) | (1 << 30))
#define MMC_CMD23_ARG_TAG_REQ	(1 << 29)
	u32			resp[4];
	unsigned int		flags;		/* expected response type */
#define MMC_RSP_PRESENT	(1 << 0)
#define MMC_RSP_136	(1 << 1)		/* 136 bit response */
#define MMC_RSP_CRC	(1 << 2)		/* expect valid crc */
#define MMC_RSP_BUSY	(1 << 3)		/* card may send busy */
#define MMC_RSP_OPCODE	(1 << 4)		/* response contains opcode */

#define MMC_CMD_MASK	(3 << 5)		/* non-SPI command type */
#define MMC_CMD_AC	(0 << 5)
#define MMC_CMD_ADTC	(1 << 5)
#define MMC_CMD_BC	(2 << 5)
#define MMC_CMD_BCR	(3 << 5)

#define MMC_RSP_SPI_S1	(1 << 7)		/* one status byte */
#define MMC_RSP_SPI_S2	(1 << 8)		/* second byte */
#define MMC_RSP_SPI_B4	(1 << 9)		/* four data bytes */
#define MMC_RSP_SPI_BUSY (1 << 10)		/* card may send busy */

/*
 * These are the native response types, and correspond to valid bit
 * patterns of the above flags.  One additional valid pattern
 * is all zeros, which means we don't expect a response.
 */
#define MMC_RSP_NONE	(0)
#define MMC_RSP_R1	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
#define MMC_RSP_R1B	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
#define MMC_RSP_R2	(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
#define MMC_RSP_R3	(MMC_RSP_PRESENT)
#define MMC_RSP_R4	(MMC_RSP_PRESENT)
#define MMC_RSP_R5	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
#define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
#define MMC_RSP_R7	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)

#define mmc_resp_type(cmd)	((cmd)->flags & (MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC|MMC_RSP_BUSY|MMC_RSP_OPCODE))

/*
 * These are the SPI response types for MMC, SD, and SDIO cards.
 * Commands return R1, with maybe more info.  Zero is an error type;
 * callers must always provide the appropriate MMC_RSP_SPI_Rx flags.
 */
#define MMC_RSP_SPI_R1	(MMC_RSP_SPI_S1)
#define MMC_RSP_SPI_R1B	(MMC_RSP_SPI_S1|MMC_RSP_SPI_BUSY)
#define MMC_RSP_SPI_R2	(MMC_RSP_SPI_S1|MMC_RSP_SPI_S2)
#define MMC_RSP_SPI_R3	(MMC_RSP_SPI_S1|MMC_RSP_SPI_B4)
#define MMC_RSP_SPI_R4	(MMC_RSP_SPI_S1|MMC_RSP_SPI_B4)
#define MMC_RSP_SPI_R5	(MMC_RSP_SPI_S1|MMC_RSP_SPI_S2)
#define MMC_RSP_SPI_R7	(MMC_RSP_SPI_S1|MMC_RSP_SPI_B4)

#define mmc_spi_resp_type(cmd)	((cmd)->flags & \
		(MMC_RSP_SPI_S1|MMC_RSP_SPI_BUSY|MMC_RSP_SPI_S2|MMC_RSP_SPI_B4))

/*
 * These are the command types.
 */
#define mmc_cmd_type(cmd)	((cmd)->flags & MMC_CMD_MASK)

	unsigned int		retries;	/* max number of retries */
	int			error;		/* command error */

/*
 * Standard errno values are used for errors, but some have specific
 * meaning in the MMC layer:
 *
 * ETIMEDOUT    Card took too long to respond
 * EILSEQ       Basic format problem with the received or sent data
 *              (e.g. CRC check failed, incorrect opcode in response
 *              or bad end bit)
 * EINVAL       Request cannot be performed because of restrictions
 *              in hardware and/or the driver
 * ENOMEDIUM    Host can determine that the slot is empty and is
 *              actively failing requests
 */

	unsigned int		busy_timeout;	/* busy detect timeout in ms */
	/* Set this flag only for blocking sanitize request */
	bool			sanitize_busy;

	struct mmc_data		*data;		/* data segment associated with cmd */
	struct mmc_request	*mrq;		/* associated request */
};

struct mmc_data {
	unsigned int		timeout_ns;	/* data timeout (in ns, max 80ms) */
	unsigned int		timeout_clks;	/* data timeout (in clocks) */
	unsigned int		blksz;		/* data block size */
	unsigned int		blocks;		/* number of blocks */
	int			error;		/* data error */
	unsigned int		flags;

#define MMC_DATA_WRITE	(1 << 8)
#define MMC_DATA_READ	(1 << 9)
#define MMC_DATA_STREAM	(1 << 10)

	unsigned int		bytes_xfered;

	struct mmc_command	*stop;		/* stop command */
	struct mmc_request	*mrq;		/* associated request */

	unsigned int		sg_len;		/* size of scatter list */
	int			sg_count;	/* mapped sg entries */
	struct scatterlist	*sg;		/* I/O scatter list */
	s32			host_cookie;	/* host private data */
};

struct mmc_host;
struct mmc_request {
	struct mmc_command	*sbc;		/* SET_BLOCK_COUNT for multiblock */
	struct mmc_command	*cmd;
	struct mmc_data		*data;
	struct mmc_command	*stop;

	struct completion	completion;
	void			(*done)(struct mmc_request *);/* completion function */
	struct mmc_host		*host;
};

struct mmc_card;
struct mmc_async_req;

extern int mmc_stop_bkops(struct mmc_card *);
extern int mmc_read_bkops_status(struct mmc_card *);
extern struct mmc_async_req *mmc_start_req(struct mmc_host *,
					   struct mmc_async_req *, int *);
extern int mmc_interrupt_hpi(struct mmc_card *);
extern void mmc_wait_for_req(struct mmc_host *, struct mmc_request *);
extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
extern int mmc_app_cmd(struct mmc_host *, struct mmc_card *);
extern int mmc_wait_for_app_cmd(struct mmc_host *, struct mmc_card *,
	struct mmc_command *, int);
extern void mmc_start_bkops(struct mmc_card *card, bool from_exception);
extern int __mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int, bool,
			bool, bool);
extern int mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int);
extern int mmc_send_tuning(struct mmc_host *host);
extern int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd);

#define MMC_ERASE_ARG		0x00000000
#define MMC_SECURE_ERASE_ARG	0x80000000
#define MMC_TRIM_ARG		0x00000001
#define MMC_DISCARD_ARG		0x00000003
#define MMC_SECURE_TRIM1_ARG	0x80000001
#define MMC_SECURE_TRIM2_ARG	0x80008000

#define MMC_SECURE_ARGS		0x80000000
#define MMC_TRIM_ARGS		0x00008001

extern int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
		     unsigned int arg);
extern int mmc_can_erase(struct mmc_card *card);
extern int mmc_can_trim(struct mmc_card *card);
extern int mmc_can_discard(struct mmc_card *card);
extern int mmc_can_sanitize(struct mmc_card *card);
extern int mmc_can_secure_erase_trim(struct mmc_card *card);
extern int mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,
				   unsigned int nr);
extern unsigned int mmc_calc_max_discard(struct mmc_card *card);

extern int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen);
extern int mmc_set_blockcount(struct mmc_card *card, unsigned int blockcount,
			      bool is_rel_write);
extern int mmc_hw_reset(struct mmc_host *host);
extern int mmc_can_reset(struct mmc_card *card);

extern void mmc_set_data_timeout(struct mmc_data *, const struct mmc_card *);
extern unsigned int mmc_align_data_size(struct mmc_card *, unsigned int);

extern int __mmc_claim_host(struct mmc_host *host, atomic_t *abort);
extern void mmc_release_host(struct mmc_host *host);

extern void mmc_get_card(struct mmc_card *card);
extern void mmc_put_card(struct mmc_card *card);

extern int mmc_flush_cache(struct mmc_card *);

extern int mmc_detect_card_removed(struct mmc_host *host);

/**
 *	mmc_claim_host - exclusively claim a host
 *	@host: mmc host to claim
 *
 *	Claim a host for a set of operations.
 */
static inline void mmc_claim_host(struct mmc_host *host)
{
	__mmc_claim_host(host, NULL);
}

struct device_node;
extern u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max);
extern int mmc_of_parse_voltage(struct device_node *np, u32 *mask);

#endif /* LINUX_MMC_CORE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                         #ifndef LINUX_MMC_BOOT_H
#define LINUX_MMC_BOOT_H

enum { MMC_PROGRESS_ENTER, MMC_PROGRESS_INIT,
       MMC_PROGRESS_LOAD, MMC_PROGRESS_DONE };

#endif /* LINUX_MMC_BOOT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * linux/include/linux/mmc/pm.h
 *
 * Author:	Nicolas Pitre
 * Copyright:	(C) 2009 Marvell Technology Group Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef LINUX_MMC_PM_H
#define LINUX_MMC_PM_H

/*
 * These flags are used to describe power management features that
 * some cards (typically SDIO cards) might wish to benefit from when
 * the host system is being suspended.  There are several layers of
 * abstractions involved, from the host controller driver, to the MMC core
 * code, to the SDIO core code, to finally get to the actual SDIO function
 * driver.  This file is therefore used for common definitions shared across
 * all those layers.
 */

typedef unsigned int mmc_pm_flag_t;

#define MMC_PM_KEEP_POWER	(1 << 0)	/* preserve card power during suspend */
#define MMC_PM_WAKE_SDIO_IRQ	(1 << 1)	/* wake up host system on SDIO IRQ assertion */

#endif /* LINUX_MMC_PM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #ifndef LINUX_MMC_SDHCI_PCI_DATA_H
#define LINUX_MMC_SDHCI_PCI_DATA_H

struct pci_dev;

struct sdhci_pci_data {
	struct pci_dev	*pdev;
	int		slotno;
	int		rst_n_gpio; /* Set to -EINVAL if unused */
	int		cd_gpio;    /* Set to -EINVAL if unused */
	int		(*setup)(struct sdhci_pci_data *data);
	void		(*cleanup)(struct sdhci_pci_data *data);
};

extern struct sdhci_pci_data *(*sdhci_pci_get_data)(struct pci_dev *pdev,
				int slotno);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * SDIO Classes, Interface Types, Manufacturer IDs, etc.
 */

#ifndef LINUX_MMC_SDIO_IDS_H
#define LINUX_MMC_SDIO_IDS_H

/*
 * Standard SDIO Function Interfaces
 */

#define SDIO_CLASS_NONE		0x00	/* Not a SDIO standard interface */
#define SDIO_CLASS_UART		0x01	/* standard UART interface */
#define SDIO_CLASS_BT_A		0x02	/* Type-A BlueTooth std interface */
#define SDIO_CLASS_BT_B		0x03	/* Type-B BlueTooth std interface */
#define SDIO_CLASS_GPS		0x04	/* GPS standard interface */
#define SDIO_CLASS_CAMERA	0x05	/* Camera standard interface */
#define SDIO_CLASS_PHS		0x06	/* PHS standard interface */
#define SDIO_CLASS_WLAN		0x07	/* WLAN interface */
#define SDIO_CLASS_ATA		0x08	/* Embedded SDIO-ATA std interface */
#define SDIO_CLASS_BT_AMP	0x09	/* Type-A Bluetooth AMP interface */

/*
 * Vendors and devices.  Sort key: vendor first, device next.
 */
#define SDIO_VENDOR_ID_BROADCOM			0x02d0
#define SDIO_DEVICE_ID_BROADCOM_43143		0xa887
#define SDIO_DEVICE_ID_BROADCOM_43241		0x4324
#define SDIO_DEVICE_ID_BROADCOM_4329		0x4329
#define SDIO_DEVICE_ID_BROADCOM_4330		0x4330
#define SDIO_DEVICE_ID_BROADCOM_4334		0x4334
#define SDIO_DEVICE_ID_BROADCOM_43340		0xa94c
#define SDIO_DEVICE_ID_BROADCOM_43341		0xa94d
#define SDIO_DEVICE_ID_BROADCOM_4335_4339	0x4335
#define SDIO_DEVICE_ID_BROADCOM_43362		0xa962
#define SDIO_DEVICE_ID_BROADCOM_43430		0xa9a6
#define SDIO_DEVICE_ID_BROADCOM_4345		0x4345
#define SDIO_DEVICE_ID_BROADCOM_4354		0x4354

#define SDIO_VENDOR_ID_INTEL			0x0089
#define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX	0x1402
#define SDIO_DEVICE_ID_INTEL_IWMC3200WIFI	0x1403
#define SDIO_DEVICE_ID_INTEL_IWMC3200TOP	0x1404
#define SDIO_DEVICE_ID_INTEL_IWMC3200GPS	0x1405
#define SDIO_DEVICE_ID_INTEL_IWMC3200BT		0x1406
#define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX_2G5	0x1407

#define SDIO_VENDOR_ID_MARVELL			0x02df
#define SDIO_DEVICE_ID_MARVELL_LIBERTAS		0x9103
#define SDIO_DEVICE_ID_MARVELL_8688WLAN		0x9104
#define SDIO_DEVICE_ID_MARVELL_8688BT		0x9105

#define SDIO_VENDOR_ID_SIANO			0x039a
#define SDIO_DEVICE_ID_SIANO_NOVA_B0		0x0201
#define SDIO_DEVICE_ID_SIANO_NICE		0x0202
#define SDIO_DEVICE_ID_SIANO_VEGA_A0		0x0300
#define SDIO_DEVICE_ID_SIANO_VENICE		0x0301
#define SDIO_DEVICE_ID_SIANO_NOVA_A0		0x1100
#define SDIO_DEVICE_ID_SIANO_STELLAR 		0x5347

#endif /* LINUX_MMC_SDIO_IDS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 *  include/linux/mmc/sdio.h
 *
 *  Copyright 2006-2007 Pierre Ossman
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 */

#ifndef LINUX_MMC_SDIO_H
#define LINUX_MMC_SDIO_H

/* SDIO commands                         type  argument     response */
#define SD_IO_SEND_OP_COND          5 /* bcr  [23:0] OCR         R4  */
#define SD_IO_RW_DIRECT            52 /* ac   [31:0] See below   R5  */
#define SD_IO_RW_EXTENDED          53 /* adtc [31:0] See below   R5  */

/*
 * SD_IO_RW_DIRECT argument format:
 *
 *      [31] R/W flag
 *      [30:28] Function number
 *      [27] RAW flag
 *      [25:9] Register address
 *      [7:0] Data
 */

/*
 * SD_IO_RW_EXTENDED argument format:
 *
 *      [31] R/W flag
 *      [30:28] Function number
 *      [27] Block mode
 *      [26] Increment address
 *      [25:9] Register address
 *      [8:0] Byte/block count
 */

#define R4_18V_PRESENT (1<<24)
#define R4_MEMORY_PRESENT (1 << 27)

/*
  SDIO status in R5
  Type
	e : error bit
	s : status bit
	r : detected and set for the actual command response
	x : detected and set during command execution. the host must poll
            the card by sending status command in order to read these bits.
  Clear condition
	a : according to the card state
	b : always related to the previous command. Reception of
            a valid command will clear it (with a delay of one command)
	c : clear by read
 */

#define R5_COM_CRC_ERROR	(1 << 15)	/* er, b */
#define R5_ILLEGAL_COMMAND	(1 << 14)	/* er, b */
#define R5_ERROR		(1 << 11)	/* erx, c */
#define R5_FUNCTION_NUMBER	(1 << 9)	/* er, c */
#define R5_OUT_OF_RANGE		(1 << 8)	/* er, c */
#define R5_STATUS(x)		(x & 0xCB00)
#define R5_IO_CURRENT_STATE(x)	((x & 0x3000) >> 12) /* s, b */

/*
 * Card Common Control Registers (CCCR)
 */

#define SDIO_CCCR_CCCR		0x00

#define  SDIO_CCCR_REV_1_00	0	/* CCCR/FBR Version 1.00 */
#define  SDIO_CCCR_REV_1_10	1	/* CCCR/FBR Version 1.10 */
#define  SDIO_CCCR_REV_1_20	2	/* CCCR/FBR Version 1.20 */
#define  SDIO_CCCR_REV_3_00	3	/* CCCR/FBR Version 3.00 */

#define  SDIO_SDIO_REV_1_00	0	/* SDIO Spec Version 1.00 */
#define  SDIO_SDIO_REV_1_10	1	/* SDIO Spec Version 1.10 */
#define  SDIO_SDIO_REV_1_20	2	/* SDIO Spec Version 1.20 */
#define  SDIO_SDIO_REV_2_00	3	/* SDIO Spec Version 2.00 */
#define  SDIO_SDIO_REV_3_00	4	/* SDIO Spec Version 3.00 */

#define SDIO_CCCR_SD		0x01

#define  SDIO_SD_REV_1_01	0	/* SD Physical Spec Version 1.01 */
#define  SDIO_SD_REV_1_10	1	/* SD Physical Spec Version 1.10 */
#define  SDIO_SD_REV_2_00	2	/* SD Physical Spec Version 2.00 */
#define  SDIO_SD_REV_3_00	3	/* SD Physical Spev Version 3.00 */

#define SDIO_CCCR_IOEx		0x02
#define SDIO_CCCR_IORx		0x03

#define SDIO_CCCR_IENx		0x04	/* Function/Master Interrupt Enable */
#define SDIO_CCCR_INTx		0x05	/* Function Interrupt Pending */

#define SDIO_CCCR_ABORT		0x06	/* function abort/card reset */

#define SDIO_CCCR_IF		0x07	/* bus interface controls */

#define  SDIO_BUS_WIDTH_MASK	0x03	/* data bus width setting */
#define  SDIO_BUS_WIDTH_1BIT	0x00
#define  SDIO_BUS_WIDTH_RESERVED 0x01
#define  SDIO_BUS_WIDTH_4BIT	0x02
#define  SDIO_BUS_ECSI		0x20	/* Enable continuous SPI interrupt */
#define  SDIO_BUS_SCSI		0x40	/* Support continuous SPI interrupt */

#define  SDIO_BUS_ASYNC_INT	0x20

#define  SDIO_BUS_CD_DISABLE     0x80	/* disable pull-up on DAT3 (pin 1) */

#define SDIO_CCCR_CAPS		0x08

#define  SDIO_CCCR_CAP_SDC	0x01	/* can do CMD52 while data transfer */
#define  SDIO_CCCR_CAP_SMB	0x02	/* can do multi-block xfers (CMD53) */
#define  SDIO_CCCR_CAP_SRW	0x04	/* supports read-wait protocol */
#define  SDIO_CCCR_CAP_SBS	0x08	/* supports suspend/resume */
#define  SDIO_CCCR_CAP_S4MI	0x10	/* interrupt during 4-bit CMD53 */
#define  SDIO_CCCR_CAP_E4MI	0x20	/* enable ints during 4-bit CMD53 */
#define  SDIO_CCCR_CAP_LSC	0x40	/* low speed card */
#define  SDIO_CCCR_CAP_4BLS	0x80	/* 4 bit low speed card */

#define SDIO_CCCR_CIS		0x09	/* common CIS pointer (3 bytes) */

/* Following 4 regs are valid only if SBS is set */
#define SDIO_CCCR_SUSPEND	0x0c
#define SDIO_CCCR_SELx		0x0d
#define SDIO_CCCR_EXECx		0x0e
#define SDIO_CCCR_READYx	0x0f

#define SDIO_CCCR_BLKSIZE	0x10

#define SDIO_CCCR_POWER		0x12

#define  SDIO_POWER_SMPC	0x01	/* Supports Master Power Control */
#define  SDIO_POWER_EMPC	0x02	/* Enable Master Power Control */

#define SDIO_CCCR_SPEED		0x13

#define  SDIO_SPEED_SHS		0x01	/* Supports High-Speed mode */
#define  SDIO_SPEED_BSS_SHIFT	1
#define  SDIO_SPEED_BSS_MASK	(7<<SDIO_SPEED_BSS_SHIFT)
#define  SDIO_SPEED_SDR12	(0<<SDIO_SPEED_BSS_SHIFT)
#define  SDIO_SPEED_SDR25	(1<<SDIO_SPEED_BSS_SHIFT)
#define  SDIO_SPEED_SDR50	(2<<SDIO_SPEED_BSS_SHIFT)
#define  SDIO_SPEED_SDR104	(3<<SDIO_SPEED_BSS_SHIFT)
#define  SDIO_SPEED_DDR50	(4<<SDIO_SPEED_BSS_SHIFT)
#define  SDIO_SPEED_EHS		SDIO_SPEED_SDR25	/* Enable High-Speed */

#define SDIO_CCCR_UHS		0x14
#define  SDIO_UHS_SDR50		0x01
#define  SDIO_UHS_SDR104	0x02
#define  SDIO_UHS_DDR50		0x04

#define SDIO_CCCR_DRIVE_STRENGTH 0x15
#define  SDIO_SDTx_MASK		0x07
#define  SDIO_DRIVE_SDTA	(1<<0)
#define  SDIO_DRIVE_SDTC	(1<<1)
#define  SDIO_DRIVE_SDTD	(1<<2)
#define  SDIO_DRIVE_DTSx_MASK	0x03
#define  SDIO_DRIVE_DTSx_SHIFT	4
#define  SDIO_DTSx_SET_TYPE_B	(0 << SDIO_DRIVE_DTSx_SHIFT)
#define  SDIO_DTSx_SET_TYPE_A	(1 << SDIO_DRIVE_DTSx_SHIFT)
#define  SDIO_DTSx_SET_TYPE_C	(2 << SDIO_DRIVE_DTSx_SHIFT)
#define  SDIO_DTSx_SET_TYPE_D	(3 << SDIO_DRIVE_DTSx_SHIFT)
/*
 * Function Basic Registers (FBR)
 */

#define SDIO_FBR_BASE(f)	((f) * 0x100) /* base of function f's FBRs */

#define SDIO_FBR_STD_IF		0x00

#define  SDIO_FBR_SUPPORTS_CSA	0x40	/* supports Code Storage Area */
#define  SDIO_FBR_ENABLE_CSA	0x80	/* enable Code Storage Area */

#define SDIO_FBR_STD_IF_EXT	0x01

#define SDIO_FBR_POWER		0x02

#define  SDIO_FBR_POWER_SPS	0x01	/* Supports Power Selection */
#define  SDIO_FBR_POWER_EPS	0x02	/* Enable (low) Power Selection */

#define SDIO_FBR_CIS		0x09	/* CIS pointer (3 bytes) */


#define SDIO_FBR_CSA		0x0C	/* CSA pointer (3 bytes) */

#define SDIO_FBR_CSA_DATA	0x0F

#define SDIO_FBR_BLKSIZE	0x10	/* block size (2 bytes) */

#endif /* LINUX_MMC_SDIO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 *  linux/include/linux/mmc/host.h
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 *  Host driver specific definitions.
 */
#ifndef LINUX_MMC_HOST_H
#define LINUX_MMC_HOST_H

#include <linux/leds.h>
#include <linux/mutex.h>
#include <linux/sched.h>
#include <linux/device.h>
#include <linux/fault-inject.h>

#include <linux/mmc/core.h>
#include <linux/mmc/card.h>
#include <linux/mmc/pm.h>

struct mmc_ios {
	unsigned int	clock;			/* clock rate */
	unsigned short	vdd;

/* vdd stores the bit number of the selected voltage range from below. */

	unsigned char	bus_mode;		/* command output mode */

#define MMC_BUSMODE_OPENDRAIN	1
#define MMC_BUSMODE_PUSHPULL	2

	unsigned char	chip_select;		/* SPI chip select */

#define MMC_CS_DONTCARE		0
#define MMC_CS_HIGH		1
#define MMC_CS_LOW		2

	unsigned char	power_mode;		/* power supply mode */

#define MMC_POWER_OFF		0
#define MMC_POWER_UP		1
#define MMC_POWER_ON		2
#define MMC_POWER_UNDEFINED	3

	unsigned char	bus_width;		/* data bus width */

#define MMC_BUS_WIDTH_1		0
#define MMC_BUS_WIDTH_4		2
#define MMC_BUS_WIDTH_8		3

	unsigned char	timing;			/* timing specification used */

#define MMC_TIMING_LEGACY	0
#define MMC_TIMING_MMC_HS	1
#define MMC_TIMING_SD_HS	2
#define MMC_TIMING_UHS_SDR12	3
#define MMC_TIMING_UHS_SDR25	4
#define MMC_TIMING_UHS_SDR50	5
#define MMC_TIMING_UHS_SDR104	6
#define MMC_TIMING_UHS_DDR50	7
#define MMC_TIMING_MMC_DDR52	8
#define MMC_TIMING_MMC_HS200	9
#define MMC_TIMING_MMC_HS400	10

	unsigned char	signal_voltage;		/* signalling voltage (1.8V or 3.3V) */

#define MMC_SIGNAL_VOLTAGE_330	0
#define MMC_SIGNAL_VOLTAGE_180	1
#define MMC_SIGNAL_VOLTAGE_120	2

	unsigned char	drv_type;		/* driver type (A, B, C, D) */

#define MMC_SET_DRIVER_TYPE_B	0
#define MMC_SET_DRIVER_TYPE_A	1
#define MMC_SET_DRIVER_TYPE_C	2
#define MMC_SET_DRIVER_TYPE_D	3
};

struct mmc_host_ops {
	/*
	 * It is optional for the host to implement pre_req and post_req in
	 * order to support double buffering of requests (prepare one
	 * request while another request is active).
	 * pre_req() must always be followed by a post_req().
	 * To undo a call made to pre_req(), call post_req() with
	 * a nonzero err condition.
	 */
	void	(*post_req)(struct mmc_host *host, struct mmc_request *req,
			    int err);
	void	(*pre_req)(struct mmc_host *host, struct mmc_request *req,
			   bool is_first_req);
	void	(*request)(struct mmc_host *host, struct mmc_request *req);
	/*
	 * Avoid calling these three functions too often or in a "fast path",
	 * since underlaying controller might implement them in an expensive
	 * and/or slow way.
	 *
	 * Also note that these functions might sleep, so don't call them
	 * in the atomic contexts!
	 *
	 * Return values for the get_ro callback should be:
	 *   0 for a read/write card
	 *   1 for a read-only card
	 *   -ENOSYS when not supported (equal to NULL callback)
	 *   or a negative errno value when something bad happened
	 *
	 * Return values for the get_cd callback should be:
	 *   0 for a absent card
	 *   1 for a present card
	 *   -ENOSYS when not supported (equal to NULL callback)
	 *   or a negative errno value when something bad happened
	 */
	void	(*set_ios)(struct mmc_host *host, struct mmc_ios *ios);
	int	(*get_ro)(struct mmc_host *host);
	int	(*get_cd)(struct mmc_host *host);

	void	(*enable_sdio_irq)(struct mmc_host *host, int enable);

	/* optional callback for HC quirks */
	void	(*init_card)(struct mmc_host *host, struct mmc_card *card);

	int	(*start_signal_voltage_switch)(struct mmc_host *host, struct mmc_ios *ios);

	/* Check if the card is pulling dat[0:3] low */
	int	(*card_busy)(struct mmc_host *host);

	/* The tuning command opcode value is different for SD and eMMC cards */
	int	(*execute_tuning)(struct mmc_host *host, u32 opcode);

	/* Prepare HS400 target operating frequency depending host driver */
	int	(*prepare_hs400_tuning)(struct mmc_host *host, struct mmc_ios *ios);
	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
	void	(*hw_reset)(struct mmc_host *host);
	void	(*card_event)(struct mmc_host *host);

	/*
	 * Optional callback to support controllers with HW issues for multiple
	 * I/O. Returns the number of supported blocks for the request.
	 */
	int	(*multi_io_quirk)(struct mmc_card *card,
				  unsigned int direction, int blk_size);
};

struct mmc_card;
struct device;

struct mmc_async_req {
	/* active mmc request */
	struct mmc_request	*mrq;
	/*
	 * Check error status of completed mmc request.
	 * Returns 0 if success otherwise non zero.
	 */
	int (*err_check) (struct mmc_card *, struct mmc_async_req *);
};

/**
 * struct mmc_slot - MMC slot functions
 *
 * @cd_irq:		MMC/SD-card slot hotplug detection IRQ or -EINVAL
 * @handler_priv:	MMC/SD-card slot context
 *
 * Some MMC/SD host controllers implement slot-functions like card and
 * write-protect detection natively. However, a large number of controllers
 * leave these functions to the CPU. This struct provides a hook to attach
 * such slot-function drivers.
 */
struct mmc_slot {
	int cd_irq;
	void *handler_priv;
};

/**
 * mmc_context_info - synchronization details for mmc context
 * @is_done_rcv		wake up reason was done request
 * @is_new_req		wake up reason was new request
 * @is_waiting_last_req	mmc context waiting for single running request
 * @wait		wait queue
 * @lock		lock to protect data fields
 */
struct mmc_context_info {
	bool			is_done_rcv;
	bool			is_new_req;
	bool			is_waiting_last_req;
	wait_queue_head_t	wait;
	spinlock_t		lock;
};

struct regulator;
struct mmc_pwrseq;

struct mmc_supply {
	struct regulator *vmmc;		/* Card power supply */
	struct regulator *vqmmc;	/* Optional Vccq supply */
};

struct mmc_host {
	struct device		*parent;
	struct device		class_dev;
	int			index;
	const struct mmc_host_ops *ops;
	struct mmc_pwrseq	*pwrseq;
	unsigned int		f_min;
	unsigned int		f_max;
	unsigned int		f_init;
	u32			ocr_avail;
	u32			ocr_avail_sdio;	/* SDIO-specific OCR */
	u32			ocr_avail_sd;	/* SD-specific OCR */
	u32			ocr_avail_mmc;	/* MMC-specific OCR */
	struct notifier_block	pm_notify;
	u32			max_current_330;
	u32			max_current_300;
	u32			max_current_180;

#define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
#define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
#define MMC_VDD_21_22		0x00000200	/* VDD voltage 2.1 ~ 2.2 */
#define MMC_VDD_22_23		0x00000400	/* VDD voltage 2.2 ~ 2.3 */
#define MMC_VDD_23_24		0x00000800	/* VDD voltage 2.3 ~ 2.4 */
#define MMC_VDD_24_25		0x00001000	/* VDD voltage 2.4 ~ 2.5 */
#define MMC_VDD_25_26		0x00002000	/* VDD voltage 2.5 ~ 2.6 */
#define MMC_VDD_26_27		0x00004000	/* VDD voltage 2.6 ~ 2.7 */
#define MMC_VDD_27_28		0x00008000	/* VDD voltage 2.7 ~ 2.8 */
#define MMC_VDD_28_29		0x00010000	/* VDD voltage 2.8 ~ 2.9 */
#define MMC_VDD_29_30		0x00020000	/* VDD voltage 2.9 ~ 3.0 */
#define MMC_VDD_30_31		0x00040000	/* VDD voltage 3.0 ~ 3.1 */
#define MMC_VDD_31_32		0x00080000	/* VDD voltage 3.1 ~ 3.2 */
#define MMC_VDD_32_33		0x00100000	/* VDD voltage 3.2 ~ 3.3 */
#define MMC_VDD_33_34		0x00200000	/* VDD voltage 3.3 ~ 3.4 */
#define MMC_VDD_34_35		0x00400000	/* VDD voltage 3.4 ~ 3.5 */
#define MMC_VDD_35_36		0x00800000	/* VDD voltage 3.5 ~ 3.6 */

	u32			caps;		/* Host capabilities */

#define MMC_CAP_4_BIT_DATA	(1 << 0)	/* Can the host do 4 bit transfers */
#define MMC_CAP_MMC_HIGHSPEED	(1 << 1)	/* Can do MMC high-speed timing */
#define MMC_CAP_SD_HIGHSPEED	(1 << 2)	/* Can do SD high-speed timing */
#define MMC_CAP_SDIO_IRQ	(1 << 3)	/* Can signal pending SDIO IRQs */
#define MMC_CAP_SPI		(1 << 4)	/* Talks only SPI protocols */
#define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
#define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
#define MMC_CAP_AGGRESSIVE_PM	(1 << 7)	/* Suspend (e)MMC/SD at idle  */
#define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
#define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
#define MMC_CAP_ERASE		(1 << 10)	/* Allow erase/trim commands */
#define MMC_CAP_1_8V_DDR	(1 << 11)	/* can support */
						/* DDR mode at 1.8V */
#define MMC_CAP_1_2V_DDR	(1 << 12)	/* can support */
						/* DDR mode at 1.2V */
#define MMC_CAP_POWER_OFF_CARD	(1 << 13)	/* Can power off after boot */
#define MMC_CAP_BUS_WIDTH_TEST	(1 << 14)	/* CMD14/CMD19 bus width ok */
#define MMC_CAP_UHS_SDR12	(1 << 15)	/* Host supports UHS SDR12 mode */
#define MMC_CAP_UHS_SDR25	(1 << 16)	/* Host supports UHS SDR25 mode */
#define MMC_CAP_UHS_SDR50	(1 << 17)	/* Host supports UHS SDR50 mode */
#define MMC_CAP_UHS_SDR104	(1 << 18)	/* Host supports UHS SDR104 mode */
#define MMC_CAP_UHS_DDR50	(1 << 19)	/* Host supports UHS DDR50 mode */
#define MMC_CAP_RUNTIME_RESUME	(1 << 20)	/* Resume at runtime_resume. */
#define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
#define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
#define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */
#define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
#define MMC_CAP_HW_RESET	(1 << 31)	/* Hardware reset */

	u32			caps2;		/* More host capabilities */

#define MMC_CAP2_BOOTPART_NOACC	(1 << 0)	/* Boot partition no access */
#define MMC_CAP2_FULL_PWR_CYCLE	(1 << 2)	/* Can do full power cycle */
#define MMC_CAP2_HS200_1_8V_SDR	(1 << 5)        /* can support */
#define MMC_CAP2_HS200_1_2V_SDR	(1 << 6)        /* can support */
#define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \
				 MMC_CAP2_HS200_1_2V_SDR)
#define MMC_CAP2_HC_ERASE_SZ	(1 << 9)	/* High-capacity erase size */
#define MMC_CAP2_CD_ACTIVE_HIGH	(1 << 10)	/* Card-detect signal active high */
#define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */
#define MMC_CAP2_PACKED_RD	(1 << 12)	/* Allow packed read */
#define MMC_CAP2_PACKED_WR	(1 << 13)	/* Allow packed write */
#define MMC_CAP2_PACKED_CMD	(MMC_CAP2_PACKED_RD | \
				 MMC_CAP2_PACKED_WR)
#define MMC_CAP2_NO_PRESCAN_POWERUP (1 << 14)	/* Don't power up before scan */
#define MMC_CAP2_HS400_1_8V	(1 << 15)	/* Can support HS400 1.8V */
#define MMC_CAP2_HS400_1_2V	(1 << 16)	/* Can support HS400 1.2V */
#define MMC_CAP2_HS400		(MMC_CAP2_HS400_1_8V | \
				 MMC_CAP2_HS400_1_2V)
#define MMC_CAP2_HSX00_1_2V	(MMC_CAP2_HS200_1_2V_SDR | MMC_CAP2_HS400_1_2V)
#define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
#define MMC_CAP2_FORCE_MULTIBLOCK (1 << 31)	/* Always use multiblock transfers */

	mmc_pm_flag_t		pm_caps;	/* supported pm features */

#ifdef CONFIG_MMC_CLKGATE
	int			clk_requests;	/* internal reference counter */
	unsigned int		clk_delay;	/* number of MCI clk hold cycles */
	bool			clk_gated;	/* clock gated */
	struct delayed_work	clk_gate_work; /* delayed clock gate */
	unsigned int		clk_old;	/* old clock value cache */
	spinlock_t		clk_lock;	/* lock for clk fields */
	struct mutex		clk_gate_mutex;	/* mutex for clock gating */
	struct device_attribute clkgate_delay_attr;
	unsigned long           clkgate_delay;
#endif

	/* host specific block data */
	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
	unsigned short		max_segs;	/* see blk_queue_max_segments */
	unsigned short		unused;
	unsigned int		max_req_size;	/* maximum number of bytes in one req */
	unsigned int		max_blk_size;	/* maximum size of one mmc block */
	unsigned int		max_blk_count;	/* maximum number of blocks in one req */
	unsigned int		max_busy_timeout; /* max busy timeout in ms */

	/* private data */
	spinlock_t		lock;		/* lock for claim and bus ops */

	struct mmc_ios		ios;		/* current io bus settings */

	/* group bitfields together to minimize padding */
	unsigned int		use_spi_crc:1;
	unsigned int		claimed:1;	/* host exclusively claimed */
	unsigned int		bus_dead:1;	/* bus has been released */
#ifdef CONFIG_MMC_DEBUG
	unsigned int		removed:1;	/* host is being removed */
#endif

	int			rescan_disable;	/* disable card detection */
	int			rescan_entered;	/* used with nonremovable devices */

	bool			trigger_card_event; /* card_event necessary */

	struct mmc_card		*card;		/* device attached to this host */

	wait_queue_head_t	wq;
	struct task_struct	*claimer;	/* task that has host claimed */
	int			claim_cnt;	/* "claim" nesting count */

	struct delayed_work	detect;
	int			detect_change;	/* card detect flag */
	struct mmc_slot		slot;

	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
	unsigned int		bus_refs;	/* reference counter */

	unsigned int		sdio_irqs;
	struct task_struct	*sdio_irq_thread;
	bool			sdio_irq_pending;
	atomic_t		sdio_irq_thread_abort;

	mmc_pm_flag_t		pm_flags;	/* requested pm features */

	struct led_trigger	*led;		/* activity led */

#ifdef CONFIG_REGULATOR
	bool			regulator_enabled; /* regulator state */
#endif
	struct mmc_supply	supply;

	struct dentry		*debugfs_root;

	struct mmc_async_req	*areq;		/* active async req */
	struct mmc_context_info	context_info;	/* async synchronization info */

#ifdef CONFIG_FAIL_MMC_REQUEST
	struct fault_attr	fail_mmc_request;
#endif

	unsigned int		actual_clock;	/* Actual HC clock rate */

	unsigned int		slotno;	/* used for sdio acpi binding */

	int			dsr_req;	/* DSR value is valid */
	u32			dsr;	/* optional driver stage (DSR) value */

	unsigned long		private[0] ____cacheline_aligned;
};

struct mmc_host *mmc_alloc_host(int extra, struct device *);
int mmc_add_host(struct mmc_host *);
void mmc_remove_host(struct mmc_host *);
void mmc_free_host(struct mmc_host *);
int mmc_of_parse(struct mmc_host *host);

static inline void *mmc_priv(struct mmc_host *host)
{
	return (void *)host->private;
}

#define mmc_host_is_spi(host)	((host)->caps & MMC_CAP_SPI)

#define mmc_dev(x)	((x)->parent)
#define mmc_classdev(x)	(&(x)->class_dev)
#define mmc_hostname(x)	(dev_name(&(x)->class_dev))

int mmc_power_save_host(struct mmc_host *host);
int mmc_power_restore_host(struct mmc_host *host);

void mmc_detect_change(struct mmc_host *, unsigned long delay);
void mmc_request_done(struct mmc_host *, struct mmc_request *);

static inline void mmc_signal_sdio_irq(struct mmc_host *host)
{
	host->ops->enable_sdio_irq(host, 0);
	host->sdio_irq_pending = true;
	wake_up_process(host->sdio_irq_thread);
}

void sdio_run_irqs(struct mmc_host *host);

#ifdef CONFIG_REGULATOR
int mmc_regulator_get_ocrmask(struct regulator *supply);
int mmc_regulator_set_ocr(struct mmc_host *mmc,
			struct regulator *supply,
			unsigned short vdd_bit);
#else
static inline int mmc_regulator_get_ocrmask(struct regulator *supply)
{
	return 0;
}

static inline int mmc_regulator_set_ocr(struct mmc_host *mmc,
				 struct regulator *supply,
				 unsigned short vdd_bit)
{
	return 0;
}
#endif

int mmc_regulator_get_supply(struct mmc_host *mmc);

int mmc_pm_notify(struct notifier_block *notify_block, unsigned long, void *);

static inline int mmc_card_is_removable(struct mmc_host *host)
{
	return !(host->caps & MMC_CAP_NONREMOVABLE);
}

static inline int mmc_card_keep_power(struct mmc_host *host)
{
	return host->pm_flags & MMC_PM_KEEP_POWER;
}

static inline int mmc_card_wake_sdio_irq(struct mmc_host *host)
{
	return host->pm_flags & MMC_PM_WAKE_SDIO_IRQ;
}

static inline int mmc_host_cmd23(struct mmc_host *host)
{
	return host->caps & MMC_CAP_CMD23;
}

static inline int mmc_boot_partition_access(struct mmc_host *host)
{
	return !(host->caps2 & MMC_CAP2_BOOTPART_NOACC);
}

static inline int mmc_host_uhs(struct mmc_host *host)
{
	return host->caps &
		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
		 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
		 MMC_CAP_UHS_DDR50);
}

static inline int mmc_host_packed_wr(struct mmc_host *host)
{
	return host->caps2 & MMC_CAP2_PACKED_WR;
}

#ifdef CONFIG_MMC_CLKGATE
void mmc_host_clk_hold(struct mmc_host *host);
void mmc_host_clk_release(struct mmc_host *host);
unsigned int mmc_host_clk_rate(struct mmc_host *host);

#else
static inline void mmc_host_clk_hold(struct mmc_host *host)
{
}

static inline void mmc_host_clk_release(struct mmc_host *host)
{
}

static inline unsigned int mmc_host_clk_rate(struct mmc_host *host)
{
	return host->ios.clock;
}
#endif

static inline int mmc_card_hs(struct mmc_card *card)
{
	return card->host->ios.timing == MMC_TIMING_SD_HS ||
		card->host->ios.timing == MMC_TIMING_MMC_HS;
}

static inline int mmc_card_uhs(struct mmc_card *card)
{
	return card->host->ios.timing >= MMC_TIMING_UHS_SDR12 &&
		card->host->ios.timing <= MMC_TIMING_UHS_DDR50;
}

static inline bool mmc_card_hs200(struct mmc_card *card)
{
	return card->host->ios.timing == MMC_TIMING_MMC_HS200;
}

static inline bool mmc_card_ddr52(struct mmc_card *card)
{
	return card->host->ios.timing == MMC_TIMING_MMC_DDR52;
}

static inline bool mmc_card_hs400(struct mmc_card *card)
{
	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
}

#endif /* LINUX_MMC_HOST_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 *  linux/include/linux/mmc/card.h
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 *  Card driver specific definitions.
 */
#ifndef LINUX_MMC_CARD_H
#define LINUX_MMC_CARD_H

#include <linux/device.h>
#include <linux/mmc/core.h>
#include <linux/mod_devicetable.h>

struct mmc_cid {
	unsigned int		manfid;
	char			prod_name[8];
	unsigned char		prv;
	unsigned int		serial;
	unsigned short		oemid;
	unsigned short		year;
	unsigned char		hwrev;
	unsigned char		fwrev;
	unsigned char		month;
};

struct mmc_csd {
	unsigned char		structure;
	unsigned char		mmca_vsn;
	unsigned short		cmdclass;
	unsigned short		tacc_clks;
	unsigned int		tacc_ns;
	unsigned int		c_size;
	unsigned int		r2w_factor;
	unsigned int		max_dtr;
	unsigned int		erase_size;		/* In sectors */
	unsigned int		read_blkbits;
	unsigned int		write_blkbits;
	unsigned int		capacity;
	unsigned int		read_partial:1,
				read_misalign:1,
				write_partial:1,
				write_misalign:1,
				dsr_imp:1;
};

struct mmc_ext_csd {
	u8			rev;
	u8			erase_group_def;
	u8			sec_feature_support;
	u8			rel_sectors;
	u8			rel_param;
	u8			part_config;
	u8			cache_ctrl;
	u8			rst_n_function;
	u8			max_packed_writes;
	u8			max_packed_reads;
	u8			packed_event_en;
	unsigned int		part_time;		/* Units: ms */
	unsigned int		sa_timeout;		/* Units: 100ns */
	unsigned int		generic_cmd6_time;	/* Units: 10ms */
	unsigned int            power_off_longtime;     /* Units: ms */
	u8			power_off_notification;	/* state */
	unsigned int		hs_max_dtr;
	unsigned int		hs200_max_dtr;
#define MMC_HIGH_26_MAX_DTR	26000000
#define MMC_HIGH_52_MAX_DTR	52000000
#define MMC_HIGH_DDR_MAX_DTR	52000000
#define MMC_HS200_MAX_DTR	200000000
	unsigned int		sectors;
	unsigned int		hc_erase_size;		/* In sectors */
	unsigned int		hc_erase_timeout;	/* In milliseconds */
	unsigned int		sec_trim_mult;	/* Secure trim multiplier  */
	unsigned int		sec_erase_mult;	/* Secure erase multiplier */
	unsigned int		trim_timeout;		/* In milliseconds */
	bool			partition_setting_completed;	/* enable bit */
	unsigned long long	enhanced_area_offset;	/* Units: Byte */
	unsigned int		enhanced_area_size;	/* Units: KB */
	unsigned int		cache_size;		/* Units: KB */
	bool			hpi_en;			/* HPI enablebit */
	bool			hpi;			/* HPI support bit */
	unsigned int		hpi_cmd;		/* cmd used as HPI */
	bool			bkops;		/* background support bit */
	bool			man_bkops_en;	/* manual bkops enable bit */
	unsigned int            data_sector_size;       /* 512 bytes or 4KB */
	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
	unsigned int		boot_ro_lock;		/* ro lock support */
	bool			boot_ro_lockable;
	bool			ffu_capable;	/* Firmware upgrade support */
#define MMC_FIRMWARE_LEN 8
	u8			fwrev[MMC_FIRMWARE_LEN];  /* FW version */
	u8			raw_exception_status;	/* 54 */
	u8			raw_partition_support;	/* 160 */
	u8			raw_rpmb_size_mult;	/* 168 */
	u8			raw_erased_mem_count;	/* 181 */
	u8			raw_ext_csd_structure;	/* 194 */
	u8			raw_card_type;		/* 196 */
	u8			out_of_int_time;	/* 198 */
	u8			raw_pwr_cl_52_195;	/* 200 */
	u8			raw_pwr_cl_26_195;	/* 201 */
	u8			raw_pwr_cl_52_360;	/* 202 */
	u8			raw_pwr_cl_26_360;	/* 203 */
	u8			raw_s_a_timeout;	/* 217 */
	u8			raw_hc_erase_gap_size;	/* 221 */
	u8			raw_erase_timeout_mult;	/* 223 */
	u8			raw_hc_erase_grp_size;	/* 224 */
	u8			raw_sec_trim_mult;	/* 229 */
	u8			raw_sec_erase_mult;	/* 230 */
	u8			raw_sec_feature_support;/* 231 */
	u8			raw_trim_mult;		/* 232 */
	u8			raw_pwr_cl_200_195;	/* 236 */
	u8			raw_pwr_cl_200_360;	/* 237 */
	u8			raw_pwr_cl_ddr_52_195;	/* 238 */
	u8			raw_pwr_cl_ddr_52_360;	/* 239 */
	u8			raw_pwr_cl_ddr_200_360;	/* 253 */
	u8			raw_bkops_status;	/* 246 */
	u8			raw_sectors[4];		/* 212 - 4 bytes */

	unsigned int            feature_support;
#define MMC_DISCARD_FEATURE	BIT(0)                  /* CMD38 feature */
};

struct sd_scr {
	unsigned char		sda_vsn;
	unsigned char		sda_spec3;
	unsigned char		bus_widths;
#define SD_SCR_BUS_WIDTH_1	(1<<0)
#define SD_SCR_BUS_WIDTH_4	(1<<2)
	unsigned char		cmds;
#define SD_SCR_CMD20_SUPPORT   (1<<0)
#define SD_SCR_CMD23_SUPPORT   (1<<1)
};

struct sd_ssr {
	unsigned int		au;			/* In sectors */
	unsigned int		erase_timeout;		/* In milliseconds */
	unsigned int		erase_offset;		/* In milliseconds */
};

struct sd_switch_caps {
	unsigned int		hs_max_dtr;
	unsigned int		uhs_max_dtr;
#define HIGH_SPEED_MAX_DTR	50000000
#define UHS_SDR104_MAX_DTR	208000000
#define UHS_SDR50_MAX_DTR	100000000
#define UHS_DDR50_MAX_DTR	50000000
#define UHS_SDR25_MAX_DTR	UHS_DDR50_MAX_DTR
#define UHS_SDR12_MAX_DTR	25000000
	unsigned int		sd3_bus_mode;
#define UHS_SDR12_BUS_SPEED	0
#define HIGH_SPEED_BUS_SPEED	1
#define UHS_SDR25_BUS_SPEED	1
#define UHS_SDR50_BUS_SPEED	2
#define UHS_SDR104_BUS_SPEED	3
#define UHS_DDR50_BUS_SPEED	4

#define SD_MODE_HIGH_SPEED	(1 << HIGH_SPEED_BUS_SPEED)
#define SD_MODE_UHS_SDR12	(1 << UHS_SDR12_BUS_SPEED)
#define SD_MODE_UHS_SDR25	(1 << UHS_SDR25_BUS_SPEED)
#define SD_MODE_UHS_SDR50	(1 << UHS_SDR50_BUS_SPEED)
#define SD_MODE_UHS_SDR104	(1 << UHS_SDR104_BUS_SPEED)
#define SD_MODE_UHS_DDR50	(1 << UHS_DDR50_BUS_SPEED)
	unsigned int		sd3_drv_type;
#define SD_DRIVER_TYPE_B	0x01
#define SD_DRIVER_TYPE_A	0x02
#define SD_DRIVER_TYPE_C	0x04
#define SD_DRIVER_TYPE_D	0x08
	unsigned int		sd3_curr_limit;
#define SD_SET_CURRENT_LIMIT_200	0
#define SD_SET_CURRENT_LIMIT_400	1
#define SD_SET_CURRENT_LIMIT_600	2
#define SD_SET_CURRENT_LIMIT_800	3
#define SD_SET_CURRENT_NO_CHANGE	(-1)

#define SD_MAX_CURRENT_200	(1 << SD_SET_CURRENT_LIMIT_200)
#define SD_MAX_CURRENT_400	(1 << SD_SET_CURRENT_LIMIT_400)
#define SD_MAX_CURRENT_600	(1 << SD_SET_CURRENT_LIMIT_600)
#define SD_MAX_CURRENT_800	(1 << SD_SET_CURRENT_LIMIT_800)
};

struct sdio_cccr {
	unsigned int		sdio_vsn;
	unsigned int		sd_vsn;
	unsigned int		multi_block:1,
				low_speed:1,
				wide_bus:1,
				high_power:1,
				high_speed:1,
				disable_cd:1;
};

struct sdio_cis {
	unsigned short		vendor;
	unsigned short		device;
	unsigned short		blksize;
	unsigned int		max_dtr;
};

struct mmc_host;
struct mmc_ios;
struct sdio_func;
struct sdio_func_tuple;

#define SDIO_MAX_FUNCS		7

enum mmc_blk_status {
	MMC_BLK_SUCCESS = 0,
	MMC_BLK_PARTIAL,
	MMC_BLK_CMD_ERR,
	MMC_BLK_RETRY,
	MMC_BLK_ABORT,
	MMC_BLK_DATA_ERR,
	MMC_BLK_ECC_ERR,
	MMC_BLK_NOMEDIUM,
	MMC_BLK_NEW_REQUEST,
};

/* The number of MMC physical partitions.  These consist of:
 * boot partitions (2), general purpose partitions (4) and
 * RPMB partition (1) in MMC v4.4.
 */
#define MMC_NUM_BOOT_PARTITION	2
#define MMC_NUM_GP_PARTITION	4
#define MMC_NUM_PHY_PARTITION	7
#define MAX_MMC_PART_NAME_LEN	20

/*
 * MMC Physical partitions
 */
struct mmc_part {
	unsigned int	size;	/* partition size (in bytes) */
	unsigned int	part_cfg;	/* partition type */
	char	name[MAX_MMC_PART_NAME_LEN];
	bool	force_ro;	/* to make boot parts RO by default */
	unsigned int	area_type;
#define MMC_BLK_DATA_AREA_MAIN	(1<<0)
#define MMC_BLK_DATA_AREA_BOOT	(1<<1)
#define MMC_BLK_DATA_AREA_GP	(1<<2)
#define MMC_BLK_DATA_AREA_RPMB	(1<<3)
};

/*
 * MMC device
 */
struct mmc_card {
	struct mmc_host		*host;		/* the host this device belongs to */
	struct device		dev;		/* the device */
	u32			ocr;		/* the current OCR setting */
	unsigned int		rca;		/* relative card address of device */
	unsigned int		type;		/* card type */
#define MMC_TYPE_MMC		0		/* MMC card */
#define MMC_TYPE_SD		1		/* SD card */
#define MMC_TYPE_SDIO		2		/* SDIO card */
#define MMC_TYPE_SD_COMBO	3		/* SD combo (IO+mem) card */
	unsigned int		state;		/* (our) card state */
#define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
#define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
#define MMC_STATE_BLOCKADDR	(1<<2)		/* card uses block-addressing */
#define MMC_CARD_SDXC		(1<<3)		/* card is SDXC */
#define MMC_CARD_REMOVED	(1<<4)		/* card has been removed */
#define MMC_STATE_DOING_BKOPS	(1<<5)		/* card is doing BKOPS */
#define MMC_STATE_SUSPENDED	(1<<6)		/* card is suspended */
	unsigned int		quirks; 	/* card quirks */
#define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
#define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
						/* for byte mode */
#define MMC_QUIRK_NONSTD_SDIO	(1<<2)		/* non-standard SDIO card attached */
						/* (missing CIA registers) */
#define MMC_QUIRK_BROKEN_CLK_GATING (1<<3)	/* clock gating the sdio bus will make card fail */
#define MMC_QUIRK_NONSTD_FUNC_IF (1<<4)		/* SDIO card has nonstd function interfaces */
#define MMC_QUIRK_DISABLE_CD	(1<<5)		/* disconnect CD/DAT[3] resistor */
#define MMC_QUIRK_INAND_CMD38	(1<<6)		/* iNAND devices have broken CMD38 */
#define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
#define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)	/* Avoid sending 512 bytes in */
						/* byte mode */
#define MMC_QUIRK_LONG_READ_TIME (1<<9)		/* Data read time > CSD says */
#define MMC_QUIRK_SEC_ERASE_TRIM_BROKEN (1<<10)	/* Skip secure for erase/trim */
#define MMC_QUIRK_BROKEN_IRQ_POLLING	(1<<11)	/* Polling SDIO_CCCR_INTx could create a fake interrupt */

	unsigned int		erase_size;	/* erase size in sectors */
 	unsigned int		erase_shift;	/* if erase unit is power 2 */
 	unsigned int		pref_erase;	/* in sectors */
 	u8			erased_byte;	/* value of erased bytes */

	u32			raw_cid[4];	/* raw card CID */
	u32			raw_csd[4];	/* raw card CSD */
	u32			raw_scr[2];	/* raw card SCR */
	struct mmc_cid		cid;		/* card identification */
	struct mmc_csd		csd;		/* card specific */
	struct mmc_ext_csd	ext_csd;	/* mmc v4 extended card specific */
	struct sd_scr		scr;		/* extra SD information */
	struct sd_ssr		ssr;		/* yet more SD information */
	struct sd_switch_caps	sw_caps;	/* switch (CMD6) caps */

	unsigned int		sdio_funcs;	/* number of SDIO functions */
	struct sdio_cccr	cccr;		/* common card info */
	struct sdio_cis		cis;		/* common tuple info */
	struct sdio_func	*sdio_func[SDIO_MAX_FUNCS]; /* SDIO functions (devices) */
	struct sdio_func	*sdio_single_irq; /* SDIO function when only one IRQ active */
	unsigned		num_info;	/* number of info strings */
	const char		**info;		/* info strings */
	struct sdio_func_tuple	*tuples;	/* unknown common tuples */

	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
	unsigned int		mmc_avail_type;	/* supported device type by both host and card */

	struct dentry		*debugfs_root;
	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
	unsigned int    nr_parts;
};

/*
 * This function fill contents in mmc_part.
 */
static inline void mmc_part_add(struct mmc_card *card, unsigned int size,
			unsigned int part_cfg, char *name, int idx, bool ro,
			int area_type)
{
	card->part[card->nr_parts].size = size;
	card->part[card->nr_parts].part_cfg = part_cfg;
	sprintf(card->part[card->nr_parts].name, name, idx);
	card->part[card->nr_parts].force_ro = ro;
	card->part[card->nr_parts].area_type = area_type;
	card->nr_parts++;
}

static inline bool mmc_large_sector(struct mmc_card *card)
{
	return card->ext_csd.data_sector_size == 4096;
}

/*
 *  The world is not perfect and supplies us with broken mmc/sdio devices.
 *  For at least some of these bugs we need a work-around.
 */

struct mmc_fixup {
	/* CID-specific fields. */
	const char *name;

	/* Valid revision range */
	u64 rev_start, rev_end;

	unsigned int manfid;
	unsigned short oemid;

	/* SDIO-specfic fields. You can use SDIO_ANY_ID here of course */
	u16 cis_vendor, cis_device;

	void (*vendor_fixup)(struct mmc_card *card, int data);
	int data;
};

#define CID_MANFID_ANY (-1u)
#define CID_OEMID_ANY ((unsigned short) -1)
#define CID_NAME_ANY (NULL)

#define END_FIXUP { NULL }

#define _FIXUP_EXT(_name, _manfid, _oemid, _rev_start, _rev_end,	\
		   _cis_vendor, _cis_device,				\
		   _fixup, _data)					\
	{						   \
		.name = (_name),			   \
		.manfid = (_manfid),			   \
		.oemid = (_oemid),			   \
		.rev_start = (_rev_start),		   \
		.rev_end = (_rev_end),			   \
		.cis_vendor = (_cis_vendor),		   \
		.cis_device = (_cis_device),		   \
		.vendor_fixup = (_fixup),		   \
		.data = (_data),			   \
	 }

#define MMC_FIXUP_REV(_name, _manfid, _oemid, _rev_start, _rev_end,	\
		      _fixup, _data)					\
	_FIXUP_EXT(_name, _manfid,					\
		   _oemid, _rev_start, _rev_end,			\
		   SDIO_ANY_ID, SDIO_ANY_ID,				\
		   _fixup, _data)					\

#define MMC_FIXUP(_name, _manfid, _oemid, _fixup, _data) \
	MMC_FIXUP_REV(_name, _manfid, _oemid, 0, -1ull, _fixup, _data)

#define SDIO_FIXUP(_vendor, _device, _fixup, _data)			\
	_FIXUP_EXT(CID_NAME_ANY, CID_MANFID_ANY,			\
		    CID_OEMID_ANY, 0, -1ull,				\
		   _vendor, _device,					\
		   _fixup, _data)					\

#define cid_rev(hwrev, fwrev, year, month)	\
	(((u64) hwrev) << 40 |                  \
	 ((u64) fwrev) << 32 |                  \
	 ((u64) year) << 16 |                   \
	 ((u64) month))

#define cid_rev_card(card)		  \
	cid_rev(card->cid.hwrev,	  \
		    card->cid.fwrev,      \
		    card->cid.year,	  \
		    card->cid.month)

/*
 * Unconditionally quirk add/remove.
 */

static inline void __maybe_unused add_quirk(struct mmc_card *card, int data)
{
	card->quirks |= data;
}

static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
{
	card->quirks &= ~data;
}

#define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)
#define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
#define mmc_card_sdio(c)	((c)->type == MMC_TYPE_SDIO)

#define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
#define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
#define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
#define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
#define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
#define mmc_card_doing_bkops(c)	((c)->state & MMC_STATE_DOING_BKOPS)
#define mmc_card_suspended(c)	((c)->state & MMC_STATE_SUSPENDED)

#define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
#define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
#define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
#define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
#define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
#define mmc_card_set_doing_bkops(c)	((c)->state |= MMC_STATE_DOING_BKOPS)
#define mmc_card_clr_doing_bkops(c)	((c)->state &= ~MMC_STATE_DOING_BKOPS)
#define mmc_card_set_suspended(c) ((c)->state |= MMC_STATE_SUSPENDED)
#define mmc_card_clr_suspended(c) ((c)->state &= ~MMC_STATE_SUSPENDED)

/*
 * Quirk add/remove for MMC products.
 */

static inline void __maybe_unused add_quirk_mmc(struct mmc_card *card, int data)
{
	if (mmc_card_mmc(card))
		card->quirks |= data;
}

static inline void __maybe_unused remove_quirk_mmc(struct mmc_card *card,
						   int data)
{
	if (mmc_card_mmc(card))
		card->quirks &= ~data;
}

/*
 * Quirk add/remove for SD products.
 */

static inline void __maybe_unused add_quirk_sd(struct mmc_card *card, int data)
{
	if (mmc_card_sd(card))
		card->quirks |= data;
}

static inline void __maybe_unused remove_quirk_sd(struct mmc_card *card,
						   int data)
{
	if (mmc_card_sd(card))
		card->quirks &= ~data;
}

static inline int mmc_card_lenient_fn0(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_LENIENT_FN0;
}

static inline int mmc_blksz_for_byte_mode(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
}

static inline int mmc_card_disable_cd(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_DISABLE_CD;
}

static inline int mmc_card_nonstd_func_interface(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_NONSTD_FUNC_IF;
}

static inline int mmc_card_broken_byte_mode_512(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_BROKEN_BYTE_MODE_512;
}

static inline int mmc_card_long_read_time(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_LONG_READ_TIME;
}

static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
{
	return c->quirks & MMC_QUIRK_BROKEN_IRQ_POLLING;
}

#define mmc_card_name(c)	((c)->cid.prod_name)
#define mmc_card_id(c)		(dev_name(&(c)->dev))

#define mmc_dev_to_card(d)	container_of(d, struct mmc_card, dev)

/*
 * MMC device driver (e.g., Flash card, I/O card...)
 */
struct mmc_driver {
	struct device_driver drv;
	int (*probe)(struct mmc_card *);
	void (*remove)(struct mmc_card *);
	void (*shutdown)(struct mmc_card *);
};

extern int mmc_register_driver(struct mmc_driver *);
extern void mmc_unregister_driver(struct mmc_driver *);

extern void mmc_fixup_device(struct mmc_card *card,
			     const struct mmc_fixup *table);

#endif /* LINUX_MMC_CARD_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * Header for MultiMediaCard (MMC)
 *
 * Copyright 2002 Hewlett-Packard Company
 *
 * Use consistent with the GNU GPL is permitted,
 * provided that this copyright notice is
 * preserved in its entirety in all copies and derived works.
 *
 * HEWLETT-PACKARD COMPANY MAKES NO WARRANTIES, EXPRESSED OR IMPLIED,
 * AS TO THE USEFULNESS OR CORRECTNESS OF THIS CODE OR ITS
 * FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 * Many thanks to Alessandro Rubini and Jonathan Corbet!
 *
 * Based strongly on code by:
 *
 * Author: Yong-iL Joh <tolkien@mizi.com>
 *
 * Author:  Andrew Christian
 *          15 May 2002
 */

#ifndef LINUX_MMC_MMC_H
#define LINUX_MMC_MMC_H

/* Standard MMC commands (4.1)           type  argument     response */
   /* class 1 */
#define MMC_GO_IDLE_STATE         0   /* bc                          */
#define MMC_SEND_OP_COND          1   /* bcr  [31:0] OCR         R3  */
#define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
#define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
#define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
#define MMC_SLEEP_AWAKE		  5   /* ac   [31:16] RCA 15:flg R1b */
#define MMC_SWITCH                6   /* ac   [31:0] See below   R1b */
#define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
#define MMC_SEND_EXT_CSD          8   /* adtc                    R1  */
#define MMC_SEND_CSD              9   /* ac   [31:16] RCA        R2  */
#define MMC_SEND_CID             10   /* ac   [31:16] RCA        R2  */
#define MMC_READ_DAT_UNTIL_STOP  11   /* adtc [31:0] dadr        R1  */
#define MMC_STOP_TRANSMISSION    12   /* ac                      R1b */
#define MMC_SEND_STATUS          13   /* ac   [31:16] RCA        R1  */
#define MMC_BUS_TEST_R           14   /* adtc                    R1  */
#define MMC_GO_INACTIVE_STATE    15   /* ac   [31:16] RCA            */
#define MMC_BUS_TEST_W           19   /* adtc                    R1  */
#define MMC_SPI_READ_OCR         58   /* spi                  spi_R3 */
#define MMC_SPI_CRC_ON_OFF       59   /* spi  [0:0] flag      spi_R1 */

  /* class 2 */
#define MMC_SET_BLOCKLEN         16   /* ac   [31:0] block len   R1  */
#define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0] data addr   R1  */
#define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0] data addr   R1  */
#define MMC_SEND_TUNING_BLOCK    19   /* adtc                    R1  */
#define MMC_SEND_TUNING_BLOCK_HS200	21	/* adtc R1  */

  /* class 3 */
#define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */

  /* class 4 */
#define MMC_SET_BLOCK_COUNT      23   /* adtc [31:0] data addr   R1  */
#define MMC_WRITE_BLOCK          24   /* adtc [31:0] data addr   R1  */
#define MMC_WRITE_MULTIPLE_BLOCK 25   /* adtc                    R1  */
#define MMC_PROGRAM_CID          26   /* adtc                    R1  */
#define MMC_PROGRAM_CSD          27   /* adtc                    R1  */

  /* class 6 */
#define MMC_SET_WRITE_PROT       28   /* ac   [31:0] data addr   R1b */
#define MMC_CLR_WRITE_PROT       29   /* ac   [31:0] data addr   R1b */
#define MMC_SEND_WRITE_PROT      30   /* adtc [31:0] wpdata addr R1  */

  /* class 5 */
#define MMC_ERASE_GROUP_START    35   /* ac   [31:0] data addr   R1  */
#define MMC_ERASE_GROUP_END      36   /* ac   [31:0] data addr   R1  */
#define MMC_ERASE                38   /* ac                      R1b */

  /* class 9 */
#define MMC_FAST_IO              39   /* ac   <Complex>          R4  */
#define MMC_GO_IRQ_STATE         40   /* bcr                     R5  */

  /* class 7 */
#define MMC_LOCK_UNLOCK          42   /* adtc                    R1b */

  /* class 8 */
#define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
#define MMC_GEN_CMD              56   /* adtc [0] RD/WR          R1  */

static inline bool mmc_op_multi(u32 opcode)
{
	return opcode == MMC_WRITE_MULTIPLE_BLOCK ||
	       opcode == MMC_READ_MULTIPLE_BLOCK;
}

/*
 * MMC_SWITCH argument format:
 *
 *	[31:26] Always 0
 *	[25:24] Access Mode
 *	[23:16] Location of target Byte in EXT_CSD
 *	[15:08] Value Byte
 *	[07:03] Always 0
 *	[02:00] Command Set
 */

/*
  MMC status in R1, for native mode (SPI bits are different)
  Type
	e : error bit
	s : status bit
	r : detected and set for the actual command response
	x : detected and set during command execution. the host must poll
            the card by sending status command in order to read these bits.
  Clear condition
	a : according to the card state
	b : always related to the previous command. Reception of
            a valid command will clear it (with a delay of one command)
	c : clear by read
 */

#define R1_OUT_OF_RANGE		(1 << 31)	/* er, c */
#define R1_ADDRESS_ERROR	(1 << 30)	/* erx, c */
#define R1_BLOCK_LEN_ERROR	(1 << 29)	/* er, c */
#define R1_ERASE_SEQ_ERROR      (1 << 28)	/* er, c */
#define R1_ERASE_PARAM		(1 << 27)	/* ex, c */
#define R1_WP_VIOLATION		(1 << 26)	/* erx, c */
#define R1_CARD_IS_LOCKED	(1 << 25)	/* sx, a */
#define R1_LOCK_UNLOCK_FAILED	(1 << 24)	/* erx, c */
#define R1_COM_CRC_ERROR	(1 << 23)	/* er, b */
#define R1_ILLEGAL_COMMAND	(1 << 22)	/* er, b */
#define R1_CARD_ECC_FAILED	(1 << 21)	/* ex, c */
#define R1_CC_ERROR		(1 << 20)	/* erx, c */
#define R1_ERROR		(1 << 19)	/* erx, c */
#define R1_UNDERRUN		(1 << 18)	/* ex, c */
#define R1_OVERRUN		(1 << 17)	/* ex, c */
#define R1_CID_CSD_OVERWRITE	(1 << 16)	/* erx, c, CID/CSD overwrite */
#define R1_WP_ERASE_SKIP	(1 << 15)	/* sx, c */
#define R1_CARD_ECC_DISABLED	(1 << 14)	/* sx, a */
#define R1_ERASE_RESET		(1 << 13)	/* sr, c */
#define R1_STATUS(x)            (x & 0xFFFFE000)
#define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
#define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
#define R1_SWITCH_ERROR		(1 << 7)	/* sx, c */
#define R1_EXCEPTION_EVENT	(1 << 6)	/* sr, a */
#define R1_APP_CMD		(1 << 5)	/* sr, c */

#define R1_STATE_IDLE	0
#define R1_STATE_READY	1
#define R1_STATE_IDENT	2
#define R1_STATE_STBY	3
#define R1_STATE_TRAN	4
#define R1_STATE_DATA	5
#define R1_STATE_RCV	6
#define R1_STATE_PRG	7
#define R1_STATE_DIS	8

/*
 * MMC/SD in SPI mode reports R1 status always, and R2 for SEND_STATUS
 * R1 is the low order byte; R2 is the next highest byte, when present.
 */
#define R1_SPI_IDLE		(1 << 0)
#define R1_SPI_ERASE_RESET	(1 << 1)
#define R1_SPI_ILLEGAL_COMMAND	(1 << 2)
#define R1_SPI_COM_CRC		(1 << 3)
#define R1_SPI_ERASE_SEQ	(1 << 4)
#define R1_SPI_ADDRESS		(1 << 5)
#define R1_SPI_PARAMETER	(1 << 6)
/* R1 bit 7 is always zero */
#define R2_SPI_CARD_LOCKED	(1 << 8)
#define R2_SPI_WP_ERASE_SKIP	(1 << 9)	/* or lock/unlock fail */
#define R2_SPI_LOCK_UNLOCK_FAIL	R2_SPI_WP_ERASE_SKIP
#define R2_SPI_ERROR		(1 << 10)
#define R2_SPI_CC_ERROR		(1 << 11)
#define R2_SPI_CARD_ECC_ERROR	(1 << 12)
#define R2_SPI_WP_VIOLATION	(1 << 13)
#define R2_SPI_ERASE_PARAM	(1 << 14)
#define R2_SPI_OUT_OF_RANGE	(1 << 15)	/* or CSD overwrite */
#define R2_SPI_CSD_OVERWRITE	R2_SPI_OUT_OF_RANGE

/* These are unpacked versions of the actual responses */

struct _mmc_csd {
	u8  csd_structure;
	u8  spec_vers;
	u8  taac;
	u8  nsac;
	u8  tran_speed;
	u16 ccc;
	u8  read_bl_len;
	u8  read_bl_partial;
	u8  write_blk_misalign;
	u8  read_blk_misalign;
	u8  dsr_imp;
	u16 c_size;
	u8  vdd_r_curr_min;
	u8  vdd_r_curr_max;
	u8  vdd_w_curr_min;
	u8  vdd_w_curr_max;
	u8  c_size_mult;
	union {
		struct { /* MMC system specification version 3.1 */
			u8  erase_grp_size;
			u8  erase_grp_mult;
		} v31;
		struct { /* MMC system specification version 2.2 */
			u8  sector_size;
			u8  erase_grp_size;
		} v22;
	} erase;
	u8  wp_grp_size;
	u8  wp_grp_enable;
	u8  default_ecc;
	u8  r2w_factor;
	u8  write_bl_len;
	u8  write_bl_partial;
	u8  file_format_grp;
	u8  copy;
	u8  perm_write_protect;
	u8  tmp_write_protect;
	u8  file_format;
	u8  ecc;
};

/*
 * OCR bits are mostly in host.h
 */
#define MMC_CARD_BUSY	0x80000000	/* Card Power up status bit */

/*
 * Card Command Classes (CCC)
 */
#define CCC_BASIC		(1<<0)	/* (0) Basic protocol functions */
					/* (CMD0,1,2,3,4,7,9,10,12,13,15) */
					/* (and for SPI, CMD58,59) */
#define CCC_STREAM_READ		(1<<1)	/* (1) Stream read commands */
					/* (CMD11) */
#define CCC_BLOCK_READ		(1<<2)	/* (2) Block read commands */
					/* (CMD16,17,18) */
#define CCC_STREAM_WRITE	(1<<3)	/* (3) Stream write commands */
					/* (CMD20) */
#define CCC_BLOCK_WRITE		(1<<4)	/* (4) Block write commands */
					/* (CMD16,24,25,26,27) */
#define CCC_ERASE		(1<<5)	/* (5) Ability to erase blocks */
					/* (CMD32,33,34,35,36,37,38,39) */
#define CCC_WRITE_PROT		(1<<6)	/* (6) Able to write protect blocks */
					/* (CMD28,29,30) */
#define CCC_LOCK_CARD		(1<<7)	/* (7) Able to lock down card */
					/* (CMD16,CMD42) */
#define CCC_APP_SPEC		(1<<8)	/* (8) Application specific */
					/* (CMD55,56,57,ACMD*) */
#define CCC_IO_MODE		(1<<9)	/* (9) I/O mode */
					/* (CMD5,39,40,52,53) */
#define CCC_SWITCH		(1<<10)	/* (10) High speed switch */
					/* (CMD6,34,35,36,37,50) */
					/* (11) Reserved */
					/* (CMD?) */

/*
 * CSD field definitions
 */

#define CSD_STRUCT_VER_1_0  0           /* Valid for system specification 1.0 - 1.2 */
#define CSD_STRUCT_VER_1_1  1           /* Valid for system specification 1.4 - 2.2 */
#define CSD_STRUCT_VER_1_2  2           /* Valid for system specification 3.1 - 3.2 - 3.31 - 4.0 - 4.1 */
#define CSD_STRUCT_EXT_CSD  3           /* Version is coded in CSD_STRUCTURE in EXT_CSD */

#define CSD_SPEC_VER_0      0           /* Implements system specification 1.0 - 1.2 */
#define CSD_SPEC_VER_1      1           /* Implements system specification 1.4 */
#define CSD_SPEC_VER_2      2           /* Implements system specification 2.0 - 2.2 */
#define CSD_SPEC_VER_3      3           /* Implements system specification 3.1 - 3.2 - 3.31 */
#define CSD_SPEC_VER_4      4           /* Implements system specification 4.0 - 4.1 */

/*
 * EXT_CSD fields
 */

#define EXT_CSD_FLUSH_CACHE		32      /* W */
#define EXT_CSD_CACHE_CTRL		33      /* R/W */
#define EXT_CSD_POWER_OFF_NOTIFICATION	34	/* R/W */
#define EXT_CSD_PACKED_FAILURE_INDEX	35	/* RO */
#define EXT_CSD_PACKED_CMD_STATUS	36	/* RO */
#define EXT_CSD_EXP_EVENTS_STATUS	54	/* RO, 2 bytes */
#define EXT_CSD_EXP_EVENTS_CTRL		56	/* R/W, 2 bytes */
#define EXT_CSD_DATA_SECTOR_SIZE	61	/* R */
#define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
#define EXT_CSD_PARTITION_SETTING_COMPLETED 155	/* R/W */
#define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
#define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
#define EXT_CSD_HPI_MGMT		161	/* R/W */
#define EXT_CSD_RST_N_FUNCTION		162	/* R/W */
#define EXT_CSD_BKOPS_EN		163	/* R/W */
#define EXT_CSD_BKOPS_START		164	/* W */
#define EXT_CSD_SANITIZE_START		165     /* W */
#define EXT_CSD_WR_REL_PARAM		166	/* RO */
#define EXT_CSD_RPMB_MULT		168	/* RO */
#define EXT_CSD_FW_CONFIG		169	/* R/W */
#define EXT_CSD_BOOT_WP			173	/* R/W */
#define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
#define EXT_CSD_PART_CONFIG		179	/* R/W */
#define EXT_CSD_ERASED_MEM_CONT		181	/* RO */
#define EXT_CSD_BUS_WIDTH		183	/* R/W */
#define EXT_CSD_HS_TIMING		185	/* R/W */
#define EXT_CSD_POWER_CLASS		187	/* R/W */
#define EXT_CSD_REV			192	/* RO */
#define EXT_CSD_STRUCTURE		194	/* RO */
#define EXT_CSD_CARD_TYPE		196	/* RO */
#define EXT_CSD_OUT_OF_INTERRUPT_TIME	198	/* RO */
#define EXT_CSD_PART_SWITCH_TIME        199     /* RO */
#define EXT_CSD_PWR_CL_52_195		200	/* RO */
#define EXT_CSD_PWR_CL_26_195		201	/* RO */
#define EXT_CSD_PWR_CL_52_360		202	/* RO */
#define EXT_CSD_PWR_CL_26_360		203	/* RO */
#define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
#define EXT_CSD_S_A_TIMEOUT		217	/* RO */
#define EXT_CSD_REL_WR_SEC_C		222	/* RO */
#define EXT_CSD_HC_WP_GRP_SIZE		221	/* RO */
#define EXT_CSD_ERASE_TIMEOUT_MULT	223	/* RO */
#define EXT_CSD_HC_ERASE_GRP_SIZE	224	/* RO */
#define EXT_CSD_BOOT_MULT		226	/* RO */
#define EXT_CSD_SEC_TRIM_MULT		229	/* RO */
#define EXT_CSD_SEC_ERASE_MULT		230	/* RO */
#define EXT_CSD_SEC_FEATURE_SUPPORT	231	/* RO */
#define EXT_CSD_TRIM_MULT		232	/* RO */
#define EXT_CSD_PWR_CL_200_195		236	/* RO */
#define EXT_CSD_PWR_CL_200_360		237	/* RO */
#define EXT_CSD_PWR_CL_DDR_52_195	238	/* RO */
#define EXT_CSD_PWR_CL_DDR_52_360	239	/* RO */
#define EXT_CSD_BKOPS_STATUS		246	/* RO */
#define EXT_CSD_POWER_OFF_LONG_TIME	247	/* RO */
#define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
#define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
#define EXT_CSD_PWR_CL_DDR_200_360	253	/* RO */
#define EXT_CSD_FIRMWARE_VERSION	254	/* RO, 8 bytes */
#define EXT_CSD_SUPPORTED_MODE		493	/* RO */
#define EXT_CSD_TAG_UNIT_SIZE		498	/* RO */
#define EXT_CSD_DATA_TAG_SUPPORT	499	/* RO */
#define EXT_CSD_MAX_PACKED_WRITES	500	/* RO */
#define EXT_CSD_MAX_PACKED_READS	501	/* RO */
#define EXT_CSD_BKOPS_SUPPORT		502	/* RO */
#define EXT_CSD_HPI_FEATURES		503	/* RO */

/*
 * EXT_CSD field definitions
 */

#define EXT_CSD_WR_REL_PARAM_EN		(1<<2)

#define EXT_CSD_BOOT_WP_B_PWR_WP_DIS	(0x40)
#define EXT_CSD_BOOT_WP_B_PERM_WP_DIS	(0x10)
#define EXT_CSD_BOOT_WP_B_PERM_WP_EN	(0x04)
#define EXT_CSD_BOOT_WP_B_PWR_WP_EN	(0x01)

#define EXT_CSD_PART_CONFIG_ACC_MASK	(0x7)
#define EXT_CSD_PART_CONFIG_ACC_BOOT0	(0x1)
#define EXT_CSD_PART_CONFIG_ACC_RPMB	(0x3)
#define EXT_CSD_PART_CONFIG_ACC_GP0	(0x4)

#define EXT_CSD_PART_SETTING_COMPLETED	(0x1)
#define EXT_CSD_PART_SUPPORT_PART_EN	(0x1)

#define EXT_CSD_CMD_SET_NORMAL		(1<<0)
#define EXT_CSD_CMD_SET_SECURE		(1<<1)
#define EXT_CSD_CMD_SET_CPSECURE	(1<<2)

#define EXT_CSD_CARD_TYPE_HS_26	(1<<0)	/* Card can run at 26MHz */
#define EXT_CSD_CARD_TYPE_HS_52	(1<<1)	/* Card can run at 52MHz */
#define EXT_CSD_CARD_TYPE_HS	(EXT_CSD_CARD_TYPE_HS_26 | \
				 EXT_CSD_CARD_TYPE_HS_52)
#define EXT_CSD_CARD_TYPE_DDR_1_8V  (1<<2)   /* Card can run at 52MHz */
					     /* DDR mode @1.8V or 3V I/O */
#define EXT_CSD_CARD_TYPE_DDR_1_2V  (1<<3)   /* Card can run at 52MHz */
					     /* DDR mode @1.2V I/O */
#define EXT_CSD_CARD_TYPE_DDR_52       (EXT_CSD_CARD_TYPE_DDR_1_8V  \
					| EXT_CSD_CARD_TYPE_DDR_1_2V)
#define EXT_CSD_CARD_TYPE_HS200_1_8V	(1<<4)	/* Card can run at 200MHz */
#define EXT_CSD_CARD_TYPE_HS200_1_2V	(1<<5)	/* Card can run at 200MHz */
						/* SDR mode @1.2V I/O */
#define EXT_CSD_CARD_TYPE_HS200		(EXT_CSD_CARD_TYPE_HS200_1_8V | \
					 EXT_CSD_CARD_TYPE_HS200_1_2V)
#define EXT_CSD_CARD_TYPE_HS400_1_8V	(1<<6)	/* Card can run at 200MHz DDR, 1.8V */
#define EXT_CSD_CARD_TYPE_HS400_1_2V	(1<<7)	/* Card can run at 200MHz DDR, 1.2V */
#define EXT_CSD_CARD_TYPE_HS400		(EXT_CSD_CARD_TYPE_HS400_1_8V | \
					 EXT_CSD_CARD_TYPE_HS400_1_2V)

#define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
#define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
#define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
#define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
#define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */

#define EXT_CSD_TIMING_BC	0	/* Backwards compatility */
#define EXT_CSD_TIMING_HS	1	/* High speed */
#define EXT_CSD_TIMING_HS200	2	/* HS200 */
#define EXT_CSD_TIMING_HS400	3	/* HS400 */

#define EXT_CSD_SEC_ER_EN	BIT(0)
#define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
#define EXT_CSD_SEC_GB_CL_EN	BIT(4)
#define EXT_CSD_SEC_SANITIZE	BIT(6)  /* v4.5 only */

#define EXT_CSD_RST_N_EN_MASK	0x3
#define EXT_CSD_RST_N_ENABLED	1	/* RST_n is enabled on card */

#define EXT_CSD_NO_POWER_NOTIFICATION	0
#define EXT_CSD_POWER_ON		1
#define EXT_CSD_POWER_OFF_SHORT		2
#define EXT_CSD_POWER_OFF_LONG		3

#define EXT_CSD_PWR_CL_8BIT_MASK	0xF0	/* 8 bit PWR CLS */
#define EXT_CSD_PWR_CL_4BIT_MASK	0x0F	/* 8 bit PWR CLS */
#define EXT_CSD_PWR_CL_8BIT_SHIFT	4
#define EXT_CSD_PWR_CL_4BIT_SHIFT	0

#define EXT_CSD_PACKED_EVENT_EN	BIT(3)

/*
 * EXCEPTION_EVENT_STATUS field
 */
#define EXT_CSD_URGENT_BKOPS		BIT(0)
#define EXT_CSD_DYNCAP_NEEDED		BIT(1)
#define EXT_CSD_SYSPOOL_EXHAUSTED	BIT(2)
#define EXT_CSD_PACKED_FAILURE		BIT(3)

#define EXT_CSD_PACKED_GENERIC_ERROR	BIT(0)
#define EXT_CSD_PACKED_INDEXED_ERROR	BIT(1)

/*
 * BKOPS status level
 */
#define EXT_CSD_BKOPS_LEVEL_2		0x2

/*
 * BKOPS modes
 */
#define EXT_CSD_MANUAL_BKOPS_MASK	0x01

/*
 * MMC_SWITCH access modes
 */

#define MMC_SWITCH_MODE_CMD_SET		0x00	/* Change the command set */
#define MMC_SWITCH_MODE_SET_BITS	0x01	/* Set bits which are 1 in value */
#define MMC_SWITCH_MODE_CLEAR_BITS	0x02	/* Clear bits which are 1 in value */
#define MMC_SWITCH_MODE_WRITE_BYTE	0x03	/* Set target to value */

#endif /* LINUX_MMC_MMC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * Synopsys DesignWare Multimedia Card Interface driver
 *  (Based on NXP driver for lpc 31xx)
 *
 * Copyright (C) 2009 NXP Semiconductors
 * Copyright (C) 2009, 2010 Imagination Technologies Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef LINUX_MMC_DW_MMC_H
#define LINUX_MMC_DW_MMC_H

#include <linux/scatterlist.h>
#include <linux/mmc/core.h>

#define MAX_MCI_SLOTS	2

enum dw_mci_state {
	STATE_IDLE = 0,
	STATE_SENDING_CMD,
	STATE_SENDING_DATA,
	STATE_DATA_BUSY,
	STATE_SENDING_STOP,
	STATE_DATA_ERROR,
	STATE_SENDING_CMD11,
	STATE_WAITING_CMD11_DONE,
};

enum {
	EVENT_CMD_COMPLETE = 0,
	EVENT_XFER_COMPLETE,
	EVENT_DATA_COMPLETE,
	EVENT_DATA_ERROR,
	EVENT_XFER_ERROR
};

struct mmc_data;

/**
 * struct dw_mci - MMC controller state shared between all slots
 * @lock: Spinlock protecting the queue and associated data.
 * @regs: Pointer to MMIO registers.
 * @fifo_reg: Pointer to MMIO registers for data FIFO
 * @sg: Scatterlist entry currently being processed by PIO code, if any.
 * @sg_miter: PIO mapping scatterlist iterator.
 * @cur_slot: The slot which is currently using the controller.
 * @mrq: The request currently being processed on @cur_slot,
 *	or NULL if the controller is idle.
 * @cmd: The command currently being sent to the card, or NULL.
 * @data: The data currently being transferred, or NULL if no data
 *	transfer is in progress.
 * @use_dma: Whether DMA channel is initialized or not.
 * @using_dma: Whether DMA is in use for the current transfer.
 * @dma_64bit_address: Whether DMA supports 64-bit address mode or not.
 * @sg_dma: Bus address of DMA buffer.
 * @sg_cpu: Virtual address of DMA buffer.
 * @dma_ops: Pointer to platform-specific DMA callbacks.
 * @cmd_status: Snapshot of SR taken upon completion of the current
 *	command. Only valid when EVENT_CMD_COMPLETE is pending.
 * @data_status: Snapshot of SR taken upon completion of the current
 *	data transfer. Only valid when EVENT_DATA_COMPLETE or
 *	EVENT_DATA_ERROR is pending.
 * @stop_cmdr: Value to be loaded into CMDR when the stop command is
 *	to be sent.
 * @dir_status: Direction of current transfer.
 * @tasklet: Tasklet running the request state machine.
 * @card_tasklet: Tasklet handling card detect.
 * @pending_events: Bitmask of events flagged by the interrupt handler
 *	to be processed by the tasklet.
 * @completed_events: Bitmask of events which the state machine has
 *	processed.
 * @state: Tasklet state.
 * @queue: List of slots waiting for access to the controller.
 * @bus_hz: The rate of @mck in Hz. This forms the basis for MMC bus
 *	rate and timeout calculations.
 * @current_speed: Configured rate of the controller.
 * @num_slots: Number of slots available.
 * @verid: Denote Version ID.
 * @dev: Device associated with the MMC controller.
 * @pdata: Platform data associated with the MMC controller.
 * @drv_data: Driver specific data for identified variant of the controller
 * @priv: Implementation defined private data.
 * @biu_clk: Pointer to bus interface unit clock instance.
 * @ciu_clk: Pointer to card interface unit clock instance.
 * @slot: Slots sharing this MMC controller.
 * @fifo_depth: depth of FIFO.
 * @data_shift: log2 of FIFO item size.
 * @part_buf_start: Start index in part_buf.
 * @part_buf_count: Bytes of partial data in part_buf.
 * @part_buf: Simple buffer for partial fifo reads/writes.
 * @push_data: Pointer to FIFO push function.
 * @pull_data: Pointer to FIFO pull function.
 * @quirks: Set of quirks that apply to specific versions of the IP.
 * @irq_flags: The flags to be passed to request_irq.
 * @irq: The irq value to be passed to request_irq.
 * @sdio_id0: Number of slot0 in the SDIO interrupt registers.
 *
 * Locking
 * =======
 *
 * @lock is a softirq-safe spinlock protecting @queue as well as
 * @cur_slot, @mrq and @state. These must always be updated
 * at the same time while holding @lock.
 *
 * @irq_lock is an irq-safe spinlock protecting the INTMASK register
 * to allow the interrupt handler to modify it directly.  Held for only long
 * enough to read-modify-write INTMASK and no other locks are grabbed when
 * holding this one.
 *
 * The @mrq field of struct dw_mci_slot is also protected by @lock,
 * and must always be written at the same time as the slot is added to
 * @queue.
 *
 * @pending_events and @completed_events are accessed using atomic bit
 * operations, so they don't need any locking.
 *
 * None of the fields touched by the interrupt handler need any
 * locking. However, ordering is important: Before EVENT_DATA_ERROR or
 * EVENT_DATA_COMPLETE is set in @pending_events, all data-related
 * interrupts must be disabled and @data_status updated with a
 * snapshot of SR. Similarly, before EVENT_CMD_COMPLETE is set, the
 * CMDRDY interrupt must be disabled and @cmd_status updated with a
 * snapshot of SR, and before EVENT_XFER_COMPLETE can be set, the
 * bytes_xfered field of @data must be written. This is ensured by
 * using barriers.
 */
struct dw_mci {
	spinlock_t		lock;
	spinlock_t		irq_lock;
	void __iomem		*regs;
	void __iomem		*fifo_reg;

	struct scatterlist	*sg;
	struct sg_mapping_iter	sg_miter;

	struct dw_mci_slot	*cur_slot;
	struct mmc_request	*mrq;
	struct mmc_command	*cmd;
	struct mmc_data		*data;
	struct mmc_command	stop_abort;
	unsigned int		prev_blksz;
	unsigned char		timing;

	/* DMA interface members*/
	int			use_dma;
	int			using_dma;
	int			dma_64bit_address;

	dma_addr_t		sg_dma;
	void			*sg_cpu;
	const struct dw_mci_dma_ops	*dma_ops;
#ifdef CONFIG_MMC_DW_IDMAC
	unsigned int		ring_size;
#else
	struct dw_mci_dma_data	*dma_data;
#endif
	u32			cmd_status;
	u32			data_status;
	u32			stop_cmdr;
	u32			dir_status;
	struct tasklet_struct	tasklet;
	unsigned long		pending_events;
	unsigned long		completed_events;
	enum dw_mci_state	state;
	struct list_head	queue;

	u32			bus_hz;
	u32			current_speed;
	u32			num_slots;
	u32			fifoth_val;
	u16			verid;
	struct device		*dev;
	struct dw_mci_board	*pdata;
	const struct dw_mci_drv_data	*drv_data;
	void			*priv;
	struct clk		*biu_clk;
	struct clk		*ciu_clk;
	struct dw_mci_slot	*slot[MAX_MCI_SLOTS];

	/* FIFO push and pull */
	int			fifo_depth;
	int			data_shift;
	u8			part_buf_start;
	u8			part_buf_count;
	union {
		u16		part_buf16;
		u32		part_buf32;
		u64		part_buf;
	};
	void (*push_data)(struct dw_mci *host, void *buf, int cnt);
	void (*pull_data)(struct dw_mci *host, void *buf, int cnt);

	/* Workaround flags */
	u32			quirks;

	bool			vqmmc_enabled;
	unsigned long		irq_flags; /* IRQ flags */
	int			irq;

	int			sdio_id0;

	struct timer_list       cmd11_timer;
};

/* DMA ops for Internal/External DMAC interface */
struct dw_mci_dma_ops {
	/* DMA Ops */
	int (*init)(struct dw_mci *host);
	void (*start)(struct dw_mci *host, unsigned int sg_len);
	void (*complete)(struct dw_mci *host);
	void (*stop)(struct dw_mci *host);
	void (*cleanup)(struct dw_mci *host);
	void (*exit)(struct dw_mci *host);
};

/* IP Quirks/flags. */
/* DTO fix for command transmission with IDMAC configured */
#define DW_MCI_QUIRK_IDMAC_DTO			BIT(0)
/* delay needed between retries on some 2.11a implementations */
#define DW_MCI_QUIRK_RETRY_DELAY		BIT(1)
/* High Speed Capable - Supports HS cards (up to 50MHz) */
#define DW_MCI_QUIRK_HIGHSPEED			BIT(2)
/* Unreliable card detection */
#define DW_MCI_QUIRK_BROKEN_CARD_DETECTION	BIT(3)
/* No write protect */
#define DW_MCI_QUIRK_NO_WRITE_PROTECT		BIT(4)

/* Slot level quirks */
/* This slot has no write protect */
#define DW_MCI_SLOT_QUIRK_NO_WRITE_PROTECT	BIT(0)

struct dma_pdata;

struct block_settings {
	unsigned short	max_segs;	/* see blk_queue_max_segments */
	unsigned int	max_blk_size;	/* maximum size of one mmc block */
	unsigned int	max_blk_count;	/* maximum number of blocks in one req*/
	unsigned int	max_req_size;	/* maximum number of bytes in one req*/
	unsigned int	max_seg_size;	/* see blk_queue_max_segment_size */
};

/* Board platform data */
struct dw_mci_board {
	u32 num_slots;

	u32 quirks; /* Workaround / Quirk flags */
	unsigned int bus_hz; /* Clock speed at the cclk_in pad */

	u32 caps;	/* Capabilities */
	u32 caps2;	/* More capabilities */
	u32 pm_caps;	/* PM capabilities */
	/*
	 * Override fifo depth. If 0, autodetect it from the FIFOTH register,
	 * but note that this may not be reliable after a bootloader has used
	 * it.
	 */
	unsigned int fifo_depth;

	/* delay in mS before detecting cards after interrupt */
	u32 detect_delay_ms;

	struct dw_mci_dma_ops *dma_ops;
	struct dma_pdata *data;
	struct block_settings *blk_settings;
};

#endif /* LINUX_MMC_DW_MMC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * include/linux/mmc/tmio.h
 *
 * Copyright (C) 2007 Ian Molton
 * Copyright (C) 2004 Ian Molton
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Driver for the MMC / SD / SDIO cell found in:
 *
 * TC6393XB TC6391XB TC6387XB T7L66XB ASIC3
 */
#ifndef LINUX_MMC_TMIO_H
#define LINUX_MMC_TMIO_H

#define CTL_SD_CMD 0x00
#define CTL_ARG_REG 0x04
#define CTL_STOP_INTERNAL_ACTION 0x08
#define CTL_XFER_BLK_COUNT 0xa
#define CTL_RESPONSE 0x0c
#define CTL_STATUS 0x1c
#define CTL_STATUS2 0x1e
#define CTL_IRQ_MASK 0x20
#define CTL_SD_CARD_CLK_CTL 0x24
#define CTL_SD_XFER_LEN 0x26
#define CTL_SD_MEM_CARD_OPT 0x28
#define CTL_SD_ERROR_DETAIL_STATUS 0x2c
#define CTL_SD_DATA_PORT 0x30
#define CTL_TRANSACTION_CTL 0x34
#define CTL_SDIO_STATUS 0x36
#define CTL_SDIO_IRQ_MASK 0x38
#define CTL_DMA_ENABLE 0xd8
#define CTL_RESET_SD 0xe0
#define CTL_VERSION 0xe2
#define CTL_SDIO_REGS 0x100
#define CTL_CLK_AND_WAIT_CTL 0x138
#define CTL_RESET_SDIO 0x1e0

/* Definitions for values the CTRL_STATUS register can take. */
#define TMIO_STAT_CMDRESPEND    0x00000001
#define TMIO_STAT_DATAEND       0x00000004
#define TMIO_STAT_CARD_REMOVE   0x00000008
#define TMIO_STAT_CARD_INSERT   0x00000010
#define TMIO_STAT_SIGSTATE      0x00000020
#define TMIO_STAT_WRPROTECT     0x00000080
#define TMIO_STAT_CARD_REMOVE_A 0x00000100
#define TMIO_STAT_CARD_INSERT_A 0x00000200
#define TMIO_STAT_SIGSTATE_A    0x00000400
#define TMIO_STAT_CMD_IDX_ERR   0x00010000
#define TMIO_STAT_CRCFAIL       0x00020000
#define TMIO_STAT_STOPBIT_ERR   0x00040000
#define TMIO_STAT_DATATIMEOUT   0x00080000
#define TMIO_STAT_RXOVERFLOW    0x00100000
#define TMIO_STAT_TXUNDERRUN    0x00200000
#define TMIO_STAT_CMDTIMEOUT    0x00400000
#define TMIO_STAT_RXRDY         0x01000000
#define TMIO_STAT_TXRQ          0x02000000
#define TMIO_STAT_ILL_FUNC      0x20000000
#define TMIO_STAT_CMD_BUSY      0x40000000
#define TMIO_STAT_ILL_ACCESS    0x80000000

#define TMIO_BBS		512		/* Boot block size */

#endif /* LINUX_MMC_TMIO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 *  include/linux/mmc/sd.h
 *
 *  Copyright (C) 2005-2007 Pierre Ossman, All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 */

#ifndef LINUX_MMC_SD_H
#define LINUX_MMC_SD_H

/* SD commands                           type  argument     response */
  /* class 0 */
/* This is basically the same command as for MMC with some quirks. */
#define SD_SEND_RELATIVE_ADDR     3   /* bcr                     R6  */
#define SD_SEND_IF_COND           8   /* bcr  [11:0] See below   R7  */
#define SD_SWITCH_VOLTAGE         11  /* ac                      R1  */

  /* class 10 */
#define SD_SWITCH                 6   /* adtc [31:0] See below   R1  */

  /* class 5 */
#define SD_ERASE_WR_BLK_START    32   /* ac   [31:0] data addr   R1  */
#define SD_ERASE_WR_BLK_END      33   /* ac   [31:0] data addr   R1  */

  /* Application commands */
#define SD_APP_SET_BUS_WIDTH      6   /* ac   [1:0] bus width    R1  */
#define SD_APP_SD_STATUS         13   /* adtc                    R1  */
#define SD_APP_SEND_NUM_WR_BLKS  22   /* adtc                    R1  */
#define SD_APP_OP_COND           41   /* bcr  [31:0] OCR         R3  */
#define SD_APP_SEND_SCR          51   /* adtc                    R1  */

/* OCR bit definitions */
#define SD_OCR_S18R		(1 << 24)    /* 1.8V switching request */
#define SD_ROCR_S18A		SD_OCR_S18R  /* 1.8V switching accepted by card */
#define SD_OCR_XPC		(1 << 28)    /* SDXC power control */
#define SD_OCR_CCS		(1 << 30)    /* Card Capacity Status */

/*
 * SD_SWITCH argument format:
 *
 *      [31] Check (0) or switch (1)
 *      [30:24] Reserved (0)
 *      [23:20] Function group 6
 *      [19:16] Function group 5
 *      [15:12] Function group 4
 *      [11:8] Function group 3
 *      [7:4] Function group 2
 *      [3:0] Function group 1
 */

/*
 * SD_SEND_IF_COND argument format:
 *
 *	[31:12] Reserved (0)
 *	[11:8] Host Voltage Supply Flags
 *	[7:0] Check Pattern (0xAA)
 */

/*
 * SCR field definitions
 */

#define SCR_SPEC_VER_0		0	/* Implements system specification 1.0 - 1.01 */
#define SCR_SPEC_VER_1		1	/* Implements system specification 1.10 */
#define SCR_SPEC_VER_2		2	/* Implements system specification 2.00-3.0X */

/*
 * SD bus widths
 */
#define SD_BUS_WIDTH_1		0
#define SD_BUS_WIDTH_4		2

/*
 * SD_SWITCH mode
 */
#define SD_SWITCH_CHECK		0
#define SD_SWITCH_SET		1

/*
 * SD_SWITCH function groups
 */
#define SD_SWITCH_GRP_ACCESS	0

/*
 * SD_SWITCH access modes
 */
#define SD_SWITCH_ACCESS_DEF	0
#define SD_SWITCH_ACCESS_HS	1

#endif /* LINUX_MMC_SD_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * include/linux/mmc/sh_mmcif.h
 *
 * platform data for eMMC driver
 *
 * Copyright (C) 2010 Renesas Solutions Corp.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 */

#ifndef LINUX_MMC_SH_MMCIF_H
#define LINUX_MMC_SH_MMCIF_H

#include <linux/io.h>
#include <linux/platform_device.h>

/*
 * MMCIF : CE_CLK_CTRL [19:16]
 * 1000 : Peripheral clock / 512
 * 0111 : Peripheral clock / 256
 * 0110 : Peripheral clock / 128
 * 0101 : Peripheral clock / 64
 * 0100 : Peripheral clock / 32
 * 0011 : Peripheral clock / 16
 * 0010 : Peripheral clock / 8
 * 0001 : Peripheral clock / 4
 * 0000 : Peripheral clock / 2
 * 1111 : Peripheral clock (sup_pclk set '1')
 */

struct sh_mmcif_plat_data {
	int (*get_cd)(struct platform_device *pdef);
	unsigned int		slave_id_tx;	/* embedded slave_id_[tr]x */
	unsigned int		slave_id_rx;
	bool			use_cd_gpio : 1;
	bool			ccs_unsupported : 1;
	bool			clk_ctrl2_present : 1;
	unsigned int		cd_gpio;
	u8			sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
	unsigned long		caps;
	u32			ocr;
};

#define MMCIF_CE_CMD_SET	0x00000000
#define MMCIF_CE_ARG		0x00000008
#define MMCIF_CE_ARG_CMD12	0x0000000C
#define MMCIF_CE_CMD_CTRL	0x00000010
#define MMCIF_CE_BLOCK_SET	0x00000014
#define MMCIF_CE_CLK_CTRL	0x00000018
#define MMCIF_CE_BUF_ACC	0x0000001C
#define MMCIF_CE_RESP3		0x00000020
#define MMCIF_CE_RESP2		0x00000024
#define MMCIF_CE_RESP1		0x00000028
#define MMCIF_CE_RESP0		0x0000002C
#define MMCIF_CE_RESP_CMD12	0x00000030
#define MMCIF_CE_DATA		0x00000034
#define MMCIF_CE_INT		0x00000040
#define MMCIF_CE_INT_MASK	0x00000044
#define MMCIF_CE_HOST_STS1	0x00000048
#define MMCIF_CE_HOST_STS2	0x0000004C
#define MMCIF_CE_CLK_CTRL2	0x00000070
#define MMCIF_CE_VERSION	0x0000007C

/* CE_BUF_ACC */
#define BUF_ACC_DMAWEN		(1 << 25)
#define BUF_ACC_DMAREN		(1 << 24)
#define BUF_ACC_BUSW_32		(0 << 17)
#define BUF_ACC_BUSW_16		(1 << 17)
#define BUF_ACC_ATYP		(1 << 16)

/* CE_CLK_CTRL */
#define CLK_ENABLE		(1 << 24) /* 1: output mmc clock */
#define CLK_CLEAR		(0xf << 16)
#define CLK_SUP_PCLK		(0xf << 16)
#define CLKDIV_4		(1 << 16) /* mmc clock frequency.
					   * n: bus clock/(2^(n+1)) */
#define CLKDIV_256		(7 << 16) /* mmc clock frequency. (see above) */
#define SRSPTO_256		(2 << 12) /* resp timeout */
#define SRBSYTO_29		(0xf << 8) /* resp busy timeout */
#define SRWDTO_29		(0xf << 4) /* read/write timeout */
#define SCCSTO_29		(0xf << 0) /* ccs timeout */

/* CE_VERSION */
#define SOFT_RST_ON		(1 << 31)
#define SOFT_RST_OFF		0

static inline u32 sh_mmcif_readl(void __iomem *addr, int reg)
{
	return __raw_readl(addr + reg);
}

static inline void sh_mmcif_writel(void __iomem *addr, int reg, u32 val)
{
	__raw_writel(val, addr + reg);
}

#define SH_MMCIF_BBS 512 /* boot block size */

static inline void sh_mmcif_boot_cmd_send(void __iomem *base,
					  unsigned long cmd, unsigned long arg)
{
	sh_mmcif_writel(base, MMCIF_CE_INT, 0);
	sh_mmcif_writel(base, MMCIF_CE_ARG, arg);
	sh_mmcif_writel(base, MMCIF_CE_CMD_SET, cmd);
}

static inline int sh_mmcif_boot_cmd_poll(void __iomem *base, unsigned long mask)
{
	unsigned long tmp;
	int cnt;

	for (cnt = 0; cnt < 1000000; cnt++) {
		tmp = sh_mmcif_readl(base, MMCIF_CE_INT);
		if (tmp & mask) {
			sh_mmcif_writel(base, MMCIF_CE_INT, tmp & ~mask);
			return 0;
		}
	}

	return -1;
}

static inline int sh_mmcif_boot_cmd(void __iomem *base,
				    unsigned long cmd, unsigned long arg)
{
	sh_mmcif_boot_cmd_send(base, cmd, arg);
	return sh_mmcif_boot_cmd_poll(base, 0x00010000);
}

static inline int sh_mmcif_boot_do_read_single(void __iomem *base,
					       unsigned int block_nr,
					       unsigned long *buf)
{
	int k;

	/* CMD13 - Status */
	sh_mmcif_boot_cmd(base, 0x0d400000, 0x00010000);

	if (sh_mmcif_readl(base, MMCIF_CE_RESP0) != 0x0900)
		return -1;

	/* CMD17 - Read */
	sh_mmcif_boot_cmd(base, 0x11480000, block_nr * SH_MMCIF_BBS);
	if (sh_mmcif_boot_cmd_poll(base, 0x00100000) < 0)
		return -1;

	for (k = 0; k < (SH_MMCIF_BBS / 4); k++)
		buf[k] = sh_mmcif_readl(base, MMCIF_CE_DATA);

	return 0;
}

static inline int sh_mmcif_boot_do_read(void __iomem *base,
					unsigned long first_block,
					unsigned long nr_blocks,
					void *buf)
{
	unsigned long k;
	int ret = 0;

	/* In data transfer mode: Set clock to Bus clock/4 (about 20Mhz) */
	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL,
			CLK_ENABLE | CLKDIV_4 | SRSPTO_256 |
			SRBSYTO_29 | SRWDTO_29 | SCCSTO_29);

	/* CMD9 - Get CSD */
	sh_mmcif_boot_cmd(base, 0x09806000, 0x00010000);

	/* CMD7 - Select the card */
	sh_mmcif_boot_cmd(base, 0x07400000, 0x00010000);

	/* CMD16 - Set the block size */
	sh_mmcif_boot_cmd(base, 0x10400000, SH_MMCIF_BBS);

	for (k = 0; !ret && k < nr_blocks; k++)
		ret = sh_mmcif_boot_do_read_single(base, first_block + k,
						   buf + (k * SH_MMCIF_BBS));

	return ret;
}

static inline void sh_mmcif_boot_init(void __iomem *base)
{
	/* reset */
	sh_mmcif_writel(base, MMCIF_CE_VERSION, SOFT_RST_ON);
	sh_mmcif_writel(base, MMCIF_CE_VERSION, SOFT_RST_OFF);

	/* byte swap */
	sh_mmcif_writel(base, MMCIF_CE_BUF_ACC, BUF_ACC_ATYP);

	/* Set block size in MMCIF hardware */
	sh_mmcif_writel(base, MMCIF_CE_BLOCK_SET, SH_MMCIF_BBS);

	/* Enable the clock, set it to Bus clock/256 (about 325Khz). */
	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL,
			CLK_ENABLE | CLKDIV_256 | SRSPTO_256 |
			SRBSYTO_29 | SRWDTO_29 | SCCSTO_29);

	/* CMD0 */
	sh_mmcif_boot_cmd(base, 0x00000040, 0);

	/* CMD1 - Get OCR */
	do {
		sh_mmcif_boot_cmd(base, 0x01405040, 0x40300000); /* CMD1 */
	} while ((sh_mmcif_readl(base, MMCIF_CE_RESP0) & 0x80000000)
		 != 0x80000000);

	/* CMD2 - Get CID */
	sh_mmcif_boot_cmd(base, 0x02806040, 0);

	/* CMD3 - Set card relative address */
	sh_mmcif_boot_cmd(base, 0x03400040, 0x00010000);
}

#endif /* LINUX_MMC_SH_MMCIF_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Generic GPIO card-detect helper header
 *
 * Copyright (C) 2011, Guennadi Liakhovetski <g.liakhovetski@gmx.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef MMC_SLOT_GPIO_H
#define MMC_SLOT_GPIO_H

struct mmc_host;

int mmc_gpio_get_ro(struct mmc_host *host);
int mmc_gpio_request_ro(struct mmc_host *host, unsigned int gpio);

int mmc_gpio_get_cd(struct mmc_host *host);
int mmc_gpio_request_cd(struct mmc_host *host, unsigned int gpio,
			unsigned int debounce);

int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
			 unsigned int idx, bool override_active_level,
			 unsigned int debounce, bool *gpio_invert);
int mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,
			 unsigned int idx, bool override_active_level,
			 unsigned int debounce, bool *gpio_invert);
void mmc_gpio_set_cd_isr(struct mmc_host *host,
			 irqreturn_t (*isr)(int irq, void *dev_id));
void mmc_gpiod_request_cd_irq(struct mmc_host *host);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /* linux/include/linux/amba/pl330.h
 *
 * Copyright (C) 2010 Samsung Electronics Co. Ltd.
 *	Jaswinder Singh <jassi.brar@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef	__AMBA_PL330_H_
#define	__AMBA_PL330_H_

#include <linux/dmaengine.h>

struct dma_pl330_platdata {
	/*
	 * Number of valid peripherals connected to DMAC.
	 * This may be different from the value read from
	 * CR0, as the PL330 implementation might have 'holes'
	 * in the peri list or the peri could also be reached
	 * from another DMAC which the platform prefers.
	 */
	u8 nr_valid_peri;
	/* Array of valid peripherals */
	u8 *peri_id;
	/* Operational capabilities */
	dma_cap_mask_t cap_mask;
	/* Bytes to allocate for MC buffer */
	unsigned mcbuf_sz;
};

extern bool pl330_filter(struct dma_chan *chan, void *param);
#endif	/* __AMBA_PL330_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 *  linux/include/asm-arm/hardware/serial_amba.h
 *
 *  Internal header file for AMBA serial ports
 *
 *  Copyright (C) ARM Limited
 *  Copyright (C) 2000 Deep Blue Solutions Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#ifndef ASM_ARM_HARDWARE_SERIAL_AMBA_H
#define ASM_ARM_HARDWARE_SERIAL_AMBA_H

#include <linux/types.h>

/* -------------------------------------------------------------------------------
 *  From AMBA UART (PL010) Block Specification
 * -------------------------------------------------------------------------------
 *  UART Register Offsets.
 */
#define UART01x_DR		0x00	/* Data read or written from the interface. */
#define UART01x_RSR		0x04	/* Receive status register (Read). */
#define UART01x_ECR		0x04	/* Error clear register (Write). */
#define UART010_LCRH		0x08	/* Line control register, high byte. */
#define ST_UART011_DMAWM	0x08    /* DMA watermark configure register. */
#define UART010_LCRM		0x0C	/* Line control register, middle byte. */
#define ST_UART011_TIMEOUT	0x0C    /* Timeout period register. */
#define UART010_LCRL		0x10	/* Line control register, low byte. */
#define UART010_CR		0x14	/* Control register. */
#define UART01x_FR		0x18	/* Flag register (Read only). */
#define UART010_IIR		0x1C	/* Interrupt identification register (Read). */
#define UART010_ICR		0x1C	/* Interrupt clear register (Write). */
#define ST_UART011_LCRH_RX	0x1C    /* Rx line control register. */
#define UART01x_ILPR		0x20	/* IrDA low power counter register. */
#define UART011_IBRD		0x24	/* Integer baud rate divisor register. */
#define UART011_FBRD		0x28	/* Fractional baud rate divisor register. */
#define UART011_LCRH		0x2c	/* Line control register. */
#define ST_UART011_LCRH_TX	0x2c    /* Tx Line control register. */
#define UART011_CR		0x30	/* Control register. */
#define UART011_IFLS		0x34	/* Interrupt fifo level select. */
#define UART011_IMSC		0x38	/* Interrupt mask. */
#define UART011_RIS		0x3c	/* Raw interrupt status. */
#define UART011_MIS		0x40	/* Masked interrupt status. */
#define UART011_ICR		0x44	/* Interrupt clear register. */
#define UART011_DMACR		0x48	/* DMA control register. */
#define ST_UART011_XFCR		0x50	/* XON/XOFF control register. */
#define ST_UART011_XON1		0x54	/* XON1 register. */
#define ST_UART011_XON2		0x58	/* XON2 register. */
#define ST_UART011_XOFF1	0x5C	/* XON1 register. */
#define ST_UART011_XOFF2	0x60	/* XON2 register. */
#define ST_UART011_ITCR		0x80	/* Integration test control register. */
#define ST_UART011_ITIP		0x84	/* Integration test input register. */
#define ST_UART011_ABCR		0x100	/* Autobaud control register. */
#define ST_UART011_ABIMSC	0x15C	/* Autobaud interrupt mask/clear register. */

#define UART011_DR_OE		(1 << 11)
#define UART011_DR_BE		(1 << 10)
#define UART011_DR_PE		(1 << 9)
#define UART011_DR_FE		(1 << 8)

#define UART01x_RSR_OE 		0x08
#define UART01x_RSR_BE 		0x04
#define UART01x_RSR_PE 		0x02
#define UART01x_RSR_FE 		0x01

#define UART011_FR_RI		0x100
#define UART011_FR_TXFE		0x080
#define UART011_FR_RXFF		0x040
#define UART01x_FR_TXFF		0x020
#define UART01x_FR_RXFE		0x010
#define UART01x_FR_BUSY		0x008
#define UART01x_FR_DCD 		0x004
#define UART01x_FR_DSR 		0x002
#define UART01x_FR_CTS 		0x001
#define UART01x_FR_TMSK		(UART01x_FR_TXFF + UART01x_FR_BUSY)

#define UART011_CR_CTSEN	0x8000	/* CTS hardware flow control */
#define UART011_CR_RTSEN	0x4000	/* RTS hardware flow control */
#define UART011_CR_OUT2		0x2000	/* OUT2 */
#define UART011_CR_OUT1		0x1000	/* OUT1 */
#define UART011_CR_RTS		0x0800	/* RTS */
#define UART011_CR_DTR		0x0400	/* DTR */
#define UART011_CR_RXE		0x0200	/* receive enable */
#define UART011_CR_TXE		0x0100	/* transmit enable */
#define UART011_CR_LBE		0x0080	/* loopback enable */
#define UART010_CR_RTIE		0x0040
#define UART010_CR_TIE 		0x0020
#define UART010_CR_RIE 		0x0010
#define UART010_CR_MSIE		0x0008
#define ST_UART011_CR_OVSFACT	0x0008	/* Oversampling factor */
#define UART01x_CR_IIRLP	0x0004	/* SIR low power mode */
#define UART01x_CR_SIREN	0x0002	/* SIR enable */
#define UART01x_CR_UARTEN	0x0001	/* UART enable */
 
#define UART011_LCRH_SPS	0x80
#define UART01x_LCRH_WLEN_8	0x60
#define UART01x_LCRH_WLEN_7	0x40
#define UART01x_LCRH_WLEN_6	0x20
#define UART01x_LCRH_WLEN_5	0x00
#define UART01x_LCRH_FEN	0x10
#define UART01x_LCRH_STP2	0x08
#define UART01x_LCRH_EPS	0x04
#define UART01x_LCRH_PEN	0x02
#define UART01x_LCRH_BRK	0x01

#define ST_UART011_DMAWM_RX_1	(0 << 3)
#define ST_UART011_DMAWM_RX_2	(1 << 3)
#define ST_UART011_DMAWM_RX_4	(2 << 3)
#define ST_UART011_DMAWM_RX_8	(3 << 3)
#define ST_UART011_DMAWM_RX_16	(4 << 3)
#define ST_UART011_DMAWM_RX_32	(5 << 3)
#define ST_UART011_DMAWM_RX_48	(6 << 3)
#define ST_UART011_DMAWM_TX_1	0
#define ST_UART011_DMAWM_TX_2	1
#define ST_UART011_DMAWM_TX_4	2
#define ST_UART011_DMAWM_TX_8	3
#define ST_UART011_DMAWM_TX_16	4
#define ST_UART011_DMAWM_TX_32	5
#define ST_UART011_DMAWM_TX_48	6

#define UART010_IIR_RTIS	0x08
#define UART010_IIR_TIS		0x04
#define UART010_IIR_RIS		0x02
#define UART010_IIR_MIS		0x01

#define UART011_IFLS_RX1_8	(0 << 3)
#define UART011_IFLS_RX2_8	(1 << 3)
#define UART011_IFLS_RX4_8	(2 << 3)
#define UART011_IFLS_RX6_8	(3 << 3)
#define UART011_IFLS_RX7_8	(4 << 3)
#define UART011_IFLS_TX1_8	(0 << 0)
#define UART011_IFLS_TX2_8	(1 << 0)
#define UART011_IFLS_TX4_8	(2 << 0)
#define UART011_IFLS_TX6_8	(3 << 0)
#define UART011_IFLS_TX7_8	(4 << 0)
/* special values for ST vendor with deeper fifo */
#define UART011_IFLS_RX_HALF	(5 << 3)
#define UART011_IFLS_TX_HALF	(5 << 0)

#define UART011_OEIM		(1 << 10)	/* overrun error interrupt mask */
#define UART011_BEIM		(1 << 9)	/* break error interrupt mask */
#define UART011_PEIM		(1 << 8)	/* parity error interrupt mask */
#define UART011_FEIM		(1 << 7)	/* framing error interrupt mask */
#define UART011_RTIM		(1 << 6)	/* receive timeout interrupt mask */
#define UART011_TXIM		(1 << 5)	/* transmit interrupt mask */
#define UART011_RXIM		(1 << 4)	/* receive interrupt mask */
#define UART011_DSRMIM		(1 << 3)	/* DSR interrupt mask */
#define UART011_DCDMIM		(1 << 2)	/* DCD interrupt mask */
#define UART011_CTSMIM		(1 << 1)	/* CTS interrupt mask */
#define UART011_RIMIM		(1 << 0)	/* RI interrupt mask */

#define UART011_OEIS		(1 << 10)	/* overrun error interrupt status */
#define UART011_BEIS		(1 << 9)	/* break error interrupt status */
#define UART011_PEIS		(1 << 8)	/* parity error interrupt status */
#define UART011_FEIS		(1 << 7)	/* framing error interrupt status */
#define UART011_RTIS		(1 << 6)	/* receive timeout interrupt status */
#define UART011_TXIS		(1 << 5)	/* transmit interrupt status */
#define UART011_RXIS		(1 << 4)	/* receive interrupt status */
#define UART011_DSRMIS		(1 << 3)	/* DSR interrupt status */
#define UART011_DCDMIS		(1 << 2)	/* DCD interrupt status */
#define UART011_CTSMIS		(1 << 1)	/* CTS interrupt status */
#define UART011_RIMIS		(1 << 0)	/* RI interrupt status */

#define UART011_OEIC		(1 << 10)	/* overrun error interrupt clear */
#define UART011_BEIC		(1 << 9)	/* break error interrupt clear */
#define UART011_PEIC		(1 << 8)	/* parity error interrupt clear */
#define UART011_FEIC		(1 << 7)	/* framing error interrupt clear */
#define UART011_RTIC		(1 << 6)	/* receive timeout interrupt clear */
#define UART011_TXIC		(1 << 5)	/* transmit interrupt clear */
#define UART011_RXIC		(1 << 4)	/* receive interrupt clear */
#define UART011_DSRMIC		(1 << 3)	/* DSR interrupt clear */
#define UART011_DCDMIC		(1 << 2)	/* DCD interrupt clear */
#define UART011_CTSMIC		(1 << 1)	/* CTS interrupt clear */
#define UART011_RIMIC		(1 << 0)	/* RI interrupt clear */

#define UART011_DMAONERR	(1 << 2)	/* disable dma on error */
#define UART011_TXDMAE		(1 << 1)	/* enable transmit dma */
#define UART011_RXDMAE		(1 << 0)	/* enable receive dma */

#define UART01x_RSR_ANY		(UART01x_RSR_OE|UART01x_RSR_BE|UART01x_RSR_PE|UART01x_RSR_FE)
#define UART01x_FR_MODEM_ANY	(UART01x_FR_DCD|UART01x_FR_DSR|UART01x_FR_CTS)

#ifndef __ASSEMBLY__
struct amba_device; /* in uncompress this is included but amba/bus.h is not */
struct amba_pl010_data {
	void (*set_mctrl)(struct amba_device *dev, void __iomem *base, unsigned int mctrl);
};

struct dma_chan;
struct amba_pl011_data {
	bool (*dma_filter)(struct dma_chan *chan, void *filter_param);
	void *dma_rx_param;
	void *dma_tx_param;
	bool dma_rx_poll_enable;
	unsigned int dma_rx_poll_rate;
	unsigned int dma_rx_poll_timeout;
        void (*init) (void);
	void (*exit) (void);
};
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * ARM PrimeXsys System Controller SP810 header file
 *
 * Copyright (C) 2009 ST Microelectronics
 * Viresh Kumar <viresh.linux@gmail.com>
 *
 * This file is licensed under the terms of the GNU General Public
 * License version 2. This program is licensed "as is" without any
 * warranty of any kind, whether express or implied.
 */

#ifndef __AMBA_SP810_H
#define __AMBA_SP810_H

#include <linux/io.h>

/* sysctl registers offset */
#define SCCTRL			0x000
#define SCSYSSTAT		0x004
#define SCIMCTRL		0x008
#define SCIMSTAT		0x00C
#define SCXTALCTRL		0x010
#define SCPLLCTRL		0x014
#define SCPLLFCTRL		0x018
#define SCPERCTRL0		0x01C
#define SCPERCTRL1		0x020
#define SCPEREN			0x024
#define SCPERDIS		0x028
#define SCPERCLKEN		0x02C
#define SCPERSTAT		0x030
#define SCSYSID0		0xEE0
#define SCSYSID1		0xEE4
#define SCSYSID2		0xEE8
#define SCSYSID3		0xEEC
#define SCITCR			0xF00
#define SCITIR0			0xF04
#define SCITIR1			0xF08
#define SCITOR			0xF0C
#define SCCNTCTRL		0xF10
#define SCCNTDATA		0xF14
#define SCCNTSTEP		0xF18
#define SCPERIPHID0		0xFE0
#define SCPERIPHID1		0xFE4
#define SCPERIPHID2		0xFE8
#define SCPERIPHID3		0xFEC
#define SCPCELLID0		0xFF0
#define SCPCELLID1		0xFF4
#define SCPCELLID2		0xFF8
#define SCPCELLID3		0xFFC

#define SCCTRL_TIMERENnSEL_SHIFT(n)	(15 + ((n) * 2))

static inline void sysctl_soft_reset(void __iomem *base)
{
	/* switch to slow mode */
	writel(0x2, base + SCCTRL);

	/* writing any value to SCSYSSTAT reg will reset system */
	writel(0, base + SCSYSSTAT);
}

#endif /* __AMBA_SP810_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 *  linux/include/amba/bus.h
 *
 *  This device type deals with ARM PrimeCells and anything else that
 *  presents a proper CID (0xB105F00D) at the end of the I/O register
 *  region or that is derived from a PrimeCell.
 *
 *  Copyright (C) 2003 Deep Blue Solutions Ltd, All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#ifndef ASMARM_AMBA_H
#define ASMARM_AMBA_H

#include <linux/clk.h>
#include <linux/device.h>
#include <linux/mod_devicetable.h>
#include <linux/err.h>
#include <linux/resource.h>
#include <linux/regulator/consumer.h>

#define AMBA_NR_IRQS	9
#define AMBA_CID	0xb105f00d
#define CORESIGHT_CID	0xb105900d

struct clk;

struct amba_device {
	struct device		dev;
	struct resource		res;
	struct clk		*pclk;
	unsigned int		periphid;
	unsigned int		irq[AMBA_NR_IRQS];
	char			*driver_override;
};

struct amba_driver {
	struct device_driver	drv;
	int			(*probe)(struct amba_device *, const struct amba_id *);
	int			(*remove)(struct amba_device *);
	void			(*shutdown)(struct amba_device *);
	int			(*suspend)(struct amba_device *, pm_message_t);
	int			(*resume)(struct amba_device *);
	const struct amba_id	*id_table;
};

/*
 * Constants for the designer field of the Peripheral ID register. When bit 7
 * is set to '1', bits [6:0] should be the JEP106 manufacturer identity code.
 */
enum amba_vendor {
	AMBA_VENDOR_ARM = 0x41,
	AMBA_VENDOR_ST = 0x80,
	AMBA_VENDOR_QCOM = 0x51,
	AMBA_VENDOR_LSI = 0xb6,
};

extern struct bus_type amba_bustype;

#define to_amba_device(d)	container_of(d, struct amba_device, dev)

#define amba_get_drvdata(d)	dev_get_drvdata(&d->dev)
#define amba_set_drvdata(d,p)	dev_set_drvdata(&d->dev, p)

int amba_driver_register(struct amba_driver *);
void amba_driver_unregister(struct amba_driver *);
struct amba_device *amba_device_alloc(const char *, resource_size_t, size_t);
void amba_device_put(struct amba_device *);
int amba_device_add(struct amba_device *, struct resource *);
int amba_device_register(struct amba_device *, struct resource *);
struct amba_device *amba_apb_device_add(struct device *parent, const char *name,
					resource_size_t base, size_t size,
					int irq1, int irq2, void *pdata,
					unsigned int periphid);
struct amba_device *amba_ahb_device_add(struct device *parent, const char *name,
					resource_size_t base, size_t size,
					int irq1, int irq2, void *pdata,
					unsigned int periphid);
struct amba_device *
amba_apb_device_add_res(struct device *parent, const char *name,
			resource_size_t base, size_t size, int irq1,
			int irq2, void *pdata, unsigned int periphid,
			struct resource *resbase);
struct amba_device *
amba_ahb_device_add_res(struct device *parent, const char *name,
			resource_size_t base, size_t size, int irq1,
			int irq2, void *pdata, unsigned int periphid,
			struct resource *resbase);
void amba_device_unregister(struct amba_device *);
struct amba_device *amba_find_device(const char *, struct device *, unsigned int, unsigned int);
int amba_request_regions(struct amba_device *, const char *);
void amba_release_regions(struct amba_device *);

static inline int amba_pclk_enable(struct amba_device *dev)
{
	return clk_enable(dev->pclk);
}

static inline void amba_pclk_disable(struct amba_device *dev)
{
	clk_disable(dev->pclk);
}

static inline int amba_pclk_prepare(struct amba_device *dev)
{
	return clk_prepare(dev->pclk);
}

static inline void amba_pclk_unprepare(struct amba_device *dev)
{
	clk_unprepare(dev->pclk);
}

/* Some drivers don't use the struct amba_device */
#define AMBA_CONFIG_BITS(a) (((a) >> 24) & 0xff)
#define AMBA_REV_BITS(a) (((a) >> 20) & 0x0f)
#define AMBA_MANF_BITS(a) (((a) >> 12) & 0xff)
#define AMBA_PART_BITS(a) ((a) & 0xfff)

#define amba_config(d)	AMBA_CONFIG_BITS((d)->periphid)
#define amba_rev(d)	AMBA_REV_BITS((d)->periphid)
#define amba_manf(d)	AMBA_MANF_BITS((d)->periphid)
#define amba_part(d)	AMBA_PART_BITS((d)->periphid)

#define __AMBA_DEV(busid, data, mask)				\
	{							\
		.coherent_dma_mask = mask,			\
		.init_name = busid,				\
		.platform_data = data,				\
	}

/*
 * APB devices do not themselves have the ability to address memory,
 * so DMA masks should be zero (much like USB peripheral devices.)
 * The DMA controller DMA masks should be used instead (much like
 * USB host controllers in conventional PCs.)
 */
#define AMBA_APB_DEVICE(name, busid, id, base, irqs, data)	\
struct amba_device name##_device = {				\
	.dev = __AMBA_DEV(busid, data, 0),			\
	.res = DEFINE_RES_MEM(base, SZ_4K),			\
	.irq = irqs,						\
	.periphid = id,						\
}

/*
 * AHB devices are DMA capable, so set their DMA masks
 */
#define AMBA_AHB_DEVICE(name, busid, id, base, irqs, data)	\
struct amba_device name##_device = {				\
	.dev = __AMBA_DEV(busid, data, ~0ULL),			\
	.res = DEFINE_RES_MEM(base, SZ_4K),			\
	.irq = irqs,						\
	.periphid = id,						\
}

/*
 * module_amba_driver() - Helper macro for drivers that don't do anything
 * special in module init/exit.  This eliminates a lot of boilerplate.  Each
 * module may only use this macro once, and calling it replaces module_init()
 * and module_exit()
 */
#define module_amba_driver(__amba_drv) \
	module_driver(__amba_drv, amba_driver_register, amba_driver_unregister)

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * linux/include/asm-arm/hardware/amba_clcd.h -- Integrator LCD panel.
 *
 * David A Rusling
 *
 * Copyright (C) 2001 ARM Limited
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive
 * for more details.
 */
#include <linux/fb.h>

/*
 * CLCD Controller Internal Register addresses
 */
#define CLCD_TIM0		0x00000000
#define CLCD_TIM1 		0x00000004
#define CLCD_TIM2 		0x00000008
#define CLCD_TIM3 		0x0000000c
#define CLCD_UBAS 		0x00000010
#define CLCD_LBAS 		0x00000014

#define CLCD_PL110_IENB		0x00000018
#define CLCD_PL110_CNTL		0x0000001c
#define CLCD_PL110_STAT		0x00000020
#define CLCD_PL110_INTR 	0x00000024
#define CLCD_PL110_UCUR		0x00000028
#define CLCD_PL110_LCUR		0x0000002C

#define CLCD_PL111_CNTL		0x00000018
#define CLCD_PL111_IENB		0x0000001c
#define CLCD_PL111_RIS		0x00000020
#define CLCD_PL111_MIS		0x00000024
#define CLCD_PL111_ICR		0x00000028
#define CLCD_PL111_UCUR		0x0000002c
#define CLCD_PL111_LCUR		0x00000030

#define CLCD_PALL 		0x00000200
#define CLCD_PALETTE		0x00000200

#define TIM2_CLKSEL		(1 << 5)
#define TIM2_IVS		(1 << 11)
#define TIM2_IHS		(1 << 12)
#define TIM2_IPC		(1 << 13)
#define TIM2_IOE		(1 << 14)
#define TIM2_BCD		(1 << 26)

#define CNTL_LCDEN		(1 << 0)
#define CNTL_LCDBPP1		(0 << 1)
#define CNTL_LCDBPP2		(1 << 1)
#define CNTL_LCDBPP4		(2 << 1)
#define CNTL_LCDBPP8		(3 << 1)
#define CNTL_LCDBPP16		(4 << 1)
#define CNTL_LCDBPP16_565	(6 << 1)
#define CNTL_LCDBPP16_444	(7 << 1)
#define CNTL_LCDBPP24		(5 << 1)
#define CNTL_LCDBW		(1 << 4)
#define CNTL_LCDTFT		(1 << 5)
#define CNTL_LCDMONO8		(1 << 6)
#define CNTL_LCDDUAL		(1 << 7)
#define CNTL_BGR		(1 << 8)
#define CNTL_BEBO		(1 << 9)
#define CNTL_BEPO		(1 << 10)
#define CNTL_LCDPWR		(1 << 11)
#define CNTL_LCDVCOMP(x)	((x) << 12)
#define CNTL_LDMAFIFOTIME	(1 << 15)
#define CNTL_WATERMARK		(1 << 16)

enum {
	/* individual formats */
	CLCD_CAP_RGB444		= (1 << 0),
	CLCD_CAP_RGB5551	= (1 << 1),
	CLCD_CAP_RGB565		= (1 << 2),
	CLCD_CAP_RGB888		= (1 << 3),
	CLCD_CAP_BGR444		= (1 << 4),
	CLCD_CAP_BGR5551	= (1 << 5),
	CLCD_CAP_BGR565		= (1 << 6),
	CLCD_CAP_BGR888		= (1 << 7),

	/* connection layouts */
	CLCD_CAP_444		= CLCD_CAP_RGB444 | CLCD_CAP_BGR444,
	CLCD_CAP_5551		= CLCD_CAP_RGB5551 | CLCD_CAP_BGR5551,
	CLCD_CAP_565		= CLCD_CAP_RGB565 | CLCD_CAP_BGR565,
	CLCD_CAP_888		= CLCD_CAP_RGB888 | CLCD_CAP_BGR888,

	/* red/blue ordering */
	CLCD_CAP_RGB		= CLCD_CAP_RGB444 | CLCD_CAP_RGB5551 |
				  CLCD_CAP_RGB565 | CLCD_CAP_RGB888,
	CLCD_CAP_BGR		= CLCD_CAP_BGR444 | CLCD_CAP_BGR5551 |
				  CLCD_CAP_BGR565 | CLCD_CAP_BGR888,

	CLCD_CAP_ALL		= CLCD_CAP_BGR | CLCD_CAP_RGB,
};

struct clcd_panel {
	struct fb_videomode	mode;
	signed short		width;	/* width in mm */
	signed short		height;	/* height in mm */
	u32			tim2;
	u32			tim3;
	u32			cntl;
	u32			caps;
	unsigned int		bpp:8,
				fixedtimings:1,
				grayscale:1;
	unsigned int		connector;
};

struct clcd_regs {
	u32			tim0;
	u32			tim1;
	u32			tim2;
	u32			tim3;
	u32			cntl;
	unsigned long		pixclock;
};

struct clcd_fb;

/*
 * the board-type specific routines
 */
struct clcd_board {
	const char *name;

	/*
	 * Optional.  Hardware capability flags.
	 */
	u32	caps;

	/*
	 * Optional.  Check whether the var structure is acceptable
	 * for this display.
	 */
	int	(*check)(struct clcd_fb *fb, struct fb_var_screeninfo *var);

	/*
	 * Compulsory.  Decode fb->fb.var into regs->*.  In the case of
	 * fixed timing, set regs->* to the register values required.
	 */
	void	(*decode)(struct clcd_fb *fb, struct clcd_regs *regs);

	/*
	 * Optional.  Disable any extra display hardware.
	 */
	void	(*disable)(struct clcd_fb *);

	/*
	 * Optional.  Enable any extra display hardware.
	 */
	void	(*enable)(struct clcd_fb *);

	/*
	 * Setup platform specific parts of CLCD driver
	 */
	int	(*setup)(struct clcd_fb *);

	/*
	 * mmap the framebuffer memory
	 */
	int	(*mmap)(struct clcd_fb *, struct vm_area_struct *);

	/*
	 * Remove platform specific parts of CLCD driver
	 */
	void	(*remove)(struct clcd_fb *);
};

struct amba_device;
struct clk;

/* this data structure describes each frame buffer device we find */
struct clcd_fb {
	struct fb_info		fb;
	struct amba_device	*dev;
	struct clk		*clk;
	struct clcd_panel	*panel;
	struct clcd_board	*board;
	void			*board_data;
	void __iomem		*regs;
	u16			off_ienb;
	u16			off_cntl;
	u32			clcd_cntl;
	u32			cmap[16];
	bool			clk_enabled;
};

static inline void clcdfb_decode(struct clcd_fb *fb, struct clcd_regs *regs)
{
	struct fb_var_screeninfo *var = &fb->fb.var;
	u32 val, cpl;

	/*
	 * Program the CLCD controller registers and start the CLCD
	 */
	val = ((var->xres / 16) - 1) << 2;
	val |= (var->hsync_len - 1) << 8;
	val |= (var->right_margin - 1) << 16;
	val |= (var->left_margin - 1) << 24;
	regs->tim0 = val;

	val = var->yres;
	if (fb->panel->cntl & CNTL_LCDDUAL)
		val /= 2;
	val -= 1;
	val |= (var->vsync_len - 1) << 10;
	val |= var->lower_margin << 16;
	val |= var->upper_margin << 24;
	regs->tim1 = val;

	val = fb->panel->tim2;
	val |= var->sync & FB_SYNC_HOR_HIGH_ACT  ? 0 : TIM2_IHS;
	val |= var->sync & FB_SYNC_VERT_HIGH_ACT ? 0 : TIM2_IVS;

	cpl = var->xres_virtual;
	if (fb->panel->cntl & CNTL_LCDTFT)	  /* TFT */
		/* / 1 */;
	else if (!var->grayscale)		  /* STN color */
		cpl = cpl * 8 / 3;
	else if (fb->panel->cntl & CNTL_LCDMONO8) /* STN monochrome, 8bit */
		cpl /= 8;
	else					  /* STN monochrome, 4bit */
		cpl /= 4;

	regs->tim2 = val | ((cpl - 1) << 16);

	regs->tim3 = fb->panel->tim3;

	val = fb->panel->cntl;
	if (var->grayscale)
		val |= CNTL_LCDBW;

	if (fb->panel->caps && fb->board->caps &&
	    var->bits_per_pixel >= 16) {
		/*
		 * if board and panel supply capabilities, we can support
		 * changing BGR/RGB depending on supplied parameters
		 */
		if (var->red.offset == 0)
			val &= ~CNTL_BGR;
		else
			val |= CNTL_BGR;
	}

	switch (var->bits_per_pixel) {
	case 1:
		val |= CNTL_LCDBPP1;
		break;
	case 2:
		val |= CNTL_LCDBPP2;
		break;
	case 4:
		val |= CNTL_LCDBPP4;
		break;
	case 8:
		val |= CNTL_LCDBPP8;
		break;
	case 16:
		/*
		 * PL110 cannot choose between 5551 and 565 modes in its
		 * control register.  It is possible to use 565 with
		 * custom external wiring.
		 */
		if (amba_part(fb->dev) == 0x110 ||
		    var->green.length == 5)
			val |= CNTL_LCDBPP16;
		else if (var->green.length == 6)
			val |= CNTL_LCDBPP16_565;
		else
			val |= CNTL_LCDBPP16_444;
		break;
	case 32:
		val |= CNTL_LCDBPP24;
		break;
	}

	regs->cntl = val;
	regs->pixclock = var->pixclock;
}

static inline int clcdfb_check(struct clcd_fb *fb, struct fb_var_screeninfo *var)
{
	var->xres_virtual = var->xres = (var->xres + 15) & ~15;
	var->yres_virtual = var->yres = (var->yres + 1) & ~1;

#define CHECK(e,l,h) (var->e < l || var->e > h)
	if (CHECK(right_margin, (5+1), 256) ||	/* back porch */
	    CHECK(left_margin, (5+1), 256) ||	/* front porch */
	    CHECK(hsync_len, (5+1), 256) ||
	    var->xres > 4096 ||
	    var->lower_margin > 255 ||		/* back porch */
	    var->upper_margin > 255 ||		/* front porch */
	    var->vsync_len > 32 ||
	    var->yres > 1024)
		return -EINVAL;
#undef CHECK

	/* single panel mode: PCD = max(PCD, 1) */
	/* dual panel mode: PCD = max(PCD, 5) */

	/*
	 * You can't change the grayscale setting, and
	 * we can only do non-interlaced video.
	 */
	if (var->grayscale != fb->fb.var.grayscale ||
	    (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)
		return -EINVAL;

#define CHECK(e) (var->e != fb->fb.var.e)
	if (fb->panel->fixedtimings &&
	    (CHECK(xres)		||
	     CHECK(yres)		||
	     CHECK(bits_per_pixel)	||
	     CHECK(pixclock)		||
	     CHECK(left_margin)		||
	     CHECK(right_margin)	||
	     CHECK(upper_margin)	||
	     CHECK(lower_margin)	||
	     CHECK(hsync_len)		||
	     CHECK(vsync_len)		||
	     CHECK(sync)))
		return -EINVAL;
#undef CHECK

	var->nonstd = 0;
	var->accel_flags = 0;

	return 0;
}
                                                                                                                                                                                                                                                                                         #include <linux/types.h>

/* platform data for the PL061 GPIO driver */

struct pl061_platform_data {
	/* number of the first GPIO */
	unsigned	gpio_base;

	/* number of the first IRQ.
	 * If the IRQ functionality in not desired this must be set to 0.
	 */
	unsigned	irq_base;

	u8		directions;	/* startup directions, 1: out, 0: in */
	u8		values;		/* startup values */
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 *  include/linux/amba/mmci.h
 */
#ifndef AMBA_MMCI_H
#define AMBA_MMCI_H

#include <linux/mmc/host.h>

/**
 * struct mmci_platform_data - platform configuration for the MMCI
 * (also known as PL180) block.
 * @ocr_mask: available voltages on the 4 pins from the block, this
 * is ignored if a regulator is used, see the MMC_VDD_* masks in
 * mmc/host.h
 * @ios_handler: a callback function to act on specfic ios changes,
 * used for example to control a levelshifter
 * mask into a value to be binary (or set some other custom bits
 * in MMCIPWR) or:ed and written into the MMCIPWR register of the
 * block.  May also control external power based on the power_mode.
 * @status: if no GPIO read function was given to the block in
 * gpio_wp (below) this function will be called to determine
 * whether a card is present in the MMC slot or not
 * @gpio_wp: read this GPIO pin to see if the card is write protected
 * @gpio_cd: read this GPIO pin to detect card insertion
 * @cd_invert: true if the gpio_cd pin value is active low
 */
struct mmci_platform_data {
	unsigned int ocr_mask;
	int (*ios_handler)(struct device *, struct mmc_ios *);
	unsigned int (*status)(struct device *);
	int	gpio_wp;
	int	gpio_cd;
	bool	cd_invert;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /* include/linux/amba/pl080.h
 *
 * Copyright 2008 Openmoko, Inc.
 * Copyright 2008 Simtec Electronics
 *      http://armlinux.simtec.co.uk/
 *      Ben Dooks <ben@simtec.co.uk>
 *
 * ARM PrimeCell PL080 DMA controller
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

/* Note, there are some Samsung updates to this controller block which
 * make it not entierly compatible with the PL080 specification from
 * ARM. When in doubt, check the Samsung documentation first.
 *
 * The Samsung defines are PL080S, and add an extra control register,
 * the ability to move more than 2^11 counts of data and some extra
 * OneNAND features.
*/

#ifndef ASM_PL080_H
#define ASM_PL080_H

#define PL080_INT_STATUS			(0x00)
#define PL080_TC_STATUS				(0x04)
#define PL080_TC_CLEAR				(0x08)
#define PL080_ERR_STATUS			(0x0C)
#define PL080_ERR_CLEAR				(0x10)
#define PL080_RAW_TC_STATUS			(0x14)
#define PL080_RAW_ERR_STATUS			(0x18)
#define PL080_EN_CHAN				(0x1c)
#define PL080_SOFT_BREQ				(0x20)
#define PL080_SOFT_SREQ				(0x24)
#define PL080_SOFT_LBREQ			(0x28)
#define PL080_SOFT_LSREQ			(0x2C)

#define PL080_CONFIG				(0x30)
#define PL080_CONFIG_M2_BE			(1 << 2)
#define PL080_CONFIG_M1_BE			(1 << 1)
#define PL080_CONFIG_ENABLE			(1 << 0)

#define PL080_SYNC				(0x34)

/* Per channel configuration registers */

#define PL080_Cx_STRIDE				(0x20)
#define PL080_Cx_BASE(x)			((0x100 + (x * 0x20)))
#define PL080_Cx_SRC_ADDR(x)			((0x100 + (x * 0x20)))
#define PL080_Cx_DST_ADDR(x)			((0x104 + (x * 0x20)))
#define PL080_Cx_LLI(x)				((0x108 + (x * 0x20)))
#define PL080_Cx_CONTROL(x)			((0x10C + (x * 0x20)))
#define PL080_Cx_CONFIG(x)			((0x110 + (x * 0x20)))
#define PL080S_Cx_CONTROL2(x)			((0x110 + (x * 0x20)))
#define PL080S_Cx_CONFIG(x)			((0x114 + (x * 0x20)))

#define PL080_CH_SRC_ADDR			(0x00)
#define PL080_CH_DST_ADDR			(0x04)
#define PL080_CH_LLI				(0x08)
#define PL080_CH_CONTROL			(0x0C)
#define PL080_CH_CONFIG				(0x10)
#define PL080S_CH_CONTROL2			(0x10)
#define PL080S_CH_CONFIG			(0x14)

#define PL080_LLI_ADDR_MASK			(0x3fffffff << 2)
#define PL080_LLI_ADDR_SHIFT			(2)
#define PL080_LLI_LM_AHB2			(1 << 0)

#define PL080_CONTROL_TC_IRQ_EN			(1 << 31)
#define PL080_CONTROL_PROT_MASK			(0x7 << 28)
#define PL080_CONTROL_PROT_SHIFT		(28)
#define PL080_CONTROL_PROT_CACHE		(1 << 30)
#define PL080_CONTROL_PROT_BUFF			(1 << 29)
#define PL080_CONTROL_PROT_SYS			(1 << 28)
#define PL080_CONTROL_DST_INCR			(1 << 27)
#define PL080_CONTROL_SRC_INCR			(1 << 26)
#define PL080_CONTROL_DST_AHB2			(1 << 25)
#define PL080_CONTROL_SRC_AHB2			(1 << 24)
#define PL080_CONTROL_DWIDTH_MASK		(0x7 << 21)
#define PL080_CONTROL_DWIDTH_SHIFT		(21)
#define PL080_CONTROL_SWIDTH_MASK		(0x7 << 18)
#define PL080_CONTROL_SWIDTH_SHIFT		(18)
#define PL080_CONTROL_DB_SIZE_MASK		(0x7 << 15)
#define PL080_CONTROL_DB_SIZE_SHIFT		(15)
#define PL080_CONTROL_SB_SIZE_MASK		(0x7 << 12)
#define PL080_CONTROL_SB_SIZE_SHIFT		(12)
#define PL080_CONTROL_TRANSFER_SIZE_MASK	(0xfff << 0)
#define PL080S_CONTROL_TRANSFER_SIZE_MASK	(0x1ffffff << 0)
#define PL080_CONTROL_TRANSFER_SIZE_SHIFT	(0)

#define PL080_BSIZE_1				(0x0)
#define PL080_BSIZE_4				(0x1)
#define PL080_BSIZE_8				(0x2)
#define PL080_BSIZE_16				(0x3)
#define PL080_BSIZE_32				(0x4)
#define PL080_BSIZE_64				(0x5)
#define PL080_BSIZE_128				(0x6)
#define PL080_BSIZE_256				(0x7)

#define PL080_WIDTH_8BIT			(0x0)
#define PL080_WIDTH_16BIT			(0x1)
#define PL080_WIDTH_32BIT			(0x2)

#define PL080N_CONFIG_ITPROT			(1 << 20)
#define PL080N_CONFIG_SECPROT			(1 << 19)
#define PL080_CONFIG_HALT			(1 << 18)
#define PL080_CONFIG_ACTIVE			(1 << 17)  /* RO */
#define PL080_CONFIG_LOCK			(1 << 16)
#define PL080_CONFIG_TC_IRQ_MASK		(1 << 15)
#define PL080_CONFIG_ERR_IRQ_MASK		(1 << 14)
#define PL080_CONFIG_FLOW_CONTROL_MASK		(0x7 << 11)
#define PL080_CONFIG_FLOW_CONTROL_SHIFT		(11)
#define PL080_CONFIG_DST_SEL_MASK		(0xf << 6)
#define PL080_CONFIG_DST_SEL_SHIFT		(6)
#define PL080_CONFIG_SRC_SEL_MASK		(0xf << 1)
#define PL080_CONFIG_SRC_SEL_SHIFT		(1)
#define PL080_CONFIG_ENABLE			(1 << 0)

#define PL080_FLOW_MEM2MEM			(0x0)
#define PL080_FLOW_MEM2PER			(0x1)
#define PL080_FLOW_PER2MEM			(0x2)
#define PL080_FLOW_SRC2DST			(0x3)
#define PL080_FLOW_SRC2DST_DST			(0x4)
#define PL080_FLOW_MEM2PER_PER			(0x5)
#define PL080_FLOW_PER2MEM_PER			(0x6)
#define PL080_FLOW_SRC2DST_SRC			(0x7)

/* DMA linked list chain structure */

struct pl080_lli {
	u32	src_addr;
	u32	dst_addr;
	u32	next_lli;
	u32	control0;
};

struct pl080s_lli {
	u32	src_addr;
	u32	dst_addr;
	u32	next_lli;
	u32	control0;
	u32	control1;
};

#endif /* ASM_PL080_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * include/linux/amba/pl022.h
 *
 * Copyright (C) 2008-2009 ST-Ericsson AB
 * Copyright (C) 2006 STMicroelectronics Pvt. Ltd.
 *
 * Author: Linus Walleij <linus.walleij@stericsson.com>
 *
 * Initial version inspired by:
 *	linux-2.6.17-rc3-mm1/drivers/spi/pxa2xx_spi.c
 * Initial adoption to PL022 by:
 *      Sachin Verma <sachin.verma@st.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#ifndef _SSP_PL022_H
#define _SSP_PL022_H

#include <linux/types.h>

/**
 * whether SSP is in loopback mode or not
 */
enum ssp_loopback {
	LOOPBACK_DISABLED,
	LOOPBACK_ENABLED
};

/**
 * enum ssp_interface - interfaces allowed for this SSP Controller
 * @SSP_INTERFACE_MOTOROLA_SPI: Motorola Interface
 * @SSP_INTERFACE_TI_SYNC_SERIAL: Texas Instrument Synchronous Serial
 * interface
 * @SSP_INTERFACE_NATIONAL_MICROWIRE: National Semiconductor Microwire
 * interface
 * @SSP_INTERFACE_UNIDIRECTIONAL: Unidirectional interface (STn8810
 * &STn8815 only)
 */
enum ssp_interface {
	SSP_INTERFACE_MOTOROLA_SPI,
	SSP_INTERFACE_TI_SYNC_SERIAL,
	SSP_INTERFACE_NATIONAL_MICROWIRE,
	SSP_INTERFACE_UNIDIRECTIONAL
};

/**
 * enum ssp_hierarchy - whether SSP is configured as Master or Slave
 */
enum ssp_hierarchy {
	SSP_MASTER,
	SSP_SLAVE
};

/**
 * enum ssp_clock_params - clock parameters, to set SSP clock at a
 * desired freq
 */
struct ssp_clock_params {
	u8 cpsdvsr; /* value from 2 to 254 (even only!) */
	u8 scr;	    /* value from 0 to 255 */
};

/**
 * enum ssp_rx_endian - endianess of Rx FIFO Data
 * this feature is only available in ST versionf of PL022
 */
enum ssp_rx_endian {
	SSP_RX_MSB,
	SSP_RX_LSB
};

/**
 * enum ssp_tx_endian - endianess of Tx FIFO Data
 */
enum ssp_tx_endian {
	SSP_TX_MSB,
	SSP_TX_LSB
};

/**
 * enum ssp_data_size - number of bits in one data element
 */
enum ssp_data_size {
	SSP_DATA_BITS_4 = 0x03, SSP_DATA_BITS_5, SSP_DATA_BITS_6,
	SSP_DATA_BITS_7, SSP_DATA_BITS_8, SSP_DATA_BITS_9,
	SSP_DATA_BITS_10, SSP_DATA_BITS_11, SSP_DATA_BITS_12,
	SSP_DATA_BITS_13, SSP_DATA_BITS_14, SSP_DATA_BITS_15,
	SSP_DATA_BITS_16, SSP_DATA_BITS_17, SSP_DATA_BITS_18,
	SSP_DATA_BITS_19, SSP_DATA_BITS_20, SSP_DATA_BITS_21,
	SSP_DATA_BITS_22, SSP_DATA_BITS_23, SSP_DATA_BITS_24,
	SSP_DATA_BITS_25, SSP_DATA_BITS_26, SSP_DATA_BITS_27,
	SSP_DATA_BITS_28, SSP_DATA_BITS_29, SSP_DATA_BITS_30,
	SSP_DATA_BITS_31, SSP_DATA_BITS_32
};

/**
 * enum ssp_mode - SSP mode of operation (Communication modes)
 */
enum ssp_mode {
	INTERRUPT_TRANSFER,
	POLLING_TRANSFER,
	DMA_TRANSFER
};

/**
 * enum ssp_rx_level_trig - receive FIFO watermark level which triggers
 * IT: Interrupt fires when _N_ or more elements in RX FIFO.
 */
enum ssp_rx_level_trig {
	SSP_RX_1_OR_MORE_ELEM,
	SSP_RX_4_OR_MORE_ELEM,
	SSP_RX_8_OR_MORE_ELEM,
	SSP_RX_16_OR_MORE_ELEM,
	SSP_RX_32_OR_MORE_ELEM
};

/**
 * Transmit FIFO watermark level which triggers (IT Interrupt fires
 * when _N_ or more empty locations in TX FIFO)
 */
enum ssp_tx_level_trig {
	SSP_TX_1_OR_MORE_EMPTY_LOC,
	SSP_TX_4_OR_MORE_EMPTY_LOC,
	SSP_TX_8_OR_MORE_EMPTY_LOC,
	SSP_TX_16_OR_MORE_EMPTY_LOC,
	SSP_TX_32_OR_MORE_EMPTY_LOC
};

/**
 * enum SPI Clock Phase - clock phase (Motorola SPI interface only)
 * @SSP_CLK_FIRST_EDGE: Receive data on first edge transition (actual direction depends on polarity)
 * @SSP_CLK_SECOND_EDGE: Receive data on second edge transition (actual direction depends on polarity)
 */
enum ssp_spi_clk_phase {
	SSP_CLK_FIRST_EDGE,
	SSP_CLK_SECOND_EDGE
};

/**
 * enum SPI Clock Polarity - clock polarity (Motorola SPI interface only)
 * @SSP_CLK_POL_IDLE_LOW: Low inactive level
 * @SSP_CLK_POL_IDLE_HIGH: High inactive level
 */
enum ssp_spi_clk_pol {
	SSP_CLK_POL_IDLE_LOW,
	SSP_CLK_POL_IDLE_HIGH
};

/**
 * Microwire Conrol Lengths Command size in microwire format
 */
enum ssp_microwire_ctrl_len {
	SSP_BITS_4 = 0x03, SSP_BITS_5, SSP_BITS_6,
	SSP_BITS_7, SSP_BITS_8, SSP_BITS_9,
	SSP_BITS_10, SSP_BITS_11, SSP_BITS_12,
	SSP_BITS_13, SSP_BITS_14, SSP_BITS_15,
	SSP_BITS_16, SSP_BITS_17, SSP_BITS_18,
	SSP_BITS_19, SSP_BITS_20, SSP_BITS_21,
	SSP_BITS_22, SSP_BITS_23, SSP_BITS_24,
	SSP_BITS_25, SSP_BITS_26, SSP_BITS_27,
	SSP_BITS_28, SSP_BITS_29, SSP_BITS_30,
	SSP_BITS_31, SSP_BITS_32
};

/**
 * enum Microwire Wait State
 * @SSP_MWIRE_WAIT_ZERO: No wait state inserted after last command bit
 * @SSP_MWIRE_WAIT_ONE: One wait state inserted after last command bit
 */
enum ssp_microwire_wait_state {
	SSP_MWIRE_WAIT_ZERO,
	SSP_MWIRE_WAIT_ONE
};

/**
 * enum ssp_duplex - whether Full/Half Duplex on microwire, only
 * available in the ST Micro variant.
 * @SSP_MICROWIRE_CHANNEL_FULL_DUPLEX: SSPTXD becomes bi-directional,
 *     SSPRXD not used
 * @SSP_MICROWIRE_CHANNEL_HALF_DUPLEX: SSPTXD is an output, SSPRXD is
 *     an input.
 */
enum ssp_duplex {
	SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
	SSP_MICROWIRE_CHANNEL_HALF_DUPLEX
};

/**
 * enum ssp_clkdelay - an optional clock delay on the feedback clock
 * only available in the ST Micro PL023 variant.
 * @SSP_FEEDBACK_CLK_DELAY_NONE: no delay, the data coming in from the
 * slave is sampled directly
 * @SSP_FEEDBACK_CLK_DELAY_1T: the incoming slave data is sampled with
 * a delay of T-dt
 * @SSP_FEEDBACK_CLK_DELAY_2T: dito with a delay if 2T-dt
 * @SSP_FEEDBACK_CLK_DELAY_3T: dito with a delay if 3T-dt
 * @SSP_FEEDBACK_CLK_DELAY_4T: dito with a delay if 4T-dt
 * @SSP_FEEDBACK_CLK_DELAY_5T: dito with a delay if 5T-dt
 * @SSP_FEEDBACK_CLK_DELAY_6T: dito with a delay if 6T-dt
 * @SSP_FEEDBACK_CLK_DELAY_7T: dito with a delay if 7T-dt
 */
enum ssp_clkdelay {
	SSP_FEEDBACK_CLK_DELAY_NONE,
	SSP_FEEDBACK_CLK_DELAY_1T,
	SSP_FEEDBACK_CLK_DELAY_2T,
	SSP_FEEDBACK_CLK_DELAY_3T,
	SSP_FEEDBACK_CLK_DELAY_4T,
	SSP_FEEDBACK_CLK_DELAY_5T,
	SSP_FEEDBACK_CLK_DELAY_6T,
	SSP_FEEDBACK_CLK_DELAY_7T
};

/**
 * CHIP select/deselect commands
 */
enum ssp_chip_select {
	SSP_CHIP_SELECT,
	SSP_CHIP_DESELECT
};


struct dma_chan;
/**
 * struct pl022_ssp_master - device.platform_data for SPI controller devices.
 * @bus_id: identifier for this bus
 * @num_chipselect: chipselects are used to distinguish individual
 *     SPI slaves, and are numbered from zero to num_chipselects - 1.
 *     each slave has a chipselect signal, but it's common that not
 *     every chipselect is connected to a slave.
 * @enable_dma: if true enables DMA driven transfers.
 * @dma_rx_param: parameter to locate an RX DMA channel.
 * @dma_tx_param: parameter to locate a TX DMA channel.
 * @autosuspend_delay: delay in ms following transfer completion before the
 *     runtime power management system suspends the device. A setting of 0
 *     indicates no delay and the device will be suspended immediately.
 * @rt: indicates the controller should run the message pump with realtime
 *     priority to minimise the transfer latency on the bus.
 * @chipselects: list of <num_chipselects> chip select gpios
 */
struct pl022_ssp_controller {
	u16 bus_id;
	u8 num_chipselect;
	u8 enable_dma:1;
	bool (*dma_filter)(struct dma_chan *chan, void *filter_param);
	void *dma_rx_param;
	void *dma_tx_param;
	int autosuspend_delay;
	bool rt;
	int *chipselects;
};

/**
 * struct ssp_config_chip - spi_board_info.controller_data for SPI
 * slave devices, copied to spi_device.controller_data.
 *
 * @iface: Interface type(Motorola, TI, Microwire, Universal)
 * @hierarchy: sets whether interface is master or slave
 * @slave_tx_disable: SSPTXD is disconnected (in slave mode only)
 * @clk_freq: Tune freq parameters of SSP(when in master mode)
 * @com_mode: communication mode: polling, Interrupt or DMA
 * @rx_lev_trig: Rx FIFO watermark level (for IT & DMA mode)
 * @tx_lev_trig: Tx FIFO watermark level (for IT & DMA mode)
 * @ctrl_len: Microwire interface: Control length
 * @wait_state: Microwire interface: Wait state
 * @duplex: Microwire interface: Full/Half duplex
 * @clkdelay: on the PL023 variant, the delay in feeback clock cycles
 * before sampling the incoming line
 * @cs_control: function pointer to board-specific function to
 * assert/deassert I/O port to control HW generation of devices chip-select.
 */
struct pl022_config_chip {
	enum ssp_interface iface;
	enum ssp_hierarchy hierarchy;
	bool slave_tx_disable;
	struct ssp_clock_params clk_freq;
	enum ssp_mode com_mode;
	enum ssp_rx_level_trig rx_lev_trig;
	enum ssp_tx_level_trig tx_lev_trig;
	enum ssp_microwire_ctrl_len ctrl_len;
	enum ssp_microwire_wait_state wait_state;
	enum ssp_duplex duplex;
	enum ssp_clkdelay clkdelay;
	void (*cs_control) (u32 control);
};

#endif /* _SSP_PL022_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /* linux/amba/pl093.h
 *
 * Copyright (c) 2008 Simtec Electronics
 *	http://armlinux.simtec.co.uk/
 *	Ben Dooks <ben@simtec.co.uk>
 *
 * AMBA PL093 SSMC (synchronous static memory controller)
 *  See DDI0236.pdf (r0p4) for more details
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

#define SMB_BANK(x)	((x) * 0x20) /* each bank control set is 0x20 apart */

/* Offsets for SMBxxxxRy registers */

#define SMBIDCYR	(0x00)
#define SMBWSTRDR	(0x04)
#define SMBWSTWRR	(0x08)
#define SMBWSTOENR	(0x0C)
#define SMBWSTWENR	(0x10)
#define SMBCR		(0x14)
#define SMBSR		(0x18)
#define SMBWSTBRDR	(0x1C)

/* Masks for SMB registers */
#define IDCY_MASK	(0xf)
#define WSTRD_MASK	(0xf)
#define WSTWR_MASK	(0xf)
#define WSTOEN_MASK	(0xf)
#define WSTWEN_MASK	(0xf)

/* Notes from datasheet:
 *	WSTOEN <= WSTRD
 *	WSTWEN <= WSTWR
 *
 * WSTOEN is not used with nWAIT
 */

/* SMBCR bit definitions */
#define SMBCR_BIWRITEEN		(1 << 21)
#define SMBCR_ADDRVALIDWRITEEN	(1 << 20)
#define SMBCR_SYNCWRITE		(1 << 17)
#define SMBCR_BMWRITE		(1 << 16)
#define SMBCR_WRAPREAD		(1 << 14)
#define SMBCR_BIREADEN		(1 << 13)
#define SMBCR_ADDRVALIDREADEN	(1 << 12)
#define SMBCR_SYNCREAD		(1 << 9)
#define SMBCR_BMREAD		(1 << 8)
#define SMBCR_SMBLSPOL		(1 << 6)
#define SMBCR_WP		(1 << 3)
#define SMBCR_WAITEN		(1 << 2)
#define SMBCR_WAITPOL		(1 << 1)
#define SMBCR_RBLE		(1 << 0)

#define SMBCR_BURSTLENWRITE_MASK	(3 << 18)
#define SMBCR_BURSTLENWRITE_4		(0 << 18)
#define SMBCR_BURSTLENWRITE_8		(1 << 18)
#define SMBCR_BURSTLENWRITE_RESERVED	(2 << 18)
#define SMBCR_BURSTLENWRITE_CONTINUOUS	(3 << 18)

#define SMBCR_BURSTLENREAD_MASK		(3 << 10)
#define SMBCR_BURSTLENREAD_4		(0 << 10)
#define SMBCR_BURSTLENREAD_8		(1 << 10)
#define SMBCR_BURSTLENREAD_16		(2 << 10)
#define SMBCR_BURSTLENREAD_CONTINUOUS	(3 << 10)

#define SMBCR_MW_MASK			(3 << 4)
#define SMBCR_MW_8BIT			(0 << 4)
#define SMBCR_MW_16BIT			(1 << 4)
#define SMBCR_MW_M32BIT			(2 << 4)

/* SSMC status registers */
#define SSMCCSR		(0x200)
#define SSMCCR		(0x204)
#define SSMCITCR	(0x208)
#define SSMCITIP	(0x20C)
#define SSMCITIOP	(0x210)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 *  linux/include/asm-arm/hardware/amba_kmi.h
 *
 *  Internal header file for AMBA KMI ports
 *
 *  Copyright (C) 2000 Deep Blue Solutions Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * ---------------------------------------------------------------------------
 *  From ARM PrimeCell(tm) PS2 Keyboard/Mouse Interface (PL050) Technical
 *  Reference Manual - ARM DDI 0143B - see http://www.arm.com/
 * ---------------------------------------------------------------------------
 */
#ifndef ASM_ARM_HARDWARE_AMBA_KMI_H
#define ASM_ARM_HARDWARE_AMBA_KMI_H

/*
 * KMI control register:
 *  KMICR_TYPE       0 = PS2/AT mode, 1 = No line control bit mode
 *  KMICR_RXINTREN   1 = enable RX interrupts
 *  KMICR_TXINTREN   1 = enable TX interrupts
 *  KMICR_EN         1 = enable KMI
 *  KMICR_FD         1 = force KMI data low
 *  KMICR_FC         1 = force KMI clock low
 */
#define KMICR		(KMI_BASE + 0x00)
#define KMICR_TYPE		(1 << 5)
#define KMICR_RXINTREN		(1 << 4)
#define KMICR_TXINTREN		(1 << 3)
#define KMICR_EN		(1 << 2)
#define KMICR_FD		(1 << 1)
#define KMICR_FC		(1 << 0)

/*
 * KMI status register:
 *  KMISTAT_TXEMPTY  1 = transmitter register empty
 *  KMISTAT_TXBUSY   1 = currently sending data
 *  KMISTAT_RXFULL   1 = receiver register ready to be read
 *  KMISTAT_RXBUSY   1 = currently receiving data
 *  KMISTAT_RXPARITY parity of last databyte received
 *  KMISTAT_IC       current level of KMI clock input
 *  KMISTAT_ID       current level of KMI data input
 */
#define KMISTAT		(KMI_BASE + 0x04)
#define KMISTAT_TXEMPTY		(1 << 6)
#define KMISTAT_TXBUSY		(1 << 5)
#define KMISTAT_RXFULL		(1 << 4)
#define KMISTAT_RXBUSY		(1 << 3)
#define KMISTAT_RXPARITY	(1 << 2)
#define KMISTAT_IC		(1 << 1)
#define KMISTAT_ID		(1 << 0)

/*
 * KMI data register
 */
#define KMIDATA		(KMI_BASE + 0x08)

/*
 * KMI clock divisor: to generate 8MHz internal clock
 *  div = (ref / 8MHz) - 1; 0 <= div <= 15
 */
#define KMICLKDIV	(KMI_BASE + 0x0c)

/*
 * KMI interrupt register:
 *  KMIIR_TXINTR     1 = transmit interrupt asserted
 *  KMIIR_RXINTR     1 = receive interrupt asserted
 */
#define KMIIR		(KMI_BASE + 0x10)
#define KMIIR_TXINTR		(1 << 1)
#define KMIIR_RXINTR		(1 << 0)

/*
 * The size of the KMI primecell
 */
#define KMI_SIZE	(0x100)

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * linux/amba/pl08x.h - ARM PrimeCell DMA Controller driver
 *
 * Copyright (C) 2005 ARM Ltd
 * Copyright (C) 2010 ST-Ericsson SA
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * pl08x information required by platform code
 *
 * Please credit ARM.com
 * Documentation: ARM DDI 0196D
 */

#ifndef AMBA_PL08X_H
#define AMBA_PL08X_H

/* We need sizes of structs from this header */
#include <linux/dmaengine.h>
#include <linux/interrupt.h>

struct pl08x_driver_data;
struct pl08x_phy_chan;
struct pl08x_txd;

/* Bitmasks for selecting AHB ports for DMA transfers */
enum {
	PL08X_AHB1 = (1 << 0),
	PL08X_AHB2 = (1 << 1)
};

/**
 * struct pl08x_channel_data - data structure to pass info between
 * platform and PL08x driver regarding channel configuration
 * @bus_id: name of this device channel, not just a device name since
 * devices may have more than one channel e.g. "foo_tx"
 * @min_signal: the minimum DMA signal number to be muxed in for this
 * channel (for platforms supporting muxed signals). If you have
 * static assignments, make sure this is set to the assigned signal
 * number, PL08x have 16 possible signals in number 0 thru 15 so
 * when these are not enough they often get muxed (in hardware)
 * disabling simultaneous use of the same channel for two devices.
 * @max_signal: the maximum DMA signal number to be muxed in for
 * the channel. Set to the same as min_signal for
 * devices with static assignments
 * @muxval: a number usually used to poke into some mux regiser to
 * mux in the signal to this channel
 * @cctl_memcpy: options for the channel control register for memcpy
 *  *** not used for slave channels ***
 * @addr: source/target address in physical memory for this DMA channel,
 * can be the address of a FIFO register for burst requests for example.
 * This can be left undefined if the PrimeCell API is used for configuring
 * this.
 * @single: the device connected to this channel will request single DMA
 * transfers, not bursts. (Bursts are default.)
 * @periph_buses: the device connected to this channel is accessible via
 * these buses (use PL08X_AHB1 | PL08X_AHB2).
 */
struct pl08x_channel_data {
	const char *bus_id;
	int min_signal;
	int max_signal;
	u32 muxval;
	u32 cctl_memcpy;
	dma_addr_t addr;
	bool single;
	u8 periph_buses;
};

/**
 * struct pl08x_platform_data - the platform configuration for the PL08x
 * PrimeCells.
 * @slave_channels: the channels defined for the different devices on the
 * platform, all inclusive, including multiplexed channels. The available
 * physical channels will be multiplexed around these signals as they are
 * requested, just enumerate all possible channels.
 * @get_xfer_signal: request a physical signal to be used for a DMA transfer
 * immediately: if there is some multiplexing or similar blocking the use
 * of the channel the transfer can be denied by returning less than zero,
 * else it returns the allocated signal number
 * @put_xfer_signal: indicate to the platform that this physical signal is not
 * running any DMA transfer and multiplexing can be recycled
 * @lli_buses: buses which LLIs can be fetched from: PL08X_AHB1 | PL08X_AHB2
 * @mem_buses: buses which memory can be accessed from: PL08X_AHB1 | PL08X_AHB2
 */
struct pl08x_platform_data {
	const struct pl08x_channel_data *slave_channels;
	unsigned int num_slave_channels;
	struct pl08x_channel_data memcpy_channel;
	int (*get_xfer_signal)(const struct pl08x_channel_data *);
	void (*put_xfer_signal)(const struct pl08x_channel_data *, int);
	u8 lli_buses;
	u8 mem_buses;
};

#ifdef CONFIG_AMBA_PL08X
bool pl08x_filter_id(struct dma_chan *chan, void *chan_id);
#else
static inline bool pl08x_filter_id(struct dma_chan *chan, void *chan_id)
{
	return false;
}
#endif

#endif	/* AMBA_PL08X_H */
                                                                                                                                                                                               /*
 * consumer.h -- SoC Regulator consumer support.
 *
 * Copyright (C) 2007, 2008 Wolfson Microelectronics PLC.
 *
 * Author: Liam Girdwood <lrg@slimlogic.co.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Regulator Consumer Interface.
 *
 * A Power Management Regulator framework for SoC based devices.
 * Features:-
 *   o Voltage and current level control.
 *   o Operating mode control.
 *   o Regulator status.
 *   o sysfs entries for showing client devices and status
 *
 * EXPERIMENTAL FEATURES:
 *   Dynamic Regulator operating Mode Switching (DRMS) - allows regulators
 *   to use most efficient operating mode depending upon voltage and load and
 *   is transparent to client drivers.
 *
 *   e.g. Devices x,y,z share regulator r. Device x and y draw 20mA each during
 *   IO and 1mA at idle. Device z draws 100mA when under load and 5mA when
 *   idling. Regulator r has > 90% efficiency in NORMAL mode at loads > 100mA
 *   but this drops rapidly to 60% when below 100mA. Regulator r has > 90%
 *   efficiency in IDLE mode at loads < 10mA. Thus regulator r will operate
 *   in normal mode for loads > 10mA and in IDLE mode for load <= 10mA.
 *
 */

#ifndef __LINUX_REGULATOR_CONSUMER_H_
#define __LINUX_REGULATOR_CONSUMER_H_

#include <linux/err.h>

struct device;
struct notifier_block;
struct regmap;

/*
 * Regulator operating modes.
 *
 * Regulators can run in a variety of different operating modes depending on
 * output load. This allows further system power savings by selecting the
 * best (and most efficient) regulator mode for a desired load.
 *
 * Most drivers will only care about NORMAL. The modes below are generic and
 * will probably not match the naming convention of your regulator data sheet
 * but should match the use cases in the datasheet.
 *
 * In order of power efficiency (least efficient at top).
 *
 *  Mode       Description
 *  FAST       Regulator can handle fast changes in it's load.
 *             e.g. useful in CPU voltage & frequency scaling where
 *             load can quickly increase with CPU frequency increases.
 *
 *  NORMAL     Normal regulator power supply mode. Most drivers will
 *             use this mode.
 *
 *  IDLE       Regulator runs in a more efficient mode for light
 *             loads. Can be used for devices that have a low power
 *             requirement during periods of inactivity. This mode
 *             may be more noisy than NORMAL and may not be able
 *             to handle fast load switching.
 *
 *  STANDBY    Regulator runs in the most efficient mode for very
 *             light loads. Can be used by devices when they are
 *             in a sleep/standby state. This mode is likely to be
 *             the most noisy and may not be able to handle fast load
 *             switching.
 *
 * NOTE: Most regulators will only support a subset of these modes. Some
 * will only just support NORMAL.
 *
 * These modes can be OR'ed together to make up a mask of valid register modes.
 */

#define REGULATOR_MODE_FAST			0x1
#define REGULATOR_MODE_NORMAL			0x2
#define REGULATOR_MODE_IDLE			0x4
#define REGULATOR_MODE_STANDBY			0x8

/*
 * Regulator notifier events.
 *
 * UNDER_VOLTAGE  Regulator output is under voltage.
 * OVER_CURRENT   Regulator output current is too high.
 * REGULATION_OUT Regulator output is out of regulation.
 * FAIL           Regulator output has failed.
 * OVER_TEMP      Regulator over temp.
 * FORCE_DISABLE  Regulator forcibly shut down by software.
 * VOLTAGE_CHANGE Regulator voltage changed.
 *                Data passed is old voltage cast to (void *).
 * DISABLE        Regulator was disabled.
 * PRE_VOLTAGE_CHANGE   Regulator is about to have voltage changed.
 *                      Data passed is "struct pre_voltage_change_data"
 * ABORT_VOLTAGE_CHANGE Regulator voltage change failed for some reason.
 *                      Data passed is old voltage cast to (void *).
 * PRE_DISABLE    Regulator is about to be disabled
 * ABORT_DISABLE  Regulator disable failed for some reason
 *
 * NOTE: These events can be OR'ed together when passed into handler.
 */

#define REGULATOR_EVENT_UNDER_VOLTAGE		0x01
#define REGULATOR_EVENT_OVER_CURRENT		0x02
#define REGULATOR_EVENT_REGULATION_OUT		0x04
#define REGULATOR_EVENT_FAIL			0x08
#define REGULATOR_EVENT_OVER_TEMP		0x10
#define REGULATOR_EVENT_FORCE_DISABLE		0x20
#define REGULATOR_EVENT_VOLTAGE_CHANGE		0x40
#define REGULATOR_EVENT_DISABLE			0x80
#define REGULATOR_EVENT_PRE_VOLTAGE_CHANGE	0x100
#define REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE	0x200
#define REGULATOR_EVENT_PRE_DISABLE		0x400
#define REGULATOR_EVENT_ABORT_DISABLE		0x800

/**
 * struct pre_voltage_change_data - Data sent with PRE_VOLTAGE_CHANGE event
 *
 * @old_uV: Current voltage before change.
 * @min_uV: Min voltage we'll change to.
 * @max_uV: Max voltage we'll change to.
 */
struct pre_voltage_change_data {
	unsigned long old_uV;
	unsigned long min_uV;
	unsigned long max_uV;
};

struct regulator;

/**
 * struct regulator_bulk_data - Data used for bulk regulator operations.
 *
 * @supply:   The name of the supply.  Initialised by the user before
 *            using the bulk regulator APIs.
 * @consumer: The regulator consumer for the supply.  This will be managed
 *            by the bulk API.
 *
 * The regulator APIs provide a series of regulator_bulk_() API calls as
 * a convenience to consumers which require multiple supplies.  This
 * structure is used to manage data for these calls.
 */
struct regulator_bulk_data {
	const char *supply;
	struct regulator *consumer;

	/* private: Internal use */
	int ret;
};

#if defined(CONFIG_REGULATOR)

/* regulator get and put */
struct regulator *__must_check regulator_get(struct device *dev,
					     const char *id);
struct regulator *__must_check devm_regulator_get(struct device *dev,
					     const char *id);
struct regulator *__must_check regulator_get_exclusive(struct device *dev,
						       const char *id);
struct regulator *__must_check devm_regulator_get_exclusive(struct device *dev,
							const char *id);
struct regulator *__must_check regulator_get_optional(struct device *dev,
						      const char *id);
struct regulator *__must_check devm_regulator_get_optional(struct device *dev,
							   const char *id);
void regulator_put(struct regulator *regulator);
void devm_regulator_put(struct regulator *regulator);

int regulator_register_supply_alias(struct device *dev, const char *id,
				    struct device *alias_dev,
				    const char *alias_id);
void regulator_unregister_supply_alias(struct device *dev, const char *id);

int regulator_bulk_register_supply_alias(struct device *dev,
					 const char *const *id,
					 struct device *alias_dev,
					 const char *const *alias_id,
					 int num_id);
void regulator_bulk_unregister_supply_alias(struct device *dev,
					    const char * const *id, int num_id);

int devm_regulator_register_supply_alias(struct device *dev, const char *id,
					 struct device *alias_dev,
					 const char *alias_id);
void devm_regulator_unregister_supply_alias(struct device *dev,
					    const char *id);

int devm_regulator_bulk_register_supply_alias(struct device *dev,
					      const char *const *id,
					      struct device *alias_dev,
					      const char *const *alias_id,
					      int num_id);
void devm_regulator_bulk_unregister_supply_alias(struct device *dev,
						 const char *const *id,
						 int num_id);

/* regulator output control and status */
int __must_check regulator_enable(struct regulator *regulator);
int regulator_disable(struct regulator *regulator);
int regulator_force_disable(struct regulator *regulator);
int regulator_is_enabled(struct regulator *regulator);
int regulator_disable_deferred(struct regulator *regulator, int ms);

int __must_check regulator_bulk_get(struct device *dev, int num_consumers,
				    struct regulator_bulk_data *consumers);
int __must_check devm_regulator_bulk_get(struct device *dev, int num_consumers,
					 struct regulator_bulk_data *consumers);
int __must_check regulator_bulk_enable(int num_consumers,
				       struct regulator_bulk_data *consumers);
int regulator_bulk_disable(int num_consumers,
			   struct regulator_bulk_data *consumers);
int regulator_bulk_force_disable(int num_consumers,
			   struct regulator_bulk_data *consumers);
void regulator_bulk_free(int num_consumers,
			 struct regulator_bulk_data *consumers);

int regulator_can_change_voltage(struct regulator *regulator);
int regulator_count_voltages(struct regulator *regulator);
int regulator_list_voltage(struct regulator *regulator, unsigned selector);
int regulator_is_supported_voltage(struct regulator *regulator,
				   int min_uV, int max_uV);
unsigned int regulator_get_linear_step(struct regulator *regulator);
int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV);
int regulator_set_voltage_time(struct regulator *regulator,
			       int old_uV, int new_uV);
int regulator_get_voltage(struct regulator *regulator);
int regulator_sync_voltage(struct regulator *regulator);
int regulator_set_current_limit(struct regulator *regulator,
			       int min_uA, int max_uA);
int regulator_get_current_limit(struct regulator *regulator);

int regulator_set_mode(struct regulator *regulator, unsigned int mode);
unsigned int regulator_get_mode(struct regulator *regulator);
int regulator_set_load(struct regulator *regulator, int load_uA);

int regulator_allow_bypass(struct regulator *regulator, bool allow);

struct regmap *regulator_get_regmap(struct regulator *regulator);
int regulator_get_hardware_vsel_register(struct regulator *regulator,
					 unsigned *vsel_reg,
					 unsigned *vsel_mask);
int regulator_list_hardware_vsel(struct regulator *regulator,
				 unsigned selector);

/* regulator notifier block */
int regulator_register_notifier(struct regulator *regulator,
			      struct notifier_block *nb);
int devm_regulator_register_notifier(struct regulator *regulator,
				     struct notifier_block *nb);
int regulator_unregister_notifier(struct regulator *regulator,
				struct notifier_block *nb);
void devm_regulator_unregister_notifier(struct regulator *regulator,
					struct notifier_block *nb);

/* driver data - core doesn't touch */
void *regulator_get_drvdata(struct regulator *regulator);
void regulator_set_drvdata(struct regulator *regulator, void *data);

#else

/*
 * Make sure client drivers will still build on systems with no software
 * controllable voltage or current regulators.
 */
static inline struct regulator *__must_check regulator_get(struct device *dev,
	const char *id)
{
	/* Nothing except the stubbed out regulator API should be
	 * looking at the value except to check if it is an error
	 * value. Drivers are free to handle NULL specifically by
	 * skipping all regulator API calls, but they don't have to.
	 * Drivers which don't, should make sure they properly handle
	 * corner cases of the API, such as regulator_get_voltage()
	 * returning 0.
	 */
	return NULL;
}

static inline struct regulator *__must_check
devm_regulator_get(struct device *dev, const char *id)
{
	return NULL;
}

static inline struct regulator *__must_check
regulator_get_exclusive(struct device *dev, const char *id)
{
	return ERR_PTR(-ENODEV);
}

static inline struct regulator *__must_check
regulator_get_optional(struct device *dev, const char *id)
{
	return ERR_PTR(-ENODEV);
}


static inline struct regulator *__must_check
devm_regulator_get_optional(struct device *dev, const char *id)
{
	return ERR_PTR(-ENODEV);
}

static inline void regulator_put(struct regulator *regulator)
{
}

static inline void devm_regulator_put(struct regulator *regulator)
{
}

static inline int regulator_register_supply_alias(struct device *dev,
						  const char *id,
						  struct device *alias_dev,
						  const char *alias_id)
{
	return 0;
}

static inline void regulator_unregister_supply_alias(struct device *dev,
						    const char *id)
{
}

static inline int regulator_bulk_register_supply_alias(struct device *dev,
						const char *const *id,
						struct device *alias_dev,
						const char * const *alias_id,
						int num_id)
{
	return 0;
}

static inline void regulator_bulk_unregister_supply_alias(struct device *dev,
						const char * const *id,
						int num_id)
{
}

static inline int devm_regulator_register_supply_alias(struct device *dev,
						       const char *id,
						       struct device *alias_dev,
						       const char *alias_id)
{
	return 0;
}

static inline void devm_regulator_unregister_supply_alias(struct device *dev,
							  const char *id)
{
}

static inline int devm_regulator_bulk_register_supply_alias(struct device *dev,
						const char *const *id,
						struct device *alias_dev,
						const char *const *alias_id,
						int num_id)
{
	return 0;
}

static inline void devm_regulator_bulk_unregister_supply_alias(
	struct device *dev, const char *const *id, int num_id)
{
}

static inline int regulator_enable(struct regulator *regulator)
{
	return 0;
}

static inline int regulator_disable(struct regulator *regulator)
{
	return 0;
}

static inline int regulator_force_disable(struct regulator *regulator)
{
	return 0;
}

static inline int regulator_disable_deferred(struct regulator *regulator,
					     int ms)
{
	return 0;
}

static inline int regulator_is_enabled(struct regulator *regulator)
{
	return 1;
}

static inline int regulator_bulk_get(struct device *dev,
				     int num_consumers,
				     struct regulator_bulk_data *consumers)
{
	return 0;
}

static inline int devm_regulator_bulk_get(struct device *dev, int num_consumers,
					  struct regulator_bulk_data *consumers)
{
	return 0;
}

static inline int regulator_bulk_enable(int num_consumers,
					struct regulator_bulk_data *consumers)
{
	return 0;
}

static inline int regulator_bulk_disable(int num_consumers,
					 struct regulator_bulk_data *consumers)
{
	return 0;
}

static inline int regulator_bulk_force_disable(int num_consumers,
					struct regulator_bulk_data *consumers)
{
	return 0;
}

static inline void regulator_bulk_free(int num_consumers,
				       struct regulator_bulk_data *consumers)
{
}

static inline int regulator_can_change_voltage(struct regulator *regulator)
{
	return 0;
}

static inline int regulator_set_voltage(struct regulator *regulator,
					int min_uV, int max_uV)
{
	return 0;
}

static inline int regulator_set_voltage_time(struct regulator *regulator,
					     int old_uV, int new_uV)
{
	return 0;
}

static inline int regulator_get_voltage(struct regulator *regulator)
{
	return -EINVAL;
}

static inline int regulator_is_supported_voltage(struct regulator *regulator,
				   int min_uV, int max_uV)
{
	return 0;
}

static inline int regulator_set_current_limit(struct regulator *regulator,
					     int min_uA, int max_uA)
{
	return 0;
}

static inline int regulator_get_current_limit(struct regulator *regulator)
{
	return 0;
}

static inline int regulator_set_mode(struct regulator *regulator,
	unsigned int mode)
{
	return 0;
}

static inline unsigned int regulator_get_mode(struct regulator *regulator)
{
	return REGULATOR_MODE_NORMAL;
}

static inline int regulator_set_load(struct regulator *regulator, int load_uA)
{
	return REGULATOR_MODE_NORMAL;
}

static inline int regulator_allow_bypass(struct regulator *regulator,
					 bool allow)
{
	return 0;
}

static inline struct regmap *regulator_get_regmap(struct regulator *regulator)
{
	return ERR_PTR(-EOPNOTSUPP);
}

static inline int regulator_get_hardware_vsel_register(struct regulator *regulator,
						       unsigned *vsel_reg,
						       unsigned *vsel_mask)
{
	return -EOPNOTSUPP;
}

static inline int regulator_list_hardware_vsel(struct regulator *regulator,
					       unsigned selector)
{
	return -EOPNOTSUPP;
}

static inline int regulator_register_notifier(struct regulator *regulator,
			      struct notifier_block *nb)
{
	return 0;
}

static inline int devm_regulator_register_notifier(struct regulator *regulator,
						   struct notifier_block *nb)
{
	return 0;
}

static inline int regulator_unregister_notifier(struct regulator *regulator,
				struct notifier_block *nb)
{
	return 0;
}

static inline int devm_regulator_unregister_notifier(struct regulator *regulator,
						     struct notifier_block *nb)
{
	return 0;
}

static inline void *regulator_get_drvdata(struct regulator *regulator)
{
	return NULL;
}

static inline void regulator_set_drvdata(struct regulator *regulator,
	void *data)
{
}

static inline int regulator_count_voltages(struct regulator *regulator)
{
	return 0;
}
#endif

static inline int regulator_set_voltage_tol(struct regulator *regulator,
					    int new_uV, int tol_uV)
{
	if (regulator_set_voltage(regulator, new_uV, new_uV + tol_uV) == 0)
		return 0;
	else
		return regulator_set_voltage(regulator,
					     new_uV - tol_uV, new_uV + tol_uV);
}

static inline int regulator_is_supported_voltage_tol(struct regulator *regulator,
						     int target_uV, int tol_uV)
{
	return regulator_is_supported_voltage(regulator,
					      target_uV - tol_uV,
					      target_uV + tol_uV);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * National Semiconductors LP3971 PMIC chip client interface
 *
 *  Copyright (C) 2009 Samsung Electronics
 *  Author: Marek Szyprowski <m.szyprowski@samsung.com>
 *
 * Based on wm8400.h
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef __LINUX_REGULATOR_LP3971_H
#define __LINUX_REGULATOR_LP3971_H

#include <linux/regulator/machine.h>

#define LP3971_LDO1  0
#define LP3971_LDO2  1
#define LP3971_LDO3  2
#define LP3971_LDO4  3
#define LP3971_LDO5  4

#define LP3971_DCDC1 5
#define LP3971_DCDC2 6
#define LP3971_DCDC3 7

#define LP3971_NUM_REGULATORS 8

struct lp3971_regulator_subdev {
	int id;
	struct regulator_init_data *initdata;
};

struct lp3971_platform_data {
	int num_regulators;
	struct lp3971_regulator_subdev *regulators;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * max1586.h  --  Voltage regulation for the Maxim 1586
 *
 * Copyright (C) 2008 Robert Jarzmik
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef REGULATOR_MAX1586
#define REGULATOR_MAX1586

#include <linux/regulator/machine.h>

#define MAX1586_V3 0
#define MAX1586_V6 1

/* precalculated values for v3_gain */
#define MAX1586_GAIN_NO_R24   1000000  /* 700000 .. 1475000 mV */
#define MAX1586_GAIN_R24_3k32 1051098  /* 735768 .. 1550369 mV */
#define MAX1586_GAIN_R24_5k11 1078648  /* 755053 .. 1591005 mV */
#define MAX1586_GAIN_R24_7k5  1115432  /* 780802 .. 1645262 mV */

/**
 * max1586_subdev_data - regulator data
 * @id: regulator Id (either MAX1586_V3 or MAX1586_V6)
 * @name: regulator cute name (example for V3: "vcc_core")
 * @platform_data: regulator init data (constraints, supplies, ...)
 */
struct max1586_subdev_data {
	int				id;
	const char			*name;
	struct regulator_init_data	*platform_data;
};

/**
 * max1586_platform_data - platform data for max1586
 * @num_subdevs: number of regulators used (may be 1 or 2)
 * @subdevs: regulator used
 *           At most, there will be a regulator for V3 and one for V6 voltages.
 * @v3_gain: gain on the V3 voltage output multiplied by 1e6.
 *           This can be calculated as ((1 + R24/R25 + R24/185.5kOhm) * 1e6)
 *           for an external resistor configuration as described in the
 *           data sheet (R25=100kOhm).
 */
struct max1586_platform_data {
	int num_subdevs;
	struct max1586_subdev_data *subdevs;
	int v3_gain;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * act8865.h  --  Voltage regulation for active-semi act88xx PMUs
 *
 * Copyright (C) 2013 Atmel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#ifndef __LINUX_REGULATOR_ACT8865_H
#define __LINUX_REGULATOR_ACT8865_H

#include <linux/regulator/machine.h>

enum {
	ACT8600_ID_DCDC1,
	ACT8600_ID_DCDC2,
	ACT8600_ID_DCDC3,
	ACT8600_ID_SUDCDC4,
	ACT8600_ID_LDO5,
	ACT8600_ID_LDO6,
	ACT8600_ID_LDO7,
	ACT8600_ID_LDO8,
	ACT8600_ID_LDO9,
	ACT8600_ID_LDO10,
};

enum {
	ACT8865_ID_DCDC1,
	ACT8865_ID_DCDC2,
	ACT8865_ID_DCDC3,
	ACT8865_ID_LDO1,
	ACT8865_ID_LDO2,
	ACT8865_ID_LDO3,
	ACT8865_ID_LDO4,
	ACT8865_REG_NUM,
};

enum {
	ACT8846_ID_REG1,
	ACT8846_ID_REG2,
	ACT8846_ID_REG3,
	ACT8846_ID_REG4,
	ACT8846_ID_REG5,
	ACT8846_ID_REG6,
	ACT8846_ID_REG7,
	ACT8846_ID_REG8,
	ACT8846_ID_REG9,
	ACT8846_ID_REG10,
	ACT8846_ID_REG11,
	ACT8846_ID_REG12,
	ACT8846_REG_NUM,
};

enum {
	ACT8600,
	ACT8865,
	ACT8846,
};

/**
 * act8865_regulator_data - regulator data
 * @id: regulator id
 * @name: regulator name
 * @platform_data: regulator init data
 */
struct act8865_regulator_data {
	int id;
	const char *name;
	struct regulator_init_data *platform_data;
};

/**
 * act8865_platform_data - platform data for act8865
 * @num_regulators: number of regulators used
 * @regulators: pointer to regulators used
 */
struct act8865_platform_data {
	int num_regulators;
	struct act8865_regulator_data *regulators;
};
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * tps6507x.h  --  Voltage regulation for the Texas Instruments TPS6507X
 *
 * Copyright (C) 2010 Texas Instruments, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */

#ifndef REGULATOR_TPS6507X
#define REGULATOR_TPS6507X

/**
 * tps6507x_reg_platform_data - platform data for tps6507x
 * @defdcdc_default: Defines whether DCDC high or the low register controls
 *	output voltage by default. Valid for DCDC2 and DCDC3 outputs only.
 */
struct tps6507x_reg_platform_data {
	bool defdcdc_default;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Copyright (C) ST-Ericsson SA 2010
 *
 * License Terms: GNU General Public License v2
 *
 * Author: Bengt Jonsson <bengt.g.jonsson@stericsson.com> for ST-Ericsson
 *
 * Interface to power domain regulators on DB8500
 */

#ifndef __REGULATOR_H__
#define __REGULATOR_H__

/* Number of DB8500 regulators and regulator enumeration */
enum db8500_regulator_id {
	DB8500_REGULATOR_VAPE,
	DB8500_REGULATOR_VARM,
	DB8500_REGULATOR_VMODEM,
	DB8500_REGULATOR_VPLL,
	DB8500_REGULATOR_VSMPS1,
	DB8500_REGULATOR_VSMPS2,
	DB8500_REGULATOR_VSMPS3,
	DB8500_REGULATOR_VRF1,
	DB8500_REGULATOR_SWITCH_SVAMMDSP,
	DB8500_REGULATOR_SWITCH_SVAMMDSPRET,
	DB8500_REGULATOR_SWITCH_SVAPIPE,
	DB8500_REGULATOR_SWITCH_SIAMMDSP,
	DB8500_REGULATOR_SWITCH_SIAMMDSPRET,
	DB8500_REGULATOR_SWITCH_SIAPIPE,
	DB8500_REGULATOR_SWITCH_SGA,
	DB8500_REGULATOR_SWITCH_B2R2_MCDE,
	DB8500_REGULATOR_SWITCH_ESRAM12,
	DB8500_REGULATOR_SWITCH_ESRAM12RET,
	DB8500_REGULATOR_SWITCH_ESRAM34,
	DB8500_REGULATOR_SWITCH_ESRAM34RET,
	DB8500_NUM_REGULATORS
};

/*
 * Exported interface for CPUIdle only. This function is called with all
 * interrupts turned off.
 */
int power_state_active_is_enabled(void);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * Copyright 2012 Texas Instruments
 *
 * Author: Milo(Woogyom) Kim <milo.kim@ti.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 */

#ifndef __LP872X_REGULATOR_H__
#define __LP872X_REGULATOR_H__

#include <linux/regulator/machine.h>
#include <linux/platform_device.h>
#include <linux/gpio.h>

#define LP872X_MAX_REGULATORS		9

enum lp872x_regulator_id {
	LP8720_ID_BASE,
	LP8720_ID_LDO1 = LP8720_ID_BASE,
	LP8720_ID_LDO2,
	LP8720_ID_LDO3,
	LP8720_ID_LDO4,
	LP8720_ID_LDO5,
	LP8720_ID_BUCK,

	LP8725_ID_BASE,
	LP8725_ID_LDO1 = LP8725_ID_BASE,
	LP8725_ID_LDO2,
	LP8725_ID_LDO3,
	LP8725_ID_LDO4,
	LP8725_ID_LDO5,
	LP8725_ID_LILO1,
	LP8725_ID_LILO2,
	LP8725_ID_BUCK1,
	LP8725_ID_BUCK2,

	LP872X_ID_MAX,
};

enum lp872x_dvs_state {
	DVS_LOW  = GPIOF_OUT_INIT_LOW,
	DVS_HIGH = GPIOF_OUT_INIT_HIGH,
};

enum lp872x_dvs_sel {
	SEL_V1,
	SEL_V2,
};

/**
 * lp872x_dvs
 * @gpio       : gpio pin number for dvs control
 * @vsel       : dvs selector for buck v1 or buck v2 register
 * @init_state : initial dvs pin state
 */
struct lp872x_dvs {
	int gpio;
	enum lp872x_dvs_sel vsel;
	enum lp872x_dvs_state init_state;
};

/**
 * lp872x_regdata
 * @id        : regulator id
 * @init_data : init data for each regulator
 */
struct lp872x_regulator_data {
	enum lp872x_regulator_id id;
	struct regulator_init_data *init_data;
};

/**
 * lp872x_platform_data
 * @general_config    : the value of LP872X_GENERAL_CFG register
 * @update_config     : if LP872X_GENERAL_CFG register is updated, set true
 * @regulator_data    : platform regulator id and init data
 * @dvs               : dvs data for buck voltage control
 */
struct lp872x_platform_data {
	u8 general_config;
	bool update_config;
	struct lp872x_regulator_data regulator_data[LP872X_MAX_REGULATORS];
	struct lp872x_dvs *dvs;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * tps51632-regulator.h -- TPS51632 regulator
 *
 * Interface for regulator driver for TPS51632 3-2-1 Phase D-Cap Step Down
 * Driverless Controller with serial VID control and DVFS.
 *
 * Copyright (C) 2012 NVIDIA Corporation

 * Author: Laxman Dewangan <ldewangan@nvidia.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA	02110-1301, USA.
 *
 */

#ifndef __LINUX_REGULATOR_TPS51632_H
#define __LINUX_REGULATOR_TPS51632_H

/*
 * struct tps51632_regulator_platform_data - tps51632 regulator platform data.
 *
 * @reg_init_data: The regulator init data.
 * @enable_pwm_dvfs: Enable PWM DVFS or not.
 * @dvfs_step_20mV: Step for DVFS is 20mV or 10mV.
 * @max_voltage_uV: Maximum possible voltage in PWM-DVFS mode.
 * @base_voltage_uV: Base voltage when PWM-DVFS enabled.
 */
struct tps51632_regulator_platform_data {
	struct regulator_init_data *reg_init_data;
	bool enable_pwm_dvfs;
	bool dvfs_step_20mV;
	int max_voltage_uV;
	int base_voltage_uV;
};

#endif /* __LINUX_REGULATOR_TPS51632_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#ifndef __LINUX_REG_PFUZE100_H
#define __LINUX_REG_PFUZE100_H

#define PFUZE100_SW1AB		0
#define PFUZE100_SW1C		1
#define PFUZE100_SW2		2
#define PFUZE100_SW3A		3
#define PFUZE100_SW3B		4
#define PFUZE100_SW4		5
#define PFUZE100_SWBST		6
#define PFUZE100_VSNVS		7
#define PFUZE100_VREFDDR	8
#define PFUZE100_VGEN1		9
#define PFUZE100_VGEN2		10
#define PFUZE100_VGEN3		11
#define PFUZE100_VGEN4		12
#define PFUZE100_VGEN5		13
#define PFUZE100_VGEN6		14
#define PFUZE100_MAX_REGULATOR	15

#define PFUZE200_SW1AB		0
#define PFUZE200_SW2		1
#define PFUZE200_SW3A		2
#define PFUZE200_SW3B		3
#define PFUZE200_SWBST		4
#define PFUZE200_VSNVS		5
#define PFUZE200_VREFDDR	6
#define PFUZE200_VGEN1		7
#define PFUZE200_VGEN2		8
#define PFUZE200_VGEN3		9
#define PFUZE200_VGEN4		10
#define PFUZE200_VGEN5		11
#define PFUZE200_VGEN6		12

#define PFUZE3000_SW1A		0
#define PFUZE3000_SW1B		1
#define PFUZE3000_SW2		2
#define PFUZE3000_SW3		3
#define PFUZE3000_SWBST		4
#define PFUZE3000_VSNVS		5
#define PFUZE3000_VREFDDR	6
#define PFUZE3000_VLDO1		7
#define PFUZE3000_VLDO2		8
#define PFUZE3000_VCCSD		9
#define PFUZE3000_V33		10
#define PFUZE3000_VLDO3		11
#define PFUZE3000_VLDO4		12

struct regulator_init_data;

struct pfuze_regulator_platform_data {
	struct regulator_init_data *init_data[PFUZE100_MAX_REGULATOR];
};

#endif /* __LINUX_REG_PFUZE100_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * National Semiconductors LP3972 PMIC chip client interface
 *
 * Based on lp3971.h
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef __LINUX_REGULATOR_LP3972_H
#define __LINUX_REGULATOR_LP3972_H

#include <linux/regulator/machine.h>

#define LP3972_LDO1  0
#define LP3972_LDO2  1
#define LP3972_LDO3  2
#define LP3972_LDO4  3
#define LP3972_LDO5  4

#define LP3972_DCDC1 5
#define LP3972_DCDC2 6
#define LP3972_DCDC3 7

#define LP3972_NUM_REGULATORS 8

struct lp3972_regulator_subdev {
	int id;
	struct regulator_init_data *initdata;
};

struct lp3972_platform_data {
	int num_regulators;
	struct lp3972_regulator_subdev *regulators;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * OpenFirmware regulator support routines
 *
 */

#ifndef __LINUX_OF_REG_H
#define __LINUX_OF_REG_H

struct regulator_desc;

struct of_regulator_match {
	const char *name;
	void *driver_data;
	struct regulator_init_data *init_data;
	struct device_node *of_node;
	const struct regulator_desc *desc;
};

#if defined(CONFIG_OF)
extern struct regulator_init_data
	*of_get_regulator_init_data(struct device *dev,
				    struct device_node *node,
				    const struct regulator_desc *desc);
extern int of_regulator_match(struct device *dev, struct device_node *node,
			      struct of_regulator_match *matches,
			      unsigned int num_matches);
#else
static inline struct regulator_init_data
	*of_get_regulator_init_data(struct device *dev,
				    struct device_node *node,
				    const struct regulator_desc *desc)
{
	return NULL;
}

static inline int of_regulator_match(struct device *dev,
				     struct device_node *node,
				     struct of_regulator_match *matches,
				     unsigned int num_matches)
{
	return 0;
}
#endif /* CONFIG_OF */

#endif /* __LINUX_OF_REG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * gpio-regulator.h
 *
 * Copyright 2011 Heiko Stuebner <heiko@sntech.de>
 *
 * based on fixed.h
 *
 * Copyright 2008 Wolfson Microelectronics PLC.
 *
 * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 *
 * Copyright (c) 2009 Nokia Corporation
 * Roger Quadros <ext-roger.quadros@nokia.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 */

#ifndef __REGULATOR_GPIO_H
#define __REGULATOR_GPIO_H

struct regulator_init_data;

enum regulator_type;

/**
 * struct gpio_regulator_state - state description
 * @value:		microvolts or microamps
 * @gpios:		bitfield of gpio target-states for the value
 *
 * This structure describes a supported setting of the regulator
 * and the necessary gpio-state to achieve it.
 *
 * The n-th bit in the bitfield describes the state of the n-th GPIO
 * from the gpios-array defined in gpio_regulator_config below.
 */
struct gpio_regulator_state {
	int value;
	int gpios;
};

/**
 * struct gpio_regulator_config - config structure
 * @supply_name:	Name of the regulator supply
 * @enable_gpio:	GPIO to use for enable control
 *			set to -EINVAL if not used
 * @enable_high:	Polarity of enable GPIO
 *			1 = Active high, 0 = Active low
 * @enabled_at_boot:	Whether regulator has been enabled at
 *			boot or not. 1 = Yes, 0 = No
 *			This is used to keep the regulator at
 *			the default state
 * @startup_delay:	Start-up time in microseconds
 * @gpios:		Array containing the gpios needed to control
 *			the setting of the regulator
 * @nr_gpios:		Number of gpios
 * @states:		Array of gpio_regulator_state entries describing
 *			the gpio state for specific voltages
 * @nr_states:		Number of states available
 * @regulator_type:	either REGULATOR_CURRENT or REGULATOR_VOLTAGE
 * @init_data:		regulator_init_data
 *
 * This structure contains gpio-voltage regulator configuration
 * information that must be passed by platform code to the
 * gpio-voltage regulator driver.
 */
struct gpio_regulator_config {
	const char *supply_name;

	int enable_gpio;
	unsigned enable_high:1;
	unsigned enabled_at_boot:1;
	unsigned startup_delay;

	struct gpio *gpios;
	int nr_gpios;

	struct gpio_regulator_state *states;
	int nr_states;

	enum regulator_type type;
	struct regulator_init_data *init_data;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Copyright (c) 2014 MediaTek Inc.
 * Author: Flora Fu <flora.fu@mediatek.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#ifndef __LINUX_REGULATOR_MT6397_H
#define __LINUX_REGULATOR_MT6397_H

enum {
	MT6397_ID_VPCA15 = 0,
	MT6397_ID_VPCA7,
	MT6397_ID_VSRAMCA15,
	MT6397_ID_VSRAMCA7,
	MT6397_ID_VCORE,
	MT6397_ID_VGPU,
	MT6397_ID_VDRM,
	MT6397_ID_VIO18 = 7,
	MT6397_ID_VTCXO,
	MT6397_ID_VA28,
	MT6397_ID_VCAMA,
	MT6397_ID_VIO28,
	MT6397_ID_VUSB,
	MT6397_ID_VMC,
	MT6397_ID_VMCH,
	MT6397_ID_VEMC3V3,
	MT6397_ID_VGP1,
	MT6397_ID_VGP2,
	MT6397_ID_VGP3,
	MT6397_ID_VGP4,
	MT6397_ID_VGP5,
	MT6397_ID_VGP6,
	MT6397_ID_VIBR,
	MT6397_ID_RG_MAX,
};

#define MT6397_MAX_REGULATOR	MT6397_ID_RG_MAX
#define MT6397_REGULATOR_ID97	0x97
#define MT6397_REGULATOR_ID91	0x91

#endif /* __LINUX_REGULATOR_MT6397_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #ifndef __REGULATOR_PLATFORM_CONSUMER_H_
#define __REGULATOR_PLATFORM_CONSUMER_H_

struct regulator_consumer_supply;

/**
 * struct regulator_userspace_consumer_data - line consumer
 * initialisation data.
 *
 * @name: Name for the consumer line
 * @num_supplies: Number of supplies feeding the line
 * @supplies: Supplies configuration.
 * @init_on: Set if the regulators supplying the line should be
 *           enabled during initialisation
 */
struct regulator_userspace_consumer_data {
	const char *name;

	int num_supplies;
	struct regulator_bulk_data *supplies;

	bool init_on;
};

#endif /* __REGULATOR_PLATFORM_CONSUMER_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * max8660.h  --  Voltage regulation for the Maxim 8660/8661
 *
 * Copyright (C) 2009 Wolfram Sang, Pengutronix e.K.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef __LINUX_REGULATOR_MAX8660_H
#define __LINUX_REGULATOR_MAX8660_H

#include <linux/regulator/machine.h>

enum {
	MAX8660_V3,
	MAX8660_V4,
	MAX8660_V5,
	MAX8660_V6,
	MAX8660_V7,
	MAX8660_V_END,
};

/**
 * max8660_subdev_data - regulator subdev data
 * @id: regulator id
 * @name: regulator name
 * @platform_data: regulator init data
 */
struct max8660_subdev_data {
	int				id;
	const char			*name;
	struct regulator_init_data	*platform_data;
};

/**
 * max8660_platform_data - platform data for max8660
 * @num_subdevs: number of regulators used
 * @subdevs: pointer to regulators used
 * @en34_is_high: if EN34 is driven high, regulators cannot be en-/disabled.
 */
struct max8660_platform_data {
	int num_subdevs;
	struct max8660_subdev_data *subdevs;
	unsigned en34_is_high:1;
};
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * fan53555.h - Fairchild Regulator FAN53555 Driver
 *
 * Copyright (C) 2012 Marvell Technology Ltd.
 * Yunfan Zhang <yfzhang@marvell.com>
 *
 * This package is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 */

#ifndef __FAN53555_H__
#define __FAN53555_H__

/* VSEL ID */
enum {
	FAN53555_VSEL_ID_0 = 0,
	FAN53555_VSEL_ID_1,
};

/* Transition slew rate limiting from a low to high voltage.
 * -----------------------
 *   Bin |Slew Rate(mV/uS)
 * ------|----------------
 *   000 |    64.00
 * ------|----------------
 *   001 |    32.00
 * ------|----------------
 *   010 |    16.00
 * ------|----------------
 *   011 |     8.00
 * ------|----------------
 *   100 |     4.00
 * ------|----------------
 *   101 |     2.00
 * ------|----------------
 *   110 |     1.00
 * ------|----------------
 *   111 |     0.50
 * -----------------------
 */
enum {
	FAN53555_SLEW_RATE_64MV = 0,
	FAN53555_SLEW_RATE_32MV,
	FAN53555_SLEW_RATE_16MV,
	FAN53555_SLEW_RATE_8MV,
	FAN53555_SLEW_RATE_4MV,
	FAN53555_SLEW_RATE_2MV,
	FAN53555_SLEW_RATE_1MV,
	FAN53555_SLEW_RATE_0_5MV,
};

struct fan53555_platform_data {
	struct regulator_init_data *regulator;
	unsigned int slew_rate;
	/* Sleep VSEL ID */
	unsigned int sleep_vsel_id;
};

#endif /* __FAN53555_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * machine.h -- SoC Regulator support, machine/board driver API.
 *
 * Copyright (C) 2007, 2008 Wolfson Microelectronics PLC.
 *
 * Author: Liam Girdwood <lrg@slimlogic.co.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Regulator Machine/Board Interface.
 */

#ifndef __LINUX_REGULATOR_MACHINE_H_
#define __LINUX_REGULATOR_MACHINE_H_

#include <linux/regulator/consumer.h>
#include <linux/suspend.h>

struct regulator;

/*
 * Regulator operation constraint flags. These flags are used to enable
 * certain regulator operations and can be OR'ed together.
 *
 * VOLTAGE:  Regulator output voltage can be changed by software on this
 *           board/machine.
 * CURRENT:  Regulator output current can be changed by software on this
 *           board/machine.
 * MODE:     Regulator operating mode can be changed by software on this
 *           board/machine.
 * STATUS:   Regulator can be enabled and disabled.
 * DRMS:     Dynamic Regulator Mode Switching is enabled for this regulator.
 * BYPASS:   Regulator can be put into bypass mode
 */

#define REGULATOR_CHANGE_VOLTAGE	0x1
#define REGULATOR_CHANGE_CURRENT	0x2
#define REGULATOR_CHANGE_MODE		0x4
#define REGULATOR_CHANGE_STATUS		0x8
#define REGULATOR_CHANGE_DRMS		0x10
#define REGULATOR_CHANGE_BYPASS		0x20

/**
 * struct regulator_state - regulator state during low power system states
 *
 * This describes a regulators state during a system wide low power
 * state.  One of enabled or disabled must be set for the
 * configuration to be applied.
 *
 * @uV: Operating voltage during suspend.
 * @mode: Operating mode during suspend.
 * @enabled: Enabled during suspend.
 * @disabled: Disabled during suspend.
 */
struct regulator_state {
	int uV;	/* suspend voltage */
	unsigned int mode; /* suspend regulator operating mode */
	int enabled; /* is regulator enabled in this suspend state */
	int disabled; /* is the regulator disbled in this suspend state */
};

/**
 * struct regulation_constraints - regulator operating constraints.
 *
 * This struct describes regulator and board/machine specific constraints.
 *
 * @name: Descriptive name for the constraints, used for display purposes.
 *
 * @min_uV: Smallest voltage consumers may set.
 * @max_uV: Largest voltage consumers may set.
 * @uV_offset: Offset applied to voltages from consumer to compensate for
 *             voltage drops.
 *
 * @min_uA: Smallest current consumers may set.
 * @max_uA: Largest current consumers may set.
 *
 * @valid_modes_mask: Mask of modes which may be configured by consumers.
 * @valid_ops_mask: Operations which may be performed by consumers.
 *
 * @always_on: Set if the regulator should never be disabled.
 * @boot_on: Set if the regulator is enabled when the system is initially
 *           started.  If the regulator is not enabled by the hardware or
 *           bootloader then it will be enabled when the constraints are
 *           applied.
 * @apply_uV: Apply the voltage constraint when initialising.
 * @ramp_disable: Disable ramp delay when initialising or when setting voltage.
 *
 * @input_uV: Input voltage for regulator when supplied by another regulator.
 *
 * @state_disk: State for regulator when system is suspended in disk mode.
 * @state_mem: State for regulator when system is suspended in mem mode.
 * @state_standby: State for regulator when system is suspended in standby
 *                 mode.
 * @initial_state: Suspend state to set by default.
 * @initial_mode: Mode to set at startup.
 * @ramp_delay: Time to settle down after voltage change (unit: uV/us)
 * @enable_time: Turn-on time of the rails (unit: microseconds)
 */
struct regulation_constraints {

	const char *name;

	/* voltage output range (inclusive) - for voltage control */
	int min_uV;
	int max_uV;

	int uV_offset;

	/* current output range (inclusive) - for current control */
	int min_uA;
	int max_uA;

	/* valid regulator operating modes for this machine */
	unsigned int valid_modes_mask;

	/* valid operations for regulator on this machine */
	unsigned int valid_ops_mask;

	/* regulator input voltage - only if supply is another regulator */
	int input_uV;

	/* regulator suspend states for global PMIC STANDBY/HIBERNATE */
	struct regulator_state state_disk;
	struct regulator_state state_mem;
	struct regulator_state state_standby;
	suspend_state_t initial_state; /* suspend state to set at init */

	/* mode to set on startup */
	unsigned int initial_mode;

	unsigned int ramp_delay;
	unsigned int enable_time;

	/* constraint flags */
	unsigned always_on:1;	/* regulator never off when system is on */
	unsigned boot_on:1;	/* bootloader/firmware enabled regulator */
	unsigned apply_uV:1;	/* apply uV constraint if min == max */
	unsigned ramp_disable:1; /* disable ramp delay */
};

/**
 * struct regulator_consumer_supply - supply -> device mapping
 *
 * This maps a supply name to a device. Use of dev_name allows support for
 * buses which make struct device available late such as I2C.
 *
 * @dev_name: Result of dev_name() for the consumer.
 * @supply: Name for the supply.
 */
struct regulator_consumer_supply {
	const char *dev_name;   /* dev_name() for consumer */
	const char *supply;	/* consumer supply - e.g. "vcc" */
};

/* Initialize struct regulator_consumer_supply */
#define REGULATOR_SUPPLY(_name, _dev_name)			\
{								\
	.supply		= _name,				\
	.dev_name	= _dev_name,				\
}

/**
 * struct regulator_init_data - regulator platform initialisation data.
 *
 * Initialisation constraints, our supply and consumers supplies.
 *
 * @supply_regulator: Parent regulator.  Specified using the regulator name
 *                    as it appears in the name field in sysfs, which can
 *                    be explicitly set using the constraints field 'name'.
 *
 * @constraints: Constraints.  These must be specified for the regulator to
 *               be usable.
 * @num_consumer_supplies: Number of consumer device supplies.
 * @consumer_supplies: Consumer device supply configuration.
 *
 * @regulator_init: Callback invoked when the regulator has been registered.
 * @driver_data: Data passed to regulator_init.
 */
struct regulator_init_data {
	const char *supply_regulator;        /* or NULL for system supply */

	struct regulation_constraints constraints;

	int num_consumer_supplies;
	struct regulator_consumer_supply *consumer_supplies;

	/* optional regulator machine specific init */
	int (*regulator_init)(void *driver_data);
	void *driver_data;	/* core does not touch this */
};

#ifdef CONFIG_REGULATOR
void regulator_has_full_constraints(void);
int regulator_suspend_prepare(suspend_state_t state);
int regulator_suspend_finish(void);
#else
static inline void regulator_has_full_constraints(void)
{
}
static inline int regulator_suspend_prepare(suspend_state_t state)
{
	return 0;
}
static inline int regulator_suspend_finish(void)
{
	return 0;
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * tps62360.h -- TI tps62360
 *
 * Interface for regulator driver for TI TPS62360 Processor core supply
 *
 * Copyright (C) 2012 NVIDIA Corporation

 * Author: Laxman Dewangan <ldewangan@nvidia.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA	02110-1301, USA.
 *
 */

#ifndef __LINUX_REGULATOR_TPS62360_H
#define __LINUX_REGULATOR_TPS62360_H

/*
 * struct tps62360_regulator_platform_data - tps62360 regulator platform data.
 *
 * @reg_init_data: The regulator init data.
 * @en_discharge: Enable discharge the output capacitor via internal
 *                register.
 * @en_internal_pulldn: internal pull down enable or not.
 * @vsel0_gpio: Gpio number for vsel0. It should be -1 if this is tied with
 *              fixed logic.
 * @vsel1_gpio: Gpio number for vsel1. It should be -1 if this is tied with
 *              fixed logic.
 * @vsel0_def_state: Default state of vsel0. 1 if it is high else 0.
 * @vsel1_def_state: Default state of vsel1. 1 if it is high else 0.
 */
struct tps62360_regulator_platform_data {
	struct regulator_init_data *reg_init_data;
	bool en_discharge;
	bool en_internal_pulldn;
	int vsel0_gpio;
	int vsel1_gpio;
	int vsel0_def_state;
	int vsel1_def_state;
};

#endif /* __LINUX_REGULATOR_TPS62360_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * da9211.h - Regulator device driver for DA9211/DA9213
 * Copyright (C) 2014  Dialog Semiconductor Ltd.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 */

#ifndef __LINUX_REGULATOR_DA9211_H
#define __LINUX_REGULATOR_DA9211_H

#include <linux/regulator/machine.h>

#define DA9211_MAX_REGULATORS	2

enum da9211_chip_id {
	DA9211,
	DA9213,
};

struct da9211_pdata {
	/*
	 * Number of buck
	 * 1 : 4 phase 1 buck
	 * 2 : 2 phase 2 buck
	 */
	int num_buck;
	int gpio_ren[DA9211_MAX_REGULATORS];
	struct device_node *reg_node[DA9211_MAX_REGULATORS];
	struct regulator_init_data *init_data[DA9211_MAX_REGULATORS];
};
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         